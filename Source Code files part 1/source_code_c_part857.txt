;
        }
    }

    //  copy subregions back to caller
    CopyMemory( rghrgnParts, rghrgn, sizeof(rghrgn) );

    //  extract frame resizing templates
    ZeroMemory( rghrgn, sizeof(rghrgn) ); // reuse region array
    for( i = 0; i < cFRAMEPARTS; i++ )
    {
        const RECT* prc = &pncwm->rcW0[NCRC_FRAMEFIRST + i];

        if( VALID_WINDOWPART(pncwm->rgsizehitparts[i]) && !IsRectEmpty( prc ) )
        {
            if( SUCCEEDED(GetThemeBackgroundRegion( _hTheme, NULL, pncwm->rgsizehitparts[i], pncwm->framestate,
                                                    prc, &rghrgn[i])) )
            {

                SPEW_RGNRECT(NCTF_RGNWND, TEXT("CreateCompositeRgn() sizing template"), rghrgn[i], pncwm->rgframeparts[i] );
            }
        }
    }
    CopyMemory( rghrgnTemplates, rghrgn, sizeof(rghrgn) );

    return hrgnWnd;
}

//-------------------------------------------------------------------------//
void CThemeWnd::AssignFrameRgn( BOOL fAssign, DWORD dwFlags )
{
    if( fAssign )
    {
        NCWNDMET*  pncwm = NULL;
        NCTHEMEMET nctm = {0};
        if( GetNcWindowMetrics( NULL, &pncwm, &nctm, 0 ) )
        {
            //  should we set up a window region on this frame?
            if( pncwm->fFrame )
            {
                if( _ShouldAssignFrameRgn( pncwm, nctm ) )
                {
                    if( (_sizeRgn.cx != RECTWIDTH(&pncwm->rcW0[NCRC_WINDOW]) || 
                         _sizeRgn.cy != RECTHEIGHT(&pncwm->rcW0[NCRC_WINDOW])) )
                    {
                        HRGN hrgnWnd = NULL;
                        HRGN rghrgnParts[cFRAMEPARTS] = {0};
                        HRGN rghrgnTemplates[cFRAMEPARTS] = {0};
                        
                        if( (hrgnWnd = CreateCompositeRgn( pncwm, rghrgnParts, rghrgnTemplates )) != NULL )
                        {
                            _sizeRgn.cx = RECTWIDTH(&pncwm->rcW0[NCRC_WINDOW]);
                            _sizeRgn.cy = RECTHEIGHT(&pncwm->rcW0[NCRC_WINDOW]);

                            //  cache all of our regions for fast hit-testing.
                            _FreeRegionHandles();
                            _hrgnWnd     =  _DupRgn( hrgnWnd ); // dup this one cuz after _AssignRgn, we don't own it.
                            CopyMemory( _rghrgnParts, rghrgnParts, sizeof(_rghrgnParts) );
                            CopyMemory( _rghrgnSizingTemplates, rghrgnTemplates, sizeof(_rghrgnSizingTemplates) );

                            //  assign the region
                            _AssignRgn( hrgnWnd, dwFlags );
                        }
                    }
                }
                // otherwise, if we've assigned a region, make sure we remove it.
                else if( AssignedFrameRgn() ) 
                {
                    fAssign = FALSE;
                }
            }
        }
    }

    if( !fAssign )
    {
        _AssignRgn( NULL, dwFlags );
        FillMemory(&_sizeRgn, sizeof(_sizeRgn), 0xFF);
        _FreeRegionHandles();
    }
    SetDirtyFrameRgn(FALSE); // make sure we reset this in case we didn't hit _AssignRgn.
}

//-------------------------------------------------------------------------//
//  CThemeWnd::_AssignRgn() - assigns the specified region
//  to the window, prevents recursion (SetWindowRgn w/ bRedraw == TRUE
//  generates WM_WINDOWPOSCHANGING, WM_NCCALCSIZE, && WM_NCPAINT).
//
void CThemeWnd::_AssignRgn( HRGN hrgn, DWORD dwFlags )
{
    if( TESTFLAG(dwFlags, FTF_NOMODIFYRGN) )
    {
        _fAssignedFrameRgn = FALSE;
    }
    else if( !IsWindowInDestroy(_hwnd) )
    {
        //  Assign the new region.
        _fAssigningFrameRgn = TRUE;
        SPEW_RGNRECT(NCTF_RGNWND, TEXT("_AssignRgn() rect"), hrgn, -1 );
        _fAssignedFrameRgn = SetWindowRgn( _hwnd, hrgn, TESTFLAG(dwFlags, FTF_REDRAW) ) != 0;
        _fAssigningFrameRgn = FALSE;

    }
    SetDirtyFrameRgn(FALSE);
}

//-------------------------------------------------------------------------//
//  CThemeWnd::GetNcWindowMetrics
//
//  Computes internal per-window theme metrics.
//
BOOL CThemeWnd::GetNcWindowMetrics(
    IN  OPTIONAL LPCRECT prcWnd,
    OUT OPTIONAL NCWNDMET** ppncwm,
    OUT OPTIONAL NCTHEMEMET* pnctm,
    IN  DWORD dwOptions )
{
    LogEntryNC(L"GetNcWindowMetrics");

    NCTHEMEMET  nctm;
    BOOL        bRet         = FALSE;
    BOOL        fMenuBar     = _ncwm.cyMenu != 0;
    WINDOWPARTS rgframeparts[cFRAMEPARTS]; 

    CopyMemory( rgframeparts, _ncwm.rgframeparts, sizeof(rgframeparts) );
    
    //  fetch per-theme metrics; we're going to need theme throughout
    if (TESTFLAG(dwOptions, NCWMF_PREVIEW))
    {
        _LoadNcThemeMetrics(_hwnd, &nctm);
    } 
    else if( !GetCurrentNcThemeMetrics( &nctm ) )
    {
        goto exit;
    }
    
    if( pnctm ) *pnctm = nctm;

    if( !_ncwm.fValid || prcWnd != NULL )
        dwOptions |= NCWMF_RECOMPUTE;

    if( TESTFLAG(dwOptions, NCWMF_RECOMPUTE) )
    {
        //  get caption text size before entering critsec (sends WM_GETTEXTLENGTH, WM_GETTEXT).
        SIZE  sizeCaptionText = {0};
        HFONT hfCaption = NULL;
        HWND  hwndMDIActive = NULL;

        //  Do rough determination of whether or not we're a frame window and need to compute text metrics.  
        //  We'll finalize this later
        BOOL fFrame, fSmallFrame;

        if( _ncwm.fValid )
        {
            fFrame      = TESTFLAG( CThemeWnd::EvaluateStyle(_ncwm.dwStyle, _ncwm.dwExStyle), TWCF_FRAME|TWCF_TOOLFRAME );
            fSmallFrame = TESTFLAG( CThemeWnd::EvaluateStyle(_ncwm.dwStyle, _ncwm.dwExStyle), TWCF_TOOLFRAME );
        }
        else
        {
            fFrame = TestCF(TWCF_FRAME|TWCF_TOOLFRAME);
            fSmallFrame = TestCF(TWCF_TOOLFRAME);
        }

        //  Compute text metrics outside of critical section (sends WM_GETTEXT);
        if( fFrame && _fFrameThemed )
        {
            hfCaption = NcGetCaptionFont( fSmallFrame );
            _GetNcCaptionTextSize( _hTheme, _hwnd, hfCaption, &sizeCaptionText );
        }
        
        //  Retrieve active MDI sibling outside of critical section (sends WM_MDIGETACTIVE);
        if( TESTFLAG(GetWindowLong(_hwnd, GWL_EXSTYLE), WS_EX_MDICHILD) )
        {
            hwndMDIActive = _MDIGetActive( GetParent(_hwnd) );
        }
        
        ASSERT(VALID_CRITICALSECTION(&_cswm));

        if( VALID_CRITICALSECTION(&_cswm) )
        {
            EnterCriticalSection( &_cswm );
        
            ZeroMemory( &_ncwm, sizeof(_ncwm) );

            if( (bRet = _GetWindowMetrics( _hwnd, hwndMDIActive, &_ncwm )) != FALSE )
            {
                _ComputeNcWindowStatus( _hwnd, _ncwm.dwWindowStatus, &_ncwm );

                //  if window RECT is provided by the caller, stuff it now.
                if( prcWnd )
                {
                    _ncwm.rcS0[NCRC_WINDOW] = *prcWnd;
                    SetRectEmpty( &_ncwm.rcS0[NCRC_CLIENT] );
                }

                //  stuff caption text size
                _ncwm.sizeCaptionText = sizeCaptionText;
                _ncwm.hfCaption = hfCaption;

                //  retrieve frame metrics.
                if( _GetNcFrameMetrics( _hwnd, _hTheme, nctm, _ncwm ) )
                {
                    if( _ncwm.fFrame )
                    {
                        //  user32!SetMenu has been called, or the caption or frame part has changed
                        //  So ensure frame region update.
                        if( (_ncwm.cyMenu == 0 && fMenuBar) || (_ncwm.cyMenu > 0  && !fMenuBar) ||
                            memcmp( rgframeparts, _ncwm.rgframeparts, sizeof(rgframeparts) ) )
                        {
                            SetDirtyFrameRgn(TRUE, TRUE);
                        }

                        //  Compute NC button placement
                        AcquireFrameIcon(_ncwm.dwStyle, _ncwm.dwExStyle, FALSE);
                        _GetNcBtnMetrics( &_ncwm, &nctm, _hAppIcon, _MNCanClose(_hwnd) );

                        // Determine the caption margin for lame button metrics.
                        _GetNcCaptionMargins( _hTheme, nctm, _ncwm );
                        _GetNcCaptionTextRect( &_ncwm );

                        if( _ncwm.fFrame )
                        {
                            GetLameButtonMetrics( &_ncwm, &sizeCaptionText );
                        }
                    }

                    //  Compute window-relative metrics
                    //
                    //  If passed a window rect, base offsets on current window rect. 
                    //  This is done to ensure preview window's (_hwnd) fake child windows are rendered correctly.
                    RECT rcWnd = _ncwm.rcS0[NCRC_WINDOW];

                    if( prcWnd )
                    {
                        if( _hwnd )
                            GetWindowRect( _hwnd, &rcWnd );

                         // for an incoming window rect, assign the computed client rect.
                        _ncwm.rcS0[NCRC_CLIENT] = _ncwm.rcS0[NCRC_UXCLIENT];

                    }

                    for( int i = NCRC_FIRST; i < NCRC_COUNT; i++ )
                    {
                        _ncwm.rcW0[i] = _ncwm.rcS0[i];
                        OffsetRect( &_ncwm.rcW0[i], -rcWnd.left, -rcWnd.top ); 
                    }

                    //  All base computations are done; mark valid.
                    _ncwm.fValid = TRUE;
                }
            }
        
            LeaveCriticalSection( &_cswm );
        }
    }

    if( ppncwm )
    {
        *ppncwm = &_ncwm;
    }

    bRet = TRUE;

exit:
    LogExitNC(L"GetNcWindowMetrics");
    return bRet;
}

//-------------------------------------------------------------------------//
inline COLORREF _GetNcCaptionTextColor( FRAMESTATES iStateId )
{
    return GetSysColor( FS_ACTIVE == iStateId ? 
            COLOR_CAPTIONTEXT : COLOR_INACTIVECAPTIONTEXT );
}

//-------------------------------------------------------------------------//
//  Get CTLCOLOR brush for solid fills
void _GetBrushesForPart(HTHEME hTheme, int iPart, HBITMAP* phbm, HBRUSH* phbr)
{
    int nBgType;

    *phbm = NULL;
    *phbr = NULL;

    //  Get CTLCOLOR brush for solid fills
    HRESULT hr = GetThemeEnumValue( hTheme, iPart, 0, TMT_BGTYPE, &nBgType );
    if( SUCCEEDED( hr ))
    {
        if (BT_BORDERFILL == nBgType)
        {
            int nFillType;
            hr = GetThemeEnumValue( hTheme, iPart, 0, TMT_FILLTYPE, &nFillType );
            if (SUCCEEDED( hr ) &&
                FT_SOLID == nFillType)
            {
                COLORREF cr;
                hr = GetThemeColor( hTheme, iPart, 0, TMT_FILLCOLOR, &cr);

                *phbr = CreateSolidBrush(cr);
            }
            else
            {
                ASSERTMSG(FALSE, "Themes: The theme file specified an invalid fill type for dialog boxes");
            }
        }
        else if (BT_IMAGEFILE == nBgType)
        {
            HDC hdc = GetWindowDC(NULL);
            if ( hdc )
            {
                hr = GetThemeBitmap(hTheme, hdc, iPart, 0, NULL, phbm);
                if (SUCCEEDED(hr))
                {
                    *phbr = CreatePatternBrush(*phbm);
                }
                ReleaseDC(NULL, hdc);
            }
        }
    }
}

//-------------------------------------------------------------------------//
//
//  Chooses appropriate hit testing parts for the various Nc area
//
void _GetNcSizingTemplates(
    IN const NCTHEMEMET& nctm,
    IN OUT NCWNDMET& ncwm )         // window metric block.   dwStyle, dwExStyle, rcS0[NCRC_WINDOW] members are required.
{
    FillMemory( ncwm.rgsizehitparts, sizeof(ncwm.rgsizehitparts), BOGUS_WINDOWPART );

    // No need on windows without frames
    if( !ncwm.fFrame )
        return;

    // minimized or full-screen maximized window
    if( ncwm.fMin || ncwm.fFullMaxed )
        return;

    // No need on windows that aren't sizable
    if( !TESTFLAG(ncwm.dwStyle, WS_THICKFRAME) )
        return;

    if( ncwm.fSmallFrame)
    {
        if (nctm.fSmCapSizingTemplate)
            ncwm.rgsizehitparts[iCAPTION]    = WP_SMALLCAPTIONSIZINGTEMPLATE;

        if (nctm.fSmLeftSizingTemplate)
            ncwm.rgsizehitparts[iFRAMELEFT]   = WP_SMALLFRAMELEFTSIZINGTEMPLATE;

        if (nctm.fSmRightSizingTemplate)
            ncwm.rgsizehitparts[iFRAMERIGHT]  = WP_SMALLFRAMERIGHTSIZINGTEMPLATE;

        if (nctm.fSmBottomSizingTemplate)
            ncwm.rgsizehitparts[iFRAMEBOTTOM] = WP_SMALLFRAMEBOTTOMSIZINGTEMPLATE;
    }
    else
    {
        if (nctm.fCapSizingTemplate)
            ncwm.rgsizehitparts[iCAPTION]     = WP_CAPTIONSIZINGTEMPLATE;

        if (nctm.fLeftSizingTemplate)
            ncwm.rgsizehitparts[iFRAMELEFT]   = WP_FRAMELEFTSIZINGTEMPLATE;

        if (nctm.fRightSizingTemplate)
            ncwm.rgsizehitparts[iFRAMERIGHT]  = WP_FRAMERIGHTSIZINGTEMPLATE;

        if (nctm.fBottomSizingTemplate)
            ncwm.rgsizehitparts[iFRAMEBOTTOM] = WP_FRAMEBOTTOMSIZINGTEMPLATE;
    }
}

//-------------------------------------------------------------------------//
//
//  Computes theme metrics for frame window.
//
BOOL _GetNcFrameMetrics( 
    IN OPTIONAL HWND hwnd,          // window handle (required for multiline menubar calcs).
    IN HTHEME hTheme,               // theme handle (required)
    IN const NCTHEMEMET& nctm,      // theme metric block
    IN OUT NCWNDMET& ncwm )         // window metric block.   dwStyle, dwExStyle, rcS0[NCRC_WINDOW] members are required.
{
    LogEntryNC(L"_GetNcFrameMetrics");
    ASSERT(hTheme);
    
    //  recompute style class
    ncwm.dwStyleClass = CThemeWnd::EvaluateStyle( ncwm.dwStyle, ncwm.dwExStyle );
    ncwm.cnBorders    = _GetWindowBorders( ncwm.dwStyle, ncwm.dwExStyle );

    //  compute frame attributes, state
    ncwm.fFrame       = TESTFLAG( ncwm.dwStyleClass, (TWCF_FRAME|TWCF_TOOLFRAME) );
    ncwm.fSmallFrame  = TESTFLAG( ncwm.dwStyleClass, TWCF_TOOLFRAME );

    //  compute frame and caption parts
    if( ncwm.fFrame )
    {
        ncwm.rgframeparts[iFRAMEBOTTOM] = 
        ncwm.rgframeparts[iFRAMELEFT]   = 
        ncwm.rgframeparts[iFRAMERIGHT]  = 
        ncwm.rgframeparts[iCAPTION]     = BOGUS_WINDOWPART;

        if( ncwm.fMin ) // minimized window
        {
            ncwm.rgframeparts[iCAPTION] = WP_MINCAPTION;
        }
        else if( ncwm.fFullMaxed ) // full-screen maximized window
        {
            ncwm.rgframeparts[iCAPTION] = WP_MAXCAPTION;
        }
        else // normal or partial-screen maximized window with thick border
        {
            if( ncwm.fSmallFrame )
            {
                ncwm.rgframeparts[iCAPTION]     = WP_SMALLCAPTION;
                ncwm.rgframeparts[iFRAMELEFT]   = WP_SMALLFRAMELEFT;
                ncwm.rgframeparts[iFRAMERIGHT]  = WP_SMALLFRAMERIGHT;
                ncwm.rgframeparts[iFRAMEBOTTOM] = WP_SMALLFRAMEBOTTOM;
            }
            else 
            {
                ncwm.rgframeparts[iCAPTION]     = ncwm.fMaxed ? WP_MAXCAPTION : WP_CAPTION;
                ncwm.rgframeparts[iFRAMELEFT]   = WP_FRAMELEFT;
                ncwm.rgframeparts[iFRAMERIGHT]  = WP_FRAMERIGHT;
                ncwm.rgframeparts[iFRAMEBOTTOM] = WP_FRAMEBOTTOM;
            }
        }

        //  stash caption text color.
        ncwm.rgbCaption = _GetNcCaptionTextColor( ncwm.framestate );
        
        //  retrieve sizing templates.
        _GetNcSizingTemplates( nctm, ncwm );
    }

    //-----------------------------------------------------------//
    //   Frame metrics
    //
    //   Frame area includes 'skin' boundaries,
    //   menu, integrated caption and client edge.
    //
    //   Independent of the frame is the separate caption seg,
    //   scrollbars, and sizebox
    //-----------------------------------------------------------//
    if( ncwm.fFrame )  //  frame windows only
    {
        //  Initialize positions of main frame components...

        //  Content rect: area bounded by frame theme.
        //  Client rect:  area contained in content rect that excludes all nonclient
        //                elements (viz, scrollbars, menubar, inside edges).
        //  Caption rect: pertains to minimized and maximized windows, 
        //                and normal windows if the theme defines a caption part
        ncwm.rcS0[NCRC_CAPTION] =
        ncwm.rcS0[NCRC_CONTENT] = ncwm.rcS0[NCRC_WINDOW];
        SetRectEmpty( &ncwm.rcS0[NCRC_UXCLIENT] );

        if( ncwm.fMin ) /* minimized frame */
        {
            //  zero out content, client rectangles.
            ncwm.rcS0[NCRC_CONTENT].right = ncwm.rcS0[NCRC_CONTENT].left;
            ncwm.rcS0[NCRC_CONTENT].bottom = ncwm.rcS0[NCRC_CONTENT].top;

            ncwm.rcS0[NCRC_CLIENT]   = 
            ncwm.rcS0[NCRC_UXCLIENT] = ncwm.rcS0[NCRC_CONTENT];
        }
        else
        {
            NONCLIENTMETRICS ncm;
            if( NcGetNonclientMetrics( &ncm, FALSE ) )
            {
                ncwm.rcS0[NCRC_FRAMEBOTTOM] = 
                ncwm.rcS0[NCRC_FRAMELEFT] = 
                ncwm.rcS0[NCRC_FRAMERIGHT] = ncwm.rcS0[NCRC_WINDOW];

                //  themed caption rect spans left, top, right bordersS
                //  and 1 pixel edge below caption
                ncwm.rcS0[NCRC_CAPTION].bottom  = 
                            ncwm.rcS0[NCRC_CAPTION].top + ncwm.cnBorders + 
                            (ncwm.fSmallFrame ? ncm.iSmCaptionHeight : ncm.iCaptionHeight) + 
                            1 /* 1 pixel below caption */;

                // update the content and rects while we're here:
                InflateRect( &ncwm.rcS0[NCRC_CONTENT], -ncwm.cnBorders, -ncwm.cnBorders );
                ncwm.rcS0[NCRC_CONTENT].top = ncwm.rcS0[NCRC_CAPTION].bottom;
                if( ncwm.rcS0[NCRC_CONTENT].bottom < ncwm.rcS0[NCRC_CONTENT].top )
                    ncwm.rcS0[NCRC_CONTENT].bottom = ncwm.rcS0[NCRC_CONTENT].top;

                //  at this point the client rect is identical to the content rect (haven't computed menubar, scrollbars).
                ncwm.rcS0[NCRC_UXCLIENT] = ncwm.rcS0[NCRC_CONTENT]; 

                //  bottom border segment.
                ncwm.rcS0[NCRC_FRAMEBOTTOM].top = ncwm.rcS0[NCRC_FRAMEBOTTOM].bottom - ncwm.cnBorders;

                //  side border segments
                ncwm.rcS0[NCRC_FRAMELEFT].top  = 
                ncwm.rcS0[NCRC_FRAMERIGHT].top = ncwm.rcS0[NCRC_CAPTION].bottom;
                
                ncwm.rcS0[NCRC_FRAMELEFT].bottom  = 
                ncwm.rcS0[NCRC_FRAMERIGHT].bottom = ncwm.rcS0[NCRC_FRAMEBOTTOM].top;

                ncwm.rcS0[NCRC_FRAMELEFT].right = ncwm.rcS0[NCRC_FRAMELEFT].left  + ncwm.cnBorders;
                ncwm.rcS0[NCRC_FRAMERIGHT].left = ncwm.rcS0[NCRC_FRAMERIGHT].right - ncwm.cnBorders;
            }
        }
    }
    else // frameless windows with scrollbars and/or client-edge:
    {
        //  Non-frame windows
        ncwm.rcS0[NCRC_UXCLIENT] = ncwm.rcS0[NCRC_WINDOW];
        InflateRect( &ncwm.rcS0[NCRC_UXCLIENT], -ncwm.cnBorders, -ncwm.cnBorders );
        ncwm.rcS0[NCRC_CONTENT] = ncwm.rcS0[NCRC_UXCLIENT];
    }

    // Menubar
    if( !(ncwm.fMin || TESTFLAG( ncwm.dwStyle, WS_CHILD )) )  // child windows don't have menubars
    {
        //  Menubar offsets (for painting)
        ncwm.cnMenuOffsetTop   = ncwm.rcS0[NCRC_CONTENT].top  - ncwm.rcS0[NCRC_WINDOW].top;
        ncwm.cnMenuOffsetLeft  = ncwm.rcS0[NCRC_CONTENT].left - ncwm.rcS0[NCRC_WINDOW].left;
        ncwm.cnMenuOffsetRight = ncwm.rcS0[NCRC_WINDOW].right - ncwm.rcS0[NCRC_CONTENT].right;

        if( hwnd )
        {
            //  calc menubar does the right thing for multiline menubars
            ncwm.cyMenu = CalcMenuBar( hwnd, ncwm.cnMenuOffsetLeft,
                                       ncwm.cnMenuOffsetRight, 
                                       ncwm.cnMenuOffsetTop,
                                       &ncwm.rcS0[NCRC_WINDOW] );
        }
        else
        {
            //  no window (e.g. preview) == no menu, meaning don't call CalcMenuBar.
            //  we emulate computations best we can:
            ncwm.cyMenu = NcGetSystemMetrics( SM_CYMENUSIZE ); 
        }

        //  CalcMenuBar and SM_CYMENUSIZE are 1 pixel short of reality.
        if( ncwm.cyMenu )
            ncwm.cyMenu += nctm.dyMenuBar;

        //  Menubar rect (for hit-testing and clipping)
        SetRect( &ncwm.rcS0[NCRC_MENUBAR],
                  ncwm.rcS0[NCRC_CONTENT].left,
                  ncwm.rcS0[NCRC_CONTENT].top,
                  ncwm.rcS0[NCRC_CONTENT].right,
                  min(ncwm.rcS0[NCRC_CONTENT].bottom, ncwm.rcS0[NCRC_CONTENT].top + ncwm.cyMenu) );

        ncwm.rcS0[NCRC_UXCLIENT].top = ncwm.rcS0[NCRC_MENUBAR].bottom;
    }

    //  Client Edge.
    if( !ncwm.fMin && TESTFLAG(ncwm.dwExStyle, WS_EX_CLIENTEDGE) )
    {
        CopyRect( &ncwm.rcS0[NCRC_CLIENTEDGE], &ncwm.rcS0[NCRC_UXCLIENT] );
        InflateRect( &ncwm.rcS0[NCRC_UXCLIENT],
                     -NcGetSystemMetrics( SM_CXEDGE ),
                     -NcGetSystemMetrics( SM_CYEDGE ));
    }

    //-----------------------------------------------------------//
    //  Scrollbars and sizebox/gripper
    //-----------------------------------------------------------//

    if( !ncwm.fMin )
    {
        //  horizontal scroll bar.
        if( TESTFLAG(ncwm.dwStyle, WS_HSCROLL) )
        {
            ncwm.rcS0[NCRC_HSCROLL] = ncwm.rcS0[NCRC_UXCLIENT];
            ncwm.rcS0[NCRC_HSCROLL].top = ncwm.rcS0[NCRC_UXCLIENT].bottom =
                ncwm.rcS0[NCRC_HSCROLL].bottom - NcGetSystemMetrics( SM_CYHSCROLL );

            if( IsRectEmpty( &ncwm.rcS0[NCRC_CLIENT] ) /* this happens in preview */ )
            {
                ncwm.rcS0[NCRC_HSCROLL].left  = ncwm.rcS0[NCRC_UXCLIENT].left;
                ncwm.rcS0[NCRC_HSCROLL].right = ncwm.rcS0[NCRC_UXCLIENT].right;
            }
            else
            {
                ncwm.rcS0[NCRC_HSCROLL].left  = ncwm.rcS0[NCRC_CLIENT].left;
                ncwm.rcS0[NCRC_HSCROLL].right = ncwm.rcS0[NCRC_CLIENT].right;
            }
        }

        //  vertical scroll bar
        if( TESTFLAG(ncwm.dwStyle, WS_VSCROLL) )
        {
            ncwm.rcS0[NCRC_VSCROLL] = ncwm.rcS0[NCRC_UXCLIENT];

            if( TESTFLAG(ncwm.dwExStyle, WS_EX_LAYOUTRTL) ^ TESTFLAG(ncwm.dwExStyle, WS_EX_LEFTSCROLLBAR) )
            {
                ncwm.rcS0[NCRC_VSCROLL].right = ncwm.rcS0[NCRC_UXCLIENT].left =
                    ncwm.rcS0[NCRC_VSCROLL].left + NcGetSystemMetrics( SM_CXVSCROLL );

                //  Adjust for horz scroll, gripper
                if( TESTFLAG(ncwm.dwStyle, WS_HSCROLL) )
                {
                    ncwm.rcS0[NCRC_SIZEBOX]= ncwm.rcS0[NCRC_HSCROLL];
                    ncwm.rcS0[NCRC_SIZEBOX].right = ncwm.rcS0[NCRC_HSCROLL].left =
                        ncwm.rcS0[NCRC_UXCLIENT].left;
                }
            }
            else
            {
                ncwm.rcS0[NCRC_VSCROLL].left = ncwm.rcS0[NCRC_UXCLIENT].right =
                    ncwm.rcS0[NCRC_VSCROLL].right - NcGetSystemMetrics( SM_CXVSCROLL );

                //  Adjust for horz scroll, gripper
                if( TESTFLAG(ncwm.dwStyle, WS_HSCROLL) )
                {
                    ncwm.rcS0[NCRC_SIZEBOX]= ncwm.rcS0[NCRC_HSCROLL];
                    ncwm.rcS0[NCRC_SIZEBOX].left = ncwm.rcS0[NCRC_HSCROLL].right =
                        ncwm.rcS0[NCRC_UXCLIENT].right;
                }
            }

            if( IsRectEmpty( &ncwm.rcS0[NCRC_CLIENT] ) /* this happens in preview */ )
            {
                ncwm.rcS0[NCRC_VSCROLL].top    = ncwm.rcS0[NCRC_UXCLIENT].top;
                ncwm.rcS0[NCRC_VSCROLL].bottom = ncwm.rcS0[NCRC_UXCLIENT].bottom;
            }
            else
            {
                ncwm.rcS0[NCRC_VSCROLL].top    = ncwm.rcS0[NCRC_CLIENT].top;
                ncwm.rcS0[NCRC_VSCROLL].bottom = ncwm.rcS0[NCRC_CLIENT].bottom;
            }
        }
    }

    LogExitNC(L"_GetNcFrameMetrics");
    return TRUE;
}

#define EXT_TRACK_VERT  0x01
#define EXT_TRACK_HORZ  0x02

//-------------------------------------------------------------------------//
void _GetNcBtnHitTestRect( 
    IN const NCWNDMET* pncwm, 
    IN UINT uHitcode, 
    BOOL fWindowRelative, 
    OUT LPRECT prcHit )
{
    const RECT* prcBtn = NULL;
    int   dxLeft = 0; // button's left side delta
    int   dxRight = 0; // button's right side delta
    
    //  adjust hitrect to classic-look caption bar strip:
    RECT  rcHit = fWindowRelative ? pncwm->rcW0[NCRC_CAPTION] : pncwm->rcS0[NCRC_CAPTION];
    rcHit.top   += pncwm->cnBorders;
    rcHit.left  += pncwm->cnBorders;
    rcHit.right -= pncwm->cnBorders;
    rcHit.bottom -= 1;

    //  determine which button we're working with, how to extend the left, right sides.
    switch( uHitcode )
    {
        case HTMINBUTTON:
            prcBtn  = fWindowRelative ? &pncwm->rcW0[NCRC_MINBTN] : &pncwm->rcS0[NCRC_MINBTN];
            dxLeft  = -1;
            break;

        case HTMAXBUTTON:
            prcBtn  = fWindowRelative ? &pncwm->rcW0[NCRC_MAXBTN] : &pncwm->rcS0[NCRC_MAXBTN];
            dxRight = 1;
            break;

        case HTHELP:
            prcBtn  = fWindowRelative ? &pncwm->rcW0[NCRC_HELPBTN] : &pncwm->rcS0[NCRC_HELPBTN];
            dxLeft  = -1;
            dxRight = 1;
            break;

        case HTCLOSE:
            prcBtn  = fWindowRelative ? &pncwm->rcW0[NCRC_CLOSEBTN] : &pncwm->rcS0[NCRC_CLOSEBTN];
            dxLeft  = -1;
            dxRight = rcHit.right - prcBtn->right;
            break;

        case HTSYSMENU:
            prcBtn  = fWindowRelative ? &pncwm->rcW0[NCRC_SYSBTN] : &pncwm->rcS0[NCRC_SYSBTN];
            dxLeft  = rcHit.left - prcBtn->left;
            dxRight = 1;
            break;
    }

    if( prcBtn )
    {
        *prcHit = *prcBtn;
        if( !IsRectEmpty( prcBtn ) )
        {
            rcHit.left  = prcBtn->left  + dxLeft;
            rcHit.right = prcBtn->right + dxRight;
            *prcHit = rcHit;
        }
    }
    else
    {
        SetRectEmpty( prcHit );
    }
}

//-------------------------------------------------------------------------//
//  wraps alloc, retrieval of window text 
LPWSTR _AllocWindowText( IN HWND hwnd )
{
    LPWSTR pszRet = NULL;

    if (hwnd && IsWindow(hwnd))
    {
        if( (pszRet = new WCHAR[MAX_PATH]) != NULL )
        {
            int cch;
            if( (cch = InternalGetWindowText(hwnd, pszRet, MAX_PATH)) <= 0 )
            {
                __try // some wndprocs can't handle an early WM_GETTEXT (eg.310700).
                {
                    cch = GetWindowText(hwnd, pszRet, MAX_PATH);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    cch = 0;
                }
            }
            
            if( !cch )
            {
                SAFE_DELETE_ARRAY(pszRet); // delete and zero pointer
            }
        }
    }

    return pszRet;
}

//-------------------------------------------------------------------------//
//  _GetNcCaptionMargins() - computes a margin from the window ULC based on the
//          offsets in the theme and the location of enabled caption buttons.  The left
//          margin is to the right of the last left-aligned button, and the right margin
//          is to the left of the first right-aligned button.
//
BOOL _GetNcCaptionMargins( IN HTHEME hTheme, IN const NCTHEMEMET& nctm, IN OUT NCWNDMET& ncwm )
{
    ZeroMemory( &ncwm.CaptionMargins, sizeof(ncwm.CaptionMargins) );
    
    if( ncwm.fFrame )
    {
        //  assign per-window CaptinMargins, hfCaption values
        if( ncwm.fSmallFrame )
        {
            ncwm.CaptionMargins = nctm.marSmCaptionText;
        }
        else
        {
            if( ncwm.fMaxed ) 
            {
                ncwm.CaptionMargins = nctm.marMaxCaptionText;
            }
            else if( ncwm.fMin )
            {
                ncwm.CaptionMargins = nctm.marMinCaptionText;
            }
            else
            {
                ncwm.CaptionMargins = nctm.marCaptionText;
            }
        }
        ncwm.hfCaption = NcGetCaptionFont(ncwm.fSmallFrame);


        RECT  rcContainer = ncwm.rcS0[NCRC_CAPTION];
        RECT  *prcBtn = &ncwm.rcS0[NCBTNFIRST];
        rcContainer.left   += ncwm.cnBorders;
        rcContainer.right -= ncwm.cnBorders;

        //  sysmenu icon, if present, is the leftmost limit
        if( !IsRectEmpty( &ncwm.rcS0[NCRC_SYSBTN] ) )
        {
            rcContainer.left = ncwm.rcS0[NCRC_SYSBTN].right;
        }

        // Compute our rightmost limit
        for( UINT cRects = NCBTNRECTS; cRects; --cRects, ++prcBtn )
        {
            if (!IsRectEmpty(prcBtn))
            {
                if( prcBtn->left < rcContainer.right )
                {
                    rcContainer.right = prcBtn->left;
                }
            }
        }

        if( rcContainer.right < rcContainer.left )
        {
            rcContainer.right = rcContainer.left;
        }

        // final captions margins are adjusted to accommodate buttons.
        ncwm.CaptionMargins.cxLeftWidth  += (rcContainer.left - ncwm.rcS0[NCRC_CAPTION].left);
        ncwm.CaptionMargins.cxRightWidth += (ncwm.rcS0[NCRC_CAPTION].right - rcContainer.right);

        return TRUE;
    }
    
    return FALSE;
}

//-------------------------------------------------------------------------//
BOOL _GetNcCaptionTextSize( HTHEME hTheme, HWND hwnd, HFONT hf, OUT SIZE* psizeCaption )
{
    BOOL   fRet = FALSE;
    LPWSTR pszCaption = _AllocWindowText( hwnd );

    psizeCaption->cx = psizeCaption->cy = 0;

    if( pszCaption )
    {
        HDC hdc = GetWindowDC(hwnd);
        if( hdc )
        {
            //---- select font ----
            HFONT hf0 = (HFONT)SelectObject(hdc, hf);

            //---- let theme mgr do the calculation ----
            RECT rcExtent;
            HRESULT hr = GetThemeTextExtent( hTheme, hdc, WP_CAPTION, 0,
                pszCaption, lstrlen(pszCaption), 0, NULL, &rcExtent );

            //---- store result in "psizeCaption ----
            if (SUCCEEDED(hr))
            {
                psizeCaption->cx = WIDTH(rcExtent);
                psizeCaption->cy = HEIGHT(rcExtent);
            }

            //---- clean up ----
            SelectObject(hdc, hf0);
            ReleaseDC(hwnd, hdc);
        }

        SAFE_DELETE_ARRAY(pszCaption);
    }
    return fRet;
}

//-------------------------------------------------------------------------//
//  Retrieves position of available area for caption text, in window-relative
//  coordinates
BOOL _GetNcCaptionTextRect( IN OUT NCWNDMET* pncwm )
{
    pncwm->rcS0[NCRC_CAPTIONTEXT] = pncwm->rcS0[NCRC_CAPTION];

    //  accommodate classic top sizing border:
    pncwm->rcS0[NCRC_CAPTIONTEXT].top  += pncwm->cnBorders;

    //  Assign left, right based on resp. caption margins
    pncwm->rcS0[NCRC_CAPTIONTEXT].left  += pncwm->CaptionMargins.cxLeftWidth;
    pncwm->rcS0[NCRC_CAPTIONTEXT].right -= pncwm->CaptionMargins.cxRightWidth;

    //  vertically center the text between margins
    int cyPadding = (RECTHEIGHT(&pncwm->rcS0[NCRC_CAPTIONTEXT]) - pncwm->sizeCaptionText.cy)/2;
    pncwm->rcS0[NCRC_CAPTIONTEXT].top     += cyPadding;
    pncwm->rcS0[NCRC_CAPTIONTEXT].bottom  -= cyPadding;

    return TRUE;
}

//-------------------------------------------------------------------------//
//  retrieve the window icon
HICON CThemeWnd::AcquireFrameIcon( 
    DWORD dwStyle, DWORD dwExStyle, BOOL fWinIniChange )
{
    if( _hAppIcon != NULL )
    {
        if( fWinIniChange )
        {
            _hAppIcon = NULL;
        }
    }

    if( !TESTFLAG(dwStyle, WS_SYSMENU) || TESTFLAG(dwExStyle, WS_EX_TOOLWINDOW) )
    {
        //  return nil value without throwing away cached icon handle;
        //  this may be a transient style change.
        return NULL;
    }

    NONCLIENTMETRICS ncm = {0};
    NcGetNonclientMetrics( &ncm, FALSE );
    BOOL fPerferLargeIcon = ((30 < ncm.iCaptionHeight) ? TRUE : FALSE);
    if( NULL == _hAppIcon && NULL == (_hAppIcon = _GetWindowIcon(_hwnd, fPerferLargeIcon)) )
    {
        if ( HAS_CAPTIONBAR(dwStyle) &&
             ((dwStyle & (WS_BORDER|WS_DLGFRAME)) != WS_DLGFRAME) &&
             !TESTFLAG(dwExStyle, WS_EX_DLGMODALFRAME) )
        {
            // If we still can't get an icon and the window has
            // SYSMENU set, then they get the default winlogo icon
            _hAppIcon = LoadIcon(NULL, IDI_WINLOGO);
        }
    }

    return _hAppIcon;
}

//-------------------------------------------------------------------------//
//  CThemeWnd::ScreenToWindow() - transforms points from screen coords to
//  window coords.
//
void CThemeWnd::ScreenToWindow( LPPOINT prgPts, UINT cPts )
{
    RECT rcWnd;
    if( GetWindowRect( _hwnd, &rcWnd ) )
    {
        for( UINT i = 0; i < cPts; i++ )
        {
            prgPts[i].x -= rcWnd.left;
            prgPts[i].y -= rcWnd.top;
        }
    }
}

//-------------------------------------------------------------------------//
//  CThemeWnd::ScreenToWindow() - transforms non-empty rectangles from
//  screen coords to window coords.
//
void CThemeWnd::ScreenToWindowRect( LPRECT prc )
{
    if( !IsRectEmpty(prc) )
        ScreenToWindow( (LPPOINT)prc, 2 );
}

//-------------------------------------------------------------------------//
//  CThemeWnd::InitWindowMetrics()
//
//  initializes theme resources
void CThemeWnd::InitWindowMetrics()
{
    ZeroMemory( &_ncwm, sizeof(_ncwm) );
}

//-------------------------------------------------------------------------//
BOOL _fClassicNcBtnMetricsReset = TRUE;

//-------------------------------------------------------------------------//
//  computes classic button position
BOOL _GetNcBtnMetrics( 
    IN OUT   NCWNDMET* pncwm,
    IN const NCTHEMEMET* pnctm,
    IN HICON hAppIcon, 
    IN OPTIONAL BOOL fCanClose )
{
    BOOL fRet = TRUE;
    
    if( pncwm && pncwm->fFrame && TESTFLAG(pncwm->dwStyle, WS_SYSMENU) )
    {
        NONCLIENTMETRICS ncm;
        fRet = NcGetNonclientMetrics( &ncm, FALSE );
        if( fRet )
        {
            //  (1) compute baseline rectangles
            int cxEdge  = NcGetSystemMetrics( SM_CXEDGE );
            int cyEdge  = NcGetSystemMetrics( SM_CYEDGE );

            int cyBtn   = NcGetSystemMetrics( SM_CYSIZE );
            int cxBtn   = MulDiv( cyBtn, pnctm->sizeBtn.cx, pnctm->sizeBtn.cy );

            int cySmBtn = NcGetSystemMetrics( SM_CYSMSIZE );
            int cxSmBtn = MulDiv( cySmBtn, pnctm->sizeSmBtn.cx, pnctm->sizeSmBtn.cy );

            // remove padding from x,y
            cyBtn   -= (cyEdge * 2);
            cxBtn   -= (cyEdge * 2);
            cySmBtn -= (cyEdge * 2);
            cxSmBtn -= (cyEdge * 2);

            RECT rcClose, rcMin, rcMax, rcHelp, rcSys, rcSmClose;

            //  common top, w/ zero v-offset
            rcClose.top = rcMin.top = rcMax.top = rcHelp.top = rcSys.top = rcSmClose.top = 0;

            //  common bottom, w/ zero v-offset
            rcClose.bottom = rcMin.bottom = rcMax.bottom = rcHelp.bottom = 
                max( rcClose.top, rcClose.top + cyBtn );

            rcSmClose.bottom = 
                max( rcSmClose.top, cySmBtn );

            //  sysmenu icon bottom
            rcSys.bottom    = rcSys.top + NcGetSystemMetrics(SM_CYSMICON);

            //  close, min, max left, right (as offsets from container's right boundary)
            rcClose.right   = -cxEdge; 
            rcClose.left    = rcClose.right - cxBtn;

            rcMax.right     = rcClose.left - cxEdge; 
            rcMax.left      = rcMax.right  - cxBtn;
            rcHelp          = rcMax;

            rcMin.right     = rcMax.left   - cxEdge; 
            rcMin.left      = rcMin.right  - cxBtn;

            //  appicon left, right (as offsets from container's left boundary)
            rcSys.left      = cxEdge; 
            rcSys.right     = rcSys.left + NcGetSystemMetrics(SM_CXSMICON);
    
            //  toolwindow close, left, right
            rcSmClose.right = -cxEdge; 
            rcSmClose.left  = rcSmClose.right - cxSmBtn;

            const RECT* prcBox = &pncwm->rcS0[NCRC_CAPTION];
            int   cnLOffset    = prcBox->left  + pncwm->cnBorders;
            int   cnROffset    = prcBox->right - pncwm->cnBorders;
            int   cnCtrOffset  = pncwm->cnBorders + prcBox->top + 
                                (pncwm->fSmallFrame ? (ncm.iCaptionHeight   - RECTHEIGHT(&rcClose))/2 : 
                                                      (ncm.iSmCaptionHeight - RECTHEIGHT(&rcSmClose))/2);

            //  (2) assign outbound rectangles.
            //      vertically center w/ respect to classic caption area, 
            //      horizontally position w/ respect to respective container boundary.

            //  close button
            pncwm->rcS0[NCRC_CLOSEBTN] = pncwm->fSmallFrame ? rcSmClose : rcClose;
            OffsetRect( &pncwm->rcS0[NCRC_CLOSEBTN], cnROffset, cnCtrOffset );
            
            pncwm->rawCloseBtnState = fCanClose ? CBS_NORMAL : CBS_DISABLED;

            //  (1) min/max/help/appicons not displayed for toolwindows
            //  (2) min/max btns mutually exclusive w/ context help btn
            if( !TESTFLAG(pncwm->dwExStyle, WS_EX_TOOLWINDOW) )
            {
                //  min, max
                if( TESTFLAG(pncwm->dwStyle, WS_MINIMIZEBOX|WS_MAXIMIZEBOX) )
                {
                    pncwm->rcS0[NCRC_MINBTN] = rcMin;
                    OffsetRect( &pncwm->rcS0[NCRC_MINBTN], cnROffset, cnCtrOffset );

                    pncwm->rcS0[NCRC_MAXBTN] = rcMax;
                    OffsetRect( &pncwm->rcS0[NCRC_MAXBTN], cnROffset, cnCtrOffset );
                    
                    pncwm->iMaxButtonPart = pncwm->fMaxed ? WP_RESTOREBUTTON : WP_MAXBUTTON;
                    pncwm->iMinButtonPart = pncwm->fMin   ? WP_RESTOREBUTTON : WP_MINBUTTON;

                    pncwm->rawMaxBtnState = TESTFLAG(pncwm->dwStyle, WS_MAXIMIZEBOX) ? CBS_NORMAL : CBS_DISABLED;
                    pncwm->rawMinBtnState = TESTFLAG(pncwm->dwStyle, WS_MINIMIZEBOX) ? CBS_NORMAL : CBS_DISABLED;
                }
                //  help btn
                else if( TESTFLAG(pncwm->dwExStyle, WS_EX_CONTEXTHELP) )
                {
                    pncwm->rcS0[NCRC_HELPBTN] = rcHelp;
                    OffsetRect( &pncwm->rcS0[NCRC_HELPBTN], cnROffset, cnCtrOffset );
                }

                if( hAppIcon )
                {
                    //  sysmenu icon
                    pncwm->rcS0[NCRC_SYSBTN] = rcSys;
                    OffsetRect( &pncwm->rcS0[NCRC_SYSBTN], cnLOffset,  
                                pncwm->cnBorders + prcBox->top + (ncm.iCaptionHeight - RECTHEIGHT(&rcSys))/2 );
                }
            }
        }
    }
    return fRet;
}

//-------------------------------------------------------------------------//
//  computes classic nonclient button position

#if 0  // (keeping around for documentation purposes - scotthan)
BOOL _GetClassicNcBtnMetrics( 
    IN OPTIONAL NCWNDMET* pncwm, 
    IN HICON hAppIcon, 
    IN OPTIONAL BOOL fCanClose, 
    BOOL fRefresh )
{
    static int  cxEdge, cyEdge;
    static int  cxBtn, cyBtn, cxSmBtn, cySmBtn;
    static RECT rcClose, rcMin, rcMax, rcHelp, rcSys;
    static RECT rcSmClose;
    static BOOL fInit = FALSE;

    if( _fClassicNcBtnMetricsReset || fRefresh )
    {
        cxBtn   = NcGetSystemMetrics( SM_CXSIZE );
        cyBtn   = NcGetSystemMetrics( SM_CYSIZE );
        cxSmBtn = NcGetSystemMetrics( SM_CXSMSIZE );
        cySmBtn = NcGetSystemMetrics( SM_CYSMSIZE );
        cxEdge  = NcGetSystemMetrics( SM_CXEDGE );
        cyEdge  = NcGetSystemMetrics( SM_CYEDGE ); 

        //  common top, w/ zero v-offset
        rcClose.top = rcMin.top = rcMax.top = rcHelp.top = rcSys.top = rcSmClose.top = 0;

        //  common bottom, w/ zero v-offset
        rcClose.bottom  = rcMin.bottom = rcMax.bottom = rcHelp.bottom = rcClose.top + (cyBtn - (cyEdge * 2));
        rcSmClose.bottom= (cySmBtn - (cyEdge * 2));

        //  sysmenu icon bottom
        rcSys.bottom    = rcSys.top + NcGetSystemMetrics(SM_CYSMICON);

        //  close, min, max left, right (as offsets from container's right boundary)
        rcClose.right   = -cxEdge; 
        rcClose.left    = rcClose.right - (cxBtn - cxEdge);

        rcMax.right     = rcClose.left  - cxEdge; 
        rcMax.left      = rcMax.right - (cxBtn - cxEdge);
        rcHelp          = rcMax;

        rcMin.right     = rcMax.left; 
        rcMin.left      = rcMin.right - (cxBtn - cxEdge);

        //  appicon left, right (as offsets from container's left boundary)
        rcSys.left      = cxEdge; 
        rcSys.right     = rcSys.left + NcGetSystemMetrics(SM_CXSMICON);
        
        //  toolwindow close, left, right
        rcSmClose.right = -cxEdge; 
        rcSmClose.left  = rcSmClose.right - (cxSmBtn - cxEdge);
        
        _fClassicNcBtnMetricsReset = FALSE;
    }

    if( !_fClassicNcBtnMetricsReset && 
        pncwm && pncwm->fFrame && TESTFLAG(pncwm->dwStyle, WS_SYSMENU) )
    {
        NONCLIENTMETRICS ncm;

        if( NcGetNonclientMetrics( &ncm, FALSE ) )
        {
            const RECT* prcBox = &pncwm->rcS0[NCRC_CAPTION];
            int   cnLOffset    = prcBox->left  + pncwm->cnBorders;
            int   cnROffset    = prcBox->right - pncwm->cnBorders;
            int   cnCtrOffset  = pncwm->cnBorders + prcBox->top + 
                                (pncwm->fSmallFrame ? (ncm.iCaptionHeight   - RECTHEIGHT(&rcClose))/2 : 
                                                      (ncm.iSmCaptionHeight - RECTHEIGHT(&rcSmClose))/2);

            //  assign outbound rectangles.
            //  vertically center w/ respect to classic caption area, 
            //  horizontally position w/ respect to respective container boundary.

            //  close button
            pncwm->rcS0[NCRC_CLOSEBTN] = pncwm->fSmallFrame ? rcSmClose : rcClose;
            OffsetRect( &pncwm->rcS0[NCRC_CLOSEBTN], cnROffset, cnCtrOffset );
            
            pncwm->rawCloseBtnState = fCanClose ? CBS_NORMAL : CBS_DISABLED;

            //  (1) min/max/help/appicons not displayed for toolwindows
            //  (2) min/max btns mutually exclusive w/ context help btn
            if( !TESTFLAG(pncwm->dwExStyle, WS_EX_TOOLWINDOW) )
            {
                //  min, max
                if( TESTFLAG(pncwm->dwStyle, WS_MINIMIZEBOX|WS_MAXIMIZEBOX) )
                {
                    pncwm->rcS0[NCRC_MINBTN] = rcMin;
                    OffsetRect( &pncwm->rcS0[NCRC_MINBTN], cnROffset, cnCtrOffset );

                    pncwm->rcS0[NCRC_MAXBTN] = rcMax;
                    OffsetRect( &pncwm->rcS0[NCRC_MAXBTN], cnROffset, cnCtrOffset );
                    
                    pncwm->iMaxButtonPart = pncwm->fMaxed ? WP_RESTOREBUTTON : WP_MAXBUTTON;
                    pncwm->iMinButtonPart = pncwm->fMin   ? WP_RESTOREBUTTON : WP_MINBUTTON;

                    pncwm->rawMaxBtnState = TESTFLAG(pncwm->dwStyle, WS_MAXIMIZEBOX) ? CBS_NORMAL : CBS_DISABLED;
                    pncwm->rawMinBtnState = TESTFLAG(pncwm->dwStyle, WS_MINIMIZEBOX) ? CBS_NORMAL : CBS_DISABLED;
                }
                //  help btn
                else if( TESTFLAG(pncwm->dwExStyle, WS_EX_CONTEXTHELP) )
                {
                    pncwm->rcS0[NCRC_HELPBTN] = rcHelp;
                    OffsetRect( &pncwm->rcS0[NCRC_HELPBTN], cnROffset, cnCtrOffset );
                }

                if( hAppIcon )
                {
                    //  sysmenu icon
                    pncwm->rcS0[NCRC_SYSBTN] = rcSys;
                    OffsetRect( &pncwm->rcS0[NCRC_SYSBTN], cnLOffset,  
                                pncwm->cnBorders + prcBox->top + (ncm.iCaptionHeight - RECTHEIGHT(&rcSys))/2 );
                }
            }
            return TRUE;
        }
        return FALSE;
    }
    return fInit;
}
#endif 0  // (keeping around for documentation purposes - scotthan)

//-------------------------------------------------------------------------//
//  CThemeWnd::NcBackgroundHitTest() - hit test the Caption or Frame part
//
WORD CThemeWnd::NcBackgroundHitTest( 
    POINT ptHit, LPCRECT prcWnd, 
    DWORD dwStyle, DWORD dwExStyle, 
    FRAMESTATES fs,
    const WINDOWPARTS rgiParts[],
    const WINDOWPARTS rgiTemplates[],
    const RECT rgrcParts[] )
{
    WORD        hitcode = HTNOWHERE;
    HRESULT     hr = E_FAIL;
    eFRAMEPARTS iPartHit = (eFRAMEPARTS)-1;

    //  do a standard rect hit test:
    for( int i = 0; i < cFRAMEPARTS; i++ )
    {
        if( _StrictPtInRect(&rgrcParts[i], ptHit) )
        {
            iPartHit = (eFRAMEPARTS)i;
            break;
        }
    }
    
    if( iPartHit >= 0 )
    {
        BOOL    fResizing = TESTFLAG(dwStyle, WS_THICKFRAME);
        DWORD   dwHTFlags = fResizing ? HTTB_RESIZINGBORDER : HTTB_FIXEDBORDER;

        RECT    rcHit = rgrcParts[iPartHit];

        switch( iPartHit )
        {
            case iCAPTION:
                //  Ensure caption rect and test point are zero-relative to
                //  the correct origin (if we have a window region, 
                //  this would be window origin, otherwise, it's the part origin.)
                if( _hrgnWnd != NULL )
                    rcHit = *prcWnd;
                if( fResizing )
                    dwHTFlags &= ~HTTB_RESIZINGBORDER_BOTTOM;
                break;

            case iFRAMEBOTTOM:
                if( fResizing )
                    dwHTFlags &= ~HTTB_RESIZINGBORDER_TOP;
                break;

            case iFRAMELEFT:
                if( fResizing )
                    dwHTFlags = HTTB_RESIZINGBORDER_LEFT;
                break;

            case iFRAMERIGHT:
                if( fResizing )
                    dwHTFlags = HTTB_RESIZINGBORDER_RIGHT;
                break;
        }

        ptHit.x -= prcWnd->left;
        ptHit.y -= prcWnd->top;
        OffsetRect( &rcHit, -prcWnd->left, -prcWnd->top );

    
        // Here our assumption is that the hit testing for the template
        // is "as good" or "better" than the rectangles checking applied
        // to the caption part.  So we do one or the other.  There are
        // situations where you would need to do both (if the template
        // were outside the window region and you were able to get USER to
        // send you NcHitTest messages for it).  For those situations
        // you would need to call both so that you can distinguish between
        // a mouse hit over the caption "client" area vs. over the
        // outside-transparent area.
        if( VALID_WINDOWPART(rgiTemplates[iPartHit]) )
        {
            hr = HitTestThemeBackground( _hTheme, NULL, rgiTemplates[iPartHit], fs,
                                         dwHTFlags | (fResizing ? HTTB_SIZINGTEMPLATE : 0),
                                         &rcHit, _rghrgnSizingTemplates[iPartHit], ptHit, &hitcode );
        }
        else
        {
            hr = HitTestThemeBackground( _hTheme, NULL, rgiParts[iPartHit], fs, 
                                         dwHTFlags | (fResizing ? HTTB_SYSTEMSIZINGMARGINS : 0),
                                         &rcHit, _hrgnWnd, ptHit, &hitcode );
        }

        if( SUCCEEDED(hr) )
        {
            if( iCAPTION == iPartHit && (HTCLIENT == hitcode || HTBORDER == hitcode) )
                hitcode = HTCAPTION;
        }
    }

    if ( FAILED(hr) )
    {
        hitcode = HTNOWHERE;
    }

    return hitcode;
}

//-------------------------------------------------------------------------//
//  CThemeWnd::TrackFrameButton() - track the mouse over the caption buttons,
//  pressing/releasing as appropriate.  Return back SC_* command to report or 0
//  if the mouse was released off of the button.
//
BOOL CThemeWnd::TrackFrameButton(
    HWND hwnd, 
    INT  iHitCode, 
    OUT OPTIONAL WPARAM* puSysCmd,
    BOOL fHottrack )
{
    int    iStateId, iNewStateId;
    int    iPartId = -1;
    UINT   cmd = 0;
    MSG    msg = {0};
    LPRECT prcBtnPaint = NULL;
    RECT   rcBtnTrack;
    HDC    hdc;

    if (puSysCmd)
    {
        *puSysCmd = 0;
    }

    // map iHitCode to the correct part number
    switch (iHitCode)
    {
        case HTHELP:
            cmd = SC_CONTEXTHELP;
            iPartId = WP_HELPBUTTON;
            prcBtnPaint = &_ncwm.rcW0[NCRC_HELPBTN];
            break;

        case HTCLOSE:
            cmd = SC_CLOSE;
            iPartId = _ncwm.fSmallFrame ? WP_SMALLCLOSEBUTTON : WP_CLOSEBUTTON;
            prcBtnPaint = &_ncwm.rcW0[NCRC_CLOSEBTN];
            break;

        case HTMINBUTTON:
            cmd = _ncwm.fMin ? SC_RESTORE : SC_MINIMIZE;
            iPartId = _ncwm.iMinButtonPart;
            prcBtnPaint = &_ncwm.rcW0[NCRC_MINBTN];
            break;

        case HTMAXBUTTON:
            cmd = _ncwm.fMaxed ? SC_RESTORE : SC_MAXIMIZE;
            iPartId = _ncwm.iMaxButtonPart;
            prcBtnPaint = &_ncwm.rcW0[NCRC_MAXBTN];
            break;

        case HTSYSMENU:
            if (puSysCmd)
            {
                *puSysCmd = SC_MOUSEMENU | iHitCode;
            }
            return TRUE;
    }

    // If we didn't recognize the hit code there's nothing to track
    if (iPartId >= 0 )
    {
        // Get the window DC, in window coords
        hdc = _GetNonclientDC(_hwnd, NULL);
        if ( hdc )
        {
            // Don't paint in the window's content area, clip to the content area
            ExcludeClipRect( hdc, _ncwm.rcW0[NCRC_CONTENT].left, 
                                  _ncwm.rcW0[NCRC_CONTENT].top, 
                                  _ncwm.rcW0[NCRC_CONTENT].right, 
                                  _ncwm.rcW0[NCRC_CONTENT].bottom );

            // Calculate the tracking rect. We track a larger button rect when maximized
            // but paint into the normal sized rect.
            rcBtnTrack = *prcBtnPaint;
            _GetNcBtnHitTestRect( &_ncwm, iHitCode, TRUE, &rcBtnTrack );

            // when tracking MDI child window frame buttons, clip to their
            // parent rect. 
            if ( TESTFLAG(GetWindowLong(hwnd, GWL_EXSTYLE), WS_EX_MDICHILD) )
            {
                RECT rcMDIClient;

                GetWindowRect(GetParent(hwnd), &rcMDIClient);
                ScreenToWindowRect(&rcMDIClient);
                InflateRect(&rcMDIClient, -NcGetSystemMetrics(SM_CXEDGE), -NcGetSystemMetrics(SM_CYEDGE));
                IntersectClipRect(hdc, rcMDIClient.left, rcMDIClient.top, rcMDIClient.right, rcMDIClient.bottom);
            }

            if (fHottrack)
            {
                // draw the button hot if the mouse is over it
                iStateId = (iHitCode == _htHot) ? SBS_HOT : CBS_NORMAL;
            }
            else
            {
                // draw the button depressed
                iStateId = SBS_PUSHED;
            }

            iStateId = MAKE_BTNSTATE(_ncwm.framestate, iStateId);
            NcDrawThemeBackground(_hTheme, hdc, iPartId, iStateId, prcBtnPaint, 0);

            // TODO NotifyWinEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_TITLEBAR, iButton, 0);


            if (!fHottrack)
            {
                BOOL fTrack, fMouseUp = FALSE;
                SetCapture(hwnd);   // take mouse capture

                do // mouse button tracking loop
                {
                    fTrack = FALSE;

                    //  Let's go to sleep, to be awakened only on a mouse message placed in our
                    //  thread's queue.

                    switch (MsgWaitForMultipleObjectsEx(0, NULL, INFINITE /*why consume CPU processing a timeout when we don't have to?*/, 
                                                        QS_MOUSE, MWMO_INPUTAVAILABLE))
                    {
                        case WAIT_OBJECT_0: // a mouse message or important system event has been queued
                            
                            if (PeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE))
                            {

                                // PeekMessage returns a point in screen relative coords. Mirror the
                                // point it this is a RTL window. Translate the point to window coords.
                                if ( TESTFLAG(_ncwm.dwExStyle, WS_EX_LAYOUTRTL) )
                                {
                                    // mirror the point to hittest correctly
                                    MIRROR_POINT(_ncwm.rcS0[NCRC_WINDOW], msg.pt);
                                }
                                ScreenToWindow( &msg.pt, 1 );

                                if (msg.message == WM_LBUTTONUP)
                                {
                                    ReleaseCapture();
                                    fMouseUp = TRUE;
                                }
                                else if ((msg.message == WM_MOUSEMOVE) && cmd)
                                {
                                    iNewStateId = MAKE_BTNSTATE(_ncwm.framestate, PtInRect(&rcBtnTrack, msg.pt) ? SBS_PUSHED : SBS_NORMAL);

                                    if (iStateId != iNewStateId)
                                    {
                                        iStateId = iNewStateId;
                                        NcDrawThemeBackground(_hTheme, hdc, iPartId, iStateId, prcBtnPaint, 0);
                                        // TODO NotifyWinEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_TITLEBAR, iButton, 0);
                                    }
                                
                                    fTrack = TRUE;
                                }
                            }
                            else
                            {
                                //  Check loss of capture.  This can happen if we loose activation 
                                //  via alt-tab and may not have received a WM_CAPTURECHANGED message
                                if (GetCapture() != hwnd)
                                {
                                    break;
                                }
                            }

                            // Dequeue CAPTURECHANGED
                            if (PeekMessage(&msg, NULL, WM_CAPTURECHANGED, WM_CAPTURECHANGED, PM_REMOVE) ||
                                fMouseUp)
                            {
                                break;
                            }
                            fTrack = TRUE;  // go back to sleep until the next mouse event
                            break;

                        default:
                            break; 
                    }

                } while (fTrack);

                // draw button in normal state if it is not in that state already
                iNewStateId = MAKE_BTNSTATE(_ncwm.framestate, CBS_NORMAL);
                if (iStateId != iNewStateId)
                {
                    NcDrawThemeBackground(_hTheme, hdc, iPartId, iNewStateId, prcBtnPaint, 0);
                }

                // if we did not end up on a button return 0
                if( puSysCmd && (*puSysCmd = cmd) != 0 )
                {
                    // TODO NotifyWinEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_TITLEBAR, iButton, 0);

                    // If mouse wasn't released over the button, cancel the command.
                    if( !(fMouseUp && PtInRect(&rcBtnTrack, msg.pt)) )
                        *puSysCmd = 0;
                }

            }

            // Done with DC now
            ReleaseDC(_hwnd, hdc);
        }
    }

    return TRUE;
}

//-------------------------------------------------------------------------//
DWORD GetTextAlignFlags(HTHEME hTheme, IN NCWNDMET* pncwm, BOOL fReverse)
{
    CONTENTALIGNMENT  contentAlignment = CA_LEFT;
    DWORD dwAlignFlags = 0;

    //---- compute text alignment ----
    GetThemeInt(hTheme, pncwm->rgframeparts[iCAPTION], pncwm->framestate, TMT_CONTENTALIGNMENT, 
                (int *)&contentAlignment);

    if (fReverse)
    {
        //---- reverse alignment ----
        switch(contentAlignment)
        {
            default:
            case CA_LEFT:   dwAlignFlags |= DT_RIGHT;   break;
            case CA_CENTER: dwAlignFlags |= DT_CENTER; break;
            case CA_RIGHT:  dwAlignFlags |= DT_LEFT;  break;
        }
    }
    else
    {
        //---- normal alignment ----
        switch(contentAlignment)
        {
            default:
            case CA_LEFT:   dwAlignFlags |= DT_LEFT;   break;
            case CA_CENTER: dwAlignFlags |= DT_CENTER; break;
            case CA_RIGHT:  dwAlignFlags |= DT_RIGHT;  break;
        }
    }

    return dwAlignFlags;
}

//-------------------------------------------------------------------------//
void _BorderRect( HDC hdc, COLORREF rgb, LPCRECT prc, int cxBorder, int cyBorder )
{
    COLORREF rgbSave = SetBkColor( hdc, rgb );
    RECT rc = *prc;

    //  bottom border
    rc = *prc; rc.top = prc->bottom - cyBorder;
    ExtTextOut( hdc, rc.left, rc.top, ETO_OPAQUE, &rc, NULL, 0, NULL );

    //  right border
    rc = *prc; rc.left = prc->right - cxBorder;
    ExtTextOut( hdc, rc.left, rc.top, ETO_OPAQUE, &rc, NULL, 0, NULL );

    //  left border
    rc = *prc; rc.right = prc->left + cxBorder;
    ExtTextOut( hdc, rc.left, rc.top, ETO_OPAQUE, &rc, NULL, 0, NULL );

    //  top border
    rc = *prc; rc.bottom = prc->top + cyBorder;
    ExtTextOut( hdc, rc.left, rc.top, ETO_OPAQUE, &rc, NULL, 0, NULL );

    SetBkColor( hdc, rgbSave );
}

//-------------------------------------------------------------------------//
void _DrawWindowEdges( HDC hdc, NCWNDMET* pncwm, BOOL fIsFrame )
{
    //  non-frame window edge & border
    if( !fIsFrame )
    {
        RECT rcWnd = pncwm->rcW0[NCRC_WINDOW];

        int  cxBorder = NcGetSystemMetrics(SM_CXBORDER),
             cyBorder = NcGetSystemMetrics(SM_CYBORDER);

        //  static, window edge
        if( TESTFLAG(pncwm->dwExStyle, WS_EX_WINDOWEDGE) )
        {
            RECT rcClip = rcWnd;

            InflateRect( &rcClip, -pncwm->cnBorders, -pncwm->cnBorders );
            ExcludeClipRect( hdc, rcClip.left, rcClip.top, rcClip.right, rcClip.bottom );
            DrawEdge( hdc, &rcWnd, EDGE_RAISED, BF_RECT | BF_ADJUST | BF_MIDDLE);
            SelectClipRgn( hdc, NULL );
        }
        else if( TESTFLAG(pncwm->dwExStyle, WS_EX_STATICEDGE) )
        {
            DrawEdge( hdc, &rcWnd, BDR_SUNKENOUTER, BF_RECT | BF_ADJUST );
        }
        // Normal border
        else if( TESTFLAG(pncwm->dwStyle, WS_BORDER) )
        {
            _BorderRect( hdc, GetSysColor( COLOR_WINDOWFRAME),
                         &rcWnd, cxBorder, cyBorder );
        }
    }

    //  client edge
    if( TESTFLAG(pncwm->dwExStyle, WS_EX_CLIENTEDGE) )
    {
#ifdef _TEST_CLIENTEDGE_

        HBRUSH hbr = CreateSolidBrush( RGB(255,0,255) );
        FillRect(hdc, &ncwm.rcW0[NCRC_CLIENTEDGE], hbr);
        DeleteObject(hbr);

#else  _TEST_CLIENTEDGE_

        DrawEdge( hdc, &pncwm->rcW0[NCRC_CLIENTEDGE], EDGE_SUNKEN, BF_RECT | BF_ADJUST);

#endif _TEST_CLIENTEDGE_
    }
}

//-------------------------------------------------------------------------//
void CThemeWnd::NcPaintCaption(
    IN HDC       hdcOut,
    IN NCWNDMET* pncwm,
    IN BOOL      fBuffered,
    IN DWORD     dwCaptionFlags, // draw caption flags (DC_xxx, winuser.h)
    IN DTBGOPTS* pdtbopts )
{
    ASSERT(hdcOut);
    ASSERT(pncwm);
    ASSERT(pncwm->fFrame);
    ASSERT(HAS_CAPTIONBAR(pncwm->dwStyle));

    DWORD dwOldAlign = 0;

    //  caption text implies caption background
    if( TESTFLAG( dwCaptionFlags, DC_TEXT|DC_ICON ) || 0 == dwCaptionFlags )
    {
        dwCaptionFlags = DC_ENTIRECAPTION;
    }

    if( dwCaptionFlags != DC_ENTIRECAPTION
#if defined(DEBUG) && defined(DEBUG_NCPAINT)
        || TESTFLAG( _NcTraceFlags, NCTF_NCPAINT )
#endif DEBUG
    )
    {
        fBuffered = FALSE;
    }

    //  create caption double buffer
    HBITMAP hbmBuf = fBuffered ? CreateCompatibleBitmap(hdcOut, RECTWIDTH(&pncwm->rcW0[NCRC_CAPTION]),
                                                        RECTHEIGHT(&pncwm->rcW0[NCRC_CAPTION])) : 
                                 NULL;
    
    if( !fBuffered || hbmBuf )
    {
        HDC hdc = fBuffered ? CreateCompatibleDC(hdcOut) : hdcOut;
        if( hdc )
        {
            //--- DO NOT EXIT FROM WITHIN THIS CONDITIONAL ---//
            EnterNcThemePaint(); 

            HBITMAP hbm0 = fBuffered ? (HBITMAP)SelectObject(hdc, hbmBuf) : NULL;

            if( TESTFLAG( dwCaptionFlags, DC_BACKGROUND ) )
            {
                //  Draw caption background

                RECT rcBkgnd = pncwm->rcW0[NCRC_CAPTION];
                if( pncwm->fFullMaxed )
                {
                    rcBkgnd.top   += pncwm->cnBorders;
                    rcBkgnd.left  += pncwm->cnBorders;
                    rcBkgnd.right -= pncwm->cnBorders;
                }
                NcDrawThemeBackgroundEx( _hTheme, hdc, pncwm->rgframeparts[iCAPTION], pncwm->framestate,
                                         &rcBkgnd, pdtbopts );
            }

            if( TESTFLAG( dwCaptionFlags, DC_BUTTONS ) )
            {
                //  Draw standard caption buttons
                if (!IsRectEmpty(&pncwm->rcW0[NCRC_CLOSEBTN]))
                {
                    NcDrawThemeBackground( _hTheme, hdc, pncwm->fSmallFrame ? WP_SMALLCLOSEBUTTON : WP_CLOSEBUTTON,
                                           MAKE_BTNSTATE(pncwm->framestate, pncwm->rawCloseBtnState),
                                           &pncwm->rcW0[NCRC_CLOSEBTN], 0);
                }

                if (!IsRectEmpty(&pncwm->rcW0[NCRC_MAXBTN]))
                {
                
                    NcDrawThemeBackground(_hTheme, hdc, pncwm->iMaxButtonPart,
                                          MAKE_BTNSTATE(pncwm->framestate, pncwm->rawMaxBtnState), 
                                          &pncwm->rcW0[NCRC_MAXBTN], 0);
                }

                if (!IsRectEmpty(&pncwm->rcW0[NCRC_MINBTN]))
                {
                    NcDrawThemeBackground( _hTheme, hdc, pncwm->iMinButtonPart,
                                           MAKE_BTNSTATE(pncwm->framestate, pncwm->rawMinBtnState), 
                                           &pncwm->rcW0[NCRC_MINBTN], 0);
                }

                if (!IsRectEmpty(&pncwm->rcW0[NCRC_HELPBTN]))
                    NcDrawThemeBackground(_hTheme, hdc, WP_HELPBUTTON, MAKE_BTNSTATE(pncwm->framestate, CBS_NORMAL), 
                                          &pncwm->rcW0[NCRC_HELPBTN], 0);
            }

            //  Draw sysmenu icon
            if( TESTFLAG( dwCaptionFlags, DC_ICON ) )
            {
                if (!IsRectEmpty(&pncwm->rcW0[NCRC_SYSBTN]) && _hAppIcon)
                {
                    #define MAX_APPICON_RETRIES 1
                    int cRetries = 0;

                    DWORD dwLayout = GetLayout(hdc);
                    if( GDI_ERROR != dwLayout && TESTFLAG(dwLayout, LAYOUT_RTL) )
                    {
                        SetLayout(hdc, dwLayout|LAYOUT_BITMAPORIENTATIONPRESERVED);
                    }

                    do 
                    {
                        //  note: we don't draw sysmenu icon mirrored
                        if( DrawIconEx(hdc, pncwm->rcW0[NCRC_SYSBTN].left, pncwm->rcW0[NCRC_SYSBTN].top, _hAppIcon,
                                       RECTWIDTH(&pncwm->rcW0[NCRC_SYSBTN]), RECTHEIGHT(&pncwm->rcW0[NCRC_SYSBTN]),
                                       0, NULL, DI_NORMAL))
                        {
                            break; // success; done
                        }

                        //  failure; try recycling the handle
                        if( _hAppIcon && GetLastError() == ERROR_INVALID_CURSOR_HANDLE )
                        {
                            _hAppIcon = NULL;
                            AcquireFrameIcon( pncwm->dwStyle, pncwm->dwExStyle, FALSE );

                            if( (++cRetries) > MAX_APPICON_RETRIES )
                            {
                                _hAppIcon = NULL; // failed to retrieve a new icon handle; bail for good.
                            }
                        }

                    } while( _hAppIcon && cRetries <= MAX_APPICON_RETRIES );

                    if( GDI_ERROR != dwLayout )
                    {
                        SetLayout(hdc, dwLayout);
                    }

                }
            }

            if( TESTFLAG( dwCaptionFlags, DC_TEXT ) )
            {
                //  Draw caption text
                HFONT  hf0 = NULL;
                DWORD  dwDTFlags = DT_SINGLELINE | DT_NOPREFIX | DT_END_ELLIPSIS;
                BOOL   fSelFont = FALSE;
                LPWSTR pszText = _AllocWindowText(_hwnd);

                if( pszText && *pszText )
                {
                    //  Compute frame text rect
                    if( pncwm->hfCaption )
                    {
                        hf0 = (HFONT)SelectObject( hdc, pncwm->hfCaption );
                        fSelFont = TRUE;
                    }

                    //---- compute text alignment ----
                    BOOL fReverse = TESTFLAG(_ncwm.dwExStyle, WS_EX_RIGHT);

                    dwDTFlags |= GetTextAlignFlags(_hTheme, pncwm, fReverse);
                }

                //---- adjust text align for WS_EX_RTLREADING ----
                if (TESTFLAG(_ncwm.dwExStyle, WS_EX_RTLREADING)) 
                    dwOldAlign = SetTextAlign(hdc, TA_RTLREADING | GetTextAlign(hdc));

                if( pszText && *pszText )
                {
                    //---- set options for DrawThemeText() ----
                    DTTOPTS DttOpts = {sizeof(DttOpts)};
                    DttOpts.dwFlags = DTT_TEXTCOLOR;
                    DttOpts.crText = pncwm->rgbCaption;

                    Log(LOG_RFBUG, L"Drawing Caption Text: left=%d, state=%d, text=%s",
                        pncwm->rcW0[NCRC_CAPTIONTEXT].left, pncwm->framestate, pszText);

                    //---- draw the caption text ----
                    DrawThemeTextEx(_hTheme, hdc, pncwm->rgframeparts[iCAPTION], pncwm->framestate, 
                        pszText, -1, dwDTFlags, &pncwm->rcW0[NCRC_CAPTIONTEXT], &DttOpts);
                }

                //---- free the text, if temp. allocated ----
                SAFE_DELETE_ARRAY(pszText)

                //---- draw the "Comments?" text ----
                SetBkMode( hdc, TRANSPARENT );
                SetTextColor( hdc, pncwm->rgbCaption );
                DrawLameButton(hdc, pncwm);

                //---- restore the text align ----
                if (TESTFLAG(_ncwm.dwExStyle, WS_EX_RTLREADING)) 
                    SetTextAlign(hdc, dwOldAlign);
            
                if( fSelFont )
                {
                    SelectObject(hdc, hf0);
                }
            }
            
            if( hdc != hdcOut )
            {
                //  Slap the bits on the output DC.
                BitBlt( hdcOut, pncwm->rcW0[NCRC_CAPTION].left, pncwm->rcW0[NCRC_CAPTION].top,
                        WIDTH(pncwm->rcW0[NCRC_CAPTION]), HEIGHT(pncwm->rcW0[NCRC_CAPTION]),
                        hdc, 0, 0, SRCCOPY );
                SelectObject(hdc, hbm0);
                DeleteDC(hdc);
            }

            LeaveNcThemePaint();
        }
        DeleteObject( hbmBuf );
    }

    if( IsWindowVisible(_hwnd) )
    {
        SetRenderedNcPart(RNCF_CAPTION);
    }
}

//-------------------------------------------------------------------------//
//  CThemeWnd::NcPaint() - NC painting worker
//
void CThemeWnd::NcPaint(
    IN OPTIONAL HDC    hdcIn,
    IN          ULONG  dwFlags,
    IN OPTIONAL HRGN   hrgnUpdate,
    IN OPTIONAL NCPAINTOVERIDE* pncpo)
{
    NCTHEMEMET  nctm;
    NCWNDMET*   pncwm = NULL;
    HDC         hdc   = NULL;

    if( _cLockRedraw > 0 ) 
        return;

    //  Compute all metrics before painting:
    if (pncpo) // preview override
    {
        ASSERT(hdcIn);
        hdc    = hdcIn;
        pncwm = pncpo->pncwm;
        nctm   = pncpo->nctm;
    }
    else       // live window
    {
        if( !GetNcWindowMetrics( NULL, &pncwm, &nctm, NCWMF_RECOMPUTE ) )
            return;

        //  Ensure status bits reflect caller's intention for frame state
        if( dwFlags != NCPF_DEFAULT )
        {
            _ComputeNcWindowStatus( _hwnd, TESTFLAG(dwFlags, NCPF_ACTIVEFRAME) ? WS_ACTIVECAPTION : 0, pncwm );
        }

        hdc = hdcIn ? hdcIn : _GetNonclientDC( _hwnd, hrgnUpdate );

        if (! hdc)
        {
            //---- don't assert here since stress (out of memory) could cause a legit failure ----
            Log(LOG_ALWAYS, L"call to GetDCEx() for nonclient painting failed");
        }
    }

    if( hdc != NULL )
    {
        //--- DO NOT EXIT FROM WITHIN THIS CONDITIONAL ---//
        
        BEGIN_DEBUG_NCPAINT();
        EnterNcThemePaint();

        //  Clip to content rect (alleviates flicker in menubar and scrollbars as we paint background)
        RECT rcClip;
        rcClip = pncwm->rcW0[NCRC_CONTENT];
        if( TESTFLAG(pncwm->dwExStyle, WS_EX_LAYOUTRTL) )
        {
            // mirror the clip rect relative to the window rect
            // and apply that as the clipping region for the dc
            MIRROR_RECT(pncwm->rcW0[NCRC_WINDOW], rcClip);
        }

        ExcludeClipRect( hdc, rcClip.left, rcClip.top, rcClip.right, rcClip.bottom );

        if( pncwm->fFrame )
        {
            //---- DrawThemeBackgroundEx() options ----
            DTBGOPTS dtbopts = {sizeof(dtbopts)};
            DTBGOPTS *pdtbopts = NULL;

            //  if not drawing preview, set "draw solid" option
            if(!pncpo)        
            {
                //  Because of the interleaving of NCPAINT and SetWindowRgn, drawing solid results 
                //  in some flicker and transparency bleed.  Commenting this out for now [scotthan]
                //dtbopts.dwFlags |= DTBG_DRAWSOLID;
                pdtbopts = &dtbopts;
            }

            //  Frame Background
            if( pncwm->fMin )
            {
                NcDrawThemeBackgroundEx( _hTheme, hdc, WP_MINCAPTION, pncwm->framestate,
                                         &pncwm->rcW0[NCRC_CAPTION], pdtbopts ) ;
            }
            else if( !pncwm->fFullMaxed )
            {
                NcDrawThemeBackgroundEx( _hTheme, hdc, pncwm->rgframeparts[iFRAMELEFT], pncwm->framestate,
                                         &pncwm->rcW0[NCRC_FRAMELEFT], pdtbopts );
                NcDrawThemeBackgroundEx( _hTheme, hdc, pncwm->rgframeparts[iFRAMERIGHT], pncwm->framestate,
                                         &pncwm->rcW0[NCRC_FRAMERIGHT], pdtbopts );
                NcDrawThemeBackgroundEx( _hTheme, hdc, pncwm->rgframeparts[iFRAMEBOTTOM], pncwm->framestate,
                                         &pncwm->rcW0[NCRC_FRAMEBOTTOM], pdtbopts );
            }

            SetRenderedNcPart(RNCF_FRAME);

            //  Caption
            NcPaintCaption( hdc, pncwm, !(pncwm->fMin || pncwm->fFullMaxed || pncpo),
                            DC_ENTIRECAPTION, pdtbopts );
        }

        //  Clip to client rect
        SelectClipRgn( hdc, NULL );

        //  Menubar
        if( !(pncwm->fMin || TESTFLAG(pncwm->dwStyle, WS_CHILD)) 
            && !IsRectEmpty(&pncwm->rcW0[NCRC_MENUBAR]) )
        {
            RECT rcMenuBar = pncwm->rcW0[NCRC_MENUBAR];
            BOOL fClip = RECTHEIGHT(&rcMenuBar) < pncwm->cyMenu;
             
            if( fClip )
            {
                IntersectClipRect( hdc, rcMenuBar.left, rcMenuBar.top, 
                                   rcMenuBar.right, rcMenuBar.bottom );
            }

            PaintMenuBar( _hwnd, hdc, pncwm->cnMenuOffsetLeft,
                          pncwm->cnMenuOffsetRight, pncwm->cnMenuOffsetTop,
                          TESTFLAG(pncwm->framestate, FS_ACTIVE) ? PMB_ACTIVE : 0 );
    
            //  deal with unpainted menubar pixels:
            if( nctm.dyMenuBar > 0 && RECTHEIGHT(&pncwm->rcW0[NCRC_MENUBAR]) >= pncwm->cyMenu )
            {
                rcMenuBar.top = rcMenuBar.bottom - nctm.dyMenuBar;
                COLORREF rgbBk = SetBkColor( hdc, GetSysColor(COLOR_MENU) );
                ExtTextOut(hdc, rcMenuBar.left, rcMenuBar.top, ETO_OPAQUE, &rcMenuBar, NULL, 0, NULL );
                SetBkColor( hdc, rgbBk );
            }

            if( fClip )
                SelectClipRgn( hdc, NULL );
        }

        //  Scrollbars
        if( !pncwm->fMin )
        {
            //  Draw static, window, client edges.
            _DrawWindowEdges( hdc, pncwm, pncwm->fFrame );

            RECT rcVScroll = pncwm->rcW0[NCRC_VSCROLL];
            if ( TESTFLAG(pncwm->dwExStyle, WS_EX_LAYOUTRTL) )
            {
                MIRROR_RECT(pncwm->rcW0[NCRC_WINDOW], rcVScroll);
            }

            if( TESTFLAG(pncwm->dwStyle, WS_VSCROLL) && 
                ( HasRenderedNcPart(RNCF_SCROLLBAR) || RectVisible(hdc, &rcVScroll)) )
            {
                if( TESTFLAG(pncwm->dwStyle, WS_HSCROLL) )
                {

                    //  Draw sizebox.
                    RECT rcSizeBox = pncwm->rcW0[NCRC_SIZEBOX];

                    if ( TESTFLAG(pncwm->dwExStyle, WS_EX_LAYOUTRTL) )
                    {
                        MIRROR_RECT(pncwm->rcW0[NCRC_WINDOW], rcSizeBox);
                    }

                    DrawSizeBox( _hwnd, hdc, rcSizeBox.left, rcSizeBox.top );
                }

                DrawScrollBar( _hwnd, hdc, pncpo ? &pncwm->rcW0[NCRC_VSCROLL]: NULL, TRUE /*vertical*/ );
                SetRenderedNcPart( RNCF_SCROLLBAR );
            }

            if( TESTFLAG(pncwm->dwStyle, WS_HSCROLL) && 
                ( HasRenderedNcPart(RNCF_SCROLLBAR) || RectVisible(hdc, &pncwm->rcW0[NCRC_HSCROLL])) )
            {
                DrawScrollBar( _hwnd, hdc, pncpo ? &pncwm->rcW0[NCRC_HSCROLL] : NULL, FALSE /*vertical*/ );
                SetRenderedNcPart( RNCF_SCROLLBAR );
            }
        }

        if (pncpo || hdcIn)
        {
            SelectClipRgn( hdc, NULL );
        }
        else
        {
            ReleaseDC( _hwnd, hdc );
        }

        LeaveNcThemePaint();
        END_DEBUG_NCPAINT();
    }
}

//-------------------------------------------------------------------------//
//  WM_STYLECHANGED themewnd instance handler
void CThemeWnd::StyleChanged( UINT iGWL, DWORD dwOld, DWORD dwNew )
{
    DWORD dwStyleOld, dwStyleNew, dwExStyleOld, dwExStyleNew;

    switch( iGWL )
    {
        case GWL_STYLE:
            dwStyleOld = dwOld;
            dwStyleNew = dwNew;
            dwExStyleOld = dwExStyleNew = GetWindowLong(_hwnd, GWL_EXSTYLE);
            break;

        case GWL_EXSTYLE:
            dwExStyleOld = dwOld;
            dwExStyleNew = dwNew;
            dwStyleOld = dwStyleNew = GetWindowLong(_hwnd, GWL_STYLE);
            break;

        default:
            return;
    }

    DWORD fClassFlagsOld  = CThemeWnd::EvaluateStyle( dwStyleOld, dwExStyleOld);
    DWORD fClassFlagsNew  = CThemeWnd::EvaluateStyle( dwStyleNew, dwExStyleNew);

    //  Update theme class flags.
    //  Always keep the scrollbar class flag if the window had it initially. User
    //  flips scroll styles on and off without corresponding style change notification.
    _fClassFlags = fClassFlagsNew | (_fClassFlags & TWCF_SCROLLBARS);
    _fFrameThemed = TESTFLAG( _fClassFlags, TWCF_FRAME|TWCF_TOOLFRAME );        

    //  Are we losing the frame?
    if( TESTFLAG( fClassFlagsOld, TWCF_FRAME|TWCF_TOOLFRAME ) &&
        !TESTFLAG( fClassFlagsNew, TWCF_FRAME|TWCF_TOOLFRAME ) )
    {
        ThemeMDIMenuButtons(FALSE, FALSE);

        if( AssignedFrameRgn() )
        {
            AssignFrameRgn(FALSE /*strip off frame rgn*/, FTF_REDRAW);
        }
    }
    //  Are we gaining a frame?
    else if( TESTFLAG( fClassFlagsNew, TWCF_FRAME|TWCF_TOOLFRAME ) &&
            !TESTFLAG( fClassFlagsOld, TWCF_FRAME|TWCF_TOOLFRAME ) )
    {
        SetFrameTheme(0, NULL);
    }

    //  Freshen window metrics
    GetNcWindowMetrics( NULL, NULL, NULL, NCWMF_RECOMPUTE );
}

//-------------------------------------------------------------------------//
//  ThemeDefWindowProc message handlers
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
//  WM_THEMECHANGED post-wndproc msg handler
LRESULT CALLBACK OnOwpPostThemeChanged( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if (IS_THEME_CHANGE_TARGET(ptm->lParam))
    {
        //---- avoid redundant retheming (except for SetWindowTheme() calls)
        if ((HTHEME(*pwnd) == _nctmCurrent.hTheme) && (! (ptm->lParam & WTC_CUSTOMTHEME)))
        {
            Log(LOG_NCATTACH, L"OnOwpPostThemeChanged, just kicking the frame");

            //---- window got correct theme thru _XXXWindowProc() from sethook ----
            //---- we just need to redraw the frame for all to be right ----
            if (pwnd->IsFrameThemed())
            {
                //---- attach the region to the window now ----
                pwnd->SetFrameTheme(FTF_REDRAW, NULL);
            }
        }
        else
        {
            Log(LOG_NCATTACH, L"OnOwpPostThemeChanged, calling Full ::ChangeTheme()");

            //---- its a real, app/system theme change ----
            pwnd->ChangeTheme( ptm );
        }
    }

    MsgHandled( ptm );
    return 1L;
}

//-------------------------------------------------------------------------//
void CThemeWnd::ChangeTheme( THEME_MSG* ptm )
{
    if( _hTheme )       // hwnd attached for previous theme
    {
        //  do a lightweight detach from current theme
        _DetachInstance( HMD_CHANGETHEME );
    }

    if( IsAppThemed() )           // new theme is active
    {
        //  retrieve window client rect, style bits.
        WINDOWINFO wi;
        wi.cbSize = sizeof(wi);
        GetWindowInfo( ptm->hwnd, &wi );
        ULONG ulTargetFlags = EvaluateStyle( wi.dwStyle, wi.dwExStyle );
        
        //  If the window is themable
        if( TESTFLAG(ulTargetFlags, TWCF_NCTHEMETARGETMASK) )
        {
            //  Open the new theme
            HTHEME hTheme = ::OpenNcThemeData( ptm->hwnd, L"Window" );

            if( hTheme )
            {
                //  do a lightweight attach
                if( _AttachInstance( ptm->hwnd, hTheme, ulTargetFlags, NULL ) )
                {
                    //  reattach scrollbars
                    if( TESTFLAG( ulTargetFlags, TWCF_SCROLLBARS ) )
                    {
                        AttachScrollBars(ptm->hwnd);
                    }

                    if (IsFrameThemed())
                    {
                        //---- attach the region to the window now ----
                        SetFrameTheme(FTF_REDRAW, NULL);
                    }
                }
                else
                {
                    CloseThemeData( hTheme );
                }
            }
        }
    }

    if (! _hTheme)      // if an hwnd is no longer attached
    {
        // Left without a theme handle: This means either we failed to open a new theme handle or
        // failed to evaulate as a target, no new theme, etc.
        RemoveWindowProperties(ptm->hwnd, FALSE);

        //---- release our CThemeWnd obj so it doesn't leak (addref-protected by caller) ----
        Release();
    }

}
//-------------------------------------------------------------------------//
BOOL IsPropertySheetChild(HWND hDlg)
{
    while(hDlg)
    {
        ULONG ulFlags = HandleToUlong(GetProp(hDlg, MAKEINTATOM(GetThemeAtom(THEMEATOM_DLGTEXTURING))));

        if( ETDT_ENABLETAB == (ulFlags & ETDT_ENABLETAB) /* all bits in this mask are required */ )
        {
            return TRUE;
        }
        hDlg = GetAncestor(hDlg, GA_PARENT);
    }

    return FALSE;
}
//---------------------------------------------------------------------------
void PrintClientNotHandled(HWND hwnd)
{
    ATOM aIsPrinting = GetThemeAtom(THEMEATOM_PRINTING);
    DWORD dw = PtrToUlong(GetProp(hwnd, (PCTSTR)aIsPrinting));
    if (dw == PRINTING_ASKING)
        SetProp(hwnd, (PCTSTR)aIsPrinting, (HANDLE)PRINTING_WINDOWDIDNOTHANDLE);
}

//---------------------------------------------------------------------------
HBRUSH GetDialogColor(HWND hwnd, NCTHEMEMET &nctm)
{
    HBRUSH hbr = NULL;

    //  if this is a PROPSHEET child or the app called
    //  EnableThemeDialogTexture() on this hwnd, we'll use the tab background.
    if (IsPropertySheetChild(hwnd))
    {
        hbr = nctm.hbrTabDialog;
    }

    if( NULL == hbr )
    {
        hbr = GetSysColorBrush(COLOR_3DFACE);
    }

    return hbr;
}
//---------------------------------------------------------------------------
LRESULT CALLBACK OnDdpPrint(CThemeWnd* pwnd, THEME_MSG* ptm)
{
    LRESULT lRet = 0L;
    if (!ptm->lRet)
    {
        if (pwnd->HasProcessedEraseBk())
        {
            RECT rc;
            HDC hdc = (HDC)ptm->wParam;
            NCTHEMEMET nctm;
            if( GetCurrentNcThemeMetrics( &nctm ))
            {
                HBRUSH hbr = GetDialogColor(*pwnd, nctm);
                
                if (hbr)
                {
                    POINT pt;

                    if (GetClipBox(hdc, &rc) == NULLREGION)
                        GetClientRect(*pwnd, &rc);

                    SetBrushOrgEx(hdc, -rc.left, -rc.top, &pt);
                    FillRect(hdc, &rc, hbr);
                    SetBrushOrgEx(hdc, pt.x, pt.y, NULL);

                    lRet = (LRESULT)1;
                    MsgHandled( ptm );
                }
            }
        }
        else
        {
            PrintClientNotHandled(*pwnd);
        }
    }

    return lRet;
}

//---------------------------------------------------------------------------
LRESULT CALLBACK OnDdpCtlColor(CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = 0L;
    if (!ptm->lRet && pwnd->HasProcessedEraseBk())
    {
        NCTHEMEMET nctm;
        if( GetCurrentNcThemeMetrics( &nctm ))
        {
            HBRUSH hbr = GetDialogColor(*pwnd, nctm);
            if (hbr)
            {
                RECT     rc;
                HDC      hdc = (HDC)ptm->wParam;

                GetWindowRect(((HWND)ptm->lParam), &rc);
                MapWindowPoints(NULL, *pwnd, (POINT*)&rc, 2);
                SetBkMode(hdc, TRANSPARENT);
                SetBrushOrgEx(hdc, -rc.left, -rc.top, NULL);

                // the hdc's default background color needs to be set
                // for for those controls that insist on using OPAQUE
                SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));

                lRet = (LRESULT)hbr;
                MsgHandled( ptm );
            }
        }
    }
    return lRet;
}

//-------------------------------------------------------------------------//
//  WM_CTLCOLORxxx defwindowproc override handler
LRESULT CALLBACK OnDdpPostCtlColor( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = 0L;
    if (!ptm->lRet)
    {
        // This is sent to the parent in the case of WM_CTLCOLORMSGBOX, but to the
        // dialog itself in the case of a WM_CTLCOLORDLG. This gets both.
        CThemeWnd* pwndDlg = CThemeWnd::FromHwnd((HWND)ptm->lParam);


        // WM_CTLCOLORMSGBOX is sent for Both the dialog AND the static
        // control inside. So we need to sniff: Are we talking to a dialog or a 
        // control. the pwnd is associated with the dialog, but not the control
        if (pwndDlg && VALID_THEMEWND(pwndDlg))
        {
            if (IsPropertySheetChild(*pwnd))
            {
                NCTHEMEMET nctm;
                if( GetCurrentNcThemeMetrics( &nctm ))
                {
                    HBRUSH hbr = GetDialogColor(*pwndDlg, nctm);
                    if (hbr)
                    {
                        lRet = (LRESULT) hbr;
                        pwndDlg->ProcessedEraseBk(TRUE);
                        MsgHandled(ptm);
                    }
                }
            }
        }
        else
        {
            // If we're talking to a control, forward to the control handler
            // because we have to offset the brush
            lRet = OnDdpCtlColor(pwnd, ptm );

        }
    }
    return lRet;
}

//-------------------------------------------------------------------------//
LRESULT CALLBACK OnDwpPrintClient( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    PrintClientNotHandled(*pwnd);

    return 0;
}



//---- Non-Client ----

//-------------------------------------------------------------------------//
//  WM_NCPAINT pre-wndmproc msg handler
LRESULT CALLBACK OnOwpPreNcPaint( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    NcPaintWindow_Add(*pwnd);

    if( !pwnd->InNcPaint() )
    {
        pwnd->ClearRenderedNcPart(RNCF_ALL); 
    }
    pwnd->EnterNcPaint();
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_NCPAINT DefWindowProc msg handler
LRESULT CALLBACK OnDwpNcPaint( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = 0L;
    if( !pwnd->IsNcThemed() )
        return lRet;

    if( IsWindowVisible(*pwnd) )
    {
        pwnd->NcPaint( NULL, NCPF_DEFAULT, 1 == ptm->wParam ? NULL : (HRGN)ptm->wParam, NULL );
    }

    MsgHandled( ptm );
    return lRet;
}

//-------------------------------------------------------------------------//
//  WM_NCPAINT post-wndmproc msg handler
LRESULT CALLBACK OnOwpPostNcPaint( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    pwnd->LeaveNcPaint();
    NcPaintWindow_Remove();
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_PRINT DefWindowProc msg handler
LRESULT CALLBACK OnDwpPrint( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = DoMsgDefault(ptm);
    if( !pwnd->IsNcThemed() )
        return lRet;

    if( ptm->lParam & PRF_NONCLIENT )
    {
        int iLayoutSave = GDI_ERROR;
        HDC hdc = (HDC)ptm->wParam;

        if (TESTFLAG(GetWindowLong(*pwnd, GWL_EXSTYLE), WS_EX_LAYOUTRTL))
        {
            // AnimateWindow sends WM_PRINT with an unmirrored memory hdc 
            iLayoutSave = SetLayout(hdc, LAYOUT_RTL);
        }

        pwnd->NcPaint( (HDC)ptm->wParam, NCPF_DEFAULT, NULL, NULL );

        if (iLayoutSave != GDI_ERROR)
        {
            SetLayout(hdc, iLayoutSave);
        }
    }

    return lRet;
}

//-------------------------------------------------------------------------//
//  WM_NCUAHDRAWCAPTION DefWindowProc msg handler
LRESULT CALLBACK OnDwpNcThemeDrawCaption( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = 0L;
    if( !pwnd->IsNcThemed() || !pwnd->HasRenderedNcPart(RNCF_CAPTION) )
        return lRet;

    NCWNDMET* pncwm;
    if( pwnd->GetNcWindowMetrics( NULL, &pncwm, NULL, NCWMF_RECOMPUTE ) )
    {
        HDC hdc = _GetNonclientDC( *pwnd, NULL );
        if( hdc )
        {
            DTBGOPTS dtbo;
            dtbo.dwSize = sizeof(dtbo);
            dtbo.dwFlags = DTBG_DRAWSOLID;
            
            pwnd->NcPaintCaption( hdc, pncwm, TRUE, (DWORD)ptm->wParam, &dtbo );
            ReleaseDC( *pwnd, hdc );
            MsgHandled( ptm );
        }
    }

    return lRet;
}

//-------------------------------------------------------------------------//
//  WM_NCUAHDRAWFRAME DefWindowProc msg handler
LRESULT CALLBACK OnDwpNcThemeDrawFrame( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = 0L;
    if( !pwnd->IsNcThemed() || !pwnd->HasRenderedNcPart(RNCF_FRAME) )
        return lRet;

    pwnd->NcPaint( (HDC)ptm->wParam, ptm->lParam & DF_ACTIVE ? NCPF_ACTIVEFRAME : NCPF_INACTIVEFRAME, NULL, NULL );

    MsgHandled( ptm );
    return lRet;
}

//-------------------------------------------------------------------------//
CMdiBtns* CThemeWnd::LoadMdiBtns( IN OPTIONAL HDC hdc, IN OPTIONAL UINT uSysCmd )
{
    if( NULL == _pMdiBtns && NULL == (_pMdiBtns = new CMdiBtns) )
    {
        return NULL;
    }

    return _pMdiBtns->Load( _hTheme, hdc, uSysCmd ) ? _pMdiBtns : NULL;
}

//-------------------------------------------------------------------------//
void CThemeWnd::UnloadMdiBtns( IN OPTIONAL UINT uSysCmd )
{
    SAFE_DELETE(_pMdiBtns);
}

//-------------------------------------------------------------------------//
//  WM_MEASUREITEM pre-wndproc msg handler
LRESULT CALLBACK OnOwpPreMeasureItem( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if( pwnd->IsNcThemed() && IsWindow(pwnd->GetMDIClient()) )
    {
        MEASUREITEMSTRUCT* pmis = (MEASUREITEMSTRUCT*)ptm->lParam;

        CMdiBtns* pBtns = pwnd->LoadMdiBtns( NULL, pmis->itemID );
        if( pBtns )
        {
            if( pBtns->Measure( *pwnd, pmis ) )
            {
                MsgHandled(ptm);
                return TRUE;
            }
        }
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
//  WM_DRAWITEM pre-wndproc msg handler
LRESULT CALLBACK OnOwpPreDrawItem( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if( pwnd->IsNcThemed() && IsWindow(pwnd->GetMDIClient()) )
    {
        DRAWITEMSTRUCT* pdis = (DRAWITEMSTRUCT*)ptm->lParam;

        CMdiBtns* pBtns = pwnd->LoadMdiBtns( NULL, pdis->itemID );
        if( pBtns )
        {
            if( pBtns->Draw( *pwnd, pdis ) )
            {
                MsgHandled(ptm);
                return TRUE;
            }
        }
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
//  WM_MENUCHAR pre-wndproc msg handler
LRESULT CALLBACK OnOwpPreMenuChar( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    //  Route MENUCHAR messages relating to themed MDI buttons to
    //  DefWindowProc (some apps assume all owner-drawn menuitems
    //  belong to themselves).
    HWND hwndMDIClient = pwnd->GetMDIClient();

    if( pwnd->IsNcThemed() && IsWindow(hwndMDIClient))
    {
        if( LOWORD(ptm->wParam) == TEXT('-') )
        {
            BOOL fMaxedChild;
            HWND hwndActive = _MDIGetActive(hwndMDIClient, &fMaxedChild );
            if( hwndActive && fMaxedChild )
            {
                MsgHandled(ptm);
                return DefFrameProc(ptm->hwnd, hwndMDIClient, ptm->uMsg, 
                                    ptm->wParam, ptm->lParam);
            }
        }
    }
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_NCHITTEST DefWindowProc msg handler
LRESULT CALLBACK OnDwpNcHitTest( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if( !pwnd->IsNcThemed() )
        return DoMsgDefault( ptm );

    NCTHEMEMET nctm;
    NCWNDMET*  pncwm;
    POINT      pt;
    MAKEPOINT( pt, ptm->lParam );
    MsgHandled( ptm );

    if( pwnd->GetNcWindowMetrics( NULL, &pncwm, &nctm, 0 ) )
    {
        if( _StrictPtInRect( &pncwm->rcS0[NCRC_CLIENT], pt ) )
            return HTCLIENT;

        if( _StrictPtInRect( &pncwm->rcS0[NCRC_HSCROLL], pt ) )
            return HTHSCROLL;

        if( _StrictPtInRect( &pncwm->rcS0[NCRC_SIZEBOX], pt ) )
        {
            if (SizeBoxHwnd(*pwnd) && !TESTFLAG(pncwm->dwExStyle, WS_EX_LEFTSCROLLBAR))

            {
                return TESTFLAG(pncwm->dwExStyle, WS_EX_LAYOUTRTL) ? HTBOTTOMLEFT : HTBOTTOMRIGHT;
            }
            else
            {
                return HTGROWBOX;
            }
        }

        if ( TESTFLAG(pncwm->dwExStyle, WS_EX_LAYOUTRTL) )
        {
            // mirror the point to hittest correctly
            MIRROR_POINT(pncwm->rcS0[NCRC_WINDOW], pt);
        }

        if( _StrictPtInRect( &pncwm->rcS0[NCRC_VSCROLL], pt ) )
            return HTVSCROLL;

        if( _StrictPtInRect( &pncwm->rcS0[NCRC_MENUBAR], pt ) )
            return HTMENU;

        if( pncwm->fFrame )
        {
            RECT rcButton;
            
            // ---- close button ----
            _GetNcBtnHitTestRect( pncwm, HTCLOSE, FALSE, &rcButton );

            if ( _StrictPtInRect( &rcButton, pt ) )
            {
                return HTCLOSE;
            }

            // ---- minimize button ----
            _GetNcBtnHitTestRect( pncwm, HTMINBUTTON, FALSE, &rcButton );

            if ( _StrictPtInRect( &rcButton, pt ) )
            {
                return HTMINBUTTON;
            }

            // ---- maximize button ----
            _GetNcBtnHitTestRect( pncwm, HTMAXBUTTON, FALSE, &rcButton );

            if ( _StrictPtInRect( &rcButton, pt ) )
            {
                return HTMAXBUTTON;
            }

            // ---- sys menu ----
            _GetNcBtnHitTestRect( pncwm, HTSYSMENU, FALSE, &rcButton );

            if ( _StrictPtInRect( &rcButton, pt ) )
            {
                return HTSYSMENU;
            }

            // ---- help button ----
            _GetNcBtnHitTestRect( pncwm, HTHELP, FALSE, &rcButton );

            if ( _StrictPtInRect( &rcButton, pt ) )
            {
                return HTHELP;
            }
        
#ifdef LAME_BUTTON
            if ( TESTFLAG(pncwm->dwExStyle, WS_EX_LAMEBUTTON) )
            {
                if ( _StrictPtInRect( &pncwm->rcS0[NCRC_LAMEBTN], pt ) )
                    return HTLAMEBUTTON;
            }
#endif // LAME_BUTTON

            // don't need a mirrored point for the remaining hittests
            MAKEPOINT( pt, ptm->lParam );

            if( !_StrictPtInRect( &pncwm->rcS0[NCRC_CONTENT], pt ) )
            {
                if( pncwm->fMin || pncwm->fMaxed )
                {
                    if( _StrictPtInRect( &pncwm->rcS0[NCRC_CAPTION], pt ) )
                        return HTCAPTION;
                }

                //---- combined caption/frame case ----
                return pwnd->NcBackgroundHitTest( pt, &pncwm->rcS0[NCRC_WINDOW], pncwm->dwStyle, pncwm->dwExStyle, 
                                                  pncwm->framestate, pncwm->rgframeparts, pncwm->rgsizehitparts,
                                                  pncwm->rcS0 + NCRC_FRAMEFIRST ); 
            }
        }
    }

    return DoMsgDefault( ptm );
}


//-------------------------------------------------------------------------//
//  WM_WINDOWPOSCHANGING pre-wndproc override handler
LRESULT CALLBACK OnOwpPreWindowPosChanging( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if( pwnd->IsFrameThemed() )
    {
        //  Suppress WM_WINDOWPOSCHANGING from being sent to wndproc if it
        //  was generated by us calling SetWindowRgn.   
        
        //  Many apps (e.g. Adobe Acrobat Reader, Photoshop dialogs, etc) that handle 
        //  WM_NCCALCSIZE, WM_WINDOWPOSCHANGING and/or WM_WINDOWPOSCHANGED are not 
        //  reentrant on their handlers for these messages, and therefore botch the
        //  recursion induced by our SetWindowRgn call when we post-process 
        //  WM_WINDOWPOSCHANGED.

        //  There is no reason that a theme-complient wndproc should ever know that
        //  it's window(s) host a region managed by the system.
        if( pwnd->AssigningFrameRgn() )
        {
            MsgHandled(ptm);
            return DefWindowProc(ptm->hwnd, ptm->uMsg, ptm->wParam, ptm->lParam);
        }
    }
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_WINDOWPOSCHANGED pre-wndproc override handler
LRESULT CALLBACK OnOwpPreWindowPosChanged( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if( pwnd->IsFrameThemed() )
    {
        //  Suppress WM_WINDOWPOSCHANGING from being sent to wndproc if it
        //  was generated by us calling SetWindowRgn.   
        
        //  Many apps (e.g. Adobe Acrobat Reader, Photoshop dialogs, etc) that handle 
        //  WM_NCCALCSIZE, WM_WINDOWPOSCHANGING and/or WM_WINDOWPOSCHANGED are not 
        //  reentrant on their handlers for these messages, and therefore botch the
        //  recursion induced by our SetWindowRgn call when we post-process
        //  WM_WINDOWPOSCHANGED.

        //  There is no reason that a theme-complient wndproc should ever know that
        //  it's window(s) host a region managed by the system.

        if( pwnd->AssigningFrameRgn() )
        {
            MsgHandled(ptm);
            return DefWindowProc(ptm->hwnd, ptm->uMsg, ptm->wParam, ptm->lParam);
        }
    }
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_WINDOWPOSCHANGED message handler
inline LRESULT WindowPosChangedWorker( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if( pwnd->IsRevoked(RF_DEFER) )
    {
        if( !pwnd->IsRevoked(RF_INREVOKE) )
        {
            pwnd->Revoke(); // don't touch PWND after this!
        }
    }
    else if( pwnd->IsNcThemed() && !IsWindowInDestroy(*pwnd) )
    {
        //  If were not resizing, update the window region.
        if( pwnd->IsFrameThemed() )
        {
            NCWNDMET*  pncwm = NULL;
            NCTHEMEMET nctm = {0};

            //  Freshen per-window metrics 
            if( !pwnd->AssigningFrameRgn() )
            {
                WINDOWPOS *pWndPos = (WINDOWPOS*) ptm->lParam;

                //  Freshen this window's per-window metrics
                pwnd->GetNcWindowMetrics( NULL, &pncwm, &nctm, NCWMF_RECOMPUTE );

                //  Freshen window metrics for nc-themed children (e.g., MDI child frames)
                EnumChildWindows( *pwnd, _FreshenThemeMetricsCB, NULL );

                if( !TESTFLAG(pWndPos->flags, SWP_NOSIZE) || pwnd->DirtyFrameRgn() || 
                     TESTFLAG(pWndPos->flags, SWP_FRAMECHANGED) )
                {
                    if( pWndPos->cx > 0 && pWndPos->cy > 0 )
                    {
                        pwnd->AssignFrameRgn( TRUE, FTF_REDRAW );
                    }
                }
            }
        }

        _MDIUpdate( *pwnd, ((WINDOWPOS*) ptm->lParam)->flags);
    }
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_WINDOWPOSCHANGED post-wndproc override handler
//  
//  Note: we'll handle this post-wndproc for normal, client-side wndprocs
LRESULT CALLBACK OnOwpPostWindowPosChanged( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if( !IsServerSideWindow(ptm->hwnd) )
    {
        return WindowPosChangedWorker( pwnd, ptm );
    }
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_WINDOWPOSCHANGED DefWindowProc override handler.
//  
//  Note: we'll handle this in DefWindowProc only for windows with win32k-based
//  wndprocs, which are deprived of OWP callbacks.
LRESULT CALLBACK OnDwpWindowPosChanged( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if( IsServerSideWindow(ptm->hwnd) )
    {
        WindowPosChangedWorker( pwnd, ptm );
    }
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_NACTIVATE DefWindowProc msg handler
LRESULT CALLBACK OnDwpNcActivate( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = 1L;

    if( pwnd->IsNcThemed() )
    {
        // We need to forward on.  The DWP remembers the state
        // and MFC apps (for one) need this as well
        // but we don't want to actually paint, so lock the window
        ptm->lParam = (LPARAM)-1;
        lRet = DoMsgDefault(ptm);

        pwnd->NcPaint( NULL, ptm->wParam ? NCPF_ACTIVEFRAME : NCPF_INACTIVEFRAME, NULL, NULL );
        MsgHandled(ptm);
    }

    return lRet;
}

//-------------------------------------------------------------------------//
BOOL CThemeWnd::ShouldTrackFrameButton( UINT uHitcode )
{
    switch(uHitcode)
    {
        case HTHELP:
            return TESTFLAG(_ncwm.dwExStyle, WS_EX_CONTEXTHELP);

        case HTMAXBUTTON:
            if( !TESTFLAG(_ncwm.dwStyle, WS_MAXIMIZEBOX) || 
                 (CBS_DISABLED == _ncwm.rawMaxBtnState && FS_ACTIVE == _ncwm.framestate) )
            {
                break;
            }
            return TRUE;

        case HTMINBUTTON:
            if( !TESTFLAG(_ncwm.dwStyle, WS_MINIMIZEBOX) || 
                (CBS_DISABLED == _ncwm.rawMinBtnState && FS_ACTIVE == _ncwm.framestate) )
            {
                break;
            }
            return TRUE;

        case HTCLOSE:
            if( !_MNCanClose(_hwnd) || 
                (CBS_DISABLED == _ncwm.rawCloseBtnState && FS_ACTIVE == _ncwm.framestate) )
            {
                break;
            }
            return TRUE;

        case HTSYSMENU:
            return TESTFLAG(_ncwm.dwStyle, WS_SYSMENU);
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
//  WM_NCLBUTTONDOWN DefWindowProc msg handler
LRESULT CALLBACK OnDwpNcLButtonDown( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    WPARAM uSysCmd = 0;
    MsgHandled( ptm );

    switch( ptm->wParam /* hittest code */ )
    {
        case HTHELP:
        case HTMAXBUTTON:
        case HTMINBUTTON:
        case HTCLOSE:
        case HTSYSMENU:
            if( pwnd->ShouldTrackFrameButton(ptm->wParam) )
            {
                if( pwnd->HasRenderedNcPart(RNCF_CAPTION) )
                {
                    POINT      pt;
                    MAKEPOINT( pt, ptm->lParam );
                    if( !pwnd->TrackFrameButton( *pwnd, (int)ptm->wParam, &uSysCmd ) )
                    {
                        return DoMsgDefault( ptm );
                    }
                }
                else
                {
                    return DoMsgDefault( ptm );
                }
            }
            break;

        case HTHSCROLL:
        case HTVSCROLL:
            if( pwnd->HasRenderedNcPart(RNCF_SCROLLBAR) )
            {
                uSysCmd = ptm->wParam | ((ptm->wParam == HTVSCROLL) ? SC_HSCROLL:SC_VSCROLL);

                break;
            }

            // fall thru

        default:
            return DoMsgDefault( ptm );
    }

    // TODO USER will ignore system command if it is disabled on system menu here,
    // don't know why.  Imitating the code caused standard min/max/close buttons to
    // render so be careful.

    if( uSysCmd != 0 )
    {
        SendMessage( *pwnd, WM_SYSCOMMAND, uSysCmd, ptm->lParam );
    }

    return 0L;
}


//-------------------------------------------------------------------------//
//  WM_NCMOUSEMOVE DefWindowProc msg handler
LRESULT CALLBACK OnDwpNcMouseMove(CThemeWnd* pwnd, THEME_MSG *ptm)
{
    LRESULT lRet = DoMsgDefault(ptm);

    int htHotLast = pwnd->GetNcHotItem();
    int htHot;

    //
    // If the mouse has just entered the NC area, request
    // that we be notified when it leaves. 
    //
    if (htHotLast == HTERROR)
    {
        TRACKMOUSEEVENT tme;

        tme.cbSize      = sizeof(tme);
        tme.dwFlags     = TME_LEAVE | TME_NONCLIENT;
        tme.hwndTrack   = *pwnd;
        tme.dwHoverTime = 0;

        TrackMouseEvent(&tme);
    }

    //
    // Filter out the NC elements we don't care about hottracking. And only
    // track the element if we've previously rendered it. Some apps handle
    // painting non-client elements by handling ncpaint. They may not expect 
    // that we now hottrack.
    //
    if ( (IsHTFrameButton(ptm->wParam) && pwnd->HasRenderedNcPart(RNCF_CAPTION) && 
          pwnd->ShouldTrackFrameButton(ptm->wParam)) || 

         (IsHTScrollBar(ptm->wParam) && pwnd->HasRenderedNcPart(RNCF_SCROLLBAR)) )
    {
        htHot = (int)ptm->wParam;
    }
    else
    {
        htHot = HTNOWHERE;
    }

    //
    // anything to do?
    //
    if ((htHot != htHotLast) || IsHTScrollBar(htHot) || IsHTScrollBar(htHotLast))
    {
        POINT pt;

        MAKEPOINT( pt, ptm->lParam );

        //
        // save the hittest code of the NC element the mouse is 
        // currently over
        //
        pwnd->SetNcHotItem(htHot);

        //
        // Determine what should be repainted because the mouse
        // is no longer over it
        //
        if ( IsHTFrameButton(htHotLast) && pwnd->HasRenderedNcPart(RNCF_CAPTION) )
        {
            pwnd->TrackFrameButton(*pwnd, htHotLast, NULL, TRUE);
        }
        else if ( IsHTScrollBar(htHotLast) && pwnd->HasRenderedNcPart(RNCF_SCROLLBAR) )
        {
            ScrollBar_MouseMove(*pwnd, (htHot == htHotLast) ? &pt : NULL, (htHotLast == HTVSCROLL) ? TRUE : FALSE);
        }

        //
        // Determine what should be repainted because the mouse
        // is now over it
        //
        if ( IsHTFrameButton(htHot) && pwnd->HasRenderedNcPart(RNCF_CAPTION) )
        {
            pwnd->TrackFrameButton(*pwnd, htHot, NULL, TRUE);
        }
        else if ( IsHTScrollBar(htHot) && pwnd->HasRenderedNcPart(RNCF_SCROLLBAR) )
        {
            ScrollBar_MouseMove(*pwnd, &pt, (htHot == HTVSCROLL) ? TRUE : FALSE);
        }

    }

    return lRet;
}

//-------------------------------------------------------------------------//
//  WM_NCMOUSELEAVE DefWindowProc msg handler
LRESULT CALLBACK OnDwpNcMouseLeave(CThemeWnd* pwnd, THEME_MSG *ptm)
{
    LRESULT lRet = DoMsgDefault(ptm);

    int     htHot = pwnd->GetNcHotItem();

    //
    // the mouse has left NC area, nothing should be drawn in the
    // hot state anymore
    //
    pwnd->SetNcHotItem(HTERROR);

    if ( IsHTFrameButton(htHot) && pwnd->ShouldTrackFrameButton(htHot) &&
         pwnd->HasRenderedNcPart(RNCF_CAPTION) )
    {
        pwnd->TrackFrameButton(*pwnd, htHot, NULL, TRUE);
    }
    else if ( IsHTScrollBar(htHot) && pwnd->HasRenderedNcPart(RNCF_SCROLLBAR) )
    {
        ScrollBar_MouseMove(*pwnd, NULL, (htHot == HTVSCROLL) ? TRUE : FALSE);
    }

    return lRet;
}

//-------------------------------------------------------------------------//
//  WM_CONTEXTMENU DefWindowProc msg handler
LRESULT CALLBACK OnDwpContextMenu(CThemeWnd* pwnd, THEME_MSG *ptm)
{
    NCWNDMET*  pncwm;
    POINT      pt;
    MAKEPOINT( pt, ptm->lParam );
    MsgHandled( ptm );

    if( pwnd->GetNcWindowMetrics( NULL, &pncwm, NULL, 0 ) )
    {
        if ( TESTFLAG(pncwm->dwExStyle, WS_EX_LAYOUTRTL) )
        {
            // mirror the point to hittest correctly
            MIRROR_POINT(pncwm->rcS0[NCRC_WINDOW], pt);
        }

        if( _StrictPtInRect( &pncwm->rcS0[NCRC_HSCROLL], pt ) )
        {
            ScrollBar_Menu(*pwnd, *pwnd, ptm->lParam, FALSE);
            return 0;
        }

        if( _StrictPtInRect( &pncwm->rcS0[NCRC_VSCROLL], pt ) )
        {
            ScrollBar_Menu(*pwnd, *pwnd, ptm->lParam, TRUE);
            return 0;
        }
    }

    return DoMsgDefault( ptm );
}

//-------------------------------------------------------------------------//
//  WM_SYSCOMMAND DefWindowProc msg handler
LRESULT CALLBACK OnDwpSysCommand( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = 0L;

    switch( ptm->wParam & ~0x0F )
    {
        //  Handle scroll commands
        case SC_VSCROLL:
        case SC_HSCROLL:
            HandleScrollCmd( *pwnd, ptm->wParam, ptm->lParam );
            MsgHandled( ptm );
            return lRet;
    }
    return DoMsgDefault( ptm );
}

//-------------------------------------------------------------------------//
//  MDI menubar button theme/untheme wrapper
void CThemeWnd::ThemeMDIMenuButtons( BOOL fTheme, BOOL fRedraw )
{
    //  Verify we're an MDI frame with a maximized mdi child
    if( _hwndMDIClient && !IsWindowInDestroy(_hwndMDIClient) )
    {
        BOOL fMaxed = FALSE;
        HWND hwndActive = _MDIGetActive( _hwndMDIClient, &fMaxed );
    
        if( hwndActive && fMaxed )
        {
            ModifyMDIMenubar(fTheme, fRedraw );
        }
    }
}

//-------------------------------------------------------------------------//
//  MDI menubar button theme/untheme worker
void CThemeWnd::ModifyMDIMenubar( BOOL fTheme, BOOL fRedraw )
{
    _fThemedMDIBtns = FALSE;

    if( IsFrameThemed() || !fTheme )
    {
        MENUBARINFO mbi;
        mbi.cbSize = sizeof(mbi);

        if( GetMenuBarInfo( _hwnd, OBJID_MENU, 0, &mbi ) )
        {
            _NcTraceMsg( NCTF_MDIBUTTONS, TEXT("ModifyMDIMenubar: GetMenuBarInfo() returns hMenu: %08lX, hwndMenu: %08lX"), mbi.hMenu, mbi.hwndMenu );

            int cItems = GetMenuItemCount( mbi.hMenu );
            int cThemedItems = 0;
            int cRedraw = 0;

            _NcTraceMsg( NCTF_MDIBUTTONS, TEXT("ModifyMDIMenubar: on entry, GetMenuItemCount(hMenu = %08lX) returns %d"), mbi.hMenu, cItems );

            if( cItems > 0 )
            {
                for( int i = cItems - 1; i >= 0 && cThemedItems < MDIBTNCOUNT; i-- )
                {
                    MENUITEMINFO mii;
                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_ID|MIIM_STATE|MIIM_FTYPE|MIIM_BITMAP;

                    if( GetMenuItemInfo( mbi.hMenu, i, TRUE, &mii ) )
                    {
                        _NcTraceMsg( NCTF_MDIBUTTONS, TEXT("GetMenuItemInfo by pos (%d) returns ID %04lX"), i, mii.wID );

                        switch( mii.wID )
                        {
                            case SC_RESTORE:
                            case SC_MINIMIZE:
                            case SC_CLOSE:
                            {
                                BOOL fThemed = TESTFLAG(mii.fType, MFT_OWNERDRAW);
                                if( (fThemed && fTheme) || (fThemed == fTheme) )
                                {
                                    cThemedItems = MDIBTNCOUNT; // one item is already done, assume all to be.
                                }
                                else
                                {
                                    CMdiBtns* pBtns = LoadMdiBtns( NULL, mii.wID );
                                    if( pBtns )
                                    {
                                        if( pBtns->ThemeItem( mbi.hMenu, i, &mii, fTheme ) )
                                        {
                                            cThemedItems++;
                                            cRedraw++;
                                            _NcTraceMsg( NCTF_MDIBUTTONS, TEXT("ModifyMDIMenubar: on entry, GetMenuItemCount(hMenu = %08lX) returns %d"), mbi.hMenu, GetMenuItemCount(mbi.hMenu) );
                                        }
                                    }
                                }
                                break;
                            }
                        }
                    }
                }
            }

            if( cThemedItems )
            {
                _fThemedMDIBtns = fTheme;

                if( fRedraw && cRedraw )
                {
                    DrawMenuBar( _hwnd );
                }
            }

            _NcTraceMsg( NCTF_MDIBUTTONS, TEXT("ModifyMDIMenubar: Modified %d menu items, exiting"), cThemedItems );
        }
    }
}

//-------------------------------------------------------------------------//
BOOL CThemeWnd::_PreDefWindowProc(    
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    LRESULT *plRet )
{
    if (uMsg == WM_PRINTCLIENT)
    {
        PrintClientNotHandled(hwnd);
    }

    return FALSE;
}

//-------------------------------------------------------------------------//
BOOL CThemeWnd::_PostDlgProc(    
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    LRESULT *plRet )
{
    switch( uMsg )
    {
        case WM_PRINTCLIENT:
        {
            PrintClientNotHandled(hwnd);
        }
        break;
    }

    return FALSE;
}


//-------------------------------------------------------------------------//
//  Handles Defwindowproc post-processing for unthemed windows.
BOOL CThemeWnd::_PostWndProc( 
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    LRESULT *plRet )
{
    switch( uMsg )
    {
        //  Special-case WM_SYSCOMMAND for MDI frame window updates
        case WM_WINDOWPOSCHANGED:
            if( lParam /* don't trust this */)
            {
                _MDIUpdate( hwnd, ((WINDOWPOS*) lParam)->flags);
            }
            break;

        case WM_MDISETMENU:
        {
            HWND hwndActive = _MDIGetActive(hwnd);
            if( hwndActive )
                _MDIChildUpdateParent( hwndActive, TRUE );
            break;
        }
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
//  WM_CREATE post-wndproc msg handler
LRESULT CALLBACK OnOwpPostCreate( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if( -1 != ptm->lRet )
    {
        if( pwnd->TestCF( TWCF_FRAME|TWCF_TOOLFRAME ))
        {
            DWORD dwFTFlags = FTF_CREATE;
            CREATESTRUCT* pcs = (CREATESTRUCT*)ptm->lParam;

            if( pcs )
            {
                //  don't resize dialogs until post-WM_INITDIALOG
                if( pwnd->TestCF(TWCF_DIALOG) )
                {
                    dwFTFlags |= FTF_NOMODIFYPLACEMENT;
                }

                pwnd->SetFrameTheme( dwFTFlags, NULL );
                MsgHandled(ptm);
            }
        }
    }
    return 0L;
}

//---------------------------------------------------------------------------
//  WM_INITDIALOG post defdialogproc handler
LRESULT CALLBACK OnDdpPostInitDialog(CThemeWnd* pwnd, THEME_MSG* ptm)
{
    LRESULT lRet = ptm->lRet;

    //  Do this sequence for dialogs only
    if( pwnd->TestCF( TWCF_DIALOG ) && pwnd->TestCF( TWCF_FRAME|TWCF_TOOLFRAME ) )
    {
        DWORD dwFTFlags = FTF_CREATE;
        pwnd->SetFrameTheme( dwFTFlags, NULL );
        MsgHandled(ptm);
    }
    
    return lRet;    
}


//-------------------------------------------------------------------------//
//  WM_STYLECHANGING/WM_SYTLECHANGED Pre DefWindowProc msg handler
LRESULT CALLBACK OnOwpPreStyleChange( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    // Allow this message to arrive at detination WndProc?
    if ( pwnd->SuppressingStyleMsgs() )
    {
        MsgHandled(ptm);
        return DefWindowProc(ptm->hwnd, ptm->uMsg, ptm->wParam, ptm->lParam);
    }
    
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_SYTLECHANGED DefWindowProc msg handler
LRESULT CALLBACK OnDwpStyleChanged( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    pwnd->StyleChanged((UINT)ptm->wParam, ((STYLESTRUCT*)ptm->lParam)->styleOld, 
                                     ((STYLESTRUCT*)ptm->lParam)->styleNew );
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_SETTINGCHANGE post-wndproc handler
LRESULT CALLBACK OnOwpPostSettingChange( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    /*ignore theme setting change process refresh*/

    if( SPI_SETNONCLIENTMETRICS == ptm->wParam && !pwnd->InThemeSettingChange() )
    {
        //  recompute per-theme metrics.
        if( VALID_CRITICALSECTION(&_csThemeMet) )
        {
            EnterCriticalSection( &_csThemeMet );
     
            //  force refresh of NONCLIENTMETRICS cache.
            NcGetNonclientMetrics( NULL, TRUE );

            LeaveCriticalSection( &_csThemeMet );
        }

        pwnd->UnloadMdiBtns();

        //  recycle frame icon handle; current one is no longer valid.
        pwnd->AcquireFrameIcon( GetWindowLong(*pwnd, GWL_STYLE),
                                GetWindowLong(*pwnd, GWL_EXSTYLE), TRUE );

        //  frame windows should be invalidated.
        if( pwnd->IsFrameThemed() )
        {
            SetWindowPos( *pwnd, NULL, 0,0,0,0, SWP_DRAWFRAME|
                          SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE );
        }
    }
    
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_SETTEXT DefWindowProc msg handler
LRESULT CALLBACK OnDwpSetText( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = 0L;
    if( pwnd->IsFrameThemed() )
    {
        //  prevent ourselves from painting as we call on RealDefWindowProc()
        //  to cache the new window text.
        pwnd->LockRedraw( TRUE );
        lRet = DoMsgDefault(ptm);
        pwnd->LockRedraw( FALSE );
    }
    return lRet;
}

//-------------------------------------------------------------------------//
//  WM_SETICON DefWindowProc msg handler
LRESULT CALLBACK OnDwpSetIcon( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = 0L;

    //  invalidate our app icon handle, force re-acquire.
    pwnd->SetFrameIcon(NULL);

    //  call on RealDefWindowProc to cache the icon
    lRet = DoMsgDefault( ptm );

    //  RealDefWindowProc won't call send a WM_NCUAHDRAWCAPTION for large icons
    if( ICON_BIG == ptm->wParam && pwnd->IsFrameThemed() )
    {
        NCWNDMET* pncwm;
        if( pwnd->GetNcWindowMetrics( NULL, &pncwm, NULL, NCWMF_RECOMPUTE ) )
        {
            HDC hdc = _GetNonclientDC( *pwnd, NULL );
            if( hdc )
            {
                DTBGOPTS dtbo;
                dtbo.dwSize = sizeof(dtbo);
                dtbo.dwFlags = DTBG_DRAWSOLID;
            
                pwnd->NcPaintCaption( hdc, pncwm, TRUE, (DWORD)DC_ICON, &dtbo );
                ReleaseDC( *pwnd, hdc );
            }
        }
    }
    return lRet;
}

//-------------------------------------------------------------------------//
#define NCPREV_CLASS TEXT("NCPreviewFakeWindow")

//-------------------------------------------------------------------------//
BOOL _fPreviewSysMetrics = FALSE;

//-------------------------------------------------------------------------//
void _NcSetPreviewMetrics( BOOL fPreview )
{
    BOOL fPrev = _fPreviewSysMetrics;
    _fPreviewSysMetrics = fPreview;
    
    if( fPreview != fPrev ) 
    {
        // make sure we reset button metrics if something has changed    
        _fClassicNcBtnMetricsReset = TRUE;
    }
}

//-------------------------------------------------------------------------//
inline BOOL _NcUsingPreviewMetrics()
{
    return _fPreviewSysMetrics;
}

//-------------------------------------------------------------------------//
BOOL NcGetNonclientMetrics( OUT OPTIONAL NONCLIENTMETRICS* pncm, BOOL fRefresh )
{
    BOOL fRet = FALSE;
    CInternalNonclientMetrics *pincm = NULL;

    if( VALID_CRITICALSECTION(&_csNcSysMet) )
    {
        EnterCriticalSection( &_csNcSysMet );

        //  Feed off a static instance of NONCLIENTMETRICS to reduce call overhead.
        if( _NcUsingPreviewMetrics() )
        {
            //  hand off preview metrics and get out.
            pincm = &_incmPreview;
        }
        else 
        {
            if( _incmCurrent.Acquire( fRefresh ) )
            {
                pincm = &_incmCurrent;
            }
        }

        if( pincm )
        {
            if( pncm )
            {
                *pncm = pincm->GetNcm();
            }
            fRet = TRUE;
        }

        LeaveCriticalSection( &_csNcSysMet );
    }

    return fRet;
}

//-------------------------------------------------------------------------//
HFONT NcGetCaptionFont( BOOL fSmallCaption )
{
    HFONT hf = NULL;
    if( VALID_CRITICALSECTION(&_csNcSysMet) )
    {
        EnterCriticalSection( &_csNcSysMet );

        hf = _NcUsingPreviewMetrics() ? _incmPreview.GetFont( fSmallCaption ) : 
                                        _incmCurrent.GetFont( fSmallCaption );
    
        LeaveCriticalSection( &_csNcSysMet );
    }
    return hf;
}

//-------------------------------------------------------------------------//
void NcClearNonclientMetrics()
{
    _incmCurrent.Clear();
}


//-------------------------------------------------------------------------//
int NcGetSystemMetrics(int nIndex)
{
    if( _NcUsingPreviewMetrics() )
    {
        int iValue;
        const NONCLIENTMETRICS& ncmPreview = _incmPreview.GetNcm();

        switch (nIndex)
        {
            case SM_CXHSCROLL:  // fall through
            case SM_CXVSCROLL:  iValue = ncmPreview.iScrollWidth;  break;
            case SM_CYHSCROLL:  // fall through
            case SM_CYVSCROLL:  iValue = ncmPreview.iScrollHeight;  break;

            case SM_CXSIZE:     iValue = ncmPreview.iCaptionWidth;  break;
            case SM_CYSIZE:     iValue = ncmPreview.iCaptionHeight;  break;
            case SM_CYCAPTION:  iValue = ncmPreview.iCaptionHeight + 1;  break;
            case SM_CXSMSIZE:   iValue = ncmPreview.iSmCaptionWidth;  break;
            case SM_CYSMSIZE:   iValue = ncmPreview.iSmCaptionHeight;  break;
            case SM_CXMENUSIZE: iValue = ncmPreview.iMenuWidth;  break;
            case SM_CYMENUSIZE: iValue = ncmPreview.iMenuHeight;  break;
            
            default:            iValue = ClassicGetSystemMetrics(nIndex); break;
        }
        return iValue;
    }
    else
    {
        return ClassicGetSystemMetrics(nIndex);
    }
}

//-------------------------------------------------------------------------//
//  _InternalGetSystemMetrics() - Themed implementation of GetSystemMetrics().
//
int _InternalGetSystemMetrics( int iMetric, BOOL& fHandled )
{
    int         iRet = 0;
    int*        plSysMet = NULL;
    NCTHEMEMET  nctm;

    switch( iMetric )
    {
        case SM_CXSIZE:
            plSysMet = &nctm.theme_sysmets.cxBtn; break;

        case SM_CXSMSIZE:
            plSysMet = &nctm.theme_sysmets.cxSmBtn; break;
    }

    if( plSysMet &&
        GetCurrentNcThemeMetrics( &nctm ) && nctm.hTheme != NULL && 
        nctm.theme_sysmets.fValid )
    {
        iRet = *plSysMet;
        fHandled = TRUE; /*was missing (doh! - 408190)*/
    }

    return iRet;
}

//-------------------------------------------------------------------------//
//  _InternalSystemParametersInfo() - Themed implementation of SystemParametersInfo().
//  
//  return value of FALSE interpreted by caller as not handled.
BOOL _InternalSystemParametersInfo( 
    IN UINT uiAction, 
    IN UINT uiParam, 
    IN OUT PVOID pvParam, 
    IN UINT fWinIni,
    IN BOOL fUnicode,
    BOOL& fHandled )
{
    SYSTEMPARAMETERSINFO pfnDefault = 
                fUnicode ? ClassicSystemParametersInfoW : ClassicSystemParametersInfoA;\

    BOOL fRet = pfnDefault( uiAction, uiParam, pvParam, fWinIni );
    fHandled = TRUE;

    if( SPI_GETNONCLIENTMETRICS == uiAction && fRet )
    {
        NCTHEMEMET nctm;
        if( GetCurrentNcThemeMetrics( &nctm ) && nctm.hTheme != NULL && nctm.theme_sysmets.fValid )
        {
            NONCLIENTMETRICS* pncm = (NONCLIENTMETRICS*)pvParam;
            pncm->iCaptionWidth = nctm.theme_sysmets.cxBtn;
        }
    }
    return fRet;
}

//-------------------------------------------------------------------------//
THEMEAPI DrawNCWindow(CThemeWnd* pThemeWnd, HWND hwndFake, HDC hdc, DWORD dwFlags, LPRECT prc, NONCLIENTMETRICS* pncm, COLORREF* prgb)
{
    // Build up Overide structure
    NCPAINTOVERIDE ncpo;
    pThemeWnd->GetNcWindowMetrics( prc, &ncpo.pncwm, &ncpo.nctm, NCWMF_RECOMPUTE|NCWMF_PREVIEW );

    // Force window to look active
    if (dwFlags & NCPREV_ACTIVEWINDOW)
    {
        ncpo.pncwm->framestate = FS_ACTIVE;
        
        ncpo.pncwm->rawCloseBtnState = 
        ncpo.pncwm->rawMaxBtnState = 
        ncpo.pncwm->rawMinBtnState = CBS_NORMAL;
     }
    ncpo.pncwm->rgbCaption = prgb[FS_ACTIVE == ncpo.pncwm->framestate ? COLOR_CAPTIONTEXT : COLOR_INACTIVECAPTIONTEXT];
    ncpo.pncwm->dwStyle &= ~WS_SIZEBOX;
    // Paint the beautiful visual styled window
    pThemeWnd->NcPaint(hdc, NCPF_DEFAULT, NULL, &ncpo);

    COLORREF rgbBk = prgb[(dwFlags & NCPREV_MESSAGEBOX) ? COLOR_3DFACE : COLOR_WINDOW];
    HBRUSH hbrBack = CreateSolidBrush(rgbBk);
    FillRect(hdc, &ncpo.pncwm->rcW0[NCRC_CLIENT], hbrBack);
    DeleteObject(hbrBack);

    WCHAR szText[MAX_PATH];
    // Draw client area

    HFONT hfont = CreateFont(-MulDiv(8, GetDeviceCaps(hdc, LOGPIXELSY), 72), 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH, L"MS Shell Dlg");
    if (hfont)
    {
        if (dwFlags & NCPREV_MESSAGEBOX)
        {
            HTHEME htheme = OpenThemeData( hwndFake, L"Button" );
            int offsetX = ((ncpo.pncwm->rcW0[NCRC_CLIENT].right + ncpo.pncwm->rcW0[NCRC_CLIENT].left) / 2) - 40;
            int offsetY = ((ncpo.pncwm->rcW0[NCRC_CLIENT].bottom + ncpo.pncwm->rcW0[NCRC_CLIENT].top) / 2) - 15;
            RECT rcButton = { offsetX, offsetY, offsetX + 80, offsetY + 30 };
            NcDrawThemeBackground(htheme, hdc, BP_PUSHBUTTON, PBS_DEFAULTED, &rcButton, 0);
            RECT rcContent;
            GetThemeBackgroundContentRect(htheme, hdc, BP_PUSHBUTTON, PBS_DEFAULTED, &rcButton, &rcContent);
            LoadString(g_hInst, IDS_OKBUTTON, szText, ARRAYSIZE(szText));
            if (szText[0])
            {
                HFONT hfontOld = (HFONT)SelectObject(hdc, hfont);
                DrawThemeText(htheme, hdc, BP_PUSHBUTTON, PBS_DEFAULTED, szText, lstrlen(szText), DT_CENTER | DT_VCENTER | DT_SINGLELINE, 0, &rcContent);
                SelectObject(hdc, hfontOld);
            }
            CloseThemeData(htheme);
        }
        else if (dwFlags & NCPREV_ACTIVEWINDOW)
        {
            HTHEME htheme = OpenThemeData( hwndFake, L"Button" );
            RECT rcButton = ncpo.pncwm->rcW0[NCRC_CLIENT];
            LoadString(g_hInst, IDS_WINDOWTEXT, szText, ARRAYSIZE(szText));
            if (szText[0])
            {
                HFONT hfontOld = (HFONT)SelectObject(hdc, hfont);
                DTTOPTS DttOpts = {sizeof(DttOpts)};
                DttOpts.dwFlags = DTT_TEXTCOLOR;
                DttOpts.crText = prgb[COLOR_WINDOWTEXT];

                DrawThemeTextEx(htheme, hdc, BP_PUSHBUTTON, PBS_DEFAULTED, szText, lstrlen(szText), DT_SINGLELINE, &rcButton, &DttOpts);
                SelectObject(hdc, hfontOld);
            }
            CloseThemeData(htheme);
        }
    }
    DeleteObject(hfont);


    ClearNcThemeMetrics(&ncpo.nctm);

    return S_OK;
}

//-------------------------------------------------------------------------//
THEMEAPI DrawNCPreview(HDC hdc, DWORD dwFlags, LPRECT prc, LPCWSTR pszVSPath, LPCWSTR pszVSColor, LPCWSTR pszVSSize, NONCLIENTMETRICS* pncm, COLORREF* prgb)
{
    WNDCLASS wc;

    // Create a fake Window and attach NC themeing to it
    if (!GetClassInfo(g_hInst, NCPREV_CLASS, &wc)) {
        wc.style = 0;
        wc.lpfnWndProc = DefWindowProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = g_hInst;
        wc.hIcon = NULL;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_3DFACE+1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = NCPREV_CLASS;

        if (!RegisterClass(&wc))
            return FALSE;
    }

    _incmPreview = *pncm;
    _incmPreview._fPreview = TRUE;
    _NcSetPreviewMetrics( TRUE );
    
    DWORD dwExStyle = WS_EX_DLGMODALFRAME | ((dwFlags & NCPREV_RTL) ? WS_EX_RTLREADING : 0);
    HWND hwndFake = CreateWindowEx(dwExStyle, NCPREV_CLASS, L"", 0, 0, 0, RECTWIDTH(prc), RECTHEIGHT(prc), NULL, NULL, g_hInst, NULL);

    if (hwndFake)
    {
        HTHEMEFILE htFile = NULL;

        WCHAR szCurVSPath[MAX_PATH];
        WCHAR szCurVSColor[MAX_PATH];
        WCHAR szCurVSSize[MAX_PATH];

        GetCurrentThemeName(szCurVSPath, ARRAYSIZE(szCurVSPath), szCurVSColor, ARRAYSIZE(szCurVSColor), szCurVSSize, ARRAYSIZE(szCurVSSize));

        if ((lstrcmp(szCurVSPath,  pszVSPath) != 0) ||
            (lstrcmp(szCurVSColor, pszVSColor) != 0) ||
            (lstrcmp(szCurVSSize,  pszVSSize) != 0))
        {
            HRESULT hr = OpenThemeFile(pszVSPath, pszVSColor, pszVSSize, &htFile, FALSE);
            if (SUCCEEDED(hr))
            {
                //---- first, detach from the normal theme ----
                CThemeWnd::Detach(hwndFake, FALSE);

                //---- apply the preview theme ----
                hr = ApplyTheme(htFile, 0, hwndFake); 
            }
        }

        //---- attach to the preview theme ----
        CThemeWnd* pThemeWnd = CThemeWnd::Attach(hwndFake);

        if (VALID_THEMEWND(pThemeWnd))
        {
            struct {
                DWORD dwNcPrev;
                UINT uIDStr;
                DWORD dwFlags;
                RECT rc;
            } fakeWindow[]= {   {NCPREV_INACTIVEWINDOW, IDS_INACTIVEWINDOW, 0,                                       { prc->left, prc->top, prc->right - 17, prc->bottom - 20 }},
                                {NCPREV_ACTIVEWINDOW,   IDS_ACTIVEWINDOW,   NCPREV_ACTIVEWINDOW,                     { prc->left + 10, prc->top + 22, prc->right, prc->bottom }},
                                {NCPREV_MESSAGEBOX,     IDS_MESSAGEBOX,     NCPREV_ACTIVEWINDOW | NCPREV_MESSAGEBOX, { prc->left + (RECTWIDTH(prc)/2) - 75, prc->top + (RECTHEIGHT(prc)/2) - 50 + 22,
                                        prc->left + (RECTWIDTH(prc)/2) + 75, prc->top + (RECTHEIGHT(prc)/2) + 50 + 22}}};

            WCHAR szWindowName[MAX_PATH];
            for (int i = 0; i < ARRAYSIZE(fakeWindow); i++)
            {
                if (dwFlags & fakeWindow[i].dwNcPrev)
                {
                    LoadString(g_hInst, fakeWindow[i].uIDStr, szWindowName, ARRAYSIZE(szWindowName));
                    SetWindowText(hwndFake, szWindowName);
                    
                    if (fakeWindow[i].dwNcPrev & NCPREV_MESSAGEBOX)
                    {
                        SetWindowLongPtr(hwndFake, GWL_STYLE, WS_TILED | WS_CAPTION | WS_SYSMENU);
                    }
                    else
                    {
                        SetWindowLongPtr(hwndFake, GWL_STYLE, WS_TILEDWINDOW | WS_VSCROLL);
                    }

                    DrawNCWindow(pThemeWnd, hwndFake, hdc, fakeWindow[i].dwFlags, &fakeWindow[i].rc, pncm, prgb);
                }
            }

            // Clean Up
            CThemeWnd::Detach(hwndFake, 0);
        }

        if (htFile)
        {
            CloseThemeFile(htFile);
            
            //---- clear the preview hold on the theme file ----
            ApplyTheme(NULL, 0, hwndFake); 
        }

        DestroyWindow(hwndFake);
    }

    _NcSetPreviewMetrics( FALSE );
    _incmPreview.Clear();
    return S_OK;
}

//-------------------------------------------------------------------------//
//  CMdiBtns impl
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
//  ctor
CMdiBtns::CMdiBtns()
{
    ZeroMemory( _rgBtns, sizeof(_rgBtns) );
    _rgBtns[0].wID = SC_CLOSE;
    _rgBtns[1].wID = SC_RESTORE;
    _rgBtns[2].wID = SC_MINIMIZE;
}

//-------------------------------------------------------------------------//
//  Helper: button lookup based on syscmd ID.
CMdiBtns::MDIBTN* CMdiBtns::_FindBtn( UINT wID )
{
    for( int i = 0; i < ARRAYSIZE(_rgBtns); i++ )
    {
        if( wID == _rgBtns[i].wID )
        {
            return (_rgBtns + i);
        }
    }
    return NULL;
}

//-------------------------------------------------------------------------//
//  Acquires MDI button resources,.computes metrics
BOOL CMdiBtns::Load( HTHEME hTheme, IN OPTIONAL HDC hdc, UINT uSysCmd )
{
    //  if caller wants all buttons loaded, call recursively.
    if( 0 == uSysCmd )
    {
        return Load( hTheme, hdc, SC_CLOSE ) &&
               Load( hTheme, hdc, SC_RESTORE ) &&
               Load( hTheme, hdc, SC_MINIMIZE );
    }
    
    MDIBTN* pBtn = _FindBtn( uSysCmd );
    
    if( pBtn && !VALID_WINDOWPART(pBtn->iPartId) /*only if necessary*/ )
    {
        //  select appropriate window part
        WINDOWPARTS iPartId = BOGUS_WINDOWPART;
        switch( uSysCmd )
        {
            case SC_CLOSE:      iPartId = WP_MDICLOSEBUTTON;   break;
            case SC_RESTORE:    iPartId = WP_MDIRESTOREBUTTON; break;
            case SC_MINIMIZE:   iPartId = WP_MDIMINBUTTON;     break;
        }
        
        if( VALID_WINDOWPART(iPartId) )
        {
            if( IsThemePartDefined( hTheme, iPartId, 0) )
            {
                //  Retrieve sizing type, defaulting to 'stretch'.
                if( FAILED( GetThemeInt( hTheme, iPartId, 0, TMT_SIZINGTYPE, (int*)&pBtn->sizingType ) ) )
                {
                    pBtn->sizingType = ST_STRETCH;
                }
                
                //  if 'truesize', retrieve the size.
                if( ST_TRUESIZE == pBtn->sizingType )
                {
                    //  If no DC provided, base size on screen DC of default monitor.
                    HDC hdcSize = hdc;
                    if( NULL == hdcSize )
                    {
                        hdcSize = GetDC(NULL);
                    }

                    if( FAILED( GetThemePartSize( hTheme, hdc, iPartId, 0, NULL, TS_TRUE, &pBtn->size ) ) )
                    {
                        pBtn->sizingType = ST_STRETCH;
                    }

                    if( hdcSize != hdc )
                    {
                        ReleaseDC(NULL, hdcSize);
                    }
                }

                //  not 'truesize'; use system metrics for MDI buttons
                if( pBtn->sizingType != ST_TRUESIZE )
                {
                    pBtn->size.cx = NcGetSystemMetrics( SM_CXMENUSIZE );
                    pBtn->size.cy = NcGetSystemMetrics( SM_CYMENUSIZE );
                }
                
                //  assign button attributes
                pBtn->iPartId = iPartId;
            }
        }
    }
    return pBtn != NULL && VALID_WINDOWPART(pBtn->iPartId);
}

//-------------------------------------------------------------------------//
//  Releases MDI button resources,.resets metrics
void CMdiBtns::Unload( IN OPTIONAL UINT uSysCmd )
{
    //  if caller wants all buttons unloaded, call recursively.
    if( 0 == uSysCmd )
    {
        Unload( SC_CLOSE );
        Unload( SC_RESTORE );
        Unload( SC_MINIMIZE );
        return;
    }

    MDIBTN* pBtn = _FindBtn( uSysCmd );

    if( pBtn )
    {
        SAFE_DELETE_GDIOBJ(pBtn->hbmTheme);
        ZeroMemory(pBtn, sizeof(*pBtn));
        
        // restore our zeroed syscommand value
        pBtn->wID = uSysCmd;
    }
}

//-------------------------------------------------------------------------//
//  Theme/untheme MDI frame menubar's Minimize, Restore, Close menu items.
BOOL CMdiBtns::ThemeItem( HMENU hMenu, int iPos, MENUITEMINFO* pmii, BOOL fTheme )
{
    //  To theme, we simply make the item owner draw.  To untheme,
    //  we restore it to system-drawn.
    BOOL fRet = FALSE;
    MDIBTN* pBtn = _FindBtn( pmii->wID );

    if( pBtn && pmii && hMenu )
    {
        if( fTheme )
        {
            //  save off previous menuitem type, bitmap
            pBtn->fTypePrev = pmii->fType;
            pBtn->hbmPrev   = pmii->hbmpItem;

            pmii->fType    &= ~MFT_BITMAP;
            pmii->fType    |= MFT_OWNERDRAW|MFT_RIGHTJUSTIFY;
            pmii->hbmpItem  = NULL;
        }
        else
        {
            //  restore menuitem type, bitmap
            pmii->fType = pBtn->fTypePrev|MFT_RIGHTJUSTIFY /*409042 - force right-justify on the way out*/;
            pmii->hbmpItem = pBtn->hbmPrev;
        }
        
        pmii->fMask = MIIM_FTYPE;

        fRet = SetMenuItemInfo( hMenu, iPos, TRUE, pmii );

        if( !fRet || !fTheme )
        {
            pBtn->fTypePrev = 0;
            pBtn->hbmPrev = NULL;
        }
    }
    return fRet;
}

//-------------------------------------------------------------------------//
//  Computes button state identifier from Win32 owner draw state
CLOSEBUTTONSTATES CMdiBtns::_CalcState( ULONG ulOwnerDrawAction, ULONG ulOwnerDrawState )
{
    CLOSEBUTTONSTATES iStateId = CBS_NORMAL;

    if( TESTFLAG(ulOwnerDrawState, ODS_DISABLED|ODS_GRAYED|ODS_INACTIVE) )
    {
        iStateId = CBS_DISABLED;
    }
    else if( TESTFLAG(ulOwnerDrawState, ODS_SELECTED) )
    {
        iStateId = CBS_PUSHED;
    }
    else if( TESTFLAG(ulOwnerDrawState, ODS_HOTLIGHT) )
    {
        iStateId = CBS_HOT;
    }
    return iStateId;
}

//-------------------------------------------------------------------------//
//  MDI sys button WM_DRAWITEM handler
BOOL CMdiBtns::Measure( HTHEME hTheme, MEASUREITEMSTRUCT* pmis )
{
    MDIBTN* pBtn = _FindBtn( pmis->itemID );

    if( pBtn && VALID_WINDOWPART(pBtn->iPartId) )
    {
        pmis->itemWidth  = pBtn->size.cx;
        pmis->itemHeight = pBtn->size.cy;
        return TRUE;
    }

    return FALSE;
}

//-------------------------------------------------------------------------//
//  MDI sys button WM_DRAWITEM handler
BOOL CMdiBtns::Draw( HTHEME hTheme, DRAWITEMSTRUCT* pdis )
{
    MDIBTN* pBtn = _FindBtn( pdis->itemID );

    if( pBtn && VALID_WINDOWPART(pBtn->iPartId) )
    {
        return SUCCEEDED(NcDrawThemeBackground( 
            hTheme, pdis->hDC, pBtn->iPartId, _CalcState( pdis->itemAction, pdis->itemState ), &pdis->rcItem, 0 ));
    }
    return FALSE;
}

//-------------------------------------------------------------------------////
//  "Comments?" link in caption bar, known as the PHellyar (lame) button
//-------------------------------------------------------------------------//
#ifdef LAME_BUTTON

//-------------------------------------------------------------------------//
WCHAR   g_szLameText[50] = {0};

//-------------------------------------------------------------------------//
#define SZ_LAMETEXT_SUBKEY      TEXT("Control Panel\\Desktop")
#define SZ_LAMETEXT_VALUE       TEXT("LameButtonText")
#define SZ_LAMETEXT_DEFAULT     TEXT("Comments?")
#define CLR_LAMETEXT            RGB(91, 171, 245)

//-------------------------------------------------------------------------//
void InitLameText()
{
    CCurrentUser hkeyCurrentUser(KEY_READ);
    HKEY         hkLame;
    HRESULT      hr = E_FAIL;


    if ( RegOpenKeyEx(hkeyCurrentUser, SZ_LAMETEXT_SUBKEY, 0, KEY_QUERY_VALUE, &hkLame) == ERROR_SUCCESS )
    {
        hr = RegistryStrRead(hkLame, SZ_LAMETEXT_VALUE, g_szLameText, ARRAYSIZE(g_szLameText));
        RegCloseKey(hkLame);
    }

    if ( FAILED(hr) )
    {
        StringCchCopyW(g_szLameText, ARRAYSIZE(g_szLameText), SZ_LAMETEXT_DEFAULT);
    }
}

//-------------------------------------------------------------------------//
VOID CThemeWnd::InitLameResources()
{
    //
    // Using GetWindowInfo here bc GetWindowLong masks 
    // out the WS_EX_LAMEBUTTON bit.
    //
    SAFE_DELETE_GDIOBJ(_hFontLame);

    WINDOWINFO wi = {0};

    wi.cbSize = sizeof(wi);
    if ( GetWindowInfo(_hwnd, &wi) && TESTFLAG(wi.dwExStyle, WS_EX_LAMEBUTTON) )
    {
        SIZE    sizeLame;
        HFONT   hfCaption = NcGetCaptionFont(TESTFLAG(wi.dwExStyle, WS_EX_TOOLWINDOW));

        if( hfCaption != NULL )
        {
            LOGFONT lfLame;
            if( GetObject( hfCaption, sizeof(lfLame), &lfLame ) )
            {
                lfLame.lfHeight    -= (lfLame.lfHeight > 0) ? 2 : -2;
                lfLame.lfUnderline = TRUE;
                lfLame.lfWeight    = FW_THIN;

                HFONT hFontLame = CreateFontIndirect(&lfLame);
                if ( hFontLame != NULL )
                {
                    HDC hdc = GetWindowDC(_hwnd);

                    if ( hdc != NULL )
                    {
                        SelectObject(hdc, hFontLame);

                        if (GetTextExtentPoint32(hdc, g_szLameText, lstrlen(g_szLameText), &sizeLame))
                        {
                            _hFontLame = hFontLame;
                            hFontLame = NULL;           // don't free at end of this function
                            _sizeLame = sizeLame;
                        }

                        ReleaseDC(_hwnd, hdc);
                    }
                }

                if (hFontLame)       // didn't assign this font
                    DeleteObject(hFontLame);
            }
        }
    }

}


//-------------------------------------------------------------------------//
VOID CThemeWnd::ClearLameResources()
{
    SAFE_DELETE_GDIOBJ(_hFontLame);
    ZeroMemory( &_sizeLame, sizeof(_sizeLame) );
}


//-------------------------------------------------------------------------//
inline VOID CThemeWnd::DrawLameButton(HDC hdc, IN const NCWNDMET* pncwm)
{
    if ( TESTFLAG(pncwm->dwExStyle, WS_EX_LAMEBUTTON) && _hFontLame )
    {
        Log(LOG_RFBUG, L"DrawLameButton; _hFontLame=0x%x", _hFontLame);

        HFONT    hFontSave = (HFONT)SelectObject(hdc, _hFontLame);
        COLORREF clrSave = SetTextColor(hdc, CLR_LAMETEXT);

        DrawText(hdc, g_szLameText, lstrlen(g_szLameText), (LPRECT)&pncwm->rcW0[NCRC_LAMEBTN], 
                 DT_LEFT | DT_SINGLELINE);

        SetTextColor(hdc, clrSave);
        SelectObject(hdc, hFontSave);
    }
}

//-------------------------------------------------------------------------//
VOID CThemeWnd::GetLameButtonMetrics( NCWNDMET* pncwm, const SIZE* psizeCaption )
{
    if( TESTFLAG(pncwm->dwExStyle, WS_EX_LAMEBUTTON) && _hFontLame )
    {
        BOOL  fLameOn;
        RECT  rcCaptionText = pncwm->rcS0[NCRC_CAPTIONTEXT];
        RECT* prcButton = &pncwm->rcS0[NCRC_LAMEBTN];
        int   cxPad = NcGetSystemMetrics(SM_CXEDGE) * 2;
        
        // Enough room to draw the lame button link?
        fLameOn = RECTWIDTH(&rcCaptionText) > 
                        psizeCaption->cx + 
                        cxPad + // between caption, lame text
                        _sizeLame.cx + 
                        cxPad; // between lame text, nearest button;

        //---- compute lame button alignment ----
        BOOL fReverse = TRUE;           // normally, lame goes on right side

        //---- WS_EX_RIGHT wants the opposite ----
        if (TESTFLAG(_ncwm.dwExStyle, WS_EX_RIGHT))
            fReverse = FALSE;

        DWORD dwFlags = GetTextAlignFlags(_hTheme, &_ncwm, fReverse);

        //---- turn off lame button for center captions ----
        if (dwFlags & DT_CENTER)
            fLameOn = FALSE;

        if ( fLameOn )
        {
            CopyRect(prcButton, &rcCaptionText);

            //---- note: pMargins already includes the theme specified ----
            //---- CaptionMargins (which scale with DPI) and the ----
            //---- icon and buttons widths ----

            if(dwFlags & DT_RIGHT)       // put lame on right
            {
                prcButton->left = (prcButton->right - _sizeLame.cx) - cxPad ;

                //---- adjust margins to remove lame area ----
                pncwm->CaptionMargins.cxRightWidth -= _sizeLame.cx;
            }
            else                        // put lame on left
            {
                prcButton->right = (prcButton->left + _sizeLame.cx) + cxPad;

                //---- adjust margins to remove lame area ----
                pncwm->CaptionMargins.cxLeftWidth += _sizeLame.cx;
            }

            //  vertically center the text between margins
            prcButton->top     += (RECTHEIGHT(&rcCaptionText) - _sizeLame.cy)/2;
            prcButton->bottom  =  prcButton->top + _sizeLame.cy;
        }
    }
}

#endif // LAME_BUTTON


#ifdef DEBUG
//-------------------------------------------------------------------------//
void CDECL _NcTraceMsg( ULONG uFlags, LPCTSTR pszFmt, ...)
{
    if( TESTFLAG(_NcTraceFlags, uFlags) || NCTF_ALWAYS == uFlags )
    {
        va_list args;
        va_start(args, pszFmt);

        TCHAR szSpew[2048];
        StringCchPrintf(szSpew, ARRAYSIZE(szSpew), pszFmt, args);
        OutputDebugString(szSpew);
        OutputDebugString(TEXT("\n"));

        va_end(args);
    }
}

//-------------------------------------------------------------------------//
void INIT_THEMEWND_DBG( CThemeWnd* pwnd )
{
    if( IsWindow( *pwnd ) )
    {
        GetWindowText( *pwnd, pwnd->_szCaption, ARRAYSIZE(pwnd->_szCaption) );
        GetClassName( *pwnd, pwnd->_szWndClass, ARRAYSIZE(pwnd->_szWndClass) );
    }
}

//-------------------------------------------------------------------------//
void CThemeWnd::Spew( DWORD dwSpewFlags, LPCTSTR pszFmt, LPCTSTR pszClassList )
{
    if( pszClassList && *pszClassList )
    {
        if( !_tcsstr( pszClassList, _szWndClass ) )
            return;
    }

    TCHAR szInfo[MAX_PATH*2];
    TCHAR szMsg[MAX_PATH*2];

    StringCchPrintf( szInfo, ARRAYSIZE(szInfo), TEXT("%08lX -'%s' ('%s') cf: %08lX"), _hwnd, _szCaption, _szWndClass, _fClassFlags );
    StringCchPrintf( szMsg, ARRAYSIZE(szMsg), pszFmt, szInfo );
    Log(LOG_NCATTACH, szMsg );
}

typedef struct
{
    DWORD dwProcessId;
    DWORD dwThreadId;
    DWORD dwSpewFlags;
    LPCTSTR pszFmt;
    LPCTSTR pszClassList;
} SPEW_ALL;

//-------------------------------------------------------------------------//
BOOL _SpewAllEnumCB( HWND hwnd, LPARAM lParam )
{
    SPEW_ALL* psa = (SPEW_ALL*)lParam;

    if( IsWindowProcess( hwnd, psa->dwProcessId ) )
    {
        CThemeWnd* pwnd = CThemeWnd::FromHwnd( hwnd );
        if( VALID_THEMEWND(pwnd) )
            pwnd->Spew( psa->dwSpewFlags, psa->pszFmt );
    }

    return TRUE;
}

//-------------------------------------------------------------------------//
void CThemeWnd::SpewAll( DWORD dwSpewFlags, LPCTSTR pszFmt, LPCTSTR pszClassList )
{
    SPEW_ALL sa;
    sa.dwThreadId  = GetCurrentThreadId();
    sa.dwProcessId = GetCurrentProcessId();
    sa.dwSpewFlags = dwSpewFlags;
    sa.pszFmt = pszFmt;
    sa.pszClassList = pszClassList;

    //---- this will enum all windows for this process (all desktops, all child levels) ----
    EnumProcessWindows( _SpewAllEnumCB, (LPARAM)&sa );
}

//-------------------------------------------------------------------------//
void CThemeWnd::SpewLeaks()
{
    if( _cObj > 0 )
    {
        Log(LOG_NCATTACH, L"LEAK WARNING: %d CThemeWnd instances outstanding.", _cObj );
    }
}

//-------------------------------------------------------------------------//
void SPEW_RECT( ULONG ulTrace, LPCTSTR pszMsg, LPCRECT prc )
{
    LPCTSTR pszFmt = TEXT("%s: {L:%d,T:%d,R:%d,B:%d}, (%d x %d)");
    WCHAR   szMsg[1024];

    StringCchPrintfW( szMsg, ARRAYSIZE(szMsg), pszFmt, pszMsg,
               prc->left, prc->top, prc->right, prc->bottom,
               RECTWIDTH(prc), RECTHEIGHT(prc) );
    _NcTraceMsg(ulTrace, szMsg);
}

//-------------------------------------------------------------------------//
void SPEW_MARGINS( ULONG ulTrace, LPCTSTR pszMsg, 
                   LPCRECT prcParent, LPCRECT prcChild )
{
    LPCTSTR pszFmt = TEXT("%s: {L:%d,T:%d,R:%d,B:%d}");
    WCHAR   szMsg[1024];

    StringCchPrintfW( szMsg, ARRAYSIZE(szMsg), pszFmt, pszMsg,
               prcChild->left - prcParent->left,
               prcChild->top  - prcParent->top,
               prcParent->right - prcChild->right,
               prcParent->bottom - prcChild->bottom );
    _NcTraceMsg(ulTrace, szMsg);
}


//-------------------------------------------------------------------------//
void SPEW_RGNRECT( ULONG ulTrace, LPCTSTR pszMsg, HRGN hrgn, int iPartID )
{
    RECT rc;
    if( NULLREGION == GetRgnBox( hrgn, &rc ) )
        FillMemory( &rc, sizeof(rc), static_cast<UCHAR>(-1) );
    
    _NcTraceMsg( ulTrace, TEXT("Region %08lX for partID[%d]:\n\t"), hrgn, iPartID );
    SPEW_RECT( ulTrace, pszMsg, &rc );
}

//-------------------------------------------------------------------------//
void SPEW_WINDOWINFO( ULONG ulTrace, WINDOWINFO* pwi )
{
    SPEW_RECT(ulTrace,   TEXT("->wi.rcWindow"), &pwi->rcWindow );
    SPEW_RECT(ulTrace,   TEXT("->wi.rcClient"), &pwi->rcClient );
    _NcTraceMsg(ulTrace, TEXT("->wi.dwStyle: %08lX"), pwi->dwStyle );
    _NcTraceMsg(ulTrace, TEXT("->wi.dwExStyle: %08lX"), pwi->dwExStyle );
    _NcTraceMsg(ulTrace, TEXT("->wi.dwWindowStatus: %08lX"), pwi->dwWindowStatus );
    _NcTraceMsg(ulTrace, TEXT("->wi.cxWindowBorders: %d"), pwi->cxWindowBorders );
    _NcTraceMsg(ulTrace, TEXT("->wi.cyWindowBorders: %d"), pwi->cyWindowBorders );
}

//-------------------------------------------------------------------------//
void SPEW_NCWNDMET( ULONG ulTrace, LPCTSTR pszMsg, NCWNDMET* pncwm )
{
    _NcTraceMsg(ulTrace, TEXT("\n%s - Spewing NCWNDMET @ %08lx..."), pszMsg, pncwm );

    _NcTraceMsg(ulTrace, TEXT("->fValid:            %d"), pncwm->fValid );
    _NcTraceMsg(ulTrace, TEXT("->dwStyle:           %08lX"), pncwm->dwStyle );
    _NcTraceMsg(ulTrace, TEXT("->dwExStyle:         %08lX"), pncwm->dwExStyle );
    _NcTraceMsg(ulTrace, TEXT("->dwWindowStatus:    %08lX"), pncwm->dwWindowStatus );
    _NcTraceMsg(ulTrace, TEXT("->fFrame:            %d"), pncwm->fFrame );
    _NcTraceMsg(ulTrace, TEXT("->fSmallFrame:       %d"), pncwm->fSmallFrame );
    _NcTraceMsg(ulTrace, TEXT("->iFRAMEBOTTOM       %d"), pncwm->rgframeparts[iFRAMEBOTTOM] );
    _NcTraceMsg(ulTrace, TEXT("->iFRAMELEFT:        %d"), pncwm->rgframeparts[iFRAMELEFT] );
    _NcTraceMsg(ulTrace, TEXT("->iFRAMERIGHT:       %d"), pncwm->rgframeparts[iFRAMERIGHT] );
    _NcTraceMsg(ulTrace, TEXT("->framestate:        %d"), pncwm->framestate );
    _NcTraceMsg(ulTrace, TEXT("->iMinButtonPart:    %d"), pncwm->iMinButtonPart);
    _NcTraceMsg(ulTrace, TEXT("->iMaxButtonPart:    %d"), pncwm->iMaxButtonPart);
    _NcTraceMsg(ulTrace, TEXT("->rawCloseBtnState:  %d"), pncwm->rawCloseBtnState);
    _NcTraceMsg(ulTrace, TEXT("->rawMinBtnState:    %d"), pncwm->rawMinBtnState);
    _NcTraceMsg(ulTrace, TEXT("->rawMaxBtnState:    %d"), pncwm->rawMaxBtnState);
    _NcTraceMsg(ulTrace, TEXT("->cyMenu:            %d"), pncwm->cyMenu );
    _NcTraceMsg(ulTrace, TEXT("->cnMenuOffsetLeft:  %d"), pncwm->cnMenuOffsetLeft );
    _NcTraceMsg(ulTrace, TEXT("->cnMenuOffsetRight: %d"), pncwm->cnMenuOffsetRight );
    _NcTraceMsg(ulTrace, TEXT("->cnMenuOffsetTop:   %d"), pncwm->cnMenuOffsetTop );
    _NcTraceMsg(ulTrace, TEXT("->cnBorders:         %d"), pncwm->cnBorders );
    _NcTraceMsg(ulTrace, TEXT("->CaptionMargins: (%d,%d,%d,%d)"), pncwm->CaptionMargins );

    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_WINDOW]   "), &pncwm->rcS0[NCRC_WINDOW] );
    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_CLIENT]   "), &pncwm->rcS0[NCRC_CLIENT] );
    SPEW_MARGINS(ulTrace, TEXT("Window-Client margins"), &pncwm->rcS0[NCRC_WINDOW], &pncwm->rcS0[NCRC_CLIENT] );

    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_CONTENT]   "), &pncwm->rcS0[NCRC_CONTENT] );
    SPEW_MARGINS(ulTrace, TEXT("Window-Content margins"), &pncwm->rcS0[NCRC_WINDOW], &pncwm->rcS0[NCRC_CONTENT]);

    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_MENUBAR]   "), &pncwm->rcS0[NCRC_MENUBAR] );
    SPEW_MARGINS(ulTrace, TEXT("Window-Menubar margins"), &pncwm->rcS0[NCRC_WINDOW], &pncwm->rcS0[NCRC_MENUBAR]);

    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_CAPTION]   "), &pncwm->rcS0[NCRC_CAPTION] ); 
    SPEW_MARGINS(ulTrace, TEXT("Window-Caption margins"), &pncwm->rcS0[NCRC_WINDOW], &pncwm->rcS0[NCRC_CAPTION]);

    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_FRAMELEFT] "), &pncwm->rcS0[NCRC_FRAMELEFT] );
    SPEW_MARGINS(ulTrace, TEXT("Window-FrameLeft margins"), &pncwm->rcS0[NCRC_WINDOW], &pncwm->rcS0[NCRC_FRAMELEFT]);

    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_FRAMERIGHT]"), &pncwm->rcS0[NCRC_FRAMERIGHT] );
    SPEW_MARGINS(ulTrace, TEXT("Window-FrameRight margins"), &pncwm->rcS0[NCRC_WINDOW], &pncwm->rcS0[NCRC_FRAMERIGHT]);

    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_FRAMEBOTTOM]"), &pncwm->rcS0[NCRC_FRAMEBOTTOM] );
    SPEW_MARGINS(ulTrace, TEXT("Window-FrameBottom margins"), &pncwm->rcS0[NCRC_WINDOW], &pncwm->rcS0[NCRC_FRAMEBOTTOM]);

    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_CLIENTEDGE]"), &pncwm->rcS0[NCRC_CLIENTEDGE] );
    SPEW_MARGINS(ulTrace, TEXT("Window-ClientEdge margins"), &pncwm->rcS0[NCRC_WINDOW], &pncwm->rcS0[NCRC_CLIENTEDGE]);
    
    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_HSCROLL]   "), &pncwm->rcS0[NCRC_HSCROLL] );
    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_VSCROLL]   "), &pncwm->rcS0[NCRC_VSCROLL] );
    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_SIZEBOX]   "), &pncwm->rcS0[NCRC_SIZEBOX] );
    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_CLOSEBTN]  "), &pncwm->rcS0[NCRC_CLOSEBTN] );
    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_MINBTN]    "), &pncwm->rcS0[NCRC_MINBTN] );
    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_MAXBTN]    "), &pncwm->rcS0[NCRC_MAXBTN] );
    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_SYSBTN]    "), &pncwm->rcS0[NCRC_SYSBTN] );
    SPEW_RECT(ulTrace, TEXT("->rcS0[NCRC_HELPBTN]   "), &pncwm->rcS0[NCRC_HELPBTN] );
#ifdef LAME_BUTTON
    SPEW_RECT(ulTrace, TEXT("rcLame"), &pncwm->rcS0[NCRC_LAMEBTN] );
#endif // LAME_BUTTON
}

//-------------------------------------------------------------------------//
void SPEW_THEMEMSG( ULONG ulTrace, LPCTSTR pszMsg, THEME_MSG* ptm )
{
    _NcTraceMsg(ulTrace, TEXT("%s hwnd: %08lX, uMsg: %04lX, handled?: %d"),
                pszMsg, (ptm)->hwnd, (ptm)->uMsg, (ptm)->fHandled );
}

//-------------------------------------------------------------------------//
void SPEW_SCROLLINFO( LPCTSTR pszMsg, HWND hwnd, LPCSCROLLINFO psi )
{
#ifdef _ENABLE_SCROLL_SPEW_
    _NcTraceMsg(ulTrace, L"%s for HWND %08lX...\ncbSize: %d\nfMask: %08lX\nnMin: %d\nnMax: %d\nnPage: %d\nnPos: %d",
                pszMsg, hwnd, psi->cbSize, psi->fMask, psi->nMin, psi->nMax, psi->nPage, psi->nPos );
#endif _ENABLE_SCROLL_SPEW_
}

#if defined(DEBUG_NCPAINT)

static int _cPaintSleep = 10;

void _DebugBackground(
    HDC hdc, 
    COLORREF rgb,
    const RECT *prc )
{
    //  paint some indicator stuff
    COLORREF rgb0 = SetBkColor( hdc, rgb );
    SPEW_RECT( NCTF_ALWAYS, TEXT("\tprc"), prc );
    ExtTextOut( hdc, prc->left, prc->top, ETO_OPAQUE, prc, NULL, 0, NULL );
    Sleep(_cPaintSleep);
    SetBkColor( hdc, rgb0 );
}


//-------------------------------------------------------------------------//
HRESULT _DebugDrawThemeBackground(
    HTHEME hTheme, 
    HDC hdc, 
    int iPartId, 
    int iStateId, 
    const RECT *prc,
    OPTIONAL const RECT* prcClip )
{
    if( TESTFLAG( _NcTraceFlags, NCTF_NCPAINT ) )
    {
        _NcTraceMsg( NCTF_ALWAYS, TEXT("DrawThemeBackground( hTheme = %08lX, hdc = %08lX, iPartId = %d, iStateId = %d"),
                     hTheme, hdc, iPartId, iStateId );
        _DebugBackground( hdc, RGBDEBUGBKGND, prc );
    }

    //  paint the real background.
    HRESULT hr = DrawThemeBackground( hTheme, hdc, iPartId, iStateId, prc, prcClip );

    if( TESTFLAG( _NcTraceFlags, NCTF_NCPAINT ) )
    {
        Sleep(_cPaintSleep);
    }

    return hr;
}

//-------------------------------------------------------------------------//
HRESULT _DebugDrawThemeBackgroundEx(
    HTHEME hTheme, 
    HDC hdc, 
    int iPartId, 
    int iStateId, 
    const RECT *prc, 
    OPTIONAL const DTBGOPTS *pOptions )
{
    if( TESTFLAG( _NcTraceFlags, NCTF_NCPAINT ) )
    {
        _NcTraceMsg( NCTF_ALWAYS, TEXT("DrawThemeBackground( hTheme = %08lX, hdc = %08lX, iPartId = %d, iStateId = %d"),
                     hTheme, hdc, iPartId, iStateId );
        _DebugBackground( hdc, RGBDEBUGBKGND, prc );
    }

    //  paint the real background.
    HRESULT hr = DrawThemeBackgroundEx( hTheme, hdc, iPartId, iStateId, prc, pOptions );

    if( TESTFLAG( _NcTraceFlags, NCTF_NCPAINT ) )
    {
        Sleep(_cPaintSleep);
    }

    return hr;
}


//-------------------------------------------------------------------------//
void NcDebugClipRgn( HDC hdc, COLORREF rgbPaint )
{
    if( TESTFLAG( _NcTraceFlags, NCTF_NCPAINT ) )
    {
        HRGN hrgn = CreateRectRgn(0,0,1,1);

        if( hrgn )
        {
            if( GetClipRgn( hdc, hrgn ) > 0 )
            {
                HBRUSH hbr = CreateSolidBrush(rgbPaint);
                FillRgn( hdc, hrgn, hbr );
                DeleteObject(hbr);
                Sleep(_cPaintSleep);
            }
            DeleteObject(hrgn);
        }
    }
}

#endif //defined(DEBUG_NCPAINT)


#endif DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\nctheme.h ===
//-------------------------------------------------------------------------//
//  NCTheme.h
//-------------------------------------------------------------------------//
#ifndef __NC_THEME_H__
#define __NC_THEME_H__

#include "handlers.h"

//---------------------------------------------------------------------------//
//  Enable/disable rude message dumping
//
//---------------------------------------------------------------------------//
//#define _ENABLE_MSG_SPEW_

//---------------------------------------------------------------------------//
//  Enable/disable rude scrollinfo dumping
//
//#define _ENABLE_SCROLL_SPEW_

//---------------------------------------------------------------------------//
//  Debug CThemeWnd, critsec double deletion
#define DEBUG_THEMEWND_DESTRUCTOR

//---------------------------------------------------------------------------
//  Target window theme class flags
#define TWCF_DIALOG             0x00000001
#define TWCF_FRAME              0x00000002
#define TWCF_TOOLFRAME          0x00000004  
#define TWCF_SCROLLBARS         0x00000010
#define TWCF_CLIENTEDGE         0x00010000  // not targetted per se

#define TWCF_NCTHEMETARGETMASK  0x0000FFFF
#define TWCF_ALL    (TWCF_DIALOG|TWCF_FRAME|TWCF_TOOLFRAME|\
                     TWCF_SCROLLBARS|TWCF_CLIENTEDGE)
#define TWCF_ANY    TWCF_ALL

//---------------------------------------------------------------------------
//  per-window NC rectangle identifiers.
typedef enum _eNCWNDMETRECT
{
    #define NCRC_FIRST  NCRC_WINDOW
    NCRC_WINDOW  = 0,    //  window rect
    NCRC_CLIENT  = 1,    //  client rect
    NCRC_UXCLIENT = 2,   //  client rect, computed based on theme layout.
    NCRC_CONTENT = 3,    //  frame content area (client area + scrollbars + clientedge)
    NCRC_MENUBAR = 4,    //  menubar rect

    //  the following members should be in same sequence as eFRAMEPARTS
    NCRC_CAPTION = 5,    //  window frame caption segment
    NCRC_FRAMELEFT = 6,  //  window frame left segment
    NCRC_FRAMERIGHT = 7, //  window frame right segment
    NCRC_FRAMEBOTTOM = 8,//  window frame bottom segment
    #define NCRC_FRAMEFIRST NCRC_CAPTION
    #define NCRC_FRAMELAST  NCRC_FRAMEBOTTOM

    NCRC_CAPTIONTEXT = 9,//  caption text rect
    NCRC_CLIENTEDGE = 10,//  client edge inner rect
    NCRC_HSCROLL = 11,   //  horizontal scrollbar
    NCRC_VSCROLL = 12,   //  vertical scrollbar
    NCRC_SIZEBOX = 13,   //  gripper box
    NCRC_SYSBTN = 14,    //  system button/icon

    //  Standard frame button
    //  (followed by identically ordered MDI frame buttons!!)
    #define NCBTNFIRST    NCRC_CLOSEBTN
    NCRC_CLOSEBTN = 15,  //  close btn
    NCRC_MINBTN = 16,    //  minimize/restore button
    NCRC_MAXBTN = 17,    //  maximize/restore button
    NCRC_HELPBTN = 18,   //  help button
    #define NCBTNLAST     NCRC_HELPBTN
    #define NCBTNRECTS    ((NCBTNLAST - NCBTNFIRST)+1)

    //  MDI frame buttons for maximized MDI child 
    //  (preceeded by identically ordered standard frame buttons!!)
    #define NCMDIBTNFIRST NCRC_MDICLOSEBTN
    NCRC_MDICLOSEBTN = 19,//  MDI child close btn
    NCRC_MDIMINBTN = 20,  //  MDI child minimize/restore button
    NCRC_MDIMAXBTN = 21,  //  MDI child maximize/restore button
    NCRC_MDISYSBTN = 22,  //  MDI child system button/icon
    NCRC_MDIHELPBTN = 23, //  MDI child help button
    #define NCMDIBTNLAST  NCRC_MDIHELPBTN
    #define NCMDIBTNRECTS ((NCMDIBTNLAST- NCMDIBTNFIRST)+1)

#ifdef LAME_BUTTON
    NCRC_LAMEBTN,   //  "Comments..." (formerly "Lame...") link.
#endif LAME_BUTTON,
    
    NCRC_COUNT,     //  count of rectangles

} eNCWNDMETRECT;

//---------------------------------------------------------------------------
//  NCWNDMET::rgframeparts array indices
typedef enum _eFRAMEPARTS
{
    iCAPTION,
    iFRAMELEFT,
    iFRAMERIGHT,
    iFRAMEBOTTOM,

    cFRAMEPARTS,
} eFRAMEPARTS;

//---------------------------------------------------------------------------
//  nonclient window metrics
typedef struct _NCWNDMET
{
    //----------------------//
    //  per-window metrics
    BOOL                fValid;            //  
    BOOL                fFrame;            //  WS_CAPTION style?
    BOOL                fSmallFrame;       //  toolframe style?
    BOOL                fMin;              //  minimized.
    BOOL                fMaxed;            //  maximized
    BOOL                fFullMaxed;        //  full-screen maximized or maximized child window.
    ULONG               dwStyle;           //  WINDOWINFO::dwStyle
    ULONG               dwExStyle;         //  WINDOWINFO::dwExStyle
    ULONG               dwWindowStatus;    //  WINDOWINFO::dwWindowStatus
    ULONG               dwStyleClass;      //  style class.
    WINDOWPARTS         rgframeparts[cFRAMEPARTS];   //  rendered frame parts
    WINDOWPARTS         rgsizehitparts[cFRAMEPARTS]; //  frame resizing border hit test template parts.
    FRAMESTATES         framestate;        //  current frame & caption state
    HFONT               hfCaption;         //  Font handle for dynamically resizing caption.  This handle
                                           //  is not owned by NCWNDMET, and should not be destroyed with it.
    COLORREF            rgbCaption;        //  color of caption text.
    SIZE                sizeCaptionText;   //  size of caption text
    MARGINS             CaptionMargins;    //  Margins for in-frame caption
    int                 iMinButtonPart;    //  restore / minimize as appropriate
    int                 iMaxButtonPart;    //  restore / maximize as appropriate
    CLOSEBUTTONSTATES   rawCloseBtnState;  //  zero-relative close button state.  Final state must be computed using the MAKE_BTNSTATE macro.
    CLOSEBUTTONSTATES   rawMinBtnState;    //  zero-relative min btnstate.  Final state must be computed using the MAKE_BTNSTATE macro.  
    CLOSEBUTTONSTATES   rawMaxBtnState;    //  zero-relative max btnstate.  Final state must be computed using the MAKE_BTNSTATE macro.
    int                 cyMenu;            //  return value of CalcMenuBar or Gsm(SM_CYMENUSIZE)
    int                 cnMenuOffsetLeft;  //  left menubar margin from window edge
    int                 cnMenuOffsetRight; //  right menubar margin from window edge
    int                 cnMenuOffsetTop;   //  top menubar margin from window edge
    int                 cnBorders;         //  window border width, according to USER
    RECT                rcS0[NCRC_COUNT];  //  nonclient area component rects, screen relative coords
    RECT                rcW0[NCRC_COUNT];  //  nonclient area component rects, window relative coords
    
} NCWNDMET, *PNCWNDMET;

//---------------------------------------------------------------------------
//  nonclient part transparency bitfield
typedef struct
{
    BOOL fCaption : 1;
    BOOL fSmallCaption: 1;
    BOOL fMinCaption : 1;
    BOOL fSmallMinCaption : 1;
    BOOL fMaxCaption : 1;
    BOOL fSmallMaxCaption : 1;
    BOOL fFrameLeft : 1;
    BOOL fFrameRight : 1;
    BOOL fFrameBottom : 1;
    BOOL fSmFrameLeft : 1;
    BOOL fSmFrameRight : 1;
    BOOL fSmFrameBottom : 1;
    BOOL fReserved0 : 1;
    BOOL fReserved1 : 1;
    BOOL fReserved2 : 1;
    BOOL fReserved3 : 1;
} NCTRANSPARENCY, *PNCTRANSPARENCY;
//---------------------------------------------------------------------------
//  nonclient theme metrics
typedef struct _NCTHEMEMET
{
    HTHEME  hTheme;                // theme handle
    HTHEME  hThemeTab;             // tab's theme handle for "prop sheet" dialogs
    SIZE    sizeMinimized;         // size of minimized window
    BOOL    fCapSizingTemplate:1;     // has a caption sizing template
    BOOL    fLeftSizingTemplate:1;    // has a left frame sizing template
    BOOL    fRightSizingTemplate:1;   // has a frame right sizing template
    BOOL    fBottomSizingTemplate:1;  // has a frame bottom sizing template
    BOOL    fSmCapSizingTemplate:1;   // has a small caption sizing template
    BOOL    fSmLeftSizingTemplate:1;  // has a small left frame sizing template
    BOOL    fSmRightSizingTemplate:1; // has a small frame right sizing template
    BOOL    fSmBottomSizingTemplate:1;// has a small frame bottom sizing template
    MARGINS marCaptionText;        // margin member values of {0,0,0,0} are interpreted as default
    MARGINS marMinCaptionText;     // margin member values of {0,0,0,0} are interpreted as default
    MARGINS marMaxCaptionText;     // margin member values of {0,0,0,0} are interpreted as default
    MARGINS marSmCaptionText;      // margin member values of {0,0,0,0} are interpreted as default
    int     dyMenuBar;             // difference between SM_CYMENU and SM_CYMENUSIZE.
    int     cyMaxCaption;          // height of maximized window caption (for top/button caption only)
    int     cnSmallMaximizedWidth; // width of maximized window caption (for left/right caption only)
    int     cnSmallMaximizedHeight;// height of maximized window caption (for top/button caption only)
    SIZE    sizeBtn;               // size of normal nonclient button
    SIZE    sizeSmBtn;             // size of toolframe nonclient button
    HBRUSH  hbrTabDialog;             // brush for special tab dialogs
    HBITMAP hbmTabDialog;          // must save the bitmap to keep the brush valid
    NCTRANSPARENCY nct;            // cached transparency checks.

    struct {
        BOOL fValid;
        int  cxBtn;
        int  cxSmBtn;
    } theme_sysmets;

} NCTHEMEMET, *PNCTHEMEMET;

//---------------------------------------------------------------------------
typedef struct _NCEVALUATE
{
    //  IN params:
    BOOL    fIgnoreWndRgn;

    //  CThemeWnd::_Evaluate OUT params:
    ULONG   fClassFlags;
    ULONG   dwStyle;
    ULONG   dwExStyle;
    BOOL    fExile;
    PVOID   pvWndCompat; // optional
} NCEVALUATE, *PNCEVALUATE;

//---------------------------------------------------------------------------
//  nonclient theme metric API
BOOL    GetCurrentNcThemeMetrics( OUT NCTHEMEMET* pnctm );
HRESULT AcquireNcThemeMetrics();
BOOL    IsValidNcThemeMetrics( NCTHEMEMET* pnctm );
BOOL    ThemeNcAdjustWindowRect( NCTHEMEMET* pnctm, LPCRECT prcSrc, LPCRECT prcDest, BOOL fWantClientRect );
void    InitNcThemeMetrics( NCTHEMEMET* pnctm = NULL );
void    ClearNcThemeMetrics( NCTHEMEMET* pnctm = NULL );

//---------------------------------------------------------------------------
typedef struct _NCPAINTOVERIDE
{
    NCWNDMET*  pncwm;
    NCTHEMEMET nctm;
} NCPAINTOVERIDE, *PNCPAINTOVERIDE;

//---------------------------------------------------------------------------
class CMdiBtns;

//---------------------------------------------------------------------------
//  Hook state flags
#define HOOKSTATE_IN_DWP                0x00000001  // prevents Post-wndproc OWP from deleting the themewnd
#define HOOKSTATE_DETACH_WINDOWDESTROY  0x00000002  // tags themewnd for detach on window death
#define HOOKSTATE_DETACH_THEMEDESTROY   0x00000004  // tags themewnd for detach on theme death

//---------------------------------------------------------------------------
class CThemeWnd
//---------------------------------------------------------------------------
{
public:
    //  ref counting
    LONG              AddRef();
    LONG              Release();

    //  access operators
    operator HWND()   { return _hwnd; }
    operator HTHEME() { return _hTheme; }
    
    //  theme object attach/detach methods
    static ULONG      EvaluateWindowStyle( HWND hwnd );
    static ULONG      EvaluateStyle( DWORD dwStyle, DWORD dwExStyle );
    static CThemeWnd* Attach( HWND hwnd, IN OUT OPTIONAL NCEVALUATE* pnce = NULL );  // attaches CThemeWnd instance from window
    static CThemeWnd* FromHwnd( HWND hwnd ); // Retrieves CThemeWnd instance from window
    static CThemeWnd* FromHdc( HDC hdc, int cScanAncestors = 0 ); // maximum number of ancestor windows to grock.
    static void       Detach( HWND hwnd, DWORD dwDisposition ); // detaches CThemeWnd instance from window
    static void       DetachAll( DWORD dwDisposition ); // detaches all CThemeWnd instances in the current process
    static void       RemoveWindowProperties(HWND hwnd, BOOL fDestroying);
    static BOOL       Reject( HWND hwnd, BOOL fExile );
    static BOOL       Fail( HWND hwnd );
           BOOL       Revoke();  // revokes theming on a themed window

    BOOL              TestCF( ULONG fClassFlag ) const     
                              { return (_fClassFlags & fClassFlag) != 0; }

    //  Theme state
    BOOL        IsNcThemed();
    BOOL        IsFrameThemed();

    //  set/remove/change theme
    void        SetFrameTheme( ULONG dwFlags, IN OPTIONAL WINDOWINFO* pwi );
    void        RemoveFrameTheme( ULONG dwFlags );
    void        ChangeTheme( THEME_MSG* ptm );

    #define FTF_CREATE             0x00000001   // 'soft' theme the window during creation sequence.
    #define FTF_REDRAW             0x00000010   // force frame redraw.
    #define FTF_NOMODIFYRGN        0x00000040   // don't touch window region.
    #define FTF_NOMODIFYPLACEMENT  0x00000080   // don't move the window

    //  Theme revocation
    #define RF_NORMAL     0x00000001
    #define RF_REGION     0x00000002
    #define RF_TYPEMASK   0x0000FFFF
    #define RF_DEFER      0x00010000   // defer revocation until next WM_WINDOWPOSCHANGED
    #define RF_INREVOKE   0x00020000

    void        SetRevokeFlags( ULONG dwFlags ) {_dwRevokeFlags = dwFlags;}
    DWORD       GetRevokeFlags() const {return _dwRevokeFlags;}
    DWORD       IsRevoked( IN OPTIONAL ULONG dwFlags = 0 ) const   
                                       {return dwFlags ? TESTFLAG(_dwRevokeFlags, dwFlags) : 
                                                         TESTFLAG(_dwRevokeFlags, RF_TYPEMASK);}

    void        EnterRevoke()          {AddRef(); _dwRevokeFlags |= RF_INREVOKE;}
    void        LeaveRevoke()          {_dwRevokeFlags &= ~RF_INREVOKE; Release();}

    //  NCPaint hooking:
    BOOL        InNcPaint() const      { return _cNcPaint != 0; }
    void        EnterNcPaint()         { _cNcPaint++; }
    void        LeaveNcPaint()         { _cNcPaint--; }

    BOOL        InNcThemePaint() const { return _cNcThemePaint != 0; }
    void        EnterNcThemePaint()    { _cNcThemePaint++; }
    void        LeaveNcThemePaint()    { _cNcThemePaint--; }

    //  window region state
    void        SetDirtyFrameRgn( BOOL fDirty, BOOL fFrameChanged = FALSE );
    BOOL        DirtyFrameRgn() const      { return _fDirtyFrameRgn; }
    BOOL        AssigningFrameRgn() const  { return _fAssigningFrameRgn; }
    BOOL        AssignedFrameRgn() const   { return _fAssignedFrameRgn; }
    
    //  window region management
    void        AssignFrameRgn( BOOL fAssign, DWORD dwFlags );
    HRGN        CreateCompositeRgn( IN const NCWNDMET* pncwm,
                                    OUT HRGN rghrgnParts[],
                                    OUT HRGN rghrgnTemplates[] /* arrays presumed cFRAMEPARTS in length */);

    //  metrics/layout/state helpers.
    BOOL        GetNcWindowMetrics( IN OPTIONAL LPCRECT prcWnd, 
                                    OUT OPTIONAL NCWNDMET** ppncwm,
                                    OUT OPTIONAL NCTHEMEMET* pnctm, 
                                    IN DWORD dwOptions );
                #define NCWMF_RECOMPUTE      0x00000001  // recompute values
                #define NCWMF_PREVIEW        0x00000002  // Only used for the preview forces recalculating of NCTHEMEMET

    BOOL        InThemeSettingChange() const  {return _fInThemeSettingChange;}
    void        EnterThemeSettingChange()     {_fInThemeSettingChange = TRUE;}
    void        LeaveThemeSettingChange()     {_fInThemeSettingChange = FALSE;}

    UINT        NcCalcMenuBar( int, int, int ); // user32!CalcMenuBar wrap

    void        ScreenToWindow( LPPOINT prgPts, UINT cPts );
    void        ScreenToWindowRect( LPRECT prc );

    // MDI frame state.
    void        UpdateMDIFrameStuff( HWND hwndMDIClient, BOOL fSetMenu = FALSE );
    void        ThemeMDIMenuButtons( BOOL fTheme, BOOL fRedraw );
    void        ModifyMDIMenubar( BOOL fTheme, BOOL fRedraw );
    
    //  hit testing and mouse tracking
    WORD        NcBackgroundHitTest( POINT ptHit, LPCRECT prcWnd, DWORD dwStyle, DWORD dwExStyle, FRAMESTATES fs,
                                     const WINDOWPARTS rgiParts[],
                                     const WINDOWPARTS rgiTemplates[],
                                     const RECT rgrcParts[] /* all arrays presumed cFRAMEPARTS in length */);

    //  determines whether the indicated button should be tracked on mouse events.
    BOOL        ShouldTrackFrameButton( UINT uHitcode );

    //  Track mouse on NC frame button; copies back appropriate syscmd (SC_) code and target window, 
    //  returns TRUE if tracking was handled, otherwise FALSE if default tracking is required.
    BOOL        TrackFrameButton( IN HWND hwnd, IN INT uHitCode, OUT OPTIONAL WPARAM* puSysCmd, 
                                  BOOL fHottrack = FALSE );

    //  hot NC hittest identifier accessors
    int         GetNcHotItem()            { return _htHot; }
    void        SetNcHotItem(int htHot)   { _htHot = htHot; }

    //  style change handling
    void        StyleChanged( UINT iGWL, DWORD dwOld, DWORD dwNew );
    BOOL        SuppressingStyleMsgs() { return _fSuppressStyleMsgs; }
    void        SuppressStyleMsgs()   { _fSuppressStyleMsgs = TRUE; }
    void        AllowStyleMsgs()      { _fSuppressStyleMsgs = FALSE; }

    //  App icon management
    HICON       AcquireFrameIcon( DWORD dwStyle, DWORD dwExStyle, BOOL fWinIniChange );
    void        SetFrameIcon(HICON hIcon) { _hAppIcon = hIcon; }

    //  non-client painting
    void        NcPaint( IN OPTIONAL HDC hdc, 
                         IN ULONG dwFlags, 
                         IN OPTIONAL HRGN hrgnUpdate, 
                         IN OPTIONAL PNCPAINTOVERIDE pncpo );

                #define NCPF_DEFAULT            0x00000000
                #define NCPF_ACTIVEFRAME        0x00000001
                #define NCPF_INACTIVEFRAME      0x00000002

                #define DC_BACKGROUND           0x00010000
                #define DC_ENTIRECAPTION        0xFFFFFFFF
    void        NcPaintCaption( IN HDC hdcOut, 
                                IN NCWNDMET* pncwm, 
                                IN BOOL fBuffered, 
                                IN OPTIONAL DWORD dwCaptionFlags = DC_ENTIRECAPTION, 
                                IN DTBGOPTS *pdtbopts = NULL );

                #define RNCF_CAPTION            0x00000001
                #define RNCF_SCROLLBAR          0x00000002
                #define RNCF_FRAME              0x00000004
                #define RNCF_ALL                0xFFFFFFFF
    BOOL        HasRenderedNcPart( DWORD dwField ) const   { return TESTFLAG(_dwRenderedNcParts, dwField); }
    void        SetRenderedNcPart( DWORD dwField )         { _dwRenderedNcParts |= dwField; }
    void        ClearRenderedNcPart( DWORD dwField )       { _dwRenderedNcParts &= ~dwField; }

    void        LockRedraw( BOOL bLock )             { _cLockRedraw += (bLock ? 1 : -1); }

    BOOL        HasProcessedEraseBk()                { return _fProcessedEraseBk; }
    void        ProcessedEraseBk(BOOL fProcessed)    { _fProcessedEraseBk = fProcessed; }

    //  Maxed MDI child button ownerdraw implementation
    HWND        GetMDIClient() const                { return _hwndMDIClient; }
    CMdiBtns*   LoadMdiBtns( IN OPTIONAL HDC hdc, IN OPTIONAL UINT uSysCmd = 0 );
    void        UnloadMdiBtns( IN OPTIONAL UINT uSysCmd = 0 );

    //  resource management
    void        InitWindowMetrics();

    //  lame button support
#ifdef LAME_BUTTON
                //  ExStyles not defined by user
                #define WS_EX_LAMEBUTTONON      0x00000800L 
                #define WS_EX_LAMEBUTTON        0x00008000L 
    void        ClearLameResources();
    void        InitLameResources();
    void        DrawLameButton(HDC hdc, IN const NCWNDMET* pncwm);
    void        GetLameButtonMetrics( NCWNDMET* pncwm, const SIZE* psizeCaption );
#else
#   define      ClearLameResources()
#   define      InitLameResources()
#   define      DrawLameButton(hdc, pncwm)
#   define      GetLameButtonMetrics(pncwm, psize)
#endif // LAME_BUTTON

    //  Debugging:
#ifdef DEBUG
    void        Spew( DWORD dwSpewFlags, LPCTSTR pszFmt, LPCTSTR pszWndClassList = NULL );
    static void SpewAll( DWORD dwSpewFlags, LPCTSTR pszFmt, LPCTSTR pszWndClassList = NULL );
    static void SpewLeaks();
#endif DEBUG

    //  CThemeWnd object-window association
private:
    static ULONG    _Evaluate( HWND hwnd, NCEVALUATE* pnce );
    static ULONG    _EvaluateExclusions( HWND hwnd, NCEVALUATE* pnce );

    BOOL            _AttachInstance( HWND hwnd, HTHEME hTheme, ULONG fTargetFlags, PVOID pvWndCompat );
    BOOL            _DetachInstance( DWORD dwDisposition );
    void            _CloseTheme();

    static BOOL CALLBACK _DetachDesktopWindowsCB( HWND hwnd, LPARAM dwProcessId );

    //  Ctor, Dtor
private:  // auto-instantiated and deleted through friends
    CThemeWnd();
    ~CThemeWnd();

    //  Misc private methods
private:
    static BOOL     _PostWndProc( HWND, UINT, WPARAM, LPARAM, LRESULT* );
    static BOOL     _PostDlgProc( HWND, UINT, WPARAM, LPARAM, LRESULT* );
    static BOOL     _PreDefWindowProc( HWND, UINT, WPARAM, LPARAM, LRESULT* );

    static HTHEME   _AcquireThemeHandle( HWND hwnd, IN OUT ULONG *pfClassFlags );
    void            _AssignRgn( HRGN hrgn, DWORD dwFlags );
    void            _FreeRegionHandles();

    //  Private data
private:

    CHAR       _szHead[9];         // header signature used for object validation

    HWND       _hwnd;
    LONG       _cRef;              // ref count.
    HTHEME     _hTheme;            // theme handle
    DWORD      _dwRenderedNcParts; // mask of the NC elements we've drawn, to decide if we should track them
    ULONG      _dwRevokeFlags;     // theme revoke flags
    ULONG      _fClassFlags;       // theming class flag bits
    NCWNDMET   _ncwm;              // per-window metrics
    HICON      _hAppIcon;          // application's icon
    HRGN       _hrgnWnd;           // cached window region.
    HRGN       _rghrgnParts[cFRAMEPARTS]; // cached nc component subregions.
    HRGN       _rghrgnSizingTemplates[cFRAMEPARTS]; // cached nc frame resizing hittest template subregions.
    BOOL       _fDirtyFrameRgn;    // State flag: window region needs updating.
    BOOL       _fFrameThemed;      // SetFrameTheme() has been invoked on a valid frame window
    BOOL       _fAssigningFrameRgn;// SetWindowRgn state flag.
    BOOL       _fAssignedFrameRgn; // Region state flag
    BOOL       _fSuppressStyleMsgs;    // Suppress style change messages to arrive at the WndProc
    BOOL       _fProcessedEraseBk;
    BOOL       _fInThemeSettingChange; // window is being sent a theme setting change message.
    BOOL       _fDetached;         // Detached object; leave it alone!
    BOOL       _fThemedMDIBtns;    // MDI menubar buttons have been themed-rendered.
    HWND       _hwndMDIClient;     // MDICLIENT child window.
    int        _cLockRedraw;       // paint lock reference count.
    int        _cNcPaint;          // NCPAINT message ref count
    int        _cNcThemePaint;     // Indicator: we're painting the nonclient area.
    SIZE       _sizeRgn;           // window rgn size.
    int        _htHot;             // hittest code of the current hot NC element
    CMdiBtns*  _pMdiBtns;
    CRITICAL_SECTION _cswm;    // serializes access to _ncwm.

#ifdef LAME_BUTTON
    HFONT      _hFontLame;        // font used to draw the lame button text
    SIZE       _sizeLame;         // the text extent of the lame text
#endif // LAME_BUTTON

    static LONG _cObj;            // instance count

#ifdef DEBUG
public:
    TCHAR      _szCaption[MAX_PATH];
    TCHAR      _szWndClass[MAX_PATH];
#endif DEBUG

    CHAR       _szTail[4];        // tail signature used for object validation

    //  Message tracking
public:

    //   Friends
    friend LRESULT _ThemeDefWindowProc( HWND, UINT, WPARAM, LPARAM, BOOL );
    friend BOOL     ThemePreWndProc( HWND, UINT, WPARAM, LPARAM, LRESULT*, VOID** );
    friend BOOL     ThemePostWndProc( HWND, UINT, WPARAM, LPARAM, LRESULT*, VOID** );
    friend BOOL     ThemePreDefDlgProc( HWND, UINT, WPARAM, LPARAM, LRESULT*, VOID** );
    friend BOOL     ThemePrePostDlgProc( HWND, UINT, WPARAM, LPARAM, LRESULT*, VOID** );
    friend BOOL     ThemePostDefDlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT*, VOID**);
};

//-------------------------------------------------------------------------//
//  public variables.
extern CRITICAL_SECTION _csThemeMet;  // protects access to _nctmCurrent in nctheme.cpp
extern CRITICAL_SECTION _csNcSysMet;  // protects access to _ncmCurrent in nctheme.cpp
extern CRITICAL_SECTION _csNcPaint;   // protects thread-in-NCPAINT collection

//-------------------------------------------------------------------------//
//  forwards:

//  Internal sysmet wrappers.   These functions can be more efficient than
//  calling through USER32, and support theme preview functionality.
int   NcGetSystemMetrics(int);
BOOL  NcGetNonclientMetrics( OUT OPTIONAL NONCLIENTMETRICS* pncm, BOOL fRefresh = FALSE );
void  NcClearNonclientMetrics();
HFONT NcGetCaptionFont( BOOL fSmallCaption );

HWND  NcPaintWindow_Find(); // retrieves window in current thread that is processing NCPAINT

//
void PrintClientNotHandled(HWND hwnd);

//  hook function workers
int  _InternalGetSystemMetrics( int, BOOL& fHandled );
BOOL _InternalSystemParametersInfo( UINT, UINT, PVOID, UINT, BOOL fUnicode, BOOL& fHandled );

//------------------------------------------ -------------------------------//
///  debug spew
#define NCTF_THEMEWND       0x00000001
#define NCTF_AWR            0x00000002 // ThemeAdjustWindowRectEx vs Calcsize
#define NCTF_SETFRAMETHEME  0x00000004 // 
#define NCTF_CALCWNDPOS     0x00000008 // WM_NCCALCSIZE, WM_WINDOWPOSCHANGED.
#define NCTF_RGNWND         0x00000010 // region window debugging
#define NCTF_MDIBUTTONS     0x00000020 // region window debugging
#define NCTF_NCPAINT        0x00000040 // debug painting
#define NCTF_SYSMETS        0x00000080 // system metrics calls
#define NCTF_ALWAYS         0xFFFFFFFF // always trace



#ifdef DEBUG
    void   CDECL _NcTraceMsg( ULONG uFlags, LPCTSTR pszFmt, ...);
    void   INIT_THEMEWND_DBG( CThemeWnd* pwnd );
    void   SPEW_RECT( ULONG ulTrace, LPCTSTR pszMsg, LPCRECT prc );
    void   SPEW_MARGINS( ULONG ulTrace, LPCTSTR pszMsg, LPCRECT prcParent, LPCRECT prcChild );
    void   SPEW_RGNRECT( ULONG ulTrace, LPCTSTR pszMsg, HRGN hrgn, int iPartID );
    void   SPEW_WINDOWINFO( ULONG ulTrace, WINDOWINFO* );
    void   SPEW_NCWNDMET( ULONG ulTrace, LPCTSTR, NCWNDMET* );
    void   SPEW_SCROLLINFO( ULONG ulTrace, LPCTSTR pszMsg, HWND hwnd, LPCSCROLLINFO psi );
    void   SPEW_THEMEMSG( ULONG ulTrace, LPCTSTR pszMsg, THEME_MSG* ptm );
#   define SPEW_THEMEWND(pwnd,dwFlags,txt,classlist)  (pwnd)->Spew( dwFlags, txt, classlist )
#   define SPEW_THEMEWND_LEAKS(pwnd)           (pwnd)->SpewLeaks()
#else  // DEBUG
    inline void CDECL _NcTraceMsg( ULONG uFlags, LPCTSTR pszFmt, ...) {}
#   define INIT_THEMEWND_DBG( pwnd );
#   define SPEW_RECT( ulTrace, pszMsg, prc )
#   define SPEW_MARGINS( ulTrace, pszMsg, prcParent, prcChild )
#   define SPEW_RGNRECT( ulTrace, pszMsg, hrgn, iPartID )
#   define SPEW_WINDOWINFO( ulTrace, pwi )
#   define SPEW_NCWNDMET( ulTrace, pszMsg, pncwm )
#   define SPEW_SCROLLINFO( ulTrace, pszMsg, hwnd, psi )
#   define SPEW_THEMEMSG( ulTrace, pszMsg, ptm )
#   define SPEW_THEMEWND(pwnd,dwFlags,txt,classlist)  (pwnd)->Spew( dwFlags, txt, classlist )
#   define SPEW_THEMEWND_LEAKS(pwnd)           (pwnd)->SpewLeaks()
#endif // DEBUG

#endif __NC_THEME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\ntleng.cpp ===
//-------------------------------------------------------------------------
//	NtlEng.cpp - support for Native Theme Language runtime graphics engine
//-------------------------------------------------------------------------
#include "stdafx.h"
#include "ntleng.h"
//---------------------------------------------------------------------------
#define COLORNULL 0xff000000
//---------------------------------------------------------------------------
POINT TranslateLogPoint(POINT &pt, RECT &rcLogRect, RECT &rcCaller)
{
    POINT ptNew;

    ptNew.x = rcCaller.left + (WIDTH(rcCaller) * (pt.x - rcLogRect.left))/WIDTH(rcLogRect);
    ptNew.y = rcCaller.top + (HEIGHT(rcCaller) * (pt.y - rcLogRect.top))/HEIGHT(rcLogRect);
    
    return ptNew;
}
//---------------------------------------------------------------------------
int TranslateLogSize(int iSize, RECT &rcLogRect, RECT &rcCaller)
{
    //---- "iSize" is somewhere between width & height ----
    int iWidthSize = (WIDTH(rcCaller) * iSize)/WIDTH(rcLogRect);
    int iHeightSize = (HEIGHT(rcCaller) * iSize)/HEIGHT(rcLogRect);

    return min(iWidthSize, iHeightSize);
}
//---------------------------------------------------------------------------
COLORREF GetParamColor(MIXEDPTRS &u)
{
    COLORREF crVal = 0;

    if (*u.pb == PT_COLORREF)
        crVal = *u.pi++;
    else if (*u.pb == PT_SYSCOLORINDEX)
        crVal = GetSysColor(*u.ps++);
    else if (*u.pb == PT_COLORNULL)
        crVal = COLORNULL;
    else
    {
        Log(LOG_ERROR, L"Bad color param value in NTL stream: 0x%0x", *u.pb);
    }
    
    return crVal;
}
//---------------------------------------------------------------------------
int GetParamInt(MIXEDPTRS &u)
{
    int iVal;

    if (*u.pb == PT_INT)
        iVal = *u.pi++;
    else
        iVal = ClassicGetSystemMetrics(*u.ps++);
    
    return iVal;
}
//---------------------------------------------------------------------------
POINT GetParamPoint(MIXEDPTRS &u, RECT &rcCaller, RECT &rcLogRect)
{
    POINT pt = *u.ppt++;
    pt = TranslateLogPoint(pt, rcCaller, rcLogRect);

    return pt;
}
//---------------------------------------------------------------------------
void SetPen(HDC hdc, HPEN &hPen, COLORREF crLine, int iLineWidth)
{
    DeleteObject(hPen);

    if (crLine == COLORNULL)
        hPen = (HPEN)GetStockObject(NULL_PEN);
    else
        hPen = CreatePen(PS_SOLID, iLineWidth, crLine);

    SelectObject(hdc, hPen);
}
//---------------------------------------------------------------------------
HRESULT GetImageBrush(HDC hdc, int iPartId, int iStateId, int iIndex, 
    INtlEngCallBack *pCallBack, HBRUSH *phbr)
{
    HRESULT hr;

    if (! pCallBack)
    {
        Log(LOG_ERROR, L"No callback for NtlRun specified");
        hr = MakeError32(ERROR_INTERNAL_ERROR); 
    }
    else
        hr = pCallBack->CreateImageBrush(hdc, iPartId, iStateId, iIndex, phbr);

    return hr;
}
//---------------------------------------------------------------------------
HRESULT GetFillBrush(HDC hdc, MIXEDPTRS &u, int iPartId, int iStateId, 
      INtlEngCallBack *pCallBack, HBRUSH *phbr)
{
    HBRUSH hbr = NULL;
    BYTE bIndex;
    HRESULT hr = S_OK;

    switch (*u.pb)
    {
        case PT_IMAGEFILE:
            bIndex = *u.pb++;
            hr = GetImageBrush(hdc, iPartId, iStateId, bIndex, pCallBack, &hbr);
            break;

        default:
            COLORREF crVal = GetParamColor(u);
            if (crVal == COLORNULL)
                hbr = (HBRUSH)GetStockObject(NULL_BRUSH);
            else
                hbr = CreateSolidBrush(crVal);
            break;
    }

    if (SUCCEEDED(hr))
        *phbr = hbr;

    return hr;
}
//---------------------------------------------------------------------------
void DrawRect(HDC hdc, MIXEDPTRS &u, RECT &rcCaller)
{
    int iVals[4];
    COLORREF crVals[4];

    //---- get int params ----
    for (int i=0; i < 4; i++)
    {
        if ((*u.pb != PT_INT) && (*u.pb != PT_SYSMETRICINDEX))
            break;
        iVals[i] = GetParamInt(u);
    }

    int cInts = i;

    //---- get color param s----
    for (i=0; i < 4; i++)
    {
        if ((*u.pb != PT_COLORREF) && (*u.pb != PT_COLORNULL)
            && (*u.pb != PT_SYSCOLORINDEX))
            break;
        crVals[i] = GetParamColor(u);
    }

    int cColors = i;

    if ((cInts == 1) && (cColors == 1))        // single size/color for all 4 sides
    {
        if (crVals[0] != COLORNULL)
        {
            HPEN hpen = CreatePen(PS_SOLID | PS_INSIDEFRAME, iVals[0], crVals[0]);
            HPEN hpenOld = (HPEN)SelectObject(hdc, hpen);

            HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, GetStockObject(NULL_BRUSH));

            Rectangle(hdc, rcCaller.left, rcCaller.top, rcCaller.right, rcCaller.bottom);

            SelectObject(hdc, hpenOld);
            SelectObject(hdc, hbrOld);

            DeleteObject(hpen);
        }

        InflateRect(&rcCaller, -iVals[0], -iVals[0]);
    }
    else                // need to draw each side one at a time
    {
        //---- expand int's into 4 values ----
        if (cInts == 1)
        {
            iVals[1] = iVals[2] = iVals[3] = iVals[0];
        }
        else if (cInts == 2)
        {
            iVals[2] = iVals[0];
            iVals[3] = iVals[1];
        }

        //---- expand colors's into 4 values ----
        if (cColors == 1)
        {
            crVals[1] = crVals[2] = crVals[3] = crVals[0];
        }
        else if (cColors == 2)
        {
            crVals[2] = crVals[0];
            crVals[3] = crVals[1];
        }

        HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, GetStockObject(NULL_BRUSH));
        HBRUSH hbr = NULL;

        //---- left ----
        if ((crVals[0] != COLORNULL) && (iVals[0]))
        {
            hbr = CreateSolidBrush(crVals[0]);
            SelectObject(hdc, hbr);

            PatBlt(hdc, rcCaller.left, rcCaller.top, iVals[0], HEIGHT(rcCaller), PATCOPY);
        }
        rcCaller.left += iVals[0];

        //---- top ----
        if ((crVals[1] != COLORNULL) && (iVals[1]))    
        {
            if (crVals[1] != crVals[0])     // need new brush
            {
                hbr = CreateSolidBrush(crVals[1]);
                SelectObject(hdc, hbr);
            }

            PatBlt(hdc, rcCaller.left, rcCaller.top, WIDTH(rcCaller), iVals[0], PATCOPY);
        }
        rcCaller.top += iVals[1];

        //---- right ----
        if ((crVals[2] != COLORNULL) && (iVals[2]))    
        {
            if (crVals[2] != crVals[1])     // need new brush
            {
                hbr = CreateSolidBrush(crVals[2]);
                SelectObject(hdc, hbr);
            }

            PatBlt(hdc, rcCaller.right - iVals[0], rcCaller.top, iVals[0], HEIGHT(rcCaller), PATCOPY);
        }
        rcCaller.right -= iVals[2];

        //---- bottom ----
        if ((crVals[3] != COLORNULL) && (iVals[3]))    
        {
            if (crVals[3] != crVals[2])     // need new brush
            {
                hbr = CreateSolidBrush(crVals[3]);
                SelectObject(hdc, hbr);
            }

            PatBlt(hdc, rcCaller.left, rcCaller.bottom - iVals[0], WIDTH(rcCaller), iVals[0], PATCOPY);
        }
        rcCaller.bottom -= iVals[3];

        SelectObject(hdc, hbrOld);
        DeleteObject(hbr);
    }
}
//---------------------------------------------------------------------------
HRESULT RunNtl(HDC hdc, RECT &rcCaller, HBRUSH hbrBkDefault, DWORD dwOptions, 
     int iPartId, int iStateId, BYTE *pbCode, int iCodeLen, INtlEngCallBack *pCallBack)
{
    HRESULT hr = S_OK;
    MIXEDPTRS u;
    u.pb = pbCode;
    RECT rcLogRect = {0, 0, 1000, 1000};

    RESOURCE HPEN hPen = (HPEN)GetStockObject(BLACK_PEN);
    RESOURCE HBRUSH hBrush = (HBRUSH)GetStockObject(GRAY_BRUSH);
    BOOL fDeleteBrush = FALSE;

    if (hbrBkDefault)
        hBrush = hbrBkDefault;

    RESOURCE HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, hBrush);
    RESOURCE HPEN hpenOld = (HPEN)SelectObject(hdc, hPen);

    while (*u.pb != NTL_RETURN)
    {
        switch (*u.pb)
        {
            case NTL_STATEJUMPTABLE:
            {
                BYTE bStateCount = *u.pb++;
                if ((iStateId < 1) || (iStateId > bStateCount))
                    iStateId = 1;
                u.pb = pbCode + u.pi[iStateId-1];
            }
            break;

            case NTL_JMPON:
            {
                BYTE bBitNum = *u.pb++;
                int iOffset = *u.pi++;
                if (dwOptions & (1 << bBitNum))
                    u.pb = pbCode + iOffset;
            }
            break;

            case NTL_JMPOFF:
            {
                BYTE bBitNum = *u.pb++;
                int iOffset = *u.pi++;
                if (! (dwOptions & (1 << bBitNum)))
                    u.pb = pbCode + iOffset;
            }
            break;

            case NTL_JMP:
            {
                int iOffset = *u.pi++;
                u.pb = pbCode + iOffset;
            }
            break;

            case NTL_LOGRECT:
                rcLogRect = *u.prc++;
                break;

            case NTL_LINEBRUSH:
            {
                COLORREF crLine = GetParamColor(u);
                int iLineWidth = GetParamInt(u);
                BOOL fLogWidth = *u.pb++;
                if (fLogWidth)
                    iLineWidth = TranslateLogSize(iLineWidth, rcCaller, rcLogRect);
                SetPen(hdc, hPen, crLine, iLineWidth);
            }
            break;

            case NTL_FILLBRUSH:
            {
                HBRUSH hbr;
                
                hr = GetFillBrush(hdc, u, iPartId, iStateId, pCallBack, &hbr);
                if (FAILED(hr))
                    goto exit;

                SelectObject(hdc, hbr);
                if (fDeleteBrush)
                    DeleteObject(hBrush);
                hBrush = hbr;
                fDeleteBrush = TRUE;
            }
            break;

            case NTL_MOVETO:
            {
                POINT pt = GetParamPoint(u, rcCaller, rcLogRect);
                MoveToEx(hdc, pt.x, pt.y, NULL);
            }
            break;
            
            case NTL_LINETO:
            {
                POINT pt = GetParamPoint(u, rcCaller, rcLogRect);
                LineTo(hdc, pt.x, pt.y);
            }
            break;

            case NTL_CURVETO:
            {
                POINT pts[3];
                pts[0] = GetParamPoint(u, rcCaller, rcLogRect);
                pts[1] = GetParamPoint(u, rcCaller, rcLogRect);
                pts[2] = GetParamPoint(u, rcCaller, rcLogRect);
                PolyBezierTo(hdc, pts, 3);
            }
            break;

            case NTL_SHAPE:
            {
                POINT pt = GetParamPoint(u, rcCaller, rcLogRect);
                BeginPath(hdc);
                MoveToEx(hdc, pt.x, pt.y, NULL);
            }
            break;

            case NTL_ENDSHAPE:
            {
                EndPath(hdc);
                StrokeAndFillPath(hdc);
            }
            break;

            case NTL_DRAWRECT:
            {
                DrawRect(hdc, u, rcCaller);
            }
            break;

            case NTL_FILLRECT:
            {
                HBRUSH hbr;
                
                hr = GetFillBrush(hdc, u, iPartId, iStateId, pCallBack, &hbr);
                if (FAILED(hr))
                    goto exit;

                FillRect(hdc, &rcCaller, hbr);
                DeleteObject(hbr);
            }
            break;
        }
    }

exit:
    SelectObject(hdc, hbrOld);
    SelectObject(hdc, hpenOld);

    DeleteObject(hPen);

    if (fDeleteBrush)
        DeleteObject(hBrush);

    return S_OK;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\loader.cpp ===
//---------------------------------------------------------------------------
//  Loader.cpp - loads the theme data into shared memory
//---------------------------------------------------------------------------
#include "stdafx.h"
#include <regstr.h>
#include "Loader.h"
#include "Parser.h"
#include "Utils.h"
#include "TmReg.h"
#include "TmUtils.h"
#include "syscolors.h"
#include "Render.h"
#include "BorderFill.h"
#include "ImageFile.h"
#include "TextDraw.h"
#include "info.h"
//---------------------------------------------------------------------------
#define POINTS_DPI96(pts)   -MulDiv(pts, 96, 72)
//---------------------------------------------------------------------------
WCHAR pszColorsKey[] = L"Control Panel\\Colors";
//---------------------------------------------------------------------------
typedef struct 
{
    THEMEMETRICS tm;
    HANDLE hUserToken;
} THEMEMETRICS_THREADINFO;
//---------------------------------------------------------------------------
CThemeLoader::CThemeLoader()
{
    _pbLocalData = NULL;
    _iEntryHdrLevel = -1;
    
    InitThemeMetrics(&_LoadThemeMetrics);
    
    SYSTEM_INFO si;

    GetSystemInfo(&si);
    _dwPageSize = si.dwPageSize;
}
//---------------------------------------------------------------------------
CThemeLoader::~CThemeLoader()
{
    FreeLocalTheme();
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::LoadClassDataIni(HINSTANCE hInst, LPCWSTR pszColorName,
    LPCWSTR pszSizeName, LPWSTR pszFoundIniName, DWORD dwMaxIniNameChars, LPWSTR *ppIniData)
{
    COLORSIZECOMBOS *combos;
    HRESULT hr = FindComboData(hInst, &combos);
    if (FAILED(hr))
        return hr;

    int iSizeIndex = 0;
    int iColorIndex = 0;

    if ((pszColorName) && (* pszColorName))
    {
        hr = GetColorSchemeIndex(hInst, pszColorName, &iColorIndex);
        if (FAILED(hr))
            return hr;
    }

    if ((pszSizeName) && (* pszSizeName))
    {
        hr = GetSizeIndex(hInst, pszSizeName, &iSizeIndex);
        if (FAILED(hr))
            return hr;
    }

    int filenum = COMBOENTRY(combos, iColorIndex, iSizeIndex);
    if (filenum == -1)
        return MakeError32(ERROR_NOT_FOUND);

    //---- locate resname for classdata file "filenum" ----
    hr = GetResString(hInst, L"FILERESNAMES", filenum, pszFoundIniName, dwMaxIniNameChars);
    if (SUCCEEDED(hr))
    {
        hr = AllocateTextResource(hInst, pszFoundIniName, ppIniData);
        if (FAILED(hr))
            return hr;
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::LoadTheme(LPCWSTR pszThemeName, LPCWSTR pszColorParam,
        LPCWSTR pszSizeParam, OUT HANDLE *pHandle, BOOL fGlobalTheme)
{
    HRESULT hr;
    CThemeParser *pParser = NULL;
    HINSTANCE hInst = NULL;
    WCHAR *pThemesIni = NULL;
    WCHAR *pDataIni = NULL;
    WCHAR szClassDataName[_MAX_PATH+1];

    DWORD dwStartTime = StartTimer();

    Log(LOG_TMCHANGE, L"LoadTheme: filename=%s", pszThemeName);

    FreeLocalTheme();

    //---- allocate a local theme data to construct ----

    _pbLocalData = (BYTE*) VirtualAlloc(NULL, MAX_SHAREDMEM_SIZE, MEM_RESERVE, PAGE_READWRITE);
    if (NULL == _pbLocalData)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }
    _iLocalLen = 0;

    //---- load the Color Scheme from "themes.ini" ----
    hr = LoadThemeLibrary(pszThemeName, &hInst);
    if (FAILED(hr))
        goto exit;
    
    pParser = new CThemeParser(fGlobalTheme);
    if (! pParser)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }

    //---- if a color scheme is specified, ask parser to load it ----
    if ((pszColorParam) && (*pszColorParam))     
    {
        //---- load the "themes.ini" text ----
        hr = AllocateTextResource(hInst, CONTAINER_RESNAME, &pThemesIni);
        if (FAILED(hr))
            goto exit;

        //---- parser call to load color scheme & keep state ----
        hr = pParser->ParseThemeBuffer(pThemesIni, 
            CONTAINER_RESNAME, pszColorParam, hInst, this, NULL, NULL, PTF_CONTAINER_PARSE);
        if (FAILED(hr))
            goto exit;
    }

    //---- load the classdata file resource into memory ----
    hr = LoadClassDataIni(hInst, pszColorParam, pszSizeParam, szClassDataName, 
        ARRAYSIZE(szClassDataName), &pDataIni);
    if (FAILED(hr))
        goto exit;

    //---- parse & build binary theme ----
    hr = pParser->ParseThemeBuffer(pDataIni, 
        szClassDataName, pszColorParam, hInst, this, NULL, NULL, PTF_CLASSDATA_PARSE);
    if (FAILED(hr))
        goto exit;

    _fGlobalTheme = fGlobalTheme;

    hr = PackAndLoadTheme(pszThemeName, pszColorParam, pszSizeParam, hInst);
    if (FAILED(hr))
        goto exit;

    if (LogOptionOn(LO_TMLOAD))
    {
        DWORD dwTicks;
        dwTicks = StopTimer(dwStartTime);

        WCHAR buff[100];
        TimeToStr(dwTicks, buff, ARRAYSIZE(buff));
        Log(LOG_TMLOAD, L"LoadTheme took: %s", buff);
    }

exit:

    if (FAILED(hr) && pParser)
    {
        pParser->CleanupStockBitmaps();
    }

    if (pParser)
        delete pParser;

    if (hInst)
        FreeLibrary(hInst);
    
    if (pThemesIni)
        delete [] pThemesIni;

    if (pDataIni)
        delete [] pDataIni;

    FreeLocalTheme();

    if (SUCCEEDED(hr))
    {
        if (_fGlobalTheme)
        {
            THEMEHDR *hdr = (THEMEHDR *) _LoadingThemeFile._pbThemeData;
            hdr->dwFlags |= SECTION_HASSTOCKOBJECTS;
        }

        //---- transfer theme file handle to caller ----
        *pHandle = _LoadingThemeFile.Unload();
    }
    else
    {
        _LoadingThemeFile.CloseFile();
    }

    return hr;
}
//---------------------------------------------------------------------------
void CThemeLoader::FreeLocalTheme()
{
    if (_pbLocalData)
    {
        VirtualFree(_pbLocalData, 0, MEM_RELEASE);
        _pbLocalData = NULL;
        _iLocalLen = 0; 
    }

    _LocalIndexes.RemoveAll();
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::EmitAndCopyBlock(MIXEDPTRS &u, void *pSrc, DWORD dwLen)
{
    HRESULT hr = AllocateThemeFileBytes(u.pb, dwLen);
    if (FAILED(hr))
        return hr;

    CopyMemory(u.pb, (BYTE*) pSrc, dwLen);
    u.pb += dwLen;
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::EmitObject(MIXEDPTRS &u, SHORT propnum, BYTE privnum, void *pHdr, DWORD dwHdrLen, void *pObj, DWORD dwObjLen)
{
    EmitEntryHdr(u, propnum, privnum);
    
    HRESULT hr = AllocateThemeFileBytes(u.pb, dwHdrLen + dwObjLen);
    if (FAILED(hr))
        return hr;

    CopyMemory(u.pb, (BYTE*) pHdr, dwHdrLen);
    u.pb += dwHdrLen;
    CopyMemory(u.pb, (BYTE*) pObj, dwObjLen);
    u.pb += dwObjLen;
    
    EndEntry(u);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::EmitString(MIXEDPTRS &u, LPCWSTR pszSrc, DWORD cchSrc, int *piOffSet)
{
    HRESULT hr = AllocateThemeFileBytes(u.pb, (cchSrc + 1) * sizeof(WCHAR));
    if (FAILED(hr))
        return hr;

    StringCchCopyW(u.px, cchSrc + 1, pszSrc);

    if (piOffSet)
    {
        *piOffSet = THEME_OFFSET(u.pb);
    }
    u.px += cchSrc + 1;
    return S_OK;
}
//---------------------------------------------------------------------------
int CThemeLoader::GetMaxState(APPCLASSLOCAL *ac, int iPartNum)
{
    //---- calculate max. state index ----
    int iMaxState = -1;
    int pscnt = ac->PartStateIndexes.GetSize();

    for (int i=0; i < pscnt; i++)
    {
        PART_STATE_INDEX *psi = &ac->PartStateIndexes[i];

        if (psi->iPartNum == iPartNum)
        {
            if (psi->iStateNum > iMaxState)
                iMaxState = psi->iStateNum;
        }
    }

    return iMaxState;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::CopyPartGroup(APPCLASSLOCAL *ac, MIXEDPTRS &u, int iPartNum, 
    int *piPartJumpTable, int iPartZeroIndex, int iGlobalsOffset, BOOL fGlobalsGroup)
{
    HRESULT hr = S_OK;
    int *piStateJumpTable = NULL;

    //---- calculate max. state index ----
    int iMaxState = GetMaxState(ac, iPartNum);
    if (iMaxState < 0)          // no states to copy
        goto exit;

    //---- update part jump table index ----
    if (piPartJumpTable)
        piPartJumpTable[iPartNum] = THEME_OFFSET(u.pb);

    if (iMaxState > 0)          // create a state jump table
    {
        //---- create state jump table ----
        hr = EmitEntryHdr(u, TMT_STATEJUMPTABLE, TMT_STATEJUMPTABLE);
        if (FAILED(hr))
            goto exit;

        int statecnt = 1 + iMaxState;

        hr = AllocateThemeFileBytes(u.pb, 1 + statecnt * sizeof(int));
        if (FAILED(hr))
            goto exit;

        // 1 byte table entry count
        *u.pb++ = (BYTE)statecnt;

        piStateJumpTable = u.pi;

        //---- default "not avail" indexes for children ----
        for (int j=0; j < statecnt; j++)
            *u.pi++ = -1;

        EndEntry(u);
    }

    int pscnt, iStateZeroIndex;
    iStateZeroIndex = THEME_OFFSET(u.pb);
    pscnt = ac->PartStateIndexes.GetSize();

    //---- copy each defined part/state section ----
    for (int state=0; state <= iMaxState; state++)
    {
        PART_STATE_INDEX *psi = NULL;

        //---- find entry for "state" ----
        for (int i=0; i < pscnt; i++)
        {
            psi = &ac->PartStateIndexes[i];

            if ((psi->iPartNum == iPartNum) && (psi->iStateNum == state))
                break;
        }

        if (i == pscnt)     // not found
            continue;

        //---- update state jump table entry ----
        if (piStateJumpTable)
            piStateJumpTable[state] = THEME_OFFSET(u.pb);

        //---- copy the actual PART/STATE DATA  ----
        hr = EmitAndCopyBlock(u, _pbLocalData+psi->iIndex, psi->iLen);

        //---- update child's "JumpToParent" value ----
        if (! state)    
        {
            if (fGlobalsGroup) 
            {
                *(u.pi-1) = -1;      // end of the line   
            }
            else if (! iPartNum)     // simple class jumps to globals
            {
                *(u.pi-1) = iGlobalsOffset;
            }
            else                // parts jumps to their base class
            {
                *(u.pi-1) = iPartZeroIndex;
            }
        }
        else        // states jumps to their base part
        {
            *(u.pi-1) = iStateZeroIndex;
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::CopyClassGroup(APPCLASSLOCAL *ac, MIXEDPTRS &u, int iGlobalsOffset,
    int iClassNameOffset)
{
    HRESULT hr = S_OK;
    int *piPartJumpTable = NULL;
    int *piFirstPackObj = NULL;
    int partcnt;
    int iPartZeroIndex;
    CRenderObj *pRender = NULL;
    BOOL fGlobals = (iGlobalsOffset == THEME_OFFSET(u.pb));

    BYTE *pStartOfSection = u.pb;

    BOOL fGlobalGroup = (THEME_OFFSET(u.pb) == iGlobalsOffset);

    //---- always create a part table ----
    hr = EmitEntryHdr(u, TMT_PARTJUMPTABLE, TMT_PARTJUMPTABLE);
    if (FAILED(hr))
        goto exit;

    partcnt = 1 + ac->iMaxPartNum;
    
    // offset to first packed DrawObj/TextObj
    piFirstPackObj = u.pi;
    hr = AllocateThemeFileBytes(u.pb, 1 + (1 + partcnt) * sizeof(int));
    if (FAILED(hr))
        goto exit;

    *u.pi++ = 0;        // will update later

    // partcnt
    *u.pb++ = (BYTE)partcnt;

    piPartJumpTable = u.pi;

    //---- default "not avail" indexes for children ----
    for (int j=0; j < partcnt; j++)
        *u.pi++ = -1;

    EndEntry(u);


    iPartZeroIndex = THEME_OFFSET(u.pb);

    //---- copy each defined part section ----
    for (int j=0; j <= ac->iMaxPartNum; j++)
    {
        CopyPartGroup(ac, u, j, piPartJumpTable, iPartZeroIndex, 
            iGlobalsOffset, fGlobalGroup);
    }

    //---- now, extract draw objs for each part/state as needed ----
    *piFirstPackObj = THEME_OFFSET(u.pb);

    //---- build a CRenderObj to access the just copied class section ----
    hr = CreateRenderObj(&_LoadingThemeFile, 0, THEME_OFFSET(pStartOfSection), 
        iClassNameOffset, 0, FALSE, NULL, NULL, 0, &pRender);
    if (FAILED(hr))
        goto exit;

    if (fGlobals)
        _iGlobalsDrawObj = THEME_OFFSET(u.pb);

    hr = PackDrawObjects(u, pRender, ac->iMaxPartNum, fGlobals);
    if (FAILED(hr))
        goto exit;

    if (fGlobals)
        _iGlobalsTextObj = THEME_OFFSET(u.pb);

    hr = PackTextObjects(u, pRender, ac->iMaxPartNum, fGlobals);
    if (FAILED(hr))
        goto exit;

    //---- write "end of class" marker ----
    hr = EmitEntryHdr(u, TMT_ENDOFCLASS, TMT_ENDOFCLASS);
    if (FAILED(hr))
        goto exit;

    EndEntry(u);

exit:
    delete pRender;
    return hr;
}
//---------------------------------------------------------------------------
__inline HRESULT CThemeLoader::AllocateThemeFileBytes(BYTE *upb, DWORD dwAdditionalLen)
{
    ASSERT(upb != NULL && _LoadingThemeFile._pbThemeData != NULL);

    if (PtrToUint(upb) / _dwPageSize != PtrToUint(upb + dwAdditionalLen) / _dwPageSize)
    {
        if (NULL == VirtualAlloc(_LoadingThemeFile._pbThemeData, upb - _LoadingThemeFile._pbThemeData + 1 + dwAdditionalLen, MEM_COMMIT, PAGE_READWRITE))
        {
            return MakeError32(ERROR_NOT_ENOUGH_MEMORY);        
        }
    }
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::CopyLocalThemeToLive(int iTotalLength, 
    LPCWSTR pszThemeName, LPCWSTR pszColorParam, LPCWSTR pszSizeParam)
{
    int i;
    MIXEDPTRS u;
    HRESULT hr = S_OK;

    u.pb = (BYTE*) VirtualAlloc(_LoadingThemeFile._pbThemeData, sizeof(THEMEHDR), MEM_COMMIT, PAGE_READWRITE);
    if (u.pb == NULL)
    {
        return MakeError32(ERROR_NOT_ENOUGH_MEMORY);        
    }

    _iGlobalsOffset = -1;
    _iSysMetricsOffset = -1;
    int iIndexCount = _LocalIndexes.GetSize();

    //---- build header ----
    THEMEHDR *hdr = (THEMEHDR *)u.pb;
    u.pb += sizeof(THEMEHDR);

    hdr->dwTotalLength = iTotalLength;

    CopyMemory(hdr->szSignature, kszBeginCacheFileSignature, kcbBeginSignature);
        //  note: hdr->szSignature should not be null terminated

    hdr->dwVersion = THEMEDATA_VERSION;
    hdr->dwFlags = 0;       // not yet ready to be accessed

    hdr->iDllNameOffset = 0;     // will be updated
    hdr->iColorParamOffset = 0;  // will be updated
    hdr->iSizeParamOffset = 0;   // will be updated
    hdr->dwLangID = (DWORD) GetUserDefaultUILanguage();
    hdr->iLoadId = 0;            // was iLoadCounter
    
    hdr->iGlobalsOffset = 0;            // will be updated
    hdr->iGlobalsTextObjOffset = 0;     // will be updated
    hdr->iGlobalsDrawObjOffset = 0;     // will be updated

    hdr->dwCheckSum = 0;         // will be updated

    // Store the time stamp of the .msstyles file in the live file, this will be written to the cache file
    // for later comparison (Whistler:190202).
    ZeroMemory(&hdr->ftModifTimeStamp, sizeof hdr->ftModifTimeStamp);

    HANDLE hFile = CreateFile(pszThemeName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        // There's nothing we can do if GetFileTime() fails
        GetFileTime(hFile, NULL, NULL, &hdr->ftModifTimeStamp);
        CloseHandle(hFile);
    }

    //---- build string section ----
    hdr->iStringsOffset = THEME_OFFSET(u.pb);
    DWORD *pdwFirstString = u.pdw;  
    int len;

    //---- add header strings ----
    len = lstrlen(pszThemeName);
    if (len)
    {
        hr = EmitString(u, pszThemeName, len, &hdr->iDllNameOffset);
        if (FAILED(hr))
            goto exit;
    }
    
    len = lstrlen(pszColorParam);
    if (len)
    {
        hr = EmitString(u, pszColorParam, len, &hdr->iColorParamOffset);
        if (FAILED(hr))
            goto exit;
    }
    
    len = lstrlen(pszSizeParam);
    if (len)
    {
        hr = EmitString(u, pszSizeParam, len, &hdr->iSizeParamOffset);
        if (FAILED(hr))
            goto exit;
    }

    //---- add strings from class index ----
    for (i=0; i < iIndexCount; i++)
    {
        APPCLASSLOCAL *ac = &_LocalIndexes[i];

        int len = ac->csAppName.GetLength();
        if (len)
        {
            hr = EmitString(u, ac->csAppName, len, (int*) &ac->LiveIndex.dwAppNameIndex);
            if (FAILED(hr))
                goto exit;
        }
        else
            ac->LiveIndex.dwAppNameIndex = 0;

        len = ac->csClassName.GetLength();
        if (len)
        {
            hr = EmitString(u, ac->csClassName, len, (int*) &ac->LiveIndex.dwClassNameIndex);
            if (FAILED(hr))
                goto exit;
        }
        else
            ac->LiveIndex.dwClassNameIndex = 0;
    }

    //---- copy strings from LOADTHEMEMETRICS -----
    for (i=0; i < TM_STRINGCOUNT; i++)
    {
        CWideString *ws = &_LoadThemeMetrics.wsStrings[i];
        int len = ws->GetLength();
        if (len)
        {
            hr = EmitString(u, *ws, len, &_LoadThemeMetrics.iStringOffsets[i]);
            if (FAILED(hr))
                goto exit;
        }
        else
            _LoadThemeMetrics.iStringOffsets[i] = 0;
    }

    int iStringLength = int(u.pb - ((BYTE *)pdwFirstString));
    hdr->iStringsLength = iStringLength;

    //---- write index header ----
    hdr->iSectionIndexOffset = THEME_OFFSET(u.pb);
    hdr->iSectionIndexLength = iIndexCount * sizeof(APPCLASSLIVE);

    APPCLASSLIVE *acl = (APPCLASSLIVE *)u.pb;     // will write these in parallel with theme data
    hr = AllocateThemeFileBytes(u.pb, hdr->iSectionIndexLength);
    if (FAILED(hr))
        goto exit;

    u.pb += hdr->iSectionIndexLength;

    //---- write index AND theme data in parallel ----

    //---- first pass thru, copy [globals] and all [app::xxx] sections ----
    for (i=0; i < iIndexCount; i++)         // for each parent section 
    {
        APPCLASSLOCAL *ac = &_LocalIndexes[i];

        if ((i) && (! ac->LiveIndex.dwAppNameIndex))     // not an [app::] section
            continue;

        acl->dwAppNameIndex = ac->LiveIndex.dwAppNameIndex;
        acl->dwClassNameIndex = ac->LiveIndex.dwClassNameIndex;

        acl->iIndex = THEME_OFFSET(u.pb);

        if (AsciiStrCmpI(ac->csClassName, L"globals")== 0)      // globals section
            _iGlobalsOffset = acl->iIndex;

        hr = CopyClassGroup(ac, u, _iGlobalsOffset, acl->dwClassNameIndex);
        if (FAILED(hr))
            goto exit;

        acl->iLen = THEME_OFFSET(u.pb) - acl->iIndex;

        acl++;
    }

    //---- second pass thru, copy all non-[app::xxx] sections (except [globals]) ----
    for (i=0; i < iIndexCount; i++)         // for each parent section 
    {
        APPCLASSLOCAL *ac = &_LocalIndexes[i];

        if ((! i) || (ac->LiveIndex.dwAppNameIndex))     // don't process [app::] sections
            continue;

        acl->dwAppNameIndex = ac->LiveIndex.dwAppNameIndex;
        acl->dwClassNameIndex = ac->LiveIndex.dwClassNameIndex;

        acl->iIndex = THEME_OFFSET(u.pb);

        if (AsciiStrCmpI(ac->csClassName, L"sysmetrics")== 0)      // SysMetrics section
        {
            _iSysMetricsOffset = acl->iIndex;

            hr = EmitEntryHdr(u, TMT_THEMEMETRICS, TMT_THEMEMETRICS);
            if (FAILED(hr))
                goto exit;

            DWORD len = sizeof(THEMEMETRICS);
            
            hr = EmitAndCopyBlock(u, (BYTE*) (THEMEMETRICS*) &_LoadThemeMetrics, len);

            EndEntry(u);

            //---- add a "jump to parent" to be consistent (not used) ----
            hr = EmitEntryHdr(u, TMT_JUMPTOPARENT, TMT_JUMPTOPARENT);
            if (FAILED(hr))
                goto exit;

            hr = AllocateThemeFileBytes(u.pb, sizeof(int));
            if (FAILED(hr))
                goto exit;

            *u.pi++ = -1;
            EndEntry(u);
        }
        else            // regular section
        {
            hr = CopyClassGroup(ac, u, _iGlobalsOffset, acl->dwClassNameIndex);
            if (FAILED(hr))
                goto exit;
        }

        acl->iLen = THEME_OFFSET(u.pb) - acl->iIndex;
        acl++;
    }

    hr = EmitAndCopyBlock(u, (BYTE*) kszEndCacheFileSignature, kcbEndSignature);
    if (FAILED(hr))
        goto exit;
  
    //---- ensure we got the calc size right ----
    DWORD dwActualLen;
    dwActualLen = THEME_OFFSET(u.pb);
    if (hdr->dwTotalLength != dwActualLen)
    {
        //---- make this growable so we really have enough room ----
        //Log(LOG_TMCHANGE, L"ThemeLoader - calculated len=%d, actual len=%d", 
        //    hdr->dwTotalLength, dwActualLen);
        hdr->dwTotalLength = dwActualLen;         
    }

    Log(LOG_TMCHANGE, L"ThemeLoader - theme size: %d", dwActualLen);

    //----- update header fields ----
    hdr->dwFlags |= SECTION_READY;
    hdr->iGlobalsOffset = _iGlobalsOffset;
    hdr->iSysMetricsOffset = _iSysMetricsOffset;
    hdr->iGlobalsTextObjOffset = _iGlobalsTextObj;
    hdr->iGlobalsDrawObjOffset = _iGlobalsDrawObj;
    hdr->dwCheckSum = 0;  // Reserved for future use. (old checksum was too slow.).

exit:
    return hr;

}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::PackMetrics()
{
    //---- find the optional [SysMetrics] section ----
    int iIndexCount = _LocalIndexes.GetSize();
    APPCLASSLOCAL *ac = NULL;

    for (int i=0; i < iIndexCount; i++)
    {
        ac = &_LocalIndexes[i];
    
        if (AsciiStrCmpI(ac->csClassName, L"SysMetrics")==0)
            break;
    }

    if (i == iIndexCount)       // not found
        return S_OK;
    
    //---- walk thru the properties & put into _LoadThemeMetrics ----
    if (! ac->PartStateIndexes.GetSize())       // no data
        return S_OK;

    MIXEDPTRS u;
    //---- parts & states not allowed so just use entry "0" ----
    u.pb = _pbLocalData + ac->PartStateIndexes[0].iIndex;
    UCHAR *lastpb = u.pb + ac->PartStateIndexes[0].iLen;

    while ((u.pb < lastpb) && (*u.pw != TMT_JUMPTOPARENT))
    {
        UNPACKED_ENTRYHDR hdr;

        FillAndSkipHdr(u, &hdr);

        switch (hdr.ePrimVal)
        {
            case TMT_FONT:
                _LoadThemeMetrics.lfFonts[hdr.usTypeNum-TMT_FIRSTFONT] = *(LOGFONT *)u.pb;
                break;

            case TMT_COLOR:
                _LoadThemeMetrics.crColors[hdr.usTypeNum-TMT_FIRSTCOLOR] = *(COLORREF *)u.pb;
                break;

            case TMT_BOOL:
                _LoadThemeMetrics.fBools[hdr.usTypeNum-TMT_FIRSTBOOL] = (BOOL)*u.pb;
                break;

            case TMT_SIZE:
                _LoadThemeMetrics.iSizes[hdr.usTypeNum-TMT_FIRSTSIZE] = *(int *)u.pb;
                break;

            case TMT_INT:
                _LoadThemeMetrics.iInts[hdr.usTypeNum-TMT_FIRSTINT] = *(int *)u.pb;
                break;

            case TMT_STRING:
                _LoadThemeMetrics.wsStrings[hdr.usTypeNum-TMT_FIRSTSTRING] = (WCHAR *)u.pb;
                break;
        }

        u.pb += hdr.dwDataLen;      // skip to next entry
    }

    //---- compute packed size of theme metrics ----

    //---- the actual entry ----
    ac->iPackedSize = ENTRYHDR_SIZE + sizeof(THEMEMETRICS);

    //---- a "jump to parent" entry ----
    ac->iPackedSize += ENTRYHDR_SIZE + sizeof(int);

    //---- add strings used in sysmetrics ----
    for (i=0; i < TM_STRINGCOUNT; i++)
    {
        int len =  _LoadThemeMetrics.wsStrings[i].GetLength();
        ac->iPackedSize += sizeof(WCHAR)*(1 + len);
    }
    
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::PackThemeStructs()
{
    HRESULT hr = PackMetrics();
    if (FAILED(hr))
        return hr;

    //---- IMAGEDATA and TEXTDATA packing go here ----

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::PackAndLoadTheme(LPCWSTR pszThemeName, LPCWSTR pszColorParam,
        LPCWSTR pszSizeParam, HINSTANCE hInst)
{
    WCHAR szColor[MAX_PATH];
    WCHAR szSize[MAX_PATH];

    HRESULT hr = PackThemeStructs();        

    //---- if color not specifed, get default color ----
    if ((! pszColorParam) || (! *pszColorParam))     
    {
        hr = GetResString(hInst, L"COLORNAMES", 0, szColor, ARRAYSIZE(szColor));
        if (FAILED(hr))
            goto exit;

        pszColorParam = szColor;
    }

    //---- if size not specifed, get default size ----
    if ((! pszSizeParam) || (! *pszSizeParam))     
    {
        hr = GetResString(hInst, L"SIZENAMES", 0, szSize, ARRAYSIZE(szSize));
        if (FAILED(hr))
            goto exit;

        pszSizeParam = szSize;
    }

    hr = _LoadingThemeFile.CreateFile(MAX_SHAREDMEM_SIZE, TRUE);
    if (FAILED(hr))
        goto exit;

    //---- copy local theme data to live ----
    hr = CopyLocalThemeToLive(MAX_SHAREDMEM_SIZE, pszThemeName, pszColorParam, pszSizeParam);
    if (FAILED(hr))
        goto exit;

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::AddMissingParent(LPCWSTR pszAppName, LPCWSTR pszClassName, 
    int iPartNum, int iStateNum)
{
    //---- add missing parent section ----
    int iData = 0;
    int iStart = GetNextDataIndex();

    HRESULT hr = AddData(TMT_JUMPTOPARENT, TMT_JUMPTOPARENT, &iData, sizeof(iData));
    if (FAILED(hr))
        return hr;

    int iLen = GetNextDataIndex() - iStart;
    
    hr = AddIndexInternal(pszAppName, pszClassName, iPartNum, iStateNum, 
        iStart, iLen);
    if (FAILED(hr))
        return hr;
    
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::AddIndex(LPCWSTR pszAppName, LPCWSTR pszClassName, 
    int iPartNum, int iStateNum, int iIndex, int iLen)
{
    HRESULT hr;

    if (iPartNum)       // ensure parent exists
    {
        if (! IndexExists(pszAppName, pszClassName, 0, 0))
        {
            hr = AddMissingParent(pszAppName, pszClassName, 0, 0);
            if (FAILED(hr))
                return hr;
        }
    }


    if (iStateNum)      // ensure parent exists
    {
        if (! IndexExists(pszAppName, pszClassName, iPartNum, 0))
        {
            hr = AddMissingParent(pszAppName, pszClassName, iPartNum, 0);
            if (FAILED(hr))
                return hr;
        }
    }

    hr = AddIndexInternal(pszAppName, pszClassName, iPartNum, iStateNum, iIndex,
        iLen);
    if (FAILED(hr))
        return hr;
    
    return S_OK;
}
//---------------------------------------------------------------------------
BOOL CThemeLoader::IndexExists(LPCWSTR pszAppName, LPCWSTR pszClassName, 
    int iPartNum, int iStateNum)
{
    //---- try to find existing entry ----
    int cnt = _LocalIndexes.GetSize();

    for (int i=0; i < cnt; i++)
    {
        LPCWSTR localAppName = _LocalIndexes[i].csAppName;

        if ((pszAppName) && (*pszAppName))
        {
            if ((! localAppName) || (! *localAppName))
                continue;
            if (AsciiStrCmpI(pszAppName, localAppName) != 0)
                continue;
        }
        else if ((localAppName) && (*localAppName))
            continue;

        if (AsciiStrCmpI(pszClassName, _LocalIndexes[i].csClassName)==0)
            break;
    }

    if (i == cnt)       // not found
        return FALSE;

    //---- find matching child info ----
    APPCLASSLOCAL *acl = &_LocalIndexes[i];

    for (int c=0; c < acl->PartStateIndexes.m_nSize; c++)
    {
        if (acl->PartStateIndexes[c].iPartNum == iPartNum)
        {
            if (acl->PartStateIndexes[c].iStateNum == iStateNum)
                return TRUE;
        }
    }

    return FALSE;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::AddIndexInternal(LPCWSTR pszAppName, LPCWSTR pszClassName, 
    int iPartNum, int iStateNum, int iIndex, int iLen)
{
    //---- try to find existing entry ----
    int cnt = _LocalIndexes.GetSize();

    for (int i=0; i < cnt; i++)
    {
        LPCWSTR localAppName = _LocalIndexes[i].csAppName;

        if ((pszAppName) && (*pszAppName))
        {
            if ((! localAppName) || (! *localAppName))
                continue;
            if (AsciiStrCmpI(pszAppName, localAppName) != 0)
                continue;
        }
        else if ((localAppName) && (*localAppName))
            continue;

        if (AsciiStrCmpI(pszClassName, _LocalIndexes[i].csClassName)==0)
            break;
    }

    APPCLASSLOCAL *acl;

    if (i == cnt)       // not found - create a new entry
    {
        APPCLASSLOCAL local;

        local.csAppName = pszAppName;
        local.csClassName = pszClassName;
        local.iMaxPartNum = 0;
        local.iPackedSize = 0;

        _LocalIndexes.Add(local);

        int last = _LocalIndexes.GetSize()-1;
        acl = &_LocalIndexes[last];
    }
    else                // update existing entry with child info
    {    
        acl = &_LocalIndexes[i];

        // child info should not be there already
        for (int c=0; c < acl->PartStateIndexes.m_nSize; c++)
        {
            if (acl->PartStateIndexes[c].iPartNum == iPartNum)
            {
                if (acl->PartStateIndexes[c].iStateNum == iStateNum)
                {
                    return MakeError32(ERROR_ALREADY_EXISTS); 
                }
            }
        }
    }

    //---- add the part ----
    if (iPartNum > acl->iMaxPartNum)
        acl->iMaxPartNum = iPartNum;

    PART_STATE_INDEX psi;
    psi.iPartNum = iPartNum;
    psi.iStateNum = iStateNum;
    psi.iIndex = iIndex;
    psi.iLen = iLen;

    acl->PartStateIndexes.Add(psi);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::AddData(SHORT sTypeNum, PRIMVAL ePrimVal, const void *pData, DWORD dwLen)
{
    DWORD dwFullLen = ENTRYHDR_SIZE + dwLen;
    HRESULT hr;
    BYTE bFiller = ALIGN_FACTOR - 1;

    MIXEDPTRS u;
    u.pb = _pbLocalData + _iLocalLen;

    //---- add to local copy of theme data ----
    if ((PtrToUint(u.pb) / _dwPageSize != PtrToUint(u.pb + dwFullLen + bFiller) / _dwPageSize)
        || _iLocalLen == 0)
    {
        if (NULL == VirtualAlloc(_pbLocalData, _iLocalLen + 1 + dwFullLen + bFiller, MEM_COMMIT, PAGE_READWRITE))
        {
            return MakeError32(ERROR_NOT_ENOUGH_MEMORY);        
        }
    }

    hr = EmitEntryHdr(u, sTypeNum, ePrimVal);
    if (FAILED(hr))
        goto exit;

    if (dwLen)
    {
        CopyMemory(u.pb, pData, dwLen);
        u.pb += dwLen;
    }

    //---- this may generate filler bytes ----
    bFiller = (BYTE)EndEntry(u);

    _iLocalLen += (dwFullLen + bFiller);

exit:
    return hr;
}
//---------------------------------------------------------------------------
int CThemeLoader::GetNextDataIndex()
{
    return _iLocalLen;
}
//---------------------------------------------------------------------------
void SetSysBool(THEMEMETRICS* ptm, int iBoolNum, int iSpiSetNum)
{
    BOOL fVal = ptm->fBools[iBoolNum - TMT_FIRSTBOOL];
    BOOL fSet = ClassicSystemParametersInfo(iSpiSetNum, 0, IntToPtr(fVal), SPIF_SENDCHANGE | SPIF_UPDATEINIFILE);
    if (! fSet)
    {
        Log(LOG_ALWAYS, L"Error returned from ClassicSystemParametersInfo() call to set BOOL");
    }
}
//---------------------------------------------------------------------------
void SetSystemMetrics_Worker(THEMEMETRICS* ptm)
{
#ifdef DEBUG
    if (LogOptionOn(LO_TMLOAD))
    {
        WCHAR szUserName[MAX_PATH];
        DWORD dwSize = ARRAYSIZE(szUserName);
    
        GetUserName(szUserName, &dwSize);

        Log(LOG_TMLOAD, L"SetSystemMetrics_Worker: User=%s, SM_REMOTESESSION=%d", 
            szUserName, GetSystemMetrics(SM_REMOTESESSION));
    }
#endif
    //---- apply nonclient metrics ----
    NONCLIENTMETRICS ncm = {sizeof(ncm)};
    BOOL fSet;

    //----- scale all sizes from 96-dpi to match current screen logical DPI ----
    ncm.iBorderWidth = ScaleSizeForScreenDpi(ptm->iSizes[TMT_SIZINGBORDERWIDTH - TMT_FIRSTSIZE]);

    ncm.iCaptionWidth = ScaleSizeForScreenDpi(ptm->iSizes[TMT_CAPTIONBARWIDTH - TMT_FIRSTSIZE]);
    ncm.iCaptionHeight = ScaleSizeForScreenDpi(ptm->iSizes[TMT_CAPTIONBARHEIGHT - TMT_FIRSTSIZE]);
    
    ncm.iSmCaptionWidth = ScaleSizeForScreenDpi(ptm->iSizes[TMT_SMCAPTIONBARWIDTH - TMT_FIRSTSIZE]);
    ncm.iSmCaptionHeight = ScaleSizeForScreenDpi(ptm->iSizes[TMT_SMCAPTIONBARHEIGHT - TMT_FIRSTSIZE]);
    
    ncm.iMenuWidth = ScaleSizeForScreenDpi(ptm->iSizes[TMT_MENUBARWIDTH - TMT_FIRSTSIZE]);
    ncm.iMenuHeight = ScaleSizeForScreenDpi(ptm->iSizes[TMT_MENUBARHEIGHT - TMT_FIRSTSIZE]);
    
    ncm.iScrollWidth = ScaleSizeForScreenDpi(ptm->iSizes[TMT_SCROLLBARWIDTH - TMT_FIRSTSIZE]);
    ncm.iScrollHeight = ScaleSizeForScreenDpi(ptm->iSizes[TMT_SCROLLBARHEIGHT - TMT_FIRSTSIZE]);

    //---- transfer font info (stored internally at 96 dpi) ----
    ncm.lfCaptionFont = ptm->lfFonts[TMT_CAPTIONFONT - TMT_FIRSTFONT];
    ncm.lfSmCaptionFont = ptm->lfFonts[TMT_SMALLCAPTIONFONT - TMT_FIRSTFONT];
    ncm.lfMenuFont = ptm->lfFonts[TMT_MENUFONT - TMT_FIRSTFONT];
    ncm.lfStatusFont = ptm->lfFonts[TMT_STATUSFONT - TMT_FIRSTFONT];
    ncm.lfMessageFont = ptm->lfFonts[TMT_MSGBOXFONT - TMT_FIRSTFONT];

    //---- scale fonts (from 96 dpi to current screen dpi) ----
    ScaleFontForScreenDpi(&ncm.lfCaptionFont);
    ScaleFontForScreenDpi(&ncm.lfSmCaptionFont);
    ScaleFontForScreenDpi(&ncm.lfMenuFont);
    ScaleFontForScreenDpi(&ncm.lfStatusFont);
    ScaleFontForScreenDpi(&ncm.lfMessageFont);

    fSet = ClassicSystemParametersInfo(SPI_SETNONCLIENTMETRICS,
                                       sizeof(NONCLIENTMETRICS),
                                       &ncm, 
                                       SPIF_SENDCHANGE | SPIF_UPDATEINIFILE);
    if (! fSet)
    {
        Log(LOG_ALWAYS, L"Error returned from ClassicSystemParametersInfo(SPI_SETNONCLIENTMETRICS)");
    }

    //---- apply the remaining font ----
    LOGFONT lf = ptm->lfFonts[TMT_ICONTITLEFONT - TMT_FIRSTFONT];
    ScaleFontForScreenDpi(&lf);
    fSet = ClassicSystemParametersInfo(SPI_SETICONTITLELOGFONT,
                                       sizeof(LOGFONT),
                                       &lf, 
                                       SPIF_SENDCHANGE | SPIF_UPDATEINIFILE);
    if (! fSet)
    {
        Log(LOG_ALWAYS, L"Error returned from ClassicSystemParametersInfo(SPI_SETICONTITLELOGFONT)");
    }

    //---- apply the sys bools (one at a time, unfortunately) ----
    SetSysBool(ptm, TMT_FLATMENUS, SPI_SETFLATMENU);

    //---- apply system colors ----
    int iIndexes[TM_COLORCOUNT];
    for (int i=0; i < TM_COLORCOUNT; i++)
    {
        iIndexes[i] = i;
    }

    fSet = SetSysColors(TM_COLORCOUNT, iIndexes, ptm->crColors);
    if (! fSet)
    {
        Log(LOG_ALWAYS, L"Error returned from SetSysColors()");
    }

    HRESULT hr = PersistSystemColors(ptm);     // write them to registry
    if (FAILED(hr))
    {
        Log(LOG_ALWAYS, L"failed to persist SysColors");
    }
}
//---------------------------------------------------------------------------
STDAPI_(DWORD) SetSystemMetrics_WorkerThread(void* pv)
{
    THEMEMETRICS_THREADINFO* ptm = (THEMEMETRICS_THREADINFO*)pv;
    ASSERT(ptm);
    
    BOOL fSuccess = TRUE;

    if (ptm->hUserToken)
    {
        fSuccess = ImpersonateLoggedOnUser(ptm->hUserToken);

        if (!fSuccess)
        {
            Log(LOG_ALWAYS, L"ImpersonateLoggedOnUser failed in SetSystemMetrics");
        }
    }
    
    if (fSuccess)
    {
        SetSystemMetrics_Worker(&ptm->tm);
    }

    if (ptm->hUserToken)
    {
        if (fSuccess)
        {
            RevertToSelf();
        }
        CloseHandle(ptm->hUserToken);
    }
    
    LocalFree(ptm);
    
    FreeLibraryAndExitThread(g_hInst, 0);
}
//---------------------------------------------------------------------------
void SetSystemMetrics(THEMEMETRICS* ptm, BOOL fSyncLoad)
{
    if (ptm != NULL)
    {
        BOOL    fSuccess = FALSE;
        HMODULE hmod;

        if (!fSyncLoad)      // ok to use a new thread
        {
            // add a dllref for the thread we are creating
            hmod = LoadLibrary(TEXT("uxtheme.dll"));
            if (hmod)
            {
                THEMEMETRICS_THREADINFO* ptmCopy = (THEMEMETRICS_THREADINFO*)LocalAlloc(LPTR, sizeof(THEMEMETRICS_THREADINFO));

                if (ptmCopy)
                {
                    // fill in all of the thememetrics info for the thread we are going to create
                    CopyMemory(ptmCopy, ptm, sizeof(THEMEMETRICS));

                    HANDLE hToken = NULL;
                    // If the calling thread is impersonating, use the same token
                    // OpenThreadToken can fail if the thread is not impersonating
                    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, FALSE, &hToken))
                    {
                        ptmCopy->hUserToken = hToken;

                        // we want to do this async since we end up calling xxxSendMessage for a TON of things which blocks this 
                        // thread which can cause deadlocks
                        HANDLE hThread = CreateThread(NULL, 0, SetSystemMetrics_WorkerThread, ptmCopy,  0, NULL);

                        if (hThread)
                        {
                            CloseHandle(hThread);
                            fSuccess = TRUE;
                        }
                    }
                    else
                    {
                        Log(LOG_TMCHANGE, L"OpenThreadToken failed in SetSystemMetrics, last error=%d", GetLastError());
                    }


                    if (!fSuccess)
                    {
                        LocalFree(ptmCopy);
                    }
                }

                if (!fSuccess)
                {
                    FreeLibrary(hmod);
                }
            }
        }

        if (!fSuccess)
        {
            // failed, fall back to calling synchronously
            SetSystemMetrics_Worker(ptm);
        }
    }
}
//---------------------------------------------------------------------------
void SetFont(LOGFONT *plf, LPCWSTR lszFontName, int iPointSize)
{
    memset(plf, 0, sizeof(*plf));

    plf->lfWeight = FW_NORMAL;
    plf->lfCharSet = DEFAULT_CHARSET;
    plf->lfHeight = iPointSize;

    StringCchCopyW(plf->lfFaceName, ARRAYSIZE(plf->lfFaceName), lszFontName);
}
//---------------------------------------------------------------------------
COLORREF DefaultColors[] = 
{
    RGB(212, 208, 200),     // Scrollbar (0)
    RGB(58, 110, 165),      // Background (1)
    RGB(10, 36, 106),       // ActiveCaption (2)
    RGB(128, 128, 128),     // InactiveCaption (3)
    RGB(212, 208, 200),     // Menu (4)
    RGB(255, 255, 255),     // Window (5)
    RGB(0, 0, 0),           // WindowFrame (6)
    RGB(0, 0, 0),           // MenuText (7)
    RGB(0, 0, 0),           // WindowText (8)
    RGB(255, 255, 255),     // CaptionText (9)
    RGB(212, 208, 200),     // ActiveBorder (10)
    RGB(212, 208, 200),     // InactiveBorder (11)
    RGB(128, 128, 128),     // AppWorkSpace (12)
    RGB(10, 36, 106),       // Highlight (13)
    RGB(255, 255, 255),     // HighlightText (14)
    RGB(212, 208, 200),     // BtnFace (15)
    RGB(128, 128, 128),     // BtnShadow (16)
    RGB(128, 128, 128),     // GrayText (17)
    RGB(0, 0, 0),           // BtnText (18)
    RGB(212, 208, 200),     // InactiveCaptionText (19)
    RGB(255, 255, 255),     // BtnHighlight (20)
    RGB(64, 64, 64),        // DkShadow3d (21)
    RGB(212, 208, 200),     // Light3d (22)
    RGB(0, 0, 0),           // InfoText (23)
    RGB(255, 255, 225),     // InfoBk (24)
    RGB(181, 181, 181),     // ButtonAlternateFace (25)
    RGB(0, 0, 128),         // HotTracking (26)
    RGB(166, 202, 240),     // GradientActiveCaption (27)
    RGB(192, 192, 192),     // GradientInactiveCaption (28)
    RGB(206, 211, 225),     // MenuiHilight (29)
    RGB(244, 244, 240),     // MenuBar (30)
};
//---------------------------------------------------------------------------
HRESULT InitThemeMetrics(LOADTHEMEMETRICS *tm)
{
    memset(tm, 0, sizeof(*tm));     // zero out in case we miss a property

    //---- init fonts ----
    SetFont(&tm->lfFonts[TMT_CAPTIONFONT - TMT_FIRSTFONT], L"tahoma bold", POINTS_DPI96(8));
    SetFont(&tm->lfFonts[TMT_SMALLCAPTIONFONT - TMT_FIRSTFONT], L"tahoma", POINTS_DPI96(8));
    SetFont(&tm->lfFonts[TMT_MENUFONT - TMT_FIRSTFONT], L"tahoma", POINTS_DPI96(8));
    SetFont(&tm->lfFonts[TMT_STATUSFONT - TMT_FIRSTFONT], L"tahoma", POINTS_DPI96(8));
    SetFont(&tm->lfFonts[TMT_MSGBOXFONT - TMT_FIRSTFONT], L"tahoma", POINTS_DPI96(8));
    SetFont(&tm->lfFonts[TMT_ICONTITLEFONT - TMT_FIRSTFONT], L"tahoma", POINTS_DPI96(8));

    //---- init bools ----
    tm->fBools[TMT_FLATMENUS - TMT_FIRSTBOOL] = FALSE;

    //---- init sizes ----
    tm->iSizes[TMT_SIZINGBORDERWIDTH - TMT_FIRSTSIZE] = 1;
    tm->iSizes[TMT_SCROLLBARWIDTH - TMT_FIRSTSIZE] = 16;
    tm->iSizes[TMT_SCROLLBARHEIGHT - TMT_FIRSTSIZE] = 16;
    tm->iSizes[TMT_CAPTIONBARWIDTH - TMT_FIRSTSIZE] = 18;
    tm->iSizes[TMT_CAPTIONBARHEIGHT - TMT_FIRSTSIZE] = 19;
    tm->iSizes[TMT_SMCAPTIONBARWIDTH - TMT_FIRSTSIZE] = 12;
    tm->iSizes[TMT_SMCAPTIONBARHEIGHT - TMT_FIRSTSIZE] = 19;
    tm->iSizes[TMT_MENUBARWIDTH - TMT_FIRSTSIZE] = 18;
    tm->iSizes[TMT_MENUBARHEIGHT - TMT_FIRSTSIZE] = 19;

    //---- init strings ----
    tm->iStringOffsets[TMT_CSSNAME - TMT_FIRSTSTRING] = 0;
    tm->iStringOffsets[TMT_XMLNAME - TMT_FIRSTSTRING] = 0;

    tm->wsStrings[TMT_CSSNAME - TMT_FIRSTSTRING] = L"";
    tm->wsStrings[TMT_XMLNAME - TMT_FIRSTSTRING] = L"";
    
    //---- init ints ----
    tm->iInts[TMT_MINCOLORDEPTH - TMT_FIRSTINT] = 16;

    //---- init colors ----
    for (int i=0; i < TM_COLORCOUNT; i++)
        tm->crColors[i] = DefaultColors[i];

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT PersistSystemColors(THEMEMETRICS *tm)
{
    HRESULT         hr;
    LONG            lErrorCode;
    HKEY            hkcu;
    CCurrentUser    hKeyCurrentUser(KEY_SET_VALUE);

    lErrorCode = RegOpenKeyEx(hKeyCurrentUser,
                              REGSTR_PATH_COLORS,
                              0,
                              KEY_SET_VALUE,
                              &hkcu);
    if (ERROR_SUCCESS == lErrorCode)
    {
        hr = S_OK;

        //---- believe it or not, we have to manually write each color ----
        //---- as a string to the registry to persist them ----

        ASSERT(iSysColorSize == TM_COLORCOUNT);       // should also match winuser.h entries

        //---- are gradients turned on? ----
        BOOL fGradientsEnabled = FALSE;  
        ClassicSystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, (LPVOID)&fGradientsEnabled, 0);

        //---- enough colors for a gradient? ----
        HDC hdc = GetDC(NULL);
        if (hdc)
        {
            if (GetDeviceCaps(hdc, BITSPIXEL) <= 8)
                fGradientsEnabled = FALSE;
            ReleaseDC(NULL, hdc);
        }

        for (int i=0; i < iSysColorSize; i++)
        {
            // If this is the Gradient Caption setting and the system does
            // not currently show gradient captions then don't write them out
            // to the theme file.
            if ((i == COLOR_GRADIENTACTIVECAPTION) || (i == COLOR_GRADIENTINACTIVECAPTION))
            {
                if (! fGradientsEnabled)
                    continue;
            }

            //---- translate color into "r, g, b" value string ----
            WCHAR buff[100];
            COLORREF cr = tm->crColors[i];
            StringCchPrintfW(buff, ARRAYSIZE(buff), L"%d %d %d", RED(cr), GREEN(cr), BLUE(cr));

            //---- write color key/value to registry ----
            lErrorCode = RegSetValueEx(hkcu,
                                       pszSysColorNames[i],
                                       0,
                                       REG_SZ,
                                       reinterpret_cast<BYTE*>(buff),
                                       (lstrlen(buff) + 1) * sizeof(WCHAR));
            if (ERROR_SUCCESS != lErrorCode)
            {
                if (SUCCEEDED(hr))
                {
                    hr = MakeError32(lErrorCode);
                }
            }
        }
        (LONG)RegCloseKey(hkcu);
    }
    else
    {
        hr = MakeError32(lErrorCode);
    }

    return hr;
}
//---------------------------------------------------------------------------
BOOL CThemeLoader::KeyDrawPropertyFound(int iStateDataOffset)
{
    BOOL fFound = FALSE;
    MIXEDPTRS u;
    UNPACKED_ENTRYHDR hdr;
    
    u.pb = _LoadingThemeFile._pbThemeData + iStateDataOffset;

    while (*u.ps != TMT_JUMPTOPARENT)
    {
        if (CBorderFill::KeyProperty((*u.ps)))
        {
            fFound = TRUE;
            break;
        }

        if (CImageFile::KeyProperty((*u.ps)))
        {
            fFound = TRUE;
            break;
        }

        //---- skip to next entry ----
        FillAndSkipHdr(u, &hdr);
        u.pb += hdr.dwDataLen;
    }

    return fFound;
}
//---------------------------------------------------------------------------
BOOL CThemeLoader::KeyTextPropertyFound(int iStateDataOffset)
{
    BOOL fFound = FALSE;
    MIXEDPTRS u;
    UNPACKED_ENTRYHDR hdr;

    u.pb = _LoadingThemeFile._pbThemeData + iStateDataOffset;

    while (*u.ps != TMT_JUMPTOPARENT)
    {
        if (CTextDraw::KeyProperty((*u.ps)))
        {
            fFound = TRUE;
            break;
        }

        //---- skip to next entry ----
        FillAndSkipHdr(u, &hdr);
        u.pb += hdr.dwDataLen;
    }

    return fFound;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::PackImageFileInfo(DIBINFO *pdi, CImageFile *pImageObj, MIXEDPTRS &u, 
    CRenderObj *pRender, int iPartId, int iStateId)
{
    HRESULT hr = S_OK;

    //---- write custom region data ----
    int iMaxState;
    if ((! iStateId) && (pImageObj->HasRegionImageFile(pdi, &iMaxState)))
    {
        //---- update object's _iRgnDataOffset field ----
        pImageObj->SetRgnListOffset(pdi, THEME_OFFSET(u.pb));

        //---- write the TMT_RGNLIST entry ----
        hr = EmitEntryHdr(u, TMT_RGNLIST, TMT_RGNLIST);
        if (FAILED(hr))
            goto exit;

        int cEntries = iMaxState + 1;         // number of jump table entries

        hr = AllocateThemeFileBytes(u.pb, 1 + cEntries * sizeof(int));
        if (FAILED(hr))
            goto exit;

        *u.pb++ = static_cast<BYTE>(cEntries);

        //---- write jump table now and update asap ----
        int *piJumpTable = u.pi;

        for (int i=0; i <= iMaxState; i++)
            *u.pi++ = 0;

        for (int iRgnState=0; iRgnState <= iMaxState; iRgnState++)
        {
            //---- build & pack custom region data for each state in this object's imagefile ----
            CAutoArrayPtr<RGNDATA> pRgnData;
            int iDataLen;

            hr = pImageObj->BuildRgnData(pdi, pRender, iRgnState, &pRgnData, &iDataLen);
            if (FAILED(hr))
                goto exit;

            if (iDataLen)       // if we got a non-empty region
            {
                piJumpTable[iRgnState] = THEME_OFFSET(u.pb);

                RGNDATAHDR rdHdr = {iPartId, iRgnState, 0};

                //---- copy rgndata hdr ----
                hr = EmitObject(u, TMT_RGNDATA, TMT_RGNDATA, &rdHdr, sizeof(rdHdr), pRgnData, iDataLen);
                if (FAILED(hr))
                    goto exit;
            }
        }

        EndEntry(u);
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::PackDrawObject(MIXEDPTRS &u, CRenderObj *pRender, int iPartId, 
    int iStateId)
{
    HRESULT hr = S_OK;

    BGTYPE eBgType;
    if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_BGTYPE, (int *)&eBgType)))
        eBgType = BT_BORDERFILL;      // default value

    DRAWOBJHDR hdr = {iPartId, iStateId};

    if ((eBgType == BT_BORDERFILL) || (eBgType == BT_NONE))
    {
        CBorderFill bfobj;

        hr = bfobj.PackProperties(pRender, (eBgType == BT_NONE), iPartId, iStateId);
        if (FAILED(hr))
            goto exit;

        //---- copy "bfobj" to packed bytes ----
                
        hr = EmitObject(u, TMT_DRAWOBJ, TMT_DRAWOBJ, &hdr, sizeof(hdr), &bfobj, sizeof(bfobj));
        if (FAILED(hr))
            goto exit;
    }
    else            // imagefile
    {
        CMaxImageFile maxif;
        int iMultiCount;

        hr = maxif.PackMaxProperties(pRender, iPartId, iStateId, &iMultiCount);
        if (FAILED(hr))
            goto exit;

        //---- process all DIBINFO structs in the CImageFile obj ----
        for (int i=0; ; i++)
        {
            DIBINFO *pdi = maxif.EnumImageFiles(i);
            if (! pdi)
                break;
    
            hr = PackImageFileInfo(pdi, &maxif, u, pRender, iPartId, iStateId);
            if (FAILED(hr))
                goto exit;
        }

        //---- copy imagefile obj & multi DIB's to packed bytes ----
        DWORD dwLen = sizeof(CImageFile) + sizeof(DIBINFO)*iMultiCount;

        hr = EmitObject(u, TMT_DRAWOBJ, TMT_DRAWOBJ, &hdr, sizeof(hdr), &maxif, dwLen);
        if (FAILED(hr))
            goto exit;
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::PackTextObject(MIXEDPTRS &u, CRenderObj *pRender, int iPartId, int iStateId)
{
    HRESULT hr;
    DRAWOBJHDR hdr = {iPartId, iStateId};
    CTextDraw ctobj;

    hr = ctobj.PackProperties(pRender, iPartId, iStateId);
    if (FAILED(hr))
        goto exit;

    hr = EmitObject(u, TMT_TEXTOBJ, TMT_TEXTOBJ, &hdr, sizeof(hdr), &ctobj, sizeof(ctobj));
    if (FAILED(hr))
        goto exit;

exit:
    return hr;
}
//---------------------------------------------------------------------------
int CThemeLoader::GetPartOffset(CRenderObj *pRender, int iPartNum)
{
    int iOffset;
    int iPartCount;
    MIXEDPTRS u;

    //---- see if state table exists for this part ----
    u.pb = pRender->_pbSectionData;

    if (*u.ps != TMT_PARTJUMPTABLE)
    {
        iOffset = -1;
        goto exit;
    }

    u.pb += ENTRYHDR_SIZE + sizeof(int);       // skip over hdr + PackedObjOffset
    iPartCount = *u.pb++;
    
    if (iPartNum >= iPartCount)    // iPartCount is MaxPart+1
    {
        iOffset = -1;
        goto exit;
    }

    iOffset = u.pi[iPartNum];

exit:
    return iOffset;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::PackDrawObjects(MIXEDPTRS &uOut, CRenderObj *pRender, 
    int iMaxPart, BOOL fGlobals)
{
    HRESULT hr = S_OK;
    MIXEDPTRS u;

    //---- build a draw obj for each part ----
    for (int iPart=0; iPart <= iMaxPart; iPart++)
    {
        int iPartOff = GetPartOffset(pRender, iPart);
        if (iPartOff == -1)
            continue;

        u.pb = _LoadingThemeFile._pbThemeData + iPartOff;

        if (*u.ps == TMT_STATEJUMPTABLE)
        {
            u.pb += ENTRYHDR_SIZE;
            int iMaxState = (*u.pb++) - 1;
            int *piStateJumpTable = u.pi;

            //---- build a draw obj for each needed state ----
            for (int iState=0; iState <= iMaxState; iState++)
            {
                int iStateDataOffset = piStateJumpTable[iState];
                if (iStateDataOffset == -1)
                    continue;

                if ((fGlobals) || (KeyDrawPropertyFound(iStateDataOffset)))
                {
                    hr = PackDrawObject(uOut, pRender, iPart, iState);
                    if (FAILED(hr))
                        goto exit;

                    if (fGlobals)       // just needed to force (part=0, state=0)
                        fGlobals = FALSE;
                }
            }
        }
        else            // no state jump table
        {
            if ((fGlobals) || (KeyDrawPropertyFound(THEME_OFFSET(u.pb))))
            {
                hr = PackDrawObject(uOut, pRender, iPart, 0);
                if (FAILED(hr))
                    goto exit;
            }
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::PackTextObjects(MIXEDPTRS &uOut, CRenderObj *pRender, 
    int iMaxPart, BOOL fGlobals)
{
    HRESULT hr = S_OK;
    MIXEDPTRS u;

    //---- build a text obj for each part ----
    for (int iPart=0; iPart <= iMaxPart; iPart++)
    {
        int iPartOff = GetPartOffset(pRender, iPart);
        if (iPartOff == -1)
            continue;

        u.pb = _LoadingThemeFile._pbThemeData + iPartOff;

        if (*u.ps == TMT_STATEJUMPTABLE)
        {
            u.pb += ENTRYHDR_SIZE;
            int iMaxState = (*u.pb++) - 1;
            int *piStateJumpTable = u.pi;

            //---- build a text obj for each needed state ----
            for (int iState=0; iState <= iMaxState; iState++)
            {
                int iStateDataOffset = piStateJumpTable[iState];
                if (iStateDataOffset == -1)
                    continue;

                if ((fGlobals) || (KeyTextPropertyFound(iStateDataOffset)))
                {
                    hr = PackTextObject(uOut, pRender, iPart, iState);
                    if (FAILED(hr))
                        goto exit;

                    if (fGlobals)       // just needed to force (part=0, state=0)
                        fGlobals = FALSE;
                }
            }
        }
        else            // no state jump table
        {
            if ((fGlobals) || (KeyTextPropertyFound(THEME_OFFSET(u.pb))))
            {
                hr = PackTextObject(uOut, pRender, iPart, 0);
                if (FAILED(hr))
                    goto exit;
            }
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::EmitEntryHdr(MIXEDPTRS &u, SHORT propnum, BYTE privnum)
{
    HRESULT hr = S_OK;

    if (_iEntryHdrLevel == MAX_ENTRY_NESTING)
    {
        Log(LOG_ERROR, L"Maximum entry nesting exceeded");
        hr = E_FAIL;
        goto exit;
    }

    if (_LoadingThemeFile._pbThemeData != NULL)
    {
        hr = AllocateThemeFileBytes(u.pb, ENTRYHDR_SIZE);
        if (FAILED(hr))
            goto exit;
    }

    //---- bump up the nesting level of entries ----
    _iEntryHdrLevel++;

    *u.ps++ = propnum;
    *u.pb++ = privnum;

    _pbEntryHdrs[_iEntryHdrLevel] = u.pb;    // used to update next 2 fields in EndEntry()

    *u.pb++ = 0;        // filler to align end of data to 4/8 bytes
    *u.pi++ = 0;        // length 

exit:
    return hr;
}
//---------------------------------------------------------------------------
int CThemeLoader::EndEntry(MIXEDPTRS &u)
{
    MIXEDPTRS uHdr;
    uHdr.pb = _pbEntryHdrs[_iEntryHdrLevel];

    //---- calcuate actual length of date emitted ----
    int iActualLen = (int)(u.pb - (uHdr.pb + sizeof(BYTE) + sizeof(int)));

    //---- calculate filler to be aligned ----
    int iAlignLen = ((iActualLen + ALIGN_FACTOR - 1)/ALIGN_FACTOR) * ALIGN_FACTOR;
    BYTE bFiller = (BYTE)(iAlignLen - iActualLen);

    if (_LoadingThemeFile._pbThemeData != NULL)
    {
        HRESULT hr = AllocateThemeFileBytes(u.pb, bFiller);
        if (FAILED(hr))
            return -1;
    }

    //---- emit filler bytes to be correctly aligned ----
    for (int i=0; i < bFiller; i++)
        *u.pb++ = 0 ;

    //---- update the entry Hdr ----
    *uHdr.pb++ = bFiller;
    *uHdr.pi++ = iAlignLen;

    //---- decrement the nesting level of entries ----
    _iEntryHdrLevel--;

    return bFiller;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\messagebroadcast.h ===
//  --------------------------------------------------------------------------
//  Module Name: MessageBroadcast.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to manager sending or posting messages to windows to tell them that
//  things have changed.
//
//  History:    2000-11-11  vtan        created (split from services.cpp)
//  --------------------------------------------------------------------------
#ifndef     _MessageBroadcast_
#define     _MessageBroadcast_
//  --------------------------------------------------------------------------
#include "SimpStr.h"
//  --------------------------------------------------------------------------
enum MSG_TYPE
{
    MT_SIMPLE,    
    MT_ALLTHREADS,          // send at least one msg to each thread/window in system
    MT_FILTERED,            // by processid, HWND, exclude
};
//  --------------------------------------------------------------------------
class CThemeFile;       // forward
//  --------------------------------------------------------------------------
//  CMessageBroadcast
//
//  Purpose:    Class used internally to assist with message sending which
//              must be done on the client side on behalf of the server.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

class   CMessageBroadcast
{
    public:
                                    CMessageBroadcast (BOOL fAllDesktops=TRUE);
                                    ~CMessageBroadcast (void);

                void                PostSimpleMsg(UINT msg, WPARAM wParam, LPARAM lParam);
                void                PostAllThreadsMsg(UINT msg, WPARAM wParam, LPARAM lParam);

                void                PostFilteredMsg(UINT msg, WPARAM wParam, LPARAM lParam, 
                                        HWND hwndTarget, BOOL fProcess, BOOL fExclude);

    private:
        static  BOOL    CALLBACK    DesktopCallBack(LPTSTR lpszDesktop, LPARAM lParam);
        static  BOOL    CALLBACK    TopWindowCallBack(HWND hwnd, LPARAM lParam);
        static  BOOL    CALLBACK    ChildWindowCallBack(HWND hwnd, LPARAM lParam);
                void                Worker(HWND hwnd);
                void                EnumRequestedWindows();


    private:
                MSG                 _msg;
                HWND                _hwnd;
                DWORD               _dwProcessID;
                BOOL                _fExclude;
                MSG_TYPE            _eMsgType;
                BOOL                _fAllDesktops;
                CSimpleArray<DWORD> _ThreadsProcessed;

};

#endif  /*  _MessageBroadcast_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\paramchecks.h ===
//---------------------------------------------------------------------------
//  ParamChecks.h
//---------------------------------------------------------------------------
//  these param checkers are needed for both RETAIL and DEBUG
//---------------------------------------------------------------------------
//  CThemeApiHelper class:
//    - automatically logs entry/exit to function
//    - automatically does a "CloseHandle" on pRenderObj at exit
//    - holds _pszFuncName for use by param validating macros
//---------------------------------------------------------------------------
class CThemeApiHelper
{
public:
    inline CThemeApiHelper(LPCWSTR pszFuncName, HTHEME hTheme)
    {
        _iRenderSlotNum = -1;           // not yet set
        _pszFuncName = pszFuncName;

        if (! hTheme)
        {
            LogEntryW(_pszFuncName);
        }
    }

    inline ~CThemeApiHelper()
    {
        CloseHandle();

        LogExit(_pszFuncName);
    }

    inline HRESULT OpenHandle(HTHEME hTheme, CRenderObj **ppRenderObj)
    {
        CloseHandle();

        HRESULT hr = g_pRenderList->OpenThemeHandle(hTheme, 
            ppRenderObj, &_iRenderSlotNum);
        if (SUCCEEDED(hr))
        {
            LogEntryCW(_pszFuncName, CLASSPTR(*ppRenderObj));
        }
        else
        {
            Log(LOG_PARAMS, L"Bad HTHEME param in call to %s", _pszFuncName);
        }

        return hr;
    }

    inline void CloseHandle()
    {
        if (_iRenderSlotNum > -1)
        {
            g_pRenderList->CloseThemeHandle(_iRenderSlotNum);
            _iRenderSlotNum = -1;
        }
    }

public:
    LPCWSTR _pszFuncName;

private:
    int _iRenderSlotNum;
    int _iEntryValue;                // for log resource leak checking
};
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
#ifdef DEBUG
#define APIHELPER(Name, hTheme) CThemeApiHelper ApiHelper(Name, hTheme)
#else
#define APIHELPER(Name, hTheme) CThemeApiHelper ApiHelper(NULL, hTheme)
#endif
//---------------------------------------------------------------------------
#define VALIDATE_THEME_HANDLE(helper, hTheme, ppRenderObj)   \
{    \
    HRESULT hr = helper.OpenHandle(hTheme, ppRenderObj);  \
    RETURN_VALIDATE_RETVAL(hr);   \
} 
//---------------------------------------------------------------------------
#define VALIDATE_READ_PTR(helper, p, iSize)     \
{      \
    if (IsBadReadPtr(p, iSize))  \
    {     \
        Log(LOG_PARAMS, L"Bad output PTR param in call to %s", helper._pszFuncName);  \
        RETURN_VALIDATE_RETVAL(E_POINTER);    \
    }    \
}
//---------------------------------------------------------------------------
#define VALIDATE_WRITE_PTR(helper, p, iSize)        \
{         \
    if (IsBadWritePtr(p, iSize))  \
    {     \
        Log(LOG_PARAMS, L"Bad output PTR param in call to %s", helper._pszFuncName);  \
        RETURN_VALIDATE_RETVAL(E_POINTER);    \
    }    \
}
//---------------------------------------------------------------------------
#define VALIDATE_INPUT_STRING(helper, psz, cchMax)       \
{       \
    if (IsBadStringPtr(psz, cchMax))    \
    {      \
        Log(LOG_PARAMS, L"Bad input STRING param in call to: %s", helper._pszFuncName);   \
        RETURN_VALIDATE_RETVAL(E_POINTER);    \
    }    \
}
#define VALIDATE_INPUT_UNLIMITED_STRING(helper, psz)  VALIDATE_INPUT_STRING(helper, psz, UNICODE_STRING_MAX_CHARS)
//---------------------------------------------------------------------------
#define VALIDATE_HDC(helper, hdc)       \
{     \
    if (! hdc)  \
    {    \
        Log(LOG_PARAMS, L"Bad HDC param in call to %s", helper._pszFuncName );    \
        RETURN_VALIDATE_RETVAL(E_HANDLE);    \
    }   \
}
//---------------------------------------------------------------------------
#define VALIDATE_HANDLE(helper, h)       \
{        \
    if (! h)  \
    {    \
        Log(LOG_PARAMS, L"Bad HANDLE param in call to %s", helper._pszFuncName);    \
        RETURN_VALIDATE_RETVAL(E_HANDLE);    \
    }   \
}
//---------------------------------------------------------------------------
#define VALIDATE_HWND(helper, hwnd)       \
{      \
    if (! IsWindow(hwnd))     \
    {     \
        Log(LOG_PARAMS, L"Bad HWND handle param in call to: %s", helper._pszFuncName);   \
        RETURN_VALIDATE_RETVAL(E_HANDLE);    \
    }        \
}
//---------------------------------------------------------------------------
#define VALIDATE_CALLBACK(helper, pfn)       \
{     \
    if (IsBadCodePtr((FARPROC)pfn))  \
    {    \
        Log(LOG_PARAMS, L"Bad CALLBACK param in call to %s", helper._pszFuncName);    \
        RETURN_VALIDATE_RETVAL(E_POINTER);    \
    }   \
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\messagebroadcast.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: MessageBroadcast.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to manager sending or posting messages to windows to tell them that
//  things have changed.
//
//  History:    2000-11-11  vtan        created (split from services.cpp)
//  --------------------------------------------------------------------------

#include "stdafx.h"

#include "MessageBroadcast.h"

#include "Services.h"
#include "ThemeSection.h"
#include "Loader.h"

#define TBOOL(x)    ((BOOL)(x))
#define TW32(x)     ((DWORD)(x))
#define THR(x)      ((HRESULT)(x))
#define goto        !!DO NOT USE GOTO!! - DO NOT REMOVE THIS ON PAIN OF DEATH

//  --------------------------------------------------------------------------
//  CMessageBroadcast::CMessageBroadcast
//
//  Arguments:  fAllDesktops - if TRUE, all accessible desktops will be enum-ed
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CMessageBroadcast
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

CMessageBroadcast::CMessageBroadcast (BOOL fAllDesktops) :
    _hwnd(NULL),
    _dwProcessID(0),
    _fExclude(FALSE)

{
    ZeroMemory(&_msg, sizeof(_msg));

    _eMsgType = MT_SIMPLE;  // default (set in each request function)        

    _fAllDesktops = fAllDesktops;
}

//  --------------------------------------------------------------------------
//  CMessageBroadcast::~CMessageBroadcast
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CMessageBroadcast
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

CMessageBroadcast::~CMessageBroadcast (void)

{
}

//  --------------------------------------------------------------------------
//  CMessageBroadcast::EnumRequestedWindows
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Enumerate all windows in all desktops or just on current desktop
//
//  History:    2000-12-20  rfernand        created
//  --------------------------------------------------------------------------
void    CMessageBroadcast::EnumRequestedWindows (void)
{
    if (_fAllDesktops)
    {
        //---- enumerate all desktops in current session/station ----
        TBOOL(EnumDesktops(GetProcessWindowStation(), DesktopCallBack, reinterpret_cast<LPARAM>(this)));
    }
    else
    {
        //---- enumerate all windows in current desktop ----
        TopWindowCallBack(GetDesktopWindow(), reinterpret_cast<LPARAM>(this));
    }
}

//  --------------------------------------------------------------------------
void    CMessageBroadcast::PostSimpleMsg(UINT msg, WPARAM wParam, LPARAM lParam)
{
    _eMsgType = MT_SIMPLE;

    _msg.message = msg;
    _msg.wParam = wParam;
    _msg.lParam = lParam;

    EnumRequestedWindows();
}
//  --------------------------------------------------------------------------
void    CMessageBroadcast::PostAllThreadsMsg(UINT msg, WPARAM wParam, LPARAM lParam)
{
    //---- post the msg to a window on each unique processid/threadid ----

    _ThreadsProcessed.RemoveAll();      // will track unique processid/threadid we have posted to
    
    _eMsgType = MT_ALLTHREADS;

    _msg.message = msg;
    _msg.wParam = wParam;
    _msg.lParam = lParam;

    EnumRequestedWindows();
}

//  --------------------------------------------------------------------------
//  CMessageBroadcast::PostFilteredMsg
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Builds a message and stores conditions for the enumerator to
//              make a decision on whether a message needs to be posted. Then
//              enumerate all the windows (and children).
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

void    CMessageBroadcast::PostFilteredMsg(UINT msg, WPARAM wParam, LPARAM lParam, 
     HWND hwndTarget, BOOL fProcess, BOOL fExclude)
{
    _eMsgType = MT_FILTERED;

    //---- set up the message ----
    _msg.message = msg;

    _msg.wParam = wParam;
    _msg.lParam = lParam;
    
    _hwnd = hwndTarget;

    if (fProcess)
    {
        _dwProcessID = GetCurrentProcessId();
    }
    else
    {
        _dwProcessID = 0;
    }

    _fExclude = (fExclude != NULL);

    //---- enumerate all desktops in current session/station ----
    EnumRequestedWindows();
}

//  --------------------------------------------------------------------------
//  CMessageBroadcast::DesktopCallBack
//
//  Arguments:  See the platform SDK under EnumDesktops.
//
//  Returns:    BOOL
//
//  Purpose:    enum all windows for specified desktop
//
//  History:    2000-12-13  rfernand        created
//  --------------------------------------------------------------------------

BOOL    CALLBACK    CMessageBroadcast::DesktopCallBack(LPTSTR lpszDesktop, LPARAM lParam)
{
    HDESK hDesk = OpenDesktop(lpszDesktop, 0, FALSE, DESKTOP_READOBJECTS | DESKTOP_ENUMERATE);
    if (hDesk)
    {
        Log(LOG_TMCHANGEMSG, L"CMessageBroadcast: Desktop Opened: %s", lpszDesktop);

        //---- enum windows on desktop ----
        TBOOL(EnumDesktopWindows(hDesk, TopWindowCallBack, lParam));

        CloseDesktop(hDesk);
    }

    return TRUE;            // EnumDesktopWindows() returns unreliable errors
}

//  --------------------------------------------------------------------------
//  CMessageBroadcast::TopWindowCallBack
//
//  Arguments:  hwnd, lParam
//
//  Returns:    TRUE (keep enumerating)
//
//  Purpose:    call "Worker" for hwnd and all of its (nested) children
//
//  History:    2000-12-13  rfernand        created
//  --------------------------------------------------------------------------

BOOL CALLBACK    CMessageBroadcast::TopWindowCallBack (HWND hwnd, LPARAM lParam)

{
    //---- process top level window ----
    reinterpret_cast<CMessageBroadcast*>(lParam)->Worker(hwnd);

    //---- process all children windows ----
    TBOOL(EnumChildWindows(hwnd, ChildWindowCallBack, lParam));

    return TRUE;
}

//  --------------------------------------------------------------------------
//  CMessageBroadcast::ChildWindowCallBack
//
//  Arguments:  hwnd, lParam
//
//  Returns:    TRUE (keep enumerating)
//
//  Purpose:    call "Worker" for hwnd 
//
//  History:    2000-12-13  rfernand        created
//  --------------------------------------------------------------------------

BOOL CALLBACK    CMessageBroadcast::ChildWindowCallBack (HWND hwnd, LPARAM lParam)

{
    //---- process top level window ----
    reinterpret_cast<CMessageBroadcast*>(lParam)->Worker(hwnd);

    return TRUE;
}

//  --------------------------------------------------------------------------
//  CMessageBroadcast::Worker
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Performs validation on whether the HWND should get the built
//              message.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

void CMessageBroadcast::Worker (HWND hwnd)

{
    if (_eMsgType == MT_SIMPLE)     
    {
        TBOOL(PostMessage(hwnd, _msg.message, _msg.wParam, _msg.lParam));
    }
    else if (_eMsgType == MT_ALLTHREADS)     
    {
        DWORD dwThreadId = GetWindowThreadProcessId(hwnd, NULL);
        BOOL fSendIt = TRUE;

        //---- is this a new thread? ----
        for (int i=0; i < _ThreadsProcessed.m_nSize; i++)
        {
            if (_ThreadsProcessed[i] == dwThreadId)
            {
                fSendIt = FALSE;
                break;
            }
        }

        if (fSendIt)
        {
            TBOOL(PostMessage(hwnd, _msg.message, _msg.wParam, _msg.lParam));

            _ThreadsProcessed.Add(dwThreadId);
        }
    }
    else            // MT_FILTERED
    {
        bool    fMatch;

        fMatch = true;

        if (_dwProcessID != 0)
        {
            fMatch = (IsWindowProcess(hwnd, _dwProcessID) != FALSE);
            if (_fExclude)
            {
                fMatch = !fMatch;
            }
        }

        if (fMatch)
        {
            if (_hwnd != NULL)   
            {
                fMatch = ((_hwnd == hwnd) || IsChild(_hwnd, hwnd));
                if (_fExclude)
                {
                    fMatch = !fMatch;
                }
            }

            if (fMatch)
            {
                TBOOL(PostMessage(hwnd, _msg.message, _msg.wParam, _msg.lParam));

                //Log(LOG_TMCHANGE, L"Worker: just POSTED msg=0x%x to hwnd=0x%x",
                //    _msg.message, hwnd);
            }
        }
    }
}

//  --------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\render.cpp ===
//---------------------------------------------------------------------------
//  Render.cpp - implements the themed drawing services 
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Render.h"
#include "Utils.h"
#include "Parser.h"
#include "Loader.h"
#include "tmutils.h"
#include "gradient.h"
#include "rgn.h"
#include "info.h"
#include "cache.h"
#include "cachelist.h"
#include "borderfill.h"
#include "imagefile.h"

#ifdef DEBUG
    static DWORD s_dwSize = 0;
#endif

//---------------------------------------------------------------------------
HRESULT CreateRenderObj(CUxThemeFile *pThemeFile, int iCacheSlot, int iThemeOffset, 
    int iClassNameOffset, __int64 iUniqueId, BOOL fEnableCache, CDrawBase *pBaseObj,
    CTextDraw *pTextObj, DWORD dwOtdFlags, CRenderObj **ppObj)
{
    HRESULT hr = S_OK;

    CRenderObj *pRender = new CRenderObj(pThemeFile, iCacheSlot, iThemeOffset, 
        iClassNameOffset, iUniqueId, fEnableCache, dwOtdFlags);
    
    if (! pRender)
    {
        hr = MakeError32(E_OUTOFMEMORY);
    }
    else
    {
        hr = pRender->Init(pBaseObj, pTextObj);

        if (FAILED(hr))
            delete pRender;
        else
            *ppObj = pRender;
    }

    return hr;
}
//---------------------------------------------------------------------------
CRenderObj::CRenderObj(CUxThemeFile *pThemeFile, int iCacheSlot, int iThemeOffset, 
    int iClassNameOffset, __int64 iUniqueId, BOOL fEnableCache, DWORD dwOtdFlags)
{
    StringCchCopyA(_szHead, ARRAYSIZE(_szHead), "rendobj"); 
    StringCchCopyA(_szTail, ARRAYSIZE(_szTail), "end");
    
    _fCacheEnabled = fEnableCache;
    _fCloseThemeFile = FALSE;
    _dwOtdFlags = dwOtdFlags;

    if (pThemeFile)
    {
        if (SUCCEEDED(BumpThemeFileRefCount(pThemeFile)))
            _fCloseThemeFile = TRUE;
    }
    
    _pThemeFile = pThemeFile;
    _iCacheSlot = iCacheSlot;
    _iUniqueId = iUniqueId;

    if (pThemeFile)
    {
        _pbThemeData = pThemeFile->_pbThemeData;
        _pbSectionData = _pbThemeData + iThemeOffset;
        _ptm = GetThemeMetricsPtr(pThemeFile);
    }
    else
    {
        _pbThemeData = NULL;
        _pbSectionData = NULL;
        _ptm = NULL;
    }

    _pszClassName = ThemeString(pThemeFile, iClassNameOffset);

    _iMaxPart = 0;
    _pParts = NULL;

    _iDpiOverride = 0;

    //---- caller must call "Init()" after ctr! ----
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::PrepareAlphaBitmap(HBITMAP hBitmap)
{
    HRESULT hr = S_OK;

    //---- convert to DIBDATA ----
    CBitmapPixels pixels;
    DWORD *pPixelQuads;
    int iWidth, iHeight, iBytesPerPixel, iBytesPerRow;

    hr = pixels.OpenBitmap(NULL, hBitmap, TRUE, &pPixelQuads, &iWidth, &iHeight, 
        &iBytesPerPixel, &iBytesPerRow);
    if (FAILED(hr))
        goto exit;
    
    PreMultiplyAlpha(pPixelQuads, iWidth, iHeight);

    pixels.CloseBitmap(NULL, hBitmap);

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::Init(CDrawBase *pBaseObj, CTextDraw *pTextObj)
{
    HRESULT hr = S_OK;

    if (_fCacheEnabled)
    {
        hr = BuildPackedPtrs(pBaseObj, pTextObj);
        if (FAILED(hr))
            goto exit;
    }

    //---- prepare direct objects ----
    if ((pBaseObj) && (pBaseObj->_eBgType == BT_IMAGEFILE))
    {
        CMaxImageFile *pMaxIf = (CMaxImageFile *)pBaseObj;

        //---- process primary image ----
        DIBINFO *pdi = &pMaxIf->_ImageInfo;

        if (pdi->fAlphaChannel)
        {
            hr = PrepareAlphaBitmap(pdi->hProcessBitmap);
            if (FAILED(hr))
                goto exit;
        }

        //---- process glyph image ----
        pdi = &pMaxIf->_GlyphInfo;

        if (pdi->fAlphaChannel)
        {
            hr = PrepareAlphaBitmap(pdi->hProcessBitmap);
            if (FAILED(hr))
                goto exit;
        }

        //---- process multiple images ----
        for (int i=0; i < pMaxIf->_iMultiImageCount; i++)
        {
            pdi = pMaxIf->MultiDibPtr(i);

            if (pdi->fAlphaChannel)
            {
                hr = PrepareAlphaBitmap(pdi->hProcessBitmap);
                if (FAILED(hr))
                    goto exit;
            }
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
CRenderObj::~CRenderObj()
{
    //---- delete memory allocated for pack objects looked ----
    if (_pParts)
    {
        for(int i=0; i<_iMaxPart+1; i++)
        {
            if (_pParts[i].pStateDrawObjs)
                delete[] _pParts[i].pStateDrawObjs;

            if (_pParts[i].pStateTextObjs)
                delete[] _pParts[i].pStateTextObjs;
        }
        delete[] _pParts;
    }

    //---- if we opened a refcount on a themefile, close it now ----
    if (_fCloseThemeFile)
        CloseThemeFile(_pThemeFile);

    //---- mark this object as "deleted" (for debugging) ----

    StringCchCopyA(_szHead, ARRAYSIZE(_szHead), "deleted"); 
}
//---------------------------------------------------------------------------
int CRenderObj::GetDpiOverride()
{
    return _iDpiOverride;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::BuildPackedPtrs(CDrawBase *pBaseObj, CTextDraw *pTextObj)
{
    MIXEDPTRS u;
    HRESULT hr = S_OK;
    int iPackedOffset = 0;
    int *iPartOffsets = NULL;
    BOOL fSingleObj = FALSE;

    //---- extract _iMaxPart ----
    if ((pBaseObj) || (pTextObj))       // single object to be used for all parts/states
    {
        _iMaxPart = 1;          // dummy value
        fSingleObj = TRUE;
    }
    else
    {
        u.pb = _pbSectionData;
        if (*u.ps != TMT_PARTJUMPTABLE)
        {
            hr = MakeError32(E_FAIL);       // something went amiss
            goto exit;
        }

        u.pb += ENTRYHDR_SIZE;
        iPackedOffset = *u.pi++;
        
        _iMaxPart = *u.pb - 1;
        
        u.pb++;
        iPartOffsets = u.pi;
    }

    //---- allocate _pParts ----
    _pParts = new PARTINFO[_iMaxPart+1];
    if (! _pParts)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }

    memset(_pParts, 0, sizeof(PARTINFO)*(_iMaxPart+1));

    if (fSingleObj)
    {
        for (int i=0; i <= _iMaxPart; i++)
            _pParts[i].iMaxState = 1;           // dummy value

        if (pBaseObj)       // single draw object to be used for all parts/states
        {
            for (int i=0; i <= _iMaxPart; i++)
            {
                _pParts[i].pDrawObj = pBaseObj;
            }
        }

        if (pTextObj)       // single text object t to be used for all parts/states
        {
            for (int i=0; i <= _iMaxPart; i++)
            {
                _pParts[i].pTextObj = pTextObj;
            }
        }
    }
    else
    {
        u.pb = _pbThemeData + iPackedOffset;

        hr = WalkDrawObjects(u, iPartOffsets);
        if (FAILED(hr))
            goto exit;

        hr = WalkTextObjects(u, iPartOffsets);
        if (FAILED(hr))
            goto exit;
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::WalkDrawObjects(MIXEDPTRS &u, int *iPartOffsets)
{
    int iPartId;
    int iStateId;
    HRESULT hr = S_OK;
    THEMEHDR *pHdr = (THEMEHDR *)_pbThemeData;
    UNPACKED_ENTRYHDR hdr;

    //---- get ptr to global text obj ----
	BYTE *pb = _pbThemeData + pHdr->iGlobalsDrawObjOffset;
	pb += ENTRYHDR_SIZE + sizeof(DRAWOBJHDR);
    CDrawBase *pGlobalObj = (CDrawBase *)pb;

    //---- start with all parts inheriting from [globals] ----
    for (int i=0; i <= _iMaxPart; i++)
        _pParts[i].pDrawObj = pGlobalObj;

    //---- now, process all specified objects ----
    while (1)
    {
        if ((*u.ps == TMT_RGNLIST))
        {
            //---- skip over this entry ----
            FillAndSkipHdr(u, &hdr);
            u.pb += hdr.dwDataLen;
            continue;
        }

        if (*u.ps != TMT_DRAWOBJ)
            break;

        FillAndSkipHdr(u, &hdr);

        DRAWOBJHDR *ph = (DRAWOBJHDR *)u.pb;
        CDrawBase *pCurrentObj = (CDrawBase *)(u.pb + sizeof(DRAWOBJHDR));
        u.pb += hdr.dwDataLen;

        iPartId = ph->iPartNum;
        iStateId = ph->iStateNum;

        if ((! iPartId) && (! iStateId))
        {
            //---- all parts inherit from this obj ----
            for (int i=0; i <= _iMaxPart; i++)
                _pParts[i].pDrawObj = pCurrentObj;
            continue;
        }

        PARTINFO *ppi = &_pParts[iPartId];
        if (! iStateId)
        {
            ppi->pDrawObj = pCurrentObj;
        }
        else
        {
            if (! ppi->iMaxState)       // extract MaxState
            {
                MIXEDPTRS u2;
                u2.pb = _pbThemeData + iPartOffsets[iPartId];
                if (*u2.ps != TMT_STATEJUMPTABLE)
                {
                    hr = MakeError32(E_FAIL);       // something went amiss
                    goto exit;
                }
                u2.pb += ENTRYHDR_SIZE;
                ppi->iMaxState = *u2.pb - 1;
            }

            if (! ppi->pStateDrawObjs)      // allocate now
            {
                ppi->pStateDrawObjs = new CDrawBase *[ppi->iMaxState];
                if (! ppi->pStateDrawObjs)
                {
                    hr = MakeError32(E_OUTOFMEMORY);
                    goto exit;
                }

                //---- fill in default objs as state 0 ----
                for (int i=0; i < ppi->iMaxState; i++)
                    ppi->pStateDrawObjs[i] = ppi->pDrawObj;
            }

            ppi->pStateDrawObjs[iStateId-1] = pCurrentObj;
        }
            
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::WalkTextObjects(MIXEDPTRS &u, int *iPartOffsets)
{
    int iPartId;
    int iStateId;
    HRESULT hr = S_OK;
    THEMEHDR *pHdr = (THEMEHDR *)_pbThemeData;
    UNPACKED_ENTRYHDR hdr;

    //---- get ptr to global text obj ----
	BYTE *pb = _pbThemeData + pHdr->iGlobalsTextObjOffset;
	pb += ENTRYHDR_SIZE + sizeof(DRAWOBJHDR);
    CTextDraw *pGlobalObj = (CTextDraw *)pb;

    //---- start with all parts inheriting from [globals] ----
    for (int i=0; i <= _iMaxPart; i++)
        _pParts[i].pTextObj = pGlobalObj;

    while (*u.ps == TMT_TEXTOBJ)        
    {
        FillAndSkipHdr(u, &hdr);

        DRAWOBJHDR *ph = (DRAWOBJHDR *)u.pb;
        CTextDraw *pCurrentObj = (CTextDraw *)(u.pb + sizeof(DRAWOBJHDR));
        u.pb += hdr.dwDataLen;

        iPartId = ph->iPartNum;
        iStateId = ph->iStateNum;

        if ((! iPartId) && (! iStateId))
        {
            //---- all parts inherit from this obj ----
            for (int i=0; i <= _iMaxPart; i++)
                _pParts[i].pTextObj = pCurrentObj;
            continue;
        }

        PARTINFO *ppi = &_pParts[iPartId];
        if (! iStateId)
        {
            ppi->pTextObj = pCurrentObj;
        }
        else
        {
            if (! ppi->iMaxState)       // extract MaxState
            {
                MIXEDPTRS u2;
                u2.pb = _pbThemeData + iPartOffsets[iPartId];
                if (*u2.ps != TMT_STATEJUMPTABLE)
                {
                    hr = MakeError32(E_FAIL);       // something went amiss
                    goto exit;
                }
                u2.pb += ENTRYHDR_SIZE;
                ppi->iMaxState = *u2.pb - 1;
            }

            if (! ppi->pStateTextObjs)      // allocate now
            {
                ppi->pStateTextObjs = new CTextDraw *[ppi->iMaxState];
                if (! ppi->pStateTextObjs)
                {
                    hr = MakeError32(E_OUTOFMEMORY);
                    goto exit;
                }

                //---- fill in default objs as state 0 ----
                for (int i=0; i < ppi->iMaxState; i++)
                    ppi->pStateTextObjs[i] = ppi->pTextObj;
            }

            ppi->pStateTextObjs[iStateId-1] = pCurrentObj;
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetBitmap(HDC hdc, int iDibOffset, OUT HBITMAP *phBitmap)
{
    HRESULT hr = S_OK;
    HBITMAP hBitmap;

    if ((! iDibOffset) || (! _pbThemeData))
    {
        hr = E_FAIL;
        goto exit;
    }

    TMBITMAPHEADER *pThemeBitmapHeader;

    pThemeBitmapHeader = reinterpret_cast<TMBITMAPHEADER*>(_pbThemeData + iDibOffset);
    ASSERT(pThemeBitmapHeader->dwSize == TMBITMAPSIZE);

    *phBitmap = pThemeBitmapHeader->hBitmap;
    if (*phBitmap != NULL)
    {
        //Log(LOG_TMBITMAP, L"Used stock bitmap:%8X", *phBitmap);
        return hr;
    }

    hr = CreateBitmapFromData(hdc, iDibOffset + TMBITMAPSIZE, &hBitmap);
    if (FAILED(hr))
        goto exit;

    Log(LOG_TM, L"GetBitmap - CACHE MISS: class=%s, diboffset=%d, bitmap=0x%x", 
        SHARECLASS(this), iDibOffset, hBitmap);

    *phBitmap = hBitmap;

exit:
    return hr;
}
//---------------------------------------------------------------------------
void CRenderObj::ReturnBitmap(HBITMAP hBitmap)
{
    DeleteObject(hBitmap);
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::CreateBitmapFromData(HDC hdc, int iDibOffset, OUT HBITMAP *phBitmap)
{
    BYTE *pDibData;
    RESOURCE HDC hdcTemp = NULL;
    RESOURCE HBITMAP hBitmap = NULL;
    HRESULT hr = S_OK;

    if ((! iDibOffset) || (! _pbThemeData))
    {
        hr = E_FAIL;
        goto exit;
    }

    pDibData = (BYTE *)(_pbThemeData + iDibOffset);
    BITMAPINFOHEADER *pBitmapHdr;
    pBitmapHdr = (BITMAPINFOHEADER *)pDibData;

    BOOL fAlphaChannel;
    fAlphaChannel = (pBitmapHdr->biBitCount == 32);

    if (! hdc)
    {
        hdcTemp = GetWindowDC(NULL);
        if (! hdcTemp)
        {
            Log(LOG_ALWAYS, L"GetWindowDC() failed in CreateBitmapFromData");
            hr = MakeErrorLast();
            goto exit;
        }

        hdc = hdcTemp;
    }

    //---- create the actual bitmap ----
    //---- if using alpha channel, we must use a DIB ----
    if (fAlphaChannel)
    {
        void *pv;
        hBitmap = CreateDIBSection(hdc, (BITMAPINFO *)pBitmapHdr, DIB_RGB_COLORS, 
            &pv, NULL, 0);
    }
    else
    {
        hBitmap = CreateCompatibleBitmap(hdc, pBitmapHdr->biWidth, pBitmapHdr->biHeight);
    }

    if (! hBitmap)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    int iSetVal;

    //---- SetDIBits() can take unaligned data, right? ----
    iSetVal = SetDIBits(hdc, hBitmap, 0, pBitmapHdr->biHeight, DIBDATA(pBitmapHdr), (BITMAPINFO *)pBitmapHdr,
        DIB_RGB_COLORS);

    if (! iSetVal)
    {
        hr = MakeErrorLast();
        goto exit;
    }
        
    *phBitmap = hBitmap;
    
#ifdef DEBUG
    if (hBitmap)
    {
        BITMAP bm;

        GetObject(hBitmap, sizeof bm, &bm);
        s_dwSize += bm.bmWidthBytes * bm.bmHeight;
        //Log(LOG_TMBITMAP, L"Created a bitmap of %d bytes. total is %d", bm.bmWidthBytes * bm.bmHeight, s_dwSize);
    }
#endif

exit:
    if (hdcTemp)
        ReleaseDC(NULL, hdcTemp);

    if (FAILED(hr))
    {
        if (hBitmap)
            DeleteObject(hBitmap);
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetScaledFontHandle(HDC hdc, LOGFONT *plf, HFONT *phFont)
{
    HRESULT hr = S_OK;

    if (_fCacheEnabled)
    {
        CRenderCache *pCacheObj = GetTlsCacheObj();
        if (pCacheObj)
            hr = pCacheObj->GetScaledFontHandle(hdc, plf, phFont);
    }
    else
    {
        LOGFONT lf = *plf;
        
        //---- convert to current screen dpi ----
        ScaleFontForHdcDpi(hdc, &lf);

        *phFont  = CreateFontIndirect(&lf);
        if (! *phFont)
            hr = MakeError32(E_OUTOFMEMORY);
    }

    return hr;
}
//---------------------------------------------------------------------------
void CRenderObj::ReturnFontHandle(HFONT hFont)
{
    if (_fCacheEnabled)
    {
        //--- cache currently doesn't refcnt so save time by not calling ---
        //CRenderCache *pCacheObj = GetTlsCacheObj();
        //if (pCacheObj)
        //{
            //pCacheObj->ReturnFontHandle(hFont);
            //goto exit;
        //}
    }
    else
    {
        DeleteObject(hFont);
    }
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::PrepareRegionDataForScaling(
    RGNDATA *pRgnData, LPCRECT prcImage, MARGINS *pMargins)
{
    //---- compute margin values ----
    int sw = prcImage->left;
    int lw = prcImage->left + pMargins->cxLeftWidth;
    int rw = prcImage->right - pMargins->cxRightWidth;

    int sh = prcImage->top;
    int th = prcImage->top + pMargins->cyTopHeight;
    int bh = prcImage->bottom - pMargins->cyBottomHeight;

    //---- step thru region data & customize it ----
    //---- classify each POINT according to a gridnum and ----
    //---- make it 0-relative to its grid location ----

    POINT *pt = (POINT *)pRgnData->Buffer;
    BYTE *pByte = (BYTE *)pRgnData->Buffer + pRgnData->rdh.nRgnSize;
    int iCount = 2 * pRgnData->rdh.nCount;

    for (int i=0; i < iCount; i++, pt++, pByte++)
    {
        if (pt->x < lw)
        {
            pt->x -= sw;

            if (pt->y < th)         // left top
            {
                *pByte = GN_LEFTTOP;
                pt->y -= sh;
            }
            else if (pt->y < bh)    // left middle
            {
                *pByte = GN_LEFTMIDDLE;
                pt->y -= th;
            }
            else                    // left bottom
            {
                *pByte = GN_LEFTBOTTOM;
                pt->y -= bh;
            }
        }
        else if (pt->x < rw)
        {
            pt->x -= lw;

            if (pt->y < th)         // middle top
            {
                *pByte = GN_MIDDLETOP;
                pt->y -= sh;
            }
            else if (pt->y < bh)    // middle middle
            {
                *pByte = GN_MIDDLEMIDDLE;
                pt->y -= th;
            }
            else                    // middle bottom
            {
                *pByte = GN_MIDDLEBOTTOM;
                pt->y -= bh;
            }
        }
        else
        {
            pt->x -= rw;

            if (pt->y < th)         // right top
            {
                *pByte = GN_RIGHTTOP;
                pt->y -= sh;
            }
            else if (pt->y < bh)    // right middle
            {
                *pByte = GN_RIGHTMIDDLE;
                pt->y -= th;
            }
            else                    // right bottom
            {
                *pByte = GN_RIGHTBOTTOM;
                pt->y -= bh;
            }
        }

    }

    return S_OK;
} 
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetColor(int iPartId, int iStateId, int iPropId, COLORREF *pColor)
{
    if (! pColor)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)          // not found
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index;        // point at data

    *pColor = *u.pi;
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetString(int iPartId, int iStateId, int iPropId, 
    LPWSTR pszBuff, DWORD cchBuff)
{
    if (! pszBuff)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index - sizeof(int);      // point at length
    DWORD len = *u.pdw++;
    len /= sizeof(WCHAR);         // adjust to characters

    HRESULT hr = SafeStringCchCopyW(pszBuff, cchBuff, u.pw );
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetBool(int iPartId, int iStateId, int iPropId, BOOL *pfVal)
{
    if (! pfVal)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index;      // point at data

    *pfVal = *u.pb;
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetInt(int iPartId, int iStateId, int iPropId, int *piVal)
{
    if (! piVal)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index;      // point at data

    *piVal = *u.pi;
    return S_OK;
}
//---------------------------------------------------------------------------
static int iMetricDefaults[] = 
{
    1,      // TMT_BORDERWIDTH
    18,     // TMT_VERTSCROLLWIDTH
    18,     // TMT_HORZSCROLLHEIGHT
    27,     // TMT_CAPTIONBUTTONWIDTH
    27,     // TMT_CAPTIONBUTTONHEIGHT
    22,     // TMT_SMCAPTIONBUTTONWIDTH
    22,     // TMT_SMCAPTIONBUTTONHEIGHT
    22,     // TMT_MENUBUTTONWIDTH
    22,     // TMT_MENUBUTTONHEIGHT
};
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetMetric(OPTIONAL HDC hdc, int iPartId, int iStateId, int iPropId, int *piVal)
{
    if (! piVal)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    int value;

    if (index >= 0)      // found
    {
        MIXEDPTRS u;
        u.pb = _pbThemeData + index;      // point at data

        value = *u.pi;
    }
    else
        return MakeError32(ERROR_NOT_FOUND);
    
    *piVal = ScaleSizeForHdcDpi(hdc, value);
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetEnumValue(int iPartId, int iStateId, int iPropId, int *piVal)
{
    if (! piVal)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index;      // point at data

    *piVal = *u.pi;
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetPosition(int iPartId, int iStateId, int iPropId, POINT *pPoint)
{
    if (! pPoint)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index;      // point at data

    pPoint->x = *u.pi++;
    pPoint->y = *u.pi++;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetFont(OPTIONAL HDC hdc, int iPartId, int iStateId, int iPropId,
    BOOL fWantHdcScaling, LOGFONT *pFont)
{
    if (! pFont)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index;      // point at data

    *pFont = *(LOGFONT *)u.pb;
    
    if (fWantHdcScaling)
    {
        ScaleFontForHdcDpi(hdc, pFont);
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetMargins(OPTIONAL HDC hdc, int iPartId, int iStateId, 
    int iPropId, OPTIONAL RECT *prc, MARGINS *pMargins)
{
    //---- return unscaled margins ----

    if (! pMargins)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index;      // point at data

    pMargins->cxLeftWidth = *u.pi++;
    pMargins->cxRightWidth = *u.pi++;
    pMargins->cyTopHeight = *u.pi++;
    pMargins->cyBottomHeight = *u.pi++;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetIntList(int iPartId, int iStateId, int iPropId, INTLIST *pIntList)
{
    if (! pIntList)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index;      // point at data

    int iCount = *u.pi++;
    if (iCount > MAX_INTLIST_COUNT)
    {
        Log(LOG_ALWAYS, L"GetIntList() found bad theme data - Count=%d", iCount);

        return MakeError32(ERROR_NOT_FOUND);
    }

    pIntList->iValueCount = iCount;

    for (int i=0; i < iCount; i++)
        pIntList->iValues[i] = *u.pi++;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetRect(int iPartId, int iStateId, int iPropId, RECT *pRect)
{
    if (! pRect)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index;      // point at data

    pRect->left = *u.pi++;
    pRect->top = *u.pi++;
    pRect->right = *u.pi++;
    pRect->bottom = *u.pi++;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetFilename(int iPartId, int iStateId, int iPropId, LPWSTR pszBuff, 
   DWORD cchBuff)
{
    if (! pszBuff)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index - sizeof(int);      // point at length
    DWORD len = *u.pdw++;
    len /= sizeof(WCHAR);             // adjust to chars size
    
    HRESULT hr = SafeStringCchCopyW(pszBuff, cchBuff, u.pw);
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetData(int iPartId, int iStateId, int iPropId, BYTE **ppData,
    OPTIONAL int *piSize)
{
    if (! ppData)
        return MakeError32(E_INVALIDARG);
    
    int index = GetValueIndex(iPartId, iStateId, iPropId);
    if (index < 0)
        return MakeError32(ERROR_NOT_FOUND);

    MIXEDPTRS u;
    u.pb = _pbThemeData + index - sizeof(int);      // point at length
    DWORD len = *u.pdw++;

    *ppData = u.pb;

    if (piSize)
        *piSize = len;

    return S_OK;
}
//---------------------------------------------------------------------------
int CRenderObj::GetValueIndex(int iPartId, int iStateId, int iTarget)
{
    if (! iTarget)            
    {
        Log(LOG_PARAMS, L"Invalid iProperyId passed to GetValueIndex: %d", iTarget);
        return -1;
    }

    if (! _pbSectionData)
    {
        return -1;
    }

    MIXEDPTRS u;
    int index;

    u.pb = _pbSectionData;

    //---- find end of data ----
    THEMEHDR *hdr = (THEMEHDR *)_pbThemeData;
    BYTE *pbLastValidChar = _pbThemeData + (hdr->dwTotalLength - 1) - kcbEndSignature;

    while (u.pb <= pbLastValidChar)           
    {
        UNPACKED_ENTRYHDR hdr;
        
        FillAndSkipHdr(u, &hdr);

        if (hdr.usTypeNum == TMT_PARTJUMPTABLE)   
        {
            u.pi++;     // skip over offset to first drawobj

            BYTE cnt = *u.pb++;

            if ((iPartId < 0) || (iPartId >= cnt))
            {
                index = u.pi[0];
            }
            else
            {
                index = u.pi[iPartId];
                if (index == -1)
                    index = u.pi[0];
            }

            u.pb = _pbThemeData + index;
            continue;
        }

        if (hdr.usTypeNum == (BYTE)TMT_STATEJUMPTABLE)   
        {
            BYTE cnt = *u.pb++;

            if ((iStateId < 0) || (iStateId >= cnt))
                index = u.pi[0];
            else
            {
                index = u.pi[iStateId];
                if (index == -1)
                    index = u.pi[0];
            }

            u.pb = _pbThemeData + index;
            continue;
        }

        if (hdr.usTypeNum == iTarget)        // got our target
        {
            // Log("GetValueIndex: match at index=%d", u.pb - _pbThemeData);
            return (int)(u.pb - _pbThemeData);      // point at actual data (not hdr)
        }

        if (hdr.ePrimVal == TMT_JUMPTOPARENT)
        {
            index = *u.pi;
            if (index == -1)
            {
                // Log("no match found");
                return -1;
            }

            // Log("GetValueIndex: jumping to parent at index=%d", index);
            u.pb = _pbThemeData + index;
            continue;
        }

        // Log("GetValueIndex: no match to hdr.usTypeNum=%d", hdr.usTypeNum);

        // advance to next value
        u.pb += hdr.dwDataLen;
    }

    //---- something went wrong ----
    Log(LOG_ERROR, L"GetValueIndex: ran off the valid data without a '-1' jump");
    return -1;
}
//---------------------------------------------------------------------------
HRESULT CRenderObj::GetPropertyOrigin(int iPartId, int iStateId, int iTarget, 
    PROPERTYORIGIN *pOrigin)
{
    if (! iTarget)            
    {
        Log(LOG_PARAMS, L"Invalid iProperyId passed to GetPropertyOrigin: %d", iTarget);
        return E_FAIL;
    }

    if (! _pbSectionData)
    {
        return E_FAIL;
    }

    MIXEDPTRS u;
    if (! pOrigin)
        return MakeError32(E_INVALIDARG);

    //---- start at our section ----
    u.pb = _pbSectionData;
    PROPERTYORIGIN origin = PO_CLASS;

    //---- find end of data ----
    THEMEHDR *hdr = (THEMEHDR *)_pbThemeData;
    BYTE *pbLastValidChar = _pbThemeData + (hdr->dwTotalLength - 1) - kcbEndSignature;

    while (u.pb <= pbLastValidChar)           
    {
        UNPACKED_ENTRYHDR hdr;
        
        FillAndSkipHdr(u, &hdr);

        if (hdr.usTypeNum == TMT_PARTJUMPTABLE)   
        {
            u.pi++;     // skip over offset to first drawobj

            BYTE cnt = *u.pb++;
            int index;

            if ((iPartId <= 0) || (iPartId >= cnt))
            {
                index = u.pi[0];
            }
            else
            {
                index = u.pi[iPartId];
                if (index == -1)
                    index = u.pi[0];
            }

            if (index == u.pi[0])
                origin = PO_CLASS;
            else
                origin = PO_PART;

            u.pb = _pbThemeData + index;
            continue;
        }

        if (hdr.usTypeNum == TMT_STATEJUMPTABLE)   
        {
            BYTE cnt = *u.pb++;
            int index;

            if ((iStateId <= 0) || (iStateId >= cnt))
            {
                index = u.pi[0];
            }
            else
            {
                index = u.pi[iStateId];
                if (index == -1)
                    index = u.pi[0];
            }

            if (index != u.pi[0])
                origin = PO_STATE;

            u.pb = _pbThemeData + index;
            continue;
        }

        //Log("GetPropertyOrgin: iPartId=%d, iTarget=%d, DataIndex=%d", 
          //  iPartId, iTarget, u.pb - _pbThemeData);

        if ((iTarget == -1) || (hdr.usTypeNum == iTarget))        // got our target
        {
            // Log("GetPropertyOrgin: match at index=%d", u.pb - _pbThemeData);
            *pOrigin = origin;
            return S_OK;
        }

        if (hdr.ePrimVal == TMT_JUMPTOPARENT)
        {
            int index = *u.pi;
            if (index == -1)
            {
                // Log("GetPropertyOrgin: no match found");
                *pOrigin = PO_NOTFOUND;
                return S_OK;
            }

            // Log("GetPropertyOrgin: jumping to parent at index=%d", index);
            u.pb = _pbThemeData + index;
            origin = (PROPERTYORIGIN) (origin + 1);    // move down to next level of heirarchy
            continue;
        }

        // advance to next value
        u.pb += hdr.dwDataLen;
    }

    //---- something went wrong ----
    Log(LOG_ERROR, L"GetPropertyOrigin: ran off the valid data without a '-1' jump");
    return E_FAIL;
}
//---------------------------------------------------------------------------
BOOL WINAPI CRenderObj::IsPartDefined(int iPartId, int iStateId)
{
    PROPERTYORIGIN origin;
    HRESULT hr = GetPropertyOrigin(iPartId, iStateId, -1, &origin);
    SET_LAST_ERROR(hr);
    if (FAILED(hr))
    {
        return FALSE;
    }

    if (iStateId)
        return (origin == PO_STATE);

    return (origin == PO_PART);
}
//---------------------------------------------------------------------------
BOOL CRenderObj::ValidateObj()
{
    BOOL fValid = TRUE;

    //---- check object quickly ----
    if (   (! this)                         
        || (ULONGAT(_szHead) != 'dner')     // "rend"
        || (ULONGAT(&_szHead[4]) != 'jbo')  // "obj" 
        || (ULONGAT(_szTail) != 'dne'))     // "end"
    {
        Log(LOG_ALWAYS, L"CRenderObj is corrupt, addr=0x%08x", this);
        fValid = FALSE;
    }

    return fValid;
}
//---------------------------------------------------------------------------
CRenderCache *CRenderObj::GetTlsCacheObj()
{
    HRESULT hr = S_OK;
    CRenderCache *pCacheObj = NULL;

    CCacheList *pcl = GetTlsCacheList(TRUE);
    if (pcl)
        hr = pcl->GetCacheObject(this, _iCacheSlot, &pCacheObj);

    return pCacheObj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\scroll.cpp ===
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "scroll.h"

#if defined(_UXTHEME_)

// non-client scrollbar 
#include "nctheme.h"
#include "scrollp.h"

#else

// scrollbar control 
#include "usrctl32.h"

#endif _UXTHEME_

//  comment this out to visually match user32 scrollbar:
//#define _VISUAL_DELTA_

#ifdef _VISUAL_DELTA_
#define CARET_BORDERWIDTH   2
#endif _VISUAL_DELTA_

//-------------------------------------------------------------------------//
#define FNID_SCROLLBAR          0x0000029A      // UxScrollBarWndProc;
#define GetOwner(hwnd)          GetWindow(hwnd, GW_OWNER)
#define HW(x)                   x
#define HWq(x)                  x
#define RIPERR0(s1,s2,errno)
#define RIPMSG1(errno,fmt,arg1)
#define RIPMSG2(errno,fmt,arg1,arg2)
#define RIPMSG3(errno,fmt,arg1,arg2,arg3)
#define RIP_VERBOSE()
#define ClrWF                   ClearWindowState
#define SetWF                   SetWindowState
#define Lock(phwnd, hwnd)       InterlockedExchangePointer((PVOID*)(phwnd), (PVOID)hwnd)
#define Unlock(phwnd)           Lock(phwnd, NULL)
#define CheckLock(hwnd)
#define ThreadLock(w,t)
#define ThreadUnlock(t)
#define VALIDATECLASSANDSIZE
#define DTTIME                  (MulDiv( GetDoubleClickTime(), 4, 5 ))
#define _KillSystemTimer              KillTimer
#define _SetSystemTimer               SetTimer
#define IsWinEventNotifyDeferredOK()  TRUE
#define IsWinEventNotifyDeferred()    FALSE

//-------------------------------------------------------------------------//
//  scroll type flags userk.h
#define SCROLL_NORMAL   0
#define SCROLL_DIRECT   1
#define SCROLL_MENU     2

//-------------------------------------------------------------------------//
//  internal Scrollbar state/style bits
//#define SBFSIZEBOXTOPLEFT       0x0C02
//#define SBFSIZEBOXBOTTOMRIGHT   0x0C04
//#define SBFSIZEBOX              0x0C08
#define SBFSIZEGRIP             0x0C10


//----------------------------------//
//  Scrollbar arrow disable flags
#define LTUPFLAG    0x0001  // Left/Up arrow disable flag.
#define RTDNFLAG    0x0002  // Right/Down arrow disable flag.

//----------------------------------//
//  function forwards
UINT _SysToChar(UINT message, LPARAM lParam);

//-------------------------------------------------------------------------//
//  private hittest codes
//#define HTEXSCROLLFIRST     60
#define HTSCROLLUP          60
#define HTSCROLLDOWN        61
#define HTSCROLLUPPAGE      62
#define HTSCROLLDOWNPAGE    63
#define HTSCROLLTHUMB       64
//#define HTEXSCROLLLAST      64
//#define HTEXMENUFIRST       65
//#define HTMDISYSMENU        65
//#define HTMDIMAXBUTTON      66
//#define HTMDIMINBUTTON      67
//#define HTMDICLOSE          68
//#define HTMENUITEM          69
//#define HTEXMENULAST        69

#define IDSYS_SCROLL            0x0000FFFEL // timer ID, user.h

typedef HWND  SBHWND;
typedef HMENU PMENU;


//-------------------------------------------------------------------------//
//  SBDATA
typedef struct tagSBDATA 
{
    int     posMin;
    int     posMax;
    int     page;
    int     pos;
} SBDATA, *PSBDATA;

//-------------------------------------------------------------------------//
//  SBINFO is the set of values that hang off of a window structure, 
//  if the window has scrollbars.
typedef struct tagSBINFO 
{
    int     WSBflags;
    SBDATA  Horz;
    SBDATA  Vert;
} SBINFO, * PSBINFO;

//-------------------------------------------------------------------------//
//  SBCALC
//  Scrollbar metrics block.
typedef struct tagSBCALC
{
    SBDATA  data;               /* this must be first -- we cast structure pointers */
    int     pxTop;
    int     pxBottom;
    int     pxLeft;
    int     pxRight;
    int     cpxThumb;
    int     pxUpArrow;
    int     pxDownArrow;
    int     pxStart;         /* Initial position of thumb */
    int     pxThumbBottom;
    int     pxThumbTop;
    int     cpx;
    int     pxMin;
} SBCALC, *PSBCALC;

//-------------------------------------------------------------------------//
//  SBTRACK
//  Scrollbar thumb-tracking state block.
typedef struct tagSBTRACK {
    DWORD    fHitOld : 1;
    DWORD    fTrackVert : 1;
    DWORD    fCtlSB : 1;
    DWORD    fTrackRecalc: 1;
    HWND     hwndTrack;
    HWND     hwndSB;
    HWND     hwndSBNotify;
    RECT     rcTrack;
    VOID     (CALLBACK *pfnSB)(HWND, UINT, WPARAM, LPARAM, PSBCALC);
    UINT     cmdSB;
    UINT_PTR hTimerSB;
    int      dpxThumb;        /* Offset from mouse point to start of thumb box */
    int      pxOld;           /* Previous position of thumb */
    int      posOld;
    int      posNew;
    int      nBar;
    PSBCALC  pSBCalc;
} SBTRACK, *PSBTRACK;

//-------------------------------------------------------------------------//
//  Window scrollbars, control base.
class CUxScrollBar
//-------------------------------------------------------------------------//
{
public:
    CUxScrollBar();
    virtual ~CUxScrollBar() {}

    virtual BOOL          IsCtl() const { return FALSE;}
    operator HWND()       { return _hwnd; }
    static  CUxScrollBar* Calc(  HWND hwnd, PSBCALC pSBCalc, LPRECT prcOverrideClient, BOOL fVert); 
    virtual void          Calc2( PSBCALC pSBCalc, LPRECT lprc, CONST PSBDATA pw, BOOL fVert);
    virtual void          DoScroll( HWND hwndNotify, int cmd, int pos, BOOL fVert );

    virtual void          ClearTrack()  { ZeroMemory( &_track, sizeof(_track) ); }
    SBTRACK*              GetTrack()    { return &_track; }
    SBINFO*               GetInfo()     { return &_info; }
    HTHEME                GetTheme()    { return _hTheme; }
    BOOL                  IsAttaching() { return _fAttaching; }
    INT                   GetHotComponent(BOOL fVert) { return fVert ? _htVert : _htHorz; }
    VOID                  SetHotComponent(INT ht, BOOL fVert) { (fVert ? _htVert : _htHorz) = ht; }
    virtual void          ChangeSBTheme();
    virtual BOOL          FreshenSBData( int nBar, BOOL fRedraw );

    //  UxScrollBar API.
    static CUxScrollBar*  Attach( HWND hwnd, BOOL bCtl, BOOL fRedraw );
    static CUxScrollBar*  FromHwnd( HWND hwnd );
    static void           Detach( HWND hwnd );

    static SBTRACK*       GetSBTrack( HWND hwnd );
    static void           ClearSBTrack( HWND hwnd );
    static SBINFO*        GetSBInfo( HWND hwnd );
    static HTHEME         GetSBTheme( HWND hwnd );
    static INT            GetSBHotComponent( HWND hwnd, BOOL fVert);


protected:
    HWND        _hwnd;
    SBTRACK     _track;
    SBINFO      _info;
    INT         _htVert;            // Scroll bar part the mouse is currently over
    INT         _htHorz;            // Scroll bar part the mouse is currently over
    HTHEME      _hTheme;// Handle to theme manager
    BOOL        _fAttaching;
};

//-------------------------------------------------------------------------//
//  Scrollbar control
class CUxScrollBarCtl : public CUxScrollBar
//-------------------------------------------------------------------------//
{
public:
    CUxScrollBarCtl();

    virtual BOOL    IsCtl() const { return TRUE;}
    BOOL            AddRemoveDisableFlags( UINT wAdd, UINT wRemove );

    //  UxScrollBarCtl API.
    static CUxScrollBarCtl* FromHwnd( HWND hwnd );
    static UINT             GetDisableFlags( HWND hwnd );
    static SBCALC*          GetCalc( HWND hwnd );
    static BOOL             AddRemoveDisableFlags( HWND, UINT, UINT );
    static LRESULT CALLBACK WndProc( HWND, UINT, WPARAM, LPARAM );

    BOOL   _fVert;
    UINT   _wDisableFlags;      // Indicates which arrow is disabled;
    SBCALC _calc;
};

//-------------------------------------------------------------------------//
//  IsScrollBarControl
#ifdef PORTPORT
#define IsScrollBarControl(h) (GETFNID(h) == FNID_SCROLLBAR)
#else  //PORTPORT
inline BOOL IsScrollBarControl(HWND hwnd)   {
    return CUxScrollBarCtl::FromHwnd( hwnd ) != NULL;
}
#endif //PORTPORT

//-------------------------------------------------------------------------//
//  Forwards:
void           DrawScrollBar( HWND hwnd, HDC hdc, LPRECT prcOverrideClient, BOOL fVert);
HWND           SizeBoxHwnd( HWND hwnd );
VOID          _DrawPushButton( HWND hwnd, HDC hdc, LPRECT lprc, UINT state, UINT flags, BOOL fVert);
UINT          _GetWndSBDisableFlags(HWND, BOOL);
void CALLBACK _TrackThumb( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, PSBCALC pSBCalc);
void CALLBACK _TrackBox( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, PSBCALC pSBCalc);
void          _RedrawFrame( HWND hwnd );
BOOL          _FChildVisible( HWND hwnd );
LONG          _SetScrollBar( HWND hwnd, int code, LPSCROLLINFO lpsi, BOOL fRedraw);

HBRUSH        _UxGrayBrush(VOID);

//-------------------------------------------------------------------------//
BOOL WINAPI InitScrollBarClass( HINSTANCE hInst )
{
    WNDCLASSEX wc;
    ZeroMemory( &wc, sizeof(wc) );
    wc.cbSize = sizeof(wc);
    wc.style = CS_GLOBALCLASS|CS_PARENTDC|CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS;
    wc.lpfnWndProc = CUxScrollBarCtl::WndProc;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hInstance = hInst;
    wc.lpszClassName = WC_SCROLLBAR;
    wc.cbWndExtra = max(sizeof(CUxScrollBar), sizeof(CUxScrollBarCtl));
    return RegisterClassEx( &wc ) != 0;
}

//-------------------------------------------------------------------------//
//  CUxScrollBar impl
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
CUxScrollBar::CUxScrollBar()
    :   _hwnd(NULL), 
        _hTheme(NULL), 
        _htVert(HTNOWHERE), 
        _htHorz(HTNOWHERE), 
        _fAttaching(FALSE)
{
    ClearTrack();
    ZeroMemory( &_info, sizeof(_info) );
    _info.Vert.posMax = 100;    // ported from _InitPwSB
    _info.Horz.posMax = 100;    // ported from _InitPwSB
}

//-------------------------------------------------------------------------//
CUxScrollBar* CUxScrollBar::Attach( HWND hwnd, BOOL bCtl, BOOL fRedraw )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if( NULL == psb )
    {
        psb = bCtl ? new CUxScrollBarCtl : new CUxScrollBar;

        if( psb != NULL )
        {
            ASSERT( psb->IsCtl() == bCtl );

            if( (! hwnd) || (! SetProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_SCROLLBAR)), (HANDLE)psb ) ))
            {
                delete psb;
                psb = NULL;
            }
            else
            {
                psb->_hwnd = hwnd;
                psb->_fAttaching = TRUE;

                if (psb->IsCtl())
                {
                    psb->_hTheme = OpenThemeData(hwnd, L"ScrollBar");
                }
                else
                {
                    psb->_hTheme = OpenNcThemeData(hwnd, L"ScrollBar");

                    //
                    // window SBs must grovel for state data each 
                    // time attached [scotthan]
                    //
                    SCROLLINFO si;

                    ZeroMemory(&si, sizeof(si));
                    si.cbSize = sizeof(si);
                    si.fMask  = SIF_ALL;
                    if (GetScrollInfo(hwnd, SB_VERT, &si))
                    {
                        si.fMask |= SIF_DISABLENOSCROLL;
                        _SetScrollBar(hwnd, SB_VERT, &si, FALSE);
                    }

                    ZeroMemory(&si, sizeof(si));
                    si.cbSize = sizeof(si);
                    si.fMask  = SIF_ALL;
                    if (GetScrollInfo(hwnd, SB_HORZ, &si))
                    {
                        si.fMask |= SIF_DISABLENOSCROLL;
                        _SetScrollBar(hwnd, SB_HORZ, &si, FALSE);
                    }
                }

                psb->_fAttaching = FALSE;
            }
        }
    }

    return psb;
}

//-------------------------------------------------------------------------//
CUxScrollBar* CUxScrollBar::FromHwnd( HWND hwnd )
{
    if (! hwnd)
        return NULL;

    return (CUxScrollBar*)GetProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_SCROLLBAR)));
}

//-------------------------------------------------------------------------//
void CUxScrollBar::Detach( HWND hwnd )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if ( psb == NULL || !psb->_fAttaching )
    {
        if (hwnd)
        {
            RemoveProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_SCROLLBAR)));
        }

        if( psb != NULL )
        {
            if ( psb->_hTheme )
            {
                CloseThemeData(psb->_hTheme);
            }
            delete psb;
        }
    }
}

//-------------------------------------------------------------------------//
void WINAPI AttachScrollBars( HWND hwnd )
{
    ASSERT( GetWindowLong( hwnd, GWL_STYLE ) & (WS_HSCROLL|WS_VSCROLL) );
    CUxScrollBar::Attach( hwnd, FALSE, FALSE );
}

//-------------------------------------------------------------------------//
void WINAPI DetachScrollBars( HWND hwnd )
{
    CUxScrollBar::Detach( hwnd );
}

//-------------------------------------------------------------------------//
SBTRACK* CUxScrollBar::GetSBTrack( HWND hwnd )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if( psb )
        return &psb->_track;
    return NULL;
}

//-------------------------------------------------------------------------//
void CUxScrollBar::ClearSBTrack( HWND hwnd )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if( psb )
        psb->ClearTrack();
}

//-------------------------------------------------------------------------//
SBINFO* CUxScrollBar::GetSBInfo( HWND hwnd )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if( psb )
        return &psb->_info;
    return NULL;
}

//-------------------------------------------------------------------------//
HTHEME CUxScrollBar::GetSBTheme( HWND hwnd )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if( psb )
        return psb->_hTheme;
    return NULL;
}

//-------------------------------------------------------------------------//
INT CUxScrollBar::GetSBHotComponent( HWND hwnd, BOOL fVert )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if( psb )
        return psb->GetHotComponent(fVert);
    return 0;
}

//-------------------------------------------------------------------------//
BOOL CUxScrollBar::FreshenSBData( int nBar, BOOL fRedraw )
{
#ifdef __POLL_FOR_SCROLLINFO__

    ASSERT(IsWindow(_hwnd));

    if( !IsCtl() )
    {
        // Note scrollbar ctls don't go stale because
        // they receive SBM notifications
        SCROLLINFO si;
        si.cbSize = sizeof(si);
        si.fMask  = SIF_ALL;

        switch(nBar)
        {
            case SB_VERT:
            case SB_HORZ:
                if( GetScrollInfo( _hwnd, nBar, &si ) )
                {
                    _SetScrollBar( _hwnd, nBar, &si, fRedraw );
                }
                break;

            case SB_BOTH:
                return FreshenSBData( SB_VERT, fRedraw ) &&
                       FreshenSBData( SB_HORZ, fRedraw );
                break;

            default: return FALSE;
        }
    }
#endif __POLL_FOR_SCROLLINFO__

    return TRUE;
}

//-------------------------------------------------------------------------//
void CUxScrollBar::ChangeSBTheme()
{
    if ( _hTheme )
    {
        CloseThemeData(_hTheme);
    }

    _hTheme = NULL;

    if (IsCtl())
        _hTheme = OpenThemeData(_hwnd, L"ScrollBar");
    else
        _hTheme = OpenNcThemeData(_hwnd, L"ScrollBar");
}

//-------------------------------------------------------------------------//
//  CUxScrollBarCtl impl
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
CUxScrollBarCtl::CUxScrollBarCtl()
    :   _wDisableFlags(0), _fVert(FALSE)
{
    ZeroMemory( &_calc, sizeof(_calc) );
}

//-------------------------------------------------------------------------//
CUxScrollBarCtl* CUxScrollBarCtl::FromHwnd( HWND hwnd )
{
    CUxScrollBarCtl* psb = (CUxScrollBarCtl*)CUxScrollBar::FromHwnd( hwnd );
    if( psb )
        return psb->IsCtl() ? psb : NULL;
    return NULL;
}

//-------------------------------------------------------------------------//
UINT CUxScrollBarCtl::GetDisableFlags( HWND hwnd )
{
    CUxScrollBarCtl* psb = FromHwnd( hwnd );
    if( psb )
        return psb->_wDisableFlags;
    return 0;
}

//-------------------------------------------------------------------------//
SBCALC* CUxScrollBarCtl::GetCalc( HWND hwnd )
{
    CUxScrollBarCtl* psb = FromHwnd( hwnd );
    if( psb )
        return &psb->_calc;
    return NULL;
}

//-------------------------------------------------------------------------//
//  CUxScrollBarCtl::AddRemoveDisableFlags() - static 
BOOL CUxScrollBarCtl::AddRemoveDisableFlags( HWND hwnd, UINT wAdd, UINT wRemove )
{
    CUxScrollBarCtl* psb = FromHwnd( hwnd );
    if( psb )
        return psb->AddRemoveDisableFlags( wAdd, wRemove );
    return FALSE;
}

//-------------------------------------------------------------------------//
//  CUxScrollBarCtl::AddRemoveDisableFlags() - instance member
BOOL CUxScrollBarCtl::AddRemoveDisableFlags( UINT wAdd, UINT wRemove )
{
    //  returns TRUE if flags changed, otherwise FALSE.
    UINT wOld = _wDisableFlags;
    _wDisableFlags |= wAdd;
    _wDisableFlags &= ~wRemove;
    return _wDisableFlags != wOld;
}

//-------------------------------------------------------------------------//
//  CUxScrollBar::Calc().  computes metrics for window SBs only.  
//  derives rect and calls Calc2.
CUxScrollBar* CUxScrollBar::Calc(
    HWND hwnd,
    PSBCALC pSBCalc,
    LPRECT prcOverrideClient,
    BOOL fVert)
{
    RECT    rcT;
#ifdef USE_MIRRORING
    int     cx, iTemp;
#endif

    //
    //  Get client rectangle in window-relative coords.  
    //  We know that window scrollbars always align to the right
    //  and to the bottom of the client area.
    //
    WINDOWINFO wi;
    wi.cbSize = sizeof(wi);
    if( !GetWindowInfo( hwnd, &wi ) )
        return NULL;
    OffsetRect( &wi.rcClient, -wi.rcWindow.left, -wi.rcWindow.top );

#ifdef USE_MIRRORING
    if (TestWF(hwnd, WEFLAYOUTRTL)) {
        cx                = wi.rcWindow.right - wi.rcWindow.left;
        iTemp             = wi.rcClient.left;
        wi.rcClient.left  = cx - wi.rcClient.right;
        wi.rcClient.right = cx - iTemp;
    }
#endif

    if (fVert) {
         // Only add on space if vertical scrollbar is really there.
        if (TestWF(hwnd, WEFLEFTSCROLL)) {
            rcT.right = rcT.left = wi.rcClient.left;
            if (TestWF(hwnd, WFVPRESENT))
                rcT.left -= SYSMET(CXVSCROLL);
        } else {
            rcT.right = rcT.left = wi.rcClient.right;
            if (TestWF(hwnd, WFVPRESENT))
                rcT.right += SYSMET(CXVSCROLL);
        }

        rcT.top = wi.rcClient.top;
        rcT.bottom = wi.rcClient.bottom;
    } else {
        // Only add on space if horizontal scrollbar is really there.
        rcT.bottom = rcT.top = wi.rcClient.bottom;
        if (TestWF(hwnd, WFHPRESENT))
            rcT.bottom += SYSMET(CYHSCROLL);

        rcT.left = wi.rcClient.left;
        rcT.right = wi.rcClient.right;
    }

    if (prcOverrideClient)
    {
        rcT = *prcOverrideClient;
    }
    // If InitPwSB stuff fails (due to our heap being full) there isn't anything reasonable
    // we can do here, so just let it go through.  We won't fault but the scrollbar won't work
    // properly either...
    CUxScrollBar* psb = CUxScrollBar::Attach( hwnd, FALSE, FALSE );
    if( psb )
    {
        SBDATA*  pData = fVert ? &psb->_info.Vert : &psb->_info.Horz;
        if( psb )
            psb->Calc2( pSBCalc, &rcT, pData, fVert );
        return psb;
    }
    return NULL;
}

//-------------------------------------------------------------------------//
// CUxScrollBar::Calc2().  computes metrics for window SBs or SB ctls.  
void CUxScrollBar::Calc2( PSBCALC pSBCalc, LPRECT lprc, CONST PSBDATA pw, BOOL fVert)
{
    int cpx;
    DWORD dwRange;
    int denom;

    if (fVert) {
        pSBCalc->pxTop = lprc->top;
        pSBCalc->pxBottom = lprc->bottom;
        pSBCalc->pxLeft = lprc->left;
        pSBCalc->pxRight = lprc->right;
        pSBCalc->cpxThumb = SYSMET(CYVSCROLL);
    } else {

        /*
         * For horiz scroll bars, "left" & "right" are "top" and "bottom",
         * and vice versa.
         */
        pSBCalc->pxTop = lprc->left;
        pSBCalc->pxBottom = lprc->right;
        pSBCalc->pxLeft = lprc->top;
        pSBCalc->pxRight = lprc->bottom;
        pSBCalc->cpxThumb = SYSMET(CXHSCROLL);
    }

    pSBCalc->data.pos = pw->pos;
    pSBCalc->data.page = pw->page;
    pSBCalc->data.posMin = pw->posMin;
    pSBCalc->data.posMax = pw->posMax;

    dwRange = ((DWORD)(pSBCalc->data.posMax - pSBCalc->data.posMin)) + 1;

    //
    // For the case of short scroll bars that don't have enough
    // room to fit the full-sized up and down arrows, shorten
    // their sizes to make 'em fit
    //
    cpx = min((pSBCalc->pxBottom - pSBCalc->pxTop) / 2, pSBCalc->cpxThumb);

    pSBCalc->pxUpArrow   = pSBCalc->pxTop    + cpx;
    pSBCalc->pxDownArrow = pSBCalc->pxBottom - cpx;

    if ((pw->page != 0) && (dwRange != 0)) {
        // JEFFBOG -- This is the one and only place where we should
        // see 'range'.  Elsewhere it should be 'range - page'.

        /*
         * The minimun thumb size used to depend on the frame/edge metrics.
         * People that increase the scrollbar width/height expect the minimun
         *  to grow with proportianally. So NT5 bases the minimun on
         *  CXH/YVSCROLL, which is set by default in cpxThumb.
         */
        /*
         * i is used to keep the macro "max" from executing MulDiv twice.
         */
        int i = MulDiv(pSBCalc->pxDownArrow - pSBCalc->pxUpArrow,
                                             pw->page, dwRange);
        pSBCalc->cpxThumb = max(pSBCalc->cpxThumb / 2, i);
    }

    pSBCalc->pxMin = pSBCalc->pxTop + cpx;
    pSBCalc->cpx = pSBCalc->pxBottom - cpx - pSBCalc->cpxThumb - pSBCalc->pxMin;

    denom = dwRange - (pw->page ? pw->page : 1);
    if (denom)
        pSBCalc->pxThumbTop = MulDiv(pw->pos - pw->posMin,
            pSBCalc->cpx, denom) +
            pSBCalc->pxMin;
    else
        pSBCalc->pxThumbTop = pSBCalc->pxMin - 1;

    pSBCalc->pxThumbBottom = pSBCalc->pxThumbTop + pSBCalc->cpxThumb;
}

//-------------------------------------------------------------------------//
void CUxScrollBar::DoScroll( HWND hwndNotify, int cmd, int pos, BOOL fVert )
{
    HWND hwnd = _hwnd;
    
    //
    // Send scroll notification to the scrollbar owner. If this is a control
    // the lParam is the control's handle, NULL otherwise.
    //
    SendMessage(hwndNotify, 
                (UINT)(fVert ? WM_VSCROLL : WM_HSCROLL),
                MAKELONG(cmd, pos), 
                (LPARAM)(IsCtl() ? _hwnd : NULL));

    //
    // The hwnd can have it's scrollbar removed as the result
    // of the previous sendmessge. 
    //
    if( CUxScrollBar::GetSBTrack(hwnd) && !IsCtl() )
    {
        FreshenSBData( fVert ? SB_VERT : SB_HORZ, TRUE );
    }
}


/*
 * Now it is possible to selectively Enable/Disable just one arrow of a Window
 * scroll bar; Various bits in the 7th word in the rgwScroll array indicates which
 * one of these arrows are disabled; The following masks indicate which bit of the
 * word indicates which arrow;
 */
#define WSB_HORZ_LF  0x0001  // Represents the Left arrow of the horizontal scroll bar.
#define WSB_HORZ_RT  0x0002  // Represents the Right arrow of the horizontal scroll bar.
#define WSB_VERT_UP  0x0004  // Represents the Up arrow of the vert scroll bar.
#define WSB_VERT_DN  0x0008  // Represents the Down arrow of the vert scroll bar.

#define WSB_VERT (WSB_VERT_UP | WSB_VERT_DN)
#define WSB_HORZ   (WSB_HORZ_LF | WSB_HORZ_RT)

void DrawCtlThumb( SBHWND );

/*
 * RETURN_IF_PSBTRACK_INVALID:
 * This macro tests whether the pSBTrack we have is invalid, which can happen
 * if it gets freed during a callback.
 * This protects agains the original pSBTrack being freed and no new one
 * being allocated or a new one being allocated at a different address.
 * This does not protect against the original pSBTrack being freed and a new
 * one being allocated at the same address.
 * If pSBTrack has changed, we assert that there is not already a new one
 * because we are really not expecting this.
 */
#define RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd) \
    if ((pSBTrack) != CUxScrollBar::GetSBTrack(hwnd)) {      \
        ASSERT(CUxScrollBar::GetSBTrack(hwnd) == NULL);  \
        return;                                    \
    }

/*
 * REEVALUATE_PSBTRACK
 * This macro just refreshes the local variable pSBTrack, in case it has
 * been changed during a callback.  After performing this operation, pSBTrack
 * should be tested to make sure it is not now NULL.
 */

#if (defined(DBG) || defined(DEBUG) || defined(_DEBUG))
    #define REEVALUATE_PSBTRACK(pSBTrack, hwnd, str)          \
        if ((pSBTrack) != CUxScrollBar::GetSBTrack(hwnd)) {             \
            RIPMSG3(RIP_WARNING,                              \
                    "%s: pSBTrack changed from %#p to %#p",   \
                    (str), (pSBTrack), CUxScrollBar::GetSBTrack(hwnd)); \
        }                                                     \
        (pSBTrack) = CUxScrollBar::GetSBTrack(hwnd)
#else
    #define REEVALUATE_PSBTRACK(pSBTrack, hwnd, str)          \
        (pSBTrack) = CUxScrollBar::GetSBTrack(hwnd)
#endif

/***************************************************************************\
* HitTestScrollBar
*
* 11/15/96      vadimg          ported from Memphis sources
\***************************************************************************/

int HitTestScrollBar(HWND hwnd, BOOL fVert, POINT pt)
{
    UINT wDisable;
    int px;
    CUxScrollBar*    psb    = CUxScrollBar::FromHwnd( hwnd );
    CUxScrollBarCtl* psbCtl = CUxScrollBarCtl::FromHwnd( hwnd );
    BOOL fCtl = psbCtl != NULL;

    SBCALC SBCalc = {0};
    SBCALC *pSBCalc = NULL;

    if (fCtl) {
        wDisable = psbCtl->_wDisableFlags;
    } else {
        RECT rcWindow;
        GetWindowRect( hwnd, &rcWindow );
#ifdef USE_MIRRORING
        //
        // Reflect the click coordinates on the horizontal
        // scroll bar if the window is mirrored
        //
        if (TestWF(hwnd,WEFLAYOUTRTL) && !fVert) {
            pt.x = rcWindow.right - pt.x;
        }
        else
#endif
        pt.x -= rcWindow.left;
        pt.y -= rcWindow.top;
        wDisable = _GetWndSBDisableFlags(hwnd, fVert);
    }

    if ((wDisable & SB_DISABLE_MASK) == SB_DISABLE_MASK) {
        return HTERROR;
    }

    if (fCtl) {
        pSBCalc = CUxScrollBarCtl::GetCalc(hwnd);
    } else {
        pSBCalc = &SBCalc;
        psb->FreshenSBData( SB_BOTH, FALSE );
        psb->Calc(hwnd, pSBCalc, NULL, fVert);
    }

    px = fVert ? pt.y : pt.x;

    if( pSBCalc )
    {
        if (px < pSBCalc->pxUpArrow) {
            if (wDisable & LTUPFLAG) {
                return HTERROR;
            }
            return HTSCROLLUP;
        } else if (px >= pSBCalc->pxDownArrow) {
            if (wDisable & RTDNFLAG) {
                return HTERROR;
            }
            return HTSCROLLDOWN;
        } else if (px < pSBCalc->pxThumbTop) {
            return HTSCROLLUPPAGE;
        } else if (px < pSBCalc->pxThumbBottom) {
            return HTSCROLLTHUMB;
        } else if (px < pSBCalc->pxDownArrow) {
            return HTSCROLLDOWNPAGE;
        }
    }
    return HTERROR;
}

BOOL _SBGetParms(
    HWND hwnd,
    int code,
    PSBDATA pw,
    LPSCROLLINFO lpsi)
{
    PSBTRACK pSBTrack;

    pSBTrack = CUxScrollBar::GetSBTrack(hwnd);

    if (lpsi->fMask & SIF_RANGE) {
        lpsi->nMin = pw->posMin;
        lpsi->nMax = pw->posMax;
    }

    if (lpsi->fMask & SIF_PAGE)
        lpsi->nPage = pw->page;

    if (lpsi->fMask & SIF_POS) {
        lpsi->nPos = pw->pos;
    }

    if (lpsi->fMask & SIF_TRACKPOS)
    {
        if (pSBTrack && (pSBTrack->nBar == code) && (pSBTrack->hwndTrack == hwnd)) {
            // posNew is in the context of psbiSB's window and bar code
            lpsi->nTrackPos = pSBTrack->posNew;
        } else {
            lpsi->nTrackPos = pw->pos;
        }
    }
    return ((lpsi->fMask & SIF_ALL) ? TRUE : FALSE);
}

//-------------------------------------------------------------------------//
BOOL WINAPI ThemeGetScrollInfo( HWND hwnd, int nBar, LPSCROLLINFO psi )
{
    CUxScrollBar* psb = CUxScrollBar::FromHwnd(hwnd);
    if((psb != NULL) && (psb->IsAttaching() == FALSE))
    {
#ifdef DEBUG
        if( psb->IsCtl() )
        {
            ASSERT(FALSE); // controls cooperate through an SBM_GETSCROLLINFO message.
        }
        else
#endif DEBUG
        {
            SBINFO* psbi;
            if( (psbi = psb->GetInfo()) != NULL )
            {
                SBDATA* psbd = SB_VERT == nBar ? &psbi->Vert :
                               SB_HORZ == nBar ? &psbi->Horz : NULL;
                if( psbd )
                    return _SBGetParms( hwnd, nBar, psbd, psi );
            }
        }
    }
    return FALSE;
}

/***************************************************************************\
* _GetWndSBDisableFlags
*
* This returns the scroll bar Disable flags of the scroll bars of a
*  given Window.
*
*
* History:
*  4-18-91 MikeHar Ported for the 31 merge
\***************************************************************************/

UINT _GetWndSBDisableFlags(
    HWND hwnd,  // The window whose scroll bar Disable Flags are to be returned;
    BOOL fVert)  // If this is TRUE, it means Vertical scroll bar.
{
    PSBINFO pw;

    if ((pw = CUxScrollBar::GetSBInfo( hwnd )) == NULL) {
        RIPERR0(ERROR_NO_SCROLLBARS, RIP_VERBOSE, "");
        return 0;
    }

    return (fVert ? (pw->WSBflags & WSB_VERT) >> 2 : pw->WSBflags & WSB_HORZ);
}


/***************************************************************************\
*  xxxEnableSBCtlArrows()
*
*  This function can be used to selectively Enable/Disable
*     the arrows of a scroll bar Control
*
* History:
* 04-18-91 MikeHar      Ported for the 31 merge
\***************************************************************************/

BOOL xxxEnableSBCtlArrows(
    HWND hwnd,
    UINT wArrows)
{
    UINT wOldFlags = CUxScrollBarCtl::GetDisableFlags( hwnd ); // Get the original status
    BOOL bChanged  = FALSE;

    if (wArrows == ESB_ENABLE_BOTH) {      // Enable both the arrows
        bChanged = CUxScrollBarCtl::AddRemoveDisableFlags( hwnd, 0, SB_DISABLE_MASK );
    } else {
        bChanged = CUxScrollBarCtl::AddRemoveDisableFlags( hwnd, wArrows, 0 );
    }

    /*
     * Check if the status has changed because of this call
     */
    if (!bChanged)
        return FALSE;

    /*
     * Else, redraw the scroll bar control to reflect the new state
     */
    if (IsWindowVisible(hwnd))
        InvalidateRect(hwnd, NULL, TRUE);

    UINT wNewFlags = CUxScrollBarCtl::GetDisableFlags(hwnd);

    // state change notifications
    if ((wOldFlags & ESB_DISABLE_UP) != (wNewFlags & ESB_DISABLE_UP))
    {
        NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEX_SCROLLBAR_UP);
    }

    if ((wOldFlags & ESB_DISABLE_DOWN) != (wNewFlags & ESB_DISABLE_DOWN))
    {
        NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEX_SCROLLBAR_DOWN);
    }

    return TRUE;
}


/***************************************************************************\
* xxxEnableWndSBArrows()
*
*  This function can be used to selectively Enable/Disable
*     the arrows of a Window Scroll bar(s)
*
* History:
*  4-18-91 MikeHar      Ported for the 31 merge
\***************************************************************************/

BOOL xxxEnableWndSBArrows(
    HWND hwnd,
    UINT wSBflags,
    UINT wArrows)
{
    INT wOldFlags;
    PSBINFO pw;
    BOOL bRetValue = FALSE;
    HDC hdc;

    CheckLock(hwnd);
    ASSERT(IsWinEventNotifyDeferredOK());

    if ((pw = CUxScrollBar::GetSBInfo( hwnd )) != NULL)
    {
        wOldFlags = pw->WSBflags;
    }
    else
    {
        // Originally everything is enabled; Check to see if this function is
        // asked to disable anything; Otherwise, no change in status; So, must
        // return immediately;
        if(!wArrows)
            return FALSE;          // No change in status!

        wOldFlags = 0;    // Both are originally enabled;

        CUxScrollBar::Attach( hwnd, FALSE, FALSE );
        if((pw = CUxScrollBar::GetSBInfo(hwnd)) == NULL)  // Allocate the pSBInfo for hWnd
            return FALSE;
    }

    hdc = GetWindowDC(hwnd);
    if (hdc != NULL)
    {

        /*
         *  First Take care of the Horizontal Scroll bar, if one exists.
         */
        if((wSBflags == SB_HORZ) || (wSBflags == SB_BOTH)) {
            if(wArrows == ESB_ENABLE_BOTH)      // Enable both the arrows
                pw->WSBflags &= ~SB_DISABLE_MASK;
            else
                pw->WSBflags |= wArrows;

            /*
             * Update the display of the Horizontal Scroll Bar;
             */
            if(pw->WSBflags != wOldFlags) {
                bRetValue = TRUE;
                wOldFlags = pw->WSBflags;
                if (TestWF(hwnd, WFHPRESENT) && !TestWF(hwnd, WFMINIMIZED) &&
                        IsWindowVisible(hwnd)) {
                    DrawScrollBar(hwnd, hdc, NULL, FALSE);  // Horizontal Scroll Bar.
                }
            }

            // Left button
            if ((wOldFlags & ESB_DISABLE_LEFT) != (pw->WSBflags & ESB_DISABLE_LEFT))
            {
                NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_HSCROLL, INDEX_SCROLLBAR_UP);
            }

            // Right button
            if ((wOldFlags & ESB_DISABLE_RIGHT) != (pw->WSBflags & ESB_DISABLE_RIGHT))
            {
                NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_HSCROLL, INDEX_SCROLLBAR_DOWN);
            }
        }

        // Then take care of the Vertical Scroll bar, if one exists.
        if ((wSBflags == SB_VERT) || (wSBflags == SB_BOTH))
        {
            if (wArrows == ESB_ENABLE_BOTH)
            {
                // Enable both the arrows
                pw->WSBflags &= ~(SB_DISABLE_MASK << 2);
            }
            else
            {
                pw->WSBflags |= (wArrows << 2);
            }

            // Update the display of the Vertical Scroll Bar;
            if(pw->WSBflags != wOldFlags)
            {
                bRetValue = TRUE;
                if (TestWF(hwnd, WFVPRESENT) && !TestWF(hwnd, WFMINIMIZED) && IsWindowVisible(hwnd))
                {
                    // Vertical Scroll Bar
                    DrawScrollBar(hwnd, hdc, NULL, TRUE);
                }

                // Up button
                if ((wOldFlags & (ESB_DISABLE_UP << 2)) != (pw->WSBflags & (ESB_DISABLE_UP << 2)))
                {
                    NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_VSCROLL, INDEX_SCROLLBAR_UP);
                }

                // Down button
                if ((wOldFlags & (ESB_DISABLE_DOWN << 2)) != (pw->WSBflags & (ESB_DISABLE_DOWN << 2)))
                {
                    NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_VSCROLL, INDEX_SCROLLBAR_DOWN);
                }
            }
        }

        ReleaseDC(hwnd,hdc);
    }

    return bRetValue;
}


/***************************************************************************\
* EnableScrollBar()
*
* This function can be used to selectively Enable/Disable
*     the arrows of a scroll bar; It could be used with Windows Scroll
*     bars as well as scroll bar controls
*
* History:
*  4-18-91 MikeHar Ported for the 31 merge
\***************************************************************************/

BOOL xxxEnableScrollBar(
    HWND hwnd,
    UINT wSBflags,  // Whether it is a Window Scroll Bar; if so, HORZ or VERT?
                    // Possible values are SB_HORZ, SB_VERT, SB_CTL or SB_BOTH
    UINT wArrows)   // Which arrows must be enabled/disabled:
                    // ESB_ENABLE_BOTH = > Enable both arrows.
                    // ESB_DISABLE_LTUP = > Disable Left/Up arrow;
                    // ESB_DISABLE_RTDN = > DIsable Right/Down arrow;
                    // ESB_DISABLE_BOTH = > Disable both the arrows;
{
#define ES_NOTHING 0
#define ES_DISABLE 1
#define ES_ENABLE  2
    UINT wOldFlags;
    UINT wEnableWindow;

    CheckLock(hwnd);

    if(wSBflags != SB_CTL) {
        return xxxEnableWndSBArrows(hwnd, wSBflags, wArrows);
    }

    /*
     *  Let us assume that we don't have to call EnableWindow
     */
    wEnableWindow = ES_NOTHING;

    wOldFlags = CUxScrollBarCtl::GetDisableFlags( hwnd ) & (UINT)SB_DISABLE_MASK;

    /*
     * Check if the present state of the arrows is exactly the same
     *  as what the caller wants:
     */
    if (wOldFlags == wArrows)
        return FALSE ;          // If so, nothing needs to be done;

    /*
     * Check if the caller wants to disable both the arrows
     */
    if (wArrows == ESB_DISABLE_BOTH) {
        wEnableWindow = ES_DISABLE;      // Yes! So, disable the whole SB Ctl.
    } else {

        /*
         * Check if the caller wants to enable both the arrows
         */
        if(wArrows == ESB_ENABLE_BOTH) {

            /*
             * We need to enable the SB Ctl only if it was already disabled.
             */
            if(wOldFlags == ESB_DISABLE_BOTH)
                wEnableWindow = ES_ENABLE;// EnableWindow(.., TRUE);
        } else {

            /*
             * Now, Caller wants to disable only one arrow;
             * Check if one of the arrows was already disabled and we want
             * to disable the other;If so, the whole SB Ctl will have to be
             * disabled; Check if this is the case:
             */
            if((wOldFlags | wArrows) == ESB_DISABLE_BOTH)
                wEnableWindow = ES_DISABLE;      // EnableWindow(, FALSE);
         }
    }
    if(wEnableWindow != ES_NOTHING) {

        /*
         * EnableWindow returns old state of the window; We must return
         * TRUE only if the Old state is different from new state.
         */
        if(EnableWindow(hwnd, (BOOL)(wEnableWindow == ES_ENABLE))) {
            return !(TestWF(hwnd, WFDISABLED));
        } else {
            return TestWF(hwnd, WFDISABLED);
        }
    }

    return (BOOL)SendMessage(hwnd, SBM_ENABLE_ARROWS, (DWORD)wArrows, 0);
#undef ES_NOTHING
#undef ES_DISABLE
#undef ES_ENABLE
}

//-------------------------------------------------------------------------
BOOL WINAPI ThemeEnableScrollBar( HWND hwnd, UINT nSBFlags, UINT nArrows )
{
    return xxxEnableScrollBar( hwnd, nSBFlags, nArrows );
}


//-------------------------------------------------------------------------
//
// DrawSizeBox() - paints the scrollbar sizebox/gripper given top, left
// point in window coords.
//
void DrawSizeBox(HWND hwnd, HDC hdc, int x, int y)
{
    RECT rc;

    SetRect(&rc, x, y, x + SYSMET(CXVSCROLL), y + SYSMET(CYHSCROLL));
    FillRect(hdc, &rc, GetSysColorBrush(COLOR_3DFACE));

    //
    // If we have a scrollbar control, or the sizebox is not associated with
    // a sizeable window, draw the flat gray sizebox.  Otherwise, use the
    // sizing grip.
    //

    if ((IsScrollBarControl(hwnd) && TestWF(hwnd, SBFSIZEGRIP)) || SizeBoxHwnd(hwnd))
    {
        HTHEME hTheme = CUxScrollBar::GetSBTheme(hwnd);

        if (!hTheme)
        {
            // Blt out the grip bitmap.
            DrawFrameControl( hdc, &rc, DFC_SCROLL,
                              TestWF(hwnd, WEFLEFTSCROLL) ? DFCS_SCROLLSIZEGRIPRIGHT : DFCS_SCROLLSIZEGRIP );
            
            //user: BitBltSysBmp(hdc, x, y, TestWF(hwnd, WEFLEFTSCROLL) ? OBI_NCGRIP_L : OBI_NCGRIP);
        }
        else
        {
            DrawThemeBackground(hTheme, hdc, SBP_SIZEBOX, TestWF(hwnd, WEFLEFTSCROLL) ? SZB_LEFTALIGN : SZB_RIGHTALIGN, &rc, 0);
        }
    }
}


//-------------------------------------------------------------------------
//
// _DrawSizeBoxFromFrame
//
// Calculates position and draws of sizebox/gripper at fixed offset from
// perimeter of host window frame.
//
// This, combined with implementation of DrawSizeBox(), 
// was the original DrawSize() port.  Needed to expost method to
// draw sizebox at absolute position.  [scotthan]
//
void _DrawSizeBoxFromFrame(HWND hwnd, HDC hdc, int cxFrame,int cyFrame )
{
    int     x, y;
    RECT    rcWindow;

    GetWindowRect(hwnd, &rcWindow);

    if (TestWF(hwnd, WEFLEFTSCROLL)) 
    {
        x = cxFrame;
    } 
    else 
    {
        x = rcWindow.right - rcWindow.left - cxFrame - SYSMET(CXVSCROLL);
    }

    y = rcWindow.bottom - rcWindow.top  - cyFrame - SYSMET(CYHSCROLL);

    DrawSizeBox(hwnd, hdc, x, y);
}


//-------------------------------------------------------------------------
HBRUSH ScrollBar_GetControlColor(HWND hwndParent, HWND hwndCtl, HDC hdc, UINT uMsg, BOOL *pfOwnerBrush)
{
    HBRUSH hbrush;
    BOOL   fOwnerBrush = FALSE;

    //
    // If we're sending to a window of another thread, don't send this message
    // but instead call DefWindowProc().  New rule about the CTLCOLOR messages.
    // Need to do this so that we don't send an hdc owned by one thread to
    // another thread.  It is also a harmless change.
    //
    if (GetWindowThreadProcessId(hwndParent, NULL) != GetCurrentThreadId()) 
    {
        hbrush = (HBRUSH)DefWindowProc(hwndParent, uMsg, (WPARAM)hdc, (LPARAM)hwndCtl);
    }
    else
    {
        hbrush = (HBRUSH)SendMessage(hwndParent, uMsg, (WPARAM)hdc, (LPARAM)hwndCtl);

        //
        // If the brush returned from the parent is invalid, get a valid brush from
        // DefWindowProc.
        //
        if (hbrush == NULL) 
        {
            hbrush = (HBRUSH)DefWindowProc(hwndParent, uMsg, (WPARAM)hdc, (LPARAM)hwndCtl);
        }
        else
        {
            fOwnerBrush = TRUE;
        }
    }

    if (pfOwnerBrush)
    {
        *pfOwnerBrush = fOwnerBrush;
    }

    return hbrush;
}


//-------------------------------------------------------------------------
HBRUSH ScrollBar_GetControlBrush(HWND hwnd, HDC hdc, UINT uMsg, BOOL *pfOwnerBrush)
{
    HWND hwndSend;

    hwndSend = TESTFLAG(GetWindowStyle(hwnd), WS_POPUP) ? GetOwner(hwnd) : GetParent(hwnd);
    if (hwndSend == NULL)
    {
        hwndSend = hwnd;
    }

    return ScrollBar_GetControlColor(hwndSend, hwnd, hdc, uMsg, pfOwnerBrush);
}


//-------------------------------------------------------------------------
HBRUSH ScrollBar_GetColorObjects(HWND hwnd, HDC hdc, BOOL *pfOwnerBrush)
{
    HBRUSH hbrRet;

    CheckLock(hwnd);

    // Use the scrollbar color even if the scrollbar is disabeld.
    if (!IsScrollBarControl(hwnd))
    {
        hbrRet = (HBRUSH)DefWindowProc(hwnd, WM_CTLCOLORSCROLLBAR, (WPARAM)hdc, (LPARAM)HWq(hwnd));
    }
    else 
    {
        // B#12770 - GetControlBrush sends a WM_CTLCOLOR message to the
        // owner.  If the app doesn't process the message, DefWindowProc32
        // will always return the appropriate system brush. If the app.
        // returns an invalid object, GetControlBrush will call DWP for
        // the default brush. Thus hbrRet doesn't need any validation
        // here.
        hbrRet = ScrollBar_GetControlBrush(hwnd, hdc, WM_CTLCOLORSCROLLBAR, pfOwnerBrush);
    }

    return hbrRet;
}


//-------------------------------------------------------------------------
//
// ScrollBar_PaintTrack
//
// Draws lines & middle of thumb groove
// Note that pw points into prc.  Moreover, note that both pw & prc are
// pointers, so *prc better not be on the stack.
//
void ScrollBar_PaintTrack(HWND hwnd, HDC hdc, HBRUSH hbr, LPRECT prc, BOOL fVert, INT iPartId, BOOL fOwnerBrush)
{
    HTHEME hTheme = CUxScrollBar::GetSBTheme(hwnd);

    // If the scrollbar is unthemed or 
    // #374054 we've been passed an brush defined by the owner, paint 
    // the shaft using the brush 
    if ((hTheme == NULL) || (fOwnerBrush == TRUE))
    {
        if ((hbr == SYSHBR(3DHILIGHT)) || (hbr == SYSHBR(SCROLLBAR)) || (hbr == _UxGrayBrush()) )
        {
            FillRect(hdc, prc, hbr);
        }
        else
        {
    #ifdef PORTPORT // we need SystemParametersInfo for _UxGrayBrush
        // Draw sides
           CopyRect(&rc, prc);
           DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_ADJUST | BF_FLAT |
                    (fVert ? BF_LEFT | BF_RIGHT : BF_TOP | BF_BOTTOM));
    #endif PORTPORT

        // Fill middle
            FillRect(hdc, prc, hbr);
        }
    }
    else
    {
        INT iStateId;
        INT ht = CUxScrollBar::GetSBHotComponent(hwnd, fVert);
        
        if ((CUxScrollBarCtl::GetDisableFlags(hwnd) & ESB_DISABLE_BOTH) == ESB_DISABLE_BOTH)
        {
            iStateId = SCRBS_DISABLED;
        }
        else if ((((iPartId == SBP_LOWERTRACKHORZ) || (iPartId == SBP_LOWERTRACKVERT)) && (ht == HTSCROLLUPPAGE)) ||
                 (((iPartId == SBP_UPPERTRACKHORZ) || (iPartId == SBP_UPPERTRACKVERT)) && (ht == HTSCROLLDOWNPAGE)))
        {
            iStateId = SCRBS_HOT;
       }
        else
        {
            iStateId = SCRBS_NORMAL;
        }
        DrawThemeBackground(hTheme, hdc, iPartId, iStateId, prc, 0);
    }
}

/***************************************************************************\
* CalcTrackDragRect
*
* Give the rectangle for a scrollbar in pSBTrack->pSBCalc,
* calculate pSBTrack->rcTrack, the rectangle where tracking
* may occur without cancelling the thumbdrag operation.
*
\***************************************************************************/

void CalcTrackDragRect(PSBTRACK pSBTrack) {

    int     cx;
    int     cy;
    LPINT   pwX, pwY;

    //
    // Point pwX and pwY at the parts of the rectangle
    // corresponding to pSBCalc->pxLeft, pxTop, etc.
    //
    // pSBTrack->pSBCalc->pxLeft is the left edge of a vertical
    // scrollbar and the top edge of horizontal one.
    // pSBTrack->pSBCalc->pxTop is the top of a vertical
    // scrollbar and the left of horizontal one.
    // etc...
    //
    // Point pwX and pwY to the corresponding parts
    // of pSBTrack->rcTrack.
    //

    pwX = pwY = (LPINT)&pSBTrack->rcTrack;

    if (pSBTrack->fTrackVert) {
        cy = SYSMET(CYVTHUMB);
        pwY++;
    } else {
        cy = SYSMET(CXHTHUMB);
        pwX++;
    }
    /*
     * Later5.0 GerardoB: People keep complaining about this tracking region
     *  being too narrow so let's make it wider while PM decides what to do
     *  about it.
     * We also used to have some hard coded min and max values but that should
     *  depend on some metric, if at all needed.
     */
    cx = (pSBTrack->pSBCalc->pxRight - pSBTrack->pSBCalc->pxLeft) * 8;
    cy *= 2;

    *(pwX + 0) = pSBTrack->pSBCalc->pxLeft - cx;
    *(pwY + 0) = pSBTrack->pSBCalc->pxTop - cy;
    *(pwX + 2) = pSBTrack->pSBCalc->pxRight + cx;
    *(pwY + 2) = pSBTrack->pSBCalc->pxBottom + cy;
}

void RecalcTrackRect(PSBTRACK pSBTrack) {
    LPINT pwX, pwY;
    RECT rcSB;


    if (!pSBTrack->fCtlSB)
        CUxScrollBar::Calc(pSBTrack->hwndTrack, pSBTrack->pSBCalc, NULL, pSBTrack->fTrackVert);

    pwX = (LPINT)&rcSB;
    pwY = pwX + 1;
    if (!pSBTrack->fTrackVert)
        pwX = pwY--;

    *(pwX + 0) = pSBTrack->pSBCalc->pxLeft;
    *(pwY + 0) = pSBTrack->pSBCalc->pxTop;
    *(pwX + 2) = pSBTrack->pSBCalc->pxRight;
    *(pwY + 2) = pSBTrack->pSBCalc->pxBottom;

    switch(pSBTrack->cmdSB) {
    case SB_LINEUP:
        *(pwY + 2) = pSBTrack->pSBCalc->pxUpArrow;
        break;
    case SB_LINEDOWN:
        *(pwY + 0) = pSBTrack->pSBCalc->pxDownArrow;
        break;
    case SB_PAGEUP:
        *(pwY + 0) = pSBTrack->pSBCalc->pxUpArrow;
        *(pwY + 2) = pSBTrack->pSBCalc->pxThumbTop;
        break;
    case SB_THUMBPOSITION:
        CalcTrackDragRect(pSBTrack);
        break;
    case SB_PAGEDOWN:
        *(pwY + 0) = pSBTrack->pSBCalc->pxThumbBottom;
        *(pwY + 2) = pSBTrack->pSBCalc->pxDownArrow;
        break;
    }

    if (pSBTrack->cmdSB != SB_THUMBPOSITION) {
        CopyRect(&pSBTrack->rcTrack, &rcSB);
    }
}

//-------------------------------------------------------------------------
void DrawThumb2(
    HWND    hwnd,
    PSBCALC pSBCalc,
    HDC     hdc,
    HBRUSH  hbr,
    BOOL    fVert,
    UINT    wDisable,       // Disabled flags for the scroll bar
    BOOL    fOwnerBrush)
{
    int    *pLength;
    int    *pWidth;
    RECT   rcSB;
    PSBTRACK pSBTrack;
    HTHEME hTheme = CUxScrollBar::GetSBTheme(hwnd);

    //
    // Bail out if the scrollbar has an empty rect
    //
    if ((pSBCalc->pxTop >= pSBCalc->pxBottom) || (pSBCalc->pxLeft >= pSBCalc->pxRight))
    {
        return;
    }

    pLength = (LPINT)&rcSB;
    if (fVert)
    {
        pWidth = pLength++;
    }
    else
    {
        pWidth  = pLength + 1;
    }

    pWidth[0] = pSBCalc->pxLeft;
    pWidth[2] = pSBCalc->pxRight;

    // If were're not themed and both buttons are disabled OR there isn't
    // enough room to draw a thumb just draw the track and run.
    //
    // When we are themed the thumb can be drawn disabled.
    if (((wDisable & LTUPFLAG) && (wDisable & RTDNFLAG)) || 
        ((pSBCalc->pxDownArrow - pSBCalc->pxUpArrow) < pSBCalc->cpxThumb))
    {
        // draw the entire track
        pLength[0] = pSBCalc->pxUpArrow;
        pLength[2] = pSBCalc->pxDownArrow;

        ScrollBar_PaintTrack(hwnd, hdc, hbr, &rcSB, fVert, fVert ? SBP_LOWERTRACKVERT : SBP_LOWERTRACKHORZ, fOwnerBrush);
        return;
    }

    if (pSBCalc->pxUpArrow < pSBCalc->pxThumbTop)
    {
        // draw the track above the thumb
        pLength[0] = pSBCalc->pxUpArrow;
        pLength[2] = pSBCalc->pxThumbTop;

        ScrollBar_PaintTrack(hwnd, hdc, hbr, &rcSB, fVert, fVert ? SBP_LOWERTRACKVERT : SBP_LOWERTRACKHORZ, fOwnerBrush);
    }

    if (pSBCalc->pxThumbBottom < pSBCalc->pxDownArrow)
    {
        // draw the track below the thumb
        pLength[0] = pSBCalc->pxThumbBottom;
        pLength[2] = pSBCalc->pxDownArrow;

        ScrollBar_PaintTrack(hwnd, hdc, hbr, &rcSB, fVert, fVert ? SBP_UPPERTRACKVERT : SBP_UPPERTRACKHORZ, fOwnerBrush);
    }

    //
    // Draw elevator
    //
    pLength[0] = pSBCalc->pxThumbTop;
    pLength[2] = pSBCalc->pxThumbBottom;

    // Not soft!
    _DrawPushButton(hwnd, hdc, &rcSB, 0, 0, fVert);

#ifdef _VISUAL_DELTA_
    InflateRect( &rcSB, -CARET_BORDERWIDTH, -CARET_BORDERWIDTH);
    DrawEdge( hdc, &rcSB, EDGE_SUNKEN, BF_RECT );
#endif _VISUAL_DELTA_

    /*
     * If we're tracking a page scroll, then we've obliterated the hilite.
     * We need to correct the hiliting rectangle, and rehilite it.
     */
    pSBTrack = CUxScrollBar::GetSBTrack(hwnd);

    if (pSBTrack && (pSBTrack->cmdSB == SB_PAGEUP || pSBTrack->cmdSB == SB_PAGEDOWN) &&
            (hwnd == pSBTrack->hwndTrack) &&
            (BOOL)pSBTrack->fTrackVert == fVert) {

        if (pSBTrack->fTrackRecalc) {
            RecalcTrackRect(pSBTrack);
            pSBTrack->fTrackRecalc = FALSE;
        }

        pLength = (int *)&pSBTrack->rcTrack;

        if (fVert)
            pLength++;

        if (pSBTrack->cmdSB == SB_PAGEUP)
            pLength[2] = pSBCalc->pxThumbTop;
        else
            pLength[0] = pSBCalc->pxThumbBottom;

        if (pLength[0] < pLength[2])
        {
            if (!hTheme)
            {
                InvertRect(hdc, &pSBTrack->rcTrack);
            }
            else
            {
                DrawThemeBackground(hTheme, 
                                    hdc, 
                                    pSBTrack->cmdSB == SB_PAGEUP ? 
                                        (fVert ? SBP_LOWERTRACKVERT : SBP_LOWERTRACKHORZ) : 
                                        (fVert ? SBP_UPPERTRACKVERT : SBP_UPPERTRACKHORZ), 
                                    SCRBS_PRESSED, 
                                    &pSBTrack->rcTrack, 
                                    0);
            }
        }
    }
}

/***************************************************************************\
* xxxDrawSB2
*
*
*
* History:
\***************************************************************************/

void xxxDrawSB2(
    HWND hwnd,
    PSBCALC pSBCalc,
    HDC hdc,
    BOOL fVert,
    UINT wDisable)
{

    int      cLength;
    int      cWidth;
    int      *pwX;
    int      *pwY;
    HBRUSH   hbr;
    HBRUSH   hbrSave;
    int      cpxArrow;
    RECT     rc, rcSB;
    COLORREF crText, crBk;
    HTHEME   hTheme;
    INT      ht;
    INT      iStateId;
    BOOL     fOwnerBrush = FALSE;

    CheckLock(hwnd);

    cLength = (pSBCalc->pxBottom - pSBCalc->pxTop) / 2;
    cWidth = (pSBCalc->pxRight - pSBCalc->pxLeft);

    if ((cLength <= 0) || (cWidth <= 0)) {
        return;
    }

    if (fVert)
    {
        cpxArrow = SYSMET(CYVSCROLL);
    }
    else
    {
        cpxArrow = SYSMET(CXHSCROLL);
    }

    // Save background and DC color, since they get changed in
    // ScrollBar_GetColorObjects. Restore before we return.
    crBk = GetBkColor(hdc);
    crText = GetTextColor(hdc);

    hbr = ScrollBar_GetColorObjects(hwnd, hdc, &fOwnerBrush);

    if (cLength > cpxArrow)
    {
        cLength = cpxArrow;
    }

    pwX = (int *)&rcSB;
    pwY = pwX + 1;
    if (!fVert)
    {
        pwX = pwY--;
    }

    pwX[0] = pSBCalc->pxLeft;
    pwY[0] = pSBCalc->pxTop;
    pwX[2] = pSBCalc->pxRight;
    pwY[2] = pSBCalc->pxBottom;

    hbrSave = SelectBrush(hdc, SYSHBR(BTNTEXT));

    //
    // BOGUS
    // Draw scrollbar arrows as disabled if the scrollbar itself is
    // disabled OR if the window it is a part of is disabled?
    //
    hTheme = CUxScrollBar::GetSBTheme(hwnd);
    ht     = CUxScrollBar::GetSBHotComponent(hwnd, fVert);
    if (fVert) 
    {
        // up button
        CopyRect(&rc, &rcSB);
        rc.bottom = rc.top + cLength;
        if (!hTheme)
        {
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLUP | ((wDisable & LTUPFLAG) ? DFCS_INACTIVE : 0));
        }
        else
        {
            iStateId = (wDisable & LTUPFLAG) ? ABS_UPDISABLED : (ht == HTSCROLLUP) ? ABS_UPHOT : ABS_UPNORMAL;
            DrawThemeBackground(hTheme, hdc, SBP_ARROWBTN, iStateId, &rc, 0);
        }

        // down button
        rc.bottom = rcSB.bottom;
        rc.top = rcSB.bottom - cLength;
        if (!hTheme)
        {
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLDOWN | ((wDisable & RTDNFLAG) ? DFCS_INACTIVE : 0));
        }
        else
        {
            iStateId = (wDisable & RTDNFLAG) ? ABS_DOWNDISABLED : (ht == HTSCROLLDOWN) ? ABS_DOWNHOT : ABS_DOWNNORMAL;
            DrawThemeBackground(hTheme, hdc, SBP_ARROWBTN, iStateId, &rc, 0);
        }
    } 
    else 
    {
        // left button
        CopyRect(&rc, &rcSB);
        rc.right = rc.left + cLength;
        if (!hTheme)
        {
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLLEFT | ((wDisable & LTUPFLAG) ? DFCS_INACTIVE : 0));
        }
        else
        {
            iStateId = (wDisable & LTUPFLAG) ? ABS_LEFTDISABLED : (ht == HTSCROLLUP) ? ABS_LEFTHOT : ABS_LEFTNORMAL;
            DrawThemeBackground(hTheme, hdc, SBP_ARROWBTN, iStateId, &rc, 0);
        }

        // right button
        rc.right = rcSB.right;
        rc.left = rcSB.right - cLength;
        if (!hTheme)
        {
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLRIGHT | ((wDisable & RTDNFLAG) ? DFCS_INACTIVE : 0));
        }
        else
        {
            iStateId = (wDisable & RTDNFLAG) ? ABS_RIGHTDISABLED : (ht == HTSCROLLDOWN) ? ABS_RIGHTHOT : ABS_RIGHTNORMAL;
            DrawThemeBackground(hTheme, hdc, SBP_ARROWBTN, iStateId, &rc, 0);
        }
    }

    hbrSave = SelectBrush(hdc, hbrSave);
    DrawThumb2(hwnd, pSBCalc, hdc, hbr, fVert, wDisable, fOwnerBrush);
    SelectBrush(hdc, hbrSave);

    SetBkColor(hdc, crBk);
    SetTextColor(hdc, crText);
}

/***************************************************************************\
* zzzSetSBCaretPos
*
*
*
* History:
\***************************************************************************/

void zzzSetSBCaretPos(
    SBHWND hwndSB)
{

    if (GetFocus() == hwndSB) {
        CUxScrollBarCtl* psb = CUxScrollBarCtl::FromHwnd( hwndSB );
        if( psb )
        {
            int x = (psb->_fVert ? psb->_calc.pxLeft : psb->_calc.pxThumbTop) + SYSMET(CXEDGE);
            int y = (psb->_fVert ? psb->_calc.pxThumbTop : psb->_calc.pxLeft) + SYSMET(CYEDGE);

#ifdef _VISUAL_DELTA_
            x += CARET_BORDERWIDTH;
            y += CARET_BORDERWIDTH;
#endif _VISUAL_DELTA_

            SetCaretPos( x, y );
        }
    }
}

/***************************************************************************\
* SBCtlSetup
*
*
*
* History:
\***************************************************************************/

CUxScrollBarCtl* SBCtlSetup(
    SBHWND hwndSB)
{
    RECT rc;
    GetClientRect( hwndSB, &rc );
    CUxScrollBarCtl* psb = (CUxScrollBarCtl*)CUxScrollBar::Attach( hwndSB, TRUE, FALSE );
    if( psb )
    {
        psb->Calc2( &psb->_calc, &rc, &psb->_calc.data, psb->_fVert );
    }
    return psb;
}

/***************************************************************************\
* HotTrackSB
*
\***************************************************************************/

#ifdef COLOR_HOTTRACKING

DWORD GetTrackFlags(int ht, BOOL fDraw)
{
    if (fDraw) {
        switch(ht) {
        case HTSCROLLUP:
        case HTSCROLLUPPAGE:
            return LTUPFLAG;

        case HTSCROLLDOWN:
        case HTSCROLLDOWNPAGE:
            return RTDNFLAG;

        case HTSCROLLTHUMB:
            return LTUPFLAG | RTDNFLAG;

        default:
            return 0;
        }
    } else {
        return 0;
    }
}

void xxxHotTrackSBCtl(SBHWND hwndSB, int ht, BOOL fDraw)
{
    DWORD dwTrack = GetTrackFlags(ht, fDraw);
    HDC hdc;

    CheckLock(hwndSB);

    SBCtlSetup(hwndSB);
    hdc = _GetDCEx((HWND)hwndSB, NULL, DCX_WINDOW | DCX_USESTYLE | DCX_CACHE);
    xxxDrawSB2((HWND)hwndSB, &psb->_calc, hdc, psb->_fVert, psb->_wDisableFlags, dwTrack);
    ReleaseDC(hwnd, hdc);
}
#endif // COLOR_HOTTRACKING

BOOL SBSetParms(PSBDATA pw, LPSCROLLINFO lpsi, LPBOOL lpfScroll, LPLONG lplres)
{
    // pass the struct because we modify the struct but don't want that
    // modified version to get back to the calling app

    BOOL fChanged = FALSE;

    if (lpsi->fMask & SIF_RETURNOLDPOS)
        // save previous position
        *lplres = pw->pos;

    if (lpsi->fMask & SIF_RANGE) {
        // if the range MAX is below the range MIN -- then treat is as a
        // zero range starting at the range MIN.
        if (lpsi->nMax < lpsi->nMin)
            lpsi->nMax = lpsi->nMin;

        if ((pw->posMin != lpsi->nMin) || (pw->posMax != lpsi->nMax)) {
            pw->posMin = lpsi->nMin;
            pw->posMax = lpsi->nMax;

            if (!(lpsi->fMask & SIF_PAGE)) {
                lpsi->fMask |= SIF_PAGE;
                lpsi->nPage = pw->page;
            }

            if (!(lpsi->fMask & SIF_POS)) {
                lpsi->fMask |= SIF_POS;
                lpsi->nPos = pw->pos;
            }

            fChanged = TRUE;
        }
    }

    if (lpsi->fMask & SIF_PAGE) {
        DWORD dwMaxPage = (DWORD) abs(pw->posMax - pw->posMin) + 1;

        // Clip page to 0, posMax - posMin + 1

        if (lpsi->nPage > dwMaxPage)
            lpsi->nPage = dwMaxPage;


        if (pw->page != (int)(lpsi->nPage)) {
            pw->page = lpsi->nPage;

            if (!(lpsi->fMask & SIF_POS)) {
                lpsi->fMask |= SIF_POS;
                lpsi->nPos = pw->pos;
            }

            fChanged = TRUE;
        }
    }

    if (lpsi->fMask & SIF_POS) {
        int iMaxPos = pw->posMax - ((pw->page) ? pw->page - 1 : 0);
        // Clip pos to posMin, posMax - (page - 1).

        if (lpsi->nPos < pw->posMin)
            lpsi->nPos = pw->posMin;
        else if (lpsi->nPos > iMaxPos)
            lpsi->nPos = iMaxPos;


        if (pw->pos != lpsi->nPos) {
            pw->pos = lpsi->nPos;
            fChanged = TRUE;
        }
    }

    if (!(lpsi->fMask & SIF_RETURNOLDPOS)) {
        // Return the new position
        *lplres = pw->pos;
    }

    /*
     * This was added by JimA as Cairo merge but will conflict
     * with the documentation for SetScrollPos
     */
/*
    else if (*lplres == pw->pos)
        *lplres = 0;
*/
    if (lpsi->fMask & SIF_RANGE) {
        *lpfScroll = (pw->posMin != pw->posMax);
        if (*lpfScroll)
            goto checkPage;
    } else if (lpsi->fMask & SIF_PAGE)
checkPage:
        *lpfScroll = (pw->page <= (pw->posMax - pw->posMin));

    return fChanged;
}


/***************************************************************************\
*
*  DrawCtlThumb()
*
\***************************************************************************/
void DrawCtlThumb(SBHWND hwnd)
{
    HBRUSH  hbr, hbrSave;
    HDC     hdc = (HDC) GetWindowDC(hwnd);

    if ( hdc != NULL )
    {
        CUxScrollBarCtl* psb = SBCtlSetup(hwnd);

        if (psb)
        {
            BOOL fOwnerBrush = FALSE;

            hbr = ScrollBar_GetColorObjects(hwnd, hdc, &fOwnerBrush);
            hbrSave = SelectBrush(hdc, hbr);

            DrawThumb2(hwnd, &psb->_calc, hdc, hbr, psb->_fVert, psb->_wDisableFlags, fOwnerBrush);

            SelectBrush(hdc, hbrSave);
        }

        ReleaseDC(hwnd, hdc);
    }
}


//-------------------------------------------------------------------------
void xxxDrawThumb(HWND hwnd, PSBCALC pSBCalc, BOOL fVert)
{
    HBRUSH hbr, hbrSave;
    HDC hdc;
    UINT wDisableFlags;
    SBCALC SBCalc;

    CheckLock(hwnd);

    if (!pSBCalc) 
    {
        pSBCalc = &SBCalc;
    }

    CUxScrollBar::Calc( hwnd, pSBCalc, NULL, fVert );
    wDisableFlags = _GetWndSBDisableFlags(hwnd, fVert);

    hdc = GetWindowDC(hwnd);
    if ( hdc != NULL )
    {
        BOOL fOwnerBrush = FALSE;

        hbr = ScrollBar_GetColorObjects(hwnd, hdc, &fOwnerBrush);
        hbrSave = SelectBrush(hdc, hbr);
        DrawThumb2(hwnd, pSBCalc, hdc, hbr, fVert, wDisableFlags, fOwnerBrush);
        SelectBrush(hdc, hbrSave);
        ReleaseDC(hwnd, hdc);
    }
}


//-------------------------------------------------------------------------
UINT _GetArrowEnableFlags(HWND hwnd, BOOL fVert)
{
    SCROLLBARINFO sbi = {0};
    UINT uFlags = ESB_ENABLE_BOTH;

    sbi.cbSize = sizeof(sbi);
    if ( GetScrollBarInfo(hwnd, fVert ? OBJID_VSCROLL : OBJID_HSCROLL, &sbi) )
    {
        if ( TESTFLAG(sbi.rgstate[INDEX_SCROLLBAR_UP], (STATE_SYSTEM_UNAVAILABLE|STATE_SYSTEM_INVISIBLE)) )
        {
            uFlags |= ESB_DISABLE_UP;
        }

        if ( TESTFLAG(sbi.rgstate[INDEX_SCROLLBAR_DOWN], (STATE_SYSTEM_UNAVAILABLE|STATE_SYSTEM_INVISIBLE)) )
        {
            uFlags |= ESB_DISABLE_DOWN;
        }
    }

    return uFlags;
}


/***************************************************************************\
* _SetScrollBar
*
*
*
* History:
\***************************************************************************/

LONG _SetScrollBar(
    HWND hwnd,
    int code,
    LPSCROLLINFO lpsi,
    BOOL fRedraw)
{
    BOOL        fVert;
    PSBDATA     pw;
    PSBINFO     pSBInfo;
    BOOL        fOldScroll;
    BOOL        fScroll;
    WORD        wfScroll;
    LONG        lres;
    BOOL        fNewScroll;

    CheckLock(hwnd);
    ASSERT(IsWinEventNotifyDeferredOK());

    if (fRedraw)
        // window must be visible to redraw
        fRedraw = IsWindowVisible(hwnd);

    if (code == SB_CTL)
#ifdef FE_SB // xxxSetScrollBar()
        // scroll bar control; send the control a message
        if(GETPTI(hwnd)->TIF_flags & TIF_16BIT) {
            //
            // If the target application is 16bit apps, we don't pass win40's message.
            // This fix for Ichitaro v6.3. It eats the message. It never forwards
            // the un-processed messages to original windows procedure via
            // CallWindowProc().
            //
            // Is this from xxxSetScrollPos() ?
            if(lpsi->fMask == (SIF_POS|SIF_RETURNOLDPOS)) {
                return (int)SendMessage(hwnd, SBM_SETPOS, lpsi->nPos, fRedraw);
            // Is this from xxxSetScrollRange() ?
            } else if(lpsi->fMask == SIF_RANGE) {
                SendMessage(hwnd, SBM_SETRANGE, lpsi->nMin, lpsi->nMax);
                return TRUE;
            // Others...
            } else {
                return (LONG)SendMessage(hwnd, SBM_SETSCROLLINFO, (WPARAM) fRedraw, (LPARAM) lpsi);
            }
        } else {
            return (LONG)SendMessage(hwnd, SBM_SETSCROLLINFO, (WPARAM) fRedraw, (LPARAM) lpsi);
        }
#else
        // scroll bar control; send the control a message
        return (LONG)SendMessage(hwnd, SBM_SETSCROLLINFO, (WPARAM) fRedraw, (LPARAM) lpsi);
#endif // FE_SB

    fVert = (code != SB_HORZ);

    wfScroll = (WORD)((fVert) ? WFVSCROLL : WFHSCROLL);

    fScroll = fOldScroll = (TestWF(hwnd, wfScroll)) ? TRUE : FALSE;

    /*
     * Don't do anything if we're setting position of a nonexistent scroll bar.
     */
    if (!(lpsi->fMask & SIF_RANGE) && !fOldScroll && (CUxScrollBar::GetSBInfo( hwnd ) == NULL)) {
        RIPERR0(ERROR_NO_SCROLLBARS, RIP_VERBOSE, "");
        return 0;
    }

    pSBInfo = CUxScrollBar::GetSBInfo( hwnd );
    fNewScroll = !pSBInfo;

    if (fNewScroll) {
        CUxScrollBar* psb = CUxScrollBar::Attach( hwnd, FALSE, fRedraw );
        if( NULL == psb )
            return 0;
        
        pSBInfo = psb->GetInfo();
    }

    pw = (fVert) ? &(pSBInfo->Vert) : &(pSBInfo->Horz);

    if (!SBSetParms(pw, lpsi, &fScroll, &lres) && !fNewScroll) 
    {
        // no change -- but if REDRAW is specified and there's a scrollbar,
        // redraw the thumb
        if (fOldScroll && fRedraw)
        {
            goto redrawAfterSet;
        }

        if (lpsi->fMask & SIF_DISABLENOSCROLL)
        {
            xxxEnableWndSBArrows(hwnd, code, _GetArrowEnableFlags(hwnd, fVert));
        }

        return lres;
    }

    ClrWF(hwnd, wfScroll);

    if (fScroll)
        SetWF(hwnd, wfScroll);
    else if (!TestWF(hwnd, (WFHSCROLL | WFVSCROLL)))
    {
        // if neither scroll bar is set and both ranges are 0, then free up the
        // scroll info
        CUxScrollBar::Detach( hwnd );
    }

    if (lpsi->fMask & SIF_DISABLENOSCROLL) 
    {
        if (fOldScroll) 
        {
            SetWF(hwnd, wfScroll);
            xxxEnableWndSBArrows(hwnd, code, _GetArrowEnableFlags(hwnd, fVert));
        }
    } 
    else if (fOldScroll ^ fScroll) 
    {
        PSBTRACK pSBTrack = CUxScrollBar::GetSBTrack(hwnd);
        if (pSBTrack && (hwnd == pSBTrack->hwndTrack)) 
        {
            pSBTrack->fTrackRecalc = TRUE;
        }

        _RedrawFrame(hwnd);
        // Note: after xxx, pSBTrack may no longer be valid (but we return now)
        return lres;
    }

    if (fScroll && fRedraw && (fVert ? TestWF(hwnd, WFVPRESENT) : TestWF(hwnd, WFHPRESENT)))
    {
        PSBTRACK pSBTrack;
redrawAfterSet:
        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE,
                       hwnd,
                       (fVert ? OBJID_VSCROLL : OBJID_HSCROLL),
                       INDEX_SCROLLBAR_SELF);

        pSBTrack = CUxScrollBar::GetSBTrack(hwnd);
        // Bail out if the caller is trying to change the position of
        // a scrollbar that is in the middle of tracking.  We'll hose
        // TrackThumb() otherwise.

        if (pSBTrack && (hwnd == pSBTrack->hwndTrack) &&
                ((BOOL)(pSBTrack->fTrackVert) == fVert) &&
                (pSBTrack->pfnSB == _TrackThumb)) {
            return lres;
        }

        xxxDrawThumb(hwnd, NULL, fVert);
        // Note: after xxx, pSBTrack may no longer be valid (but we return now)
    }

    return lres;
}

//-------------------------------------------------------------------------//
LONG WINAPI ThemeSetScrollInfo( HWND hwnd, int nBar, LPCSCROLLINFO psi, BOOL bRedraw )
{
    return _SetScrollBar( hwnd, nBar, (LPSCROLLINFO)psi, bRedraw );
}


//-------------------------------------------------------------------------//
BOOL WINAPI ScrollBar_MouseMove( HWND hwnd, LPPOINT ppt, BOOL fVert )
{
    BOOL fRet = FALSE;
    CUxScrollBar* psb = CUxScrollBar::FromHwnd( hwnd );

    if (psb)
    {
        int htScroll = (ppt != NULL) ? HitTestScrollBar(hwnd, fVert, *ppt) : HTNOWHERE;

        //
        // Redraw the scroll bar if the mouse is over something different
        //
        if (htScroll != psb->GetHotComponent(fVert))
        {
            HDC hdc;

            //
            // save the hittest code of the Scrollbar element the mouse is 
            // currently over
            //
            psb->SetHotComponent(htScroll, fVert);

            hdc = GetDCEx(hwnd, NULL, DCX_USESTYLE|DCX_WINDOW|DCX_LOCKWINDOWUPDATE);
            if (hdc != NULL)
            {
                DrawScrollBar(hwnd, hdc, NULL, fVert);
                ReleaseDC(hwnd, hdc);
            }

            fRet = TRUE;
        }
    }
    
    return fRet;
}


//-------------------------------------------------------------------------//
void DrawScrollBar(HWND hwnd, HDC hdc, LPRECT prcOverrideClient, BOOL fVert)
{
    SBCALC SBCalc = {0};
    PSBCALC pSBCalc;
    PSBTRACK pSBTrack = CUxScrollBar::GetSBTrack(hwnd);

    CheckLock(hwnd);
    if (pSBTrack && (hwnd == pSBTrack->hwndTrack) && (pSBTrack->fCtlSB == FALSE)
         && (fVert == (BOOL)pSBTrack->fTrackVert)) 
    {
        pSBCalc = pSBTrack->pSBCalc;
    } 
    else 
    {
        pSBCalc = &SBCalc;
    }
    CUxScrollBar::Calc(hwnd, pSBCalc, prcOverrideClient, fVert);

    xxxDrawSB2(hwnd, pSBCalc, hdc, fVert, _GetWndSBDisableFlags(hwnd, fVert));
}

/***************************************************************************\
* SBPosFromPx
*
* Compute scroll bar position from pixel location
*
* History:
\***************************************************************************/

int SBPosFromPx(
    PSBCALC  pSBCalc,
    int px)
{
    if (px < pSBCalc->pxMin) {
        return pSBCalc->data.posMin;
    }
    if (px >= pSBCalc->pxMin + pSBCalc->cpx) {
        return (pSBCalc->data.posMax - (pSBCalc->data.page ? pSBCalc->data.page - 1 : 0));
    }
    if (pSBCalc->cpx)
        return (pSBCalc->data.posMin + MulDiv(pSBCalc->data.posMax - pSBCalc->data.posMin -
            (pSBCalc->data.page ? pSBCalc->data.page - 1 : 0),
            px - pSBCalc->pxMin, pSBCalc->cpx));
    else
        return (pSBCalc->data.posMin - 1);
}

/***************************************************************************\
* InvertScrollHilite
*
*
*
* History:
\***************************************************************************/

void InvertScrollHilite(
    HWND hwnd,
    PSBTRACK pSBTrack)
{
    HDC hdc;

    /*
     * Don't invert if the thumb is all the way at the top or bottom
     * or you will end up inverting the line between the arrow and the thumb.
     */
    if (!IsRectEmpty(&pSBTrack->rcTrack))
    {
        if (pSBTrack->fTrackRecalc) {
            RecalcTrackRect(pSBTrack);
            pSBTrack->fTrackRecalc = FALSE;
        }

        hdc = (HDC)GetWindowDC(hwnd);
        if( hdc )
        {
            HTHEME hTheme = CUxScrollBar::GetSBTheme(hwnd);
            if (!hTheme)
            {
                InvertRect(hdc, &pSBTrack->rcTrack);
            }
            else
            {
                DrawThemeBackground(hTheme, 
                                    hdc, 
                                    pSBTrack->cmdSB == SB_PAGEUP ? 
                                        (pSBTrack->fTrackVert ? SBP_LOWERTRACKVERT : SBP_LOWERTRACKHORZ) : 
                                        (pSBTrack->fTrackVert ? SBP_UPPERTRACKVERT : SBP_UPPERTRACKHORZ), 
                                    SCRBS_NORMAL, 
                                    &pSBTrack->rcTrack, 
                                    0);
            }
            ReleaseDC(hwnd, hdc);
        }
    }
}

/***************************************************************************\
* xxxDoScroll
*
* Sends scroll notification to the scroll bar owner
*
* History:
\***************************************************************************/

void xxxDoScroll(
    HWND hwnd,
    HWND hwndNotify,
    int cmd,
    int pos,
    BOOL fVert
)
{

    //
    // Send scroll notification to the scrollbar owner. If this is a control
    // the lParam is the control's handle, NULL otherwise.
    //
    SendMessage(hwndNotify, 
                (UINT)(fVert ? WM_VSCROLL : WM_HSCROLL),
                MAKELONG(cmd, pos), 
                (LPARAM)(IsScrollBarControl(hwnd) ? hwnd : NULL));
}

/***************************************************************************\
* xxxMoveThumb
*
* History:
\***************************************************************************/

void xxxMoveThumb(
    HWND hwnd,
    PSBCALC  pSBCalc,
    int px)
{
    HBRUSH        hbr, hbrSave;
    HDC           hdc;
    CUxScrollBar* psb = CUxScrollBar::FromHwnd( hwnd );
    PSBTRACK      pSBTrack = psb->GetTrack();

    CheckLock(hwnd);

    if ((pSBTrack == NULL) || (px == pSBTrack->pxOld))
        return;

pxReCalc:

    pSBTrack->posNew = SBPosFromPx(pSBCalc, px);

    /* Tentative position changed -- notify the guy. */
    if (pSBTrack->posNew != pSBTrack->posOld) {
        if (pSBTrack->hwndSBNotify != NULL) {
            psb->DoScroll(pSBTrack->hwndSBNotify, SB_THUMBTRACK, pSBTrack->posNew, pSBTrack->fTrackVert
            );

        }
        // After xxxDoScroll, re-evaluate pSBTrack
        REEVALUATE_PSBTRACK(pSBTrack, hwnd, "xxxMoveThumb(1)");
        if ((pSBTrack == NULL) || (pSBTrack->pfnSB == NULL))
            return;

        pSBTrack->posOld = pSBTrack->posNew;

        //
        // Anything can happen after the SendMessage above!
        // Make sure that the SBINFO structure contains data for the
        // window being tracked -- if not, recalculate data in SBINFO
        //
//        CheckScrollRecalc(hwnd, pSBState, pSBCalc);
        // when we yield, our range can get messed with
        // so make sure we handle this

        if (px >= pSBCalc->pxMin + pSBCalc->cpx)
        {
            px = pSBCalc->pxMin + pSBCalc->cpx;
            goto pxReCalc;
        }

    }

    hdc = GetWindowDC(hwnd);
    if ( hdc != NULL )
    {
        BOOL fOwnerBrush = FALSE;

        pSBCalc->pxThumbTop = px;
        pSBCalc->pxThumbBottom = pSBCalc->pxThumbTop + pSBCalc->cpxThumb;

        // at this point, the disable flags are always going to be 0 --
        // we're in the middle of tracking.
        hbr = ScrollBar_GetColorObjects(hwnd, hdc, &fOwnerBrush);
        hbrSave = SelectBrush(hdc, hbr);

        // After ScrollBar_GetColorObjects, re-evaluate pSBTrack
        REEVALUATE_PSBTRACK(pSBTrack, hwnd, "xxxMoveThumb(2)");
        if (pSBTrack == NULL) 
        {
            RIPMSG1(RIP_ERROR, "Did we use to leak hdc %#p?", hdc) ;
            ReleaseDC(hwnd, hdc);
            return;
        }
        DrawThumb2(hwnd, pSBCalc, hdc, hbr, pSBTrack->fTrackVert, 0, fOwnerBrush);
        SelectBrush(hdc, hbrSave);
        ReleaseDC(hwnd, hdc);
    }

    pSBTrack->pxOld = px;
}

/***************************************************************************\
* zzzDrawInvertScrollArea
*
*
*
* History:
\***************************************************************************/

void zzzDrawInvertScrollArea(
    HWND hwnd,
    PSBTRACK pSBTrack,
    BOOL fHit,
    UINT cmd)
{
    HDC hdc;
    RECT rcTemp;
    int cx, cy;
    HTHEME hTheme;

    if ((cmd != SB_LINEUP) && (cmd != SB_LINEDOWN)) {
        // not hitting on arrow -- just invert the area and return
        InvertScrollHilite(hwnd, pSBTrack);

        if (cmd == SB_PAGEUP)
        {
            if (fHit)
                SetWF(hwnd, WFPAGEUPBUTTONDOWN);
            else
                ClrWF(hwnd, WFPAGEUPBUTTONDOWN);
        }
        else
        {
            if (fHit)
                SetWF(hwnd, WFPAGEDNBUTTONDOWN);
            else
                ClrWF(hwnd, WFPAGEDNBUTTONDOWN);
        }

        NotifyWinEvent(EVENT_OBJECT_STATECHANGE,
                       hwnd,
                       (pSBTrack->fCtlSB ? OBJID_CLIENT : (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
                       ((cmd == SB_PAGEUP) ? INDEX_SCROLLBAR_UPPAGE : INDEX_SCROLLBAR_DOWNPAGE));
        // Note: after zzz, pSBTrack may no longer be valid (but we return now)
        return;
    }

    if (pSBTrack->fTrackRecalc) {
        RecalcTrackRect(pSBTrack);
        pSBTrack->fTrackRecalc = FALSE;
    }

    CopyRect(&rcTemp, &pSBTrack->rcTrack);

    hdc = GetWindowDC(hwnd);
    if( hdc != NULL )
    {
        if (pSBTrack->fTrackVert) {
            cx = SYSMET(CXVSCROLL);
            cy = SYSMET(CYVSCROLL);
        } else {
            cx = SYSMET(CXHSCROLL);
            cy = SYSMET(CYHSCROLL);
        }

        hTheme = CUxScrollBar::GetSBTheme(hwnd);
        if (!hTheme)
        {
            DrawFrameControl(hdc, &rcTemp, DFC_SCROLL,
                ((pSBTrack->fTrackVert) ? DFCS_SCROLLVERT : DFCS_SCROLLHORZ) |
                ((fHit) ? DFCS_PUSHED | DFCS_FLAT : 0) |
                ((cmd == SB_LINEUP) ? DFCS_SCROLLMIN : DFCS_SCROLLMAX));
        }
        else
        {
            INT iStateId;

            // Determine the pressed state of the button
            iStateId = fHit ? SCRBS_PRESSED : SCRBS_NORMAL;

            // Determine which kind of button it is.
            // NOTE: (phellyar) this is dependant on the order of
            //                  the ARROWBTNSTATE enum
            if (pSBTrack->fTrackVert)
            {
                if (cmd == SB_LINEUP)
                {
                    // Up button states are the first four entries
                    // in the enum
                    iStateId += 0;
                }
                else
                {
                    // Down button states are the second four entries
                    // in the enum
                    iStateId += 4;
                }
            }
            else
            {
                if (cmd == SB_LINEUP)
                {
                    // Left button states are the third four entries
                    // in the enum
                    iStateId += 8;
                }
                else
                {
                    // Right button states are the last four entries
                    // in the enum
                    iStateId += 12;
                }
            }
            DrawThemeBackground(hTheme, hdc, SBP_ARROWBTN, iStateId, &rcTemp, 0);
        }

        ReleaseDC(hwnd, hdc);
    }

    if (cmd == SB_LINEUP) {
        if (fHit)
            SetWF(hwnd, WFLINEUPBUTTONDOWN);
        else
            ClrWF(hwnd, WFLINEUPBUTTONDOWN);
    } else {
        if (fHit)
            SetWF(hwnd, WFLINEDNBUTTONDOWN);
        else
            ClrWF(hwnd, WFLINEDNBUTTONDOWN);
    }

    NotifyWinEvent(EVENT_OBJECT_STATECHANGE,
                   hwnd,
                   (pSBTrack->fCtlSB ? OBJID_CLIENT : (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
                   (cmd == SB_LINEUP ? INDEX_SCROLLBAR_UP : INDEX_SCROLLBAR_DOWN));
    // Note: after zzz, pSBTrack may no longer be valid (but we return now)
}

/***************************************************************************\
* xxxEndScroll
*
*
*
* History:
\***************************************************************************/

void xxxEndScroll(
    HWND hwnd,
    BOOL fCancel)
{
    UINT oldcmd;
    PSBTRACK pSBTrack;
    CheckLock(hwnd);
    ASSERT(!IsWinEventNotifyDeferred());

    CUxScrollBar* psb = CUxScrollBar::FromHwnd( hwnd );
    ASSERT(psb != NULL);
    pSBTrack = psb->GetTrack();

    if (pSBTrack && GetCapture() == hwnd && pSBTrack->pfnSB != NULL) {

        oldcmd = pSBTrack->cmdSB;
        pSBTrack->cmdSB = 0;
        ReleaseCapture();

        // After ReleaseCapture, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);

        if (pSBTrack->pfnSB == _TrackThumb) {

            if (fCancel) {
                pSBTrack->posOld = pSBTrack->pSBCalc->data.pos;
            }

            /*
             * DoScroll does thread locking on these two pwnds -
             * this is ok since they are not used after this
             * call.
             */
            if (pSBTrack->hwndSBNotify != NULL) {
                psb->DoScroll( pSBTrack->hwndSBNotify,
                               SB_THUMBPOSITION, pSBTrack->posOld, pSBTrack->fTrackVert
                );
                // After xxxDoScroll, revalidate pSBTrack
                RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
            }

            if (pSBTrack->fCtlSB) {
                DrawCtlThumb((SBHWND) hwnd);
            } else {
                xxxDrawThumb(hwnd, pSBTrack->pSBCalc, pSBTrack->fTrackVert);
                // Note: after xxx, pSBTrack may no longer be valid
            }

        } else if (pSBTrack->pfnSB == _TrackBox) {
            DWORD lParam;
            POINT ptMsg;
            RECT  rcWindow;

            if (pSBTrack->hTimerSB != 0) {
                _KillSystemTimer(hwnd, IDSYS_SCROLL);
                pSBTrack->hTimerSB = 0;
            }
            lParam = GetMessagePos();
            GetWindowRect( hwnd, &rcWindow );
#ifdef USE_MIRRORING
            if (TestWF(hwnd, WEFLAYOUTRTL)) {
                ptMsg.x = rcWindow.right - GET_X_LPARAM(lParam);
            } else
#endif
            {
                ptMsg.x = GET_X_LPARAM(lParam) - rcWindow.left;
            }
            ptMsg.y = GET_Y_LPARAM(lParam) - rcWindow.top;
            if (PtInRect(&pSBTrack->rcTrack, ptMsg)) {
                zzzDrawInvertScrollArea(hwnd, pSBTrack, FALSE, oldcmd);
                // Note: after zzz, pSBTrack may no longer be valid
            }
        }

        /*
         * Always send SB_ENDSCROLL message.
         *
         * DoScroll does thread locking on these two pwnds -
         * this is ok since they are not used after this
         * call.
         */

        // After xxxDrawThumb or zzzDrawInvertScrollArea, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);

        if (pSBTrack->hwndSBNotify != NULL) {
            psb->DoScroll( pSBTrack->hwndSBNotify,
                           SB_ENDSCROLL, 0, pSBTrack->fTrackVert);
            // After xxxDoScroll, revalidate pSBTrack
            RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
        }

        ClrWF(hwnd, WFSCROLLBUTTONDOWN);
        ClrWF(hwnd, WFVERTSCROLLTRACK);

        NotifyWinEvent(EVENT_SYSTEM_SCROLLINGEND,
                       hwnd,
                       (pSBTrack->fCtlSB ? OBJID_CLIENT : (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
                       INDEXID_CONTAINER);
        // After NotifyWinEvent, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);

        // If this is a Scroll Bar Control, turn the caret back on.
        if (pSBTrack->hwndSB != NULL)
        {
            ShowCaret(pSBTrack->hwndSB);
            // After zzz, revalidate pSBTrack
            RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
        }

        pSBTrack->pfnSB = NULL;

        /*
         * Unlock structure members so they are no longer holding down windows.
         */
        
        Unlock(&pSBTrack->hwndSB);
        Unlock(&pSBTrack->hwndSBNotify);
        Unlock(&pSBTrack->hwndTrack);
        CUxScrollBar::ClearSBTrack( hwnd );
    }
}


//-------------------------------------------------------------------------//
VOID CALLBACK xxxContScroll(HWND hwnd, UINT message, UINT_PTR ID, DWORD dwTime)
{
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(ID);
    UNREFERENCED_PARAMETER(dwTime);

    CUxScrollBar* psb = CUxScrollBar::FromHwnd( hwnd );

    if ( psb != NULL )
    {
        PSBTRACK pSBTrack = psb->GetTrack();

        if ( pSBTrack != NULL )
        {
            LONG pt;
            RECT rcWindow;

            CheckLock(hwnd);

            pt = GetMessagePos();
            GetWindowRect( hwnd, &rcWindow );

            if (TestWF(hwnd, WEFLAYOUTRTL)) 
            {
                pt = MAKELONG(rcWindow.right - GET_X_LPARAM(pt), GET_Y_LPARAM(pt) - rcWindow.top);
            } 
            else
            {
                pt = MAKELONG( GET_X_LPARAM(pt) - rcWindow.left, GET_Y_LPARAM(pt) - rcWindow.top);
            }

            _TrackBox(hwnd, WM_NULL, 0, pt, NULL);

            // After _TrackBox, revalidate pSBTrack
            RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);

            if (pSBTrack->fHitOld) 
            {
                pSBTrack->hTimerSB = _SetSystemTimer(hwnd, IDSYS_SCROLL, DTTIME/8, xxxContScroll);

                // DoScroll does thread locking on these two pwnds -
                // this is ok since they are not used after this call.
                if (pSBTrack->hwndSBNotify != NULL) 
                {
                    psb->DoScroll(pSBTrack->hwndSBNotify, pSBTrack->cmdSB, 0, pSBTrack->fTrackVert);
                    // Note: after xxx, pSBTrack may no longer be valid (but we return now)
                }
            }
        }
    }
}


//-------------------------------------------------------------------------//
void CALLBACK _TrackBox(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, PSBCALC pSBCalc)
{
    CUxScrollBar* psb = CUxScrollBar::FromHwnd(hwnd);

    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(pSBCalc);

    CheckLock(hwnd);
    ASSERT(IsWinEventNotifyDeferredOK());

    if ( psb )
    {
        PSBTRACK pSBTrack = psb->GetTrack();

        if ( pSBTrack )
        {
            BOOL  fHit;
            POINT ptHit;
            int   cmsTimer;

            if ((uMsg != WM_NULL) && (HIBYTE(uMsg) != HIBYTE(WM_MOUSEFIRST)))
            {
                return;
            }

            if (pSBTrack->fTrackRecalc) 
            {
                RecalcTrackRect(pSBTrack);
                pSBTrack->fTrackRecalc = FALSE;
            }

            ptHit.x = GET_X_LPARAM(lParam);
            ptHit.y = GET_Y_LPARAM(lParam);
            fHit = PtInRect(&pSBTrack->rcTrack, ptHit);

            if (fHit != (BOOL)pSBTrack->fHitOld) 
            {
                zzzDrawInvertScrollArea(hwnd, pSBTrack, fHit, pSBTrack->cmdSB);
                // After zzz, pSBTrack may no longer be valid
                RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
            }

            cmsTimer = DTTIME/8;

            switch (uMsg) 
            {
            case WM_LBUTTONUP:
                xxxEndScroll(hwnd, FALSE);
                // Note: after xxx, pSBTrack may no longer be valid
                break;

            case WM_LBUTTONDOWN:
                pSBTrack->hTimerSB = 0;
                cmsTimer = DTTIME;

                //
                // FALL THRU
                //

            case WM_MOUSEMOVE:
                if (fHit && fHit != (BOOL)pSBTrack->fHitOld) 
                {
                    //
                    // We moved back into the normal rectangle: reset timer
                    //
                    pSBTrack->hTimerSB = _SetSystemTimer(hwnd, IDSYS_SCROLL,
                            cmsTimer, xxxContScroll);

                    //
                    // DoScroll does thread locking on these two pwnds -
                    // this is ok since they are not used after this
                    // call.
                    //
                    if (pSBTrack->hwndSBNotify != NULL) 
                    {
                        psb->DoScroll( pSBTrack->hwndSBNotify, pSBTrack->cmdSB, 
                                       0, pSBTrack->fTrackVert);
                        // Note: after xxx, pSBTrack may no longer be valid
                    }
                }

                break;
            }

            // After xxxDoScroll or xxxEndScroll, revalidate pSBTrack
            RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
            pSBTrack->fHitOld = fHit;
        }
    }
}


/***************************************************************************\
* _TrackThumb
*
*
*
* History:
\***************************************************************************/

void CALLBACK _TrackThumb(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    PSBCALC pSBCalc)
{
    int px;
    CUxScrollBar* psb = CUxScrollBar::FromHwnd( hwnd );
    ASSERT(psb);
    PSBTRACK pSBTrack = psb->GetTrack();
    POINT pt;

    UNREFERENCED_PARAMETER(wParam);

    CheckLock(hwnd);

    if (HIBYTE(message) != HIBYTE(WM_MOUSEFIRST))
        return;

    if (pSBTrack == NULL)
        return;

    // Make sure that the SBINFO structure contains data for the
    // window being tracked -- if not, recalculate data in SBINFO
//    CheckScrollRecalc(hwnd, pSBState, pSBCalc);
    if (pSBTrack->fTrackRecalc) {
        RecalcTrackRect(pSBTrack);
        pSBTrack->fTrackRecalc = FALSE;
    }


    pt.y = GET_Y_LPARAM(lParam);
    pt.x = GET_X_LPARAM(lParam);
    if (!PtInRect(&pSBTrack->rcTrack, pt))
        px = pSBCalc->pxStart;
    else {
        px = (pSBTrack->fTrackVert ? pt.y : pt.x) + pSBTrack->dpxThumb;
        if (px < pSBCalc->pxMin)
            px = pSBCalc->pxMin;
        else if (px >= pSBCalc->pxMin + pSBCalc->cpx)
            px = pSBCalc->pxMin + pSBCalc->cpx;
    }

    xxxMoveThumb(hwnd, pSBCalc, px);

    /*
     * We won't get the WM_LBUTTONUP message if we got here through
     * the scroll menu, so test the button state directly.
     */
    if (message == WM_LBUTTONUP || GetKeyState(VK_LBUTTON) >= 0) {
        xxxEndScroll(hwnd, FALSE);
    }

}

/***************************************************************************\
* _ClientToWindow
* History:
\***************************************************************************/
BOOL _ClientToWindow( HWND hwnd, LPPOINT ppt )
{
    WINDOWINFO wi;
    wi.cbSize = sizeof(wi);
    if( GetWindowInfo( hwnd, &wi ) )
    {
        ppt->x += (wi.rcClient.left - wi.rcWindow.left);
        ppt->y += (wi.rcClient.top -  wi.rcWindow.top);
        return TRUE;
    }
    return FALSE;
}

/***************************************************************************\
* xxxSBTrackLoop
*
*
*
* History:
\***************************************************************************/

void xxxSBTrackLoop(
    HWND hwnd,
    LPARAM lParam,
    PSBCALC pSBCalc)
{
    MSG msg;
    UINT cmd;
    VOID (*pfnSB)(HWND, UINT, WPARAM, LPARAM, PSBCALC);
    CUxScrollBar* psb = CUxScrollBar::FromHwnd( hwnd );
    PSBTRACK pSBTrack = psb->GetSBTrack(hwnd);

    CheckLock(hwnd);
    ASSERT(IsWinEventNotifyDeferredOK());


    if (pSBTrack == NULL)
        // mode cancelled -- exit track loop
        return;
    
    pfnSB = pSBTrack->pfnSB;
    if (pfnSB == NULL)
        // mode cancelled -- exit track loop
        return;

    if (pSBTrack->fTrackVert)
        SetWF(hwnd, WFVERTSCROLLTRACK);

    NotifyWinEvent(EVENT_SYSTEM_SCROLLINGSTART,
                   hwnd,
                   (pSBTrack->fCtlSB ? OBJID_CLIENT : (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
                   INDEXID_CONTAINER);
    // Note: after xxx, pSBTrack may no longer be valid

    (*pfnSB)(hwnd, WM_LBUTTONDOWN, 0, lParam, pSBCalc);
    // Note: after xxx, pSBTrack may no longer be valid

    while (GetCapture() == hwnd) {
        if (!GetMessage(&msg, NULL, 0, 0)) {
            // Note: after xxx, pSBTrack may no longer be valid
            break;
        }

        if (!CallMsgFilter(&msg, MSGF_SCROLLBAR))
        {
            BOOL bTrackMsg = FALSE;
            cmd = msg.message;
            lParam = msg.lParam;

            if (msg.hwnd == HWq(hwnd))
            {
                if( cmd >= WM_MOUSEFIRST && cmd <= WM_MOUSELAST )
                {
                    if( !psb->IsCtl() )
                    {
                        POINT pt;
                        pt.x = GET_X_LPARAM(msg.lParam);
                        pt.y = GET_Y_LPARAM(msg.lParam);
                        _ClientToWindow( hwnd, &pt );
                        lParam = MAKELPARAM(pt.x, pt.y);
                    }
                    bTrackMsg = TRUE;
                }
                else if( cmd >= WM_KEYFIRST && cmd <= WM_KEYLAST )
                {
                    cmd = _SysToChar(cmd, msg.lParam);
                    bTrackMsg = TRUE;
                }
            }

            if( bTrackMsg )
            {
                // After NotifyWinEvent, pfnSB, TranslateMessage or
                // DispatchMessage, re-evaluate pSBTrack.
                REEVALUATE_PSBTRACK(pSBTrack, hwnd, "xxxTrackLoop");
                if ((pSBTrack == NULL) || (NULL == (pfnSB = pSBTrack->pfnSB)))
                    // mode cancelled -- exit track loop
                    return;

                (*pfnSB)(hwnd, cmd, msg.wParam, lParam, pSBCalc);
            }
            else
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
}


/***************************************************************************\
* _SBTrackInit
*
* History:
\***************************************************************************/

void _SBTrackInit(
    HWND hwnd,
    LPARAM lParam,
    int curArea,
    UINT uType)
{
    int px;
    LPINT pwX;
    LPINT pwY;
    UINT wDisable;     // Scroll bar disable flags;
    SBCALC SBCalc = {0};
    PSBCALC pSBCalc;
    RECT rcSB;
    PSBTRACK pSBTrack;

    CheckLock(hwnd);

#ifdef PORTPORT // unneccessary dbgchk w/ port
    if (CUxScrollBar::GetSBTrack(hwnd)) {
        RIPMSG1(RIP_WARNING, "_SBTrackInit: CUxScrollBar::GetSBTrack(hwnd) == %#p",
                CUxScrollBar::GetSBTrack(hwnd));
        return;
    }
#endif PORTPORT

    CUxScrollBar*    psb = CUxScrollBar::Attach( hwnd, !curArea, TRUE );

    if (!psb)
    {
        return;
    }
     
    CUxScrollBarCtl* psbCtl = psb->IsCtl() ? (CUxScrollBarCtl*)psb : NULL;

    pSBTrack = psb->GetTrack();
    if (pSBTrack == NULL)
        return;

    pSBTrack->hTimerSB = 0;
    pSBTrack->fHitOld = FALSE;

    pSBTrack->pfnSB = _TrackBox;

    pSBTrack->hwndTrack = NULL;
    pSBTrack->hwndSB = NULL;
    pSBTrack->hwndSBNotify = NULL;
    Lock(&pSBTrack->hwndTrack, hwnd); // pSBTrack->hwndTrack = hwnd;  

    pSBTrack->fCtlSB = (!curArea);
    if (pSBTrack->fCtlSB)
    {
        /*
         * This is a scroll bar control.
         */
        ASSERT(psbCtl != NULL);

        pSBTrack->hwndSB = hwnd; //Lock(&pSBTrack->hwndSB, hwnd);
        pSBTrack->fTrackVert = psbCtl->_fVert;
        Lock(&pSBTrack->hwndSBNotify, GetParent(hwnd)); // pSBTrack->hwndSBNotify = GetParent( hwnd );
        wDisable = psbCtl->_wDisableFlags;
        pSBCalc = &psbCtl->_calc;
        pSBTrack->nBar = SB_CTL;
    } else {

        /*
         * This is a scroll bar that is part of the window frame.
         */
        RECT rcWindow;
        GetWindowRect( hwnd, &rcWindow );
        int x = GET_X_LPARAM(lParam);
        int y = GET_Y_LPARAM(lParam);

#ifdef USE_MIRRORING
        //
        // Mirror the window coord of the scroll bar,
        // if it is a mirrored one
        //
        if (TestWF(hwnd,WEFLAYOUTRTL)) {
            lParam = MAKELONG(
                    rcWindow.right - x,
                    y - rcWindow.top);
        }
        else {
#endif
        lParam = MAKELONG( x - rcWindow.left, y - rcWindow.top);

#ifdef USE_MIRRORING
        }
#endif
        Lock(&pSBTrack->hwndSBNotify, hwnd); // pSBTrack->hwndSBNotify = hwnd; //
        Lock(&pSBTrack->hwndSB, NULL);       // pSBTrack->hwndSB = NULL;
        
        pSBTrack->fTrackVert = (curArea - HTHSCROLL);
        wDisable = _GetWndSBDisableFlags(hwnd, pSBTrack->fTrackVert);
        pSBCalc = &SBCalc;
        pSBTrack->nBar = (curArea - HTHSCROLL) ? SB_VERT : SB_HORZ;
    }

    pSBTrack->pSBCalc = pSBCalc;
    /*
     *  Check if the whole scroll bar is disabled
     */
    if((wDisable & SB_DISABLE_MASK) == SB_DISABLE_MASK) {
        CUxScrollBar::Detach( hwnd );
        return;  // It is a disabled scroll bar; So, do not respond.
    }

    if (!pSBTrack->fCtlSB) {
        psb->FreshenSBData( pSBTrack->nBar, FALSE );
        CUxScrollBar::Calc(hwnd, pSBCalc, NULL, pSBTrack->fTrackVert);
    }

    pwX = (LPINT)&rcSB;
    pwY = pwX + 1;
    if (!pSBTrack->fTrackVert)
        pwX = pwY--;

    px = (pSBTrack->fTrackVert ? GET_Y_LPARAM(lParam) : GET_X_LPARAM(lParam));

    *(pwX + 0) = pSBCalc->pxLeft;
    *(pwY + 0) = pSBCalc->pxTop;
    *(pwX + 2) = pSBCalc->pxRight;
    *(pwY + 2) = pSBCalc->pxBottom;
    pSBTrack->cmdSB = (UINT)-1;
    if (px < pSBCalc->pxUpArrow) {

        /*
         *  The click occurred on Left/Up arrow; Check if it is disabled
         */
        if(wDisable & LTUPFLAG) {
            if(pSBTrack->fCtlSB) {   // If this is a scroll bar control,
                ShowCaret(pSBTrack->hwndSB);  // show the caret before returning;
                // After ShowCaret, revalidate pSBTrack
                RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
            }
            CUxScrollBar::Detach( hwnd );
            return;         // Yes! disabled. Do not respond.
        }

        // LINEUP -- make rcSB the Up Arrow's Rectangle
        pSBTrack->cmdSB = SB_LINEUP;
        *(pwY + 2) = pSBCalc->pxUpArrow;
    } else if (px >= pSBCalc->pxDownArrow) {

        /*
         * The click occurred on Right/Down arrow; Check if it is disabled
         */
        if (wDisable & RTDNFLAG) {
            if (pSBTrack->fCtlSB) {    // If this is a scroll bar control,
                ShowCaret(pSBTrack->hwndSB);  // show the caret before returning;
                // After ShowCaret, revalidate pSBTrack
                RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
            }

            CUxScrollBar::Detach( hwnd );
            return;// Yes! disabled. Do not respond.
        }

        // LINEDOWN -- make rcSB the Down Arrow's Rectangle
        pSBTrack->cmdSB = SB_LINEDOWN;
        *(pwY + 0) = pSBCalc->pxDownArrow;
    } else if (px < pSBCalc->pxThumbTop) {
        // PAGEUP -- make rcSB the rectangle between Up Arrow and Thumb
        pSBTrack->cmdSB = SB_PAGEUP;
        *(pwY + 0) = pSBCalc->pxUpArrow;
        *(pwY + 2) = pSBCalc->pxThumbTop;
    } else if (px < pSBCalc->pxThumbBottom) {

DoThumbPos:
        /*
         * Elevator isn't there if there's no room.
         */
        if (pSBCalc->pxDownArrow - pSBCalc->pxUpArrow <= pSBCalc->cpxThumb) {
            CUxScrollBar::Detach( hwnd );
            return;
        }
        // THUMBPOSITION -- we're tracking with the thumb
        pSBTrack->cmdSB = SB_THUMBPOSITION;
        CalcTrackDragRect(pSBTrack);

        pSBTrack->pfnSB = _TrackThumb;
        pSBTrack->pxOld = pSBCalc->pxStart = pSBCalc->pxThumbTop;
        pSBTrack->posNew = pSBTrack->posOld = pSBCalc->data.pos;
        pSBTrack->dpxThumb = pSBCalc->pxStart - px;

        SetCapture( hwnd ); //xxxCapture(PtiCurrent(), hwnd, WINDOW_CAPTURE);
        
        // After xxxCapture, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);

        /*
         * DoScroll does thread locking on these two pwnds -
         * this is ok since they are not used after this
         * call.
         */
        if (pSBTrack->hwndSBNotify != NULL) {
            psb->DoScroll( pSBTrack->hwndSBNotify, SB_THUMBTRACK, 
                           pSBTrack->posOld, pSBTrack->fTrackVert
            );
            // Note: after xxx, pSBTrack may no longer be valid
        }
    } else if (px < pSBCalc->pxDownArrow) {
        // PAGEDOWN -- make rcSB the rectangle between Thumb and Down Arrow
        pSBTrack->cmdSB = SB_PAGEDOWN;
        *(pwY + 0) = pSBCalc->pxThumbBottom;
        *(pwY + 2) = pSBCalc->pxDownArrow;
    }

    /*
     * If the shift key is down, we'll position the thumb directly so it's
     * centered on the click point.
     */
    if ((uType == SCROLL_DIRECT && pSBTrack->cmdSB != SB_LINEUP && pSBTrack->cmdSB != SB_LINEDOWN) ||
            (uType == SCROLL_MENU)) {
        if (pSBTrack->cmdSB != SB_THUMBPOSITION) {
            goto DoThumbPos;
        }
        pSBTrack->dpxThumb = -(pSBCalc->cpxThumb / 2);
    }

    SetCapture( hwnd ); // xxxCapture(PtiCurrent(), hwnd, WINDOW_CAPTURE);
    // After xxxCapture, revalidate pSBTrack
    RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);

    if (pSBTrack->cmdSB != SB_THUMBPOSITION) {
        CopyRect(&pSBTrack->rcTrack, &rcSB);
    }

    xxxSBTrackLoop(hwnd, lParam, pSBCalc);

    // After xxx, re-evaluate pSBTrack
    REEVALUATE_PSBTRACK(pSBTrack, hwnd, "xxxTrackLoop");
    if (pSBTrack) 
    {
        CUxScrollBar::ClearSBTrack( hwnd );
    }
}

/***************************************************************************\
* HandleScrollCmd
*
* History: added to support and encap SB tracking initialization originating
*          from WM_SYSCOMMAND::SC_VSCROLL/SC_HSCROLL [scotthan]
\***************************************************************************/
void WINAPI HandleScrollCmd( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
    UINT uArea = (UINT)(wParam & 0x0F);
    _SBTrackInit( hwnd, lParam, uArea, 
                    (GetKeyState(VK_SHIFT) < 0) ? SCROLL_DIRECT : SCROLL_NORMAL);
}


//-------------------------------------------------------------------------
HMENU ScrollBar_GetMenu(HWND hwnd, BOOL fVert)
{
    static HMODULE hModUser = NULL;
    HMENU hMenu = NULL;

    if ( !hModUser )
    {
        hModUser = GetModuleHandle(TEXT("user32"));
    }

#define ID_HSCROLLMENU  0x40
#define ID_VSCROLLMENU  0x50

    if ( hModUser )
    {
        hMenu = LoadMenu(hModUser, MAKEINTRESOURCE((fVert ? ID_VSCROLLMENU : ID_HSCROLLMENU)));
        if ( hMenu ) 
        {
            hMenu = GetSubMenu(hMenu, 0);
        }
    }

    return hMenu;
}


//-------------------------------------------------------------------------
VOID ScrollBar_Menu(HWND hwndNotify, HWND hwnd, LPARAM lParam, BOOL fVert)
{
    CUxScrollBar*    psb    = CUxScrollBar::FromHwnd( hwnd );
    CUxScrollBarCtl* psbCtl = CUxScrollBarCtl::FromHwnd( hwnd );
    BOOL fCtl = (psbCtl != NULL);

    if ( psb || psbCtl )
    {
        UINT  wDisable;
        RECT  rcWindow;
        POINT pt;

        GetWindowRect(hwnd, &rcWindow);

        POINTSTOPOINT(pt, lParam);
        if ( TestWF(hwnd, WEFLAYOUTRTL) && !fVert ) 
        {
            MIRROR_POINT(rcWindow, pt);
        }
        pt.x -= rcWindow.left;
        pt.y -= rcWindow.top;

        if ( fCtl ) 
        {
            wDisable = psbCtl->_wDisableFlags;
        } 
        else 
        {
            wDisable = _GetWndSBDisableFlags(hwndNotify, fVert);
        }

        // Make sure the scrollbar isn't disabled.
        if ( (wDisable & SB_DISABLE_MASK) != SB_DISABLE_MASK) 
        {
            HMENU hMenu = ScrollBar_GetMenu(hwndNotify, fVert);

            // Put up a menu and scroll accordingly.
            if (hMenu != NULL) 
            {
                int iCmd;

                iCmd = TrackPopupMenuEx(hMenu,
                            TPM_RIGHTBUTTON | TPM_RETURNCMD | TPM_NONOTIFY,
                            GET_X_LPARAM(lParam),
                            GET_Y_LPARAM(lParam),
                            hwndNotify,
                            NULL);

                DestroyMenu(hMenu);

                if (iCmd) 
                {
                    if ((iCmd & 0x00FF) == SB_THUMBPOSITION) 
                    {
                        if ( fCtl ) 
                        {
                            _SBTrackInit(hwnd, MAKELPARAM(pt.x, pt.y), 0, SCROLL_MENU);
                        }   
                        else 
                        {
                            _SBTrackInit(hwndNotify, lParam, fVert ? HTVSCROLL : HTHSCROLL, SCROLL_MENU);
                        }
                    } 
                    else 
                    {
                        xxxDoScroll(hwnd, hwndNotify, (iCmd & 0x00FF), 0, fVert);
                        xxxDoScroll(hwnd, hwndNotify, SB_ENDSCROLL, 0, fVert);
                    }
                }
            }
        }
    }
}


//-------------------------------------------------------------------------
LRESULT CUxScrollBarCtl::WndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    LONG         l;
    LONG         lres = 0;
    int          cx, cy;
    UINT         cmd;
    UINT         uSide;
    HDC          hdc;
    RECT         rc;
    POINT        pt;
    BOOL         fSizeReal;
    HBRUSH       hbrSave;
    BOOL         fSize;
    PAINTSTRUCT  ps;
    DWORD        dwStyle;
    SCROLLINFO   si;
    LPSCROLLINFO lpsi = &si;
    BOOL         fRedraw = FALSE;
    BOOL         fScroll;
    
    CUxScrollBarCtl* psb = CUxScrollBarCtl::FromHwnd( hwnd );
    if (!psb && uMsg != WM_NCCREATE)
    {
        goto CallDWP;
    }

    CheckLock(hwnd);
    ASSERT(IsWinEventNotifyDeferredOK());

    VALIDATECLASSANDSIZE(((HWND)hwnd), uMsg, wParam, lParam, FNID_SCROLLBAR, WM_CREATE);

    dwStyle = GetWindowStyle(hwnd);
    fSize = (((LOBYTE(dwStyle)) & (SBS_SIZEBOX | SBS_SIZEGRIP)) != 0);

    switch (uMsg) 
    {
    
    case WM_NCCREATE:
        
        if( NULL == psb )
        {
            psb = (CUxScrollBarCtl*)CUxScrollBar::Attach( hwnd, TRUE, FALSE );
        }

        goto CallDWP;
        
    case WM_NCDESTROY:
        CUxScrollBar::Detach(hwnd);
        psb = NULL;
        goto CallDWP;

    case WM_CREATE:
        /*
         * Guard against lParam being NULL since the thunk allows it [51986]
         */

        if (lParam) 
        {
            rc.right = (rc.left = ((LPCREATESTRUCT)lParam)->x) +
                    ((LPCREATESTRUCT)lParam)->cx;
            rc.bottom = (rc.top = ((LPCREATESTRUCT)lParam)->y) +
                    ((LPCREATESTRUCT)lParam)->cy;
            // This is because we can't just rev CardFile -- we should fix the
            // problem here in case anyone else happened to have some EXTRA
            // scroll styles on their scroll bar controls (jeffbog 03/21/94)
            if (!TestWF((HWND)hwnd, WFWIN40COMPAT))
                dwStyle &= ~(WS_HSCROLL | WS_VSCROLL);

            if (!fSize) 
            {
                l = PtrToLong(((LPCREATESTRUCT)lParam)->lpCreateParams);
                
                psb->_calc.data.pos = psb->_calc.data.posMin = LOWORD(l);
                psb->_calc.data.posMax = HIWORD(l);
                psb->_fVert = ((LOBYTE(dwStyle) & SBS_VERT) != 0);
                psb->_calc.data.page = 0;
            }

            if (dwStyle & WS_DISABLED)
                psb->_wDisableFlags = SB_DISABLE_MASK;

            if (LOBYTE(dwStyle) & (SBS_TOPALIGN | SBS_BOTTOMALIGN)) {
                if (fSize) {
                    if (LOBYTE(dwStyle) & SBS_SIZEBOXBOTTOMRIGHTALIGN) {
                        rc.left = rc.right - SYSMET(CXVSCROLL);
                        rc.top = rc.bottom - SYSMET(CYHSCROLL);
                    }

                    rc.right = rc.left + SYSMET(CXVSCROLL);
                    rc.bottom = rc.top + SYSMET(CYHSCROLL);
                } else {
                    if (LOBYTE(dwStyle) & SBS_VERT) {
                        if (LOBYTE(dwStyle) & SBS_LEFTALIGN)
                            rc.right = rc.left + SYSMET(CXVSCROLL);
                        else
                            rc.left = rc.right - SYSMET(CXVSCROLL);
                    } else {
                        if (LOBYTE(dwStyle) & SBS_TOPALIGN)
                            rc.bottom = rc.top + SYSMET(CYHSCROLL);
                        else
                            rc.top = rc.bottom - SYSMET(CYHSCROLL);
                    }
                }

                MoveWindow((HWND)hwnd, rc.left, rc.top, rc.right - rc.left,
                         rc.bottom - rc.top, FALSE);
            }
        } /* if */

        else {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING,
                    "UxScrollBarCtlWndProc - NULL lParam for WM_CREATE\n") ;
        } /* else */

        break;

    case WM_SIZE:
        if (GetFocus() != (HWND)hwnd)
            break;

        // scroll bar has the focus -- recalc it's thumb caret size
        // no need to DeferWinEventNotify() - see CreateCaret below.
        DestroyCaret();

            //   |             |
            //   |  FALL THRU  |
            //   V             V

    case WM_SETFOCUS:
    {
        // REVIEW (phellyar) Do we want themed scroll bars to have
        //                   a caret?
        if ( !psb->GetTheme() )
        {
            SBCtlSetup(hwnd);
            RECT rcWindow;
            GetWindowRect( hwnd, &rcWindow );

            cx = (psb->_fVert ? rcWindow.right - rcWindow.left
                                : psb->_calc.cpxThumb) - 2 * SYSMET(CXEDGE);
            cy = (psb->_fVert ? psb->_calc.cpxThumb
                                : rcWindow.bottom - rcWindow.top) - 2 * SYSMET(CYEDGE);
#ifdef _VISUAL_DELTA_
            cx -= (CARET_BORDERWIDTH * 2);
            cy -= (CARET_BORDERWIDTH * 2);
#endif _VISUAL_DELTA_

            CreateCaret((HWND)hwnd, (HBITMAP)1, cx, cy);
            zzzSetSBCaretPos(hwnd);
            ShowCaret((HWND)hwnd);
        }
        break;
    }

    case WM_KILLFOCUS:
        DestroyCaret();
        break;

    case WM_ERASEBKGND:

        /*
         * Do nothing, but don't let DefWndProc() do it either.
         * It will be erased when its painted.
         */
        return (LONG)TRUE;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        if ((hdc = (HDC)wParam) == NULL) {
            hdc = BeginPaint((HWND)hwnd, (LPPAINTSTRUCT)&ps);
        }
        if (!fSize) {
            SBCtlSetup(hwnd);
            xxxDrawSB2((HWND)hwnd, &psb->_calc, hdc, psb->_fVert, psb->_wDisableFlags);
        } else {
            fSizeReal = TestWF((HWND)hwnd, WFSIZEBOX);
            if (!fSizeReal)
                SetWF((HWND)hwnd, WFSIZEBOX);

            _DrawSizeBoxFromFrame((HWND)hwnd, hdc, 0, 0);

            if (!fSizeReal)
                ClrWF((HWND)hwnd, WFSIZEBOX);
        }

        if (wParam == 0L)
            EndPaint((HWND)hwnd, (LPPAINTSTRUCT)&ps);
        break;

    case WM_GETDLGCODE:
        return DLGC_WANTARROWS;

    case WM_CONTEXTMENU:
    {
        HWND hwndParent = GetParent(hwnd);
        if (hwndParent)
        {
            ScrollBar_Menu(hwndParent, hwnd, lParam, psb->_fVert);
        }
        break;

    }
    case WM_NCHITTEST:
        if (LOBYTE(dwStyle) & SBS_SIZEGRIP) {
#ifdef USE_MIRRORING
            /*
             * If the scroll bar is RTL mirrored, then
             * mirror the hittest of the grip location.
             */
            if (TestWF((HWND)hwnd, WEFLAYOUTRTL))
                return HTBOTTOMLEFT;
            else
#endif
                return HTBOTTOMRIGHT;
        } else {
            goto CallDWP;
        }
        break;

    case WM_MOUSELEAVE:
        psb->SetHotComponent(HTNOWHERE, psb->_fVert);
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_MOUSEMOVE:
    {
        INT ht;

        if (psb->GetHotComponent(psb->_fVert) == 0) 
        {
            TRACKMOUSEEVENT tme;

            tme.cbSize      = sizeof(TRACKMOUSEEVENT);
            tme.dwFlags     = TME_LEAVE;
            tme.hwndTrack   = hwnd;
            tme.dwHoverTime = 0;

            TrackMouseEvent(&tme);
        }

        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        ht = HitTestScrollBar((HWND)hwnd, psb->_fVert, pt);
        if (psb->GetHotComponent(psb->_fVert) != ht) 
        {
            psb->SetHotComponent(ht, psb->_fVert);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        break;

    }
    case WM_LBUTTONDBLCLK:
        cmd = SC_ZOOM;
        if (fSize)
            goto postmsg;

        /*
         *** FALL THRU **
         */

    case WM_LBUTTONDOWN:
            //
            // Note that SBS_SIZEGRIP guys normally won't ever see button
            // downs.  This is because they return HTBOTTOMRIGHT to
            // WindowHitTest handling.  This will walk up the parent chain
            // to the first sizeable ancestor, bailing out at caption windows
            // of course.  That dude, if he exists, will handle the sizing
            // instead.
            //
        if (!fSize) {
            if (TestWF((HWND)hwnd, WFTABSTOP)) {
                SetFocus((HWND)hwnd);
            }

            HideCaret((HWND)hwnd);
            SBCtlSetup(hwnd);

            /*
             * SBCtlSetup enters SEM_SB, and _SBTrackInit leaves it.
             */
            _SBTrackInit((HWND)hwnd, lParam, 0, (GetKeyState(VK_SHIFT) < 0) ? SCROLL_DIRECT : SCROLL_NORMAL);
            break;
        } else {
            cmd = SC_SIZE;
postmsg:
            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);
            ClientToScreen((HWND)hwnd, &pt);
            lParam = MAKELONG(pt.x, pt.y);

            /*
             * convert HT value into a move value.  This is bad,
             * but this is purely temporary.
             */
#ifdef USE_MIRRORING
            if (TestWF(GetParent(hwnd),WEFLAYOUTRTL))
            {
                uSide = HTBOTTOMLEFT;
            } 
            else 
#endif
            {
                uSide = HTBOTTOMRIGHT;
            }
            ThreadLock(((HWND)hwnd)->hwndParent, &tlpwndParent);
            SendMessage(GetParent(hwnd), WM_SYSCOMMAND,
                    (cmd | (uSide - HTSIZEFIRST + 1)), lParam);
            ThreadUnlock(&tlpwndParent);
        }
        break;

    case WM_KEYUP:
        switch (wParam) {
        case VK_HOME:
        case VK_END:
        case VK_PRIOR:
        case VK_NEXT:
        case VK_LEFT:
        case VK_UP:
        case VK_RIGHT:
        case VK_DOWN:

            /*
             * Send end scroll uMsg when user up clicks on keyboard
             * scrolling.
             *
             * DoScroll does thread locking on these two pwnds -
             * this is ok since they are not used after this
             * call.
             */
            xxxDoScroll( (HWND)hwnd, GetParent(hwnd),
                         SB_ENDSCROLL, 0, psb->_fVert
            );
            break;

        default:
            break;
        }
        break;

    case WM_KEYDOWN:
        switch (wParam) {
        case VK_HOME:
            wParam = SB_TOP;
            goto KeyScroll;

        case VK_END:
            wParam = SB_BOTTOM;
            goto KeyScroll;

        case VK_PRIOR:
            wParam = SB_PAGEUP;
            goto KeyScroll;

        case VK_NEXT:
            wParam = SB_PAGEDOWN;
            goto KeyScroll;

        case VK_LEFT:
        case VK_UP:
            wParam = SB_LINEUP;
            goto KeyScroll;

        case VK_RIGHT:
        case VK_DOWN:
            wParam = SB_LINEDOWN;
KeyScroll:

            /*
             * DoScroll does thread locking on these two pwnds -
             * this is ok since they are not used after this
             * call.
             */
            xxxDoScroll((HWND)hwnd, GetParent(hwnd), (int)wParam, 0, psb->_fVert
            );
            break;

        default:
            break;
        }
        break;

    case WM_ENABLE:
        return SendMessage((HWND)hwnd, SBM_ENABLE_ARROWS,
               (wParam ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH), 0);

    case SBM_ENABLE_ARROWS:

        /*
         * This is used to enable/disable the arrows in a SB ctrl
         */
        return (LONG)xxxEnableSBCtlArrows((HWND)hwnd, (UINT)wParam);

    case SBM_GETPOS:
        return (LONG)psb->_calc.data.pos;

    case SBM_GETRANGE:
        *((LPINT)wParam) = psb->_calc.data.posMin;
        *((LPINT)lParam) = psb->_calc.data.posMax;
        return MAKELRESULT(LOWORD(psb->_calc.data.posMin), LOWORD(psb->_calc.data.posMax));

    case SBM_GETSCROLLINFO:
        return (LONG)_SBGetParms((HWND)hwnd, SB_CTL, (PSBDATA)&psb->_calc, (LPSCROLLINFO) lParam);

    case SBM_SETRANGEREDRAW:
        fRedraw = TRUE;

    case SBM_SETRANGE:
        // Save the old values of Min and Max for return value
        si.cbSize = sizeof(si);
//        si.nMin = LOWORD(lParam);
//        si.nMax = HIWORD(lParam);
        si.nMin = (int)wParam;
        si.nMax = (int)lParam;
        si.fMask = SIF_RANGE | SIF_RETURNOLDPOS;
        goto SetInfo;

    case SBM_SETPOS:
        fRedraw = (BOOL) lParam;
        si.cbSize = sizeof(si);
        si.fMask = SIF_POS | SIF_RETURNOLDPOS;
        si.nPos  = (int)wParam;
        goto SetInfo;

    case SBM_SETSCROLLINFO:
    {
        lpsi = (LPSCROLLINFO) lParam;
        fRedraw = (BOOL) wParam;
SetInfo:
        fScroll = TRUE;
        lres = SBSetParms((PSBDATA)&psb->_calc, lpsi, &fScroll, &lres);

        if (SBSetParms((PSBDATA)&psb->_calc, lpsi, &fScroll, &lres))
        {
            NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, hwnd, OBJID_CLIENT, INDEX_SCROLLBAR_SELF);
        }

        if (!fRedraw)
            return lres;

        /*
         * We must set the new position of the caret irrespective of
         * whether the window is visible or not;
         * Still, this will work only if the app has done a xxxSetScrollPos
         * with fRedraw = TRUE;
         * Fix for Bug #5188 --SANKAR-- 10-15-89
         * No need to DeferWinEventNotify since hwnd is locked.
         */
        HideCaret((HWND)hwnd);
        SBCtlSetup(hwnd);
        zzzSetSBCaretPos(hwnd);

            /*
             ** The following ShowCaret() must be done after the DrawThumb2(),
             ** otherwise this caret will be erased by DrawThumb2() resulting
             ** in this bug:
             ** Fix for Bug #9263 --SANKAR-- 02-09-90
             *
             */

            /*
             *********** ShowCaret((HWND)hwnd); ******
             */

        if (_FChildVisible((HWND)hwnd) && fRedraw)
        {
            UINT    wDisable;
            HBRUSH  hbrUse;

            if (!fScroll)
                fScroll = !(lpsi->fMask & SIF_DISABLENOSCROLL);

            wDisable = (fScroll) ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH;
            xxxEnableScrollBar((HWND) hwnd, SB_CTL, wDisable);

            hdc = GetWindowDC((HWND)hwnd);
            if (hdc)
            {
                BOOL fOwnerBrush = FALSE;

                hbrUse = ScrollBar_GetColorObjects(hwnd, hdc, &fOwnerBrush);
                hbrSave = SelectBrush(hdc, hbrUse);

                // Before we used to only hideshowthumb() if the mesage was
                // not SBM_SETPOS.  I am not sure why but this case was ever
                // needed for win 3.x but on NT it resulted in trashing the border
                // of the scrollbar when the app called SetScrollPos() during
                // scrollbar tracking.  - mikehar 8/26
                DrawThumb2((HWND)hwnd, &psb->_calc, hdc, hbrUse, psb->_fVert, psb->_wDisableFlags, fOwnerBrush);
                SelectBrush(hdc, hbrSave);
                ReleaseDC(hwnd, hdc);
            }
        }

            /*
             * This ShowCaret() has been moved to this place from above
             * Fix for Bug #9263 --SANKAR-- 02-09-90
             */
        ShowCaret((HWND)hwnd);
        return lres;
    }

    case WM_GETOBJECT:

        if(lParam == OBJID_QUERYCLASSNAMEIDX)
        {
             return MSAA_CLASSNAMEIDX_SCROLLBAR;
        }

        break;

    case WM_THEMECHANGED:

        psb->ChangeSBTheme();
        InvalidateRect(hwnd, NULL, TRUE);

        break;

    default:

CallDWP:
        return DefWindowProc((HWND)hwnd, uMsg, wParam, lParam);

    }

    return 0L;
}

//-------------------------------------------------------------------------//
//  Globals
static HBRUSH g_hbrGray = NULL;

//-------------------------------------------------------------------------//
HBRUSH _UxGrayBrush(VOID)
{
    if( NULL == g_hbrGray )
    {
        CONST static WORD patGray[8] = {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa};
        HBITMAP hbmGray;
        /*
         * Create a gray brush to be used with GrayString
         */
        if( (hbmGray = CreateBitmap(8, 8, 1, 1, (LPBYTE)patGray)) != NULL )
        {
            g_hbrGray  = CreatePatternBrush(hbmGray);
            DeleteObject( hbmGray );
        }
    }
    return g_hbrGray;
}

//-------------------------------------------------------------------------//
void _RedrawFrame( HWND hwnd )
{
    CheckLock(hwnd);

    /*
     * We always want to call xxxSetWindowPos, even if invisible or iconic,
     * because we need to make sure the WM_NCCALCSIZE message gets sent.
     */
    SetWindowPos( hwnd, NULL, 0, 0, 0, 0, SWP_NOZORDER |
                  SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE | SWP_DRAWFRAME);
}

//-------------------------------------------------------------------------//
//  from winmgr.c
BOOL _FChildVisible( HWND hwnd )
{
    while (GetWindowStyle( hwnd ) & WS_CHILD )
    {
        if( NULL == (hwnd = GetParent(hwnd)) )
        if (!TestWF(hwnd, WFVISIBLE))
            return FALSE;
    }

    return TRUE;
}


//-------------------------------------------------------------------------//
//
// SizeBoxHwnd
//
// Returns the HWND that will be sized if the user drags in the given window's
// sizebox -- If NULL, then the sizebox is not needed
//
// Criteria for choosing what window will be sized:
// find first sizeable parent; if that parent is not maximized and the child's
// bottom, right corner is within a scroll bar height and width of the parent's
//
HWND SizeBoxHwnd(HWND hwnd)
{
    BOOL bMirroredSizeBox = (BOOL)TestWF(hwnd, WEFLAYOUTRTL);
    RECT rc;
    int  xbrChild;
    int  ybrChild;

    GetWindowRect(hwnd, &rc);
    
    xbrChild = bMirroredSizeBox ? rc.left : rc.right;
    ybrChild = rc.bottom;

    while (hwnd != HWND_DESKTOP)
    {
        if (TestWF(hwnd, WFSIZEBOX)) 
        {
            //
            // First sizeable parent found
            //
            int xbrParent;
            int ybrParent;

            if (TestWF(hwnd, WFMAXIMIZED))
            {
                return NULL;
            }

            GetWindowRect(hwnd, &rc);

            xbrParent = bMirroredSizeBox ? rc.left : rc.right;
            ybrParent = rc.bottom;

            //
            // the sizebox dude is within an EDGE of the client's bottom
            // right corner (left corner for mirrored windows), let this succeed.
            // That way people who draw their own sunken clients will be happy.
            //
            if (bMirroredSizeBox) 
            {
                if ((xbrChild - SYSMETRTL(CXFRAME) > xbrParent) || (ybrChild + SYSMETRTL(CYFRAME) < ybrParent)) 
                {
                    //
                    // Child's bottom, left corner of SIZEBOX isn't close enough
                    // to bottom left of parent's client.
                    //
                    return NULL;
                }
            } 
            else
            {
                if ((xbrChild + SYSMETRTL(CXFRAME) < xbrParent) || (ybrChild + SYSMETRTL(CYFRAME) < ybrParent)) 
                {
                    //
                    // Child's bottom, right corner of SIZEBOX isn't close enough
                    // to bottom right of parent's client.
                    //
                    return NULL;
                }
            }

            return hwnd;
        }

        if (!TestWF(hwnd, WFCHILD) || TestWF(hwnd, WFCPRESENT))
        {
            break;
        }

        hwnd = GetParent(hwnd); 
    }

    return NULL;
}


//-------------------------------------------------------------------------//
//
// _DrawPushButton
//
// From ntuser\rtl\draw.c
// Draws a push style button in the given state.  Adjusts passed in rectangle
// if desired.
//
// Algorithm:
// Depending on the state we either draw
//      - raised edge   (undepressed)
//      - sunken edge with extra shadow (depressed)
// If it is an option push button (a push button that is
// really a check button or a radio button like buttons
// in tool bars), and it is checked, then we draw it
// depressed with a different fill in the middle.
//
VOID _DrawPushButton(HWND hwnd, HDC hdc, LPRECT lprc, UINT state, UINT flags, BOOL fVert)
{
    RECT   rc;
    HBRUSH hbrMiddle;
    DWORD  rgbBack = 0;
    DWORD  rgbFore = 0;
    BOOL   fDither;
    HTHEME hTheme = CUxScrollBar::GetSBTheme(hwnd);

    if ( !hTheme )
    {
        rc = *lprc;

        DrawEdge(hdc,
                 &rc,
                 (state & (DFCS_PUSHED | DFCS_CHECKED)) ? EDGE_SUNKEN : EDGE_RAISED,
                 (UINT)(BF_ADJUST | BF_RECT | (flags & (BF_SOFT | BF_FLAT | BF_MONO))));

        //
        // BOGUS
        // On monochrome, need to do something to make pushed buttons look
        // better.
        //

        //
        // Fill in middle.  If checked, use dither brush (gray brush) with
        // black becoming normal color.
        //
        fDither = FALSE;

        if (state & DFCS_CHECKED) 
        {
            if ((GetDeviceCaps(hdc, BITSPIXEL) /*gpsi->BitCount*/ < 8) || (SYSRGBRTL(3DHILIGHT) == RGB(255,255,255))) 
            {
                hbrMiddle = _UxGrayBrush();
                rgbBack = SetBkColor(hdc, SYSRGBRTL(3DHILIGHT));
                rgbFore = SetTextColor(hdc, SYSRGBRTL(3DFACE));
                fDither = TRUE;
            } 
            else 
            {
                hbrMiddle = SYSHBR(3DHILIGHT);
            }

        } 
        else 
        {
            hbrMiddle = SYSHBR(3DFACE);
        }

        FillRect(hdc, &rc, hbrMiddle);

        if (fDither) 
        {
            SetBkColor(hdc, rgbBack);
            SetTextColor(hdc, rgbFore);
        }

        if (flags & BF_ADJUST)
        {
            *lprc = rc;
        }
    }
    else
    {
        INT  iStateId;
        INT  iPartId;
        SIZE sizeGrip;
        RECT rcContent;
        PSBTRACK pSBTrack = CUxScrollBar::GetSBTrack(hwnd);

        if ((CUxScrollBarCtl::GetDisableFlags(hwnd) & ESB_DISABLE_BOTH) == ESB_DISABLE_BOTH)
        {
            iStateId = SCRBS_DISABLED;
        }
        else if (pSBTrack && ((BOOL)pSBTrack->fTrackVert == fVert) && (pSBTrack->cmdSB == SB_THUMBPOSITION))
        {
            iStateId = SCRBS_PRESSED;
        }
        else if (CUxScrollBar::GetSBHotComponent(hwnd, fVert) == HTSCROLLTHUMB)
        {
            iStateId = SCRBS_HOT;
        }
        else
        {
            iStateId = SCRBS_NORMAL;
        }

        iPartId = fVert ? SBP_THUMBBTNVERT : SBP_THUMBBTNHORZ;

        //
        // Draw the thumb
        //
        DrawThemeBackground(hTheme, hdc, iPartId, iStateId, lprc, 0);
        
        //
        // Lastly draw the little gripper image, if there is enough room 
        //
        if ( SUCCEEDED(GetThemeBackgroundContentRect(hTheme, hdc, iPartId, iStateId, lprc, &rcContent)) )
        {
            iPartId = fVert ? SBP_GRIPPERVERT : SBP_GRIPPERHORZ;

            if ( SUCCEEDED(GetThemePartSize(hTheme, hdc, iPartId, iStateId, &rcContent, TS_TRUE, &sizeGrip)) )
            {
                if ( (sizeGrip.cx < RECTWIDTH(&rcContent)) && (sizeGrip.cy < RECTHEIGHT(&rcContent)) )
                {
                    DrawThemeBackground(hTheme, hdc, iPartId, iStateId, &rcContent, 0);
                }
            }
        }                   
    }
}


//  user.h
#define CheckMsgFilter(wMsg, wMsgFilterMin, wMsgFilterMax)                 \
    (   ((wMsgFilterMin) == 0 && (wMsgFilterMax) == 0xFFFFFFFF)            \
     || (  ((wMsgFilterMin) > (wMsgFilterMax))                             \
         ? (((wMsg) <  (wMsgFilterMax)) || ((wMsg) >  (wMsgFilterMin)))    \
         : (((wMsg) >= (wMsgFilterMin)) && ((wMsg) <= (wMsgFilterMax)))))

#define SYS_ALTERNATE           0x2000
#define SYS_PREVKEYSTATE        0x4000
         
//  mnaccel.h         
/***************************************************************************\
* _SysToChar
*
* EXIT: If the message was not made with the ALT key down, convert
*       the message from a WM_SYSKEY* to a WM_KEY* message.
*
* IMPLEMENTATION:
*     The 0x2000 bit in the hi word of lParam is set if the key was
*     made with the ALT key down.
*
* History:
*   11/30/90 JimA       Ported.
\***************************************************************************/

UINT _SysToChar(
    UINT message,
    LPARAM lParam)
{
    if (CheckMsgFilter(message, WM_SYSKEYDOWN, WM_SYSDEADCHAR) &&
            !(HIWORD(lParam) & SYS_ALTERNATE))
        return (message - (WM_SYSKEYDOWN - WM_KEYDOWN));

    return message;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\rgn.h ===
//-------------------------------------------------------------------------//
//  BmpRgn.h - Bitmap-to-Region transforms
//
//  History:
//  01/31/2000  scotthan   created
//-------------------------------------------------------------------------//

#ifndef __RGN_H__
#define __RGN_H__
//-------------------------------------------------------------------------//
//  CreateBitmapRgn
//
//  Creates a region based on an arbitrary bitmap, transparency-keyed on a
//  RGB value within a specified tolerance.  The key value is optional (-1 ==
//  use the value of the first pixel as the key).
//
EXTERN_C HRESULT WINAPI CreateBitmapRgn( 
    HBITMAP hbm, int cxOffset, int cyOffset, 
    int cx, int cy, BOOL fAlphaChannel, int iAlphaThreshold, COLORREF rgbMask, 
    int nMaskTolerance, OUT HRGN *phrgn);

//-------------------------------------------------------------------------//
//  CreateScaledBitmapRgn
//
//  Behaves in the same manner as CreateBitmapRgn, 
//  except builds a region based on a +scaled+ arbitrary bitmap.
EXTERN_C HRGN WINAPI CreateScaledBitmapRgn( 
    HBITMAP hbm, int cx, int cy, COLORREF rgbMask, int nMaskTolerance );

//-------------------------------------------------------------------------//
//  CreateTextRgn
//
//  Creates a region based on a text string in the indicated font.
//
EXTERN_C HRGN WINAPI CreateTextRgn( HFONT hf, LPCTSTR pszText );

//-------------------------------------------------------------------------//
//  AddToCompositeRgn
//
//  Wraps CombineRgn by managing composite creation and positioning
//  the source region (which is permanently offset). Returns one of:
//  NULLREGION, SIMPLEREGION, COMPLEXREGION, ERROR.
//
EXTERN_C int WINAPI AddToCompositeRgn( 
    HRGN* phrgnComposite, HRGN hrgnSrc, int cxOffset, int cyOffset );

//-------------------------------------------------------------------------//
//  RemoveFromCompositeRgn
//
//  Wraps CombineRgn by managing removal of rectangular region from
//  an existing destination region. Returns one of:
//  NULLREGION, SIMPLEREGION, COMPLEXREGION, ERROR.
//
EXTERN_C int WINAPI RemoveFromCompositeRgn( HRGN hrgnDest, LPCRECT prcRemove );

//-------------------------------------------------------------------------//
//  CreateTiledRectRgn
//
//  Returns a rectangular region composed of region tiles.
//
EXTERN_C HRGN WINAPI CreateTiledRectRgn( 
    HRGN hrgnTile, int cxTile, int cyTile, int cxBound, int cyBound );

//-------------------------------------------------------------------------//
//  Region utilities:
//
EXTERN_C HRGN WINAPI _DupRgn( HRGN hrgnSrc );

//-------------------------------------------------------------------------//
//  hit-testing
#define HTR_NORESIZE_USESEGCODE    0
#define HTR_NORESIZE_RETDEFAULT    -1
struct HITTESTRGN
{
    HRGN  hrgn;          // test region
    POINT pt;            // test point
    WORD  wSegCode;      // raw grid code, in the form of HTTOP, HTLEFT, HTTOPLEFT, etc.  This speeds calcs
    WORD  wDefault;      // return code on hit failure.
    BOOL  fCaptionAtTop; // interpret hits in top grid segs as a caption hit.
    UINT  cxLeftMargin;  // width of left resizing margin, HTR_NORESIZE_USESEGCODE, or HTR_NORESIZE_USEDEFAULTCODE
    UINT  cyTopMargin;   // height of top resizing margin, HTR_NORESIZE_USESEGCODE, or HTR_NORESIZE_USEDEFAULTCODE
    UINT  cxRightMargin; // width of right resizing margin, HTR_NORESIZE_USESEGCODE, or HTR_NORESIZE_USEDEFAULTCODE
    UINT  cyBottomMargin;// height of bottom resizing margin, HTR_NORESIZE_USESEGCODE, or HTR_NORESIZE_USEDEFAULTCODE
};

EXTERN_C WORD WINAPI _DefaultHitCodeFromSegCode( BOOL fHasCaption, WORD wSegHTcode );

//-------------------------------------------------------------------------//
//   Stretch/Tile rects from original region and create a new one
EXTERN_C HRESULT WINAPI _ScaleRectsAndCreateRegion(RGNDATA  *pCustomRgnData, 
    const RECT *pBoundRect, MARGINS *pMargins, SIZE *pszSrcImage, HRGN *pHrgn);

//-------------------------------------------------------------------------//
#ifdef _DEBUG
void RegionDebug(HRGN hrgn);
#endif

#endif __RGN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\renderlist.cpp ===
//---------------------------------------------------------------------------
//  RenderList.cpp - manages list of CRemderObj objects
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "RenderList.h"
#include "Render.h"
//---------------------------------------------------------------------------
#define MAKE_HTHEME(recycle, slot)  (HTHEME)IntToPtr((recycle << 16) | (slot & 0xffff))
//---------------------------------------------------------------------------
CRenderList::CRenderList()
{
    _iNextUniqueId = 0;

    ZeroMemory(&_csListLock, sizeof(_csListLock));
    if( !InitializeCriticalSectionAndSpinCount(&_csListLock, 0 ) )
    {
        ASSERT(0 == _csListLock.DebugInfo);
    }
}
//---------------------------------------------------------------------------
CRenderList::~CRenderList()
{
    for (int i=0; i < _RenderEntries.m_nSize; i++)
    {
        //---- ignore refcount here (end of process) ----
        if (_RenderEntries[i].pRenderObj)
        {
            //Log(LOG_RFBUG, L"DELETED CRenderObj at: 0x%08x", _RenderEntries[i].pRenderObj);
            delete _RenderEntries[i].pRenderObj;
        }
    }

    SAFE_DELETECRITICALSECTION(&_csListLock);
}
//---------------------------------------------------------------------------
HRESULT CRenderList::OpenRenderObject(CUxThemeFile *pThemeFile, int iThemeOffset, 
    int iClassNameOffset, CDrawBase *pDrawBase, CTextDraw *pTextObj, HWND hwnd,
    DWORD dwOtdFlags, HTHEME *phTheme)
{
    HRESULT hr = S_OK;
    CAutoCS autoCritSect(&_csListLock);

    CRenderObj *pRender = NULL;
    int iUsedSlot = -1;
    int iNextAvailSlot = -1;

    //---- see if OK to share an existing CRenderObj ----
    BOOL fShare = ((! pDrawBase) && (! pTextObj) && (! LogOptionOn(LO_TMHANDLE)));
    if (fShare)
    {
        if ((dwOtdFlags) && (dwOtdFlags != OTD_NONCLIENT))  // bits other than nonclient are set
            fShare = FALSE;
    }

    //---- loop for sharing and finding first avail entry ----
    for (int i=0; i < _RenderEntries.m_nSize; i++)
    {
        RENDER_OBJ_ENTRY *pEntry = &_RenderEntries[i];
        pRender = pEntry->pRenderObj;

        //---- skip over available entries ----
        if (! pRender)
        {
            if (iNextAvailSlot == -1)       // take first found slot
                iNextAvailSlot = i;

            continue;
        }

        if ((fShare) && (! pEntry->fClosing))
        {
            pRender->ValidateObj();

            int iOffset = int(pRender->_pbSectionData - pRender->_pbThemeData);

            if ((pRender->_pThemeFile == pThemeFile) && (iOffset == iThemeOffset))
            {
                pEntry->iRefCount++;
                iUsedSlot = i;
                Log(LOG_CACHE, L"OpenRenderObject: found match for Offset=%d (slot=%d, refcnt=%d)", 
                    iThemeOffset, i, pEntry->iRefCount);
                break;
            }
        }
    }

    if (iUsedSlot == -1)        // not found
    {
        if (iNextAvailSlot == -1)           // add to end
            iUsedSlot = _RenderEntries.m_nSize ;
        else 
            iUsedSlot = iNextAvailSlot;

        _iNextUniqueId++;

        hr = CreateRenderObj(pThemeFile, iUsedSlot, iThemeOffset, iClassNameOffset, 
            _iNextUniqueId, TRUE, pDrawBase, pTextObj, dwOtdFlags, &pRender);
        if (FAILED(hr))
            goto exit;

        //Log(LOG_RFBUG, L"ALLOCATED CRenderObj at: 0x%08x", pRender);

        //---- extract theme file Load ID ----
        THEMEHDR *th = (THEMEHDR *)pRender->_pbThemeData;
        int iLoadId = 0;
        if (th)
            iLoadId = th->iLoadId;

        RENDER_OBJ_ENTRY entry = {pRender, 1, 1, 0, iLoadId, FALSE, hwnd};

        if (iUsedSlot == _RenderEntries.m_nSize)           // add new entry
        {
            if (! _RenderEntries.Add(entry))
            {
                delete pRender;

                hr = MakeError32(E_OUTOFMEMORY);
                goto exit;
            }

            Log(LOG_CACHE, L"OpenRenderObject: created new obj AT END (slot=%d, refcnt=%d)", 
                pRender->_iCacheSlot, 1);
        }
        else                // use an existing slot
        {
            entry.dwRecycleNum = _RenderEntries[iUsedSlot].dwRecycleNum + 1;

            _RenderEntries[iUsedSlot] = entry;

            Log(LOG_CACHE, L"OpenRenderObject: created new obj SLOT REUSE (slot=%d, refcnt=%d, recycle=%d)", 
                iUsedSlot, 1, _RenderEntries[iUsedSlot].dwRecycleNum);
        }

    }

    if (SUCCEEDED(hr))
    {
        RENDER_OBJ_ENTRY *pEntry = &_RenderEntries[iUsedSlot];

        *phTheme = MAKE_HTHEME(pEntry->dwRecycleNum, iUsedSlot);

        //---- for debugging refcount issues ----
        if (LogOptionOn(LO_TMHANDLE))
        {
            WCHAR buff[MAX_PATH];

            if (hwnd)
                GetClassName(hwnd, buff, ARRAYSIZE(buff));
            else
                buff[0] = 0;

            //if (lstrcmpi(pRender->_pszClassName, L"window")==0)
            {
                //Log(LOG_TMHANDLE, L"OTD: cls=%s (%s), hwnd=0x%x, htheme=0x%x, new refcnt=%d", 
                //    pRender->_pszClassName, buff, hwnd, *phTheme, pEntry->iRefCount);
            }
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
BOOL CRenderList::DeleteCheck(RENDER_OBJ_ENTRY *pEntry)
{
    BOOL fClosed = FALSE;

    if ((! pEntry->iRefCount) && (! pEntry->iInUseCount))
    {
        //Log(LOG_RFBUG, L"DELETED CRenderObj at: 0x%08x", pEntry->pRenderObj);
        delete pEntry->pRenderObj;

        //---- important: don't use RemoveAt() or entries will shift and ----
        //---- our "SlotNumber" model between RenderList & CacheList will ----
        //---- be broken ----

        pEntry->pRenderObj = NULL;
        pEntry->fClosing = FALSE;

        fClosed = TRUE;
    }

    return fClosed;
}
//---------------------------------------------------------------------------
HRESULT CRenderList::CloseRenderObject(HTHEME hTheme)
{
    CAutoCS autoCritSect(&_csListLock);
    HRESULT hr = S_OK;

    int iSlotNum = (DWORD(PtrToInt(hTheme)) & 0xffff);
    DWORD dwRecycleNum = (DWORD(PtrToInt(hTheme)) >> 16);

    if (iSlotNum >= _RenderEntries.m_nSize)
    {
        Log(LOG_BADHTHEME, L"Illegal Theme Handle: 0x%x", hTheme);

        hr = MakeError32(E_HANDLE);
        goto exit;
    }

    RENDER_OBJ_ENTRY *pEntry = &_RenderEntries[iSlotNum];
    if ((! pEntry->pRenderObj) || (pEntry->fClosing) || (pEntry->dwRecycleNum != dwRecycleNum))
    {
        Log(LOG_BADHTHEME, L"Expired Theme Handle: 0x%x", hTheme);

        hr = MakeError32(E_HANDLE);
        goto exit;
    }

    //---- allow for our iRefCount to have been set to zero explicitly ----
    if (pEntry->iRefCount > 0)
        pEntry->iRefCount--;

#if 0
    //---- for debugging refcount issues ----
    if (LogOptionOn(LO_TMHANDLE))
    {
        CRenderObj *pRender = pEntry->pRenderObj;

        Log(LOG_TMHANDLE, L"CTD: cls=%s, hwnd=0x%x, htheme=0x%x, new refcnt=%d", 
            pRender->_pszClassName, pEntry->hwnd, hTheme, pEntry->iRefCount);
    }
#endif

    DeleteCheck(pEntry);
    
exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderList::OpenThemeHandle(HTHEME hTheme, CRenderObj **ppRenderObj, int *piSlotNum)
{
    CAutoCS autoCritSect(&_csListLock);
    HRESULT hr = S_OK;

    int iSlotNum = (int)(DWORD(PtrToInt(hTheme)) & 0xffff);
    DWORD dwRecycleNum = (DWORD(PtrToInt(hTheme)) >> 16);

    if (iSlotNum >= _RenderEntries.m_nSize)
    {
        Log(LOG_BADHTHEME, L"Illegal Theme Handle: 0x%x", hTheme);

        hr = MakeError32(E_HANDLE);
        goto exit;
    }

    RENDER_OBJ_ENTRY *pEntry = &_RenderEntries[iSlotNum];
    if ((! pEntry->pRenderObj) || (pEntry->fClosing) || (pEntry->dwRecycleNum != dwRecycleNum))
    {
        Log(LOG_BADHTHEME, L"Expired Theme Handle: 0x%x", hTheme);

        hr = MakeError32(E_HANDLE);
        goto exit;
    }

    if (pEntry->iInUseCount > 25)
    {
        Log(LOG_BADHTHEME, L"Warning BREAK: high ThemeHandle inuse count=%d", pEntry->iInUseCount);
    }

    pEntry->iInUseCount++;

    *ppRenderObj = pEntry->pRenderObj;
    *piSlotNum = iSlotNum;

exit:
    return hr;
}
//---------------------------------------------------------------------------
void CRenderList::CloseThemeHandle(int iSlotNum)
{
    CAutoCS autoCritSect(&_csListLock);
    RENDER_OBJ_ENTRY *pEntry = &_RenderEntries[iSlotNum];

    if (pEntry->iInUseCount <= 0)
    {
        Log(LOG_ERROR, L"Bad iUseCount on CRenderObj at slot=%d", iSlotNum);
    }
    else
    {
        pEntry->iInUseCount--;
        DeleteCheck(pEntry);
    }
}
//---------------------------------------------------------------------------
void CRenderList::FreeRenderObjects(int iThemeFileLoadId)
{
    CAutoCS autoCritSect(&_csListLock);

    int iFoundCount = 0;
    int iClosedCount = 0;

    //---- theme hooking has been turned off - mark all ----
    //---- our objects so they can be freed as soon ----
    //---- as all wrapper API's are exited so that ----
    //---- we don't hold open those big theme files in memory ----

    for (int i=0; i < _RenderEntries.m_nSize; i++)
    {
        RENDER_OBJ_ENTRY *pEntry = &_RenderEntries[i];

        if (pEntry->pRenderObj)
        {
            if ((iThemeFileLoadId == -1) || (iThemeFileLoadId == pEntry->iLoadId))
            {
                iFoundCount++;

                HTHEME hTheme = MAKE_HTHEME(pEntry->dwRecycleNum, i);

                Log(LOG_BADHTHEME, L"Unclosed RenderList[]: class=%s, hwnd=0x%x, htheme=0x%x, refcnt=%d", 
                    pEntry->pRenderObj->_pszClassName, pEntry->hwnd, hTheme, pEntry->iRefCount);

                pEntry->fClosing = TRUE;        // don't grant further access to this obj
                pEntry->iRefCount = 0;          // free it as soon as callers have exited

                if (DeleteCheck(pEntry))        // delete now or mark for "delete on API exit"
                {
                    //---- just deleted it ----
                    iClosedCount++;
                }
            }
        }
    }

    Log(LOG_TMHANDLE, L"FreeRenderObjects: iLoadId=%d, found-open=%d, closed-now=%d", 
        iThemeFileLoadId, iFoundCount, iClosedCount);
}
//---------------------------------------------------------------------------
#ifdef DEBUG
void CRenderList::DumpFileHolders()
{
    CAutoCS autoCritSect(&_csListLock);
 
    if (LogOptionOn(LO_TMHANDLE))
    {
        //---- find number of CRenderObj's ----
        int iCount = 0;
        _RenderEntries.m_nSize;

        for (int i=0; i < _RenderEntries.m_nSize; i++)
        {
            if (_RenderEntries[i].pRenderObj)
                iCount++;
        }

        if (! iCount)
        {
            Log(LOG_TMHANDLE, L"---- No CRenderObj objects ----");
        }
        else
        {
            Log(LOG_TMHANDLE, L"---- Dump of %d CRenderObj objects ----", iCount);

            for (int i=0; i < _RenderEntries.m_nSize; i++)
            {
                RENDER_OBJ_ENTRY *pEntry = &_RenderEntries[i];

                if (pEntry->pRenderObj)
                {
                    CRenderObj *pr = pEntry->pRenderObj;
                    THEMEHDR *th = (THEMEHDR *)pr->_pbThemeData;
                    int iLoadId = 0;

                    if (th)
                        iLoadId = th->iLoadId;

                    LPCWSTR pszClass = NULL;

                    if (pr->_pszClassName)
                        pszClass = pr->_pszClassName;

                    Log(LOG_TMHANDLE, L"  RenderObj[%d]: class=%s, refcnt=%d, hwnd=0x%x", 
                        i, pszClass, pEntry->iRefCount, pEntry->hwnd);

                }
            }
        }
    }
}
#endif
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\render.h ===
//---------------------------------------------------------------------------
//  Render.h - implements the themed drawing services 
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "SimpStr.h"
#include "loader.h"
#include "ThemeFile.h"
//---------------------------------------------------------------------------
#define FONTCOMPARE(f1, f2) ((memcmp(&(f1), &(f2), sizeof(LOGFONT)-LF_FACESIZE)==0) \
    && (lstrcmpi((f1).lfFaceName, (f2).lfFaceName)==0))
//---------------------------------------------------------------------------
#define DEFAULT_TRANSPARENT_COLOR   RGB(255, 0, 255)
//---------------------------------------------------------------------------
class CRenderCache;     // forward
class CDrawBase;        // forward
class CTextDraw;        // forward
struct BRUSHBUFF;       // forward
//---------------------------------------------------------------------------
struct PARTINFO
{
    int iMaxState;

    CDrawBase *pDrawObj;               // DrawObj[0]
    CTextDraw *pTextObj;               // TextObj[0]

    CDrawBase **pStateDrawObjs;        // DrawObjs[1..iMaxState]
    CTextDraw **pStateTextObjs;        // TextObjs[1..iMaxState]
};
//---------------------------------------------------------------------------
class CRenderObj
{
public:
	CRenderObj(CUxThemeFile *pThemeFile, int iCacheSlot, int iThemeOffset, int iClassNameOffset,
        __int64 iUniqueId, BOOL fEnableCache, DWORD dwOtdFlags);
    ~CRenderObj();
    HRESULT Init(CDrawBase *pBaseObj, CTextDraw *pTextObj);   // must be called after constructor

    BOOL ValidateObj();

public:
    //---- information methods ----
    HRESULT WINAPI GetColor(int iPartId, int iStateId, int iPropId, COLORREF *pColor);
    HRESULT WINAPI GetMetric(OPTIONAL HDC hdc, int iPartId, int iStateId, int iPropId, int *piVal);
    HRESULT WINAPI GetString(int iPartId, int iStateId, int iPropId, LPWSTR pszBuff, DWORD dwMaxBuffChars);
    HRESULT WINAPI GetBool(int iPartId, int iStateId, int iPropId, BOOL *pfVal);
    HRESULT WINAPI GetInt(int iPartId, int iStateId, int iPropId, int *piVal);
    HRESULT WINAPI GetEnumValue(int iPartId, int iStateId, int iPropId, int *piVal);
    HRESULT WINAPI GetPosition(int iPartId, int iStateId, int iPropId, POINT *pPoint);
    HRESULT WINAPI GetFont(OPTIONAL HDC hdc, int iPartId, int iStateId, int iPropId, BOOL fWantHdcScaling,
        LOGFONT *pFont);
    HRESULT WINAPI GetMargins(OPTIONAL HDC hdc, int iPartId, int iStateId, int iPropId, 
        OPTIONAL RECT *prc, MARGINS *pMargins);
    HRESULT WINAPI GetIntList(int iPartId, int iStateId, int iPropId, INTLIST *pIntList);
    HRESULT WINAPI GetRect(int iPartId, int iStateId, int iPropId, RECT *pRect);
    HRESULT WINAPI GetFilename(int iPartId, int iStateId, int iPropId, LPWSTR pszBuff, DWORD dwMaxBuffChars);
    HRESULT WINAPI GetPropertyOrigin(int iPartId, int iStateId, int iPropId, PROPERTYORIGIN *pOrigin);
    BOOL WINAPI IsPartDefined(int iPartId, int iStateId);

    HRESULT GetBitmap(HDC hdc, int iDibOffset, OUT HBITMAP *pBitmap);

    HRESULT GetScaledFontHandle(HDC hdc, LOGFONT *plf, HFONT *phFont);

    void ReturnBitmap(HBITMAP hBitmap);
    void ReturnFontHandle(HFONT hFont);

    int GetDpiOverride();
    //---------------------------------------------------------------------------
    inline HRESULT GetDrawObj(int iPartId, int iStateId, CDrawBase **ppObj)
    {
        HRESULT hr = S_OK;
        
        if (! _pParts)
        {
            hr = MakeError32(E_FAIL);
        }
        else
        {
            if ((iPartId < 0) || (iPartId > _iMaxPart))
                iPartId = 0;

            PARTINFO *ppi = &_pParts[iPartId];

            if (! ppi->pStateDrawObjs)      // good to go
            {
                *ppObj = ppi->pDrawObj;
            }
            else
            {
                if ((iStateId < 0) || (iStateId > ppi->iMaxState))
                    iStateId = 0;

                if (! iStateId)
                    *ppObj = ppi->pDrawObj;
                else
                    *ppObj = ppi->pStateDrawObjs[iStateId-1];
            }

            if (! *ppObj)
            {
                Log(LOG_ERROR, L"GetDrawObj() returned NULL");
                hr = MakeError32(E_FAIL);
            }
        }

        return hr;
    }
    //---------------------------------------------------------------------------
    inline HRESULT GetTextObj(int iPartId, int iStateId, CTextDraw **ppObj)
    {
        HRESULT hr = S_OK;
        
        if (! _pParts)
        {
            hr = MakeError32(E_FAIL);
        }
        else
        {
            if ((iPartId < 0) || (iPartId > _iMaxPart))
                iPartId = 0;

            PARTINFO *ppi = &_pParts[iPartId];

            if (! ppi->pStateTextObjs)      // good to go
            {
                *ppObj = ppi->pTextObj;
            }
            else
            {
                if ((iStateId < 0) || (iStateId > ppi->iMaxState))
                    iStateId = 0;

                if (! iStateId)
                    *ppObj = ppi->pTextObj;
                else
                    *ppObj = ppi->pStateTextObjs[iStateId-1];
            }

            if (! *ppObj)
            {
                Log(LOG_ERROR, L"GetTextObj() returned NULL");
                hr = MakeError32(E_FAIL);
            }
        }

        return hr;
    }
    //---------------------------------------------------------------------------
    inline bool IsReady()
    {
        if (_pThemeFile)
        {
            return _pThemeFile->IsReady();
        }
        return true;
    }
    //---------------------------------------------------------------------------
   
    int GetValueIndex(int iPartId, int iStateId, int iTarget);

    HRESULT PrepareRegionDataForScaling(RGNDATA *pRgnData, LPCRECT prcImage, MARGINS *pMargins);
    
protected:
    //---- helpers ----
    HRESULT GetData(int iPartId, int iStateId, int iPropId, BYTE **ppDibData, 
        OPTIONAL int *piDibSize=NULL);

    CRenderCache *GetTlsCacheObj();
 
    HRESULT WalkDrawObjects(MIXEDPTRS &u, int *iPartOffsets);
    HRESULT WalkTextObjects(MIXEDPTRS &u, int *iPartOffsets);
    
    HRESULT CreateBitmapFromData(HDC hdc, int iDibOffset, OUT HBITMAP *phBitmap);

    HRESULT BuildPackedPtrs(CDrawBase *pBaseObj, CTextDraw *pTextObj);
    
    HRESULT PrepareAlphaBitmap(HBITMAP hBitmap);

public:
    //---- data ----
    char _szHead[8];

    //---- object id ----
    CUxThemeFile *_pThemeFile;        // holds a refcnt on the binary theme file
    int _iCacheSlot;        // our index into thread local cache list
    __int64 _iUniqueId;     // used to validate cache objects against render objects 

    //---- cached info from theme ----
    BYTE *_pbThemeData;     // ptr to start of binary theme data
    BYTE *_pbSectionData;   // ptr to our section of binary theme data

    BOOL _fCacheEnabled;
    BOOL _fCloseThemeFile;

    THEMEMETRICS *_ptm;     // ptr to theme metrics
    LPCWSTR _pszClassName;  // ptr to class name we matched to create this obj

    //---- direct ptrs to packed structs ----
    int _iMaxPart;
    PARTINFO *_pParts;      // [0.._MaxPart]

    //---- OpenThemeData override flags ----
    DWORD _dwOtdFlags;
    int _iDpiOverride;

    char _szTail[4];
};
//---------------------------------------------------------------------------
HRESULT CreateRenderObj(CUxThemeFile *pThemeFile, int iCacheSlot, int iThemeOffset, 
    int iClassNameOffset, __int64 iUniqueId, BOOL fEnableCache, CDrawBase *pBaseObj,
    CTextDraw *pTextObj, DWORD dwOtdFlags, CRenderObj **ppObj);
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by UxTheme.rc
//

#define IDC_STATIC                      -1

/////////////////////////////////////////////////////////////////////
// String Resource IDs (2000 - 10000)
/////////////////////////////////////////////////////////////////////
#define IDS_MESSAGEBOX         2000
#define IDS_ACTIVEWINDOW       2001
#define IDS_INACTIVEWINDOW     2002
#define IDS_OKBUTTON           2003
#define IDS_WINDOWTEXT         2004
#define IDS_WINDOWMETRICS      2005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        153
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\renderlist.h ===
//---------------------------------------------------------------------------
//  RenderList.h - manages list of CRemderObj objects
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "Render.h"
//---------------------------------------------------------------------------
class CUxThemeFile;       // forward
//---------------------------------------------------------------------------
#define MAX_RETADDRS    10
//---------------------------------------------------------------------------
struct RENDER_OBJ_ENTRY
{
    CRenderObj *pRenderObj;
    DWORD dwRecycleNum;     // sequential number to validate handle against current obj

    //---- these control use/freeing of object ----
    int iRefCount;          // number of HTHEME handles returned for this obj
    int iInUseCount;        // number of active wrapper API calls for this obj
    int iLoadId;            // load ID of associated theme file
    BOOL fClosing;          // TRUE when we are forcing this object closed

    //---- for tracking foreign windows & debugging leaks ----
    HWND hwnd;
};
//---------------------------------------------------------------------------
class CRenderList
{
    //---- methods ----
public:
    CRenderList();
    ~CRenderList();

    HRESULT OpenRenderObject(CUxThemeFile *pThemeFile, int iThemeOffset, 
        int iClassNameOffset, CDrawBase *pDrawBase, CTextDraw *pTextObj, HWND hwnd,
        DWORD dwOtdFlags, HTHEME *phTheme);
    HRESULT CloseRenderObject(HTHEME hTheme);

    HRESULT OpenThemeHandle(HTHEME hTheme, CRenderObj **ppRenderObj, int *piSlotNum);
    void CloseThemeHandle(int iSlotNum);
    void FreeRenderObjects(int iThemeFileLoadId);

#ifdef DEBUG
    void DumpFileHolders();
#endif

protected:
    //---- helper methods ----
    BOOL DeleteCheck(RENDER_OBJ_ENTRY *pEntry);

    //---- data ----
protected:
    __int64 _iNextUniqueId;
    CSimpleArray<RENDER_OBJ_ENTRY> _RenderEntries;

    //---- lock for all methods of this object ----
    CRITICAL_SECTION _csListLock;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\rgn.cpp ===
//-------------------------------------------------------------------------//
//  Rgn.cpp - Bitmap-to-Region transforms
//
//  History:
//  01/31/2000  scotthan   created
//-------------------------------------------------------------------------//

#include "stdafx.h"
#include "rgn.h"
#include "tmutils.h"


//------------//
//  Helpers:

//-------------------------------------------------------------------------//
#define CX_USEDEFAULT   -1
#define CY_USEDEFAULT   -1

#define _ABS( val1, val2 )   ((val1)>(val2) ? (val1)-(val2) : (val2)-(val1))

//-------------------------------------------------------------------------//
inline BOOL IsColorMatch( COLORREF rgb1, COLORREF rgb2, int nTolerance = 0 )
{
    if( nTolerance == 0 )
        return (rgb1 << 8) == (rgb2 << 8);

    return _ABS(GetRValue(rgb1),GetRValue(rgb2)) <= nTolerance &&
           _ABS(GetGValue(rgb1),GetGValue(rgb2)) <= nTolerance &&
           _ABS(GetBValue(rgb1),GetBValue(rgb2)) <= nTolerance;
}

//-------------------------------------------------------------------------//
inline BOOL _IsNormalRect( IN LPCRECT prc )
{
    return (prc->right >= prc->left) &&
           (prc->bottom >= prc->top);
}

//-------------------------------------------------------------------------//
inline BOOL _IsOnScreenRect( IN LPCRECT prc )
{
    return prc->left >= 0 && prc->top >= 0 &&
           prc->right >= 0 && prc->bottom >= 0;
}

//-------------------------------------------------------------------------//
inline void _InPlaceUnionRect( IN OUT LPRECT prcDest, IN LPCRECT prcSrc )
{
    ASSERT(prcDest);
    ASSERT(prcSrc);
    ASSERT(_IsNormalRect(prcSrc));

    if( prcDest->left == -1 || prcDest->left > prcSrc ->left )
        prcDest->left = prcSrc ->left;

    if( prcDest->right == -1 || prcDest->right < prcSrc ->right )
        prcDest->right = prcSrc ->right;

    if( prcDest->top == -1 || prcDest->top > prcSrc ->top )
        prcDest->top = prcSrc ->top;

    if( prcDest->bottom == -1 || prcDest->bottom < prcSrc ->bottom )
        prcDest->bottom = prcSrc ->bottom;
}

//-------------------------------------------------------------------------//
//  Walks the pixels and computes the region
HRGN WINAPI _PixelsToRgn( 
    DWORD *pdwBits,
    int cxImageOffset,  // image cell horz offset
    int cyImageOffset,  // image cell vert offset
    int cxImage,        // image cell width
    int cyImage,        // image cell height
    int cxSrc,          // src bitmap width
    int cySrc,          // src bitmap height
    BOOL fAlphaChannel,
    int iAlphaThreshold,
    COLORREF rgbMask, 
    int nMaskTolerance )
{
    //  Establish a series of rectangles, each corresponding to a scan line (row)
    //  in the bitmap, that will comprise the region.
    const UINT RECTBLOCK = 512;
    UINT       nAllocRects = 0;
    HRGN       hrgnRet = NULL;
    HGLOBAL    hrgnData = GlobalAlloc( GMEM_MOVEABLE, 
                                    sizeof(RGNDATAHEADER) + (sizeof(RECT) * (nAllocRects + RECTBLOCK)) );

    if( hrgnData )
    {
        nAllocRects += RECTBLOCK;

        RGNDATA* prgnData = (RGNDATA*)GlobalLock( hrgnData );
        LPRECT   prgrc    = (LPRECT)prgnData->Buffer;

        ZeroMemory( &prgnData->rdh, sizeof(prgnData->rdh) );
        prgnData->rdh.dwSize   = sizeof(prgnData->rdh);
        prgnData->rdh.iType    = RDH_RECTANGLES;
        SetRect( &prgnData->rdh.rcBound, -1, -1, -1, -1 );

        // invert offset in y dimension since bits are arrayed bottom to top
        int cyRow0 = cySrc - (cyImage + cyImageOffset);
        int cyRowN = (cyRow0 + cyImage) - 1 ;  // index of the last row

        //  Compute a transparency mask if not specified.
        if( -1 == rgbMask )
            rgbMask = pdwBits[cxImageOffset + (cyRowN * cxSrc)];

        //---- pixels in pdwBits[] have RBG's reversed ----
        //---- reverse our mask to match ----
        rgbMask = REVERSE3(rgbMask);        

        //---- rows in pdwBits[] are reversed (bottom to top) ----
        for( int y = cyRow0; y <= cyRowN; y++ ) // working bottom-to-top
        {
            //---- Scanning pixels left to right ----
            DWORD *pdwFirst = &pdwBits[cxImageOffset + (y * cxSrc)];
            DWORD *pdwLast = pdwFirst + cxImage - 1;
            DWORD *pdwPixel = pdwFirst;

            while (pdwPixel <= pdwLast)
            {
                //---- skip TRANSPARENT pixels to find next OPAQUE (on this row) ----
                if (fAlphaChannel)
                {
                    while ((pdwPixel <= pdwLast) && (ALPHACHANNEL(*pdwPixel) < iAlphaThreshold))
                        pdwPixel++;
                }
                else
                {
                    while ((pdwPixel <= pdwLast) && (IsColorMatch(*pdwPixel, rgbMask, nMaskTolerance)))
                        pdwPixel++;
                }

                if (pdwPixel > pdwLast)     // too far; try next row
                    break;       

                DWORD *pdw0 = pdwPixel;
                pdwPixel++;             // skip over current opaque pixel

                //---- skip OPAQUE pixels to find next TRANSPARENT (on this row) ----
                if (fAlphaChannel)
                {
                    while ((pdwPixel <= pdwLast) && (ALPHACHANNEL(*pdwPixel) >= iAlphaThreshold))
                        pdwPixel++;
                }
                else
                {
                    while ((pdwPixel <= pdwLast) && (! IsColorMatch(*pdwPixel, rgbMask, nMaskTolerance)))
                        pdwPixel++;
                }

                //---- got a stream of 1 or more opaque pixels on this row ----

                //  allocate more region rects if necessary (a particularly complex line)
                if( prgnData->rdh.nCount >= nAllocRects )
                {
                    GlobalUnlock( hrgnData );
                    prgnData = NULL;
                    HGLOBAL hNew = GlobalReAlloc( hrgnData, 
                            sizeof(RGNDATAHEADER) + (sizeof(RECT) * (nAllocRects + RECTBLOCK)),
                            GMEM_MOVEABLE );

                    if( hNew )
                    {
                        hrgnData = hNew;
                        nAllocRects += RECTBLOCK;
                        prgnData = (RGNDATA*)GlobalLock( hrgnData );
                        prgrc    = (LPRECT)prgnData->Buffer;
                        ASSERT(prgnData);
                    }
                    else
                        goto exit;      // out of memory
                }
                
                //  assign region rectangle
                int x0 = (int)(pdw0 - pdwFirst);
                int x = (int)(pdwPixel - pdwFirst);
                int y0 = cyRowN - y;

                SetRect( prgrc + prgnData->rdh.nCount, 
                         x0, y0, x, y0+1  /* each rectangle is always 1 pixel high */ );
                
                //  merge into bounding box
                _InPlaceUnionRect( &prgnData->rdh.rcBound, 
                                   prgrc + prgnData->rdh.nCount );
                prgnData->rdh.nCount++;

            } // while ()
        } // for(y)

        if( prgnData->rdh.nCount && _IsOnScreenRect(&prgnData->rdh.rcBound) )
        {
            //  Create the region representing the scan line.
            hrgnRet = ExtCreateRegion( NULL, sizeof(RGNDATAHEADER) + (sizeof(RECT) * nAllocRects),
                                       prgnData );
        }

exit:
        // Free region def block.
        GlobalUnlock( hrgnData );
        GlobalFree( hrgnData );
    }

    return hrgnRet;
}

//-------------------------------------------------------------------------//
//  Creates a region based on a text string in the indicated font.
HRGN WINAPI CreateTextRgn( HFONT hf, LPCTSTR pszText )
{
    HRGN hrgnRet = NULL;

    if( pszText && *pszText )
    {
        int   cchText = lstrlen( pszText );

        //  Create a composite DC for assembling the region.
        HDC  hdcMem = CreateCompatibleDC( NULL );

        SetBkMode( hdcMem, TRANSPARENT );
        SetTextAlign( hdcMem, TA_TOP|TA_LEFT );
        HFONT hfOld = (HFONT)SelectObject( hdcMem, hf );

        //  Derive a region from a path.
        BeginPath( hdcMem );
        TextOut( hdcMem, 0, 0, pszText, cchText );
        EndPath( hdcMem );

        hrgnRet = PathToRegion( hdcMem );

        //  Clean up composite DC
        SelectObject( hdcMem, hfOld );
        DeleteDC( hdcMem );
    }

    return hrgnRet;
}

//-------------------------------------------------------------------------//
//  Creates a region based on an arbitrary bitmap, transparency-keyed on a
//  RGB value within a specified tolerance.  The key value is optional 
//  (-1 == use the value of the first pixel as the key).
//
HRESULT WINAPI CreateBitmapRgn( 
    HBITMAP hbm, 
    int cxOffset,
    int cyOffset,
    int cx,
    int cy,
    BOOL fAlphaChannel,
    int iAlphaThreshold,
    COLORREF rgbMask, 
    int nMaskTolerance,
    OUT HRGN *phrgn)
{
    CBitmapPixels BitmapPixels;
    DWORD         *prgdwPixels;
    int           cwidth, cheight;

    HRESULT hr = BitmapPixels.OpenBitmap(NULL, hbm, TRUE, &prgdwPixels, &cwidth, &cheight);
    if (FAILED(hr))
        return hr;

    if (cx <= 0)
        cx = cwidth;

    if (cy <= 0)
        cy = cheight;

    HRGN hrgn = _PixelsToRgn(prgdwPixels, cxOffset, cyOffset, cx, cy, cwidth, cheight, fAlphaChannel,
        iAlphaThreshold, rgbMask, nMaskTolerance);
    if (! hrgn)
        return MakeError32(E_FAIL);      // unknown reason for failure

    *phrgn = hrgn;
    return S_OK;
}

//-------------------------------------------------------------------------//
//  Creates a region based on an arbitrary bitmap, transparency-keyed on a
//  RGB value within a specified tolerance.  The key value is optional (-1 ==
//  use the value of the first pixel as the key).
//
HRGN WINAPI CreateScaledBitmapRgn( 
    HBITMAP hbm, 
    int cx,
    int cy,
    COLORREF rgbMask, 
    int nMaskTolerance )
{
    HRGN   hrgnRet = NULL;
    BITMAP bm;

    if( hbm && GetObject( hbm, sizeof(bm), &bm ) )
    {
        //  Create a memory DC to do the pixel walk
        HDC hdcMem = NULL;
        if( (hdcMem = CreateCompatibleDC(NULL)) != NULL )
        {
            if( CX_USEDEFAULT == cx )
                cx = bm.bmWidth;
            if( CY_USEDEFAULT == cy )
                cy = bm.bmHeight;

            //  Create a 32-bit empty bitmap for the walk
            BITMAPINFO bmi;
            ZeroMemory( &bmi, sizeof(bmi) );
            bmi.bmiHeader.biSize        = sizeof(bmi.bmiHeader);
            bmi.bmiHeader.biWidth       = cx;
            bmi.bmiHeader.biHeight      = cy;
            bmi.bmiHeader.biPlanes      = 1;
            bmi.bmiHeader.biBitCount    = 32;
            bmi.bmiHeader.biCompression = BI_RGB; // uncompressed.

            VOID*   pvBits = NULL;
            HBITMAP hbmMem  = CreateDIBSection( hdcMem, &bmi, DIB_RGB_COLORS, &pvBits, NULL, NULL );
            BITMAP  bmMem;

            if( hbmMem )
            {
                //  Transfer the image to our 32-bit format for the pixel walk.
                HBITMAP hbmMemOld = (HBITMAP)SelectObject( hdcMem, hbmMem );
                HDC hdc = CreateCompatibleDC( hdcMem );
                HBITMAP hbmOld = (HBITMAP)SelectObject( hdc, hbm );

                StretchBlt( hdcMem, 0, 0, cx, cy, 
                            hdc, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY );
                SelectObject( hdc, hbmOld );
                DeleteDC( hdc );
                
                GetObject( hbmMem, sizeof(bmMem), &bmMem );
                ASSERT(bmMem.bmBitsPixel == 32);
                ASSERT(bmMem.bmWidthBytes/bmMem.bmWidth == sizeof(DWORD));
                LPDWORD pdwBits = (LPDWORD)bmMem.bmBits;
                ASSERT(pdwBits != NULL);

                hrgnRet = _PixelsToRgn(pdwBits, 0, 0, cx, cy, cx, cy, FALSE, 0, rgbMask, nMaskTolerance);
              
                //  Delete 32-bit memory bitmap
                SelectObject( hdcMem, hbmMemOld ); 
                DeleteObject( hbmMem ); 
            }
            //  Delete memory DC
            DeleteDC(hdcMem);

        }
    }
    return hrgnRet;
}
//-------------------------------------------------------------------------//
//  crete a region built up from rectangular tiles
HRGN WINAPI CreateTiledRectRgn( 
    IN HRGN hrgnSrc, 
    IN int cxSrc, 
    IN int cySrc, 
    IN int cxDest, 
    IN int cyDest )
{
    HRGN hrgnBound = NULL; // return value
    HRGN hrgnTile = _DupRgn( hrgnSrc );

    if( hrgnTile )
    {
        //  Build up an unplaced, unclipped composite
        HRGN hrgnTmp = NULL;
        for( int y = 0; y < cyDest; y += cySrc )
        {
            for( int x = 0; x < cxDest; x += cxSrc )
            {
                AddToCompositeRgn( &hrgnTmp, hrgnTile, 
                                   (x ? cxSrc  : 0), (y ? cySrc : 0) );
            }
        }

        if( NULL != hrgnTmp )
        {
            //  Clip the composite to the specified rectangle
            hrgnBound = CreateRectRgn( 0, 0, cxDest, cyDest );
            if( hrgnBound )
            {
                
                if( ERROR == CombineRgn( hrgnBound, hrgnTmp, hrgnBound, RGN_AND ) )
                {
                    DeleteObject( hrgnBound );
                    hrgnBound = NULL;
                }
            }
            DeleteObject( hrgnTmp );   
        }
        DeleteObject( hrgnTile );
    }
    return hrgnBound;
}
//-------------------------------------------------------------------------//
int WINAPI AddToCompositeRgn( 
    IN OUT HRGN* phrgnComposite, 
    IN OUT HRGN hrgnSrc, 
    IN int cxOffset, 
    IN int cyOffset )
{
    int nRet = ERROR;

    if( NULL != phrgnComposite && NULL != hrgnSrc )
    {
        nRet = OffsetRgn( hrgnSrc, cxOffset, cyOffset );
        if( nRet != ERROR )
        {
            int nMode = RGN_OR;
            if( NULL == *phrgnComposite )
            {
                *phrgnComposite = CreateRectRgn(0,0,1,1);
                if( NULL == *phrgnComposite )
                    return ERROR;
                nMode = RGN_COPY;
            }
            nRet = CombineRgn( *phrgnComposite, hrgnSrc, *phrgnComposite, nMode );
        }
    }

    return nRet;
}

//-------------------------------------------------------------------------//
//  removes a rectangle from a region.
int WINAPI RemoveFromCompositeRgn( 
    HRGN hrgnDest, 
    LPCRECT prcRemove )
{
    ASSERT(hrgnDest);
    ASSERT(prcRemove);
    ASSERT(!IsRectEmpty(prcRemove));

    int nRet = ERROR;
    
    RECT rc = *prcRemove;
    HRGN hrgn;
    if( (hrgn = CreateRectRgnIndirect( &rc )) != NULL )
    {
        nRet = CombineRgn( hrgnDest, hrgnDest, hrgn, RGN_DIFF );
        DeleteObject( hrgn );
    }
    return nRet;
}

//-------------------------------------------------------------------------//
HRGN WINAPI _DupRgn( HRGN hrgnSrc )
{
    if( hrgnSrc )
    {
        HRGN hrgnDest = CreateRectRgn(0,0,1,1);
        if (hrgnDest)
        {
            if (CombineRgn( hrgnDest, hrgnSrc, NULL, RGN_COPY ) )
                return hrgnDest;
    
            DeleteObject(hrgnDest);
        }
    }
    return NULL; 
}

//-------------------------------------------------------------------------//
void FixMarginOverlaps(int szDest, int *pm1, int *pm2)
{
    int szSrc = (*pm1 + *pm2);

    if ((szSrc > szDest) && (szSrc > 0))
    {
        //---- reduce each but maintain ratio ----
        *pm1 = int(.5 + float(*pm1 * szDest)/float(szSrc));
        *pm2 = szDest - *pm1;
    }
}
//-------------------------------------------------------------------------//
HRESULT _ScaleRectsAndCreateRegion(
    RGNDATA     *prd, 
    const RECT  *prc,
    MARGINS     *pMargins,
    SIZE        *pszSrcImage, 
    HRGN        *phrgn)
{
    //---- note: "prd" is region data with the 2 points in each ----
    //---- rectangle made relative to its grid.  Also, after the points, ----
    //---- there is a BYTE for each point signifying the grid id (0-8) ----
    //---- that each point lies within.  the grid is determined using ----
    //---- the original region with the background "margins".   This is ----
    //---- done to make scaling the points as fast as possible. ----

    if (! prd)                  // required
        return MakeError32(E_POINTER);

    //---- easy access variables ----
    int lw = pMargins->cxLeftWidth;
    int rw = pMargins->cxRightWidth;
    int th = pMargins->cyTopHeight;
    int bh = pMargins->cyBottomHeight;

    int iDestW = WIDTH(*prc);
    int iDestH = HEIGHT(*prc);

    //---- prevent left/right dest margins from overlapping ----
    FixMarginOverlaps(iDestW, &lw, &rw);

    //---- prevent top/bottom dest margins from overlapping ----
    FixMarginOverlaps(iDestH, &th, &bh);

    int lwFrom = lw;
    int rwFrom = pszSrcImage->cx - rw;
    int thFrom = th;
    int bhFrom = pszSrcImage->cy - bh;

    int lwTo = prc->left + lw;
    int rwTo = prc->right - rw;
    int thTo = prc->top + th;
    int bhTo = prc->bottom - bh;

    //---- compute offsets & factors ----
    int iLeftXOffset = prc->left;
    int iMiddleXOffset = lwTo;
    int iRightXOffset = rwTo;

    int iTopYOffset = prc->top;
    int iMiddleYOffset = thTo;
    int iBottomYOffset = bhTo;
        
    int iToMiddleWidth = rwTo - lwTo;
    int iFromMiddleWidth = rwFrom - lwFrom;
    int iToMiddleHeight = bhTo - thTo;
    int iFromMiddleHeight = bhFrom - thFrom;

    if (! iFromMiddleWidth)        // avoid divide by zero
    {
        //--- map point to x=0 ----
        iToMiddleWidth = 0;       
        iFromMiddleWidth = 1;
    }

    if (! iFromMiddleHeight)        // avoid divide by zero
    {
        //--- map point to y=0 ----
        iToMiddleHeight = 0;       
        iFromMiddleHeight = 1;
    }

    //---- clipping values for adjusted lw/rw/th/bh ----
    int lwMaxVal = __max(lw - 1, 0);
    int rwMinVal = __min(pMargins->cxRightWidth - rw, __max(pMargins->cxRightWidth-1, 0));
    int thMaxVal = __max(th - 1, 0);
    int bhMinVal = __min(pMargins->cyBottomHeight - bh, __max(pMargins->cyBottomHeight-1, 0));

    //---- allocte a buffer for the new points (rects) ----
    int newlen = sizeof(RGNDATAHEADER) + prd->rdh.nRgnSize;    // same # of rects
    BYTE *newData = (BYTE *)new BYTE[newlen];
    
    RGNDATA *prdNew = (RGNDATA *)newData;
    if (! prdNew)
        return MakeError32(E_OUTOFMEMORY);

    ZeroMemory(&prdNew->rdh, sizeof(prdNew->rdh));

    prdNew->rdh.dwSize = sizeof(prdNew->rdh);
    prdNew->rdh.iType  = RDH_RECTANGLES;
    int cRects         = prd->rdh.nCount;
    prdNew->rdh.nCount = cRects;
    SetRect(&prdNew->rdh.rcBound, -1, -1, -1, -1);

    //---- step thru our custom data (POINT + BYTE combos) ----
    POINT *pt     = (POINT *)prd->Buffer;
    BYTE *pByte   = (BYTE *)prd->Buffer + prd->rdh.nRgnSize;
    int cPoints   = 2 * cRects;
    POINT *ptNew  = (POINT *)prdNew->Buffer;

    for (int i=0; i < cPoints; i++, pt++, pByte++, ptNew++)        // transform each "point"
    {
        switch (*pByte)
        {
            //---- in the "don't scale" areas, we clip the translated values ----
            //---- for the case where the destination areas are too small ----
            //---- using the below "__min()" and "__max()" calls ----

            //---- remember: each point has been made 0-relative to its grid ----

            case GN_LEFTTOP:                 // left top
                ptNew->x = __min(pt->x, lwMaxVal) + iLeftXOffset;
                ptNew->y = __min(pt->y, thMaxVal) + iTopYOffset;
                break;

            case GN_MIDDLETOP:               // middle top
                ptNew->x = (pt->x*iToMiddleWidth)/iFromMiddleWidth + iMiddleXOffset;
                ptNew->y = __min(pt->y, thMaxVal) + iTopYOffset;
                break;

            case GN_RIGHTTOP:                // right top
                ptNew->x = __max(pt->x, rwMinVal) + iRightXOffset;
                ptNew->y = __min(pt->y, thMaxVal) + iTopYOffset;
                break;

            case GN_LEFTMIDDLE:              // left middle
                ptNew->x = __min(pt->x, lwMaxVal) + iLeftXOffset;
                ptNew->y = (pt->y*iToMiddleHeight)/iFromMiddleHeight + iMiddleYOffset;
                break;

            case GN_MIDDLEMIDDLE:            // middle middle
                ptNew->x = (pt->x*iToMiddleWidth)/iFromMiddleWidth + iMiddleXOffset;
                ptNew->y = (pt->y*iToMiddleHeight)/iFromMiddleHeight + iMiddleYOffset;
                break;

            case GN_RIGHTMIDDLE:             // right middle
                ptNew->x = __max(pt->x, rwMinVal) + iRightXOffset;
                ptNew->y = (pt->y*iToMiddleHeight)/iFromMiddleHeight + iMiddleYOffset;
                break;

            case GN_LEFTBOTTOM:              // left bottom
                ptNew->x = __min(pt->x, lwMaxVal) + iLeftXOffset;
                ptNew->y = __max(pt->y, bhMinVal) + iBottomYOffset;
                break;

            case GN_MIDDLEBOTTOM:             // middle bottom
                ptNew->x = (pt->x*iToMiddleWidth)/iFromMiddleWidth + iMiddleXOffset;
                ptNew->y = __max(pt->y, bhMinVal) + iBottomYOffset;
                break;

            case GN_RIGHTBOTTOM:              // right bottom
                ptNew->x = __max(pt->x, rwMinVal) + iRightXOffset;
                ptNew->y = __max(pt->y, bhMinVal) + iBottomYOffset;
                break;
        }
    }

    //---- compute bounding box of new region ----
    RECT *pRect = (RECT *)prdNew->Buffer;
    RECT newBox = {-1, -1, -1, -1};

    for (i=0; i < cRects; i++, pRect++)
        _InPlaceUnionRect(&newBox, pRect);

    //---- create the new region ----
    prdNew->rdh.rcBound = newBox;
    HRGN hrgn = ExtCreateRegion(NULL, newlen, prdNew);
    
    delete [] newData;          // free prdNew (aka newdata)
    if (! hrgn)
        return MakeErrorLast();

    *phrgn = hrgn;
    return S_OK;
}

//---------------------------------------------------------------------------------//
#ifdef DEBUG
void RegionDebug(
  HRGN hrgn)
{
    DWORD len = GetRegionData(hrgn, 0, NULL);       // get required length
    ATLASSERT(len);

    RGNDATA *pRgnData = (RGNDATA *) new BYTE[len + sizeof(RGNDATAHEADER)];
    DWORD len2 = GetRegionData(hrgn, len, pRgnData);
    ASSERT(len == len2);
    UNREFERENCED_PARAMETER(len2);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\scroll.h ===
#ifndef __SCROLL_H__
#define __SCROLL_H__

//-------------------------------------------------------------------------//
#ifndef WC_SCROLLBAR
// ScrollBar Ctl Class Name
#define WC_SCROLLBARW         L"UxScrollBar"
#define WC_SCROLLBARA         "UxScrollBar"

#ifdef UNICODE
#define WC_SCROLLBAR          WC_SCROLLBARW
#else
#define WC_SCROLLBAR          WC_SCROLLBARA
#endif
#endif WC_SCROLLBAR

//-------------------------------------------------------------------------//
//  Window scroll bar methods
void    WINAPI DrawSizeBox( HWND, HDC, int x, int y);
void    WINAPI DrawScrollBar( HWND, HDC, LPRECT, BOOL fVert);
HWND    WINAPI SizeBoxHwnd( HWND hwnd );
BOOL    WINAPI ScrollBar_MouseMove( HWND, LPPOINT, BOOL fVert);
VOID    WINAPI ScrollBar_Menu(HWND, HWND, LPARAM, BOOL fVert);
void    WINAPI HandleScrollCmd( HWND hwnd, WPARAM wParam, LPARAM lParam );
void    WINAPI DetachScrollBars( HWND hwnd );
void    WINAPI AttachScrollBars( HWND hwnd );
LONG    WINAPI ThemeSetScrollInfo( HWND, int, LPCSCROLLINFO, BOOL );
BOOL    WINAPI ThemeGetScrollInfo( HWND, int, LPSCROLLINFO );
BOOL    WINAPI ThemeEnableScrollBar( HWND, UINT, UINT );


#endif  //__SCROLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\scrollp.cpp ===
//-------------------------------------------------------------------------//
//  Module Name: scrollp.cpp
//  
//  Copyright (c) 1985 - 1999, Microsoft Corporation
//  
//  win32k->uxtheme port routines for scrollbar
//  
//  History:
//  03-21-00 ScottHan   Created
//-------------------------------------------------------------------------//
#include "stdafx.h"
#include "scrollp.h"

extern HBRUSH  _UxGrayBrush(VOID);
extern void    _UxFreeGDIResources();

enum {
    WF_STATE1 = 0,
    WF_STATE2,
    WF_EXSTYLE,
    WF_STYLE,
};

//-------------------------------------------------------------------------//
ULONG _ExpandWF( ULONG ulRaw, ULONG* pulField )
{
    ULONG ulField  = ( HIBYTE(ulRaw) & 0xFC ) >> 2;
    ULONG ulShift  = HIBYTE(ulRaw) & 0x03;
    ULONG ulResult = LOBYTE(ulRaw) << (ulShift << 3);
    if( pulField )
        *pulField  = ulField;
    return ulResult;
}

//-------------------------------------------------------------------------//
//  From usrctl32.h/.cpp
void SetWindowState(
    HWND hwnd,
    UINT flags)
{
    ULONG ulField;
    ULONG ulVal = _ExpandWF( flags, &ulField );

    if( WF_EXSTYLE == ulField || WF_STYLE == ulField)
    {
        ULONG dwBits = 0;
        ULONG dwGwl = (WF_EXSTYLE == ulField) ? GWL_EXSTYLE : 
                      (WF_STYLE   == ulField) ? GWL_STYLE : 0;
        UserAssert(dwGwl);

        dwBits = GetWindowLong( hwnd, dwGwl );

        if( (dwBits & ulVal) != ulVal )
            SetWindowLong(hwnd, dwGwl, dwBits | ulVal );
    }
}

//-------------------------------------------------------------------------//
//  From usrctl32.h/.cpp
void ClearWindowState(
    HWND hwnd,
    UINT flags)
{
    ULONG ulField;
    ULONG ulVal = _ExpandWF( flags, &ulField );

    if( WF_EXSTYLE == ulField || WF_STYLE == ulField)
    {
        ULONG dwBits = 0;
        ULONG dwGwl = (WF_EXSTYLE == ulField) ? GWL_EXSTYLE : 
                      (WF_STYLE   == ulField) ? GWL_STYLE : 0;
        UserAssert(dwGwl);

        dwBits = GetWindowLong( hwnd, dwGwl );

        if( (dwBits & ulVal) != ulVal )
            SetWindowLong(hwnd, dwGwl, dwBits &= ~ulVal );
    }
}

//-------------------------------------------------------------------------//
//  window bitfield discriminator (in lobyte of internal flags)
#define WF_SEL_STATE    0x00
#define WF_SEL_STATE2   0x04
#define WF_SEL_STYLE_EX 0x08
#define WF_SEL_STYLE    0x0C

#ifdef _WIN64
#undef GWL_WOWWORDS
#endif /* _WIN64 */
#define GWLP_WOWWORDS       (-1)
#define GCL_WOWWORDS        (-27)
#define GCL_WOWMENUNAME     (-29)
#ifdef _WIN64
#undef GCL_WOWWORDS
#endif /* _WIN64 */
#define GCLP_WOWWORDS       (-27)

LONG TestWF(HWND hwnd, DWORD flag)
{
    LPDWORD pdwWW;

    // GWLP_WOWWORDS returns a pointer to the WW struct in the hwnd.
    // We're interest in the first four DWORDS: state, state2, 
    // ExStyle (exposed, although not all bits, by GetWindowExStyle),
    // and style (exposed by GetWindowStyle). 
    //
    // The parameter flag, contains information on how to pick the field 
    // we want and how to build the WS_xxx or WS_EX_xxx we want to 
    // check for. 
    // 
    // See UsrCtl32.h for more details on how this is done. 
    //
    pdwWW = (LPDWORD)GetWindowLongPtr(hwnd, GWLP_WOWWORDS);
    if ( pdwWW )
    {
        INT  iField;     // the field we want
        INT  iShift;     // how many bytes to shift flag
        LONG ulMask;     // WS_xxx or WS_EX_xxx flag 

        iField = ( HIBYTE(flag) & 0xFC ) >> 2;
        iShift = HIBYTE(flag) & 0x03;
        ulMask = LOBYTE(flag) << (iShift << 3);

        UserAssert( 0 <= iField && iField < 4 );
        return pdwWW[iField] & ulMask;
    };

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\stdafx.h ===
//---------------------------------------------------------------------------
//  StdAfx.h - defines precompiled hdr set (doesn't use CrtDbgReport)
//---------------------------------------------------------------------------
#ifndef _STDAFX_UXTHEME_
#define _STDAFX_UXTHEME_
//---------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
//---------------------------------------------------------------------------
#include <wchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
//---------------------------------------------------------------------------
#define _ATL_NO_ATTRIBUTES
#define _ATL_APARTMENT_THREADED
//---------------------------------------------------------------------------
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <windows.h>
#include <winuser.h>
#include <winnls.h>
//---------------------------------------------------------------------------
#include <w4warn.h>
//---------------------------------------------------------------------------
#include <atlbase.h> 
//---------------------------------------------------------------------------
#define STRSAFE_LIB
#include <strsafe.h>
//---------------------------------------------------------------------------
#define _UXTHEME_
//#define __NO_APPHACKS__  // disables app hacks
//---------------------------------------------------------------------------
//---- keep this for a while (allows building on win2000 for home development) ----
#ifndef SPI_GETDROPSHADOW
#define SPI_GETDROPSHADOW                   0x1024
#define SPI_SETDROPSHADOW                   0x1025
#endif
//---------------------------------------------------------------------------
#include "autos.h"
#include "log.h"
#include "Errors.h"
#include "Utils.h"
#include "SimpStr.h"
#include "stringtable.h"
//---------------------------------------------------------------------------
#include "TmSchema.h"
#include <uxtheme.h>
#include <uxthemep.h>
#include "wrapper.h"

#undef  HKEY_CURRENT_USER
#define HKEY_CURRENT_USER   !!DO NOT USE HKEY_CURRENT_USER - USE CCurrentUser!!

#include "globals.h"
//---------------------------------------------------------------------------
#endif //_STDAFX_UXTHEME_
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\textdraw.cpp ===
//---------------------------------------------------------------------------
//  TextDraw.cpp - implements the drawing API for text
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Render.h"
#include "Utils.h"
#include "TextDraw.h"
#include "info.h"
#include "DrawHelp.h"

//---------------------------------------------------------------------------
HRESULT CTextDraw::PackProperties(CRenderObj *pRender, int iPartId, int iStateId)
{
    memset(this, 0, sizeof(CTextDraw));     // allowed because we have no vtable

    //---- save off partid, stateid for debugging ----
    _iSourcePartId = iPartId;
    _iSourceStateId = iStateId;

    if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_TEXTCOLOR, &_crText)))
        _crText = 0;          // default value
    
    //---- shadow ----
    if (SUCCEEDED(pRender->GetPosition(iPartId, iStateId, TMT_TEXTSHADOWOFFSET, &_ptShadowOffset)))
    {
        if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_TEXTSHADOWCOLOR, &_crShadow)))
            _crShadow = RGB(0, 0, 0);          // default value = black

        if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_TEXTSHADOWTYPE, (int *)&_eShadowType)))
            _eShadowType = TST_NONE;           // default value
    }

    //---- border ----
    if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_TEXTBORDERSIZE, &_iBorderSize)))
    {
        _iBorderSize = 0;
    }
    else
    {
        if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_TEXTBORDERCOLOR, &_crBorder)))
            _crBorder = RGB(0, 0, 0);     // default value
    }

    //---- font ----
    if (SUCCEEDED(pRender->GetFont(NULL, iPartId, iStateId, TMT_FONT, FALSE, &_lfFont)))
        _fHaveFont = TRUE;

    //---- edge colors ----
    if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_EDGELIGHTCOLOR, &_crEdgeLight)))
        _crEdgeLight = RGB(192, 192, 192);

    if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_EDGEHIGHLIGHTCOLOR, &_crEdgeHighlight)))
        _crEdgeHighlight = RGB(255, 255, 255);

    if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_EDGESHADOWCOLOR, &_crEdgeShadow)))
        _crEdgeShadow = RGB(128, 128, 128);

    if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_EDGEDKSHADOWCOLOR, &_crEdgeDkShadow)))
        _crEdgeDkShadow = RGB(0, 0, 0);

    if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_EDGEFILLCOLOR, &_crEdgeFill)))
        _crEdgeFill = _crEdgeLight;

    return S_OK;
}
//---------------------------------------------------------------------------
BOOL CTextDraw::KeyProperty(int iPropId)
{
    BOOL fKey = FALSE;

    switch (iPropId)
    {
        case TMT_TEXTCOLOR:
        case TMT_TEXTSHADOWOFFSET:
        case TMT_TEXTSHADOWCOLOR:
        case TMT_TEXTSHADOWTYPE:
        case TMT_TEXTBORDERSIZE:
        case TMT_TEXTBORDERCOLOR:
        case TMT_FONT:
        case TMT_EDGELIGHTCOLOR:
        case TMT_EDGEHIGHLIGHTCOLOR:
        case TMT_EDGESHADOWCOLOR:
        case TMT_EDGEDKSHADOWCOLOR:
        case TMT_EDGEFILLCOLOR:
            fKey = TRUE;
            break;
    }

    return fKey;
}
//---------------------------------------------------------------------------
void CTextDraw::DumpProperties(CSimpleFile *pFile, BYTE *pbThemeData, BOOL fFullInfo)
{
    if (fFullInfo)
        pFile->OutLine(L"Dump of CTextDraw at offset=0x%x", (BYTE *)this - pbThemeData);
    else
        pFile->OutLine(L"Dump of CTextDraw");
    
    pFile->OutLine(L"  _crText=0x%08x", _crText);

    pFile->OutLine(L"  _ptShadowOffset=(%d, %d)", _ptShadowOffset.x, _ptShadowOffset.y);

    pFile->OutLine(L"  _crEdgeLight=0x%08x, _crEdgeHighlight=0x%08x, _crEdgeShadow=0x%08x",
        _crEdgeLight, _crEdgeHighlight, _crEdgeShadow);

    pFile->OutLine(L"  _crEdgeDkShadow=0x%08x, _crEdgeFill=0x%08x, _crShadow=0x%08x",
        _crEdgeDkShadow, _crEdgeFill, _crShadow);

    pFile->OutLine(L"  _eShadowType, _iBorderSize=%d, _crBorder=0x%08x",
        _eShadowType, _iBorderSize, _crBorder);

    //---- dump resolution-independent font points ----
    int iFontPoints = FontPointSize(_lfFont.lfHeight);

    pFile->OutLine(L"  _fHaveFont=%d, font: %s, size=%d points, bold=%d, italic=%d",
        _fHaveFont, _lfFont.lfFaceName, iFontPoints, _lfFont.lfWeight > 400, _lfFont.lfItalic);
}
//---------------------------------------------------------------------------
HRESULT CTextDraw::DrawText(CRenderObj *pRender, HDC hdc, int iPartId, int iStateId, LPCWSTR _pszText, 
        DWORD dwCharCount, DWORD dwTextFlags, const RECT *pRect, const DTTOPTS *pOptions)
{
    Log(LOG_TM, L"DrawText(): iPartId=%d, pszText=%s", iPartId, _pszText);

    int iRetVal;
    HFONT hFont = NULL;
    COLORREF oldcolor = 0;

    HRESULT hr = S_OK;
    BOOL fOldColor = FALSE;
    RESOURCE HFONT oldfont = NULL;

    LPWSTR pszText = (LPWSTR)_pszText;      // so DrawText() calls are happy
    dwTextFlags &= ~(DT_MODIFYSTRING);      // we don't want to change the constant ptr

    int oldmode = SetBkMode(hdc, TRANSPARENT);
    RECT rect;

    COLORREF crText = _crText;
    COLORREF crBorder = _crBorder;
    COLORREF crShadow = _crShadow;

    TEXTSHADOWTYPE eShadowType = _eShadowType;
    POINT ptShadowOffset = _ptShadowOffset;
    int iBorderSize = _iBorderSize;

    if (pOptions)
    {
        DWORD dwFlags = pOptions->dwFlags;

        if (dwFlags & DTT_TEXTCOLOR)
            crText = pOptions->crText;

        if (dwFlags & DTT_BORDERCOLOR)
            crBorder = pOptions->crBorder;

        if (dwFlags & DTT_SHADOWCOLOR)
            crShadow = pOptions->crShadow;

        if (dwFlags & DTT_SHADOWTYPE)
            eShadowType = (TEXTSHADOWTYPE)pOptions->eTextShadowType;

        if (dwFlags & DTT_SHADOWOFFSET)
            ptShadowOffset = pOptions->ptShadowOffset;

        if (dwFlags & DTT_BORDERSIZE)
            iBorderSize = pOptions->iBorderSize;
    }

    BOOL fShadow = (eShadowType != TST_NONE);

    if (_fHaveFont)
    {
        hr = pRender->GetScaledFontHandle(hdc, &_lfFont, &hFont);
        if (FAILED(hr))
            goto exit;

        oldfont = (HFONT)SelectObject(hdc, hFont);
    }

    //---- BLURRED shadow approach ----
    if ((fShadow) && (eShadowType == TST_CONTINUOUS))   
    {
        SetRect(&rect, pRect->left, pRect->top, pRect->right, pRect->bottom);

        hr = EnsureUxCtrlLoaded();
        if (FAILED(hr))
            goto exit;

        //---- this will draw shadow & text (no outline support yet) ----
        iRetVal = CCDrawShadowText(hdc, pszText, dwCharCount, &rect, dwTextFlags, crText, crShadow,
            ptShadowOffset.x, ptShadowOffset.y);
    }
    else        //---- normal approach ----
    {
        //---- draw SINGLE shadow first ----
        if (fShadow) 
        {
            oldcolor = SetTextColor(hdc, crShadow);
            fOldColor = TRUE;

            //---- adjust rect for drawing shadow ----
            rect.left = pRect->left + ptShadowOffset.x;
            rect.top = pRect->top + ptShadowOffset.y;
            rect.right = pRect->right + ptShadowOffset.x;
            rect.bottom = pRect->bottom, ptShadowOffset.y;

            iRetVal = DrawTextEx(hdc, pszText, dwCharCount, &rect, dwTextFlags, NULL);
            if (! iRetVal)
            {
                hr = MakeErrorLast();
                goto exit;
            }
        }
        SetRect(&rect, pRect->left, pRect->top, pRect->right, pRect->bottom);

        //---- draw outline, if wanted ----
        if (iBorderSize)        // draw outline around text
        {
            iRetVal = BeginPath(hdc);
            if (! iRetVal)
            {
                hr = MakeErrorLast();
                goto exit;
            }

            iRetVal = DrawTextEx(hdc, pszText, dwCharCount, &rect, dwTextFlags, NULL);
            if (! iRetVal)
            {
                AbortPath(hdc);
                hr = MakeErrorLast();
                goto exit;
            }

            EndPath(hdc);

            HPEN pen, oldpen;
            HBRUSH brush, oldbrush;

            pen = CreatePen(PS_SOLID, iBorderSize, crBorder);
            brush = CreateSolidBrush(crText);
            if ((pen) && (brush))
            {
                oldpen = (HPEN)SelectObject(hdc, pen);
                oldbrush = (HBRUSH)SelectObject(hdc, brush);

                //---- this draws both outline & normal text ---
                StrokeAndFillPath(hdc);

                SelectObject(hdc, oldpen);
                SelectObject(hdc, oldbrush);
            }
        }
        else                    // draw normal text
        {
            if (fOldColor)
                SetTextColor(hdc, crText);
            else
            {
                oldcolor = SetTextColor(hdc, crText);
                fOldColor = TRUE;
            }

            iRetVal = DrawTextEx(hdc, pszText, dwCharCount, &rect, dwTextFlags, NULL);
            if (! iRetVal)
            {
                hr = MakeErrorLast();
                goto exit;
            }
        }
    }


    hr = S_OK;

exit:
    //---- restore hdc objects ----
    SetBkMode(hdc, oldmode);

    if (fOldColor)
        SetTextColor(hdc, oldcolor);

    if (oldfont)
        SelectObject(hdc, oldfont);

    if (hFont)
        pRender->ReturnFontHandle(hFont);

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CTextDraw::GetTextExtent(CRenderObj *pRender, HDC hdc, int iPartId, int iStateId, LPCWSTR _pszText, 
    int iCharCount, DWORD dwTextFlags, const RECT *pBoundingRect, RECT *pExtentRect)
{
    LPWSTR pszText = (LPWSTR)_pszText;      // so DrawText() calls are happy
    dwTextFlags &= ~(DT_MODIFYSTRING);      // we don't want to change the constant ptr

    Log(LOG_TM, L"GetTextExtent(): iPartId=%d, pszText=%s", iPartId, pszText);

    RESOURCE HFONT oldfont = NULL;
    HFONT hFont = NULL;
    HRESULT hr = S_OK;

    if (_fHaveFont)
    {
        hr = pRender->GetScaledFontHandle(hdc, &_lfFont, &hFont);
        if (FAILED(hr))
            goto exit;

        oldfont = (HFONT)SelectObject(hdc, hFont);
    }

    RECT rect;
    int iRetVal;

    if (pBoundingRect)
        rect = *pBoundingRect;
    else
        SetRect(&rect, 0, 0, 0, 0);

    iRetVal = DrawTextEx(hdc, pszText, iCharCount, &rect, dwTextFlags | DT_CALCRECT, NULL);
    if (! iRetVal)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    //----do NOT adjust for text shadow (ok if shadows overlap...) ----

    *pExtentRect = rect;

exit:
    //---- restore hdc objects ----
    if (oldfont)
        SelectObject(hdc, oldfont);

    Log(LOG_TM, L"END Of GetTextExtent()");

    if (hFont)
        pRender->ReturnFontHandle(hFont);

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CTextDraw::GetTextMetrics(CRenderObj *pRender, HDC hdc, int iPartId, int iStateId, TEXTMETRIC* ptm)
{
    Log(LOG_TM, L"GetTextMetrics(): iPartId=%d, ", iPartId);

    HRESULT hr = S_OK;
    RESOURCE HFONT hFont = NULL;
    RESOURCE HFONT oldfont = NULL;

    if (! ptm)
    {
        hr = MakeError32(E_INVALIDARG);
        goto exit;
    }

    if (_fHaveFont)
    {
        hr = pRender->GetScaledFontHandle(hdc, &_lfFont, &hFont);
        if (FAILED(hr))
            goto exit;

        oldfont = (HFONT)SelectObject(hdc, hFont);
    }

    if (! ::GetTextMetrics(hdc, ptm))
    {
        hr = MakeErrorLast();
        goto exit;
    }

exit:
    //---- restore hdc objects ----
    if (oldfont)
        SelectObject(hdc, oldfont);

    if (hFont)
        pRender->ReturnFontHandle(hFont);

    Log(LOG_TM, L"END Of GetTextMetrics()");
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CTextDraw::DrawEdge(CRenderObj *pRender, HDC hdc, int iPartId, int iStateId, const RECT *pDestRect, 
    UINT uEdge, UINT uFlags, OUT RECT *pContentRect)
{
    Log(LOG_TM, L"DrawEdge(): iPartId=%d, iStateId=%d, uEdge=0x%08x, uFlags=0x%08x", iPartId, iStateId, uEdge, uFlags);
    HRESULT hr = _DrawEdge(hdc, pDestRect, uEdge, uFlags, 
        _crEdgeLight, _crEdgeHighlight, _crEdgeShadow, _crEdgeDkShadow, _crEdgeFill, pContentRect);
    Log(LOG_TM, L"END Of DrawEdge()");
    return hr;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\scrollp.h ===
//-------------------------------------------------------------------------//
//  
//  scrollp.h
//
//  Definitions and decls used exclusively by the win32K->uxtheme scrollbar 
//  port for non-client theming.  Many of the same definitions are duplicated in 
//  usrctl32.h for base control ports to comctl [scotthan]
//
//-------------------------------------------------------------------------//
#ifndef __SCROLLPORT_H__
#define __SCROLLPORT_H__

#define SIF_RETURNOLDPOS        0x1000

#define SB_DISABLE_MASK         ESB_DISABLE_BOTH
#define abs(x)                  (((x)<0) ? -1 * x : x)
#define TEST_FLAG(dw,f)         ((BOOL)((dw) & (f)))
#define SYSMET(i)               NcGetSystemMetrics( SM_##i )
#define SYSMETRTL(i)            NcGetSystemMetrics( SM_##i )
#define SYSRGB(i)               GetSysColor(COLOR_##i)
#define SYSRGBRTL(i)            GetSysColor(COLOR_##i)
#define SYSHBR(i)               GetSysColorBrush(COLOR_##i)

#define UserAssert(x)

#define SelectBrush             (HBRUSH)SelectObject
#define GetWindowStyle(hwnd)    GetWindowLong(hwnd,GWL_STYLE)
#define GetWindowExStyle(hwnd)  GetWindowLong(hwnd,GWL_EXSTYLE)

//  lparam->point crackers from user.h
#ifndef GET_X_LPARAM
#define GET_X_LPARAM(lp)    ((int)(short)LOWORD(lp))
#endif
#ifndef GET_Y_LPARAM
#define GET_Y_LPARAM(lp)    ((int)(short)HIWORD(lp))

// from comctl32 v6
#define MSAA_CLASSNAMEIDX_SCROLLBAR (65536L + 10)
#endif

//-------------------------------------------------------------------------//
//  private DrawFrameControl values (winuserp.h)
//#define DFC_CACHE               0xFFFF
//#define DFCS_INMENU             0x0040
//#define DFCS_INSMALL            0x0080
#define DFCS_SCROLLMIN          0x0000
#define DFCS_SCROLLVERT         0x0000
#define DFCS_SCROLLMAX          0x0001
#define DFCS_SCROLLHORZ         0x0002
//#define DFCS_SCROLLLINE         0x0004

//-------------------------------------------------------------------------//
//  internal window state/style bits
#define WFMPRESENT              0x0001
#ifndef _UXTHEME_
#define WFVPRESENT              0x0002
#define WFHPRESENT              0x0004
#else _UXTHEME_
#define WFVPRESENT              WFVSCROLL /*0x0002*/
#define WFHPRESENT              WFHSCROLL /*0x0004*/
#endif _UXTHEME_
#define WFCPRESENT              0x0008
#define WFFRAMEPRESENTMASK      0x000F

#define WFSENDSIZEMOVE          0x0010
#define WFMSGBOX                0x0020  // used to maintain count of msg boxes on screen
#define WFFRAMEON               0x0040
#define WFHASSPB                0x0080
#define WFNONCPAINT             0x0101
#define WFSENDERASEBKGND        0x0102
#define WFERASEBKGND            0x0104
#define WFSENDNCPAINT           0x0108
#define WFINTERNALPAINT         0x0110
#define WFUPDATEDIRTY           0x0120
#define WFHIDDENPOPUP           0x0140
#define WFMENUDRAW              0x0180

/*
 * NOTE -- WFDIALOGWINDOW is used in WOW.  DO NOT CHANGE without
 *   changing WD_DIALOG_WINDOW in winuser.w
 */
#define WFDIALOGWINDOW          0x0201

#define WFTITLESET              0x0202
#define WFSERVERSIDEPROC        0x0204
#define WFANSIPROC              0x0208
#define WFBEINGACTIVATED        0x0210  // prevent recursion in xxxActivateThis Window
#define WFHASPALETTE            0x0220
#define WFPAINTNOTPROCESSED     0x0240  // WM_PAINT message not processed
#define WFSYNCPAINTPENDING      0x0280
#define WFGOTQUERYSUSPENDMSG    0x0301
#define WFGOTSUSPENDMSG         0x0302
#define WFTOGGLETOPMOST         0x0304  // Toggle the WS_EX_TOPMOST bit ChangeStates

/*
 * DON'T MOVE REDRAWIFHUNGFLAGS WITHOUT ADJUSTING WFANYHUNGREDRAW
 */
#define WFREDRAWIFHUNG          0x0308
#define WFREDRAWFRAMEIFHUNG     0x0310
#define WFANYHUNGREDRAW         0x0318

#define WFANSICREATOR           0x0320
#define WFREALLYMAXIMIZABLE     0x0340  // The window fills the work area or monitor when maximized
#define WFDESTROYED             0x0380
#define WFWMPAINTSENT           0x0401
#define WFDONTVALIDATE          0x0402
#define WFSTARTPAINT            0x0404
#define WFOLDUI                 0x0408
#define WFCEPRESENT             0x0410  // Client edge present
#define WFBOTTOMMOST            0x0420  // Bottommost window
#define WFFULLSCREEN            0x0440
#define WFINDESTROY             0x0480

/*
 * DON'T MOVE ANY ONE OF THE FOLLOWING WFWINXXCOMPAT FLAGS,
 * BECAUSE WFWINCOMPATMASK DEPENDS ON THEIR VALUES
 */
#define WFWIN31COMPAT           0x0501  // Win 3.1 compatible window
#define WFWIN40COMPAT           0x0502  // Win 4.0 compatible window
#define WFWIN50COMPAT           0x0504  // Win 5.0 compatibile window
#define WFWINCOMPATMASK         0x0507  // Compatibility flag mask

#define WFMAXFAKEREGIONAL       0x0508  // Window has a fake region for maxing on 1 monitor

// Active Accessibility (Window Event) state
#define WFCLOSEBUTTONDOWN       0x0510
#define WFZOOMBUTTONDOWN        0x0520
#define WFREDUCEBUTTONDOWN      0x0540
#define WFHELPBUTTONDOWN        0x0580
#define WFLINEUPBUTTONDOWN      0x0601  // Line up/left scroll button down
#define WFPAGEUPBUTTONDOWN      0x0602  // Page up/left scroll area down
#define WFPAGEDNBUTTONDOWN      0x0604  // Page down/right scroll area down
#define WFLINEDNBUTTONDOWN      0x0608  // Line down/right scroll area down
#define WFSCROLLBUTTONDOWN      0x0610  // Any scroll button down?
#define WFVERTSCROLLTRACK       0x0620  // Vertical or horizontal scroll track...

#define WFALWAYSSENDNCPAINT     0x0640  // Always send WM_NCPAINT to children
#define WFPIXIEHACK             0x0680  // Send (HRGN)1 to WM_NCPAINT (see PixieHack)

/*
 * WFFULLSCREENBASE MUST HAVE LOWORD OF 0. See SetFullScreen macro.
 */
#define WFFULLSCREENBASE        0x0700  // Fullscreen flags take up 0x0701
#define WFFULLSCREENMASK        0x0707  // and 0x0702 and 0x0704
#define WEFTRUNCATEDCAPTION     0x0708  // The caption text was truncated -> caption tootip

#define WFNOANIMATE             0x0710  // ???
#define WFSMQUERYDRAGICON       0x0720  // ??? Small icon comes from WM_QUERYDRAGICON
#define WFSHELLHOOKWND          0x0740  // ???
#define WFISINITIALIZED         0x0780  // Window is initialized -- checked by WoW32

/*
 * Add more state flags here, up to 0x0780.
 * Look for empty slots above before adding to the end.
 * Be sure to add the flag to the wFlags array in kd\userexts.c
 */

/*
 * Window Extended Style, from 0x0800 to 0x0B80.
 */
#define WEFDLGMODALFRAME        0x0801  // WS_EX_DLGMODALFRAME
#define WEFDRAGOBJECT           0x0802  // ???
#define WEFNOPARENTNOTIFY       0x0804  // WS_EX_NOPARENTNOTIFY
#define WEFTOPMOST              0x0808  // WS_EX_TOPMOST
#define WEFACCEPTFILES          0x0810  // WS_EX_ACCEPTFILES
#define WEFTRANSPARENT          0x0820  // WS_EX_TRANSPARENT
#define WEFMDICHILD             0x0840  // WS_EX_MDICHILD
#define WEFTOOLWINDOW           0x0880  // WS_EX_TOOLWINDOW
#define WEFWINDOWEDGE           0x0901  // WS_EX_WINDOWEDGE
#define WEFCLIENTEDGE           0x0902  // WS_EX_CLIENTEDGE
#define WEFEDGEMASK             0x0903  // WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE
#define WEFCONTEXTHELP          0x0904  // WS_EX_CONTEXTHELP


// intl styles
#define WEFRIGHT                0x0910  // WS_EX_RIGHT
#define WEFRTLREADING           0x0920  // WS_EX_RTLREADING
#define WEFLEFTSCROLL           0x0940  // WS_EX_LEFTSCROLLBAR


#define WEFCONTROLPARENT        0x0A01  // WS_EX_CONTROLPARENT
#define WEFSTATICEDGE           0x0A02  // WS_EX_STATICEDGE
#define WEFAPPWINDOW            0x0A04  // WS_EX_APPWINDOW
#define WEFLAYERED              0x0A08  // WS_EX_LAYERED

#ifdef USE_MIRRORING
#define WEFNOINHERITLAYOUT      0x0A10  // WS_EX_NOINHERITLAYOUT
#define WEFLAYOUTVBHRESERVED    0x0A20  // WS_EX_LAYOUTVBHRESERVED
#define WEFLAYOUTRTL            0x0A40  // WS_EX_LAYOUTRTL
#define WEFLAYOUTBTTRESERVED    0x0A80  // WS_EX_LAYOUTBTTRESERVED
#endif

/*
 * To delay adding a new state3 DWORD in the WW structure, we're using
 * the extended style bits for now.  If we'll need more of these, we'll
 * add the new DWORD and move these ones around
 */
#define WEFPUIFOCUSHIDDEN         0x0B80  // focus indicators hidden
#define WEFPUIACCELHIDDEN         0x0B40  // keyboard acceleraors hidden
#define WEFPREDIRECTED            0x0B20  // redirection bit
#define WEFPCOMPOSITING           0x0B10  // compositing

/*
 * Add more Window Extended Style flags here, up to 0x0B80.
 * Be sure to add the flag to the wFlags array in kd\userexts.c
 */
#ifdef REDIRECTION
#define WEFMSR                  0x0B01   // WS_EX_MSR
#endif // REDIRECTION

#define WEFCOMPOSITED           0x0B02   // WS_EX_COMPOSITED
#define WEFNOACTIVATE           0x0B08   // WS_EX_NOACTIVATE

#ifdef LAME_BUTTON
#define WEFLAMEBUTTONON         0x0908   // the "comments" button is displayed
#endif // LAME_BUTTON

/*
 * Window styles, from 0x0E00 to 0x0F80.
 */
#define WFMAXBOX                0x0E01  // WS_MAXIMIZEBOX
#define WFTABSTOP               0x0E01  // WS_TABSTOP
#define WFMINBOX                0x0E02  // WS_MAXIMIZEBOX
#define WFGROUP                 0x0E02  // WS_GROUP
#define WFSIZEBOX               0x0E04  // WS_THICKFRAME, WS_SIZEBOX
#define WFSYSMENU               0x0E08  // WS_SYSMENU
#define WFHSCROLL               0x0E10  // WS_HSCROLL
#define WFVSCROLL               0x0E20  // WS_VSCROLL
#define WFDLGFRAME              0x0E40  // WS_DLGFRAME
#define WFTOPLEVEL              0x0E40  // ???
#define WFBORDER                0x0E80  // WS_BORDER
#define WFBORDERMASK            0x0EC0  // WS_BORDER | WS_DLGFRAME
#define WFCAPTION               0x0EC0  // WS_CAPTION

#define WFTILED                 0x0F00  // WS_OVERLAPPED, WS_TILED
#define WFMAXIMIZED             0x0F01  // WS_MAXIMIZE
#define WFCLIPCHILDREN          0x0F02  // WS_CLIPCHILDREN
#define WFCLIPSIBLINGS          0x0F04  // WS_CLIPSIBLINGS
#define WFDISABLED              0x0F08  // WS_DISABLED
#define WFVISIBLE               0x0F10  // WS_VISIBLE
#define WFMINIMIZED             0x0F20  // WS_MINIMIZE
#define WFCHILD                 0x0F40  // WS_CHILD
#define WFPOPUP                 0x0F80  // WS_POPUP
#define WFTYPEMASK              0x0FC0  // WS_CHILD | WS_POPUP
#define WFICONICPOPUP           0x0FC0  // WS_CHILD | WS_POPUP
#define WFICONIC                WFMINIMIZED

#define CheckMsgFilter(wMsg, wMsgFilterMin, wMsgFilterMax)                 \
    (   ((wMsgFilterMin) == 0 && (wMsgFilterMax) == 0xFFFFFFFF)            \
     || (  ((wMsgFilterMin) > (wMsgFilterMax))                             \
         ? (((wMsg) <  (wMsgFilterMax)) || ((wMsg) >  (wMsgFilterMin)))    \
         : (((wMsg) >= (wMsgFilterMin)) && ((wMsg) <= (wMsgFilterMax)))))

#define SYS_ALTERNATE           0x2000
#define SYS_PREVKEYSTATE        0x4000

//-------------------------------------------------------------------------//
//  Utility fn forwards.
LONG          TestWF(HWND hwnd, DWORD flag);
void          SetWindowState( HWND hwnd, UINT flags);
void          ClearWindowState( HWND hwnd, UINT flags);


#endif  __SCROLLPORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\sethook.cpp ===
//---------------------------------------------------------------------------//
//  sethook.cpp - Window and DefWindowProc hooking impl.
//---------------------------------------------------------------------------//
#include "stdafx.h"
#include "sethook.h"
#include "handlers.h"
#include "scroll.h"
#include "nctheme.h"
#include "scroll.h"
#include <uxthemep.h>
#include "info.h"
#include "services.h"
#include "appinfo.h"
#include "tmreg.h"
#include "globals.h"
#include "renderlist.h"

//---------------------------------------------------//
//  statics
//---------------------------------------------------//
static int    _fShouldEnableApiHooks  = -1; // unitialized value
static BOOL   _fUnhooking             = FALSE;
static LONG   _cInitUAH      = 0;

static BOOL   _fSysMetCall            = FALSE; // anti-recursion bit on classic sysmet calls.
static CRITICAL_SECTION _csSysMetCall = {0};   // serialize ClassicXXX calls when hooks inactive.

typedef enum { PRE, DEF, POST } ePROCTYPE;

inline void ENTER_CLASSICSYSMETCALL()   { 
    if (IsAppThemed())
    {
        if( VALID_CRITICALSECTION(&_csSysMetCall) )
        {
            EnterCriticalSection(&_csSysMetCall); 
            _fSysMetCall = TRUE; 
        }
    }
}
inline void LEAVE_CLASSICSYSMETCALL()   { 
    if (_fSysMetCall)
    {
        _fSysMetCall = FALSE; 
        SAFE_LEAVECRITICALSECTION(&_csSysMetCall); 
    }
}
inline BOOL IN_CLASSICSYSMETCALL() { 
    return _fSysMetCall;
}

//---------------------------------------------------------------------------//
typedef struct
{
    HINSTANCE       hInst;          // DLL hook instance
    USERAPIHOOK     uahReal;
} UXTHEMEHOOKS, *PUXTHEMEHOOKS;
//--------------------------------------------------------------------//

//---- Hook Instance static (unprotected - thread unsafe) ----
static UXTHEMEHOOKS  _hookinf = {0};   // one-and-only instance.

//---------------------------------------------------------------------------//
//  UserApiHook callback functions
extern "C" 
{
BOOL WINAPI      ThemeInitApiHook( DWORD dwCmd, void * pvData );
LRESULT WINAPI   ThemeDefWindowProcA( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
LRESULT CALLBACK ThemeDefWindowProcW( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
int  CALLBACK    ThemeSetScrollInfoProc( HWND hwnd, int nBar, IN LPCSCROLLINFO psi, BOOL fRedraw );
BOOL CALLBACK    ThemeGetScrollInfoProc( HWND hwnd, int nBar, IN OUT LPSCROLLINFO psi );
BOOL CALLBACK    ThemeEnableScrollInfoProc( HWND hwnd, UINT nSBFlags, UINT nArrows );
BOOL CALLBACK    ThemeAdjustWindowRectEx( LPRECT lprc, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle);
BOOL CALLBACK    ThemeSetWindowRgn( HWND hwnd, HRGN hrgn, BOOL fRedraw);
int  CALLBACK    ThemeGetSystemMetrics( int iMetric );
BOOL CALLBACK    ThemeSystemParametersInfoA( UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
BOOL CALLBACK    ThemeSystemParametersInfoW( UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
BOOL CALLBACK    ThemeDrawFrameControl( IN HDC hdc, IN OUT LPRECT, IN UINT, IN UINT );
BOOL CALLBACK    ThemeDrawCaption( IN HWND, IN HDC, IN CONST RECT *, IN UINT);
VOID CALLBACK    ThemeMDIRedrawFrame( IN HWND hwndChild, BOOL fAdd );
}

//---------------------------------------------------------------------------//
void OnHooksEnabled();                                  // forward
void OnHooksDisabled(BOOL fShutDown);                   // forward
BOOL NewThemeCheck(int iChangeNum, BOOL fMsgCheck);     // forward
//---------------------------------------------------------------------------//
BOOL WINAPI ThemeHookStartup()
{
    _hookinf.uahReal.cbSize = sizeof(_hookinf.uahReal);
    HandlerTableInit();

    BOOL fRet = InitializeCriticalSectionAndSpinCount(&_csSysMetCall, 0) &&
                InitializeCriticalSectionAndSpinCount(&_csThemeMet, 0)   &&
                InitializeCriticalSectionAndSpinCount(&_csNcSysMet, 0)   &&
                InitializeCriticalSectionAndSpinCount(&_csNcPaint, 0);

    InitNcThemeMetrics(NULL);

    Log(LOG_TMCHANGE, L"UxTheme - ThemeHookStartup");

    if( !fRet )
    {
        SAFE_DELETECRITICALSECTION(&_csSysMetCall);
        SAFE_DELETECRITICALSECTION(&_csThemeMet);
        SAFE_DELETECRITICALSECTION(&_csNcSysMet);
        SAFE_DELETECRITICALSECTION(&_csNcPaint);
    }

    WindowDump(L"Startup");

    return fRet;
}

//---------------------------------------------------------------------------//
BOOL WINAPI ThemeHookShutdown()
{
    _fUnhooking = TRUE;
    
    if (HOOKSACTIVE())        // we are hooking USER msgs
    {
        //---- tell user that we gotta go ----
        _hookinf.uahReal.pfnForceResetUserApiHook(g_hInst);
        InterlockedExchange( (LONG*)&g_eThemeHookState, HS_UNINITIALIZED );
        OnHooksDisabled(TRUE);
    }

    SAFE_DELETECRITICALSECTION( &_csSysMetCall );
    SAFE_DELETECRITICALSECTION( &_csThemeMet );
    SAFE_DELETECRITICALSECTION( &_csNcSysMet );
    SAFE_DELETECRITICALSECTION( &_csNcPaint );

    ClearNcThemeMetrics();
    NcClearNonclientMetrics();


#ifdef DEBUG
    CThemeWnd::SpewLeaks();
#endif DEBUG

    return TRUE;
}

//---------------------------------------------------------------------------//
//  Loads a DLL instance and retrieves addresses of key hook exports.
BOOL LoadHookInstance()
{
    if( _hookinf.hInst != NULL )
    {
#ifdef DEBUG
        Log(LOG_ALWAYS, L"UAH hosting module instance already protected; refcount mismatch. No-op'ing self-load\n");
#endif DEBUG
        return TRUE;
    }

    //-- Increment our dll refcount
    _hookinf.hInst = LoadLibrary(L"uxtheme.dll");
    if( !_hookinf.hInst )
    {
        Log(LOG_ALWAYS, L"Cannot find UAH hosting module instance.\r\r\n");
        return FALSE;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
inline BOOL IsTargetProcess(HWND hwnd = NULL)
{
    //---- if not initialize, leave everything alone ----
    if (! g_fUxthemeInitialized)
        return FALSE;

    //---- ensure this window is in our process ----
    return (HOOKSACTIVE() && (hwnd ? IsWindowProcess(hwnd, g_dwProcessId) : TRUE));
}

//---------------------------------------------------------------------------
inline void SpewHookExceptionInfo( 
    LPCSTR pszMsg, 
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam )
{
#ifdef _ENABLE_HOOK_EXCEPTION_HANDLING_
    Log(LOG_ERROR, L"*** Theme Hook Exception Handler ***" );
    Log(LOG_ERROR, L"--- %s hwnd: %08lX, uMsg: %04lX, wParam: %08lX, lParam: %08lX.",
        pszMsg, hwnd, uMsg, wParam, lParam );
#endif _ENABLE_HOOK_EXCEPTION_HANDLING_
}

//---------------------------------------------------------------------------
//  Helper: initializes THEME_MSG structure in prep for call to msg handler
inline void _InitThemeMsg(
    PTHEME_MSG ptm,
    MSGTYPE    msgtype,
    BOOL       bUnicode,
    HWND       hwnd,
    UINT       uMsg,
    WPARAM     wParam,
    LPARAM     lParam,
    LRESULT    lRet = 0,
    WNDPROC    pfnDefProc = NULL )
{
#ifdef DEBUG
    if( MSGTYPE_DEFWNDPROC == msgtype )
    {
        ASSERT( pfnDefProc != NULL ); // DWP, handlers require default processing
    }
    else
    {
        ASSERT( NULL == pfnDefProc ); // no default processing for pre/post OWP, DDP callbacks
    }
#endif DEBUG

    ptm->hwnd       = hwnd;
    ptm->uMsg       = uMsg;
    ptm->uCodePage  = bUnicode ? CP_WINUNICODE : GetACP();
    ptm->wParam     = wParam;
    ptm->lParam     = lParam;
    ptm->type       = msgtype;
    ptm->lRet       = lRet;
    ptm->pfnDefProc = pfnDefProc;
    ptm->fHandled   = FALSE;
}

//---------------------------------------------------------------------------
#ifdef UNICODE
    const BOOL _fUnicode = TRUE;
#else  // UNICODE
    const BOOL _fUnicode = FALSE;
#endif // UNICODE

//---------------------------------------------------------------------------
void _PreprocessThemeChanged(HWND hwnd, WPARAM wParam, LPARAM lParam, ePROCTYPE eCallType,
    UINT *puDisposition)
{
    //---- is this msg meant for this process? ----
    if (IS_THEME_CHANGE_TARGET(lParam))
    {
        BOOL fActive = ((lParam & WTC_THEMEACTIVE) != 0);

        if (eCallType == PRE)           // only do this on the Pre (once is enough)
        {
            //Log(LOG_TMCHANGE, L"hwnd=0x%x received WM_THEMECHANGED, changenum=0x%x", 
            //    hwnd, wParam);

            ClearExStyleBits(hwnd);
        }

        //---- this part still needs to be done in both cases ----
        if(! (fActive))
            *puDisposition |= HMD_THEMEDETACH;
        else 
            *puDisposition |= HMD_CHANGETHEME;
    }
}
//---------------------------------------------------------------------------
BOOL CALLBACK TriggerCallback(HWND hwnd, LPARAM lParam)
{
    LPARAM *plParams = (LPARAM *)lParam;
    
    SafeSendMessage(hwnd, WM_THEMECHANGED, plParams[0], plParams[1]);

    return TRUE;
}
//---------------------------------------------------------------------------
void _PreprocessThemeChangedTrigger(HWND hwnd, WPARAM wParam, LPARAM lParamMixed) 
{
    int iLoadId = (int(lParamMixed) >> 4);
    LPARAM lParamBits = (int(lParamMixed) & 0xf);

    BOOL fFirstMsg = NewThemeCheck((int)wParam, TRUE);
    if (fFirstMsg)
    {
        //Log(LOG_TMLOAD, L"hwnd=0x%x received NEW WM_THEMECHANGED_TRIGGER, loadid=%d", hwnd, 
        //    iLoadId);

        //---- send WM_THEMECHANGED to all windows in this process ----
        //---- so they let go of previous theme now ----
        LPARAM lParams[2] = {wParam, lParamBits};
        EnumProcessWindows(TriggerCallback, (LPARAM)&lParams);

        if (iLoadId)      // there was a previous theme
        {
            g_pRenderList->FreeRenderObjects(iLoadId);
        }
    }
}
//---------------------------------------------------------------------------
inline UINT _PreprocessHookedMsg( 
    HWND hwnd,
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    ePROCTYPE eCallType )
{
    UINT uDisposition = HMD_NIL;
    static bool s_fTriggerDone = false; // For some USER-owned windows, we don't get PRE, only DEF.

    switch( uMsg )
    {
        case WM_THEMECHANGED:
        {
            _PreprocessThemeChanged(hwnd, wParam, lParam, eCallType, &uDisposition);
            break;
        }

        case WM_NCDESTROY:
            uDisposition |= HMD_WINDOWDESTROY;
            break;

        case WM_STYLECHANGED:
            uDisposition |= HMD_REATTACH;
            break;

        case WM_THEMECHANGED_TRIGGER:
            //---- NULL WPARAM means this is really a normal WM_UAHINIT msgs (shared msg num) ----
            if (wParam)
            {
                if (eCallType == PRE                            // This is the normal case
                    || (eCallType == DEF && !s_fTriggerDone))   // USER server-side window, we missed the PRE
                {
                    Log(LOG_TMCHANGE, L"Recv'd: WM_THEMECHANGED_TRIGGER, Change Num=%d", wParam);

                    _PreprocessThemeChangedTrigger(hwnd, wParam, lParam);
                }
                if (eCallType == PRE) // Mark it done for the incoming DEF call
                {
                    s_fTriggerDone = true;
                }
                else // After we're done, reset the flag for the next theme change
                {
                    s_fTriggerDone = false;
                }
            }
            break;
    }
            
    return uDisposition;
}

//---------------------------------------------------------------------------
//  Pre-CallWndProc hook procedure
BOOL CALLBACK ThemePreWndProc( 
    HWND     hwnd, 
    UINT     uMsg, 
    WPARAM   wParam, 
    LPARAM   lParam, 
    LRESULT* plRes,
    VOID**   ppvParam )
{
    //  Note: From this point until the point we invoke a message handler,
    //  We need to take care that we don't do anything (including DEBUG-only code) 
    //  that causes a message to be sent to the window.
    BOOL fHandled = FALSE;

    //----------//
    LogEntryMsg(L"ThemePreWndProc", hwnd, uMsg);

    if( IsTargetProcess(hwnd) ) 
    {
        //  Retrieve window object from handle
        CThemeWnd *pwnd = CThemeWnd::FromHwnd(hwnd);

        //  #443100 InstallShield installs a global CBT hook. Their hook handler
        //  generates messages prior to the window receiving WM_NCCREATE which 
        //  causes us to exile the window prematurely because the window is temporarily
        //  parented by HWND_MESSAGE
        BOOL fPrematureExile = (EXILED_THEMEWND(pwnd) && WM_NCCREATE == uMsg);

        if ( (uMsg != WM_NCCREATE) || fPrematureExile )
        {
            //  Pre-process WM_THEMECHANGE message.
            //  Note: Pre-OWP does a detach only on theme removal.   Post-OWP takes care
            //        of window death.
            UINT uDisp        = _PreprocessHookedMsg( hwnd, uMsg, wParam, lParam, PRE );
            BOOL fLifeIsShort = TESTFLAG( uDisp, HMD_THEMEDETACH|HMD_WINDOWDESTROY );
            BOOL fDetach      = TESTFLAG( uDisp, HMD_THEMEDETACH );


            if( _WindowHasTheme(hwnd) || fLifeIsShort )
            {
                //  On STYLECHANGED or WM_THEMECHANGE, 
                //  try reattaching window that was previously rejected or failed, resp.
                if( (REJECTED_THEMEWND(pwnd) && TESTFLAG(uDisp, HMD_REATTACH)) ||
                    (FAILED_THEMEWND(pwnd) && WM_THEMECHANGED == uMsg) ||
                    fPrematureExile )
                {
                    CThemeWnd::Detach(hwnd, FALSE); // remove rejection tag.
                    pwnd = NULL;
                }
                                
                //  Attach window object if applicable.
                if( pwnd == THEMEWND_NIL && !(fLifeIsShort || _fUnhooking) )
                {
                    pwnd = CThemeWnd::Attach(hwnd);  // NOTE: Handle -1 ThemeWnd
                }

                if( VALID_THEMEWND(pwnd) )
                {
                    //  protect our themewnd pointer
                    pwnd->AddRef();

                    // set up a theme message block
                    THEME_MSG tm;
                    _InitThemeMsg( &tm, MSGTYPE_PRE_WNDPROC, _fUnicode, hwnd, uMsg, wParam, lParam );

                    //  is this a message we want to handle?
                    HOOKEDMSGHANDLER pfnPre;
                    if( FindOwpHandler( uMsg, &pfnPre, NULL ) )
                    {
                        //  call the message handler
                        LRESULT lRetHandler = pfnPre( pwnd, &tm );

                        fHandled = tm.fHandled;
                        if( fHandled )
                        {
                            *plRes = lRetHandler;
                        }
                    }

                    //  decrement themewnd ref
                    pwnd->Release();
                }
            }

            if( fDetach )
            {
                CThemeWnd::Detach( hwnd, uDisp );
                pwnd = NULL;
            }
        }
    }

    LogExitMsg(L"ThemePreWndProc");
    return fHandled;
}

//---------------------------------------------------------------------------
//  Post-CallWndProc hook procedure
BOOL CALLBACK ThemePostWndProc( 
    HWND     hwnd, 
    UINT     uMsg, 
    WPARAM   wParam, 
    LPARAM   lParam, 
    LRESULT* plRes,
    VOID**   ppvParam )
{
    //  Note: From this point until the point we invoke a message handler,
    //  We need to take care that we don't do anything (including DEBUG-only code) 
    //  that causes a message to be sent to the window.
    LogEntryMsg(L"ThemePostWndProc", hwnd, uMsg);

    BOOL fHandled = FALSE;
    if( IsTargetProcess(hwnd) && WM_NCCREATE != uMsg )
    {
        UINT uDisp  = _PreprocessHookedMsg( hwnd, uMsg, wParam, lParam, POST );
        BOOL fDetach  = TESTFLAG(uDisp, HMD_WINDOWDESTROY) && !IsServerSideWindow(hwnd);
        BOOL fRevoked = FALSE;

        CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwnd);
        if( _WindowHasTheme(hwnd) && VALID_THEMEWND(pwnd) )
        {
            //  protect our themewnd pointer
            pwnd->AddRef();
        
            //  is this a message we want to handle?
            HOOKEDMSGHANDLER pfnPost = NULL;
            if( FindOwpHandler( uMsg, NULL, &pfnPost ) )
            {
                // set up a theme message block
                THEME_MSG tm;
                _InitThemeMsg( &tm, MSGTYPE_POST_WNDPROC, _fUnicode, hwnd, uMsg, wParam, lParam, *plRes );

                        //  call the message handler
                LRESULT lRetHandler = pfnPost( pwnd, &tm );

                fHandled = tm.fHandled;
                
                if( fHandled )
                {
                    *plRes = lRetHandler;
                }
            }

            fRevoked = (pwnd->IsRevoked() && !pwnd->IsRevoked(RF_DEFER));

            //  decrement themewnd ref
            pwnd->Release();
        }
        else
        {
            //  special back-end processing for non-themed windows.
            fHandled = CThemeWnd::_PostWndProc( hwnd, uMsg, wParam, lParam, plRes );
        }

        if( fDetach )
        {
            CThemeWnd::Detach( hwnd, uDisp );
            pwnd = NULL; // don't touch
        }
        else if( fRevoked ) 
        {
            pwnd = CThemeWnd::FromHwnd(hwnd);
            if( VALID_THEMEWND(pwnd) )
            {
                pwnd->Revoke();
                pwnd = NULL; // don't touch
            }
        }
    }
    
    LogExitMsg(L"ThemePostWndProc");
    return fHandled;
}

//---------------------------------------------------------------------------
BOOL CALLBACK ThemePreDefDlgProc( 
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    LRESULT* plRes, 
    VOID** ppvData)
{
    LogEntryMsg(L"ThemePreDefDlgProc", hwnd, uMsg);

    //  Note: From this point until the point we invoke a message handler,
    //  We need to take care that we don't do anything (including DEBUG-only code) 
    //  that causes a message to be sent to the window.
    BOOL       fHandled = FALSE;
    CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwnd);

    if( IsTargetProcess(hwnd) && g_pAppInfo->AppIsThemed() )
    {
        if( VALID_THEMEWND(pwnd) )
        {
            //  protect our themewnd pointer
            pwnd->AddRef();
        
            //  is this a message we want to handle?
            HOOKEDMSGHANDLER pfnPre = NULL;
            if( FindDdpHandler( uMsg, &pfnPre, NULL ) )
            {
                // set up a theme message block
                THEME_MSG tm;
                _InitThemeMsg( &tm, MSGTYPE_PRE_DEFDLGPROC, _fUnicode, 
                               hwnd, uMsg, wParam, lParam, *plRes );

                //  call the message handler
                LRESULT lRetHandler = pfnPre( pwnd, &tm );
                
                fHandled = tm.fHandled;
                if( fHandled )
                {
                    *plRes = lRetHandler;
                }
            }

            //  decrement themewnd ref
            pwnd->Release();
        }
    }

    LogExitMsg(L"ThemePreDefDlgProc");
    return fHandled;
}

//---------------------------------------------------------------------------
BOOL CALLBACK ThemePostDefDlgProc( 
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    LRESULT* plRes, 
    VOID** ppvData)
{
    LogEntryMsg(L"ThemePostDefDlgProc", hwnd, uMsg);

    //  Note: From this point until the point we invoke a message handler,
    //  We need to take care that we don't do anything (including DEBUG-only code) 
    //  that causes a message to be sent to the window.
    BOOL       fHandled = FALSE;
    if( IsTargetProcess(hwnd) )
    {
        CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwnd);

        if( _WindowHasTheme(hwnd) && VALID_THEMEWND(pwnd) )
        {
            //  protect our themewnd pointer
            pwnd->AddRef();
        
            //  is this a message we want to handle?
            HOOKEDMSGHANDLER pfnPost = NULL;
            if( FindDdpHandler( uMsg, NULL, &pfnPost ) )
            {
                // set up a theme message block
                THEME_MSG tm;
                _InitThemeMsg( &tm, MSGTYPE_POST_DEFDLGPROC, _fUnicode, 
                               hwnd, uMsg, wParam, lParam, *plRes );

                //  call the message handler
                LRESULT lRetHandler = pfnPost( pwnd, &tm );
                
                fHandled = tm.fHandled;
                if( fHandled )
                {
                    *plRes = lRetHandler;
                }
            }

            //  decrement themewnd ref
            pwnd->Release();
        }
        else
        {
            //  special back-end processing for non-themed windows.
            fHandled = CThemeWnd::_PostDlgProc( hwnd, uMsg, wParam, lParam, plRes );
        }
    }

    LogExitMsg(L"ThemePostDefDlgProc");
    return fHandled;
}

//---------------------------------------------------------------------------
BOOL _ShouldInitApiHook( DWORD dwCmd, void* pvData )
{
    if( -1 == _fShouldEnableApiHooks )
    {
        _fShouldEnableApiHooks = TRUE;

        if( IsDebuggerPresent() )
        {
            BOOL fHookDebuggees = TRUE;
            HRESULT hr = GetCurrentUserThemeInt( L"ThemeDebuggees", TRUE, &fHookDebuggees );

            if( SUCCEEDED(hr) && !fHookDebuggees )
            {
                _fShouldEnableApiHooks = FALSE;
            }
        }
    }
    return _fShouldEnableApiHooks;
}

//---------------------------------------------------------------------------
//  ThemeInitApiHook() - USER API subclassing initialization callback.
//  This is called by USER asynchronously after we call RegisterDefWindowProc().
BOOL CALLBACK ThemeInitApiHook( DWORD dwCmd, void * pvData )
{
    //Log(LOG_TMCHANGE, L"ThemeInitApiHook called with dwCmd=%d, ApiCallCount=%d", dwCmd, _cInitUAH);

    BOOL fRetVal = FALSE;

    //---- if wierd loading order has called us before DllMain(), deny hooking ----
    if (! g_fUxthemeInitialized)
    {
        g_fEarlyHookRequest = TRUE;      // remember that we denied at least one hook request
    }
    else if( _ShouldInitApiHook( dwCmd, pvData ) )
    {
        switch (dwCmd)
        {
            case UIAH_INITIALIZE:
            {
                if( !UNHOOKING() )
                {
                    int cInit = InterlockedIncrement(&_cInitUAH);
                    if (cInit != 1)     // another thread is taking (has taken) care of this
                    {
                        //Log(LOG_TMCHANGE, L"ThemeInitApiHook already called - will just exit");
                        InterlockedDecrement(&_cInitUAH);
                    }
                    else
                    {
                        PUSERAPIHOOK puah = (PUSERAPIHOOK)pvData;
                        //  stash 'real' defwindowproc functions
                        _hookinf.uahReal = *puah;

                        puah->pfnGetScrollInfo         = ThemeGetScrollInfoProc;
                        puah->pfnSetScrollInfo         = ThemeSetScrollInfoProc;
                        puah->pfnEnableScrollBar       = ThemeEnableScrollInfoProc;
                        puah->pfnSetWindowRgn          = ThemeSetWindowRgn;

                        //  DefWindowProc override hooks
                        puah->pfnDefWindowProcW        = ThemeDefWindowProcW;
                        puah->pfnDefWindowProcA        = ThemeDefWindowProcA;
                        puah->mmDWP.cb                 = GetDwpMsgMask( &puah->mmDWP.rgb );

                        //  WndProc override hooks
                        puah->uoiWnd.pfnBeforeOWP      = ThemePreWndProc;
                        puah->uoiWnd.pfnAfterOWP       = ThemePostWndProc;
                        puah->uoiWnd.mm.cb             = GetOwpMsgMask( &puah->uoiWnd.mm.rgb ); // OWP message bitmask

                        //  DefDlgProc override hooks
                        puah->uoiDlg.pfnBeforeOWP      = ThemePreDefDlgProc;
                        puah->uoiDlg.pfnAfterOWP       = ThemePostDefDlgProc;
                        puah->uoiDlg.mm.cb             = GetDdpMsgMask( &puah->uoiDlg.mm.rgb ); // OWP message bitmask

                        //  System metrics hooks
                        puah->pfnGetSystemMetrics      = ThemeGetSystemMetrics;
                        puah->pfnSystemParametersInfoA = ThemeSystemParametersInfoA;
                        puah->pfnSystemParametersInfoW = ThemeSystemParametersInfoW;

                        //  Drawing hooks
                        puah->pfnDrawFrameControl      = ThemeDrawFrameControl;
                        puah->pfnDrawCaption           = ThemeDrawCaption;

                        //  MDI sysmenu hooks
                        puah->pfnMDIRedrawFrame        = ThemeMDIRedrawFrame;

                        BOOL fNcThemed = g_pAppInfo ? TESTFLAG( g_pAppInfo->GetAppFlags(), STAP_ALLOW_NONCLIENT ) : FALSE;

                        if( !fNcThemed || !LoadHookInstance() || !ApiHandlerInit( g_szProcessName, puah, &_hookinf.uahReal ) )
                        {
                            // restore 'Real' function table:
                            *puah = _hookinf.uahReal;
                        }
                        else
                        {
                            InterlockedExchange( (LONG*)&g_eThemeHookState, HS_INITIALIZED );
                            CThemeServices::ReestablishServerConnection();
                            OnHooksEnabled();
                        }

                        fRetVal = TRUE; // acknowledge out args

                    }
                }
                break;
            }

            case UIAH_UNINITIALIZE:
            case UIAH_UNHOOK:
                //  It is possible to be called on UIAH_INITIALIZED and UIAH_UNHOOK 
                //  simultaneously on two separate threads.
                
                //  Here we allow only one thread to transition from INITIALIZED to UNHOOKING state, and racing threads 
                //  will no-op. [scotthan]
                if( HS_INITIALIZED == InterlockedCompareExchange( (LONG*)&g_eThemeHookState, HS_UNHOOKING, HS_INITIALIZED ) )
                {
                    //---- now that we are completely done, decrement the count ----
                    //Log(LOG_TMCHANGE, L"ThemeInitApiHook is now decrementing the CallCount");
                    int cInit;
                    cInit = InterlockedDecrement(&_cInitUAH);
                    ASSERT(0 == cInit);

                    //---- detach themed windows, revert global state, etc
                    OnHooksDisabled(FALSE);

                    //  one thread transitions to UNITIALIZED state:
                    InterlockedExchange( (LONG*)&g_eThemeHookState, HS_UNINITIALIZED );
                    break;
                }

                fRetVal = TRUE;  // allow the hook/unhook 
                break;
        }

    }

    //Log(LOG_TMCHANGE, L"ThemeInitApiHook exiting with fRetVal=%d, ApiCallCount=%d", 
    //    fRetVal, _cInitUAH);

    return fRetVal;
}
//---------------------------------------------------------------------------
BOOL NewThemeCheck(int iChangeNum, BOOL fMsgCheck)
{
    //---- return TRUE if this is the first WM_THEMECHANGEDTRIGGER msg of ----
    //---- current theme change ----

    Log(LOG_TMCHANGE, L"NewThemeCheck, iChangeNum=%d, fMsgCheck=%d", 
        iChangeNum, fMsgCheck);

    BOOL fFirstMsg = FALSE;     

    //---- update thememgr info now (don't wait for first WM_THEMECHANGED msg) ----
    if (! g_pAppInfo->CustomAppTheme())
    {
        //---- get real changenum to minimize redundant theme changes ----
        if (iChangeNum == -1)
        {
            CThemeServices::GetCurrentChangeNumber(&iChangeNum);
        }
        
        //---- fThemeChanged is TRUE if this is the first time we have seen this ----
        //---- change number or we recently found a new theme handle ----

        BOOL fThemeChanged;
        g_pAppInfo->ResetAppTheme(iChangeNum, fMsgCheck, &fThemeChanged, &fFirstMsg);

        if (fThemeChanged)       
        {
            //---- see if theme services has died and been reborn ----
            if( S_FALSE == CThemeServices::ReestablishServerConnection() )
            {
                //---- services are back up - simulate a reset ----
                Log(LOG_ALWAYS, L"Recovering from Themes service restart");
            }

            //---- refresh theme metrics cache ----
            AcquireNcThemeMetrics();
        }
    }

    return fFirstMsg;
}
//---------------------------------------------------------------------------
void OnHooksEnabled()
{
    WindowDump(L"OnHooksEnabled");

    //---- hooking is turned on now ----
    Log(LOG_TMCHANGE, L"*** LOCAL Hooks installed ***");

    //---- load app's custom theme file, if one is registered ----

    //---- for now, comment this out since its not needed & causes problems if advapi32.dll not yet init-ed ----
    // g_pAppInfo->LoadCustomAppThemeIfFound();

    //---- we may have started this process with themes already on; in this case, we ----
    //---- don't get a WM_THEMECHANGED msg, so we better check for a theme now ----
    NewThemeCheck(-1, FALSE);
}
//---------------------------------------------------------------------------
void OnHooksDisabled(BOOL fShutDown)  
{
    DWORD dwStartTime = StartTimer();

    WindowDump(L"OnHooksDisabled");

    //---- reset the AppTheme info to OFF ----
    g_pAppInfo->ResetAppTheme(-1, FALSE, NULL, NULL);

    g_pAppInfo->SetPreviewThemeFile(NULL, NULL);

    //---- keep the static theme info in sync ----
    AcquireNcThemeMetrics();

    // NOTE: this function called from ThemeInitApiHook()( & ThemeHookShutdown()

    // We need to release all nctheme state objects from windows in this process
    // in two cases:
    // (1) normal process shutdown.
    // (2) Themes being turned off (this case).  Here, we're relying on notification
    //     from USER that hooks are coming off this process.
 
    if (fShutDown)
        CThemeWnd::DetachAll( HMD_PROCESSDETACH );
    else
        CThemeWnd::DetachAll( HMD_THEMEDETACH );

#ifdef DEBUG
    //---- all nonclient & client code should have closed their HTHEME's by now ----
    g_pAppInfo->DumpFileHolders();
    g_pRenderList->DumpFileHolders();
#endif

    //---- force this process to remove its refcount on the global theme ----
    //---- this is allowed because hTheme's are no longer directly connected ----
    //---- to a CRenderObj ----
    g_pRenderList->FreeRenderObjects(-1);

    //  free hook instance
    if( _hookinf.hInst )
    {
        FreeLibrary( _hookinf.hInst );
        _hookinf.hInst = NULL;
    }

    if (LogOptionOn(LO_TMLOAD))
    {
        DWORD dwTicks;
        dwTicks = StopTimer(dwStartTime);

        WCHAR buff[100];
        TimeToStr(dwTicks, buff, ARRAYSIZE(buff));
        Log(LOG_TMLOAD, L"OnHooksDisabled took: %s", buff);
    }

    Log(LOG_TMCHANGE, L"*** LOCAL Hooks removed ***");
}
//---------------------------------------------------------------------------
//  _ThemeDefWindowProc()  - defwindowproc worker
LRESULT CALLBACK _ThemeDefWindowProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL bUnicode )
{
    //  Note: From this point until the point we invoke a message handler,
    //  We need to take care that we don't do anything that causes
    //  a message to be sent to the window.

    LRESULT lRet = 0L;

    LogEntryMsg(L"_ThemeDefWindowProc", hwnd, uMsg);

    BOOL    fHandled = FALSE;
    WNDPROC pfnDefault = bUnicode ? _hookinf.uahReal.pfnDefWindowProcW : 
                                    _hookinf.uahReal.pfnDefWindowProcA;

    //  Pre-process WM_THEMECHANGE message
    if( IsTargetProcess(hwnd) )
    {
        UINT uDisp        = _PreprocessHookedMsg( hwnd, uMsg, wParam, lParam, DEF );
        BOOL fLifeIsShort = TESTFLAG(uDisp, HMD_THEMEDETACH|HMD_WINDOWDESTROY);
        BOOL fDetach      = TESTFLAG(uDisp, HMD_WINDOWDESTROY) && IsServerSideWindow(hwnd);

        //  Try handling message
        CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwnd);

        //  special back-end processing for non-themed windows.
        fHandled = CThemeWnd::_PreDefWindowProc( hwnd, uMsg, wParam, lParam, &lRet );

        if(fHandled == FALSE && 
           (_WindowHasTheme(hwnd) || fLifeIsShort))
        {
            //  On STYLECHANGED or WM_THEMECHANGE, 
            //  try reattaching window that was previously rejected or failed, resp.
            if( (REJECTED_THEMEWND(pwnd) && TESTFLAG(uDisp, HMD_REATTACH)) ||
                (FAILED_THEMEWND(pwnd) && WM_THEMECHANGED == uMsg)  )
            {
                CThemeWnd::Detach(hwnd, FALSE); // remove rejection tag.
                pwnd = NULL;
            }

            //  Attach window object if applicable.
            if( pwnd == NULL && !(fLifeIsShort || _fUnhooking) )
            {
                pwnd = CThemeWnd::Attach(hwnd);
            }

            if( VALID_THEMEWND(pwnd) )
            {
                //  protect our themewnd pointer:
                pwnd->AddRef();

                // set up a theme message block
                THEME_MSG tm;
                _InitThemeMsg( &tm, MSGTYPE_DEFWNDPROC, bUnicode, hwnd, uMsg, 
                               wParam, lParam, 0, pfnDefault );

                //  is this a message we want to handle?
                HOOKEDMSGHANDLER pfnHandler = NULL;
                if( FindDwpHandler( uMsg, &pfnHandler ))
                {
                    //  call the message handler
                    LRESULT lRetHandler = pfnHandler( pwnd, &tm );
                    
                    fHandled = tm.fHandled;
                    if( fHandled )
                    {
                        lRet = lRetHandler;
                    }
                }

                //  decrement themewnd ref
                pwnd->Release();
            }
        }

        if( fDetach )
        {
            CThemeWnd::Detach( hwnd, uDisp );
            pwnd = NULL; // don't touch
        }

    }

    if( !fHandled )
        lRet = pfnDefault( hwnd, uMsg, wParam, lParam );

    LogExitMsg(L"_ThemeDefWindowProc");
    return lRet;
}

//---------------------------------------------------------------------------
//  ThemeDefWindowProcA()  - Themed ansi defwindowproc
LRESULT CALLBACK ThemeDefWindowProcA( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    return _ThemeDefWindowProc( hwnd, uMsg, wParam, lParam, FALSE );
}

//---------------------------------------------------------------------------
//  ThemeDefWindowProcW()  - Themed widechar defwindowproc
LRESULT CALLBACK ThemeDefWindowProcW( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    return _ThemeDefWindowProc( hwnd, uMsg, wParam, lParam, TRUE );
}

//---------------------------------------------------------------------------
int CALLBACK ThemeSetScrollInfoProc( 
    HWND hwnd, 
    int nBar, 
    IN LPCSCROLLINFO psi, 
    BOOL fRedraw )
{
    int  nRet = 0;

    if ( psi != NULL )
    {
        LogEntryMsg(L"ThemeSetScrollInfoProc", hwnd, nBar);

        BOOL fHandled = FALSE;
        
        if ( IsTargetProcess(hwnd) && _WindowHasTheme(hwnd) && (nBar != SB_CTL) )
        {
            DWORD dwStyle;
            BOOL  fStyleChanged;

            CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwnd);

            //
            // Call the real SetScrollInfo first to give user
            // a chance to update their internal state. They can
            // potentially set WS_VSCROLL/WS_HSCROLL without notifying
            // anyone at all (eg. defview's listview)
            //
            // If they do, we'll need to redraw the entire
            // scroll bar.
            //
            dwStyle = GetWindowLong(hwnd, GWL_STYLE);
            nRet = _hookinf.uahReal.pfnSetScrollInfo( hwnd, nBar, psi, FALSE );
            fStyleChanged = (((dwStyle ^ GetWindowLong(hwnd, GWL_STYLE)) & (WS_VSCROLL|WS_HSCROLL)) != 0) ? TRUE : FALSE;

            //  If we previously rejected the host window, it's possible that it
            //  didn't have the WS_H/VSCROLL bits.   Now it will, so we can re-attach.
            if ( REJECTED_THEMEWND(pwnd) )
            {
                CThemeWnd::Detach(hwnd, FALSE);
                pwnd = CThemeWnd::Attach(hwnd);
            }

            if ( VALID_THEMEWND(pwnd) )
            {

                // SetScrollInfo can potentially change WS_VSCROLL/WS_HSCROLL but
                // no style change message gets send. User does this by directly changing
                // the wnd struct. We do this by calling SetWindowLong which will generated
                // stylchanging and stylechanged. For compatability, we'll need to suppress
                // these messages.
                pwnd->SuppressStyleMsgs();
                fHandled = TRUE;

                #ifdef _ENABLE_SCROLL_SPEW_
                SpewScrollInfo( "ThemeSetScrollInfoProc to RealSetScrollInfo:", hwnd, psi );
                #endif // _ENABLE_SCROLL_SPEW_

                SCROLLINFO si;
                si.cbSize = sizeof(si);
                si.fMask  = psi->fMask | SIF_DISABLENOSCROLL;
                if ( _hookinf.uahReal.pfnGetScrollInfo( hwnd, nBar, &si ) )
                {
                    ThemeSetScrollInfo( hwnd, nBar, &si, fRedraw );
                }
                else
                {
                    ThemeSetScrollInfo( hwnd, nBar, psi, fRedraw );
                }

                if ( fRedraw && fStyleChanged )
                {
                    HDC hdc = GetWindowDC(hwnd);

                    if ( hdc )
                    {
                        DrawScrollBar(hwnd, hdc, NULL, (nBar != SB_HORZ));
                        ReleaseDC(hwnd, hdc);
                    }
                }

                pwnd->AllowStyleMsgs();
            }
        }

        if( !fHandled )
        {
            nRet = _hookinf.uahReal.pfnSetScrollInfo( hwnd, nBar, psi, fRedraw );
        }

        LogExitMsg(L"ThemeSetScrollInfoProc");
    }

    return nRet;
}

//---------------------------------------------------------------------------
BOOL CALLBACK ThemeGetScrollInfoProc( 
    HWND hwnd, 
    int nBar, 
    IN OUT LPSCROLLINFO psi )
{
    BOOL fRet = FALSE;

    if ( psi != NULL )    
    {
        LogEntryMsg(L"ThemeGetScrollInfoProc", hwnd, nBar);

        if( IsTargetProcess(hwnd) && _WindowHasTheme(hwnd) )
        {
            CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwnd);
            if( VALID_THEMEWND(pwnd) )
            {
                fRet = ThemeGetScrollInfo( hwnd, nBar, psi );
            }
        }

        if( !fRet )
        {
            fRet = _hookinf.uahReal.pfnGetScrollInfo( hwnd, nBar, psi );
        }

        LogExitMsg(L"ThemeGetScrollInfoProc");
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return fRet;
}

//---------------------------------------------------------------------------
BOOL CALLBACK ThemeEnableScrollInfoProc( HWND hwnd, UINT nSBFlags, UINT nArrows )
{
    LogEntryMsg(L"ThemeEnableScrollInfoProc", 0, 0);

    BOOL fRet = _hookinf.uahReal.pfnEnableScrollBar( hwnd, nSBFlags, nArrows );

    if( fRet )
    {
        if( IsTargetProcess(hwnd) && _WindowHasTheme(hwnd))
        {
            CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwnd);
            if( VALID_THEMEWND(pwnd) )
            {
                ThemeEnableScrollBar( hwnd, nSBFlags, nArrows );
            }
        }
    }

    LogExitMsg(L"ThemeEnableScrollInfoProc");

    return fRet;
}

//---------------------------------------------------------------------------
int CALLBACK ThemeGetSystemMetrics( int iMetric )
{
    LogEntryMsg(L"ThemeGetSystemMetrics", 0, 0);

    int iRet;

    if( IsTargetProcess() && g_pAppInfo->AppIsThemed() && !IN_CLASSICSYSMETCALL() )
    {
        BOOL fHandled = FALSE;
        iRet = _InternalGetSystemMetrics( iMetric, fHandled );
        if( fHandled )
            return iRet;
    }
    iRet = _hookinf.uahReal.pfnGetSystemMetrics(iMetric);

    LogExitMsg(L"ThemeGetSystemMetrics");
    return iRet;
}

//---------------------------------------------------------------------------
THEMEAPI_(int) ClassicGetSystemMetrics( int iMetric )
{
    LogEntryMsg(L"ThemeGetSystemMetrics", 0, 0);

    if( HOOKSACTIVE() && _hookinf.uahReal.pfnGetSystemMetrics != NULL )
    {
        return _hookinf.uahReal.pfnGetSystemMetrics( iMetric );
    }

    ENTER_CLASSICSYSMETCALL();
    int nRet =  GetSystemMetrics( iMetric );
    LEAVE_CLASSICSYSMETCALL();

    LogExitMsg(L"ThemeGetSystemMetrics");
    return nRet;
}

//---------------------------------------------------------------------------
BOOL CALLBACK ThemeSystemParametersInfoA( 
    IN UINT uiAction, 
    IN UINT uiParam, 
    IN OUT PVOID pvParam, 
    IN UINT fWinIni)
{
    LogEntryMsg(L"ThemeSystemParametersInfoA", 0, 0);

    BOOL fRet = FALSE;

    if( IsTargetProcess() && g_pAppInfo->AppIsThemed() && !IN_CLASSICSYSMETCALL() )
    {
        BOOL fHandled = FALSE;

        fRet = _InternalSystemParametersInfo( uiAction, uiParam, pvParam, fWinIni, FALSE, fHandled );
        if( fHandled )
            return fRet;
    }
    
    fRet = _hookinf.uahReal.pfnSystemParametersInfoA( uiAction, uiParam, pvParam, fWinIni );

    LogExitMsg(L"ThemeSystemParametersInfoA");

    return fRet;
}

//---------------------------------------------------------------------------
BOOL CALLBACK ThemeSystemParametersInfoW( IN UINT uiAction, IN UINT uiParam, IN OUT PVOID pvParam, IN UINT fWinIni)
{
    LogEntryMsg(L"ThemeSystemParametersInfoA", 0, 0);

    BOOL fRet = FALSE;

    if( IsTargetProcess() && g_pAppInfo->AppIsThemed() && !IN_CLASSICSYSMETCALL() )
    {
        BOOL fHandled = FALSE;

        fRet = _InternalSystemParametersInfo( uiAction, uiParam, pvParam, fWinIni, TRUE, fHandled );
        if( fHandled )
            return fRet;
    }
    
    fRet = _hookinf.uahReal.pfnSystemParametersInfoW( uiAction, uiParam, pvParam, fWinIni );

    LogExitMsg(L"ThemeSystemParametersInfoA");

    return fRet;
}

//---------------------------------------------------------------------------
THEMEAPI_(BOOL) ClassicSystemParametersInfoA( IN UINT uiAction, IN UINT uiParam, IN OUT PVOID pvParam, IN UINT fWinIni)
{
    if( HOOKSACTIVE() && _hookinf.uahReal.pfnSystemParametersInfoA ) 
    {
        return _hookinf.uahReal.pfnSystemParametersInfoA( uiAction, uiParam, pvParam, fWinIni );
    }
        
    ENTER_CLASSICSYSMETCALL();
    BOOL fRet =  SystemParametersInfoA( uiAction, uiParam, pvParam, fWinIni );
    LEAVE_CLASSICSYSMETCALL();
    
    return fRet;
}

//---------------------------------------------------------------------------
THEMEAPI_(BOOL) ClassicSystemParametersInfoW( IN UINT uiAction, IN UINT uiParam, IN OUT PVOID pvParam, IN UINT fWinIni)
{
    if( HOOKSACTIVE() && _hookinf.uahReal.pfnSystemParametersInfoW ) 
    {
        return _hookinf.uahReal.pfnSystemParametersInfoW( uiAction, uiParam, pvParam, fWinIni );
    }
        
    ENTER_CLASSICSYSMETCALL();
    BOOL fRet =  SystemParametersInfoW( uiAction, uiParam, pvParam, fWinIni );
    LEAVE_CLASSICSYSMETCALL();
    
    return fRet;
}

//---------------------------------------------------------------------------
THEMEAPI_(BOOL) ClassicAdjustWindowRectEx( LPRECT prcWnd, DWORD dwStyle, BOOL fMenu, DWORD dwExStyle )
{
   //  If hooks are active, simply call user32!RealAdjustWindowRectEx.
    if( HOOKSACTIVE() && _hookinf.uahReal.pfnAdjustWindowRectEx )
    {
        return _hookinf.uahReal.pfnAdjustWindowRectEx( prcWnd, dwStyle, fMenu, dwExStyle );
    }

    ENTER_CLASSICSYSMETCALL();
    BOOL fRet = AdjustWindowRectEx( prcWnd, dwStyle, fMenu, dwExStyle );
    LEAVE_CLASSICSYSMETCALL();

    return fRet;
}

//---------------------------------------------------------------------------
BOOL CALLBACK ThemeSetWindowRgn( HWND hwnd, HRGN hrgn, BOOL fRedraw)
{
    LogEntryMsg(L"ThemeSetWindowRgn", hwnd, 0);
    BOOL fHandled = FALSE;

    if( IsTargetProcess(hwnd) )
    {
        CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwnd);
        
        if( VALID_THEMEWND(pwnd) )
        {
            if( _WindowHasTheme(hwnd) )
            {
                if( hrgn != NULL && 
                    pwnd->IsFrameThemed() && !pwnd->AssigningFrameRgn() /* don't hook our own call */ )
                {
                    //  If we're executing here, the window is being assigned a
                    //  region externally or by the app.   We'll want to revoke theming
                    //  of this window from this point forward.
                    pwnd->AddRef();
            
                    //  Disown our theme window region without directly removing it;
                    //  we'll simply fall through and let the theme region get stomped.
                    if( pwnd->AssignedFrameRgn() )
                        pwnd->AssignFrameRgn( FALSE, FTF_NOMODIFYRGN );

                    //  Exile the window.
                    pwnd->Revoke();

                    pwnd->Release();
                }
            }
        }
        else if( NULL == hrgn && !IsWindowInDestroy(hwnd) )
        {
            if( TESTFLAG( CThemeWnd::EvaluateWindowStyle( hwnd ), TWCF_FRAME|TWCF_TOOLFRAME ) )
            {
                if( pwnd )
                    RemoveProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_NONCLIENT)) );
                    
                NCEVALUATE nce = {0};
                nce.fIgnoreWndRgn = TRUE;
                pwnd = CThemeWnd::Attach(hwnd, &nce);

                if( VALID_THEMEWND(pwnd) )
                {
                    ASSERT(pwnd->TestCF(TWCF_FRAME|TWCF_TOOLFRAME));
                    fHandled = TRUE;
                    pwnd->SetFrameTheme( FTF_REDRAW, NULL );
                }
            }
        }
    }
    

    BOOL fRet = TRUE;
    if( !fHandled )
    {
        ASSERT(_hookinf.uahReal.pfnSetWindowRgn);
        fRet = _hookinf.uahReal.pfnSetWindowRgn( hwnd, hrgn, fRedraw );
    }

    LogExitMsg(L"ThemeSetWindowRgn");
    return fRet;
}

//---------------------------------------------------------------------------
BOOL CALLBACK ThemeDrawFrameControl( 
    IN HDC hdc, IN OUT LPRECT prc, IN UINT uType, IN UINT uState )
{
    LogEntryMsg(L"ThemeDrawFrameControl", NULL, 0);

    if( IsTargetProcess() )
    {
        CThemeWnd* pwnd = CThemeWnd::FromHdc(hdc);
        if( NULL == pwnd)  // HDC is a memory DC
        {
            //  Find the window in this thread that is processing WM_NCPAINT
            HWND hwnd = NcPaintWindow_Find();
            if( hwnd )
            {
                pwnd = CThemeWnd::FromHwnd(hwnd);
            }
        }
        
        if( VALID_THEMEWND(pwnd) && _WindowHasTheme(*pwnd) )
        {
            if( pwnd->IsFrameThemed() && pwnd->InNcPaint() && !pwnd->InNcThemePaint() )
            {
                DWORD dwFlags = RF_NORMAL|RF_DEFER;
                if( pwnd->AssignedFrameRgn() )
                {
                    dwFlags |= RF_REGION;
                }
                
                pwnd->SetRevokeFlags(dwFlags);
            }
        }
    }

    ASSERT(_hookinf.uahReal.pfnDrawFrameControl);
    BOOL fRet = _hookinf.uahReal.pfnDrawFrameControl( hdc, prc, uType, uState );

    LogExitMsg(L"ThemeDrawFrameControl");
    return fRet;
}

//---------------------------------------------------------------------------
BOOL CALLBACK ThemeDrawCaption( IN HWND hwnd, IN HDC hdc, IN CONST RECT *prc, IN UINT uType)
{
    LogEntryMsg(L"ThemeDrawFrameControl", NULL, 0);

    if( IsTargetProcess() )
    {
        CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwnd);
        
        if( VALID_THEMEWND(pwnd) && _WindowHasTheme(*pwnd) )
        {
            if( pwnd->IsFrameThemed() && pwnd->InNcPaint() && !pwnd->InNcThemePaint() )
            {
                DWORD dwFlags = RF_NORMAL|RF_DEFER;
                if( pwnd->AssignedFrameRgn() )
                {
                    dwFlags |= RF_REGION;
                }
                
                pwnd->SetRevokeFlags(dwFlags);
            }
        }
    }

    ASSERT(_hookinf.uahReal.pfnDrawCaption);
    BOOL fRet = _hookinf.uahReal.pfnDrawCaption( hwnd, hdc, prc, uType );

    LogExitMsg(L"ThemeDrawFrameControl");
    return fRet;
}

//---------------------------------------------------------------------------
VOID CALLBACK ThemeMDIRedrawFrame( IN HWND hwndChild, BOOL fAdd )
{
    LogEntryMsg(L"ThemeMDIRedrawFrame", NULL, 0);

    if( IsTargetProcess() )
    {
        HWND hwndClient = GetParent(hwndChild);
        HWND hwndFrame  = GetParent(hwndClient); 

        if( hwndFrame )
        {
            CThemeWnd* pwnd = CThemeWnd::FromHwnd(hwndFrame);

            if( VALID_THEMEWND(pwnd) )
            {
                pwnd->ModifyMDIMenubar( fAdd, FALSE );
            }
        }
    }
    
    ASSERT(_hookinf.uahReal.pfnMDIRedrawFrame);
    _hookinf.uahReal.pfnMDIRedrawFrame( hwndChild, fAdd );
    LogExitMsg(L"ThemeMDIRedrawFrame");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\services.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Services.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  APIs to communicate with the theme service running in the winlogon
//  process context.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------

#include "stdafx.h"

#include "Services.h"

#include <uxthemep.h>

#include "errors.h"
#include "info.h"
#include "MessageBroadcast.h"
#include "stringtable.h"
#include "themefile.h"
#include "ThemeSection.h"
#include "ThemeServer.h"
#include "tmreg.h"
#include "tmutils.h"
#include <regstr.h>     // REGSTR_PATH_POLICIES

#define TBOOL(x)            ((BOOL)(x))
#define TW32(x)             ((DWORD)(x))
#define THR(x)              ((HRESULT)(x))
#define TSTATUS(x)          ((NTSTATUS)(x))
#undef  ASSERTMSG
#define ASSERTMSG(x, y)
#define goto                !!DO NOT USE GOTO!! - DO NOT REMOVE THIS ON PAIN OF DEATH

//  --------------------------------------------------------------------------
//  CThemeServices::s_hAPIPort
//
//  Purpose:    Static member variables for CThemeServices.
//
//              NOTE: The critical section provides a lock for s_hAPIPort.
//              It's not acquired consistently because most of the API calls
//              would block trying to acquire the lock while another API call
//              is holding the lock across a request. The handle could be
//              copied to a local variable but this would defeat the purpose
//              of the lock. So the lock isn't used. It's possible for the
//              handle to become invalid. If so the request will just fail.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

CRITICAL_SECTION    CThemeServices::s_lock = {0};
HANDLE              CThemeServices::s_hAPIPort      =   INVALID_HANDLE_VALUE;

//  --------------------------------------------------------------------------
//  CThemeServices::StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initialize static member variables.
//
//  History:    2000-10-11  vtan        created
//              2000-11-09  vtan        make static
//  --------------------------------------------------------------------------

void    CThemeServices::StaticInitialize (void)

{
    if( !InitializeCriticalSectionAndSpinCount(&s_lock, 0) )
    {
        ASSERT(0 == s_lock.DebugInfo);
    }
}

//  --------------------------------------------------------------------------
//  CThemeServices::~CThemeServices
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Release static resources used by CThemeServices.
//
//  History:    2000-10-11  vtan        created
//              2000-11-09  vtan        make static
//  --------------------------------------------------------------------------

void    CThemeServices::StaticTerminate (void)

{
    ReleaseConnection();
    SAFE_DELETECRITICALSECTION(&s_lock);
}

//  --------------------------------------------------------------------------
//  CThemeServices::ThemeHooksOn
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Ask the server what the hook DLL HMODULE and
//              pfnInitUserApiHook is and call user32!RegisterUserApiHook on
//              the client side. This is done because it's specific to the
//              session on which the client runs.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::ThemeHooksOn (HWND hwndTarget)

{
    HRESULT hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);

    if (ConnectedToService())
    {
        NTSTATUS                status;
        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_THEMEHOOKSON;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hAPIPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        CheckForDisconnectedPort(status);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
            if (NT_SUCCESS(status))
            {
                hr = portMessageOut.apiThemes.apiSpecific.apiThemeHooksOn.out.hr;
            }
        }
        if (!NT_SUCCESS(status))
        {
            hr = HRESULT_FROM_NT(status);
        }

        //---- send the WM_UAHINIT msg to engage hooking now ----
        if (SUCCEEDED(hr))
        {
            if (hwndTarget)
            {
                (LRESULT)SendMessage(hwndTarget, WM_UAHINIT, 0, 0);
            }
            else
            {
                CMessageBroadcast   messageBroadcast;
                messageBroadcast.PostAllThreadsMsg(WM_UAHINIT, 0, 0);

                //Log(LOG_TMCHANGEMSG, L"Just sent WM_UAHINIT, hwndTarget=0x%x", hwndTarget);
            }
        }

        Log(LOG_TMCHANGE, L"ThemeHooksOn called, hr=0x%x", hr);
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CThemeServices::ThemeHooksOff
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Tell the server that this session is unregistering hooks.
//              Call user32!UnregisterUserApiHook either way.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::ThemeHooksOff (void)

{
    HRESULT     hr;

    hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
    if (ConnectedToService())
    {
        NTSTATUS                status;
        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_THEMEHOOKSOFF;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hAPIPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        CheckForDisconnectedPort(status);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
            if (NT_SUCCESS(status))
            {
                hr = portMessageOut.apiThemes.apiSpecific.apiThemeHooksOff.out.hr;
            }

            if (SUCCEEDED(hr))
            {
                //---- real unhooking happens on next window message in each process ----
                //---- so post a dummy msg to everyone to make it happen asap ----
                PostMessage(HWND_BROADCAST, WM_THEMECHANGED, WPARAM(-1), 0);

                Log(LOG_TMLOAD, L"Message to kick all window threads in session posted");
            }
        }
        if (!NT_SUCCESS(status))
        {
            hr = HRESULT_FROM_NT(status);
        }
    }

    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::GetStatusFlags
//
//  Arguments:  pdwFlags    =   Status flags returned from the theme services.
//
//  Returns:    HRESULT
//
//  Purpose:    Gets status flags from the theme services.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::GetStatusFlags (DWORD *pdwFlags)

{
    HRESULT     hr;

    hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
    if (ConnectedToService())
    {
        NTSTATUS                status;
        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_GETSTATUSFLAGS;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hAPIPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        CheckForDisconnectedPort(status);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
            if (NT_SUCCESS(status))
            {
                *pdwFlags = portMessageOut.apiThemes.apiSpecific.apiGetStatusFlags.out.dwFlags;
                hr = S_OK;
            }
        }
        if (!NT_SUCCESS(status))
        {
            hr = HRESULT_FROM_NT(status);
        }
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::GetCurrentChangeNumber
//
//  Arguments:  piValue     =   Current change number returned to caller.
//
//  Returns:    HRESULT
//
//  Purpose:    Gets the current change number of the theme services.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::GetCurrentChangeNumber (int *piValue)

{
    HRESULT     hr;

    hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
    if (ConnectedToService())
    {
        NTSTATUS                status;
        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_GETCURRENTCHANGENUMBER;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hAPIPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        CheckForDisconnectedPort(status);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
            if (NT_SUCCESS(status))
            {
                *piValue = portMessageOut.apiThemes.apiSpecific.apiGetCurrentChangeNumber.out.iChangeNumber;
                hr = S_OK;
            }

            Log(LOG_TMLOAD, L"*** GetCurrentChangeNumber: num=%d, hr=0x%x", *piValue, hr);
        }
        if (!NT_SUCCESS(status))
        {
            hr = HRESULT_FROM_NT(status);
        }
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::SetGlobalTheme
//
//  Arguments:  hSection    =   Section to set as the global theme.
//
//  Returns:    HRESULT
//
//  Purpose:    Sets the current global theme section handle.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::SetGlobalTheme (HANDLE hSection)

{
    HRESULT     hr;

    hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
    if (ConnectedToService())
    {
        NTSTATUS                status;
        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_SETGLOBALTHEME;
        portMessageIn.apiThemes.apiSpecific.apiSetGlobalTheme.in.hSection = hSection;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hAPIPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        CheckForDisconnectedPort(status);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
            if (NT_SUCCESS(status))
            {
                hr = portMessageOut.apiThemes.apiSpecific.apiSetGlobalTheme.out.hr;
            }
        }
        if (!NT_SUCCESS(status))
        {
            hr = HRESULT_FROM_NT(status);
        }
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::GetGlobalTheme
//
//  Arguments:  phSection   =   Section object returned from theme services.
//
//  Returns:    HRESULT
//
//  Purpose:    Gets the current global theme section handle.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------
HRESULT     CThemeServices::GetGlobalTheme (HANDLE *phSection)

{
    HRESULT     hr;

    hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
    if (ConnectedToService())
    {
        NTSTATUS                status;
        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_GETGLOBALTHEME;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hAPIPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        CheckForDisconnectedPort(status);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
            if (NT_SUCCESS(status))
            {
                hr = portMessageOut.apiThemes.apiSpecific.apiGetGlobalTheme.out.hr;
                if (SUCCEEDED(hr))
                {
                    *phSection = portMessageOut.apiThemes.apiSpecific.apiGetGlobalTheme.out.hSection;
                }
            }
        }
        if (!NT_SUCCESS(status))
        {
            hr = HRESULT_FROM_NT(status);
        }
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::CheckThemeSignature
//
//  Arguments:  pszThemeName    =   File path of theme to check.
//
//  Returns:    HRESULT
//
//  Purpose:    Checks the given theme's signature.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::CheckThemeSignature (const WCHAR *pszThemeName)

{
    HRESULT     hr;

    hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
    if (ConnectedToService())
    {
        NTSTATUS                status;
        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_CHECKTHEMESIGNATURE;
        portMessageIn.apiThemes.apiSpecific.apiCheckThemeSignature.in.pszName = pszThemeName;
        portMessageIn.apiThemes.apiSpecific.apiCheckThemeSignature.in.cchName = lstrlen(pszThemeName) + sizeof('\0');
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hAPIPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        CheckForDisconnectedPort(status);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
            if (NT_SUCCESS(status))
            {
                hr = portMessageOut.apiThemes.apiSpecific.apiCheckThemeSignature.out.hr;
            }
        }
        if (!NT_SUCCESS(status))
        {
            hr = HRESULT_FROM_NT(status);
        }
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::LoadTheme
//
//  Arguments:  phSection       =   Section object to theme returned.
//              pszThemeName    =   Theme file to load.
//              pszColorParam   =   Color.
//              pszSizeParam    =   Size.
//              fGlobal         =   FALSE for a preview.
//
//  Returns:    HRESULT
//
//  Purpose:    Loads the given theme and creates a section object for it.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::LoadTheme (HANDLE *phSection, 
    const WCHAR *pszThemeName, const WCHAR *pszColor, const WCHAR *pszSize, BOOL fGlobal)

{
    HRESULT     hr;

    *phSection = NULL; // Result if failure

    hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
    if (ConnectedToService())
    {
        HANDLE          hSection;
        CThemeLoader    *pLoader;
        WCHAR           szColor[MAX_PATH];
        WCHAR           szSize[MAX_PATH];

        //  Because the loader makes GDI calls that directly affect the
        //  client instance of win32k the theme must be loaded on the
        //  client side. Once the theme is loaded it is handed to the
        //  server (which creates a new section) and copies the data to
        //  it. The server then controls the theme data and the client
        //  discards the temporary theme.

        hSection = NULL;
        pLoader = new CThemeLoader;
        if (pLoader != NULL)
        {
            HINSTANCE hInst = NULL;
            
            // Keep the DLL loaded to avoid loading it 3 times below
            hr = LoadThemeLibrary(pszThemeName, &hInst);

            if (SUCCEEDED(hr) && (pszColor == NULL || *pszColor == L'\0'))
            {
                hr = GetThemeDefaults(pszThemeName, szColor, ARRAYSIZE(szColor), NULL, 0);
                pszColor = szColor;
            }

            if (SUCCEEDED(hr) && (pszSize == NULL || *pszSize == L'\0'))
            {
                hr = GetThemeDefaults(pszThemeName, NULL, 0, szSize, ARRAYSIZE(szSize));
                pszSize = szSize;
            }

            if (SUCCEEDED(hr))
            {
                hr = pLoader->LoadTheme(pszThemeName, pszColor, pszSize, &hSection, fGlobal);
            }
            
            delete pLoader;
            
            if (hInst)
            {
                FreeLibrary(hInst);
            }
        }
        else
        {
            hr = MakeError32(E_OUTOFMEMORY);
        }
        if (SUCCEEDED(hr) && (hSection != NULL))
        {
            NTSTATUS                status;
            THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

            ZeroMemory(&portMessageIn, sizeof(portMessageIn));
            ZeroMemory(&portMessageOut, sizeof(portMessageOut));
            portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_LOADTHEME;
            portMessageIn.apiThemes.apiSpecific.apiLoadTheme.in.pszName = pszThemeName;
            portMessageIn.apiThemes.apiSpecific.apiLoadTheme.in.cchName = lstrlen(pszThemeName) + sizeof('\0');
            portMessageIn.apiThemes.apiSpecific.apiLoadTheme.in.pszColor = pszColor;
            portMessageIn.apiThemes.apiSpecific.apiLoadTheme.in.cchColor = lstrlen(pszColor) + sizeof('\0');
            portMessageIn.apiThemes.apiSpecific.apiLoadTheme.in.pszSize = pszSize;
            portMessageIn.apiThemes.apiSpecific.apiLoadTheme.in.cchSize = lstrlen(pszSize) + sizeof('\0');
            portMessageIn.apiThemes.apiSpecific.apiLoadTheme.in.hSection = hSection;
            portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
            portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
            status = NtRequestWaitReplyPort(s_hAPIPort,
                                            &portMessageIn.portMessage,
                                            &portMessageOut.portMessage);
            CheckForDisconnectedPort(status);
            if (NT_SUCCESS(status))
            {
                status = portMessageOut.apiThemes.apiGeneric.status;
                if (NT_SUCCESS(status))
                {
                    hr = portMessageOut.apiThemes.apiSpecific.apiLoadTheme.out.hr;
                    if (SUCCEEDED(hr))
                    {
                        *phSection = portMessageOut.apiThemes.apiSpecific.apiLoadTheme.out.hSection;
                    }
                    else
                    {
                    }
                }
            }
            if (!NT_SUCCESS(status))
            {
                hr = HRESULT_FROM_NT(status);
            }
        }

        // Clear our temporary section
        if (hSection != NULL)
        {
            // If we didn't transfer the stock objects handles to a new section, clear them always
            if (*phSection == NULL)
            {
                THR(ClearStockObjects(hSection));
            }
            TBOOL(CloseHandle(hSection));
        }
    }
    return(hr);
}

//  --------------------------------------------------------------------------
HRESULT CThemeServices::ProcessLoadGlobalTheme( 
    const WCHAR *pszThemeName, 
    const WCHAR *pszColor, 
    const WCHAR *pszSize, 
    OUT HANDLE *phSection )
{
    HRESULT     hr;
    *phSection = 0;

    hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
    if (ConnectedToService())
    {
        WCHAR     szColor[MAX_PATH];
        WCHAR     szSize[MAX_PATH];
        HINSTANCE hInst = NULL;

        hr = S_OK;

        //  In this version of theme load, we're going to request the server initiate
        //  the load from disk.  Because the loader makes GDI calls that directly affect the
        //  client instance of win32k the theme must be loaded on the client's window station.   
        //  To accomplish this, the theme server may decide to launch a new process or inject 
        //  a thread into some existing process on this client's window station.   The client 
        //  doesn't know or care which method is used.

        //  Addl note: On case of failure, any GDI stock objects created will be cleaned up
        //             elsewhere.

        //  fetch default color variant name if needed
        if (SUCCEEDED(hr) && !(pszColor && *pszColor))
        {
            // Map in the .msstyles dll to avoid multiple loads.
            hr = LoadThemeLibrary(pszThemeName, &hInst);

            if( SUCCEEDED(hr) )
            {
                hr = GetThemeDefaults(pszThemeName, szColor, ARRAYSIZE(szColor), NULL, 0);
                pszColor = szColor;
            }
        }

        //  fetch default size variant name if needed
        if (SUCCEEDED(hr) && !(pszSize && *pszSize))
        {
            hr = GetThemeDefaults(pszThemeName, NULL, 0, szSize, ARRAYSIZE(szSize));
            pszSize = szSize;
        }

        //  drop our msstyles reference, if any
        if (hInst)
        {
            FreeLibrary(hInst);
        }
        
        //  ready to do the LPC request
        if (SUCCEEDED(hr))
        {
            NTSTATUS                status;
            THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

            ZeroMemory(&portMessageIn, sizeof(portMessageIn));
            ZeroMemory(&portMessageOut, sizeof(portMessageOut));
            portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_PROCESSLOADTHEME;
            portMessageIn.apiThemes.apiSpecific.apiProcessLoadTheme.in.pszName  = pszThemeName;
            portMessageIn.apiThemes.apiSpecific.apiProcessLoadTheme.in.cchName  = lstrlen(pszThemeName) + sizeof('\0');
            portMessageIn.apiThemes.apiSpecific.apiProcessLoadTheme.in.pszColor = pszColor;
            portMessageIn.apiThemes.apiSpecific.apiProcessLoadTheme.in.cchColor = lstrlen(pszColor) + sizeof('\0');
            portMessageIn.apiThemes.apiSpecific.apiProcessLoadTheme.in.pszSize  = pszSize;
            portMessageIn.apiThemes.apiSpecific.apiProcessLoadTheme.in.cchSize  = lstrlen(pszSize) + sizeof('\0');
            
            portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
            portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
            status = NtRequestWaitReplyPort(s_hAPIPort,
                                            &portMessageIn.portMessage,
                                            &portMessageOut.portMessage);
            CheckForDisconnectedPort(status);
            if (NT_SUCCESS(status))
            {
                status = portMessageOut.apiThemes.apiGeneric.status;
                if (NT_SUCCESS(status))
                {
                    hr = portMessageOut.apiThemes.apiSpecific.apiProcessLoadTheme.out.hr;
                    if (SUCCEEDED(hr))
                    {
                        *phSection = portMessageOut.apiThemes.apiSpecific.apiProcessLoadTheme.out.hSection;
                    }
                }
                else
                {
                    hr = HRESULT_FROM_NT(status);
                }
            }
            else
            {
                hr = HRESULT_FROM_NT(status);
            }
        }
    }
    return(hr);
}

//  --------------------------------------------------------------------------
HRESULT CThemeServices::CheckColorDepth(CUxThemeFile *pThemeFile)
{
    HRESULT hr = S_OK;
    THEMEMETRICS *pMetrics = GetThemeMetricsPtr(pThemeFile);
    DWORD dwDepthRequired = pMetrics->iInts[TMT_MINCOLORDEPTH - TMT_FIRSTINT];

    if (MinimumDisplayColorDepth() < dwDepthRequired)
    {
        hr = MakeError32(ERROR_BAD_ENVIRONMENT);
    }

    return hr;
}

//  --------------------------------------------------------------------------
HRESULT CThemeServices::UpdateThemeRegistry(BOOL fThemeActive,
     LPCWSTR pszThemeFileName, LPCWSTR pszColorParam, LPCWSTR pszSizeParam, BOOL fJustSetActive,
     BOOL fJustApplied)
{
    if (fThemeActive)
    {
        if (fJustSetActive)    
        {
            //---- see if a theme was previously active ----
            WCHAR szThemeName[MAX_PATH];

            THR(GetCurrentUserThemeString(THEMEPROP_DLLNAME, L"", szThemeName, ARRAYSIZE(szThemeName)));
            if (szThemeName[0] != L'\0')
            {
                THR(SetCurrentUserThemeInt(THEMEPROP_THEMEACTIVE, 1));
            }
        }
        else
        {
            WCHAR szFullName[MAX_PATH];

            if (GetFullPathName(pszThemeFileName, ARRAYSIZE(szFullName), szFullName, NULL) == 0)
            {
                SafeStringCchCopyW(szFullName, ARRAYSIZE(szFullName), pszThemeFileName);
            }

            THR(SetCurrentUserThemeInt(THEMEPROP_THEMEACTIVE, 1));

            if (fJustApplied)
            {
                THR(SetCurrentUserThemeInt(THEMEPROP_LOADEDBEFORE, 1));
                THR(SetCurrentUserThemeInt(THEMEPROP_LANGID, (int) GetUserDefaultUILanguage()));

                //  Theme identification

                THR(SetCurrentUserThemeStringExpand(THEMEPROP_DLLNAME, szFullName));
                THR(SetCurrentUserThemeString(THEMEPROP_COLORNAME, pszColorParam));
                THR(SetCurrentUserThemeString(THEMEPROP_SIZENAME, pszSizeParam));
            }
            else        // for forcing theme to be loaded from InitUserTheme()
            {
                WCHAR szThemeName[MAX_PATH];

                THR(GetCurrentUserThemeString(THEMEPROP_DLLNAME, L"", szThemeName, ARRAYSIZE(szThemeName)));

                if (lstrcmpiW(szThemeName, szFullName) != 0)
                {
                    THR(SetCurrentUserThemeString(THEMEPROP_DLLNAME, szFullName));

                    TW32(DeleteCurrentUserThemeValue(THEMEPROP_LOADEDBEFORE));
                    TW32(DeleteCurrentUserThemeValue(THEMEPROP_LANGID));
                    TW32(DeleteCurrentUserThemeValue(THEMEPROP_COLORNAME));
                    TW32(DeleteCurrentUserThemeValue(THEMEPROP_SIZENAME));
                } else
                {
                    return S_FALSE; // S_FALSE means we did nothing really
                }
            }
        }
    }
    else
    {
        THR(SetCurrentUserThemeInt(THEMEPROP_THEMEACTIVE, 0));

        if (! fJustSetActive)     // wipe out all theme info
        {
            THR(DeleteCurrentUserThemeValue(THEMEPROP_DLLNAME));
            THR(DeleteCurrentUserThemeValue(THEMEPROP_COLORNAME));
            THR(DeleteCurrentUserThemeValue(THEMEPROP_SIZENAME));
            THR(DeleteCurrentUserThemeValue(THEMEPROP_LOADEDBEFORE));
            THR(DeleteCurrentUserThemeValue(THEMEPROP_LANGID));
        }
    }

    return S_OK;
}

//  --------------------------------------------------------------------------
void CThemeServices::SendThemeChangedMsg(BOOL fNewTheme, HWND hwndTarget, DWORD dwFlags,
    int iLoadId)
{
    WPARAM wParam;
    LPARAM lParamBits, lParamMixed;

    BOOL fExcluding = ((dwFlags & AT_EXCLUDE) != 0);
    BOOL fCustom = ((dwFlags & AT_PROCESS) != 0);

    //---- change number was set in ApplyTheme() for both global and preview cases ----
    int iChangeNum;
    if( SUCCEEDED(GetCurrentChangeNumber(&iChangeNum)) )
    {
        wParam = iChangeNum;

        lParamBits = 0;
        if (fNewTheme)
        {
            lParamBits |= WTC_THEMEACTIVE;
        }

        if (fCustom)
        {
            lParamBits |= WTC_CUSTOMTHEME;
        }

        if ((hwndTarget) && (! fExcluding))
        {
            SendMessage(hwndTarget, WM_THEMECHANGED, wParam, lParamBits);
        }
        else
        {
            lParamMixed = (iLoadId << 4) | (lParamBits & 0xf);

            CMessageBroadcast messageBroadcast;

            //  POST the WM_THEMECHANGED_TRIGGER msg to all targeted windows
            messageBroadcast.PostAllThreadsMsg(WM_THEMECHANGED_TRIGGER, wParam, lParamMixed);

            Log(LOG_TMCHANGEMSG, L"Just Broadcasted WM_THEMECHANGED_TRIGGER: iLoadId=%d", iLoadId);
        }
    }
}
//  --------------------------------------------------------------------------
int CThemeServices::GetLoadId(HANDLE hSectionOld)
{
    int iLoadId = 0;

    //---- extract LoadId from old section ----
    if (hSectionOld)
    {
        CThemeSection   pThemeSectionFile;

        if (SUCCEEDED(pThemeSectionFile.Open(hSectionOld)))
        {
            CUxThemeFile *pThemeFile = pThemeSectionFile;
            if (pThemeFile)
            {
                THEMEHDR *hdr = (THEMEHDR *)(pThemeFile->_pbThemeData);
                if (hdr)
                {
                    iLoadId = hdr->iLoadId;
                }
            }
        }
    }

    return iLoadId;
}

//  --------------------------------------------------------------------------
//  CThemeServices::ApplyTheme
//
//  Arguments:  pThemeFile  =   Object wrapping the theme section to apply.
//              dwFlags     =   Flags.
//              hwndTarget  =   HWND.
//
//  Returns:    HRESULT
//
//  Purpose:    Applies the given theme. Do some metric and color depth
//              validation, clear the stock bitmaps of the old theme, set
//              the given theme as the current theme and broadcast this fact.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------
//  In the design notes below, note that SEND and POST differences are 
//  significant.  
//
//  Also, when the "WM_THEMECHANGED_TRIGGER" msg is sent,
//  the uxtheme hooking code in each process will:
//
//      1. enumerate all windows for process (using desktop enumeration and 
//         the per-process "foreign window list") to:
//
//            a. process WM_THEMECHANGED for nonclient area
//            b. SEND a WM_THEMECHANGED msg to regular window
//
//      2. call FreeRenderObjects() for old theme, if any
//  --------------------------------------------------------------------------
//  To ensure correct window notification of theme changes and correct removal 
//  of old theme file RefCounts, the following CRITICAL STEPS must be taken 
//  in the 4 basic theme transition sequences:
//
//      turning ON preview theme:
//          a. turn ON global UAE hooks 
//          b. SEND WM_UAHINIT msg to hwndTarget
//          c. SEND WM_THEMECHANGED to hwndTarget
//
//      turning ON global theme:
//          a. turn ON global UAE hooks 
//          b. POST WM_UAHINIT msg to all accessible windows
//          c. POST WM_THEMECHANGED_TRIGGER to all accessible window threads
//
//      turning OFF preview theme:
//          c. SEND WM_THEMECHANGED to hwndTarget
//
//      turning OFF global theme:
//          a. turn OFF global UAE hooks 
//          b. step "a" will cause WM_THEMECHANGED_TRIGGER-type processing 
//             to occur from OnHooksDisabled() in each process
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::ApplyTheme (CUxThemeFile *pThemeFile, DWORD dwFlags, HWND hwndTarget)
{
    HRESULT         hr;
    bool            fNewTheme, fGlobal;
    int             iLoadId;
    WCHAR           szThemeFileName[MAX_PATH];
    WCHAR           szColorParam[MAX_PATH];
    WCHAR           szSizeParam[MAX_PATH];
    HANDLE          hSection = NULL;

    if (pThemeFile != NULL)
    {
        hSection = pThemeFile->Handle();
    }
    fGlobal = (((dwFlags & AT_EXCLUDE) != 0) ||
               ((hwndTarget == NULL) && ((dwFlags & AT_PROCESS) == 0)));
    fNewTheme = (hSection != NULL);
    iLoadId = 0;

    Log(LOG_TMHANDLE, L"ApplyTheme: hSection=0x%x, dwFlags=0x%x, hwndTarget=0x%x",
        hSection, dwFlags, hwndTarget);

    if (fNewTheme)
    {
        if (pThemeFile->HasStockObjects() && !fGlobal) // Don't do this
        {
            hr = E_INVALIDARG;
        }
        else
        {
            //---- get some basic info used thruout this function ----
            hr = GetThemeNameId(pThemeFile, 
                szThemeFileName, ARRAYSIZE(szThemeFileName),
                szColorParam, ARRAYSIZE(szColorParam),
                szSizeParam, ARRAYSIZE(szSizeParam),
                NULL, NULL);
            if (SUCCEEDED(hr))
            {
                //---- ensure color depth of monitor(s) are enough for theme ----
                if (GetSystemMetrics(SM_REMOTESESSION))     // only check for terminal server sessions
                {
                    hr = CheckColorDepth(pThemeFile);
                }

                if (SUCCEEDED(hr))
                {
                    //---- ensure hooks are on ----
                    hr = ThemeHooksOn(hwndTarget);
                }
            }
        }
    }
    else
    {
        hr = S_OK;
    }

    if (SUCCEEDED(hr) && fGlobal)
    {
        HANDLE  hSectionOld;

        //---- get a handle to the old global theme (for stock cleanup) ----
        hr = GetGlobalTheme(&hSectionOld);
        if (SUCCEEDED(hr))
        {
            //---- extract Load ID before theme becomes invalid (dwFlags & SECTION_READY=0) ----
            if (hSectionOld != NULL)
            {
                iLoadId = GetLoadId(hSectionOld);
            }

            //---- tell server to switch global themes ----
            hr = SetGlobalTheme(hSection);
            if (SUCCEEDED(hr))
            {
                //---- update needed registry settings ----
                if ((dwFlags & AT_NOREGUPDATE) == 0)       // if caller allows update
                {
                    hr = UpdateThemeRegistry(fNewTheme, szThemeFileName, szColorParam, szSizeParam, 
                        FALSE, TRUE);
                    if (FAILED(hr))
                    {
                        Log(LOG_ALWAYS, L"UpdateThemeRegistry call failed, hr=0x%x", hr);
                        hr = S_OK;      // not a fatal error
                    }
                }

                //---- set system metrics, if requested ----
                if ((dwFlags & AT_LOAD_SYSMETRICS) != 0)
                {
                    BOOL fSync = ((dwFlags & AT_SYNC_LOADMETRICS) != 0);

                    if (fNewTheme)
                    {
                        SetSystemMetrics(GetThemeMetricsPtr(pThemeFile), fSync);
                    }
                    else        // just load classic metrics 
                    {
                        LOADTHEMEMETRICS tm;

                        hr = InitThemeMetrics(&tm);
                        if (SUCCEEDED(hr))
                        {
                            SetSystemMetrics(&tm, fSync);
                        }
                    }
                }
            }
            if (hSectionOld != NULL)
            {
                TBOOL(CloseHandle(hSectionOld));
            }
        }
    }

    //---- if we turned off global theme, turn hooks off now ----
    if (SUCCEEDED(hr))
    {
        if (!fNewTheme && fGlobal)
        {
            hr = ThemeHooksOff(); 
        }
        else 
        {
            //---- send the correct WM_THEMECHANGED_XXX msg to window(s) ----
            SendThemeChangedMsg(fNewTheme, hwndTarget, dwFlags, iLoadId);
        }
    }
    // If the service is down but we're trying to turn Themes off, clean up the registry
    else if (hr == MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT) && !fNewTheme && fGlobal && (dwFlags & AT_NOREGUPDATE) == 0)
    {
        // Ignore failure here
        UpdateThemeRegistry(fNewTheme, NULL, NULL, NULL, FALSE, TRUE);
    }

    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::AdjustTheme
//
//  Arguments:  BOOL fEnable - if TRUE, enable CU theme; if FALSE, disable it
//
//  Returns:    HRESULT
//              
//  Purpose:    for 3rd party skinning apps to cooperate better with theme mgr
//
//  History:    2001-03-12  rfernand        created
//  --------------------------------------------------------------------------
HRESULT CThemeServices::AdjustTheme(BOOL fEnable)
{
    HRESULT hr = UpdateThemeRegistry(fEnable, NULL, NULL, NULL, TRUE, FALSE);

    if (SUCCEEDED(hr))
    {
        hr = InitUserTheme(FALSE);
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CThemeServices::ApplyDefaultMetrics
//
//  Arguments:  <none>
//
//  Returns:    <none>
//              
//  Purpose:    Make sure the user metrics gets reset to Windows Standard
//
//  History:    2001-03-30  lmouton     created
//  --------------------------------------------------------------------------
void CThemeServices::ApplyDefaultMetrics(void)
{            
    HKEY            hKeyThemes;
    CCurrentUser    hKeyCurrentUser(KEY_READ | KEY_WRITE);

    Log(LOG_TMLOAD, L"Applying default metrics");

    if ((ERROR_SUCCESS == RegOpenKeyEx(hKeyCurrentUser,
                                       THEMES_REGKEY L"\\" SZ_DEFAULTVS_OFF,
                                       0,
                                       KEY_QUERY_VALUE,
                                       &hKeyThemes)))
    {
        WCHAR szVisualStyle[MAX_PATH] = {L'\0'};
        WCHAR szColor[MAX_PATH] = {L'\0'};
        WCHAR szSize[MAX_PATH] = {L'\0'};
        BOOL  fGotOne;
        
        // Note: These will fail for the first user logon, themeui sets these keys and needs to call InstallVS itself

        fGotOne = SUCCEEDED(RegistryStrRead(hKeyThemes, SZ_INSTALLVISUALSTYLE, szVisualStyle, ARRAYSIZE(szVisualStyle)));
        fGotOne = SUCCEEDED(RegistryStrRead(hKeyThemes, SZ_INSTALLVISUALSTYLECOLOR, szColor, ARRAYSIZE(szColor))) 
            || fGotOne;
        fGotOne = SUCCEEDED(RegistryStrRead(hKeyThemes, SZ_INSTALLVISUALSTYLESIZE, szSize, ARRAYSIZE(szSize))) 
            || fGotOne;

        if (fGotOne)
        {
            // At least one key is present in the registry, it may be enough
            WCHAR szSysDir[MAX_PATH];

            if (0 < GetSystemDirectory(szSysDir, ARRAYSIZE(szSysDir)))
            {
                WCHAR *pszCmdLine = new WCHAR[MAX_PATH * 5];

                if (pszCmdLine)
                {
                    StringCchPrintfW(pszCmdLine, MAX_PATH * 5, L"%s\\regsvr32.exe /s /n /i:\"" SZ_INSTALL_VS L"%s','%s','%s'\" %s\\themeui.dll", szSysDir, szVisualStyle, szColor, szSize, szSysDir);
    
                    // Set a reg key to have themeui install the proper settings instead of defaults
                    // We can't do this now because the user could not be completely logged on

                    HKEY hKeyRun;

                    if ((ERROR_SUCCESS == RegOpenKeyEx(hKeyCurrentUser, REGSTR_PATH_RUNONCE, 0, KEY_SET_VALUE, &hKeyRun)))
                    {
                        THR(RegistryStrWrite(hKeyRun, szColor, pszCmdLine));
                        TW32(RegCloseKey(hKeyRun));
                    }
                    
                    delete [] pszCmdLine;
                }
            }
        }
        TW32(RegCloseKey(hKeyThemes));
    }
}

//  --------------------------------------------------------------------------
//  CThemeServices::InitUserTheme
//
//  Arguments:  BOOL fPolicyCheckOnly 
//                 TRUE means 
//                 "only do something if the policy is different from the current loaded theme"
//
//  Returns:    HRESULT
//              
//  Purpose:    Special entry point for winlogon/msgina to control themes
//              for user logon/logoff.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::InitUserTheme (BOOL fPolicyCheckOnly)
{
    BOOL fActive = FALSE;
    BOOL fOldActive = FALSE;
    BOOL fPolicyActive = FALSE;

    //---- should theme be active for this user? ----
    if (! IsRemoteThemeDisabled())
    {
        THR(GetCurrentUserThemeInt(THEMEPROP_THEMEACTIVE, FALSE, &fActive));
    
        fOldActive = fActive;

        fPolicyActive = ThemeEnforcedByPolicy(fActive != FALSE);
        if (fPolicyActive)
        {
            // Refresh fActive because the policy changed it
            THR(GetCurrentUserThemeInt(THEMEPROP_THEMEACTIVE, FALSE, &fActive));
        }

        if ((fActive) && (ThemeSettingsModified()))
        {
            fActive = FALSE;
        }
    }

#ifdef DEBUG
    if (LogOptionOn(LO_TMLOAD))
    {
        WCHAR szUserName[MAX_PATH];
        DWORD dwSize = ARRAYSIZE(szUserName);
    
        GetUserName(szUserName, &dwSize);

        Log(LOG_TMLOAD, L"InitUserTheme: User=%s, ThemeActive=%d, SM_REMOTESESSION=%d, fPolicyActive=%d, fPolicyCheckOnly=%d", 
            szUserName, fActive, GetSystemMetrics(SM_REMOTESESSION), fPolicyActive, fPolicyCheckOnly);
    }
#endif

    BOOL fEarlyExit = FALSE;

    if (fPolicyCheckOnly)
    {
        // Bail out early if nothing has changed since last time, which is most of the time
        if (!fPolicyActive)
        {
            Log(LOG_TMLOAD, L"InitUserTheme: Nothing to do after Policy check");
            fEarlyExit = TRUE;
        } else
        {
            Log(LOG_TMLOAD, L"InitUserTheme: Reloading after Policy check");
        }
    }

    if (!fEarlyExit)
    {
        if (fActive)
        {
            //---- load this user's theme ----
            HRESULT hr = LoadCurrentTheme();

            if (FAILED(hr))
            {
                fActive = FALSE;
            }
        }

        if (! fActive)          // turn off themes
        {
            // if fPolicyActive, force refresh system metrics from temporary defaults
            THR(ApplyTheme(NULL, AT_NOREGUPDATE | (fPolicyActive ? AT_LOAD_SYSMETRICS | AT_SYNC_LOADMETRICS: 0), false));

            // Apply the proper default metrics
            if (fPolicyActive)
            {
                ApplyDefaultMetrics();
            }
        }
    }

    return S_OK;        // never fail this guy
}

//  --------------------------------------------------------------------------
//  CThemeServices::InitUserRegistry
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//              
//  Purpose:    Propogate settings from HKLM to HKCU. This should only be
//              invoked for ".Default" hives. Assert to ensure this.
//
//  History:    2000-11-11  vtan        created (ported from themeldr.cpp)
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::InitUserRegistry (void)

{
    HRESULT         hr;
    DWORD           dwErrorCode;
    HKEY            hklm;
    CCurrentUser    hkeyCurrentUser(KEY_READ | KEY_WRITE);

#ifdef      DEBUG
    ASSERT(CThemeServer::IsSystemProcessContext());
#endif  /*  DEBUG   */

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      THEMEMGR_REGKEY,
                                      0,
                                      KEY_QUERY_VALUE | KEY_SET_VALUE,
                                      &hklm))
    {
        HKEY    hkcu;

        if (ERROR_SUCCESS == RegCreateKeyEx(hkeyCurrentUser,
                                            THEMEMGR_REGKEY,
                                            0,
                                            NULL,
                                            0,
                                            KEY_QUERY_VALUE | KEY_SET_VALUE,
                                            NULL,
                                            &hkcu,
                                            NULL))
        {
            int     iLMVersion;

            hr = RegistryIntRead(hklm, THEMEPROP_LMVERSION, &iLMVersion);
            if (SUCCEEDED(hr))
            {
                int     iCUVersion;

                if (FAILED(RegistryIntRead(hkcu, THEMEPROP_LMVERSION, &iCUVersion)))
                {
                    iCUVersion = 0;
                }
                if (iLMVersion != iCUVersion)
                {
                    BOOL    fOverride;
                    WCHAR   szValueData[MAX_PATH];

                    hr = RegistryIntWrite(hkcu, THEMEPROP_LMVERSION, iLMVersion);
                    if (FAILED(hr) || FAILED(RegistryIntRead(hklm, THEMEPROP_LMOVERRIDE, &fOverride)))
                    {
                        fOverride = FALSE;
                    }
                    if ((fOverride != FALSE) ||
                        FAILED(RegistryStrRead(hkcu, THEMEPROP_DLLNAME, szValueData, ARRAYSIZE(szValueData))) ||
                        (lstrlenW(szValueData) == 0))
                    {
                        DWORD   dwIndex;

                        dwIndex = 0;
                        do
                        {
                            DWORD   dwType, dwValueNameSize, dwValueDataSize;
                            WCHAR   szValueName[MAX_PATH];

                            dwValueNameSize = ARRAYSIZE(szValueName);
                            dwValueDataSize = sizeof(szValueData);
                            dwErrorCode = RegEnumValue(hklm,
                                                       dwIndex++,
                                                       szValueName,
                                                       &dwValueNameSize,
                                                       NULL,
                                                       &dwType,
                                                       reinterpret_cast<LPBYTE>(szValueData),
                                                       &dwValueDataSize);
                            if ((ERROR_SUCCESS == dwErrorCode) &&
                                ((REG_SZ == dwType) || (REG_EXPAND_SZ == dwType)) &&
                                (AsciiStrCmpI(szValueName, THEMEPROP_LMOVERRIDE) != 0))
                            {
                                if (AsciiStrCmpI(szValueName, THEMEPROP_DLLNAME) == 0)
                                {
                                    hr = RegistryStrWriteExpand(hkcu, szValueName, szValueData);
                                }
                                else
                                {
                                    hr = RegistryStrWrite(hkcu, szValueName, szValueData);
                                }
                            }
                        } while ((dwErrorCode == ERROR_SUCCESS) && SUCCEEDED(hr));
                        // Since we wrote a new DLL name, erase the old names
                        (DWORD)RegDeleteValue(hkcu, THEMEPROP_COLORNAME);
                        (DWORD)RegDeleteValue(hkcu, THEMEPROP_SIZENAME);
                    }
                }
            }
            else
            {
                hr = S_OK;
            }

            BOOL fLoadedBefore = 1;

            if (SUCCEEDED(RegistryIntRead(hklm, THEMEPROP_LOADEDBEFORE, &fLoadedBefore)) && fLoadedBefore == 0)
            {
                // HKLM\..\LoadedBefore was reset to 0 during Setup, propagate it to HKCU (.DEFAULT), so that the 
                // metrics get refreshed for the Winlogon dialogs.
                RegistryIntWrite(hkcu, THEMEPROP_LOADEDBEFORE, 0);
                // Mark it done
                RegistryIntWrite(hklm, THEMEPROP_LOADEDBEFORE, 1);
            }

            TW32(RegCloseKey(hkcu));
        }
        else
        {
            dwErrorCode = GetLastError();
            hr = HRESULT_FROM_WIN32(dwErrorCode);
        }
        TW32(RegCloseKey(hklm));
    }
    else
    {
        //  It's possible for this key to be absent. Ignore the error.

        hr = S_OK;
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::ReestablishServerConnection
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//              
//  Purpose:    Forces an attempt to reconnect to the theme server. Used when
//              the port was disconnected but a refresh is desired because the
//              server came back up.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::ReestablishServerConnection (void)

{
    HRESULT     hr;
    NTSTATUS    status;

    //---- do we have a good looking handle that as gone bad? ----
    if ((s_hAPIPort != NULL) && (s_hAPIPort != INVALID_HANDLE_VALUE))
    {
        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_PING;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hAPIPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
        }
    }
    else
    {
        status = STATUS_PORT_DISCONNECTED;
    }

    if (NT_SUCCESS(status))
    {
        hr = S_OK;
    }
    else
    {
        //---- our handle has gone bad; reset for another try on next service call ----
        LockAcquire();
        if ((s_hAPIPort != NULL) && (s_hAPIPort != INVALID_HANDLE_VALUE))
        {
            TBOOL(CloseHandle(s_hAPIPort));
        }
        s_hAPIPort = INVALID_HANDLE_VALUE;
        LockRelease();
        hr = S_FALSE;
    }

    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::LockAcquire
//
//  Arguments:  <none>
//
//  Returns:    <none>
//              
//  Purpose:    Acquire the critical section.
//
//  History:    2000-12-01  vtan        created
//  --------------------------------------------------------------------------

void    CThemeServices::LockAcquire (void)
{
    SAFE_ENTERCRITICALSECTION(&s_lock);
}

//  --------------------------------------------------------------------------
//  CThemeServices::LockRelease
//
//  Arguments:  <none>
//
//  Returns:    <none>
//              
//  Purpose:    Release the critical section.
//
//  History:    2000-12-01  vtan        created
//  --------------------------------------------------------------------------

void    CThemeServices::LockRelease (void)
{
    SAFE_LEAVECRITICALSECTION(&s_lock);
}

//  --------------------------------------------------------------------------
//  CThemeServices::ConnectedToService
//
//  Arguments:  <none>
//
//  Returns:    bool
//              
//  Purpose:    Demand connect to service. Only do this once. This function
//              has knowledge of where the port exists within the NT object
//              namespace.
//
//  History:    2000-10-27  vtan        created
//  --------------------------------------------------------------------------

bool    CThemeServices::ConnectedToService (void)

{
    if (s_hAPIPort == INVALID_HANDLE_VALUE)
    {
        ULONG                           ulConnectionInfoLength;
        UNICODE_STRING                  portName;
        SECURITY_QUALITY_OF_SERVICE     sqos;
        WCHAR                           szConnectionInfo[32];

        RtlInitUnicodeString(&portName, THEMES_PORT_NAME);
        sqos.Length = sizeof(sqos);
        sqos.ImpersonationLevel = SecurityImpersonation;
        sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        sqos.EffectiveOnly = TRUE;
        StringCchCopyW(szConnectionInfo, ARRAYSIZE(szConnectionInfo), THEMES_CONNECTION_REQUEST);
        ulConnectionInfoLength = sizeof(szConnectionInfo);
        LockAcquire();
        if (!NT_SUCCESS(NtConnectPort(&s_hAPIPort,
                                      &portName,
                                      &sqos,
                                      NULL,
                                      NULL,
                                      NULL,
                                      szConnectionInfo,
                                      &ulConnectionInfoLength)))
        {
            s_hAPIPort = NULL;
        }
        LockRelease();
    }
    return(s_hAPIPort != NULL);
}

//  --------------------------------------------------------------------------
//  CThemeServices::ReleaseConnection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//              
//  Purpose:    Releases the API port connection.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

void    CThemeServices::ReleaseConnection (void)

{
    if ((s_hAPIPort != INVALID_HANDLE_VALUE) && (s_hAPIPort != NULL))
    {
        LockAcquire();
        TBOOL(CloseHandle(s_hAPIPort));
        s_hAPIPort = INVALID_HANDLE_VALUE;
        LockRelease();
    }
}

//  --------------------------------------------------------------------------
//  CThemeServices::CheckForDisconnectedPort
//
//  Arguments:  status  =   NTSTATUS of last API request.
//
//  Returns:    <none>
//              
//  Purpose:    Checks for STATUS_PORT_DISCONNECTED. If found then it
//              releases the port object and NULL out the handle.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

void    CThemeServices::CheckForDisconnectedPort (NTSTATUS status)

{
    if (STATUS_PORT_DISCONNECTED == status)
    {
        ReleaseConnection();
    }
#ifdef DEBUG
    else if( !NT_SUCCESS(status) )
    {
        Log(LOG_ALWAYS, L"ThemeServices::CheckForDisconnectedPort failure status code: %08lX\n", status);
    }
#endif DEBUG
}

//  --------------------------------------------------------------------------
//  CThemeServices::CurrentThemeMatch
//
//  Arguments:  pszThemeName            =   Name of theme.
//              pszColor                =   Color.
//              pszSize                 =   Size.
//              fLoadMetricsOnMatch     =   Load metrics.
//
//  Returns:    HRESULT
//              
//  Purpose:    Is the current theme the same as the theme specified? This
//              can be used to save reloading a theme when it's the same.
//
//  History:    2000-11-11  vtan        created (ported from themeldr.cpp)
//  --------------------------------------------------------------------------

bool    CThemeServices::CurrentThemeMatch (LPCWSTR pszThemeName, LPCWSTR pszColor, LPCWSTR pszSize, LANGID wLangID, bool fLoadMetricsOnMatch)

{
    bool    fMatch;
    HANDLE  hSection;

    fMatch = false;

    if (SUCCEEDED(GetGlobalTheme(&hSection)) && (hSection != NULL))
    {
        CThemeSection   pThemeSectionFile;

        if (SUCCEEDED(pThemeSectionFile.Open(hSection)))
        {
            fMatch = (ThemeMatch(pThemeSectionFile, pszThemeName, pszColor, pszSize, wLangID) != FALSE);

            if (fMatch)
            {
                //---- ensure color depth of monitor(s) are enough for theme ----
                if (GetSystemMetrics(SM_REMOTESESSION))     // only check for terminal server sessions
                {
                    if (FAILED(CheckColorDepth(pThemeSectionFile)))
                    {
                        fMatch = FALSE;
                    }
                }
            }

            if (fMatch && fLoadMetricsOnMatch)
            {
                SetSystemMetrics(GetThemeMetricsPtr(pThemeSectionFile), FALSE);
            }
        }
        TBOOL(CloseHandle(hSection));
    }
    return(fMatch);
}

//  --------------------------------------------------------------------------
//  CThemeServices::LoadCurrentTheme
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//              
//  Purpose:    Loads the current theme as set in the registry for the
//              impersonated user.
//
//  History:    2000-11-11  vtan        created (ported from themeldr.cpp)
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::LoadCurrentTheme (void)

{
    HRESULT     hr = S_OK;
    WCHAR       szThemeName[MAX_PATH];
    WCHAR       szColorName[MAX_PATH];
    WCHAR       szSizeName[MAX_PATH];

    THR(GetCurrentUserThemeString(THEMEPROP_DLLNAME, L"", szThemeName, ARRAYSIZE(szThemeName)));
    if (szThemeName[0] != L'\0')
    {
        int     iLoadedBefore;
        HANDLE  hSection;
        int     nLangID;

        THR(GetCurrentUserThemeString(THEMEPROP_COLORNAME, L"", szColorName, ARRAYSIZE(szColorName)));
        THR(GetCurrentUserThemeString(THEMEPROP_SIZENAME, L"", szSizeName, ARRAYSIZE(szSizeName)));
        THR(GetCurrentUserThemeInt(THEMEPROP_LOADEDBEFORE, 0, &iLoadedBefore));
        THR(GetCurrentUserThemeInt(THEMEPROP_LANGID, -1, &nLangID));

    //  Does new user's theme match the current theme?
        if (nLangID != -1 && CurrentThemeMatch(szThemeName, szColorName, szSizeName, (LANGID) nLangID, (iLoadedBefore == 0)))
        {
            DWORD   dwFlags;

            //  Everything is done except this registry value.

            if (iLoadedBefore == 0)
            {
                THR(SetCurrentUserThemeInt(THEMEPROP_LOADEDBEFORE, 1));
            }

            hr = GetStatusFlags(&dwFlags);
            if (SUCCEEDED(hr))
            {
                if ((dwFlags & QTS_RUNNING) == 0)
                {
                    hr = GetGlobalTheme(&hSection);
                    if (SUCCEEDED(hr))
                    {
                        CUxThemeFile file; // Will clean up on destruction
                        
                        if (SUCCEEDED(file.OpenFromHandle(hSection, FILE_MAP_READ, TRUE)))
                        {
                            hr = ApplyTheme(&file, 0, false);
                        }
                    }
                }
            }
        }
        else
        {
            hr = LoadTheme(&hSection, szThemeName, szColorName, szSizeName, TRUE);

            if (SUCCEEDED(hr))
            {
                DWORD   dwFlags;

                dwFlags = 0;

                //  Has this theme been loaded before?
                //  or has the user changed his/her language?
                if (iLoadedBefore == 0 || ((nLangID != -1) && ((LANGID) nLangID != GetUserDefaultUILanguage())))
                {
                    dwFlags |= AT_LOAD_SYSMETRICS;
                }

                CUxThemeFile file; // Will clean up on destruction
                
                if (SUCCEEDED(file.OpenFromHandle(hSection, FILE_MAP_READ, TRUE)))
                {
                    hr = ApplyTheme(&file, dwFlags, false);
                }
            }
        }
    }
    else
    {
        hr = MakeError32(ERROR_NOT_FOUND);
    }

    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::SectionProcessType
//
//  Arguments:  hSection    =   Section to walk and clear stock objects in.
//
//  Returns:    HRESULT
//              
//  Purpose:    Walks the section (read-only) and finds HBITMAPs that are stock 
//              listed in the section and deletes these objects. 
//              This is work that needs to be done on the client.
//
//  History:    2000-11-17  lmouton     created
//                          vtan        rewritten from themeldr.cpp
//  --------------------------------------------------------------------------

int     CThemeServices::SectionProcessType (const BYTE *pbThemeData, MIXEDPTRS& u)

{
    UNPACKED_ENTRYHDR   header;

    FillAndSkipHdr(u, &header);
    switch (header.ePrimVal)
    {
        case TMT_PARTJUMPTABLE:
        case TMT_STATEJUMPTABLE:
            break;
        case TMT_DIBDATA:
            TMBITMAPHEADER *pThemeBitmapHeader;

            pThemeBitmapHeader = reinterpret_cast<TMBITMAPHEADER*>(u.pb);
            ASSERT(pThemeBitmapHeader->dwSize == TMBITMAPSIZE);

            // Clean up stock bitmaps
            if (pThemeBitmapHeader->hBitmap != NULL)
            {
                HBITMAP     hBitmap;

                hBitmap = pThemeBitmapHeader->hBitmap;
                hBitmap = ClearBitmapAttributes(hBitmap, SBA_STOCK);
#ifdef DEBUG
                if (hBitmap == NULL)
                {
                    Log(LOG_TMBITMAP, L"UxTheme: ClearBitmapAttributes failed for %8X in SetGlobalTheme", hBitmap);
                }
                else if (!DeleteObject(hBitmap))
                {
                    Log(LOG_TMBITMAP, L"Failed to delete bitmap:%8X", hBitmap);
                }
#else
                if (hBitmap != NULL)
                {
                    DeleteObject(hBitmap);
                }
#endif
            }

            //  Fall thru to the default case that increments the mixed pointer.

        default:
            u.pb += header.dwDataLen;
            break;
    }
    return(header.ePrimVal);
}

//  --------------------------------------------------------------------------
//  CThemeServices::SectionWalkData
//
//  Arguments:  pV      =   Address of section data to walk.
//              iIndex  =   Index into section.
//
//  Returns:    <none>
//              
//  Purpose:    
//
//  History:    2000-11-17  lmouton     created
//                          vtan        rewritten from themeldr.cpp
//  --------------------------------------------------------------------------

void    CThemeServices::SectionWalkData (const BYTE *pbThemeData, int iIndexIn)

{
    bool        fDone;
    MIXEDPTRS   u;

    fDone = false;
    u.pb = const_cast<BYTE*>(pbThemeData + iIndexIn);
    while (!fDone)
    {
        //---- special post-handling ----
        switch (SectionProcessType(pbThemeData, u))
        {
            int     i, iLimit, iIndex;

            case TMT_PARTJUMPTABLE:
                u.pi++;
                iLimit = *u.pb++;
                for (i = 0; i < iLimit; ++i)
                {
                    iIndex = *u.pi++;
                    if (iIndex > -1)
                    {
                        SectionWalkData(pbThemeData, iIndex);
                    }
                }
                fDone = true;
                break;
            case TMT_STATEJUMPTABLE:
                iLimit = *u.pb++;
                for (i = 0; i < iLimit; ++i)
                {
                    iIndex = *u.pi++;
                    if (iIndex > -1)
                    {
                        SectionWalkData(pbThemeData, iIndex);
                    }
                }
                fDone = true;
                break;
            case TMT_JUMPTOPARENT:
                fDone = true;
                break;
            default:
                break;
        }
    }
}

//  --------------------------------------------------------------------------
//  CThemeServices::ClearStockObjects
//
//  Arguments:  hSection    =   Section to walk and clear bitmaps in.
//
//  Returns:    HRESULT
//              
//  Purpose:    Walks the section (read-only) and finds HBITMAPs and corresponding
//              HBRUSHes that are stock listed in the section and deletes these objects. 
//              This is work that needs to be done on the client.
//
//  History:    2000-11-17  lmouton     created
//                          vtan        rewritten from themeldr.cpp
//              2001-05-15  lmouton     Added semaphore support for cleaning from ~CUxThemeFile
//  --------------------------------------------------------------------------

HRESULT     CThemeServices::ClearStockObjects (HANDLE hSection, BOOL fForce)

{
    HRESULT         hr;
    BYTE*           pbThemeData;
    bool            bWriteable = true;
    HANDLE          hSectionWrite = NULL;

    // If the section is global, we can't write to it since only the server can.
    // So let's try to get write access, else we'll call the server
    pbThemeData = static_cast<BYTE*>(MapViewOfFile(hSection,
                                                   FILE_MAP_WRITE,
                                                   0,
                                                   0,
                                                   0));
    if (pbThemeData == NULL)
    {
        // Let's try to reopen a write handle for ourselves
        if (DuplicateHandle(GetCurrentProcess(),
                            hSection,
                            GetCurrentProcess(),
                            &hSectionWrite,
                            FILE_MAP_WRITE,
                            FALSE,
                            0) != FALSE)
        {
            pbThemeData = static_cast<BYTE*>(MapViewOfFile(hSectionWrite,
                                                           FILE_MAP_WRITE,
                                                           0,
                                                           0,
                                                           0));
        }

        if (pbThemeData == NULL)
        {
            // We can't open it for write, let's try read-only
            pbThemeData = static_cast<BYTE*>(MapViewOfFile(hSection,
                                                           FILE_MAP_READ,
                                                           0,
                                                           0,
                                                           0));
            bWriteable = false;
        }
#ifdef DEBUG
        else
        {
            Log(LOG_TMLOAD, L"Reopened section %d for write", reinterpret_cast<THEMEHDR*>(pbThemeData)->iLoadId);
        }
#endif
    }

#ifdef DEBUG
    if (LogOptionOn(LO_TMLOAD))
    {
        // Unexpected failure
        ASSERT(pbThemeData != NULL);
    }
#endif

    if (pbThemeData != NULL)
    {
        int                 i, iLimit;
        THEMEHDR   *pThemeHdr;
        APPCLASSLIVE        *pACL;

        pThemeHdr = reinterpret_cast<THEMEHDR*>(pbThemeData);
        hr = S_OK;

        Log(LOG_TMLOAD, L"ClearStockObjects for section %X, bWriteable=%d, dwFlags=%d, iLoadId=%d, fForce=%d", 
            hSection, bWriteable, pThemeHdr->dwFlags, pThemeHdr->iLoadId, fForce);

        volatile THEMEHDR* pTmpHdr = pThemeHdr;
        
        //  If this is a local section with stock objects, it's this process's responsibility to
        //  clean them up.
        if ((pTmpHdr->dwFlags & SECTION_HASSTOCKOBJECTS) && !(pTmpHdr->dwFlags & SECTION_GLOBAL))
        {
            // Make sure we don't contend with any other cleanup threads
            WCHAR szName[64];

            if (pThemeHdr->iLoadId != 0)
            {
                // Each section has a unique iLoadId but not across sessions
                // It has to be global because the Theme service can create it
                StringCchPrintfW(szName, ARRAYSIZE(szName), 
                                 L"Global\\ClearStockGlobal%d-%d", pThemeHdr->iLoadId, NtCurrentPeb()->SessionId);
            }
            else
            {
                // The session is local to the process
                StringCchPrintfW(szName, ARRAYSIZE(szName), 
                                 L"ClearStockLocal%d-%d", GetCurrentProcessId(), NtCurrentPeb()->SessionId);
            }

            HANDLE hSemaphore = CreateSemaphore(NULL, 0, 1, szName);
            DWORD dwError = GetLastError();

            Log(LOG_TMLOAD, L"Opening semaphore %s, hSemaphore=%X, gle=%d", szName, hSemaphore, dwError);

            // If CreateSemaphore fails for another reason, ignore the failure, we have to clean and we only 
            //   risk a GDI assert on CHK builds.
            // We'll get access denied if the semaphore was created in the service on SetGlobalTheme, but 
            //   in this case fForce is true for winlogon, false for the other callers.
            bool bAlreadyExists = (dwError == ERROR_ALREADY_EXISTS || dwError == ERROR_ACCESS_DENIED);

#ifdef DEBUG
            if (LogOptionOn(LO_TMLOAD))
            {
                // Unexpected failure
                ASSERT(dwError == 0 || bAlreadyExists);
            }
#endif
            //  Recheck again that this is a local section with stock objects.  We've seen in stress
            //  runs where in the middle of creating the semaphore (above), another thread
            //  raced ahead and removed the SECTION_GLOBAL flag and cleared the stock bitmaps, but hadn't 
            //  quite gotten around to removing the SECTION_HASSTOCKOBJECTS bit before this thread 
            //  woke up and executed, resulting in hundreds of GDI assertions that the bitmap isn't stock, etc.
            if ((!bAlreadyExists || fForce) 
                && ((pTmpHdr->dwFlags & SECTION_HASSTOCKOBJECTS) && !(pTmpHdr->dwFlags & SECTION_GLOBAL)))
            {
                // If nobody else is already doing it
                Log(LOG_TMLOAD, L"ClearStockObjects: Clearing data, semaphore = %s", szName);
#ifdef DEBUG
                bool bDisconnected = false;
#endif
                pACL = reinterpret_cast<APPCLASSLIVE*>(pbThemeData + pThemeHdr->iSectionIndexOffset);
                iLimit = pThemeHdr->iSectionIndexLength / sizeof(APPCLASSLIVE);

                for (i = 0; i < iLimit; ++pACL, ++i)
                {
                    SectionWalkData(pbThemeData, pACL->iIndex);
                }
                if (bWriteable)
                {
                    pThemeHdr->dwFlags &= ~SECTION_HASSTOCKOBJECTS; // To avoid doing it twice
                }
                else
                {
                    // Can't write to it, let's call MarkSection in the service to do it
                    hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
                    if (ConnectedToService())
                    {
                        NTSTATUS                status;
                        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

                        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
                        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
                        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_MARKSECTION;
                        portMessageIn.apiThemes.apiSpecific.apiMarkSection.in.hSection = hSection;
                        portMessageIn.apiThemes.apiSpecific.apiMarkSection.in.dwAdd = 0;
                        portMessageIn.apiThemes.apiSpecific.apiMarkSection.in.dwRemove = SECTION_HASSTOCKOBJECTS;
                        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
                        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
                        status = NtRequestWaitReplyPort(s_hAPIPort,
                                                        &portMessageIn.portMessage,
                                                        &portMessageOut.portMessage);
                        CheckForDisconnectedPort(status);
#ifdef DEBUG
                        if (STATUS_PORT_DISCONNECTED == status)
                        {
                            bDisconnected = true; // This failure must not trigger the assert
                        }
#endif
                        if (NT_SUCCESS(status))
                        {
                            status = portMessageOut.apiThemes.apiGeneric.status;
                            if (NT_SUCCESS(status))
                            {
                                hr = S_OK;
                            }
                        }
                        if (!NT_SUCCESS(status))
                        {
                            hr = HRESULT_FROM_NT(status);
                        }
                    }
                }
#ifdef DEBUG
                // When the service goes down, we may fail ApplyTheme (so iLoadId is still 0), 
                //   and we fail MarkSection too, ignore this error.
                if (LogOptionOn(LO_TMLOAD) && !bDisconnected && pThemeHdr->iLoadId != 0)
                {
                    ASSERT(!(pThemeHdr->dwFlags & SECTION_HASSTOCKOBJECTS));
                }
#endif
            }
            else
            {
                Log(LOG_TMLOAD, L"ClearStockObjects: Doing nothing, semaphore %s, dwFlags=%d, gle=%d", szName, pThemeHdr->dwFlags, dwError);
            }
            if (hSemaphore)
            {
                Log(LOG_TMLOAD, L"ClearStockObjects: Closing semaphore %X", hSemaphore);
                CloseHandle(hSemaphore);
            }
        }

        TBOOL(UnmapViewOfFile(pbThemeData));
    }
    else
    {
        DWORD   dwErrorCode;

        dwErrorCode = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErrorCode);
    }

    if (hSectionWrite != NULL)
    {
        CloseHandle(hSectionWrite);
    }

    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServices::ThemeSettingsModified
//
//  Returns:    BOOL
//              
//  Purpose:    Detects that appearance settings have been changed on a
//                W2K machine by a roaming user.
//
//  History:    2000-11-28  lmouton          created
//  --------------------------------------------------------------------------

bool    CThemeServices::ThemeSettingsModified (void)

{
    WCHAR   szCurrent[MAX_PATH];
    WCHAR   szNewCurrent[MAX_PATH];

    //  If NewCurrent exists and is different from Current, Current
    //  has been tampered with on a roaming W2K machine

    THR(GetCurrentUserString(CONTROLPANEL_APPEARANCE_REGKEY, THEMEPROP_CURRSCHEME, L" ", szCurrent, ARRAYSIZE(szCurrent)));
    THR(GetCurrentUserString(CONTROLPANEL_APPEARANCE_REGKEY, THEMEPROP_NEWCURRSCHEME, L" ", szNewCurrent, ARRAYSIZE(szNewCurrent)));
    return((lstrcmpW(szNewCurrent, L" ") != 0) && (lstrcmpW(szCurrent, szNewCurrent) != 0));
}

//  --------------------------------------------------------------------------
//  CThemeServices::ThemeEnforcedByPolicy
//
//  Arguments:  BOOL        TRUE if a .msstyles file is currently active for the user
//
//  Returns:    BOOL        TRUE if the policy changed something
//              
//  Purpose:    Loads the .msstyles file specified in the SetVisualStyle policy.
//
//  History:    2000-11-28  lmouton          created
//  --------------------------------------------------------------------------

bool    CThemeServices::ThemeEnforcedByPolicy (bool fActive)

{
    bool            fPolicyPresent;
    HKEY            hKeyPol = NULL;
    CCurrentUser    hKeyCurrentUser(KEY_READ | KEY_WRITE);

    fPolicyPresent = false;

    // See if a policy overrides the theme name
    if ((ERROR_SUCCESS == RegOpenKeyEx(hKeyCurrentUser,
                                       REGSTR_PATH_POLICIES L"\\" SZ_THEME_POLICY_KEY,
                                       0,
                                       KEY_QUERY_VALUE,
                                       &hKeyPol)))
    {
        WCHAR   szNewThemeName[MAX_PATH + 1];

        StringCchCopyW(szNewThemeName, ARRAYSIZE(szNewThemeName), L" ");
        if (SUCCEEDED(RegistryStrRead(hKeyPol,
                                      SZ_POLICY_SETVISUALSTYLE,
                                      szNewThemeName,
                                      ARRAYSIZE(szNewThemeName))))
        {
            if (szNewThemeName[0] == L'\0') // Disable themes
            {
                if (fActive)
                {
                    THR(UpdateThemeRegistry(FALSE, NULL, NULL, NULL, FALSE, FALSE));

                    fPolicyPresent = true;
                }
            }
            else
            {
                if (FileExists(szNewThemeName))
                {
                    HRESULT hr = UpdateThemeRegistry(TRUE, szNewThemeName, NULL, NULL, FALSE, FALSE);

                    THR(hr);
                    if (!fActive || hr == S_OK)
                    {
                        // If we had no theme before or a different one, say we changed something
                        fPolicyPresent = true;
                    }
                }
            }
        }
        TW32(RegCloseKey(hKeyPol));
    }
    return(fPolicyPresent);
}

//  --------------------------------------------------------------------------
//  ::CThemeServices::SendProcessAssignSection
//
//  Arguments:  hrApply     = Error HRESULT to forward to themeservice
//              hSection    = read-write theme section handle, valid in current address space.
//              dwHash      = hash value for theme section
//              pPortMsgIn  = port message object for parameters sent to service
//              pPortMsgOut = port message object for parameters received in response
//              
//
//  Returns:    NTSTATUS
//
//  Purpose:    Worker function to send API_THEMES_PROCESSASSIGNSECTION to request
//
//  History:    2002-02-26      scotthan       created
//  --------------------------------------------------------------------------
NTSTATUS CThemeServices::SendProcessAssignSection( 
    HRESULT hrAssign,
    HANDLE  hSection,
    DWORD   dwHash,
    OUT THEMESAPI_PORT_MESSAGE* pPortMsgIn, 
    OUT THEMESAPI_PORT_MESSAGE* pPortMsgOut )
{
    NTSTATUS status = STATUS_PORT_DISCONNECTED;
    if (ConnectedToService())
    {
        ZeroMemory(pPortMsgIn, sizeof(*pPortMsgIn));
        ZeroMemory(pPortMsgOut, sizeof(*pPortMsgOut));
        pPortMsgIn->apiThemes.apiGeneric.ulAPINumber = API_THEMES_PROCESSASSIGNSECTION;
        pPortMsgIn->apiThemes.apiSpecific.apiProcessAssignSection.in.hrLoad = hrAssign;
        pPortMsgIn->apiThemes.apiSpecific.apiProcessAssignSection.in.dwHash = dwHash;
        pPortMsgIn->apiThemes.apiSpecific.apiProcessAssignSection.in.hSection = hSection;

        pPortMsgIn->portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        pPortMsgIn->portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));

        status = NtRequestWaitReplyPort(s_hAPIPort,&pPortMsgIn->portMessage,
                                        &pPortMsgOut->portMessage);
        CheckForDisconnectedPort(status);
    }

    return status;
}

//  --------------------------------------------------------------------------
//  ::ProcessLoadTheme_RunDLLW
//
//  (Deliberately undocumented entrypoint.)
//
//  History:    2002-02-26      scotthan       created
//  --------------------------------------------------------------------------

STDAPI_(void) ProcessLoadTheme_RunDLLW(
    HWND hwndDefer, HINSTANCE hInst, LPWSTR lpwszDeferMsg, int cTimeout)
{
    __try
    {
        WCHAR szModule[MAX_PATH];

        //  validate that we're a rundll32 process launched from %windir%\system32
        if( GetModuleFileName(NULL, szModule, ARRAYSIZE(szModule)) )
        {
            WCHAR szRunDll[MAX_PATH];
            if( GetSystemDirectory(szRunDll, ARRAYSIZE(szRunDll)) &&
                SUCCEEDED(StringCchCatW(szRunDll, ARRAYSIZE(szRunDll), L"\\rundll32.exe")) )
            {
                if( 0 == AsciiStrCmpI(szModule, szRunDll) != 0 )
                {
                    CThemeServices::ProcessLoaderEntry(lpwszDeferMsg);
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Log(LOG_ALWAYS, L"Exception in theme loader process.");
    }
}

//  --------------------------------------------------------------------------
//  ::CThemeServices::ProcessLoaderEntry
//
//  Arguments:  lpwszCmdLine    = cmdline
//              
//
//  Returns:    HRESULT, but no one is listening.
//
//  Purpose:    This is the secure loader process's RunDLL worker function
//              (needed to be a static member to access private static
//               class data.).
//
//  History:    2002-02-26      scotthan       created
//  --------------------------------------------------------------------------
HRESULT CThemeServices::ProcessLoaderEntry(LPWSTR lpwszCmdLine)
{
    size_t  cchCmdLine;
    HRESULT hr = StringCchLengthW(lpwszCmdLine, 
                                  (MAX_PATH*3) + 2 /* three strings delimited by 2 spaces */,
                                  &cchCmdLine);
    ASSERT(SUCCEEDED(hr));
   
    if( SUCCEEDED(hr) )
    {
        //  make a local copy of the command line, which we'll modify in parsing.
        LPWSTR pszCmdLine = new WCHAR[cchCmdLine + 1];

        if( pszCmdLine )
        {
            LPWSTR rgArgs[3] = {0}; // array of pointers to args in pszCmdLine
            int    iArg = 0;        // tracks current index into rgArgs.
            enum   {iThemeFileArg, iColorVariantArg, iSizeVariantArg}; //  rgArg array indices

            StringCchCopyW(pszCmdLine, cchCmdLine + 1, lpwszCmdLine);
            LPWSTR psz;     // working cmdline char pointer
            LPWSTR pszArg;  // address of current arg token

            //  skip spaces
            for( psz = pszCmdLine; L' ' == *psz; psz++);

            //  init first arg token
            pszArg = psz;  

            //  capture arg tokens (delimited by '?') and null terminate each.
            while(*psz != 0)
            {
                if( L'?' == *psz )
                {
                    //  null-terminate and assign to arg list
                    *psz = 0; // null terminate
                    
                    if( iArg < ARRAYSIZE(rgArgs) )
                    {
                        rgArgs[iArg] = pszArg;
                        pszArg = ++psz; // advance past the delimiter and update arg token.
                    }
                    iArg++; // advance current arg index
                }
                else
                {
                    psz++; // advance cmdline char ptr.
                }
            }

              // assign the last arg.
            if( iArg < ARRAYSIZE(rgArgs) )
            {
                rgArgs[iArg++] = pszArg;
            }
            
            //  check arg count.  Correct count should be == ARRAYSIZE(rgArgs)
            if( ARRAYSIZE(rgArgs) == iArg )
            {
                hr = S_OK;

                HANDLE hSection = NULL;
                DWORD  dwHash = 0;

                //  create the memory section
                CThemeLoader *pLoader = new CThemeLoader;
                if (pLoader != NULL)
                {
                    hr = pLoader->LoadTheme(rgArgs[iThemeFileArg], rgArgs[iColorVariantArg], 
                                            rgArgs[iSizeVariantArg], &hSection, TRUE);
                    delete pLoader;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                //  compute a hash to further secure the data
                if( SUCCEEDED(hr) )
                {
                    ASSERT(hSection);
#if 0
                    hr = HashThemeSection(hSection, Get
                                          GetCurrentProcessId() /* as hash parameter, which server possesses and can use for data validate */, 
                                          &dwHash ); 
#endif
                }

                //  unconditionally notify service of what happened so the result can be propagated to the
                //  LPC client of API_THEMES_PROCESSLOADTHEME:
                NTSTATUS                status;
                THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;
                
                status = SendProcessAssignSection(hr, hSection, dwHash, &portMessageIn, &portMessageOut);

                // if we were able to create the section and hash it...
                if( SUCCEEDED(hr) ) 
                {
                    // check LPC result
                    hr = HRESULT_FROM_NT(status);
                    if (NT_SUCCESS(status))
                    {
                        // check service's high-level result
                        status = portMessageOut.apiThemes.apiGeneric.status;
                        hr = HRESULT_FROM_NT(status);

                        if (NT_SUCCESS(status))
                        {
                            // check service's specialized result*/
                            hr = portMessageOut.apiThemes.apiSpecific.apiProcessAssignSection.out.hr;
                        }
                    }
                }

                if( hSection != NULL )
                {
                    //  if we failed anywhere, we need to destroy stock objects
                    if( FAILED(hr) )
                    {
                        ClearStockObjects( hSection, TRUE );
                    }
                
                    //  And whether we succeeded or failed, we close the section handle; 
                    //  we're done with this local read-write copy.
                    CloseHandle(hSection);
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
            
            delete [] pszCmdLine;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\sethook.h ===
//---------------------------------------------------------------------------
//  SetHook.h - Window and DefWindowProc hooking decls.
//---------------------------------------------------------------------------
#pragma once

//---------------------------------------------------------------------------
//  Hooked message disposition flags
#define HMD_NIL           0x00000000  
#define HMD_THEMEDETACH   0x00000001  // detach: theme removed
#define HMD_WINDOWDESTROY 0x00000002  // detach: window is dying
#define HMD_CHANGETHEME   0x00000004  // theme is changing
#define HMD_REATTACH      0x00000008  // attempt attaching window that was previously rejected.
#define HMD_REVOKE        0x00000010  // theme revoked on non-compliant window.
#define HMD_PROCESSDETACH 0x00000020  // process is dying
#define HMD_BULKDETACH    0x00000040  // context is a DetachAll sequence.

//---------------------------------------------------------------------------
//  Query class-specific hooking

BOOL    WINAPI FrameHookEnabled();
BOOL    WINAPI CtlHooksEnabled();

//---------------------------------------------------------------------------
//  ThemeHookStartup/Shutdown() - invoked from DLL_PROCESS_ATTACH/DETACH, resp.
BOOL WINAPI ThemeHookStartup();
BOOL WINAPI ThemeHookShutdown();
//---------------------------------------------------------------------------
//  More helper macros.
#define STRINGIZE_ATOM(a)     MAKEINTATOM(a)
#define BOGUS_THEMEID         0

#define IS_THEME_CHANGE_TARGET(lParam) \
    ((! g_pAppInfo->CustomAppTheme()) || (lParam & WTC_CUSTOMTHEME))
//---------------------------------------------------------------------------
//  Nonclient theming target window classifications [scotthan]:

// NIL:    window has not been evaluated
// REJECT: window has been rejected on the basis of current attributes or conditions, 
//            but may be reconsidered a theming target
// EXILE:  window has been permanently rejected for attachment themewnd object because
//            it's wndproc has proven itself incompatible with theme protocol(s).

//  Helper macros:
#define THEMEWND_NIL                ((CThemeWnd*)NULL) 
#define THEMEWND_REJECT             ((CThemeWnd*)-1)   
#define THEMEWND_EXILE              ((CThemeWnd*)-2)   
#define THEMEWND_FAILURE            ((CThemeWnd*)-3)   

#define EXILED_THEMEWND(pwnd)   ((pwnd)==THEMEWND_EXILE)
#define REJECTED_THEMEWND(pwnd) ((pwnd)==THEMEWND_REJECT)
#define FAILED_THEMEWND(pwnd)   ((pwnd)==THEMEWND_FAILURE)

#define VALID_THEMEWND(pwnd)    (((pwnd) != THEMEWND_NIL) && !FAILED_THEMEWND(pwnd) &&\
                                  !REJECTED_THEMEWND(pwnd) && !EXILED_THEMEWND(pwnd))

#define ISWINDOW(hwnd)         ((hwnd) && (hwnd != INVALID_HANDLE_VALUE) && (IsWindow(hwnd)))
//---------------------------------------------------------------------------
extern "C" BOOL WINAPI ThemeInitApiHook( DWORD dwCmd, void * pvData );

//---- must manually call ProcessStartUp() if needed in ThemeInitApiHook() ----
BOOL ProcessStartUp(HINSTANCE hModule);

//---- avail for calling when tracking down leaks with BoundsChecker() ----
BOOL ProcessShutDown();
//---------------------------------------------------------------------------
inline void ShutDownCheck(HWND hwnd)
{
#ifdef LOGGING
    //---- if we just released APP Window, call ProcessShutDown() for best leak detection ----
    if (hwnd == g_hwndFirstHooked)
    {
        if (LogOptionOn(LO_SHUTDOWN))    // "+shutdown" log option selected
            ProcessShutDown();
    }
#endif
}
//---------------------------------------------------------------------------//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\services.h ===
//  --------------------------------------------------------------------------
//  Module Name: Services.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  APIs to communicate with the theme service.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------

#ifndef     _UxThemeServices_
#define     _UxThemeServices_

#include <LPCThemes.h>

//  --------------------------------------------------------------------------
//  CThemeServices
//
//  Purpose:    Class to implement APIs to communicate with the theme service.
//
//  History:    2000-08-10  vtan        created
//              2000-10-11  vtan        rewrite for LPC
//  --------------------------------------------------------------------------

class   CThemeServices
{
    private:
                                    CThemeServices (void);
                                    ~CThemeServices (void);
    public:
        static  void                StaticInitialize (void);
        static  void                StaticTerminate (void);

        //  These are calls to the server.

        static  HRESULT             ThemeHooksOn (HWND hwndTarget);
        static  HRESULT             ThemeHooksOff (void);
        static  HRESULT             GetStatusFlags (DWORD *pdwFlags);
        static  HRESULT             GetCurrentChangeNumber (int *piValue);
        static  HRESULT             SetGlobalTheme (HANDLE hSection);
        static  HRESULT             GetGlobalTheme (HANDLE *phSection);
        static  HRESULT             CheckThemeSignature (const WCHAR *pszThemeName);
        static  HRESULT             ProcessLoadGlobalTheme( const WCHAR *pszThemeName, const WCHAR *pszColor, const WCHAR *pszSize, OUT HANDLE* phSection );
        static  HRESULT             LoadTheme (HANDLE *phSection, const WCHAR *pszThemeName, const WCHAR *pszColor, const WCHAR *pszSize, BOOL fGlobal);
        static  HRESULT             ProcessLoaderEntry(LPWSTR lpwszCmdLine); 
        static  NTSTATUS            SendProcessAssignSection( HRESULT hrAssign, HANDLE  hSection, DWORD  dwHash,
                                                              OUT THEMESAPI_PORT_MESSAGE* pPortMsgIn, OUT THEMESAPI_PORT_MESSAGE* pPortMsgOut );

        //  These are calls implemented on the client side
        //  that may make calls to the server.

        static  HRESULT             ApplyTheme (CUxThemeFile *pThemeFile, DWORD dwFlags, HWND hwndTarget);
        static  HRESULT             InitUserTheme (BOOL fPolicyCheckOnly = FALSE);
        static  HRESULT             AdjustTheme(BOOL fEnable);
        static  HRESULT             InitUserRegistry (void);

        //  These are special private APIs

        static  HRESULT             ReestablishServerConnection (void);
        static  HRESULT             ClearStockObjects (HANDLE hSection, BOOL fForce = FALSE);
    private:
        static  void                ApplyDefaultMetrics(void);
        static  void                LockAcquire (void);
        static  void                LockRelease (void);
        static  bool                ConnectedToService (void);
        static  void                ReleaseConnection (void);
        static  void                CheckForDisconnectedPort (NTSTATUS status);
        static  bool                CurrentThemeMatch (LPCWSTR pszThemeName, LPCWSTR pszColor, LPCWSTR pszSize, LANGID wLangID, bool fLoadMetricsOnMatch);
        static  HRESULT             LoadCurrentTheme (void);
        static  int                 SectionProcessType (const BYTE *pbThemeData, MIXEDPTRS& u);
        static  void                SectionWalkData (const BYTE *pbThemeData, int iIndex);
        static  bool                ThemeSettingsModified (void);
        static  bool                ThemeEnforcedByPolicy (bool fActive);
        static  HRESULT             CheckColorDepth(CUxThemeFile *pThemeFile);
        static  HRESULT             UpdateThemeRegistry(BOOL fNewTheme, LPCWSTR pszThemeFileName, 
                                        LPCWSTR pszColorParam, LPCWSTR pszSizeParam, BOOL fJustSetActive, BOOL fJustApplied);
        static  void                SendThemeChangedMsg(BOOL fNewTheme, HWND hwndTarget, DWORD dwFlags,
                                        int iLoadId);
        static  int                 GetLoadId(HANDLE hSectionOld);

    private:
        static  CRITICAL_SECTION    s_lock;
        static  HANDLE              s_hAPIPort;
        static  const WCHAR         s_szDefault[];
};

#endif  /*  _UxThemeServices_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\themesection.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeSection.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that wraps CUxThemeFile. CUxThemeFile automatically closes the section
//  member variable handle. This makes usage of the class difficult because
//  it doesn't duplicate the handle but it takes ownership. It does declare
//  the handle as a PUBLIC member variable so we capitalize on this poor
//  design. This class wraps CUxThemeFile to make the life of users of this
//  class easier by not having them worry about closing the handles or not.
//  When you use this class the handle is NOT closed.
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

#include "stdafx.h"

#include "ThemeSection.h"

#define goto        !!DO NOT USE GOTO!! - DO NOT REMOVE THIS ON PAIN OF DEATH

//  --------------------------------------------------------------------------
//  CThemeSection::CThemeSection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CThemeSection.
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

CThemeSection::CThemeSection (void)

{
}

//  --------------------------------------------------------------------------
//  CThemeSection::~CThemeSection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CThemeSection. This is TOTALLY BOGUS having to
//              set an internal member variable contents to NULL to prevent
//              it from releasing resources but the rest of the code relies
//              on the auto-release behavior without duplication of the
//              handle. This is done to protect this class from that hassle.
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

CThemeSection::~CThemeSection (void)

{
    _themeFile._hMemoryMap = NULL;
}

//  --------------------------------------------------------------------------
//  CThemeSection::operator CUxThemeFile*
//
//  Arguments:  <none>
//
//  Returns:    CUxThemeFile*
//
//  Purpose:    Automagic operator to convert from CThemeSection to
//              CUxThemeFile* which keeps current usage transparent.
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

CThemeSection::operator CUxThemeFile* (void)

{
    return(&_themeFile);
}

//  --------------------------------------------------------------------------
//  CThemeSection::Open
//
//  Arguments:  hSection     =   Section to use.
//              dwViewAccess =   desired access for mapped view.
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru to CUxThemeFile::OpenFile.
//
//  History:    2000-11-22  vtan        created
//              2002-03-24  scotthan    add dwViewAccess arg.
//  --------------------------------------------------------------------------

HRESULT     CThemeSection::Open (HANDLE hSection, DWORD dwViewAccess /* FILE_MAP_READ*/)

{
    return(_themeFile.OpenFromHandle(hSection, dwViewAccess));
}

//  --------------------------------------------------------------------------
//  CThemeSection::ValidateData
//
//  Arguments:  fFullCheck  =   Perform a full check?
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru to CUxThemeFile::ValidateThemeData.
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeSection::ValidateData (bool fFullCheck)

{
    return(_themeFile.ValidateThemeData(fFullCheck));
}

//  --------------------------------------------------------------------------
//  CThemeSection::CreateFromSection
//
//  Arguments:  hSection    =   Section to duplicate.
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru to CUxThemeFile::CreateFromSection.
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeSection::CreateFromSection (HANDLE hSection)
{
    return(_themeFile.CreateFromSection(hSection));
}

//  --------------------------------------------------------------------------
//  CThemeSection::Get
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Returns the handle of the CUxThemeFile object. Because this
//              class always NULLs out the handle it will get leaked. Once
//              this handle is returned the caller owns the handle. 
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

HANDLE      CThemeSection::Get (void)  const

{
    return(_themeFile._hMemoryMap);
}

//  --------------------------------------------------------------------------
//  CThemeSection::GetData
//
//  Arguments:  <none>
//
//  Returns:    PVOID
//
//  Purpose:    Returns a pointer to the theme data.
//
//  History:    2002-03-24  scotthan        created
//  --------------------------------------------------------------------------
PVOID CThemeSection::GetData(void)
{
    return _themeFile._pbThemeData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\textdraw.h ===
//---------------------------------------------------------------------------
//  TextDraw.h - implements the drawing API for text
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "wrapper.h"
//---------------------------------------------------------------------------
class CRenderObj;       // forward
//---------------------------------------------------------------------------
//    Note: draw objects like CBorderFill cannot have virtual methods
//          since they reside in the shared memory map file.
//---------------------------------------------------------------------------
class CTextDraw 
{
public:
    //---- methods ----
    HRESULT PackProperties(CRenderObj *pRender, int iPartId, int iStateId);
    
    static BOOL KeyProperty(int iPropId);
    
    void DumpProperties(CSimpleFile *pFile, BYTE *pbThemeData, BOOL fFullInfo);

    HRESULT DrawText(CRenderObj *pRender, HDC hdc, int iPartId, int iStateId, LPCWSTR _pszText, 
        DWORD dwCharCount, DWORD dwTextFlags, const RECT *pRect, const DTTOPTS *pOptions);

    HRESULT DrawEdge(CRenderObj *pRender, HDC hdc, int iPartId, int iStateId, const RECT *pDestRect, 
        UINT uEdge, UINT uFlags, OUT RECT *pContentRect);

    HRESULT GetTextExtent(CRenderObj *pRender, HDC hdc, int iPartId, int iStateId, LPCWSTR _pszText, 
        int iCharCount, DWORD dwTextFlags, const RECT *pBoundingRect, RECT *pExtentRect);

    HRESULT GetTextMetrics(CRenderObj *pRender, HDC hdc, int iPartId, int iStateId, TEXTMETRIC* ptm);

public:
    //---- data ----

    //---- text ----
    COLORREF _crText;

    //---- edge ----
    COLORREF _crEdgeLight;
    COLORREF _crEdgeHighlight;
    COLORREF _crEdgeShadow;
    COLORREF _crEdgeDkShadow;
    COLORREF _crEdgeFill;

    //---- shadow ----
    POINT _ptShadowOffset;
    COLORREF _crShadow;
    TEXTSHADOWTYPE _eShadowType;

    //---- border ----
    int _iBorderSize;
    COLORREF _crBorder;

    //---- font ----
    LOGFONT _lfFont;
    BOOL _fHaveFont;

    //---- id ----
    int _iSourcePartId; 
    int _iSourceStateId;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\themeldr.cpp ===
//---------------------------------------------------------------------------
//  ThemeLdr.cpp - entrypoints for routines declared in ThemeLdr.h
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Services.h"
#include "ThemeServer.h"
#include "loader.h"
//---------------------------------------------------------------------------

//  --------------------------------------------------------------------------
//  InjectedThreadDispatcherExceptionFilter
//
//  Arguments:  pExceptionInfo  =   Exception that happened.
//
//  Returns:    LONG
//
//  Purpose:    Filters exceptions that occur when executing injected threads
//              into another process context to prevent the process from
//              terminating due to unforeseen exceptions.
//
//  History:    2000-10-13  vtan        created
//              2001-05-18  vtan        copied from theme service LPC
//  --------------------------------------------------------------------------

LONG    WINAPI  InjectedThreadExceptionFilter (struct _EXCEPTION_POINTERS *pExceptionInfo)

{
    (LONG)RtlUnhandledExceptionFilter(pExceptionInfo);
    return(EXCEPTION_EXECUTE_HANDLER);
}

//  --------------------------------------------------------------------------
//  ::SessionAllocate
//
//  Arguments:  hProcess                =   Winlogon process for the session.
//              dwServerChangeNumber    =   Server base change number.
//              pfnRegister             =   Address of register function.
//              pfnUnregister           =   Address of unregister function.
//
//  Returns:    void*
//
//  Purpose:    Allocates a CThemeServer object that contains information
//              for a theme session. Wrapped in try/except because of
//              critical section initialization.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void*       WINAPI  SessionAllocate (HANDLE hProcess, DWORD dwServerChangeNumber, void *pfnRegister, void *pfnUnregister, void *pfnClearStockObjects, DWORD dwStackSizeReserve, DWORD dwStackSizeCommit)

{
    CThemeServer    *pvContext;

    __try
    {
        pvContext = new CThemeServer(hProcess, dwServerChangeNumber, pfnRegister, pfnUnregister, pfnClearStockObjects, dwStackSizeReserve, dwStackSizeCommit);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        pvContext = NULL;
    }
    return(pvContext);
}

//  --------------------------------------------------------------------------
//  ::SessionFree
//
//  Arguments:  pvContext   =   CThemeServer this object.
//
//  Returns:    <none>
//
//  Purpose:    Destroys the CThemeServer object when the session goes away.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void        WINAPI  SessionFree (void *pvContext)

{
    delete static_cast<CThemeServer*>(pvContext);
}

//  --------------------------------------------------------------------------
//  ::ThemeHooksOn
//
//  Arguments:  pvContext   =   CThemeServer this object.
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  ThemeHooksOn (void *pvContext)

{
    return(static_cast<CThemeServer*>(pvContext)->ThemeHooksOn());
}

//  --------------------------------------------------------------------------
//  ::ThemeHooksOff
//
//  Arguments:  pvContext   =   CThemeServer this object.
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  ThemeHooksOff (void *pvContext)

{
    (HRESULT)static_cast<CThemeServer*>(pvContext)->ThemeHooksOff();
    return(S_OK);
}

//  --------------------------------------------------------------------------
//  ::AreThemeHooksActive
//
//  Arguments:  pvContext   =   CThemeServer this object.
//
//  Returns:    BOOL
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL        WINAPI  AreThemeHooksActive (void *pvContext)

{
    return(static_cast<CThemeServer*>(pvContext)->AreThemeHooksActive());
}

//  --------------------------------------------------------------------------
//  ::GetCurrentChangeNumber
//
//  Arguments:  pvContext   =   CThemeServer this object.
//
//  Returns:    int
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    int         WINAPI  GetCurrentChangeNumber (void *pvContext)

{
    return(static_cast<CThemeServer*>(pvContext)->GetCurrentChangeNumber());
}

//  --------------------------------------------------------------------------
//  ::GetNewChangeNumber
//
//  Arguments:  pvContext   =   CThemeServer this object.
//
//  Returns:    int
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    int         WINAPI  GetNewChangeNumber (void *pvContext)

{
    return(static_cast<CThemeServer*>(pvContext)->GetNewChangeNumber());
}

//  --------------------------------------------------------------------------
//  ::SetGlobalTheme
//
//  Arguments:  pvContext   =   CThemeServer this object.
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  SetGlobalTheme (void *pvContext, HANDLE hSection)

{
    return(static_cast<CThemeServer*>(pvContext)->SetGlobalTheme(hSection));
}

//  --------------------------------------------------------------------------
//  ::GetGlobalTheme
//
//  Arguments:  pvContext   =   CThemeServer this object.
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  GetGlobalTheme (void *pvContext, HANDLE *phSection)

{
    return(static_cast<CThemeServer*>(pvContext)->GetGlobalTheme(phSection));
}

//  --------------------------------------------------------------------------
//  ::LoadTheme
//
//  Arguments:  pvContext   =   CThemeServer this object.
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  LoadTheme (
    void *pvContext, 
    HANDLE hSection, 
    HANDLE *phSection, 
    LPCWSTR pszName, 
    LPCWSTR pszColor, 
    LPCWSTR pszSize,
    OPTIONAL DWORD dwFlags )

{
    return(static_cast<CThemeServer*>(pvContext)->LoadTheme(
        hSection, phSection, pszName, pszColor, pszSize, dwFlags));
}

//  --------------------------------------------------------------------------
//  ::InitUserTheme
//
//  Arguments:  BOOL 
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  InitUserTheme (BOOL fPolicyCheckOnly)

{
    return(CThemeServices::InitUserTheme(fPolicyCheckOnly));
}

//  --------------------------------------------------------------------------
//  ::InitUserRegistry
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-15  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  InitUserRegistry (void)

{
    return(CThemeServices::InitUserRegistry());
}

//  --------------------------------------------------------------------------
//  ::ReestablishServerConnection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  ReestablishServerConnection (void)

{
    return(CThemeServices::ReestablishServerConnection());
}

//  --------------------------------------------------------------------------
//  ::ThemeHooksInstall
//
//  Arguments:  pvContext   =   Unused.
//
//  Returns:    DWORD
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    DWORD   WINAPI  ThemeHooksInstall (void *pvContext)

{
    UNREFERENCED_PARAMETER(pvContext);

    DWORD   dwResult;

    __try
    {
        dwResult = CThemeServer::ThemeHooksInstall();
    }
    __except (InjectedThreadExceptionFilter(GetExceptionInformation()))
    {
        dwResult = 0;
    }
    ExitThread(dwResult);
}

//  --------------------------------------------------------------------------
//  ::ThemeHooksRemove
//
//  Arguments:  pvContext   =   Unused.
//
//  Returns:    DWORD
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    DWORD   WINAPI  ThemeHooksRemove (void *pvContext)

{
    UNREFERENCED_PARAMETER(pvContext);

    DWORD   dwResult;

    __try
    {
        dwResult = CThemeServer::ThemeHooksRemove();
    }
    __except (InjectedThreadExceptionFilter(GetExceptionInformation()))
    {
        dwResult = 0;
    }
    ExitThread(dwResult);
}

//  --------------------------------------------------------------------------
//  ::ServerClearStockObjects
//
//  Arguments:  pvContext   =   ptr to section
//
//  Returns:    <none>
//
//  Purpose:    Pass thru function.
//
//  History:    2001-05-01 rfernand        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ServerClearStockObjects (void *pvContext)

{
    DWORD   dwResult;

    __try
    {
        dwResult = CThemeServer::ClearStockObjects(HANDLE(pvContext));
    }
    __except (InjectedThreadExceptionFilter(GetExceptionInformation()))
    {
        dwResult = 0;
    }
    ExitThread(dwResult);
}

//  --------------------------------------------------------------------------
//  ::ServiceClearStockObjects
//
//  Arguments:  pvContext   =   CThemeServer this object.
//              hSection    =   Theme section handle containing 
//
//  Returns:    <none>
//
//  Purpose:    Pass thru function.   This function differs from
//              ::ServerClearStockObjects in that it is intended to be called
//              from the theme service, which can't clean stock bitmaps 
//              itself (not on the winsta that created the bitmaps).
//
//  History:    2002-03-11 scotthan        created
//  --------------------------------------------------------------------------

EXTERN_C  HRESULT ServiceClearStockObjects(PVOID pvContext, HANDLE hSection )
{
    return (static_cast<CThemeServer*>(pvContext)->InjectStockObjectCleanupThread(hSection));
}

//---------------------------------------------------------------------------

//  --------------------------------------------------------------------------
//  ::ClearTheme
//
//  Arguments:  hSection    =   Theme section to clear.
//
//  Returns:    HRESULT
//              
//  Purpose:    Clears stock bitmaps in the theme section data and closes it.
//
//  History:    2000-11-21  vtan        created
//  --------------------------------------------------------------------------

HRESULT     WINAPI  ClearTheme (HANDLE hSection, BOOL fForce)

{
    HRESULT     hr;

    if (hSection != NULL)
    {
        hr = CThemeServices::ClearStockObjects(hSection, fForce);
    }
    else
    {
        hr = S_OK;
    }

    //---- always close the handle ----
    CloseHandle(hSection);

    return(hr);
}

//  --------------------------------------------------------------------------
//  ::MarkSection
//
//  Arguments:  hSection            =   Section to change
//              dwAdd, dwRemove     =   Flags to set or clear in the header. 
//                                      See loader.h.
//
//  Returns:    void
//
//  Purpose:    Update the global section state.
//
//  History:    2001-05-08  lmouton     created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  MarkSection (HANDLE hSection, DWORD dwAdd, DWORD dwRemove)

{
    Log(LOG_TMLOAD, L"MarkSection: Add %d and remove %d on %X", dwAdd, dwRemove, hSection);

    void *pV = MapViewOfFile(hSection,
                       FILE_MAP_WRITE,
                       0,
                       0,
                       0);
    if (pV != NULL)
    {
        THEMEHDR *hdr = reinterpret_cast<THEMEHDR*>(pV);

        // Do some validation
        if (0 == memcmp(hdr->szSignature, kszBeginCacheFileSignature, kcbBeginSignature)
            && hdr->dwVersion == THEMEDATA_VERSION)
        {
            // Only allow this flag for now
            if (dwRemove == SECTION_HASSTOCKOBJECTS)
            {
                Log(LOG_TMLOAD, L"MarkSection: Previous flags were %d", hdr->dwFlags);
                hdr->dwFlags &= ~dwRemove;
            }
        }
        UnmapViewOfFile(pV);
    }
#ifdef DEBUG
    else
    {
        Log(LOG_TMLOAD, L"MarkSection: Failed to open write handle for %X", hSection);
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\themesection.h ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeSection.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that wraps CUxThemeFile. CUxThemeFile automatically closes the section
//  member variable handle. This makes usage of the class difficult because
//  it doesn't duplicate the handle but it takes ownership. It does declare
//  the handle as a PUBLIC member variable so we capitalize on this poor
//  design. This class wraps CUxThemeFile to make the life of users of this
//  class easier by not having them worry about closing the handles or not.
//  When you use this class the handle is NOT closed.
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _ThemeSection_
#define     _ThemeSection_

#include "ThemeFile.h"

//  --------------------------------------------------------------------------
//  CThemeSection
//
//  Purpose:    Class that wraps CUxThemeFile and doesn't release the handle on
//              closure.
//
//  History:    2000-11-22  vtan        created
//  --------------------------------------------------------------------------

class   CThemeSection
{
    public:
                    CThemeSection (void);
                    ~CThemeSection (void);

                    operator CUxThemeFile* (void);

        HRESULT     Open (HANDLE hSection, DWORD dwViewAccess = FILE_MAP_READ);
        HRESULT     ValidateData (bool fFullCheck);
        HRESULT     CreateFromSection (HANDLE hSection);
        HANDLE      Get (void)  const;
        PVOID       GetData(void);

    private:
        CUxThemeFile  _themeFile;
};

#endif  /*  _ThemeSection_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\textfade.cpp ===
//---------------------------------------------------------------------------
//    TextFade.cpp - text fading code (removed from taskbar)
//---------------------------------------------------------------------------
//  BEGIN fade-text drawing functions and friends
//---------------------------------------------------------------------------
#include "stdafx.h"
//---------------------------------------------------------------------------
static HBITMAP CreateDibSection32Bit(int w, int h, void** ppv)
{
    HBITMAP bitmap;
    BITMAPINFO bmi;
    memset(&bmi, 0, sizeof(bmi));
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth = w;
    bmi.bmiHeader.biHeight = h;
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biSizeImage = 0;
    bitmap = CreateDIBSection(NULL, &bmi, DIB_RGB_COLORS, ppv, NULL, 0);
    if (bitmap)
        memset(*ppv, 0xff, w*h*4); //32bpp=4bytes
    return bitmap;
}
//---------------------------------------------------------------------------
static void SetupAlphaChannel(DWORD* pdw, int w, int h, BYTE bstart, BYTE bend, int nExtra)
{
    //nExtra is extra space that we want to fill with the final value
    int i,j;
    w -= nExtra;
    if (bstart > bend)
    {
        BYTE bdiff = bstart - bend;
        for (j=0;j<h;j++)
        {
            for (i=0;i<w;i++)
            {
                BYTE a = bstart - bdiff * i/w; //alpha
                BYTE r = (GetRValue(*pdw)*a)/256;
                BYTE g = (GetGValue(*pdw)*a)/256;
                BYTE b = (GetBValue(*pdw)*a)/256;
                *pdw = (a<<24)|RGB(r,g,b);
                pdw++;
            }
            for (i=w;i<w+nExtra;i++)
            {
                BYTE a = bend; //alpha
                BYTE r = (GetRValue(*pdw)*a)/256;
                BYTE g = (GetGValue(*pdw)*a)/256;
                BYTE b = (GetBValue(*pdw)*a)/256;
                *pdw = (a<<24)|RGB(r,g,b);
                pdw++;
            }
        }
    }
    else
    {
        BYTE bdiff = bend - bstart;
        for (j=0;j<h;j++)
        {
            for (i=0;i<w;i++)
            {
                BYTE a = bstart + bdiff * i/w; //alpha
                BYTE r = (GetRValue(*pdw)*a)/256;
                BYTE g = (GetGValue(*pdw)*a)/256;
                BYTE b = (GetBValue(*pdw)*a)/256;
                *pdw = (a<<24)|RGB(r,g,b);
                pdw++;
            }
            for (i=w;i<w+nExtra;i++)
            {
                BYTE a = bend; //alpha
                BYTE r = (GetRValue(*pdw)*a)/256;
                BYTE g = (GetGValue(*pdw)*a)/256;
                BYTE b = (GetBValue(*pdw)*a)/256;
                *pdw = (a<<24)|RGB(r,g,b);
                pdw++;
            }
        }
    }
}
//---------------------------------------------------------------------------
int ExtTextOutAlpha(HDC dc, int X, int Y, UINT fuOptions, CONST RECT *lprc,
    LPCTSTR lpsz, UINT nCount, CONST INT *lpDx)
{
    BOOL bEffects = FALSE;
    SystemParametersInfo(SPI_GETUIEFFECTS, 0, (void*)&bEffects, 0);
    // don't alpha blend if ui effects off or number of colors <= 256
    if (!bEffects || 
        (GetDeviceCaps(dc, BITSPIXEL) * GetDeviceCaps(dc, PLANES) <= 8))
    {
        return ExtTextOut(dc, X, Y, fuOptions, lprc, lpsz, nCount, lpDx);
    }

    if (lprc == NULL)
        return ExtTextOut(dc, X, Y, fuOptions, lprc, lpsz, nCount, lpDx);

    RECT rc = *lprc;
    int nwidth = rc.right -rc.left;
    int nheight = rc.bottom - rc.top;
    int nLen = (nCount == -1) ? lstrlen(lpsz) : nCount;
    int nFit=0;
    int* pFit = new int[nLen];
    if (pFit == NULL)
        return 0;
    pFit[0] = 0;
    SIZE size;
    GetTextExtentExPoint(dc, lpsz, nLen, nwidth, &nFit, pFit, &size);
    if (nFit >= nLen)
        return ExtTextOut(dc, X, Y, fuOptions, lprc, lpsz, nCount, lpDx);
        
    // too small, let's alpha blend it

    if ((nwidth <= 0) || (nheight <= 0))
        return 1;

    TEXTMETRIC tm;
    GetTextMetrics(dc, &tm);
    int nPix = tm.tmAveCharWidth*5;
    //don't fade out more than half the text
    if (nPix > nwidth)
        nPix = nwidth/2;

    //Create a 32bpp dibsection to store the background
    void* pv = NULL;
    HDC dcbitmap = CreateCompatibleDC(dc);
    int nRet = 0;
    if (dcbitmap != NULL)
    {
        HBITMAP bitmap = CreateDibSection32Bit(nPix, nheight, &pv);
        if (bitmap != NULL)
        {
            HBITMAP tmpbmp = (HBITMAP) SelectObject(dcbitmap, bitmap);
            BitBlt(dcbitmap, 0, 0, nPix, nheight, dc, rc.right-nPix, rc.top, SRCCOPY);
            //Setup the per-pixel alpha blending values
            SetupAlphaChannel((DWORD*)pv, nPix, nheight, 0x00, 0xdf, 0);
  
            //Draw the text onto the display DC
            ExtTextOut(dc, X, Y, fuOptions, lprc, lpsz, nLen, lpDx);

            //Blend the background back into the display
            BLENDFUNCTION blend = {AC_SRC_OVER, 0, 0xff, AC_SRC_ALPHA};
            GdiAlphaBlend(dc, rc.right-nPix, rc.top, nPix, nheight, dcbitmap, 0, 0, nPix, nheight, blend);
            ::SelectObject(dcbitmap, tmpbmp);
            DeleteObject(bitmap);
            nRet = 1;
        }
        DeleteDC(dcbitmap);    
    }
    return nRet;
}
//---------------------------------------------------------------------------
int DrawTextAlpha(HDC hdc, LPCTSTR lpsz, int nCount, RECT* prc, UINT uFormat)
{
    BOOL bEffects = FALSE;
    SystemParametersInfo(SPI_GETUIEFFECTS, 0, (void*)&bEffects, 0);
    // don't alpha blend if ui effects off or number of colors <= 256
    if (!bEffects || 
        (GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES) <= 8))
    {
        return DrawText(hdc, lpsz, nCount, prc, uFormat);
    }
    UINT nEllipsis = (DT_END_ELLIPSIS|DT_WORD_ELLIPSIS|DT_WORD_ELLIPSIS); 
    if (!(uFormat & DT_SINGLELINE) || !(uFormat & DT_END_ELLIPSIS) || (uFormat & DT_CALCRECT))
        return ::DrawText(hdc, lpsz, nCount, prc, uFormat);
    //we are single line and ellipses are requested
    //we are going to alpha blend though
    uFormat &= ~nEllipsis; //turn all ellipsis flags off
    if (nCount == -1)
        nCount = lstrlen(lpsz);

    RECT rc;
    CopyRect(&rc, prc);
    ::DrawText(hdc, (TCHAR*)lpsz, nCount, &rc, uFormat | DT_CALCRECT);
    if (rc.right <= prc->right) //not truncated
        return ::DrawText(hdc, lpsz, nCount, prc, uFormat);

    // DT_CENTER is effectively ignored when ellipses flags are on, 
    // because text is clipped to fit in rectangle.  With fading, we
    // need to justify the text.
    uFormat &= ~DT_CENTER;

    CopyRect(&rc, prc);
    int nwidth = RECTWIDTH(&rc);
    int nheight = RECTHEIGHT(&rc);

    if ((nwidth <= 0) || (nheight <= 0))
        return 1;

    // Figure out how much of the background to stash away
    TEXTMETRIC tm;
    GetTextMetrics(hdc, &tm);
    int nPix = tm.tmAveCharWidth*5; //five characters worth
    if (nPix > nwidth/2)
        nPix = nwidth/2;
    //Adjust by one max char width because DrawText can draw up to 
    //one extra character outside the clip rect.
    nPix += tm.tmMaxCharWidth;
    rc.right += tm.tmMaxCharWidth;

    //Create a 32bpp dibsection to store the background
    void* pv = NULL;
    HDC dcbitmap = CreateCompatibleDC(hdc);
    int nRet = 0;
    if (dcbitmap != NULL)
    {
        HBITMAP bitmap = CreateDibSection32Bit(nPix, nheight, &pv);
        if (bitmap != NULL)
        {
            HBITMAP tmpbmp = (HBITMAP) SelectObject(dcbitmap, bitmap);
            BitBlt(dcbitmap, 0, 0, nPix, nheight, hdc, rc.right-nPix, rc.top, SRCCOPY);
            //Setup the per-pixel alpha blending values
            SetupAlphaChannel((DWORD*)pv, nPix, nheight, 0x00, 0xdf, tm.tmMaxCharWidth);
            //Draw the text onto the display DC
            ::DrawText(hdc, lpsz, nCount, prc, uFormat);

            //Blend the background back into the display
            BLENDFUNCTION blend = {AC_SRC_OVER, 0, 0xff, AC_SRC_ALPHA};
            GdiAlphaBlend(hdc, rc.right-nPix, rc.top, nPix, nheight, dcbitmap, 0, 0, nPix, nheight, blend);
            ::SelectObject(dcbitmap, tmpbmp);
            DeleteObject(bitmap);
            nRet = 1;
        }
        DeleteDC(dcbitmap);    
    }
    return nRet;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\themefile.cpp ===
//---------------------------------------------------------------------------
//  ThemeFile.cpp - manages loaded theme files
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "ThemeFile.h"
#include "Loader.h"
#include "Services.h"
//---------------------------------------------------------------------------
CUxThemeFile::CUxThemeFile()
{
    StringCchCopyA(_szHead, ARRAYSIZE(_szHead), "thmfile"); 
    StringCchCopyA(_szTail, ARRAYSIZE(_szTail), "end");

    Reset();
}
//---------------------------------------------------------------------------
CUxThemeFile::~CUxThemeFile()
{
    if (_pbThemeData || _hMemoryMap)
        CloseFile();

    StringCchCopyA(_szHead, ARRAYSIZE(_szHead), "deleted"); 
}
//---------------------------------------------------------------------------
__inline bool CUxThemeFile::IsReady()
{
    THEMEHDR *hdr = (THEMEHDR *)_pbThemeData;

    if (hdr != NULL && ((hdr->dwFlags & SECTION_READY) != 0))
    {
        return true;
    }
    return false;
}
//---------------------------------------------------------------------------
__inline bool CUxThemeFile::IsGlobal()
{
    THEMEHDR *hdr = (THEMEHDR *)_pbThemeData;

    if (hdr != NULL && ((hdr->dwFlags & SECTION_GLOBAL) != 0))
    {
        return true;
    }
    return false;
}
//---------------------------------------------------------------------------
__inline bool CUxThemeFile::HasStockObjects()
{
    THEMEHDR *hdr = (THEMEHDR *)_pbThemeData;

    if (hdr != NULL && ((hdr->dwFlags & SECTION_HASSTOCKOBJECTS) != 0))
    {
        return true;
    }
    return false;
}

//---------------------------------------------------------------------------
#ifdef DEBUG
void _CreateDebugSectionName( LPCWSTR pszBasicName, OUT LPWSTR pszName, IN ULONG cchName )
{
    static DWORD dwRand = GetTickCount();       // rand seed
    dwRand = (dwRand * 214013L + 2531011L);     // randomize

    DWORD dwUnique = (GetTickCount() | dwRand | (GetCurrentThreadId() << 8) | (GetCurrentProcessId() << 16));

    StringCchPrintfW(pszName, cchName, 
                     L"%s_%d_%d_%08lX", 
                     pszBasicName,
                     NtCurrentPeb()->SessionId, // winlogon can't load/unload themes in different sessions.
                     GetProcessWindowStation(), // winlogon can't load/unload themes in different winstas
                     dwUnique); 
}
#endif DEBUG

//---------------------------------------------------------------------------
HRESULT CUxThemeFile::CreateFile(int iLength, BOOL fReserve)
{
    Log(LOG_TM, L"CUxThemeFile::CreateFile");

    HRESULT hr = S_OK;

    if (_pbThemeData)
        CloseFile();

    //---- we rely on all theme section names containing "ThemeSection" in CHK build so ----
    //---- devs/testers can verify that all handles to old theme sections are released. ----
    //---- For FRE builds, we want a NULL name to prevent name squatting attacks. ----
    WCHAR *pszName = NULL;

#ifdef DEBUG
    WCHAR szSectionName[MAX_PATH];
    
    _CreateDebugSectionName(L"Debug_Create_ThemeSection", szSectionName, ARRAYSIZE(szSectionName));

    pszName = szSectionName;
#endif

    _hMemoryMap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,
        PAGE_READWRITE | (fReserve ? SEC_RESERVE : 0), 0, iLength, pszName);
    if (! _hMemoryMap)
    {
        Log(LOG_ALWAYS, L"CUxThemeFile::CreateFile: could not create shared memory mapping");
        hr = MakeErrorLast();
        goto exit;
    }

    _pbThemeData = (BYTE *)MapViewOfFile(_hMemoryMap, FILE_MAP_WRITE, 0, 0, 0);
    if (! _pbThemeData)
    {
        Log(LOG_ALWAYS, L"CUxThemeFile::CreateFile: could not create shared memory view");
        CloseHandle(_hMemoryMap);

        hr = MakeErrorLast();
        goto exit;
    }

    Log(LOG_TMHANDLE, L"CUxThemeFile::CreateFile FILE CREATED: len=%d, addr=0x%x", 
        iLength, _pbThemeData);

exit:
    if (FAILED(hr))
        Reset();

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CUxThemeFile::CreateFromSection(HANDLE hSection)
{
    Log(LOG_TM, L"CUxThemeFile::CreateFromSection");

    HRESULT hr = S_OK;
    void *pvOld = NULL;

    //---- ensure we start with all previous handles closed ----
    if (_pbThemeData)
        CloseFile();

    //---- get access to source section data ----
    pvOld = MapViewOfFile(hSection, FILE_MAP_READ, 0, 0, 0);
    if (! pvOld)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    THEMEHDR *pHdr = (THEMEHDR *)pvOld;
    DWORD dwTrueSize = pHdr->dwTotalLength;

    //---- we rely on all theme section names containing "ThemeSection" in CHK build so ----
    //---- devs/testers can verify that all handles to old theme sections are released. ----
    //---- For FRE builds, we want a NULL name to prevent name squatting attacks. ----
    WCHAR *pszName = NULL;

#ifdef DEBUG
    WCHAR szSectionName[MAX_PATH];

    _CreateDebugSectionName(L"Debug_CreateFromSection_ThemeSection", szSectionName, ARRAYSIZE(szSectionName));
    
    pszName = szSectionName;
#endif

    //---- create the new section ----
    _hMemoryMap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,
        PAGE_READWRITE, 0, dwTrueSize, pszName);

    DWORD dwErr = GetLastError();
    
    if( ERROR_ALREADY_EXISTS == dwErr )
    {
        Log(LOG_ALWAYS, L"CUxThemeFile::CreateFromSection: shared theme section mapping already exists");
        ASSERT(FALSE);
    }

    if (! _hMemoryMap)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        Log(LOG_ALWAYS, L"CUxThemeFile::CreateFromSection: could not create shared memory mapping (%ld)", dwErr);
        goto exit;
    }

    //---- get access to new section data ----
    _pbThemeData = (BYTE *)MapViewOfFile(_hMemoryMap, FILE_MAP_WRITE, 0, 0, 0);
    if (! _pbThemeData)
    {
        hr = MakeErrorLast();
        Log(LOG_ALWAYS, L"CThemeFile::CreateFromSection: could not create shared memory view");
        goto exit;
    }

    //---- copy the data from the old section to the new section ----
    __try
    {
        CopyMemory(_pbThemeData, pvOld, dwTrueSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        hr = GetExceptionCode();
        goto exit;
    }

    //---- ensure version, checksum, etc. is all looking good ----
    hr = ValidateThemeData(TRUE);
    if (FAILED(hr))
        goto exit;

    Log(LOG_TMHANDLE, L"CUxThemeFile::CreateFromSection FILE CREATED: addr=0x%x", 
        _pbThemeData);

exit:
    if (pvOld != NULL)
        UnmapViewOfFile(pvOld);

    if (FAILED(hr))
        CloseFile();

    return hr;
}
//---------------------------------------------------------------------------
// If fCleanupOnFailure is FALSE, we won't close the handle passed, even on failure.
//---------------------------------------------------------------------------
HRESULT CUxThemeFile::OpenFromHandle(
    HANDLE handle,
    DWORD dwDesiredAccess, 
    BOOL fCleanupOnFailure)
{
    HRESULT hr = S_OK;

    if (_pbThemeData)
        CloseFile();

    _pbThemeData = (BYTE *)MapViewOfFile(handle, dwDesiredAccess, 0, 0, 0);
    if (! _pbThemeData)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    _hMemoryMap = handle;

    //---- ensure data is valid ----
    hr = ValidateThemeData(FALSE);
    if (FAILED(hr))
    {   
        if (!fCleanupOnFailure)
        {
            _hMemoryMap = NULL;	// don't give up the refcount on the handle
            CloseFile();
        }

        hr = MakeError32(ERROR_BAD_FORMAT);
        goto exit;
    }

#ifdef DEBUG
    THEMEHDR *ph;
    ph = (THEMEHDR *)_pbThemeData;
    Log(LOG_TMHANDLE, L"CUxThemeFile::OpenFromHandle OPENED: num=%d, addr=0x%x", 
        ph->iLoadId, _pbThemeData);
#endif

exit:
    if (FAILED(hr))
    {
        if (!fCleanupOnFailure)
        {
            Reset();
        }
        else
        {
            CloseFile();
        }
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CUxThemeFile::ValidateThemeData(BOOL fFullCheck)
{
    HRESULT hr = S_OK;
    THEMEHDR *hdr;

    if (! ValidateObj())
    {
        hr = MakeError32(ERROR_INTERNAL_ERROR);
        goto exit;
    }

    if (IsBadReadPtr(_pbThemeData, 4))        // sufficient test
    {
        hr = MakeError32(ERROR_BAD_FORMAT);
        goto exit;
    }

    hdr = (THEMEHDR *)_pbThemeData;

    if (0 != memcmp(hdr->szSignature, kszBeginCacheFileSignature, kcbBeginSignature)) // bad ptr
    {
#ifdef DEBUG
        CHAR szSignature[kcbBeginSignature + 1];
        CopyMemory(szSignature, hdr->szSignature, kcbBeginSignature); // hdr->szSignature is not NULL-terminated
        szSignature[kcbBeginSignature] = '\0';

        Log(LOG_ERROR, L"ValidateThemeData(): bad header signature: %S", szSignature);
#else
        Log(LOG_ERROR, L"ValidateThemeData(): bad header signature");
#endif
        hr = MakeError32(ERROR_BAD_FORMAT);
        goto exit;
    }

    if (hdr->dwVersion != THEMEDATA_VERSION)
    {
        Log(LOG_ALWAYS, L"ValidateThemeData(): wrong theme data version: 0x%x", hdr->dwVersion);
        hr = MakeError32(ERROR_BAD_FORMAT);
        goto exit;
    }

    if (!IsReady())               // data not ready to use
    {
        Log(LOG_ALWAYS, L"ValidateThemeData(): data not READY - hdr->dwFlags=%x", hdr->dwFlags);
        hr = MakeError32(ERROR_BAD_FORMAT);
        goto exit;
    }

    if (!fFullCheck)        // we are done
        goto exit;

    // Whistler:190200:Instead of checking the checksum, check the end of file signature, to avoid paging in everything
    if (0 != memcmp(_pbThemeData + hdr->dwTotalLength - kcbEndSignature, kszEndCacheFileSignature, kcbEndSignature))
    {
        Log(LOG_ERROR, L"ValidateThemeData(): bad end of file signature");
        hr = MakeError32(ERROR_BAD_FORMAT);
        goto exit;
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
void CUxThemeFile::CloseFile()
{
#ifdef DEBUG
    THEMEHDR *ph = (THEMEHDR *)_pbThemeData;
    if (ph != NULL)
    {
        Log(LOG_TMHANDLE, L"Share CLOSED: num=%d, addr=0x%x", 
            ph->iLoadId, _pbThemeData);
    }
#endif

    if (_hMemoryMap && HasStockObjects() && !IsGlobal())
    {
        CThemeServices::ClearStockObjects(_hMemoryMap);
    }

    if (_pbThemeData)
        UnmapViewOfFile(_pbThemeData);

    if (_hMemoryMap)
        CloseHandle(_hMemoryMap);

    Reset();
}
//---------------------------------------------------------------------------
void CUxThemeFile::Reset()
{
    _pbThemeData = NULL;
    _hMemoryMap = NULL;
}
//---------------------------------------------------------------------------
BOOL CUxThemeFile::ValidateObj()
{
    BOOL fValid = TRUE;

    //---- check object quickly ----
    if (   (! this)                         
        || (ULONGAT(_szHead) != 'fmht')     // "thmf"
        || (ULONGAT(&_szHead[4]) != 'eli')  // "ile" 
        || (ULONGAT(_szTail) != 'dne'))     // "end"
    {
        Log(LOG_ERROR, L"*** ERROR: Invalid CUxThemeFile Encountered, addr=0x%08x ****", this);
        fValid = FALSE;
    }

    return fValid;
}
//---------------------------------------------------------------------------

HANDLE CUxThemeFile::Unload()
{
    HANDLE handle = _hMemoryMap;

    if (_pbThemeData != NULL)
    {
        UnmapViewOfFile(_pbThemeData);
    }
    Reset();          // don't free handle
    return handle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\themeserver.h ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeServer.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Functions that implement server functionality.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _ThemeServer_
#define     _ThemeServer_

//  --------------------------------------------------------------------------
//  CThemeServer
//
//  Purpose:    Class to implement server related functions. Functions
//              declared in this class execute on the server side of themes.
//
//              This means they are restricted in what functions they can and
//              cannot call on the client's behalf. Any win32k functions that
//              are per instance of win32k cannot be called.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

class   CThemeServer
{
    private:
        enum
        {
            FunctionNothing                 =   0,
            FunctionRegisterUserApiHook,
            FunctionUnregisterUserApiHook,
            FunctionClearStockObjects
        };
    private:
                                    CThemeServer (void);
    public:
                                    CThemeServer (HANDLE hProcessRegisterHook, DWORD dwServerChangeNumber, void *pfnRegister, void *pfnUnregister, void *pfnClearStockObjects, DWORD dwStackSizeReserve, DWORD dwStackSizeCommit);
                                    ~CThemeServer (void);

                HRESULT             ThemeHooksOn (void);
                HRESULT             ThemeHooksOff (void);
                bool                AreThemeHooksActive (void);
                int                 GetCurrentChangeNumber (void);
                int                 GetNewChangeNumber (void);
                HRESULT             SetGlobalTheme (HANDLE hSection);
                HRESULT             GetGlobalTheme (HANDLE *phSection);
                HRESULT             LoadTheme (HANDLE hSection, 
                                               HANDLE *phSection, LPCWSTR pszName, LPCWSTR pszColor, LPCWSTR pszSize,
                                               OPTIONAL DWORD dwFlags = 0 /*LTF_xxx*/);
                HRESULT             InjectStockObjectCleanupThread (HANDLE hSection);

        static  bool                IsSystemProcessContext (void);
        static  DWORD               ThemeHooksInstall (void);
        static  DWORD               ThemeHooksRemove (void);
        static  DWORD               ClearStockObjects (HANDLE hSection);
    private:
                void                LockAcquire (void);
                void                LockRelease (void);
                HRESULT             InjectClientSessionThread (HANDLE hProcess, int iIndexFunction, void *pvParam, 
                                                               OUT OPTIONAL BOOL* pfThreadCreated = NULL);
    private:
                HANDLE              _hProcessRegisterHook;
                DWORD               _dwServerChangeNumber;
                void*               _pfnRegister;
                void*               _pfnUnregister;
                void*               _pfnClearStockObjects;
                DWORD               _dwStackSizeReserve;
                DWORD               _dwStackSizeCommit;
                DWORD               _dwSessionID;
                bool                _fHostHooksSet;
                HANDLE              _hSectionGlobalTheme;
                DWORD               _dwClientChangeNumber;
                CRITICAL_SECTION    _lock;
};

#endif  /*  _ThemeLoader_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\themeserver.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeServer.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Functions that implement server functionality. Functions in this file
//  cannot execute per instance win32k functions that are done on the client's
//  behalf. That work must be done on the client side.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

#include "stdafx.h"

#include "ThemeServer.h"
#include "uxthemeserver.h"

#include <shfolder.h>

#include "Loader.h"
#include "Signing.h"
#include "ThemeSection.h"
#include "TmUtils.h"
#include "sethook.h"
#include "log.h"

#include "services.h"

#define TBOOL(x)    ((BOOL)(x))
#define TW32(x)     ((DWORD)(x))
#define THR(x)      ((HRESULT)(x))
#define TSTATUS(x)  ((NTSTATUS)(x))
#define goto        !!DO NOT USE GOTO!! - DO NOT REMOVE THIS ON PAIN OF DEATH

//  --------------------------------------------------------------------------
//  CThemeServer::CThemeServer
//
//  Arguments:  hProcessRegisterHook    =   Process used to install hooks.
//              dwServerChangeNumber    =   Server change number.
//              pfnRegister             =   Address of install hook function.
//              pfnUnregister           =   Address of remove hook function.
//              pfnClearStockObjects    =   Address of function to remove stock objects from section
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CThemeServer. Initializes member variables
//              with information relevant for the session. Keeps a handle to
//              the process that called this to use to inject threads in to
//              handle hook installation and removal.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

CThemeServer::CThemeServer (HANDLE hProcessRegisterHook, DWORD dwServerChangeNumber, void *pfnRegister, void *pfnUnregister, void *pfnClearStockObjects, DWORD dwStackSizeReserve, DWORD dwStackSizeCommit) :
    _hProcessRegisterHook(NULL),
    _dwServerChangeNumber(dwServerChangeNumber),
    _pfnRegister(pfnRegister),
    _pfnUnregister(pfnUnregister),
    _pfnClearStockObjects(pfnClearStockObjects),
    _dwStackSizeReserve(dwStackSizeReserve),
    _dwStackSizeCommit(dwStackSizeCommit),
    _dwSessionID(NtCurrentPeb()->SessionId),
    _fHostHooksSet(false),
    _hSectionGlobalTheme(NULL),
    _dwClientChangeNumber(0)

{
    ULONG                           ulReturnLength;
    PROCESS_SESSION_INFORMATION     processSessionInformation;

    ZeroMemory(&_lock, sizeof(_lock));
    if( !InitializeCriticalSectionAndSpinCount(&_lock, 0) )
    {
        ASSERT(!VALID_CRITICALSECTION(&_lock));
    }

    TBOOL(DuplicateHandle(GetCurrentProcess(),
                          hProcessRegisterHook,
                          GetCurrentProcess(),
                          &_hProcessRegisterHook,
                          0,
                          FALSE,
                          DUPLICATE_SAME_ACCESS));
    if (NT_SUCCESS(NtQueryInformationProcess(hProcessRegisterHook,
                                             ProcessSessionInformation,
                                             &processSessionInformation,
                                             sizeof(processSessionInformation),
                                             &ulReturnLength)))
    {
        _dwSessionID = processSessionInformation.SessionId;
    }
}

//  --------------------------------------------------------------------------
//  CThemeServer::~CThemeServer
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CThemeServer. Releases resources used.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

CThemeServer::~CThemeServer (void)

{
    //---- important: turn off hooks so everyone gets unthemed ----
    if (!GetSystemMetrics(SM_SHUTTINGDOWN)) // Don't do this on shutdown to keep winlogon themed
    {
        ThemeHooksOff();        
    }

    //---- mark global theme invalid & release it ----
    if (_hSectionGlobalTheme != NULL)
    {
        SetGlobalTheme(NULL);
    }

    if (_hProcessRegisterHook != NULL)
    {
        TBOOL(CloseHandle(_hProcessRegisterHook));
        _hProcessRegisterHook = NULL;
    }
    
    SAFE_DELETECRITICALSECTION(&_lock);
}

//  --------------------------------------------------------------------------
//  CThemeServer::ThemeHooksOn
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Install theme hooks via the session controlling process.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeServer::ThemeHooksOn (void)

{
    HRESULT     hr;

    LockAcquire();
    if (!_fHostHooksSet)
    {
        if (ClassicGetSystemMetrics(SM_CLEANBOOT) == 0)
        {
            if (_hProcessRegisterHook != NULL)
            {
                hr = InjectClientSessionThread(_hProcessRegisterHook, FunctionRegisterUserApiHook, NULL);
                _fHostHooksSet = SUCCEEDED(hr);
            }
            else
            {
                hr = MakeError32(ERROR_SERVICE_REQUEST_TIMEOUT);
            }
        }
        else
        {
            hr = MakeError32(ERROR_BAD_ENVIRONMENT);        // themes not allowed in safe mode
        }
    }
    else
    {
        hr = S_OK;
    }
    LockRelease();
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServer::ThemeHooksOff
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Remove theme hooks via the session controlling process.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeServer::ThemeHooksOff (void)

{
    LockAcquire();
    if (_fHostHooksSet)
    {
        _fHostHooksSet = false;
        if (_hProcessRegisterHook != NULL)
        {
            THR(InjectClientSessionThread(_hProcessRegisterHook, FunctionUnregisterUserApiHook, NULL));
        }
    }
    LockRelease();
    return(S_OK);
}

//  --------------------------------------------------------------------------
//  CThemeServer::AreThemeHooksActive
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether theme hooks have been successfully installed.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

bool    CThemeServer::AreThemeHooksActive (void)

{
    bool    fResult;

    LockAcquire();
    fResult = _fHostHooksSet;
    LockRelease();
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CThemeServer::GetCurrentChangeNumber
//
//  Arguments:  <none>
//
//  Returns:    int
//
//  Purpose:    Returns the current change number.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

int     CThemeServer::GetCurrentChangeNumber (void)

{
    int     iCurrentChangeNumber;

    LockAcquire();
    iCurrentChangeNumber = static_cast<int>((_dwServerChangeNumber << 16) | _dwClientChangeNumber);
    LockRelease();

    Log(LOG_TMCHANGE, L"GetCurrentChangeNumber: server: %d, client: %d, change: 0x%x", 
        _dwServerChangeNumber, _dwClientChangeNumber, iCurrentChangeNumber);

    return(iCurrentChangeNumber);
}

//  --------------------------------------------------------------------------
//  CThemeServer::GetNewChangeNumber
//
//  Arguments:  <none>
//
//  Returns:    int
//
//  Purpose:    Returns a new change number.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

int     CThemeServer::GetNewChangeNumber (void)

{
    int     iCurrentChangeNumber;

    LockAcquire();

    _dwClientChangeNumber = static_cast<WORD>(_dwClientChangeNumber + 1);
    iCurrentChangeNumber = static_cast<int>((_dwServerChangeNumber << 16) | _dwClientChangeNumber);

    Log(LOG_TMLOAD, L"GetNewChangeNumber: server: %d, client: %d, change: 0x%x", 
        _dwServerChangeNumber, _dwClientChangeNumber, iCurrentChangeNumber);

    LockRelease();
    return(iCurrentChangeNumber);
}

//  --------------------------------------------------------------------------
//  CThemeServer::SetGlobalTheme
//
//  Arguments:  hSection    =   Handle to section of new theme.
//
//  Returns:    HRESULT
//
//  Purpose:    Invalidates the old section and closes the handle to it.
//              Validates the new section and if valid sets it as the global
//              theme.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeServer::SetGlobalTheme (HANDLE hSection)

{
    HRESULT     hr;

    LockAcquire();
    if (_hSectionGlobalTheme != NULL)
    {
        void    *pV;
        HANDLE hSemaphore = NULL;

        //  Before closing the section invalidate it.

        pV = MapViewOfFile(_hSectionGlobalTheme,
                           FILE_MAP_WRITE,
                           0,
                           0,
                           0);
#ifdef DEBUG
        if (LogOptionOn(LO_TMLOAD))
        {
            // Unexpected failure
            ASSERT(pV != NULL);
        }
#endif
        
        if (pV != NULL)
        {
            // Create a semaphore so that no client will try to clean it before us, which would result in a double free
            // (as soon as we clear SECTION_GLOBAL, various CUxThemeFile destructors can call ClearStockObjects)
            WCHAR szName[64];

            StringCchPrintfW(szName, ARRAYSIZE(szName), L"Global\\ClearStockGlobal%d-%d", reinterpret_cast<THEMEHDR*>(pV)->iLoadId, _dwSessionID);
            hSemaphore = CreateSemaphore(NULL, 0, 1, szName);

            Log(LOG_TMLOAD, L"SetGlobalTheme clearing section %d, semaphore=%s, hSemaphore=%X, gle=%d", reinterpret_cast<THEMEHDR*>(pV)->iLoadId, szName, hSemaphore, GetLastError());
            reinterpret_cast<THEMEHDR*>(pV)->dwFlags &= ~(SECTION_READY | SECTION_GLOBAL);
        }

        HANDLE hSectionForInjection = NULL;

        //---- create a handle for CLIENT process to use to clear stock bitmaps ----
        if (DuplicateHandle(GetCurrentProcess(),
                        _hSectionGlobalTheme,
                        _hProcessRegisterHook,
                        &hSectionForInjection,
                        FILE_MAP_READ,
                        FALSE,
                        0) != FALSE)
        {
            // This will close the handle
            THR(InjectClientSessionThread(_hProcessRegisterHook, FunctionClearStockObjects, hSectionForInjection));
        }

        if (pV != NULL)
        {
            reinterpret_cast<THEMEHDR*>(pV)->dwFlags &= ~SECTION_HASSTOCKOBJECTS;
            
            if (hSemaphore != NULL)
            {
                CloseHandle(hSemaphore);
            }

            TBOOL(UnmapViewOfFile(pV));
        }

        TBOOL(CloseHandle(_hSectionGlobalTheme));
        _hSectionGlobalTheme = NULL;
    }
    if (hSection != NULL)
    {
        CThemeSection   themeSection;

        hr = themeSection.Open(hSection);
        if (SUCCEEDED(hr))
        {
            hr = themeSection.ValidateData(true);
        }
        if (SUCCEEDED(hr))
        {
            if (DuplicateHandle(GetCurrentProcess(),
                                hSection,
                                GetCurrentProcess(),
                                &_hSectionGlobalTheme,
                                FILE_MAP_ALL_ACCESS,
                                FALSE,
                                0) != FALSE)
            {
                hr = S_OK;

            }
            else
            {
                hr = MakeErrorLast();
            }
        }
    }
    else
    {
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        //---- bump the change number at the same time so everything is in sync. ----
        int iChangeNum = GetNewChangeNumber();

        if (_hSectionGlobalTheme)
        {
            //---- put changenum into theme hdr to help client keep things straight ----
            VOID *pv = MapViewOfFile(_hSectionGlobalTheme,
                               FILE_MAP_WRITE,
                               0,
                               0,
                               0);
            if (pv != NULL)
            {
                reinterpret_cast<THEMEHDR*>(pv)->dwFlags |= SECTION_GLOBAL;
                reinterpret_cast<THEMEHDR*>(pv)->iLoadId = iChangeNum;
                Log(LOG_TMLOAD, L"SetGlobalTheme: new section is %d", reinterpret_cast<THEMEHDR*>(pv)->iLoadId);
                TBOOL(UnmapViewOfFile(pv));
            }
        }
    }
    
    LockRelease();
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServer::GetGlobalTheme
//
//  Arguments:  phSection   =   Handle to the section received.
//
//  Returns:    HRESULT
//
//  Purpose:    Duplicates the section back to the caller.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

HRESULT     CThemeServer::GetGlobalTheme (HANDLE *phSection)

{
    HRESULT     hr;

    LockAcquire();
    *phSection = NULL;
    if (_hSectionGlobalTheme != NULL)
    {
        if (DuplicateHandle(GetCurrentProcess(),
                            _hSectionGlobalTheme,
                            GetCurrentProcess(),
                            phSection,
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS) != FALSE)
        {
            hr = S_OK;
        }
        else
        {
            hr = MakeErrorLast();
        }
    }
    else
    {
        hr = S_OK;
    }
    LockRelease();
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServer::LoadTheme
//
//  Arguments:  hSection    =   Section created by the client.
//              phSection   =   Section created by the server returned.
//              pszName     =   Theme name.
//              pszColor    =   Theme size.
//              pszSize     =   Theme color.
//              fOwnStockObjects =  TRUE to clear the stock objects bit on the 
//                                  incoming section, on success, thereby taking 
//                                  full responsibility for SO cleanup.
//
//  Returns:    HRESULT
//
//  Purpose:    Creates a new section in the server context based on the
//              section from the client. The contents are transferred across.
//              The section contents are also strictly verified.
//
//  History:    2000-11-11  vtan        created
//              2002-03-21  scotthan    Update incoming section header to
//                                      indicate change of ownership.
//  --------------------------------------------------------------------------

HRESULT     CThemeServer::LoadTheme (
    HANDLE hSection, 
    HANDLE *phSection, 
    LPCWSTR pszName, 
    LPCWSTR pszColor, 
    LPCWSTR pszSize,
    OPTIONAL DWORD dwFlags)

{
    HRESULT     hr;

    hr = CheckThemeSignature(pszName);          //  Check this is signed
    if (SUCCEEDED(hr))
    {
        CThemeSection   themeSectionIn;

        if (SUCCEEDED(themeSectionIn.Open(hSection, FILE_MAP_READ|FILE_MAP_WRITE)))
        {
            if (ThemeMatch(themeSectionIn, pszName, pszColor, pszSize, 0) != FALSE)
            {
                hr = themeSectionIn.ValidateData(true);
                if (SUCCEEDED(hr))
                {
                    CThemeSection   themeSectionOut;

                    //  Only privileged clients can create a section with GDI stock objects
                    if( 0 == (((THEMEHDR*)themeSectionIn.GetData())->dwFlags & SECTION_HASSTOCKOBJECTS) ||
                        0 != (dwFlags & LTF_GLOBALPRIVILEGEDCLIENT) )
                    {
                        // Note: we come here impersonating the user, we need for ThemeMatch.
                        // However the theme section must be created in the system context, so that only
                        // the system context has write access to it. We revert to self here based on the
                        // knowledge that nothing after this call needs to be done in the user context.
                        RevertToSelf();

                        // make sure that we're TCB svchost.   Nobody else should be able to do this in-proc.
                        if( !TokenHasPrivilege( NULL, SE_TCB_PRIVILEGE ) )
                        {
                            hr = E_ACCESSDENIED;
                        }
                        else
                        {
                            hr = themeSectionOut.CreateFromSection(hSection);
                            if (SUCCEEDED(hr))
                            {
                                *phSection = themeSectionOut.Get();     //  We now own the handle

                                if( (dwFlags & LTF_TRANSFERSTOCKOBJOWNERSHIP) != 0 )
                                {
                                    //  We're transfering ownership of stock bitmaps, if any, to the output (read-only) 
                                    //  section; this simply means removing the SECTION_HASSTOCKOBJECTS bit from the 
                                    //  incoming section so that the client doesn't attempt to clear them.
                                    ((THEMEHDR*)themeSectionIn.GetData())->dwFlags &= ~SECTION_HASSTOCKOBJECTS;
                                }
                            }
                        }
                    }
                    else
                    {
                        hr = E_ACCESSDENIED;
                    }
                }
            }
            else
            {
                hr = E_ACCESSDENIED;
            }
        }
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeServer::IsSystemProcessContext
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Is the current process executing in the SYSTEM context?
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

bool    CThemeServer::IsSystemProcessContext (void)

{
    bool    fResult;
    HANDLE  hToken;

    fResult = false;
    if (OpenProcessToken(GetCurrentProcess(),
                         TOKEN_QUERY,
                         &hToken) != FALSE)
    {
        static  const LUID  sLUIDSystem     =   SYSTEM_LUID;

        ULONG               ulReturnLength;
        TOKEN_STATISTICS    tokenStatistics;

        fResult = ((GetTokenInformation(hToken,
                                        TokenStatistics,
                                        &tokenStatistics,
                                        sizeof(tokenStatistics),
                                        &ulReturnLength) != FALSE) &&
                   RtlEqualLuid(&tokenStatistics.AuthenticationId, &sLUIDSystem));
        TBOOL(CloseHandle(hToken));
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CThemeServer::ThemeHooksInstall
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Thread entry point for injected thread running in session
//              creating process' context to call user32!RegisterUserApiHook.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

DWORD   CThemeServer::ThemeHooksInstall (void)

{
    DWORD   dwErrorCode;

    if (IsSystemProcessContext())
    {
        INITUSERAPIHOOK pfnInitUserApiHook = ThemeInitApiHook;

        if (RegisterUserApiHook(g_hInst, pfnInitUserApiHook) != FALSE)
        {

            dwErrorCode = ERROR_SUCCESS;
        }
        else
        {
            dwErrorCode = GetLastError();
        }
    }
    else
    {
        dwErrorCode = ERROR_ACCESS_DENIED;
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CThemeServer::ThemeHooksRemove
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Thread entry point for injected thread running in session
//              creating process' context to call
//              user32!UnregisterUserApiHook.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

DWORD   CThemeServer::ThemeHooksRemove (void)

{
    DWORD   dwErrorCode;

    if (IsSystemProcessContext())
    {
        if (UnregisterUserApiHook() != FALSE)
        {
            dwErrorCode = ERROR_SUCCESS;

            Log(LOG_TMLOAD, L"UnregisterUserApiHook() called");
        }
        else
        {
            dwErrorCode = GetLastError();
        }

    }
    else
    {
        dwErrorCode = ERROR_ACCESS_DENIED;
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CThemeServer::ClearStockObjects
//
//  Arguments:  HANDLE hSection
//
//  Returns:    DWORD
//
//  Purpose:    Thread entry point for injected thread running in session
//              creating process' context to clear stock objects in theme
//              section.
//           
//
//  History:    2001-05-01  rfernand        created
//  --------------------------------------------------------------------------

DWORD   CThemeServer::ClearStockObjects (HANDLE hSection)

{
    DWORD   dwErrorCode = ERROR_SUCCESS;

    if (IsSystemProcessContext())
    {
        if (hSection)
        {
            //---- Clearing the stock bitmaps in the section ----
            //---- is OK here since we are running in the context ----
            //---- of the current USER session ----

            HRESULT hr = ClearTheme(hSection, TRUE);
            if (FAILED(hr))
            {
                Log(LOG_ALWAYS, L"ClearTheme() failed, hr=0x%x", hr);
                hr = S_OK;      // not a fatal error
            }
        }
    }
    else
    {
        dwErrorCode = ERROR_ACCESS_DENIED;
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CThemeServer::LockAcquire
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Acquires the object critical section.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

void    CThemeServer::LockAcquire (void)

{
    SAFE_ENTERCRITICALSECTION(&_lock);
}

//  --------------------------------------------------------------------------
//  CThemeServer::LockRelease
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases the object critical section.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

void    CThemeServer::LockRelease (void)

{
    SAFE_LEAVECRITICALSECTION(&_lock);
}

//  --------------------------------------------------------------------------
//  CThemeServer::InjectStockObjectCleanupThread
//
//  Arguments:  hSection        =   Handle of section to clean/clear
//
//  Returns:    HRESULT
//
//  Purpose:    Permits server to inject a thread into the process 
//              in which stock object handles can be released.
//
//  History:    2002-03-11  scotthan     created
//  --------------------------------------------------------------------------
HRESULT  CThemeServer::InjectStockObjectCleanupThread(HANDLE hSection)
{
    HANDLE hSectionClean;

    //---- create a handle for target process to use to clear stock bitmaps ----
    if (!DuplicateHandle(GetCurrentProcess(),
                        hSection,
                        _hProcessRegisterHook,
                        &hSectionClean,
                        FILE_MAP_READ,
                        FALSE,
                        0))
    {
        return MakeErrorLast();
    }
    
    // This will close the duplicate we just created, but not the inbound handle
    BOOL fThreadCreated;
    HRESULT hr = InjectClientSessionThread(_hProcessRegisterHook, FunctionClearStockObjects, hSectionClean,
                                            &fThreadCreated);

    if( !fThreadCreated )
    {
        CloseHandle(hSectionClean);
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CThemeServer::InjectClientSessionThread
//
//  Arguments:  hProcess        =   Handle to process to inject thread in.
//              iIndexFunction  =   Function to call on injected thread.
//              pvParam         =   Ptr to param for entry function
//
//  Returns:    HRESULT
//
//  Purpose:    Create a user mode thread in the remote process (possibly
//              across sessions) and execute the entry point specified at
//              object construction which is valid in the remote process
//              context. Wait for the thread to finish. It will signal its
//              success of failure in the exit code.
//
//  History:    2000-11-11  vtan        created
//              2001-05-18  vtan        generic function index
//  --------------------------------------------------------------------------

HRESULT     CThemeServer::InjectClientSessionThread (
    HANDLE hProcess, int iIndexFunction, void *pvParam,
    OUT OPTIONAL BOOL* pfThreadCreated )

{
    HRESULT                     hr;
    PUSER_THREAD_START_ROUTINE  pfnThreadStart;

    if( pfThreadCreated )
        *pfThreadCreated = FALSE;

    switch (iIndexFunction)
    {
        case FunctionRegisterUserApiHook:
            pfnThreadStart = reinterpret_cast<PUSER_THREAD_START_ROUTINE>(_pfnRegister);
            break;
        case FunctionUnregisterUserApiHook:
            pfnThreadStart = reinterpret_cast<PUSER_THREAD_START_ROUTINE>(_pfnUnregister);
            break;
        case FunctionClearStockObjects:
            pfnThreadStart = reinterpret_cast<PUSER_THREAD_START_ROUTINE>(_pfnClearStockObjects);
            break;
        default:
            pfnThreadStart = NULL;
            break;
    }
    if (pfnThreadStart != NULL)
    {
        NTSTATUS    status;
        HANDLE      hThread;

        status = RtlCreateUserThread(hProcess,
                                     NULL,
                                     FALSE,
                                     0,
                                     _dwStackSizeReserve,
                                     _dwStackSizeCommit,
                                     pfnThreadStart,
                                     pvParam,
                                     &hThread,
                                     NULL);
        if (NT_SUCCESS(status))
        {
            DWORD   dwWaitResult, dwExitCode;

            if( pfThreadCreated )
                *pfThreadCreated = TRUE;

            dwWaitResult = WaitForSingleObject(hThread, INFINITE);
            if (GetExitCodeThread(hThread, &dwExitCode) != FALSE)
            {
                hr = HRESULT_FROM_WIN32(dwExitCode);
            }
            else
            {
                hr = E_FAIL;
            }
            TBOOL(CloseHandle(hThread));
        }
        else
        {
            hr = HRESULT_FROM_NT(status);
        }
    }
    else
    {
        hr = E_FAIL;
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\wrapper.h ===
//---------------------------------------------------------------------------
//  Wrapper.h - wrappers for internal-only API's (not private)
//            - public and private API's in uxtheme.h, uxthemep.h
//---------------------------------------------------------------------------
#ifndef _WRAPPER_H
#define _WRAPPER_H
//---------------------------------------------------------------------------
#include "parser.h"
//---------------------------------------------------------------------------
//---- bits used in dwFlags of DTTOPTS ----
#define DTT_TEXTCOLOR     (1 << 0)   // crText has been specified
#define DTT_BORDERCOLOR   (1 << 1)   // crBorder has been specified
#define DTT_SHADOWCOLOR   (1 << 2)   // crShadow has been specified

#define DTT_SHADOWTYPE    (1 << 3)   // iTextShadowType has been specified
#define DTT_SHADOWOFFSET  (1 << 4)   // ptShadowOffset has been specified
#define DTT_BORDERSIZE    (1 << 5)   // iBorderSize has been specified

//------------------------------------------------------------------------
typedef struct _DTTOPTS
{
    DWORD dwSize;          // size of the struct
    DWORD dwFlags;         // which options have been specified

    COLORREF crText;       // color to use for text fill
    COLORREF crBorder;     // color to use for text outline
    COLORREF crShadow;     // color to use for text shadow

    int eTextShadowType;   // TST_SINGLE or TST_CONTINUOUS
    POINT ptShadowOffset;  // where shadow is drawn (relative to text)
    int iBorderSize;       // border around text
} 
DTTOPTS, *PDTTOPTS;
//------------------------------------------------------------------------

THEMEAPI GetThemeBitmap(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, 
    const RECT *prc, OUT HBITMAP *phBitmap);

THEMEAPI_(HTHEME) OpenNcThemeData(HWND hwnd, LPCWSTR pszClassIdList);

THEMEAPI DrawThemeTextEx(HTHEME hTheme, HDC hdc, int iPartId, 
    int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, 
    const RECT *pRect, OPTIONAL const DTTOPTS *pOptions);

THEMEAPI_(HTHEME) OpenThemeDataFromFile(HTHEMEFILE hLoadedThemeFile, 
    OPTIONAL HWND hwnd, OPTIONAL LPCWSTR pszClassList, BOOL fClient);

THEMEAPI ClearTheme (HANDLE hSection, BOOL fForce = FALSE);

//---------------------------------------------------------------------------
#endif // _WRAPPER_H
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\cleaninf\debug.c ===
#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "tests.ini"
#define SZ_DEBUGSECTION     "ICONVIEW"
#define SZ_MODULE           "ICONVIEW"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\cleaninf\priv.h ===
#ifndef _PRIV_H_
#define _PRIV_H_

#include <windows.h>
#include <windowsx.h>

#include <ccstock.h>
#include <debug.h>

#ifdef __cplusplus
#include <shstr.h>
#endif

#include <stdlib.h>
#include <stdio.h>

#include "resource.h"

#include "parse.h"

#ifdef __cplusplus
extern "C" {
#endif

// Helper functions
// (Don't link to shlwapi.dll so this is a stand-alone tool)
//
void PathUnquoteSpaces(LPTSTR lpsz);
BOOL StrTrim(LPSTR  pszTrimMe, LPCSTR pszTrimChars);


// Trace and Dump flags
#define BF_ONOPEN           0x00000010


// Parse file flags
#define PFF_WHITESPACE      0x00000001
#define PFF_INF             0x00000002
#define PFF_HTML            0x00000004
#define PFF_JS              0x00000008
#define PFF_HTC             0x00000010


#ifdef __cplusplus
}
#endif

#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\wrapper.cpp ===
//---------------------------------------------------------------------------
//  Wrapper.cpp - wrappers for win32-style API (handle-based)
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Render.h"

#include "Utils.h"
#include "Loader.h"
#include "Wrapper.h"
#include "SetHook.h"
#include "Info.h"
#include "Services.h"
#include "appinfo.h"
#include "tmreg.h"
#include "tmutils.h"
#include "themeldr.h"
#include "borderfill.h"
#include "imagefile.h"
#include "textdraw.h"
#include "renderlist.h"
#include "filedump.h"
#include "Signing.h"
//---------------------------------------------------------------------------
#include "paramchecks.h"
//---------------------------------------------------------------------------
#define RETURN_VALIDATE_RETVAL(hr) { if (FAILED(hr)) return MakeError32(hr); }     // HRESULT functions
//---------------------------------------------------------------------------
#define MAX_THEMEAPI_STRINGPARAM MAX_PATH   // Strings used by Themes APIs can't be bigger than this
#define MAX_FILENAMEPARAM (MAX_PATH + 1)    // + 1 for the NULL terminator
//---------------------------------------------------------------------------
THEMEAPI GetThemePropertyOrigin(HTHEME hTheme, int iPartId, int iStateId,
    int iPropId, OUT PROPERTYORIGIN *pOrigin)
{
    APIHELPER(L"GetThemePropertyOrigin", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, pOrigin, sizeof(PROPERTYORIGIN));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetPropertyOrigin(iPartId, iStateId, iPropId, pOrigin);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeColor(HTHEME hTheme, int iPartId, int iStateId,
   int iPropId, OUT COLORREF *pColor)
{
    APIHELPER(L"GetThemeColor", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, pColor, sizeof(COLORREF));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetColor(iPartId, iStateId, iPropId, pColor);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeBitmap(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, 
    const RECT *prc, OUT HBITMAP *phBitmap)
{
    APIHELPER(L"GetThemeBitmap", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, phBitmap, sizeof(HBITMAP));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CDrawBase *pDrawObj;

    HRESULT hr = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr))
    {
        if (pDrawObj->_eBgType == BT_IMAGEFILE)
        {
            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            hr = pImageFile->GetBitmap(pRender, hdc, prc, phBitmap);
        }
        else        // BorderFill
        {
            hr = E_FAIL;
        }
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeMetric(HTHEME hTheme, OPTIONAL HDC hdc, int iPartId, int iStateId,
     int iPropId, OUT int *piVal)
{
    APIHELPER(L"GetThemeMetric", hTheme);

    if (hdc)
    {
        VALIDATE_HDC(ApiHelper, hdc);
    }

    VALIDATE_WRITE_PTR(ApiHelper, piVal, sizeof(int));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetMetric(hdc, iPartId, iStateId, iPropId, piVal);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeString(HTHEME hTheme, int iPartId, int iStateId,
    int iPropId, OUT LPWSTR pszBuff, int cchMaxBuffChars)
{
    APIHELPER(L"GetThemeString", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, pszBuff, sizeof(WCHAR)*cchMaxBuffChars);

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetString(iPartId, iStateId, iPropId, pszBuff, cchMaxBuffChars);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeBool(HTHEME hTheme, int iPartId, int iStateId,
     int iPropId, OUT BOOL *pfVal)
{
    APIHELPER(L"GetThemeBool", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, pfVal, sizeof(BOOL));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetBool(iPartId, iStateId, iPropId, pfVal);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeInt(HTHEME hTheme, int iPartId, int iStateId,
    int iPropId, OUT int *piVal)
{
    APIHELPER(L"GetThemeInt", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, piVal, sizeof(int));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetInt(iPartId, iStateId, iPropId, piVal);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeEnumValue(HTHEME hTheme, int iPartId, int iStateId,
    int iPropId, OUT int *piVal)
{
    APIHELPER(L"GetThemeEnumValue", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, piVal, sizeof(int));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetEnumValue(iPartId, iStateId, iPropId, piVal);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemePosition(HTHEME hTheme, int iPartId, int iStateId,
    int iPropId, OUT POINT *ppt)
{
    APIHELPER(L"GetThemePosition", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, ppt, sizeof(POINT));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetPosition(iPartId, iStateId, iPropId, ppt);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeFont(HTHEME hTheme, OPTIONAL HDC hdc, int iPartId, int iStateId, 
    int iPropId, OUT LOGFONT *pFont)
{
    APIHELPER(L"GetThemeFont", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, pFont, sizeof(LOGFONT));

    if (hdc)
    {
        VALIDATE_HDC(ApiHelper, hdc);
    }

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetFont(hdc, iPartId, iStateId, iPropId, TRUE, pFont);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeIntList(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT INTLIST *pIntList)
{
    APIHELPER(L"GetThemeIntList", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, pIntList, sizeof(INTLIST));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetIntList(iPartId, iStateId, iPropId, pIntList);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeMargins(HTHEME hTheme, OPTIONAL HDC hdc, int iPartId, 
    int iStateId, int iPropId, OPTIONAL RECT *prc, OUT MARGINS *pMargins)
{
    APIHELPER(L"GetThemeMargins", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, pMargins, sizeof(MARGINS));

    if (hdc)
    {
        VALIDATE_HDC(ApiHelper, hdc);
    }

    if (prc)
    {
        VALIDATE_READ_PTR(ApiHelper, prc, sizeof(RECT));
    }

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    //---- look up unscaled value of margins ----
    HRESULT hr = pRender->GetMargins(hdc, iPartId, iStateId, iPropId, prc, pMargins);
    if (FAILED(hr))
        goto exit;
    
    //---- try to convert to scaled margins ----
    CDrawBase *pDrawObj;

    HRESULT hr2 = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr2))
    {
        if (pDrawObj->_eBgType == BT_IMAGEFILE)
        {
            SIZE szDraw;
            TRUESTRETCHINFO tsInfo;

            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            
            DIBINFO *pdi = pImageFile->SelectCorrectImageFile(pRender, hdc, prc, FALSE, NULL);

            pImageFile->GetDrawnImageSize(pdi, prc, &tsInfo, &szDraw);

            hr = pImageFile->ScaleMargins(pMargins, hdc, pRender, pdi, &szDraw);
        }
    }

exit:
    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeRect(HTHEME hTheme, int iPartId, int iStateId,
    int iPropId, OUT RECT *pRect)
{
    APIHELPER(L"GetThemeRect", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, pRect, sizeof(RECT));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetRect(iPartId, iStateId, iPropId, pRect);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeFilename(HTHEME hTheme, int iPartId, int iStateId,
    int iPropId, OUT LPWSTR pszBuff, int cchMaxBuffChars)
{
    APIHELPER(L"GetThemeFilename", hTheme);

    VALIDATE_WRITE_PTR(ApiHelper, pszBuff, sizeof(WCHAR)*cchMaxBuffChars);

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    return pRender->GetFilename(iPartId, iStateId, iPropId, pszBuff, cchMaxBuffChars);
}
//-----------------------------------------------------------------------
THEMEAPI DrawThemeBackgroundEx(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, const RECT *pRect, OPTIONAL const DTBGOPTS *pOptions)
{
    APIHELPER(L"DrawThemeBackground", hTheme);

    HRESULT hr = S_OK;
    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CDrawBase *pDrawObj;

    VALIDATE_HDC(ApiHelper, hdc);
    VALIDATE_READ_PTR(ApiHelper, pRect, sizeof(RECT));

    if (pOptions)    
    {
        VALIDATE_READ_PTR(ApiHelper, pOptions, sizeof(*pOptions));
        if (pOptions->dwSize != sizeof(*pOptions))
        {
            hr = MakeError32(E_FAIL);
            return hr;
        }
    }

    hr = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr))
    {
        if (pDrawObj->_eBgType == BT_BORDERFILL)
        {
            CBorderFill *pBorderFill = (CBorderFill *)pDrawObj;
            hr = pBorderFill->DrawBackground(pRender, hdc, pRect, pOptions);
        }
        else        // imagefile
        {
            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            hr = pImageFile->DrawBackground(pRender, hdc, iStateId, pRect, pOptions);
        }
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI DrawThemeBackground(HTHEME hTheme, HDC hdc, int iPartId, 
    int iStateId, const RECT *pRect, OPTIONAL const RECT *pClipRect)
{
    APIHELPER(L"DrawThemeBackground", hTheme);

    HRESULT hr = S_OK;
    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CDrawBase *pDrawObj;

    VALIDATE_HDC(ApiHelper, hdc);
    VALIDATE_READ_PTR(ApiHelper, pRect, sizeof(RECT));

    if (pClipRect)    
    {
        VALIDATE_READ_PTR(ApiHelper, pClipRect, sizeof(RECT));
        
        RECT rcx;
        if (! IntersectRect(&rcx, pRect, pClipRect))        // nothing to paint
            goto exit;
    }

    hr = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr))
    {
        DTBGOPTS Opts = {sizeof(Opts)};
        DTBGOPTS *pOpts = NULL;

        if (pClipRect)
        {
            pOpts = &Opts;
            Opts.dwFlags |= DTBG_CLIPRECT;
            Opts.rcClip = *pClipRect;
        }

        if (pDrawObj->_eBgType == BT_BORDERFILL || 
            pDrawObj->_eBgType == BT_NONE)
        {
            CBorderFill *pBorderFill = (CBorderFill *)pDrawObj;
            hr = pBorderFill->DrawBackground(pRender, hdc, pRect, pOpts);
        }
        else        // imagefile
        {
            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            hr = pImageFile->DrawBackground(pRender, hdc, iStateId, pRect, pOpts);
        }
    }

exit:
    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI HitTestThemeBackground(
    HTHEME hTheme, 
    OPTIONAL HDC hdc, 
    int iPartId, 
    int iStateId, 
    DWORD dwOptions, 
    const RECT *pRect, 
    OPTIONAL HRGN hrgn,
    POINT ptTest, 
    OUT WORD *pwHitTestCode)
{
    APIHELPER(L"HitTestThemeBackground", hTheme);
    
    HRESULT hr;
    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CDrawBase *pDrawObj;

    VALIDATE_READ_PTR(ApiHelper, pRect, sizeof(RECT));
    VALIDATE_WRITE_PTR(ApiHelper, pwHitTestCode, sizeof(WORD));

    if (hdc)
    {
        VALIDATE_HDC(ApiHelper, hdc);
    }

    if( hrgn )
    {
        VALIDATE_HANDLE(ApiHelper, hrgn);
    }

    hr = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr))
    {
        if (pDrawObj->_eBgType == BT_BORDERFILL)
        {
            CBorderFill *pBorderFill = (CBorderFill *)pDrawObj;
            hr = pBorderFill->HitTestBackground(pRender, hdc, dwOptions, pRect, 
                hrgn, ptTest, pwHitTestCode);
        }
        else        // imagefile
        {
            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            hr = pImageFile->HitTestBackground(pRender, hdc, iStateId, dwOptions, pRect, 
                hrgn, ptTest, pwHitTestCode);
        }
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI DrawThemeTextEx(HTHEME hTheme, HDC hdc, int iPartId, 
    int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, 
    const RECT *pRect, OPTIONAL const DTTOPTS *pOptions)
{
    APIHELPER(L"DrawThemeTextEx", hTheme);
    
    VALIDATE_HDC(ApiHelper, hdc);
    
    if (iCharCount == -1)
    {
        VALIDATE_INPUT_UNLIMITED_STRING(ApiHelper, pszText);
    }
    else
    {
        VALIDATE_READ_PTR(ApiHelper, pszText, sizeof(WCHAR)*iCharCount);
    }

    VALIDATE_READ_PTR(ApiHelper, pRect, sizeof(RECT));

    if (pOptions)
    {
        VALIDATE_READ_PTR(ApiHelper, pOptions, sizeof(*pOptions));
        if (pOptions->dwSize != sizeof(*pOptions))
        {
            return MakeError32(E_FAIL);
        }
    }

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CTextDraw *pTextObj;

    HRESULT hr = pRender->GetTextObj(iPartId, iStateId, &pTextObj);
    if (SUCCEEDED(hr))
    {
        hr = pTextObj->DrawText(pRender, hdc, iPartId, iStateId, pszText, iCharCount, 
            dwTextFlags, pRect, pOptions);
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI DrawThemeText(HTHEME hTheme, HDC hdc, int iPartId, 
    int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, 
    DWORD dwTextFlags2, const RECT *pRect)
{
    APIHELPER(L"DrawThemeText", hTheme);
    
    VALIDATE_HDC(ApiHelper, hdc);
    
    if (iCharCount == -1)
    {
        VALIDATE_INPUT_UNLIMITED_STRING(ApiHelper, pszText);
    }
    else
    {
        VALIDATE_READ_PTR(ApiHelper, pszText, sizeof(WCHAR)*iCharCount);
    }

    VALIDATE_READ_PTR(ApiHelper, pRect, sizeof(RECT));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CTextDraw *pTextObj;

    HRESULT hr = pRender->GetTextObj(iPartId, iStateId, &pTextObj);
    if (SUCCEEDED(hr))
    {
        hr = pTextObj->DrawText(pRender, hdc, iPartId, iStateId, pszText, iCharCount, 
            dwTextFlags, pRect, NULL);
    }

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI CloseThemeData(HTHEME hTheme)
{
    //---- don't take a refcount on hTheme since we are about to close it ----
    APIHELPER(L"CloseThemeData", NULL);

    return g_pRenderList->CloseRenderObject(hTheme);
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeBackgroundContentRect(HTHEME hTheme, OPTIONAL HDC hdc, 
    int iPartId, int iStateId, const RECT *pBoundingRect, 
    OUT RECT *pContentRect)
{
    APIHELPER(L"GetThemeBackgroundContentRect", hTheme);

    HRESULT hr;
    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CDrawBase *pDrawObj;

    VALIDATE_READ_PTR(ApiHelper, pBoundingRect, sizeof(RECT));
    VALIDATE_WRITE_PTR(ApiHelper, pContentRect, sizeof(RECT));

    if (hdc)
    {
        VALIDATE_HDC(ApiHelper, hdc);
    }

    hr = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr))
    {
        if (pDrawObj->_eBgType == BT_BORDERFILL)
        {
            CBorderFill *pBorderFill = (CBorderFill *)pDrawObj;
            hr = pBorderFill->GetBackgroundContentRect(pRender, hdc, 
                pBoundingRect, pContentRect);
        }
        else        // imagefile
        {
            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            hr = pImageFile->GetBackgroundContentRect(pRender, hdc, 
                pBoundingRect, pContentRect);
        }
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeBackgroundRegion(HTHEME hTheme, OPTIONAL HDC hdc,  
    int iPartId, int iStateId, const RECT *pRect, OUT HRGN *pRegion)
{
    APIHELPER(L"GetThemeBackgroundRegion", hTheme);

    VALIDATE_READ_PTR(ApiHelper, pRect, sizeof(RECT));
    VALIDATE_WRITE_PTR(ApiHelper, pRegion, sizeof(HRGN));

    if (hdc)
    {
        VALIDATE_HDC(ApiHelper, hdc);
    }

    if (IsRectEmpty(pRect))
    {
        *pRegion = NULL;
        return S_FALSE;
    }

    HRESULT hr;
    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CDrawBase *pDrawObj;

    hr = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr))
    {
        if (pDrawObj->_eBgType == BT_BORDERFILL)
        {
            CBorderFill *pBorderFill = (CBorderFill *)pDrawObj;
            hr = pBorderFill->GetBackgroundRegion(pRender, hdc, pRect, pRegion);
        }
        else        // imagefile
        {
            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            hr = pImageFile->GetBackgroundRegion(pRender, hdc, iStateId, pRect, pRegion);
        }
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeTextExtent(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, 
    DWORD dwTextFlags, OPTIONAL const RECT *pBoundingRect, 
    OUT RECT *pExtentRect)
{
    APIHELPER(L"GetThemeTextExtent", hTheme);

    VALIDATE_HDC(ApiHelper, hdc);

    if (iCharCount == -1)
    {
        VALIDATE_INPUT_UNLIMITED_STRING(ApiHelper, pszText);
    } else
    {
        VALIDATE_READ_PTR(ApiHelper, pszText, sizeof(WCHAR)*iCharCount);
    }

    if (pBoundingRect)
    {
        VALIDATE_READ_PTR(ApiHelper, pBoundingRect, sizeof(RECT));
    }

    VALIDATE_WRITE_PTR(ApiHelper, pExtentRect, sizeof(RECT));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CTextDraw *pTextObj;

    HRESULT hr = pRender->GetTextObj(iPartId, iStateId, &pTextObj);
    if (SUCCEEDED(hr))
    {
        hr = pTextObj->GetTextExtent(pRender, hdc, iPartId, iStateId, pszText, iCharCount,
            dwTextFlags, pBoundingRect, pExtentRect);
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeTextMetrics(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, OUT TEXTMETRIC* ptm)
{
    APIHELPER(L"GetThemeTextMetrics", hTheme);

    VALIDATE_HDC(ApiHelper, hdc);
    VALIDATE_WRITE_PTR(ApiHelper, ptm, sizeof(TEXTMETRIC));

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CTextDraw *pTextObj;

    HRESULT hr = pRender->GetTextObj(iPartId, iStateId, &pTextObj);
    if (SUCCEEDED(hr))
    {
        hr = pTextObj->GetTextMetrics(pRender, hdc, iPartId, iStateId, ptm);
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI GetThemeBackgroundExtent(HTHEME hTheme, OPTIONAL HDC hdc,
    int iPartId, int iStateId, const RECT *pContentRect, OUT RECT *pExtentRect)
{
    APIHELPER(L"GetThemeBackgroundExtent", hTheme);

    VALIDATE_READ_PTR(ApiHelper, pContentRect, sizeof(RECT));
    VALIDATE_WRITE_PTR(ApiHelper, pExtentRect, sizeof(RECT));

    if (hdc)
    {
        VALIDATE_HDC(ApiHelper, hdc);
    }

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CDrawBase *pDrawObj;
    HRESULT hr = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr))
    {
        if (pDrawObj->_eBgType == BT_BORDERFILL)
        {
            CBorderFill *pBorderFill = (CBorderFill *)pDrawObj;
            hr = pBorderFill->GetBackgroundExtent(pRender, hdc, pContentRect,
                pExtentRect);
        }
        else        // imagefile
        {
            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            hr = pImageFile->GetBackgroundExtent(pRender, hdc, 
                pContentRect, pExtentRect);
        }
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI GetThemePartSize(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, OPTIONAL RECT *prc, THEMESIZE eSize, OUT SIZE *psz)
{
    APIHELPER(L"GetThemePartSize", hTheme);

    HRESULT hr;
    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CDrawBase *pDrawObj;

    if (hdc)
    {
        VALIDATE_HDC(ApiHelper, hdc);
    }

    if (prc)
    {
        VALIDATE_READ_PTR(ApiHelper, prc, sizeof(RECT));
    }

    VALIDATE_WRITE_PTR(ApiHelper, psz, sizeof(SIZE));

    hr = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr))
    {
        if (pDrawObj->_eBgType == BT_BORDERFILL)
        {
            CBorderFill *pBorderFill = (CBorderFill *)pDrawObj;
            hr = pBorderFill->GetPartSize(hdc, eSize, psz);
        }
        else        // imagefile
        {
            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            hr = pImageFile->GetPartSize(pRender, hdc, prc, eSize, psz);
        }
    }

    return hr;
}
//-----------------------------------------------------------------------
THEMEAPI SetWindowTheme(HWND hwnd, LPCWSTR pszSubAppName, 
    LPCWSTR pszSubIdList)
{
    APIHELPER(L"SetWindowTheme", NULL);

    VALIDATE_HWND(ApiHelper, hwnd);
    if (pszSubAppName)
    {
        VALIDATE_INPUT_STRING(ApiHelper, pszSubAppName, 255); // Atom
    }
    if (pszSubIdList)
    {
        VALIDATE_INPUT_STRING(ApiHelper, pszSubIdList, 255); // Atom
    }
    
    ApplyStringProp(hwnd, pszSubAppName, GetThemeAtom(THEMEATOM_SUBAPPNAME));
    ApplyStringProp(hwnd, pszSubIdList, GetThemeAtom(THEMEATOM_SUBIDLIST));

    //---- tell target window to get a new theme handle ----
    SendMessage(hwnd, WM_THEMECHANGED, static_cast<WPARAM>(-1), WTC_THEMEACTIVE | WTC_CUSTOMTHEME);

    return S_OK;
}
//---------------------------------------------------------------------------
THEMEAPI GetCurrentThemeName(
    OUT LPWSTR pszNameBuff, int cchMaxNameChars, 
    OUT OPTIONAL LPWSTR pszColorBuff, int cchMaxColorChars,
    OUT OPTIONAL LPWSTR pszSizeBuff, int cchMaxSizeChars)
{
    APIHELPER(L"GetCurrentThemeName", NULL);

    VALIDATE_WRITE_PTR(ApiHelper, pszNameBuff, sizeof(WCHAR)*cchMaxNameChars);
    if (pszColorBuff)
    {
        VALIDATE_WRITE_PTR(ApiHelper, pszColorBuff, sizeof(WCHAR)*cchMaxColorChars);
    }
    if (pszSizeBuff)
    {
        VALIDATE_WRITE_PTR(ApiHelper, pszSizeBuff, sizeof(WCHAR)*cchMaxSizeChars);
    }

    HRESULT hr;
    CUxThemeFile *pThemeFile = NULL;

    //---- get a shared CUxThemeFile object ----
    hr = g_pAppInfo->OpenWindowThemeFile(NULL, &pThemeFile);
    if (FAILED(hr))
        goto exit;

    //---- get info about current theme ----
    hr = GetThemeNameId(pThemeFile, pszNameBuff, cchMaxNameChars, pszColorBuff, cchMaxColorChars,
        pszSizeBuff, cchMaxSizeChars, NULL, NULL);

exit:
    if (pThemeFile)
        g_pAppInfo->CloseThemeFile(pThemeFile);

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI OpenThemeFile(LPCWSTR pszThemeName, OPTIONAL LPCWSTR pszColorParam,
   OPTIONAL LPCWSTR pszSizeParam, OUT HTHEMEFILE *phThemeFile, BOOL fGlobalTheme)
{
    HRESULT hr = S_OK;
    APIHELPER(L"OpenThemeFile", NULL);

    VALIDATE_INPUT_STRING(ApiHelper, pszThemeName, MAX_FILENAMEPARAM);

    if (pszColorParam)
    {
        VALIDATE_INPUT_STRING(ApiHelper, pszColorParam, MAX_THEMEAPI_STRINGPARAM);
    }

    if (pszSizeParam)
    {
        VALIDATE_INPUT_STRING(ApiHelper, pszSizeParam, MAX_THEMEAPI_STRINGPARAM);
    }

    VALIDATE_WRITE_PTR(ApiHelper, phThemeFile, sizeof(HTHEMEFILE));

    //  TCB (trusted computing base) privilege is required to create a 
    //  global theme section.
    if( fGlobalTheme == FALSE || TokenHasPrivilege( NULL, SE_TCB_PRIVILEGE ) )
    {
        HANDLE handle;
        hr = CThemeServices::LoadTheme(&handle, pszThemeName, pszColorParam, pszSizeParam, 
            fGlobalTheme);
        if (FAILED(hr))
            goto exit;
    
        //---- convert from Memory Mapped File handle to a CUxThemeFile ptr ----
        CUxThemeFile *pThemeFile;
  
        //---- set new file ----
        hr = g_pAppInfo->OpenThemeFile(handle, &pThemeFile);
        if (SUCCEEDED(hr))
        {
            *phThemeFile = (HTHEMEFILE *)pThemeFile; 
        }
        else
        {
            // We don't have a CUxThemeFile, have to clear ourselves
            ClearTheme(handle);
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI ApplyTheme(OPTIONAL HTHEMEFILE hThemeFile, DWORD dwApplyFlags,
    OPTIONAL HWND hwndTarget)
{
    APIHELPER(L"ApplyTheme", NULL);

    HRESULT hr = S_OK;

    if (hThemeFile)
    {
        VALIDATE_READ_PTR(ApiHelper, hThemeFile, sizeof(HTHEMEFILE));
    }

    if (hwndTarget)
    {
        VALIDATE_HWND(ApiHelper, hwndTarget);
    }

    CUxThemeFile *pThemeFile = (CUxThemeFile *)hThemeFile;

    //----- set preview info, if targeted at a window ----
    if (hwndTarget)
        g_pAppInfo->SetPreviewThemeFile(pThemeFile->Handle(), hwndTarget);

    hr = CThemeServices::ApplyTheme(pThemeFile, dwApplyFlags, hwndTarget);

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI CloseThemeFile(HTHEMEFILE hThemeFile)
{
    APIHELPER(L"CloseThemeFile", NULL);

    if (hThemeFile)
    {
        VALIDATE_READ_PTR(ApiHelper, hThemeFile, sizeof(HTHEMEFILE));
    }

    CUxThemeFile *pThemeFile = (CUxThemeFile *)hThemeFile;
    if (pThemeFile)
    {
        VALIDATE_READ_PTR(ApiHelper, pThemeFile, sizeof(CUxThemeFile));

        g_pAppInfo->CloseThemeFile(pThemeFile);
    }
    
    return S_OK;
}

//---------------------------------------------------------------------------
THEMEAPI SetSystemVisualStyle(
    LPCWSTR pszVisualStyleFile, 
    OPTIONAL LPCWSTR pszColorParam,
    OPTIONAL LPCWSTR pszSizeParam, 
    DWORD dwFlags )
{
    APIHELPER(L"SetSystemVisualStyle", NULL);

    HRESULT hr = E_INVALIDARG;

    if( pszVisualStyleFile )
    {
        VALIDATE_INPUT_STRING(ApiHelper, pszVisualStyleFile, MAX_FILENAMEPARAM);

        if (pszColorParam)
        {
            VALIDATE_INPUT_STRING(ApiHelper, pszColorParam, MAX_THEMEAPI_STRINGPARAM);
        }

        if (pszSizeParam)
        {
            VALIDATE_INPUT_STRING(ApiHelper, pszSizeParam, MAX_THEMEAPI_STRINGPARAM);
        }

        HANDLE  hSection;
        hr = CThemeServices::ProcessLoadGlobalTheme(pszVisualStyleFile, pszColorParam, pszSizeParam, &hSection);

        if( FAILED(hr) )
        {
            ASSERT(hSection == NULL); // the service is up to no good.
        }

        if( SUCCEEDED(hr) )
        {
            //---- convert from Memory Mapped File handle to a CUxThemeFile ptr ----
            CUxThemeFile *pThemeFile;
  
            //---- set new file ----
            hr = g_pAppInfo->OpenThemeFile(hSection, &pThemeFile);
            if (SUCCEEDED(hr))
            {
                hr = CThemeServices::ApplyTheme(pThemeFile, dwFlags, NULL);

                g_pAppInfo->CloseThemeFile(pThemeFile);
            }
            else
            {
                // We don't have a CUxThemeFile, have to clear ourselves
                ClearTheme(hSection);
            }
        }
    }
    else
    {
        hr = CThemeServices::ApplyTheme(NULL, dwFlags, NULL);
    }

    return hr;
}

//---------------------------------------------------------------------------
THEMEAPI EnumThemes(LPCWSTR pszThemeRoot, THEMEENUMPROC lpEnumFunc, LPARAM lParam)
{
    APIHELPER(L"EnumThemes", NULL);

    VALIDATE_INPUT_STRING(ApiHelper, pszThemeRoot, MAX_FILENAMEPARAM);
    VALIDATE_CALLBACK(ApiHelper, lpEnumFunc);

    HRESULT hr;
    HANDLE hFile = NULL;
    if (! lpEnumFunc)
        hr = MakeError32(E_INVALIDARG);
    else
    {
        WCHAR szSearchPath[MAX_PATH+1];
        WCHAR szFileName[MAX_PATH+1];
        WCHAR szDisplayName[MAX_PATH+1];
        WCHAR szToolTip[MAX_PATH+1];

        StringCchPrintfW(szSearchPath, ARRAYSIZE(szSearchPath), L"%s\\*.*", pszThemeRoot);

        //---- first find all child directories containing a *.msstyles files ----
        BOOL   bFile = TRUE;
        WIN32_FIND_DATA wfd;
        hr = S_FALSE;       // assume interrupted until we complete

        bool bRemote = GetSystemMetrics(SM_REMOTESESSION) ? true : false;

        DWORD dwCurMinDepth = 0;
            
        if (bRemote)
        {
            dwCurMinDepth = MinimumDisplayColorDepth();
        }

        for( hFile = FindFirstFile( szSearchPath, &wfd ); hFile != INVALID_HANDLE_VALUE && bFile;
             bFile = FindNextFile( hFile, &wfd ) )
        {
            if(! ( wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ))
                continue;

            if ((lstrcmp(wfd.cFileName, TEXT("."))==0) || (lstrcmp(wfd.cFileName, TEXT(".."))==0))
                continue;

            StringCchPrintfW(szFileName, ARRAYSIZE(szFileName), L"%s\\%s\\%s.msstyles", pszThemeRoot, wfd.cFileName, wfd.cFileName);

            //---- ensure its signed by ms ----
            hr = CThemeServices::CheckThemeSignature(szFileName);
            if (FAILED(hr))
                continue;

            //---- ensure its loadable & has a supported version ----
            HINSTANCE hInst;
            hr = LoadThemeLibrary(szFileName, &hInst);
            if (FAILED(hr))
                continue;

            int iBaseNum = RES_BASENUM_DOCPROPERTIES - TMT_FIRST_RCSTRING_NAME;

            //---- get DisplayName ----
            if (! LoadString(hInst, iBaseNum + TMT_DISPLAYNAME, szDisplayName, ARRAYSIZE(szDisplayName)))
                *szDisplayName = 0;

            //---- get ToolTip ----
            if (! LoadString(hInst, iBaseNum + TMT_TOOLTIP, szToolTip, ARRAYSIZE(szToolTip)))
                *szToolTip = 0;

            //---- see if one class file supports this color depth
            bool bMatch = true;
            
            // Check on remote sessions only (the console can be in 8-bit mode)
            if (bRemote)
            {
                bMatch = CheckMinColorDepth(hInst, dwCurMinDepth);
            }

            //---- free the lib ----
            FreeLibrary(hInst);

            if (bMatch)
            {
                //---- its a good one - call the callback ----
                BOOL fContinue = (*lpEnumFunc)(TCB_THEMENAME, szFileName, szDisplayName, 
                    szToolTip, 0, lParam);        // call the callback
    
                if (! fContinue)
                    goto exit;
            }
        }

        hr = S_OK;      // completed
    }

exit:
    if (hFile)
        FindClose(hFile);

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI EnumThemeSizes(LPCWSTR pszThemeName, 
    OPTIONAL LPCWSTR pszColorScheme, DWORD dwSizeIndex, OUT THEMENAMEINFO *ptn)
{
    APIHELPER(L"EnumThemeSizes", NULL);

    VALIDATE_INPUT_STRING(ApiHelper, pszThemeName, MAX_FILENAMEPARAM);
    
    if (pszColorScheme)
    {
        VALIDATE_INPUT_STRING(ApiHelper, pszColorScheme, MAX_THEMEAPI_STRINGPARAM);
    }

    VALIDATE_WRITE_PTR(ApiHelper, ptn, sizeof(THEMENAMEINFO));

    HINSTANCE hInst = NULL;
    HRESULT hr = LoadThemeLibrary(pszThemeName, &hInst);

    if (SUCCEEDED(hr))
    {
        hr = _EnumThemeSizes(hInst, pszThemeName, pszColorScheme, dwSizeIndex, ptn, (BOOL) GetSystemMetrics(SM_REMOTESESSION));
        FreeLibrary(hInst);
    }

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI EnumThemeColors(LPCWSTR pszThemeName, 
    OPTIONAL LPCWSTR pszSizeName, DWORD dwColorIndex, OUT THEMENAMEINFO *ptn)
{
    APIHELPER(L"EnumThemeColors", NULL);

    VALIDATE_INPUT_STRING(ApiHelper, pszThemeName, MAX_FILENAMEPARAM);
    if (pszSizeName)
    {
        VALIDATE_INPUT_STRING(ApiHelper, pszSizeName, MAX_THEMEAPI_STRINGPARAM);
    }

    VALIDATE_WRITE_PTR(ApiHelper, ptn, sizeof(THEMENAMEINFO));

    HINSTANCE hInst = NULL;
    HRESULT hr = LoadThemeLibrary(pszThemeName, &hInst);

    if (SUCCEEDED(hr))
    {
        hr = _EnumThemeColors(hInst, pszThemeName, pszSizeName, dwColorIndex, ptn, (BOOL) GetSystemMetrics(SM_REMOTESESSION));
        FreeLibrary(hInst);
    }

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI DrawThemeEdge(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, 
                       const RECT *pDestRect, UINT uEdge, UINT uFlags, OUT RECT *pContentRect)
{
    APIHELPER(L"DrawThemeEdge", hTheme);

    VALIDATE_HDC(ApiHelper, hdc);
    VALIDATE_READ_PTR(ApiHelper, pDestRect, sizeof(RECT));
    if (pContentRect)
    {
        VALIDATE_WRITE_PTR(ApiHelper, pContentRect, sizeof(RECT));
    }

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CTextDraw *pTextObj;

    HRESULT hr = pRender->GetTextObj(iPartId, iStateId, &pTextObj);
    if (SUCCEEDED(hr))
    {
        hr = pTextObj->DrawEdge(pRender, hdc, iPartId, iStateId, pDestRect, uEdge, uFlags, pContentRect);
    }

    return hr;
}

//---------------------------------------------------------------------------
THEMEAPI DrawThemeIcon(HTHEME hTheme, HDC hdc, int iPartId, 
    int iStateId, const RECT *pRect, HIMAGELIST himl, int iImageIndex)
{
    APIHELPER(L"DrawThemeIcon", hTheme);

    VALIDATE_HDC(ApiHelper, hdc);
    VALIDATE_READ_PTR(ApiHelper, pRect, sizeof(RECT));
    VALIDATE_HANDLE(ApiHelper, himl);

    IMAGELISTDRAWPARAMS params = {sizeof(params)};

    HRESULT hr = EnsureUxCtrlLoaded();
    if (FAILED(hr))
        goto exit;

    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    //---- build up the IMAGELISTDRAWPARAMS struct ----

    params.hdcDst = hdc;
    params.himl = himl;
    params.i = iImageIndex;
    params.x = pRect->left;
    params.y = pRect->top;
    params.cx = WIDTH(*pRect);
    params.cy = HEIGHT(*pRect);

    params.rgbBk = CLR_NONE;
    params.rgbFg = CLR_NONE;
    params.fStyle = ILD_TRANSPARENT;

    //---- get IconEffect ----
    ICONEFFECT effect;
    if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_ICONEFFECT, (int *)&effect)))
        effect = ICE_NONE;

    if (effect == ICE_GLOW)
    {
        params.fState = ILS_GLOW;

        //---- get GlowColor ----
        COLORREF glow;
        if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_GLOWCOLOR, &glow)))
            glow = RGB(0, 0, 255);

        params.crEffect = glow;
    }
    else if (effect == ICE_SHADOW)
    {
        params.fState = ILS_SHADOW;

        //---- get ShadowColor ----
        COLORREF shadow;
        if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_SHADOWCOLOR, &shadow)))
            shadow = RGB(0, 0, 0);

        params.crEffect = shadow;
    }
    else if (effect == ICE_PULSE)
    {
        params.fState = ILS_SATURATE;

        //---- get Saturation ----
        int saturate;
        if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_SATURATION, &saturate)))
            saturate = 128;          // 50% of 255

        params.Frame = saturate;
    }
    else if (effect == ICE_ALPHA)
    {
        params.fState = ILS_ALPHA;

        //---- get AlphaLevel ----
        int alpha;
        if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_ALPHALEVEL, &alpha)))
            alpha = 128;        // 50% of 255
        
        params.Frame = alpha;
    }

    if (! (*ImageList_DrawProc)(&params))
        hr = MakeError32(E_FAIL);      // no other error info available

exit:
    return hr;
}

//---------------------------------------------------------------------------
THEMEAPI GetThemeDefaults(LPCWSTR pszThemeName, 
    OUT OPTIONAL LPWSTR pszDefaultColor, int cchMaxColorChars, 
    OUT OPTIONAL LPWSTR pszDefaultSize, int cchMaxSizeChars)
{
    APIHELPER(L"GetThemeDefaults", NULL);

    VALIDATE_INPUT_STRING(ApiHelper, pszThemeName, MAX_FILENAMEPARAM);
    if (pszDefaultColor)
    {
        VALIDATE_WRITE_PTR(ApiHelper, pszDefaultColor, sizeof(WCHAR) * cchMaxColorChars);
    }
    if (pszDefaultSize)
    {
        VALIDATE_WRITE_PTR(ApiHelper, pszDefaultSize, sizeof(WCHAR) * cchMaxSizeChars);
    }

    HRESULT hr;
    HINSTANCE hInst = NULL;
    hr = LoadThemeLibrary(pszThemeName, &hInst);
    if (FAILED(hr))
        goto exit;

    if (pszDefaultColor)
    {
        hr = GetResString(hInst, L"COLORNAMES", 0, pszDefaultColor, cchMaxColorChars);
        if (FAILED(hr))
            goto exit;
    } 

    if (pszDefaultSize)
    {
        hr = GetResString(hInst, L"SIZENAMES", 0, pszDefaultSize, cchMaxSizeChars);
        if (FAILED(hr))
            goto exit;
    }

exit:
    FreeLibrary(hInst);

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI GetThemeDocumentationProperty(LPCWSTR pszThemeName,
    LPCWSTR pszPropertyName, OUT LPWSTR pszValueBuff, int cchMaxValChars)
{
    APIHELPER(L"GetThemeDocumentationProperty", NULL);

    VALIDATE_INPUT_STRING(ApiHelper, pszThemeName, MAX_FILENAMEPARAM);
    VALIDATE_INPUT_STRING(ApiHelper, pszPropertyName, MAX_THEMEAPI_STRINGPARAM);
    VALIDATE_WRITE_PTR(ApiHelper, pszValueBuff, sizeof(WCHAR)*cchMaxValChars);

    HRESULT hr;
    CThemeParser *pParser = NULL;

    HINSTANCE hInst = NULL;
    hr = LoadThemeLibrary(pszThemeName, &hInst);
    if (FAILED(hr))
        goto exit;

    pParser = new CThemeParser;
    if (! pParser)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }

    //---- is this a recognized (localized) property name? ----
    int iPropNum;
    hr = pParser->GetPropertyNum(pszPropertyName, &iPropNum);
    if (SUCCEEDED(hr))
    {
        //---- try to read from string table of recognized [documentation] properties ----
        if (LoadString(hInst, iPropNum+RES_BASENUM_DOCPROPERTIES, pszValueBuff, cchMaxValChars))
            goto exit;
    }

    //---- load the themes.ini text into memory ----
    LPWSTR pThemesIni;
    hr = AllocateTextResource(hInst, CONTAINER_RESNAME, &pThemesIni);
    if (FAILED(hr))
        goto exit;

    hr = pParser->ParseThemeBuffer(pThemesIni, NULL, NULL, NULL, NULL, NULL, NULL, 
        PTF_QUERY_DOCPROPERTY | PTF_CONTAINER_PARSE, pszPropertyName, pszValueBuff, cchMaxValChars);

exit:

    if (pParser)
        delete pParser;

    FreeLibrary(hInst);

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI GetThemeSysFont96(HTHEME hTheme, int iFontId, OUT LOGFONT *plf)
{
    APIHELPER(L"GetThemeSysFont96", hTheme);

    CRenderObj *pRender = NULL;
    HRESULT hr = S_OK;

    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    VALIDATE_WRITE_PTR(ApiHelper, plf, sizeof(LOGFONT)); 

    //---- check font index limits ----
    if ((iFontId < TMT_FIRSTFONT) || (iFontId > TMT_LASTFONT))
    {
        hr = MakeError32(E_INVALIDARG);
        goto exit;
    }

    //---- return unscaled value ----
    *plf = pRender->_ptm->lfFonts[iFontId - TMT_FIRSTFONT];

exit:
    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI GetThemeSysFont(OPTIONAL HTHEME hTheme, int iFontId, OUT LOGFONT *plf)
{
    APIHELPER(L"GetThemeSysFont", hTheme);

    CRenderObj *pRender = NULL;
    if (hTheme)
    {
        VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);
    }

    VALIDATE_WRITE_PTR(ApiHelper, plf, sizeof(LOGFONT)); 

    //---- check font index limits ----
    HRESULT hr = S_OK;

    if ((iFontId < TMT_FIRSTFONT) || (iFontId > TMT_LASTFONT))
    {
        hr = MakeError32(E_INVALIDARG);
        goto exit;
    }

    if (pRender)            // get theme value
    {
        *plf = pRender->_ptm->lfFonts[iFontId - TMT_FIRSTFONT];

        //---- convert to current screen dpi ----
        ScaleFontForScreenDpi(plf);
    }
    else                    // get system value
    {
        if (iFontId == TMT_ICONTITLEFONT)
        {
            BOOL fGet = ClassicSystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), plf, 0);
            if (! fGet)
            {
                Log(LOG_ERROR, L"Error returned from ClassicSystemParametersInfo(SPI_GETICONTITLELOGFONT)");
                hr = MakeErrorLast();
                goto exit;
            }
        }
        else
        {
            NONCLIENTMETRICS ncm = {sizeof(ncm)};
            BOOL fGet = ClassicSystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);
            if (! fGet)
            {
                Log(LOG_ERROR, L"Error returned from ClassicSystemParametersInfo(SPI_GETNONCLIENTMETRICS)");
                hr = MakeErrorLast();
                goto exit;
            }
        
            switch (iFontId)
            {
                case TMT_CAPTIONFONT:
                    *plf = ncm.lfCaptionFont;
                    break;

                case TMT_SMALLCAPTIONFONT:
                    *plf = ncm.lfSmCaptionFont;
                    break;

                case TMT_MENUFONT:
                    *plf = ncm.lfMenuFont;
                    break;

                case TMT_STATUSFONT:
                    *plf = ncm.lfStatusFont;
                    break;

                case TMT_MSGBOXFONT:
                    *plf = ncm.lfMessageFont;
                    break;

            }
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI GetThemeSysString(HTHEME hTheme, int iStringId, 
    OUT LPWSTR pszStringBuff, int cchStringBuff)
{
    APIHELPER(L"GetThemeSysString", hTheme);

    CRenderObj *pRender = NULL;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    VALIDATE_WRITE_PTR(ApiHelper, pszStringBuff, sizeof(WCHAR)*cchStringBuff); 

    HRESULT hr;

    //---- check string index limits ----
    if ((iStringId < TMT_FIRSTSTRING) || (iStringId > TMT_LASTSTRING))
    {
        hr = MakeError32(E_INVALIDARG);
        goto exit;
    }

    LPCWSTR p;
    p = ThemeString(pRender->_pThemeFile, pRender->_ptm->iStringOffsets[iStringId - TMT_FIRSTSTRING]);

    hr = SafeStringCchCopyW(pszStringBuff, cchStringBuff, p );
    if (FAILED(hr))
        goto exit;

    hr = S_OK;

exit:
    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI GetThemeSysInt(HTHEME hTheme, int iIntId, int *piValue)
{
    APIHELPER(L"GetThemeSysInt", hTheme);

    CRenderObj *pRender = NULL;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    VALIDATE_WRITE_PTR(ApiHelper, piValue, sizeof(int)); 

    HRESULT hr;

    //---- check int index limits ----
    if ((iIntId < TMT_FIRSTINT) || (iIntId > TMT_LASTINT))
    {
        hr = MakeError32(E_INVALIDARG);
        goto exit;
    }

    *piValue = pRender->_ptm->iInts[iIntId - TMT_FIRSTINT];
    hr = S_OK;

exit:
    return hr;
}
//---------------------------------------------------------------------------
#define THEME_FORCE_VERSION     103     // increment this when you want to force
                                        // new theme settings
//---------------------------------------------------------------------------
THEMEAPI RegisterDefaultTheme(LPCWSTR pszFileName, BOOL fOverride)
{
    APIHELPER(L"RegisterDefaultTheme", NULL);

    RESOURCE HKEY tmkey = NULL;
    HRESULT hr = S_OK;

    //---- Note: at install time, its not possible to access each ----
    //---- user's registry info (may be roaming on server) so ----
    //---- we put default theme under HKEY_LM.  Then, during ----
    //---- themeldr init for a user, we propagate the info ----
    //---- to the HKEY_CU root. ----

    //---- open LM + THEMEMGR key (create if needed) ----
    int code32 = RegCreateKeyEx(HKEY_LOCAL_MACHINE, THEMEMGR_REGKEY, NULL, NULL, 
        REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ, NULL, &tmkey, NULL);
    if (code32 != ERROR_SUCCESS)       
    {
        hr = MakeErrorLast();
        goto exit;
    }

    //---- read the value of "THEMEPROP_LMVERSION" ----
    int iValue;
    hr = RegistryIntRead(tmkey, THEMEPROP_LMVERSION, &iValue);
    if (FAILED(hr))     
        iValue = 0;

    //---- write the "THEMEPROP_LOADEDBEFORE" = "0" ----
    hr = RegistryIntWrite(tmkey, THEMEPROP_LOADEDBEFORE, 0);
    if (FAILED(hr))
        goto exit;

    if (iValue == THEME_FORCE_VERSION)     // matches - don't update anything
        goto exit;
    
    //---- write the NEW value of "THEMEPROP_LMVERSION" ----
    hr = RegistryIntWrite(tmkey, THEMEPROP_LMVERSION, THEME_FORCE_VERSION);
    if (FAILED(hr))
        goto exit;

    //---- write the value of "THEMEPROP_LMOVERRIDE" ----
    iValue = (fOverride != 0);
    hr = RegistryIntWrite(tmkey, THEMEPROP_LMOVERRIDE, iValue);
    if (FAILED(hr))
        goto exit;

    //---- write the "THEMEPROP_THEMEACTIVE" = "1" ----
    hr = RegistryIntWrite(tmkey, THEMEPROP_THEMEACTIVE, 1);
    if (FAILED(hr))
        goto exit;

    //---- write "DllName=xxxx" string/value ----
    hr =  RegistryStrWriteExpand(tmkey, THEMEPROP_DLLNAME, pszFileName);
    if (FAILED(hr))
        goto exit;

exit:
    if (tmkey)
        RegCloseKey(tmkey);

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI DumpLoadedThemeToTextFile(HTHEMEFILE hThemeFile, LPCWSTR pszTextFile, 
    BOOL fPacked, BOOL fFullInfo)
{
    APIHELPER(L"DumpLoadedThemeToTextFile", NULL);

    VALIDATE_READ_PTR(ApiHelper, hThemeFile, sizeof(HTHEMEFILE));
    VALIDATE_INPUT_STRING(ApiHelper, pszTextFile, MAX_FILENAMEPARAM);

    CUxThemeFile *pThemeFile = (CUxThemeFile *)hThemeFile;

    return DumpThemeFile(pszTextFile, pThemeFile, fPacked, fFullInfo);
}
//---------------------------------------------------------------------------
THEMEAPI GetThemeParseErrorInfo(OUT PARSE_ERROR_INFO *pInfo)
{
    APIHELPER(L"GetThemeParseErrorInfo", NULL);

    VALIDATE_WRITE_PTR(ApiHelper, pInfo, sizeof(*pInfo)); 

    return _GetThemeParseErrorInfo(pInfo);
}
//---------------------------------------------------------------------------
THEMEAPI ParseThemeIniFile(LPCWSTR pszFileName,  
    DWORD dwParseFlags, OPTIONAL THEMEENUMPROC pfnCallBack, OPTIONAL LPARAM lparam) 
{
    APIHELPER(L"ParseThemeIniFile", NULL);

    VALIDATE_INPUT_STRING(ApiHelper, pszFileName, MAX_FILENAMEPARAM);
    if (pfnCallBack)
    {
        VALIDATE_CALLBACK(ApiHelper, pfnCallBack);
    }

    return _ParseThemeIniFile(pszFileName, dwParseFlags, pfnCallBack, lparam);
}
//---------------------------------------------------------------------------
THEMEAPI OpenThemeFileFromData(HTHEME hTheme, HTHEMEFILE *phThemeFile)
{
    APIHELPER(L"OpenThemeFileFromData", hTheme);

    CRenderObj *pRender = NULL;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    VALIDATE_WRITE_PTR(ApiHelper, phThemeFile, sizeof(HTHEMEFILE));

    return _OpenThemeFileFromData(pRender, phThemeFile);
}
//---------------------------------------------------------------------------
THEMEAPI DrawThemeParentBackground(HWND hwnd, HDC hdc, OPTIONAL RECT* prc)
{
    APIHELPER(L"DrawThemeParentBackground", NULL);

    //---- param validation ----
    VALIDATE_HWND(ApiHelper, hwnd);
    
    VALIDATE_HDC(ApiHelper, hdc);
    
    if (prc)
    {
        VALIDATE_READ_PTR(ApiHelper, prc, sizeof(RECT)); 
    }

    // INVESTIGATE: There is a possible sync problem. If we have a window
    // parented to a window in another thread, then the property stuff may get out of
    // sync between the threads. If this is an issue, then we may have to leave the
    // property on the window instead of removing it when we're done.
    RECT rc; 
    POINT pt;
    CSaveClipRegion csrPrevClip;
    HRESULT hr = S_OK;
    HWND hwndParent = GetParent(hwnd);
    ATOM aIsPrinting = GetThemeAtom(THEMEATOM_PRINTING);

    if (prc)
    {
        rc = *prc;
        hr = csrPrevClip.Save(hdc);      // save current clipping region
        if (FAILED(hr))
            goto exit;

        IntersectClipRect(hdc, prc->left, prc->top, prc->right, prc->bottom);
    }

    //---- get RECT of "hwnd" client area in parent coordinates ----
    GetClientRect(hwnd, &rc);
    MapWindowPoints(hwnd, hwndParent, (POINT*)&rc, 2);

    // Set a property saying "We want to see if this window handles WM_PRINTCLIENT. i.e. if it passes 
    // it to DefWindowProc it didn't handle it.
    SetProp(hwndParent, (PCTSTR)aIsPrinting, (HANDLE)PRINTING_ASKING);

    // Setup the viewport so that it is aligned with the parents.
    GetViewportOrgEx(hdc, &pt);
    SetViewportOrgEx(hdc, pt.x - rc.left, pt.y - rc.top, &pt);
    SendMessage(hwndParent, WM_ERASEBKGND, (WPARAM)hdc, (LPARAM)0);
    SendMessage(hwndParent, WM_PRINTCLIENT, (WPARAM)hdc, (LPARAM)PRF_CLIENT);
    SetViewportOrgEx(hdc, pt.x, pt.y, NULL);

    // See if the window handled the print. If this is set to PRINTING_WINDOWDIDNOTHANDLE, 
    // it means they did not handle it (i.e. it was passed to DefWindowProc)
    if (PtrToUlong(GetProp(hwndParent, (PCTSTR)aIsPrinting)) == PRINTING_WINDOWDIDNOTHANDLE)
    {
        hr = S_FALSE;
    }

exit:
    RemoveProp(hwndParent, (PCTSTR)aIsPrinting);
    csrPrevClip.Restore(hdc);      // restore current clipping region

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI EnableThemeDialogTexture(HWND hwnd, DWORD dwFlagsIn)
{
    APIHELPER(L"EnableThemeDialogTexture", NULL);
    HRESULT hr = S_OK;

    if (TESTFLAG(dwFlagsIn, ETDT_DISABLE))
    {
        RemoveProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_DLGTEXTURING)));
    }
    else
    {
        ULONG ulFlagsOut = HandleToUlong(GetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_DLGTEXTURING))));
        
        //  validate and add requested flags:
        ulFlagsOut |= (dwFlagsIn & (ETDT_ENABLE|ETDT_USETABTEXTURE));

        if (!SetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_DLGTEXTURING)), ULongToHandle(ulFlagsOut)))
        {
            DWORD dwErr = GetLastError();
            hr = (ERROR_SUCCESS == dwErr) ? E_FAIL : HRESULT_FROM_WIN32(dwErr);
        }
    }

    return hr;
}
//---------------------------------------------------------------------------
THEMEAPI RefreshThemeForTS()
{
    APIHELPER(L"RefreshThemeForTS", NULL);

    return CThemeServices::InitUserTheme();
}
//---------------------------------------------------------------------------
//---- put all non-HRESULT returning functions down at the bottom here ----
//---------------------------------------------------------------------------
#undef RETURN_VALIDATE_RETVAL
#define RETURN_VALIDATE_RETVAL(hr) { if (FAILED(hr)) { SET_LAST_ERROR(hr); return NULL; } }     // HANDLE functions
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) CreateThemeDataFromObjects(OPTIONAL CDrawBase *pDrawObj, 
    OPTIONAL CTextDraw *pTextObj, DWORD dwOtdFlags)
{
    APIHELPER(L"CreateThemeDataFromObjects", NULL);

    HTHEME hTheme = NULL;
    BOOL fGotOne = FALSE;
    HRESULT hr = S_OK;

    if (pDrawObj)
    {
        VALIDATE_READ_PTR(ApiHelper, pDrawObj, sizeof(pDrawObj->_eBgType));

        if (pDrawObj->_eBgType == BT_BORDERFILL)
        {
            VALIDATE_READ_PTR(ApiHelper, pDrawObj, sizeof(CBorderFill));
        }
        else if (pDrawObj->_eBgType == BT_IMAGEFILE)
        {
            VALIDATE_READ_PTR(ApiHelper, pDrawObj, sizeof(CImageFile));
        }
        else
            goto exit;      // unknown object type

        fGotOne = TRUE;
    }

    if (pTextObj)
    {
        VALIDATE_READ_PTR(ApiHelper, pTextObj, sizeof(CTextDraw));

        fGotOne = TRUE;
    }

    if (! fGotOne)
    {
        hr = MakeError32(E_POINTER);
        goto exit;
    }

    hr = g_pRenderList->OpenRenderObject(NULL, 0, 0, pDrawObj, pTextObj, NULL, dwOtdFlags,
        &hTheme);

    if (FAILED(hr))
    {
        hTheme = NULL;
    }

exit:
    SET_LAST_ERROR(hr);
    return hTheme;
}
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) OpenThemeData(OPTIONAL HWND hwnd, LPCWSTR pszClassIdList)
{
    APIHELPER(L"OpenThemeData", NULL);

    if (hwnd)
        VALIDATE_HWND(ApiHelper, hwnd);

    VALIDATE_INPUT_STRING(ApiHelper, pszClassIdList, MAX_THEMEAPI_STRINGPARAM);
    
    return _OpenThemeData(hwnd, pszClassIdList, 0);
}
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) OpenThemeDataEx(OPTIONAL HWND hwnd, LPCWSTR pszClassIdList, DWORD dwFlags)
{
    APIHELPER(L"OpenThemeDataEx", NULL);

    if (hwnd)
        VALIDATE_HWND(ApiHelper, hwnd);

    VALIDATE_INPUT_STRING(ApiHelper, pszClassIdList, MAX_THEMEAPI_STRINGPARAM);
    
    return _OpenThemeData(hwnd, pszClassIdList, dwFlags);
}
//-----------------------------------------------------------------------
THEMEAPI_(HTHEME) OpenNcThemeData(HWND hwnd, LPCWSTR pszClassIdList)
{
    APIHELPER(L"OpenNcThemeData", NULL);

    if (hwnd)
        VALIDATE_HWND(ApiHelper, hwnd);

    VALIDATE_INPUT_STRING(ApiHelper, pszClassIdList, MAX_THEMEAPI_STRINGPARAM);

    return _OpenThemeData(hwnd, pszClassIdList, OTD_NONCLIENT);
}
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) OpenThemeDataFromFile(HTHEMEFILE hLoadedThemeFile, 
    OPTIONAL HWND hwnd, OPTIONAL LPCWSTR pszClassList, BOOL fClient)
{
    APIHELPER(L"OpenThemeDataFromFile", NULL);

    VALIDATE_READ_PTR(ApiHelper, hLoadedThemeFile, sizeof(HTHEMEFILE));
    
    if (hwnd)
        VALIDATE_HWND(ApiHelper, hwnd);

    if (pszClassList)
    {
        VALIDATE_INPUT_STRING(ApiHelper, pszClassList, MAX_THEMEAPI_STRINGPARAM);
    }
    else
    {
        pszClassList = L"globals";
    }

    //---- caller holds a REFCOUNT on hLoadedThemeFile so we don't need to adjust it ----
    //---- for the call to _OpenThemeDataFromFile.  If it succeeds, CRenderObj will ----
    //---- add its own REFCOUNT.  If it fails, the REFCOUNT will be the orig REFCOUNT ----
    DWORD dwFlags = 0;

    if (! fClient)
    {
        dwFlags |= OTD_NONCLIENT;
    }

    return _OpenThemeDataFromFile(hLoadedThemeFile, hwnd, pszClassList, dwFlags);
}
//---------------------------------------------------------------------------
THEMEAPI EnableTheming(BOOL fEnable)
{
    APIHELPER(L"EnableTheming", NULL);
    
    return CThemeServices::AdjustTheme(fEnable);
}
//---------------------------------------------------------------------------
THEMEAPI_(HBRUSH) GetThemeSysColorBrush(OPTIONAL HTHEME hTheme, int iSysColorId)
{
    APIHELPER(L"GetThemeSysColorBrush", hTheme);
    HBRUSH hbr;

    CRenderObj *pRender = NULL;
    if (hTheme)
    {
        VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);
    }

    //---- keep orig & make our own version of ColorId ----
    int iThemeColorId = iSysColorId + TMT_FIRSTCOLOR;

    //---- check color index limits ----
    if ((iThemeColorId < TMT_FIRSTCOLOR) || (iThemeColorId > TMT_LASTCOLOR))
        iThemeColorId = TMT_FIRSTCOLOR;

    //---- make index 0-relative ----
    iThemeColorId -= TMT_FIRSTCOLOR;

    if (! pRender)
    {
        hbr = GetSysColorBrush(iSysColorId);
    }
    else
    {
        COLORREF cr = pRender->_ptm->crColors[iThemeColorId];
        hbr = CreateSolidBrush(cr);
    }

    return hbr;
}
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) GetWindowTheme(HWND hwnd)
{
    APIHELPER(L"GetWindowTheme", NULL);

    VALIDATE_HWND(ApiHelper, hwnd);
    
    return (HTHEME)GetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_HTHEME)));
}
//---------------------------------------------------------------------------
#undef RETURN_VALIDATE_RETVAL
#define RETURN_VALIDATE_RETVAL { if (FAILED(hr)) { SET_LAST_ERROR(hr); return FALSE; } }     // BOOL functions
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsThemeActive()
{
    APIHELPER(L"IsThemeActive", NULL);

    SetLastError(0);

    Log(LOG_TMLOAD, L"IsThemeActive(): start...");

    BOOL fThemeActive = g_pAppInfo->IsSystemThemeActive();

    Log(LOG_TMLOAD, L"IsThemeActive(): fThemeActive=%d", fThemeActive);

    return fThemeActive;
}
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsThemePartDefined(HTHEME hTheme, int iPartId, int iStateId)
{
    APIHELPER(L"IsThemePartDefined", hTheme);

    BOOL fDefined;
    
    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    SetLastError(0);

    fDefined = pRender->IsPartDefined(iPartId, iStateId);

    return fDefined;
}
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsThemeBackgroundPartiallyTransparent(HTHEME hTheme, int iPartId, int iStateId)
{
    APIHELPER(L"IsThemeBackgroundPartiallyTransparent", hTheme);

    BOOL fTrans = FALSE;
    HRESULT hr = S_OK;
    CRenderObj *pRender;
    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    CDrawBase *pDrawObj;
    
    hr = pRender->GetDrawObj(iPartId, iStateId, &pDrawObj);
    if (SUCCEEDED(hr))
    {
        if (pDrawObj->_eBgType == BT_BORDERFILL)
        {
            CBorderFill *pBorderFill = (CBorderFill *)pDrawObj;
            fTrans = pBorderFill->IsBackgroundPartiallyTransparent();
        }
        else        // imagefile
        {
            CImageFile *pImageFile = (CImageFile *)pDrawObj;
            fTrans = pImageFile->IsBackgroundPartiallyTransparent(iStateId);
        }
    }
    
    SET_LAST_ERROR(hr);
    return fTrans;
}
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsAppThemed()
{
    APIHELPER(L"IsAppThemed", NULL);

    SetLastError(0);
    return g_pAppInfo->AppIsThemed(); 
}
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsThemeDialogTextureEnabled(HWND hwnd)
{
    APIHELPER(L"IsThemeDialogTextureEnabled", NULL);

    SetLastError(0);
    INT_PTR iDialogTexture = (INT_PTR)GetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_DLGTEXTURING)));
    return iDialogTexture != 0; // If it's 1 or 2 then it's textured
}
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) GetThemeSysBool(OPTIONAL HTHEME hTheme, int iBoolId)
{
    APIHELPER(L"GetThemeSysBool", hTheme);
    BOOL fValue;

    CRenderObj *pRender = NULL;
    if (hTheme)
    {
        VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);
    }

    SetLastError(0);

    //---- check bool index limits ----
    if ((iBoolId < TMT_FIRSTBOOL) || (iBoolId > TMT_LASTBOOL))
    {
        fValue = FALSE;
        goto exit;
    }

    if (! pRender)
    {
        int iSpIndex;

        switch (iBoolId)
        {
            case TMT_FLATMENUS:
                iSpIndex = SPI_GETFLATMENU;
                break;

            default:
                Log(LOG_PARAMS, L"Unsupported system BOOL");
                fValue = FALSE;           // failed
                goto exit;
        }

        BOOL fGet = ClassicSystemParametersInfo(iSpIndex, 0, &fValue, 0);
        if (! fGet)
        {
            Log(LOG_ERROR, L"Error returned from ClassicSystemParametersInfo() getting a BOOL");
            fValue = FALSE;
        }

        goto exit;
    }

    fValue = pRender->_ptm->fBools[iBoolId - TMT_FIRSTBOOL];

exit:
    return fValue;
}
//---------------------------------------------------------------------------
#undef RETURN_VALIDATE_RETVAL
#define RETURN_VALIDATE_RETVAL { if (FAILED(hr)) { SET_LAST_ERROR(hr); return 0; } }     // value functions
//---------------------------------------------------------------------------
THEMEAPI_(DWORD) QueryThemeServices()
{
    APIHELPER(L"QueryThemeServices", NULL);

    DWORD dwBits;
    HRESULT hr = CThemeServices::GetStatusFlags(&dwBits);
    if (FAILED(hr))
        dwBits = 0;

    SET_LAST_ERROR(hr);
    return dwBits;
}
//---------------------------------------------------------------------------
THEMEAPI_(COLORREF) GetThemeSysColor(OPTIONAL HTHEME hTheme, int iSysColorId)
{
    APIHELPER(L"GetThemeSysColor", hTheme);

    COLORREF crValue;
    CRenderObj *pRender = NULL;

    if (hTheme)
    {
        VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);
    }

    SetLastError(0);

    //---- keep orig & make our own version of ColorId ----
    int iThemeColorId = iSysColorId + TMT_FIRSTCOLOR;

    if ((iThemeColorId < TMT_FIRSTCOLOR) || (iThemeColorId > TMT_LASTCOLOR))
        iThemeColorId = TMT_FIRSTCOLOR;

    //---- make index 0-relative ----
    iThemeColorId -= TMT_FIRSTCOLOR;

    if (! pRender)
    {
        crValue = GetSysColor(iSysColorId);
    }
    else
    {
        crValue = pRender->_ptm->crColors[iThemeColorId];
    }

    return crValue;
}
//---------------------------------------------------------------------------
THEMEAPI_(int) GetThemeSysSize96(HTHEME hTheme, int iSizeId)
{
    APIHELPER(L"GetThemeSysSize96", hTheme);

    SetLastError(0);

    CRenderObj *pRender = NULL;
    int iThemeSizeNum;
    int iValue = 0;

    VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);

    HRESULT hr = GetThemeSizeId(iSizeId, &iThemeSizeNum);
    if (SUCCEEDED(hr))
    {
        //---- unscaled value ----
        iValue = pRender->_ptm->iSizes[iThemeSizeNum - TMT_FIRSTSIZE];
    }
    else
    {
        SET_LAST_ERROR(MakeError32(E_INVALIDARG));
    }

    return iValue;
}
//---------------------------------------------------------------------------
THEMEAPI_(int) GetThemeSysSize(OPTIONAL HTHEME hTheme, int iSysSizeNum)
{
    APIHELPER(L"GetThemeSysSize", hTheme);

    SetLastError(0);

    CRenderObj *pRender = NULL;
    int iThemeSizeNum;
    int iValue = 0;

    if (hTheme)
    {
        VALIDATE_THEME_HANDLE(ApiHelper, hTheme, &pRender);
    }

    HRESULT hr = S_OK;
    
    if (pRender)
    {
        hr = GetThemeSizeId(iSysSizeNum, &iThemeSizeNum);
        if (SUCCEEDED(hr))
        {
            iValue = pRender->_ptm->iSizes[iThemeSizeNum - TMT_FIRSTSIZE];

            //---- scale from 96 dpi to current screen dpi ----
            iValue = ScaleSizeForScreenDpi(iValue);
        }
        else
        {
            SET_LAST_ERROR(hr);
        }
    }
    else
    {
        iValue = ClassicGetSystemMetrics(iSysSizeNum);
    }

    return iValue;
}
//---------------------------------------------------------------------------
THEMEAPI_(DWORD) GetThemeAppProperties()
{
    APIHELPER(L"GetThemeAppProperties", NULL);

    SetLastError(0);

    return g_pAppInfo->GetAppFlags();
}
//---------------------------------------------------------------------------
#undef RETURN_VALIDATE_RETVAL
#define RETURN_VALIDATE_RETVAL { if (FAILED(hr)) { SET_LAST_ERROR(hr); return; } }     // null functions
//---------------------------------------------------------------------------
THEMEAPI_(void) SetThemeAppProperties(DWORD dwFlags)
{
    APIHELPER(L"SetThemeAppProperties", NULL);

    SetLastError(0);

    g_pAppInfo->SetAppFlags(dwFlags);
}
//---------------------------------------------------------------------------
//  --------------------------------------------------------------------------
//  ::CheckThemeSignature
//
//  Returns:    HRESULT
//
//  Purpose:    Pass thru function.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  CheckThemeSignature (LPCWSTR pszName)

{
    return CheckThemeFileSignature(pszName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\cleaninf\parse.h ===
#ifndef _PARSE_H_
#define _PARSE_H_
#ifdef __cplusplus

#define CHAR_EOF    -1


class CParseFile
{
public:
    void    Parse(FILE * pfileSrc, FILE * pfileDest, DWORD dwFlags);
    
    CParseFile();
    ~CParseFile() {};
    
private:
    void    _ParseInf(void);
    void    _ParseHtml(void);
    void    _ParseJS(void);
    void    _ParseHtc(void);
    
    char    _ReadChar(DWORD dwFlags);
    char    _SniffChar(int ichAhead);
    BOOL    _IsTagEqual(LPSTR pszTag);
    BOOL    _IsEndTag(void);
    
    void    _WriteChar(char);
    void    _FlushWriteBuffer(void);
    
    void    _WriteTag(void);
    void    _SkipCommentTag(void);
    BOOL    _SkipComment(int * pcNestedComment);
    BOOL    _SkipWhitespace(BOOL bPreserveOneSpace = FALSE);
    void    _ParseInnerStyle(void);


    FILE *  _pfileSrc;
    FILE *  _pfileDest;
    
    char    _ch;
    int     _ichRead;
    int     _cchRead;
    int     _ichWrite;

    BITBOOL _bSkipWhitespace: 1;        // TRUE: skip whitespace

    BITBOOL _bFirstChar: 1;             // TRUE: current character is first one on a new line
    
    char    _szReadBuf[512];
    char    _szWriteBuf[512];
};


#endif // __cplusplus
#endif // _PARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\cleaninf\app.cpp ===
#include "priv.h"       

HINSTANCE g_hinst;

#define APP_VERSION         "Version 0.4"


// Don't link to shlwapi.dll so this is a stand-alone tool

/*----------------------------------------------------------
Purpose: If a path is contained in quotes then remove them.

*/
void
PathUnquoteSpaces(
    LPTSTR lpsz)
{
    int cch;

    cch = lstrlen(lpsz);

    // Are the first and last chars quotes?
    if (lpsz[0] == TEXT('"') && lpsz[cch-1] == TEXT('"'))
    {
        // Yep, remove them.
        lpsz[cch-1] = TEXT('\0');
        hmemcpy(lpsz, lpsz+1, (cch-1) * SIZEOF(TCHAR));
    }
}


#define CH_WHACK TEXT(FILENAME_SEPARATOR)

LPTSTR
PathFindExtension(
    LPCTSTR pszPath)
{
    LPCTSTR pszDot = NULL;

    if (pszPath)
    {
        for (; *pszPath; pszPath = CharNext(pszPath))
        {
            switch (*pszPath) {
            case TEXT('.'):
                pszDot = pszPath;         // remember the last dot
                break;
            case CH_WHACK:
            case TEXT(' '):         // extensions can't have spaces
                pszDot = NULL;       // forget last dot, it was in a directory
                break;
            }
        }
    }

    // if we found the extension, return ptr to the dot, else
    // ptr to end of the string (NULL extension) (cast->non const)
    return pszDot ? (LPTSTR)pszDot : (LPTSTR)pszPath;
}



__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}


LPSTR FAR PASCAL StrChrA(LPCSTR lpStart, WORD wMatch)
{
    for ( ; *lpStart; lpStart = AnsiNext(lpStart))
    {
        if (!ChrCmpA_inline(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            return((LPSTR)lpStart);
    }
    return (NULL);
}

BOOL
StrTrim(
    IN OUT LPSTR  pszTrimMe,
    IN     LPCSTR pszTrimChars)
    {
    BOOL bRet = FALSE;
    LPSTR psz;
    LPSTR pszStartMeat;
    LPSTR pszMark = NULL;

    ASSERT(IS_VALID_STRING_PTRA(pszTrimMe, -1));
    ASSERT(IS_VALID_STRING_PTRA(pszTrimChars, -1));

    if (pszTrimMe)
    {
        /* Trim leading characters. */

        psz = pszTrimMe;

        while (*psz && StrChrA(pszTrimChars, *psz))
            psz = CharNextA(psz);

        pszStartMeat = psz;

        /* Trim trailing characters. */

        // (The old algorithm used to start from the end and go
        // backwards, but that is piggy because DBCS version of
        // CharPrev iterates from the beginning of the string
        // on every call.)

        while (*psz)
            {
            if (StrChrA(pszTrimChars, *psz))
                {
                pszMark = psz;
                }
            else
                {
                pszMark = NULL;
                }
            psz = CharNextA(psz);
            }

        // Any trailing characters to clip?
        if (pszMark)
            {
            // Yes
            *pszMark = '\0';
            bRet = TRUE;
            }

        /* Relocate stripped string. */

        if (pszStartMeat > pszTrimMe)
        {
            /* (+ 1) for null terminator. */
            MoveMemory(pszTrimMe, pszStartMeat, CbFromCchA(lstrlenA(pszStartMeat) + 1));
            bRet = TRUE;
        }
        else
            ASSERT(pszStartMeat == pszTrimMe);

        ASSERT(IS_VALID_STRING_PTRA(pszTrimMe, -1));
    }

    return bRet;
    }



void PrintSyntax(void)
{
    fprintf(stderr, "cleaninf.exe  " APP_VERSION "\n\n"
                    "Cleans up an inf, html, or script file for public distribution or for packing\n"
                    "into a resource.  Without any options, this removes all comments.  This\n"
                    "tool recognizes .inf, .htm, .hta, .js and .htc files by default.\n\n"
                    "Syntax:  cleaninf [-w] [-inf | -htm | -js | -htc] sourceFile destFile\n\n"
                    "          -w     Strip whitespace\n\n"
                    "         These flags are mutually exclusive, and will treat the file\n"
                    "         accordingly, regardless of extension:\n"
                    "          -inf   Treat file as a .inf file\n"
                    "          -htm   Treat file as a .htm file\n"
                    "          -js    Treat file as a .js file\n"
                    "          -htc   Treat file as a .htc file\n");
}    


/*----------------------------------------------------------
Purpose: Worker function to do the work

*/
int
DoWork(int cArgs, char * rgszArgs[])
{
    LPSTR psz;
    LPSTR pszSrc = NULL;
    LPSTR pszDest = NULL;
    DWORD dwFlags = 0;
    int i;
    int nRet = 0;

    // (The first arg is actually the exe.  Skip that.)

    for (i = 1; i < cArgs; i++)
    {
        psz = rgszArgs[i];

        // Check for options
        if ('/' == *psz || '-' == *psz)
        {
            psz++;
            switch (*psz)
            {
            case '?':
                // Help
                PrintSyntax();
                return 0;

            case 'w':
                dwFlags |= PFF_WHITESPACE;
                break;

            default:
                if (0 == strncmp(psz, "inf", 3))
                {
                    dwFlags |= PFF_INF;
                }
                else if (0 == strncmp(psz, "htm", 3))
                {
                    dwFlags |= PFF_HTML;
                }
                else if (0 == strncmp(psz, "js", 2))
                {
                    dwFlags |= PFF_JS;
                }
                else if (0 == strncmp(psz, "htc", 3))
                {
                    dwFlags |= PFF_HTC;
                }
                else
                {
                    // unknown
                    fprintf(stderr, "Invalid option -%c\n", *psz);
                    return -1;
                }
                break;
            }
        }
        else if (!pszSrc)
            pszSrc = rgszArgs[i];
        else if (!pszDest)
            pszDest = rgszArgs[i];
        else
        {
            fprintf(stderr, "Ignoring invalid parameter - %s\n", rgszArgs[i]);
        }
    }

    if (!pszSrc || !pszDest)
    {
        PrintSyntax();
        return -2;
    }

    // Has the file type already been explicitly specified?
    if ( !(dwFlags & (PFF_INF | PFF_HTML | PFF_JS | PFF_HTC)) )
    {
        // No; determine it based on the extension
        LPTSTR pszExt = PathFindExtension(pszSrc);

        if (pszExt)
        {
            if (0 == lstrcmpi(pszExt, ".htm") || 0 == lstrcmpi(pszExt, ".hta"))
                dwFlags |= PFF_HTML;
            else if (0 == lstrcmpi(pszExt, ".js"))
                dwFlags |= PFF_JS;
            else if (0 == lstrcmpi(pszExt, ".htc"))
                dwFlags |= PFF_HTC;
        }
    }
    
    // Open the files
    PathUnquoteSpaces(pszSrc);
    PathUnquoteSpaces(pszDest);

    FILE * pfileSrc = fopen(pszSrc, "r");

    if (NULL == pfileSrc)
    {
        fprintf(stderr, "\"%s\" could not be opened", pszSrc);
        nRet = -3;
    }
    else
    {
        FILE * pfileDest = fopen(pszDest, "w");

        if (NULL == pfileDest)
        {
            fprintf(stderr, "\"%s\" could not be created", pszDest);
            nRet = -4;
        }
        else
        {
            CParseFile parsefile;

            parsefile.Parse(pfileSrc, pfileDest, dwFlags);
            
            fclose(pfileDest);
        }
        
        fclose(pfileSrc);
    }
    return nRet;
}


#ifdef UNIX

EXTERN_C
HINSTANCE MwMainwinInitLite(int argc, char *argv[], void* lParam);

EXTERN_C
HINSTANCE mainwin_init(int argc, char *argv[])
{
          return MwMainwinInitLite(argc, argv, NULL);
}

#endif

int __cdecl main(int argc, char * argv[])
{
    return DoWork(argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\cleaninf\resource.h ===
#define MENU_ABOUT          2
#define MENU_EXIT           4
#define MENU_OPEN           5
#define MENU_COPY           6
#define MENU_PASTE          7
#define MENU_CUT            8
#define MENU_NEW            10
#define MENU_SETSPLAT       11
#define MENU_CLEARSPLAT     12
#define MENU_DELETEDB       13

#define MENU_VIEW           100
#define MENU_VIEW_ICON      100
#define MENU_VIEW_REPORT    101
#define MENU_VIEW_SMALLICON 102
#define MENU_VIEW_LIST      103
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\cleaninf\parse.cpp ===
#include "priv.h"       



#define IS_WHITESPACE(ch)   (' ' == ch || '\t' == ch)
#define IS_NEWLINE(ch)      ('\n' == ch)


// Flags for _ReadChar
#define RCF_NEXTLINE        0x0001      // skip to next line
#define RCF_NEXTNWS         0x0002      // skip to next non-whitespace
#define RCF_SKIPTRAILING    0x0004      // skip trailing whitespace


// constructor
CParseFile::CParseFile()
{
}



/*-------------------------------------------------------------------------
Purpose: Parse the given file according to the provided flags.
*/
void CParseFile::Parse(FILE * pfileSrc, FILE * pfileDest, DWORD dwFlags)
{
    _bSkipWhitespace = BOOLIFY(dwFlags & PFF_WHITESPACE);
    
    _pfileSrc = pfileSrc;
    _pfileDest = pfileDest;
    _ichRead = 0;
    _cchRead = 0;
    
    _ichWrite = 0;
    
    _ch = 0;

    if (dwFlags & PFF_HTML)
        _ParseHtml();
    else if (dwFlags & PFF_HTC)
        _ParseHtc();
    else if (dwFlags & PFF_JS)
        _ParseJS();
    else
        _ParseInf();

    _FlushWriteBuffer();
}


/*-------------------------------------------------------------------------
Purpose: Read the next character in the file.  Sets _ch.

*/
char CParseFile::_ReadChar(DWORD dwFlags)
{
    BOOL bFirstCharSav = _bFirstChar;
    
    do 
    {
        _ichRead++;
        _bFirstChar = FALSE;

        // Are we past the buffer, or do we skip to next line?
        if (_ichRead >= _cchRead || dwFlags & RCF_NEXTLINE)
        {
            // Yes; read in more
            if (fgets(_szReadBuf, SIZECHARS(_szReadBuf), _pfileSrc))
            {
                _ichRead = 0;
                _cchRead = strlen(_szReadBuf);
                _bFirstChar = TRUE;
            }
            else
            {
                _ichRead = 0;
                _cchRead = 0;
            }
        }

        if (_ichRead < _cchRead)
            _ch = _szReadBuf[_ichRead];
        else
            _ch = CHAR_EOF;
    } while ((dwFlags & RCF_NEXTNWS) && IS_WHITESPACE(_ch));

    // Are we supposed to skip to the next non-whitespace?
    if (dwFlags & RCF_NEXTNWS)
    {
        // Yes; then retain the "first character" state
        _bFirstChar = bFirstCharSav;
    }
        
    return _ch;
}


/*-------------------------------------------------------------------------
Purpose: Read ahead to the next character in the buffer and return its
         value, but don't set _ch or increment the read pointer.
*/
char CParseFile::_SniffChar(int ichAhead)
{
    if (_ichRead + ichAhead < _cchRead)
        return _szReadBuf[_ichRead + ichAhead];
        
    return 0;
}



/*-------------------------------------------------------------------------
Purpose: Write the character to the file
*/
void CParseFile::_WriteChar(char ch)
{
    _szWriteBuf[_ichWrite++] = ch;
    _szWriteBuf[_ichWrite] = 0;

    if ('\n' == ch || SIZECHARS(_szWriteBuf)-1 == _ichWrite)
    {
        fputs(_szWriteBuf, _pfileDest);
        _ichWrite = 0;
    }
}


/*-------------------------------------------------------------------------
Purpose: Flushes the write buffer to the file
*/
void CParseFile::_FlushWriteBuffer(void)
{
    if (_ichWrite > 0)
    {
        fputs(_szWriteBuf, _pfileDest);
        _ichWrite = 0;
    }
}



/*-------------------------------------------------------------------------
Purpose: Parse a .inf file.
*/
void CParseFile::_ParseInf(void)
{
    _ReadChar(0);
    
    while (CHAR_EOF != _ch)
    {
        if (_bFirstChar)
        {
            // Is this a comment?
            if (';' == _ch)
            {
                // Yes; skip to next line
                _ReadChar(RCF_NEXTLINE);
                continue;
            }

            if (_SkipWhitespace())
                continue;
        }
        
        _WriteChar(_ch);
        _ReadChar(0);
    }
}    


/*-------------------------------------------------------------------------
Purpose: Write the current character and the rest of the tag.  Assumes
         _ch is the beginning of the tag ('<').

         There are some parts of the tag which may be compacted if _bSkipWhitespace
         is TRUE.  The general rule is only one space is required between attributes,
         and newlines are converted to spaces if necessary.  Anything in quotes 
         (single or double) are left alone.
*/
void CParseFile::_WriteTag(void)
{
    BOOL bSingleQuotes = FALSE;
    BOOL bDblQuotes = FALSE;
    
    // The end of the tag is the next '>' that is not in single or double-quotes.

    while (CHAR_EOF != _ch)
    {
        if ('\'' == _ch)
            bSingleQuotes ^= TRUE;
        else if ('"' == _ch)
            bDblQuotes ^= TRUE;

        if (!bSingleQuotes && !bDblQuotes)
        {
            // _SkipWhitespace returns TRUE if it skips any whitespace,
            // which means we've read some more input, which means we should
            // go to the top of the loop and check for EOF and quotes.
            if (_bSkipWhitespace && _SkipWhitespace(TRUE))
                continue;

            // End of tag?
            if ('>' == _ch)
            {
                // Yes
                _WriteChar(_ch);
                break;
            }
        }
        
        _WriteChar(_ch);
        _ReadChar(0);
    }
}


/*-------------------------------------------------------------------------
Purpose: Skip the current comment tag.  Assumes _ch is the beginning of
         the tag ('<').
*/
void CParseFile::_SkipCommentTag(void)
{
    // The end of the tag is the next '-->'

    while (CHAR_EOF != _ch)
    {
        // Is the end of the comment coming up?
        if ('-' == _ch && _SniffChar(1) == '-' && _SniffChar(2) == '>')
        {
            // Yes
            _ReadChar(0);   // skip '-'
            _ReadChar(0);   // skip '>'
            break;
        }
        
        _ReadChar(0);
    }
}


/*-------------------------------------------------------------------------
Purpose: Skip leading whitespace.

         Returns TRUE if anything was skipped
*/
BOOL CParseFile::_SkipWhitespace(BOOL bPreserveOneSpace)
{
    BOOL bRet = FALSE;
    
    if (_bSkipWhitespace)
    {
        if (IS_WHITESPACE(_ch))
        {
            // Skip leading whitespace in line
            _ReadChar(RCF_NEXTNWS);
            bRet = TRUE;
        }
        else if (IS_NEWLINE(_ch))
        {
            // Move to the next line
            _ReadChar(RCF_NEXTLINE);

            // Skip leading whitespace on the next line, but don't write
            // another space char (we'll do that here if necessary) and
            // ignore the return value since we've already skipped some
            // whitespace here (return TRUE).
            _SkipWhitespace(FALSE);

            bRet = TRUE;
        }
        // Write a single space char if we skipped something and the caller
        // asked us to preserve a space.
        if (bRet && bPreserveOneSpace)
            _WriteChar(' ');
    }
    return bRet;
}


/*-------------------------------------------------------------------------
Purpose: Skip a C or C++ style comment

         Returns TRUE if a comment boundary was encountered.
*/
BOOL CParseFile::_SkipComment(int * pcNestedComment)
{
    BOOL bRet = FALSE;
    
    if ('/' == _ch)
    {
        // Is this a C++ comment?
        if ('/' == _SniffChar(1))
        {
            // Yes; skip it to end of line
            if (!_bFirstChar || !_bSkipWhitespace)
                _WriteChar('\n');
                
            _ReadChar(RCF_NEXTLINE);
            bRet = TRUE;
        }
        // Is this a C comment?
        else if ('*' == _SniffChar(1))
        {
            // Yes; skip to respective '*/'
            _ReadChar(0);       // skip '/'
            _ReadChar(0);       // skip '*'
            (*pcNestedComment)++;
            bRet = TRUE;
        }
    }
    else if ('*' == _ch)
    {
        // Is this the end of a C comment?
        if ('/' == _SniffChar(1))
        {
            // Yes
            _ReadChar(0);       // skip '*'
            _ReadChar(0);       // skip '/'
            (*pcNestedComment)--;
            
            // Prevent writing an unnecessary '\n'
            _bFirstChar = TRUE;
            bRet = TRUE;
        }
    }
    return bRet;
}


/*-------------------------------------------------------------------------
Purpose: Parse the innertext of the STYLE tag, remove any comments
*/
void CParseFile::_ParseInnerStyle(void)
{
    int cNestedComment = 0;
    
    // The end of the tag is the next '</STYLE>'

    _ReadChar(0);

    while (CHAR_EOF != _ch)
    {
        if (_bFirstChar && _SkipWhitespace())
            continue;

        // Is the end of the styletag section coming up?
        if ('<' == _ch && _IsTagEqual("/STYLE"))
        {
            // Yes
            break;
        }

        if (_SkipComment(&cNestedComment))
            continue;

        if (0 == cNestedComment && !IS_NEWLINE(_ch))
            _WriteChar(_ch);
            
        _ReadChar(0);
    }
}


/*-------------------------------------------------------------------------
Purpose: Returns TRUE if the given tagname matches the currently parsed token
*/
BOOL CParseFile::_IsTagEqual(LPSTR pszTag)
{
    int ich = 1;

    while (*pszTag)
    {
        if (_SniffChar(ich++) != *pszTag++)
            return FALSE;
    }

    // We should verify we've come to the end of the tagName
    char chEnd = _SniffChar(ich);
    
    return (' ' == chEnd || '>' == chEnd || '<' == chEnd);
}


/*-------------------------------------------------------------------------
Purpose: Returns TRUE if the current tag is an end tag
*/
BOOL CParseFile::_IsEndTag(void)
{
    return (_SniffChar(1) == '/');
}


/*-------------------------------------------------------------------------
Purpose: Parse a .htm or .hta file.
*/
void CParseFile::_ParseHtml(void)
{
    BOOL bFollowingTag = FALSE;
    BOOL bFollowingEndTag = FALSE;
    
    _ReadChar(0);
    
    while (CHAR_EOF != _ch)
    {
        // Anytime we read another char, we should go to the top of the loop
        // to check for EOF and skip leading whitespace if it's a new line.
        //
        // Note that _SkipWhitespace returns TRUE if it has skipped something,
        // which also involves reading a new char.

        if (_bFirstChar && _SkipWhitespace())
            continue;

        // Is this a tag?
        if ('<' == _ch)
        {
            // Yes; looks like it

            // Since we've found a new tag, no need to remember if we just saw
            // an end tag. That only matters for text content following an end
            // tag. For example, given "<SPAN>foo</SPAN>  bar", we need to
            // preserve a space before the word "bar".
            bFollowingEndTag = FALSE;

            if (_IsTagEqual("!--"))
            {
                // Comment; skip it
                _SkipCommentTag();
            }
            else if (_IsTagEqual("SCRIPT"))
            {
                // Parse the script 
                _WriteTag();        // write the <SCRIPT> tag
                
                // FEATURE (scotth): we always assume javascript, maybe we should support something else
                _ParseJS();

                _WriteTag();        // write the </SCRIPT> tag
            }
            else if (_IsTagEqual("STYLE"))
            {
                _WriteTag();        // write the <STYLE> tag
                _ParseInnerStyle();
                _WriteTag();        // write the </STYLE> tag
            }
            else
            {
                // Check for end tag ("</") before calling _WriteTag
                bFollowingEndTag = _IsEndTag();

                // Any other tag: write the tag and go to the next one
                _WriteTag();
            }

            bFollowingTag = TRUE;
            _ReadChar(0);
            continue;
        }

        if (bFollowingTag && _bSkipWhitespace)
        {
            // We can't entirely skip whitespace following tags such as </SPAN>
            // or </A>, but we can at least collapse it down to a single space.
            BOOL bPreserveOneSpace = bFollowingEndTag;

            bFollowingEndTag = FALSE;
            bFollowingTag = FALSE;

            if (_SkipWhitespace(bPreserveOneSpace))
                continue;
        }
        
        _WriteChar(_ch);
        _ReadChar(0);
    }
}


/*-------------------------------------------------------------------------
Purpose: Parse a .js file.
*/
void CParseFile::_ParseJS(void)
{
    BOOL bDblQuotes = FALSE;
    BOOL bSingleQuotes = FALSE;
    int cNestedComment = 0;
    
    _ReadChar(0);
    
    while (CHAR_EOF != _ch)
    {
        // Are we in a comment?
        if (0 == cNestedComment)
        {
            // No; (we only pay attention to strings when they're not in comments)
            if ('\'' == _ch)
                bSingleQuotes ^= TRUE;
            else if ('"' == _ch)
                bDblQuotes ^= TRUE;

            if (_bSkipWhitespace && !bDblQuotes && !bSingleQuotes)
            {
                if (IS_WHITESPACE(_ch))
                {
                    // Skip whitespace
                    if (!_bFirstChar)
                        _WriteChar(' ');
                        
                    _ReadChar(RCF_NEXTNWS);
                    continue;
                }
                else if (IS_NEWLINE(_ch))
                {
                    // Since javascript doesn't require a ';' at the end of a statement,
                    // we should at least replace the newline with a space so tokens don't
                    // get appended accidentally.

                    // The javascript engine has a line-length limit.  So don't replace
                    // a newline with a space.
                    if (!_bFirstChar)
                        _WriteChar('\n');
                        
                    _ReadChar(RCF_NEXTLINE);
                    continue;
                }
            }

            // Are we in a string?
            if (!bDblQuotes && !bSingleQuotes)
            {
                // No; look for the terminating SCRIPT tag
                if ('<' == _ch)
                {
                    if (_IsTagEqual("/SCRIPT"))
                    {
                        // We've reached the end of the script block
                        break;
                    }
                }
            }
        }

        // Are we in a string?
        if (!bDblQuotes && !bSingleQuotes)
        {
            // No; look for comments...
            if (_SkipComment(&cNestedComment))
                continue;
        }
        
        if (0 == cNestedComment)
            _WriteChar(_ch);
            
        _ReadChar(0);
    }
}


/*-------------------------------------------------------------------------
Purpose: Parse a .htc file.
*/
void CParseFile::_ParseHtc(void)
{
    BOOL bFollowingTag = FALSE;
    int cNestedComment = 0;
    
    _ReadChar(0);
    
    while (CHAR_EOF != _ch)
    {
        if (_bFirstChar && _SkipWhitespace())
            continue;

        // Is this a tag?
        if ('<' == _ch)
        {
            // Yes; is it a script tag?
            if (_IsTagEqual("SCRIPT"))
            {
                // Yes; parse the script 
                _WriteTag();        // write the <SCRIPT> tag
                
                // FEATURE (scotth): we always assume javascript
                _ParseJS();

                _WriteTag();        // write the </SCRIPT> tag

                _ReadChar(0);
                bFollowingTag = TRUE;
                continue;
            }
            else
            {
                _WriteTag();
                _ReadChar(0);
                bFollowingTag = TRUE;
                continue;

            }
        }

        // Look for comments outside the SCRIPT block...
        if (_SkipComment(&cNestedComment))
            continue;
            
        if (bFollowingTag && _bSkipWhitespace)
        {
            bFollowingTag = FALSE;

            if (_SkipWhitespace())
                continue;
        }
        
        if (0 == cNestedComment)
             _WriteChar(_ch);
             
        _ReadChar(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\hdrver\ie50.c ===
#undef _WIN32_IE
#define _WIN32_IE 0x0500
#include <shlobj.h>
#include <shlobjp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\hdrver\ie10.c ===
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#undef _WIN32_IE
#define _WIN32_IE 0x0100

#include <windows.h>
#include <shfusion.h>
#include <shlobj.h>
#include <shlobjp.h>

// Do the work in the lowest version number to ensure we are maximally
// downlevel-compatible.

int __cdecl main(int argc, char **argv)
{
    // That's right, we call SHFusionInitialize with NULL.  But that's
    // okay because this program doesn't actually run.  We just want to
    // make sure it builds and links.
    //
    SHFusionInitialize(0);
    SHFusionUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\hdrver\ie30.c ===
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#undef _WIN32_IE
#define _WIN32_IE 0x0300
#include <shlobj.h>
#include <shlobjp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\hdrver\ie40.c ===
#undef _WIN32_IE
#define _WIN32_IE 0x0400
#include <shlobj.h>
#include <shlobjp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\hdrver\ie51.c ===
#undef _WIN32_IE
#define _WIN32_IE 0x0501
#include <shlobj.h>
#include <shlobjp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\hdrver\ie55.c ===
#undef _WIN32_IE
#define _WIN32_IE 0x0550
#include <shlobj.h>
#include <shlobjp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\shlexts\makefile.inc ===
HDEPENDENCIES=..\exts.h $(WINDOWS_INC_PATH)\stdexts.h

GENUEDEFDEFINES=/D_$(ALT_PROJECT)_
!if !$(FREEBUILD)
GENUEDEFDEFINES=$(GENUEDEFDEFINES) /DDEBUGTAGS=1
!endif

precomp.h: ..\precomp.h

$(O)\shlexts.def: ..\genuedef.c $(HDEPENDENCIES)
    $(CXX_COMPILER_NAME) $(GENUEDEFDEFINES) /EP ..\genuedef.c > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\regdate\main.cpp ===
#include <tchar.h>
#include <stdio.h>
#include <windows.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

#ifdef UNICODE
extern "C"
{
int __cdecl wmain(int argc, wchar_t* argv[])
#else
int __cdecl main(int argc, char* argv[])
#endif
{
    HKEY hkey;
    FILETIME ft = {0};
    SYSTEMTIME st = {0};
    PBYTE pb = (PBYTE)&ft;

    GetSystemTimeAsFileTime(&ft);

    if (FileTimeToSystemTime(&ft, &st))
    {
        _tprintf(TEXT("\nTime: %04d-%02d-%02d %02d:%02d:%02d:%04d\n\n"), st.wYear,
            st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond,
            st.wMilliseconds);
    }

    _tprintf(TEXT("Put this in devxprop.inx:\n"));
    _tprintf(TEXT("HKLM,\"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\PerHwIdStorage\",\"LastUpdateTime\",1,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x\n"),
        pb[0], pb[1], pb[2], pb[3], pb[4], pb[5], pb[6], pb[7]);

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER,
        TEXT("Software\\Microsoft\\Test"), 0, NULL,
        REG_OPTION_VOLATILE, MAXIMUM_ALLOWED, NULL, &hkey, NULL))
    {
        if (ERROR_SUCCESS == RegSetValueEx(hkey, TEXT("LastUpdateTimeCompare"),
            NULL, REG_BINARY, (PBYTE)&ft, sizeof(ft)))
        {
            _tprintf(TEXT("\n> Successfully written value HKCU\\Software\\Microsoft\\Test!LastUpdateTime for comparison.\n"));
        }        

        CloseHandle(hkey);
    }

    return 0;
}                       
#ifdef UNICODE
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\hdrver\ie60.c ===
#undef _WIN32_IE
#define _WIN32_IE 0x0600
#include <shlobj.h>
#include <shlobjp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\shlexts\drawicon.cpp ===
#include "precomp.h"
#pragma hdrstop

extern "C"
{
#include <stdexts.h>
};

#define ARRAYSIZE(x)   (sizeof(x)/sizeof(x[0]))
#define MIN_WIDTH     96 
#define MIN_HEIGHT    64
#define BORDER_WIDTH  32 

typedef struct _DRAW_ICON_STRUCT
{
    HBITMAP hBitmap;
    BYTE* psBits;
    BITMAPINFO bmi;
    HICON hIcon;
    int zoom;
} DRAW_ICON_STRUCT;

/************************************************************************\
* Procedure: CreateDIBSectionFromIcon
*
* Description:
*
*     Creates a DIB section given the handle to an icon
*
* 3/28/2001 - Created  bretan
*
\************************************************************************/
BOOL CreateDIBSectionFromIcon(DRAW_ICON_STRUCT* pDIS)
{
    ICONINFO info;

    if (!pDIS->hIcon)
    {
        Print("Invalid HICON handle\n");
        return FALSE;
    }

    if (GetIconInfo (pDIS->hIcon, &info))
    {
        HDC     hdc = NULL;
        HDC		dc  = NULL;
        HBRUSH	hBrush  = NULL;
        BITMAP	bitmap;
        
        hdc = CreateDC(L"DISPLAY", NULL, NULL, NULL);
        if (!hdc)
        {
            Print("CreateDC failed\n");
            return FALSE;
        }
            
        dc = CreateCompatibleDC(hdc);
        if (!dc)
        {
            Print("CreateCompatiblDC failed\n");
            return FALSE;
        }
                                                                                                                                                                                                                                                       
        if (!GetObject (info.hbmColor, sizeof (BITMAP), &bitmap))
        {
            Print("GetObject failed\n");
            return FALSE;
        }

        pDIS->bmi.bmiHeader.biSize     = sizeof(BITMAPINFOHEADER);
        pDIS->bmi.bmiHeader.biWidth    = bitmap.bmWidth;
        pDIS->bmi.bmiHeader.biHeight   = bitmap.bmHeight;
        pDIS->bmi.bmiHeader.biPlanes   = 1;
        pDIS->bmi.bmiHeader.biBitCount = bitmap.bmPlanes * bitmap.bmBitsPixel;
        
        if (pDIS->bmi.bmiHeader.biBitCount <= 1)
        {
            pDIS->bmi.bmiHeader.biBitCount = 1;
        }
        else if (pDIS->bmi.bmiHeader.biBitCount <= 4) 
        {
            pDIS->bmi.bmiHeader.biBitCount = 4;
        }
        else if (pDIS->bmi.bmiHeader.biBitCount <= 8)
        {
            pDIS->bmi.bmiHeader.biBitCount = 8;
        }
        else
        {
            pDIS->bmi.bmiHeader.biBitCount = 24;
        }
        
        pDIS->bmi.bmiHeader.biCompression = BI_RGB;
        
        // Create a DIB section so we don't have to worry about the display settings
        pDIS->hBitmap = CreateDIBSection(dc, (const BITMAPINFO *)&pDIS->bmi, DIB_RGB_COLORS, (void**)&pDIS->psBits, NULL, 0); 
        if (pDIS->hBitmap == NULL)
        {
            Print("CreateDIBSection failed\n");
            return FALSE;
        }
        
        SelectObject (dc, pDIS->hBitmap);
        hBrush = (HBRUSH)GetStockObject(BLACK_BRUSH);
        DrawIconEx (dc, 0, 0, pDIS->hIcon, 0, 0, 0, hBrush, DI_NORMAL);
        
        if (NULL == pDIS->psBits)
        {
            Print("CreateDIBSection failed.\n");
            return FALSE;
        }

        DeleteObject (info.hbmMask);
        DeleteObject (info.hbmColor);
        DeleteDC (hdc);
        DeleteDC (dc);
    }
        
    return TRUE;
}

/************************************************************************\
* Procedure: ZoomIn
*
* Description:
*
*     Zooms the window in by a factor of 2
*
* 3/28/2001 - Created  bretan
*
\************************************************************************/
void ZoomIn(HWND hwnd)
{
    DRAW_ICON_STRUCT* pDIS = (DRAW_ICON_STRUCT*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    int w, h;
            
    pDIS->zoom++;

    w = pDIS->bmi.bmiHeader.biWidth * pDIS->zoom + BORDER_WIDTH;
    h = pDIS->bmi.bmiHeader.biHeight * pDIS->zoom + BORDER_WIDTH;
 
    if (w < MIN_WIDTH) w = MIN_WIDTH;
    if (h < MIN_HEIGHT) h = MIN_HEIGHT;
    
    SetWindowPos(hwnd, 0, 0, 0, w, h, SWP_NOZORDER | SWP_NOMOVE);
    InvalidateRect(hwnd, NULL, TRUE);
}

/************************************************************************\
* Procedure: ZoomOut
*
* Description:
*
*     Zooms the window out by a factor of 2
*
* 3/28/2001 - Created  bretan
*
\************************************************************************/
void ZoomOut(HWND hwnd)
{
    DRAW_ICON_STRUCT* pDIS = (DRAW_ICON_STRUCT*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    pDIS->zoom--;

    if (pDIS->zoom < 1)
    { 
        pDIS->zoom = 1;
    }
    else
    {
        int w = pDIS->bmi.bmiHeader.biWidth * pDIS->zoom + BORDER_WIDTH;
        int h = pDIS->bmi.bmiHeader.biHeight * pDIS->zoom + BORDER_WIDTH;
            
        if (w < MIN_WIDTH) w = MIN_WIDTH;
        if (h < MIN_HEIGHT) h = MIN_HEIGHT;
    
        SetWindowPos(hwnd, 0, 0, 0, w, h, SWP_NOZORDER | SWP_NOMOVE);
        InvalidateRect(hwnd, NULL, TRUE);
    }
}

/************************************************************************\
* Procedure: WndProc
*
* Description:
*
*     The wndproc for the icon window
*
* 3/28/2001 - Created  bretan
*
\************************************************************************/
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        case WM_NCHITTEST: return HTCAPTION;
        
        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &ps);
            HDC buf = CreateCompatibleDC(hdc);
            HBITMAP oldbuf;
            RECT r;
            DRAW_ICON_STRUCT* pDIS = (DRAW_ICON_STRUCT*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            
            GetClientRect(hwnd, &r);
            FillRect(hdc, &r, (HBRUSH)GetStockObject(WHITE_BRUSH));
            
            if (pDIS)
            {
                int x, y, w, h;
 
                w = pDIS->bmi.bmiHeader.biWidth * pDIS->zoom;
                h = pDIS->bmi.bmiHeader.biHeight * pDIS->zoom;
                
                x = r.right/2 - w/2;
                y = r.bottom/2 - h/2;
                
                oldbuf = (HBITMAP)SelectObject(buf, pDIS->hBitmap);
                StretchBlt(hdc, x, y, w, h, buf, 0, 0, w/pDIS->zoom, h/pDIS->zoom, SRCCOPY);
            }

            SelectObject(buf, oldbuf);
            DeleteDC(buf);
            EndPaint(hwnd, &ps);
        }
        break;
        
        case WM_NCLBUTTONDBLCLK:
        {
            ZoomIn(hwnd);
        }
        break;
        
        case WM_NCRBUTTONDBLCLK:
        {
            ZoomOut(hwnd);
        }
        break;
        
        case WM_KEYDOWN:
        {
            switch (wParam)
            {
                case 187: // '+'
                {
                    ZoomIn(hwnd);
                }
                break;

                case 189: // '-'
                {
                    ZoomOut(hwnd);
                }
                break;

                case 81: // 'q'
                {
                    PostQuitMessage(0);
                }
                break;

                /*default:
                {
                    TCHAR szTemp[256];
                    wsprintf(szTemp, L"%d", wParam);
                    MessageBox(hwnd, szTemp, szTemp, MB_OK);
                }
                break;*/
            }
            break;
        }
        break;
        
        case WM_SYSCOMMAND:
        {
            switch (wParam)
            {
                case SC_CLOSE:
                {
                    PostQuitMessage(0);
                }
                break;
            }
        }
        break;

        case WM_TIMER:
        {
            if (IsCtrlCHit())
            {
                PostQuitMessage(0);
            }
        }
        break;
    }
 
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

/************************************************************************\
* Procedure: DrawIconWindow
*
* Description:
*
*     Draws the icon in a window on the remote side
*
* 3/28/2001 - Created  bretan
*
\************************************************************************/
DWORD WINAPI DrawIconWindow(LPVOID inpDIS)
{
    MSG msg;
	WNDCLASS wc;
    HWND hwnd;
    DRAW_ICON_STRUCT* pDIS = (DRAW_ICON_STRUCT*)inpDIS;
    LPCTSTR szClassName = L"ntsd - drawicon";
    TCHAR szTitle[32] = {0};
    int w, h;

	memset(&wc,0,sizeof(wc));
	wc.lpfnWndProc = WndProc;
	wc.hInstance = NULL;
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.style = CS_DBLCLKS;
	wc.lpszClassName = szClassName;
	RegisterClass(&wc);

    w = pDIS->bmi.bmiHeader.biWidth + BORDER_WIDTH; 
    h = pDIS->bmi.bmiHeader.biHeight + BORDER_WIDTH; 

    if (w < MIN_WIDTH)  w = MIN_WIDTH;
    if (h < MIN_HEIGHT) h = MIN_HEIGHT;

    StringCchPrintf(szTitle, ARRAYSIZE(szTitle), TEXT("%08x"), pDIS->hIcon);
	hwnd = CreateWindowEx(WS_EX_TOOLWINDOW, 
                          szClassName, szTitle, 
                          WS_POPUPWINDOW | WS_CAPTION | WS_VISIBLE, 
                          10, 10, 
                          w, h,
                          NULL, NULL, NULL, NULL);
	if (!hwnd) return FALSE;

    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pDIS);
    SetTimer(hwnd, 0, 100, NULL);
    SetForegroundWindow(hwnd);
    SetFocus(hwnd);

	while (GetMessage(&msg, (HWND) NULL, 0, 0))
	{ 
		TranslateMessage(&msg); 
		DispatchMessage(&msg); 
    }

    KillTimer(hwnd, 0);
    DestroyWindow(hwnd);
    UnregisterClass(szClassName, NULL);
    return TRUE;
}

/************************************************************************\
* Procedure: DrawIconASCII
*
* Description:
*
*     Prints the icon in ASCII format through the ntsd session
*
* 3/28/2001 - Created  bretan
*
\************************************************************************/
BOOL DrawIconASCII(DRAW_ICON_STRUCT* pDIS, BOOL bColor)
{
    HANDLE hConsole;
    DWORD dwWritten;
    WORD wOldColorAttrs; 
    CONSOLE_SCREEN_BUFFER_INFO csbiInfo; 
    

    if (bColor)
    {
        hConsole = GetStdHandle(STD_OUTPUT_HANDLE);

        if (hConsole)
        {
            if (!GetConsoleScreenBufferInfo(hConsole, &csbiInfo)) 
            {
                bColor = FALSE;
            }
        }
        else
        {
            bColor = FALSE;
        }
        
        wOldColorAttrs = csbiInfo.wAttributes; 
    }

/*
    // Uncomment this to get a nice big list of all the chars to choose from
    for (int x = 0; x < 256; x++)
    {
        TCHAR szPrint[10];
        wsprintf(szPrint, L"%d = %c\n", x, x);
        WriteConsole(hConsole, szPrint, lstrlen(szPrint), &dwWritten, NULL);
    }
*/
    
    for (int y = pDIS->bmi.bmiHeader.biHeight*3 - 3; y; y-=3)
    {
        int Offset = y * pDIS->bmi.bmiHeader.biWidth;
                
        for (int x = 0; x < pDIS->bmi.bmiHeader.biWidth*3; x+=3)
        {
            RGBQUAD* prgb = (RGBQUAD*)&pDIS->psBits[x + Offset];

            if (bColor)
            {
                TCHAR szPrint[3];
                WORD wForeground = 0;

                if (prgb->rgbRed > 128)
                {
                    wForeground |= FOREGROUND_RED;
                }

                if (prgb->rgbGreen > 128)
                {
                    wForeground |= FOREGROUND_GREEN;
                }
            
                if (prgb->rgbBlue > 128)
                {
                    wForeground |= FOREGROUND_BLUE;
                }

                if (prgb->rgbRed > 192 || prgb->rgbGreen > 192 || prgb->rgbBlue > 192)
                {
                    wForeground |= FOREGROUND_INTENSITY;
                }

                SetConsoleTextAttribute(hConsole, wForeground);
                StringCchPrintf(szPrint, ARRAYSIZE(szPrint), TEXT("%c%c"), 15, 15);
                WriteConsole(hConsole, szPrint, 2, &dwWritten, NULL);
            }
            else
            {
                int val = (prgb->rgbRed + prgb->rgbGreen + prgb->rgbBlue) / 3; 

                if (val > 0 && val <= 25) Print("  ");
                else if (val > 25 && val <= 100)  Print("%c%c", 176, 176);
                else if (val > 100 && val <= 165) Print("%c%c", 177, 177);
                else if (val > 165 && val <= 215) Print("%c%c", 178, 178);
                else if (val > 215 && val <= 255) Print("%c%c", 219, 219);
                else Print("  ");
            }
        }
        
        if (bColor)
        {
            WriteConsole(hConsole, L"\n", 1, &dwWritten, NULL);
        }
        else
        {
            Print("\n");
        }
    }
 
    if (bColor)
    {
        WriteConsole(hConsole, L"\n", 1, &dwWritten, NULL);
        SetConsoleTextAttribute(hConsole, wOldColorAttrs);
    }
    else
    {
        Print("\n");
    }

    return TRUE;
}

/************************************************************************\
* Procedure: Idrawicon
*
* Description:
*
*     Draws the given icon in ASCII or in a popup window
*
* 3/28/2001 - Created  bretan
*
\************************************************************************/
extern "C" BOOL Idrawicon(DWORD dwOpts,
                          LPVOID pArg )
{
    DRAW_ICON_STRUCT DIS;
    BOOL ret=FALSE;
    HICON hIcon = (HICON)pArg;
            
    DIS.zoom = 1;
    DIS.hIcon = hIcon;

    ret = CreateDIBSectionFromIcon(&DIS);
 
    if (ret)
    {
        if (OFLAG(w) & dwOpts)
        {
            ret = DrawIconWindow(&DIS);
        }
        else
        {
            ret = DrawIconASCII(&DIS, (OFLAG(c) & dwOpts)? TRUE : FALSE);
        }
        
        DeleteObject(DIS.hBitmap);
    }
    
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\shlexts\genuedef.c ===
LIBRARY SHLEXTS

; DESCRIPTION is obsolete and gives the IA64 linker the heebie-jeebies
;DESCRIPTION 'SHELL Debugger Extensions'

;
; This file generates shlexts.def. This allows one file (exts.h) to
; be used to generate extension exports, entrypoints, and help text.
;
; To add an extension, add the appropriate entry to exts.h and matching
; code to shlexts.c
;

//#ifdef _FE_
//#define FE_IME 1
//#endif

EXPORTS
#define DOIT(name, helpstring1, helpstring2, validflags, argtype) name
#include "exts.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\shlexts\exts.h ===
/************************************************************************\
*
* MODULE: exts.h
*
* DESCRIPTION: macro driving file for use with stdexts.h and stdexts.c.
*
* Copyright (c) 6/9/1995, Microsoft Corporation
*
* 6/9/1995 SanfordS Created
* 10/28/97 butchered by cdturner to work for the shell team
*
\************************************************************************/

DOIT(   help
        ,"help -v [cmd]                  - Displays this list or gives details on command\n"
        ,"  help      - To dump short help text on all commands.\n"
         "  help -v   - To dump long help text on all commands.\n"
         "  help cmd  - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

DOIT(   pidl
        ,"pidl -vrf [address]            - Display contents of pidl at address [address]\n"
        ,"pidl -r [address]   - To dump the contents of a RegItem pidl at [address]\n"
         "pidl -f [address]   - To dump the contents of a FileSys pidl at [address]\n"
         "pidl -vr [address]  - Dumps the verbose info for each pidl\n"
        , "vrf" 
        , STDARGS1)

DOIT(   filever
        ,"filever [-nd] [<filename>]     - Display file version information\n"
        ,"filever -d <filename>     - DllGetVersionInfo (requires LoadLibrary)\n"
         "filever -n <filename>     - File version resource information (default)\n"
         "filever -v <filename>     - Verbose file version resource information\n"
         "\n"
         "          If omitted, <filename> defaults to shell32.dll\n"
         "          Flags may be combined to dump multiple info\n"
        ,"vnd"
        ,CUSTOM)

DOIT(   test
        ,"test                           - Test basic debug functions.\n"
        ,""
        ,""
        ,NOARGS)

DOIT(   ver
        ,"ver                            - show versions of shlexts.\n"
        ,""
        ,""
        ,NOARGS)

DOIT(   hwnd
        ,"hwnd                           - show HWND info (doesn't require symbols)\n"
        ,"hwnd windowhandle              - display basic informatione\n"
         "hwnd -b windowhandle           - display window extra bytes\n"
         "hwnd -p windowhandle           - display window properties\n"
         "hwnd -m                        - display miscellaneous windows\n"
         "\n"
         "Window <hwnd> \"<title>\" (<class>)\n"
         "  N=<hwndNext> C=<hwndChild> P=<hwndParent> O=<hwndOwner>\n"
         "  W=<windowrect> C=<clientrect>\n"
         "  pid.tid=<pid>.<tid> hinst=<hinstance> wp=<wndproc>\n"
         "  style=<style> exstyle=<exstyle>\n"
        ,"bpm"
        , STDARGS1)

DOIT(   hmenu
        ,"hmenu                          - show HMENU info (doesn't require symbols)\n"
        ,"hmenu menuhandle               - display basic information\n"
         "\n"
         "Menu <hmenu> %d items\n"
         " n: id=<id> ref=<refdata> type <desc> <flags> [-> <submenu>]\n"
        ,""
        , STDARGS1)


DOIT(   dlgt
       ,"dlgt address                    - dump dialog template\n"
       ,"dlgt address                    - dump dialog template\n"
       ,"" 
       , STDARGS1)

DOIT(   stackpig
       ,"stackpig [nFrames]              - stack trace with stack usage\n"
       ,"    [nFrames]                   - number of frames to walk, default 25\n"
       ,"" 
       , STDARGS1)

DOIT(   wmex 
       ,"wmex msg [hwnd]                 - print window message\n"
       ,"wmex msg                        - print the name of all window messages with value msg\n"
        "wmex msg hwnd                   - print the name of msg specific to window class of hwnd\n" 
       ,"" 
       , STDARGS2)

DOIT(   drawicon 
        ,"drawicon [-cw] handle           - Draws the given icon as ASCII or in a window\n"
        ,"drawicon handle                - Draws icon as ASCII in ntsd session\n"
         "drawicon -c handle             - Draws icon as ASCII in ntsd session w/ color\n"
         "                                 (Colors will not work through a remote)\n"
         "drawicon -w handle             - Draws icon in popup window on remote side\n"
         "                                 Left double-click or '+' to zoom in\n"
         "                                 Right double-click or '-' to zoom out\n"
        ,"cw"
        , STDARGS1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\shlexts\msgs.cpp ===
//-----------------------------------------------------------------------------
#include "precomp.h"
#pragma hdrstop

extern "C"
{
#include <stdexts.h>
#include <dbgeng.h>
#include <commctrl.h>
#include <comctrlp.h>

#include "msgs.h"
};


//-----------------------------------------------------------------------------
void PrintUser32Message(UINT uMsg)
{
    IDebugClient*  pDebugClient;
    IDebugControl* pDebugControl;

    if (SUCCEEDED(DebugCreate(__uuidof(IDebugClient), (void**)&pDebugClient)))
    {
        if (SUCCEEDED(pDebugClient->QueryInterface(__uuidof(IDebugControl), (void**)&pDebugControl)))
        {
            // Try calling the wm extension from userexts.dll
            ULONG64 ulExtension = 0;
            CHAR szMsg[64];

            pDebugControl->AddExtension("userexts", DEBUG_EXTENSION_AT_ENGINE, &ulExtension);
            pDebugControl->CallExtension(ulExtension, "wm", _itoa(uMsg, szMsg, 16)); 

            pDebugControl->Release();
        }

        pDebugClient->Release();
    }
}


//-----------------------------------------------------------------------------
void PrintRegisteredMessage(UINT uMsg)
{
    CHAR szMsg[64];

    if (GetClipboardFormatNameA(uMsg, szMsg, ARRAYSIZE(szMsg)))
    {
        Print("  %x %s\n", uMsg, szMsg);
    }
    else
    {
        Print("  %x ???\n", uMsg);
    }
}


//-----------------------------------------------------------------------------
void PrintComctl32Message(UINT uMsg, HWND hwnd)
{
    BOOL fMatchClass = FALSE;
    BOOL fFound      = FALSE;

    CHAR szClassName[64];
    if (hwnd && IsWindow(hwnd))
    {
        if (GetClassNameA(hwnd, szClassName, ARRAYSIZE(szClassName)))
        {
            fMatchClass = TRUE;
        }
    }


    for (int i = 0; !IsCtrlCHit() && (i < ARRAYSIZE(rgMsgMap)); i++)
    {
        if ((i > 0) &&  // always execute first iteration, contains msgs common to all
            (fMatchClass && (_stricmp(szClassName, rgMsgMap[i].szClassName) != 0)))
        {
            continue;
        }

        int j;
        MSGNAME* pmm;
        for (j = 0, pmm = rgMsgMap[i].rgMsgName; !IsCtrlCHit() && (j < rgMsgMap[i].chMsgName); j++)
        {
            if (pmm[j].uMsg == uMsg)
            {
                Print("  %x %-25s%s\n", pmm[j].uMsg, pmm[j].szMsg, fMatchClass ? "" : rgMsgMap[i].szFriendlyClassName);
                fFound = TRUE;
                break;
            }
        }
    }

    if (!fFound)
    {
        Print("  %x ???\n", uMsg);
    }
}


//-----------------------------------------------------------------------------
void PrintWindowMessageEx(UINT uMsg, HWND hwnd)
{
    if (uMsg <= WM_USER)
    {
        PrintUser32Message(uMsg);
    }
    else if (uMsg >= 0xC000)
    {
        PrintRegisteredMessage(uMsg);
    }
    else
    {
        PrintComctl32Message(uMsg, hwnd);
    }
}


//-----------------------------------------------------------------------------
extern "C" BOOL Iwmex(DWORD dwOpts, LPVOID pArg1, LPVOID pArg2)
{
    PrintWindowMessageEx(PtrToUint(pArg1), (HWND)(HWND *)pArg2);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\shlexts\msgs.h ===
typedef struct tagMSGNAME
{
    UINT    uMsg;
    LPSTR   szMsg;
} MSGNAME;

typedef struct tagMSGMAP
{
    LPSTR       szClassName;
    LPSTR       szFriendlyClassName;
    MSGNAME     *rgMsgName;
    int         chMsgName;
} MSGMAP;


#define MSGNAME_ENTRY(x)    {x, #x}


//-----------------------------------------------------------------------------
// Common Control Messages
MSGNAME rgMsgNameCCM[] = 
{
    // control message range declarations, put them in the common bucket
    MSGNAME_ENTRY(LVM_FIRST),
    MSGNAME_ENTRY(TV_FIRST),
    MSGNAME_ENTRY(HDM_FIRST),
    MSGNAME_ENTRY(TCM_FIRST),
    MSGNAME_ENTRY(PGM_FIRST),
    MSGNAME_ENTRY(ECM_FIRST),
    MSGNAME_ENTRY(BCM_FIRST),
    MSGNAME_ENTRY(CBM_FIRST),

    // common control messages
    MSGNAME_ENTRY(CCM_FIRST),
    MSGNAME_ENTRY(CCM_LAST),
    MSGNAME_ENTRY(CCM_SETBKCOLOR),
    MSGNAME_ENTRY(CCM_SETCOLORSCHEME),
    MSGNAME_ENTRY(CCM_GETCOLORSCHEME),
    MSGNAME_ENTRY(CCM_GETDROPTARGET),
    MSGNAME_ENTRY(CCM_SETUNICODEFORMAT),
    MSGNAME_ENTRY(CCM_GETUNICODEFORMAT),
    MSGNAME_ENTRY(CCM_SETVERSION),
    MSGNAME_ENTRY(CCM_GETVERSION),
    MSGNAME_ENTRY(CCM_SETNOTIFYWINDOW),
    MSGNAME_ENTRY(CCM_TRANSLATEACCELERATOR),
    MSGNAME_ENTRY(CCM_SETWINDOWTHEME),
    MSGNAME_ENTRY(CCM_DPISCALE),
};

//-----------------------------------------------------------------------------
// Header Control Messages
MSGNAME rgMsgNameHDM[] = 
{
    MSGNAME_ENTRY(HDM_GETITEMCOUNT),
    MSGNAME_ENTRY(HDM_INSERTITEMA),
    MSGNAME_ENTRY(HDM_INSERTITEMW),
    MSGNAME_ENTRY(HDM_DELETEITEM),
    MSGNAME_ENTRY(HDM_GETITEMA),
    MSGNAME_ENTRY(HDM_GETITEMW),
    MSGNAME_ENTRY(HDM_SETITEMA),
    MSGNAME_ENTRY(HDM_SETITEMW),
    MSGNAME_ENTRY(HDM_LAYOUT),
    MSGNAME_ENTRY(HDM_HITTEST),
    MSGNAME_ENTRY(HDM_GETITEMRECT),
    MSGNAME_ENTRY(HDM_SETIMAGELIST),
    MSGNAME_ENTRY(HDM_GETIMAGELIST),
    MSGNAME_ENTRY(HDM_ORDERTOINDEX),
    MSGNAME_ENTRY(HDM_CREATEDRAGIMAGE),
    MSGNAME_ENTRY(HDM_GETORDERARRAY),
    MSGNAME_ENTRY(HDM_SETORDERARRAY),
    MSGNAME_ENTRY(HDM_SETHOTDIVIDER),
    MSGNAME_ENTRY(HDM_SETBITMAPMARGIN),
    MSGNAME_ENTRY(HDM_GETBITMAPMARGIN),
    MSGNAME_ENTRY(HDM_SETFILTERCHANGETIMEOUT),
    MSGNAME_ENTRY(HDM_EDITFILTER),
    MSGNAME_ENTRY(HDM_CLEARFILTER),
};


//-----------------------------------------------------------------------------
// Toolbar Control Messages
MSGNAME rgMsgNameTB[] = 
{
    MSGNAME_ENTRY(TB_ENABLEBUTTON),
    MSGNAME_ENTRY(TB_CHECKBUTTON),
    MSGNAME_ENTRY(TB_PRESSBUTTON),
    MSGNAME_ENTRY(TB_HIDEBUTTON),
    MSGNAME_ENTRY(TB_INDETERMINATE),
    MSGNAME_ENTRY(TB_MARKBUTTON),
    MSGNAME_ENTRY(TB_ISBUTTONENABLED),
    MSGNAME_ENTRY(TB_ISBUTTONCHECKED),
    MSGNAME_ENTRY(TB_ISBUTTONPRESSED),
    MSGNAME_ENTRY(TB_ISBUTTONHIDDEN),
    MSGNAME_ENTRY(TB_ISBUTTONINDETERMINATE),
    MSGNAME_ENTRY(TB_ISBUTTONHIGHLIGHTED),
    MSGNAME_ENTRY(TB_SETSTATE),
    MSGNAME_ENTRY(TB_GETSTATE),
    MSGNAME_ENTRY(TB_ADDBITMAP),
    MSGNAME_ENTRY(TB_ADDBUTTONSA),
    MSGNAME_ENTRY(TB_INSERTBUTTONA),
    MSGNAME_ENTRY(TB_ADDBUTTONS),
    MSGNAME_ENTRY(TB_INSERTBUTTON),
    MSGNAME_ENTRY(TB_DELETEBUTTON),
    MSGNAME_ENTRY(TB_GETBUTTON),
    MSGNAME_ENTRY(TB_BUTTONCOUNT),
    MSGNAME_ENTRY(TB_COMMANDTOINDEX),
    MSGNAME_ENTRY(TB_SAVERESTOREA),
    MSGNAME_ENTRY(TB_SAVERESTOREW),
    MSGNAME_ENTRY(TB_CUSTOMIZE),
    MSGNAME_ENTRY(TB_ADDSTRINGA),
    MSGNAME_ENTRY(TB_ADDSTRINGW),
    MSGNAME_ENTRY(TB_GETITEMRECT),
    MSGNAME_ENTRY(TB_BUTTONSTRUCTSIZE),
    MSGNAME_ENTRY(TB_SETBUTTONSIZE),
    MSGNAME_ENTRY(TB_SETBITMAPSIZE),
    MSGNAME_ENTRY(TB_AUTOSIZE),
    MSGNAME_ENTRY(TB_SETBUTTONTYPE),
    MSGNAME_ENTRY(TB_GETTOOLTIPS),
    MSGNAME_ENTRY(TB_SETTOOLTIPS),
    MSGNAME_ENTRY(TB_SETPARENT),
    MSGNAME_ENTRY(TB_ADDBITMAP32),
    MSGNAME_ENTRY(TB_SETROWS),
    MSGNAME_ENTRY(TB_GETROWS),
    MSGNAME_ENTRY(TB_SETCMDID),
    MSGNAME_ENTRY(TB_CHANGEBITMAP),
    MSGNAME_ENTRY(TB_GETBITMAP),
    MSGNAME_ENTRY(TB_GETBUTTONTEXTA),
    MSGNAME_ENTRY(TB_GETBUTTONTEXTW),
    MSGNAME_ENTRY(TB_REPLACEBITMAP),
    MSGNAME_ENTRY(TB_SETINDENT),
    MSGNAME_ENTRY(TB_SETIMAGELIST),
    MSGNAME_ENTRY(TB_GETIMAGELIST),
    MSGNAME_ENTRY(TB_LOADIMAGES),
    MSGNAME_ENTRY(TB_GETRECT),
    MSGNAME_ENTRY(TB_SETHOTIMAGELIST),
    MSGNAME_ENTRY(TB_GETHOTIMAGELIST),
    MSGNAME_ENTRY(TB_SETDISABLEDIMAGELIST),
    MSGNAME_ENTRY(TB_GETDISABLEDIMAGELIST),
    MSGNAME_ENTRY(TB_SETSTYLE),
    MSGNAME_ENTRY(TB_GETSTYLE),
    MSGNAME_ENTRY(TB_GETBUTTONSIZE),
    MSGNAME_ENTRY(TB_SETBUTTONWIDTH),
    MSGNAME_ENTRY(TB_SETMAXTEXTROWS),
    MSGNAME_ENTRY(TB_GETTEXTROWS),
    MSGNAME_ENTRY(TB_GETOBJECT),
    MSGNAME_ENTRY(TB_GETHOTITEM),
    MSGNAME_ENTRY(TB_SETHOTITEM),
    MSGNAME_ENTRY(TB_SETANCHORHIGHLIGHT),
    MSGNAME_ENTRY(TB_GETANCHORHIGHLIGHT),
    MSGNAME_ENTRY(TB_MAPACCELERATORA),
    MSGNAME_ENTRY(TB_GETINSERTMARK),
    MSGNAME_ENTRY(TB_SETINSERTMARK),
    MSGNAME_ENTRY(TB_INSERTMARKHITTEST),
    MSGNAME_ENTRY(TB_MOVEBUTTON),
    MSGNAME_ENTRY(TB_GETMAXSIZE),
    MSGNAME_ENTRY(TB_SETEXTENDEDSTYLE),
    MSGNAME_ENTRY(TB_GETEXTENDEDSTYLE),
    MSGNAME_ENTRY(TB_GETPADDING),
    MSGNAME_ENTRY(TB_SETPADDING),
    MSGNAME_ENTRY(TB_SETINSERTMARKCOLOR),
    MSGNAME_ENTRY(TB_GETINSERTMARKCOLOR),
    MSGNAME_ENTRY(TB_MAPACCELERATORW),
    MSGNAME_ENTRY(TB_GETBITMAPFLAGS),
    MSGNAME_ENTRY(TB_GETBUTTONINFOW),
    MSGNAME_ENTRY(TB_SETBUTTONINFOW),
    MSGNAME_ENTRY(TB_GETBUTTONINFOA),
    MSGNAME_ENTRY(TB_SETBUTTONINFOA),
    MSGNAME_ENTRY(TB_INSERTBUTTONW),
    MSGNAME_ENTRY(TB_ADDBUTTONSW),
    MSGNAME_ENTRY(TB_HITTEST),
    MSGNAME_ENTRY(TB_SETDRAWTEXTFLAGS),
    MSGNAME_ENTRY(TB_GETSTRINGW),
    MSGNAME_ENTRY(TB_GETSTRINGA),
    MSGNAME_ENTRY(TB_SETBOUNDINGSIZE),
    MSGNAME_ENTRY(TB_SETHOTITEM2),
    MSGNAME_ENTRY(TB_HASACCELERATOR),
    MSGNAME_ENTRY(TB_SETLISTGAP),
    MSGNAME_ENTRY(TB_GETIMAGELISTCOUNT),
    MSGNAME_ENTRY(TB_GETIDEALSIZE),
    MSGNAME_ENTRY(TB_SETDROPDOWNGAP),
    MSGNAME_ENTRY(TB_GETMETRICS),
    MSGNAME_ENTRY(TB_SETMETRICS),
};


//-----------------------------------------------------------------------------
// Rebar Control Messages
MSGNAME rgMsgNameRB[] = 
{
    MSGNAME_ENTRY(RB_INSERTBANDA),
    MSGNAME_ENTRY(RB_DELETEBAND),
    MSGNAME_ENTRY(RB_GETBARINFO),
    MSGNAME_ENTRY(RB_SETBARINFO),
    MSGNAME_ENTRY(RB_GETBANDINFOOLD),
    MSGNAME_ENTRY(RB_GETBANDINFO),
    MSGNAME_ENTRY(RB_SETBANDINFOA),
    MSGNAME_ENTRY(RB_SETPARENT),
    MSGNAME_ENTRY(RB_HITTEST),
    MSGNAME_ENTRY(RB_GETRECT),
    MSGNAME_ENTRY(RB_INSERTBANDW),
    MSGNAME_ENTRY(RB_SETBANDINFOW),
    MSGNAME_ENTRY(RB_GETBANDCOUNT),
    MSGNAME_ENTRY(RB_GETROWCOUNT),
    MSGNAME_ENTRY(RB_GETROWHEIGHT),
    MSGNAME_ENTRY(RB_GETOBJECT),
    MSGNAME_ENTRY(RB_IDTOINDEX),
    MSGNAME_ENTRY(RB_GETTOOLTIPS),
    MSGNAME_ENTRY(RB_SETTOOLTIPS),
    MSGNAME_ENTRY(RB_SETBKCOLOR),
    MSGNAME_ENTRY(RB_GETBKCOLOR),
    MSGNAME_ENTRY(RB_SETTEXTCOLOR),
    MSGNAME_ENTRY(RB_GETTEXTCOLOR),
    MSGNAME_ENTRY(RB_SIZETORECT),
    MSGNAME_ENTRY(RB_BEGINDRAG),
    MSGNAME_ENTRY(RB_ENDDRAG),
    MSGNAME_ENTRY(RB_DRAGMOVE),
    MSGNAME_ENTRY(RB_GETBARHEIGHT),
    MSGNAME_ENTRY(RB_GETBANDINFOW),
    MSGNAME_ENTRY(RB_GETBANDINFOA),
    MSGNAME_ENTRY(RB_MINIMIZEBAND),
    MSGNAME_ENTRY(RB_MAXIMIZEBAND),
    MSGNAME_ENTRY(RB_PRIV_RESIZE),
    MSGNAME_ENTRY(RB_GETBANDBORDERS),
    MSGNAME_ENTRY(RB_SHOWBAND),
    MSGNAME_ENTRY(RB_PRIV_DODELAYEDSTUFF),
    MSGNAME_ENTRY(RB_SETPALETTE),
    MSGNAME_ENTRY(RB_GETPALETTE),
    MSGNAME_ENTRY(RB_MOVEBAND),
    MSGNAME_ENTRY(RB_GETBANDMARGINS),
    MSGNAME_ENTRY(RB_PUSHCHEVRON),
};


//-----------------------------------------------------------------------------
// Tooltip Control Messages
MSGNAME rgMsgNameTTM[] = 
{
    MSGNAME_ENTRY(TTM_ACTIVATE),
    MSGNAME_ENTRY(TTM_SETDELAYTIME),
    MSGNAME_ENTRY(TTM_ADDTOOLA),
    MSGNAME_ENTRY(TTM_ADDTOOLW),
    MSGNAME_ENTRY(TTM_DELTOOLA),
    MSGNAME_ENTRY(TTM_DELTOOLW),
    MSGNAME_ENTRY(TTM_NEWTOOLRECTA),
    MSGNAME_ENTRY(TTM_NEWTOOLRECTW),
    MSGNAME_ENTRY(TTM_RELAYEVENT),
    MSGNAME_ENTRY(TTM_GETTOOLINFOA),
    MSGNAME_ENTRY(TTM_GETTOOLINFOW),
    MSGNAME_ENTRY(TTM_SETTOOLINFOA),
    MSGNAME_ENTRY(TTM_SETTOOLINFOW),
    MSGNAME_ENTRY(TTM_HITTESTA),
    MSGNAME_ENTRY(TTM_HITTESTW),
    MSGNAME_ENTRY(TTM_GETTEXTA),
    MSGNAME_ENTRY(TTM_GETTEXTW),
    MSGNAME_ENTRY(TTM_UPDATETIPTEXTA),
    MSGNAME_ENTRY(TTM_UPDATETIPTEXTW),
    MSGNAME_ENTRY(TTM_GETTOOLCOUNT),
    MSGNAME_ENTRY(TTM_ENUMTOOLSA),
    MSGNAME_ENTRY(TTM_ENUMTOOLSW),
    MSGNAME_ENTRY(TTM_GETCURRENTTOOLA),
    MSGNAME_ENTRY(TTM_GETCURRENTTOOLW),
    MSGNAME_ENTRY(TTM_WINDOWFROMPOINT),
    MSGNAME_ENTRY(TTM_TRACKACTIVATE),
    MSGNAME_ENTRY(TTM_TRACKPOSITION),
    MSGNAME_ENTRY(TTM_SETTIPBKCOLOR),
    MSGNAME_ENTRY(TTM_SETTIPTEXTCOLOR),
    MSGNAME_ENTRY(TTM_GETDELAYTIME),
    MSGNAME_ENTRY(TTM_GETTIPBKCOLOR),
    MSGNAME_ENTRY(TTM_GETTIPTEXTCOLOR),
    MSGNAME_ENTRY(TTM_SETMAXTIPWIDTH),
    MSGNAME_ENTRY(TTM_GETMAXTIPWIDTH),
    MSGNAME_ENTRY(TTM_SETMARGIN),
    MSGNAME_ENTRY(TTM_GETMARGIN),
    MSGNAME_ENTRY(TTM_POP),
    MSGNAME_ENTRY(TTM_UPDATE),
    MSGNAME_ENTRY(TTM_GETBUBBLESIZE),
    MSGNAME_ENTRY(TTM_ADJUSTRECT),
    MSGNAME_ENTRY(TTM_SETTITLEA),
    MSGNAME_ENTRY(TTM_SETTITLEW),
    MSGNAME_ENTRY(TTM_POPUP),
    MSGNAME_ENTRY(TTM_GETTITLE),
};


//-----------------------------------------------------------------------------
// Status Control Messages
MSGNAME rgMsgNameSB[] = 
{
    MSGNAME_ENTRY(SB_SETTEXTA),
    MSGNAME_ENTRY(SB_SETTEXTW),
    MSGNAME_ENTRY(SB_GETTEXTA),
    MSGNAME_ENTRY(SB_GETTEXTW),
    MSGNAME_ENTRY(SB_GETTEXTLENGTHA),
    MSGNAME_ENTRY(SB_GETTEXTLENGTHW),
    MSGNAME_ENTRY(SB_SETPARTS),
    MSGNAME_ENTRY(SB_SETBORDERS),
    MSGNAME_ENTRY(SB_GETPARTS),
    MSGNAME_ENTRY(SB_GETBORDERS),
    MSGNAME_ENTRY(SB_SETMINHEIGHT),
    MSGNAME_ENTRY(SB_SIMPLE),
    MSGNAME_ENTRY(SB_GETRECT),
    MSGNAME_ENTRY(SB_ISSIMPLE),
    MSGNAME_ENTRY(SB_SETICON),
    MSGNAME_ENTRY(SB_SETTIPTEXTA),
    MSGNAME_ENTRY(SB_SETTIPTEXTW),
    MSGNAME_ENTRY(SB_GETTIPTEXTA),
    MSGNAME_ENTRY(SB_GETTIPTEXTW),
    MSGNAME_ENTRY(SB_GETICON),
};


//-----------------------------------------------------------------------------
// ButtonListBox Control Messages ???
MSGNAME rgMsgNameBL[] = 
{
    MSGNAME_ENTRY(BL_ADDBUTTON),
    MSGNAME_ENTRY(BL_DELETEBUTTON),
    MSGNAME_ENTRY(BL_GETCARETINDEX),
    MSGNAME_ENTRY(BL_GETCOUNT),
    MSGNAME_ENTRY(BL_GETCURSEL),
    MSGNAME_ENTRY(BL_GETITEMDATA),
    MSGNAME_ENTRY(BL_GETITEMRECT),
    MSGNAME_ENTRY(BL_GETTEXT),
    MSGNAME_ENTRY(BL_GETTEXTLEN),
    MSGNAME_ENTRY(BL_GETTOPINDEX),
    MSGNAME_ENTRY(BL_INSERTBUTTON),
    MSGNAME_ENTRY(BL_RESETCONTENT),
    MSGNAME_ENTRY(BL_SETCARETINDEX),
    MSGNAME_ENTRY(BL_SETCURSEL),
    MSGNAME_ENTRY(BL_SETITEMDATA),
    MSGNAME_ENTRY(BL_SETTOPINDEX),
    MSGNAME_ENTRY(BL_MSGMAX),
};


//-----------------------------------------------------------------------------
// Trackbar Control Messages
MSGNAME rgMsgNameTBM[] = 
{
    MSGNAME_ENTRY(TBM_GETPOS),
    MSGNAME_ENTRY(TBM_GETRANGEMIN),
    MSGNAME_ENTRY(TBM_GETRANGEMAX),
    MSGNAME_ENTRY(TBM_GETTIC),
    MSGNAME_ENTRY(TBM_SETTIC),
    MSGNAME_ENTRY(TBM_SETPOS),
    MSGNAME_ENTRY(TBM_SETRANGE),
    MSGNAME_ENTRY(TBM_SETRANGEMIN),
    MSGNAME_ENTRY(TBM_SETRANGEMAX),
    MSGNAME_ENTRY(TBM_CLEARTICS),
    MSGNAME_ENTRY(TBM_SETSEL),
    MSGNAME_ENTRY(TBM_SETSELSTART),
    MSGNAME_ENTRY(TBM_SETSELEND),
    MSGNAME_ENTRY(TBM_GETPTICS),
    MSGNAME_ENTRY(TBM_GETTICPOS),
    MSGNAME_ENTRY(TBM_GETNUMTICS),
    MSGNAME_ENTRY(TBM_GETSELSTART),
    MSGNAME_ENTRY(TBM_GETSELEND),
    MSGNAME_ENTRY(TBM_CLEARSEL),
    MSGNAME_ENTRY(TBM_SETTICFREQ),
    MSGNAME_ENTRY(TBM_SETPAGESIZE),
    MSGNAME_ENTRY(TBM_GETPAGESIZE),
    MSGNAME_ENTRY(TBM_SETLINESIZE),
    MSGNAME_ENTRY(TBM_GETLINESIZE),
    MSGNAME_ENTRY(TBM_GETTHUMBRECT),
    MSGNAME_ENTRY(TBM_GETCHANNELRECT),
    MSGNAME_ENTRY(TBM_SETTHUMBLENGTH),
    MSGNAME_ENTRY(TBM_GETTHUMBLENGTH),
    MSGNAME_ENTRY(TBM_SETTOOLTIPS),
    MSGNAME_ENTRY(TBM_GETTOOLTIPS),
    MSGNAME_ENTRY(TBM_SETTIPSIDE),
    MSGNAME_ENTRY(TBM_SETBUDDY),
    MSGNAME_ENTRY(TBM_GETBUDDY),
};


//-----------------------------------------------------------------------------
// DragList Control Messages
MSGNAME rgMsgNameDL[] = 
{
    MSGNAME_ENTRY(DL_BEGINDRAG),
    MSGNAME_ENTRY(DL_DRAGGING),
    MSGNAME_ENTRY(DL_DROPPED),
    MSGNAME_ENTRY(DL_CANCELDRAG),
};


//-----------------------------------------------------------------------------
// UpDown Control Messages
MSGNAME rgMsgNameUDM[] = 
{
    MSGNAME_ENTRY(UDM_SETRANGE),
    MSGNAME_ENTRY(UDM_GETRANGE),
    MSGNAME_ENTRY(UDM_SETPOS),
    MSGNAME_ENTRY(UDM_GETPOS),
    MSGNAME_ENTRY(UDM_SETBUDDY),
    MSGNAME_ENTRY(UDM_GETBUDDY),
    MSGNAME_ENTRY(UDM_SETACCEL),
    MSGNAME_ENTRY(UDM_GETACCEL),
    MSGNAME_ENTRY(UDM_SETBASE),
    MSGNAME_ENTRY(UDM_GETBASE),
    MSGNAME_ENTRY(UDM_SETRANGE32),
    MSGNAME_ENTRY(UDM_GETRANGE32),
    MSGNAME_ENTRY(UDM_SETPOS32),
    MSGNAME_ENTRY(UDM_GETPOS32),
};


//-----------------------------------------------------------------------------
// Progress Control Messages
MSGNAME rgMsgNamePBM[] = 
{
    MSGNAME_ENTRY(PBM_SETRANGE),
    MSGNAME_ENTRY(PBM_SETPOS),
    MSGNAME_ENTRY(PBM_DELTAPOS),
    MSGNAME_ENTRY(PBM_SETSTEP),
    MSGNAME_ENTRY(PBM_STEPIT),
    MSGNAME_ENTRY(PBM_SETRANGE32),
    MSGNAME_ENTRY(PBM_GETRANGE),
    MSGNAME_ENTRY(PBM_GETPOS),
    MSGNAME_ENTRY(PBM_SETBARCOLOR),
    MSGNAME_ENTRY(PBM_SETMARQUEE),
};


//-----------------------------------------------------------------------------
// Hotkey Control Messages
MSGNAME rgMsgNameHKM[] = 
{
    MSGNAME_ENTRY(HKM_SETHOTKEY),
    MSGNAME_ENTRY(HKM_GETHOTKEY),
    MSGNAME_ENTRY(HKM_SETRULES),
};


//-----------------------------------------------------------------------------
// Listview Control Messages
MSGNAME rgMsgNameLVM[] = 
{
    MSGNAME_ENTRY(LVM_GETBKCOLOR),
    MSGNAME_ENTRY(LVM_SETBKCOLOR),
    MSGNAME_ENTRY(LVM_GETIMAGELIST),
    MSGNAME_ENTRY(LVM_SETIMAGELIST),
    MSGNAME_ENTRY(LVM_GETITEMCOUNT),
    MSGNAME_ENTRY(LVM_GETITEMA),
    MSGNAME_ENTRY(LVM_GETITEMW),
    MSGNAME_ENTRY(LVM_SETITEMA),
    MSGNAME_ENTRY(LVM_SETITEMW),
    MSGNAME_ENTRY(LVM_INSERTITEMA),
    MSGNAME_ENTRY(LVM_INSERTITEMW),
    MSGNAME_ENTRY(LVM_DELETEITEM),
    MSGNAME_ENTRY(LVM_DELETEALLITEMS),
    MSGNAME_ENTRY(LVM_GETCALLBACKMASK),
    MSGNAME_ENTRY(LVM_SETCALLBACKMASK),
    MSGNAME_ENTRY(LVM_GETNEXTITEM),
    MSGNAME_ENTRY(LVM_FINDITEMA),
    MSGNAME_ENTRY(LVM_FINDITEMW),
    MSGNAME_ENTRY(LVM_GETITEMRECT),
    MSGNAME_ENTRY(LVM_SETITEMPOSITION),
    MSGNAME_ENTRY(LVM_GETITEMPOSITION),
    MSGNAME_ENTRY(LVM_GETSTRINGWIDTHA),
    MSGNAME_ENTRY(LVM_GETSTRINGWIDTHW),
    MSGNAME_ENTRY(LVM_HITTEST),
    MSGNAME_ENTRY(LVM_ENSUREVISIBLE),
    MSGNAME_ENTRY(LVM_SCROLL),
    MSGNAME_ENTRY(LVM_REDRAWITEMS),
    MSGNAME_ENTRY(LVM_ARRANGE),
    MSGNAME_ENTRY(LVM_EDITLABELA),
    MSGNAME_ENTRY(LVM_EDITLABELW),
    MSGNAME_ENTRY(LVM_GETEDITCONTROL),
    MSGNAME_ENTRY(LVM_GETCOLUMNA),
    MSGNAME_ENTRY(LVM_GETCOLUMNW),
    MSGNAME_ENTRY(LVM_SETCOLUMNA),
    MSGNAME_ENTRY(LVM_SETCOLUMNW),
    MSGNAME_ENTRY(LVM_INSERTCOLUMNA),
    MSGNAME_ENTRY(LVM_INSERTCOLUMNW),
    MSGNAME_ENTRY(LVM_DELETECOLUMN),
    MSGNAME_ENTRY(LVM_GETCOLUMNWIDTH),
    MSGNAME_ENTRY(LVM_SETCOLUMNWIDTH),
    MSGNAME_ENTRY(LVM_GETHEADER),
    MSGNAME_ENTRY(LVM_CREATEDRAGIMAGE),
    MSGNAME_ENTRY(LVM_GETVIEWRECT),
    MSGNAME_ENTRY(LVM_GETTEXTCOLOR),
    MSGNAME_ENTRY(LVM_SETTEXTCOLOR),
    MSGNAME_ENTRY(LVM_GETTEXTBKCOLOR),
    MSGNAME_ENTRY(LVM_SETTEXTBKCOLOR),
    MSGNAME_ENTRY(LVM_GETTOPINDEX),
    MSGNAME_ENTRY(LVM_GETCOUNTPERPAGE),
    MSGNAME_ENTRY(LVM_GETORIGIN),
    MSGNAME_ENTRY(LVM_UPDATE),
    MSGNAME_ENTRY(LVM_SETITEMSTATE),
    MSGNAME_ENTRY(LVM_GETITEMSTATE),
    MSGNAME_ENTRY(LVM_GETITEMTEXTA),
    MSGNAME_ENTRY(LVM_GETITEMTEXTW),
    MSGNAME_ENTRY(LVM_SETITEMTEXTA),
    MSGNAME_ENTRY(LVM_SETITEMTEXTW),
    MSGNAME_ENTRY(LVM_SETITEMCOUNT),
    MSGNAME_ENTRY(LVM_SORTITEMS),
    MSGNAME_ENTRY(LVM_SETITEMPOSITION32),
    MSGNAME_ENTRY(LVM_GETSELECTEDCOUNT),
    MSGNAME_ENTRY(LVM_GETITEMSPACING),
    MSGNAME_ENTRY(LVM_GETISEARCHSTRINGA),
    MSGNAME_ENTRY(LVM_GETISEARCHSTRINGW),
    MSGNAME_ENTRY(LVM_SETICONSPACING),
    MSGNAME_ENTRY(LVM_SETEXTENDEDLISTVIEWSTYLE),
    MSGNAME_ENTRY(LVM_GETEXTENDEDLISTVIEWSTYLE),
    MSGNAME_ENTRY(LVM_GETSUBITEMRECT),
    MSGNAME_ENTRY(LVM_SUBITEMHITTEST),
    MSGNAME_ENTRY(LVM_SETCOLUMNORDERARRAY),
    MSGNAME_ENTRY(LVM_GETCOLUMNORDERARRAY),
    MSGNAME_ENTRY(LVM_SETHOTITEM),
    MSGNAME_ENTRY(LVM_GETHOTITEM),
    MSGNAME_ENTRY(LVM_SETHOTCURSOR),
    MSGNAME_ENTRY(LVM_GETHOTCURSOR),
    MSGNAME_ENTRY(LVM_APPROXIMATEVIEWRECT),
    MSGNAME_ENTRY(LVM_SETWORKAREAS),
    MSGNAME_ENTRY(LVM_GETWORKAREAS),
    MSGNAME_ENTRY(LVM_GETNUMBEROFWORKAREAS),
    MSGNAME_ENTRY(LVM_GETSELECTIONMARK),
    MSGNAME_ENTRY(LVM_SETSELECTIONMARK),
    MSGNAME_ENTRY(LVM_SETHOVERTIME),
    MSGNAME_ENTRY(LVM_GETHOVERTIME),
    MSGNAME_ENTRY(LVM_SETTOOLTIPS),
    MSGNAME_ENTRY(LVM_GETTOOLTIPS),
    MSGNAME_ENTRY(LVM_GETHOTLIGHTCOLOR),
    MSGNAME_ENTRY(LVM_SETHOTLIGHTCOLOR),
    MSGNAME_ENTRY(LVM_SORTITEMSEX),
    MSGNAME_ENTRY(LVM_SETBKIMAGEA),
    MSGNAME_ENTRY(LVM_SETBKIMAGEW),
    MSGNAME_ENTRY(LVM_GETBKIMAGEA),
    MSGNAME_ENTRY(LVM_GETBKIMAGEW),
    MSGNAME_ENTRY(LVM_SETSELECTEDCOLUMN),
    MSGNAME_ENTRY(LVM_SETTILEWIDTH),
    MSGNAME_ENTRY(LVM_SETVIEW),
    MSGNAME_ENTRY(LVM_GETVIEW),
    MSGNAME_ENTRY(LVM_INSERTGROUP),
    MSGNAME_ENTRY(LVM_SETGROUPINFO),
    MSGNAME_ENTRY(LVM_GETGROUPINFO),
    MSGNAME_ENTRY(LVM_REMOVEGROUP),
    MSGNAME_ENTRY(LVM_MOVEGROUP),
    MSGNAME_ENTRY(LVM_MOVEITEMTOGROUP),
    MSGNAME_ENTRY(LVM_SETGROUPMETRICS),
    MSGNAME_ENTRY(LVM_GETGROUPMETRICS),
    MSGNAME_ENTRY(LVM_ENABLEGROUPVIEW),
    MSGNAME_ENTRY(LVM_SORTGROUPS),
    MSGNAME_ENTRY(LVM_INSERTGROUPSORTED),
    MSGNAME_ENTRY(LVM_REMOVEALLGROUPS),
    MSGNAME_ENTRY(LVM_HASGROUP),
    MSGNAME_ENTRY(LVM_SETTILEVIEWINFO),
    MSGNAME_ENTRY(LVM_GETTILEVIEWINFO),
    MSGNAME_ENTRY(LVM_SETTILEINFO),
    MSGNAME_ENTRY(LVM_GETTILEINFO),
    MSGNAME_ENTRY(LVM_SETINSERTMARK),
    MSGNAME_ENTRY(LVM_GETINSERTMARK),
    MSGNAME_ENTRY(LVM_INSERTMARKHITTEST),
    MSGNAME_ENTRY(LVM_GETINSERTMARKRECT),
    MSGNAME_ENTRY(LVM_SETINSERTMARKCOLOR),
    MSGNAME_ENTRY(LVM_GETINSERTMARKCOLOR),
    MSGNAME_ENTRY(LVM_SETINFOTIP),
    MSGNAME_ENTRY(LVM_GETSELECTEDCOLUMN),
    MSGNAME_ENTRY(LVM_ISGROUPVIEWENABLED),
    MSGNAME_ENTRY(LVM_GETOUTLINECOLOR),
    MSGNAME_ENTRY(LVM_SETOUTLINECOLOR),
    MSGNAME_ENTRY(LVM_KEYBOARDSELECTED),
    MSGNAME_ENTRY(LVM_CANCELEDITLABEL),
    MSGNAME_ENTRY(LVM_MAPINDEXTOID),
    MSGNAME_ENTRY(LVM_MAPIDTOINDEX),
    MSGNAME_ENTRY(LVM_ISITEMVISIBLE),
    MSGNAME_ENTRY(LVM_SETLVRANGEOBJECT),
    MSGNAME_ENTRY(LVM_RESETEMPTYTEXT),
    MSGNAME_ENTRY(LVM_SETFROZENITEM),
    MSGNAME_ENTRY(LVM_GETFROZENITEM),
    MSGNAME_ENTRY(LVM_SETFROZENSLOT),
    MSGNAME_ENTRY(LVM_GETFROZENSLOT),
    MSGNAME_ENTRY(LVM_SETVIEWMARGINS),
    MSGNAME_ENTRY(LVM_GETVIEWMARGINS),
};


//-----------------------------------------------------------------------------
// Treeview Control Messages
MSGNAME rgMsgNameTVM[] = 
{
    MSGNAME_ENTRY(TV_FINDITEM),

    MSGNAME_ENTRY(TVM_INSERTITEMA),
    MSGNAME_ENTRY(TVM_INSERTITEMW),
    MSGNAME_ENTRY(TVM_DELETEITEM),
    MSGNAME_ENTRY(TVM_EXPAND),
    MSGNAME_ENTRY(TVM_GETITEMRECT),
    MSGNAME_ENTRY(TVM_GETCOUNT),
    MSGNAME_ENTRY(TVM_GETINDENT),
    MSGNAME_ENTRY(TVM_SETINDENT),
    MSGNAME_ENTRY(TVM_GETIMAGELIST),
    MSGNAME_ENTRY(TVM_SETIMAGELIST),
    MSGNAME_ENTRY(TVM_GETNEXTITEM),
    MSGNAME_ENTRY(TVM_SELECTITEM),
    MSGNAME_ENTRY(TVM_GETITEMA),
    MSGNAME_ENTRY(TVM_GETITEMW),
    MSGNAME_ENTRY(TVM_SETITEMA),
    MSGNAME_ENTRY(TVM_SETITEMW),
    MSGNAME_ENTRY(TVM_EDITLABELA),
    MSGNAME_ENTRY(TVM_EDITLABELW),
    MSGNAME_ENTRY(TVM_GETEDITCONTROL),
    MSGNAME_ENTRY(TVM_GETVISIBLECOUNT),
    MSGNAME_ENTRY(TVM_HITTEST),
    MSGNAME_ENTRY(TVM_CREATEDRAGIMAGE),
    MSGNAME_ENTRY(TVM_SORTCHILDREN),
    MSGNAME_ENTRY(TVM_ENSUREVISIBLE),
    MSGNAME_ENTRY(TVM_SORTCHILDRENCB),
    MSGNAME_ENTRY(TVM_ENDEDITLABELNOW),
    MSGNAME_ENTRY(TVM_GETISEARCHSTRINGA),
    MSGNAME_ENTRY(TVM_GETISEARCHSTRINGW),
    MSGNAME_ENTRY(TVM_SETTOOLTIPS),
    MSGNAME_ENTRY(TVM_GETTOOLTIPS),
    MSGNAME_ENTRY(TVM_SETINSERTMARK),
    MSGNAME_ENTRY(TVM_SETITEMHEIGHT),
    MSGNAME_ENTRY(TVM_GETITEMHEIGHT),
    MSGNAME_ENTRY(TVM_SETBKCOLOR),
    MSGNAME_ENTRY(TVM_SETTEXTCOLOR),
    MSGNAME_ENTRY(TVM_GETBKCOLOR),
    MSGNAME_ENTRY(TVM_GETTEXTCOLOR),
    MSGNAME_ENTRY(TVM_SETSCROLLTIME),
    MSGNAME_ENTRY(TVM_GETSCROLLTIME),
    MSGNAME_ENTRY(TVM_SETBORDER),
    MSGNAME_ENTRY(TVM_GETBORDER),
    MSGNAME_ENTRY(TVM_SETINSERTMARKCOLOR),
    MSGNAME_ENTRY(TVM_GETINSERTMARKCOLOR),
    MSGNAME_ENTRY(TVM_GETITEMSTATE),
    MSGNAME_ENTRY(TVM_SETLINECOLOR),
    MSGNAME_ENTRY(TVM_GETLINECOLOR),
    MSGNAME_ENTRY(TVM_MAPACCIDTOHTREEITEM),
    MSGNAME_ENTRY(TVM_MAPHTREEITEMTOACCID),
    MSGNAME_ENTRY(TVM_SETEXTENDEDSTYLE),
    MSGNAME_ENTRY(TVM_GETEXTENDEDSTYLE),
};


//-----------------------------------------------------------------------------
// ComboBoxEx Control Messages
MSGNAME rgMsgNameCBEM[] = 
{
    MSGNAME_ENTRY(CBEM_INSERTITEMA),
    MSGNAME_ENTRY(CBEM_SETIMAGELIST),
    MSGNAME_ENTRY(CBEM_GETIMAGELIST),
    MSGNAME_ENTRY(CBEM_GETITEMA),
    MSGNAME_ENTRY(CBEM_SETITEMA),
    MSGNAME_ENTRY(CBEM_GETCOMBOCONTROL),
    MSGNAME_ENTRY(CBEM_GETEDITCONTROL),
    MSGNAME_ENTRY(CBEM_SETEXSTYLE),
    MSGNAME_ENTRY(CBEM_SETEXTENDEDSTYLE),
    MSGNAME_ENTRY(CBEM_GETEXSTYLE),
    MSGNAME_ENTRY(CBEM_GETEXTENDEDSTYLE),
    MSGNAME_ENTRY(CBEM_SETEXSTYLE),
    MSGNAME_ENTRY(CBEM_GETEXSTYLE),
    MSGNAME_ENTRY(CBEM_HASEDITCHANGED),
    MSGNAME_ENTRY(CBEM_INSERTITEMW),
    MSGNAME_ENTRY(CBEM_SETITEMW),
    MSGNAME_ENTRY(CBEM_GETITEMW),
};

//-----------------------------------------------------------------------------
// Tab Control Messages
MSGNAME rgMsgNameTCM[] = 
{
    MSGNAME_ENTRY(TCM_GETBKCOLOR),
    MSGNAME_ENTRY(TCM_SETBKCOLOR),
    MSGNAME_ENTRY(TCM_GETIMAGELIST),
    MSGNAME_ENTRY(TCM_SETIMAGELIST),
    MSGNAME_ENTRY(TCM_GETITEMCOUNT),
    MSGNAME_ENTRY(TCM_GETITEMA),
    MSGNAME_ENTRY(TCM_GETITEMW),
    MSGNAME_ENTRY(TCM_SETITEMA),
    MSGNAME_ENTRY(TCM_SETITEMW),
    MSGNAME_ENTRY(TCM_INSERTITEMA),
    MSGNAME_ENTRY(TCM_INSERTITEMW),
    MSGNAME_ENTRY(TCM_DELETEITEM),
    MSGNAME_ENTRY(TCM_DELETEALLITEMS),
    MSGNAME_ENTRY(TCM_GETITEMRECT),
    MSGNAME_ENTRY(TCM_GETCURSEL),
    MSGNAME_ENTRY(TCM_SETCURSEL),
    MSGNAME_ENTRY(TCM_HITTEST),
    MSGNAME_ENTRY(TCM_SETITEMEXTRA),
    MSGNAME_ENTRY(TCM_ADJUSTRECT),
    MSGNAME_ENTRY(TCM_SETITEMSIZE),
    MSGNAME_ENTRY(TCM_REMOVEIMAGE),
    MSGNAME_ENTRY(TCM_SETPADDING),
    MSGNAME_ENTRY(TCM_GETROWCOUNT),
    MSGNAME_ENTRY(TCM_GETTOOLTIPS),
    MSGNAME_ENTRY(TCM_SETTOOLTIPS),
    MSGNAME_ENTRY(TCM_GETCURFOCUS),
    MSGNAME_ENTRY(TCM_SETCURFOCUS),
    MSGNAME_ENTRY(TCM_SETMINTABWIDTH),
    MSGNAME_ENTRY(TCM_DESELECTALL),
    MSGNAME_ENTRY(TCM_HIGHLIGHTITEM),
    MSGNAME_ENTRY(TCM_SETEXTENDEDSTYLE),
    MSGNAME_ENTRY(TCM_GETEXTENDEDSTYLE),
    MSGNAME_ENTRY(TCM_GETOBJECT),
};


//-----------------------------------------------------------------------------
// Animate Control Messages
MSGNAME rgMsgNameACM[] = 
{
    MSGNAME_ENTRY(ACM_OPENA),
    MSGNAME_ENTRY(ACM_OPENW),
    MSGNAME_ENTRY(ACM_PLAY),
    MSGNAME_ENTRY(ACM_STOP),
};


//-----------------------------------------------------------------------------
// MonthCal Control Messages
MSGNAME rgMsgNameMCM[] = 
{
    MSGNAME_ENTRY(MCM_FIRST),
    MSGNAME_ENTRY(MCM_GETCURSEL),
    MSGNAME_ENTRY(MCM_SETCURSEL),
    MSGNAME_ENTRY(MCM_GETMAXSELCOUNT),
    MSGNAME_ENTRY(MCM_SETMAXSELCOUNT),
    MSGNAME_ENTRY(MCM_GETSELRANGE),
    MSGNAME_ENTRY(MCM_SETSELRANGE),
    MSGNAME_ENTRY(MCM_GETMONTHRANGE),
    MSGNAME_ENTRY(MCM_SETDAYSTATE),
    MSGNAME_ENTRY(MCM_GETMINREQRECT),
    MSGNAME_ENTRY(MCM_SETCOLOR),
    MSGNAME_ENTRY(MCM_GETCOLOR),
    MSGNAME_ENTRY(MCM_SETTODAY),
    MSGNAME_ENTRY(MCM_GETTODAY),
    MSGNAME_ENTRY(MCM_HITTEST),
    MSGNAME_ENTRY(MCM_SETFIRSTDAYOFWEEK),
    MSGNAME_ENTRY(MCM_GETFIRSTDAYOFWEEK),
    MSGNAME_ENTRY(MCM_GETRANGE),
    MSGNAME_ENTRY(MCM_SETRANGE),
    MSGNAME_ENTRY(MCM_GETMONTHDELTA),
    MSGNAME_ENTRY(MCM_SETMONTHDELTA),
    MSGNAME_ENTRY(MCM_GETMAXTODAYWIDTH),
};

//-----------------------------------------------------------------------------
// DateTimePicker Control Messages
MSGNAME rgMsgNameDTM[] = 
{
    MSGNAME_ENTRY(DTM_FIRST),
    MSGNAME_ENTRY(DTM_GETSYSTEMTIME),
    MSGNAME_ENTRY(DTM_SETSYSTEMTIME),
    MSGNAME_ENTRY(DTM_GETRANGE),
    MSGNAME_ENTRY(DTM_SETRANGE),
    MSGNAME_ENTRY(DTM_SETFORMATA),
    MSGNAME_ENTRY(DTM_SETFORMATW),
    MSGNAME_ENTRY(DTM_SETMCCOLOR),
    MSGNAME_ENTRY(DTM_GETMCCOLOR),
    MSGNAME_ENTRY(DTM_GETMONTHCAL),
    MSGNAME_ENTRY(DTM_SETMCFONT),
    MSGNAME_ENTRY(DTM_GETMCFONT),
};


//-----------------------------------------------------------------------------
// IP Address Control Messages
MSGNAME rgMsgNameIPM[] = 
{
    MSGNAME_ENTRY(IPM_CLEARADDRESS),
    MSGNAME_ENTRY(IPM_SETADDRESS),
    MSGNAME_ENTRY(IPM_GETADDRESS),
    MSGNAME_ENTRY(IPM_SETRANGE),
    MSGNAME_ENTRY(IPM_SETFOCUS),
    MSGNAME_ENTRY(IPM_ISBLANK),
};


//-----------------------------------------------------------------------------
// Pager Control Messages
MSGNAME rgMsgNamePGM[] = 
{
    MSGNAME_ENTRY(PGM_SETCHILD),
    MSGNAME_ENTRY(PGM_RECALCSIZE),
    MSGNAME_ENTRY(PGM_FORWARDMOUSE),
    MSGNAME_ENTRY(PGM_SETBKCOLOR),
    MSGNAME_ENTRY(PGM_GETBKCOLOR),
    MSGNAME_ENTRY(PGM_SETBORDER),
    MSGNAME_ENTRY(PGM_GETBORDER),
    MSGNAME_ENTRY(PGM_SETPOS),
    MSGNAME_ENTRY(PGM_GETPOS),
    MSGNAME_ENTRY(PGM_SETBUTTONSIZE),
    MSGNAME_ENTRY(PGM_GETBUTTONSIZE),
    MSGNAME_ENTRY(PGM_GETBUTTONSTATE),
    MSGNAME_ENTRY(PGM_SETSCROLLINFO),
};


//-----------------------------------------------------------------------------
// Button Control Messages
MSGNAME rgMsgNameBCM[] = 
{
    MSGNAME_ENTRY(BCM_GETIDEALSIZE),
    MSGNAME_ENTRY(BCM_SETIMAGELIST),
    MSGNAME_ENTRY(BCM_GETIMAGELIST),
    MSGNAME_ENTRY(BCM_SETTEXTMARGIN),
    MSGNAME_ENTRY(BCM_GETTEXTMARGIN),
};


//-----------------------------------------------------------------------------
// Edit Control Messages
MSGNAME rgMsgNameEM[] = 
{
    MSGNAME_ENTRY(EM_SETCUEBANNER),
    MSGNAME_ENTRY(EM_GETCUEBANNER),
    MSGNAME_ENTRY(EM_SHOWBALLOONTIP),
    MSGNAME_ENTRY(EM_HIDEBALLOONTIP),
};


//-----------------------------------------------------------------------------
// Combobox Control Messages
MSGNAME rgMsgNameCB[] = 
{
    MSGNAME_ENTRY(CB_SETMINVISIBLE),
    MSGNAME_ENTRY(CB_GETMINVISIBLE),
};


//-----------------------------------------------------------------------------
// Link Window Control Messages
MSGNAME rgMsgNameLM[] = 
{
    MSGNAME_ENTRY(LM_HITTEST),
    MSGNAME_ENTRY(LM_GETIDEALHEIGHT),
    MSGNAME_ENTRY(LM_SETITEM),
    MSGNAME_ENTRY(LM_GETITEM),
};


MSGMAP rgMsgMap[] = 
{
    { "ComCtl32",          "ComCtl32",       rgMsgNameCCM,  ARRAYSIZE(rgMsgNameCCM)  },
    { WC_HEADERA,          "Header",         rgMsgNameHDM,  ARRAYSIZE(rgMsgNameHDM)  },
    { TOOLBARCLASSNAMEA,   "Toolbar",        rgMsgNameTB,   ARRAYSIZE(rgMsgNameTB)   },
    { REBARCLASSNAMEA,     "Rebar",          rgMsgNameRB,   ARRAYSIZE(rgMsgNameRB)   },
    { TOOLTIPS_CLASSA,     "Tooltips",       rgMsgNameTTM,  ARRAYSIZE(rgMsgNameTTM)  },
    { STATUSCLASSNAMEA,    "Status",         rgMsgNameSB,   ARRAYSIZE(rgMsgNameSB)   },
    { BUTTONLISTBOX,       BUTTONLISTBOX,    rgMsgNameBL,   ARRAYSIZE(rgMsgNameBL)   },
    { TRACKBAR_CLASSA,     "TrackBar",       rgMsgNameTBM,  ARRAYSIZE(rgMsgNameTBM)  },
    { "DragList",          "Draglist",       rgMsgNameDL,   ARRAYSIZE(rgMsgNameDL)   },
    { UPDOWN_CLASSA,       "UpDown",         rgMsgNameUDM,  ARRAYSIZE(rgMsgNameUDM)  },
    { PROGRESS_CLASSA,     "Progress",       rgMsgNamePBM,  ARRAYSIZE(rgMsgNamePBM)  },
    { HOTKEY_CLASSA,       "Hotkey",         rgMsgNameHKM,  ARRAYSIZE(rgMsgNameHKM)  },
    { WC_LISTVIEWA,        "Listview",       rgMsgNameLVM,  ARRAYSIZE(rgMsgNameLVM)  },
    { WC_TREEVIEWA,        "Treeview",       rgMsgNameTVM,  ARRAYSIZE(rgMsgNameTVM)  },
    { WC_COMBOBOXEXA,      "ComboboxEx",     rgMsgNameCBEM, ARRAYSIZE(rgMsgNameCBEM) },
    { WC_TABCONTROLA,      "Tab",            rgMsgNameTCM,  ARRAYSIZE(rgMsgNameTCM)  },
    { ANIMATE_CLASSA,      "Animate",        rgMsgNameACM,  ARRAYSIZE(rgMsgNameACM)  },
    { MONTHCAL_CLASSA,     "MonthCal",       rgMsgNameMCM,  ARRAYSIZE(rgMsgNameMCM)  },
    { DATETIMEPICK_CLASSA, "DateTimePicker", rgMsgNameDTM,  ARRAYSIZE(rgMsgNameDTM)  },
    { WC_IPADDRESSA,       "IPAddress",      rgMsgNameIPM,  ARRAYSIZE(rgMsgNameIPM)  },
    { WC_PAGESCROLLERA,    "Pager",          rgMsgNamePGM,  ARRAYSIZE(rgMsgNamePGM)  },
    { WC_BUTTONA,          WC_BUTTONA,       rgMsgNameBCM,  ARRAYSIZE(rgMsgNameBCM)  },
    { WC_EDITA,            WC_EDITA,         rgMsgNameEM,   ARRAYSIZE(rgMsgNameEM)   },
    { WC_COMBOBOXA,        WC_COMBOBOXA,     rgMsgNameCB,   ARRAYSIZE(rgMsgNameCB)   },
    { "SysLink",           "SysLink",        rgMsgNameLM,   ARRAYSIZE(rgMsgNameLM)   },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\shlexts\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <excpt.h>
#include <stdio.h>
#include <limits.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <string.h>
#include <ntstatus.h>
#include <windows.h>
#include <ntddvdeo.h>

#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <commdlg.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#ifndef FIELDOFFSET
#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)   (sizeof(x)/sizeof(x[0]))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\shlexts\pidlcmds.cpp ===
#include "precomp.h"
#pragma hdrstop

#include "shguidp.h"
#include "..\..\shell32\pidl.h"
#include "..\..\shell32\shitemid.h"

// We never want assertions since we are the debugger extension!
#undef DBG
#undef DEBUG
#include "..\..\lib\idhidden.cpp"

extern "C"
{
#include <stdexts.h>
};

UNALIGNED WCHAR * ua_lstrcpyW(UNALIGNED WCHAR * dst, UINT cchDest, UNALIGNED const WCHAR * src)
{
    UNALIGNED WCHAR * cp = dst;

    if (cchDest == 0)
        return dst;

    while( cchDest )
    {
        WCHAR ch = *src++;

        *cp++ = ch;

        if (ch == TEXT('\0'))
        {
            break;
        }
        --cchDest;
    }

    if (cchDest == 0)
    {
        --cp;
        *cp = TEXT('\0');
    }

    return( dst );
}

///////////////////////////////////////////////////////////////////////////////
// Pidl Cracking function                                                    //
//                                                                           //
// returns fSuccess                                                          //
//                                                                           //
// History:                                                                  //
//     11/4/97 Created by cdturner                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// NOTE: the options are autovalidate before they are passed to us

typedef enum _PidlTypes
{
    PIDL_UNKNOWN,
    PIDL_ROOT,
    PIDL_FILESYS,
    PIDL_DRIVES,
    PIDL_NET,
    PIDL_INTERNET,
    PIDL_FAVORITES
} PIDLTYPE;

#define PIDL_BUFFER_SIZE    400

class CPidlBreaker
{
    public:
    
        CPidlBreaker( LPVOID pArg );
        ~CPidlBreaker( );

        void SetVerbose() {_fVerbose = TRUE;};

        VOID SetType( PIDLTYPE eType );
        BOOL FillBuffer( DWORD cbSize, BOOL fAppend );
        VOID ResetBuffer( void );

        WORD FetchWord();
        DWORD FetchDWORD();
        LPBYTE GetBuffer( int iPos = 0);

        PIDLTYPE CrackType( BYTE bType );
        void PrintType( PIDLTYPE eType );
        
        BOOL PrintPidl();
        BOOL PrintRootPidl();
        BOOL PrintDrivePidl();
        BOOL PrintFileSysPidl();
        BOOL PrintInternetPidl();
        BOOL PrintNetworkPidl();

        BOOL GetSHIDFlags( BYTE bFlags, CHAR * pszBuffer, DWORD cchSize );

        void CLSIDToString( CHAR * pszBuffer, DWORD cchSize, REFCLSID rclsid );

        BOOL GetCLSIDText( const CHAR * pszCLSID, CHAR * pszBuffer, DWORD cbSize );
        
    private:
        PIDLTYPE _eType;
        LPVOID _pArg;
        BYTE _rgBuffer[PIDL_BUFFER_SIZE];
        int _iCurrent;
        int _iMax;
        BOOL _fVerbose;

        // used to display slashes right when we are not in verbose mode...
        BOOL _fSlash;
};

extern "C" BOOL Ipidl( DWORD dwOpts,
                       LPVOID pArg )
{
    PIDLTYPE eType = PIDL_UNKNOWN;

    CPidlBreaker Breaker( pArg );
    
    if ( dwOpts & OFLAG(r))
    {
        Breaker.SetType( PIDL_ROOT );
    }
    else if ( dwOpts & OFLAG(f))
    {
        Breaker.SetType( PIDL_FILESYS );
    }

    if (dwOpts & OFLAG(v))
    {
        Breaker.SetVerbose();
    }

    BOOL bRes = FALSE;
    __try
    {
        bRes = Breaker.PrintPidl();
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        Print( "Exception caught in !pidl\n");
    }

    if ( !(dwOpts & OFLAG(v)) )
        Print( "\n" );
    
    return bRes;
}

VOID CPidlBreaker::SetType( PIDLTYPE eType )
{
    _eType = eType;
}

CPidlBreaker::CPidlBreaker( LPVOID pArg )
{
    _pArg = pArg;
    _iCurrent = 0;
    _iMax = 0;
    _eType = PIDL_UNKNOWN;
    _fVerbose = FALSE;
    _fSlash = FALSE;
}

CPidlBreaker::~CPidlBreaker( )
{
}

BOOL CPidlBreaker::FillBuffer( DWORD cbSize, BOOL fAppend )
{
    if ( !fAppend )
    {
        _iCurrent = 0;
        _iMax = 0;
    }

    int iStart = fAppend ? _iMax : 0;

    if ( cbSize + iStart > PIDL_BUFFER_SIZE )
    {
        return FALSE;
    }

#ifdef DEBUG
    char szBuffer[50];
    StringCchPrintf( szBuffer, ARRAYSIZE(szBuffer), "****Moving %d from %8X\n", cbSize, _pArg );
    Print( szBuffer );
#endif
    
    if ( tryMoveBlock( _rgBuffer + iStart, _pArg, cbSize ))
    {

#ifdef DEBUG
        for ( int iByte = 0; iByte < (int) cbSize; iByte ++ )
        {
            StringCchPrintf( szBuffer, ARRAYSIZE(szBuffer), "Byte %2x\n", _rgBuffer[iByte + iStart] );
            Print( szBuffer );
        }
#endif

        _pArg = (LPBYTE) _pArg + cbSize;
        _iMax += cbSize;

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

WORD CPidlBreaker::FetchWord()
{
    // assume that the buffer has been filled...
    if ( _iCurrent + 1 >= _iMax )
    {
        return 0;
    }
    
    WORD wRet = MAKEWORD( _rgBuffer[_iCurrent], _rgBuffer[_iCurrent + 1]);
    _iCurrent += 2;

#ifdef DEBUG
    char szBuffer[200];
    StringCchPrintf( szBuffer, ARRAYSIZE(szBuffer), "FetchWord() == %4X\n", wRet );
    Print( szBuffer );
#endif
    
    return wRet;
}

DWORD CPidlBreaker::FetchDWORD()
{
    // assume that the buffer has been filled...
    if ( _iCurrent + 3 >= _iMax )
    {
        return 0;
    }
    
    DWORD dwRet = MAKELONG( MAKEWORD( _rgBuffer[_iCurrent], _rgBuffer[_iCurrent + 1]), 
                            MAKEWORD( _rgBuffer[_iCurrent + 2], _rgBuffer[_iCurrent + 3] ));
    _iCurrent += 4;

#ifdef DEBUG
    char szBuffer[200];
    StringCchPrintf(( szBuffer, ARRAYSIZE(szBuffer), "FetchDWord() == %8X\n", dwRet );
    Print( szBuffer );
#endif

    return dwRet;
    
}

LPBYTE CPidlBreaker::GetBuffer(int iPos)
{
    return _rgBuffer + _iCurrent + iPos;
}

VOID CPidlBreaker::ResetBuffer( )
{
    _iCurrent = 0;
    _iMax = 0;
}

BOOL CPidlBreaker::PrintRootPidl()
{
    CHAR szBuffer[200];
    
    if ( !FillBuffer( sizeof( WORD ), FALSE ))
    {
        Print( "ERROR Unable to get the pidl size\n");
        return FALSE;
    }
    

    // get the size of the first chunk
    WORD wSize = FetchWord();


    // root pidls always have the size field as 14 
    if ( wSize != sizeof( IDREGITEM ))
    {
        StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "Pidl Size %d seems bogus for a regitem\n", wSize );
        
        Print( szBuffer );
        return FALSE;
    }
    else
    {
        if ( !FillBuffer( wSize - sizeof(WORD) , TRUE ))
        {
            StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "Error: unable to access the data for the pidl of size %d\n", wSize );
            Print( szBuffer );
            return FALSE;
        }

        LPBYTE pBuf = GetBuffer(- ((int) sizeof(WORD)));
        char szBuffer2[200];

        if ( pBuf[2] != SHID_ROOT_REGITEM )
        {
            Print( "Pidl has incorrect flags, should have SHID_ROOT_REGITEM\n");
        }
        
        // now map it to a Root structure
        LPIDREGITEM pRegItem = (LPIDREGITEM) pBuf;

        GetSHIDFlags( pRegItem->bFlags, szBuffer2, ARRAYSIZE( szBuffer2 ));
        
        Print( "RegItem Pidl:\n");

        if ( _fVerbose )
        {
            StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "    bFlags = %d (%s)\n", pRegItem->bFlags, szBuffer2 );
            Print( szBuffer );
            StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "    bOrder = %d\n", pRegItem->bOrder );
            Print( szBuffer );
        }
        
        CHAR szCLSID[40];
        CLSIDToString( szCLSID, ARRAYSIZE( szCLSID ), pRegItem->clsid );

        StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "    CLSID = %s ", szCLSID );
        Print( szBuffer );

        if ( GetCLSIDText( szCLSID, szBuffer2 + 1, ARRAYSIZE( szBuffer2 ) -2))
        {
            szBuffer2[0] = '(';
            StringCchCatA( szBuffer2, ARRAYSIZE(szBuffer2), ")\n" );
            Print( szBuffer2 );
        }

        if ( _fVerbose )
            Print( "\n" );
        
        ResetBuffer();
        
        if ( pRegItem->clsid == CLSID_ShellNetwork )
        {
            PrintNetworkPidl();
        }
        else if ( pRegItem->clsid == CLSID_ShellInetRoot )
        {
            // internet root
            PrintInternetPidl();
        }
        else if ( pRegItem->clsid == CLSID_ShellDrives )
        {
            // file system pidls ...
            PrintDrivePidl();
        }
        else
        {
            // unknown pidl type ....
            Print( "unknown pidl type, can't crack any further\n");
        }
    }

    return TRUE;
}

void _SprintDosDateTime(LPSTR szBuffer, LPCSTR pszType, WORD wDate, WORD wTime)
{
    StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "    date/time %s = 0x%04x/%04x = %04d/%02d/%02d %02d:%02d:%02d\n",
             pszType,
             wDate, wTime,
             ((wDate & 0xFE00) >> 9)+1980,
              (wDate & 0x01E0) >> 5,
              (wDate & 0x001F) >> 0,
              (wTime & 0xF800) >> 11,
              (wTime & 0x07E0) >> 5,
              (wTime & 0x001F) << 1 );
}

BOOL CPidlBreaker::PrintFileSysPidl()
{
    CHAR szBuffer[200];
    CHAR szBuffer2[200];
    
    if ( !FillBuffer( sizeof( WORD ), FALSE ))
    {
        Print( "ERROR Unable to get the pidl size\n");
        return FALSE;
    }
    
    // get the size of the first chunk
    WORD wSize = FetchWord();

    if ( wSize == 0 )
    {
        // end of the pidl chain....
        return TRUE;
    }
    
    if ( !FillBuffer( wSize - sizeof(WORD) , TRUE ))
    {
        StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "Error: unable to access the data for the pidl of size %d\n", wSize );
        Print( szBuffer );
        return FALSE;
    }

    LPBYTE pBuf = GetBuffer(- ((int)sizeof(WORD)));

    if (( pBuf[2] & SHID_FS ) != SHID_FS )
    {
        StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "Error, Unknown Pidl flag, use !db %8X\n", (DWORD_PTR) _pArg - wSize);
        Print( szBuffer );
        return FALSE;
    }
    if ((( pBuf[2] & SHID_FS_UNICODE ) == SHID_FS_UNICODE ) && wSize > sizeof( IDFOLDER ) )
    {
        StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "Error, size to big for a UNICODE FileSys Pidl, use !db %8X\n", (DWORD_PTR) _pArg - wSize);
        Print( szBuffer );
        return FALSE;
    }
    if ((( pBuf[2] & SHID_FS_UNICODE) != SHID_FS_UNICODE ) && wSize > sizeof( IDFOLDER ))
    {
        StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "Error, size to big for a ANSI FileSys Pidl, use !db %8X\n", (DWORD_PTR) _pArg - wSize);
        Print( szBuffer );
        return FALSE;
    }

    if ( _fVerbose )
        Print("FileSystem pidl:\n");
    
    LPIDFOLDER pItem = (LPIDFOLDER) pBuf;

    if ( _fVerbose )
    {
        GetSHIDFlags( pItem->bFlags, szBuffer2, ARRAYSIZE( szBuffer2));
        StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "    bFlags = %d (%s)\n", pItem->bFlags, szBuffer2 );
        Print( szBuffer );

        StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "    dwSize = %d,\tattrs = 0x%X\n", pItem->dwSize, pItem->wAttrs );
        Print( szBuffer );

        _SprintDosDateTime(szBuffer, "modified", pItem->dateModified, pItem->timeModified);
        Print( szBuffer );
    }

    BOOL fPathShown = FALSE;

    PIDFOLDEREX pidlx = (PIDFOLDEREX)ILFindHiddenIDOn((LPITEMIDLIST)pBuf, IDLHID_IDFOLDEREX, FALSE);
    if (pidlx && pidlx->hid.cb >= sizeof(IDFOLDEREX))
    {
        LPBYTE pbMax = pBuf + wSize;

        if (_fVerbose)
        {
            _SprintDosDateTime(szBuffer, "created", pidlx->dsCreate.wDate, pidlx->dsCreate.wTime);
            Print(szBuffer);

            _SprintDosDateTime(szBuffer, "accessed", pidlx->dsAccess.wDate, pidlx->dsAccess.wTime);
            Print(szBuffer);

            if (pidlx->offResourceA)
            {
                LPSTR pszResourceA = (LPSTR)pidlx + pidlx->offResourceA;
                if ((LPBYTE)pszResourceA < pbMax)
                {
                    Print("    MUI = ");
                    Print(pszResourceA);
                    Print("\n");
                }
            }
        }

        // Do a "cheap" UnicodeToAnsi because
        //
        //  1. There's really no point in getting it right, since there
        //     is no guarantee that the debugger is running the same
        //     codepage as the app, and...
        //  2. The string is unaligned so we have to walk it manually anyway.
        //
        if (pidlx->offNameW)
        {
            LPBYTE pbName = (LPBYTE)pidlx + pidlx->offNameW;
            int i = 0;
            while (pbName < pbMax && *pbName && i < ARRAYSIZE(szBuffer2) - 1)
            {
                szBuffer2[i++] = *pbName;
                pbName += 2;
            }
            szBuffer2[i] = TEXT('\0');
        }

        if (_fVerbose)
        {
            Print("    NameW = ");
            Print(szBuffer2);
            Print("\n");
        }
        else
        {
            fPathShown = TRUE;
            if ( !_fSlash )
                Print( "\\" );

            Print( szBuffer2 );
        }

    }


    if (( pItem->bFlags & SHID_FS_UNICODE ) == SHID_FS_UNICODE )
    {
        WCHAR szTemp[MAX_PATH];

        ua_lstrcpyW( szTemp, ARRAYSIZE(szTemp), (LPCWSTR)pItem->cFileName );
        
        WideCharToMultiByte( CP_ACP, 0, szTemp, -1, szBuffer2, ARRAYSIZE( szBuffer2 ) * sizeof(CHAR), 0 ,0 );

        if ( _fVerbose )
        {
            StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "    cFileName = %s\n", szBuffer2 );
            Print( szBuffer );
        }
        else if (!fPathShown)
        {
            fPathShown = TRUE;
            if ( !_fSlash )
                Print( "\\" );

            Print( szBuffer2 );
        }
    }
    else
    {
        // assume to be ansi ...
        if ( _fVerbose )
        {
            StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "    cFileName = %s\n", pItem->cFileName);
            Print( szBuffer );
        }
        else if (!fPathShown)
        {
            fPathShown = TRUE;
            if ( !_fSlash )
                Print( "\\" );

            Print( pItem->cFileName );
        }

        if ( _fVerbose )
        {
            int cLen = lstrlenA( pItem->cFileName);
            
            StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "    cAltName = %s\n", pItem->cFileName + cLen + 1);
            Print( szBuffer );
        }
    }

    if ( pItem->bFlags & SHID_JUNCTION )
    {
         // it is a junction point, so the CLASSID is tagged on the end

         /*[TODO]*/
    }

    _fSlash = FALSE;
    
    ResetBuffer();
    
    PrintFileSysPidl();
    return TRUE;
}

BOOL CPidlBreaker::PrintPidl()
{
    if ( _eType == PIDL_UNKNOWN )
    {
        LPVOID pPrevArg = _pArg;
        // check the 3rd byte in, it might be a SHID value...
        if ( !FillBuffer(3, FALSE ))
        {
            Print( "Unable to access the memory\n");
            return FALSE;
        }

        LPBYTE pBuf = GetBuffer();

        _eType = CrackType( pBuf[2] );

        ResetBuffer();
        _pArg = pPrevArg;
    }

    PrintType( _eType );
    return TRUE;
}

BOOL CPidlBreaker::PrintInternetPidl()
{
    return TRUE;
}

BOOL CPidlBreaker::PrintNetworkPidl()
{
    return TRUE;
}

BOOL CPidlBreaker::PrintDrivePidl()
{
    CHAR szBuffer[200];
    CHAR szBuffer2[200];
    
    if ( !FillBuffer( sizeof( WORD ), FALSE ))
    {
        Print( "ERROR Unable to get the pidl size\n");
        return FALSE;
    }
    
    // get the size of the first chunk
    WORD wSize = FetchWord();

    if ( wSize == 0 )
    {
        return TRUE;
    }
    
    if ( !FillBuffer( wSize - sizeof(WORD) , TRUE ))
    {
        StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "Error: unable to access the data for the pidl of size %d\n", wSize );
        Print( szBuffer );
        return FALSE;
    }

    LPBYTE pBuf = GetBuffer(- ((int)sizeof(WORD)));
    
    // need to check to see if it is an IDDrive structure or a regitem ....
    if ( wSize == sizeof( IDDRIVE ) || wSize == FIELD_OFFSET(IDDRIVE, clsid) )
    {
        // must be a drive structure....
        if ( _fVerbose )
            Print( "(My Computer) Drives Pidl:\n");
        else
            Print( "Path = ");

        LPIDDRIVE pDriveItem = (LPIDDRIVE) pBuf;

        if ( _fVerbose )
        {
            GetSHIDFlags( pDriveItem->bFlags, szBuffer2, ARRAYSIZE( szBuffer2 ));
            StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "    bFlags = %d (%s)\n", pDriveItem->bFlags, szBuffer2 );
            Print( szBuffer );
            
            StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "    cName = %s\n", pDriveItem->cName );
            Print( szBuffer );
            
            StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "    qwSize = 0x%lX\tqwFree = 0x%lX\n", pDriveItem->qwSize, pDriveItem->qwFree );
            Print( szBuffer );
            StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "    wSig = 0x%X\n\n", pDriveItem->wSig);
            Print( szBuffer );
            if ( wSize == sizeof( IDDRIVE ) )
            {
                CHAR szCLSID[40];
                CLSIDToString( szCLSID, ARRAYSIZE( szCLSID ), pDriveItem->clsid  );
                StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "    CLSID = %s ", szCLSID );
                Print( szBuffer );
            }
        }
        else
            Print( pDriveItem->cName );

        // coming from a drive, we already have a slash at the start
        _fSlash = TRUE;
        
        // assume the next pidl is a standard file-sys one...
        PrintFileSysPidl();
    }
    else if ( wSize == sizeof( IDREGITEM ))
    {
        // must be a reg item like control panel or printers...

        Print( "Drives (My Computer) RegItem Pidl\n");
        
        if ( pBuf[2] != SHID_COMPUTER_REGITEM )
        {
            Print( "Pidl has incorrect flags, should have SHID_ROOT_REGITEM\n");
        }
        
        // now map it to a Root structure
        LPIDREGITEM pRegItem = (LPIDREGITEM) pBuf;

        GetSHIDFlags( pRegItem->bFlags, szBuffer2, ARRAYSIZE( szBuffer2 ));
        
        Print( "RegItem Pidl:\n");

        if ( _fVerbose )
        {
            StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "    bFlags = %d (%s)\n", pRegItem->bFlags, szBuffer2 );
            Print( szBuffer );
            StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "    bOrder = %d\n", pRegItem->bOrder );
            Print( szBuffer );
        }
        
        CHAR szCLSID[40];
        CLSIDToString( szCLSID, ARRAYSIZE( szCLSID ), pRegItem->clsid );

        StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "    CLSID = %s ", szCLSID );
        Print( szBuffer );

        if ( GetCLSIDText( szCLSID, szBuffer2 + 1, ARRAYSIZE( szBuffer2 ) -2))
        {
            szBuffer2[0] = '(';
            StringCchCatA( szBuffer2, ARRAYSIZE(szBuffer2), ")\n" );
            Print( szBuffer2 );
        }

        ResetBuffer();

        LPVOID _pPrevArg = _pArg;
        
        if ( !FillBuffer( sizeof( WORD ), FALSE ))
        {
            Print( "Error unable to access next pidl section\n");
        }
        if ( FetchWord() != 0 )
        {
            // unknown hierarchy pidl type
            StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "Unknown Pidl Type contents, use !db %8X\n", (DWORD_PTR) _pPrevArg );
        }

        _pArg = _pPrevArg;
    }
    else
    {
        Print( "Unknown Drives pidl type\n");
        return FALSE;
    }

    return TRUE;
}

PIDLTYPE CPidlBreaker::CrackType( BYTE bType )
{
    PIDLTYPE eType = PIDL_UNKNOWN;
    
    switch( bType & 0xf0 )
    {
        case SHID_ROOT:
            eType = PIDL_ROOT;
            break;
            
        case SHID_COMPUTER:
            eType = PIDL_DRIVES;
            break;
            
        case SHID_FS:
            eType = PIDL_FILESYS;
            break;
            
        case SHID_NET:
            eType = PIDL_NET;
            break;
            
        case 0x60:  // SHID_INTERNET
            eType = PIDL_INTERNET;
            break;
    }
    return eType;
}

void CPidlBreaker::PrintType( PIDLTYPE eType )
{
    switch( eType )
    {
        case PIDL_ROOT:
            PrintRootPidl();
            break;

        case PIDL_FILESYS:
            PrintFileSysPidl();
            break;

        case PIDL_DRIVES:
            PrintDrivePidl();
            break;
            
        case PIDL_NET:
        case PIDL_INTERNET:
        default:
            Print( "Unknown Pidl Type\n");
            break;
    }
}
        

typedef struct _tagSHIDs
{
    BYTE bFlag;
    LPCSTR pszText;
} SHIDFLAGS;

SHIDFLAGS g_argSHID[] =
{
    {SHID_ROOT,                 "SHID_ROOT" },
    {SHID_ROOT_REGITEM,         "SHID_ROOT_REGITEM"},
    {SHID_COMPUTER,             "SHID_COMPUTER"},
    {SHID_COMPUTER_1,           "SHID_COMPUTER_1"},
    {SHID_COMPUTER_REMOVABLE,   "SHID_COMPUTER_REMOVABLE"},
    {SHID_COMPUTER_FIXED,       "SHID_COMPUTER_FIXED"},
    {SHID_COMPUTER_REMOTE,      "SHID_COMPUTER_REMOTE"},
    {SHID_COMPUTER_CDROM,       "SHID_COMPUTER_CDROM"},
    {SHID_COMPUTER_RAMDISK,     "SHID_COMPUTER_RAMDISK"},
    {SHID_COMPUTER_7,           "SHID_COMPUTER_7"},
    {SHID_COMPUTER_DRIVE525,    "SHID_COMPUTER_DRIVE525"},
    {SHID_COMPUTER_DRIVE35,     "SHID_COMPUTER_DRIVE35"},
    {SHID_COMPUTER_NETDRIVE,    "SHID_COMPUTER_NETDRIVE"},
    {SHID_COMPUTER_NETUNAVAIL,  "SHID_COMPUTER_NETUNAVAIL"},
    {SHID_COMPUTER_C,           "SHID_COMPUTER_C"},
    {SHID_COMPUTER_D,           "SHID_COMPUTER_D"},
    {SHID_COMPUTER_REGITEM,     "SHID_COMPUTER_REGITEM"},
    {SHID_COMPUTER_MISC,        "SHID_COMPUTER_MISC"},
    {SHID_FS,                   "SHID_FS"},
    {SHID_FS_TYPEMASK,          "SHID_FS_TYPEMASK"},
    {SHID_FS_DIRECTORY,         "SHID_FS_DIRECTORY"},
    {SHID_FS_FILE,              "SHID_FS_FILE"},
    {SHID_FS_UNICODE,           "SHID_FS_UNICODE"},
    {SHID_FS_DIRUNICODE,        "SHID_FS_DIRUNICODE"},
    {SHID_FS_FILEUNICODE,       "SHID_FS_FILEUNICODE"},
    {SHID_NET,                  "SHID_NET"},
    {SHID_NET_DOMAIN,           "SHID_NET_DOMAIN"},
    {SHID_NET_SERVER,           "SHID_NET_SERVER"},
    {SHID_NET_SHARE,            "SHID_NET_SHARE"},
    {SHID_NET_FILE,             "SHID_NET_FILE"},
    {SHID_NET_GROUP,            "SHID_NET_GROUP"},
    {SHID_NET_NETWORK,          "SHID_NET_NETWORK"},
    {SHID_NET_RESTOFNET,        "SHID_NET_RESTOFNET"},
    {SHID_NET_SHAREADMIN,       "SHID_NET_SHAREADMIN"},
    {SHID_NET_DIRECTORY,        "SHID_NET_DIRECTORY"},
    {SHID_NET_TREE,             "SHID_NET_TREE"},
    {SHID_NET_REGITEM,          "SHID_NET_REGITEM"},
    {SHID_NET_PRINTER,          "SHID_NET_PRINTER"}
};

BOOL CPidlBreaker::GetSHIDFlags( BYTE bFlags, CHAR * pszBuffer, DWORD cchSize )
{
    LPCSTR pszText = NULL;
    for ( int iFlag = 0; iFlag < ARRAYSIZE( g_argSHID ); iFlag ++ )
    {
        if ( g_argSHID[iFlag].bFlag == ( bFlags & SHID_TYPEMASK ))
        {
            pszText = g_argSHID[iFlag].pszText;
            break;
        }
    }

    if ( pszText == NULL )
    {
        StringCchPrintfA( pszBuffer, cchSize, "unknown SHID value %2X", bFlags );
        return FALSE;
    }
    else
    {
        StringCchCopyA( pszBuffer, cchSize, pszText );
    }
    
    if (bFlags & SHID_JUNCTION)
    {
        StringCchCatA(pszBuffer, cchSize, " | SHID_JUNCTION");
    }
    return TRUE;
}

void CPidlBreaker::CLSIDToString( CHAR * pszBuffer, DWORD cchSize, REFCLSID rclsid )
{
    WCHAR szBuffer[40];

    StringFromGUID2( rclsid, szBuffer, ARRAYSIZE( szBuffer ));
    WideCharToMultiByte( CP_ACP, 0, szBuffer, -1, pszBuffer, cchSize, 0, 0 );
}

//
//  Some CLSIDs have "known" names which are used if there is no custom name
//  in the registry.
//
typedef struct KNOWNCLSIDS
{
    LPCSTR pszCLSID;
    LPCSTR pszName;
} KNOWNCLSIDS;

const KNOWNCLSIDS c_kcKnown[] = {
    { "{20D04FE0-3AEA-1069-A2D8-08002B30309D}", "My Computer" },
    { "{21EC2020-3AEA-1069-A2DD-08002B30309D}", "Control Panel" },
    { "{645FF040-5081-101B-9F08-00AA002F954E}", "Recycle Bin" },
    { "{450D8FBA-AD25-11D0-98A8-0800361B1103}", "My Documents" },
    { "{871C5380-42A0-1069-A2EA-08002B30309D}", "The Internet" },
};

BOOL CPidlBreaker::GetCLSIDText( const CHAR * pszCLSID, CHAR * pszBuffer, DWORD cbSize )
{
    int i;
    for (i = 0; i < ARRAYSIZE(c_kcKnown); i++)
    {
        if (lstrcmpiA(c_kcKnown[i].pszCLSID, pszCLSID) == 0)
        {
            StringCbCopyA(pszBuffer, cbSize, c_kcKnown[i].pszName);
            return TRUE;
        }
    }


    HKEY hKey;
    LONG lRes = RegOpenKeyExA( HKEY_CLASSES_ROOT, "CLSID", 0, KEY_READ, &hKey );
    if ( ERROR_SUCCESS == lRes )
    {
        LONG lSize = cbSize;
        lRes = RegQueryValueA( hKey, pszCLSID, pszBuffer, &lSize );
        RegCloseKey(hKey);
        return ( ERROR_SUCCESS == lRes );
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\shlexts\shlexts.c ===
/****************************** Module Header ******************************\
* Module Name: shlexts.c
*
* Copyright (c) 1997, Microsoft Corporation
*
* This module contains user related debugging extensions.
*
* History:
* 10/28/97 created by cdturner (butchered from the userexts.dll)
\***************************************************************************/

#include <precomp.h>
#pragma hdrstop

#include <winver.h>
#include <shlwapi.h>


char * pszExtName = "SHLEXTS";

#include <stdexts.h>
#include <stdexts.c>

BOOL bShowFlagNames = TRUE;
#define NO_FLAG INVALID_HANDLE_VALUE // use this for non-meaningful entries.

LPSTR apszSFGAOFlags[] =
{
    "SFGAO_CANCOPY",        // 0x00000001L
    "SFGAO_CANMOVE",        // 0x00000002L
    "SFGAO_CANLINK",        // 0x00000004L
    NO_FLAG,
    "SFGAO_CANRENAME",      // 0x00000010L     // Objects can be renamed
    "SFGAO_CANDELETE",      // 0x00000020L     // Objects can be deleted
    "SFGAO_HASPROPSHEET",   // 0x00000040L     // Objects have property sheets
    NO_FLAG,
    "SFGAO_DROPTARGET",     // 0x00000100L     // Objects are drop target
    NO_FLAG,
    NO_FLAG,
    NO_FLAG,
    "SFGAO_LINK",           // 0x00010000L     // Shortcut (link)
    "SFGAO_SHARE",          // 0x00020000L     // shared
    "SFGAO_READONLY",       // 0x00040000L     // read-only
    "SFGAO_GHOSTED",        // 0x00080000L     // ghosted icon
    "SFGAO_NONENUMERATED",  // 0x00100000L     // is a non-enumerated object
    "SFGAO_NEWCONTENT",     // 0x00200000L     // should show bold in explorer tree
    NO_FLAG,
    NO_FLAG,
    "SFGAO_VALIDATE",       // 0x01000000L     // invalidate cached information
    "SFGAO_REMOVABLE",      // 0x02000000L     // is this removeable media?
    "SFGAO_COMPRESSED",     // 0x04000000L     // Object is compressed (use alt color)
    "SFGAO_BROWSABLE",      // 0x08000000L     // is in-place browsable
    "SFGAO_FILESYSANCESTOR",// 0x10000000L     // It contains file system folder
    "SFGAO_FOLDER",         // 0x20000000L     // It's a folder.
    "SFGAO_FILESYSTEM",     // 0x40000000L     // is a file system thing (file/folder/root)
    "SFGAO_HASSUBFOLDER",   // 0x80000000L     // Expandable in the map pane
    NULL
};

LPSTR apszSLDFFlags[] = 
{
   "SLDF_HAS_ID_LIST",      // = 0x0001,   // Shell link saved with ID list
   "SLDF_HAS_LINK_INFO",    // = 0x0002,   // Shell link saved with LinkInfo
   "SLDF_HAS_NAME",         // = 0x0004,
   "SLDF_HAS_RELPATH",      // = 0x0008,
   "SLDF_HAS_WORKINGDIR",   // = 0x0010,
   "SLDF_HAS_ARGS",         // = 0x0020,
   "SLDF_HAS_ICONLOCATION", // = 0x0040,
   "SLDF_UNICODE",          // = 0x0080,   // the strings are unicode (NT is comming!)
   "SLDF_FORCE_NO_LINKINFO",// = 0x0100,   // don't create a LINKINFO (make a dumb link)
   "SLDF_HAS_EXP_SZ"        // = 0x0200,   // the link contains expandable env strings
   "SLDF_RUN_IN_SEPARATE",  // = 0x0400,   // Run the 16-bit target exe in a separate VDM/WOW
   "SLDF_HAS_LOGO3ID",      // = 0x0800,   // this link is a special Logo3/MSICD link
   "SLDF_HAS_DARWINID",     // = 0x1000    // this link is a special Darwin link
   NULL
};

LPSTR apszFWFFlags[] =
{
    "FWF_AUTOARRANGE",          // =  0x0001,
    "FWF_ABBREVIATEDNAMES",     // =  0x0002,
    "FWF_SNAPTOGRID",           // =  0x0004,
    "FWF_OWNERDATA",            // =  0x0008,
    "FWF_BESTFITWINDOW",        // =  0x0010,
    "FWF_DESKTOP",              // =  0x0020,
    "FWF_SINGLESEL",            // =  0x0040,
    "FWF_NOSUBFOLDERS",         // =  0x0080,
    "FWF_TRANSPARENT",          // =  0x0100,
    "FWF_NOCLIENTEDGE",         // =  0x0200,
    "FWF_NOSCROLL",             // =  0x0400,
    "FWF_ALIGNLEFT",            // =  0x0800,
    "FWF_NOICONS",              // =  0x1000,
    "FWF_SINGLECLICKACTIVATE",  // = 0x8000  // TEMPORARY -- NO UI FOR THIS
    NULL
};

LPSTR apszICIFlags[] = 
{
    "ICIFLAG_LARGE",       // 0x0001
    "ICIFLAG_SMALL",       // 0x0002
    "ICIFLAG_BITMAP",      // 0x0004
    "ICIFLAG_ICON",        // 0x0008
    "ICIFLAG_INDEX",       // 0x0010
    "ICIFLAG_NAME",        // 0x0020
    "ICIFLAG_FLAGS",       // 0x0040
    "ICIFLAG_NOUSAGE",     // 0x0080
    NULL
};

LPSTR apszFDFlags[] =
{
    "FD_CLSID",            // = 0x0001,
    "FD_SIZEPOINT",        // = 0x0002,
    "FD_ATTRIBUTES",       // = 0x0004,
    "FD_CREATETIME",       // = 0x0008,
    "FD_ACCESSTIME",       // = 0x0010,
    "FD_WRITESTIME",       // = 0x0020,
    "FD_FILESIZE",         // = 0x0040,
    "FD_LINKUI",           // = 0x8000,       // 'link' UI is prefered
    NULL
};

LPSTR apszSHCNEFlags[] =
{
    "SHCNE_RENAMEITEM",         // 0x00000001L
    "SHCNE_CREATE",             // 0x00000002L
    "SHCNE_DELETE",             // 0x00000004L
    "SHCNE_MKDIR",              // 0x00000008L
    "SHCNE_RMDIR",              // 0x00000010L
    "SHCNE_MEDIAINSERTED",      // 0x00000020L
    "SHCNE_MEDIAREMOVED",       // 0x00000040L
    "SHCNE_DRIVEREMOVED",       // 0x00000080L
    "SHCNE_DRIVEADD",           // 0x00000100L
    "SHCNE_NETSHARE",           // 0x00000200L
    "SHCNE_NETUNSHARE",         // 0x00000400L
    "SHCNE_ATTRIBUTES",         // 0x00000800L
    "SHCNE_UPDATEDIR",          // 0x00001000L
    "SHCNE_UPDATEITEM",         // 0x00002000L
    "SHCNE_SERVERDISCONNECT",   // 0x00004000L
    "SHCNE_UPDATEIMAGE",        // 0x00008000L
    "SHCNE_DRIVEADDGUI",        // 0x00010000L
    "SHCNE_RENAMEFOLDER",       // 0x00020000L
    "SHCNE_FREESPACE",          // 0x00040000L
    NO_FLAG,
    NO_FLAG,
    NO_FLAG,
    "SHCNE_EXTENDED_EVENT",     // 0x04000000L
    "SHCNE_ASSOCCHANGED",       // 0x08000000L
    NULL
};

LPSTR apszSSFFlags[] =
{
    "SSF_SHOWALLOBJECTS",       // 0x0001
    "SSF_SHOWEXTENSIONS",       // 0x0002
    "SSF_WIN95UNUSED",          // 0x0004  // ;Internal - corresponding SHELLSTATE fields don't exist in SHELLFLAGSTATE
    "SSF_SHOWCOMPCOLOR",        // 0x0008
    "SSF_SORTCOLUMNS",          // 0x0010  // ;Internal - corresponding SHELLSTATE fields don't exist in SHELLFLAGSTATE
    "SSF_SHOWSYSFILES",         // 0x0020
    "SSF_DOUBLECLICKINWEBVIEW", // 0x0080
    "SSF_SHOWATTRIBCOL",        // 0x0100
    "SSF_DESKTOPHTML",          // 0x0200
    "SSF_WIN95CLASSIC",         // 0x0400
    "SSF_DONTPRETTYPATH",       // 0x0800
    "SSF_MAPNETDRVBUTTON",      // 0x1000
    "SSF_SHOWINFOTIP",          // 0x2000
    "SSF_HIDEICONS",            // 0x4000
    "SSF_NOCONFIRMRECYCLE",     // 0x8000
    "SSF_FILTER",               // 0x00010000  // ;Internal - corresponding SHELLSTATE fields don't exist in SHELLFLAGSTATE
    "SSF_WEBVIEW",              // 0x00020000  // ;Internal
    "SSF_SHOWSUPERHIDDEN",      // 0x00040000  // ;Internal
    "SSF_SEPPROCESS",           // 0x00080000  // ;Internal
    "SSF_NONETCRAWLING",        // 0x00100000  // ;Internal
    "SSF_STARTPANELON",         // 0x00200000  // ;Internal

    NULL
};

enum GF_FLAGS {
    GL_SFGAO = 0,
    GL_SLDF,
    GL_FWF,
    GL_ICI,
    GL_FD,
    GL_SHCNE,
    GL_SSF,
    GF_MAX,
};

struct _tagFlags
{
    LPSTR * apszFlags;
    LPSTR pszFlagsname;
} argFlag[GF_MAX] = 
{
    {apszSFGAOFlags,    "SFGAO"},
    {apszSLDFFlags,     "SLD"},
    {apszFWFFlags,      "FWF"},
    {apszICIFlags,      "ICIFLAG"},
    {apszFDFlags,       "FD"},
    {apszSHCNEFlags,    "SHCNE"},
    {apszSSFFlags,      "SSF"}
};

/************************************************************************\
* Procedure: GetFlags
*
* Description:
*
* Converts a 32bit set of flags into an appropriate string.
* pszBuf should be large enough to hold this string, no checks are done.
* pszBuf can be NULL, allowing use of a local static buffer but note that
* this is not reentrant.
* Output string has the form: "FLAG1 | FLAG2 ..." or "0"
*
* Returns: pointer to given or static buffer with string in it.
*
* 6/9/1995  Created SanfordS
* 11/5/1997 cdturner changed the aapszFlag type 
*
\************************************************************************/
LPSTR GetFlags(
    WORD    wType,
    DWORD   dwFlags,
    LPSTR   pszBuf,
    UINT    cchBuf,
    BOOL    fPrintZero)
{
    static char szT[512];
    WORD i;
    BOOL fFirst = TRUE;
    BOOL fNoMoreNames = FALSE;
    LPSTR *apszFlags;

    if (pszBuf == NULL) 
    {
        pszBuf = szT;
        cchBuf = ARRAYSIZE(szT);
    }
    
    if (!bShowFlagNames) 
    {
        StringCchPrintfA(pszBuf, cchBuf, "%x", dwFlags);
        return pszBuf;
    }

    *pszBuf = '\0';

    if (wType >= GF_MAX) 
    {
        StringCchCopyA(pszBuf, cchBuf, "Invalid flag type.");
        return pszBuf;
    }

    apszFlags = argFlag[wType].apszFlags;

    for (i = 0; dwFlags; dwFlags >>= 1, i++) 
    {
        if (!fNoMoreNames && apszFlags[i] == NULL) 
        {
            fNoMoreNames = TRUE;
        }

        if (dwFlags & 1) 
        {
            if (!fFirst) 
            {
                StringCchCatA(pszBuf, cchBuf, " | ");
            } 
            else 
            {
                fFirst = FALSE;
            }

            if (fNoMoreNames || apszFlags[i] == NO_FLAG) 
            {
                char ach[16];
                StringCchPrintfA(ach, ARRAYSIZE(ach), "0x%lx", 1 << i);
                StringCchCatA(pszBuf, cchBuf, ach);
            } 
            else 
            {
                StringCchCatA(pszBuf, cchBuf, apszFlags[i]);
            }
        }
    }

    if (fFirst && fPrintZero) 
    {
        StringCchPrintfA(pszBuf, cchBuf, "0");
    }

    return pszBuf;
}

/************************************************************************\
* Procedure: Iflags
*
* Description:
*
*     outputs the list of flags for the given flags type
*
* 11/5/1997 Created cdturner
*
\************************************************************************/
BOOL Iflags( DWORD dwOpts,
             LPSTR pszArgs )
{
    CHAR szBuffer[100];
    int iOffset = 0;
    int iFlags;
    LPDWORD pAddr;
    BOOL bAddr = FALSE;
    DWORD dwValue;
    LPSTR pszOut;
    
    if ( dwOpts & OFLAG(l))
    {
        // list all the struct names
        Print("Flags types known:\n");

        for ( iFlags = 0; iFlags < GF_MAX; iFlags ++ )
        {
            StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "    %s\n", argFlag[iFlags].pszFlagsname);
            Print( szBuffer );
        }
        return TRUE;
    }

    // skip whitespace
    while ( *pszArgs == ' ' )
        pszArgs ++;

    // now grab the flagsname
    while ( pszArgs[iOffset] != ' ' && pszArgs[iOffset] != '\0' )
    {
        szBuffer[iOffset] = pszArgs[iOffset];
        iOffset ++;
    };

    // terminate the string
    szBuffer[iOffset] = 0;
    
    // find the flags value
    for ( iFlags = 0; iFlags < GF_MAX; iFlags ++ )
    {
        if ( lstrcmpA( szBuffer, argFlag[iFlags].pszFlagsname ) == 0 )
            break;
    }

    if ( iFlags >= GF_MAX )
    {
        Print( "unknown flagsname - ");
        Print( szBuffer );
        Print( "\n" );
        return TRUE;
    }

    // skip white space
    while ( pszArgs[iOffset] == ' ' )
        iOffset ++;

    if ( pszArgs[iOffset] == '*' )
    {
        bAddr = TRUE;
        iOffset ++;
    }
    
    pAddr = (LPDWORD) EvalExp( pszArgs + iOffset );

    if ( bAddr )
    {
        if ( !tryDword( &dwValue, pAddr ) )
        {
            Print( "unable to access memory at that location\n");
            return TRUE;
        }
    }
    else 
    {
        dwValue = PtrToUlong(pAddr);
    }
    
    pszOut = GetFlags( (WORD) iFlags, dwValue, NULL, 0, TRUE ); 
    if ( pszOut )
    {
        StringCchPrintfA( szBuffer, ARRAYSIZE(szBuffer), "Value = %8X, pAddr = %8X\n", dwValue, (DWORD_PTR)pAddr );
        Print( szBuffer );
        Print( pszOut );
        Print( "\n" );
    }
    
    return TRUE;
}

/************************************************************************\
* Procedure: Itest
*
* Description: Tests the basic stdexts macros and functions - a good check
*   on the debugger extensions in general before you waste time debuging
*   entensions.
*
* Returns: fSuccess
*
* 11/4/1997 Created cdturner
*
\************************************************************************/
BOOL Itest()
{
    Print("Print test!\n");
    SAFEWHILE(TRUE) 
    {
        Print("SAFEWHILE test...  Hit Ctrl-C NOW!\n");
    }
    return TRUE;
}



/************************************************************************\
* Procedure: Iver
*
* Description: Dumps versions of extensions and winsrv/win32k
*
* Returns: fSuccess
*
* 11/4/1997 Created cdturner
*
\************************************************************************/
BOOL Iver()
{
#if DEBUG
    Print("SHLEXTS version: Debug.\n");
#else
    Print("SHLEXTS version: Retail.\n");
#endif

    return TRUE;
}


/************************************************************************\
*
*   DumpVerboseFileInfo
*
*   Stolen from MSDN.
*
\************************************************************************/

typedef struct LANGANDCODEPAGE {
    WORD wLang;
    WORD wCP;
} LANGANDCODEPAGE;

void DumpVersionString(LPVOID pBlock, LANGANDCODEPAGE *lpTranslate, LPCSTR pszKey)
{
    char szBuf[128];
    LPSTR pszValue;
    DWORD cb;

    StringCchPrintfA(szBuf, ARRAYSIZE(szBuf), "\\StringFileInfo\\%04x%04x\\%s",
              lpTranslate->wLang, lpTranslate->wCP, pszKey);
    if (VerQueryValueA(pBlock, szBuf, (LPVOID*)&pszValue, &cb) &&
        lstrlenA(pszValue))         // lstrlen traps exceptions
    {
        Print(szBuf+16);            // skip over "\\StringFileInfo\\"
        Print(" = ");
        Print(pszValue);
        Print("\n");
    }
}

LPCSTR c_rgszVersionKeys[] =
{
    "CompanyName",
    "FileDescription",
    "InternalName",
    "OriginalFilename",
    "ProductName",
    "ProductVersion",
    "FileVersion",
    "LegalCopyright",
    "LegalTrademarks",
    "PrivateBuild",
    "SpecialBuild",
    "Comments",
    NULL,
};

void DumpVerboseFileInfo(LPVOID pBlock)
{
    LANGANDCODEPAGE *lpTranslate;
    DWORD cbTranslate;

    // Read the list of languages and code pages
    if (VerQueryValueA(pBlock, "\\VarFileInfo\\Translation",
                       (LPVOID*)&lpTranslate, &cbTranslate))
    {
        UINT i;
        for (i = 0; i < cbTranslate/sizeof(*lpTranslate) && !IsCtrlCHit(); i++)
        {
            LPCSTR *ppszVK;
            for (ppszVK  = c_rgszVersionKeys; *ppszVK && !IsCtrlCHit(); ppszVK++)
            {
                DumpVersionString(pBlock, &lpTranslate[i], *ppszVK);
            }
        }

    }
}

/************************************************************************\
* Procedure: Ifilever
*
* Description: Dumps versions of extensions and winsrv/win32k
*
* Returns: fSuccess
*
* 11/4/1997 Created cdturner
*
\************************************************************************/
BOOL Ifilever( DWORD dwOpts,
             LPSTR pszArgs )
{
    HINSTANCE hDll = NULL;
    DLLGETVERSIONPROC pGetVer = NULL;
    DWORD dwHandle;
    DWORD dwBlockLen;
    LPVOID pBlock = NULL;
    char szMessage[200];
    BOOL fSkipLoad = FALSE;
    
    
    if ( pszArgs == NULL || lstrlenA( pszArgs ) == 0 )
    {
        pszArgs = "Shell32.dll";    // default filename
    }

    if ( !dwOpts )
    {
        dwOpts = OFLAG(n);          // default flags
    }

    Print("filever ");
    Print(pszArgs);
    Print("\n");
            
    if ( dwOpts & OFLAG(d) )
    {
        hDll = LoadLibraryA(pszArgs);
        if ( hDll == NULL )
        {
            Print("LoadLibrary failed\n");
        }
        else
        {
            pGetVer = (DLLGETVERSIONPROC) GetProcAddress( hDll, "DllGetVersion");
            if ( pGetVer )
            {
                DLLVERSIONINFO rgVerInfo;

                rgVerInfo.cbSize = sizeof( rgVerInfo );

                pGetVer( &rgVerInfo );

                StringCchPrintfA( szMessage, ARRAYSIZE(szMessage), "DllGetVersion\n    Major = %d\n    Minor = %d\n    Build = %d\n",
                    rgVerInfo.dwMajorVersion, rgVerInfo.dwMinorVersion, rgVerInfo.dwBuildNumber );

                Print(szMessage );
            }
            FreeLibrary( hDll );
        }
    }

    if ( dwOpts & (OFLAG(n) | OFLAG(v)) )
    {
        // now test the normal version details...
        dwBlockLen = GetFileVersionInfoSizeA( pszArgs, &dwHandle );
        if ( dwBlockLen == 0 )
        {
            Print("GetFileVersionSize failed\n");
        }
        else
        {
            pBlock = LocalAlloc( LPTR, dwBlockLen );
            if ( pBlock )
            {
                if (GetFileVersionInfoA( pszArgs, dwHandle, dwBlockLen, pBlock ))
                {
                    VS_FIXEDFILEINFO * pFileInfo;
                    UINT uLen;

                    VerQueryValueA( pBlock, "\\", (LPVOID *) &pFileInfo, &uLen );
                    Print("GetFileVersionInfo\n");

                    StringCchPrintfA( szMessage, ARRAYSIZE(szMessage), "Version: %d.%d.%d.%d (0x%08x`%08x)\n",
                        HIWORD(pFileInfo->dwFileVersionMS),
                        LOWORD(pFileInfo->dwFileVersionMS),
                        HIWORD(pFileInfo->dwFileVersionLS),
                        LOWORD(pFileInfo->dwFileVersionLS),
                        pFileInfo->dwFileVersionMS,
                        pFileInfo->dwFileVersionLS);
                    Print( szMessage );
                }

                if (dwOpts & OFLAG(v))
                {
                    DumpVerboseFileInfo(pBlock);
                }
                LocalFree( pBlock );
            }
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\shlexts\shlkdx.h ===
/****************************** Module Header ******************************\
* Module Name: shlkdx.h
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* A preprocessed version of this file is passed to structo.exe to build
*  the struct field name-offset tables.
*
* History:
* 11-04-1997 Cdturner Created
\***************************************************************************/
#ifndef _SHLKDX_
#define _SHLKDX_

#include "precomp.h"
#pragma hdrstop

#include "conapi.h"
#include <ntsdexts.h>
#define NOEXTAPI
#include <wdbgexts.h>

#endif /* _SHLKDX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\shlexts\stackwlk.cpp ===
//-----------------------------------------------------------------------------
#include "precomp.h"
#pragma hdrstop

extern "C"
{
#include <stdexts.h>
#include <dbgeng.h>
};

#define DEFAULT_STACK_FRAMES    25
#define OINK_THRESHOLD          4.0 


//-----------------------------------------------------------------------------
void StackPig(ULONG ulFrames)
{
    IDebugClient*  pDebugClient;
    IDebugControl* pDebugControl;

    if (SUCCEEDED(DebugCreate(__uuidof(IDebugClient), (void**)&pDebugClient)))
    {
        if (SUCCEEDED(pDebugClient->QueryInterface(__uuidof(IDebugControl), (void**)&pDebugControl)))
        {
            DEBUG_STACK_FRAME  rgdsf[DEFAULT_STACK_FRAMES];
            DEBUG_STACK_FRAME* pdsf = NULL;

            if ((ulFrames > ARRAYSIZE(rgdsf)))
            {
                // Try allocating a buffer to accomodate the frames requested.
                // Failing that fallback to the default size stack variable.
                pdsf = (DEBUG_STACK_FRAME *)LocalAlloc(LPTR, sizeof(DEBUG_STACK_FRAME)*ulFrames);
            }

            if (pdsf == NULL)
            {
                pdsf = rgdsf;
                if ((ulFrames == 0) || (ulFrames > ARRAYSIZE(rgdsf)))
                {
                    ulFrames = ARRAYSIZE(rgdsf);
                }
            }

            if (SUCCEEDED(pDebugControl->GetStackTrace(0, 0, 0, pdsf, ulFrames, &ulFrames))) 
            {
                double dResult = 0.0;

                // print the header
                Print("StackSize ");
                pDebugControl->OutputStackTrace(
                                DEBUG_OUTCTL_ALL_CLIENTS, 
                                pdsf, 
                                0, 
                                DEBUG_STACK_COLUMN_NAMES|DEBUG_STACK_FRAME_ADDRESSES);

                for (UINT i = 0; !IsCtrlCHit() && (i < ulFrames); i++)
                {
                    (dResult < 0.1) ? 
                        Print("          ") : 
                        Print("%s%4.1fK ", ((dResult >= OINK_THRESHOLD) ? "OINK" : "    "), dResult);
                    pDebugControl->OutputStackTrace(
                                    DEBUG_OUTCTL_ALL_CLIENTS, 
                                    &pdsf[i], 
                                    1, 
                                    DEBUG_STACK_FRAME_ADDRESSES);

                    // process' initial ebp is zero, prevent negative result
                    if ((i+1 == ulFrames) || (pdsf[i+1].FrameOffset == 0)) 
                    {
                        dResult = 0.0;
                        continue;
                    }
                    
                    dResult = (pdsf[i+1].FrameOffset - pdsf[i].FrameOffset)/1024.0;
                }
            }

            if (pdsf != rgdsf)
            {
                LocalFree(pdsf);
            }

            pDebugControl->Release();
        }

        pDebugClient->Release();
    }
}


//-----------------------------------------------------------------------------
extern "C" BOOL Istackpig(DWORD dwOpts, LPVOID pArg)
{
    StackPig(PtrToUlong(pArg)); 
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\shlexts\ntsd\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\shlexts\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

CCSHELL_DIR     = $(PROJECT_ROOT)

TARGETNAME=shlexts
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=DYNLINK

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib         \
           $(SDK_LIB_PATH)\gdi32.lib            \
           $(WINDOWS_LIB_PATH)\user32p.lib      \
           $(SDK_LIB_PATH)\advapi32.lib         \
           $(SDK_LIB_PATH)\ole32.lib            \
           $(SDK_LIB_PATH)\version.lib          \
           $(SDK_LIB_PATH)\psapi.lib            \
           $(SDK_LIB_PATH)\dbgeng.lib           \
           $(SHELL_LIB_PATH)\shell32p.lib       \
           $(SHELL_LIB_PATH)\shlwapip.lib       \
           $(CCSHELL_DIR)\lib\$(O)\shguid.lib   \
           $(CCSHELL_DIR)\lib\$(O)\shguidp.lib

LINKLIBS=..\cpp\$(O)\shlcpp.lib

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -D_USER32_ -DUNICODE

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES= ..;$(WINDOWS_INC_PATH)

USE_NTDLL=1

SOURCES= \
        ..\shlexts.c    \
        ..\shlexts.rc

NTTARGETFILE0= \
        $(O)\shlexts.def

DLLDEF=$(O)\shlexts.def

UMTYPE=console

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\types\makefile.inc ===
!CMDSWITCHES +i

$O\shell95.out: $(SHELL95)\shell32.dll
    $(TLVIEWER) $(SHELL95)\shell32.dll $@

$O\shellnt.out: $(SHELLNT)\shell32.dll
    $(TLVIEWER) $(SHELLNT)\shell32.dll $@

$O\shdocvw.out: $(SHDOCVW)\shdocvw.dll
    $(TLVIEWER) $(SHDOCVW)\shdocvw.dll $@

!CMDSWITCHES -i

$O\sh95err.out: $O\shell95.out shell32.ref
    $(TLDIFF) -s -f tldiff.ini $O\shell95.out shell32.ref > $@


$O\shnterr.out: $O\shellnt.out shell32.ref
    $(TLDIFF) -s -f tldiff.ini $O\shellnt.out shell32.ref > $@


$O\shdocer.out: $O\shdocvw.out shdocvw.ref
    $(TLDIFF) -s -f tldiff.ini $O\shdocvw.out shdocvw.ref > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\tools\shlexts\usercmds.cpp ===
#include "precomp.h"
#pragma hdrstop

extern "C"
{
#include <stdexts.h>
#include <winuserp.h>
#include <wowuserp.h>
#include <psapi.h>
};

typedef struct _LARGE_UNICODE_STRING {
    ULONG Length;
    ULONG MaximumLength : 31;
    ULONG bAnsi : 1;
    void *Buffer;               // kernel-sized pointer
} LARGE_UNICODE_STRING, *PLARGE_UNICODE_STRING;

typedef struct tagWND : public WW
{
    tagWND* spwndNext;
    tagWND* spwndPrev;
    tagWND* spwndParent;
    tagWND* spwndChild;
    tagWND* spwndOwner;

    RECT    rcWindow;
    RECT    rcClient;
    WNDPROC lpfnWndProc;
    void*   pcls;
    HRGN    hrgnUpdate;         // kernel-sized pointer
    void*   ppropList;
    void*   pSBInfo;
    HMENU   spmenuSys;
    HMENU   spmenu;
    HRGN    hrgnClip;
    LARGE_UNICODE_STRING strName;
    int     cbWndExtra;
    void*   spwndLastActive;
    void*   hImc;               // kernel-sized pointer
    void*   dwUserData;         // kernel-sized pointer
    void*   pActCtx;
} WND, *PWND;

BOOL CALLBACK PropEnumProc(HWND hwnd, LPCSTR lpszString, HANDLE hData)
{
    if (IS_INTRESOURCE(lpszString))
    {
        Print("Prop 0x%04x = 0x%08x\n", lpszString, hData);
    }
    else
    {
        Print("Prop \"%s\" = 0x%08x\n", lpszString, hData);
    }
    return TRUE;
}

void DumpWindowBytes(HWND hwnd)
{
    PWND pwnd = (PWND)GetWindowLongPtr(hwnd, GWLP_WOWWORDS);
    if (pwnd)
    {
        Print("cbWndExtra=%d\n", pwnd->cbWndExtra);
        // USER tries to hide GetWindowLong from out-of-process apps
        // so we have to grovel it manually.

        LONG_PTR *rglp = (LONG_PTR*)(pwnd+1);

        for (int i = 0; i < pwnd->cbWndExtra; i += sizeof(LONG_PTR))
        {
            LONG_PTR lp = *(LONG_PTR*)((LPBYTE)(pwnd+1) + i);
            Print("%8d = 0x%p\n", i, lp);
        }
    }
    Print("UserData = 0x%p\n", pwnd->dwUserData);
}

void DumpMiscWindowInfo(HWND hwnd, char *szBuf)
{
    Print("\n"
          "GetClipboardOwner()      = 0x%p\n", GetClipboardOwner());
    Print("GetClipboardViewer()     = 0x%p\n", GetClipboardViewer());
    Print("GetOpenClipboardWindow() = 0x%p\n", GetOpenClipboardWindow());
    Print("GetActiveWindow()        = 0x%p\n", GetActiveWindow());
    Print("GetFocus()               = 0x%p\n", GetFocus());
    Print("GetCapture()             = 0x%p\n", GetCapture());
    Print("GetForegroundWindow()    = 0x%p\n", GetForegroundWindow());
    Print("GetWindowContextHelpId() = 0x%p\n", GetWindowContextHelpId(hwnd));
    Print("GetDesktopWindow()       = 0x%p\n", GetDesktopWindow());
    Print("GetLastActivePopup()     = 0x%p\n", GetLastActivePopup(hwnd));

    if (GetWindowModuleFileNameA(hwnd, szBuf, MAX_PATH))
    {
        Print("GetWindowModuleFileName()= %s\n", szBuf);
    }

    DWORD pid;
    if (GetWindowThreadProcessId(hwnd, &pid))
    {
        HANDLE h = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
        if (h)
        {
            if (GetModuleFileNameExA(h, NULL, szBuf, MAX_PATH))
            {
                Print("Process                  = %s\n", szBuf);
            }
            CloseHandle(h);
        }
    }

}

extern "C" BOOL Ihwnd(DWORD dwOpts,
                       LPVOID pArg )
{
    HWND hwnd = (HWND)pArg;
    char szBuf[MAX_PATH];
    RECT rc;

    if (hwnd == 0)
        hwnd = GetDesktopWindow();

    Print("Window 0x%08x ", hwnd);

    if (!IsWindow(hwnd))
    {
        Print("*** NOT A WINDOW HANDLE\n");
        return TRUE;
    }

    if (dwOpts & OFLAG(m))
    {
        DumpMiscWindowInfo(hwnd, szBuf);
        return TRUE;
    }

    GetWindowTextA(hwnd, szBuf, ARRAYSIZE(szBuf));
    Print("\"%s\" ", szBuf);

    GetClassNameA(hwnd, szBuf, ARRAYSIZE(szBuf));
    Print("(%s)", szBuf);

    if (IsWindowUnicode(hwnd)) {
        Print(" UNICODE\n");
    } else {
        Print(" ANSI\n");
    }

    if ( dwOpts & OFLAG(p) )
    {
        EnumPropsA(hwnd, PropEnumProc);
        Print("End of property list\n");
        return TRUE;
    }

    if ( dwOpts & OFLAG(b) )
    {
        DumpWindowBytes(hwnd);
        return TRUE;
    }

    Print("  N=0x%08x C=0x%08x P=0x%08x O=0x%08x\n",
          GetWindow(hwnd, GW_HWNDNEXT),
          GetWindow(hwnd, GW_CHILD),
          GetAncestor(hwnd, GA_PARENT),
          GetWindow(hwnd, GW_OWNER));

    GetWindowRect(hwnd, &rc);
    Print("  W=(%d,%d)-(%d,%d) %dx%d ",
          rc.left, rc.top,
          rc.right, rc.bottom,
          rc.right - rc.left,
          rc.bottom - rc.top);

    GetClientRect(hwnd, &rc);
    Print("  C=(%d,%d)-(%d,%d) %dx%d\n",
          rc.left, rc.top,
          rc.right, rc.bottom,
          rc.right - rc.left,
          rc.bottom - rc.top);

    DWORD dwPid = 0;
    DWORD dwTid = GetWindowThreadProcessId(hwnd, &dwPid);

    Print("  pid.tid=0x%x.0x%x hinst=0x%p ", dwPid, dwTid,
          GetWindowLongPtr(hwnd, GWLP_HINSTANCE));

    // Now the evil part: Getting the wndproc...
    PWND pwnd = (PWND)GetWindowLongPtr(hwnd, GWLP_WOWWORDS);
    if (pwnd)
    {
        Print("wp=0x%p", pwnd->lpfnWndProc);
    }
    Print("\n");

    Print("  style-0x%08x exstyle=0x%08x\n",
          GetWindowLong(hwnd, GWL_STYLE),
          GetWindowLong(hwnd, GWL_EXSTYLE));

    return TRUE;
}

/***********************************************************************/

extern "C" BOOL Ihmenu(DWORD dwOpts,
                       LPVOID pArg )
{
    HMENU hmenu = (HMENU)pArg;
    char szBuf[MAX_PATH];
    RECT rc;

    Print("Menu 0x%08x ", hmenu);

    if (!IsMenu(hmenu))
    {
        Print("*** NOT A MENU HANDLE\n");
        return TRUE;
    }

    UINT cItems = GetMenuItemCount(hmenu);
    Print("%d items\n", cItems);

    UINT uiPosDefault = GetMenuDefaultItem(hmenu, TRUE, GMDI_USEDISABLED);

    for (UINT ui = 0; !IsCtrlCHit() && ui < cItems; ui++)
    {
        MENUITEMINFOA mii = { 0 };
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_DATA | MIIM_FTYPE | MIIM_ID | MIIM_STATE |
                    MIIM_STRING | MIIM_SUBMENU;
        mii.dwTypeData = szBuf;
        mii.cch = ARRAYSIZE(szBuf);
        if (GetMenuItemInfoA(hmenu, ui, TRUE, &mii))
        {
            Print("%2d: id=0x%04x ref=0x%p ", ui, mii.wID, mii.dwItemData);
            if (mii.fType & MFT_BITMAP)
            {
                Print("bitmap 0x%p ", mii.dwTypeData);
            }
            else if (mii.fType & MFT_OWNERDRAW)
            {
                Print("ownerdraw 0x%p ", mii.dwTypeData);
            }
            else if (mii.fType & MFT_SEPARATOR)
            {
                Print("separator ");
            }
            else
            {
                Print("string \"%s\" ", mii.dwTypeData);
            }

            if (mii.fType & MFT_MENUBARBREAK)
                Print("MFT_MENUBARBREAK ");

            if (mii.fType & MFT_MENUBREAK)
                Print("MFT_MENUBREAK ");

            if (mii.fType & MFT_RADIOCHECK)
                Print("MFT_RADIOCHECK ");

            if (mii.fType & MFT_RIGHTJUSTIFY)
                Print("MFT_RIGHTJUSTIFY ");

            if (mii.fType & MFT_RIGHTORDER)
                Print("MFT_RIGHTORDER ");

            if (mii.fState & MFS_CHECKED)
                Print("MFS_CHECKED ");

            if (mii.fState & MFS_DEFAULT)
                Print("MFS_DEFAULT ");

            if (mii.fState & MFS_DISABLED)
                Print("MFS_DISABLED ");

            if (mii.fState & MFS_GRAYED)
                Print("MFS_GRAYED ");

            if (mii.fState & MFS_HILITE)
                Print("MFS_HILITE ");

            if (mii.hSubMenu)
                Print("-> 0x%p ", mii.hSubMenu);

            Print("\n");
        }
    }


    return TRUE;
}

/***********************************************************************/

#include <pshpack1.h>

#define CC_BUTTON           0x80        /* Class codes */
#define CC_EDIT             0x81
#define CC_STATIC           0x82
#define CC_LISTBOX          0x83
#define CC_SCROLLBAR        0x84
#define CC_COMBOBOX         0x85

#define DS_DIALOGEX         0xFFFF0001

typedef struct DIALOGDIMEN {
    WORD    x;
    WORD    y;
    WORD    cx;
    WORD    cy;
} DIALOGDIMEN, *PDIALOGDIMEN;

typedef struct DLGFINISH {          /* Common dialog finish-up */
    WORD    cDlgItems;
    DIALOGDIMEN dd;
} DLGFINISH, *PDLGFINISH;

typedef struct DLG {
    DWORD   dwStyle;            // or DS_DIALOGEX if DIALOGEX
    DWORD   dwExStyle;
    DLGFINISH dlgfinish;
    WORD    wszMenuName[1];
    /*
     * wszMenuName[] -- wsz or 0x00FF followed by WORD ordinal
     * wszClassName[] -- wsz or 0x00FF followed by WORD ordinal (?)
     * wszTitle[] -- wsz
     * if dwStyle & DS_SETFONT
     *      WORD wPoint;                // point size
     *      wszFontName[] -- wsz
     * endif
     * followed by a packed array of DITs, each DWORD aligned
     */
} DLG, *PDLG;

typedef struct DLGEX {
    WORD    wDlgVer;                    /* Version number; always 0001 */
    WORD    wSignature;                 /* Always 0xFFFF */
    DWORD   dwHelpID;
    DWORD   dwExStyle;
    DWORD   dwStyle;
    DLGFINISH dlgfinish;
    /*
     * wszMenuName[] -- wsz or 0x00FF followed by WORD ordinal
     * wszClassName[] -- wsz or 0x00FF followed by WORD ordinal (?)
     * wszTitle[] -- wsz
     * if dwStyle & DS_SETFONT
     *      WORD wPoint;                // point size
     *      WORD wWeight;
     *      BYTE bItalic;
     *      BYTE bCharSet;
     *      wszFontName[] -- wsz
     * endif
     * followed by a packed array of DITEX'es, each DWORD aligned
     */
} DLGEX, *PDLGEX;

typedef struct DIT {                /* dialog item template */
    DWORD   dwStyle;
    DWORD   dwExStyle;
    DIALOGDIMEN dd;
    WORD    wID;
    /*
     * wszClassName[] -- wsz or 0xFFFF followed by WORD ordinal
     * wszTitle[] -- wsz
     * cbExtra -- word value
     */
} DIT, *PDIT;

typedef struct DITEX {
    DWORD   dwHelpID;
    DWORD   dwExStyle;
    DWORD   dwStyle;
    DIALOGDIMEN dd;
    DWORD   dwID;
    /*
     * wszClassName[] -- wsz or 0xFFFF followed by WORD ordinal
     * wszTitle[] -- wsz
     * cbExtra -- word value
     */
} DITEX, *PDITEX;

#include <poppack.h>

BOOL _MoveBlock(LPVOID pvDst, LPVOID pvSrc, DWORD cb)
{
    BOOL fSuccess = tryMoveBlock(pvDst, pvSrc, cb);
    if (fSuccess) return fSuccess;
    Print("Error reading %d bytes from %p\n", cb, pvSrc);
    return FALSE;
}

LPCSTR DlgGetClassName(WORD wClass)
{
    switch (wClass) {       /* Handle internal class types */
    case CC_BUTTON:     return "button";
    case CC_EDIT:       return "edit";
    case CC_STATIC:     return "static";
    case CC_LISTBOX:    return "listbox";
    case CC_SCROLLBAR:  return "scrollbar";
    case CC_COMBOBOX:   return "combobox";
    default:            return "<unknown>";
    }
}

typedef LPCSTR (*ORDINALRESOLVER)(WORD w);

LPBYTE DlgDumpString(LPCSTR pszField, LPBYTE pArg, ORDINALRESOLVER Resolve)
{
    WCHAR wch;

    Print("%s: ", pszField);

    if (!_MoveBlock(&wch, pArg, sizeof(wch))) return NULL;

    pArg += sizeof(wch);

    if (wch == 0xFF || wch == 0xFFFF)
    {
        if (!_MoveBlock(&wch, pArg, sizeof(wch))) return NULL;
        pArg += sizeof(wch);

        LPCSTR pszOrdinal;
        if (Resolve && (pszOrdinal = Resolve(wch)))
        {
            Print("%s\n", pszOrdinal);
        }
        else
        {
            Print("#0x%04x\n", wch);
        }
        return pArg;
    }

    Print("\"");
    while (wch) {
        Print("%c", wch); // truncate to ANSI, sorry
        if (IsCtrlCHit()) return NULL;

        if (!_MoveBlock(&wch, pArg, sizeof(wch))) return NULL;
        pArg += sizeof(wch);
    }
    Print("\"\n");
    return pArg;
}

LPBYTE DlgDwordAlign(LPBYTE pBase, LPBYTE pArg)
{
    SIZE_T diff = pArg - pBase;
    if (diff % 4) pArg += 4 - (diff % 4);
    return pArg;
}

void DumpDialogEx(LPBYTE pArg)
{
    DLGEX dlg;

    LPBYTE pBase = pArg;
    WORD w;

    if (!_MoveBlock(&dlg, pArg, sizeof(dlg))) return;

    Print("  wDlgVer = 0x%04x\n", dlg.wDlgVer);
    Print("  dwStyle = 0x%08x\n", dlg.dwStyle);
    Print("dwExStyle = 0x%08x\n", dlg.dwExStyle);
    Print(" dwHelpID = 0x%08x\n", dlg.dwHelpID);
    Print("  ( x, y) = (%3d, %3d)\n", dlg.dlgfinish.dd.x, dlg.dlgfinish.dd.y);
    Print("  (cx,cy) = (%3d, %3d)\n", dlg.dlgfinish.dd.cx, dlg.dlgfinish.dd.cy);

    pArg += FIELD_OFFSET(DLG, wszMenuName);

    pArg = DlgDumpString("Menu", pArg, NULL);
    if (!pArg) return;

    pArg = DlgDumpString("Class", pArg, NULL);
    if (!pArg) return;

    pArg = DlgDumpString("Title", pArg, NULL);
    if (!pArg) return;

    if (dlg.dwStyle & DS_SETFONT)
    {
        struct {
            WORD wPoint;
            WORD wWeight;
            BYTE bItalic;
            BYTE bCharSet;
        } ft;

        if (!_MoveBlock(&ft, pArg, sizeof(ft))) return;
        pArg += sizeof(ft);

        pArg = DlgDumpString("Font", pArg, NULL);
        if (!pArg) return;

        Print("  %dpt, weight=%d, italic=%d, charset=%d\n",
              ft.wPoint, ft.wWeight, ft.bItalic, ft.bCharSet);
    }

    // and then a packed array of DITEXs, DWORD-aligned

    Print("Number of controls: %d\n\n", dlg.dlgfinish.cDlgItems);

    for (int i = 0; !IsCtrlCHit() && i < dlg.dlgfinish.cDlgItems; i++)
    {
        pArg = DlgDwordAlign(pBase, pArg);

        DITEX dit;

        if (!_MoveBlock(&dit, pArg, sizeof(dit))) return;
        pArg += sizeof(dit);

        Print("Control %d (0x%04x):\n", dit.dwID, dit.dwID);
        Print("      dwStyle = 0x%08x\n", dit.dwStyle);
        Print("    dwExStyle = 0x%08x\n", dit.dwExStyle);
        Print("     dwHelpID = 0x%08x\n", dit.dwHelpID);
        Print("      ( x, y) = (%3d, %3d)\n", dit.dd.x, dit.dd.y);
        Print("      (cx,cy) = (%3d, %3d)\n", dit.dd.cx, dit.dd.cy);

        pArg = DlgDumpString("    Class", pArg, DlgGetClassName);
        if (!pArg) return;

        pArg = DlgDumpString("    Title", pArg, DlgGetClassName);
        if (!pArg) return;

        if (!_MoveBlock(&w, pArg, sizeof(w))) return;
        pArg += sizeof(w);
        pArg += w;
    }
}

void DumpDialog(LPBYTE pArg)
{
    DLG dlg;

    LPBYTE pBase = pArg;
    WORD w;

    if (!_MoveBlock(&dlg, pArg, sizeof(dlg))) return;

    Print("  dwStyle = 0x%08x\n", dlg.dwStyle);
    Print("dwExStyle = 0x%08x\n", dlg.dwExStyle);
    Print("  ( x, y) = (%3d, %3d)\n", dlg.dlgfinish.dd.x, dlg.dlgfinish.dd.y);
    Print("  (cx,cy) = (%3d, %3d)\n", dlg.dlgfinish.dd.cx, dlg.dlgfinish.dd.cy);

    pArg += FIELD_OFFSET(DLG, wszMenuName);

    pArg = DlgDumpString("Menu", pArg, NULL);
    if (!pArg) return;

    pArg = DlgDumpString("Class", pArg, NULL);
    if (!pArg) return;

    pArg = DlgDumpString("Title", pArg, NULL);
    if (!pArg) return;

    if (dlg.dwStyle & DS_SETFONT)
    {
        if (!_MoveBlock(&w, pArg, sizeof(w))) return;
        pArg += sizeof(WORD);

        pArg = DlgDumpString("Font", pArg, NULL);
        if (!pArg) return;

        Print("  Font size: %dpt\n", w);
    }

    // and then a packed array of DITs, DWORD-aligned

    Print("Number of controls: %d\n\n", dlg.dlgfinish.cDlgItems);

    for (int i = 0; !IsCtrlCHit() && i < dlg.dlgfinish.cDlgItems; i++)
    {
        pArg = DlgDwordAlign(pBase, pArg);

        DIT dit;

        if (!_MoveBlock(&dit, pArg, sizeof(dit))) return;
        pArg += sizeof(dit);

        Print("Control %d (0x%04x):\n", (short)dit.wID, dit.wID);
        Print("      dwStyle = 0x%08x\n", dit.dwStyle);
        Print("    dwExStyle = 0x%08x\n", dit.dwExStyle);
        Print("      ( x, y) = (%3d, %3d)\n", dit.dd.x, dit.dd.y);
        Print("      (cx,cy) = (%3d, %3d)\n", dit.dd.cx, dit.dd.cy);

        pArg = DlgDumpString("    Class", pArg, DlgGetClassName);
        if (!pArg) return;

        pArg = DlgDumpString("    Title", pArg, DlgGetClassName);
        if (!pArg) return;

        if (!_MoveBlock(&w, pArg, sizeof(w))) return;
        pArg += sizeof(w);
        pArg += w;
    }
}

extern "C" BOOL Idlgt(DWORD dwOpts,
                       LPVOID pArg )
{
    int cItems;
    PDLGFINISH pdlgfinish;

    DWORD dw;
    if (!_MoveBlock(&dw, pArg, sizeof(dw)))
    {
        return TRUE;
    }

    if (dw == DS_DIALOGEX)
    {
        DumpDialogEx((LPBYTE)pArg);
    }
    else
    {
        DumpDialog((LPBYTE)pArg);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appcmpt\aciniupd\aciniupd.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/***********************************************************************
*
*  ACINIUPD.H
*     This module contains typedefs and defines required for
*     the ACINIUPD utility.
*
*
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be

/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_GET_VALUE                             102
#define IDS_ERROR_UPDATE_VALUE                          103
#define IDS_ERROR_DEL_KEY                               104
#define IDS_ERROR_UPDATE_KEY                            105
#define IDS_ERROR_CHANGE_MODE                           106
#define IDS_HELP_USAGE1                                 110
#define IDS_HELP_USAGE2                                 111
#define IDS_HELP_USAGE3                                 112
#define IDS_HELP_USAGE4                                 113
#define IDS_HELP_USAGE5                                 114
#define IDS_HELP_USAGE6                                 115
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appcmpt\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_INF             =obj\$(TARGET_DIRECTORY)
_ROOT            =..
_INSTALL         =$(_ROOT)\install
_INSTALL_TEMPLATE=$(_ROOT)\install\template
_LOGON           =$(_ROOT)\logon
_LOGON_TEMPLATE  =$(_ROOT)\logon\template
_UNINST          =$(_ROOT)\uninst


.SUFFIXES: .cmd .key

make_root:
    binplace -R $(_NTTREE) $(_ROOT)\CHKROOT.CMD
    binplace -R $(_NTTREE) $(_ROOT)\SETPATHS.CMD
    binplace -R $(_NTTREE) $(_ROOT)\END.CMD
    binplace -R $(_NTTREE) $(_ROOT)\ROOTDRV.CMD
    binplace -R $(_NTTREE) $(_ROOT)\USRLOGON.CMD


make_install:
    binplace -R $(_NTTREE) $(_INSTALL)\OFFICE43.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\OFFICE43.KEY
    binplace -R $(_NTTREE) $(_INSTALL)\OFC43INS.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\OUTLK98.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\MSWORD97.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\MSEXCL97.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\EUDORA4.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\LNOTE4U.CMD
    binplace -R $(_NTTREE) $(_INSTALL)\FPAGE98.CMD

make_install_template:
    binplace -R $(_NTTREE) $(_INSTALL_TEMPLATE)\MSPROJ98.KEY
    binplace -R $(_NTTREE) $(_INSTALL_TEMPLATE)\EUDORA4.key


make_logon:
    binplace -R $(_NTTREE) $(_LOGON)\TSMKUDIR.CMD
    binplace -R $(_NTTREE) $(_LOGON)\TSMKUFIL.CMD
    binplace -R $(_NTTREE) $(_LOGON)\EUD4USR.CMD


make_logon_template:
    binplace -R $(_NTTREE) $(_LOGON_TEMPLATE)\OFC43USR.CMD
    binplace -R $(_NTTREE) $(_LOGON_TEMPLATE)\OFC43USR.KEY
    binplace -R $(_NTTREE) $(_LOGON_TEMPLATE)\WRD97USR.CMD
    binplace -R $(_NTTREE) $(_LOGON_TEMPLATE)\EXL97USR.CMD
    binplace -R $(_NTTREE) $(_LOGON_TEMPLATE)\OLK98USR.CMD

make_uninst:
    binplace -R $(_NTTREE) $(_UNINST)\UExcl97.Cmd
    binplace -R $(_NTTREE) $(_UNINST)\UWord97.Cmd
    binplace -R $(_NTTREE) $(_UNINST)\UOFF43.CMD
    binplace -R $(_NTTREE) $(_UNINST)\UOff97.Cmd
    binplace -R $(_NTTREE) $(_UNINST)\UProj98.Cmd
    binplace -R $(_NTTREE) $(_UNINST)\UOUTLK98.CMD
    binplace -R $(_NTTREE) $(_UNINST)\UMSVS6.CMD
    binplace -R $(_NTTREE) $(_UNINST)\UFPG98.CMD

make_install_pp: $(_INF)\MSPROJ98.CMD    \
                 $(_INF)\OFFICE97.CMD    \
                 $(_INF)\MSVS6.CMD       \
                 $(_INF)\LNOTE4U.KEY			

make_install_template_pp: $(_INF)\OFFICE97.KEY \
                          $(_INF)\MSVS6.KEY \
                          $(_INF)\OUTLK98.KEY \
                          $(_INF)\MSWORD97.KEY \
                          $(_INF)\MSEXCL97.KEY

make_logon_pp:


make_logon_template_pp: $(_INF)\OFC97USR.CMD    \
                        $(_INF)\PRJ98USR.CMD


make_appcmpt:  make_root                \
               make_install             \
               make_install_pp          \
               make_install_template    \
               make_install_template_pp \
               make_logon               \
               make_logon_pp            \
               make_logon_template      \
               make_logon_template_pp   \
               make_uninst


make_appcmpt_pp:  make_install_pp           \
                  make_install_template_pp  \
                  make_logon_pp             \
                  make_logon_template_pp


clean: make_appcmpt



{$(_INSTALL)\}.cmd{$(_INF)}.cmd:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP
    $(BINPLACE_CMD)


{$(_INSTALL)\}.key{$(_INF)}.key:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP
    $(BINPLACE_CMD)


{$(_INSTALL_TEMPLATE)\}.cmd{$(_INF)}.cmd:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP
    $(BINPLACE_CMD)


{$(_INSTALL_TEMPLATE)\}.key{$(_INF)}.key:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP
    $(BINPLACE_CMD)


{$(_LOGON)\}.cmd{$(_INF)}.cmd:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP
    $(BINPLACE_CMD)


{$(_LOGON_TEMPLATE)\}.cmd{$(_INF)}.cmd:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<NOKEEP
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appcmpt\acsr\precomp.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <shellapi.h>
#include <shlobj.h>
#include <shlwapi.h>
#define NO_SHLWAPI_STRFCNS
#define NO_SHLWAPI_PATH
#define NO_SHLWAPI_REG
#define NO_SHLWAPI_UALSTR
#define NO_SHLWAPI_HTTP
#define NO_SHLWAPI_INTERNAL
#include <shlwapip.h>

#define FE_SB 1

#include <shlobjp.h>

#ifndef PLINKINFO
#define PLINKINFO LPVOID
#endif

#define EXP_SZ_LINK_SIG         0xA0000001
//#define NT_CONSOLE_PROPS_SIG    0xA0000002 // moved to shlobj.w
#define EXP_TRACKER_SIG         0xA0000003
//#define NT_FE_CONSOLE_PROPS_SIG 0xA0000004 // moved to shlobj.w
#define EXP_DARWIN_ID_SIG       0xA0000006

#define EXP_HEADER DATABLOCK_HEADER
#define LPEXP_HEADER LPDATABLOCK_HEADER

// most expansion data structures go here
// those shared with other components (NT40 Console stuff)
// are in shlobj.w (private)
//

typedef struct {
    IShellLink          sl;
    IPersistStream      ps;
    IPersistFile        pf;
    IShellExtInit       si;
    IContextMenu2       cm;
    IDropTarget         dt;
#ifdef USE_DATA_OBJ
    IDataObj            dobj;
#endif
////IExtractIcon        xi;
#ifdef UNICODE
    IShellLinkA         slA;            // To support ANSI callers
#endif
#ifdef ENABLE_TRACK
    IShellLinkTracker   slt;        // Interface to CTracker object.
#endif
#ifdef WINNT
    IShellLinkDataList  sldl;
#endif

    UINT                cRef;

    BOOL                bDirty;         // something has changed
    LPTSTR              pszCurFile;     // current file from IPersistFile
    LPTSTR              pszRelSource;   // overrides pszCurFile in relative tracking

    IContextMenu        *pcmTarget;     // stuff for IContextMenu
    UINT                indexMenuSave;
    UINT                idCmdFirstSave;
    UINT                idCmdLastSave;
    UINT                uFlagsSave;

    BOOL                fDataAlreadyResolved;   // for data object

    // IDropTarget specific
    IDropTarget*        pdtSrc;         // IDropTarget of link source (unresolved)
    DWORD               grfKeyStateLast;

    // persistant data

    LPITEMIDLIST        pidl;           // may be NULL
    PLINKINFO           pli;            // may be NULL

    LPTSTR              pszName;        // title on short volumes
    LPTSTR              pszRelPath;
    LPTSTR              pszWorkingDir;
    LPTSTR              pszArgs;
    LPTSTR              pszIconLocation;

    LPDBLIST            pExtraData;     // extra data to preserve for future compatibility

#ifdef ENABLE_TRACK
    struct CTracker *   ptracker;
#endif

    SHELL_LINK_DATA     sld;
} CShellLink;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appcmpt\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appcmpt\aciniupd\aciniupd.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/***************************************************************************
*
*  ACINIUPD.C
*
*  Utility to update INI files
*
*
****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsta.h>
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <utilsub.h>
#include <string.h>
#include <winnlsp.h>

#include "aciniupd.h"
#include "tsappcmp.h"

#define WININI    L"win.ini"

/*
 * Global Data
 */
WCHAR file_name[MAX_IDS_LEN+1];        // ini file name
WCHAR section_name[MAX_IDS_LEN+1];     // section name
WCHAR key_name[MAX_IDS_LEN+1];         // key name
WCHAR new_string[MAX_IDS_LEN+1];       // new string
USHORT help_flag  = FALSE;             // User wants help
USHORT fEditValue = FALSE;             // Update the value associated with the key
USHORT fEditKey   = FALSE;             // Update the key name
USHORT fUserIni   = FALSE;             // Make change to the user's windows directory
USHORT fVerbose   = FALSE;             // Verbose mode for debugging

TOKMAP ptm[] = {
      {L"/?", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
      {L"/e", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fEditValue},
      {L"/k", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fEditKey},
      {L"/u", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fUserIni},
      {L"/v", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fVerbose},
      {L" ",  TMFLAG_OPTIONAL, TMFORM_STRING, MAX_IDS_LEN, file_name},
      {L" ",  TMFLAG_OPTIONAL, TMFORM_STRING, MAX_IDS_LEN, section_name},
      {L" ",  TMFLAG_OPTIONAL, TMFORM_STRING, MAX_IDS_LEN, key_name},
      {L" ",  TMFLAG_OPTIONAL, TMFORM_STRING, MAX_IDS_LEN, new_string},
      {0, 0, 0, 0, 0}
};

/*
 * Local functions
 */
void Usage(BOOLEAN bError);
int UpdateValue(PWCHAR fileName, PWCHAR sectionName, PWCHAR keyName, PWCHAR newString);
int UpdateKey(PWCHAR fileName, PWCHAR sectionName, PWCHAR keyName, PWCHAR newString);

/******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main( INT argc, CHAR **argv )
{
    WCHAR **argvW;
    WCHAR wcSrcPort[MAX_PATH], wcDestPort[MAX_PATH];
    ULONG ulSrcPort, ulDestPort, rc;
    BOOLEAN State, Changed = FALSE;
    int result = SUCCESS;
    BOOL InstallState;

    setlocale(LC_ALL, ".OCP");
    
    SetThreadUILanguage(0);

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !help_flag ) {
            Usage(TRUE);
            return(FAILURE);
        } else {
            Usage(FALSE);
            return(SUCCESS);
        }
    }

    if (wcscmp( file_name, L"" ) == 0 ||
        wcscmp( section_name, L"" ) == 0 ||
        wcscmp( key_name, L"" ) == 0) {
       Usage( TRUE );
       return (FAILURE);
    }


    rc = 1;
#if 0
    State = CtxGetIniMapping();
    /*
     * Change the INI mapping mode if necessary
     */
    if (!State && fUserIni) {
       rc = CtxSetIniMapping( TRUE );
       Changed = TRUE;
    }
    else if (State && !fUserIni) {
       rc = CtxSetIniMapping( FALSE );
       Changed = TRUE;
    }
#else
    InstallState = TermsrvAppInstallMode();

    if( InstallState && fUserIni ) {
        rc = SetTermsrvAppInstallMode( FALSE );
        Changed = TRUE;
    } else if( !InstallState && !fUserIni ) {
        rc = SetTermsrvAppInstallMode( TRUE );
        Changed = TRUE;
    }

#endif // 0

    /*
     * Exit if failed to change user mode
     */
    if (!rc) {
       if (fVerbose) ErrorPrintf(IDS_ERROR_CHANGE_MODE, GetLastError());
       return (FAILURE);
    }

    if (fEditValue) {
       result = UpdateValue(file_name, section_name, key_name, new_string);
    }
    else if (fEditKey) {
       result = UpdateKey(file_name, section_name, key_name, new_string);
    }
    else {
       Usage(FALSE);
       result = FAILURE;
    }

    /*
     * Change back to the original mode if necessary. Assume it always successes.
     */
    if (Changed) {
//       rc = CtxSetIniMapping( State );
         rc = SetTermsrvAppInstallMode( InstallState );
    }

    return (result);
}  /* main */

/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }
    ErrorPrintf(IDS_HELP_USAGE1);
    ErrorPrintf(IDS_HELP_USAGE2);
    ErrorPrintf(IDS_HELP_USAGE3);
    ErrorPrintf(IDS_HELP_USAGE4);
    ErrorPrintf(IDS_HELP_USAGE6);
}  /* Usage() */

/******************************************************************************
*
* UpdateValue
*
*     Update the associated value for the key
*
* ENTRY:
*     PWCHAR   fileName
*        Ini file name
*     PWCHAR   sectionName
*        Section name
*     PWCHAR   keyName
*        Key name
*     pwchar   newString
*        New value
*
* EXIT:
*     FAILURE / SUCCESS
*
*******************************************************************************/

int UpdateValue( PWCHAR fileName,
                 PWCHAR sectionName,
                 PWCHAR keyName,
                 PWCHAR newString )
{
   BOOLEAN  isWinIni;
   WCHAR value[5];
   UINT result = 0;

   isWinIni = wcscmp( fileName, WININI ) == 0 ? TRUE : FALSE;

   /*
    * If change is made to win.ini, call WriteProfileString API
    */
   if (isWinIni) {
      result = WriteProfileString( sectionName,
                                   keyName,
                                   newString );
   }
   /*
    * Otherwise, call WritePrivateProfileString API
    */
   else {
      result = WritePrivateProfileString( sectionName,
                                          keyName,
                                          newString,
                                          fileName );
   }

   if (result == 0) {
      if (fVerbose)
      {
          StringDwordErrorPrintf(IDS_ERROR_UPDATE_VALUE, keyName, GetLastError());
      }
      return (FAILURE);
   }

   return (SUCCESS);
}  /* UpdateValue */

/******************************************************************************
*
* UpdateKey
*
*     Update the key name
*
* ENTRY:
*     PWCHAR   fileName
*        Ini file name
*     PWCHAR   sectionName
*        Section name
*     PWCHAR   keyName
*        Key name
*     PWCHAR   newString
*        New key name
*
* EXIT:
*     FAILURE / SUCCESS
*
*******************************************************************************/

int UpdateKey( PWCHAR fileName,
               PWCHAR sectionName,
               PWCHAR keyName,
               PWCHAR newString )
{
   BOOLEAN  isWinIni;
   PWCHAR value;
   UINT result;

   value = (WCHAR *)malloc( sizeof(WCHAR) * (MAX_IDS_LEN + 1) );
   if (value == NULL) {
      if (fVerbose) ErrorPrintf(IDS_ERROR_MALLOC);
      return (FAILURE);
   }

   __try
   {
       isWinIni = wcscmp( fileName, WININI ) == 0 ? TRUE : FALSE;
    
       /*
        * Get the value string
        */
       if (isWinIni) {
          result = GetProfileString( sectionName,
                                     keyName,
                                     L"",
                                     value,
                                     MAX_IDS_LEN+1 );
       }
       else {
          result = GetPrivateProfileString( sectionName,
                                            keyName,
                                            L"",
                                            value,
                                            MAX_IDS_LEN+1,
                                            fileName );
       }
    
       if (result == 0) {
          if (fVerbose)
          {
              StringErrorPrintf(IDS_ERROR_GET_VALUE, keyName);
          }
          return (FAILURE);
       }
    
       /*
        * Delete the old key
        */
       if (isWinIni) {
          result = WriteProfileString( sectionName, keyName, NULL );
       }
       else {
          result = WritePrivateProfileString( sectionName, keyName, NULL, fileName );
       }
    
       if (result == 0) {
          if (fVerbose)
          {
              StringDwordErrorPrintf(IDS_ERROR_DEL_KEY, keyName, GetLastError());
          }
          return (FAILURE);
       }
    
       /*
        * Add the new key
        */
       if (isWinIni) {
          result = WriteProfileString( sectionName, newString, value );
       }
       else {
          result = WritePrivateProfileString( sectionName, newString, value, fileName );
       }
    
       if (result == 0) {
          if (fVerbose)
          {
              StringDwordErrorPrintf(IDS_ERROR_UPDATE_KEY, keyName, GetLastError());
         }
          return (FAILURE);
       }
    
       return (SUCCESS);
   }

   __finally
   {
       free( value );
   }
}  /* UpdateKey */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appcmpt\acsr\acsr.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*  ACSR.C
*
*  Application Compatibility Search and Replace Helper Program
*
*
*******************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define MAXLEN 512

char Temp[MAXLEN+1];
char Temp1[MAXLEN+1];
char Srch[MAXLEN+1];
char Repl[2*MAXLEN+2];
char *InFN;
char *OutFN;

//*------------------------------------------------------------*//
//* Local function prototypes                                  *//
//*------------------------------------------------------------*//
BOOL ReadString( HANDLE hFile, LPVOID * lpVoid, BOOL bUnicode );
void ReadLnkCommandFile(HANDLE hFile);


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl main(INT argc, CHAR **argv)
{
   DWORD retval;
   int CurArg = 1;
   FILE *InFP;
   FILE *OutFP;
   int SrchLen, ReplLen;
   char *ptr, *Loc;
   HANDLE hFile;
   DWORD dwMaxLen = MAXLEN;
   DWORD dwLen;
   char* pTemp = Temp;
   BOOL fAlloc = FALSE;

   if (argc != 5)
      return(1);

    //
    //331012 Unbounded strcpy in termsrv\appcmpt\acsr\acsr.c
    //check for argv[] length and alloc if needed
    //
   dwLen = strlen(argv[CurArg]);
   if (dwLen > dwMaxLen) {
        dwMaxLen = dwLen;
        pTemp = (LPSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, (dwMaxLen+1)*sizeof(char) );
        
        if (NULL == pTemp)
            return(1);
        fAlloc = TRUE;
   }
        
   if (argv[CurArg][0] == '"')
      {
      strcpy(pTemp, &argv[CurArg][1]);
      if (pTemp[strlen(pTemp)-1] == '"')
         pTemp[strlen(pTemp)-1] = 0;
      else
         return(1);
      }
   else
      strcpy(pTemp, argv[CurArg]);

   retval = ExpandEnvironmentStringsA(pTemp, Srch, dwMaxLen);
   if ((retval == 0) || (retval > dwMaxLen))
      return(1);
   
   SrchLen = strlen(Srch);
   if (SrchLen < 1)
      return(1);

   CurArg++;
    
    //
    //331012 Unbounded strcpy in termsrv\appcmpt\acsr\acsr.c
    //check for argv[] length and realloc if needed
    //
   dwLen = strlen(argv[CurArg]);
   
   if (dwLen > dwMaxLen) {
        
        dwMaxLen = dwLen;
        //
        //check if we allocated for pTemp above, if so, free it first
        //
        if (fAlloc) {
            HeapFree(GetProcessHeap(), 0, pTemp);
        }
        
        pTemp = (LPSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, (dwMaxLen+1)*sizeof(char) );
        
        if (NULL == pTemp)
            return(1);
        fAlloc = TRUE;
   }

   if (argv[CurArg][0] == '"')
      {
      strcpy(pTemp, &argv[CurArg][1]);
      if (pTemp[strlen(pTemp)-1] == '"')
         pTemp[strlen(pTemp)-1] = 0;
      else
         return(1);
      }
   else
      strcpy(pTemp, argv[CurArg]);

   retval = ExpandEnvironmentStringsA(pTemp, Repl, dwMaxLen);
   if ((retval == 0) || (retval > dwMaxLen))
      return(1);
   
   ReplLen = strlen(Repl);
   if (ReplLen < 1)
      return(1);


   CurArg++;
   InFN = argv[CurArg];
   CurArg++;
   OutFN = argv[CurArg];
#ifdef ACSR_DEBUG
   printf("Srch  <%s>\n",Srch);
   printf("Repl  <%s>\n",Repl);
   printf("InFN  <%s>\n",InFN);
   printf("OutFN <%s>\n",OutFN);
#endif

   if (strstr(Repl,".lnk") || strstr(Repl, ".LNK")) {
      hFile = CreateFileA( Repl,
			  GENERIC_READ,
			  FILE_SHARE_READ,
			  NULL,
			  OPEN_EXISTING,
			  FILE_ATTRIBUTE_NORMAL,
			  NULL
			  );
      if (hFile != INVALID_HANDLE_VALUE) {
         ReadLnkCommandFile(hFile);
#ifdef ACSR_DEBUG
         printf("This is a .lnk file. Substitue with the real cmd %s\n", Repl);
#endif

      }

   }


   InFP = fopen(InFN, "r");
   if (InFP == NULL)
      return(1);

   OutFP = fopen(OutFN, "w");
   if (OutFP == NULL)
   {
       fclose(InFP);
       return(1);
   }

   while (1)
      {
      if (fgets(pTemp, MAXLEN, InFP) == NULL)
         break;

      ptr = pTemp;
      Temp1[0] = 0;  // Empty String

      while (1)
         {
         Loc = strstr(ptr, Srch);
         if (Loc == NULL)  // Search Term Not Found
            break;
         
         // Append part of string before search term
         Loc[0] = 0;
         if (strlen(Temp1) + strlen(ptr) < MAXLEN)
            strcat(Temp1, ptr);
         
         // Append Replacement term
         if (strlen(Temp1) + ReplLen < MAXLEN)
            strcat(Temp1, Repl);
         
         // Point to location past search term
         ptr = Loc + SrchLen;
         }
      
      // Append remainder of string
      strcat(Temp1, ptr);

      fputs(Temp1, OutFP);
      }

   fclose(InFP);
   fclose(OutFP);
   if (fAlloc) {
        HeapFree(GetProcessHeap(), 0, pTemp);
   }
   return(0);
}

//*-------------------------------------------------------------*//
//* ReadLinkCommandFile                                         *//
//*    This routine is to read a .lnk file and put the linked   *//
//*    file name and args to the Repl[] global variable         *//
//*    The logic to read the .lnk file is copied from           *//
//*    lnkdump.exe utility private\windows\shell\tools\lnkdump  *//
//* ------------------------------------------------------------*//

void  ReadLnkCommandFile(HANDLE hFile  //.lnk file handle
                         )
{
    CShellLink   csl;
    CShellLink * this = &csl;
    DWORD cbSize, cbTotal, cbToRead, dwBytesRead;
    SYSTEMTIME  st;
    LPSTR pTemp = NULL;
    CHAR szPath[ MAXLEN + 1];
    CHAR szArgs[ MAXLEN + 1];

    this->pidl = 0;
    this->pli = NULL;
    memset( this, 0, sizeof(CShellLink) );

    szPath[0] = 0;
    szArgs[0] = 0;

    // Now, read out data...

    if(!ReadFile( hFile, (LPVOID)&this->sld, sizeof(this->sld), &dwBytesRead, NULL )) {
        return;
    }


    // read all of the members

    if (this->sld.dwFlags & SLDF_HAS_ID_LIST) {
        // Read the size of the IDLIST
        cbSize = 0; // need to zero out to get HIWORD 0 'cause USHORT is only 2 bytes
        if(!ReadFile( hFile, (LPVOID)&cbSize, sizeof(USHORT), &dwBytesRead, NULL )) {
            return;
        }

        if (cbSize) {
            SetFilePointer(hFile,cbSize,NULL,FILE_CURRENT);
        } else {
#ifdef ACSR_DEBUG
            printf( "Error readling PIDL out of link!\n" );
#endif
        }
    }


    if (this->sld.dwFlags & (SLDF_HAS_LINK_INFO)) {
        LPVOID pli;

        if(!ReadFile( hFile, (LPVOID)&cbSize, sizeof(cbSize), &dwBytesRead, NULL )) {
            return;
        }

        if (cbSize >= sizeof(cbSize)) {
            cbSize -= sizeof(cbSize);
            SetFilePointer(hFile,cbSize,NULL,FILE_CURRENT);
        }

    }

    if (this->sld.dwFlags & SLDF_HAS_NAME) {
        if(!ReadString( hFile, &this->pszName, this->sld.dwFlags & SLDF_UNICODE)) {
            goto cleanup;
        }
    }


    if (this->sld.dwFlags & SLDF_HAS_RELPATH) {
        if(!ReadString( hFile, &this->pszRelPath, this->sld.dwFlags & SLDF_UNICODE)) {
            goto cleanup;
        }
    }


    if (this->sld.dwFlags & SLDF_HAS_WORKINGDIR) {
        if(!ReadString( hFile, &this->pszWorkingDir, this->sld.dwFlags & SLDF_UNICODE)) {
            goto cleanup;
        }
    }

    if (this->sld.dwFlags & SLDF_HAS_ARGS) {
        if(!ReadString( hFile, &this->pszArgs, this->sld.dwFlags & SLDF_UNICODE)) {
            goto cleanup;
        }
    }


    if (this->pszRelPath) {
        if (this->sld.dwFlags & SLDF_UNICODE) {


            WideCharToMultiByte( CP_ACP, 0,
                                 (LPWSTR)this->pszRelPath,
                                 -1,
                                 szPath,
                                 256,
                                 NULL,
                                 NULL
                               );

        } else {
            strcpy(szPath, (LPSTR)this->pszRelPath);
        }
    }


    if (this->pszArgs) {
        if (this->sld.dwFlags & SLDF_UNICODE) {

            WideCharToMultiByte( CP_ACP, 0,
                                 (LPWSTR)this->pszArgs,
                                 -1,
                                 szArgs,
                                 256,
                                 NULL,
                                 NULL
                               );

        } else {
            strcpy(szArgs, (LPSTR)this->pszArgs);
        }
    }

    // Construct the command
    if(szPath) {

        strcpy(Repl, szPath);
        strcat(Repl, " ");
        strcat(Repl, szArgs);
    }

cleanup:
    if (this->pidl)
        LocalFree( (HLOCAL)this->pidl );

    if (this->pli)
        LocalFree( this->pli );

    if (this->pszName)
        HeapFree( GetProcessHeap(), 0, this->pszName );
    if (this->pszRelPath)
        HeapFree( GetProcessHeap(), 0, this->pszRelPath );
    if (this->pszWorkingDir)
        HeapFree( GetProcessHeap(), 0, this->pszWorkingDir );
    if (this->pszArgs)
        HeapFree( GetProcessHeap(), 0, this->pszArgs );
    if (this->pszIconLocation)
        HeapFree( GetProcessHeap(), 0, this->pszIconLocation );

}
//*------------------------------------------------------------*//
//* This routine is copied from lnkdump.exe utility            *//
//* (private\windows\shell\tools\lnkdump\lnkdump.c)            *//
//* It reads a string from an opened .lnk file                 *//
//* -----------------------------------------------------------*//

BOOL ReadString( HANDLE hFile, LPVOID * lpVoid, BOOL bUnicode )
{

    USHORT cch;
    DWORD  dwBytesRead;
    
    *lpVoid = NULL;

    if(!ReadFile( hFile, (LPVOID)&cch, sizeof(cch), &dwBytesRead, NULL )) {
        return FALSE;
    }

    if (bUnicode)
    {
        LPWSTR lpWStr = NULL;
        
        lpWStr = (LPWSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, (cch+1)*sizeof(WCHAR) );
        if (lpWStr) {
            if(!ReadFile( hFile, (LPVOID)lpWStr, cch*sizeof(WCHAR), &dwBytesRead, NULL )) {
                HeapFree( GetProcessHeap(), 0, lpWStr );
                return FALSE;
            }
            lpWStr[cch] = L'\0';
        }
        *(PDWORD_PTR)lpVoid = (DWORD_PTR)lpWStr;
    }
    else
    {
        LPSTR lpStr = NULL;
        
        lpStr = (LPSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, (cch+1) );
        if (lpStr) {
            if(!ReadFile( hFile, (LPVOID)lpStr, cch, &dwBytesRead, NULL )) {
                HeapFree( GetProcessHeap(), 0, lpStr );
                return FALSE;
            }
            lpStr[cch] = '\0';
        }
        *(PDWORD_PTR)lpVoid = (DWORD_PTR)lpStr;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appcmpt\acregl\precomp.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <shlobj.h>
#include <winsta.h>
#include <locale.h>
#include <utilsub.h>
#include <printfoa.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appcmpt\acregl\acregl.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*  ACREGL.C
*
*  Application Compatibility Registry Lookup Helper Program
*
*
*******************************************************************************/

#include "precomp.h"
#pragma hdrstop


// #include <winreg.h>

#define MAXLEN 512



// Options

   // The strip char option will strip the rightmost n instances
   // of the specified character from the output.  If the count
   // is omitted, then a single instance is removed.
   // 
   // Example: STRIPCHAR\3 will change 
   // C:\WINNT40\Profiles\All Users\Start Menu to
   // C:\WINNT40 
#define OPTION_STRIP_CHAR		L"STRIPCHAR"

   // The strip path option strips off the path.
   // 
   // Example: STRIPPATH will change 
   // C:\WINNT40\Profiles\All Users\Start Menu to
   // Start Menu
#define OPTION_STRIP_PATH		L"STRIPPATH"

   // The get path option gets the common paths
   // 
   // Example: GETPATHS will return
   // 
#define OPTION_GET_PATHS		L"GETPATHS"

   // Define the strings used for setting the user/common paths
#define COMMON_STARTUP                  L"COMMON_STARTUP"
#define COMMON_START_MENU               L"COMMON_START_MENU"
#define COMMON_PROGRAMS                 L"COMMON_PROGRAMS"
#define USER_START_MENU                 L"USER_START_MENU"
#define USER_STARTUP                    L"USER_STARTUP"
#define USER_PROGRAMS                   L"USER_PROGRAMS"
#define MY_DOCUMENTS                    L"MY_DOCUMENTS"
#define TEMPLATES                       L"TEMPLATES"
#define APP_DATA                        L"APP_DATA"


// Option Block. 
// Scan Options will populate
// this struct.

typedef struct 
{
	WCHAR stripChar;	        // Character to strip.
	int stripNthChar;		// Strip nth occurrence from the right.
	int stripPath;			// Strip path.
        int getPaths;                   // Get the common paths
} OptionBlock;


//
//  Strip quotes from argument if they exist, convert to unicode, and expand 
//  environment variables.
//

int ParseArg(CHAR *inarg, WCHAR *outarg)
{
   WCHAR T[MAXLEN+1], wcin[MAXLEN+1];
   int retval;

   // Convert to Ansi
   OEM2ANSIA(inarg, (USHORT)strlen(inarg));
   wsprintf(wcin, L"%S", inarg);

   if (wcin[0] == L'"')
      {
      wcscpy(T, &wcin[1]);
      if (T[wcslen(T)-1] == L'"')
         T[wcslen(T)-1] = UNICODE_NULL;
      else
         return(-1);  // Mismatched quotes
      }
   else
      wcscpy(T, wcin);

   retval = ExpandEnvironmentStrings(T, outarg, MAXLEN);
   if ((retval == 0) || (retval > MAXLEN))
      return(-1);
   
   return(retval);
}

//
// See comment above OPTION_STRIP_CHAR definition.
//

void StripChar(WCHAR *s, WCHAR c, int num)
{
    if(s)
    {
       WCHAR *p = s + wcslen(s) + 1;

       while ((num != 0) && (p != s))
       {
          p--;
          if (*p == c)
             num--;
       }

       *p = 0;
    }
}

// 
// Strips the path from the
// specified string.
//
void StripPath(WCHAR *s)
{

   WCHAR *p = wcsrchr(s, L'\\');

   if (p != 0)
      wcscpy(s, p+1);

}

//
// Populates option block.
//
int ScanOptions(WCHAR *optionString, OptionBlock* options)
{
	WCHAR *curOption;
	WCHAR temp[MAXLEN+1];

	// Clear out option block.
	memset(options, 0, sizeof(OptionBlock));

	// Trivial Reject.
	if (*optionString == 0)
		return 0;


	// Uppercase a copy of the option string.
	wcscpy(temp, optionString);
	_wcsupr(temp);

	// Look for strip char option.
	curOption = wcsstr(temp, OPTION_STRIP_CHAR);

	if (curOption != 0)
	{
		// Change current option so it points into the original
		// option, not the uppercased copy.
		
		curOption = (WCHAR*)((INT_PTR)optionString + ((INT_PTR)curOption  - (INT_PTR)temp));


		// Get parameters after strip specifier.
		// If there are not any then error.
		curOption += (sizeof(OPTION_STRIP_CHAR)/sizeof(WCHAR)) - 1;
		if (*curOption == UNICODE_NULL || *curOption == L' ')
			return 1;

		// Get the character to strip.
		options->stripChar = *curOption++;

		// Get the number of occurrrences.
		// If not specified then assume 1.
		if (*curOption == UNICODE_NULL || *curOption == L' ')
			options->stripNthChar = 1;
		else
			options->stripNthChar = _wtoi(curOption);
	}


	// Look for leaf option.
	curOption = wcsstr(temp, OPTION_STRIP_PATH);
	if (curOption != UNICODE_NULL)
		options->stripPath = 1;


	// Look get paths option
	curOption = wcsstr(temp, OPTION_GET_PATHS);
	if (curOption != UNICODE_NULL)
		options->getPaths = 1;

	return 0;

}

// 
// Outputs the common directories into the temp file
// Input: file (input) pointer to open handle for the batch file
// Returns: 0 - success
//          1 - failure
//
int GetPaths(FILE *file)
{
   WCHAR szPath[MAX_PATH+1];

   if(  !GetWindowsDirectory(szPath, MAX_PATH) ){
       return (1);
   }

   if (SHGetFolderPath(NULL, CSIDL_COMMON_STARTMENU, NULL, 0, szPath) == S_OK) {
      fwprintf(file, L"SET %s=%s\n", COMMON_START_MENU, szPath);
   } else {
      return(1);
   }

   if (SHGetFolderPath(NULL, CSIDL_COMMON_STARTUP, NULL, 0, szPath) == S_OK) {
      fwprintf(file, L"SET %s=%s\n", COMMON_STARTUP, szPath);
   } else {
      return(1);
   }

   if (SHGetFolderPath(NULL, CSIDL_COMMON_PROGRAMS, NULL, 0, szPath) == S_OK) {
      fwprintf(file, L"SET %s=%s\n", COMMON_PROGRAMS, szPath);
   } else {
      return(1);
   }

   if (SHGetFolderPath(NULL, CSIDL_STARTMENU, NULL, 0, szPath) == S_OK) {
      fwprintf(file, L"SET %s=%s\n", USER_START_MENU, szPath);
   } else {
      return(1);
   }

   if (SHGetFolderPath(NULL, CSIDL_STARTUP, NULL, 0, szPath) == S_OK) {
      fwprintf(file, L"SET %s=%s\n", USER_STARTUP, szPath);
   } else {
      return(1);
   }

   if (SHGetFolderPath(NULL, CSIDL_PROGRAMS, NULL, 0, szPath) == S_OK) {
      fwprintf(file, L"SET %s=%s\n", USER_PROGRAMS, szPath);
   } else {
      return(1);
   }

   // MY_DOCUMENTS should only be the last component of the path
   if (SHGetFolderPath(NULL, CSIDL_PERSONAL, NULL, 0, szPath) == S_OK) {
      StripPath(szPath);
      fwprintf(file, L"SET %s=%s\n", MY_DOCUMENTS, szPath);
   } else {
      return(1);
   }

   // TEMPLATES should only be the last component of the path
   if (SHGetFolderPath(NULL, CSIDL_TEMPLATES, NULL, 0, szPath) == S_OK) {
      StripPath(szPath);
      fwprintf(file, L"SET %s=%s\n", TEMPLATES, szPath);
   } else {
      return(1);
   }

   // APP_DATA should only be the last component of the path
   if (SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, szPath) == S_OK) {
      StripPath(szPath);
      fwprintf(file, L"SET %s=%s\n", APP_DATA, szPath);
   } else {
      return(1);
   }

   return(0);
}


int __cdecl main(INT argc, CHAR **argv)
{
   FILE *OutFP;
   WCHAR OutFN[MAXLEN+1];
   WCHAR EVName[MAXLEN+1];
   WCHAR KeyName[MAXLEN+1];
   WCHAR ValName[MAXLEN+1];
   WCHAR Temp[MAXLEN+1];
   WCHAR Opts[MAXLEN+1];
   struct HKEY__ *Hive;
   DWORD RetType, RetSize;
   HKEY TargetKey;
   LONG Ret;
	OptionBlock options;
   int  rc=0;

   //
   //  Process the command line arguments.  We expect:
   //
   //    acregl FileName EnvVarName KeyName ValueName Options
   //
   //  The program uses exit code 0 to indicate success or
   //  exit code 1 for failure.
   //

   if (argc != 6)
      return(1);

   setlocale(LC_ALL, ".OCP");

   if (ParseArg(argv[1], OutFN) <= 0)
      return(1);
   
   if (ParseArg(argv[2], EVName) <= 0)
      return(1);
   
   if (ParseArg(argv[3], Temp) <= 0)
      return(1);
   
   if (_wcsnicmp(L"HKLM\\", Temp, 5) == 0)
      Hive = HKEY_LOCAL_MACHINE;
   else if (_wcsnicmp(L"HKCU\\", Temp, 5) == 0)
      Hive = HKEY_CURRENT_USER;
   else
      return(1);
   wcscpy(KeyName,&Temp[5]);

   if (ParseArg(argv[4], ValName) < 0)  // Ok if 0 is returned
      return(1);
   
   if (ParseArg(argv[5], Opts) <= 0)
      return(1);

   if (ScanOptions(Opts, &options) != 0)
      return 1;

   // wprintf(L"OutFN   <%ws>\n",OutFN);
   // wprintf(L"EVName  <%ws>\n",EVName);
   // wprintf(L"KeyName <%ws>, Hive 0x%x\n",KeyName, Hive);
   // wprintf(L"ValName <%ws>\n",ValName);
   // wprintf(L"Opts    <%ws>\n",Opts);


   // If the GETPATHS option isn't specified, open the reg keys
   if (options.getPaths == 0) {

      //
      // Read the specified key and value from the registry.  The ANSI
      // registry functions are used because the command line arguments
      // are in ANSI and when we write the data out it also needs to be
      // in ANSI.
      //
   
      Ret = RegOpenKeyEx(Hive, KeyName, 0, KEY_READ, &TargetKey);
      if (Ret != ERROR_SUCCESS)
         return(1);
   
      RetSize = MAXLEN;
      Ret = RegQueryValueEx(TargetKey, ValName, 0, &RetType, (LPBYTE) &Temp, 
                            &RetSize);
      if (Ret != ERROR_SUCCESS)
         return(1);
      
      //Now we need to procedd DWORDs too
      if(RetType == REG_DWORD)
      {
          DWORD dwTmp = (DWORD)(*Temp);
          _itow((int)dwTmp,Temp,10);
      }
      RegCloseKey(TargetKey);
   }

   //
   //  Process Options
   // 

   //
   //  Write a SET statement to the specified file.  The file can be
   //  executed from a script which will set the indicated environment
   //  variable.  This is a round-about method, but there appears to be
   //  no easy method for setting environment variables in the parent's
   //  environment.
   //

   // wprintf(L"SET %s=%s\n",EVName,Temp);
   
   OutFP = _wfopen(OutFN, L"w");
   if (OutFP == NULL)
      return(1);

   if (options.stripNthChar != 0)
      StripChar(Temp, options.stripChar, options.stripNthChar);

   if (options.stripPath != 0)
      StripPath(Temp);

   if (options.getPaths != 0) {
      if (GetPaths(OutFP)) {
         rc = 1;
      }
   } else {
      fwprintf(OutFP, L"SET %s=%s\n", EVName, Temp);
   }

   fclose(OutFP);

   return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appsec\appsec\adddlg.h ===
INT_PTR CALLBACK
AddDlgProc(
    HWND    hdlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appsec\appsec\adddlg.cpp ===
#include "pch.h"
#include "AppSec.h"
#include "AddDlg.h"
#include "ListCtrl.h"
#include "resource.h"

extern HINSTANCE hInst;
extern HWND   g_hwndList;
extern LPWSTR g_aszLogonApps[];
extern LPWSTR g_aszDOSWinApps[];
extern WCHAR   g_szSystemRoot[MAX_PATH];
extern const int MAX_LOGON_APPS;
extern const int MAX_DOSWIN_APPS;
/*
 * Extern function prototypes.
 */
BOOL fnGetApplication( HWND hWnd, PWCHAR pszFile, ULONG cbFile, PWCHAR pszTitle );
BOOL bFileIsRemote( LPWSTR pName );
/*
 * Local function prototypes.
 */
BOOL AddApplicationToList( PWCHAR );
BOOL StartLearn(VOID);
BOOL StopLearn(VOID);
BOOL ClearLearnList(VOID);
BOOL display_app_list( HWND ListBoxHandle );
VOID ResolveName( WCHAR *appname, WCHAR *ResolvedName ) ; 

/******************************************************************************
 *
 *  AddDlgProc
 *
 *  Process messages for add button
 *
 *  EXIT:
 *    TRUE - if message was processed
 *
 *  DIALOG EXIT:
 *
 ******************************************************************************/

INT_PTR CALLBACK 
AddDlgProc(
    HWND    hdlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    static HWND hwndTrackList;
    static HWND hwndTrackButton;
    static BOOL bTracking=FALSE;
    WCHAR  szApp[MAX_PATH+1];
    WCHAR  szMsg[MAX_PATH+1];
    WCHAR  szTitle[MAX_PATH+1];
    WCHAR  szExpandedApp[MAX_PATH+1] ; 

    switch ( message ) {

        case WM_INITDIALOG:
            //  get handle to list box
            hwndTrackButton=GetDlgItem( hdlg, ID_TRACKING );
            if ( (!(hwndTrackList = GetDlgItem( hdlg, IDC_TRACK_LIST )))||
                (!InitList(hwndTrackList))) {
                LoadString( NULL, IDS_ERR_LB ,szMsg, MAX_PATH );
                LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
                MessageBox( hdlg, szMsg, szTitle, MB_OK);
                EndDialog( hdlg, IDCANCEL );
                return TRUE;
            }
            return FALSE;

        case WM_HELP:
            {

                LPHELPINFO phi=(LPHELPINFO)lParam;
                if(phi->dwContextId){
                    WinHelp(hdlg,L"APPSEC",HELP_CONTEXT,phi->iCtrlId);
                }else{
                    //WinHelp(hdlg,L"APPSEC",HELP_CONTENTS,0);
                }
            }
            break;

        case WM_DRAWITEM:
        {
            LPDRAWITEMSTRUCT pdis=(LPDRAWITEMSTRUCT)lParam;
            if(pdis->hwndItem==hwndTrackList){
                OnDrawItem(hwndTrackList,pdis);
            }
        }
        break;

        case WM_NOTIFY:
        {
            NMHDR* pnmhdr=(NMHDR*)lParam;
            if(pnmhdr->hwndFrom==hwndTrackList){

                NMLISTVIEW* pnmlv=(NMLISTVIEW*)pnmhdr;

                switch(pnmlv->hdr.code){

                case LVN_COLUMNCLICK:
                    SortItems(hwndTrackList,(WORD)pnmlv->iSubItem);
                    break;
                case LVN_DELETEITEM:
                    OnDeleteItem(hwndTrackList,pnmlv->iItem);
                    break;
                default:
                    break;
                }
            }
        }
        break;

        case WM_COMMAND :
            
            switch ( LOWORD(wParam) ) {

                case IDOK :
                    {
                        //Get item from edit box
                        szApp[0] = 0;
                        if ( GetDlgItemText( hdlg, IDC_ADD_PATH, szApp, MAX_PATH ) ) {
                            if ( lstrlen( szApp ) ) {
                                ExpandEnvironmentStrings(  (LPCTSTR) szApp , szExpandedApp , MAX_PATH+1 ); 
                                
                                if ( AddApplicationToList( szExpandedApp ) == FALSE ) {
                                    break;
                                }
                            }
                        }
                        //Get items from track list
                        int iItemCount=GetItemCount(hwndTrackList);
                        for(int i=0;i<iItemCount;i++)
                        {
                            if( GetItemText(hwndTrackList,i,szApp,MAX_PATH)!= -1 ) {
                                if ( lstrlen( szApp ) ) {
                                    ExpandEnvironmentStrings(  (LPCTSTR) szApp , szExpandedApp , MAX_PATH+1) ; 
                                                                        
                                    if ( AddApplicationToList( szExpandedApp ) == FALSE ) {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                    if(bTracking){
                        StopLearn();
                        bTracking=FALSE;
                    }
                    EndDialog( hdlg, IDOK );
                    return TRUE;

                case IDCANCEL :
                    if(bTracking){
                        StopLearn();
                        bTracking=FALSE;
                    }
                    EndDialog( hdlg, IDCANCEL );
                    return TRUE;
        
                case ID_BROWSE :
                    GetDlgItemText( hdlg, IDC_ADD_PATH, szApp, MAX_PATH );
                    LoadString( NULL, IDS_BROWSE_TITLE ,szMsg, MAX_PATH );
                    if ( fnGetApplication( hdlg, szApp, MAX_PATH, szMsg ) == TRUE ) {
                        SetDlgItemText( hdlg, IDC_ADD_PATH, szApp );
                    }
                    return TRUE;
                
                case ID_TRACKING:

                    
                    if(bTracking){

                        
                        //Stop Tracking
                        bTracking=FALSE;
                        LoadString( hInst, IDS_START_TRACKING ,szMsg, MAX_PATH );
                        SetWindowText(hwndTrackButton,szMsg);
                        
                        // set the learn_enable bit to 0
            
                        if ( !StopLearn() )
                        {
                    
                            LoadString( NULL, IDS_ERR_LF, szMsg, MAX_PATH );
                            LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
                            MessageBox( hdlg, szMsg, szTitle, MB_OK);
                        }

                        //Get catched processes from registry and fill TrackList
                        
                        display_app_list(hwndTrackList);
                        if(GetItemCount(hwndTrackList)){
                            EnableWindow(hwndTrackList,TRUE);
                            AdjustColumns(hwndTrackList);
                        }else{
                            EnableWindow(hwndTrackList,FALSE);
                        }
                        ClearLearnList() ;  
            
                    }else{
                        
                        //Start Tracking
                        bTracking=TRUE;
                        LoadString( hInst, IDS_STOP_TRACKING ,szMsg, MAX_PATH );
                        SetWindowText(hwndTrackButton,szMsg);

                        // set learn_enable bit to 1
                        
                        if ( !StartLearn() )
                        {
                        
                            LoadString( NULL, IDS_ERR_LF, szMsg, MAX_PATH );
                            LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
                            MessageBox( hdlg, szMsg, szTitle, MB_OK);

                        }

                        ClearLearnList() ; 
                        
                    }
                    return TRUE;

                case ID_DELETE_SELECTED:
                    DeleteSelectedItems(hwndTrackList);
                    if(GetItemCount(hwndTrackList)){
                        EnableWindow(hwndTrackList,TRUE);
                    }else{
                        EnableWindow(hwndTrackList,FALSE);
                    }

                    return TRUE;

                default : 

                    break;
            }

            break;

        default :

            break;
    }

    // We didn't process this message
    return FALSE;
}


/******************************************************************************
 *
 *  AddApplicationToList
 *
 *  Process messages for add app button
 *
 *  EXIT:
 *
 ******************************************************************************/

BOOL
AddApplicationToList( PWCHAR pszApplication )
{
    LONG  i;
    WCHAR  szMsg[MAX_PATH+1];
    WCHAR  szMsgEx[MAX_PATH+32];
    WCHAR  szTitle[MAX_PATH+1];
    WCHAR  ResolvedAppName[MAX_PATH] ; 

    /*
     *  Get app type
     */

    /*
     *  Get volume type
     */

    /*

    if ( bFileIsRemote( pszApplication ) ) {
        LoadString( NULL, IDS_ERR_REMOTE ,szMsg, MAX_PATH );
        LoadString( NULL, IDS_NW_ERR ,szTitle, MAX_PATH );            
        wsprintf( szMsgEx, szMsg, pszApplication );
        MessageBox( NULL, szMsgEx, szTitle, MB_OK );
        return( FALSE );
    }

    */

    ResolveName( 
        pszApplication,
        ResolvedAppName
    ) ;


    /*
     *  Is it part of LOGON or DOS/Win list?
     */
    WCHAR szTmp[MAX_PATH+1];

    for ( i=0; i<MAX_LOGON_APPS; i++ ) {
        wsprintf( szTmp, L"%s\\%s", g_szSystemRoot, g_aszLogonApps[i] );
        if ( !lstrcmpi( szTmp, pszApplication ) ) {
            return( TRUE );
        }
    }
    for ( i=0; i<MAX_DOSWIN_APPS; i++ ) {
        wsprintf( szTmp, L"%s\\%s", g_szSystemRoot, g_aszDOSWinApps[i] );
        if ( !lstrcmpi( szTmp, pszApplication ) ) {
            return( TRUE );
        }
    }
    
    /*
     *  Check for redundant string
     */
    if ( FindItem(g_hwndList, ResolvedAppName ) == -1 ) {

        /*
         *  Add this item to list
         */
        AddItemToList(g_hwndList, ResolvedAppName );
    }

    return( TRUE );
}

/*******************************************************************************
 *
 *  bFileIsRemote - NT helper function
 *
 * ENTRY:
 *    pName (input)
 *       path name
 *
 * EXIT:
 *    TRUE  - File is remote
 *    FALSE - File is local
 *
 ******************************************************************************/

BOOL
bFileIsRemote( LPWSTR pName )
{
    WCHAR Buffer[MAX_PATH];

    if ( !GetFullPathName( pName, MAX_PATH, Buffer, NULL ) )
        return FALSE;

    Buffer[3] = 0;

    if ( GetDriveType( Buffer ) == DRIVE_REMOTE )
        return TRUE;
    else
        return FALSE;

}  // end CheckForComDevice


//////////////////////////////////////////////////////////////////////////////////
//Tracking Procedures
//////////////////////////////////////////////////////////////////////////////////

/*++

Routine Description :

    This routine will set the LearnEnabled Flag in registry to 1 to 
    indicate the initiation of tracking mode.
    
Arguments :

    None.
    
Return Value :

    TRUE is successful.
    FALSE otherwise.
        
--*/     


BOOL StartLearn(VOID)
{

    
    HKEY TSkey ; 
    DWORD learn_enabled = 1 ; 
    DWORD size, disp ; 
    DWORD error_code ; 
    DWORD CurrentSessionId ; 


    if ( RegCreateKeyEx(
            HKEY_CURRENT_USER,
            LIST_REG_KEY, 
            0, 
            NULL,
            REG_OPTION_NON_VOLATILE, 
            KEY_ALL_ACCESS, 
            NULL, 
            &TSkey, 
            &disp
            ) != ERROR_SUCCESS) {
        
        return FALSE;
        
    }
    
    // Get CurrentSessionId
    
    if ( ProcessIdToSessionId( 
            GetCurrentProcessId(), 
            &CurrentSessionId 
            ) == 0 ) {
        RegCloseKey(TSkey); 
        return FALSE ;
    }           
    

    // Set the LearnEnabled flag to CurrentSessionId
    
    size = sizeof(DWORD) ; 
            
    if ( RegSetValueEx(
            TSkey,
            L"LearnEnabled", 
            0, 
            REG_DWORD,
            (CONST BYTE *) &CurrentSessionId, 
            size
            ) != ERROR_SUCCESS ) {
        RegCloseKey(TSkey); 
        return FALSE ;     
    }
    
    RegCloseKey(TSkey) ; 
    return TRUE ; 


}

/*++

Routine Description :

    This routine will set the LearnEnabled Flag in registry to 0 to 
    indicate the completion of tracking mode.
    
Arguments :

    None.
    
Return Value :

    TRUE is successful.
    FALSE otherwise.
        
--*/     

BOOL StopLearn(VOID)
{

    HKEY TSkey ; 
    DWORD learn_enabled = -1 ; 
    LONG size ; 
    DWORD disp, error_code ; 
    
    
    if ( RegCreateKeyEx(
            HKEY_CURRENT_USER, 
            LIST_REG_KEY, 
            0, 
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 
            NULL,
            &TSkey,
            &disp
            ) != ERROR_SUCCESS) {
        
        return FALSE;
        
    }

    // ReSet the LearnEnabled flag
    
    size = sizeof(DWORD) ; 
            
    if ( RegSetValueEx(
            TSkey,
            L"LearnEnabled",
            0,
            REG_DWORD,
            (CONST BYTE *) &learn_enabled, 
            size
            ) != ERROR_SUCCESS ) {
        RegCloseKey(TSkey);
        return FALSE ; 
    
    }
    
    RegCloseKey(TSkey) ; 
    
    return TRUE ; 
    
}


/*++

Routine Description :

    This routine will clear the registry used in Tracking mode. 
    
Arguments :

    None.
    
Return Value :

    TRUE is successful.
    FALSE otherwise.
        
--*/     

BOOL ClearLearnList(VOID)
{

    HKEY list_key ; 
    DWORD learn_enabled = 0 ; 
    WCHAR buffer_sent[2] ; 
    
    DWORD error_code ; 

    if ( RegOpenKeyEx(
            HKEY_CURRENT_USER, 
            LIST_REG_KEY, 
            0, 
            KEY_ALL_ACCESS, 
            &list_key 
            ) != ERROR_SUCCESS)  {
        
        return FALSE;        
    }
    
    buffer_sent[0] = L'\0' ;
    buffer_sent[1] = L'\0' ; 

    // Clear the ApplicationList
    
    if ( RegSetValueEx(
            list_key,
            L"ApplicationList", 
            0, 
            REG_MULTI_SZ,
            (CONST BYTE *) buffer_sent, 
            2 * sizeof(WCHAR) 
            ) != ERROR_SUCCESS ) {
        RegCloseKey(list_key);    
        return FALSE;        
    }
            
    RegCloseKey(list_key) ; 
    
    return TRUE ; 

}

/*++

Routine Description :

    This function will display the applications tracked in the
    tracking mode onto a dialog box.
        
Arguments :

    ListBoxHandle - handle to the ListBox used in Tracking mode.
    
Return Value :

    TRUE is successful.
    FALSE otherwise.
        
--*/     

BOOL display_app_list( HWND ListBoxHandle )

{
    BOOL status = FALSE ;
    
    ULONG size = 0; 
    WCHAR *buffer_sent ; 
    UINT i, j = 0 ; 
    HKEY list_key ; 
    DWORD error_code ; 

    
    /* First open the list_reg_key */
    
    if ( error_code=RegOpenKeyEx(
                        HKEY_CURRENT_USER, 
                        LIST_REG_KEY,
                        0, 
                        KEY_READ, 
                        &list_key 
                        ) != ERROR_SUCCESS) {
            return (status) ; 
    }
    
    /* First find out size of buffer to allocate */    
    
    if ( error_code=RegQueryValueEx(
                        list_key, 
                        L"ApplicationList", 
                        NULL, 
                        NULL,
                        (LPBYTE) NULL , 
                        &size
                        ) != ERROR_SUCCESS ) {

        RegCloseKey(list_key) ; 
        return (status) ; 
    }
    
    buffer_sent =  (WCHAR *)LocalAlloc(LPTR,size); 
    if(!buffer_sent) {

        RegCloseKey(list_key) ; 
        return (status) ; 
    }

    if ( error_code=RegQueryValueEx(
                        list_key, 
                        L"ApplicationList", 
                        NULL, 
                        NULL,
                        (LPBYTE) buffer_sent , 
                        &size
                        ) != ERROR_SUCCESS ) {

        RegCloseKey(list_key) ;
        LocalFree(buffer_sent);
        return(status) ; 
    }
    
    size=size/sizeof(WCHAR)-1;//get size in characters excluding terminating 0

    for(i=0 ; i < size ; i++ ) {
        
        if(wcslen(buffer_sent+i)){             
            AddItemToList(ListBoxHandle, buffer_sent+i ) ;          
        }
        
        i+=wcslen(buffer_sent+i);
        //now buffer_sent[i]==0
        //00- end of data
    } /* end of for loop */
    
    status = TRUE ; 
    
    RegCloseKey(list_key) ; 
    LocalFree(buffer_sent);

    return(status) ; 
   
} /* end of display_app_list */


/*++

Routine Description :

    This Routine checks if the application resides in a local drive 
    or a remote network share. If it is a remote share, the UNC path
    of the application is returned. 
    
Arguments :
    
    appname - name of the application

Return Value :

    The UNC path of the appname if it resides in a remote server share.
    The same appname if it resides in a local drive.
    
--*/     

VOID 
ResolveName(
    WCHAR *appname,
    WCHAR *ResolvedName
    )
    
{

    UINT i ; 
    INT length ; 
    WCHAR LocalName[3] ; 
    WCHAR RootPathName[4] ; 
    WCHAR RemoteName[MAX_PATH] ; 
    DWORD size = MAX_PATH ; 
    DWORD DriveType, error_status ; 
    
    memset(ResolvedName, 0, MAX_PATH * sizeof(WCHAR)) ; 
    
    // check if appname is a app in local drive or remote server share
   
    wcsncpy(RootPathName, appname, 3 ) ;
    RootPathName[3] = L'\0';
    
    DriveType = GetDriveType(RootPathName) ;

    if (DriveType == DRIVE_REMOTE) {
        
        // Use WNetGetConnection to get the name of the remote share
        
        wcsncpy(LocalName, appname, 2 ) ;
        LocalName[2] = L'\0' ; 

        error_status = WNetGetConnection (
                           LocalName,
                           RemoteName,
                           &size
                           ) ;     

        if (error_status != NO_ERROR) {
        
            wcscpy(ResolvedName,appname) ; 
            return ;
        }
        
        wcscpy( ResolvedName, RemoteName ) ;
        
        length = wcslen(ResolvedName) ;

        ResolvedName[length++] = L'\\' ; 
        
        for (i = 3 ; i <= wcslen(appname) ; i++ ) {
            ResolvedName[length++] = appname[i] ; 
        }
        
        ResolvedName[length] = L'\0' ; 
        
        return ; 
        

    } else {
    
        wcscpy(ResolvedName,appname) ; 
        return ;
        
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appsec\appsec\appsec.cpp ===
/******************************************************************************
*
*   AppSec.c
*
*   This module contains code for the AppSec utility.
*   This utility is used to configure and maintain applications on
*   a WinFrame Internet server (used to secure the ActiveX client).
*
*   Copyright Citrix Systems Inc. 1997
*
*   Author: Kurt Perry (kurtp)
*
*   Date: 22-Aug-1996
*
*   $Log:   N:\nt\private\utils\citrix\winutils\appsec\VCS\appsec.c  $
*
*     Rev 1.8   Aug 11 2000  - alhen
*  bug 158727 GetBinaryType results aren't bitfields
*   ------------------------------------------------------------------------
*
*     Rev 1.7   June-July 1999 - added Tracking mode interface and dialogs
*
*   ------------------------------------------------------------------------
*
*     Rev 1.6   May 09 1998 15:31:18   tyl
*  bug 2475 - added loadwc.exe into preload
*
*     Rev 1.5   May 03 1998 21:17:06   tyl
*  bug 1852 - appsec now preloads couple more files some of which are non-binary
*  appsec doesn't check if the file is binary anymore
*
*     Rev 1.4   Apr 28 1998 09:29:26   tyl
*  bug 2134 - "Browse" is no longer hardcoded
*
*     Rev 1.2   Apr 13 1998 16:17:02   tyl
*   bug 1856 - appsec utility now pre-load the following applications in the edi
*   box when it is initially started: cmd.exe, subst.exe, xcopy.exe, net.exe,
*   regini.exe, systray.exe, and explorer.exe
*
*     Rev 1.1   29 Dec 1997 16:06:56   thanhl
*  Hydra merge
*
*     Rev 1.1   26 Sep 1997 19:03:50   butchd
*  Hydra registry name changes
*
*     Rev 1.0   31 Jul 1997 09:09:32   butchd
*  Initial revision.
*
*******************************************************************************/


/*
 *  Include files stuff
 */
#include "pch.h"
#include "resource.h"

#pragma hdrstop


#include "AppSec.h"
#include "ListCtrl.h"
#include "AddDlg.h"
#include <winsta.h>
#include <regapi.h>
#include "utildll.h"
#include <accctrl.h>
#include <aclapi.h>
/*
 * Local function prototypes.
 */
INT_PTR CALLBACK AppSecDlgProc(HWND hdlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
BOOL             AddApplicationToList( PWCHAR );
VOID             UpdateApplicationList( VOID );
LONG             ReadRegistry( VOID );
VOID             LoadInitApp(VOID);


/*
 *  Local vars
 */

HINSTANCE hInst;
INT    dxTaskman;
INT    dyTaskman;
INT    dxScreen;
INT    dyScreen;

DWORD  g_fEnabled = 0;
HWND   g_hwndDialog;
HWND   g_hwndList;

WCHAR   g_szTemp[MAX_PATH];
WCHAR   g_szApplication[MAX_PATH];

WCHAR   g_szFirstHiddenApp[MAX_PATH];
WCHAR   g_szSecondHiddenApp[MAX_PATH];
WCHAR   g_szThirdHiddenApp[MAX_PATH];
WCHAR   g_szFourthHiddenApp[MAX_PATH];

WCHAR   g_szSystemRoot[MAX_PATH];


/*
 *  DOS or Win16 binary filetypes
 *  DOSWIN_APP_FILETYPES (SCS_DOS_BINARY|SCS_PIF_BINARY|SCS_WOW_BINARY)
 */


/*
 *  Below is the list of default (necessary) applications
 */

/*
 *  This is a list of init apps.
 */

LPWSTR g_aszInitApps[] = {
   L"system32\\loadwc.exe",
   L"system32\\cmd.exe",
   L"system32\\subst.exe",
   L"system32\\xcopy.exe",
   L"system32\\net.exe",
   L"system32\\regini.exe",
   L"system32\\systray.exe",
   L"explorer.exe",
   L"system32\\attrib.exe",
   L"Application Compatibility Scripts\\ACRegL.exe",
   L"Application Compatibility Scripts\\ACsr.exe",
   L"system32\\ntsd.exe"
};

#define MAX_INIT_APPS (sizeof(g_aszInitApps)/sizeof(g_aszInitApps[0]))

/*
 *  NOTE: userinit.exe MUST be first in list!!!!
 *
 *  This is done to "hide" system programs from the user of this utility!
 */

LPWSTR g_aszLogonApps[] = {
    L"system32\\userinit.exe",
    L"system32\\wfshell.exe",
    L"system32\\chgcdm.exe",
    L"system32\\nddeagnt.exe",
};
extern const int MAX_LOGON_APPS=(sizeof(g_aszLogonApps)/sizeof(g_aszLogonApps[0]));

LPWSTR g_aszDOSWinApps[] = {
    L"system32\\command.com",
    L"system32\\dosx.exe",
    L"system32\\himem.sys",
    L"system32\\krnl386.exe",
    L"system32\\mscdexnt.exe",
    L"system32\\ntvdm.exe",
    L"system32\\nw16.exe",
    L"system32\\redir.exe",
    L"system32\\vwipxspx.exe",
    L"system32\\win.com",
    L"system32\\wowdeb.exe",
    L"system32\\wowexec.exe",
};
extern const int MAX_DOSWIN_APPS=(sizeof(g_aszDOSWinApps)/sizeof(g_aszDOSWinApps[0]));



/*** AppSecDlgProc -- Dialog Procedure for AppSec
 *
 *
 *
 * AppSecDlgProc(HWND hdlg, WORD wMSG, WPARAM wParam, LPARAM lParam)
 *
 * ENTRY -         HWND hhdlg                 - handle to dialog box.
 *                 WORD wMsg                  - message to be acted upon.
 *                 WPARAM wParam              - value specific to wMsg.
 *                 LPARAM lParam              - value specific to wMsg.
 *
 * EXIT  -           True if success, False if not.
 * SYNOPSIS -  Dialog box message processing function.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

INT_PTR CALLBACK
AppSecDlgProc(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    RECT   rc;
    POINT  pt;
    WPARAM idSelected;
    WCHAR  szMsg[MAX_PATH];
    WCHAR  szTitle[MAX_PATH];


    BOOL ClearLearnList(VOID) ;

    switch (wMsg) {

    case WM_INITDIALOG:

        //  locate dialog
        GetWindowRect(hwnd, &rc);
        dxTaskman = rc.right - rc.left;
        dyTaskman = rc.bottom - rc.top;
        dxScreen = GetSystemMetrics(SM_CXSCREEN);
        dyScreen = GetSystemMetrics(SM_CYSCREEN);

        pt.x = (dxScreen - dxTaskman) / 2;
        pt.y = (dyScreen - dyTaskman) / 2;

        //  on top!
        SetWindowPos(hwnd, HWND_NOTOPMOST, pt.x, pt.y, 0, 0,
           SWP_NOSIZE | SWP_NOACTIVATE);

        //  get handle to list box
        if ( (!(g_hwndList = GetDlgItem( hwnd, IDC_APP_LIST )))||
            (!InitList(g_hwndList))) {
            LoadString( NULL, IDS_ERR_LB ,szMsg, MAX_PATH );
            LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
            MessageBox( hwnd, szMsg, szTitle, MB_OK);
            ExitProcess(0);
        }

        //  Get SystemRoot path
        GetEnvironmentVariable( L"SystemRoot", g_szSystemRoot, MAX_PATH );

        //  Generate hidden applications
        wsprintf( g_szFirstHiddenApp, L"%s\\%s", g_szSystemRoot, g_aszLogonApps[0] );
        wsprintf( g_szSecondHiddenApp, L"%s\\%s", g_szSystemRoot, g_aszLogonApps[1] );
        wsprintf( g_szThirdHiddenApp, L"%s\\%s", g_szSystemRoot, g_aszLogonApps[2] );
        wsprintf( g_szFourthHiddenApp, L"%s\\%s", g_szSystemRoot, g_aszLogonApps[3] );

        //  get registry data
        if ( ReadRegistry() == 0 ) {
            LoadInitApp();
            UpdateApplicationList();
        }
        AdjustColumns(g_hwndList);

        //  set radio button default state
        if ( g_fEnabled ) {
            SendDlgItemMessage( hwnd, IDC_SECURITY_ENABLED,  BM_SETCHECK, TRUE, 0 );
            SendDlgItemMessage( hwnd, IDC_SECURITY_DISABLED, BM_SETCHECK, FALSE, 0 );
        }
        else {
            SendDlgItemMessage( hwnd, IDC_SECURITY_ENABLED,  BM_SETCHECK, FALSE, 0 );
            SendDlgItemMessage( hwnd, IDC_SECURITY_DISABLED, BM_SETCHECK, TRUE, 0 );
        }

        return FALSE;

    case WM_HELP:
        {
            LPHELPINFO phi=(LPHELPINFO)lParam;
            if(phi->dwContextId){
                WinHelp(hwnd,L"APPSEC",HELP_CONTEXT,phi->iCtrlId);
            }else{
                WinHelp(hwnd,L"APPSEC",HELP_FINDER,0);
            }
        }
        break;

    case WM_DRAWITEM:
        {
            LPDRAWITEMSTRUCT pdis=(LPDRAWITEMSTRUCT)lParam;
            if(pdis->hwndItem==g_hwndList){
                OnDrawItem(g_hwndList,pdis);
            }
        }
        break;

    case WM_NOTIFY:
        {
            NMHDR* pnmhdr=(NMHDR*)lParam;
            if(pnmhdr->hwndFrom==g_hwndList){

                NMLISTVIEW* pnmlv=(NMLISTVIEW*)pnmhdr;

                switch(pnmlv->hdr.code){

                case LVN_COLUMNCLICK:
                    SortItems(g_hwndList,(WORD)pnmlv->iSubItem);
                    break;
                case LVN_DELETEITEM:
                    OnDeleteItem(g_hwndList,pnmlv->iItem);
                    break;
                default:
                    break;
                }
            }
        }
        break;

    case WM_COMMAND:

        switch(LOWORD(wParam)) {

        case IDHELP :

            WinHelp(hwnd, L"appsec", HELP_CONTENTS, 0);
            break;

        case IDOK :

            PostQuitMessage(0);
            break;

        case IDC_SECURITY_ENABLED :

            /*
             *  Set enabled flag
             */
            g_fEnabled = 1;

            /*
             *  Update registry
             */
            UpdateApplicationList();

        // Show the WARNING Message Box

        LoadString( NULL, IDS_WARNING_TEXT ,szMsg, MAX_PATH );
            LoadString( NULL, IDS_WARNING ,szTitle, MAX_PATH );
            MessageBox( NULL, szMsg, szTitle, MB_OK);

            break;

        case IDC_SECURITY_DISABLED :

            /*
             *  Clear enabled flag
             */
            g_fEnabled = 0;

            /*
             *  Update registry
             */
            UpdateApplicationList();

            break;

        case ID_ADD :

            /*
             *  Get application
             */
            DialogBox( hInst, MAKEINTRESOURCE(DLG_ADD), hwnd, AddDlgProc );

            /*
             *  Update list and registry
             */
            UpdateApplicationList();
            AdjustColumns(g_hwndList);
            break;

        case ID_DELETE :

            //  are items selected?
            if ( ((idSelected = GetSelectedItemCount( g_hwndList )) != -1) &&
                  (idSelected != 0) ) {

                //  ask first
                LoadString( NULL, IDS_REMOVE ,szMsg, MAX_PATH );
                LoadString( NULL, IDS_DELETE ,szTitle, MAX_PATH );
                if ( MessageBox(hwnd, szMsg, szTitle, MB_OKCANCEL) == IDOK ) {
                    DeleteSelectedItems(g_hwndList);
                }
                /*
                 *  Update list
                 */
                UpdateApplicationList();
            }
            break;
        }

        break;

    case WM_CLOSE:

        PostQuitMessage(0);
        break;

    default:

        return FALSE;

    }

    return TRUE;

    lParam;
}

/******************************************************************************
 *
 *  UpdateApplicationList
 *
 *  Update list and registry
 *
 *  EXIT:
 *
 ******************************************************************************/

VOID
UpdateApplicationList()
{
    ULONG i;
    ULONG  cbItem;
    ULONG  cbTotal = 0;
    LPWSTR  p;

    LPWSTR  pApplicationList = NULL;
    DWORD  Disp;
    HKEY   hkApp;
    DWORD  dwBinaryType;
    BOOL   fDOSWin = FALSE;

    /*
     *  Count bytes needed for LOGON Apps
     */
    for ( i=0; i<MAX_LOGON_APPS; i++ ) {
        wsprintf( g_szTemp, L"%s\\%s", g_szSystemRoot, g_aszLogonApps[i] );
        cbTotal += lstrlen( g_szTemp ) + 1;
    }

    /*
     *  Count bytes needed for DOS/Win
     */
    for ( i=0; i<MAX_DOSWIN_APPS; i++ ) {
        wsprintf( g_szTemp, L"%s\\%s", g_szSystemRoot, g_aszDOSWinApps[i] );
        cbTotal += lstrlen( g_szTemp ) + 1;
    }

    /*
     *  Count bytes needed for list box
     */
    for ( i=0; ; i++ ) {

        /*
         *  Get current index
         */

        if ( (cbItem = GetItemText( g_hwndList, i,NULL,0 )) == -1 ) {
            break;
        }

        /*
         *  Count these bytes
         */
        cbTotal += cbItem + 1;
    }


    /*
     *  Write to registry
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, AUTHORIZEDAPPS_REG_NAME, 0,
                       KEY_ALL_ACCESS, &hkApp ) != ERROR_SUCCESS ) {

        /*
         *  Create key, if that works then just write value, new entry
         */
        if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, AUTHORIZEDAPPS_REG_NAME, 0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                             NULL, &hkApp, &Disp ) != ERROR_SUCCESS ) {
            return;
        }

        // After creating the key, give READ access to EVERYONE

    }

    /*
     *  Allocate memory (extra null)
     */
    if ( (pApplicationList = (WCHAR *)LocalAlloc(0, (++cbTotal) * sizeof(WCHAR) )) !=NULL ) {

        /*
         *  Clear buffer
         */
        memset( pApplicationList, 0, cbTotal * sizeof(WCHAR));

        /*
         *  Add apps from list box
         */
        for ( i=0, cbTotal=1, p=pApplicationList; ; i++ ) {

            /*
             *  Get current index
             */
            if ( (cbItem = GetItemText( g_hwndList, i, p,MAX_PATH )) == -1 ) {
                break;
            }

            /*
             *  Get app type
             *  Bug 158727 Whistler.
             */
            if ( GetBinaryType( p, &dwBinaryType ) == TRUE )
            {
                if( dwBinaryType == SCS_DOS_BINARY ||
                    dwBinaryType == SCS_PIF_BINARY || 
                    dwBinaryType == SCS_WOW_BINARY )
                {
                    fDOSWin = TRUE;
                }
            }
            p += cbItem + 1;
            cbTotal += cbItem + 1;

        }
        /*
         *  Add LOGON apps
         */
        for ( i=0; i<MAX_LOGON_APPS; i++ ) {
            wsprintf( p, L"%s\\%s", g_szSystemRoot, g_aszLogonApps[i] );
            cbItem = lstrlen( p );
            p += cbItem + 1;
            cbTotal += cbItem + 1;
        }

        /*
         *  Add DOS/Win apps if necessary
         */
        if ( fDOSWin ) {
            for ( i=0; i<MAX_DOSWIN_APPS; i++ ) {
                wsprintf( p, L"%s\\%s", g_szSystemRoot, g_aszDOSWinApps[i] );
                cbItem = lstrlen( p );
                p += cbItem + 1;
                cbTotal += cbItem + 1;
            }
        }

        /*
         *  Just write this value, the key has just been created
         */
        RegSetValueEx( hkApp, CTXAPPS_APPLICATIONLIST, 0, REG_MULTI_SZ,
                       (CONST BYTE *)pApplicationList, cbTotal * sizeof(WCHAR));

        /*
         *  Done with memory
         */
        LocalFree( pApplicationList );
    }

    /*
     *  Write enabled flag
     */
    RegSetValueEx( hkApp, CTXAPPS_ENABLED, 0, REG_DWORD,
               (BYTE *)&g_fEnabled, sizeof(DWORD) );

    /*
     *  Done with key
     */
    RegCloseKey( hkApp );
}


/******************************************************************************
 *
 *  LoadInitApp
 *
 *  Load the init apps into the list box
 *
 *  EXIT:
 *
 ******************************************************************************/
 VOID
 LoadInitApp(){
    WPARAM i;
    ULONG  cbItem;
    ULONG  cbTotal = 0;
    LPWSTR  p;

    // find the MAX length of InitApps
    for (i=0;i<MAX_INIT_APPS;i++) {
       cbItem = lstrlen(g_aszInitApps[i]);
       if (cbItem>cbTotal) {
          cbTotal = cbItem;
       }
    }

    // one  for the \ and one for the null
    cbTotal += 2 + lstrlen(g_szSystemRoot);

    /*
     *  Allocate memory (extra null)
     */
    if ( (p = (WCHAR *)LocalAlloc(0, (cbTotal) * sizeof(WCHAR) )) !=NULL ) {
        /*
         *  Add INIT apps
         */
        for ( i=0; i<MAX_INIT_APPS; i++ ) {
            wsprintf( p, L"%s\\%s", g_szSystemRoot, g_aszInitApps[i] );
            AddItemToList( g_hwndList, p );
        }

        /*
         *  Done with memory
         */
        LocalFree( p );
    }

 }


/******************************************************************************
 *
 *  ReadRegistry
 *
 *  Update list from registry
 *
 *  EXIT:
 *
 ******************************************************************************/

LONG
ReadRegistry()
{
    DWORD DataType;
    ULONG  InLength = 0;
    LPWSTR p;
    LPWSTR pApplicationList = NULL;
    HKEY  hkApp;
    DWORD ValueType;
    DWORD ValueSize = sizeof(DWORD);

    /*
     *  Read from registry
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, AUTHORIZEDAPPS_REG_NAME, 0,
                       KEY_ALL_ACCESS, &hkApp ) != ERROR_SUCCESS ) {
        return( InLength );
    }

    /*
     *  Get size of MULTI_SZ strings
     */
    (void) RegQueryValueEx( hkApp, CTXAPPS_APPLICATIONLIST, NULL, &DataType,
                            NULL, &InLength );

    /*
     *  Entries?
     */
    if ( InLength ) {

        /*
         *  Allocate memory (extra null)
         */
        if ( (pApplicationList = (WCHAR *)LocalAlloc(0, (++InLength) * sizeof(WCHAR))) != NULL ) {

            /*
             *  Read in list
             */
            if ( RegQueryValueEx( hkApp, CTXAPPS_APPLICATIONLIST,
                                  NULL, &DataType, (BYTE *)pApplicationList,
                                  &InLength ) == ERROR_SUCCESS ) {

                /*
                 *  Walk it
                 */
                p = pApplicationList;
                while ( *p ) {

                    if ( (p[0] == '\0') && (p[1] == '\0') ) break ;

                    //  once we get to first LOGON app we are done adding to window
                    // we shud not display the LOGON apps to the listbox

                    if ( !lstrcmpi( p, g_szFirstHiddenApp ) ) {
                        p += lstrlen(p) + 1;
                        continue;
                    }

                    if ( !lstrcmpi( p, g_szSecondHiddenApp ) ) {
                        p += lstrlen(p) + 1;
                        continue;
                    }

                    if ( !lstrcmpi( p, g_szThirdHiddenApp ) ) {
                        p += lstrlen(p) + 1;
                        continue;
                    }

                    if ( !lstrcmpi( p, g_szFourthHiddenApp ) ) {
                        p += lstrlen(p) + 1;
                        continue;
                    }

                    //  add to listbox

                    AddItemToList(g_hwndList,p);
                    //  next
                    p += lstrlen(p) + 1;
                }
            }

            /*
             *  Done with list
             */
            LocalFree( pApplicationList );
        }
    }

    /*
     *  Get enable key
     */
    if ( RegQueryValueEx( hkApp, CTXAPPS_ENABLED, NULL, &ValueType,
                  (LPBYTE) &g_fEnabled, &ValueSize ) != ERROR_SUCCESS ) {
    g_fEnabled = 0;
    }

    /*
     *  Done with key
     */
    RegCloseKey( hkApp );

    return( InLength );
}


/*** Main --         Program entry point (was WinMain).
 *
 *
 *
 * Main(int argc, char *argv[], char *envp[])
 *
 * ENTRY -         int argc                - argument count.
 *                        char *argv[]        - argument list.
 *                        char *envp[]        - environment.
 *
 * EXIT  -           TRUE if success, FALSE if not.
 * SYNOPSIS -  Parses command line, for position to place dialog box, if no
 *                                position (came from ctl/esc) then center on screen.
 *                                Also make sure only one instance of taskman.
 *
 * WARNINGS -
 * EFFECTS  -
 */
#ifdef _DEBUG
#include <crtdbg.h>
#endif _DEBUG

INT _cdecl main(
   INT argc,
   CHAR *argv[],
   CHAR *envp[])
{
    MSG msg;
    WCHAR szTitle[MAX_PATH];
    WCHAR szMsg[MAX_PATH];
    HANDLE AppsecEventHandle ;
    DWORD error_code ;

#ifdef _DEBUG
    //detecting memory leaks
    // Get current flag
    int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
    // Turn on leak-checking bit
    tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
    // Set flag to the new value
    _CrtSetDbgFlag( tmpFlag );

#endif _DEBUG

    AppsecEventHandle = CreateEvent(NULL, TRUE, FALSE, EVENT_NAME ) ;

    if (AppsecEventHandle == NULL)
    {
        error_code = GetLastError() ;
    }

    error_code = GetLastError() ;

    if (error_code == ERROR_ALREADY_EXISTS)
    {
        LoadString( NULL, IDS_ERR_INSTANCE ,szMsg, MAX_PATH );
        LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
        MessageBox( NULL, szMsg, szTitle, MB_OK);
        CloseHandle(AppsecEventHandle) ;

        ExitProcess(0) ;
    }



    // SetEvent(AppsecEventHandle) ;

    // WaitForSingleObject(AppsecEventHandle, INFINITE) ;

    //  get instance handle
    hInst = GetModuleHandle(NULL);

    // FALSE/TRUE params in the following means check for
    // local admin / domain admin respectively
    if( ( TestUserForAdmin( FALSE ) != TRUE )  &&
        ( TestUserForAdmin( TRUE ) != TRUE ) )
    {
        LoadString( NULL, IDS_ERR_ADMIN, szMsg, MAX_PATH );
        LoadString( NULL, IDS_ERROR, szTitle, MAX_PATH );
        MessageBox( NULL, szMsg, szTitle, MB_OK | MB_ICONEXCLAMATION );

        return( FALSE );
    }

    //  create us
    g_hwndDialog = CreateDialog(hInst, MAKEINTRESOURCE(DLG_MAIN_TITLE), NULL,
         AppSecDlgProc);

    //  bug us?
    if (g_hwndDialog == NULL)
        return 0;


    //  show us
    ShowWindow(g_hwndDialog, SW_NORMAL);


    HACCEL hAccel=LoadAccelerators(hInst,MAKEINTRESOURCE(IDR_ACCELERATORS));

    //  process input
    while (GetMessage(&msg, (HWND)NULL, (UINT)0, (UINT)0)) {
        if (!TranslateAccelerator(g_hwndDialog,hAccel,&msg)){
            //if (!IsDialogMessage(g_hwndDialog, &msg)) {
                TranslateMessage (&msg);
                DispatchMessage (&msg);
            //}
        }
    }

    DestroyWindow(g_hwndDialog);

    ResetEvent(AppsecEventHandle) ;
    CloseHandle(AppsecEventHandle) ;

    //ExitProcess(0) ;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appsec\appsec\appsec.h ===
#define LIST_REG_KEY L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server"

#define LEARN_REG_KEY L"System\\CurrentControlSet\\Control\\Terminal Server\\AuthorizedApplications"

#define EVENT_NAME L"Global\\AppsecEvent"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appsec\appsec\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_ROOT            =.


make_root:
    binplace -R $(_NTTREE) $(_ROOT)\APPSEC.HLP
    binplace -R $(_NTTREE) $(_ROOT)\APPSEC.CNT

clean: make_root
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appsec\appsec\listctrl.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ListCtrl.cpp

Abstract:

    Functions working with Owner Draw List Control.
Author:

    Sergey Kuzin (a-skuzin@microsoft.com) 26-July-1999

Environment:


Revision History:


--*/


#include "pch.h"
#include "ListCtrl.h"
#include "resource.h"


extern HINSTANCE hInst;


//////////////////////////////////////////////////////////////////////
//Class CItemData
//////////////////////////////////////////////////////////////////////
const LPWSTR CItemData::m_wszNull=L"";

/*++

Routine Description :

        Constructor - initializes object.
        
Arguments :

        IN LPCWSTR wszText - Full name of application file.
        
Return Value :

        none
                
--*/
CItemData::CItemData(LPCWSTR wszText)
        :m_wszText(NULL),m_sep(0)
{

        if(wszText){
                int size=wcslen(wszText);
                m_wszText=new WCHAR[size+1];

                if(!m_wszText) {
                    ExitProcess(1);
                }

                wcscpy(m_wszText,wszText);
                m_sep=size-1;
                while((m_sep)&&(wszText[m_sep]!='\\')){
                        m_sep--;
                }
        }
        else
                m_wszText=m_wszNull;
}

/*++

Routine Description :

        Destructor - deletes allocated buffer.
        
Arguments :

        none
        
Return Value :

        none
                
--*/
CItemData::~CItemData()
{
        if((m_wszText)&&(m_wszText!=m_wszNull)){
                delete[] m_wszText;
        }
}

//////////////////////////////////////////////////////////////////////
//List Control functions
//////////////////////////////////////////////////////////////////////


/*++

Routine Description :

        This routine adds Image List and columns "Name" and "Path" to List Control.
        
Arguments :

        IN HWND hwndListList - Control Handle.
        
Return Value :

        TRUE is successful.
        FALSE otherwise.
                
--*/


BOOL
InitList(
        HWND hwndList)
{

        HIMAGELIST hImageList=ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                GetSystemMetrics(SM_CYSMICON),ILC_MASK,1,1);
        if(!hImageList)
                return FALSE;
        HICON hIcon=LoadIcon(hInst,MAKEINTRESOURCE(IDI_APP));
        if (!hIcon) {
           return FALSE;
        }
        int ind=ImageList_AddIcon(hImageList,hIcon);
        DeleteObject(hIcon);
        ListView_SetImageList(hwndList,hImageList,LVSIL_SMALL);


        
        //Create Columns
        LVCOLUMN lvc;
        lvc.mask=LVCF_FMT|LVCF_WIDTH|LVCF_TEXT|LVCF_SUBITEM;
        lvc.fmt=LVCFMT_LEFT;
        lvc.cx=150;
        lvc.iSubItem=0;
        lvc.iImage=0;
        lvc.iOrder=0;
        lvc.cchTextMax=0;
        lvc.pszText=L"Name";
        if(ListView_InsertColumn(hwndList,0,&lvc)==-1){
                return FALSE;
        }
        
        RECT Rect;
        GetClientRect(hwndList,&Rect);
        lvc.cx=Rect.right-150;
        lvc.iSubItem=1;
        lvc.iOrder=1;
        lvc.pszText=L"Path";
        if(ListView_InsertColumn(hwndList,1,&lvc)==-1){
                return FALSE;
        }
        return TRUE;
}


/*++

Routine Description :

        This routine adds Item (file) to List Control.
        
Arguments :

        IN HWND hwndList - List Control Handle.
        IN LPCWSTR pwszText - Text for the Item (full path and file name)
        
Return Value :

        TRUE is successful.
        FALSE otherwise.
                
--*/
BOOL
AddItemToList(
        HWND hwndList,
        LPCWSTR pwszText)
{
        

        CItemData* pid=new CItemData(pwszText);

        if (pid == NULL) {
           return FALSE;
        }

        //get file icon
        SHFILEINFO shfi;
        ZeroMemory(&shfi,sizeof( SHFILEINFO ));
        SHGetFileInfo( pwszText, 0, &shfi, sizeof( SHFILEINFO ),
               SHGFI_ICON | SHGFI_SMALLICON  );
        

        //insert item
        LVITEM lvi;
        ZeroMemory(&lvi,sizeof(LVITEM));
        lvi.mask=LVIF_PARAM|LVIF_TEXT;
    lvi.iItem=(int) SendMessage(hwndList,LVM_GETITEMCOUNT,(WPARAM)0,(LPARAM)0);
        lvi.iSubItem=0;
        lvi.pszText=pid->Name();
    lvi.lParam=(LPARAM)pid;
        
        //set icon for item
        if(shfi.hIcon){
                HIMAGELIST hImageList=(HIMAGELIST)SendMessage(hwndList,LVM_GETIMAGELIST,
                        (WPARAM)LVSIL_SMALL,(LPARAM)0);
                pid->SetImage(ImageList_AddIcon(hImageList,shfi.hIcon));
                DestroyIcon(shfi.hIcon);
        }else{
                pid->SetImage(0);
        }

        if(SendMessage(hwndList,LVM_INSERTITEM,(WPARAM)0,(LPARAM)&lvi)==-1){
                delete pid;
                return FALSE;
        }

        lvi.iSubItem=1;
        lvi.pszText=pid->Path();
        SendMessage(hwndList,LVM_SETITEMTEXT,(WPARAM)lvi.iItem,(LPARAM)&lvi);

        return TRUE;    
}

/*++

Routine Description :

        This routine returns full path for item.
        
Arguments :

        IN HWND hwndList - List Control Handle.
        IN int iItem - Iten ID
        OUT LPWSTR pwszText - buffer (can be NULL)
                if not NULL it must be at least cchTextMax+1 characters long
        IN int cchTextMax - buffer size (in characters)
        
Return Value :

        Number of characters in item text.
        -1 if error.
                
--*/

int
GetItemText(
        HWND hwndList,
        int iItem,
        LPWSTR pwszText,
        int cchTextMax)
{
        //if pwszText=NULL then retreive length of string
        
        CItemData* pid=GetItemData(hwndList,iItem);
        if(!pid){
                return -1;
        }
        if(pwszText){
                wcsncpy(pwszText,LPWSTR(*pid),cchTextMax);
                pwszText[cchTextMax]=0;
        }
        return wcslen(LPWSTR(*pid));
        
}

/*++

Routine Description :

        This routine deletes all selected items in List Control.
        
Arguments :

        IN HWND hwndList - List Control Handle.

        
Return Value :

        none
                
--*/
void
DeleteSelectedItems(
        HWND hwndList)
{
        //get image list
        HIMAGELIST hImageList=(HIMAGELIST)SendMessage(hwndList,LVM_GETIMAGELIST,
                                        (WPARAM)LVSIL_SMALL,(LPARAM)0);

        int iItems=(int) SendMessage(hwndList,LVM_GETITEMCOUNT,(WPARAM)0,(LPARAM)0);
        UINT uiState=0;
        int i=0;
        LVITEM lvi;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_STATE | LVIF_IMAGE;
        lvi.stateMask = LVIS_SELECTED;

        while(i<iItems){
                lvi.iItem = i;
                SendMessage( hwndList,LVM_GETITEM, (WPARAM)0,(LPARAM)&lvi );
                if(lvi.state&LVIS_SELECTED){

                        //delete item
                        SendMessage(hwndList,LVM_DELETEITEM,(WPARAM)i,(LPARAM)0);
                        
                        iItems--; //decrease item count

                        //delete icon from list
                        //it will change some icon indexes
                        if(lvi.iImage){
                                if(ImageList_Remove(hImageList,lvi.iImage)){
                                        //decrement icon indexes of all items down the list
                                        //(items may be sorted in any order)
                                        int iDeletedImage=lvi.iImage;
                                        lvi.mask=LVIF_IMAGE;
                                        for(int j=0;j<iItems;j++)
                                        {
                                                
                                                lvi.iItem=j;
                                                SendMessage( hwndList,LVM_GETITEM, (WPARAM)0,(LPARAM)&lvi );
                                                if(lvi.iImage>iDeletedImage)
                                                        lvi.iImage--;
                                                SendMessage( hwndList,LVM_SETITEM, (WPARAM)0,(LPARAM)&lvi );
                                        }
                                        lvi.mask=LVIF_STATE | LVIF_IMAGE;//restore mask
                                }
                                
                        }

                }else{
                        i++;
                }
        }

}

/*++

Routine Description :

        This routine returns number of selected items in List Control.
        
Arguments :

        IN HWND hwndList - List Control Handle.

        
Return Value :

        number of selected items
                
--*/
int
GetSelectedItemCount(
        HWND hwndList)
{
        return (int) SendMessage( hwndList, LVM_GETSELECTEDCOUNT, (WPARAM) 0, (LPARAM) 0 );
}

/*++

Routine Description :

        This routine returns number of items in List Control.
        
Arguments :

        IN HWND hwndList - List Control Handle.

        
Return Value :

        number of items
                
--*/
int
GetItemCount(
        HWND hwndList)
{
        return (int) SendMessage( hwndList, LVM_GETITEMCOUNT, (WPARAM) 0, (LPARAM) 0 );
}

/*++

Routine Description :

        This routine finds item with specific text in List Control.
        
Arguments :

        IN HWND hwndList - List Control Handle.
        IN LPCWSTR pwszText - text of the item
        
Return Value :

        ID of found item
        -1 if item is ont found
                
--*/

int
FindItem(
        HWND hwndList,
        LPCWSTR pwszText)
{
        //Get item count
        int iItems=(int) SendMessage(hwndList,LVM_GETITEMCOUNT,(WPARAM)0,(LPARAM)0);

        for(int i=0;i<iItems;i++){
                CItemData* pid=GetItemData(hwndList,i);
                if((pid)&&(!lstrcmpi(pwszText,LPWSTR(*pid)))){
                        return i;
                }
        }

        return -1;
}

/*++

Routine Description :

        This routine deletes item data object wthen the item is going to be deleted.
        
Arguments :

        IN HWND hwndList - List Control Handle.
        IN int iItem - item to delete
        
Return Value :

        none
                
--*/
void
OnDeleteItem(
        HWND hwndList,
        int iItem)
{
        CItemData* pid=GetItemData(hwndList,iItem);
        if(pid){
                delete pid;
        }
}

/*++

Routine Description :

        Get CItemData object corresponding to the item.
        
Arguments :

        IN HWND hwndList - List Control Handle.
        IN int iItem - item index
        
Return Value :

        pointer ot CItemData object
        NULL - if error
                
--*/
CItemData*
GetItemData(
        HWND hwndList,
        int iItem)
{
        LVITEM lvi;
        ZeroMemory(&lvi,sizeof(lvi));
        lvi.mask=LVIF_PARAM;
        lvi.iItem=iItem;
        if(SendMessage(hwndList,LVM_GETITEM,(WPARAM)0,(LPARAM)&lvi)){
                return (CItemData*)lvi.lParam;
        }else{
                return NULL;
        }
}

/*++

Routine Description :

        This routine compares two items.
        
Arguments :

        LPARAM lParam1 - First item.
        LPARAM lParam2 - Second item
        LPARAM lParamSort - parameters
        
Return Value :

        none
                
--*/
int CALLBACK
CompareFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort)
{
        CItemData* pid1=(CItemData*)lParam1;
        CItemData* pid2=(CItemData*)lParam2;
        
        WORD wSubItem=LOWORD(lParamSort);
        WORD wDirection=HIWORD(lParamSort);

        if(wSubItem){
                if(wDirection){
                        return lstrcmpi(pid1->Path(),pid2->Path());
                }else{
                        return -lstrcmpi(pid1->Path(),pid2->Path());
                }
        }else{
                if(wDirection){
                        return lstrcmpi(pid1->Name(),pid2->Name());
                }else{
                        return -lstrcmpi(pid1->Name(),pid2->Name());
                }
        }
}

/*++

Routine Description :

        This routine sorts items.
        
Arguments :

        IN HWND hwndList - List Control Handle.
        IN int iSubItem - subitem to sort
        
Return Value :

        none
                
--*/

#define DIRECTION_ASC   0x10000
#define DIRECTION_DESC  0

void
SortItems(
        HWND hwndList,
        WORD wSubItem)
{
        static DWORD fNameSortDirection=DIRECTION_DESC;
        static DWORD fPathSortDirection=DIRECTION_DESC;
        
        WPARAM ParamSort;

        //change direction
        if(wSubItem){
                if(fPathSortDirection){
                        fPathSortDirection=DIRECTION_DESC;
                }else{
                        fPathSortDirection=DIRECTION_ASC;
                }
                ParamSort=fPathSortDirection;
        }else{
                if(fNameSortDirection){
                        fNameSortDirection=DIRECTION_DESC;
                }else{
                        fNameSortDirection=DIRECTION_ASC;
                }
                ParamSort=fNameSortDirection;
        }

        ParamSort+=wSubItem;    
                        
        SendMessage(hwndList,LVM_SORTITEMS,(WPARAM)ParamSort,(LPARAM)CompareFunc);      
}





//////////////////////////////////////////////////////////////////////////////////////
//Message Handlers
//////////////////////////////////////////////////////////////////////////////////////

/*++

Routine Description :

        This routine draws item.
        
Arguments :

        IN HWND hwndList - List Control Handle.
        IN LPDRAWITEMSTRUCT lpdis
        
Return Value :

        none
                
--*/
void
OnDrawItem(
        HWND hwndList,
        LPDRAWITEMSTRUCT lpdis)
{
    if (lpdis->itemID == -1) {
        return ;
    }
        SetROP2(lpdis->hDC, R2_COPYPEN);

    switch (lpdis->itemAction) {

        case ODA_SELECT:
                        //TRACE("######  SELECTED   #####");
        case ODA_DRAWENTIRE:
                {
                        
                        int     iBkColor,iTxtColor;
                                
                        // Determine the colors
                        if (lpdis->itemState & ODS_SELECTED){
                                iBkColor=COLOR_HIGHLIGHT;
                                iTxtColor=COLOR_HIGHLIGHTTEXT;
                        }else{
                                iBkColor=COLOR_WINDOW;
                                iTxtColor=COLOR_WINDOWTEXT;
                        }
                        
                        //get item data
                        CItemData* pid=GetItemData(hwndList,lpdis->itemID);
                        if(!pid){
                                return;
                        }
                        
                        //Draw Image.
                        // Erase the background
                        HBRUSH hOldBrush=(HBRUSH)SelectObject(lpdis->hDC,
                                CreateSolidBrush( GetSysColor(iBkColor)));
                        PatBlt( lpdis->hDC,
                                        lpdis->rcItem.left,
                                        lpdis->rcItem.top,
                                        lpdis->rcItem.right-lpdis->rcItem.left,
                                        lpdis->rcItem.bottom-lpdis->rcItem.top,
                                        PATCOPY);
                        //Select old brush and delete new one!!!
                        if(hOldBrush)
                        {
                            HBRUSH hTempBrush = (HBRUSH)SelectObject(lpdis->hDC,hOldBrush);
                            if(hTempBrush)
                            {
                                DeleteObject(hTempBrush);
                            }
                        }
                        //get image list
                        HIMAGELIST hImageList=(HIMAGELIST)SendMessage(hwndList,LVM_GETIMAGELIST,
                                        (WPARAM)LVSIL_SMALL,(LPARAM)0);
                        // Draw Image
                        
                        if(SendMessage(hwndList,LVM_GETCOLUMNWIDTH,(WPARAM)0,(LPARAM)0)>
                                (GetSystemMetrics(SM_CXSMICON)+2)){
                                ImageList_Draw(
                                                hImageList,
                                                pid->GetImage(),
                                                lpdis->hDC,
                                                lpdis->rcItem.left+2,
                                                lpdis->rcItem.top,
                                                ILD_TRANSPARENT);
                        }
                        
                        /*
                        LOGFONT lf;
                        HFONT hOldFont=(HFONT)GetCurrentObject(lpdis->hDC,OBJ_FONT);
                        GetObject(hOldFont,sizeof(LOGFONT),&lf);
                        lf.lfHeight=lpdis->rcItem.bottom-lpdis->rcItem.top;
                        HFONT hNewFont=CreateFontIndirect(&lf);
                        SelectObject(lpdis->hDC,hNewFont);
                        */
                        SetTextColor(lpdis->hDC,GetSysColor(iTxtColor));

                        int width=0;
                        RECT CellRect;
                        int nColumns=2;//we have 2 columns
            for(int i=0;i<nColumns;i++)
                        {
                                if(i==0)//for first column we have icon
                                        CellRect.left=lpdis->rcItem.left+GetSystemMetrics(SM_CXSMICON)+4;
                                else
                                        CellRect.left=lpdis->rcItem.left+width+2;
                                CellRect.top=lpdis->rcItem.top;
                                width+=(int) SendMessage(hwndList,LVM_GETCOLUMNWIDTH,(WPARAM)i,(LPARAM)0);
                                CellRect.right=lpdis->rcItem.left+width;
                                CellRect.bottom=lpdis->rcItem.bottom;
                                if(i==0){
                                        DrawText(lpdis->hDC,pid->Name(),-1,&CellRect,DT_VCENTER|DT_END_ELLIPSIS);
                                }else{
                                        DrawText(lpdis->hDC,pid->Path(),-1,&CellRect,DT_VCENTER|DT_END_ELLIPSIS);
                                }
                        }
                        
                        /*
                        SelectObject(lpdis->hDC,hOldFont);
                        DeleteObject(hNewFont);
                        */
                        // Draw the Focus rectangle
                        /*
                        if (lpdis->itemState & ODS_FOCUS){
                                DrawFocusRect(lpdis->hDC,&lpdis->rcItem);
                        }
                        */
            break;
                }

        case ODA_FOCUS:
                        //TRACE("######  FOCUSED   #####");
            /*
             * Do not process focus changes. The focus caret
             * (outline rectangle) indicates the selection.
             * The Which one? (IDOK) button indicates the final
             * selection.
             */

            break;
                default:
                        break;
    }

}

void
AdjustColumns(
        HWND hwndList)
{
        SendMessage(hwndList,LVM_SETCOLUMNWIDTH,(WPARAM)0,(LPARAM)LVSCW_AUTOSIZE_USEHEADER);
        SendMessage(hwndList,LVM_SETCOLUMNWIDTH,(WPARAM)1,(LPARAM)LVSCW_AUTOSIZE_USEHEADER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appsec\appsec\pch.h ===
#pragma once

#ifdef MYCMP

#include <windows.h>
#include <stierr.h>
#include <stdio.h>
#include <lm.h>

#else
// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// Public windows headers.
//
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <common.ver>

#endif MYCMP

#include <commctrl.h>
#include <shellapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appsec\appsec\listctrl.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ListCtrl.h

Abstract:

	Header for ListCtrl.cpp

Author:

    Sergey Kuzin (a-skuzin@microsoft.com) 26-July-1999

Revision History:

--*/

#pragma once

/*++
class CItemData:
	pointer to object of this class 
	located in lParam member of LVITEM structure 
	for each item.
--*/
class CItemData
{
private:
	static const LPWSTR	m_wszNull;//empty string

	LPWSTR	m_wszText;//Full file name.
	int		m_sep;//index of '\\' character separating file name and path.
	int		m_iImage;//Image index.
public:
	CItemData(LPCWSTR wszText);
	~CItemData();
	operator LPWSTR()
	{ 
		if(m_sep){
			m_wszText[m_sep]='\\';
		}
		return m_wszText;
	}
	LPWSTR Name()
	{
		if(m_sep){
			return m_wszText+m_sep+1;
		}else{
			return m_wszText;
		}
	}
	LPWSTR Path()
	{
		if(m_sep){
			m_wszText[m_sep]=0;
			return m_wszText;
		}else{
			return m_wszNull;
		}
	}
	void SetImage(int ind)
	{
		m_iImage=(ind==-1)?0:ind;
	}
	int GetImage()
	{
		return m_iImage;
	}

};


BOOL
InitList(
	HWND hwndList);

BOOL
AddItemToList(
	HWND hwndList,
	LPCWSTR pwszText);

int
GetItemText(
	HWND hwndList,
	int iItem,
	LPWSTR pwszText,
	int cchTextMax);

void
DeleteSelectedItems(
	HWND hwndList);

int
GetSelectedItemCount(
	HWND hwndList);

int
GetItemCount(
	HWND hwndList);

int
FindItem(
	HWND hwndList,
	LPCWSTR pwszText);

void
OnDeleteItem(
	HWND hwndList,
	int iItem);

CItemData*
GetItemData(
	HWND hwndList,
	int iItem);

void
SortItems(
	HWND hwndList,
	WORD wSubItem);

void
OnDrawItem(
	HWND hwndList,
	LPDRAWITEMSTRUCT pdis);

void 
AdjustColumns(
	HWND hwndList);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appsec\appsec\commdlg.cpp ===
/******************************************************************************
*
*   COMMDLG.C
*
*   Implements the common dialog functions.
*
*   Copyright Citrix Systems Inc. 1997
*
*   Author: Kurt Perry (kurtp) 22-Aug-1996
*
*   $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\APPSEC\VCS\COMMDLG.C  $
*  
*       Rev 2.0   28 Jul 1999 - dialog changed from "Save File" to "Open File",
                                                        some bugs fixed.

*   Rev 1.0   31 Jul 1997 09:09:46   butchd
*       
*  Initial revision.
*  
*******************************************************************************/

#include "pch.h"
#include "appsec.h"
#include "resource.h"
#include <commdlg.h>


/*
 *  Global vars
 */

extern HINSTANCE hInst;

/******************************************************************************
 *
 *  fnGetApplication
 *
 *  Implements the 
 *
 *  ENTRY:
 *
 *  EXIT:
 *
 *****************************************************************************/

BOOL 
fnGetApplication( HWND hWnd, PWCHAR pszFile, ULONG cbFile, PWCHAR pszTitle )
{
    static WCHAR szDirName[MAX_PATH+1]={0};
    WCHAR szFilter[MAX_PATH+1];
        
    WCHAR chReplace;
    INT   i;
    ULONG cbString;

        //Separate file and dir names

    WCHAR *sep=wcsrchr(pszFile,L'\\');
        
    if(sep){
            *sep=0;
            wcscpy(szDirName,pszFile);
            wcscpy(pszFile,sep+1);
    }else{
            if(!wcslen(szDirName)){//initialize only 1st time; remember last dir
                   GetSystemDirectory( szDirName, MAX_PATH );
            }
    }

    cbString = LoadString( hInst, IDS_FILTERSTRING, szFilter, MAX_PATH );

    if (cbString == 0) {
       return FALSE;
    }

    chReplace = szFilter[cbString - 1];

    for ( i = 0; szFilter[i] != L'\0'; i++ ) {

        if ( szFilter[i] == chReplace ) {
            szFilter[i] = L'\0';
        }
    }
        
    OPENFILENAME ofn;

    ZeroMemory(&ofn,sizeof(ofn));
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hWnd;
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = pszFile;
    ofn.nMaxFile = cbFile;
    ofn.lpstrInitialDir = szDirName;
    ofn.Flags = OFN_NOCHANGEDIR | OFN_FILEMUSTEXIST | OFN_NONETWORKBUTTON | OFN_PATHMUSTEXIST;
    ofn.lpstrTitle = pszTitle;

    if ( GetOpenFileName( &ofn ) ) {
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appsec\appsec\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AppSec.rc
//


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appsec\appsec\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AppSec.rc
//
#define IDC_TRACK_LIST                  1000
#define ID_DELETE                       1002
#define ID_DELETE_SELECTED              1003
#define ID_TRACKING                     1004
#define IDC_APP_LIST                    1005
#define ID_ADD                          1006
#define IDC_SECURITY					1007
#define IDC_SECURITY_ENABLED			1008
#define IDC_SECURITY_DISABLED			1009
#define IDC_ADD_PATH					1010
#define ID_BROWSE						1011
#define DLG_MAIN_TITLE					100
#define DLG_ADD							101
#define IDS_FILTERSTRING				900
#define IDS_ERR_LB			            901
#define IDS_ERROR						902
#define IDS_REMOVE						903
#define IDS_DELETE						904
#define IDS_ERR_EXE						905
#define IDS_FILE_ERR					906
#define IDS_ERR_REMOTE					907
#define IDS_NW_ERR						908
#define IDS_ERR_ADMIN					909
#define IDS_SEC_ERROR					910
#define IDS_ADD							911
#define IDS_ADD_CONFIRM					912
#define IDS_ERR_LF 						913
#define IDS_ERR_INSTANCE				914
#define IDS_BROWSE_TITLE				915
#define IDS_START_TRACKING              916
#define IDS_STOP_TRACKING               917
#define IDS_WARNING                     918
#define IDS_WARNING_TEXT                919

#define IDI_APP                         601

#define IDR_ACCELERATORS                103

#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appsec\setup\pch.h ===
#pragma once

// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// Public windows headers.
//
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appsec\dll\appsecdll.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name :   
    
    appsecdll.h
    
Abstract :

    Defines the MACROS used in appsecdll.c  
    
Author :

    Sriram (t-srisam) June 1999
    
--*/        

#define APPCERT_IMAGE_OK_TO_RUN     1    
#define APPCERT_CREATION_ALLOWED    2    
#define APPCERT_CREATION_DENIED     3    

#define FENABLED_KEY                L"fEnabled"
#define LEARN_ENABLED_KEY           L"LearnEnabled"
#define AUTHORIZED_APPS_LIST_KEY    L"ApplicationList" 
#define TRACK_LIST_KEY              L"ApplicationList"
#define POWER_USERS_KEY             L"PowerUsers"

#define APPS_REGKEY                 L"System\\CurrentControlSet\\Control\\Terminal Server\\AuthorizedApplications"
#define LIST_REGKEY                 L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server"

NTSTATUS    CreateProcessNotify ( LPCWSTR lpApplicationName,ULONG Reason ) ;
BOOL        check_list( HKEY hkey , LPWSTR appname ) ; 
BOOL        add_to_list( HKEY hkey, LPCWSTR appname ) ; 
VOID        ResolveName ( LPCWSTR appname, WCHAR *ResolvedName ) ; 
BOOL        IsPowerUser(VOID); 

HANDLE g_hMutex = NULL ; 

LPCTSTR MUTEX_NAME = L"Global\\CPN_mutex" ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appsec\dll\appsecdll.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name :   
    
    appsecdll.c
    
Abstract :

    Exports a function CreateProcessNotify - this function decides whether
    the new process can be created.
    
Revision History :

    Sep 2000 - added support for Short File Names; PowerUsers not affected by AppSec - SriramSa    
    
Author :

    Sriram Sampath (SriramSa) June 1999
    
--*/        


#include "pch.h"
#pragma hdrstop

#include "appsecdll.h"

BOOL APIENTRY 
DllMain (
    HANDLE hInst, 
    DWORD ul_reason, 
    LPVOID lpReserved
    )
    
{

    switch (ul_reason) {
    
        case DLL_PROCESS_ATTACH : 

            // Disable Thread Lib calls - performance optimisation
            
            DisableThreadLibraryCalls (hInst);
            break ; 
            
        case DLL_PROCESS_DETACH :
        
            break ;
            
    } // end of switch
    
    return 1 ;

    UNREFERENCED_PARAMETER(hInst) ;
    UNREFERENCED_PARAMETER(lpReserved) ;

}

/*++

Routine Description :

    This routine determines if a process can be created based on whether
    it is a system process and if the user is an admin or not.
    
Arguments :

    lpApplicationName - process name
    Reason - the reason this CreateProcessNotify is called  

Return Value :

    STATUS_SUCCESS if the process can be created ; 
    STATUS_ACCESS_DEINIED if the process cannot be created.
    
--*/     

NTSTATUS 
CreateProcessNotify ( 
    LPCWSTR lpApplicationName,
    ULONG Reason 
    ) 
    
{
    
    INT         size ; 
    HKEY        TSkey, list_key, learn_key ;
    WCHAR       g_szSystemRoot[MAX_PATH] ;
    WCHAR       CurrentProcessName[MAX_PATH] ;
    WCHAR       LongApplicationName[MAX_PATH] ; 
    WCHAR       CorrectAppName[MAX_PATH] ; 
    WCHAR       ResolvedAppName[MAX_PATH] ;  
    BOOL        is_taskman = FALSE , is_system = FALSE ; 
    BOOL        check_flag = FALSE, taskman_flag = FALSE, add_status ; 
    BOOL        IsAppSecEnabled = TRUE ; 
    DWORD       is_enabled = 0, learn_enabled = 0, PowerUserEnabled = 0; 
    DWORD       dw, disp, error_code, CurrentSessionId, RetValue, dwTimeOut = 1000; 
    
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ sizeof( TOKEN_STATISTICS ) ];
    ULONG       ReturnLength;
    LUID        CurrentLUID = { 0, 0 };
    LUID        SystemLUID = SYSTEM_LUID;
    NTSTATUS    Status, QueryStatus;
        
    BOOL        IsMember, IsAnAdmin = FALSE;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
    PSID        AdminSid = FALSE ;
    
    if ( Reason != APPCERT_IMAGE_OK_TO_RUN ) {
        return STATUS_SUCCESS ;
    }

    // First Check if the fEnabled key to see if Security is Enabled
    // This is done by checking the fEnabled key in the Registry

    if ( RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, 
            APPS_REGKEY,
            0, 
            KEY_READ, 
            &TSkey
            ) != ERROR_SUCCESS ) {

        return STATUS_SUCCESS ; 
        
    }
    
    size = sizeof(DWORD) ; 

    if ( RegQueryValueEx(
            TSkey,
            FENABLED_KEY, 
            NULL, 
            NULL,
            (LPBYTE) &is_enabled, 
            &size
            ) != ERROR_SUCCESS ) {
        
        goto error_cleanup ; 
        
    }
    
    if (is_enabled == 0) {
        
        // Security is not Enabled

        IsAppSecEnabled = FALSE ;     
        
    }

    // Check if the PowerUsers key in the registry is Enabled or not
    if ( RegQueryValueEx(
        TSkey,
        POWER_USERS_KEY, 
        NULL, 
        NULL,
        (LPBYTE) &PowerUserEnabled, 
        &size
        ) != ERROR_SUCCESS ) {

        PowerUserEnabled = 0;
    }
    
    //
    // Check if the process which is trying to launch the new process is a system process. 
    // This is done by querying the Token information of the current process and 
    // comparing it's LUID with the LUID of a Process running under system context.
    //

    Status = NtOpenProcessToken( 
                NtCurrentProcess(),
                TOKEN_QUERY,
                &TokenHandle 
                );
                                         
    if ( !NT_SUCCESS(Status) ) {
            is_system = TRUE ; 
    }

    if ( ! is_system ) {

        QueryStatus = NtQueryInformationToken( 
                          TokenHandle, 
                          TokenStatistics, 
                          &TokenInformation,
                          sizeof(TokenInformation), 
                          &ReturnLength 
                          );
                      
        if ( !NT_SUCCESS(QueryStatus) ) {
            goto error_cleanup ; 
        }
                          

        NtClose(TokenHandle);

        RtlCopyLuid(
            &CurrentLUID,
            &(((PTOKEN_STATISTICS)TokenInformation)->AuthenticationId)
            );

        //
        // If the process is running in System context, 
        // we allow it to be created without further check
        // The only exception to this is, we do not allow WinLogon to launch TaskManager 
        // unless it is in the authorized list
        //
                    
        if ( RtlEqualLuid(
                &CurrentLUID, 
                &SystemLUID
                ) ) {
                
            is_system = TRUE ;

        }

    }
            
    // Check if Task Manager is spawned by a System Process

    if (is_system) {

        GetEnvironmentVariable( L"SystemRoot", g_szSystemRoot, MAX_PATH ) ;
        swprintf(CurrentProcessName, L"%s\\System32\\taskmgr.exe", g_szSystemRoot ) ; 

        if ( _wcsicmp( CurrentProcessName, lpApplicationName ) != 0 ) {
               
            goto error_cleanup ;

        } 

    }
        
    //
    // if not a system Process check if the user is a Administrator 
    // This is done by comparing the SID of the current user to that of an Admin
    //

    if ( NT_SUCCESS(
            RtlAllocateAndInitializeSid(
                &SystemSidAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &AdminSid
                ) 
            ) ) {
            
        if ( CheckTokenMembership( 
                 NULL,
                 AdminSid,
                 &IsAnAdmin
                 ) == 0 )   {
                
            goto error_cleanup ; 
            
        }       
          
        RtlFreeSid(AdminSid);
        
    }

    //
    // If the user is an Admin, see if we are in the Tracking mode
    // We are in Tracking mode if the LearnEnabled Flag in Registry contains the Current Session ID 
    //
        
    if (IsAnAdmin == TRUE ) {

        // Check the LearnEnabled flag to see if Tracking mode 
            
        if ( RegOpenKeyEx(
                HKEY_CURRENT_USER, 
                LIST_REGKEY,
                0, 
                KEY_READ, 
                &learn_key
                ) != ERROR_SUCCESS ) {
               
            goto error_cleanup ;     
        
        }
            
        if ( RegQueryValueEx(
                learn_key,
                LEARN_ENABLED_KEY, 
                NULL, 
                NULL,
                (LPBYTE) &learn_enabled, 
                &size
                ) != ERROR_SUCCESS ) {
            
        
            RegCloseKey(learn_key) ;
            goto error_cleanup ;  
        
        }
            
        RegCloseKey(learn_key) ; 
            
        if (learn_enabled == -1) {
              
            // Tracking is not enabled 
                
            goto error_cleanup ; 
                
        } else {
            
            // Tracking is enabled
            // now get current session and see if it is the same as
            // the one in which tracking is enabled
                   
            // Get CurrentSessionId
    
            if ( ProcessIdToSessionId( 
                    GetCurrentProcessId(), 
                    &CurrentSessionId 
                    ) == 0 ) {

                goto error_cleanup ; 
            }    
                
            if (learn_enabled != CurrentSessionId) {

                // dont add to the list of tracked applications
                    
                goto error_cleanup ;    
            }       
                
            // Tracking phase is enabled - build the list 
            // add this process name to the AppList registry
              
            // Create the Mutex for Synchronization when adding to list
            
            g_hMutex = CreateMutex(
                           NULL, 
                           FALSE,
                           MUTEX_NAME
                           ) ; 
    
            if (g_hMutex == NULL) {
                goto error_cleanup ; 
            }
    
            // Wait to Enter the Critical Section - wait for a max of 1 minute
  
            dw = WaitForSingleObject(g_hMutex, dwTimeOut) ; 
                
            if (dw == WAIT_OBJECT_0) {
                
                //
                // Create the Registry Key which will hold the applications tracked 
                // during tracking period
                //

                if ( RegCreateKeyEx(
                        HKEY_CURRENT_USER, 
                        LIST_REGKEY,
                        0, 
                        NULL, 
                        REG_OPTION_VOLATILE, 
                        KEY_ALL_ACCESS, 
                        NULL, 
                        &list_key, 
                        &disp
                        ) != ERROR_SUCCESS) {

                    ReleaseMutex(g_hMutex) ; 
                    CloseHandle(g_hMutex) ; 
                    goto error_cleanup ; 
       
               }
                    
               // Add this application name to the list in registry 
                
               add_status = add_to_list (
                                list_key, 
                                lpApplicationName 
                                ) ; 
                
            } // Done adding to the list
                
            ReleaseMutex(g_hMutex) ; 
                
            // Out of the Critical Section

            CloseHandle(g_hMutex) ;
            RegCloseKey(list_key) ; 
            goto error_cleanup ; 
                    
        } // ending of Tracking phase
        
    } // User is an admin 
        
    // Check if user is a PowerUser
    if ((PowerUserEnabled == 1) && (IsPowerUser())) {
        goto error_cleanup ; 
    }

    // User is not an admin - also it is not a system process 

    // Check if AppSec is enabled - if yes check the authorized list of apps

    if (IsAppSecEnabled == FALSE) {
    
        // AppSec is not enabled - so no need to check the authorized list of apps

        goto error_cleanup ;

    }
        
    // The filename may be in a short form - first convert it into the long form

    RetValue = GetLongPathNameW( (LPCWSTR) lpApplicationName, LongApplicationName, MAX_PATH) ;  
    if (RetValue == 0) {
        // error - so use the original app name, not the long one
        wcscpy(CorrectAppName, lpApplicationName) ; 
    } else { 
        wcscpy(CorrectAppName, LongApplicationName) ; 
    }
    //
    // Resolve Application name - if may reside in a remote server and share
    // 
        
    ResolveName(
        CorrectAppName,
        ResolvedAppName
        ); 
                              
    // Read the AuthorizedApplications List and compare with current Appname 
        
    check_flag = check_list( 
                    TSkey, 
                    ResolvedAppName
                    ) ;
        
    RegCloseKey(TSkey) ;

    //
    // If the current AppName is not in authorized list return ACCESS_DENIED 
        
    if (check_flag == FALSE) {
       
        return STATUS_ACCESS_DENIED ; 
            
    } else {

        return STATUS_SUCCESS ;

    }
    
    //
    // Error cleanup code
    // Close the Registry Key where we store authorized apps and return SUCCESS
    //

    error_cleanup :
    
        RegCloseKey(TSkey) ; 
        return STATUS_SUCCESS; 
    
} // end of CreateProcessNotify 


/*++

Routine Description :

    This routine checks if a process name is in a specified list 
    of authorised applications in the registry.
    
Arguments :
    
    hkey - The handle to the registry key which has the list of 
    authorised applications.
           
    appname - name of the process               

Return Value :

    TRUE if process is in the list of authorised applications.
    FALSE otherwise.
    
--*/     

BOOL 
check_list( 
    HKEY hkey,
    LPWSTR appname 
    )
    

{
    WCHAR   c ; 
    INT     i, j = 0 ; 
    DWORD   error_code ; 
    DWORD   RetValue ; 
    LONG    value,size = 0 ; 
    BOOL    found = FALSE ;
    WCHAR   *buffer_sent, *app ; 
    WCHAR   LongAppName[MAX_PATH] ; 
    WCHAR   AppToCompare[MAX_PATH] ; 

    // First find out size of buffer to allocate 
    // This buffer will hold the authorized list of apps
    
    if ( RegQueryValueEx(
            hkey, 
            AUTHORIZED_APPS_LIST_KEY,
            NULL, 
            NULL,
            (LPBYTE) NULL,
            &size
            ) != ERROR_SUCCESS ) {

        return TRUE ; 
    }
    
    buffer_sent = (WCHAR *) malloc ( size * sizeof(WCHAR)) ; 
    
    if (buffer_sent == NULL) {
        return TRUE ;
    }
    
    app = (WCHAR *) malloc ( size * sizeof(WCHAR)) ;     
    
    if (app == NULL) {
        free(buffer_sent) ; 
        return TRUE ;
    }
    
    memset(buffer_sent, 0, size * sizeof(WCHAR) ) ; 
    memset(app, 0, size * sizeof(WCHAR) ) ; 

    // Get the List of Authorized applications from the Registry 
    
    if ( RegQueryValueEx(
            hkey, 
            AUTHORIZED_APPS_LIST_KEY, 
            NULL, 
            NULL,
            (LPBYTE) buffer_sent,
            &size
            ) != ERROR_SUCCESS ) {

        free(buffer_sent) ;
        free(app) ; 
        return TRUE ; 
    }
    
    // check if the process is present in the Authorized List
    
    for(i=0 ; i <= size-1 ; i++ ) {

        // check for end of list
        
        if ( (buffer_sent[i] == L'\0') &&
                (buffer_sent[i+1] == L'\0') ) {
             
            break ; 
        }
        
        while ( buffer_sent[i] != L'\0' ) {
        
            app[j++] = buffer_sent[i++] ;
            
        }
                
        app[j++] = L'\0' ; 
        // The filename may be in a short form - first convert it into the long form
        RetValue = GetLongPathNameW( (LPCWSTR) app, LongAppName, MAX_PATH) ;  
        if (RetValue == 0) {
            // GetLongPathNameW failed for an app in the authorized list
            // maybe the file in the authorized list doesn't exist anymore
            wcscpy( AppToCompare, app) ; 
        } else { 
            wcscpy(AppToCompare, LongAppName) ; 
        }

        // Compare if this app is the one that is being queried now

        if ( _wcsicmp(appname, AppToCompare) == 0 ) {
        
            // this process is present in the Authorized List
            found = TRUE ; 
            break ; 
        }
        
        j = 0 ; 
        
    } // end of for loop 
    
    free(buffer_sent) ;
    free(app) ; 
    
    return(found) ; 
   
} // end of function 


/*++

Routine Description :

    This routine appends a process name to a list maintained in 
    Registry Key - used in Tracking mode.
    
Arguments :
    
    hkey - The handle to the registry key which has the list of 
           applications tracked.
           
    appname - name of the process               

Return Value :

    TRUE if process is appended successfully.
    FALSE otherwise.
    
--*/     

BOOL
add_to_list(
    HKEY hkey,
    LPCWSTR appname 
    )
    
{
    
    WCHAR   c ; 
    INT     i, j = 0 ; 
    UINT    k ; 
    DWORD   error_code ; 
    BOOL    status = FALSE ; 
    LONG    value, size = 0, new_size ; 
    WCHAR   *buffer_got, *buffer_sent ; 

    // First find out size of buffer to allocate 
    // This buffer will hold the applications which are tracked 
    
    if ( RegQueryValueEx(
            hkey, 
            TRACK_LIST_KEY, 
            NULL, 
            NULL,
            (LPBYTE) NULL,
            &size
            ) != ERROR_SUCCESS ) {
            
        return (status) ; 
    }

    buffer_got = (WCHAR *) malloc ( size * sizeof(WCHAR)) ; 
    if (buffer_got == NULL) {
        return (status);
    }
    
    memset(buffer_got, 0, size * sizeof(WCHAR) ) ;
    // Get the present list of tracked processes in buffer_got 
    
    if ( RegQueryValueEx(
            hkey, 
            TRACK_LIST_KEY,
            NULL,
            NULL,
            (LPBYTE) buffer_got,
            &size
            ) != ERROR_SUCCESS ) {
            
        free(buffer_got) ; 
        return (status) ; 
    }
    
    // Append the present process to the track list 
    // Prepare buffer to hold it
    // Size of new buffer will be the sum of the old buffer size
    // and the size of the new application + one byte for the terminating NULL char (in bytes)
    //
    
    new_size = size + (wcslen(appname) + 1) * sizeof(WCHAR) ; 
    
    buffer_sent = (WCHAR *) malloc (new_size) ; 
    
    if (buffer_sent == NULL) {
        free(buffer_got) ;
        return (status);
    }
    
    memset( buffer_sent, 0, new_size ) ; 
    
    // check if this is the FIRST entry
    // If so size will be 2 - corresponding to 2 NULL chars in a empty list
    
    if ( size == 2 ) {
    
        // this is the first entry 
        
        wcscpy(buffer_sent,appname) ;
        j = wcslen(buffer_sent) ; 
        j++ ; 
        buffer_sent[j] = L'\0' ;
        
    } else {
    
        // size > 2 - append this process to the end of track list  
    
        for(i=0 ; i <= size-1 ; i++ ) {

            if ( (buffer_got[i] == L'\0') && 
                    (buffer_got[i+1] == L'\0') ) {
             
                break ; 
           
            }
                
            buffer_sent[j++] = buffer_got[i] ;               
        
        } // end of for loop 
    
        buffer_sent[j++] = L'\0' ; 
    
        for(k=0 ; k <= wcslen(appname) - 1 ; k++) {
        
            buffer_sent[j++] = (WCHAR) appname[k] ;
            
        }
         
        buffer_sent[j++] = L'\0' ;  
        buffer_sent[j] = L'\0' ;
    
    } // size > 2 
    
    // write the new track list into registry
    
    if ( RegSetValueEx(
            hkey, 
            L"ApplicationList",
            0,
            REG_MULTI_SZ,
            (CONST BYTE *) buffer_sent,
            (j+1) * sizeof(WCHAR) 
            ) != ERROR_SUCCESS ) {
            
        // Free all the buffers which were allocated

        free(buffer_got) ;
        free(buffer_sent) ; 
        return (status) ; 

    }
    
    status = TRUE ; 
    
    // Free the buffers allocated 

    free(buffer_got) ;
    free(buffer_sent) ; 
    
    return(status) ; 
   
} // end of function 


/*++

Routine Description :

    This Routine checks if the application resides in a local drive 
    or a remote network share. If it is a remote share, the UNC path
    of the application is returned.
    
Arguments :
    
    appname - name of the application

Return Value :

    The UNC path of the appname if it resides in a remote server share.
    The same appname if it resides in a local drive.
    
--*/     

VOID 
ResolveName(
    LPCWSTR appname,
    WCHAR *ResolvedName
    )
    
{

    UINT i ; 
    INT length ; 
    WCHAR LocalName[3] ; 
    WCHAR RootPathName[4] ; 
    WCHAR RemoteName[MAX_PATH] ; 
    DWORD size = MAX_PATH ; 
    DWORD DriveType, error_status ; 
    
    //
    // ResolvedName will hold the name of the UNC path of the appname if it is in 
    // a remote server and share

    memset(ResolvedName, 0, MAX_PATH * sizeof(WCHAR)) ; 
    
    // check if appname is a app in local drive or remote server share
   
    // Parse the first 3 chars in appname to get the root directory of the drive 
    // where it resides

    wcsncpy(RootPathName, appname, 3 ) ;
    RootPathName[3] = L'\0';
    
    // Find the type of the Drive where the app is 

    DriveType = GetDriveType(RootPathName) ;

    if (DriveType == DRIVE_REMOTE) {
        
        // Use WNetGetConnection to get the name of the remote share
        
        // Parse the first two chars of the appname to get the local drive 
        // which is mapped onto the remote server and share

        wcsncpy(LocalName, appname, 2 ) ;
        LocalName[2] = L'\0' ; 

        error_status = WNetGetConnection (
                           LocalName,
                           RemoteName,
                           &size
                           ) ;     

        if (error_status != NO_ERROR) {
        
            wcscpy(ResolvedName,appname) ; 
            return ;
        }
        
        //
        // Prepare ResolvedName - it will contain the Remote Server and Share name 
        // followed by a \ and then the appname
        //

        wcscpy( ResolvedName, RemoteName ) ;
        
        length = wcslen(ResolvedName) ;

        ResolvedName[length++] = L'\\' ; 
        
        for (i = 3 ; i <= wcslen(appname) ; i++ ) {
            ResolvedName[length++] = appname[i] ; 
        }
        
        ResolvedName[length] = L'\0' ; 
        
        return ; 
        

    } else {
    
        // This application is in local drive and not in a remote server and share
        // Just send the appname back to the calling function

        wcscpy(ResolvedName,appname) ; 
        return ;
        
    }
    
}

/*++

Routine Description - This function checks if the present User belongs to the 
group of PowerUser. 

Arguments - none

Return Value - TRUE is the User belongs to the Group of PowerUser
               FALSE if not.

--*/

BOOL 
IsPowerUser(VOID)
{
    BOOL IsMember, IsAnPower;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
    PSID PowerSid;

    if (RtlAllocateAndInitializeSid(
            &SystemSidAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
			DOMAIN_ALIAS_RID_POWER_USERS,
            0, 0, 0, 0, 0, 0,
            &PowerSid
            ) != STATUS_SUCCESS) { 
        
        IsAnPower = FALSE;
    } else { 
	
        if (!CheckTokenMembership(
                NULL,
                PowerSid,
                &IsMember)) { 
            IsAnPower = FALSE;
        } else { 
            IsAnPower = IsMember;
        }
        RtlFreeSid(PowerSid);
    }
    return IsAnPower;

}// end of function IsPowerUser
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appsec\setup\setup.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name :

    setup.c    

Abstract :

    Setup program for the AppSec tool.
    Setup the Registry keys and gives Read Permission for 'Everyone' to these keys. 
    Also copies the AppSec.dll file to the %SystemRoot%\system32 directory

Revision history : 

    09.02.2000 - Adding support for command line arguments - taking a text file containing
    Authorized Applications and a integer for Enabling Appsec - SriramSa 
    
Returns :

    TRUE if success
    FALSE if failed
    
Author :

    Sriram (t-srisam) July 1999

--*/

#include "pch.h"
#pragma hdrstop

#include "setup.h"
#include "aclapi.h"
#include <accctrl.h>

WCHAR   g_szSystemRoot[MAX_PATH] ;

INT _cdecl main ( INT argc, CHAR *argv[] )
{

    DWORD   Disp, size, error_code ;
    HKEY    AppCertKey, AppsKey ; 
    WCHAR   *AppSecDllPath = L"%SystemRoot%\\system32\\appsec.dll" ;
    WCHAR   *OldFileName = L".\\appsec.dll" ;
    WCHAR   NewFileName[MAX_PATH] ;

    WCHAR   HelpMessage[HELP_MSG_SIZE]; 
    WCHAR   szTitle[MAX_PATH];
    WCHAR   szMsg[MAX_PATH];
    CHAR    FileName[MAX_PATH] ;
    INT     IsEnabled = 0;  // by default AppSec is disabled initially
    BOOL    IsInitialFile = FALSE; // assume no initial file was provided
    BOOL    status, IsNoGUI = FALSE ; 

    // Process the command line arguments
    if (argc > 1) {
        IsInitialFile = TRUE ; 
        strcpy(FileName, argv[1]) ;
        if (argc > 2) {
            IsEnabled = atoi(argv[2]) ; 
        }
        // Check if user does not want any GUI
        if ((argc > 3) && (_stricmp(argv[3], "/N") == 0)) {
            IsNoGUI = TRUE ; 
        }
    }

    // Display Help Message if asked for
    if (strcmp(FileName,"/?") == 0) {
        LoadString( NULL, IDS_HELP_MESSAGE ,HelpMessage, HELP_MSG_SIZE );
        LoadString( NULL, IDS_HELP_TITLE ,szTitle, MAX_PATH );
        MessageBox( NULL, HelpMessage, szTitle, MB_OK);
        return TRUE ; 
    }

    // Check the second argument
    if ((IsEnabled != 0) && (IsEnabled != 1)) {
        LoadString( NULL, IDS_ARGUMENT_ERROR, szMsg, MAX_PATH );
        LoadString( NULL, IDS_ERROR, szTitle, MAX_PATH );
        MessageBox( NULL, szMsg, szTitle, MB_OK);
        return TRUE ; 
    }

    // Display warning message regarding authorized apps already in the Registry
    if (IsNoGUI == FALSE) {
        LoadString( NULL, IDS_WARNING, szMsg, MAX_PATH );
        LoadString( NULL, IDS_WARNING_TITLE ,szTitle, MAX_PATH );
        if ( MessageBox( NULL, szMsg, szTitle, MB_OKCANCEL) == IDCANCEL ) { 
            return TRUE ;
        }
    }

    // Create the AppCertDlls Key 

    if (RegCreateKeyEx( 
          HKEY_LOCAL_MACHINE, 
          APPCERTDLLS_REG_NAME, 
          0,                  
          NULL,
          REG_OPTION_NON_VOLATILE, 
          KEY_ALL_ACCESS,
          NULL, 
          &AppCertKey, 
          &Disp 
          ) != ERROR_SUCCESS ) {
          
        LoadString( NULL, IDS_REG_ERROR ,szMsg, MAX_PATH );
        LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
        MessageBox( NULL, szMsg, szTitle, MB_OK);
        return FALSE ;
    
    }

    // After creating the key, give READ access to EVERYONE

    AddEveryoneToRegKey( APPCERTDLLS_REG_NAME ) ;

    // Set the AppSecDll value to the path of the AppSec.dll

    size = wcslen(AppSecDllPath) ; 

    RegSetValueEx(
        AppCertKey,
        APPSECDLL_VAL, 
        0, 
        REG_EXPAND_SZ,
        (CONST BYTE *)AppSecDllPath,
        (size + 1) * sizeof(WCHAR)
        ) ;


    // Create the AuthorizedApplications Key and give Read access to Evereone 

    if (RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            AUTHORIZEDAPPS_REG_NAME,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &AppsKey,
            &Disp
            ) != ERROR_SUCCESS ) {
            
        LoadString( NULL, IDS_REG_ERROR ,szMsg, MAX_PATH );
        LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
        MessageBox( NULL, szMsg, szTitle, MB_OK);
        RegCloseKey(AppCertKey) ; 
        return FALSE ;
    }

    // After creating the key, give READ access to EVERYONE

    AddEveryoneToRegKey( AUTHORIZEDAPPS_REG_NAME ) ;

    RegCloseKey(AppCertKey) ;
    GetEnvironmentVariable( L"SystemRoot", g_szSystemRoot, MAX_PATH ) ; 

    // Load the initial set of authorized apps into the Registry

    status = LoadInitApps( AppsKey, IsInitialFile, FileName) ; 
    if (status == FALSE) {
        LoadString( NULL, IDS_APPS_WARNING, szMsg, MAX_PATH );
        LoadString( NULL, IDS_WARNING_TITLE, szTitle, MAX_PATH );
        MessageBox( NULL, szMsg, szTitle, MB_OK);
    }

    // Set the fEnabled key now

    RegSetValueEx(
        AppsKey, 
        FENABLED_KEY,
        0,
        REG_DWORD,
        (BYTE *) &IsEnabled,
        sizeof(DWORD) );

    RegCloseKey(AppsKey) ;

    // Copy the appsec.dll file to %SystemRoot%\system32 directory

    swprintf(NewFileName, L"%s\\system32\\appsec.dll", g_szSystemRoot ) ;

    if ( CopyFile(
            OldFileName,
            NewFileName,
            TRUE 
            ) == 0 ) {

        error_code = GetLastError() ; 

        // If AppSec.dll already exists in Target Directory, print appropriate Message
        
        if (error_code == ERROR_FILE_EXISTS) {
            if (IsNoGUI == FALSE) {
                LoadString( NULL, IDS_FILE_ALREADY_EXISTS ,szMsg, MAX_PATH );
                LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
                MessageBox( NULL, szMsg, szTitle, MB_OK);
            }
            return FALSE ;
        } 

        // If AppSec.dll does not exist in the current directory, print appropriate Message

        if (error_code == ERROR_FILE_NOT_FOUND) {
            LoadString( NULL, IDS_FILE_NOT_FOUND ,szMsg, MAX_PATH );
            LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
            MessageBox( NULL, szMsg, szTitle, MB_OK); 
            return FALSE ;

        }

        LoadString( NULL, IDS_ERROR_TEXT ,szMsg, MAX_PATH );
        LoadString( NULL, IDS_ERROR ,szTitle, MAX_PATH );
        MessageBox( NULL, szMsg, szTitle, MB_OK);

        return FALSE ;  
    }
 
    // File was copied successfully - Installation was successful 
    if (IsNoGUI == FALSE) {
        LoadString( NULL, IDS_SUCCESS_TEXT ,szMsg, MAX_PATH );
        LoadString( NULL, IDS_SUCCESS ,szTitle, MAX_PATH );
        MessageBox( NULL, szMsg, szTitle, MB_OK);
    }

    return TRUE ; 

}

/*++

The following two functions are used to change the permissions of the 
relevant Regsitry Keys, to give READ access to everyone, to take
care of Guest users.

--*/

BOOL
AddSidToObjectsSecurityDescriptor(
    HANDLE hObject,
    SE_OBJECT_TYPE ObjectType,
    PSID pSid,
    DWORD dwNewAccess,
    ACCESS_MODE AccessMode,
    DWORD dwInheritance
    )
{
    BOOL            fReturn = FALSE;
    DWORD           dwRet;
    EXPLICIT_ACCESS ExpAccess;
    PACL            pOldDacl = NULL, pNewDacl = NULL;
    PSECURITY_DESCRIPTOR pSecDesc = NULL;

    //
    //  pSid cannot be NULL.
    //

    if (pSid == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    //  Get the objects security descriptor and current DACL.
    //

    dwRet = GetSecurityInfo(
                hObject,
                ObjectType,
                DACL_SECURITY_INFORMATION,
                NULL,
                NULL,
                &pOldDacl,
                NULL,
                &pSecDesc
                );

    if (dwRet != ERROR_SUCCESS) {
        return(FALSE);
    }

    //
    //  Initialize an EXPLICIT_ACCESS structure for the new ACE.
    //

    ZeroMemory(&ExpAccess, sizeof(EXPLICIT_ACCESS));
    ExpAccess.grfAccessPermissions = dwNewAccess;
    ExpAccess.grfAccessMode = AccessMode;
    ExpAccess.grfInheritance = dwInheritance;
    ExpAccess.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExpAccess.Trustee.ptstrName = (PTSTR)pSid;

    //
    //  Merge the new ACE into the existing DACL.
    //

    dwRet = SetEntriesInAcl(
                1,
                &ExpAccess,
                pOldDacl,
                &pNewDacl
                );

    if (dwRet != ERROR_SUCCESS) {
        goto ErrorCleanup;
    }

    //
    //  Set the new security for the object.
    //

    dwRet = SetSecurityInfo(
                hObject,
                ObjectType,
                DACL_SECURITY_INFORMATION,
                NULL,
                NULL,
                pNewDacl,
                NULL
                );

    if (dwRet != ERROR_SUCCESS) {
        goto ErrorCleanup;
    }

    fReturn = TRUE;

ErrorCleanup:
    if (pNewDacl != NULL) {
        LocalFree(pNewDacl);
    }

    if (pSecDesc != NULL) {
        LocalFree(pSecDesc);
    }

    return(fReturn);
}


VOID
AddEveryoneToRegKey(
    WCHAR *RegPath
    )
{
    HKEY hKey;
    PSID pSid = NULL;
    SID_IDENTIFIER_AUTHORITY SepWorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    LONG status ; 

    status = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        RegPath,
        0,
        KEY_ALL_ACCESS,
        &hKey
        );

    if (status != ERROR_SUCCESS) {
        return ; 
    }

    AllocateAndInitializeSid(
        &SepWorldAuthority,
        1,
        SECURITY_WORLD_RID,
        0, 0, 0, 0, 0, 0, 0,
        &pSid
        );

    AddSidToObjectsSecurityDescriptor(
        hKey,
        SE_REGISTRY_KEY,
        pSid,
        KEY_READ,
        GRANT_ACCESS,
        CONTAINER_INHERIT_ACE
        );

    LocalFree(pSid);
    RegCloseKey(hKey);
}

/*++

Routine Description : 
    This function loads a initial set of authorized applications to the registry.
    
Arguments : 
    AppsecKey - Key to the registry entry where authorized applications are stored
    IsInitialFile - Was a initial file given as command line argument to load applications
                    other than the default ones
    FileName - Name of the file given as command line argument
    
Return Value :         
    A BOOL indicating if the desired task succeeded or not.

--*/        

BOOL LoadInitApps( 
        HKEY AppsecKey, 
        BOOL IsInitialFile, 
        CHAR *FileName
        ) 
{ 

    FILE    *fp ; 
    INT     MaxInitApps ; 
    WCHAR   *BufferWritten ; 
    INT     BufferLength = 0 ; 
    WCHAR   AppsInFile[MAX_FILE_APPS][MAX_PATH] ;
    CHAR    FileRead[MAX_PATH] ;         
    INT     size, count = 0, NumOfApps = 0 ;
    INT     i, j, k ; 
    BOOL    IsFileExist = TRUE ; 
    WCHAR   InitApps[MAX_FILE_APPS][MAX_PATH]; 
    WCHAR   szMsg[MAX_PATH], szTitle[MAX_PATH]; 
    WCHAR   ResolvedAppName[MAX_PATH];
    DWORD   RetValue; 

    //  Below is the list of default (necessary) applications
    LPWSTR DefaultInitApps[] = {
        L"system32\\loadwc.exe",
        L"system32\\cmd.exe",
        L"system32\\subst.exe",
        L"system32\\xcopy.exe",
        L"system32\\net.exe",
        L"system32\\regini.exe",
        L"system32\\systray.exe",
        L"explorer.exe",
        L"system32\\attrib.exe",
        L"Application Compatibility Scripts\\ACRegL.exe",
        L"Application Compatibility Scripts\\ACsr.exe",
        L"system32\\ntsd.exe",
        L"system32\\userinit.exe",
        L"system32\\wfshell.exe",
        L"system32\\chgcdm.exe",
        L"system32\\nddeagnt.exe",

    };


    MaxInitApps = sizeof(DefaultInitApps)/sizeof(DefaultInitApps[0]) ; 
    
    // Prefix the default apps with %SystemRoot% 
    for (i = 0; i < MaxInitApps; i++) {
        swprintf(InitApps[i], L"%ws\\%ws", g_szSystemRoot, DefaultInitApps[i]);
    }

    // Calculate the size of buffer to allocate to hold initial apps
    for (i = 0; i < MaxInitApps; i++) {
        BufferLength += wcslen(InitApps[i]) ; 
    }

    BufferLength += MaxInitApps ; // for the terminating NULLS
    
    if (IsInitialFile == FALSE) {
        BufferLength += 1 ; //last terminating NULL in REG_MULTI_SZ
    } else { 
        // A initial file was given to us 
        fp = fopen(FileName, "r") ;
        if (fp == NULL) {
            // Display a Message Box saying Unable to open the file
            // Just load the default apps and return
            LoadString( NULL, IDS_APPFILE_NOT_FOUND ,szMsg, MAX_PATH );
            LoadString( NULL, IDS_WARNING_TITLE, szTitle, MAX_PATH );
            MessageBox( NULL, szMsg, szTitle, MB_OK);
            IsFileExist = FALSE ; 
        } else { 
            // build the array AppsInFile after UNICODE conversion
            while( fgets( FileRead, MAX_PATH, fp) != NULL ) { 
                FileRead[strlen(FileRead)- 1] = '\0' ;
                // Convert from Short to Long name
                if ( GetLongPathNameA((LPCSTR)FileRead, FileRead, MAX_PATH) == 0 ) { 
                    // GetLongPathName returns error
                    // some problem with the app listed in the file
                    // Terminate further handling of apps in the file
                    LoadString( NULL, IDS_ERROR_LOAD, szMsg, MAX_PATH );
                    LoadString( NULL, IDS_WARNING_TITLE, szTitle, MAX_PATH );
                    MessageBox( NULL, szMsg, szTitle, MB_OK);
                    break;
                }
                // Convert to UNICODE format
                // Get the size of the buffer required first
                size = MultiByteToWideChar(
                        CP_ACP,
                        MB_PRECOMPOSED,
                        FileRead,
                        -1,
                        NULL,
                        0) ;
                if (size  > MAX_PATH) {
                    // Something is wrong in the list of apps in the File 
                    // Terminate further handling of apps in the file
                    LoadString( NULL, IDS_ERROR_LOAD, szMsg, MAX_PATH );
                    LoadString( NULL, IDS_WARNING_TITLE, szTitle, MAX_PATH );
                    MessageBox( NULL, szMsg, szTitle, MB_OK);
                    break; 
                } else {
                    MultiByteToWideChar(
                        CP_ACP,
                        MB_PRECOMPOSED,
                        FileRead,
                        -1,
                        AppsInFile[count],
                        MAX_PATH) ;
                    count++ ; 
                }
            }
            fclose(fp) ; 
            NumOfApps = count ; 
            
            // Now any of these apps may be in remote Server and Share - so resolve them into UNC names
            // Copy the resolved names back into the same buffer

            for(i = 0; i < NumOfApps; i++) { 
                ResolveName((LPCWSTR)AppsInFile[i], ResolvedAppName) ; 
                wcscpy(AppsInFile[i], ResolvedAppName); 
            }

            // Continue calculation of BufferLength
            for (i = 0; i < NumOfApps; i++) {
                BufferLength += wcslen(AppsInFile[i]) ; 
            }
            BufferLength += NumOfApps ; // for the Terminating NULLs in REG_MULTI_SZ
            BufferLength += 1 ; // for the last NULL char in REG_MULTI_SZ 
        }
    }
    
    BufferWritten = (WCHAR *) malloc (BufferLength * sizeof(WCHAR)) ; 
    if (BufferWritten == NULL) {
        return FALSE ; 
    }
    memset(BufferWritten, 0, BufferLength * sizeof(WCHAR)) ; 

    // Build the LPWSTR BufferWritten with Initial Default Apps
    j = 0 ; 
    for (i = 0; i < MaxInitApps; i++) {
        for(k = 0 ; k < (int) wcslen(InitApps[i]); k++) {
            BufferWritten[j++] = InitApps[i][k]; 
        }
        BufferWritten[j++] = L'\0' ;
    }
    if (IsInitialFile && IsFileExist ) {
        for (i = 0; i < NumOfApps; i++) {
            for(k = 0 ; k < (int) wcslen(AppsInFile[i]); k++) {
                BufferWritten[j++] = AppsInFile[i][k]; 
            }
            BufferWritten[j++] = L'\0' ;
        }
    }
    BufferWritten[j] = L'\0' ; // Last NULL char in REG_MULTI_SZ

    // Write this Buffer into the Registry Key
    
    if ( RegSetValueEx(
            AppsecKey, 
            AUTHORIZED_APPS_KEY,
            0,
            REG_MULTI_SZ,
            (CONST BYTE *) BufferWritten,
            (j+1) * sizeof(WCHAR) 
            ) != ERROR_SUCCESS ) {
            
        // Free all the buffers which were allocated
        free(BufferWritten) ;
        return FALSE ;
    }

    free(BufferWritten) ; 
    return TRUE ;

}// end of function LoadInitApps

/*++

Routine Description :

    This Routine checks if the application resides in a local drive 
    or a remote network share. If it is a remote share, the UNC path
    of the application is returned.
    
Arguments :
    
    appname - name of the application

Return Value :

    The UNC path of the appname if it resides in a remote server share.
    The same appname if it resides in a local drive.
    
--*/     

VOID 
ResolveName(
    LPCWSTR appname,
    WCHAR *ResolvedName
    )
    
{

    UINT i ; 
    INT length ; 
    WCHAR LocalName[3] ; 
    WCHAR RootPathName[4] ; 
    WCHAR RemoteName[MAX_PATH] ; 
    DWORD size = MAX_PATH ; 
    DWORD DriveType, error_status ; 
    
    //
    // ResolvedName will hold the name of the UNC path of the appname if it is in 
    // a remote server and share

    memset(ResolvedName, 0, MAX_PATH * sizeof(WCHAR)) ; 
    
    // check if appname is a app in local drive or remote server share
   
    // Parse the first 3 chars in appname to get the root directory of the drive 
    // where it resides

    wcsncpy(RootPathName, appname, 3 ) ;
    RootPathName[3] = L'\0';
    
    // Find the type of the Drive where the app is 

    DriveType = GetDriveType(RootPathName) ;

    if (DriveType == DRIVE_REMOTE) {
        
        // Use WNetGetConnection to get the name of the remote share
        
        // Parse the first two chars of the appname to get the local drive 
        // which is mapped onto the remote server and share

        wcsncpy(LocalName, appname, 2 ) ;
        LocalName[2] = L'\0' ; 

        error_status = WNetGetConnection (
                           LocalName,
                           RemoteName,
                           &size
                           ) ;     

        if (error_status != NO_ERROR) {
        
            wcscpy(ResolvedName,appname) ; 
            return ;
        }

        //
        // Prepare ResolvedName - it will contain the Remote Server and Share name 
        // followed by a \ and then the appname
        //

        wcscpy( ResolvedName, RemoteName ) ;
        
        length = wcslen(ResolvedName) ;

        ResolvedName[length++] = L'\\' ; 
        
        for (i = 3 ; i <= wcslen(appname) ; i++ ) {
            ResolvedName[length++] = appname[i] ; 
        }
        
        ResolvedName[length] = L'\0' ; 
        return ; 
        

    } else {
    
        // This application is in local drive and not in a remote server and share
        // Just send the appname back to the calling function

        wcscpy(ResolvedName,appname) ; 
        return ;
        
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appsec\dll\pch.h ===
#pragma once

// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// Public windows headers.
//
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\appsec\setup\setup.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name :

    setup.h

Abstract :

    Defines the macros used in setup.c
    
Author :

    Sriram (t-srisam) July 1999

--*/

#define APPCERTDLLS_REG_NAME L"System\\CurrentControlSet\\Control\\Session Manager\\AppCertDlls"

#define AUTHORIZEDAPPS_REG_NAME L"System\\CurrentControlSet\\Control\\Terminal Server\\AuthorizedApplications"

#define APPSECDLL_VAL L"AppSecDll" 

#define HELP_MSG_SIZE                       800
                                               
#define IDS_ERROR                           900
#define IDS_ERROR_TEXT                      901
#define IDS_FILE_ALREADY_EXISTS             902
#define IDS_FILE_NOT_FOUND                  903

#define IDS_SUCCESS                         904
#define IDS_SUCCESS_TEXT                    905
#define IDS_REG_ERROR                       906
#define IDS_APPFILE_NOT_FOUND               907
#define IDS_WARNING                         908
#define IDS_HELP_MESSAGE                    909
#define IDS_HELP_TITLE                      910
#define IDS_WARNING_TITLE                   911
#define IDS_ARGUMENT_ERROR                  912
#define IDS_APPS_WARNING                    913
#define IDS_ERROR_LOAD                      914

#define MAX_FILE_APPS                       100
#define AUTHORIZED_APPS_KEY                 L"ApplicationList"
#define FENABLED_KEY                        L"fEnabled"

VOID AddEveryoneToRegKey( WCHAR *RegPath ) ;
BOOL LoadInitApps( HKEY, BOOL, CHAR *) ;
VOID ResolveName ( LPCWSTR appname, WCHAR *ResolvedName ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\change\change.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*************************************************************************
*
*  CHANGE.C
*     This module is the CHANGE utility code.
*
*
*************************************************************************/


#include <windows.h>
#include <winnt.h>
#include <stdio.h>
// #include <ntddkbd.h>
// #include <ntddmou.h>
#include <winsta.h>
#include <regapi.h>
#include <stdlib.h>
#include <time.h>
#include <utilsub.h>
#include <process.h>
#include <string.h>
#include <malloc.h>
#include <printfoa.h>
#include <locale.h>
#include <winnlsp.h>

#include "change.h"


// max length of the locale string
#define MAX_LOCALE_STRING 64


/*-----------------------------------------------------------------------
-- Supported commands (now obtained from registry)
------------------------------------------------------------------------*/
PPROGRAMCALL pProgList = NULL;

/*
 * Local function prototypes.
 */
void Usage( BOOLEAN bError );


/*************************************************************************
*
*  main
*     Main function and entry point of the text-based CHANGE menu utility.
*
*  ENTRY:
*       argc (input)
*           count of the command line arguments.
*       argv (input)
*           vector of strings containing the command line arguments;
*           (not used due to always being ANSI strings).
*
*  EXIT
*       (int) exit code: SUCCESS for success; FAILURE for error.
*
*************************************************************************/

int __cdecl
main( INT argc,
      CHAR **argv )
{
    PWCHAR        arg, *argvW;
    PPROGRAMCALL  pProg, pProgramCall = NULL;
    int           len, j, status = FAILURE;
    LONG    regstatus;
    CHAR    unused;
    WCHAR wszString[MAX_LOCALE_STRING + 1];

    setlocale(LC_ALL, ".OCP");

    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);

    
    SetThreadUILanguage(0);

    /*
     * Obtain the supported CHANGE commands from registry.
     */
    if ( (regstatus =
            RegQueryUtilityCommandList( UTILITY_REG_NAME_CHANGE, &pProgList ))
            != ERROR_SUCCESS ) {

        ErrorPrintf(IDS_ERROR_REGISTRY_FAILURE, UTILITY_NAME, regstatus);
        goto exit;
    }

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        goto exit;
    }

    /*
     * Check for valid utility name and execute.
     */
    if ( argc > 1 && *(argvW[1]) ) {

        len = wcslen(arg = argvW[1]);
        for ( pProg = pProgList->pFirst; pProg != NULL; pProg = pProg->pNext ) {

            if ( (len >= pProg->CommandLen) &&
                 !_wcsnicmp( arg, pProg->Command, len ) ) {

                pProgramCall = pProg;
                break;
            }
        }

        if ( pProgramCall ) {

                if ( ExecProgram(pProgramCall, argc - 2, &argvW[2]) )
                goto exit;

        } else if ( ((arg[0] == L'-') || (arg[0] == L'/')) &&
                    (arg[1] == L'?') ) {

            /*
             * Help requested.
             */
            Usage(FALSE);
            status = SUCCESS;
            goto exit;

        } else {

            /*
             * Bad command line.
             */
            Usage(TRUE);
            goto exit;
        }

    } else {

        /*
         * Nothing on command line.
         */
        Usage(TRUE);
        goto exit;
    }

exit:
    if ( pProgList )
        RegFreeUtilityCommandList(pProgList);   // let's be tidy

    return(status);

} /* main() */


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }

    ProgramUsage(UTILITY_NAME, pProgList, bError);

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\change\change.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*  CHANGE.H
*
*   This module contains typedefs and defines required for the CHANGE utility
*   menu.
*
******************************************************************************/

/*
 * Usage string definitions.
 */
#define UTILITY_NAME    L"CHANGE"


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_REGISTRY_FAILURE                      102
#define IDS_ERROR_NOT_TS								103
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\chgport\chgport.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/***********************************************************************
*
*  CHGPORT.H
*     This module contains typedefs and defines required for
*     the CHGPORT utility.
*
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Structure for com port name mappings
 */
typedef struct _COMNAME {
   PWCHAR com_pwcNTName;        /* pointer to NT name of device */
   PWCHAR com_pwcDOSName;       /* pointer to DOS name of device */
   struct _COMNAME *com_pnext;  /* next entry in list */
} COMNAME, *PCOMNAME;

/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_GETTING_COMPORTS                      102
#define IDS_ERROR_DEL_PORT_MAPPING                      103
#define IDS_ERROR_CREATE_PORT_MAPPING                   104
#define IDS_ERROR_PORT_MAPPING_EXISTS                   105
#define IDS_ERROR_NO_SERIAL_PORTS                       106
#define IDS_HELP_USAGE1                                 107
#define IDS_HELP_USAGE2                                 108
#define IDS_HELP_USAGE3                                 109
#define IDS_HELP_USAGE4                                 110
#define IDS_HELP_USAGE5                                 111
#define IDS_ERROR_NOT_TS	                            112
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\chgusr\chgusr.h ===
/***********************************************************************
*
*  CHGUSR.H
*     This module contains typedefs and defines required for
*     the CHGUSR utility.
*
*  Copyright Citrix Systems Inc. 1995
*  Copyright (c) 1998-1999 Microsoft Corporation
*
*************************************************************************/


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Function prototypes
 */

LPWSTR
GetErrorString(
    DWORD   Error
);


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_HELP_USAGE1                                 102
#define IDS_HELP_USAGE2                                 103
#define IDS_HELP_USAGE3                                 104
#define IDS_HELP_USAGE4                                 105
#define IDS_HELP_USAGE5                                 106
#define IDS_EXECUTE                                     107
#define IDS_INSTALL                                     108
#define IDS_ERROR_ADMIN_ONLY                            109
#define IDS_READY_INSTALL                               110
#define IDS_READY_EXECUTE                               111
#define IDS_ERROR_INI_MAPPING_FAILED                    112
#define IDS_ERROR_NOT_TS				                113
#define IDS_ERROR_REMOTE_ADMIN                          114
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\chglogon\chglogon.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation

/***********************************************************************
*
*   CHGLOGON.H
*
*   This module contains typedefs and defines required for
*   the CHGLOGON utility.
*
*  
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_HELP_USAGE1                                 102
#define IDS_HELP_USAGE2                                 103
#define IDS_HELP_USAGE3                                 104
#define IDS_HELP_USAGE4                                 105
#define IDS_HELP_USAGE5                                 106
#define IDS_WINSTATIONS_DISABLED                        107
#define IDS_WINSTATIONS_ENABLED                         108
#define IDS_ACCESS_DENIED                               109
#define IDS_ERROR_NOT_TS								110

#define IDS_ERROR_WINSTATIONS_GP_DENY_CONNECTIONS_1     111     // deny connections is set to 1
#define IDS_ERROR_WINSTATIONS_GP_DENY_CONNECTIONS_0     112     // deny connections is set to 0

/*
 *  Winlogon defines
 */

#define APPLICATION_NAME                    TEXT("Winlogon")
#define WINSTATIONS_DISABLED                TEXT("WinStationsDisabled")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\chgusr\precomp.h ===
#include <nt.h>
#include <ntrtl.h>                // NT runtime library definitions
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>

#include <ntddmou.h>
#include <tsappcmp.h>
#include <printfoa.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\chglogon\chglogon.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*   CHGLOGON.C
*
*   This module contains code for the CHGLOGON utility.
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winstaw.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <utilsub.h>
#include <string.h>
#include <locale.h>
#include <printfoa.h>
#include <winnlsp.h>

#include "chglogon.h"


// max length of the locale string
#define MAX_LOCALE_STRING 64


/*
 * Global Data
 */
USHORT   help_flag = FALSE;             // User wants help
USHORT   fQuery    = FALSE;             // query winstations
USHORT   fEnable   = FALSE;             // enable winstations
USHORT   fDisable  = FALSE;             // disable winstations

TOKMAP ptm[] = {
      {L"/q",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fQuery},
      {L"/query",   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fQuery},
      {L"/enable",  TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fEnable},
      {L"/disable", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fDisable},
      {L"/?",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
      {0, 0, 0, 0, 0}
};


/*
 * Local function prototypes.
 */
void Usage(BOOLEAN bError);


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    WCHAR **argvW;
    ULONG rc;
    INT   i;
    PPOLICY_TS_MACHINE   Ppolicy;
    WCHAR wszString[MAX_LOCALE_STRING + 1];


    setlocale(LC_ALL, ".OCP");

    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);
    
    SetThreadUILanguage(0);

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || rc ) {

        if ( !help_flag && !(rc & PARSE_FLAG_NO_PARMS) ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

        //Check if we are running under Terminal Server
        if(!AreWeRunningTerminalServices())
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
    *   Check if Group policy has thrown the big switch, if so, inform and refuse any changes
    */

    Ppolicy = LocalAlloc( LPTR, sizeof(POLICY_TS_MACHINE) ); 
    if (Ppolicy == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    RegGetMachinePolicy( Ppolicy );
    if ( Ppolicy->fPolicyDenyTSConnections )
    {
        if (Ppolicy->fDenyTSConnections)
        {
            ErrorPrintf(IDS_ERROR_WINSTATIONS_GP_DENY_CONNECTIONS_1 );
        }
        else
        {
            ErrorPrintf(IDS_ERROR_WINSTATIONS_GP_DENY_CONNECTIONS_0 );
        }
        LocalFree( Ppolicy );
        Ppolicy = NULL;
        return( FAILURE );
    }

    if (Ppolicy != NULL) {
        LocalFree( Ppolicy );
        Ppolicy = NULL;
    }

    /*
     *  Enable or disable
     */
    if ( fDisable ) {
        rc = WriteProfileString( APPLICATION_NAME, WINSTATIONS_DISABLED, TEXT("1") );
    }
    else if ( fEnable ) {
        rc = WriteProfileString( APPLICATION_NAME, WINSTATIONS_DISABLED, TEXT("0") );
    }

    /*
     *  Query or error ?
     */
    if ( !fQuery && (rc != 1) ) {
        ErrorPrintf(IDS_ACCESS_DENIED);
    }
    else if ( GetProfileInt( APPLICATION_NAME, WINSTATIONS_DISABLED, 0 ) == 0 ) {
        ErrorPrintf(IDS_WINSTATIONS_ENABLED);
    }
    else {
        ErrorPrintf(IDS_WINSTATIONS_DISABLED);
    }

    return(SUCCESS);
}


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }
    ErrorPrintf(IDS_HELP_USAGE1);
    ErrorPrintf(IDS_HELP_USAGE2);
    ErrorPrintf(IDS_HELP_USAGE3);
    ErrorPrintf(IDS_HELP_USAGE4);
    ErrorPrintf(IDS_HELP_USAGE5);

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\chgusr\chgusr.c ===
/******************************************************************************
*
*  CHGUSR.C
*
*  Text utility to change INI file mapping settings
*
*  Copyright (c) 1998-1999 Microsoft Corporation
*
*
*******************************************************************************/

#include "precomp.h"

#include <ntddkbd.h>
#include <winsta.h>
#include <syslib.h>
#include <assert.h>

#include <stdlib.h>
#include <time.h>
#include <utilsub.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <winnlsp.h>

#include "chgusr.h"
#include "winbasep.h"
#include "regapi.h"

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


// max length of the locale string
#define MAX_LOCALE_STRING 64


WCHAR Arg1[MAX_IDS_LEN+1];

int On_flag      = FALSE;
int Off_flag     = FALSE;
int Query_flag   = FALSE;
int Help_flag    = FALSE;
int Install_flag = FALSE;
int Execute_flag = FALSE;


TOKMAPW ptm[] = {
      {L" ",  TMFLAG_OPTIONAL, TMFORM_STRING, MAX_IDS_LEN,  Arg1},
      {L"/INIMAPPING:ON", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int), &On_flag},
      {L"/INIMAPPING:OFF", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int), &Off_flag},
      {L"/QUERY", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int), &Query_flag},
      {L"/Q", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int), &Query_flag},
      {L"/INSTALL", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int), &Install_flag},
      {L"/EXECUTE", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int), &Execute_flag},
      {L"/?", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &Help_flag},
      {0, 0, 0, 0, 0}
};

BOOL IsRemoteAdminMode( );

BOOL
TestUserForAdmin( VOID );

/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    WCHAR **argvW;
    ULONG rc;
    int i;
    BOOL Result;
    BOOL State;
    HANDLE hWin;
    WCHAR wszString[MAX_LOCALE_STRING + 1];

    setlocale(LC_ALL, ".OCP");

    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);
    
    SetThreadUILanguage(0);

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( Help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !Help_flag ) {
            // International
            ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
            ErrorPrintf(IDS_HELP_USAGE1);
            ErrorPrintf(IDS_HELP_USAGE2);
            ErrorPrintf(IDS_HELP_USAGE3);
            ErrorPrintf(IDS_HELP_USAGE4);
            ErrorPrintf(IDS_HELP_USAGE5);
            return(FAILURE);

        } else {
            Message(IDS_HELP_USAGE1);
            Message(IDS_HELP_USAGE2);
            Message(IDS_HELP_USAGE3);
            Message(IDS_HELP_USAGE4);
            Message(IDS_HELP_USAGE5);
            return(SUCCESS);
        }
    }

        if(!AreWeRunningTerminalServices())
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    if( Query_flag ) {

        // Show the current state
        State = TermsrvAppInstallMode();
        if( !State ) {
            Message(IDS_EXECUTE);
        }
        else {
            Message(IDS_INSTALL);
        }

        if( IsRemoteAdminMode( ) )
        {
            Message( IDS_ERROR_REMOTE_ADMIN );
        }

        return( !State + 100 );  // Exit code 100 == INSTALL Mode
                                 // Exit Code 101 == EXECUTE Mode
    } 


    /*
     *  Set the modes necessary to install applications
     */
    if ( Install_flag ) {
        On_flag = FALSE;
        Off_flag = TRUE;
    }

    /*
     *  Set the modes necessary to run applications
     */
    if ( Execute_flag ) {
        On_flag = TRUE;
        Off_flag = FALSE;
    }


    // Default to Execute mode
    State = TRUE;

    if( On_flag || Off_flag ) {

        if( IsRemoteAdminMode( ) ) {

            Message( IDS_ERROR_REMOTE_ADMIN );

            return SUCCESS;
        }

        if( Off_flag ) {

            /*
             * We only allow admins to turn off execute mode
             */
            if( !TestUserForAdmin() ) {
                ErrorPrintf(IDS_ERROR_ADMIN_ONLY);
                return(FAILURE);
            }

            State = FALSE;
        }

        rc = SetTermsrvAppInstallMode( (BOOL)(!State) );
        if( !rc ) {
            // Use function to map error message to string
            ErrorPrintf(IDS_ERROR_INI_MAPPING_FAILED,GetLastError());
            return(!rc);
        } else {
            if ( Off_flag ) 
                Message(IDS_READY_INSTALL);
            if ( On_flag ) 
                Message(IDS_READY_EXECUTE);
        }
    }
    else {
        Message(IDS_HELP_USAGE1);
        Message(IDS_HELP_USAGE2);
        Message(IDS_HELP_USAGE3);
        Message(IDS_HELP_USAGE4);
        Message(IDS_HELP_USAGE5);
        return(FAILURE);
    }

    if( IsRemoteAdminMode( ) )
    {
        Message( IDS_ERROR_REMOTE_ADMIN );
    }

    return( !rc );
}

BOOL IsRemoteAdminMode( )
{
    HKEY hKey;
    
    DWORD dwData = 0;

    BOOL fMode = FALSE;

	DWORD dwSize = sizeof( DWORD );


    DBGPRINT( ( "CHGUSR : IsRemoteAdminMode\n" ) );
    
    

    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                      REG_CONTROL_TSERVER, 
                      0,
                      KEY_READ ,
                      &hKey ) != ERROR_SUCCESS )
    {
        DBGPRINT( ( "CHGUSR : IsRemoteAdminMode -- RegOpenEx unable to open key\n" ) );

        return FALSE;
	}
	
	
    if( RegQueryValueEx( hKey ,
                         TEXT( "TSAppCompat" ) ,
                         NULL ,
                         NULL , 
                         ( LPBYTE )&dwData , 
                         &dwSize ) != ERROR_SUCCESS )
    {
        DBGPRINT( ( "CHGUSR : IsRemoteAdminMode -- RegQueryValueEx failed\n" ) );

        fMode = FALSE; // for application server
    }
    else
    {
        // dwData = 0 fMode = TRUE remote admin mode
        // dwData = 1 fMode = FALSE app server mode

        fMode = !( BOOL )dwData;
        
    }

    RegCloseKey( hKey );

    return fMode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\chgport\chgport.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*  CHGPORT.C
*
*  Change serial port mapping.
*
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winstaw.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <utilsub.h>
#include <string.h>
#include <printfoa.h>
#include <locale.h>
#include <winnlsp.h>

#include "chgport.h"


// max length of the locale string
#define MAX_LOCALE_STRING 64


/*
 * Global Data
 */
WCHAR user_string[MAX_IDS_LEN+1];       // parsed user input
USHORT help_flag = FALSE;               // User wants help
USHORT fDelete   = FALSE;               // delete mapped port
USHORT fquery = FALSE;        // query the mapped ports
PCOMNAME pValidNames = NULL;            // list of valid com names in registry

TOKMAP ptm[] = {
      {L" ",  TMFLAG_OPTIONAL, TMFORM_STRING, MAX_IDS_LEN, user_string},
      {L"/d", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fDelete},
      {L"/?", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
      {L"/QUERY", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fquery},
      {L"/Q", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fquery},
      {0, 0, 0, 0, 0}
};


/*
 * Constants
 */
#define DOSDEVICE_STRING    L"\\DosDevices"

/*
 * Local function prototypes.
 */
void Usage(BOOLEAN bError);
BOOL DeleteMappedPort(PWCHAR user_string);
BOOL GetPorts(PWCHAR user_string,
              PWCHAR pwcSrcPort,
              PWCHAR pwcDestPort,
              ULONG ulbufsize);
BOOL MapPorts(PWCHAR pwcSrcPort,
              PWCHAR pwcDestPort);
void ListSerialPorts();
BOOL IsSerialDevice(PWCHAR pwcName);
ULONG GetNTObjectName(PWCHAR pwcDOSdev,
                      PWCHAR pwcNTObjName,
                      ULONG ulbufsize);
ULONG AddComName(PCOMNAME *pComList,
                 PWCHAR pwcNTName,
                 PWCHAR pwcDOSName);
void DelComName(PCOMNAME pEntry);
PCOMNAME FindComName(PCOMNAME pComList,
                     PWCHAR pwcName);

BOOL IsVDMdeviceName(PWCHAR pwcName);

/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    WCHAR **argvW;
    WCHAR wcSrcPort[MAX_PATH], wcDestPort[MAX_PATH];
    ULONG ulSrcPort, ulDestPort, rc;
    INT   i;
    WCHAR wszString[MAX_LOCALE_STRING + 1];

    setlocale(LC_ALL, ".OCP");

    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);
    
    SetThreadUILanguage(0);


    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

            if ( !help_flag ) {

                Usage(TRUE);
                return(FAILURE);

            } else {

                Usage(FALSE);
                return(SUCCESS);
            }
    }

        //If we are not Running under Terminal Server, Return Error

        if(!AreWeRunningTerminalServices())
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return (FAILURE);
        }

    if (fDelete) {
            DeleteMappedPort(user_string);
    } else if (*user_string) {
             GetPorts(user_string, wcSrcPort, wcDestPort, MAX_PATH);
             MapPorts(wcSrcPort, wcDestPort);
    } else {                 // query the mapped ports
        ListSerialPorts();
    }

    // Free up the list of valid port names
    if (pValidNames) {
        PCOMNAME pEntry, pPrev;

        pEntry = pValidNames;
        while (pEntry) {
            pPrev = pEntry;
            pEntry = pEntry->com_pnext;
            DelComName(pPrev);
        }
    }

    return(SUCCESS);
}


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }
    ErrorPrintf(IDS_HELP_USAGE1);
    ErrorPrintf(IDS_HELP_USAGE2);
    ErrorPrintf(IDS_HELP_USAGE3);
    ErrorPrintf(IDS_HELP_USAGE4);
    ErrorPrintf(IDS_HELP_USAGE5);

}  /* Usage() */


/*******************************************************************************
 *
 *  DeleteMappedPort
 *
 *  This routine deletes the specified mapped port
 *
 *
 *  ENTRY:
 *     PWCHAR pwcport (In): Pointer to port mapping to delete
 *
 *  EXIT:
 *     TRUE: port was deleted
 *     FALSE: error deleting port
 *
 ******************************************************************************/

BOOL DeleteMappedPort(PWCHAR pwcport)
{
    ULONG rc;
    PWCHAR pwch;
    WCHAR  wcbuff[MAX_PATH];

    // Check if this a serial device and if it is, remove it
    if (!GetNTObjectName(pwcport, wcbuff, sizeof(wcbuff)/sizeof(WCHAR)) &&
        IsSerialDevice(wcbuff)) {

            if (DefineDosDevice(DDD_REMOVE_DEFINITION,
                                pwcport,
                                NULL)) {
                return(TRUE);
            } else {
                rc = GetLastError();
            }
    } else {
            rc = ERROR_FILE_NOT_FOUND;
    }

    StringDwordErrorPrintf(IDS_ERROR_DEL_PORT_MAPPING, pwcport, rc);

    return(FALSE);
}


/*******************************************************************************
 *
 *  GetPorts
 *
 *  This routine converts the string to the source and destination ports
 *
 *
 *  ENTRY:
 *     PWCHAR pwcstring (In): Pointer to user string
 *     PWCHAR pwcSrcPort (Out): Pointer to return source port
 *     PWCHAR pwcSrcPort (Out): Pointer to return destination port
 *     ULONG  ulbufsize (In): Size of return buffers
 *
 *  EXIT:
 *     TRUE: string converted to source and destination ports
 *     FALSE: error
 *
 ******************************************************************************/

BOOL GetPorts(PWCHAR pwcstring, PWCHAR pwcSrcPort, PWCHAR pwcDestPort,
              ULONG ulbufsize)
{
    PWCHAR pwch;
    ULONG  ulcnt;
    BOOL   fSawEqual = FALSE;

    pwch = pwcstring;

    // find next non alphanumeric character
    for (ulcnt = 0; pwch[ulcnt] && iswalnum(pwch[ulcnt]); ulcnt++) {
    }

    // Get the source port
    if (pwch[ulcnt] && (ulcnt < ulbufsize)) {
        wcsncpy(pwcSrcPort, pwch, ulcnt);
    } else {
        return(FALSE);
    }
    pwcSrcPort[ulcnt] = L'\0';

    pwch += ulcnt;

    // get to destination port
    while (*pwch && !iswalnum(*pwch)) {
        if (*pwch == L'=') {
            fSawEqual = TRUE;
        }
        pwch++;
    }

    // If the syntax is OK and there's room in the buffer, copy the dest. port
    if (*pwch && fSawEqual && (wcslen(pwch) < ulbufsize)) {
        wcscpy(pwcDestPort, pwch);
    } else {
        return(FALSE);
    }

    // remove the : if they entered comn:
    if (pwch = wcsrchr(pwcSrcPort, L':')) {
        *pwch = L'\0';
    }
    if (pwch = wcsrchr(pwcDestPort, L':')) {
        *pwch = L'\0';
    }

    return(TRUE);
}


/*******************************************************************************
 *
 *  MapPorts
 *
 *  This routine maps the source port number to the destination port.
 *
 *
 *  ENTRY:
 *     PWCHAR pwcSrcPort (In): Source port
 *     PWCHAR pwcDestPort (In): Destination port
 *
 *  EXIT:
 *     TRUE: port was mapped
 *     FALSE: error mapping port
 *
 ******************************************************************************/

BOOL MapPorts(PWCHAR pwcSrcPort, PWCHAR pwcDestPort)
{
    ULONG rc = ERROR_FILE_NOT_FOUND;
    WCHAR wcdest[MAX_PATH], wcsrc[MAX_PATH];

    // Get the NT name of the destination and make sure it's a serial device
    rc = GetNTObjectName(pwcDestPort, wcdest, sizeof(wcdest)/sizeof(WCHAR));
    if ((rc == 0) && IsSerialDevice(wcdest)) 
    {
        // see if this mapping already exists
        if (!GetNTObjectName(pwcSrcPort, wcsrc, sizeof(wcsrc)/sizeof(WCHAR)) &&
                !_wcsicmp(wcdest, wcsrc)) {
            ErrorPrintf(IDS_ERROR_PORT_MAPPING_EXISTS,
                         pwcSrcPort,
                         pwcDestPort);
            return(FALSE);
        }

        if (DefineDosDevice(DDD_RAW_TARGET_PATH,
                            pwcSrcPort,
                            wcdest)) {
            return(TRUE);
        } else {
            rc = GetLastError();
        }
    }

    StringDwordErrorPrintf(IDS_ERROR_CREATE_PORT_MAPPING, pwcSrcPort, rc);

    return(FALSE);
}


/*******************************************************************************
 *
 *  GetNTObjectName
 *
 *  This routine returns the NT object name for a DOS device.
 *
 *  ENTRY:
 *      PWCHAR pwcDOSdev (In): pointer to DOS device name
 *      PWCHAR pwcNTObjName (Out): pointer for NT object name
 *      ULONG ulbufsize (In): size (in wide chars) of object name buffer
 *
 *  EXIT:
 *      Success:
 *          returns 0
 *      Failure:
 *          returns error code
 *
 ******************************************************************************/

ULONG GetNTObjectName(PWCHAR pwcDOSdev, PWCHAR pwcNTObjName, ULONG ulbufsize)
{
    WCHAR wcbuff[MAX_PATH];
    PWCHAR pwch;

    // Make a copy of the name passed in
    wcscpy(wcbuff, pwcDOSdev);

    // Strip off any trailing colon (comn:)
    if (pwch = wcsrchr(wcbuff, L':')) {
        *pwch = L'\0';
    }

    if (QueryDosDevice(pwcDOSdev, pwcNTObjName, ulbufsize)) {
        return(0);
    } else {
        return(GetLastError());
    }
}


/*******************************************************************************
 *
 *  ListSerialPorts
 *
 *  This routine lists all of the mapped ports.
 *
 *  ENTRY:
 *
 *  EXIT:
 *
 ******************************************************************************/

void ListSerialPorts(void)
{
    ULONG ulcnt, rc;
    WCHAR TargetPath[4096];
    PWCH  pwch;
    PCOMNAME pComList = NULL;
    PCOMNAME pEntry, pPrev;

    DWORD dwBufferSize = 2048;
    WCHAR *DeviceNames = malloc(dwBufferSize);

    if (!DeviceNames)
    {
        ErrorPrintf(IDS_ERROR_MALLOC);
        free(DeviceNames);
        return;
    }

    //
    // Get all of the defined DOS devices
    //

    //
    // QueryDosDevice function returns success even if buffer is too small!
    // Lets get around it
    //

    SetLastError(0);
    while ( (!QueryDosDevice(NULL, DeviceNames, dwBufferSize / sizeof(WCHAR))) ||
            (GetLastError() == ERROR_INSUFFICIENT_BUFFER) ) 
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            SetLastError(0);
            free(DeviceNames);
            dwBufferSize *= 2;

            DeviceNames = malloc(dwBufferSize);

            if (!DeviceNames)
            {
                ErrorPrintf(IDS_ERROR_MALLOC);
                return;
            }

        }
        else
        {
            ErrorPrintf(IDS_ERROR_GETTING_COMPORTS, GetLastError());
            free(DeviceNames);
            return;
        }
    }

    pwch = DeviceNames;

    // Go through each DOS device and get it's NT object name, then check if
    // it's a serial device, and if so display it
    while (*pwch) 
    {
        rc = GetNTObjectName(pwch,
                             TargetPath,
                             sizeof(TargetPath)/sizeof(WCHAR));
        if (rc) 
        {
            ErrorPrintf(IDS_ERROR_GETTING_COMPORTS, rc);
        } 
        else if (IsSerialDevice(TargetPath)) 
        {
            AddComName(&pComList, TargetPath, pwch);
        }

        pwch += wcslen(pwch) + 1;
    }

    if (pComList) 
    {
        // print out the entries
        pEntry = pComList;
        while (pEntry) 
        {
            wprintf(L"%s = %s\n", pEntry->com_pwcDOSName, pEntry->com_pwcNTName);
            pPrev = pEntry;
            pEntry = pEntry->com_pnext;
            DelComName(pPrev);
        }
    } 
    else 
    {
        ErrorPrintf(IDS_ERROR_NO_SERIAL_PORTS);
    }

    free(DeviceNames);

}


/*******************************************************************************
 *
 *  IsSerialDevice
 *
 *  This routine checks if the NT file name is a serial device
 *
 *
 *  ENTRY:
 *     PWCHAR pwcName (In): Pointer to name to check
 *
 *  EXIT:
 *     TRUE: Is a serial device
 *     FALSE: Not a serial device
 *
 ******************************************************************************/

BOOL IsSerialDevice(PWCHAR pwcName)
{
    NTSTATUS Status;
    HANDLE   Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_DEVICE_INFORMATION FileFSDevInfo;
    OBJECT_ATTRIBUTES ObjFile;
    UNICODE_STRING  UniFile;
    WCHAR           wcbuff[MAX_PATH];
    WCHAR           wcvalue[MAX_PATH];
    PWCHAR          pwch;
    HKEY            hKey;
    ULONG           ulType, ulSize, ulcnt, ulValSize;
    BOOL            fIsSerial = FALSE;

    
    if (IsVDMdeviceName(pwcName)) {
        return FALSE;
    }

    RtlInitUnicodeString(&UniFile, pwcName);

    InitializeObjectAttributes(&ObjFile,
                               &UniFile,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // Open the device
    //
    Status = NtOpenFile(&Handle,
                        (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                        &ObjFile,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE);

    if (NT_SUCCESS(Status)) {
        Status = NtQueryVolumeInformationFile(Handle,
                                              &IoStatusBlock,
                                              &FileFSDevInfo,
                                              sizeof(FileFSDevInfo),
                                              FileFsDeviceInformation);

        // Check if this is actually a serial device or not
        if (NT_SUCCESS(Status))
        {
            if ( (FileFSDevInfo.DeviceType == FILE_DEVICE_NETWORK_REDIRECTOR) ||
                 (FileFSDevInfo.DeviceType == FILE_DEVICE_SERIAL_PORT) ) 
            {
                fIsSerial = TRUE;
            }
        }

        // Close the file handle
        NtClose(Handle);

    } else {
        // If we couldn't open the device, look for the name in the registry

#ifdef DEBUG
        wprintf(L"Error opening: %s, error = %x\n", pwcName, Status);
#endif

        // strip off the leading \device
        pwch = wcschr(pwcName+2, L'\\');
        if (pwch != NULL)
        {
            pwch++;


            // If we haven't built the list of valid names from the registry,
            // build it.
            if (pValidNames == NULL) {
                // Open the serialcomm entry in the registry
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                         L"Hardware\\DeviceMap\\SerialComm",
                                         0,
                                         KEY_READ,
                                         &hKey) == ERROR_SUCCESS) {

                    ulValSize = ulSize = MAX_PATH;
                    ulcnt = 0;

                    // Put all of the valid entries into the valid names list
                    while (!RegEnumValue (hKey, ulcnt++, wcvalue, &ulValSize,
                                          NULL, &ulType, (LPBYTE) wcbuff, &ulSize))
                    {
                        if (ulType != REG_SZ)
                            continue;

                        AddComName(&pValidNames, wcvalue, wcbuff);

                        ulValSize = ulSize = MAX_PATH;
                    }

                    RegCloseKey(hKey);
                }
            }

            // look for the name in the list of valid com names
            if (FindComName(pValidNames, pwch)) {
                fIsSerial = TRUE;
            }
        }
    }

    return(fIsSerial);
}


/*****************************************************************************
 *
 *  AddComName
 *
 *  This routines adds a new node onto the specified com port names.
 *
 * ENTRY:
 *   PCOMNAME *pComList (In) - Pointer to list to add entry to
 *   PWCHAR pwcNTName (In)  - NT name of device
 *   PWCHAR pwcDOSName (In) - DOW name of device
 *
 * EXIT:
 *   SUCCESS:
 *      return ERROR_SUCCESS
 *   FAILURE:
 *      returns error code
 *
 ****************************************************************************/

ULONG AddComName(PCOMNAME *pComList,
                 PWCHAR pwcNTName,
                 PWCHAR pwcDOSName)
{
    PCOMNAME pnext, pprev, pnew;
    LONG rc = ERROR_SUCCESS;

    if (pnew = malloc(sizeof(COMNAME))) {

        // clear out the new entry
        memset(pnew, 0, sizeof(COMNAME));

        // Allocate and initialize the NT name
        if (pnew->com_pwcNTName =
                malloc((wcslen(pwcNTName) + 1)*sizeof(WCHAR))) {
            wcscpy(pnew->com_pwcNTName, pwcNTName);
        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

        // Allocate and initialize the DOS name
        if ((rc == ERROR_SUCCESS) && (pnew->com_pwcDOSName =
                malloc((wcslen(pwcDOSName) + 1)*sizeof(WCHAR)))) {
            wcscpy(pnew->com_pwcDOSName, pwcDOSName);
        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        rc = ERROR_NOT_ENOUGH_MEMORY;
    }

    // If we allocate everything OK, add the node into the list
    if (rc == ERROR_SUCCESS) {
        pprev = NULL;
        pnext = *pComList;

        // Insert the entry into the list in ascending order
        while (pnext &&
               ((rc = _wcsicmp(pwcDOSName, pnext->com_pwcDOSName)) > 0)) {
            pprev = pnext;
            pnext = pnext->com_pnext;
        }

        // just return if this name is already in the list
        if (pnext && (rc == 0)) {
            return(ERROR_SUCCESS);
        }

        // Insert this entry into the list
        pnew->com_pnext = pnext;

        // If this is going to the front of the list, update list pointer
        if (pprev == NULL) {
            *pComList = pnew;
        } else {
            pprev->com_pnext = pnew;
        }

    } else if (pnew) {

        // Didn't allocate everything, release the memory we got
        DelComName(pnew);
    }

    return(rc);
}


/*****************************************************************************
 *
 *  DelComName
 *
 *  This routines frees up the memory allocated to a com name node.
 *
 * ENTRY:
 *   PCOMNAME pEntry (In)  - Node to delete
 *
 * EXIT:
 *   NONE
 *
 ****************************************************************************/

void DelComName(PCOMNAME pEntry)
{
    if (pEntry) {
        if (pEntry->com_pwcNTName) {
            free(pEntry->com_pwcNTName);
        }
        if (pEntry->com_pwcDOSName) {
            free(pEntry->com_pwcDOSName);
        }
        free(pEntry);
    }
}


/*****************************************************************************
 *
 *  FindComName
 *
 *  This routines searches for the specified name in the com port list.
 *
 * ENTRY:
 *   PCOMNAME pComList (In) - List to search
 *   PWCHAR   pwcName (In)  - Name to search for
 *
 * EXIT:
 *   SUCCESS:
 *      returns pointer to node containing the specified name
 *   FAILURE:
 *      returns NULL (name not found)
 *
 ****************************************************************************/

PCOMNAME FindComName(PCOMNAME pComList,
                     PWCHAR pwcName)
{
    PCOMNAME pcom;

    pcom = pComList;
    while (pcom) {
        //Check if the name matches either the NT or DOS device name
        if (!_wcsicmp(pwcName, pcom->com_pwcDOSName) ||
            !_wcsicmp(pwcName, pcom->com_pwcNTName)) {
               return(pcom);
        }
        pcom = pcom->com_pnext;
    }
    return(NULL);
}

BOOL IsVDMdeviceName(PWCHAR pwcName) 
{
    UINT  index;
    UINT  vdmlength = wcslen(L"VDM"); 

    for (index = 0; (index+vdmlength-1) < wcslen(pwcName); index++) {
        if (_wcsnicmp(&pwcName[index], L"VDM", vdmlength) == 0) {
            return TRUE;
        }
    }

    return FALSE;

}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\connect\tscon.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*************************************************************************
*
*  TSCON.C
*
*************************************************************************/

#include <stdio.h>
#include <windows.h>
// #include <ntddkbd.h>
// #include <ntddmou.h>
#include <winstaw.h>
#include <stdlib.h>
#include <utilsub.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <winnlsp.h>
#include <limits.h>

#include "tscon.h"
#include "printfoa.h"


// max length of the locale string
#define MAX_LOCALE_STRING 64


HANDLE         hServerName = SERVERNAME_CURRENT;
WCHAR          ServerName[MAX_IDS_LEN+1];
WINSTATIONNAME Source;
WINSTATIONNAME Destination;
WCHAR          Password[ PASSWORD_LENGTH + 1 ];
USHORT         help_flag = FALSE;
USHORT         v_flag    = FALSE;

TOKMAP ptm[] =
{
#define TERM_PARM 0
   {TOKEN_SOURCE,       TMFLAG_REQUIRED, TMFORM_S_STRING,
                            WINSTATIONNAME_LENGTH,  Source},

  /* { TOKEN_SERVER,      TMFLAG_OPTIONAL, TMFORM_STRING,
                            MAX_IDS_LEN, ServerName}, */

   {TOKEN_DESTINATION,  TMFLAG_OPTIONAL, TMFORM_X_STRING,
                            WINSTATIONNAME_LENGTH, Destination},

   {TOKEN_PASSWORD,     TMFLAG_OPTIONAL, TMFORM_X_STRING,
                            PASSWORD_LENGTH, Password},

   {TOKEN_HELP,         TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                            sizeof(USHORT), &help_flag},

   {TOKEN_VERBOSE,      TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                            sizeof(USHORT), &v_flag},

   {0, 0, 0, 0, 0}
};


/*
 * Local function prototypes.
 */
void Usage( BOOLEAN bError );
DWORD GetPasswdStr(LPWSTR buf, DWORD buflen, PDWORD len);


/*************************************************************************
*
*  main
*     Main function and entry point of the TSCON utility.
*
*  ENTRY:
*     argc  - count of the command line arguments.
*     argv  - vector of strings containing the command line arguments.
*
*  EXIT
*     Nothing.
*
*************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    BOOLEAN bCurrent = FALSE;
    int     rc;
    WCHAR   **argvW, *endptr;
    ULONG   SourceId, DestId;
    DWORD   dwPasswordLength;
    WCHAR wszString[MAX_LOCALE_STRING + 1];

    setlocale(LC_ALL, ".OCP");
    
    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);

    SetThreadUILanguage(0);

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || rc ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

    // If SERVER or DEST are not specified, we need to run on TS
    // Check if we are running under Terminal Server
    if ( ( (!IsTokenPresent(ptm, TOKEN_SERVER) )
        || (!IsTokenPresent(ptm, TOKEN_DESTINATION)) )
        && (!AreWeRunningTerminalServices()) )
    {
        ErrorPrintf(IDS_ERROR_NOT_TS);
        return(FAILURE);
    }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }

    /*
     * Validate the source.
     */
    if ( !IsTokenPresent(ptm, TOKEN_SOURCE) ) {

        /*
         * No source specified; use current winstation.
         */
        SourceId = GetCurrentLogonId();

    } else if ( !iswdigit(*Source) ) {

        /*
         * Treat the source string as a WinStation name.
         */
        if ( !LogonIdFromWinStationName(hServerName, Source, &SourceId) ) {
            StringErrorPrintf(IDS_ERROR_WINSTATION_NOT_FOUND, Source);
            return(FAILURE);
        }

    } else {

        /*
         * Treat the source string as a LogonId.
         */
        SourceId = wcstoul(Source, &endptr, 10);
        if ( *endptr || SourceId == ULONG_MAX) {
            StringErrorPrintf(IDS_ERROR_INVALID_LOGONID, Source);
            return(FAILURE);
        }
        if ( !WinStationNameFromLogonId(hServerName, SourceId, Source) ) {
            ErrorPrintf(IDS_ERROR_LOGONID_NOT_FOUND, SourceId);
            return(FAILURE);
        }
    }

    /*
     * Validate the destination.
     */
    if ( !IsTokenPresent(ptm, TOKEN_DESTINATION) ) {

        /*
         * No destination specified; use current winstation.
         */
        bCurrent = TRUE;
        DestId = GetCurrentLogonId();
        if ( !WinStationNameFromLogonId(hServerName, DestId, Destination) ) {
            ErrorPrintf(IDS_ERROR_CANT_GET_CURRENT_WINSTATION, GetLastError());
            PutStdErr(GetLastError(), 0);
            return(FAILURE);
        }

    } else {

        /*
         * Validate the destination WinStation name.
         */
        if ( !LogonIdFromWinStationName(hServerName, Destination, &DestId) ) {
            StringErrorPrintf(IDS_ERROR_WINSTATION_NOT_FOUND, Destination);
            return(FAILURE);
        }
    }

    // Check if password prompt is needed (If no password was provided)
    if (IsTokenPresent(ptm, TOKEN_PASSWORD))
    {
        // check if user wants the password prompt
        if (!wcscmp(Password, TOKEN_GET_PASSWORD))
        {
            Message(IDS_GET_PASSWORD, SourceId);
            GetPasswdStr(Password, PASSWORD_LENGTH + 1, &dwPasswordLength);
        }
    }

    /*
     * Perform the connect.
     */
    if ( v_flag )
        DwordStringMessage(IDS_WINSTATION_CONNECT, SourceId, Destination);

    if ( !WinStationConnect(hServerName, SourceId, DestId, Password, TRUE) ) {

        if ( bCurrent )
            ErrorPrintf(IDS_ERROR_WINSTATION_CONNECT_CURRENT,
                         SourceId, GetLastError());
        else
            ErrorPrintf(IDS_ERROR_WINSTATION_CONNECT,
                         SourceId, Destination, GetLastError());
        PutStdErr(GetLastError(), 0);
                
        SecureZeroMemory((PVOID)Password , sizeof(Password));

        return(FAILURE);
    }

    SecureZeroMemory((PVOID)Password , sizeof(Password));

    return(SUCCESS);

} /* main() */


/*******************************************************************************
 *
 *  GetPasswdStr
 *   
 *  Usage
 *
 *      Input a string from stdin in the Console code page.
 *       We can't use fgetws since it uses the wrong code page.
 *
 *  Arguments:
 *
 *      Buffer - Buffer to put the read string into.The Buffer will be zero 
 *               terminated and will have any traing CR/LF removed
 *
 *      BufferMaxChars - Maximum number of characters to return in the buffer 
 *                       not including the trailing NULL.
 *
 *      EchoChars - TRUE if the typed characters are to be echoed.
 *                  FALSE if not.
 *
 *  Return Values:
 *
 *      None.
 *
 *  Note: This method was ripped from net use
 *
 ******************************************************************************/
DWORD
GetPasswdStr(LPWSTR buf, DWORD buflen, PDWORD len)
{
    WCHAR   ch;
    WCHAR * bufPtr = buf;
    DWORD   c;
    DWORD   err;
    DWORD   mode;

    // Make space for null terminator
    buflen -= 1;    
    
    // GP fault probe (a la API's)
    *len = 0;       

    // Init mode in case GetConsoleMode() fails
    mode = ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT | ENABLE_PROCESSED_INPUT |
           ENABLE_MOUSE_INPUT;

    GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &mode);

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                   (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) 
    {
        err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);

        if (!err || c != 1) 
        {
            ch = 0xffff;
        }

        // Check if end of the line
        if ((ch == CR) || (ch == 0xffff))
        {
            break;
        }

        // Back up one or two
        if (ch == BACKSPACE)    
        {
            // IF bufPtr == buf then the next two lines are a no op.
            if (bufPtr != buf)
            {
                bufPtr--;
                (*len)--;
            }
        }
        else
        {
            *bufPtr = ch;

            if (*len < buflen)
                bufPtr++ ;                   // don't overflow buf
            (*len)++;                        // always increment len
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);

    // null terminate the string
    *bufPtr = '\0';         
    putchar( '\n' );

    return ((*len <= buflen) ? 0 : ERROR_BUFFER_TOO_SMALL);
}


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 *  EXIT:
 *
 *
 ******************************************************************************/
void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_USAGE_1);
        ErrorPrintf(IDS_USAGE_2);
        ErrorPrintf(IDS_USAGE_3);
        ErrorPrintf(IDS_USAGE_4);
        ErrorPrintf(IDS_USAGE_5);
        // ErrorPrintf(IDS_USAGE_6);
        ErrorPrintf(IDS_USAGE_7);
        ErrorPrintf(IDS_USAGE_8);
        ErrorPrintf(IDS_USAGE_9);
    }
    else{
        Message(IDS_USAGE_1);
        Message(IDS_USAGE_2);
        Message(IDS_USAGE_3);
        Message(IDS_USAGE_4);
        Message(IDS_USAGE_5);
        //Message(IDS_USAGE_6);
        Message(IDS_USAGE_7);
        Message(IDS_USAGE_8);
        Message(IDS_USAGE_9);
    }

} /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\connect\tscon.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*************************************************************************
*
*  TSCON.H
*     This module contains typedefs and defines for the TSCON
*     WinStation utility.
*
*************************************************************************/

// Token string definitions.
#define TOKEN_SOURCE                    L""
#define TOKEN_DESTINATION               L"/dest"
#define TOKEN_PASSWORD                  L"/password"
#define TOKEN_VERBOSE                   L"/v"
#define TOKEN_HELP                      L"/?"
#define TOKEN_SERVER                    L"/server"
#define TOKEN_GET_PASSWORD              L"*"


// General application definitions.
#define SUCCESS                         0
#define FAILURE                         1


// maximum length that the input parm can be
#define MAX_IDS_LEN                     256     


// Needed for GetPasswdStr
#define CR                              0xD
#define BACKSPACE                       0x8
#define ERROR_BUFFER_TOO_SMALL          -1


// Resource string IDs
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_WINSTATION_NOT_FOUND                  102
#define IDS_ERROR_INVALID_LOGONID                       103
#define IDS_ERROR_LOGONID_NOT_FOUND                     104
#define IDS_ERROR_WINSTATION_CONNECT                    105
#define IDS_ERROR_WINSTATION_CONNECT_CURRENT            106
#define IDS_ERROR_CANT_GET_CURRENT_WINSTATION           107
#define IDS_ERROR_SERVER                                108
#define IDS_USAGE_1                                     121
#define IDS_USAGE_2                                     122
#define IDS_USAGE_3                                     123
#define IDS_USAGE_4                                     124
#define IDS_USAGE_5                                     125
#define IDS_USAGE_6                                     126
#define IDS_USAGE_7                                     127
#define IDS_USAGE_8                                     128
#define IDS_USAGE_9                                     129
#define IDS_ERROR_NOT_TS                                130

#define IDS_WINSTATION_CONNECT                          200
#define IDS_GET_PASSWORD                                201
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\cprofile\cprofile.h ===
/***********************************************************************
*
*  CPROFILE.H
*     This module contains typedefs and defines required for
*     the CPROFILE utility.
*
*  Copyright Citrix Systems Inc. 1997
*  Copyright (c) 1998-1999 Microsoft Corporation
*
*************************************************************************/

#ifndef RC_INVOKED
#include <ntlsa.h>
#include <ntmsv1_0.h>
#endif

#include <string.h>

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

/* StringTable Defines */
#define IDS_USAGE_CMDLINE       301
#define IDS_USAGE_DESCR1        302
#define IDS_USAGE_DESCR2        303
#define IDS_USAGE_OPTION_LIST   304
#define IDS_USAGE_LOPTION       305
#define IDS_USAGE_IOPTION       306
#define IDS_USAGE_VOPTION       307
#define IDS_USAGE_HOPTION       308

#define IDS_MSG_PROCESSING      310
#define IDS_MSG_MODIFY_PROMPT   311
#define IDS_UI_YES_CHAR         312
#define IDS_UI_NO_CHAR          313
#define IDS_UI_QUIT_CHAR        314

#define IDS_ERROR_INVALID_PARAMETERS       320
#define IDS_ERROR_MALLOC                   321
#define IDS_ERROR_PRIVILEGE_NOT_AVAILABLE  322
#define IDS_ERROR_MISSING_PROFILE_LIST     323
#define IDS_ERROR_MISSING_LPROFILE         324
#define IDS_ERROR_BAD_LPROFILE             325
#define IDS_ERROR_SAVING_PROFILE           326
#define IDS_ERROR_OPENING_PROFILE          327
#define IDS_ERROR_INVALID_USER_RESP        328
#define IDS_ERROR_MISSING_RESOURCES        330
#define IDS_ERROR_BAD_PROFILE              331
#define IDS_ERROR_PROFILE_LOAD_ERR         332
#define IDS_ERROR_PROFILE_INUSE            333
#define IDS_ERROR_NOT_ADMIN                334
#define IDS_ERROR_NOT_TS                   335

extern HKEY hkeyCurrentUser;

/*
 * Function prototypes
 */

BOOL APIENTRY EnablePrivilege(DWORD Privilege, BOOL Enable);

VOID InitializeGlobalSids();

void ClearDisabledClasses(void);

BOOL APIENTRY ClearTempUserProfile();

BOOL APIENTRY OpenUserProfile(LPTSTR szFileName, PSID *pUserSid);

BOOL APIENTRY SaveUserProfile(PSID UserSid, LPTSTR lpFilePath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\cprofile\cprofile.c ===
/******************************************************************************
*
*  CPROFILE.C
*
*  Text based utility to clean user profiles.  This utility will remove user
*  file associations if they are disabled for the system and re-write
*  the user profile truncating unused space.
*
*  Copyright Citrix Systems Inc. 1995
*  Copyright (c) 1998-1999 Microsoft Corporation
*
*  Author:      Brad Anderson 01/20/97
*
*  $Log:   U:\NT\PRIVATE\UTILS\citrix\cprofile\VCS\cprofile.c  $
*
*     Rev 1.7   May 04 1998 18:06:14   bills
*  Fixes for MS bug #2109, OEM->ANSI conversion and moving strings to the rc file.
*
*     Rev 1.6   Feb 09 1998 19:37:00   yufengz
*  change user profile from directory to file
*
*     Rev 1.5   09 Oct 1997 19:04:14   scottn
*  Make help like MS.
*
*     Rev 1.4   Jun 26 1997 18:18:32   billm
*  move to WF40 tree
*
*     Rev 1.3   23 Jun 1997 16:13:18   butchd
*  update
*
*     Rev 1.2   19 Feb 1997 15:55:32   BradA
*  Allow only administrators to run CPROFILE
*
*     Rev 1.1   28 Jan 1997 20:06:28   BradA
*  Fixed up some problems related to WF 2.0 changes
*
*     Rev 1.0   27 Jan 1997 20:37:46   BradA
*  Initial Versions
*
*     Rev 1.0   27 Jan 1997 20:02:46   BradA
*  Initial Version
*
*     Rev 1.0   Jan 27 1997 19:51:12   KenB
*  Initial version
*
*
*******************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ntddkbd.h>
#include <winstaw.h>
#include <syslib.h>
#include <assert.h>

#include <time.h>
#include <utilsub.h>
#include <utildll.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <winnlsp.h>

#include "cprofile.h"

#include <printfoa.h>

#define REG_PROFILELIST \
 L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"
#define USER_PROFILE    L"NTUSER.DAT"

FILELIST Files;

int LocalProfiles_flag = FALSE;
int Verbose_flag = FALSE;
int Query_flag;
int Help_flag  = FALSE;

TOKMAP ptm[] = {
      {L"/L", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &LocalProfiles_flag},
      {L"/V", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &Verbose_flag},
      {L"/I", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &Query_flag},
      {L"/?", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &Help_flag},
      {L"/H", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &Help_flag},
      {L" ",  TMFLAG_OPTIONAL, TMFORM_FILES, sizeof(Files),  &Files},
      {0, 0, 0, 0, 0}
};

#define INPUT_CONT  0
#define INPUT_SKIP  1
#define INPUT_QUIT  2

int QueryUserInput();
int ProcessFile( PWCHAR pFile );
void Usage( BOOL ErrorOccured );


// max length of the locale string
#define MAX_LOCALE_STRING 64


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    WCHAR *CmdLine;
    WCHAR **argvW;
    ULONG rc;
    int i;
    BOOL Result;
    HANDLE hWin;
    int CurFile;
    int Abort_flag;
    WCHAR wszString[MAX_LOCALE_STRING + 1];

    setlocale(LC_ALL, ".OCP");

    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);
    
    SetThreadUILanguage(0);

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( Help_flag || (rc & ~PARSE_FLAG_NO_PARMS) ||
         (!LocalProfiles_flag && (Files.argc == 0)) ) {

        if ( !Help_flag ) {
            Usage(TRUE);
            return(FAILURE);
        }
        else {
            Usage(FALSE);
            return(SUCCESS);
        }
    }

    if (!TestUserForAdmin(FALSE)) {
        ErrorPrintf(IDS_ERROR_NOT_ADMIN);
        return(FAILURE);
    }

    InitializeGlobalSids();

    /*
     * Verify if the user  has the privilege to save the profile i.e.
     * SeBackupPrivilege
     */
    if (!EnablePrivilege(SE_BACKUP_PRIVILEGE, TRUE) ||
                  !EnablePrivilege(SE_RESTORE_PRIVILEGE, TRUE)) {
        ErrorPrintf(IDS_ERROR_PRIVILEGE_NOT_AVAILABLE);
        return(FAILURE);
    }

    CurFile = 0;
    Abort_flag = FALSE;
    while ( !Abort_flag && Files.argc && (CurFile < Files.argc) ) {
        if ( ProcessFile(Files.argv[CurFile]) ) {
            Abort_flag = TRUE;
            break;
        }
        CurFile++;
    }

    if ( !Abort_flag && LocalProfiles_flag ) {
        //  Enumerate local profiles
        LONG Status;
        HKEY hkeyProfileList;
        DWORD indx = 0;
        WCHAR wSubKeyName[MAX_PATH+sizeof(WCHAR)];
        DWORD Size;

        Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              REG_PROFILELIST,
                              0,
                              KEY_READ,
                              &hkeyProfileList);

        if ( Status != ERROR_SUCCESS ) {
            ErrorPrintf(IDS_ERROR_MISSING_PROFILE_LIST);
            Abort_flag = TRUE;
            hkeyProfileList = 0;
        }

        while ( !Abort_flag && (Status == ERROR_SUCCESS) ) {
            LONG Status2;

            Size = sizeof(wSubKeyName)/sizeof( WCHAR );
            Status = RegEnumKeyEx(hkeyProfileList,
                                  indx++,
                                  wSubKeyName,
                                  &Size,
                                  0,
                                  NULL,
                                  NULL,
                                  NULL );
            if ( Status == ERROR_SUCCESS ) {
                HKEY hkeyProfile;

                Status2 = RegOpenKeyEx(hkeyProfileList,
                                       wSubKeyName,
                                       0,
                                       KEY_READ,
                                       &hkeyProfile);

                if ( Status2 == ERROR_SUCCESS ) {
                    DWORD type;
                    WCHAR file[MAX_PATH], expandedFile[MAX_PATH];
                    DWORD filelen = sizeof(file);

                    Status2 = RegQueryValueExW(hkeyProfile,
                                            L"ProfileImagePath",
                                            0,
                                            &type,
                                            (PBYTE)file,
                                            &filelen );
                    if ( Status2 == ERROR_SUCCESS ) {
                        if ( ExpandEnvironmentStrings(file, expandedFile,
                             MAX_PATH) > 0) {
                                       //
                                       // Append the User Profile file "NTUSER.DAT"
                                       // to the end of the profile path.
                                       // Added by Yufeng Zheng
                                       //
                                       PWCHAR c;
                                       //
                                       // Find the trailing backslash '\' and
                                       // handle the appending according to the backslash.
                                       //
                                       if ((c = wcsrchr(expandedFile, L'\\')) == NULL) {
                                          wcscat(expandedFile, L"\\");
                                          wcscat(expandedFile, USER_PROFILE);
                                       }
                                       else if (c[1] == L'\0') {
                                          wcscat(expandedFile, USER_PROFILE);
                                       }
                                       else {
                                          wcscat(expandedFile, L"\\");
                                          wcscat(expandedFile, USER_PROFILE);
                                       }
                            if ( ProcessFile(expandedFile) ) {
                                Abort_flag = TRUE;
                            }
                        }
                    }
                    else {
                        StringErrorPrintf(IDS_ERROR_MISSING_LPROFILE, wSubKeyName);
                    }
                    RegCloseKey(hkeyProfile);
                }
                else {
                    StringErrorPrintf(IDS_ERROR_BAD_LPROFILE, wSubKeyName);
                }
            }
        }
        if ( hkeyProfileList ) {
            RegCloseKey(hkeyProfileList);
        }
    }

    return( Abort_flag );
}


/****************************************************************************
*
*  ProcessFile( PWCHAR pFile )
*       Read the specified profile, eliminate the Software\Classes registry
*       key if Classes are disabled, and resave the profile such that it
*       is truncated.
*
*  Arguments:
*       pFile   Filename to process
*
*  Returns:
*       FALSE   If completed successfully
*       TRUE    If there was an error, and the program should terminate.
*
****************************************************************************/
int
ProcessFile( PWCHAR pFile )
{
    PSID pUserSid;
    WCHAR tempbuf[100];
    int UserInput = INPUT_CONT;


    if ( Verbose_flag || Query_flag ) {
        StringMessage(IDS_MSG_PROCESSING, pFile );
    }

    if ( Query_flag ) {
        UserInput = QueryUserInput();
    }
    if ( UserInput == INPUT_CONT ) {
        if ( OpenUserProfile(pFile, &pUserSid) ) {
            ClearDisabledClasses();
            if ( ! SaveUserProfile(pUserSid, pFile) ) {
                StringErrorPrintf(IDS_ERROR_SAVING_PROFILE, pFile);
            }
            ClearTempUserProfile();
        }
        else {
            StringErrorPrintf(IDS_ERROR_OPENING_PROFILE, pFile);
        }
    }
    return ( UserInput == INPUT_QUIT );
}


int
QueryUserInput()
{
    WCHAR c, firstc;
    int Valid_flag = FALSE;
    int rc = INPUT_CONT;
    static int FirstTime = TRUE;
    static WCHAR yes[10], no[10], quit[10];

    if (FirstTime)
    {
        BOOLEAN error = FALSE;

        if ( !LoadString(NULL, IDS_UI_NO_CHAR, no, 2) ) {
            error = TRUE;
        }
        if ( !LoadString(NULL, IDS_UI_YES_CHAR, yes, 2) ) {
            error = TRUE;
        }
        if ( !LoadString(NULL, IDS_UI_QUIT_CHAR, quit, 2) ) {
            error = TRUE;
        }
        if ( error ) {
            ErrorPrintf(IDS_ERROR_MISSING_RESOURCES);
            return ( INPUT_QUIT );
        }

        FirstTime = FALSE;
    }

    fflush(stdin);
    Message(IDS_MSG_MODIFY_PROMPT);
    do {

        firstc = L'\0';
        while ( ((c = getwchar()) != L'\n') && (c != EOF) ) {
            if ( !firstc && !iswspace(c)) {
                firstc = c;
            }
        }

        if ( _wcsnicmp(yes, &firstc, 1) == 0 )
        {
            Valid_flag = TRUE;
        }
        else if ( _wcsnicmp(quit, &firstc, 1) == 0 ) {
            Valid_flag = TRUE;
            rc = INPUT_QUIT;
        }
        else if ( (_wcsnicmp(no, &firstc, 1) == 0) || (firstc == '\0') ) {
            rc = INPUT_SKIP;
            Valid_flag = TRUE;
        }
        else {
            ErrorPrintf(IDS_ERROR_INVALID_USER_RESP);
        }
    } while ( ! Valid_flag );

    return ( rc );
}

void Usage ( BOOL ErrorOccurred )
{
    if ( ErrorOccurred ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_USAGE_CMDLINE);
    } else {
        Message(IDS_USAGE_DESCR1);
        Message(IDS_USAGE_CMDLINE);
        Message(IDS_USAGE_DESCR2);
        Message(IDS_USAGE_OPTION_LIST);
        Message(IDS_USAGE_LOPTION);
        Message(IDS_USAGE_IOPTION);
        Message(IDS_USAGE_VOPTION);
        Message(IDS_USAGE_HOPTION);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\cprofile\precomp.h ===
#include <nt.h>
#include <ntrtl.h>                // NT runtime library definitions
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>

#include <ntddmou.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\dbgtrace\dbgtrace.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*  DBGTRACE.C
*
*  enable or disable tracing
*
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <winstaw.h>
#include <icadd.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <locale.h>
#include <utilsub.h>

#include "dbgtrace.h"
#include "printfoa.h"

WCHAR CurDir[ 256 ];
WCHAR WinStation[MAX_IDS_LEN+1];
WCHAR TraceOption[MAX_OPTION];
int bTraceOption = FALSE;
int fDebugger  = FALSE;
int fTimestamp = FALSE;
int fHelp      = FALSE;
int fSystem    = FALSE;
int fAll       = FALSE;
ULONG TraceClass  = 0;
ULONG TraceEnable = 0;
ULONG LogonId;

TOKMAP ptm[] = {
      {L" ",      TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN,    WinStation},
      {L"/c",     TMFLAG_OPTIONAL, TMFORM_LONGHEX, sizeof(ULONG),  &TraceClass},
      {L"/e",     TMFLAG_OPTIONAL, TMFORM_LONGHEX, sizeof(ULONG),  &TraceEnable},
      {L"/d",     TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int),    &fDebugger},
      {L"/t",     TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int),    &fTimestamp},
      {L"/o",     TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_OPTION,     TraceOption},
      {L"/system", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int),   &fSystem},
      {L"/all",   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(int),    &fAll},
      {L"/?",     TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fHelp},
      {0, 0, 0, 0, 0}
};


void SetSystemTrace( PICA_TRACE );
void SetStackTrace( PICA_TRACE );



/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
   WCHAR *CmdLine;
   WCHAR **argvW;
   ULONG rc;
   int i;
   ICA_TRACE Trace;

    setlocale(LC_ALL, ".OCP");

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( fHelp || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !fHelp ) {

            ErrorPrintf(IDS_ERROR_PARAMS);
            ErrorPrintf(IDS_USAGE_1);
            ErrorPrintf(IDS_USAGE_2);
            return(FAILURE);

        } else {

            Message(IDS_USAGE_1);
            Message(IDS_USAGE_2);
            return(SUCCESS);
        }
    }

   //Check if we are running under Terminal Server
        if(!AreWeRunningTerminalServices())
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    if ( fAll ) {
        TraceClass  = 0xffffffff;
        TraceEnable = 0xffffffff;
    }

    /*
     *  Get current directory
     */
    (VOID) GetCurrentDirectory( 256, CurDir );

    /*
     *  Get the LogonId
     */
    if ( ptm[0].tmFlag & TMFLAG_PRESENT ) {

        if ( iswdigit( WinStation[0] ) ) {

            LogonId = (ULONG) wcstol( WinStation, NULL, 10 );

        } else {

            if ( !LogonIdFromWinStationName( SERVERNAME_CURRENT, WinStation, &LogonId ) ) {
                StringErrorPrintf( IDS_ERROR_SESSION, WinStation );
                return(-1);
            }
        }

        if ( fSystem )
            wsprintf( Trace.TraceFile, L"%s\\winframe.log", CurDir );
        else
            wsprintf( Trace.TraceFile, L"%s\\%s.log", CurDir, WinStation );

    } else {

        LogonId = GetCurrentLogonId();

        if ( fSystem )
            wsprintf( Trace.TraceFile, L"%s\\winframe.log", CurDir );
        else
            wsprintf( Trace.TraceFile, L"%s\\%u.log", CurDir, LogonId );
    }

    /*
     *  Build trace structure
     */
    Trace.fDebugger   = fDebugger ? TRUE : FALSE;
    Trace.fTimestamp  = fTimestamp ? FALSE : TRUE;
    Trace.TraceClass  = TraceClass;
    Trace.TraceEnable = TraceEnable;

    if ( TraceClass == 0 || TraceEnable == 0 )
        Trace.TraceFile[0] = '\0';

    /*
     * Fill in the trace option if any
     */
    bTraceOption = ptm[5].tmFlag & TMFLAG_PRESENT;
    if ( bTraceOption )
        memcpy(Trace.TraceOption, TraceOption, sizeof(TraceOption));
    else
        memset(Trace.TraceOption, 0, sizeof(TraceOption));

    /*
     *  Set trace information
     */
    if ( fSystem )
        SetSystemTrace( &Trace );
    else
        SetStackTrace( &Trace );

    return(0);
}


void
SetSystemTrace( PICA_TRACE pTrace )
{
    /*
     *  Set trace information
     */
    if ( !WinStationSetInformation( SERVERNAME_CURRENT,
                                    LogonId,
                                    WinStationSystemTrace,
                                    pTrace,
                                    sizeof(ICA_TRACE) ) ) {

        Message(IDS_ERROR_SET_TRACE, GetLastError());
        return;
    }

    if ( pTrace->TraceClass == 0 || pTrace->TraceEnable == 0 ) {
        Message( IDS_TRACE_DIS_LOG );
    } else {
        Message( IDS_TRACE_EN_LOG );
        wprintf( L"- %08x %08x [%s] %s\n", pTrace->TraceClass, pTrace->TraceEnable,
                pTrace->TraceFile, fDebugger ? TEXT("Debugger") : TEXT("") );
    }

}


void
SetStackTrace( PICA_TRACE pTrace )
{
    WINSTATIONINFOCLASS InfoClass;
    ULONG               InfoSize;

    /*
     *  Check for console
     */
    if ( LogonId == 0 ) {
        Message( IDS_TRACE_UNSUPP );
        return;
    }

    /*
     *  Set trace information
     */
    if ( !WinStationSetInformation( SERVERNAME_CURRENT,
                                    LogonId,
                                    WinStationTrace,
                                    pTrace,
                                                sizeof(ICA_TRACE))) {
        Message(IDS_ERROR_SET_TRACE, GetLastError());
        return;
    }

    if ( pTrace->TraceClass == 0 || pTrace->TraceEnable == 0 ) {
        Message( IDS_TRACE_DISABLED, LogonId );
    } else {
        Message( IDS_TRACE_ENABLED, LogonId );
        wprintf( L"- %08x %08x [%s] %s\n", pTrace->TraceClass, pTrace->TraceEnable,
                pTrace->TraceFile, fDebugger ? "Debugger" : "" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\dbgtrace\dbgtrace.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/***********************************************************************
*
*  DBGTRACE.H
*     This module contains typedefs and defines required for
*     the DBGTRACE utility.
*
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be
#define MAX_OPTION     64     // max length of winstation tracing option

#define DEBUGGER	L"Debugger"

/*
 * Resource String IDs
 */
#define IDS_ERROR_MALLOC                        100	 
#define IDS_ERROR_PARAMS                        101	
#define IDS_ERROR_SESSION                       102
#define IDS_ERROR_SET_TRACE                     103	

#define IDS_TRACE_DIS_LOG                       110 
#define IDS_TRACE_EN_LOG                        111
#define IDS_TRACE_UNSUPP                        112
#define IDS_TRACE_DISABLED                      113
#define IDS_TRACE_ENABLED                       114
#define IDS_USAGE_1                             121 
#define IDS_USAGE_2                             122
#define IDS_ERROR_NOT_TS                        123
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\cprofile\file.c ===
/******************************************************************************
*
*  FILE.C
*
*  This file contains routines based off the User Profile Editor utility.
*
*  Copyright Citrix Systems, Inc.  1997
*  Copyright (c) 1998-1999 Microsoft Corporation
*
*  Author:  Brad Anderson  1/20/97
*
*  $Log:   M:\nt\private\utils\citrix\cprofile\VCS\file.c  $
*
*     Rev 1.3   Jun 26 1997 18:18:38   billm
*  move to WF40 tree
*
*     Rev 1.2   23 Jun 1997 16:13:20   butchd
*  update
*
*     Rev 1.1   28 Jan 1997 20:06:34   BradA
*  Fixed up some problems related to WF 2.0 changes
*
*     Rev 1.0   27 Jan 1997 20:03:44   BradA
*  Initial Version
*
******************************************************************************/
/****************************** Module Header ******************************\
* Module Name: upesave.c
*
* Copyright (c) 1992, Microsoft Corporation
*
* Handles OPening and saving of Profiles: default, system, current and user
* profiles.
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifndef RC_INVOKED
#include <winstaw.h>
#include <syslib.h>
#include <tsappcmp.h>
#include <compatfl.h>
#include <utilsub.h>
#endif

#include "cprofile.h"

HKEY hkeyCurrentUser;

PSID gSystemSid;         // Initialized in 'InitializeGlobalSids'
PSID gAdminsLocalGroup;  // Initialized in 'InitializeGlobalSids
SID_IDENTIFIER_AUTHORITY gNtAuthority = SECURITY_NT_AUTHORITY;

#define  SYSTEM_DEFAULT_SUBKEY  TEXT(".DEFAULT")
#define  TEMP_USER_SUBKEY       TEXT("TEMP_USER")
#define  TEMP_USER_HIVE_PATH    TEXT("%systemroot%\\system32\\config\\")
#define  TEMP_SAVE_HIVE         TEXT("%systemroot%\\system32\\config\\HiveSave")

#define  CITRIX_CLASSES L"\\Registry\\Machine\\Software\\Classes"

LPTSTR lpTempUserHive = NULL;
LPTSTR lpTempUserHivePath = NULL;
LPTSTR lpTempHiveKey;
extern TCHAR szDefExt[];
extern PSID gSystemSid;

BOOL AllocAndExpandEnvironmentStrings(LPTSTR String, LPTSTR *lpExpandedString);
VOID GetRegistryKeyFromPath(LPTSTR lpPath, LPTSTR *lpKey);

NTSTATUS
CtxDeleteKeyTree( HANDLE hKeyRoot,
                  PKEY_BASIC_INFORMATION pKeyInfo,
                  ULONG ulInfoSize );

PSECURITY_DESCRIPTOR GetSecurityInfo( LPTSTR File );
void FreeSecurityInfo(PSECURITY_DESCRIPTOR);

/***************************************************************************\
* ClearTempUserProfile
*
* Purpose : unloads the temp user profile loaded from a file, and deletes
*           the temp file
*
* History:
* 11-20-92 JohanneC       Created.
\***************************************************************************/
BOOL APIENTRY ClearTempUserProfile()
{
    BOOL bRet;

    if (hkeyCurrentUser == HKEY_CURRENT_USER)
        return(TRUE);

    //
    // Close registry keys.
    //
    if (hkeyCurrentUser) {
        RegCloseKey(hkeyCurrentUser);
    }

    hkeyCurrentUser = HKEY_CURRENT_USER;

    bRet = (RegUnLoadKey(HKEY_USERS, lpTempHiveKey) == ERROR_SUCCESS);

    if (*lpTempUserHive) {
        DeleteFile(lpTempUserHive);
        lstrcat(lpTempUserHive, TEXT(".log"));
        DeleteFile(lpTempUserHive);
        LocalFree(lpTempUserHive);
        lpTempUserHive = NULL;
    }

    return(bRet);
}


/***************************************************************************\
* OpenUserProfile
*
* Purpose : Load an existing profile in the registry and unload previously
* loaded profile (and delete its tmp file).
*
* History:
* 11-20-92 JohanneC       Created.
\***************************************************************************/
BOOL APIENTRY OpenUserProfile(LPTSTR szFilePath, PSID *pUserSid)
{

    DWORD err;

    //
    // Copy the profile to a temp hive before loading it in the registry.
    //
    if (!lpTempUserHivePath) {
        if (!AllocAndExpandEnvironmentStrings(TEMP_USER_HIVE_PATH, &lpTempUserHivePath))
            return(FALSE);
    }

    lpTempUserHive = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) *
                              (lstrlen(lpTempUserHivePath) + 17));
    if (!lpTempUserHive) {
        return(FALSE);
    }

    if (!GetTempFileName(lpTempUserHivePath, TEXT("tmp"), 0, lpTempUserHive)) {
        lstrcpy(lpTempUserHive, lpTempUserHivePath);
        lstrcat(lpTempUserHive, TEXT("\\HiveOpen"));
    }

    if (CopyFile(szFilePath, lpTempUserHive, FALSE)) {
        GetRegistryKeyFromPath(lpTempUserHive, &lpTempHiveKey);
        if ((err = RegLoadKey(HKEY_USERS, lpTempHiveKey, lpTempUserHive)) == ERROR_SUCCESS) {
            if ((err = RegOpenKeyEx(HKEY_USERS, lpTempHiveKey, 0,
                                    MAXIMUM_ALLOWED,
                                    &hkeyCurrentUser)) != ERROR_SUCCESS) {
                //
                // Error, do not have access to the profile.
                //
                ErrorPrintf(IDS_ERROR_PROFILE_LOAD_ERR, err);
                ClearTempUserProfile();
                return(FALSE);
            }
        }
        else {
            DeleteFile(lpTempUserHive);
            lstrcat(lpTempUserHive, TEXT(".log"));
            DeleteFile(lpTempUserHive);
            LocalFree(lpTempUserHive);

            //
            // Could not load the user profile, check the error code
            //
            if (err == ERROR_BADDB) {
                // bad format: not a profile registry file
                ErrorPrintf(IDS_ERROR_BAD_PROFILE);
                return(FALSE);
            }
            else {
                // generic error message : Failed to load profile
                ErrorPrintf(IDS_ERROR_PROFILE_LOAD_ERR, err);
                return(FALSE);
            }
        }
    }
    else {
        //
        // An error occured trying to load the profile.
        //
        DeleteFile(lpTempUserHive);

        switch ( (err = GetLastError()) ) {
        case ERROR_SHARING_VIOLATION:
            ErrorPrintf(IDS_ERROR_PROFILE_INUSE);
            break;
        default:
            ErrorPrintf(IDS_ERROR_PROFILE_LOAD_ERR, err);
            break;
        }
        return(FALSE);
    }

    //
    // Get the permitted user
    //
    *pUserSid = NULL;
    return(TRUE);
}

/***************************************************************************\
* SaveUserProfile
*
* Purpose : Save the loaded profile as a file.  The registry should already
*    have the existing ACL's already set so nothing needs to change.  The
*    file ACL's do need to be copied from the original and applied to the
*    saved file.  This function assumes the orignal file exists.
*
\***************************************************************************/
BOOL APIENTRY SaveUserProfile(PSID pUserSid, LPTSTR lpFilePath)
{
    LPTSTR lpTmpHive = NULL;
    BOOL err = FALSE;


    //
    // Save the profile to a temp hive then copy it over.
    //

    if ( AllocAndExpandEnvironmentStrings(TEMP_SAVE_HIVE, &lpTmpHive) )
    {
        if( lpTmpHive != NULL )
        {
            DeleteFile(lpTmpHive);

            if(RegSaveKey(hkeyCurrentUser, lpTmpHive, NULL) != ERROR_SUCCESS)
            {
                LocalFree(lpTmpHive);
                lpTmpHive = NULL;
                err = TRUE;
            }
            else
            {
                PSECURITY_DESCRIPTOR pSecDesc;
                DWORD Attrib = GetFileAttributes(lpFilePath);

                pSecDesc = GetSecurityInfo(lpFilePath);
                SetFileAttributes(lpFilePath,FILE_ATTRIBUTE_ARCHIVE);
                if(CopyFile(lpTmpHive, lpFilePath, FALSE))
                {
                    DeleteFile(lpTmpHive);
                    LocalFree(lpTmpHive);
                    lpTmpHive = NULL;
                    if (pSecDesc)
                    {
                        SetFileSecurity(lpFilePath,
                                        DACL_SECURITY_INFORMATION,
                                        pSecDesc);
                        FreeSecurityInfo(pSecDesc);
                    }
                }
                else
                {
                    if(pSecDesc)
                    {
                        FreeSecurityInfo(pSecDesc);
                    }
                    err = TRUE;
                }
                if(0xffffffff != Attrib)
                {
                    SetFileAttributes(lpFilePath,Attrib);
                }
            }
        }
    }
    else
    {
        err = TRUE;
    }

    if( lpTmpHive != NULL )
    {
        LocalFree(lpTmpHive);
    }

    return(!err);
}


/***************************************************************************\
* EnablePrivilege
*
* Enables/disabled the specified well-known privilege in the
* current process context
*
* Returns TRUE on success, FALSE on failure
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
BOOL
EnablePrivilege(
    DWORD Privilege,
    BOOL Enable
    )
{
    NTSTATUS Status;
#if 0
    BOOL WasEnabled;
    Status = RtlAdjustPrivilege(Privilege, Enable, TRUE, (PBOOLEAN)&WasEnabled);
    return(NT_SUCCESS(Status));
#else
    HANDLE ProcessToken;
    LUID LuidPrivilege;
    PTOKEN_PRIVILEGES NewPrivileges;
    DWORD Length;

    //
    // Open our own token
    //

    Status = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_ADJUST_PRIVILEGES,
                 &ProcessToken
                 );
    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    //
    // Initialize the privilege adjustment structure
    //

    LuidPrivilege = RtlConvertLongToLuid(Privilege);

    NewPrivileges = (PTOKEN_PRIVILEGES) LocalAlloc(LPTR, sizeof(TOKEN_PRIVILEGES) +
                         (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
    if (NewPrivileges == NULL) {
        NtClose(ProcessToken);
        return(FALSE);
    }

    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    //
    // WORKAROUND: because of a bug in NtAdjustPrivileges which
    // returns an error when you try to enable a privilege
    // that is already enabled, we first try to disable it.
    // to be removed when api is fixed.
    //
    NewPrivileges->Privileges[0].Attributes = 0;

    Status = NtAdjustPrivilegesToken(
                 ProcessToken,                     // TokenHandle
                 (BOOLEAN)FALSE,                   // DisableAllPrivileges
                 NewPrivileges,                    // NewPrivileges
                 0,                                // BufferLength
                 NULL,                             // PreviousState (OPTIONAL)
                 &Length                           // ReturnLength
                 );

    NewPrivileges->Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;
    //
    // Enable the privilege
    //
    Status = NtAdjustPrivilegesToken(
                 ProcessToken,                     // TokenHandle
                 (BOOLEAN)FALSE,                   // DisableAllPrivileges
                 NewPrivileges,                    // NewPrivileges
                 0,                                // BufferLength
                 NULL,                             // PreviousState (OPTIONAL)
                 &Length                           // ReturnLength
                 );

    LocalFree(NewPrivileges);

    NtClose(ProcessToken);

    if (Status) {
        return(FALSE);
    }

    return(TRUE);
#endif
}


BOOL AllocAndExpandEnvironmentStrings(LPTSTR String, LPTSTR *lpExpandedString)
{
     LPTSTR lptmp = NULL;
     DWORD cchBuffer;

     // Get the number of characters needed.
     cchBuffer = ExpandEnvironmentStrings(String, lptmp, 0);
     if (cchBuffer) {
         cchBuffer++;  // for NULL terminator
         lptmp = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * cchBuffer);
         if (!lptmp) {
             return(FALSE);
         }
         cchBuffer = ExpandEnvironmentStrings(String, lptmp, cchBuffer);
     }
     *lpExpandedString = lptmp;
     return(TRUE);
}


VOID GetRegistryKeyFromPath(LPTSTR lpPath, LPTSTR *lpKey)
{
    LPTSTR lptmp;

    *lpKey = lpPath;

    for (lptmp = lpPath; *lptmp; lptmp++) {
        if (*lptmp == TEXT('\\')) {
            *lpKey = lptmp+1;
        }
    }

}


/***************************************************************************\
* InitializeGlobalSids
*
* Initializes the various global Sids used in this module.
*
* History:
* 04-28-93 JohanneC       Created
\***************************************************************************/
VOID InitializeGlobalSids()
{
    NTSTATUS Status;

    //
    // Build the admins local group SID
    //

    Status = RtlAllocateAndInitializeSid(
                 &gNtAuthority,
                 2,
                 SECURITY_BUILTIN_DOMAIN_RID,
                 DOMAIN_ALIAS_RID_ADMINS,
                 0, 0, 0, 0, 0, 0,
                 &gAdminsLocalGroup
                 );

    //
    // create System Sid
    //

    Status = RtlAllocateAndInitializeSid(
                   &gNtAuthority,
                   1,
                   SECURITY_LOCAL_SYSTEM_RID,
                   0, 0, 0, 0, 0, 0, 0,
                   &gSystemSid
                   );

}



/*****************************************************************************
 *
 *  ClearDisabledClasses
 *
 *  This routine will check the compatibility flags for the user's Classes
 *  registry key, and remove the keys if mapping is disabled.
 *
 * ENTRY:
 *
 * EXIT:
 *   No return value.
 *
 ****************************************************************************/

void ClearDisabledClasses(void)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ulcnt = 0, ultemp = 0;
    UNICODE_STRING UniPath;
    OBJECT_ATTRIBUTES ObjAttr;
    PKEY_BASIC_INFORMATION pKeyUserInfo = NULL;
    HANDLE hKeyUser = NULL;
    NTSTATUS Status2;
    HANDLE hClassesKey;
    WCHAR wcuser[MAX_PATH];

    if ( ! hkeyCurrentUser) {
        return;
    }

    GetTermsrCompatFlags(CITRIX_CLASSES, &ultemp, CompatibilityRegEntry);
    if ( (ultemp & (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP)) !=
         (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP)) {
        return;
    }

    // Get a buffer for the key info
    ulcnt = sizeof(KEY_BASIC_INFORMATION) + MAX_PATH*sizeof(WCHAR) + sizeof(WCHAR);
    pKeyUserInfo = RtlAllocateHeap(RtlProcessHeap(),
                                   0,
                                   ulcnt);
    if (!pKeyUserInfo) {
        Status = STATUS_NO_MEMORY;
    }

    // We have the necessary buffers, start checking the keys
    if (NT_SUCCESS(Status)) {
        // Build up a string for this user's software section
        wcscpy(wcuser, L"Software");

        // Create a unicode string for the user key path
        RtlInitUnicodeString(&UniPath, wcuser);

        InitializeObjectAttributes(&ObjAttr,
                                   &UniPath,
                                   OBJ_CASE_INSENSITIVE,
                                   hkeyCurrentUser,
                                   NULL);

        Status = NtOpenKey(&hKeyUser,
                           KEY_READ | DELETE,
                           &ObjAttr);

        RtlInitUnicodeString(&UniPath, L"Classes");

        InitializeObjectAttributes(&ObjAttr,
                                   &UniPath,
                                   OBJ_CASE_INSENSITIVE,
                                   hKeyUser,
                                   NULL);
        Status2 = NtOpenKey(&hClassesKey, KEY_READ | DELETE, &ObjAttr);
        if ( NT_SUCCESS(Status2) ) {
            Status2 = CtxDeleteKeyTree(hClassesKey, pKeyUserInfo, ulcnt);

            if ( !NT_SUCCESS(Status2)) {
            }
                NtClose(hClassesKey);
        }

        // If we allocated the system key, close it
        if (hKeyUser) {
            NtClose(hKeyUser);
        }
    }

    // Free up any memory we allocated
    if (pKeyUserInfo) {
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyUserInfo);
    }
}




/*****************************************************************************
 *
 *  CtxDeleteKeyTree
 *
 *  Delete a subtree of registry keys
 *
 * ENTRY:
 *    hKeyRoot   is a handle to the root key that will be deleted along with
 *               its children
 *    pKeyInfo   is a pointer to a KEY_BASIC_INFORMATION buffer that is
 *               large enough to hold a MAX_PATH WCHAR string.  It is
 *               reused and destroyed by each recursive call.
 *    ulInfoSize is the size of the pKeyInfo buffer
 *
 * EXIT:
 *    Status
 *
 ****************************************************************************/

NTSTATUS
CtxDeleteKeyTree( HANDLE hKeyRoot,
                  PKEY_BASIC_INFORMATION pKeyInfo,
                  ULONG ulInfoSize )
{
    NTSTATUS Status = STATUS_SUCCESS, Status2;
    UNICODE_STRING UniPath;
    OBJECT_ATTRIBUTES ObjAttr;
    ULONG ulcnt = 0;
    ULONG ultemp;
    HANDLE hKey;

    // Go through each of the subkeys
    while (NT_SUCCESS(Status)) {

        Status = NtEnumerateKey(hKeyRoot,
                                ulcnt,
                                KeyBasicInformation,
                                pKeyInfo,
                                ulInfoSize,
                                &ultemp);

        // Delete sub keys
        if (NT_SUCCESS(Status)) {

            // Null terminate the key name
            pKeyInfo->Name[pKeyInfo->NameLength/sizeof(WCHAR)] = L'\0';

            // Create a unicode string for the key name
            RtlInitUnicodeString(&UniPath, pKeyInfo->Name);

            InitializeObjectAttributes(&ObjAttr,
                                       &UniPath,
                                       OBJ_CASE_INSENSITIVE,
                                       hKeyRoot,
                                       NULL);

            // Open up the child key
            Status2 = NtOpenKey(&hKey,
                                MAXIMUM_ALLOWED,
                                &ObjAttr);

            if ( NT_SUCCESS(Status2) ) {
                Status2 = CtxDeleteKeyTree ( hKey, pKeyInfo, ulInfoSize );
                NtClose(hKey);
                //  If the key was not successfully deleted, we need
                //  to increment the enumerate index to guarantee
                //  that the alogorithm will complete.
                if ( !NT_SUCCESS(Status2) ) {
                    ++ulcnt;
                }
            }
        }
    }

    // If we deleted all the sub-keys delete the curent key
    if ( !ulcnt ) {
        Status = NtDeleteKey(hKeyRoot);
    }
    else {
        Status = STATUS_CANNOT_DELETE;
    }
    return ( Status );
}


PSECURITY_DESCRIPTOR
GetSecurityInfo(LPTSTR lpFilePath)
{
    int SizeReq = 0;
    PSECURITY_DESCRIPTOR pSecDesc = NULL;

    GetFileSecurity(lpFilePath, DACL_SECURITY_INFORMATION, pSecDesc, 0,
                    &SizeReq);
    if ( !SizeReq ) {
        return (NULL);
    }

    pSecDesc = LocalAlloc(LPTR, SizeReq);
    if ( pSecDesc ) {
        if ( !GetFileSecurity(lpFilePath, DACL_SECURITY_INFORMATION, pSecDesc,
                        SizeReq, &SizeReq) ) {
            LocalFree(pSecDesc);
            pSecDesc = NULL;
        }
    }
    return (pSecDesc);
}

void
FreeSecurityInfo(PSECURITY_DESCRIPTOR pSecDesc)
{
    LocalFree(pSecDesc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\disconn\tsdiscon.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*************************************************************************
*
*  TSDISCON.C
*
*     This module is the TSDISCON utility code.
*
*
*************************************************************************/

#include <stdio.h>
#include <windows.h>
//#include <ntddkbd.h>
//#include <ntddmou.h>
#include <winstaw.h>
#include <stdlib.h>
#include <utilsub.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <winnlsp.h>

#include "tsdiscon.h"
#include "printfoa.h"


// max length of the locale string
#define MAX_LOCALE_STRING 64


WINSTATIONNAME WSName;
USHORT help_flag = FALSE;
USHORT v_flag    = FALSE;
HANDLE hServerName = SERVERNAME_CURRENT;
WCHAR  ServerName[MAX_IDS_LEN+1];

TOKMAP ptm[] =
{
#define TERM_PARM 0
   {TOKEN_WS,           TMFLAG_OPTIONAL, TMFORM_STRING,
                            WINSTATIONNAME_LENGTH, WSName},

   {TOKEN_SERVER,       TMFLAG_OPTIONAL, TMFORM_STRING,
                            MAX_IDS_LEN, ServerName},

   {TOKEN_HELP,         TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                            sizeof(USHORT), &help_flag},

   {TOKEN_VERBOSE,      TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                            sizeof(USHORT), &v_flag},

   {0, 0, 0, 0, 0}
};


/*
 * Local function prototypes.
 */
void Usage( BOOLEAN bError );



/*************************************************************************
*
*  main
*     Main function and entry point of the TSDISCON
*     utility.
*
*  ENTRY:
*     argc  - count of the command line arguments.
*     argv  - vector of strings containing the command line arguments.
*
*  EXIT
*     Nothing.
*
*************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    BOOLEAN bCurrent = FALSE;
    int   rc, i;
    ULONG Error;
    WCHAR *CmdLine;
    WCHAR **argvW, *endptr;
    ULONG LogonId;
    WCHAR wszString[MAX_LOCALE_STRING + 1];

    setlocale(LC_ALL, ".OCP");
    
    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);
    
    SetThreadUILanguage(0);

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

        //Check if we are running under Terminal Server
        if ((!IsTokenPresent(ptm, TOKEN_SERVER) ) && (!AreWeRunningTerminalServices()))
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }

    /*
     * Validate input string for WinStation or LogonId.
     */
    if ( !IsTokenPresent(ptm, TOKEN_WS) ) {

        /*
         * No string specified; use current WinStation / LogonId.
         */
        bCurrent = TRUE;
        LogonId = GetCurrentLogonId();
        if ( !WinStationNameFromLogonId(hServerName, LogonId, WSName) ) {
            ErrorPrintf(IDS_ERROR_CANT_GET_CURRENT_WINSTATION, GetLastError());
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }

    } else if ( !iswdigit(*WSName) ) {

        /*
         * Treat the string as a WinStation name.
         */
        if ( !LogonIdFromWinStationName(hServerName, WSName, &LogonId) ) {
            StringErrorPrintf(IDS_ERROR_WINSTATION_NOT_FOUND, WSName);
            return(FAILURE);
        }

    } else {

        /*
         * Treat the string as a LogonId.
         */
        LogonId = wcstoul(WSName, &endptr, 10);
        if ( *endptr ) {
            StringErrorPrintf(IDS_ERROR_INVALID_LOGONID, WSName);
            return(FAILURE);
        }
        if ( !WinStationNameFromLogonId(hServerName, LogonId, WSName) ) {
            ErrorPrintf(IDS_ERROR_LOGONID_NOT_FOUND, LogonId);
            return(FAILURE);
        }
    }

    /*
     * Perform the disconnect.
     */
    if ( v_flag )
        DwordStringMessage(IDS_WINSTATION_DISCONNECT, LogonId, WSName);

    if ( !WinStationDisconnect(hServerName, LogonId, TRUE) ) {

        if ( bCurrent )
            ErrorPrintf(IDS_ERROR_DISCONNECT_CURRENT,
                         GetLastError());
        else
            ErrorPrintf(IDS_ERROR_DISCONNECT,
                         LogonId, WSName, GetLastError());
        PutStdErr( GetLastError(), 0 );
        return(FAILURE);
    }

    return(SUCCESS);

} /* main() */


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 *  EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {

        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_USAGE_1);
        ErrorPrintf(IDS_USAGE_2);
        ErrorPrintf(IDS_USAGE_3);
        ErrorPrintf(IDS_USAGE_4);
        ErrorPrintf(IDS_USAGE_5);
        ErrorPrintf(IDS_USAGE_6);

    } else {

        Message(IDS_USAGE_1);
        Message(IDS_USAGE_2);
        Message(IDS_USAGE_3);
        Message(IDS_USAGE_4);
        Message(IDS_USAGE_5);
        Message(IDS_USAGE_6);
    }

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\flattemp\flattemp.h ===
/***********************************************************************
*
*   FLATTEMP.H
*
*   This module contains typedefs and defines required for
*   the FLATTEMP utility.
*
*   Copyright Citrix Systems Inc. 1996
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_HELP_USAGE1                                 102
#define IDS_HELP_USAGE2                                 103
#define IDS_HELP_USAGE3                                 104
#define IDS_HELP_USAGE4                                 105
#define IDS_HELP_USAGE5                                 106
#define IDS_FLATTEMP_DISABLED                           107
#define IDS_FLATTEMP_ENABLED                            108
#define IDS_ACCESS_DENIED                               109
#define IDS_ACCESS_DENIED_ADMIN                         110
#define IDS_ERROR_NOT_TS                                111
#define IDS_ACCESS_DENIED_DUE_TO_GROUP_POLICY           112
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\inc\ansiuni.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*******************************************************************************
*
* ansiuni.h
*
* ANSI / UNICODE function defines
*
*
*******************************************************************************/

#ifdef UNICODE
#ifndef TCHAR
#define TCHAR WCHAR
#endif // TCHAR
#define lstrscanf swscanf
#define lstrncpy wcsncpy
#define lstrtoul wcstoul
#define lstrtol wcstol
#define lstrnicmp _wcsnicmp
#define lstrupr _wcsupr
#define lstrlwr _wcslwr
#define islstrdigit iswdigit
#define lstrtok wcstok
#define lstrprintf swprintf
#define lstrnprintf _snwprintf
#define lstrchr wcschr
#define lstrpbrk wcspbrk
#define lstrrchr wcsrchr
#define lstr_getcwd _wgetcwd
#define lstr_access _waccess
#define lstr_mkdir _wmkdir
#define lstrstr wcsstr
#define lstrcspn wcscspn
#else
#ifndef TCHAR
#define TCHAR char
#endif // TCHAR
#ifdef WIN16
#define lstrscanf sscanf	    // need to cast string args to NEAR pointers
#define lstrncpy _fstrncpy
#define lstrtoul strtoul	    // need to cast string args to NEAR pointers
#define lstrtol strtol		    // need to cast string args to NEAR pointers
#define lstrnicmp _fstrnicmp
#define lstrupr _fstrupr
#define lstrlwr _fstrlwr
#define islstrdigit isdigit
#define lstrtok _fstrtok
#define lstrprintf sprintf          // need to cast string args to NEAR pointers
#define lstrnprintf _snprintf	    // need to cast string args to NEAR pointers
#define lstrchr _fstrchr
#define lstrpbrk _fstrpbrk
#define lstrrchr _fstrrchr
#define lstr_getcwd _getcwd	    // need to cast string args to NEAR pointers
#define lstr_access _access	    // need to cast string args to NEAR pointers
#define lstr_mkdir _mkdir	    // need to cast string args to NEAR pointers
#define lstrstr strstr  	    // need to cast string args to NEAR pointers
#define lstrcspn strcspn	    // need to cast string args to NEAR pointers
#else
#define lstrscanf sscanf
#define lstrncpy strncpy
#define lstrtoul strtoul
#define lstrtol strtol
#define lstrnicmp _strnicmp
#define lstrupr _strupr
#define lstrlwr _strlwr
#define islstrdigit isdigit
#define lstrtok strtok
#define lstrprintf sprintf
#define lstrnprintf _snprintf
#define lstrchr strchr
#define lstrpbrk strpbrk
#define lstrrchr strrchr
#define lstr_getcwd _getcwd
#define lstr_access _access
#define lstr_mkdir _mkdir
#define lstrstr strstr
#define lstrcspn strcspn
#endif // WIN16
#endif // UNICODE

#define lengthof(x)    (sizeof(x) / sizeof(TCHAR))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\inc\expand.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*****************************************************************************
*
*   EXPAND.H
*
*
****************************************************************************/

/*
* Argument structure
*    Used by expand_path routine to build argument list.
*    Caller should initialize using args_init().  Use args_reset() to
*    reset values, args_free() to free memory allocated by args_init().
*/
struct arg_data {
   int argc;
   WCHAR **argv;
   WCHAR **argvp;
   int maxargc;
   int maxargs;
   WCHAR *buf;
   WCHAR *bufptr;
   WCHAR *bufend;
};
typedef struct arg_data ARGS;

/*
 * max size of segment to allocate for pathname storage
 */
#define MAX_ARG_ALLOC 10*1024-20

extern void args_init(ARGS *, int);
extern void args_trunc(ARGS *);
extern void args_reset(ARGS *);
extern void args_free(ARGS *);
extern int  expand_path(WCHAR *, unsigned short, ARGS *);
extern int  unix_match(WCHAR *, WCHAR *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\disconn\tsdiscon.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*************************************************************************
*
*  TSDISCON.H
*     This module contains typedefs and defines for the TSDISCON
*     WinStation utility.
*
*
*************************************************************************/

/*
 * Token string definitions.
 */
#define TOKEN_WS                        L""
#define TOKEN_VERBOSE                   L"/v"
#define TOKEN_HELP                      L"/?"
#define TOKEN_SERVER                    L"/server"


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_WINSTATION_NOT_FOUND                  102
#define IDS_ERROR_INVALID_LOGONID                       103
#define IDS_ERROR_LOGONID_NOT_FOUND                     104
#define IDS_ERROR_DISCONNECT                            105
#define IDS_ERROR_DISCONNECT_CURRENT                    106
#define IDS_ERROR_CANT_GET_CURRENT_WINSTATION           107
#define IDS_ERROR_SERVER                                108

#define IDS_USAGE_1                                     121
#define IDS_USAGE_2                                     122
#define IDS_USAGE_3                                     123
#define IDS_USAGE_4                                     124
#define IDS_USAGE_5                                     125
#define IDS_USAGE_6                                     126
#define IDS_ERROR_NOT_TS                                127

#define IDS_WINSTATION_DISCONNECT                       200
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\inc\printfoa.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
//=============================================================================
//
//
//=============================================================================


#ifndef _PRINTF_OEM_ANSI_H
#define _PRINTF_OEM_ANSI_H


// Include files:
//===============
#include <windows.h>
#include <stdio.h>

// Forward References:
//====================


// Const/Define:
//==============

#define printf  ANSI2OEM_Printf
#define wprintf ANSI2OEM_Wprintf

// Classes/Structs:
//=================


// Function Prototypes:
//=====================

#ifdef __cpluspus
extern "C" {
#endif
int ANSI2OEM_Printf(const char *format, ...);
int ANSI2OEM_Wprintf(const wchar_t *format, ...);
void OEM2ANSIW(wchar_t *buffer, USHORT len);
void OEM2ANSIA(char *buffer, USHORT len);
#ifdef __cpluspus
};
#endif

#endif

// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\flattemp\flattemp.c ===
/******************************************************************************
*
*   FLATTEMP.C
*
*   This module contains code for the FLATTEMP utility.
*   This utility adds or removes the Flat Temporary directory registry key.
*
*   Copyright Citrix Systems Inc. 1996
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winstaw.h>
#include <regapi.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <utilsub.h>
#include <string.h>
#include <utildll.h>
#include <locale.h>
#include <winnlsp.h>

#include "flattemp.h"
#include "printfoa.h"


// max length of the locale string
#define MAX_LOCALE_STRING 64


/*
 * Global Data
 */
USHORT   help_flag    = FALSE;             // User wants help
USHORT   fQuery       = FALSE;             // query
USHORT   fDisable     = FALSE;             // disable
USHORT   fEnable      = FALSE;             // enable

TOKMAP ptm[] = {
      {L"/query",   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fQuery},
      {L"/enable",  TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fEnable},
      {L"/disable", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fDisable},
      {L"/?",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
      {0, 0, 0, 0, 0}
};


/*
 * Local function prototypes.
 */
VOID  Usage(BOOLEAN bError);
LONG  DeleteKey(VOID);
LONG  AddKey(VOID);
BOOL  QueryKey(VOID);


#define SZENABLE TEXT("1")


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    WCHAR *CmdLine;
    WCHAR **argvW;
    LONG  rc = 0;
    INT   i;
    POLICY_TS_MACHINE policy;
    WCHAR wszString[MAX_LOCALE_STRING + 1];

    setlocale(LC_ALL, ".OCP");
    
    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);

    SetThreadUILanguage(0);

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || rc ) {

             if ( !help_flag && !(rc & PARSE_FLAG_NO_PARMS) ) {

                Usage(TRUE);
                return(FAILURE);

             } else {

                Usage(FALSE);
                return(SUCCESS);
             }
    }

    /*
     * If there is a policy to user tmp folders, then prevent
     * this tool from running.
     */
    RegGetMachinePolicy( &policy );

    if ( policy.fPolicyTempFoldersPerSession )
    {
        Message( IDS_ACCESS_DENIED_DUE_TO_GROUP_POLICY );
        return ( FAILURE );
    }

        //Check if we are running under Terminal Server
        if(!AreWeRunningTerminalServices())
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    if (!TestUserForAdmin(FALSE)) {
        Message(IDS_ACCESS_DENIED_ADMIN);
        return(FAILURE);
    }

    /*
     *  Enable or disable
     */
    rc = 0; // reset in case it changed above and we're querying...
    if ( fDisable ) {
        rc = DeleteKey();
        Message(IDS_FLATTEMP_DISABLED);
    } else if ( fEnable ) {
        rc = AddKey();
        Message(IDS_FLATTEMP_ENABLED);
    } else if ( fQuery ) {
        if ( QueryKey() ) {
           Message(IDS_FLATTEMP_ENABLED);
        } else {
           Message(IDS_FLATTEMP_DISABLED);
        }
    }

    /*
     *  Error?  (It'll be set if there's a problem...)
     */
    if ( rc ) {
        Message(IDS_ACCESS_DENIED);
    }

    return(SUCCESS);
}


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        Message(IDS_ERROR_INVALID_PARAMETERS);
    }
    Message(IDS_HELP_USAGE1);
    Message(IDS_HELP_USAGE2);
    Message(IDS_HELP_USAGE3);
    Message(IDS_HELP_USAGE4);
    Message(IDS_HELP_USAGE5);

}  /* Usage() */


/*******************************************************************************
 *
 *  QueryKey
 *
 *  ENTRY:
 *
 *  EXIT: TRUE  - enabled
 *        FALSE - disabled (key doesn't exist or isn't "1")
 *
 *
 ******************************************************************************/

BOOL
QueryKey()
{
    DWORD  dwType = REG_SZ;
    DWORD  dwSize = 3 * sizeof(WCHAR);
    WCHAR  szValue[3];
    HKEY   Handle;
    LONG   rc;

    /*
     *  Open registry
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REG_CONTROL_TSERVER,
                       0,
                       KEY_READ,
                       &Handle ) != ERROR_SUCCESS )
        return FALSE;

    /*
     *  Read registry value
     */
    rc = RegQueryValueExW( Handle,
                           REG_CITRIX_FLATTEMPDIR,
                           NULL,
                           &dwType,
                           (PUCHAR)&szValue,
                           &dwSize );

    /*
     *  Close registry and key handle
     */
    RegCloseKey( Handle );

    if ( rc == ERROR_SUCCESS && lstrcmp(szValue,SZENABLE) == 0 ) {
       return TRUE;
    } else {
       return FALSE;
    }
}


/*******************************************************************************
 *
 *  DeleteKey
 *
 *  ENTRY:
 *
 *  EXIT:
 *
 *
 ******************************************************************************/

LONG
DeleteKey()
{
    HKEY   Handle;
    LONG   rc;

    /*
     *  Open registry
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REG_CONTROL_TSERVER,
                       0,
                       KEY_ALL_ACCESS,
                       &Handle ) != ERROR_SUCCESS )
        return FALSE;

    /*
     *  Delete flat temp directory key
     */
    rc = RegDeleteValueW( Handle,
                          REG_CITRIX_FLATTEMPDIR );

    if (rc == ERROR_FILE_NOT_FOUND) {
        rc = ERROR_SUCCESS;
    }

    /*
     *  Close registry and key handle
     */
    RegCloseKey( Handle );

    return( rc );
}


/*******************************************************************************
 *
 *  AddKey
 *
 *  ENTRY:
 *
 * EXIT:
 *
 *
 ******************************************************************************/

LONG
AddKey()
{
    HKEY   Handle;
    LONG   rc;
    DWORD  dwDummy;

    /*
     *  Open registry
     */
    if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                         REG_CONTROL_TSERVER,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         &Handle,
                         &dwDummy ) != ERROR_SUCCESS )
        return FALSE;

    /*
     *  Write registry value
     */
    rc = RegSetValueExW( Handle,
                         REG_CITRIX_FLATTEMPDIR,
                         0,
                         REG_SZ,
                         (PUCHAR)SZENABLE,
                         sizeof(SZENABLE) );

    /*
     *  Close registry and key handle
     */
    RegCloseKey( Handle );

    return( rc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\inc\utilsub.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*****************************************************************************
*   UTILSUB.H
*      This file contains the structure definitions and equtates for
*      communication between calling programs and functions in utilsub.lib.
*
****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

/*-----------------------------------------------------------------------------
 --   type-defs for File List Structure.
 ----------------------------------------------------------------------------*/
typedef struct _FILELIST {
   int	  argc;
   WCHAR  **argv;
} FILELIST, *PFILELIST;

/*-----------------------------------------------------------------------------
 --   type-defs for Token Map Structure.
 ----------------------------------------------------------------------------*/
// UNICODE version
typedef struct _TOKMAPW {
   PWCHAR tmToken;	   /* token; null pointer terminates list */
   USHORT tmFlag;	   /* flags for control communication */
   USHORT tmForm;	   /* format control string */
   USHORT tmDLen;	   /* length of data fields */
   PVOID  tmAddr;	   /* pointer to interpreted data */
} TOKMAPW, *PTOKMAPW;

// ANSI version
typedef struct _TOKMAPA {
   PCHAR  tmToken;	   /* token; null pointer terminates list */
   USHORT tmFlag;	   /* flags for control communication */
   USHORT tmForm;	   /* format control string */
   USHORT tmDLen;	   /* length of data fields */
   PVOID  tmAddr;	   /* pointer to interpreted data */
} TOKMAPA, *PTOKMAPA;

/*-----------------------------------------------------------------------------
 --   type-defs for Token Map Structure USE FOR CALLING SDM.DLL FUNCIONS
 ----------------------------------------------------------------------------*/
typedef struct _FILETOKMAP {
   PWCHAR tmToken;         /* token; null pointer terminates list */
   USHORT tmFlag;	   /* flags for control communication */
   USHORT tmForm;	   /* format control string */
   USHORT tmDLen;	   /* length of data fields */
   PVOID  tmAddr;	   /* pointer to interpreted data */
   USHORT tmLast;	   /* pointer for FindFirst FindNext junk */
} FILETOKMAP, FAR * PFILETOKMAP, NEAR * NPFILETOKMAP, * DPFILETOKMAP;

/*-----------------------------------------------------------------------------
 --   equates for _TOKMAP->tmFlag
 ----------------------------------------------------------------------------*/
#define TMFLAG_OPTIONAL       0x0000
#define TMFLAG_REQUIRED       0x0001
#define TMFLAG_PRESENT	      0x0002   /* was present in command line */
#define TMFLAG_MODIFIED       0x0004   /* was modified by app, request write */
#define TMFLAG_DELETE	      0x0008   /* request delete */

/*-----------------------------------------------------------------------------
 --   equates for _TOKMAP->tmForm
 ----------------------------------------------------------------------------*/
#define TMFORM_VOID	      0x0000
#define TMFORM_BOOLEAN	      0x0001
#define TMFORM_BYTE	      0x0002
#define TMFORM_CHAR	      0x0003
#define TMFORM_STRING	      0x0004
#define TMFORM_SHORT	      0x0005
#define TMFORM_USHORT	      0x0006
#define TMFORM_LONG	      0x0007
#define TMFORM_ULONG	      0x0008
#define TMFORM_HEX	      0x0009
#define TMFORM_LONGHEX	      0x000A
#define TMFORM_SERIAL	      0x000B
#define TMFORM_DATE	      0x000C
#define TMFORM_PHONE	      0x000D
#define TMFORM_X_STRING       0x000E
#define TMFORM_FILES	      0x000F
#define TMFORM_S_STRING       0x0010

/*-----------------------------------------------------------------------------
 --   equates for _TOKMAP->tmDLen
 ----------------------------------------------------------------------------*/
#define TMDLEN_VOID	      0x0000

/*-----------------------------------------------------------------------------
 --   prototype for Parse and setargv functions
 ----------------------------------------------------------------------------*/
// UNICODE prototypes
int WINAPI setargvW( LPWSTR szModuleName, LPWSTR szCmdLine, int *, WCHAR *** );
void WINAPI freeargvW( WCHAR ** );
USHORT WINAPI ParseCommandLineW(INT, WCHAR **, PTOKMAPW, USHORT);
BOOLEAN WINAPI IsTokenPresentW( PTOKMAPW, PWCHAR );
BOOLEAN WINAPI SetTokenPresentW( PTOKMAPW, PWCHAR );
BOOLEAN WINAPI SetTokenNotPresentW( PTOKMAPW, PWCHAR );

// ANSI prototypes
int WINAPI setargvA( LPSTR szModuleName, LPSTR szCmdLine, int *, char *** );
void WINAPI freeargvA( char ** );
USHORT WINAPI ParseCommandLineA(INT, CHAR **, PTOKMAPA, USHORT);
BOOLEAN WINAPI IsTokenPresentA( PTOKMAPA, PCHAR );
BOOLEAN WINAPI SetTokenPresentA( PTOKMAPA, PCHAR );
BOOLEAN WINAPI SetTokenNotPresentA( PTOKMAPA, PCHAR );

#ifdef UNICODE
#define setargv setargvW
#define freeargv freeargvW
#define ParseCommandLine ParseCommandLineW
#define IsTokenPresent IsTokenPresentW
#define SetTokenPresent SetTokenPresentW
#define SetTokenNotPresent SetTokenNotPresentW
#define TOKMAP TOKMAPW
#define PTOKMAP PTOKMAPW
#else
#define setargv setargvA
#define freeargv freeargvA
#define ParseCommandLine ParseCommandLineA
#define IsTokenPresent IsTokenPresentA
#define SetTokenPresent SetTokenPresentA
#define SetTokenNotPresent SetTokenNotPresentA
#define TOKMAP TOKMAPA
#define PTOKMAP PTOKMAPA
#endif /* UNICODE */

/*-----------------------------------------------------------------------------
 --   flags for ParseCommandLine().
 ----------------------------------------------------------------------------*/
#define PCL_FLAG_CONTINUE_ON_ERROR     0x0001
#define PCL_FLAG_RET_ON_FIRST_SUCCESS  0x0002
#define PCL_FLAG_IGNORE_INVALID        0x0004
#define PCL_FLAG_NO_CLEAR_MEMORY       0x0008
#define PCL_FLAG_NO_VERSION_CHECK      0x0010
#define PCL_FLAG_VERSION_CHK_UPWARD    0x0020

/*-----------------------------------------------------------------------------
 --   flags for rc=ParseCommandLine(),	PARSE_FLAG_* (BIT FLAGS)
 ----------------------------------------------------------------------------*/
#define PARSE_FLAG_NO_ERROR	       0x0000
#define PARSE_FLAG_MISSING_REQ_FIELD   0x0001
#define PARSE_FLAG_INVALID_PARM        0x0002
#define PARSE_FLAG_DUPLICATE_FIELD     0x0004
#define PARSE_FLAG_NO_PARMS	       0x0008
#define PARSE_FLAG_TOO_MANY_PARMS      0x0010
#define PARSE_FLAG_NOT_ENOUGH_MEMORY   0x0020

/*-----------------------------------------------------------------------------
 --   prototypes for WinStation utility functions
 ----------------------------------------------------------------------------*/

VOID WINAPI RefreshAllCaches();

VOID WINAPI RefreshWinStationCaches();

VOID WINAPI RefreshWinStationObjectCache();

VOID WINAPI RefreshWinStationNameCache();

ULONG WINAPI GetCurrentLogonId( );

VOID WINAPI GetCurrentWinStationName( PWCHAR, int );

BOOLEAN WINAPI GetWinStationNameFromId( ULONG, PWCHAR, int );
BOOLEAN WINAPI xxxGetWinStationNameFromId( HANDLE, ULONG, PWCHAR, int);


BOOLEAN WINAPI GetWinStationUserName( HANDLE, ULONG, PWCHAR, int );

VOID WINAPI GetCurrentUserName( PWCHAR, int );

BOOLEAN WINAPI WinStationObjectMatch( HANDLE, VOID *, PWCHAR );

/*-----------------------------------------------------------------------------
 --   prototypes for process/user utility functions
 ----------------------------------------------------------------------------*/

VOID WINAPI RefreshProcessObjectCaches();

VOID WINAPI RefreshUserSidCrcCache();

BOOLEAN WINAPI ProcessObjectMatch( HANDLE, ULONG, int, PWCHAR, PWCHAR, PWCHAR, PWCHAR );

VOID WINAPI GetUserNameFromSid( VOID *, PWCHAR, PULONG );

/*-----------------------------------------------------------------------------
 --   prototypes for helper functions
 ----------------------------------------------------------------------------*/

USHORT WINAPI CalculateCrc16( PBYTE, USHORT );

INT WINAPI ExecProgram( PPROGRAMCALL, INT, WCHAR ** );

VOID WINAPI ProgramUsage( LPCWSTR, PPROGRAMCALL, BOOLEAN );

VOID WINAPI Message( int nResourceID, ... );

VOID WINAPI StringMessage( int nErrorResourceID, PWCHAR pString );

VOID WINAPI StringDwordMessage( int nErrorResourceID, PWCHAR pString, DWORD Num );

VOID WINAPI DwordStringMessage( int nErrorResourceID, DWORD Num, PWCHAR pString );

VOID WINAPI ErrorPrintf( int nErrorResourceID, ... );

VOID WINAPI StringErrorPrintf( int nErrorResourceID, PWCHAR pString );

VOID WINAPI StringDwordErrorPrintf( int nErrorResourceID, PWCHAR pString, DWORD Num );

VOID WINAPI TruncateString( PWCHAR pString, int MaxLength );

PPDPARAMS WINAPI EnumerateDevices(PDLLNAME pDllName, PULONG pEntries);

FILE * WINAPI wfopen( LPCWSTR filename, LPCWSTR mode );

PWCHAR WINAPI wfgets( PWCHAR Buffer, int Len, FILE *Stream);

int WINAPI PutStdErr(unsigned int MsgNum, unsigned int NumOfArgs, ...);

BOOL AreWeRunningTerminalServices(void);

WCHAR **MassageCommandLine(DWORD dwArgC);

int __cdecl
My_wprintf(
    const wchar_t *format,
    ...
    );

int __cdecl
My_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   );

int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\msg\msg.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*  MSG.C
*     Send a message to another user.
*
*  Syntax:
*
*    MSG [username]       [/TIME:seconds] [/V] [/W] [/?] [message]\n" \
*    MSG [WinStationName] [/TIME:seconds] [/V] [/W] [/?] [message]\n" \
*    MSG [logonid]        [/TIME:seconds] [/V] [/W] [/?] [message]\n" \
*    MSG [@filename]      [/TIME:seconds] [/V] [/W] [/?] [message]\n" \
*
*    /TIME:seconds - time delay to wait for receiver to acknowledge msg\n" \
*    /V            - display information about actions being performed\n" \
*    /W            - wait for response from user, useful with /V
*    /?            - display syntax and options\n"
*
*  Parameters:
*
*      username
*         Identifies all logins belonging to the specific username
*
*      winstationname
*         Identifies all logins connected to the winstation name regardless
*         of loginname.
*
*      logonid
*         Decimal number specifying a logon id to send the message to
*
*      @filename
*         Identifies a file that contains usernames or winstation names to
*         send messages to.
*
*   Options:
*
*      /SELF  >>>> UNPUBLISHED <<<<
*         Send message to caller of msg.  Used to send a message to
*         users when maintenace mode is enabled.
*
*      /TIME:seconds (time delay)
*         The amount of time to wait for an acknowledgement from the target
*         login that the message has been received.
*
*      /V (verbose)
*         Display information about the actions being performed.
*
*      /? (help)
*         Display the syntax for the utility and information about the
*         options.
*
*      message
*         The text of the message to send.  If the text is not specified
*         then the text is read from STDIN.
*
*   Remarks:
*
*     The message can be typed on the command line or be read from STDIN.
*     The message is sent via a popup.  The user receiving the popup can
*     hit a key to get rid of it or it will go away after a default timeout.
*
*     If the target of the message is a terminal, then the message is
*     sent to all logins on the target terminal.
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdio.h>
#include <windows.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <stdlib.h>
#include <time.h>
#include <utilsub.h>
#include <process.h>
#include <string.h>
#include <malloc.h>
#include <wchar.h>
#include <io.h>  // for isatty
#include <locale.h>
#include <winnlsp.h>

#include "msg.h"
#include "printfoa.h"


// max length of the locale string
#define MAX_LOCALE_STRING 64


/*=============================================================================
==   Global Data
=============================================================================*/

ULONG      Seconds;
USHORT     file_flag=FALSE;   //wkp
USHORT     v_flag;
USHORT     self_flag;
USHORT     help_flag;
WCHAR      ids_input[MAX_IDS_LEN];
PWCHAR     MsgText, MsgTitle;
WCHAR      MsgLine[MAX_IDS_LEN];
ULONG      gCurrentLogonId = (ULONG)(-1);
BOOLEAN    wait_flag = FALSE;
HANDLE     hServerName = SERVERNAME_CURRENT;
WCHAR      ServerName[MAX_IDS_LEN+1];

/*
 * The token map structure is used for parsing program arguments
 */
TOKMAP ptm[] = {
   { TOKEN_INPUT,       TMFLAG_REQUIRED, TMFORM_STRING,   MAX_IDS_LEN,
                            ids_input },

   { TOKEN_SERVER,      TMFLAG_OPTIONAL, TMFORM_STRING,   MAX_IDS_LEN,
                            ServerName},

   { TOKEN_MESSAGE,     TMFLAG_OPTIONAL, TMFORM_X_STRING, MAX_IDS_LEN,
                            MsgLine },

   { TOKEN_TIME,        TMFLAG_OPTIONAL, TMFORM_ULONG,    sizeof(ULONG),
                            &Seconds },

   { TOKEN_VERBOSE,     TMFLAG_OPTIONAL, TMFORM_BOOLEAN,  sizeof(USHORT),
                            &v_flag },

   { TOKEN_WAIT,        TMFLAG_OPTIONAL, TMFORM_BOOLEAN,  sizeof(BOOLEAN),
                            &wait_flag },

   { TOKEN_SELF,        TMFLAG_OPTIONAL, TMFORM_BOOLEAN,  sizeof(USHORT),
                            &self_flag },

   { TOKEN_HELP,        TMFLAG_OPTIONAL, TMFORM_BOOLEAN,  sizeof(USHORT),
                            &help_flag },

   { 0, 0, 0, 0, 0}
};

/*
 * This is the list of names we are to send the message to
 */
int NameListCount = 0;
WCHAR **NameList = NULL;
WCHAR CurrUserName[USERNAME_LENGTH];

/*
 * Local function prototypes
 */
BOOLEAN SendMessageIfTarget( PLOGONID Id, ULONG Count,
                             LPWSTR pTitle, LPWSTR pMessage );
BOOLEAN CheckMatchList( PLOGONID );
BOOLEAN MessageSend( PLOGONID pLId, LPWSTR pTitle, LPWSTR pMessage );
BOOLEAN LoadFileToNameList( PWCHAR pName );
BOOL ReadFileByLine( HANDLE, PCHAR, DWORD, PDWORD );
void Usage( BOOLEAN bError );


/*****************************************************************************
*
*   MAIN
*
*   ENTRY:
*      argc - count of the command line arguments.
*      argv - vector of strings containing the command line arguments.
*
****************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    // struct tm * pTimeDate;
    // time_t      curtime;
    SYSTEMTIME st;
    WCHAR       TimeStamp[ MAX_TIME_DATE_LEN ];
    WCHAR      *CmdLine;
    WCHAR      **argvW;
    WCHAR       szTitleFormat[50];
    DWORD       dwSize;
    PLOGONID pTerm;
    UINT       TermCount;
    ULONG      Status;
    int        i, rc, TitleLen;
    BOOLEAN MatchedOne = FALSE;
    VOID*      pBuf;
    WCHAR wszString[MAX_LOCALE_STRING + 1];

    setlocale(LC_ALL, ".OCP");

    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);
    
    SetThreadUILanguage(0);

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if (rc && (rc & PARSE_FLAG_NO_PARMS) )
       help_flag = TRUE;

    if ( help_flag || rc ) {
         if (!help_flag) {
            Usage(TRUE);
            return(FAILURE);

        } else {
            Usage(FALSE);
            return(SUCCESS);
        }
    }

        // If no remote server was specified, then check if we are running under Terminal Server
        if ((!IsTokenPresent(ptm, TOKEN_SERVER) ) && (!AreWeRunningTerminalServices()))
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }

    /*
     * if no timeout was specified, use default
     */
    if ( !IsTokenPresent(ptm, TOKEN_TIME) )
        Seconds = RESPONSE_TIMEOUT;

    /*
     * allocate a buffer for the message header
     */
    if ( (MsgText = (PWCHAR)malloc(MAX_IDS_LEN * sizeof(WCHAR))) == NULL ) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }
    MsgText[0] = 0;

    /*
     * set up message header text: sender and timestamp
     */
    GetCurrentUserName(CurrUserName, USERNAME_LENGTH);

    /*
     * Get the current Winstation Id for this process
     */
    gCurrentLogonId = GetCurrentLogonId();

    /*
     * Form message title string.
     */
    dwSize = sizeof(szTitleFormat) / sizeof(WCHAR);

    LoadString(NULL,IDS_TITLE_FORMAT,szTitleFormat,dwSize);
    
    TitleLen = (wcslen(szTitleFormat) + wcslen(CurrUserName) + 1) * sizeof(WCHAR) + ( 2 * sizeof( TimeStamp ) );

    MsgTitle = (PWCHAR)malloc(TitleLen);

    if( MsgTitle == NULL )
    {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }


    _snwprintf(MsgTitle, TitleLen, szTitleFormat, CurrUserName);

    TimeStamp[0] = 0;

    GetLocalTime( &st );

    GetDateFormat( LOCALE_USER_DEFAULT , 
                   DATE_SHORTDATE ,
                   &st ,
                   NULL ,
                   TimeStamp,
                   MAX_TIME_DATE_LEN );


    wcscat(MsgTitle , TimeStamp);

    TimeStamp[0] = 0;

    GetTimeFormat( LOCALE_USER_DEFAULT , 
                   TIME_NOSECONDS ,
                   &st ,
                   NULL ,
                   TimeStamp,
                   MAX_TIME_DATE_LEN );

    wcscat(MsgTitle , L" " );
    wcscat(MsgTitle , TimeStamp);
    
    /*
     * if message was specified on the command line, add it to MsgText string
     */
    if ( IsTokenPresent(ptm, TOKEN_MESSAGE) ) {

        pBuf = realloc(MsgText, (wcslen(MsgText) + wcslen(MsgLine) + 1) * sizeof(WCHAR));
        if (pBuf) {
            MsgText = pBuf;
        }
        else {
            ErrorPrintf(IDS_ERROR_MALLOC);
            free(MsgText);
            return(FAILURE);
        }
        wcscat(MsgText, MsgLine);

    } else {

        /*
         * Message was not on the command line.  If STDIN is connected to
         * the keyboard, then prompt the user for the message to send,
         * otherwise just read STDIN.
         */

        if ( _isatty( _fileno(stdin) ) )
            Message(IDS_MESSAGE_PROMPT);


        while ( wfgets(MsgLine, MAX_IDS_LEN, stdin) != NULL ) {
            pBuf = (PWCHAR)realloc(
                        MsgText,
                        (wcslen(MsgText) + wcslen(MsgLine) + 1) * sizeof(WCHAR) );
            
            if (pBuf) {
                MsgText = pBuf;
            }
            else {
                ErrorPrintf(IDS_ERROR_MALLOC);
                free(MsgText);
                return(FAILURE);
            }
            wcscat(MsgText, MsgLine);
        }

        /*
         * When we fall through, we either have an eof or a problem with
         * STDIN
         */
        if ( feof(stdin) ) {

            /*
             * If we get here then we hit eof on STDIN.  First check to make
             * sure that we did not get an eof on first wfgets
             */
            if ( !wcslen(MsgText) ) {
                ErrorPrintf(IDS_ERROR_EMPTY_MESSAGE);
                return(FAILURE);
            }

        } else {

            /*
             * The return from wfgets was not eof so we have an STDIN
             * problem
             */
            ErrorPrintf(IDS_ERROR_STDIN_PROCESSING);
            return(FAILURE);
        }
    }

    /*
     * Is the ids_input really a file indirection?
     */
    if ( ids_input[0] == L'@' ) {

        /*
         * Open the input file and read the names into the NameList
         */
        if ( !LoadFileToNameList(&ids_input[1]) )
            return(FAILURE);

        /*
         * Ok, let's get in touch
         */
        file_flag = TRUE;

    } else {

        _wcslwr( ids_input );
        NameList = (WCHAR **)malloc( 2 * sizeof( WCHAR * ) );
        if ( NameList == NULL ) {
            ErrorPrintf(IDS_ERROR_MALLOC);
            return(FAILURE);
        }
        NameList[0] = ids_input;
        NameList[1] = NULL;
        NameListCount = 1;
    }

    /*
     * Enumerate across all the WinStations and send the message
     * to them if there are any matches in the NameList
     */
    if ( WinStationEnumerate(hServerName, &pTerm, &TermCount) ) {

        if ( SendMessageIfTarget(pTerm, TermCount, MsgTitle, MsgText) )
            MatchedOne = TRUE;

        WinStationFreeMemory(pTerm);

    } else{

        Status = GetLastError();
        ErrorPrintf(IDS_ERROR_WINSTATION_ENUMERATE, Status);
        return(FAILURE);
    }

    /*
     *  Check for at least one match
     */
    if ( !MatchedOne ) {

        if( file_flag )
            StringErrorPrintf(IDS_ERROR_NO_FILE_MATCHING, &ids_input[1]);
        else
            StringErrorPrintf(IDS_ERROR_NO_MATCHING, ids_input);

        return(FAILURE);

    }

    return(SUCCESS);

}  /* main() */


/******************************************************************************
 *
 *  SendMessageIfTarget - Send a Message to a group of WinStations if
 *                        their the target as specified by TargetName.
 *
 *  ENTRY
 *      LId (input)
 *          Pointer to an array of LOGONIDs returned from WinStationEnumerate()
 *      Count (input)
 *          Number of elements in LOGONID array.
 *      pTitle (input)
 *          Points to message title string.
 *      pMessage (input)
 *          Points to message string.
 *
 *  EXIT
 *      TRUE if message was sent to at least one WinStation; FALSE otherwise.
 *
 *****************************************************************************/

BOOLEAN
SendMessageIfTarget( PLOGONID Id,
                     ULONG Count,
                     LPWSTR pTitle,
                     LPWSTR pMessage )
{
    ULONG i;
    BOOLEAN MatchedOne = FALSE;

    for ( i=0; i < Count ; i++ ) {
        /*
         * Look at Id->WinStationName, get its User, etc. and compare
         * against targetname(s). Accept '*' as "everything".
         */
        if( CheckMatchList( Id ) )
        {
            MatchedOne = TRUE;

            MessageSend(Id, pTitle, pMessage);
                
        }
        Id++;
    }
    return( MatchedOne );

}  /* SendMessageIfTarget() */


/******************************************************************************
 *
 *  CheckMatchList - Returns TRUE if the current WinStation is a match for
 *                   sending a message due to either its name, id, or the
 *                   name of its logged on user being in the message target(s)
 *                   list.
 *
 *  ENTRY
 *      LId (input)
 *          Pointer to a LOGONID returned from WinStationEnumerate()
 *
 *  EXIT
 *      TRUE if this is a match, FALSE otherwise.
 *
 *****************************************************************************/

BOOLEAN
CheckMatchList( PLOGONID LId )
{
    int i;

    /*
     * Wild card matches everything
     */
    if ( ids_input[0] == L'*' ) {
        return(TRUE);
    }

    /*
     * Loop through name list to see if any given name applies to
     * this WinStation
     */
    for( i=0; i<NameListCount; i++ ) {
        if (WinStationObjectMatch( hServerName , LId, NameList[i]) ) {
            return(TRUE);
        }
    }

    return(FALSE);
}


/******************************************************************************
 *
 *  MessageSend - Send a message to the target WinStation
 *
 *  ENTRY
 *      LId (input)
 *          Pointer to a LOGONID returned from WinStationEnumerate()
 *      pTitle (input)
 *          Points to message title string.
 *      pMessage (input)
 *          Points to message string.
 *
 *  EXIT
 *      TRUE message is sent, FALSE otherwise.
 *
 *****************************************************************************/

BOOLEAN
MessageSend( PLOGONID LId,
             LPWSTR pTitle,
             LPWSTR pMessage )
{
    ULONG idResponse, ReturnLength;
    WINSTATIONINFORMATION WSInfo;

    /*
     * Make sure that the WinStation is in the 'connected' state
     */
    if ( !WinStationQueryInformation( hServerName,
                                      LId->LogonId,
                                      WinStationInformation,
                                      &WSInfo,
                                      sizeof(WSInfo),
                                      &ReturnLength ) ) {
        goto BadQuery;
    }

    if ( WSInfo.ConnectState != State_Connected &&
         WSInfo.ConnectState != State_Active ) {
        goto NotConnected;
    }

    /*
     * Send message.
     */
    if ( v_flag ) {
        if( LId->WinStationName[0] )
            StringDwordMessage(IDS_MESSAGE_WS, LId->WinStationName, Seconds);
        else
            Message(IDS_MESSAGE_ID, LId->LogonId, Seconds);

    }

    if ( !WinStationSendMessage( hServerName,
                                 LId->LogonId,
                                     pTitle,
                                 (wcslen(pTitle))*sizeof(WCHAR),
                                 pMessage,
                                 (wcslen(pMessage))*sizeof(WCHAR),
                                                 MB_OK,  // MessageBox() Style
                                                 Seconds,
                                                 &idResponse,
                                                 (BOOLEAN)(!wait_flag) ) ) {

        if( LId->WinStationName[0] )
            StringDwordErrorPrintf(IDS_ERROR_MESSAGE_WS, LId->WinStationName, GetLastError() );
        else
            ErrorPrintf(IDS_ERROR_MESSAGE_ID, LId->LogonId, GetLastError() );

        PutStdErr(GetLastError(), 0);
        goto BadMessage;
    }

    /*
     * Output response result if verbose mode.
     */
    if( v_flag ) {
        switch( idResponse ) {

            case IDTIMEOUT:
                if( LId->WinStationName[0] )
                    StringMessage(IDS_MESSAGE_RESPONSE_TIMEOUT_WS,
                            LId->WinStationName);
                else
                    Message(IDS_MESSAGE_RESPONSE_TIMEOUT_ID, LId->LogonId);

                break;

            case IDASYNC:
                if( LId->WinStationName[0] )
                    StringMessage(IDS_MESSAGE_RESPONSE_ASYNC_WS,
                            LId->WinStationName);
                else
                    Message(IDS_MESSAGE_RESPONSE_ASYNC_ID, LId->LogonId);
                break;

            case IDCOUNTEXCEEDED:
                if( LId->WinStationName[0] )
                    StringMessage(IDS_MESSAGE_RESPONSE_COUNT_EXCEEDED_WS,
                            LId->WinStationName);
                else
                    Message(IDS_MESSAGE_RESPONSE_COUNT_EXCEEDED_ID,
                            LId->LogonId);
                break;

            case IDDESKTOPERROR:
                if( LId->WinStationName[0] )
                    StringMessage(IDS_MESSAGE_RESPONSE_DESKTOP_ERROR_WS,
                            LId->WinStationName);
                else
                    Message(IDS_MESSAGE_RESPONSE_DESKTOP_ERROR_ID,
                            LId->LogonId);
                break;

            case IDERROR:
                if( LId->WinStationName[0] )
                    StringMessage(IDS_MESSAGE_RESPONSE_ERROR_WS,
                            LId->WinStationName);
                else
                    Message(IDS_MESSAGE_RESPONSE_ERROR_ID,
                            LId->LogonId);
                break;

            case IDOK:
            case IDCANCEL:
                if( LId->WinStationName[0] )
                    StringMessage(IDS_MESSAGE_RESPONSE_WS,
                            LId->WinStationName);
                else
                    Message(IDS_MESSAGE_RESPONSE_ID,
                            LId->LogonId);
                break;

            default:
                if( LId->WinStationName[0] )
                    DwordStringMessage(IDS_MESSAGE_RESPONSE_WS,
                            idResponse, LId->WinStationName);
                else
                    Message(IDS_MESSAGE_RESPONSE_ID,
                            idResponse, LId->LogonId);
                break;
        }
    }
    return(TRUE);

/*-------------------------------------
 * Error cleanup and return
 */
BadMessage:
NotConnected:
BadQuery:
    return(FALSE);

}  /* MessageSend() */


/******************************************************************************
 *
 *  LoadFileToNameList
 *
 *  Load names from a file into the input name list.
 *
 *  ENTRY:
 *    pName Name of the file to load from
 *
 *  EXIT:
 *      TRUE for sucessful name load from file; FALSE if error.
 *
 *      An appropriate error message will have been displayed on error.
 *
 *****************************************************************************/

BOOLEAN
LoadFileToNameList( PWCHAR pName )
{
    HANDLE  hFile;
    INT     CurrentSize;
    VOID*   pBuf;

    /*
     * Open input file.
     */

    hFile = CreateFile(
                pName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );
    if (hFile == INVALID_HANDLE_VALUE) {
        StringErrorPrintf(IDS_ERROR_CANT_OPEN_INPUT_FILE, pName);
        PutStdErr(GetLastError(), 0);
        return(FALSE);
    }

    /*
     * Allocate a large array for the name string pointers
     */

    CurrentSize = 100;
    if ( !(NameList = (WCHAR **)malloc(CurrentSize * sizeof(WCHAR *))) ) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    NameListCount = 0;
    while( 1 ) {
        BOOL    fRet;
        CHAR    *pBuffer;
        DWORD   nBytesRead;
        WCHAR   *pwBuffer;

        /*
         * See if we need to grow the list
         */

        if( NameListCount == CurrentSize ) {

            pBuf = realloc(NameList, CurrentSize+100);

            if (!pBuf) {
                ErrorPrintf(IDS_ERROR_MALLOC);
                free(NameList);
                return(FAILURE);
            }
            NameList = (WCHAR **)pBuf;
            CurrentSize += 100;
        }

        pBuffer = (CHAR *)LocalAlloc(LPTR, USERNAME_LENGTH * sizeof(CHAR));
        if (pBuffer == NULL) {
            ErrorPrintf(IDS_ERROR_MALLOC);
            return(FAILURE);
        }

        fRet = ReadFileByLine(
                    hFile,
                    pBuffer,
                    USERNAME_LENGTH,
                    &nBytesRead
                    );
        if (fRet && (nBytesRead > 0)) {
            INT cWChar;

            cWChar = MultiByteToWideChar(
                        CP_ACP,
                        MB_PRECOMPOSED,
                        pBuffer,
                        -1,
                        NULL,
                        0
                        );

            pwBuffer = (WCHAR *)LocalAlloc(LPTR, (cWChar + 1) * sizeof(WCHAR));
            if (pwBuffer != NULL) {
                MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    pBuffer,
                    -1,
                    pwBuffer,
                    cWChar
                    );
            } else {
                ErrorPrintf(IDS_ERROR_MALLOC);
                return(FAILURE);
            }

            if (pwBuffer[wcslen(pwBuffer)-1] == L'\n') {
                pwBuffer[wcslen(pwBuffer)-1] = (WCHAR)NULL;
            }

            _wcslwr(pwBuffer);
            NameList[NameListCount++] = pwBuffer;
        } else {
            NameList[NameListCount] = NULL;
            CloseHandle(hFile);
            return(TRUE);
        }
    }

}  /* LoadFileToNameList() */

BOOL
ReadFileByLine(
    HANDLE  hFile,
    PCHAR   pBuffer,
    DWORD   cbBuffer,
    PDWORD  pcbBytesRead
    )
{
    BOOL    fRet;

    fRet = ReadFile(
                hFile,
                pBuffer,
                cbBuffer - 1,
                pcbBytesRead,
                NULL
                );
    if (fRet && (*pcbBytesRead > 0)) {
        CHAR*   pNewLine;

        pNewLine = strstr(pBuffer, "\r\n");
        if (pNewLine != NULL) {
            LONG    lOffset;

            lOffset = (LONG)(pNewLine + 2 - pBuffer) - (*pcbBytesRead);
            if (SetFilePointer(hFile, lOffset, NULL, FILE_CURRENT) ==
                0xFFFFFFFF) {
                return(FALSE);
            }

            *pNewLine = (CHAR)NULL;
        }

    }

    return(fRet);
}


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_USAGE1);
        ErrorPrintf(IDS_USAGE2);
        ErrorPrintf(IDS_USAGE3);
        ErrorPrintf(IDS_USAGE4);
        ErrorPrintf(IDS_USAGE5);
        ErrorPrintf(IDS_USAGE6);
        ErrorPrintf(IDS_USAGE7);
        ErrorPrintf(IDS_USAGE8);
        ErrorPrintf(IDS_USAGE9);
        ErrorPrintf(IDS_USAGEA);
        ErrorPrintf(IDS_USAGEB);
        ErrorPrintf(IDS_USAGEC);
        ErrorPrintf(IDS_USAGED);
        ErrorPrintf(IDS_USAGEE);
        ErrorPrintf(IDS_USAGEF);
    }
    else
    {
        Message(IDS_USAGE1);
        Message(IDS_USAGE2);
        Message(IDS_USAGE3);
        Message(IDS_USAGE4);
        Message(IDS_USAGE5);
        Message(IDS_USAGE6);
        Message(IDS_USAGE7);
        Message(IDS_USAGE8);
        Message(IDS_USAGE9);
        Message(IDS_USAGEA);
        Message(IDS_USAGEB);
        Message(IDS_USAGEC);
        Message(IDS_USAGED);
        Message(IDS_USAGEE);
        Message(IDS_USAGEF);
    }
}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\msg\msg.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/***********************************************************************
*
*  MSG.H
*     This module contains typedefs and defines required for
*     the MSG utility.
*
*
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256   // maximum length that the input parm can be
#define MAX_COMMAND_LEN 256
#define MSG_MAX_THREADS 40
#define RESPONSE_TIMEOUT 60
#define MAX_TIME_DATE_LEN 80     //  xx/xx/xxxx 12:34pm'\0'
                                 //  12345678901234567890

/*
 * Command line token definitions.
 */
#define TOKEN_INPUT                     L""
#define TOKEN_MESSAGE                   L" "
#define TOKEN_TIME                      L"/time"
#define TOKEN_VERBOSE                   L"/v"
#define TOKEN_WAIT                      L"/w"
#define TOKEN_SELF                      L"/self"
#define TOKEN_HELP                      L"/?"
#define TOKEN_SERVER                    L"/server"


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_EMPTY_MESSAGE                         102
#define IDS_ERROR_STDIN_PROCESSING                      103
#define IDS_ERROR_WINSTATION_ENUMERATE                  104
#define IDS_ERROR_NO_FILE_MATCHING                      105
#define IDS_ERROR_NO_MATCHING                           106
#define IDS_ERROR_QUERY_WS                              107
#define IDS_ERROR_QUERY_ID                              108
#define IDS_ERROR_MESSAGE_WS                            109
#define IDS_ERROR_MESSAGE_ID                            110
#define IDS_ERROR_SERVER                                111


#define IDS_MESSAGE_PROMPT                              200
#define IDS_MESSAGE_WS                                  201
#define IDS_MESSAGE_ID                                  202
#define IDS_MESSAGE_RESPONSE_TIMEOUT_WS                 203
#define IDS_MESSAGE_RESPONSE_TIMEOUT_ID                 204
#define IDS_MESSAGE_RESPONSE_ASYNC_WS                   205
#define IDS_MESSAGE_RESPONSE_ASYNC_ID                   206
#define IDS_MESSAGE_RESPONSE_COUNT_EXCEEDED_WS          207
#define IDS_MESSAGE_RESPONSE_COUNT_EXCEEDED_ID          208
#define IDS_MESSAGE_RESPONSE_DESKTOP_ERROR_WS           209
#define IDS_MESSAGE_RESPONSE_DESKTOP_ERROR_ID           210
#define IDS_MESSAGE_RESPONSE_ERROR_WS                   211
#define IDS_MESSAGE_RESPONSE_ERROR_ID                   212
#define IDS_MESSAGE_RESPONSE_WS                         213
#define IDS_MESSAGE_RESPONSE_ID                         214

#define IDS_MESSAGE_RESPONSE_UNKNOWN_WS                 216
#define IDS_MESSAGE_RESPONSE_UNKNOWN_ID                 217
#define IDS_ERROR_CANT_OPEN_INPUT_FILE                  218

#define IDS_USAGE1                                      221
#define IDS_USAGE2                                      222
#define IDS_USAGE3                                      223
#define IDS_USAGE4                                      224
#define IDS_USAGE5                                      225
#define IDS_USAGE6                                      226
#define IDS_USAGE7                                      227
#define IDS_USAGE8                                      228
#define IDS_USAGE9                                      229
#define IDS_USAGEA                                      230
#define IDS_USAGEB                                      231
#define IDS_USAGEC                                      232
#define IDS_USAGED                                      233
#define IDS_USAGEE                                      234
#define IDS_USAGEF                                      235
#define IDS_ERROR_NOT_TS								236
#define IDS_TITLE_FORMAT                                300
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\logoff\logoff.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*************************************************************************
*
*  LOGOFF.H
*     This module contains typedefs and defines for the LOGOFF
*     WinStation utility.
*
*************************************************************************/

/*
 * Token string definitions.
 */
#define TOKEN_WS                        L""
#define TOKEN_VERBOSE                   L"/v"
#define TOKEN_HELP                      L"/?"
#define TOKEN_SERVER                    L"/server"


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_WINSTATION_NOT_FOUND                  102
#define IDS_ERROR_INVALID_LOGONID                       103
#define IDS_ERROR_LOGONID_NOT_FOUND                     104
#define IDS_ERROR_LOGOFF                                105
#define IDS_ERROR_LOGOFF_CURRENT                        106
//#define IDS_ERROR_CANT_GET_CURRENT_WINSTATION           107
#define IDS_ERROR_NEED_A_SESSIONID                      107
#define IDS_ERROR_SERVER                                108

#define IDS_WINSTATION_LOGOFF                           200
#define IDS_WARNING_LOGOFF                              201
#define IDS_WARNING_LOGOFF_QUESTIONABLE                 202
#define IDS_USAGE1                                      203
#define IDS_USAGE2                                      204
#define IDS_USAGE3                                      205
#define IDS_USAGE4                                      206
#define IDS_USAGE5                                      207
#define IDS_USAGE6                                      208
#define IDS_USAGE7                                      209
#define IDS_ERROR_NOT_TS                                210
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\qappsrv\nenum.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*************************************************************************
*
*   NENUM.C
*
*   Name Enumerator for Networks
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "qappsrv.h"


/*=============================================================================
==   External Functions Defined
=============================================================================*/

int AppServerEnum( void );


/*=============================================================================
==   Functions used
=============================================================================*/

int NwEnumerate( void );
int MsEnumerate( void );



/*******************************************************************************
 *
 *  AppServerEnum
 *
 *   AppServerEnum returns an array of application servers
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

int
AppServerEnum()
{
    /*
     *  Enumerate netware network
     */
    (void) NwEnumerate();

    /*
     *  Enumerate ms network
     */
    (void) MsEnumerate();

    return( ERROR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\logoff\logoff.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*************************************************************************
*
*  LOGOFF.C
*
*     This module is the LOGOFF utility code.
*
*
*************************************************************************/

#include <stdio.h>
#include <windows.h>
//#include <ntddkbd.h>
//#include <ntddmou.h>
#include <winstaw.h>
#include <stdlib.h>
#include <utilsub.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <winnlsp.h>

#include "logoff.h"
#include "printfoa.h"


// max length of the locale string
#define MAX_LOCALE_STRING 64


WINSTATIONNAME WSName;
USHORT help_flag = FALSE;
USHORT v_flag    = FALSE;
HANDLE hServerName = SERVERNAME_CURRENT;
WCHAR  ServerName[MAX_IDS_LEN+1];

TOKMAP ptm[] =
{
#define TERM_PARM 0
   {TOKEN_WS,           TMFLAG_OPTIONAL, TMFORM_STRING,
                            WINSTATIONNAME_LENGTH, WSName},

   {TOKEN_SERVER,       TMFLAG_OPTIONAL, TMFORM_STRING,
                            MAX_IDS_LEN, ServerName},

   {TOKEN_HELP,         TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                            sizeof(USHORT), &help_flag},

   {TOKEN_VERBOSE,      TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                            sizeof(USHORT), &v_flag},

   {0, 0, 0, 0, 0}
};


/*
 * Local function prototypes.
 */
void Usage( BOOLEAN bError );
BOOL ProceedWithLogoff(HANDLE hServerName,ULONG LogonId,PWINSTATIONNAME pWSName);


/*************************************************************************
*
*  main
*     Main function and entry point of the LOGOFF
*     utility.
*
*  ENTRY:
*     argc  - count of the command line arguments.
*     argv  - vector of strings containing the command line arguments.
*
*  EXIT
*     Nothing.
*
*************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    BOOLEAN bCurrent = FALSE;
    int   rc, i;
    WCHAR *CmdLine;
    WCHAR **argvW, *endptr;
    ULONG LogonId;
    WCHAR wszString[MAX_LOCALE_STRING + 1];

    setlocale(LC_ALL, ".OCP");

    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);
    
    SetThreadUILanguage(0);

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

        // If no remote server was specified, then check if we are running under Terminal Server
        if ((!IsTokenPresent(ptm, TOKEN_SERVER) ) && (!AreWeRunningTerminalServices()))
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }

    /*
     * Validate input string for WinStation or LogonId.
     */
    if ( !IsTokenPresent(ptm, TOKEN_WS) ) {

        /*
         * No string specified; use current WinStation / LogonId.
         */
        bCurrent = TRUE;
        LogonId = GetCurrentLogonId();

        if( ServerName[0] ) {
            ErrorPrintf(IDS_ERROR_NEED_A_SESSIONID);
            return(FAILURE);
        }

    } else if ( !iswdigit(*WSName) ) {

        /*
         * Treat the string as a WinStation name.
         */
        if ( !LogonIdFromWinStationName(hServerName, WSName, &LogonId) ) {
            StringErrorPrintf(IDS_ERROR_WINSTATION_NOT_FOUND, WSName);
            return(FAILURE);
        }

    } else {

        /*
         * Treat the string as a LogonId.
         */
        LogonId = wcstoul(WSName, &endptr, 10);

        if ( *endptr || LogonId == ( ULONG )-1 )
        {
            StringErrorPrintf(IDS_ERROR_INVALID_LOGONID, WSName);
            return(FAILURE);
        }
        if ( !WinStationNameFromLogonId(hServerName, LogonId, WSName) ) {
            ErrorPrintf(IDS_ERROR_LOGONID_NOT_FOUND, LogonId);
            return(FAILURE);
        }
    }

    /*
     * Perform the logoff.
     */
    if ( bCurrent ) {

        if ( !ExitWindowsEx(EWX_LOGOFF, (DWORD)-1) ) {

            ErrorPrintf(IDS_ERROR_LOGOFF_CURRENT,
                         GetLastError());
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }

    } else{

         if (!ProceedWithLogoff(hServerName,LogonId,WSName))
            return (SUCCESS);

         if ( v_flag )
           Message(IDS_WINSTATION_LOGOFF, LogonId);

         /*
          * RESOLVED: we need to expose the session manager's "logoff winstation"
          * API and call it here for the specified LogonId.  Till then, we'll
          * do a WinStationReset (nasty, but does the job).
          *
          * - Reset and logoff are synonymous
          */

         if ( !WinStationReset(hServerName, LogonId, TRUE) ) {

            ErrorPrintf(IDS_ERROR_LOGOFF, LogonId, GetLastError());
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
       }
   }

   return(SUCCESS);

} /* main() */


/*******************************************************************************
 *
 *  Usage
 *
 *      If LogonId does not have a corresponding UserName then a warning
 *      message is displayed.
 *
 *  ENTRY:
 *      hServerName : Handle to server
 *      LogonId     : ID as shown in qwinsta
 *      pWSName     : Session Name
 *
 *  EXIT:
 *       TRUE : User wants to logoff
 *       FALSE: User does not want to proceed with logoff
 *
 *
 ******************************************************************************/
BOOL ProceedWithLogoff(HANDLE hServerName,ULONG LogonId,PWINSTATIONNAME pWSName)
{
   #ifdef UNICODE
   #define GetStdInChar getwchar
   wint_t ch;
   #else
   #define GetStdInChar getchar
   int ch;
   #endif

   WINSTATIONINFORMATION WinInfo;
   ULONG ReturnLength;
   int rc;

   // No-session Name, No-Problem
   if(lstrlen(pWSName) == 0) return (TRUE);

   memset(&WinInfo,0,sizeof(WINSTATIONINFORMATION));
   rc = WinStationQueryInformation( hServerName,
                                    LogonId,
                                    WinStationInformation,
                                    (PVOID)&WinInfo,
                                    sizeof(WINSTATIONINFORMATION),
                                    &ReturnLength);

   // Try to show message only if necessary
   if( rc && (sizeof(WINSTATIONINFORMATION) == ReturnLength) ) {
      if(lstrlen(WinInfo.UserName) == 0) {
         ErrorPrintf(IDS_WARNING_LOGOFF);
         rc = GetStdInChar();
         if(rc == L'n') return(FALSE);
      }
   }
   // Failed on call - assume nothing and prompt with message
   else{
      ErrorPrintf(IDS_WARNING_LOGOFF_QUESTIONABLE);
      rc = GetStdInChar();
      if(rc == L'n') return(FALSE);
   }
   return (TRUE);
}

/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 *  EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {

        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }
    ErrorPrintf(IDS_USAGE1);
    ErrorPrintf(IDS_USAGE2);
    ErrorPrintf(IDS_USAGE3);
    ErrorPrintf(IDS_USAGE4);
    ErrorPrintf(IDS_USAGE5);
    ErrorPrintf(IDS_USAGE6);
    ErrorPrintf(IDS_USAGE7);
}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\qappsrv\mslan.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*************************************************************************
*
*   MSLAN.C
*
*   Name Enumerator for Microsoft networks
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <lm.h>
#include "qappsrv.h"



/*=============================================================================
==   External Functions Defined
=============================================================================*/

int MsEnumerate( void );


/*=============================================================================
==   Private Functions Defined
=============================================================================*/

int _ServerEnum( PSERVER_INFO_101 *, LPDWORD );
int _LookUpAddress( LPTSTR );

/*=============================================================================
==   Functions used
=============================================================================*/

int TreeAdd( LPTSTR, LPTSTR );


/*=============================================================================
==   Global Data
=============================================================================*/

extern WCHAR Domain[];
extern USHORT fAddress;
extern WCHAR AppServer[];



/*******************************************************************************
 *
 *  MsEnumerate
 *
 *   MsEnumerate adds all the hydra application servers on a ms network
 *   to a binary tree
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

int
MsEnumerate()
{
    PSERVER_TRANSPORT_INFO_0 pTransport;
    PSERVER_INFO_101 pInfo = NULL;
    PSERVER_INFO_101 psv101= NULL;
    DWORD AvailCount;
    ULONG ActualCount;
    ULONG TotalCount;
    WCHAR Address[MAXADDRESS];
    LPTSTR pName;
    int i, j;
    int rc;    

    /*
     *  Get the names and the count
     */
    if( AppServer[0] )
    {
        rc = ( int )NetServerGetInfo( AppServer , 101 , ( LPBYTE * )&psv101 );

        if( rc )
        {
            return rc;            
        }

        if( ( psv101->sv101_type & SV_TYPE_TERMINALSERVER ) )
        {
            if( fAddress )
            {
                rc = _LookUpAddress( AppServer );
            }
            else 
            {
                rc = TreeAdd( AppServer, L"" );
            }
        } 
        
        if( psv101 != NULL )
        {
            NetApiBufferFree( psv101 );
        }

        return rc;

    }
    else if( rc = _ServerEnum( &pInfo, &AvailCount ) ) 
    {
        return( rc );
    }
    

    /*
     *  Add name to binary tree
     */
    while( AvailCount-- )
    {
        pName = pInfo[AvailCount].sv101_name;
        
        if( fAddress )
        {
            rc = _LookUpAddress( pName );
        }
        else
        {
            if( rc = TreeAdd( pName, L"" ) )
            {
                break; //return( rc );
            }
        }
    }

    if( pInfo != NULL )
    {
        NetApiBufferFree( pInfo );
    }

    return( rc );
}



/*******************************************************************************
 *
 *  _ServerEnum
 *
 *   enumerate ms network servers
 *
 * ENTRY:
 *    ppInfo (output)
 *       adderss of pointer to data buffer
 *    pAvail (output)
 *       address to return number of entries available
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/
int
_ServerEnum( PSERVER_INFO_101 * ppInfo, LPDWORD pAvail )
{
    INT     rc;
    DWORD   TotalEntries;

    rc = NetServerEnum ( 
                     NULL,                    //IN  LPTSTR      servername OPTIONAL,
                     101,                     //IN  DWORD       level,
                     (LPBYTE *)ppInfo,        //OUT LPBYTE      *bufptr,
                     (DWORD) -1,              //IN  DWORD       prefmaxlen,
                     pAvail,                  //OUT LPDWORD     entriesread,
                     &TotalEntries,           //OUT LPDWORD     totalentries,
                     SV_TYPE_TERMINALSERVER,  //IN  DWORD       servertype,
                     Domain[0] ? Domain:NULL, //IN  LPTSTR      domain OPTIONAL,
                     NULL );                  //IN OUT LPDWORD  resume_handle OPTIONAL

    return( rc );
}

/*******************************************************************************
 *
 *  _LookUpAddress
 *
 *   enumerate ms network nodes
 *
 * ENTRY:
 *      Name of server
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/
int _LookUpAddress( LPTSTR pName )
{
    PSERVER_TRANSPORT_INFO_0 pTransport;
    ULONG ActualCount;
    ULONG TotalCount;
    WCHAR Address[MAXADDRESS] = {0};    
    int i, j;
    int rc;

    rc = NetServerTransportEnum( pName,
                                 0,
                                 (LPBYTE *) &pTransport,
                                 (DWORD) -1,
                                 &ActualCount,
                                 &TotalCount,
                                 NULL );

    if( rc == ERROR_SUCCESS )
    {
        for ( i=0; i < (int)ActualCount; i++ )
        {
            if ( wcscmp(pTransport->svti0_networkaddress,L"000000000000") )
            {
                int nSize;

                wcscpy( Address, L"          [" );
                wcscat( Address, pTransport->svti0_networkaddress );
                wcscat( Address, L"]" );

                nSize = wcslen(Address);

                for ( j=11; j < nSize; j++ )
                {
                    if ( Address[j] == '0' )
                    {
                        Address[j] = ' ';
                    }
                    else
                    {
                        break;
                    }
                }
            }

            pTransport++;

            if( rc = TreeAdd( pName, _wcsupr(Address) ) )
            {
                break; //return( rc );
            }
        }
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\qappsrv\qappsrv.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/******************************************************************************
*
*  QAPPSRV.C
*
*  query appserver information
*
*
*******************************************************************************/

/*
 *  Includes
 */
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <lm.h>
#include <winstaw.h>
#include <utilsub.h>
#include <printfoa.h>
#include <winnlsp.h>

#include "qappsrv.h"


// max length of the locale string
#define MAX_LOCALE_STRING 64


/*=============================================================================
==   Global data
=============================================================================*/

WCHAR CurrentAppServer[MAXNAME];
WCHAR AppServer[MAXNAME];
WCHAR Domain[MAX_IDS_LEN+1];
USHORT help_flag   = FALSE;
BOOLEAN MatchedOne = FALSE;
USHORT fAddress = FALSE;
USHORT fNoPage = FALSE;
ULONG Rows = 23;
HANDLE hConIn;
HANDLE hConOut;

TOKMAP ptm[] = {
      {L" ",       TMFLAG_OPTIONAL, TMFORM_STRING, MAXNAME, AppServer},
      {L"/DOMAIN", TMFLAG_OPTIONAL, TMFORM_STRING, MAX_IDS_LEN, Domain},
      {L"/ADDRESS", TMFLAG_OPTIONAL, TMFORM_BOOLEAN,sizeof(USHORT), &fAddress},
      {L"/Continue",TMFLAG_OPTIONAL, TMFORM_BOOLEAN,sizeof(USHORT), &fNoPage },
      {L"/?",      TMFLAG_OPTIONAL, TMFORM_BOOLEAN,sizeof(USHORT), &help_flag},
      {0, 0, 0, 0, 0}
};


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

void DisplayServer( LPTSTR, LPTSTR );
void Usage( BOOLEAN bError );
int _getch( void );


/*=============================================================================
==   Functions used
=============================================================================*/

int AppServerEnum( void );
void TreeTraverse( PTREETRAVERSE );




/*******************************************************************************
 *
 *  main
 *
 *   main routine
 *
 * ENTRY:
 *    argc (input)
 *       number of command line arguments
 *    argv (input)
 *       pointer to arrary of command line arguments
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    CONSOLE_SCREEN_BUFFER_INFO ScreenInfo;
    PSERVER_INFO_101 pCurrentServer;
    ULONG Status;
    ULONG rc;
    WCHAR **argvW;
    int i;
    WCHAR wszString[MAX_LOCALE_STRING + 1];

    Domain[0] = UNICODE_NULL;

    setlocale(LC_ALL, ".OCP");

    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);
    
    SetThreadUILanguage(0);

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

    /*
     *  Get handle to console
     */
    hConIn = CreateFile( L"CONIN$", GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, 0, NULL );

    hConOut = CreateFile( L"CONOUT$", GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, 0, NULL );

    /*
     *  Get the number of rows on the screen
     */
    if ( GetConsoleScreenBufferInfo( hConOut, &ScreenInfo ) )
        Rows = ScreenInfo.dwSize.Y - 2;

    /*
     *  Get current server
     */
    Status = NetServerGetInfo( NULL, 101, (LPBYTE *) &pCurrentServer );
    if ( Status ) {
        ErrorPrintf(IDS_ERROR_SERVER_INFO, Status);
        PutStdErr( Status, 0 );
        return(FAILURE);
    }
    lstrcpyn( CurrentAppServer, pCurrentServer->sv101_name, MAXNAME );

    /*
     *  Get the names and the count
     */
    //if ( rc = AppServerEnum() ) {
    //    ErrorPrintf(IDS_ERROR_SERVER_ENUMERATE, rc );
    //    PutStdErr( rc, 0 );
    //    return(FAILURE);
    //}
    
    AppServerEnum();

    /*
     *  Display names
     */
    TreeTraverse( DisplayServer );

    if (!MatchedOne)
    {
        if ( AppServer[0])
        {
            Message(IDS_ERROR_TERMSERVER_NOT_FOUND);
        }
        else
        {
            Message(IDS_ERROR_NO_TERMSERVER_IN_DOMAIN);
        }
    }

    if( pCurrentServer != NULL )
    {
        NetApiBufferFree( pCurrentServer );
    }

    return(SUCCESS);
}



/*******************************************************************************
 *
 *  DisplayServer
 *
 *  This routine displays information for one server
 *
 *
 *  ENTRY:
 *     pName (input)
 *        pointer to server name
 *     pAddress (input)
 *        pointer to server address
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayServer( LPTSTR pName, LPTSTR pAddress )
{
    static ULONG RowCount = 0;

    /*
     *  If appserver name was specified only show it
     */
    if ( AppServer[0] && _wcsicmp( pName, AppServer ) )
        return;

    /*
     *  Page pause
     */
    if ( !(++RowCount % Rows) && !fNoPage ) {
        Message(IDS_PAUSE_MSG);
       _getch();
       wprintf(L"\n");
    }

    /*
     *  If first time - output title
     */
    if ( !MatchedOne ) {
        Message( fAddress ? IDS_TITLE_ADDR : IDS_TITLE );
        Message( fAddress ? IDS_TITLE_ADDR1 : IDS_TITLE1 );
        MatchedOne = TRUE;
    }

    if ( fAddress ) {
        My_wprintf( L"%-37s%-21s\n", _wcsupr(pName), pAddress );
                    
    } else {
        My_wprintf( L"%s\n", _wcsupr(pName) );
    }
}



/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_HELP_USAGE1);
        ErrorPrintf(IDS_HELP_USAGE2);
        ErrorPrintf(IDS_HELP_USAGE3);
        ErrorPrintf(IDS_HELP_USAGE4);
        ErrorPrintf(IDS_HELP_USAGE5);
        ErrorPrintf(IDS_HELP_USAGE6);
        ErrorPrintf(IDS_HELP_USAGE7);
    } else {
        Message(IDS_HELP_USAGE1);
        Message(IDS_HELP_USAGE2);
        Message(IDS_HELP_USAGE3);
        Message(IDS_HELP_USAGE4);
        Message(IDS_HELP_USAGE5);
        Message(IDS_HELP_USAGE6);
        Message(IDS_HELP_USAGE7);
    }

}



int _getch( void )
{
        INPUT_RECORD ConInpRec;
        DWORD NumRead;
        int ch = 0;                     /* single character buffer */
        DWORD oldstate = 0;

        /*
         * Switch to raw mode (no line input, no echo input)
         */
        GetConsoleMode( hConIn, &oldstate );
        SetConsoleMode( hConIn, 0L );

        for ( ; ; ) {

            /*
             * Get a console input event.
             */
            if ( !ReadConsoleInput( hConIn,
                                    &ConInpRec,
                                    1L,
                                    &NumRead )
                 || (NumRead == 0L) )
            {
                ch = EOF;
                break;
            }

            /*
             * Look for, and decipher, key events.
             */
            if ( (ConInpRec.EventType == KEY_EVENT) &&
                 ConInpRec.Event.KeyEvent.bKeyDown ) {
                /*
                 * Easy case: if uChar.AsciiChar is non-zero, just stuff it
                 * into ch and quit.
                 */
                if ( ch = (unsigned char)ConInpRec.Event.KeyEvent.uChar.AsciiChar )
                    break;
            }
        }


        /*
         * Restore previous console mode.
         */
        SetConsoleMode( hConIn, oldstate );

        return ch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\qappsrv\nwlan.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*************************************************************************
*
*   NWLAN.C
*
*   Name Enumerator for Novell Netware
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <icaipx.h>
#include <nwapi32.h>
#include "qappsrv.h"


/*=============================================================================
==   External Functions Defined
=============================================================================*/

int NwEnumerate( void );


/*=============================================================================
==  LoadLibrary/GetProcAddress stuff for NWAPI32.DLL
=============================================================================*/

/*
 *  NWAPI32.DLL stuff
 */

#define     PSZ_NWAPI32                 TEXT("NWAPI32.DLL")

#define     PSZ_NWATTACHTOFILESERVER        "NWAttachToFileServer"
#define     PSZ_NWDETACHFROMFILESERVER      "NWDetachFromFileServer"
#define     PSZ_NWREADPROPERTYVALUE         "NWReadPropertyValue"
#define     PSZ_NWSCANOBJECT                "NWScanObject"

typedef NWCCODE (NWAPI DLLEXPORT *PNWATTACHTOFILESERVER)
                    (const char NWFAR *,
                     NWLOCAL_SCOPE,
                     NWCONN_HANDLE NWFAR *);
typedef NWCCODE (NWAPI DLLEXPORT *PNWDETACHFROMFILESERVER)
                    (NWCONN_HANDLE);
typedef NWCCODE (NWAPI DLLEXPORT *PNWREADPROPERTYVALUE)
                    (NWCONN_HANDLE,
                     const char NWFAR *,
                     NWOBJ_TYPE,
                     char NWFAR *,
                     unsigned char,
                     char NWFAR *,
                     NWFLAGS NWFAR *,
                     NWFLAGS NWFAR *);
typedef NWCCODE (NWAPI DLLEXPORT *PNWSCANOBJECT)
                     (NWCONN_HANDLE,
                      const char NWFAR *,
                      NWOBJ_TYPE,
                      NWOBJ_ID NWFAR *,
                      char NWFAR *,
                      NWOBJ_TYPE NWFAR *,
                      NWFLAGS NWFAR *,
                      NWFLAGS NWFAR *,
                      NWFLAGS NWFAR *);


/*=============================================================================
==   Private Functions
=============================================================================*/

int AppServerFindFirstNW( NWCONN_HANDLE, LPTSTR, ULONG, LPTSTR, ULONG );
int AppServerFindNextNW( NWCONN_HANDLE, LPTSTR, ULONG, LPTSTR, ULONG );
int GetNetwareAddress( NWCONN_HANDLE, LPBYTE, LPBYTE  );
int w_appsrv_ff_fn( NWCONN_HANDLE, LPTSTR, ULONG, LPTSTR, ULONG );
void FormatAddress( PBYTE, PBYTE );


/*=============================================================================
==   Functions used
=============================================================================*/

int TreeAdd( LPTSTR, LPTSTR );


/*=============================================================================
==   Local Data
=============================================================================*/

static long objectID = -1;
static PNWATTACHTOFILESERVER pNWAttachToFileServer = NULL;
static PNWDETACHFROMFILESERVER pNWDetachFromFileServer = NULL;
static PNWREADPROPERTYVALUE pNWReadPropertyValue = NULL;
static PNWSCANOBJECT pNWScanObject = NULL;

/*=============================================================================
==   Global Data
=============================================================================*/

extern USHORT fAddress;


/*******************************************************************************
 *
 *  NwEnumerate
 *
 *   NwEnumerate adds all the hydra application servers on a netware network
 *   to a binary tree
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

int
NwEnumerate()
{
    NWCONN_HANDLE hConn;
    WCHAR abName[MAXNAME];
    WCHAR Address[MAXADDRESS];
    int rc;
    HINSTANCE hinst;

    /*
     *  Load NWAPI32.DLL
     */
    if ( (hinst = LoadLibrary( PSZ_NWAPI32 )) == NULL ) {
        return( ERROR_DLL_NOT_FOUND );
    }

    /*
     * Load pointers to the NWAPI32 APIs that we'll need.
     */
    if ( (((FARPROC)pNWAttachToFileServer = GetProcAddress( hinst, PSZ_NWATTACHTOFILESERVER )) == NULL) ||
         (((FARPROC)pNWDetachFromFileServer = GetProcAddress( hinst, PSZ_NWDETACHFROMFILESERVER )) == NULL) ||
         (((FARPROC)pNWReadPropertyValue = GetProcAddress( hinst, PSZ_NWREADPROPERTYVALUE )) == NULL) ||
         (((FARPROC) pNWScanObject = GetProcAddress( hinst, PSZ_NWSCANOBJECT )) == NULL) ) {

        FreeLibrary( hinst );
        return( ERROR_PROC_NOT_FOUND );
    }

    /*
     *  Attach to novell file server
     */
    if ( rc = (*pNWAttachToFileServer)( "*", 0, &hConn ) )
        goto badattach;

    /*
     *  Get first appserver
     */
    if ( rc = AppServerFindFirstNW( hConn, abName, sizeof(abName), Address, sizeof(Address) ) )
        goto badfirst;

    /*
     *  Get remaining appservers
     */
    while ( rc == ERROR_SUCCESS ) {

        /*
         *  Add appserver name to binary tree
         */
        if ( rc = TreeAdd( abName, Address ) )
            goto badadd;

        /*
         *  Get next appserver name
         */
        rc = AppServerFindNextNW( hConn, abName, sizeof(abName), Address, sizeof(Address) );
    }

    /*
     *  Detach from file server
     */
    (void) (*pNWDetachFromFileServer)( hConn );

    FreeLibrary( hinst );
    return( ERROR_SUCCESS );


/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  binary tree name add failed
     *  error getting first appserver name
     */
badadd:
badfirst:
    (void) (*pNWDetachFromFileServer)( hConn );

    /*
     *  Attach failed
     */
badattach:
    return( rc );
}



/*******************************************************************************
 *
 *  GetNetwareAddress
 *
 *
 *  ENTRY:
 *
 *  EXIT:
 *     nothing
 *
 *
 ******************************************************************************/

int
GetNetwareAddress( NWCONN_HANDLE hConn, LPBYTE pAppServer, LPBYTE pAddress  )
{
    int             rc;
    unsigned char   more;
    unsigned char   PropFlags;

    /* Get property value */
    rc = (*pNWReadPropertyValue)( hConn,
                                  pAppServer,       // IN: object name
                                  CITRIX_APPLICATION_SERVER_SWAP, // IN: objectType
                                  "NET_ADDRESS",    // IN:
                                  1,                // IN: 1st buffer
                                  pAddress,         // OUT: Buffer to put Address
                                  &more,            // OUT: 0 == no more 128 segment
                                                    //      ff == more 128 segments
                                  &PropFlags );     // OUT: optional

    return( rc );
}


/*******************************************************************************
 *
 *  AppServerFindFirstNW
 *
 *
 *  ENTRY:
 *
 *  EXIT:
 *     nothing
 *
 *
 ******************************************************************************/

int
AppServerFindFirstNW( NWCONN_HANDLE hConn,
                      LPTSTR pAppServer, ULONG NameLength,
                      LPTSTR pAddress, ULONG AddrLength )
{
    objectID = -1;
    return( w_appsrv_ff_fn( hConn, pAppServer, NameLength, pAddress, AddrLength ) );
}


/*******************************************************************************
 *
 *  AppServerFindNextNW
 *
 *
 *  ENTRY:
 *
 *  EXIT:
 *     nothing
 *
 *
 ******************************************************************************/

int
AppServerFindNextNW( NWCONN_HANDLE hConn,
                     LPTSTR pAppServer, ULONG NameLength,
                     LPTSTR pAddress, ULONG AddrLength )
{
   return( w_appsrv_ff_fn( hConn, pAppServer, NameLength, pAddress, AddrLength ) );
}



/*******************************************************************************
 *
 *  Worker routines
 *
 *
 *  ENTRY:
 *
 *  EXIT:
 *     nothing
 *
 *
 ******************************************************************************/

int
w_appsrv_ff_fn( NWCONN_HANDLE hConn,
                LPTSTR pAppServer, ULONG NameLength,
                LPTSTR pAddress, ULONG AddrLength )
{
    int           rc;
    WORD          objectType;
    unsigned char hasPropertiesFlag = 0;
    unsigned char objectFlags;
    unsigned char objectSecurity;
    BYTE abName[49];
    BYTE Address[128];
    BYTE FormatedAddress[MAXADDRESS];
    ULONG ByteCount;


    /* while there are still properties */
    while ( hasPropertiesFlag == 0 ) {
        /* scan bindery object */
        if ( rc = (*pNWScanObject)( hConn,
                                    "*",
                                    CITRIX_APPLICATION_SERVER_SWAP,
                                    &objectID,
                                    abName,
                                    &objectType,
                                    &hasPropertiesFlag,
                                    &objectFlags,
                                    &objectSecurity )) {
            break;
        }
    }

    RtlMultiByteToUnicodeN( pAppServer, NameLength, &ByteCount,
                            abName, (strlen(abName) + 1) );

    /* get netware address */
    if ( fAddress && GetNetwareAddress( hConn, abName, Address ) == ERROR_SUCCESS ) {
        FormatAddress( Address, FormatedAddress );
        RtlMultiByteToUnicodeN( pAddress, AddrLength, &ByteCount,
                                FormatedAddress, (strlen(FormatedAddress) + 1) );
    } else {
        pAddress[0] = '\0';
    }

    return( rc );
}


/*******************************************************************************
 *
 *  FormatAddress
 *
 *
 *  ENTRY:
 *
 *  EXIT:
 *     nothing
 *
 *
 ******************************************************************************/
void
FormatAddress( PBYTE pInternetAddress, PBYTE pszAddress )
{
   USHORT i;
   USHORT j;
   USHORT firstPass;
   BYTE buf2[5];

   /* squish leading 0s on network address 1st */
   firstPass = TRUE;
   pszAddress[0] = '[';
   pszAddress[1] = '\0';
   for ( i=0; i<3; i++ ) {
      j=i;
      if ( pInternetAddress[i] ) {
         sprintf( buf2, "%2X", pInternetAddress[i] );
         strcat( pszAddress, buf2 );
         firstPass = FALSE;
         break;
      }
      else {
         strcat( pszAddress, "  " );
      }
   }

   /* remaining bytes */
   for ( i=++j; i<4; i++ ) {
      if ( firstPass )
         sprintf( buf2, "%2X", pInternetAddress[i] );
      else
         sprintf( buf2, "%02X", pInternetAddress[i] );
      strcat( pszAddress, buf2 );
      firstPass = FALSE;
   }
   strcat( pszAddress, "][" );

   /* squish leading 0s on network address 2nd */
   firstPass = TRUE;
   for ( i=4; i<10; i++ ) {
      j=i;
      if ( pInternetAddress[i] ) {
         sprintf( buf2, "%2X", pInternetAddress[i] );
         strcat( pszAddress, buf2 );
         firstPass = FALSE;
         break;
      }
      else {
         strcat( pszAddress, "  " );
      }
   }

   /* remaining bytes */
   for ( i=++j; i<10; i++ ) {
      if ( firstPass )
         sprintf( buf2, "%2X", pInternetAddress[i] );
      else
         sprintf( buf2, "%02X", pInternetAddress[i] );
      strcat( pszAddress, buf2 );
      firstPass = FALSE;
   }
   strcat( pszAddress, "]" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\qappsrv\tree.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation


/*************************************************************************
*
*   TREE.C
*
*   Binary tree routines
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "qappsrv.h"



/*=============================================================================
==   Local Structures
=============================================================================*/

typedef struct _TREENODE {
   WCHAR Name[MAXNAME];
   WCHAR Address[MAXADDRESS];
   struct _TREENODE * pLeft;
   struct _TREENODE * pRight;
   struct _TREENODE * pParent;    
} TREENODE, * PTREENODE;


/*=============================================================================
==   Local data
=============================================================================*/

static PTREENODE G_pRoot = NULL;

/*=============================================================================
==   Global Data
=============================================================================*/

extern USHORT fAddress;


/*=============================================================================
==   External Functions Defined
=============================================================================*/

int  TreeAdd( LPTSTR, LPTSTR );
void TreeTraverse( PTREETRAVERSE );


/*=============================================================================
==   Private Functions Defined
=============================================================================*/

PTREENODE _Tree_GetNext(PTREENODE pCurr);
PTREENODE _Tree_GetFirst(PTREENODE pRoot);

/*******************************************************************************
 *
 *  TreeAdd
 *
 *
 *  ENTRY:
 *     pName (input)
 *        pointer to name to add
 *     pAddress (input)
 *        pointer to address to add
 *
 *  EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

int
TreeAdd( LPTSTR pName, LPTSTR pAddress )
{
    PTREENODE pCurr = G_pRoot;
    PTREENODE pNext;
    PTREENODE pNewNode;
    int cmp;

    /*
     *  Allocate tree node structure
     */
    if ( (pNewNode = malloc(sizeof(TREENODE))) == NULL ) 
        return( ERROR_NOT_ENOUGH_MEMORY );

    /*
     *  Initialize new tree node
     */
    memset( pNewNode, 0, sizeof(TREENODE) );
    lstrcpyn( pNewNode->Name, pName, MAXNAME );
    lstrcpyn( pNewNode->Address, pAddress, MAXADDRESS );

    /*
     *  If root is null, then we are done
     */
    if ( G_pRoot == NULL ) {

        G_pRoot = pNewNode;

    } else {
 
        /*
         *  walk current tree in order
         */
        for (;;) {
  
            cmp = wcscmp( pName, pCurr->Name );

            // if entry already exists, don't add
            if ( cmp == 0 && (!fAddress || !wcscmp( &pAddress[10], &pCurr->Address[10] )) ) {
                free( pNewNode );
                return( ERROR_SUCCESS );
            }

            // greater than lexicographically go right else left
            if ( cmp < 0 ) {
   
               // at end of line, then insert
               if ( (pNext = pCurr->pLeft) == NULL ) {
                   pCurr->pLeft = pNewNode;
                   pNewNode->pParent = pCurr;
                   break;
               }
   
            } else {
   
               // at end of line, then insert
               if ( (pNext = pCurr->pRight) == NULL ) {
                   pCurr->pRight = pNewNode;
                   pNewNode->pParent = pCurr;
                   break;
               }
   
            }
   
            // next
            pCurr = pNext;
        }
    }

    return( ERROR_SUCCESS );
}



/*******************************************************************************
 *
 *  TreeTraverse
 *
 *
 *  ENTRY:
 *     pFunc (input)
 *        pointer to traverse function
 *
 *  EXIT:
 *    nothing
 *
 *  History:    Date        Author     Comment
 *              2/08/01     skuzin     Changed to use non-recursive algorithm
 ******************************************************************************/
void
TreeTraverse( PTREETRAVERSE pFunc )
{
    PTREENODE pNode;

    if(G_pRoot)
    {
        pNode = _Tree_GetFirst(G_pRoot);

        while(pNode)
        {
            /*
             *  Call function with name
             */
            (*pFunc)( pNode->Name, pNode->Address ); 
        
            pNode=_Tree_GetNext(pNode);
        }
    }
}

/*******************************************************************************
 *
 *  _Tree_GetFirst()
 *
 *  Finds the leftmost node of the tree
 *
 *  ENTRY:
 *     PTREENODE pRoot
 *        pointer to the root node
 *
 *  EXIT:
 *    pointer to the leftmost node of the tree
 *
 *  History:    Date        Author     Comment
 *              2/08/01     skuzin     Created
 ******************************************************************************/
PTREENODE 
_Tree_GetFirst(
        IN PTREENODE pRoot)
{
    PTREENODE pNode = pRoot;
    while(pNode->pLeft)
    {
        pNode = pNode->pLeft;
    }
    return pNode;    
}

/*******************************************************************************
 *
 *  _Tree_GetFirst()
 *
 *  Finds the next leftmost node of the tree
 *
 *  ENTRY:
 *     PTREENODE pCurr
 *        pointer to the the previous leftmost node
 *
 *  EXIT:
 *    pointer to the next leftmost node of the tree
 *
 *  History:    Date        Author     Comment
 *              2/08/01     skuzin     Created
 ******************************************************************************/
PTREENODE 
_Tree_GetNext(
        IN PTREENODE pCurr)
{
    PTREENODE pNode = pCurr;

    if(pNode->pRight)
    {
        pNode = pNode->pRight;
        while(pNode->pLeft)
        {
            pNode = pNode->pLeft;
        }
        return pNode;
    }
    else
    {
        while(pNode->pParent && pNode->pParent->pLeft != pNode)
        {
            pNode = pNode->pParent;
        }
        return pNode->pParent;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\qappsrv\qappsrv.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/***********************************************************************
*
*  QAPPSRV.H
*     This module contains typedefs and defines required for
*     the QAPPSRV utility.
*
*
*************************************************************************/


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be

/*
 *  Maximum server name length
 */
#define MAXNAME        48
#define MAXADDRESS     50

/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_SERVER_ENUMERATE                      102
#define IDS_ERROR_SERVER_INFO                           103
#define IDS_HELP_USAGE1                                 104
#define IDS_HELP_USAGE2                                 105
#define IDS_HELP_USAGE3                                 106
#define IDS_HELP_USAGE4                                 107
#define IDS_HELP_USAGE5                                 108
#define IDS_HELP_USAGE6                                 109
#define IDS_HELP_USAGE7                                 110
#define IDS_TITLE                                       111
#define IDS_TITLE1                                      112
#define IDS_TITLE_ADDR                                  113
#define IDS_TITLE_ADDR1                                 114
#define IDS_ERROR_NOT_TS                                115
#define IDS_PAUSE_MSG                                   116
#define IDS_ERROR_TERMSERVER_NOT_FOUND                  117
#define IDS_ERROR_NO_TERMSERVER_IN_DOMAIN               118

/*
 *  Binary tree traverse function
 */
typedef void (* PTREETRAVERSE) ( LPTSTR, LPTSTR );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\query\query.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/******************************************************************************
*
*  QUERY.H
*
*   This module contains typedefs and defines required for the QUERY utility
*   menu.
*
*  
******************************************************************************/

/*
 * Usage string definitions.
 */
#define UTILITY_NAME    L"QUERY"


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_REGISTRY_FAILURE                      102
#define IDS_ERROR_NOT_TS                                103
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\qprocess\qprocess.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/******************************************************************************
*
*  QPROCESS.C
*
*  query process information
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
// #include <ntddkbd.h>
// #include <ntddmou.h>
#include <winstaw.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <locale.h>
#include <utilsub.h>
#include <process.h>
#include <string.h>
#include <malloc.h>
#include <printfoa.h>
#include <allproc.h>
#include <winnlsp.h>

#include "qprocess.h"


// max length of the locale string
#define MAX_LOCALE_STRING 64


HANDLE  hServerName = SERVERNAME_CURRENT;
WCHAR   ServerName[MAX_IDS_LEN+1];
WCHAR   match_string[MAX_IDS_LEN+2];
USHORT  help_flag   = FALSE;
ULONG   ArgLogonId  = (ULONG)(-1);
BOOLEAN MatchedOne  = FALSE;

TOKMAP ptm[] = {
      {L" ",       TMFLAG_OPTIONAL, TMFORM_STRING, MAX_IDS_LEN, match_string},
      {L"/server", TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN,ServerName},
      {L"/?",      TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT),&help_flag},
      {L"/ID",     TMFLAG_OPTIONAL, TMFORM_ULONG,  sizeof(ULONG),&ArgLogonId },
      {0, 0, 0, 0, 0}
};


// From pstat.c
#define BUFFER_SIZE 32*1024


/*
 * Local function prototypes
 */
VOID FormatAndDisplayProcessInfo( HANDLE hServer,
                                  PTS_SYS_PROCESS_INFORMATION ProcessInfo,
                                  PSID pUserSid,
                                  ULONG LogonId,
                                  ULONG CurrentLogonId);
void Usage( BOOLEAN bError );



/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    int rc;
    // WCHAR CurrWinStationName[WINSTATIONNAME_LENGTH]; -- not used.
    WCHAR CurrUserName[USERNAME_LENGTH];
    WCHAR **argvW;
    DWORD CurrentPid;
    ULONG LogonId, CurrentLogonId;
    PSID  pUserSid;
    WCHAR wszString[MAX_LOCALE_STRING + 1];

    PTS_SYS_PROCESS_INFORMATION ProcessInfo;
    PCITRIX_PROCESS_INFORMATION CitrixInfo;


    PBYTE       pBuffer;
    ULONG       ByteCount;
    NTSTATUS    status;
    ULONG       NumberOfProcesses,j;
    PTS_ALL_PROCESSES_INFO  ProcessArray = NULL;
    int   i;
    ULONG TotalOffset;
    DWORD dwError;

    setlocale(LC_ALL, ".OCP");
    
    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);
    
    SetThreadUILanguage(0);

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    match_string[0] = L'\0';
    rc = ParseCommandLine(argc-1, argvW+1, ptm, PCL_FLAG_NO_CLEAR_MEMORY);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

        // If no remote server was specified, then check if we are running under Terminal Server
        if ((!IsTokenPresent(ptm, L"/server") ) && (!AreWeRunningTerminalServices()))
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }


    /*
     * Get the current users name
     */
    GetCurrentUserName( CurrUserName, USERNAME_LENGTH );
    _wcslwr( CurrUserName );
    OEM2ANSIW(CurrUserName, (USHORT)wcslen(CurrUserName));

    /*
     * Get current processes pid
     */
    CurrentPid = GetCurrentProcessId();

    /*
     * Get current WinStation name.
     
    GetCurrentWinStationName( CurrWinStationName, WINSTATIONNAME_LENGTH );
    _wcslwr( CurrWinStationName );
    OEM2ANSIW(CurrWinStationName, (USHORT)wcslen(CurrWinStationName));
    */

    /*
     * Get current LogonId.
     */
    CurrentLogonId = GetCurrentLogonId();

    /*
     * If no "match_string" input, then default to all processes for LoginId
     * (if /ID: switch specified) or user logged into current WinStation.
     */
    if ( !(*match_string) ) {

        if( ArgLogonId != (-1) ) {
                wsprintf( match_string, L"%d", ArgLogonId );
        }
        else
            wcscpy( match_string, CurrUserName );
    }

    /*
     * Make match name lower case
     */
    _wcslwr( match_string );

    SetFileApisToOEM();

    /*
     * Enumerate all processes on the server.
     */

    //
    // Try the new interface first (NT5 server ?)
    //
    if (WinStationGetAllProcesses( hServerName,
                                   GAP_LEVEL_BASIC,
                                   &NumberOfProcesses,
                                   &ProcessArray) )
    {
        for (j=0; j<NumberOfProcesses; j++)
        {
            ProcessInfo = (PTS_SYS_PROCESS_INFORMATION )(ProcessArray[j].pTsProcessInfo);
            pUserSid = ProcessArray[j].pSid;
            LogonId = ProcessInfo->SessionId;

            FormatAndDisplayProcessInfo(hServerName,
                                        ProcessInfo,
                                        pUserSid,
                                        LogonId,
                                        CurrentLogonId);

        }

        //
        // Free ppProcessArray and all child pointers allocated by the client stub.
        //
        WinStationFreeGAPMemory(GAP_LEVEL_BASIC, ProcessArray, NumberOfProcesses);

    }
    else    // Maybe a Hydra 4 server ?
    {
        //
        //   Check the return code indicating that the interface is not available.
        //
        dwError = GetLastError();
        if (dwError != RPC_S_PROCNUM_OUT_OF_RANGE)
        {
            ErrorPrintf(IDS_ERROR_ENUMERATE_PROCESSES);
            return(FAILURE);
        }
        else
        {

            //
            // The new interface is not known
            // It must be a Hydra 4 server
            // Let's try the old interface
            //
            if ( !WinStationEnumerateProcesses( hServerName, &pBuffer) ) {
                ErrorPrintf(IDS_ERROR_ENUMERATE_PROCESSES);
                return(FAILURE);
            }

            /*
             * Loop through all processes.  Output those that match desired
             * criteria.
             */

            ProcessInfo = (PTS_SYS_PROCESS_INFORMATION)pBuffer;
            TotalOffset = 0;
            rc = 0;
            for(;;)
            {
                /*
                 * Get the CITRIX_INFORMATION which follows the Threads
                 */
                CitrixInfo = (PCITRIX_PROCESS_INFORMATION)
                             (((PUCHAR)ProcessInfo) +
                              SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION +
                              (SIZEOF_TS4_SYSTEM_THREAD_INFORMATION * (int)ProcessInfo->NumberOfThreads));


                if( CitrixInfo->MagicNumber == CITRIX_PROCESS_INFO_MAGIC ) {
                    LogonId = CitrixInfo->LogonId;
                    pUserSid = CitrixInfo->ProcessSid;

                }
                 else
                {
                    LogonId = (ULONG)(-1);
                    pUserSid = NULL;
                }

                FormatAndDisplayProcessInfo( hServerName,
                                             ProcessInfo,
                                             pUserSid,
                                             LogonId,
                                             CurrentLogonId);


                if( ProcessInfo->NextEntryOffset == 0 ) {
                        break;
                }
                TotalOffset += ProcessInfo->NextEntryOffset;
                ProcessInfo = (PTS_SYS_PROCESS_INFORMATION)&pBuffer[TotalOffset];
            }

            /*
             *  free buffer
             */
            WinStationFreeMemory( pBuffer );
        }
    }
    /*
     *  Check for at least one match
     */
    if ( !MatchedOne ) {
        StringErrorPrintf(IDS_ERROR_PROCESS_NOT_FOUND, match_string);
        return(FAILURE);
    }

    return(SUCCESS);

}  /* main() */


/******************************************************************************
 *
 * FormatAndDisplayProcessInfo
 *
 *
 *****************************************************************************/
VOID
FormatAndDisplayProcessInfo(
        HANDLE hServer,
        PTS_SYS_PROCESS_INFORMATION ProcessInfo,
        PSID pUserSid,
        ULONG LogonId,
        ULONG CurrentLogonId)
{
    WCHAR WinStationName[WINSTATIONNAME_LENGTH];
    WCHAR UserName[USERNAME_LENGTH];
    WCHAR ImageName[ MAXNAME + 2 ];
    ULONG MaxLen;

    ImageName[MAXNAME+1] = 0; // Force NULL termination

    // Convert the counted string into a buffer
    if( ProcessInfo->ImageName.Length > MAXNAME * 2)
    {
        wcsncpy(ImageName, ProcessInfo->ImageName.Buffer, MAXNAME);
    }
    else if( ProcessInfo->ImageName.Length == 0 )
    {
            ImageName[0] = 0;
    }
    else
    {
        wcsncpy(ImageName, ProcessInfo->ImageName.Buffer, ProcessInfo->ImageName.Length/2);
        ImageName[ProcessInfo->ImageName.Length/2] = 0;
    }
    

    // get remote winstation name
    if ( (LogonId == (ULONG)(-1)) ||
            !xxxGetWinStationNameFromId( hServer,
                                    LogonId,
                                    WinStationName,
                                    WINSTATIONNAME_LENGTH ) ) {
        if (GetUnknownString())
        {
            wsprintf( WinStationName, L"(%s)", GetUnknownString() );
        }
        else
        {
            wcscpy( WinStationName, L"(Unknown)" );
        }
    }

    OEM2ANSIW(WinStationName, (USHORT)wcslen(WinStationName));

    // Get the User name for the SID of the process.
    MaxLen = USERNAME_LENGTH;
    GetUserNameFromSid( pUserSid, UserName, &MaxLen);
    OEM2ANSIW(UserName, (USHORT)wcslen(UserName));

    // Call the general process object match function
    if ( ProcessObjectMatch(UlongToPtr(ProcessInfo->UniqueProcessId),
                            LogonId,
                            ((ArgLogonId == (-1)) ? FALSE : TRUE),
                            match_string,
                            WinStationName,
                            UserName,
                            ImageName ) ){

        // Match: truncate and lower case the names in preparation for output.
        TruncateString( _wcslwr(WinStationName), 12 );
        TruncateString( _wcslwr(UserName), 18 );
        TruncateString( _wcslwr(ImageName), 15);

        // If first time - output header
        if ( !MatchedOne ) {
            Message(IDS_HEADER);
            MatchedOne = TRUE;
        }

        // identify all processes belonging to current user.
        if ( (hServerName == SERVERNAME_CURRENT) && (LogonId == CurrentLogonId ) )
            wprintf( L">" );
        else
            wprintf( L" " );

        {
            #define MAX_PRINTFOA_BUFFER_SIZE 1024
            char pUserName[MAX_PRINTFOA_BUFFER_SIZE];
            char pWinStationName[MAX_PRINTFOA_BUFFER_SIZE];
            char pImageName[MAX_PRINTFOA_BUFFER_SIZE];

            WideCharToMultiByte(CP_OEMCP, 0,
                                UserName, -1,
                                pUserName, sizeof(pUserName),
                                NULL, NULL);
            WideCharToMultiByte(CP_OEMCP, 0,
                                WinStationName, -1,
                                pWinStationName, sizeof(pWinStationName),
                                NULL, NULL);
            WideCharToMultiByte(CP_OEMCP, 0,
                                ImageName, -1,
                                pImageName, sizeof(pImageName),
                                NULL, NULL);

            fprintf( stdout,
                        FORMAT,
                        pUserName,
                        pWinStationName,
                        LogonId,
//                             ProgramState,
                        ProcessInfo->UniqueProcessId,
                        pImageName );
        }
    }
}


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_HELP_USAGE1);
        ErrorPrintf(IDS_HELP_USAGE2);
        ErrorPrintf(IDS_HELP_USAGE3);
        ErrorPrintf(IDS_HELP_USAGE40);
        ErrorPrintf(IDS_HELP_USAGE4);
        ErrorPrintf(IDS_HELP_USAGE5);
        ErrorPrintf(IDS_HELP_USAGE6);
        ErrorPrintf(IDS_HELP_USAGE7);
        ErrorPrintf(IDS_HELP_USAGE8);
        ErrorPrintf(IDS_HELP_USAGE9);
    } else {
        Message(IDS_HELP_USAGE1);
        Message(IDS_HELP_USAGE2);
        Message(IDS_HELP_USAGE3);
        Message(IDS_HELP_USAGE40);
        Message(IDS_HELP_USAGE4);
        Message(IDS_HELP_USAGE5);
        Message(IDS_HELP_USAGE6);
        Message(IDS_HELP_USAGE7);
        Message(IDS_HELP_USAGE8);
        Message(IDS_HELP_USAGE9);
    }

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\query\query.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*************************************************************************
*
*  QUERY.C
*     This module is the QUERY utility code.
*
*
*************************************************************************/

#include <stdio.h>
#include <windows.h>
#include <winstaw.h>
#include <regapi.h>
#include <stdlib.h>
#include <time.h>
#include <utilsub.h>
#include <process.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <printfoa.h>
#include <winnlsp.h>

#include "query.h"


// max length of the locale string
#define MAX_LOCALE_STRING 64


/*-----------------------------------------------------------------------
-- Supported commands (now obtained from registry)
------------------------------------------------------------------------*/
PPROGRAMCALL pProgList = NULL;

/*
 * Local function prototypes.
 */
void Usage( BOOLEAN bError );


/*************************************************************************
*
*  main
*     Main function and entry point of the text-based query
*     menu utility.
*
*  ENTRY:
*       argc (input)
*           count of the command line arguments.
*       argv (input)
*           vector of strings containing the command line arguments;
*           (not used due to always being ANSI strings).
*
*  EXIT
*       (int) exit code: SUCCESS for success; FAILURE for error.
*
*************************************************************************/

int __cdecl
main( INT argc,
      CHAR **argv )
{
    PWCHAR          arg, *argvW;
    PPROGRAMCALL    pProg, pProgramCall = NULL;
    int             len, j, status = FAILURE;
    LONG            regstatus;
    WCHAR           wszString[MAX_LOCALE_STRING + 1];

    setlocale(LC_ALL, ".OCP");

    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);
    
    SetThreadUILanguage(0);

    /*
     * Obtain the supported QUERY commands from registry.
     */
    if ( (regstatus =
            RegQueryUtilityCommandList( UTILITY_REG_NAME_QUERY, &pProgList ))
            != ERROR_SUCCESS ) {

        ErrorPrintf(IDS_ERROR_REGISTRY_FAILURE, UTILITY_NAME, regstatus);
        goto exit;
    }

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        goto exit;
    }

    /*
     * Check for valid utility name and execute.
     */
    if ( argc > 1 && *(argvW[1]) ) {

        len = wcslen(arg = argvW[1]);
        for ( pProg = pProgList->pFirst; pProg != NULL; pProg = pProg->pNext ) {

            if ( (len >= pProg->CommandLen) &&
                 !_wcsnicmp( arg, pProg->Command, len ) ) {

                pProgramCall = pProg;
                break;
            }
        }

        if ( pProgramCall ) {

                if ( ExecProgram(pProgramCall, argc - 2, &argvW[2]) )
                goto exit;

        } else if ( ((arg[0] == L'-') || (arg[0] == L'/')) &&
                    (arg[1] == L'?') ) {

            /*
             * Help requested.
             */
            Usage(FALSE);
            status = SUCCESS;
            goto exit;

        } else {

            /*
             * Bad command line.
             */
            Usage(TRUE);
            goto exit;
        }

    } else {

        /*
         * Nothing on command line.
         */
        Usage(TRUE);
        goto exit;
    }

exit:
    if ( pProgList )
        RegFreeUtilityCommandList(pProgList);   // let's be tidy

    return(status);

} /* main() */


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }

    ProgramUsage(UTILITY_NAME, pProgList, bError);

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\qprocess\qprocess.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/***********************************************************************
*
*  QPROCESS.H
*     This module contains typedefs and defines required for
*     the QPROCESS utility.
*
*
*************************************************************************/

#include <utildll.h>
/*
 * Header and format string definitions.
 */
// L" USERNAME              SESSIONNAME         ID  STATE         PID  IMAGE\n"
//    12345678901234567890  1234567890123456  1234  1234567890  12345  123456789012345

//#define FORMAT \
//L"%-20s  %-16s  %4u  %-10s  %5u  %0.15s\n"
#define FORMAT \
 "%-20s  %-16s  %4u  %5u  %0.15s\n"


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256   // maximum length that the input parm can be
#define MAXNAME 18          // Max allowed for printing.


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_QUERY_INFORMATION                     102
#define IDS_ERROR_PROCESS_NOT_FOUND                     103
#define IDS_ERROR_ENUMERATE_PROCESSES                   104
#define IDS_ERROR_SERVER                                105
#define IDS_HELP_USAGE1                                 106
#define IDS_HELP_USAGE2                                 107
#define IDS_HELP_USAGE3                                 108
#define IDS_HELP_USAGE4                                 109
#define IDS_HELP_USAGE5                                 110
#define IDS_HELP_USAGE6                                 111
#define IDS_HELP_USAGE7                                 112
#define IDS_HELP_USAGE8                                 113
#define IDS_HELP_USAGE9                                 114
#define IDS_HEADER                                      116
#define IDS_ERROR_NOT_TS                                117
#define IDS_HELP_USAGE40                                118
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\quser\quser.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/***********************************************************************
*
*  QUSER.H
*     This module contains typedefs and defines required for
*     the QUSER utility.
*
*
*************************************************************************/

#include <utildll.h>
/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be

/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_WINSTATION_ENUMERATE                  102
#define IDS_ERROR_USER_NOT_FOUND                        103
#define IDS_ERROR_SERVER                                104
#define IDS_HELP_USAGE1                                 105
#define IDS_HELP_USAGE2                                 106
#define IDS_HELP_USAGE3                                 107
#define IDS_HELP_USAGE4                                 108
#define IDS_HELP_USAGE5                                 109
#define IDS_HELP_USAGE6                                 110
#define IDS_ERROR_NOT_TS                                111
#define IDS_TITLE                                       112
#define IDS_NONE                                        113
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\qwinsta\qwinsta.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/******************************************************************************
*
*  QWINSTA.C
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>

#include <stdio.h>
#include <windows.h>
#include <winstaw.h>
#include <stdlib.h>
#include <time.h>
#include <utilsub.h>
#include <process.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <winnlsp.h>

#include <winsock.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <wsnetbs.h>
#include <nb30.h>
#include <printfoa.h>

#include <allproc.h>
#include "qwinsta.h"


// max length of the locale string
#define MAX_LOCALE_STRING 64


LPCTSTR WINAPI
StrConnectState( WINSTATIONSTATECLASS ConnectState,
                 BOOL bShortString );
LPCTSTR WINAPI
StrAsyncConnectState( ASYNCCONNECTCLASS ConnectState );


HANDLE hServerName = SERVERNAME_CURRENT;
WCHAR  ServerName[MAX_IDS_LEN+1];
WCHAR  term_string[MAX_IDS_LEN+1];
USHORT a_flag    = FALSE;
USHORT c_flag    = FALSE;
USHORT f_flag    = FALSE;
USHORT m_flag    = FALSE;
USHORT help_flag = FALSE;
USHORT fSm       = FALSE;
USHORT fDebug    = FALSE;
USHORT fVm       = FALSE;
USHORT counter_flag = FALSE;

TOKMAP ptm[] = {
      {L" ",        TMFLAG_OPTIONAL, TMFORM_S_STRING,  MAX_IDS_LEN,
                        term_string},
      {L"/address", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &a_flag},
      {L"/server",  TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN, ServerName},
      {L"/connect", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &c_flag},
      {L"/flow",    TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &f_flag},
      {L"/mode",    TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &m_flag},
      {L"/sm",      TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fSm},
      {L"/debug",   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fDebug},
      {L"/vm",      TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &fVm},
      {L"/?",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT),
                          &help_flag},
      {L"/counter", TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT),
                          &counter_flag},
      {0, 0, 0, 0, 0}
};

#define MAX_PRINTFOA_BUFFER_SIZE 1024
char g_pWinStationName[MAX_PRINTFOA_BUFFER_SIZE];
char g_pConnectState[MAX_PRINTFOA_BUFFER_SIZE];
char g_pszState[MAX_PRINTFOA_BUFFER_SIZE];
char g_pDeviceName[MAX_PRINTFOA_BUFFER_SIZE];
char g_pWdDLL[MAX_PRINTFOA_BUFFER_SIZE];
char g_pClientName[MAX_PRINTFOA_BUFFER_SIZE];
char g_pClientAddress[MAX_PRINTFOA_BUFFER_SIZE];
char g_pUserName[MAX_PRINTFOA_BUFFER_SIZE];

WINSTATIONINFORMATION g_WinInfo;
WDCONFIG g_WdInfo;
WINSTATIONCONFIG g_WinConf;
PDCONFIG g_PdConf;
WINSTATIONCLIENT g_ClientConf;
PDPARAMS g_PdParams;
DEVICENAME g_DeviceName;

/*
 * Local function prototypes
 */
BOOLEAN PrintWinStationInfo( PLOGONID pWd, int WdCount );
PWCHAR GetState( WINSTATIONSTATECLASS );
void DisplayBaud( ULONG BaudRate );
void DisplayParity( ULONG Parity );
void DisplayDataBits( ULONG DataBits );
void DisplayStopBits( ULONG StopBits );
void DisplayConnect( ASYNCCONNECTCLASS ConnectFlag, USHORT header_flag );
void DisplayFlow( PFLOWCONTROLCONFIG pFlow, USHORT header_flag );
void DisplayLptPorts( BYTE LptMask, USHORT header_flag );
void DisplayComPorts( BYTE ComMask, USHORT header_flag );
void OutputHeader( void );
void Usage( BOOLEAN bError );

/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    PLOGONID pWd;
    ULONG ByteCount, Index;
    UINT WdCount;
    ULONG Status;
    int rc, i;
    WCHAR **argvW;
    BOOLEAN MatchedOne = FALSE;
    BOOLEAN PrintWinStationInfo(PLOGONID pWd, int Count);
    WCHAR   wszString[MAX_LOCALE_STRING + 1];

    TS_COUNTER TSCounters[3];

    setlocale(LC_ALL, ".OCP");

    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);

    SetThreadUILanguage(0);

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

        // If no remote server was specified, then check if we are running under Terminal Server
        if ((!IsTokenPresent(ptm, L"/server") ) && (!AreWeRunningTerminalServices()))
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }

#if 0
    //
    // Print local WINSTATION VM info
    //
    if( fVm ) {
        PrintWinStationVmInfo();
        return( SUCCESS );
    }
#endif

    /*
     *  if no winstation was specified, display all winstations
     */
    if ( !(*term_string) )
        wcscpy( term_string, L"*" );

    /*
     *  Allocate buffer for WinStation ids
     */
    WdCount = 10;
    if ( (pWd = malloc( WdCount * sizeof(LOGONID) )) == NULL ) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        goto tscounters;
    }
    ByteCount = WdCount * sizeof(LOGONID);
    Index = 0; // Start enumeration from the begining

    /*
     *  get list of active WinStations
     */
    rc = WinStationEnumerate( hServerName, &pWd, &WdCount );
    if ( rc ) {

        if ( PrintWinStationInfo(pWd, WdCount) )
            MatchedOne = TRUE;

        WinStationFreeMemory(pWd);

        } else {

            Status = GetLastError();
        ErrorPrintf(IDS_ERROR_WINSTATION_ENUMERATE, Status);
        PutStdErr( Status, 0 );
        goto tscounters;
    }

    /*
     *  Check for at least one match
     */
    if ( !MatchedOne ) {
        StringErrorPrintf(IDS_ERROR_WINSTATION_NOT_FOUND, term_string);
        goto tscounters;
    }

tscounters:
    if (counter_flag) {
        TSCounters[0].counterHead.dwCounterID = TERMSRV_TOTAL_SESSIONS;
        TSCounters[1].counterHead.dwCounterID = TERMSRV_DISC_SESSIONS;
        TSCounters[2].counterHead.dwCounterID = TERMSRV_RECON_SESSIONS;

        rc = WinStationGetTermSrvCountersValue(hServerName, 3, TSCounters);

        if (rc) {
            if (TSCounters[0].counterHead.bResult == TRUE) {
                Message(IDS_TSCOUNTER_TOTAL_SESSIONS, TSCounters[0].dwValue);
            }

            if (TSCounters[1].counterHead.bResult == TRUE) {
                Message(IDS_TSCOUNTER_DISC_SESSIONS, TSCounters[1].dwValue);
            }

            if (TSCounters[2].counterHead.bResult == TRUE) {
                Message(IDS_TSCOUNTER_RECON_SESSIONS, TSCounters[2].dwValue);
            }
        }
        else {
            ErrorPrintf(IDS_ERROR_TERMSRV_COUNTERS);
        }
    }

    return(SUCCESS);

}  /* main() */


/******************************************************************************
 *
 * PrintWinStationInfo
 *
 *  Printout the WinStation Information for the WinStations described in
 *  the PLOGONID array.
 *
 *  ENTRY:
 *      pWd (input)
 *          pointer to array of LOGONID structures.
 *      WdCount (input)
 *          number of elements in the pWd array.
 *
 *  EXIT:
 *      TRUE if at least one WinStation was output; FALSE if none.
 *
 *****************************************************************************/

BOOLEAN
PrintWinStationInfo( PLOGONID pWd,
                     int WdCount )
{
    int i, rc;
    ULONG ErrorCode;
    ULONG ReturnLength;
    PWCHAR pState;
    UINT MatchedOne = FALSE;
    static UINT HeaderFlag = FALSE;


    /*
     *  Output terminal ids
     */
    for ( i=0; i < WdCount; i++ ) {

        if ( fSm || fDebug ) {
            {
                WideCharToMultiByte(CP_OEMCP, 0,
                                    pWd[i].WinStationName, -1,
                                    g_pWinStationName, sizeof(g_pWinStationName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    GetState( pWd[i].State ), -1,
                                    g_pConnectState, sizeof(g_pConnectState),
                                    NULL, NULL);
                fprintf( stdout, "%4u %-20s  %s\n", pWd[i].LogonId, g_pWinStationName,
                         g_pConnectState );
            }
            if ( !fDebug )
                continue;
        }

        if ( !WinStationObjectMatch( hServerName , &pWd[i], term_string ) )
            continue;

        /*
         * Get all available information so we can pick out what we need as
         * well as verify the API's
         */
        memset( &g_WinInfo,    0, sizeof(WINSTATIONINFORMATION) );
        memset( &g_WdInfo,   0, sizeof(WDCONFIG) );
        memset( &g_WinConf,    0, sizeof(WINSTATIONCONFIG) );
        memset( &g_PdConf,    0, sizeof(PDCONFIG) );
        memset( &g_ClientConf, 0, sizeof(WINSTATIONCLIENT) );
        memset( &g_PdParams,  0, sizeof(PDPARAMS) );
        memset( &g_DeviceName, 0, sizeof(DEVICENAME) );

        /*
         * If this WinStation is 'down', don't open and query.
         */
        if ( pWd[i].State == State_Init || pWd[i].State == State_Down || pWd[i].LogonId == -1 ) {

            g_WinInfo.ConnectState = pWd[i].State;

        } else {

            /*
             * Query WinStation's information.
             */
            rc = WinStationQueryInformation( hServerName,
                                             pWd[i].LogonId,
                                             WinStationInformation,
                                             (PVOID)&g_WinInfo,
                                             sizeof(WINSTATIONINFORMATION),
                                             &ReturnLength);

            if( !rc ) {
                continue;
            }

            if( ReturnLength != sizeof(WINSTATIONINFORMATION) ) {
                ErrorPrintf(IDS_ERROR_WINSTATION_INFO_VERSION_MISMATCH,
                             L"WinStationInformation",
                             ReturnLength, sizeof(WINSTATIONINFORMATION));
                continue;
            }

            rc = WinStationQueryInformation( hServerName,
                                             pWd[i].LogonId,
                                             WinStationWd,
                                             (PVOID)&g_WdInfo,
                                             sizeof(WDCONFIG),
                                             &ReturnLength);
            if( !rc ) {
                continue;
            }

            if( ReturnLength != sizeof(WDCONFIG) ) {
                ErrorPrintf(IDS_ERROR_WINSTATION_INFO_VERSION_MISMATCH,
                             L"WinStationWd",
                             ReturnLength, sizeof(WDCONFIG));
                continue;
            }

            rc = WinStationQueryInformation( hServerName,
                                             pWd[i].LogonId,
                                             WinStationConfiguration,
                                             (PVOID)&g_WinConf,
                                             sizeof(WINSTATIONCONFIG),
                                             &ReturnLength);
            if( !rc ) {
                continue;
            }

            if( ReturnLength != sizeof(WINSTATIONCONFIG) ) {
                ErrorPrintf(IDS_ERROR_WINSTATION_INFO_VERSION_MISMATCH,
                             L"WinStationConfiguration",
                             ReturnLength, sizeof(WINSTATIONCONFIG));
                continue;
            }

            rc = WinStationQueryInformation( hServerName,
                                             pWd[i].LogonId,
                                             WinStationPd,
                                             (PVOID)&g_PdConf,
                                             sizeof(PDCONFIG),
                                             &ReturnLength);
            if( !rc ) {
                continue;
            }

            if( ReturnLength != sizeof(PDCONFIG) ) {
                ErrorPrintf(IDS_ERROR_WINSTATION_INFO_VERSION_MISMATCH,
                            L"WinStationPd",
                            ReturnLength, sizeof(PDCONFIG));
                continue;
            }

            rc = WinStationQueryInformation( hServerName,
                                             pWd[i].LogonId,
                                             WinStationClient,
                                             (PVOID)&g_ClientConf,
                                             sizeof(WINSTATIONCLIENT),
                                             &ReturnLength);
            if( !rc ) {
                continue;
            }

            if( ReturnLength != sizeof(WINSTATIONCLIENT) ) {
                ErrorPrintf(IDS_ERROR_WINSTATION_INFO_VERSION_MISMATCH,
                            L"WinStationClient",
                            ReturnLength, sizeof(WINSTATIONCLIENT));
                continue;
            }

            rc = WinStationQueryInformation( hServerName,
                                             pWd[i].LogonId,
                                             WinStationPdParams,
                                             (PVOID)&g_PdParams,
                                             sizeof(PDPARAMS),
                                             &ReturnLength);
            if( !rc ) {
                continue;
            }

            if( ReturnLength != sizeof(PDPARAMS) ) {
                ErrorPrintf(IDS_ERROR_WINSTATION_INFO_VERSION_MISMATCH,
                            L"WinStationPdParams",
                            ReturnLength, sizeof(PDPARAMS));
                continue;
            }
        }

        /*
         * If this is a PdAsync Protocol, get the device name to display.
         */
        if ( g_PdParams.SdClass == SdAsync )
            wcscpy( g_DeviceName, g_PdParams.Async.DeviceName );

        /*
         * Flag sucessful match.
         */
        MatchedOne = TRUE;

        /*
         * trucate and convert to lower case
         */
        TruncateString( _wcslwr(g_WinInfo.WinStationName), 16 );
        TruncateString( _wcslwr(g_WdInfo.WdName), 8 );
        TruncateString( _wcslwr(g_DeviceName), 8 );
        TruncateString( _wcslwr(g_WdInfo.WdDLL), 13 );

        /*
         * Determine WinStation state
         */
        pState = GetState( g_WinInfo.ConnectState );

        /*
         * output header
         */
        if ( !HeaderFlag ) {
            HeaderFlag = TRUE;
            OutputHeader();
        }

        /*
         * identify current terminal
         */
        if ( (hServerName == SERVERNAME_CURRENT) && (pWd[i].LogonId == GetCurrentLogonId() ) )
            wprintf( L">" );
        else
                wprintf( L" " );

        if ( m_flag ) {
            {

                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WinInfo.WinStationName, -1,
                                    g_pWinStationName, sizeof(g_pWinStationName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    pState, -1,
                                    g_pszState, sizeof(g_pszState),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_DeviceName, -1,
                                    g_pDeviceName, sizeof(g_pDeviceName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WdInfo.WdDLL, -1,
                                    g_pWdDLL, sizeof(g_pWdDLL),
                                    NULL, NULL);
                fprintf(stdout , FORMAT_M, g_pWinStationName, g_pszState,
                       g_pDeviceName, g_pWdDLL );
            }
            DisplayBaud( g_PdParams.Async.BaudRate );
            DisplayParity( g_PdParams.Async.Parity );
            DisplayDataBits( g_PdParams.Async.ByteSize );
            DisplayStopBits( g_PdParams.Async.StopBits );
            wprintf( L"\n" );
            if ( f_flag ) {
                DisplayFlow( &g_PdParams.Async.FlowControl, TRUE );
                wprintf( L"\n" );
            }
            if ( c_flag ) {
                DisplayConnect( g_PdParams.Async.Connect.Type, TRUE );
                wprintf( L"\n" );
            }
            fflush( stdout );
        } else if ( f_flag && c_flag ) {
            {
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WinInfo.WinStationName, -1,
                                    g_pWinStationName, sizeof(g_pWinStationName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_DeviceName, -1,
                                    g_pDeviceName, sizeof(g_pDeviceName),
                                    NULL, NULL);
                fprintf(stdout,FORMAT_F_C, g_pWinStationName, g_pDeviceName );
            }
            DisplayFlow( &g_PdParams.Async.FlowControl, FALSE );
            DisplayConnect( g_PdParams.Async.Connect.Type, FALSE );
            wprintf( L"\n" );
            fflush( stdout );
        } else if ( c_flag ) {
            {
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WinInfo.WinStationName, -1,
                                    g_pWinStationName, sizeof(g_pWinStationName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    pState, -1,
                                    g_pszState, sizeof(g_pszState),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_DeviceName, -1,
                                    g_pDeviceName, sizeof(g_pDeviceName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WdInfo.WdDLL, -1,
                                    g_pWdDLL, sizeof(g_pWdDLL),
                                    NULL, NULL);
                fprintf(stdout,FORMAT_C, g_pWinStationName, g_pszState,
                       g_pDeviceName, g_pWdDLL );
            }
            DisplayConnect( g_PdParams.Async.Connect.Type, FALSE );
            wprintf( L"\n" );
            fflush(stdout);
        } else if ( f_flag ) {
            {
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WinInfo.WinStationName, -1,
                                    g_pWinStationName, sizeof(g_pWinStationName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    pState, -1,
                                    g_pszState, sizeof(g_pszState),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_DeviceName, -1,
                                    g_pDeviceName, sizeof(g_pDeviceName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WdInfo.WdDLL, -1,
                                    g_pWdDLL, sizeof(g_pWdDLL),
                                    NULL, NULL);
                fprintf(stdout,FORMAT_F, g_pWinStationName, g_pszState,
                       g_pDeviceName, g_pWdDLL );
            }
            DisplayFlow( &g_PdParams.Async.FlowControl, FALSE );
            wprintf( L"\n" );
            fflush(stdout);
        } else {
            {
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WinInfo.WinStationName, -1,
                                    g_pWinStationName, sizeof(g_pWinStationName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WinInfo.UserName, -1,
                                    g_pUserName, sizeof(g_pUserName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    pState, -1,
                                    g_pszState, sizeof(g_pszState),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_DeviceName, -1,
                                    g_pDeviceName, sizeof(g_pDeviceName),
                                    NULL, NULL);
                WideCharToMultiByte(CP_OEMCP, 0,
                                    g_WdInfo.WdDLL, -1,
                                    g_pWdDLL, sizeof(g_pWdDLL),
                                    NULL, NULL);
                fprintf(stdout,FORMAT_DEFAULT, g_pWinStationName,
                       g_pUserName, pWd[i].LogonId, g_pszState,
                       g_pWdDLL, g_pDeviceName);
            }
            fflush(stdout);
        }

    } // end for(;;)

    return( MatchedOne || fSm );

}  /* PrintWinStationInfo() */


/*******************************************************************************
 *
 *  GetState
 *
 *  This routine returns a pointer to a string describing the
 *  current WinStation state.
 *
 *  ENTRY:
 *     State (input)
 *        winstation state
 *
 *  EXIT:
 *     pointer to state string
 *
 ******************************************************************************/

PWCHAR
GetState( WINSTATIONSTATECLASS State )
{
    PWCHAR pState;


    pState = (PWCHAR) StrConnectState(State,TRUE);
/*
    switch ( State ) {

        case State_Active :
            pState = L"active";
            break;

        case State_Connected :
            pState = L"conn";
            break;

        case State_ConnectQuery :
            pState = L"connQ";
            break;

        case State_Shadow :
            pState = L"shadow";
            break;

        case State_Disconnected :
            pState = L"disc";
            break;

        case State_Idle :
            pState = L"idle";
            break;

        case State_Reset :
            pState = L"reset";
            break;

        case State_Down :
            pState = L"down";
            break;

        case State_Init :
            pState = L"init";
            break;

        case State_Listen :
            pState = L"listen";
            break;

        default :
            pState = L"unknown";
            break;
    }
*/
    return( pState );
}


/*******************************************************************************
 *
 *  DisplayBaud
 *
 *  This routine displays the baud rate
 *
 *
 *  ENTRY:
 *     BaudRate (input)
 *        baud rate
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayBaud( ULONG BaudRate )
{
    if ( BaudRate > 0 )
        wprintf( L"%6lu  ", BaudRate );
    else
        wprintf( L"        " );
    fflush( stdout );

}  /* DisplayBaud() */


/*******************************************************************************
 *
 *  DisplayParity
 *
 *  This routine displays parity
 *
 *
 *  ENTRY:
 *     Parity (input)
 *        parity
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayParity( ULONG Parity )
{
    WCHAR szParity[64] = L"";

    switch ( Parity ) {
    case 0 :
    case 1 :
    case 2 :
        //
        //  How does one handle a LoadString failure??? I choose to initialize
        //  the storage to an empty string, and then ignore any failure.
        //
        LoadString(NULL, IDS_PARITY_NONE + Parity, szParity,
                   sizeof(szParity) / sizeof(WCHAR));
        wprintf( szParity );
        break;

    default :
        LoadString(NULL, IDS_PARITY_BLANK, szParity,
                   sizeof(szParity) / sizeof(WCHAR));
        wprintf( szParity );
        break;
    }
    fflush( stdout );

}  /* DisplayParity() */


/*******************************************************************************
 *
 *  DisplayDataBits
 *
 *  This routine displays number of data bits
 *
 *
 *  ENTRY:
 *     DataBits (input)
 *        data bits
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayDataBits( ULONG DataBits )
{
    WCHAR szDataBits[64] = L"";

    //
    //  How does one handle a LoadString failure??? I choose to initialize
    //  the storage to an empty string, and then ignore any failure. The
    //  wprintf below, with an extra argument, won't cause any problems
    //  if the LoadString fails.
    //
    if ( DataBits > 0 )
    {
        LoadString(NULL, IDS_DATABITS_FORMAT, szDataBits,
                   sizeof(szDataBits) / sizeof(WCHAR));
        wprintf( szDataBits , DataBits );
    }
    else
    {
        LoadString(NULL, IDS_DATABITS_BLANK, szDataBits,
                   sizeof(szDataBits) / sizeof(WCHAR));
        wprintf( szDataBits );
    }
    fflush( stdout );

}  /* DisplayDataBits() */


/*******************************************************************************
 *
 *  DisplayStopBits
 *
 *  This routine displays the number of stop bits
 *
 *
 *  ENTRY:
 *     StopBits (input)
 *        number of stop bits
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayStopBits( ULONG StopBits )
{
    WCHAR szStopBits[64] = L"";

    switch ( StopBits ) {
    case 0 :
    case 1 :
    case 2 :
        //
        //  How does one handle a LoadString failure??? I choose to initialize
        //  the storage to an empty string, and then ignore any failure.
        //
        LoadString(NULL, IDS_STOPBITS_ONE + StopBits, szStopBits,
                   sizeof(szStopBits) / sizeof(WCHAR));
        wprintf( szStopBits );
        break;

    default :
        LoadString(NULL, IDS_STOPBITS_BLANK, szStopBits,
                   sizeof(szStopBits) / sizeof(WCHAR));
        wprintf( szStopBits );
        break;
    }
    fflush( stdout );

}  /* DisplayStopBits() */


/*******************************************************************************
 *
 *  DisplayConnect
 *
 *  This routine displays the connect settings
 *
 *
 *  ENTRY:
 *     ConnectFlag (input)
 *        connect flags
 *      header_flag (input)
 *          TRUE to display sub-header; FALSE otherwise.
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayConnect( ASYNCCONNECTCLASS ConnectFlag,
                USHORT header_flag )
{
    WCHAR buffer[80] = L"";

    //
    //  How does one handle a LoadString failure??? I choose to initialize
    //  the storage to an empty string, and then ignore any failure. The
    //  wprintf below, with an extra argument, won't cause any problems
    //  if the LoadString fails.
    //
    if ( header_flag )
    {
        LoadString(NULL, IDS_CONNECT_HEADER, buffer, sizeof(buffer) / sizeof(WCHAR));
        wprintf(buffer);
    }

    buffer[0] = (WCHAR)NULL;

    LoadString(NULL, IDS_CONNECT_FORMAT, buffer, sizeof(buffer) / sizeof(WCHAR));
    wprintf( buffer, StrAsyncConnectState(ConnectFlag) );
    fflush( stdout );

}  /* DisplayConnect() */


/*******************************************************************************
 *
 *  DisplayFlow
 *
 *  This routine displays the flow control settings
 *
 *
 *  ENTRY:
 *      pFlow (input)
 *          Pointer to flow control configuration structure
 *      header_flag (input)
 *          TRUE to display sub-header; FALSE otherwise.
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayFlow( PFLOWCONTROLCONFIG pFlow,
             USHORT header_flag )
{
    WCHAR buffer[90], buf2[90], format[90];

    buffer[0] = 0;
    buf2[0] = 0;
    format[0] = 0;

    //
    //  How does one handle a LoadString failure??? I choose to initialize
    //  the storage to an empty string, and then ignore any failure. The
    //  wprintf below, with an extra argument, won't cause any problems
    //  if the LoadString fails.
    //
    if ( header_flag )
    {
        LoadString(NULL, IDS_FLOW_HEADER, buffer, sizeof(buffer) / sizeof(WCHAR));
        wprintf(buffer);
    }

    buffer[0] = (WCHAR)NULL;

    if( pFlow->fEnableDTR )
    {
        LoadString(NULL, IDS_FLOW_ENABLE_DTR, buf2, sizeof(buf2) / sizeof(WCHAR));
        wcscat(buffer, buf2);
    }

    buf2[0] = (WCHAR)NULL;

    if( pFlow->fEnableRTS )
    {
        LoadString(NULL, IDS_FLOW_ENABLE_DTR, buf2, sizeof(buf2) / sizeof(WCHAR));
        wcscat(buffer, buf2);
    }

    buf2[0] = (WCHAR)NULL;

    /*
     * Hardware and Software flow control are mutually exclusive
     */

    if( pFlow->Type == FlowControl_Hardware ) {

        if ( pFlow->HardwareReceive == ReceiveFlowControl_None )
        {
            LoadString(NULL, IDS_FLOW_RECEIVE_NONE, buf2,
                       sizeof(buf2) / sizeof(WCHAR));
        }
        else if ( pFlow->HardwareReceive == ReceiveFlowControl_RTS )
        {
            LoadString(NULL, IDS_FLOW_RECEIVE_RTS, buf2,
                       sizeof(buf2) / sizeof(WCHAR));
        }
        else if ( pFlow->HardwareReceive == ReceiveFlowControl_DTR )
        {
            LoadString(NULL, IDS_FLOW_RECEIVE_DTR, buf2,
                       sizeof(buf2) / sizeof(WCHAR));
        }

        wcscat(buffer, buf2);
        buf2[0] = (WCHAR)NULL;

        if ( pFlow->HardwareTransmit == TransmitFlowControl_None )
        {
            LoadString(NULL, IDS_FLOW_TRANSMIT_NONE, buf2,
                       sizeof(buf2) / sizeof(WCHAR));
        }
        else if ( pFlow->HardwareTransmit == TransmitFlowControl_CTS )
        {
            LoadString(NULL, IDS_FLOW_TRANSMIT_CTS, buf2,
                       sizeof(buf2) / sizeof(WCHAR));
        }
        else if ( pFlow->HardwareTransmit == TransmitFlowControl_DSR )
        {
            LoadString(NULL, IDS_FLOW_TRANSMIT_DSR, buf2,
                       sizeof(buf2) / sizeof(WCHAR));
        }

        wcscat(buffer, buf2);

    } else if ( pFlow->Type == FlowControl_Software ) {

        if ( pFlow->fEnableSoftwareTx )
        {
            LoadString(NULL, IDS_FLOW_SOFTWARE_TX, buf2,
                       sizeof(buf2) / sizeof(WCHAR));
        }

        wcscat(buffer, buf2);
        buf2[0] = (WCHAR)NULL;

        if( pFlow->fEnableSoftwareRx )
        {
            LoadString(NULL, IDS_FLOW_SOFTWARE_TX, buf2,
                       sizeof(buf2) / sizeof(WCHAR));
        }

        wcscat(buffer, buf2);
        buf2[0] = (WCHAR)NULL;

        if ( pFlow->XonChar == 0x65 && pFlow->XoffChar == 0x67 )
        {
            LoadString(NULL, IDS_FLOW_SOFTWARE_TX, buf2,
                       sizeof(buf2) / sizeof(WCHAR));
        }
        else if( pFlow->fEnableSoftwareTx || pFlow->fEnableSoftwareRx )
        {
            LoadString(NULL, IDS_FLOW_SOFTWARE_TX, format,
                       sizeof(format) / sizeof(WCHAR));
            wsprintf( buf2, format, pFlow->XonChar, pFlow->XoffChar );
            format[0] = (WCHAR)NULL;
        }

        wcscat( buffer, buf2 );
    }

    LoadString(NULL, IDS_FLOW_FORMAT, format, sizeof(format) / sizeof(WCHAR));
    wprintf( format, buffer );
    fflush( stdout );

}  /* DisplayFlow() */


/*******************************************************************************
 *
 *  DisplayLptPorts
 *
 *  This routine displays the LPT ports that exist for a winstation
 *
 *
 *  ENTRY:
 *      LptMask (input)
 *          LPT port mask
 *      header_flag (input)
 *          TRUE to display sub-header; FALSE otherwise.
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayLptPorts( BYTE LptMask,
                USHORT header_flag )
{
    WCHAR buffer[80], buf2[10], lptname[6];
    int i;

    buffer[0] = 0;
    buf2[0] = 0;
    lptname[0] = 0;

    //
    //  How does one handle a LoadString failure??? I choose to initialize
    //  the storage to an empty string, and then ignore any failure. The
    //  wprintf below, with an extra argument, won't cause any problems
    //  if the LoadString fails.
    //
    if ( header_flag )
    {
        LoadString(NULL, IDS_LPT_HEADER, buffer, sizeof(buffer) / sizeof(WCHAR));
        wprintf(buffer);
    }

    buffer[0] = (WCHAR)NULL;

    LoadString(NULL, IDS_LPT_FORMAT, buf2, sizeof(buf2) / sizeof(WCHAR));

    /*
     * Display from the 8 possible LPT ports.
     */
    for ( i=0; i < 8; i++ ) {
        if ( LptMask & (1<<i) ) {
            wsprintf( lptname, buf2, i+1 );
            wcscat( buffer, lptname );
        }
    }

    wprintf( buffer );
    fflush( stdout );

}  /* DisplayLptPorts() */


/*******************************************************************************
 *
 *  DisplayComPorts
 *
 *  This routine displays the COM ports that exist for a winstation
 *
 *
 *  ENTRY:
 *      ComMask (input)
 *          COM port mask
 *      header_flag (input)
 *          TRUE to display sub-header; FALSE otherwise.
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayComPorts( BYTE ComMask,
                 USHORT header_flag )
{
    WCHAR buffer[80], buf2[10], comname[6];
    int i;

    buffer[0] = 0;
    buf2[0] = 0;
    comname[0] = 0;

    //
    //  How does one handle a LoadString failure??? I choose to initialize
    //  the storage to an empty string, and then ignore any failure. The
    //  wprintf below, with an extra argument, won't cause any problems
    //  if the LoadString fails.
    //
    if ( header_flag )
    {
        LoadString(NULL, IDS_COM_HEADER, buffer, sizeof(buffer) / sizeof(WCHAR));
        wprintf(buffer);
    }

    buffer[0] = (WCHAR)NULL;

    LoadString(NULL, IDS_COM_FORMAT, buf2, sizeof(buf2) / sizeof(WCHAR));

    /*
     * Display from the 8 possible LPT ports.
     */
    for ( i=0; i < 8; i++ ) {
        if ( ComMask & (1<<i) ) {
            wsprintf( comname, buf2, i+1 );
            wcscat( buffer, comname );
        }
    }

    wprintf( buffer );
    fflush( stdout );

}  /* DisplayComPorts() */


/*******************************************************************************
 *
 *  OutputHeader
 *
 *  output header
 *
 *
 *  ENTRY:
 *     nothing
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
OutputHeader( void )
{
    if ( a_flag ) {

        Message(IDS_HEADER_A);

    } else if ( m_flag ) {

        Message(IDS_HEADER_M);

    } else if ( f_flag && c_flag ) {

        Message(IDS_HEADER_F_C);

    } else if ( c_flag ) {

        Message(IDS_HEADER_C);

    } else if ( f_flag ) {

        Message(IDS_HEADER_F);

    } else {

        Message(IDS_HEADER_DEFAULT);

    }
    fflush(stdout);

}  /* OutputHeader() */


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_HELP_USAGE1);
        ErrorPrintf(IDS_HELP_USAGE2);
        ErrorPrintf(IDS_HELP_USAGE3);
        ErrorPrintf(IDS_HELP_USAGE4);
        ErrorPrintf(IDS_HELP_USAGE5);
        ErrorPrintf(IDS_HELP_USAGE6);
        ErrorPrintf(IDS_HELP_USAGE7);
        ErrorPrintf(IDS_HELP_USAGE8);
        ErrorPrintf(IDS_HELP_USAGE9);
        ErrorPrintf(IDS_HELP_USAGE10);
        ErrorPrintf(IDS_HELP_USAGE11);
    } else {
        Message(IDS_HELP_USAGE1);
        Message(IDS_HELP_USAGE2);
        Message(IDS_HELP_USAGE3);
        Message(IDS_HELP_USAGE4);
        Message(IDS_HELP_USAGE5);
        Message(IDS_HELP_USAGE6);
        Message(IDS_HELP_USAGE7);
        Message(IDS_HELP_USAGE8);
        Message(IDS_HELP_USAGE9);
        Message(IDS_HELP_USAGE10);
        Message(IDS_HELP_USAGE11);
    }

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\quser\quser.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/******************************************************************************
*
*  QUSER.C
*
*  query user information
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winstaw.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include <utilsub.h>
#include <process.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <printfoa.h>
#include <winnlsp.h>

#include "quser.h"


// max length of the locale string
#define MAX_LOCALE_STRING 64


HANDLE hServerName = SERVERNAME_CURRENT;
WCHAR  ServerName[MAX_IDS_LEN+1];
WCHAR user_string[MAX_IDS_LEN+1];
USHORT help_flag   = FALSE;
ULONG CurrentLogonId = (ULONG) -1;
BOOLEAN MatchedOne = FALSE;

TOKMAP ptm[] = {
      {L" ",       TMFLAG_OPTIONAL, TMFORM_STRING, MAX_IDS_LEN, user_string},
      {L"/server", TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN, ServerName},
      {L"/?",      TMFLAG_OPTIONAL, TMFORM_BOOLEAN,sizeof(USHORT), &help_flag},
      {0, 0, 0, 0, 0}
};

/*
 * Local function prototypes.
 */
void DisplayLastInputTime( LARGE_INTEGER * pCurrentTime, LARGE_INTEGER * pTime );
void DisplayUserInfo( HANDLE hServer , PLOGONID pId, PWCHAR pMatchName );
void Usage( BOOLEAN bError );




/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    PLOGONID pLogonId;
    UINT     TermCount;
    ULONG    Status;
    ULONG    rc;
    WCHAR  **argvW;
    int      i;
    WCHAR    wszString[MAX_LOCALE_STRING + 1];

    setlocale(LC_ALL, ".OCP");

    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);
    
    SetThreadUILanguage(0);

    // Massage the command line.
    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) 
    {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    // Parse the cmd line without parsing the program name (argc-1, argv+1)
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    // Check for error from ParseCommandLine
    if ( help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) 
    {
        if ( !help_flag ) 
        {
            Usage(TRUE);
            return(FAILURE);
        } 
        else 
        {
            Usage(FALSE);
            return(SUCCESS);
        }
    }

    // If no remote server was specified, then check if we are running under Terminal Server
    if ((!IsTokenPresent(ptm, L"/server") ) && (!AreWeRunningTerminalServices()))
    {
        ErrorPrintf(IDS_ERROR_NOT_TS);
        return(FAILURE);
    }

    // Open the specified server
    if( ServerName[0] ) 
    {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) 
        {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }

    // if no user input, then default to all usernames on system
    if ( !(*user_string) )
        wcscpy( user_string, L"*" );

    // Get current LogonId
    CurrentLogonId = GetCurrentLogonId();

    // Get list of active WinStations & display user info.
    if ( WinStationEnumerate( hServerName, &pLogonId, &TermCount) ) 
    {
        for ( i=0; i< (int)TermCount; i++ )
            DisplayUserInfo( hServerName , &pLogonId[i], user_string );

        WinStationFreeMemory(pLogonId);
    }
    else 
    {
        Status = GetLastError();
        ErrorPrintf(IDS_ERROR_WINSTATION_ENUMERATE, Status);
        PutStdErr( Status, 0 );
        return(FAILURE);
    }

    // Check for at least one match
    if ( !MatchedOne ) 
    {
        StringErrorPrintf(IDS_ERROR_USER_NOT_FOUND, user_string);
        return(FAILURE);
    }

    return(SUCCESS);
}


/*******************************************************************************
 *
 *  DisplayTime
 *
 *  This routine displays time
 *
 *
 *  ENTRY:
 *     pTime (input)
 *        pointer to system time
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayTime( LARGE_INTEGER * pTime )
{
    FILETIME   LocalTime;
    SYSTEMTIME stime;
    LPTSTR     lpDateStr = NULL;
    LPTSTR     lpTimeStr = NULL;
    int        nLen;


    if ( FileTimeToLocalFileTime( (FILETIME*)pTime, &LocalTime ) &&
         FileTimeToSystemTime( &LocalTime, &stime ) ) 
    {
        // Get the date length so we can allocate enough space for it
        nLen = GetDateFormat( LOCALE_USER_DEFAULT,
                              DATE_SHORTDATE,
                              &stime,
                              NULL,
                              NULL,
                              0 );
        if (nLen == 0)
        {
            goto unknowntime;
        }

        // Allocate room for the date string
        lpDateStr = (LPTSTR) GlobalAlloc(GPTR, (nLen + 1) * sizeof(TCHAR));
        if (lpDateStr == NULL)
        {
            goto unknowntime;
        }
        
        // Get the time
        nLen = GetDateFormat( LOCALE_USER_DEFAULT,
                              DATE_SHORTDATE,
                              &stime,
                              NULL,
                              lpDateStr,
                              nLen );
        if (nLen == 0)
        {
            goto unknowntime;
        }
            
       
        // Get the time length so we can allocate enough space for it
        nLen = GetTimeFormat( LOCALE_USER_DEFAULT,
                              TIME_NOSECONDS,
                              &stime,
                              NULL,
                              NULL,
                              0 );
        if (nLen == 0)
        {
            goto unknowntime;
        }

        // Allocate room for the time string
        lpTimeStr = (LPTSTR) GlobalAlloc(GPTR, (nLen + 1) * sizeof(TCHAR));
        if (lpTimeStr == NULL)
        {
            goto unknowntime;
        }

        nLen = GetTimeFormat( LOCALE_USER_DEFAULT,
                              TIME_NOSECONDS,
                              &stime,
                              NULL,
                              lpTimeStr,
                              nLen);
        if (nLen == 0)
        {
            goto unknowntime;
        }
        
        wprintf(L"%s %s", lpDateStr, lpTimeStr); 

        GlobalFree(lpDateStr);       
        GlobalFree(lpTimeStr);

        return;

unknowntime:
        // Use a localized "unknown" string if at all possible
        wprintf(GetUnknownString() ? GetUnknownString() : L"Unknown");

        if (lpDateStr)
            GlobalFree(lpDateStr);

        if (lpTimeStr)
            GlobalFree(lpTimeStr);

        return;
    }

}  /* DisplayTime() */


/*******************************************************************************
 *
 *  DisplayLastInputTime
 *
 *  This routine displays the time of last terminal input
 *
 *
 *  ENTRY:
 *     pCurrentTime
 *        pointer to current system time
 *     pTime (input)
 *        pointer to system time of last input
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayLastInputTime( LARGE_INTEGER * pCurrentTime, LARGE_INTEGER * pTime )
{
    LARGE_INTEGER InputTime;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER DiffTime;
    ULONG d_time;
    ULONG minutes;
    ULONG hours;
    ULONG days;
    WCHAR buf[40];

    if ( (pTime->HighPart == 0 && pTime->LowPart == 0 ) ||
         (pCurrentTime->HighPart == 0 && pCurrentTime->LowPart == 0 ) ) 
    {
        goto badtime;
    }

    // Get the number of seconds since last input
    DiffTime = RtlLargeIntegerSubtract( *pCurrentTime, *pTime );
    DiffTime = RtlExtendedLargeIntegerDivide( DiffTime, 10000000, NULL );
    d_time = DiffTime.LowPart;

    // Get the number of 'days:hours:minutes' since last input
    days    = (USHORT)(d_time / 86400L); // days since last input
    d_time  = d_time % 86400L;           // seconds into partial day
    hours   = (USHORT)(d_time / 3600L);  // hours since last input
    d_time  = d_time % 3600L;            // seconds into partial hour
    minutes = (USHORT)(d_time / 60L);    // minutes since last input

    // Output
    if ( days > 0 )
       wsprintf( buf, L"%u+%02u:%02u", days, hours, minutes );
    else if ( hours > 0 )
       wsprintf( buf, L"%u:%02u", hours, minutes );
    else if ( minutes > 0 )
       wsprintf( buf, L"%u", minutes );
    else
       wsprintf( buf, L"." );

    wprintf( L"%9s  ", buf );
    return;

    // error returns
 badtime:
    if (LoadString(NULL, IDS_NONE, buf, sizeof(buf) / sizeof( WCHAR ) ) != 0)
    {
        wprintf(buf);
    }
    else
    {
        wprintf( L"    none   " );
    }

}  /* DisplayLastInputTime() */


/*******************************************************************************
 *
 *  DisplayUserInfo
 *
 *  This routine displays user information for one user
 *
 *
 *  ENTRY:
 *     hServer ( input )
 *        handle to termsrv
 *     LogonId (input)
 *        window station id
 *     pUsername (input)
 *        user name to display (or winstation name)
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

void
DisplayUserInfo( HANDLE hServer , PLOGONID pId, PWCHAR pMatchName )
{
    WINSTATIONINFORMATION Info;
    ULONG Length;
    ULONG LogonId;
    PCWSTR wsConnectState = NULL;

    LogonId = pId->LogonId;

    if( WinStationObjectMatch( hServer, pId, pMatchName ) ) 
    {
        // Query information
        if ( !WinStationQueryInformation( hServer,
                                          LogonId,
                                          WinStationInformation,
                                          &Info,
                                          sizeof(Info),
                                          &Length ) ) 
        {
            goto done;
        }

        if ( Info.UserName[0] == UNICODE_NULL )
            goto done;

        TruncateString( _wcslwr(Info.UserName), 20 );
        TruncateString( _wcslwr(Info.WinStationName), 15 );

        // If first time - output title
        if ( !MatchedOne ) 
        {
            Message(IDS_TITLE);
            MatchedOne = TRUE;
        }

        // Output current
        if ( (hServer == SERVERNAME_CURRENT) && (Info.LogonId == CurrentLogonId ) )
            wprintf( L">" );
        else
            wprintf( L" " );

        {
            #define MAX_PRINTFOA_BUFFER_SIZE 1024
            char pUserName[MAX_PRINTFOA_BUFFER_SIZE];
            char pWinStationName[MAX_PRINTFOA_BUFFER_SIZE];
            char pConnectState[MAX_PRINTFOA_BUFFER_SIZE];

            WideCharToMultiByte(CP_OEMCP, 0,
                                Info.UserName, -1,
                                pUserName, sizeof(pUserName),
                                NULL, NULL);
            WideCharToMultiByte(CP_OEMCP, 0,
                                Info.WinStationName, -1,
                                pWinStationName, sizeof(pWinStationName),
                                NULL, NULL);
            fprintf( stdout,"%-20s  %-15s  ", pUserName,
                     (Info.ConnectState == State_Disconnected) ?
                        "" : pWinStationName );
            
            wsConnectState = StrConnectState(Info.ConnectState, TRUE);
            if (wsConnectState)
            {
                WideCharToMultiByte(CP_OEMCP, 0,
                                    wsConnectState, -1,
                                    pConnectState, sizeof(pConnectState),
                                    NULL, NULL);
                fprintf( stdout,"%4u  %-6s  ", Info.LogonId, pConnectState );
            }
            else
                fprintf( stdout, "%4u  %-6s  ", Info.LogonId, "" );
        }

        DisplayLastInputTime( &Info.CurrentTime, &Info.LastInputTime );

        DisplayTime( &Info.LogonTime );

        wprintf( L"\n" );

        }
done:
    return;

}  /* DisplayUserInfo() */


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_HELP_USAGE1);
        ErrorPrintf(IDS_HELP_USAGE2);
        ErrorPrintf(IDS_HELP_USAGE3);
        ErrorPrintf(IDS_HELP_USAGE4);
        ErrorPrintf(IDS_HELP_USAGE5);
        ErrorPrintf(IDS_HELP_USAGE6);
    } else {
        Message(IDS_HELP_USAGE1);
        Message(IDS_HELP_USAGE2);
        Message(IDS_HELP_USAGE3);
        Message(IDS_HELP_USAGE4);
        Message(IDS_HELP_USAGE5);
        Message(IDS_HELP_USAGE6);
    }

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\remotepage\main.cpp ===
// TSSecurity.cpp : Defines the entry point for the DLL application.
//

#include "RemotePage.h"
#include "registry.h"
#include "resource.h"

// our globals
// {F0152790-D56E-4445-850E-4F3117DB740C}
GUID CLSID_CTSRemotePage = 
    { 0xf0152790, 0xd56e, 0x4445, { 0x85, 0xe, 0x4f, 0x31, 0x17, 0xdb, 0x74, 0xc } };

static HINSTANCE g_hinst = NULL;
static ULONG g_uSrvLock = 0;
ULONG g_uObjects = 0;

//Class factory definition
class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    
    CClassFactory();
    ~CClassFactory();

    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IClassFactory
    ///////////////////////////////
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
};

BOOL WINAPI 
DllMain(HINSTANCE hinstDLL, 
        DWORD fdwReason, 
        void* lpvReserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}

/**************************************************************************
Exported functions
***************************************************************************/

STDAPI 
DllGetClassObject(
        REFCLSID rclsid, 
        REFIID riid, 
        LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CTSRemotePage))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CTSRemotePage)
        pFactory = new CClassFactory;
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    pFactory->Release();
    return hr;
}

STDAPI 
DllCanUnloadNow()
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}

//
// Server registration
//
STDAPI 
DllRegisterServer()
{
    return RegisterServer(g_hinst);
}


STDAPI 
DllUnregisterServer()
{
    return UnregisterServer();
}

/**************************************************************************
Class CClassFactory
***************************************************************************/

CClassFactory::CClassFactory()
{
    m_cref = 1;
    g_uObjects++;
}

CClassFactory::~CClassFactory()
{
    g_uObjects--;
}

STDMETHODIMP 
CClassFactory::QueryInterface(
        REFIID riid, 
        LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) 
CClassFactory::AddRef()
{
    return ++m_cref;
}

STDMETHODIMP_(ULONG) 
CClassFactory::Release()
{
    m_cref--;
    if (!m_cref)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP 
CClassFactory::CreateInstance(
        LPUNKNOWN pUnkOuter, 
        REFIID riid, 
        LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    pObj = new CRemotePage(g_hinst);
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    ((LPUNKNOWN)pObj)->Release();
    
    return hr;
}

STDMETHODIMP 
CClassFactory::LockServer(
        BOOL fLock)
{
    if (fLock)
    {
        g_uSrvLock++;
    }
    else
    {
        if(g_uSrvLock>0)
        {
            g_uSrvLock--;
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\remotepage\registry.cpp ===
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <windows.h>
#include <objbase.h>
#include <olectl.h>

extern GUID CLSID_CTSRemotePage;

LPCWSTR g_szExtKey = L"Software\\Microsoft\\Windows\\CurrentVersion\\Controls Folder\\"
        L"System\\shellex\\PropertySheetHandlers\\Remote Sessions CPL Extension";
LPCWSTR g_szApprovedKey = L"Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved";
const WCHAR g_szExtName[] = L"Remote Sessions CPL Extension";

//*************************************************************
//
//  RegisterServer()
//
//  Purpose:    Register the component in the registry
//
//  Parameters: hModule    -   handle to this dll module
//
//
//  Return:     S_OK  if success, error code otherwise
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/26/00    a-skuzin    Created
//              10/27/00   skuzin      Added registration of the 
//                                     component as "Approved" CPL
//                                     extension  
//                                     
//
//*************************************************************
HRESULT 
RegisterServer(HMODULE hModule)
{
    // Get server location.
    WCHAR szModule[MAX_PATH+1] ;

    if(!GetModuleFileName(hModule, szModule, MAX_PATH))
    {
        return E_UNEXPECTED;
    }
    
    // Get CLSID
    LPOLESTR szCLSID = NULL ;
    HRESULT hr = StringFromCLSID(CLSID_CTSRemotePage, &szCLSID) ;
    
    if(FAILED(hr))
    {
        return hr;
    }
    
    // Build the key CLSID\\{...}
    LPWSTR szKey = new WCHAR[wcslen(L"CLSID\\")+wcslen(szCLSID)+1];

    if(!szKey)
    {
        CoTaskMemFree(szCLSID);
        return E_OUTOFMEMORY;
    }

    wcscpy(szKey, L"CLSID\\") ;
	wcscat(szKey, szCLSID) ;
    
    HKEY hKey1,hKey2;
    LONG Err, TotalErr = 0;
    
    // Create "CLSID\{...}" key
    Err = RegCreateKeyExW(HKEY_CLASSES_ROOT, szKey, 0, NULL, 0, KEY_WRITE, NULL, &hKey1, NULL);
    
    delete szKey;
    
    TotalErr |= Err;

    if(Err == ERROR_SUCCESS ) 
    {
        Err = RegSetValueExW(hKey1, NULL, 0, REG_SZ, 
            (CONST BYTE *)g_szExtName, 
            sizeof(g_szExtName));
        
        TotalErr |= Err;
        
        // Create "CLSID\{...}\InprocServer32" key
        Err = RegCreateKeyExW(hKey1, L"InprocServer32", 0, NULL, 0, KEY_WRITE, NULL, &hKey2, NULL);
        
        TotalErr |= Err;

        RegCloseKey(hKey1);

        if(Err == ERROR_SUCCESS)
        {
            Err = RegSetValueExW(hKey2, NULL, 0, REG_SZ, 
                    (CONST BYTE *)szModule, 
                    (wcslen(szModule)+1)*sizeof(WCHAR));

            TotalErr |= Err;

            Err = RegSetValueExW(hKey2, L"ThreadingModel", 0, REG_SZ, 
                    (CONST BYTE *)L"Apartment", 
                    (wcslen(L"Apartment")+1)*sizeof(WCHAR));
            
            TotalErr |= Err;

            RegCloseKey(hKey2);
        }
        
    }
    
    //Register the component as System property sheet extension
    Err = RegCreateKeyExW(HKEY_LOCAL_MACHINE, g_szExtKey, 0, NULL, 0, KEY_WRITE, NULL, &hKey1, NULL);
    
    TotalErr |= Err;

    if(Err == ERROR_SUCCESS ) 
    {
        Err = RegSetValueExW(hKey1, NULL, 0, REG_SZ, 
            (CONST BYTE *)szCLSID, 
            (wcslen(szCLSID)+1)*sizeof(WCHAR));
        
        TotalErr |= Err;

        RegCloseKey(hKey1);
    }
    
    //Make this property sheet extension "Approved"
    Err = RegCreateKeyExW(HKEY_LOCAL_MACHINE, g_szApprovedKey, 0, NULL, 0, KEY_WRITE, NULL, &hKey1, NULL);
    
    TotalErr |= Err;

    if(Err == ERROR_SUCCESS ) 
    {
        Err = RegSetValueExW(hKey1, szCLSID, 0, REG_SZ, 
            (CONST BYTE *)g_szExtName, 
            sizeof(g_szExtName));
        
        TotalErr |= Err;

        RegCloseKey(hKey1);
    }

    // Free memory.
    CoTaskMemFree(szCLSID) ;

    if( TotalErr == ERROR_SUCCESS )
    {
       return S_OK; 
    }
    else
    {
        return SELFREG_E_CLASS;
    }
}

//*************************************************************
//
//  UnregisterServer()
//
//  Purpose:    Deletes the component registration values 
//              from the registry
//
//  Parameters: NONE
//
//
//  Return:     S_OK  if success, error code otherwise
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/26/00    a-skuzin    Created
//              10/27/00   skuzin      Modifyed to reflect 
//                                     changes in RegisterServer()
//
//*************************************************************
HRESULT 
UnregisterServer()       
{
    // Get CLSID
    LPOLESTR szCLSID = NULL ;
    HRESULT hr = StringFromCLSID(CLSID_CTSRemotePage, &szCLSID) ;
    
    if(FAILED(hr))
    {
        return hr;
    }
    
    // Build the key CLSID\\{...}\\InprocServer32
    LPWSTR szKey = new WCHAR[wcslen(L"CLSID\\")+wcslen(szCLSID)+wcslen(L"\\InprocServer32")+1];

    if(!szKey)
    {
        CoTaskMemFree(szCLSID);
        return E_OUTOFMEMORY;
    }

    wcscpy(szKey, L"CLSID\\");
	wcscat(szKey, szCLSID);
    wcscat(szKey, L"\\InprocServer32");
    
    LONG Wrn, Err, TotalErr = ERROR_SUCCESS;
    
    // Delete "CLSID\{...}\InprocServer32" key
    Err = RegDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    
    TotalErr |= Err;

    //Try to delete "CLSID\{...}" key
    //It is not an error if we cannot do this.
    if(Err == ERROR_SUCCESS )
    {
        szKey[wcslen(szKey)-wcslen(L"\\InprocServer32")] = 0;
        Wrn = RegDeleteKey(HKEY_CLASSES_ROOT, szKey);
    }

    delete szKey;
    
    //Delete Property Sheet Handler registration
    TotalErr |= RegDeleteKey(HKEY_LOCAL_MACHINE, g_szExtKey);
    
    //Remove component from list of "Approved" extensions
    HKEY hKey;
    Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,g_szApprovedKey,0,KEY_WRITE,&hKey);

    TotalErr |= Err;

    if( Err == ERROR_SUCCESS )
    {
        TotalErr|= RegDeleteValue(hKey,szCLSID);

        RegCloseKey(hKey);
    }

    // Free memory.
    CoTaskMemFree(szCLSID);

    if( TotalErr == ERROR_SUCCESS )
    {
        if(Wrn == ERROR_SUCCESS)
        {
            return S_OK; 
        }
        else
        {
            //we could not delete "CLSID\{...}" key
            //probably it has subkeys created by a user.
            return S_FALSE;
        }
    }
    else
    {
        return SELFREG_E_CLASS;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\qwinsta\qwinsta.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/***********************************************************************
*
*  QWINSTA.H
*     This module contains typedefs and defines required for
*     the QWINSTA utility.
*
*
*************************************************************************/

/*
 * Header and format string definitions.
 */

//L" SESSIONNAME       CLIENT NAME           TRANSPORT  ADDRESS\n"
// 1234567890123456  12345678901234567890  1234567    1234567890123...

#define FORMAT_A \
 "%-16s  %-20s  %-7s    %-24s  "

//L" SESSIONNAME       STATE   DEVICE    TYPE             BAUD  PARITY  DATA  STOP\n"
// 1234567890123456  123456  12345678  1234567890123  123456  1234       1     1

#define FORMAT_M \
 "%-16s  %-6s  %-8s  %-13s  "

//L" SESSIONNAME       DEVICE    FLOW CONTROL               CONNECT\n"
// 1234567890123456  12345678  1234567890123456789012345  12345678901234567890

#define FORMAT_F_C \
 "%-16s  %-8s  "

//L" SESSIONNAME       STATE   DEVICE    TYPE           CONNECT\n"
// 1234567890123456  123456  12345678  1234567890123  CTS DSR RING DCD CHAR BRK AUTO

#define FORMAT_C \
 "%-16s  %-6s  %-8s  %-13s  "

//L" SESSIONNAME       STATE   DEVICE    TYPE           FLOW CONTROL\n"
// 1234567890123456  123456  12345678  1234567890123  XON DUP RTS RTSH DTR DTRH CTSH DSRH DCDH DSRS

#define FORMAT_F \
 "%-16s  %-6s  %-8s  %-13s  "

//L" SESSIONNAME       USERNAME                ID  STATE   TYPE        DEVICE \n"
// 1234567890123456  12345678901234567890  1234  123456  1234567890  12345678

#define FORMAT_DEFAULT \
 "%-16s  %-20s  %5d  %-6s  %-10s  %-8s\n"


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_WINSTATION_ENUMERATE                  102
#define IDS_ERROR_WINSTATION_NOT_FOUND                  103
#define IDS_ERROR_WINSTATION_OPEN                       104
#define IDS_ERROR_WINSTATION_GET_INFORMATION            105
#define IDS_ERROR_WINSTATION_INFO_VERSION_MISMATCH      106
#define IDS_ERROR_SERVER                                107
#define IDS_ERROR_INFORMATION                           108
#define IDS_VMINFO1	                                    109
#define IDS_VMINFO2	                                    110
#define IDS_VMINFO3	                                    111
#define IDS_VMINFO4	                                    112
#define IDS_VMINFO5	                                    113
#define IDS_HELP_USAGE1                                 114
#define IDS_HELP_USAGE2                                 115
#define IDS_HELP_USAGE3                                 116
#define IDS_HELP_USAGE4                                 117
#define IDS_HELP_USAGE5                                 118
#define IDS_HELP_USAGE6                                 119
#define IDS_HELP_USAGE7                                 120
#define IDS_HELP_USAGE8                                 121
#define IDS_HELP_USAGE9                                 122
#define IDS_HELP_USAGE10                                123
#define IDS_HEADER_A                                    124
#define IDS_HEADER_M                                    125
#define IDS_HEADER_F_C                                  126
#define IDS_HEADER_C                                    127
#define IDS_HEADER_F                                    128
#define IDS_HEADER_DEFAULT                              129
#define IDS_ERROR_NOT_TS                                130
#define IDS_ERROR_TERMSRV_COUNTERS                      131
#define IDS_TSCOUNTER_TOTAL_SESSIONS                    132
#define IDS_TSCOUNTER_DISC_SESSIONS                     133
#define IDS_TSCOUNTER_RECON_SESSIONS                    134
#define IDS_HELP_USAGE11                                135
#define IDS_PARITY_NONE                                 136
#define IDS_PARITY_ODD                                  137
#define IDS_PARITY_EVEN                                 138
#define IDS_PARITY_BLANK                                139
#define IDS_DATABITS_FORMAT                             140
#define IDS_DATABITS_BLANK                              141
#define IDS_STOPBITS_ONE                                142
#define IDS_STOPBITS_ONEANDHALF                         143
#define IDS_STOPBITS_TWO                                144
#define IDS_STOPBITS_BLANK                              145
#define IDS_CONNECT_HEADER                              146
#define IDS_CONNECT_FORMAT                              147
#define IDS_FLOW_HEADER                                 148
#define IDS_FLOW_FORMAT                                 149
#define IDS_FLOW_ENABLE_DTR                             150
#define IDS_FLOW_ENABLE_RTS                             151
#define IDS_FLOW_RECEIVE_NONE                           152
#define IDS_FLOW_RECEIVE_RTS                            153
#define IDS_FLOW_RECEIVE_DTR                            154
#define IDS_FLOW_TRANSMIT_NONE                          155
#define IDS_FLOW_TRANSMIT_CTS                           156
#define IDS_FLOW_TRANSMIT_DSR                           157
#define IDS_FLOW_SOFTWARE_TX                            158
#define IDS_FLOW_SOFTWARE_RX                            159
#define IDS_FLOW_SOFTWARE_XPC                           160
#define IDS_FLOW_SOFTWARE_XON_XOFF                      161
#define IDS_LPT_HEADER                                  162
#define IDS_LPT_FORMAT                                  163
#define IDS_COM_HEADER                                  164
#define IDS_COM_FORMAT                                  165
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\register\register.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/***********************************************************************
*
*   REGISTER.H
*
*   This module contains typedefs and defines required for
*   the REGISTER utility.
*
*
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_OPEN                                  101
#define IDS_ERROR_SIZE                                  102
#define IDS_ERROR_CREATE                                103
#define IDS_ERROR_MAP                                   104
#define IDS_ERROR_SIGNATURE                             105
#define IDS_ERROR_INVALID_PARAMETERS                    106
#define IDS_ERROR_NOT_ADMIN				107
#define IDS_ERROR_NOT_TS                                108

#define IDS_REGISTER_USER_GLOBAL                        200
#define IDS_REGISTER_SYSTEM_GLOBAL                      201
#define IDS_REGISTER_GUI_OK                             202
#define IDS_REGISTER_GUI_NOT_OK                         203

#define IDS_USAGE1                                      210
#define IDS_USAGE2                                      211
#define IDS_USAGE3                                      212
#define IDS_USAGE4                                      213
#define IDS_USAGE5                                      214
#define IDS_USAGE6                                      215
#define IDS_USAGE7                                      216
#define IDS_X86_ONLY                                    217
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\register\register.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// Remove redundent check sums. Use the imagehelp one and delete mikes.

/*****************************************************************************
*
*   REGISTER.C for Windows NT
*
*   Description:
*
*   Register USER/SYSTEM global
*
*
****************************************************************************/

/* include files */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <winsta.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <utilsub.h>
#include <utildll.h>
#include <syslib.h>
#include <winnlsp.h>

#include "register.h"
#include "printfoa.h"


// max length of the locale string
#define MAX_LOCALE_STRING 64


/*
 *  Local variables
 */
WCHAR  fileW[MAX_PATH + 1];

USHORT system_flag = FALSE;
USHORT user_flag   = FALSE;
USHORT help_flag   = FALSE;
USHORT v_flag      = FALSE;
USHORT d_flag      = FALSE;


/*
 *  Command line parsing strucutre
 */
TOKMAP ptm[] =
{
   {L" ",          TMFLAG_REQUIRED, TMFORM_STRING,  MAX_PATH,   fileW},
   {L"/SYSTEM",    TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &system_flag},
   {L"/USER",      TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &user_flag},
   {L"/?",         TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
   {L"/v",         TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &v_flag},
   {L"/d",         TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &d_flag},
   {0, 0, 0, 0, 0}
};


/*
 *  Local function prototypes
 */
USHORT ChkSum( ULONG PartialSum, PUSHORT Source, ULONG Length );
VOID   Usage(BOOL);


BOOLEAN Is_X86_OS()
{
    SYSTEM_INFO SystemInfo;
    BOOLEAN bReturn = FALSE;

    ZeroMemory(&SystemInfo, sizeof(SystemInfo));

    GetSystemInfo(&SystemInfo);

    if(SystemInfo.wProcessorArchitecture ==  PROCESSOR_ARCHITECTURE_INTEL )
    {
        bReturn  = TRUE;
    }

    return bReturn;
}

/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

INT __cdecl
main( int argc, char *argv[] )
{
    INT     i;
    DWORD   rc;
    CHAR   *pFileView;
    HANDLE  FileHandle;
    ULONG   FileLength;
    HANDLE  Handle;
    OFSTRUCT OpenBuff;
    PIMAGE_NT_HEADERS pImageNtHeader;
    WCHAR  *CmdLine;
    WCHAR **argvW;
    ULONG   BytesOut;
    BOOL    readOnly = TRUE;
    WCHAR   wszString[MAX_LOCALE_STRING + 1];

    setlocale(LC_ALL, ".OCP");

    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);

    SetThreadUILanguage(0);

    /*
     *  Massage the command line.
     */

    if ( !Is_X86_OS() )
    {
        ErrorPrintf( IDS_X86_ONLY );
        return(FAILURE);
    }

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if (rc && (rc & PARSE_FLAG_NO_PARMS) )
       help_flag = TRUE;

    if ( help_flag || rc ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return rc;
        } else {

            Usage(FALSE);
            return ERROR_SUCCESS;
        }
    }
    else if ( system_flag && user_flag ) {

        Usage(TRUE);
        return ERROR_INVALID_PARAMETER;
    }

    if (!TestUserForAdmin(FALSE)) {
       ErrorPrintf(IDS_ERROR_NOT_ADMIN);
       return 1;
    }

    readOnly = !(system_flag || user_flag );

    /*
     *  Open file
     */

    FileHandle = CreateFile(
                    fileW,
                    readOnly ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );
    if (FileHandle == INVALID_HANDLE_VALUE) {
        ErrorPrintf(IDS_ERROR_OPEN, (rc = GetLastError()));
        PutStdErr(rc, 0);
        goto done;
    }

    /*
     *  Create mapping
     */
    if ( (Handle = CreateFileMapping( FileHandle, NULL,
          readOnly ? PAGE_READONLY : PAGE_READWRITE, 0, 0, NULL )) == NULL ) {

        ErrorPrintf(IDS_ERROR_CREATE, (rc=GetLastError()));
        PutStdErr( rc, 0 );
        goto closefile;
    }

    /*
     *  Get file size
     */
    if ( (FileLength = GetFileSize( FileHandle, NULL )) == 0xffffffff ) {

        ErrorPrintf(IDS_ERROR_SIZE, (rc=GetLastError()));
        PutStdErr( rc, 0 );
        goto closefile;
    }

    /*
     *  Map file view into our address space
     */
    if ( (pFileView = MapViewOfFile( Handle,
          readOnly ? FILE_MAP_READ : FILE_MAP_WRITE, 0, 0, 0 )) == NULL ) {

        ErrorPrintf(IDS_ERROR_MAP, (rc=GetLastError()));
        PutStdErr( rc, 0 );
        goto closefile;
    }

    /*
     *  Find and validate NT image header
     */
    if ( ((pImageNtHeader = RtlImageNtHeader( pFileView )) == NULL) ||
         (pImageNtHeader->Signature != IMAGE_NT_SIGNATURE) ) {

        ErrorPrintf(IDS_ERROR_SIGNATURE);
        rc = ERROR_BAD_FORMAT;
        goto closefile;
    }

    /*
     *  Process query
     */
    if ( !system_flag && !user_flag ) {

        /*
         *  Check for System Global Flag
         */
        if ( (pImageNtHeader->OptionalHeader.LoaderFlags & IMAGE_LOADER_FLAGS_SYSTEM_GLOBAL) )
            StringMessage(IDS_REGISTER_SYSTEM_GLOBAL, fileW);
        else
            StringMessage(IDS_REGISTER_USER_GLOBAL, fileW);
    }
    else {

        /*
         *  Set SYSTEM/USER bit
         */
        if ( system_flag ) {

            /*
             *  Mask in the load flag
             */
            pImageNtHeader->OptionalHeader.LoaderFlags |= IMAGE_LOADER_FLAGS_SYSTEM_GLOBAL;

            StringMessage(IDS_REGISTER_SYSTEM_GLOBAL, fileW);
        }
        else if ( user_flag ) {

            /*
             *  Mask out the load flag
             */
            pImageNtHeader->OptionalHeader.LoaderFlags &= ~(IMAGE_LOADER_FLAGS_SYSTEM_GLOBAL);

            StringMessage(IDS_REGISTER_USER_GLOBAL, fileW);
        }

        /*
         *  Zero out current check sum and calculate new one
         */
        pImageNtHeader->OptionalHeader.CheckSum = 0;
        pImageNtHeader->OptionalHeader.CheckSum =
                        ChkSum( 0, (PUSHORT)pFileView, (FileLength + 1) >> 1 );
        pImageNtHeader->OptionalHeader.CheckSum += FileLength;

    }

    /*
     *  Close image file when finished
     */
closefile:
    CloseHandle( FileHandle );

done:

    return rc;
}


/*******************************************************************************
 *
 *  ChkSum
 *
 ******************************************************************************/

USHORT
ChkSum(
    ULONG PartialSum,
    PUSHORT Source,
    ULONG Length
    )

/*++

Routine Description:

    Compute a partial checksum on a portion of an imagefile.

Arguments:

    PartialSum - Supplies the initial checksum value.

    Sources - Supplies a pointer to the array of words for which the
        checksum is computed.

    Length - Supplies the length of the array in words.

Return Value:

    The computed checksum value is returned as the function value.

--*/

{

    //
    // Compute the word wise checksum allowing carries to occur into the
    // high order half of the checksum longword.
    //

    while (Length--) {
        PartialSum += *Source++;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xffff);
    }

    //
    // Fold final carry into a single word result and return the resultant
    // value.
    //

    return (USHORT)(((PartialSum >> 16) + PartialSum) & 0xffff);
}


/*******************************************************************************
 *
 *  Usage
 *
 ******************************************************************************/

VOID
Usage( BOOL bError )
{

    if ( !Is_X86_OS() )
    {
        ErrorPrintf( IDS_X86_ONLY );
        return;
    }

    if ( bError ) 
    {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_USAGE1);
        ErrorPrintf(IDS_USAGE2);
        ErrorPrintf(IDS_USAGE3);
        ErrorPrintf(IDS_USAGE4);
        ErrorPrintf(IDS_USAGE7);
    }
    else {
       Message(IDS_USAGE1);
       Message(IDS_USAGE2);
       Message(IDS_USAGE3);
       Message(IDS_USAGE4);
       Message(IDS_USAGE7);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\remotepage\remotepage.h ===
#pragma once

#include <windows.h>
#include <objbase.h>
#include <objsel.h>
#include <shlobj.h>

//
#define TSCFG_MUTEXNAME TEXT("Global\\TerminalServerConfigMutex")

//***************************************************************************************
//class CRemoteUsersDialog
//***************************************************************************************
class CRemoteUsersDialog
{
private:
    HINSTANCE   m_hInst;
    HWND        m_hDlg;
    HWND        m_hList;
    WCHAR       m_szRemoteGroupName[MAX_PATH+1];
    WCHAR       m_szLocalCompName[MAX_PATH+1];
    BOOL        m_bCanShowDialog;
    //image indexes
    int m_iLocUser,m_iGlobUser,m_iLocGroup,m_iGlobGroup,m_iUnknown;
public:
    CRemoteUsersDialog(HINSTANCE hInst);
    INT_PTR DoDialog(HWND hwndParent);
    BOOL CanShowDialog(LPBOOL pbAccessDenied);
    void OnInitDialog(HWND hDlg);
    void OnLink(WPARAM wParam);
    BOOL OnOk();
    void OnItemChanged(LPARAM lParam);
    void OnDestroyWindow();
    void AddUsers();
    void RemoveUsers();
private:
    void AddPickerItems(DS_SELECTION_LIST *selections);
    int FindItemBySid(PSID pSid);
    void ReloadList();
    BOOL IsLocal(LPWSTR wszDomainandname);
    void InitAccessMessage();

};

INT_PTR APIENTRY RemoteUsersDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

//***************************************************************************************
//class CRemotePage
//***************************************************************************************
class CRemotePage : public IShellExtInit, IShellPropSheetExt
{
private:
    //reference counter
    ULONG				m_cref;
    
    BOOL        m_bProfessional;
    DWORD       m_dwPageType;
    HINSTANCE   m_hInst;
    HWND        m_hDlg;
    DWORD       m_dwInitialState;
    BOOL        m_bDisableChkBox;
    BOOL        m_bDisableButtons;
    BOOL        m_bShowAccessDeniedWarning;
    WORD        m_TemplateId;

    CRemoteUsersDialog m_RemoteUsersDialog;
public:
    
    CRemotePage(HINSTANCE hinst);
    ~CRemotePage();
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    ///////////////////////////////
    // Interface IShellExtInit
    ///////////////////////////////   
    STDMETHODIMP Initialize(LPCITEMIDLIST , LPDATAOBJECT , HKEY );

    ///////////////////////////////
    // Interface IShellPropSheetExt
    /////////////////////////////// 
    STDMETHODIMP AddPages( LPFNADDPROPSHEETPAGE ,  LPARAM );
    STDMETHODIMP ReplacePage( UINT , LPFNADDPROPSHEETPAGE , LPARAM );
    
    ///////////////////////////////
    // Internal functions
    /////////////////////////////// 
    void OnInitDialog(HWND hDlg);
    void OnSetActive();
    BOOL OnApply();
    void OnLink(WPARAM wParam);
    BOOL OnRemoteEnable();
    void OnRemoteSelectUsers();
    void RemoteEnableWarning();
private:
    BOOL CanShowRemotePage();

};

INT_PTR APIENTRY RemoteDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

#define PAGE_TYPE_UNKNOWN   0
#define PAGE_TYPE_PTS       1
#define PAGE_TYPE_APPSERVER 2
#define PAGE_TYPE_PERSONAL  3

//***************************************************************************************
//class CWaitCursor
//***************************************************************************************
class CWaitCursor
{
private:
    HCURSOR m_hOldCursor;
public:
    CWaitCursor()
    {
        m_hOldCursor=SetCursor(LoadCursor(NULL,IDC_WAIT));
    }
    ~CWaitCursor()
    {
        SetCursor(m_hOldCursor);
    }
};

//***************************************************************************************
//class CMutex
//***************************************************************************************
class CMutex
{
private:
    HANDLE m_hMutex;
public:
    CMutex() : m_hMutex(NULL)
    {
        m_hMutex=CreateMutex(NULL,TRUE,TSCFG_MUTEXNAME);
        if(m_hMutex)
        {
            //wait up to 30 sec.
            WaitForSingleObject(m_hMutex,30000);
        }
    }
    ~CMutex()
    {
        if(m_hMutex)
        {
            ReleaseMutex(m_hMutex);
            CloseHandle(m_hMutex);
        }
    }
};

//***************************************************************************************
//class COfflineFilesDialog
//***************************************************************************************
class COfflineFilesDialog
{
private:
    HINSTANCE   m_hInst;
    HWND        m_hDlg;
public:
    COfflineFilesDialog(HINSTANCE hInst);
    INT_PTR DoDialog(HWND hwndParent);
    void OnInitDialog(HWND hDlg);
    void OnLink(WPARAM wParam);
};

INT_PTR APIENTRY OfflineFilesDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

//***************************************************************************************
//Global functions
//***************************************************************************************
BOOL
getGroupMembershipPickerSettings(
   DSOP_SCOPE_INIT_INFO*&  infos,
   ULONG&                  infoCount);

HRESULT VariantToSid(VARIANT* var, PSID *ppSid);

BOOL TestUserForAdmin();

void DisplayError(HINSTANCE hInst, HWND hDlg, UINT ErrID, UINT MsgID, UINT TitleID, ...);

BOOL LookupSid(IN PSID pSid, OUT LPWSTR *ppName, OUT SID_NAME_USE *peUse);

BOOL GetTokenUserName(IN HANDLE hToken,OUT LPWSTR *ppName);

BOOL GetRDPSecurityDescriptor(OUT PSECURITY_DESCRIPTOR *ppSD);

BOOL CheckWinstationLogonAccess(IN HANDLE hToken,IN PSECURITY_DESCRIPTOR pSD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\remotepage\registry.h ===
#pragma once

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule);

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\remotepage\remotepage.cpp ===
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "RemotePage.h"
#include <lm.h>
#include <crtdbg.h>
#include <shellapi.h>
#include <htmlhelp.h>
#include "resource.h"
#include <shgina.h>
#include "RAssistance.h"
#include "RAssistance_i.c"
#include <winsta.h>
#include "cfgbkend.h"
#include "cfgbkend_i.c"

extern ULONG g_uObjects;

IRASettingProperty* g_praSetting = NULL; // Used for Remote assistance setting

#define NO_HELP                         ((DWORD) -1) // Disables Help for a control
//Table of help IDs for each control
DWORD aHelpIds[] = {
    IDC_REMOTE_ENABLE,              HIDC_REMOTE_ENABLE,               
    IDC_REMOTE_USR_LIST,            HIDC_REMOTE_USR_LIST,
    IDC_REMOTE_USR_ADD,             HIDC_REMOTE_USR_ADD,
    IDC_REMOTE_USR_REMOVE,          HIDC_REMOTE_USR_REMOVE,
    IDC_REMOTE_ASSISTANCE_ADVANCED, HIDC_RA_ADVANCED,
    IDC_ENABLERA,                   HIDC_RA_ENABLE,
    IDC_REMOTE_UPLINK,              NO_HELP,
    IDC_REMOTE_GPLINK_APPSERVER,    NO_HELP,
    IDC_REMOTE_SCLINK_APPSERVER,    NO_HELP,
    IDC_OFFLINE_FILES,              NO_HELP,
    IDC_REMOTE_COMPNAME,            NO_HELP,
    IDC_REMOTE_HELP,                NO_HELP,
    IDC_REMOTE_HELP_APPSERVER,      NO_HELP,
    IDC_REMOTE_SELECT_USERS,        NO_HELP,
    IDC_DEFAULT1,                   NO_HELP,
    IDC_DEFAULT2,                   NO_HELP,
    IDC_DEFAULT3,                   NO_HELP,
    IDC_DEFAULT4,                   NO_HELP,
    IDC_DEFAULT5,                   NO_HELP,
    0,                              0
};



//*************************************************************
//
//  CRemotePage::CRemotePage()
//
//  Purpose:    Initializes data members of the object
//
//  Parameters: HINSTANCE hinst 
//
//  Return:     NONE
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
CRemotePage::CRemotePage(
        IN HINSTANCE hinst) : 
        m_RemoteUsersDialog(hinst)
{
    m_cref = 1; //
    m_bProfessional = FALSE;
    m_dwPageType = PAGE_TYPE_UNKNOWN;
    m_hInst = hinst;
    m_bDisableChkBox = FALSE;
    m_bDisableButtons = FALSE;
    m_bShowAccessDeniedWarning = FALSE;
    m_dwInitialState = 0;
    m_hDlg = NULL;
    m_TemplateId = 0;

    g_uObjects++;
}

//*************************************************************
//
//  CRemotePage::~CRemotePage()
//
//  Purpose:    decreases the object counter
//
//  Parameters: NONE 
//
//  Return:     NONE
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
CRemotePage::~CRemotePage()
{
    g_uObjects--;
}

///////////////////////////////
// Interface IUnknown
///////////////////////////////
STDMETHODIMP 
CRemotePage::QueryInterface(
        IN  REFIID riid, 
        OUT LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IShellPropSheetExt *>(this);
    else if (IsEqualIID(riid, IID_IShellExtInit))
        *ppv = static_cast<IShellExtInit *>(this);
    else if (IsEqualIID(riid, IID_IShellPropSheetExt))
        *ppv = static_cast<IShellPropSheetExt *>(this);
    
    if (*ppv)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) 
CRemotePage::AddRef()
{
    return ++m_cref;
}

STDMETHODIMP_(ULONG) 
CRemotePage::Release()
{
    m_cref--;

    if (!m_cref)
    {
        delete this;
        return 0;
    }
    return m_cref;

}


///////////////////////////////
// Interface IShellExtInit
///////////////////////////////   

STDMETHODIMP 
CRemotePage::Initialize(
        IN LPCITEMIDLIST pidlFolder,
        IN LPDATAOBJECT lpdobj,
        IN HKEY hkeyProgID )
{
    return S_OK;
}

///////////////////////////////
// Interface IShellPropSheetExt
/////////////////////////////// 
//*************************************************************
//
//  AddPages()
//
//  Purpose:    Adds "Remote" tab to a property sheet
//
//  Parameters: lpfnAddPage    -   function to call to add a page
//              lParam - Parameter to pass to the function specified by the lpfnAddPage 

//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
STDMETHODIMP 
CRemotePage::AddPages( 
        IN LPFNADDPROPSHEETPAGE lpfnAddPage, 
        IN LPARAM lParam )
{
    
    if(CanShowRemotePage())
    {
        PROPSHEETPAGE psp;
    
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = 0;
        psp.hInstance = m_hInst;
        psp.pszTemplate = MAKEINTRESOURCE(m_TemplateId);
        psp.pfnDlgProc = RemoteDlgProc;
        psp.pszTitle = NULL;
        psp.lParam = (LPARAM)this;

        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&psp);

        if(hPage && lpfnAddPage(hPage,lParam))
        {
            return S_OK;
        }
    }

    return E_FAIL;    
}

STDMETHODIMP 
CRemotePage::ReplacePage(
        IN UINT uPageID,
        IN LPFNADDPROPSHEETPAGE lpfnReplacePage,
        IN LPARAM lParam )
{
    return E_FAIL; 
}


//*************************************************************
//
//  RemoteDlgProc()
//
//  Purpose:    Dialog box procedure for Remote tab
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
INT_PTR APIENTRY 
RemoteDlgProc (
        HWND hDlg, 
        UINT uMsg, 
        WPARAM wParam, 
        LPARAM lParam)
{
    CRemotePage *pPage = (CRemotePage *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            PROPSHEETPAGE *ppsp=(PROPSHEETPAGE *)lParam;
            pPage = (CRemotePage *)ppsp->lParam;

             
            SetWindowLongPtr(hDlg,DWLP_USER,(LONG_PTR)pPage);
            if(pPage)
            {
                pPage->AddRef();
                pPage->OnInitDialog(hDlg);
            }
        }       
        break;

    case WM_NOTIFY:
        
        switch (((NMHDR FAR*)lParam)->code)
        {

        case NM_CLICK:
        case NM_RETURN:
            // Is for RA's help?
            if (wParam == IDC_REMOTERA_HELP)
            {
#if 0
#define HELP_PATH TEXT("\\PCHEALTH\\HelpCtr\\Binaries\\HelpCtr.exe -FromStartHelp -Mode \"hcp://CN=Microsoft Corporation,L=Redmond,S=Washington,C=US/Remote Assistance/RAIMLayout.xml\" -Url \"hcp://CN=Microsoft Corporation,L=Redmond,S=Washington,C=US/Remote%20Assistance/Common/RCMoreInfo.htm\"")
                TCHAR szCommandLine[2000];
                PROCESS_INFORMATION ProcessInfo;
                STARTUPINFO StartUpInfo;

                TCHAR szWinDir[2048];
                GetWindowsDirectory(szWinDir, 2048);

                ZeroMemory((LPVOID)&StartUpInfo, sizeof(STARTUPINFO));
                StartUpInfo.cb = sizeof(STARTUPINFO);    

                wsprintf(szCommandLine, TEXT("%s%s"), szWinDir,HELP_PATH);
                CreateProcess(NULL, szCommandLine,NULL,NULL,TRUE,CREATE_NEW_PROCESS_GROUP,NULL,&szWinDir[0],&StartUpInfo,&ProcessInfo);
#else
	            HtmlHelp(NULL, TEXT("remasst.chm"), HH_HELP_FINDER, 0);
#endif
            }
            else if(pPage)
            {
                pPage->OnLink(wParam);
            }
            break;

        case PSN_APPLY:
            if(pPage)
            {
                if(pPage->OnApply())
                {
                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT,PSNRET_NOERROR);    
                }
                else
                {
                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT,PSNRET_INVALID);        
                }
            }
            return TRUE;

        case PSN_SETACTIVE:
            if(pPage)
            {
                pPage->OnSetActive();
            }
            return TRUE;

        default:
            return FALSE;
        }
   
        break;

    case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
            case IDC_REMOTE_ENABLE:
                if(pPage && pPage->OnRemoteEnable())
                {
                    pPage->RemoteEnableWarning();
                    PropSheet_Changed(GetParent(hDlg), hDlg);
                }
                break;
            case IDC_REMOTE_SELECT_USERS:
                if(pPage)
                {
                    pPage->OnRemoteSelectUsers();
                }
                break;
			// Remote Assistance Dialog button.
            case IDC_REMOTE_ASSISTANCE_ADVANCED:
                {
                    BOOL bIsChanged = FALSE;
                    if (!g_praSetting)
                    {
                        CoCreateInstance(CLSID_RASettingProperty,
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      IID_IRASettingProperty,
                                      reinterpret_cast<void**>(&g_praSetting));
                        // Need to init it at the first time.
                        if (g_praSetting)
                        {
                            g_praSetting->Init();
                        }
                        else
                        {
                            // Not enough memory, too bad.
                            return TRUE;
                        }
                    }

                    g_praSetting->ShowDialogBox(hDlg);
                    if (SUCCEEDED(g_praSetting->get_IsChanged(&bIsChanged)) && bIsChanged)
                    {
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                    }
                }
                break;

            case IDC_ENABLERA:
                {
                    PropSheet_Changed(GetParent(hDlg), hDlg);					
                    EnableWindow(GetDlgItem(hDlg,IDC_REMOTE_ASSISTANCE_ADVANCED),
        				            IsDlgButtonChecked(hDlg, IDC_ENABLERA));
                }
                break;

            default:
                
                break;
            }
        }
        return FALSE;
    
    case WM_DESTROY:
        if(pPage)
        {
            pPage->Release();
        }

        if (g_praSetting)
        {
            g_praSetting->Release();
            g_praSetting = NULL;
        }

        return FALSE; //If an application processes this message, it should return zero.

    case WM_HELP:
        {
            LPHELPINFO phi=(LPHELPINFO)lParam;
            if(phi && phi->dwContextId)
            {   
                WinHelp(hDlg,TEXT("SYSDM.HLP"),HELP_CONTEXTPOPUP,phi->dwContextId);
            }
        }
        break;

    case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, TEXT("SYSDM.HLP"), HELP_CONTEXTMENU,
                (DWORD_PTR)aHelpIds);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


//*************************************************************
//
//  CRemotePage::CanShowRemotePage()
//
//  Purpose:    Checks Windows version;
//              searches for "FDenyTSConnections" value first
//              in HKLM\\Software\\Policies\\Microsoft\\Windows NT\\Terminal Services
//              if not found than in
//              SYSTEM\\CurrentControlSet\\Control\\Terminal Server;
//              creates "Remote Desktop Users" SID,
//              gets "Remote Desktop Users" group name from the SID
//
//  Parameters: hInst   -   hInstance
//              dwPageType - can be PAGE_TYPE_PTS or PAGE_TYPE_APPSERVER
//
//  Return:     TRUE if can show remote page 
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************

BOOL 
CRemotePage::CanShowRemotePage()
{

    BOOL    fCreatePage = FALSE;
    
    //Check Windows version
    OSVERSIONINFOEX ov;
    ov.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if(!GetVersionEx((LPOSVERSIONINFO)&ov))
    {
        return FALSE;
    }
    if(ov.wProductType == VER_NT_WORKSTATION && 
        (ov.wSuiteMask & VER_SUITE_SINGLEUSERTS ))
    {
        fCreatePage = TRUE;

        if(ov.wSuiteMask & VER_SUITE_PERSONAL)
        {
#ifdef _WIN64
            // No Remote Assistance on WIN64
            fCreatePage = FALSE;
#else
            m_dwPageType = PAGE_TYPE_PERSONAL;
            m_TemplateId = IDD_REMOTE_PERSONAL;
#endif
        }
        else
        {
            m_bProfessional = TRUE;
            m_dwPageType = PAGE_TYPE_PTS;
            m_TemplateId = IDD_REMOTE_PTS;
        }
    }
    else
    {
        if((ov.wProductType == VER_NT_DOMAIN_CONTROLLER || ov.wProductType ==  VER_NT_SERVER) &&
            (ov.wSuiteMask & VER_SUITE_TERMINAL) &&
            TestUserForAdmin())
        {
            fCreatePage = TRUE;

            if(ov.wSuiteMask & VER_SUITE_SINGLEUSERTS)
            {
                m_dwPageType = PAGE_TYPE_PTS; 
                m_TemplateId = IDD_REMOTE_PTS;
            }
            else
            {
                m_dwPageType = PAGE_TYPE_APPSERVER;
                m_TemplateId = IDD_REMOTE_APPSERVER;
            }
        }
 
    }
    
    if( !fCreatePage)
    {
        return FALSE;
    }

    DWORD dwType;
    DWORD cbDisable;
    LONG Err;
    HKEY hKey;

    Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
        TEXT("Software\\Policies\\Microsoft\\Windows NT\\Terminal Services"),
        0,
        KEY_QUERY_VALUE,
        &hKey);

    if(Err == ERROR_SUCCESS)
    {
        cbDisable = sizeof(DWORD);

        Err = RegQueryValueEx(hKey,
                     TEXT("fDenyTSConnections"),
                     NULL,
                     &dwType,
                     (LPBYTE)&m_dwInitialState,
                     &cbDisable);
        
        if(Err == ERROR_SUCCESS)
        {
            m_bDisableChkBox = TRUE;

            if(m_dwInitialState != 0)
            {
                m_bDisableButtons = TRUE;
            }
        }

        RegCloseKey(hKey);

    }

    if(Err != ERROR_SUCCESS)
    {
        if(Err != ERROR_FILE_NOT_FOUND)
        {
            return FALSE;
        }

        Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        TEXT("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"),
                        0,
                        KEY_QUERY_VALUE,
                        &hKey);

        if(Err == ERROR_SUCCESS)
        {
            cbDisable = sizeof(DWORD);

            Err = RegQueryValueEx(hKey,
                     TEXT("fDenyTSConnections"),
                     NULL,
                     &dwType,
                     (LPBYTE)&m_dwInitialState,
                     &cbDisable);

            RegCloseKey(hKey);
        }

        if(Err != ERROR_SUCCESS && Err != ERROR_FILE_NOT_FOUND )
        {
            return FALSE;
        }
    }
    

    
    //Check permissions
    //on the registry
    if( !m_bDisableChkBox )
    {
        Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            TEXT("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"),
                            0,
                            KEY_SET_VALUE,
                            &hKey);
        if( Err == ERROR_SUCCESS )
        {
            RegCloseKey(hKey);
        }
        else
        {
            if(  Err == ERROR_ACCESS_DENIED )
            {
                m_bDisableChkBox = TRUE;
                m_bShowAccessDeniedWarning = TRUE;
            }
        }
    }

    if(m_dwPageType == PAGE_TYPE_PTS)
    {
        if(!m_bDisableButtons)
        {
            if(!m_RemoteUsersDialog.CanShowDialog(&m_bShowAccessDeniedWarning))
            {
                m_bDisableButtons = TRUE;
            }

            if(m_bShowAccessDeniedWarning)
            {
                m_bDisableButtons = TRUE;
            }
        }
    }

    return TRUE;
}

//*************************************************************
//
//  CRemotePage::OnInitDialog()
//
//  Purpose:    initializes check box state 
//              creates list of "Remote Desktop Users" members
//
//  Parameters: hDlg   -   the page handle 
//
//  Return:     NONE
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
void 
CRemotePage::OnInitDialog(
        IN HWND hDlg)
{
    m_hDlg = hDlg;
    
    /* Get Remote Assistance button value */
    BOOL bRAEnable = FALSE;
    int  iErr;
    HKEY hKey = NULL;
    IRARegSetting* pRA = NULL;
    CoCreateInstance(CLSID_RARegSetting,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IRARegSetting,
        reinterpret_cast<void**>(&pRA));
    if (pRA)
    {
        pRA->get_AllowGetHelpCPL(&bRAEnable);
        pRA->Release();
    }

    CheckDlgButton(m_hDlg, IDC_ENABLERA, bRAEnable?BST_CHECKED:BST_UNCHECKED);
    // check if users have permission to change this setting.
    iErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        TEXT("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"),
                        0,
                        KEY_SET_VALUE,
                        &hKey);
    if (iErr == ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
    }
    else if (iErr == ERROR_ACCESS_DENIED)
    {
        bRAEnable = FALSE;
        EnableWindow(GetDlgItem(m_hDlg,IDC_ENABLERA), FALSE);
    }

    EnableWindow(GetDlgItem(m_hDlg,IDC_REMOTE_ASSISTANCE_ADVANCED), bRAEnable);

    /***** RA done *******/

    if(m_bDisableChkBox)
    {
        EnableWindow(GetDlgItem(m_hDlg,IDC_REMOTE_ENABLE),FALSE);   
    }
    
    CheckDlgButton(m_hDlg,IDC_REMOTE_ENABLE,m_dwInitialState?BST_UNCHECKED:BST_CHECKED);
    
    if(m_dwPageType == PAGE_TYPE_PTS)
    {

        if(m_bDisableButtons)
        {
            EnableWindow(GetDlgItem(m_hDlg,IDC_REMOTE_SELECT_USERS),FALSE); 
        }

        //Get computer name
        LPTSTR  szCompName = (LPTSTR)LocalAlloc (LPTR, (MAX_PATH+1) * sizeof(TCHAR) );
        DWORD   dwNameSize = MAX_PATH;
        
        if(szCompName)
        {
            BOOL bResult = GetComputerNameEx( ComputerNameDnsFullyQualified, szCompName, &dwNameSize );

            if(!bResult && GetLastError() == ERROR_MORE_DATA)
            {
                LocalFree(szCompName);
                szCompName = (LPTSTR) LocalAlloc (LPTR, (dwNameSize+1) * sizeof(TCHAR) );

                if ( szCompName ) 
                {
                    bResult = GetComputerNameEx( ComputerNameDnsFullyQualified, szCompName, &dwNameSize );
                }
                
            }

            if(bResult)
            {
                SetDlgItemText(hDlg,IDC_REMOTE_COMPNAME,szCompName);     
            }

            if(szCompName)
            {
                LocalFree(szCompName);
            }
        }

    }

}

//*************************************************************
//
//  CRemotePage::OnSetActive()
//
//  Purpose:    When the page gets active and user does not have
//              permissions to change some settings it shows
//              a warning message.
//
//  Parameters: NONE   
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
void 
CRemotePage::OnSetActive()
{
    TCHAR szMsg[MAX_PATH+1];
    TCHAR szTitle[MAX_PATH+1];

    if( m_bShowAccessDeniedWarning )
    {
        if(LoadString(m_hInst,IDS_REMOTE_SESSIONS,szTitle,MAX_PATH) &&
            LoadString(m_hInst,IDS_WRN_NO_PERMISSIONS,szMsg,MAX_PATH))
        {
            MessageBox(m_hDlg,szMsg,szTitle,MB_OK|MB_ICONINFORMATION);
        }

        m_bShowAccessDeniedWarning = FALSE;        
    }
}

//*************************************************************
//
//  CRemotePage::OnApply()
//
//  Purpose:    saves settings in the Registry
//              saves "Remote Desktop Users" membership changes
//
//  Parameters: NONE 
//
//  Return:     TRUE - if changes can be applied
//              FALSE - otherwise.
//
//  Comments:   in case of error shows message box
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
BOOL
CRemotePage::OnApply()
{
    CWaitCursor wait;
    CMutex      mutex;

    DWORD dwType = REG_DWORD;
    DWORD dwDisable = 0;
    DWORD cbDisable = sizeof(DWORD);
    LONG Err;

    // Update RA setting first
    IRARegSetting* pRA = NULL;
    CoCreateInstance(CLSID_RARegSetting,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IRARegSetting,
            reinterpret_cast<void**>(&pRA));
    if (pRA)
    {
        pRA->put_AllowGetHelp(IsDlgButtonChecked(m_hDlg, IDC_ENABLERA)==BST_CHECKED);
        pRA->Release();
    }

    BOOL bIsChanged = FALSE;
    if (g_praSetting && SUCCEEDED(g_praSetting->get_IsChanged(&bIsChanged)) && bIsChanged)
    {
        g_praSetting->SetRegSetting();
    }
    // RA done.

    if(!OnRemoteEnable())
    {
        return FALSE;
    }

    if(IsWindowEnabled(GetDlgItem(m_hDlg,IDC_REMOTE_ENABLE)))
    {

        if(IsDlgButtonChecked(m_hDlg,IDC_REMOTE_ENABLE) == BST_UNCHECKED)
        {
            dwDisable = 1;
        }
       
        
        if(dwDisable != m_dwInitialState)
        {

            HRESULT hr;

            hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
            if (SUCCEEDED(hr))
            {
                ILocalMachine   *pLocalMachine;

                hr = CoCreateInstance(CLSID_ShellLocalMachine,
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      IID_ILocalMachine,
                                      reinterpret_cast<void**>(&pLocalMachine));
                if (SUCCEEDED(hr) && (pLocalMachine != NULL))
                {
                    hr = pLocalMachine->put_isRemoteConnectionsEnabled(dwDisable == 0);
                    pLocalMachine->Release();
                }
                CoUninitialize();
            }
            Err = HRESULT_CODE(hr);
            if (ERROR_SUCCESS == Err)
            {
                m_dwInitialState = dwDisable;
            }
            else
            {
                if (ERROR_NOT_SUPPORTED == Err)
                {
                    TCHAR   szContent[256], szTitle[256];

                    (int)LoadString(m_hInst, IDS_OTHER_USERS, szContent, sizeof(szContent) / sizeof(szContent[0]));
                    (int)LoadString(m_hInst, IDS_REMOTE_SESSIONS, szTitle, sizeof(szTitle) / sizeof(szTitle[0]));
                    MessageBox(m_hDlg, szContent, szTitle, MB_OK | MB_ICONSTOP);
                }
                else
                {
                    DisplayError(m_hInst, m_hDlg, Err, IDS_ERR_SAVE_REGISTRY, IDS_REMOTE_SESSIONS);
                }
                CheckDlgButton(m_hDlg, IDC_REMOTE_ENABLE, m_dwInitialState ? BST_UNCHECKED : BST_CHECKED);
            }
        }
    }
    
    return TRUE;
}

//*************************************************************
//
//  CRemotePage::OnLink()
//
//  Purpose:  runs application which link points to.  
//
//  Parameters: WPARAM wParam - link ID
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              5/8/00    a-skuzin    Created
//
//*************************************************************
void 
CRemotePage::OnLink(
        WPARAM wParam)
{
    switch(wParam)
    {
    case IDC_REMOTE_GPLINK_APPSERVER:
        ShellExecute(NULL,TEXT("open"),TEXT("gpedit.msc"),NULL,NULL,SW_SHOW);
        break;
    case IDC_REMOTE_SCLINK_APPSERVER:
        ShellExecute(NULL,TEXT("open"),TEXT("tscc.msc"),NULL,NULL,SW_SHOW);
        break;
    case IDC_REMOTE_UPLINK:
        ShellExecute(NULL,TEXT("open"),TEXT("control"),TEXT("userpasswords"),NULL,SW_SHOW);
        break;
        /*
    case IDC_REMOTE_HELP:
        HtmlHelp(NULL, TEXT("rdesktop.chm"), HH_HELP_FINDER, 0);
        break;*/
    case IDC_REMOTE_HELP:
        if(m_bProfessional)
        {
            ShellExecute(NULL,TEXT("open"),
                TEXT("hcp://services/subsite?node=TopLevelBucket_2/Working_Remotely/")
                TEXT("Remote_Desktop&topic=MS-ITS:rdesktop.chm::/rdesktop_overview.htm"),NULL,NULL,SW_SHOW);
        }
        else
        {
            ShellExecute(NULL,TEXT("open"),
                TEXT("hcp://services/subsite?node=Administration_and_Scripting_Tools/Remote_Administration_Tools/")
                TEXT("Remote_Administration_Using_Terminal_Services&topic=MS-ITS:rdesktop.chm::/rdesktops_chm_topnode.htm"),NULL,NULL,SW_SHOW);
        }
        break;
    case IDC_REMOTE_HELP_APPSERVER:
        ShellExecute(NULL,TEXT("open"),
                TEXT("hcp://services/subsite?node=Software_Deployment/")
                TEXT("Terminal_Services&topic=MS-ITS:termsrv.chm::/ts_chm_top.htm"),NULL,NULL,SW_SHOW);
        break;
    default:
        break;
    }
    
}

//*************************************************************
//
//  CRemotePage::OnRemoteEnable()
//
//  Purpose:    If user tries to allow remote connections and 
//              "Offline Files" is enabled it shows
//              "Disable Offline Files" dialog and unchecks
//              "Remote Connections" checkbox.  
//
//  Parameters: NONE
//
//  Return:     TRUE - if the check box state was changed.
//              FALSE - otherwise
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              5/8/00    a-skuzin    Created
//
//*************************************************************

typedef BOOL (WINAPI * PCHECKFN)();

BOOL 
CRemotePage::OnRemoteEnable()
{
    //First check if multiple connections are allowed
    DWORD dwAllowMultipleTSSessions = 0;
    DWORD dwType;
    DWORD cbSize;
    LONG Err;
    HKEY hKey;
    BOOL bResult = TRUE;
    
    //Fast User Switching / Remote Connections and Offline Files should work together fine. 
    //when Brian Aust makes his changes to offline files.
    //therefore we should not restrict remote connections in any case on Professional Machines.
    //on server machine however we conntinue to disallow remote connections if Offline files are on.
    if(m_bProfessional)
    {
        return TRUE;
    }

    //allow user to uncheck the checkbox
    if(IsDlgButtonChecked(m_hDlg,IDC_REMOTE_ENABLE) == BST_UNCHECKED )
    {
        return TRUE;
    }
    
    //check if multiple sessions is allowed.
    Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                            0,
                            KEY_QUERY_VALUE,
                            &hKey);

    if(Err == ERROR_SUCCESS)
    {
        cbSize = sizeof(DWORD);

        Err = RegQueryValueEx(hKey,
                     TEXT("AllowMultipleTSSessions"),
                     NULL,
                     &dwType,
                     (LPBYTE)&dwAllowMultipleTSSessions,
                     &cbSize);
        
        if(Err == ERROR_SUCCESS && dwAllowMultipleTSSessions)
        {
            //multiple sessions is allowed.
            //check if CSC (Offline Files) is enabled 
            HMODULE hLib = LoadLibrary(TEXT("cscdll.dll"));
            if(hLib)
            {
                PCHECKFN pfnCSCIsCSCEnabled = (PCHECKFN)GetProcAddress(hLib,"CSCIsCSCEnabled");

                if(pfnCSCIsCSCEnabled && pfnCSCIsCSCEnabled())
                {
                    //Offline Files is enabled
                    //uncheck the checkbox; show the dialog
                    COfflineFilesDialog Dlg(m_hInst);

                    CheckDlgButton(m_hDlg,IDC_REMOTE_ENABLE,BST_UNCHECKED);
                    Dlg.DoDialog(m_hDlg);
                    
                    bResult = FALSE;
                }
            }

            FreeLibrary(hLib);
            
        }

        RegCloseKey(hKey);
        
    }

    return bResult;
}

//*************************************************************
//
//  CRemotePage::OnRemoteSelectUsers()
//
//  Purpose:    Creates "Remote Desktop Users" dialog.
//
//  Parameters: NONE
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
void 
CRemotePage::OnRemoteSelectUsers()
{
    m_RemoteUsersDialog.DoDialog(m_hDlg);
}

//*************************************************************
//
//  CRemotePage::RemoteEnableWarning()
//
//  Purpose:    Displays a message box about empty passwords
//              firewalls and other stuff that can prevent
//              remote sessions from working properly.
//
//  Parameters: NONE
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              3/28/01    a-skuzin    Created
//
//*************************************************************
void
CRemotePage::RemoteEnableWarning()
{
    if(IsDlgButtonChecked(m_hDlg,IDC_REMOTE_ENABLE) == BST_CHECKED )
    {
        //
        //Now warn admin about empty passwords.
        //Empty passwords are not allowed with 
        //RemoteInteractive logon.
        //
        //Allocate a buffer for the string 1000 chars should be enough
        //
        TCHAR szTitle[MAX_PATH+1];
        DWORD cMsg = 1000;
        LPTSTR szMsg = (LPTSTR) LocalAlloc(LPTR,(cMsg+1)*sizeof(TCHAR));

        if(szMsg)
        {
            if(LoadString(m_hInst,IDS_WRN_EMPTY_PASSWORD,szMsg,cMsg) &&
                LoadString(m_hInst,IDS_REMOTE_SESSIONS,szTitle,MAX_PATH))
            {
                MessageBox(m_hDlg,szMsg,szTitle,
                    MB_OK | MB_ICONINFORMATION);
            }
            LocalFree(szMsg);
        }
    }
}

//*************************************************************
//
//  DisplayError()
//
//  Purpose:    shows message box with error description
//
//  Parameters: ErrID -    error code
//              MsgID -  ID of the first part of error messsage in the string table
//              TitleID - ID of the title in the string table
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
void 
DisplayError(
        IN HINSTANCE hInst, 
        IN HWND hDlg, 
        IN UINT ErrID, 
        IN UINT MsgID, 
        IN UINT TitleID,
        ...)
{
    TCHAR szTemplate[MAX_PATH+1];
    TCHAR szErr[MAX_PATH+1];
    
    if(!LoadString(hInst,MsgID,szTemplate,MAX_PATH))
    {
        return;
    }
    
    va_list arglist;
    va_start(arglist, TitleID);
    wvsprintf(szErr,szTemplate,arglist);
    va_end(arglist);

    TCHAR szTitle[MAX_PATH+1];

    if(!LoadString(hInst,TitleID,szTitle,MAX_PATH))
    {
        return;
    }

    LPTSTR szDescr;
    
    //load module with network error messages
    HMODULE hNetErrModule=LoadLibraryEx(TEXT("netmsg.dll"),NULL,
                            LOAD_LIBRARY_AS_DATAFILE|DONT_RESOLVE_DLL_REFERENCES);

    DWORD dwFlags;

    if(hNetErrModule)
	{
		dwFlags=FORMAT_MESSAGE_FROM_SYSTEM|
			FORMAT_MESSAGE_FROM_HMODULE|
			FORMAT_MESSAGE_ALLOCATE_BUFFER|
			FORMAT_MESSAGE_IGNORE_INSERTS;
	}
	else
	{
		dwFlags=FORMAT_MESSAGE_FROM_SYSTEM|
			FORMAT_MESSAGE_ALLOCATE_BUFFER|
			FORMAT_MESSAGE_IGNORE_INSERTS;
	}

    if(FormatMessage(dwFlags,
                        hNetErrModule,
                        ErrID,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPTSTR)&szDescr,
                        0,
                        NULL))
    {
        LPTSTR szErrMessage=(LPTSTR)LocalAlloc(LPTR,
            (lstrlen(szErr)+lstrlen(szDescr)+3)*sizeof(TCHAR));
        if(szErrMessage)
        {
            wsprintf(szErrMessage,TEXT("%s\n\n%s"),szErr,szDescr);
            MessageBox(hDlg,szErrMessage,szTitle,MB_OK | MB_ICONSTOP);
            LocalFree(szErrMessage);
        }
        LocalFree(szDescr);
    }
    else
    {
        MessageBox(hDlg,szErr,szTitle,MB_OK | MB_ICONSTOP);
    }

    if(hNetErrModule)
    {
        FreeLibrary(hNetErrModule);
    }
}


//*************************************************************
//
//  getGroupMembershipPickerSettings()
//
//  Purpose:    prepares DSOP_SCOPE_INIT_INFO
//
//  Parameters: OUT DSOP_SCOPE_INIT_INFO*&  infos,
//              OUT ULONG&                  infoCount
//
//  Return:     FALSE if cannot allocate memory
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
BOOL
getGroupMembershipPickerSettings(
   OUT DSOP_SCOPE_INIT_INFO*&  infos,
   OUT ULONG&                  infoCount)
{
   

   static const int INFO_COUNT = 5;
   infos = new DSOP_SCOPE_INIT_INFO[INFO_COUNT];
   if(infos == NULL)
   {
        infoCount = 0;
        return FALSE;
   }

   infoCount = INFO_COUNT;
   memset(infos, 0, sizeof(DSOP_SCOPE_INIT_INFO) * INFO_COUNT);

   int scope = 0;

   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
   infos[scope].flScope =
            DSOP_SCOPE_FLAG_STARTING_SCOPE
         |  DSOP_SCOPE_FLAG_WANT_DOWNLEVEL_BUILTIN_PATH; 
      // this is implied for machine only scope
      /* |  DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT */

   // allow only local users from the machine scope

   infos[scope].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
   infos[scope].FilterFlags.flDownlevel =
         DSOP_DOWNLEVEL_FILTER_USERS;
     // |  DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS;

   // for the domain this machine is joined to (native and mixed mode).

   scope++;
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
   infos[scope].flType =
         DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
      |  DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;

   infos[scope].FilterFlags.Uplevel.flNativeModeOnly =
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
      //|  DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

   // here, we allow only domain global groups and domain users.  While
   // it is possible to add a domain local group to a machine local group,
   // I'm told such an operation is not really useful from an administraion
   // perspective.

   infos[scope].FilterFlags.Uplevel.flMixedModeOnly =   
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

   // same comment above re: domain local groups applies here too.

   infos[scope].FilterFlags.flDownlevel =
         DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS
      |  DSOP_DOWNLEVEL_FILTER_USERS;

   // for domains in the same tree (native and mixed mode)

   scope++;
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
   infos[scope].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;

   infos[scope].FilterFlags.Uplevel.flNativeModeOnly =
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

   // above domain local group comment applies here, too.

   infos[scope].FilterFlags.Uplevel.flMixedModeOnly =   
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

   // for external trusted domains

   scope++;
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
   infos[scope].flType =
         DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
      |  DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;

   infos[scope].FilterFlags.Uplevel.flNativeModeOnly =
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

   infos[scope].FilterFlags.Uplevel.flMixedModeOnly =   
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

   infos[scope].FilterFlags.flDownlevel =
         DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS
      |  DSOP_DOWNLEVEL_FILTER_USERS;

   // for the global catalog

   scope++;
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
   infos[scope].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;

   // only native mode applies to gc scope.

   infos[scope].FilterFlags.Uplevel.flNativeModeOnly =
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

// SPB:252126 the workgroup scope doesn't apply in this case
//    // for when the machine is not joined to a domain
//    scope++;
//    infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
//    infos[scope].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
//    infos[scope].flType = DSOP_SCOPE_TYPE_WORKGROUP;
// 
//    infos[scope].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
//    infos[scope].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;

   _ASSERT(scope == INFO_COUNT - 1);

   return TRUE;
}

//*************************************************************
//
//  VariantToSid()
//
//  Purpose:    Converts a VARIANT containing a safe array 
//              of bytes to a SID
//
//  Parameters: IN VARIANT* var, 
//              OUT PSID *ppSid
//
//  Return:     
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              3/13/00    a-skuzin    Created
//
//*************************************************************
HRESULT 
VariantToSid(
        IN VARIANT* var, 
        OUT PSID *ppSid)
{
    _ASSERT(var);
    _ASSERT(V_VT(var) == (VT_ARRAY | VT_UI1));

    HRESULT hr = S_OK;
    SAFEARRAY* psa = V_ARRAY(var);

    do
    {
        _ASSERT(psa);
        if (!psa)
        {
            hr = E_INVALIDARG;
            break;
        }

        if (SafeArrayGetDim(psa) != 1)
        {
            hr = E_INVALIDARG;
            break;
        }

        if (SafeArrayGetElemsize(psa) != 1)
        {
            hr = E_INVALIDARG;
            break;
        }

        PSID sid = 0;
        hr = SafeArrayAccessData(psa, reinterpret_cast<void**>(&sid));
        if(FAILED(hr))
        {
            break;
        }

        if (!IsValidSid(sid))
        {
            SafeArrayUnaccessData(psa);
            hr = E_INVALIDARG;
            break;
        }
        
        *ppSid = (PSID) new BYTE[GetLengthSid(sid)];
        
        if(!(*ppSid))
        {
            SafeArrayUnaccessData(psa);
            hr = E_OUTOFMEMORY;
            break;
        }

        CopySid(GetLengthSid(sid),*ppSid,sid);
        SafeArrayUnaccessData(psa);
        
   } while (0);

   return hr;
}

/*****************************************************************************
 *
 *  TestUserForAdmin - Hydrix helper function
 *
 *   Returns whether the current thread is running under admin
 *   security.
 *
 * ENTRY:
 *   NONE
 *
 * EXIT:
 *   TRUE/FALSE - whether user is specified admin
 *
 ****************************************************************************/

BOOL
TestUserForAdmin()
{
    BOOL IsMember, IsAnAdmin;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
    PSID AdminSid;


    if (!AllocateAndInitializeSid(&SystemSidAuthority,
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 DOMAIN_ALIAS_RID_ADMINS,
                                 0, 0, 0, 0, 0, 0,
                                 &AdminSid))
    {
        IsAnAdmin = FALSE;
    }
    else
    {
        if (!CheckTokenMembership(  NULL,
                                    AdminSid,
                                    &IsMember))
        {
            FreeSid(AdminSid);
            IsAnAdmin = FALSE;
        }
        else
        {
            FreeSid(AdminSid);
            IsAnAdmin = IsMember;
        }
    }

    return IsAnAdmin;
}

//*************************************************************
//
//  OfflineFilesDlgProc()
//
//  Purpose:    Dialog box procedure for "Disable Offline Files" dialog
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam (if uMsg is WM_INITDIALOG - this is a pointer to
//                                  object of COfflineFilesDialog class)
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/9/00    a-skuzin    Created
//
//*************************************************************
INT_PTR APIENTRY 
OfflineFilesDlgProc (
        HWND hDlg, 
        UINT uMsg, 
        WPARAM wParam, 
        LPARAM lParam)
{
    
    COfflineFilesDialog *pDlg = (COfflineFilesDialog *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            pDlg=(COfflineFilesDialog *)lParam;
            SetWindowLongPtr(hDlg,DWLP_USER,(LONG_PTR)pDlg);
            if(pDlg)
            {
                pDlg->OnInitDialog(hDlg);
            }
        }       
        break;
    case WM_NOTIFY:
        
        switch (((NMHDR FAR*)lParam)->code)
        {

        case NM_CLICK:
        case NM_RETURN:
            if(pDlg)
            {
                pDlg->OnLink(wParam);
            }
            break;

        default:
            return FALSE;
        }
   
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg,0);
            break;
        default:
            return FALSE;
        }

    default:
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
// class COfflineFilesDialog
//*************************************************************

//*************************************************************
//
//  COfflineFilesDialog::COfflineFilesDialog()
//
//  Purpose:    Constructor
//  Parameters: HINSTANCE hInst
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              5/8/00    a-skuzin    Created
//
//*************************************************************
COfflineFilesDialog::COfflineFilesDialog(
        IN HINSTANCE hInst) 
    : m_hInst(hInst),m_hDlg(NULL)
{
}

//*************************************************************
//
//  COfflineFilesDialog::DoDialog()
//
//  Purpose:    Creates "Disable Offline Files" dialog
//
//  Parameters: HWND hwndParent
//
//  Return:     
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              5/8/00    a-skuzin    Created
//
//*************************************************************
INT_PTR 
COfflineFilesDialog::DoDialog(
        IN HWND hwndParent)
{
    return DialogBoxParam(
                      m_hInst,
                      MAKEINTRESOURCE(IDD_DISABLE_OFFLINE_FILES),
                      hwndParent,
                      OfflineFilesDlgProc,
                      (LPARAM) this);
}

//*************************************************************
//
//  COfflineFilesDialog::OnInitDialog()
//
//  Purpose:    Initializes m_hDlg variable
//
//  Parameters: HWND hDlg
//
//  Return:     NONE   
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              5/8/00    a-skuzin    Created
//
//*************************************************************
void 
COfflineFilesDialog::OnInitDialog(
        IN HWND hDlg)
{
    m_hDlg = hDlg;
}

//*************************************************************
//
//  COfflineFilesDialog::OnLink()
//
//  Purpose:   If ID of the link is  IDC_OFFLINE_FILES
//             it shows "Offline Files" property page.
//
//  Parameters: WPARAM wParam - ID of the link.
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              5/9/00    a-skuzin    Created
//
//*************************************************************

typedef DWORD (WINAPI * PFNCSCPROP)(HWND);

void 
COfflineFilesDialog::OnLink(
        IN WPARAM wParam)
{
    if(wParam == IDC_OFFLINE_FILES)
    {
        HINSTANCE hLib = LoadLibrary(TEXT("cscui.dll"));
        if (hLib)
        {
            PFNCSCPROP pfnCSCUIOptionsPropertySheet = 
                (PFNCSCPROP)GetProcAddress(hLib, "CSCUIOptionsPropertySheet");

            if (pfnCSCUIOptionsPropertySheet)
            {
                pfnCSCUIOptionsPropertySheet(m_hDlg);
            }

            FreeLibrary(hLib);
        }
    }

}

//*************************************************************
// class CRemoteUsersDialog
//*************************************************************
//*************************************************************
//
//  RemoteUsersDlgProc()
//
//  Purpose:    Dialog box procedure for "Remote Desktop Users" dialog
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam (if uMsg is WM_INITDIALOG - this is a pointer to
//                                  object of CRemoteUsersDialog class)
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              12/22/00    skuzin     Created
//
//*************************************************************
INT_PTR APIENTRY 
RemoteUsersDlgProc (
        HWND hDlg, 
        UINT uMsg, 
        WPARAM wParam, 
        LPARAM lParam)
{
    
    CRemoteUsersDialog *pDlg = (CRemoteUsersDialog *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            pDlg=(CRemoteUsersDialog *)lParam;
            SetWindowLongPtr(hDlg,DWLP_USER,(LONG_PTR)pDlg);
            if(pDlg)
            {
                pDlg->OnInitDialog(hDlg);
            }
        }       
        return TRUE;

    case WM_NOTIFY:
        
        switch (((NMHDR FAR*)lParam)->code)
        {

        case NM_CLICK:
        case NM_RETURN:
            if(pDlg)
            {
                pDlg->OnLink(wParam);
            }
            return TRUE;

        case LVN_ITEMCHANGED:
            if(pDlg)
            {
                pDlg->OnItemChanged(lParam);
            }
            return TRUE;

        default:
            break;
        }
   
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            if(pDlg)
            {
                pDlg->OnOk();
            }
            EndDialog(hDlg,0);
            break;
        case IDCANCEL:
            EndDialog(hDlg,0);
            break;
        case IDC_REMOTE_USR_ADD:
            if(pDlg)
            {
                pDlg->AddUsers();
            }
            break;
        case IDC_REMOTE_USR_REMOVE:
            if(pDlg)
            {
                pDlg->RemoveUsers();
            }
            break;
        default:
            return FALSE;
        }
        
        SetWindowLong(hDlg,DWLP_MSGRESULT,0);
        return TRUE;

    case WM_DESTROY:
        if(pDlg)
        {
            pDlg->OnDestroyWindow();
        }
        SetWindowLong(hDlg,DWLP_MSGRESULT,0);
        return TRUE;

    case WM_HELP:
        {
            LPHELPINFO phi=(LPHELPINFO)lParam;
            if(phi && phi->dwContextId)
            {   
                WinHelp(hDlg,TEXT("SYSDM.HLP"),HELP_CONTEXTPOPUP,phi->dwContextId);
                SetWindowLong(hDlg,DWLP_MSGRESULT,TRUE);
                return TRUE;
            }
        }
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, TEXT("SYSDM.HLP"), HELP_CONTEXTMENU,
                (DWORD_PTR)aHelpIds);
        return TRUE;
    default:
        break;
    }

    return FALSE;
}

//*************************************************************
//
//  CRemoteUsersDialog::CRemoteUsersDialog()
//
//  Purpose:    Constructor
//  Parameters: HINSTANCE hInst
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/22/00    skuzin     Created
//
//*************************************************************
CRemoteUsersDialog::CRemoteUsersDialog(
        IN HINSTANCE hInst) 
    : m_hInst(hInst),m_hDlg(NULL),m_bCanShowDialog(FALSE)
{
    m_szRemoteGroupName[0] = 0;
    m_szLocalCompName[0] = 0;  
    m_hList = NULL;
    m_iLocUser = m_iGlobUser = m_iLocGroup = m_iGlobGroup = m_iUnknown = 0;  
}

//*************************************************************
//
//  CRemoteUsersDialog::DoDialog()
//
//  Purpose:    Creates "Remote Desktop Users" dialog
//
//  Parameters: HWND hwndParent
//
//  Return:     
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/22/00    a-skuzin    Created
//
//*************************************************************
INT_PTR 
CRemoteUsersDialog::DoDialog(
        IN HWND hwndParent)
{
    if(!m_bCanShowDialog)
    {
        return -1;
    }
    else
    {
        return DialogBoxParam(
                          m_hInst,
                          MAKEINTRESOURCE(IDD_REMOTE_DESKTOP_USERS),
                          hwndParent,
                          RemoteUsersDlgProc,
                          (LPARAM) this);
    }
}

//*************************************************************
//
//  CRemoteUsersDialog::CanShowDialog()
//
//  Purpose:    
//
//  Parameters: IN OUT LPBOOL pbAccessDenied - set to TRUE if
//              NetLocalGroupAddMembers returns ACCESS_DENIED.
//
//  Return:     
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
BOOL 
CRemoteUsersDialog::CanShowDialog(
        IN OUT LPBOOL pbAccessDenied)
{
    *pbAccessDenied = FALSE;

    //get name of the "Remote Desktop Users" group 
    //(it can depend on the language used)

    //first create SID
    SID_IDENTIFIER_AUTHORITY NtSidAuthority = SECURITY_NT_AUTHORITY;
    PSID pSid = NULL;
    if( !AllocateAndInitializeSid(
                  &NtSidAuthority,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS,
                  0, 0, 0, 0, 0, 0,
                  &pSid
                  ))
    {
        return FALSE;
    }

    //Lookup name
    m_szRemoteGroupName[0] = 0;

    DWORD cRemoteGroupName = MAX_PATH;
    WCHAR szDomainName[MAX_PATH+1];
    DWORD cDomainName = MAX_PATH;
    SID_NAME_USE eUse;
    if(!LookupAccountSidW(NULL,pSid,
        m_szRemoteGroupName,&cRemoteGroupName,
        szDomainName,&cDomainName,
        &eUse))
    {
        FreeSid(pSid);
        return FALSE;
    }
    FreeSid(pSid);

    //on the group
    //we trying to add 0 members to the group to see if it returns 
    //ACCESS DENIED
    NET_API_STATUS Result= NetLocalGroupAddMembers(NULL,m_szRemoteGroupName,0,NULL,0);

    if(Result == ERROR_ACCESS_DENIED)
    {
        *pbAccessDenied = TRUE;
    }
    
    m_bCanShowDialog = TRUE;
    return TRUE;
}

//*************************************************************
//
//  CRemoteUsersDialog::OnInitDialog()
//
//  Purpose:    Initializes m_hDlg variable
//
//  Parameters: HWND hDlg
//
//  Return:     NONE   
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              5/8/00    a-skuzin    Created
//
//*************************************************************
void 
CRemoteUsersDialog::OnInitDialog(
        IN HWND hDlg)
{
    m_hDlg = hDlg;
    
    m_szLocalCompName[0] = 0;
    DWORD cCompName = MAX_PATH;
    GetComputerNameW(m_szLocalCompName,&cCompName);

    //fill list of Remote Desktop Users
    m_hList = GetDlgItem(m_hDlg,IDC_REMOTE_USR_LIST);

    if(m_hList)
    {
    
        //create image list
        HIMAGELIST hImageList = ImageList_Create(GetSystemMetrics(SM_CXSMICON), 
                        GetSystemMetrics(SM_CYSMICON), ILC_MASK , 5, 1);
        if(hImageList)
        {
            HICON hIcon;
        
            hIcon = (HICON) LoadImage(m_hInst, MAKEINTRESOURCE(IDI_UNKNOWN), IMAGE_ICON,
                16, 16, 0);
            if (hIcon)
            {
                m_iUnknown = ImageList_AddIcon(hImageList, hIcon);
                DestroyIcon(hIcon);
            }

            hIcon = (HICON) LoadImage(m_hInst, MAKEINTRESOURCE(IDI_LOC_USER), IMAGE_ICON,
                16, 16, 0);
            if (hIcon)
            {
                m_iLocUser = ImageList_AddIcon(hImageList, hIcon);
                DestroyIcon(hIcon);
            }
        
            hIcon = (HICON) LoadImage(m_hInst, MAKEINTRESOURCE(IDI_GLOB_USER), IMAGE_ICON,
                16, 16, 0);
            if (hIcon)
            {
                m_iGlobUser = ImageList_AddIcon(hImageList, hIcon);
                DestroyIcon(hIcon);
            }

            hIcon = (HICON) LoadImage(m_hInst, MAKEINTRESOURCE(IDI_LOC_GROUP), IMAGE_ICON,
                16, 16, 0);
            if (hIcon)
            {
                m_iLocGroup = ImageList_AddIcon(hImageList, hIcon);
                DestroyIcon(hIcon);
            }

            hIcon = (HICON) LoadImage(m_hInst, MAKEINTRESOURCE(IDI_GLOB_GROUP), IMAGE_ICON,
                16, 16, 0);
            if (hIcon)
            {
                m_iGlobGroup = ImageList_AddIcon(hImageList, hIcon);
                DestroyIcon(hIcon);
            }

            ListView_SetImageList(m_hList,hImageList,LVSIL_SMALL);
        }

        ReloadList();
    }

    //If current user already has remote logon access,
    //remind it to him by showing corresponding text in the dialog.
    InitAccessMessage();

}

//*************************************************************
//
//  CRemoteUsersDialog::OnLink()
//
//  Purpose:   
//
//  Parameters: WPARAM wParam - ID of the link.
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              5/9/00    a-skuzin    Created
//
//*************************************************************
void 
CRemoteUsersDialog::OnLink(
        IN WPARAM wParam)
{
    switch(wParam)
    {
    case IDC_REMOTE_UPLINK:
        ShellExecute(NULL,TEXT("open"),TEXT("control"),TEXT("userpasswords"),NULL,SW_SHOW);
        break;
    default:
        break;
    }
}

//*************************************************************
//
//  CRemoteUsersDialog::OnOk()
//
//  Purpose:   
//
//  Parameters: NONE
//
//  Return:     TRUE if success
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
BOOL 
CRemoteUsersDialog::OnOk()
{
    if(m_hList)
    {
        //Apply members
        LOCALGROUP_MEMBERS_INFO_0 *plmi0 = NULL;
        DWORD entriesread;
        DWORD totalentries;
        NET_API_STATUS Result;
        Result = NetLocalGroupGetMembers(NULL,m_szRemoteGroupName,0,(LPBYTE *)&plmi0,
                        MAX_PREFERRED_LENGTH,&entriesread,&totalentries,NULL);

        if(Result == NERR_Success)
        {
        
            int j;
            LOCALGROUP_MEMBERS_INFO_0 lmi0;

            LVITEM lvi;
            lvi.iSubItem = 0;
            lvi.mask = LVIF_PARAM ;

            int iItems=ListView_GetItemCount(m_hList);

            BOOL *pbDoNotAdd = new BOOL[iItems];

            if(!pbDoNotAdd)
            {
                if(plmi0)
                {
                    NetApiBufferFree(plmi0);
                }
                //not enough memory - too bad
                return TRUE;
            }

            ZeroMemory(pbDoNotAdd,iItems*sizeof(BOOL));

            for(DWORD i=0;i<entriesread;i++)
            {
                j = FindItemBySid(plmi0[i].lgrmi0_sid);
                                
                //SID was not found in the list - delete member
                if(j == -1)
                {
                    lmi0.lgrmi0_sid = plmi0[i].lgrmi0_sid;

                    Result = NetLocalGroupDelMembers(NULL,m_szRemoteGroupName,0,(LPBYTE)&lmi0,1);
                    
                    if(Result !=NERR_Success)
                    {
                        delete pbDoNotAdd;
                        NetApiBufferFree(plmi0);
                        DisplayError(m_hInst, m_hDlg, Result, IDS_ERR_SAVE_MEMBERS, IDS_REMOTE_SESSIONS,
                            m_szRemoteGroupName, m_szLocalCompName);
                        return FALSE;
                    }
                }
                else
                {
                    pbDoNotAdd[j] = TRUE;
                }
                
            }

            //Add the rest of members to the group
            for(j=0;j<iItems;j++)
            {
                if(!pbDoNotAdd[j])
                {
                    lvi.iItem = j;
                    ListView_GetItem( m_hList, &lvi );
                    lmi0.lgrmi0_sid = (PSID) lvi.lParam;

                    Result = NetLocalGroupAddMembers(NULL,m_szRemoteGroupName,0,(LPBYTE)&lmi0,1);
                    
                    if(Result !=NERR_Success)
                    {
                        delete pbDoNotAdd;
                        NetApiBufferFree(plmi0);
                        DisplayError(m_hInst, m_hDlg, Result, IDS_ERR_SAVE_MEMBERS, IDS_REMOTE_SESSIONS,
                            m_szRemoteGroupName, m_szLocalCompName);
                        return FALSE;
                    }
                }
            }

            delete pbDoNotAdd;
            NetApiBufferFree(plmi0);
        }
        else
        {
            DisplayError(m_hInst, m_hDlg, Result, IDS_ERR_SAVE_MEMBERS, IDS_REMOTE_SESSIONS,
                m_szRemoteGroupName, m_szLocalCompName);
            return FALSE;
        }

        return TRUE;
    }

    return FALSE;
}

//*************************************************************
//
//  CRemoteUsersDialog::OnItemChanged()
//
//  Purpose:    Enables or disables "Remove" button. 
//
//  Parameters: lParam   -    
//
//  Return:     NONE
//
//  Comments:   in case of error shows message box
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
void 
CRemoteUsersDialog::OnItemChanged(
        LPARAM lParam)
{
    NMLISTVIEW* lv = reinterpret_cast<NMLISTVIEW*>(lParam);
    if (lv->uChanged & LVIF_STATE)
    {
        // a list item changed state
        BOOL selected = ListView_GetSelectedCount(m_hList) > 0;

        EnableWindow(GetDlgItem(m_hDlg, IDC_REMOTE_USR_REMOVE), selected);

        //If we disabled IDC_REMOTE_USR_REMOVE button while it had focus
        //all property page loses focus so "Tab" key does not
        //work anymore. We need to restore focus.
        if(!GetFocus())
        {
            SetFocus(m_hDlg);
        }
    
    }
}

//*************************************************************
//
//  CRemoteUsersDialog::OnDestroyWindow()
//
//  Purpose:    Frees memory allocated by member's SIDs 
//
//  Parameters: NONE
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
void
CRemoteUsersDialog::OnDestroyWindow()
{
    if(m_hList)
    {
        int iItems=ListView_GetItemCount(m_hList);

        LVITEM lvi;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_PARAM;
        
        while(iItems)
        {
            lvi.iItem = 0;
            ListView_GetItem( m_hList, &lvi );
            //delete item
            ListView_DeleteItem(m_hList, 0);
            if(lvi.lParam)
            {
                delete (LPVOID)lvi.lParam;
            }
            iItems--; //decrease item count
        }
    }
}

//*************************************************************
//
//  CRemoteUsersDialog::AddUsers()
//
//  Purpose:    adds users to the list
//
//  Parameters: NONE
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
void 
CRemoteUsersDialog::AddUsers()
{
    HRESULT hr = CoInitializeEx(NULL,COINIT_APARTMENTTHREADED);
    
    if(SUCCEEDED(hr))
    {
        IDsObjectPicker *pDsObjectPicker = NULL;
 
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                     NULL,
                     CLSCTX_INPROC_SERVER,
                     IID_IDsObjectPicker,
                     (void **) &pDsObjectPicker);

        if(SUCCEEDED(hr))
        {
        
            DSOP_INIT_INFO initInfo;
            memset(&initInfo, 0, sizeof(initInfo));

            initInfo.cbSize = sizeof(initInfo);
            initInfo.flOptions = DSOP_FLAG_MULTISELECT;

            // aliasing the computerName internal pointer here -- ok, as lifetime
            // of computerName > initInfo

            initInfo.pwzTargetComputer = NULL;

            initInfo.cAttributesToFetch = 1;
            PWSTR attrs[2] = {0, 0};
            attrs[0] = L"ObjectSID";

            // obtuse notation required to cast *in* const and away the static len

            initInfo.apwzAttributeNames = const_cast<PCWSTR*>(&attrs[0]); 
        
            if(getGroupMembershipPickerSettings(initInfo.aDsScopeInfos, initInfo.cDsScopeInfos))
            {

                IDataObject* pdo = NULL;

                if(SUCCEEDED(pDsObjectPicker->Initialize(&initInfo)) &&
                   pDsObjectPicker->InvokeDialog(m_hDlg, &pdo) == S_OK &&
                   pdo )
                {
                    CWaitCursor wait;

                    static const UINT cf = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

                    FORMATETC formatetc =
                     {
                        (CLIPFORMAT)cf,
                        0,
                        DVASPECT_CONTENT,
                        -1,
                        TYMED_HGLOBAL
                     };
        
                    STGMEDIUM stgmedium =
                     {
                        TYMED_HGLOBAL,
                        0
                     };

                    if(cf && SUCCEEDED(pdo->GetData(&formatetc, &stgmedium)))
                    {
        
                        PVOID lockedHGlobal = GlobalLock(stgmedium.hGlobal);

                        DS_SELECTION_LIST* selections =
                            reinterpret_cast<DS_SELECTION_LIST*>(lockedHGlobal);
        
                        AddPickerItems(selections);

                        GlobalUnlock(stgmedium.hGlobal);
                    }

                    pdo->Release();
                }

                delete initInfo.aDsScopeInfos;
            }

            pDsObjectPicker->Release();
        }

        CoUninitialize();
    }
}

//*************************************************************
//
//  CRemoteUsersDialog::RemoveUsers()
//
//  Purpose:    Removes users from the list
//
//  Parameters: NONE
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
void 
CRemoteUsersDialog::RemoveUsers()
{
    //delete all selected items
    if(m_hList)
    {

        int iItems=ListView_GetItemCount(m_hList);
        UINT uiState=0;
        int i=0;
        LVITEM lvi;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_STATE | LVIF_PARAM;
        lvi.stateMask = LVIS_SELECTED;

        while(i<iItems)
        {
            lvi.iItem = i;
            ListView_GetItem( m_hList, &lvi );
            if(lvi.state&LVIS_SELECTED)
            {
                //delete item
                ListView_DeleteItem(m_hList, i);
                if(lvi.lParam)
                {
                    delete (LPVOID)lvi.lParam;
                }
                iItems--; //decrease item count
                
            }
            else
            {
                i++;
            }
        }

        //If list is not empty, set focus on the first item.
        if( ListView_GetItemCount(m_hList) )
        {
            ListView_SetItemState(m_hList, 0, LVIS_FOCUSED, LVIS_FOCUSED );
        }
    }

}

//*************************************************************
//
//  CRemoteUsersDialog::IsLocal()
//
//  Purpose:    
//
//  Parameters: wszDomainandname   -  domain\user
//              determines whether the user is local or not
//              if local - cuts out domain name 
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
BOOL 
CRemoteUsersDialog::IsLocal(
        LPWSTR wszDomainandname)
{
    LPWSTR wszTmp = wcschr(wszDomainandname,L'\\');

    if(!wszTmp)
    {
        return TRUE;
    }

    if(!_wcsnicmp(wszDomainandname, m_szLocalCompName,wcslen(m_szLocalCompName) ))
    {
        //get rid of useless domain name
        wcscpy(wszDomainandname,wszTmp+1);
        return TRUE;
    }

    return FALSE;

}

//*************************************************************
//
//  CRemoteUsersDialog::AddPickerItems()
//
//  Purpose:    adds items, returned by DSObjectPicker
//              to the list
//
//  Parameters: IN DS_SELECTION_LIST *selections
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
void 
CRemoteUsersDialog::AddPickerItems(
        IN DS_SELECTION_LIST *selections)
{
    
    if(!selections)
    {
        return;
    }

    DS_SELECTION* current = &(selections->aDsSelection[0]);
    
    if(m_hList)
    {

        for (ULONG i = 0; i < selections->cItems; i++, current++)
        {
      
            // extract the ObjectSID of the object (this should always be
            // present)

            PSID pSid;
            HRESULT hr = VariantToSid(&current->pvarFetchedAttributes[0],&pSid);
        
            if( SUCCEEDED(hr) )
            {
                //This SID is not in the list
                //Let's add it.
                if(FindItemBySid(pSid) == -1)
                {
                    LPWSTR szFullName = NULL;
                    SID_NAME_USE eUse;

                    LVITEM item;
                    ZeroMemory(&item,sizeof(item));
                    item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                    
                    //put SID it into the item data
                    //the allocated memory will be freed in OnDestroyWindow()
                    item.lParam = (LPARAM)pSid;
                
                    if(LookupSid(pSid,&szFullName, &eUse))
                    {
                        item.pszText = szFullName;
                    }
                    else
                    {
                        eUse = SidTypeUnknown;
                        if(current->pwzName)
                        {
                            item.pszText = current->pwzName;
                        }
                        else
                        {
                            item.pszText = L"?";
                        }
                    }

                    switch(eUse)
                    {
                    case SidTypeUser:
                        item.iImage = IsLocal(szFullName) ? m_iLocUser : m_iGlobUser;
                        break;
                    case SidTypeGroup:
                        item.iImage = IsLocal(szFullName) ? m_iLocGroup : m_iGlobGroup;
                        break;
                    case SidTypeWellKnownGroup:
                        item.iImage = m_iLocGroup;
                        break;

                    default:
                        item.iImage = m_iUnknown;
                        break;
                    }

                    if(ListView_InsertItem(m_hList,&item) == -1)
                    {
                        delete pSid;
                    }

                    if(szFullName)
                    {
                        LocalFree(szFullName);
                    }
                }
                else
                {
                    //Free allocated memory
                    delete pSid;
                }
            }
        }
    }
}

//*************************************************************
//
//  CRemoteUsersDialog::FindItemBySid()
//
//  Purpose:    finds user with particular SID in the list
//
//  Parameters: pSid - SID to find
//
//  Return:     item index (-1 if not found)
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
int 
CRemoteUsersDialog::FindItemBySid(
        IN PSID pSid)
{
    if(m_hList)
    {
        LVITEM lvi;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_PARAM ;

        int iItems=ListView_GetItemCount(m_hList);

        for(int i=0;i<iItems;i++)
        {
            lvi.iItem = i;
            ListView_GetItem( m_hList, &lvi );
            PSID pItemSid = (PSID) lvi.lParam;
            if(pItemSid && EqualSid(pSid,pItemSid))
            {
                return i;
            }

        }
    }

    return -1;
}

//*************************************************************
//
//  CRemoteUsersDialog::ReloadList()
//
//  Purpose:    delete all items and then refill it with
//              names of members of "Remote Desktop Users" group.    
//
//  Parameters: NONE
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              12/27/00    skuzin     Created
//
//*************************************************************
void 
CRemoteUsersDialog::ReloadList()
{

    if(m_hList)
    {
        CWaitCursor wait;

        //first delete all items
        int iItems=ListView_GetItemCount(m_hList);

        LVITEM item;
        item.iSubItem = 0;
        item.mask = LVIF_PARAM;
        
        while(iItems)
        {
            item.iItem = 0;
            ListView_GetItem( m_hList, &item );
            //delete item
            ListView_DeleteItem(m_hList, 0);
            if(item.lParam)
            {
                delete (LPVOID)item.lParam;
            }
            iItems--; //decrease item count
        }

        LOCALGROUP_MEMBERS_INFO_2 *plmi2;
        DWORD entriesread;
        DWORD totalentries;
        NET_API_STATUS Result;
        Result = NetLocalGroupGetMembers(NULL,m_szRemoteGroupName,2,(LPBYTE *)&plmi2,
            MAX_PREFERRED_LENGTH,&entriesread,&totalentries,NULL);
        if(Result == NERR_Success || Result == ERROR_MORE_DATA )
        {
            
            for(DWORD i=0;i<entriesread;i++)
            {
                ZeroMemory(&item,sizeof(item));
                item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                item.pszText = plmi2[i].lgrmi2_domainandname;
                //create copy of the SID and put it in item data
                PSID pSid = (PSID)new BYTE[GetLengthSid(plmi2[i].lgrmi2_sid)];
                if(pSid)
                {
                    CopySid(GetLengthSid(plmi2[i].lgrmi2_sid),pSid,plmi2[i].lgrmi2_sid);
                    item.lParam = (LPARAM)pSid;
                }
                switch(plmi2[i].lgrmi2_sidusage)
                {
                case SidTypeUser:
                    item.iImage = IsLocal(plmi2[i].lgrmi2_domainandname) ? m_iLocUser : m_iGlobUser;
                    break;
                case SidTypeGroup:
                    item.iImage = IsLocal(plmi2[i].lgrmi2_domainandname) ? m_iLocGroup : m_iGlobGroup;
                    break;
                case SidTypeWellKnownGroup:
                    item.iImage = m_iLocGroup;
                    break;

                default:
                    item.iImage = m_iUnknown;
                    break;
                }

                if(ListView_InsertItem(m_hList,&item) == -1)
                {
                    if(pSid)
                    {
                        delete pSid;
                    }
                }
            }

            NetApiBufferFree(plmi2);
        }

        //If list is not empty, set focus on the first item.
        if( ListView_GetItemCount(m_hList) )
        {
            ListView_SetItemState(m_hList, 0, LVIS_FOCUSED, LVIS_FOCUSED );
        }
    }
}

//*************************************************************
//
//  CRemoteUsersDialog::InitAccessMessage()
//
//  Purpose:    Check if current user has remote logon access   
//              and if he does, show corresponding text in the dialog.
//
//  Parameters: NONE
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              01/04/01    skuzin     Created
//
//*************************************************************
void
CRemoteUsersDialog::InitAccessMessage()
{
    //First, get token handle
    HANDLE hToken = NULL, hToken1 = NULL;
    
    //Get Primary token
    if(!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_DUPLICATE , &hToken))
    {
        return;
    }
    
    //Get Impersonation token
    if(!DuplicateToken(hToken, SecurityIdentification, &hToken1))
    {
        CloseHandle(hToken);
        return;
    }

    CloseHandle(hToken);

    //Get RDP-Tcp WinStation security descriptor.
    PSECURITY_DESCRIPTOR pSD;

    if(GetRDPSecurityDescriptor(&pSD))
    {
        if(CheckWinstationLogonAccess(hToken1,pSD))
        {
            //Extract the name of the user from the token.
            LPWSTR szName = NULL;
            if(GetTokenUserName(hToken1,&szName))
            {
                //If user is local, remove domain name
                IsLocal(szName);

                //Assemble a text for the message.
                WCHAR szTemplate[MAX_PATH+1];
                HWND hMessage = GetDlgItem(m_hDlg,IDC_USER_HAS_ACCESS);    
                if(hMessage &&
                    LoadString(m_hInst,IDS_USER_HAS_ASSESS,szTemplate,MAX_PATH))
                {
                    LPWSTR szMessage = (LPWSTR) LocalAlloc(LPTR,
                        (wcslen(szTemplate)+wcslen(szName))*sizeof(WCHAR));
                    if(szMessage)
                    {
                        wsprintf(szMessage,szTemplate,szName);
                        SetWindowText(hMessage,szMessage);
                        
                        LocalFree(szMessage);
                    }
                }

                LocalFree(szName);
            }
        }
        LocalFree(pSD);    
    }
    
    CloseHandle(hToken1);
}

//*************************************************************
//
//  GetTokenUserName()
//
//  Purpose:    Extracts a user name from the token.
//
//  Parameters: IN HANDLE hToken
//              OUT LPWSTR *ppName 
//
//  Return:     TRUE - if success
//              FALSE - in case of any error
//
//  Comments:   Caller should free memory allocated for user name
//              using LocalFree function
//
//  History:    Date        Author     Comment
//              01/04/01    skuzin     Created
//
//*************************************************************
BOOL 
GetTokenUserName(
        IN HANDLE hToken,
        OUT LPWSTR *ppName)
{
    *ppName = NULL;

    DWORD dwReturnLength=0;
    BOOL  bResult = FALSE;
    PTOKEN_USER pTUser = NULL;

    if(!GetTokenInformation(hToken,TokenUser,NULL,0,&dwReturnLength) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER && 
        dwReturnLength)
    {
        pTUser = (PTOKEN_USER)LocalAlloc(LPTR,dwReturnLength);
        if(pTUser)
        {
            if(GetTokenInformation(hToken,TokenUser,pTUser,dwReturnLength,&dwReturnLength))
            {
                //Get current user 's name.
                LPWSTR szName = NULL;
                SID_NAME_USE eUse;
                
                return LookupSid(pTUser->User.Sid,ppName,&eUse);
            }

            LocalFree(pTUser);
            
        }
    }

    return FALSE;
}

//*************************************************************
//
//  GetRDPSecurityDescriptor()
//
//  Purpose:    Returns security descriptor for RDP-Tcp
//
//  Parameters: OUT PSECURITY_DESCRIPTOR *ppSD
//
//  Return:     TRUE - if success
//              FALSE - in case of any error
//
//  Comments:   Caller should free memory allocated for 
//              security descriptor using LocalFree function
//
//  History:    Date        Author     Comment
//              01/04/01    skuzin     Created
//
//*************************************************************
BOOL
GetRDPSecurityDescriptor(
        OUT PSECURITY_DESCRIPTOR *ppSD)
{
    *ppSD = NULL;

    if( FAILED( CoInitializeEx(NULL, COINIT_APARTMENTTHREADED) ) )
    {
        return FALSE;
    }

    ICfgComp *pCfgcomp;

    if( SUCCEEDED( CoCreateInstance( CLSID_CfgComp , NULL , CLSCTX_INPROC_SERVER , 
                    IID_ICfgComp , ( LPVOID *)&pCfgcomp ) ) )
    {
        LONG lSDsize;
        PSECURITY_DESCRIPTOR  pSD = NULL;

        if( SUCCEEDED( pCfgcomp->Initialize() ) &&
            SUCCEEDED( pCfgcomp->GetSecurityDescriptor( L"RDP-Tcp" , &lSDsize , &pSD ) ) )
        {
           *ppSD = pSD;
        }
    
        pCfgcomp->Release();
    }

    CoUninitialize();

    return (*ppSD != NULL);
}

//*************************************************************
//
//  CheckWinstationLogonAccess()
//
//  Purpose:    Tests access token for LOGON access to WinStation
//
//  Parameters: IN HANDLE hToken
//              IN PSECURITY_DESCRIPTOR pSD
//
//  Return:     TRUE - if user has access
//              FALSE - in case of any error or if user 
//                      does not have access
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              01/04/01    skuzin     Created
//
//*************************************************************
BOOL
CheckWinstationLogonAccess(
        IN HANDLE hToken,
        IN PSECURITY_DESCRIPTOR pSD)
{
    //this is taken from "termsrv\winsta\server\acl.c"
    //
    // Structure that describes the mapping of generic access rights to object
    // specific access rights for Window Station objects.
    //
    GENERIC_MAPPING WinStaMapping = {
        STANDARD_RIGHTS_READ |
            WINSTATION_QUERY,
        STANDARD_RIGHTS_WRITE |
            WINSTATION_SET,
        STANDARD_RIGHTS_EXECUTE,
            WINSTATION_ALL_ACCESS
    };
    
    PRIVILEGE_SET PrivilegeSet;
    //There are no privileges used for this access check
    //so we don't need to allocate additional memory
    DWORD dwPrivilegeSetLength = sizeof(PrivilegeSet);
    DWORD dwGrantedAccess = 0;
    BOOL bAccessStatus = FALSE;

    if(!AccessCheck(
          pSD, // SD
          hToken,                       // handle to client access token
          WINSTATION_LOGON,                      // requested access rights 
          &WinStaMapping,          // mapping
          &PrivilegeSet,              // privileges
          &dwPrivilegeSetLength,               // size of privileges buffer
          &dwGrantedAccess,                    // granted access rights
          &bAccessStatus                      // result of access check
        ) || !bAccessStatus )
    {
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
//
//  LookupSid()
//
//  Purpose:   Given SID allocates and returns string containing 
//             name of the user in format DOMAINNAME\USERNAME
//
//  Parameters: IN PSID pSid
//              OUT LPWSTR ppName 
//              OUT SID_NAME_USE *peUse   
//
//  Return:     TRUE if success, FALSE otherwise
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              10/23/00    skuzin     Created
//
//*************************************************************
BOOL
LookupSid(
    IN PSID pSid, 
    OUT LPWSTR *ppName,
    OUT SID_NAME_USE *peUse)
{
    LPWSTR szName = NULL;
    DWORD cName = 0;
    LPWSTR szDomainName = NULL;
    DWORD cDomainName = 0;
    
    *ppName = NULL;
    
    if(!LookupAccountSidW(NULL,pSid,
        szName,&cName,
        szDomainName,&cDomainName,
        peUse) && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        //cName and cDomainName include terminating 0
        *ppName = (LPWSTR)LocalAlloc(LPTR,(cName+cDomainName)*sizeof(WCHAR));

        if(*ppName)
        {
            szDomainName = *ppName;
            szName = &(*ppName)[cDomainName];

            if(LookupAccountSidW(NULL,pSid,
                    szName,&cName,
                    szDomainName,&cDomainName,
                    peUse))
            {
                //user name now in format DOMAINNAME\0USERNAME
                //let's replace '\0' with  '\\'
                //now cName and cDomainName do not include terminating 0
                //very confusing
                if(cDomainName)
                {
                    (*ppName)[cDomainName] = L'\\';
                }
                return TRUE;
            }
            else
            {
                LocalFree(*ppName);
                *ppName = NULL;
            }

        }

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\remotepage\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RemotePage.rc
//
#define IDI_REMOTE                      500
#define IDI_LOC_USER                    501
#define IDI_GLOB_USER                   502
#define IDI_LOC_GROUP                   503
#define IDI_GLOB_GROUP                  504
#define IDI_UNKNOWN                     505
#define IDD_REMOTE_PTS                  510
#define IDD_REMOTE_APPSERVER            511
#define IDD_DISABLE_OFFLINE_FILES       512
#define IDD_REMOTE_DESKTOP_USERS        513
#define IDD_REMOTE_PERSONAL             514
#define IDS_ERR_SAVE_REGISTRY           520
#define IDS_ERR_SAVE_MEMBERS            521
#define IDS_REMOTE_SESSIONS             522
#define IDS_WRN_NO_PERMISSIONS          523
#define IDS_OTHER_USERS                 524
#define IDS_USER_HAS_ASSESS             525
#define IDS_WRN_EMPTY_PASSWORD          526
#define IDS_PAGE_TITLE                  527
#define IDC_REMOTE_ENABLE               530
#define IDC_REMOTE_USR_LIST             531
#define IDC_REMOTE_USR_ADD              532
#define IDC_REMOTE_USR_REMOVE           533
#define IDC_REMOTE_UPLINK               534
#define IDC_REMOTE_GPLINK_APPSERVER     535
#define IDC_REMOTE_SCLINK_APPSERVER     536
#define IDC_OFFLINE_FILES               537
#define IDC_REMOTE_COMPNAME             538
#define IDC_REMOTE_HELP                 539
#define IDC_REMOTE_HELP_APPSERVER       540
#define IDC_REMOTE_SELECT_USERS         541
#define IDC_USER_HAS_ACCESS             542
#define IDC_DEFAULT1                    550
#define IDC_DEFAULT2                    551
#define IDC_DEFAULT3                    552
#define IDC_DEFAULT4                    553
#define IDC_DEFAULT5                    554
#define IDC_REMOTE_ASSISTANCE_ADVANCED  555
#define IDC_ENABLERA                    556
#define IDC_REMOTERA_HELP               557


// Title of the propertysheet, we choose a special ID since this will be accessed from the outside world
#define IDS_PROPSHEET_TITLE             10000


//Help message IDs
#define HIDC_REMOTE_ENABLE              15001    // (hook up to the "Allow users" checkbox)
#define HIDC_REMOTE_USR_LIST            15002    // (hook up to the "Remote Desktop Users" display window)
#define HIDC_REMOTE_USR_ADD             15003    // (hook up to the Add... button)
#define HIDC_REMOTE_USR_REMOVE          15004    // (hook up to the Remove button)

//Help message IDs for Remote Assistance setup
#define HIDC_RA_ADVANCED                15005
#define HIDC_RA_ENABLE                  15006
#define HIDC_RA_ALLOWUNSOLICIT          15007
#define HIDC_RA_ALLOWRC                 15008
#define HIDC_RA_EXPIRY                  15009

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        566
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           200
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\rwinsta\rwinsta.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*************************************************************************
*
*  RWINSTA.H
*     This module contains typedefs and defines for the RESET
*     WinStation utility.
*
*
*************************************************************************/

/*
 * Usage string definitions.
 */
#define USAGE \
L"Reset the session subsystem hardware and software to known initial values.\n\n" \
L"RESET SESSION {sessionname | sessionid} [/SERVER:servername] [/V]\n\n" \
L"  sessionname         Identifies the session with name sessionname.\n" \
L"  sessionid           Identifies the session with ID sessionid.\n" \
L"  /SERVER:servername  The server containing the session (default is current).\n" \
L"  /V                  Display additional information.\n\n"


/*
 * Token string definitions.
 */
#define TOKEN_WS                        L""
#define TOKEN_HELP                      L"/?"
#define TOKEN_VERBOSE                   L"/v"
#define TOKEN_SERVER                    L"/server"


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_WINSTATION_NOT_FOUND                  102
#define IDS_ERROR_INVALID_LOGONID                       103
#define IDS_ERROR_LOGONID_NOT_FOUND                     104
#define IDS_ERROR_WINSTATION_RESET_FAILED               105
#define IDS_ERROR_LOGONID_RESET_FAILED                  106
#define IDS_ERROR_SERVER                                107

#define IDS_RESET_WINSTATION                            200
#define IDS_RESET_LOGONID                               201
#define IDS_RESET_WINSTATION_DONE                       202
#define IDS_RESET_LOGONID_DONE                          203
#define IDS_WARNING_LOGOFF                              204
#define IDS_WARNING_LOGOFF_QUESTIONABLE                 205
#define IDS_ERROR_NOT_TS                                206

#define IDS_USAGE_1                                     301
#define IDS_USAGE_2                                     302
#define IDS_USAGE_3                                     303
#define IDS_USAGE_4                                     304
#define IDS_USAGE_5                                     305
#define IDS_USAGE_6                                     306
#define IDS_USAGE_7                                     307
#define IDS_USAGE_8                                     308
#define IDS_USAGE_9                                     309
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\rwinsta\rwinsta.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*************************************************************************
*
*  RWINSTA.C
*     This module is the RESET WINSTA utility code.
*
*
*************************************************************************/

#include <stdio.h>
#include <windows.h>
//#include <ntddkbd.h>
//#include <ntddmou.h>
#include <winstaw.h>
#include <stdlib.h>
#include <utilsub.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <winnlsp.h>

#include "rwinsta.h"
#include <printfoa.h>


// max length of the locale string
#define MAX_LOCALE_STRING 64


WINSTATIONNAME WSName;
USHORT help_flag = FALSE;
USHORT v_flag    = FALSE;
HANDLE hServerName = SERVERNAME_CURRENT;
WCHAR  ServerName[MAX_IDS_LEN+1];

TOKMAP ptm[] =
{
#define TERM_PARM 0
   {TOKEN_WS,       TMFLAG_REQUIRED, TMFORM_S_STRING,
                        WINSTATIONNAME_LENGTH, WSName},

   {TOKEN_SERVER,   TMFLAG_OPTIONAL, TMFORM_STRING,
                        MAX_IDS_LEN, ServerName},

   {TOKEN_HELP,     TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                        sizeof(USHORT), &help_flag},

   {TOKEN_VERBOSE,  TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                        sizeof(USHORT), &v_flag},

   {0, 0, 0, 0, 0}
};


/*
 * Local function prototypes.
 */
void Usage( BOOLEAN bError );
BOOL ProceedWithLogoff(HANDLE hServerName,ULONG LogonId,PWINSTATIONNAME pWSName);


/*************************************************************************
*
*  main
*     Main function and entry point of the RESET WINSTA
*     utility.
*
*  ENTRY:
*     argc  - count of the command line arguments.
*     argv  - vector of strings containing the command line arguments.
*
*  EXIT
*     Nothing.
*
*************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    int   rc, i;
    ULONG Error;
    WCHAR **argvW, *endptr;
    ULONG LogonId;
    WCHAR wszString[MAX_LOCALE_STRING + 1];

    setlocale(LC_ALL, ".OCP");

    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);
    
    SetThreadUILanguage(0);

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || rc ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

        // If no remote server was specified, then check if we are running under Terminal Server
        if ((!IsTokenPresent(ptm, TOKEN_SERVER) ) && (!AreWeRunningTerminalServices()))
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }

    /*
     * Validate, reset, and output status.
     */
    if ( !iswdigit(*WSName) ) {

        /*
         * Treat the entered string as a WinStation name.
         */
        if ( !LogonIdFromWinStationName(hServerName, WSName, &LogonId) ) {
            StringErrorPrintf(IDS_ERROR_WINSTATION_NOT_FOUND, WSName);
            return(FAILURE);
        }

        if(!ProceedWithLogoff(hServerName,LogonId,WSName))
           return (SUCCESS);

        if ( v_flag )
            StringMessage(IDS_RESET_WINSTATION, WSName);

        if ( !WinStationReset(hServerName, LogonId, TRUE) ) {
            Error = GetLastError();
            StringDwordErrorPrintf(IDS_ERROR_WINSTATION_RESET_FAILED, WSName, Error);
            PutStdErr( Error, 0 );
            return(FAILURE);
        }

        if ( v_flag )
            StringMessage(IDS_RESET_WINSTATION_DONE, WSName);

    } else {

        /*
         * Treated the entered string as a LogonId.
         */
        LogonId = wcstoul(WSName, &endptr, 10);
        if ( *endptr ) {
            StringErrorPrintf(IDS_ERROR_INVALID_LOGONID, WSName);
            return(FAILURE);
        }
        if ( !WinStationNameFromLogonId(hServerName, LogonId, WSName) ) {
            ErrorPrintf(IDS_ERROR_LOGONID_NOT_FOUND, LogonId);
            return(FAILURE);
        }

        if(!ProceedWithLogoff(hServerName,LogonId,WSName))
           return (SUCCESS);

        if ( v_flag )
            Message(IDS_RESET_LOGONID, LogonId);

        if ( !WinStationReset(hServerName, LogonId, TRUE) ) {
            Error = GetLastError();
            ErrorPrintf(IDS_ERROR_LOGONID_RESET_FAILED, LogonId, Error);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }

        if ( v_flag )
            Message(IDS_RESET_LOGONID_DONE, LogonId);
    }

    return(SUCCESS);

} /* main() */


/*******************************************************************************
 *
 *  ProcessWithLogoff
 *
 *      If LogonId does not have a corresponding UserName then a warning
 *      message is displayed.
 *
 *  ENTRY:
 *      hServerName : Handle to server
 *      LogonId     : ID as shown in qwinsta
 *      pWSName     : Session Name
 *
 *  EXIT:
 *       TRUE : User wants to logoff
 *       FALSE: User does not want to proceed with logoff
 *
 *
 ******************************************************************************/
BOOL ProceedWithLogoff(HANDLE hServerName,ULONG LogonId,PWINSTATIONNAME pWSName)
{
   #ifdef UNICODE
   #define GetStdInChar getwchar
   wint_t ch;
   #else
   #define GetStdInChar getchar
   int ch;
   #endif

   WINSTATIONINFORMATION WinInfo;
   ULONG ReturnLength;
   int rc;

   // No-session Name, No-Problem
   if(lstrlen(pWSName) == 0) return (TRUE);

   memset(&WinInfo,0,sizeof(WINSTATIONINFORMATION));
   rc = WinStationQueryInformation( hServerName,
                                    LogonId,
                                    WinStationInformation,
                                    (PVOID)&WinInfo,
                                    sizeof(WINSTATIONINFORMATION),
                                    &ReturnLength);

   // Try to show message only if necessary
   if( rc && (sizeof(WINSTATIONINFORMATION) == ReturnLength) ) {
      if(lstrlen(WinInfo.UserName) == 0) {
         ErrorPrintf(IDS_WARNING_LOGOFF);
         rc = GetStdInChar();
         if(rc == L'n') return(FALSE);
      }
   }
   // Failed on call - assume nothing and prompt with message
   else{
      ErrorPrintf(IDS_WARNING_LOGOFF_QUESTIONABLE);
      rc = GetStdInChar();
      if(rc == L'n') return(FALSE);
   }
   return (TRUE);
}

/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 *  EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {

        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_USAGE_1);
        ErrorPrintf(IDS_USAGE_2);
        ErrorPrintf(IDS_USAGE_3);
        ErrorPrintf(IDS_USAGE_4);
        ErrorPrintf(IDS_USAGE_5);
        ErrorPrintf(IDS_USAGE_6);
        ErrorPrintf(IDS_USAGE_7);
        ErrorPrintf(IDS_USAGE_8);
        ErrorPrintf(IDS_USAGE_9);

    } else {

        Message(IDS_USAGE_1);
        Message(IDS_USAGE_2);
        Message(IDS_USAGE_3);
        Message(IDS_USAGE_4);
        Message(IDS_USAGE_5);
        Message(IDS_USAGE_6);
        Message(IDS_USAGE_7);
        Message(IDS_USAGE_8);
        Message(IDS_USAGE_9);

    }

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\reset\reset.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/******************************************************************************
*
*  RESET.H
*
*   This module contains typedefs and defines required for the RESET utility
*   menu.
*
*  
******************************************************************************/

/*
 * Usage string definitions.
 */
#define UTILITY_NAME    L"RESET"


/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_REGISTRY_FAILURE                      102
#define IDS_ERROR_NOT_TS                                103
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\reset\reset.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*************************************************************************
*
*  RESET.C
*     This module is the RESET utility code.
*
*
*************************************************************************/

#include <stdio.h>
#include <windows.h>
//#include <ntddkbd.h>
//#include <ntddmou.h>
#include <winstaw.h>
#include <regapi.h>
#include <stdlib.h>
#include <time.h>
#include <utilsub.h>
#include <process.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <winnlsp.h>

#include "reset.h"


// max length of the locale string
#define MAX_LOCALE_STRING 64


/*-----------------------------------------------------------------------
-- Supported commands (now obtained from registry)
------------------------------------------------------------------------*/
PPROGRAMCALL pProgList = NULL;

/*
 * Local function prototypes.
 */
void Usage( BOOLEAN bError );



/*************************************************************************
*
*  main
*     Main function and entry point of the text-based RESET
*     menu utility.
*
*  ENTRY:
*       argc (input)
*           count of the command line arguments.
*       argv (input)
*           vector of strings containing the command line arguments;
*           (not used due to always being ANSI strings).
*
*  EXIT
*       (int) exit code: SUCCESS for success; FAILURE for error.
*
*************************************************************************/

int __cdecl
main( INT argc,
      CHAR **argv )
{
    PWCHAR        arg, *argvW;
    PPROGRAMCALL  pProg, pProgramCall = NULL;
    size_t        len;
    int           status = FAILURE;
    LONG          regstatus;
    WCHAR         wszString[MAX_LOCALE_STRING + 1];

    setlocale(LC_ALL, ".OCP");

    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);
    
    SetThreadUILanguage(0);

    /*
     * Obtain the supported RESET commands from registry.
     */
    if ( (regstatus =
            RegQueryUtilityCommandList( UTILITY_REG_NAME_RESET, &pProgList ))
            != ERROR_SUCCESS ) {

        ErrorPrintf(IDS_ERROR_REGISTRY_FAILURE, UTILITY_NAME, regstatus);
        goto exit;
    }

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        goto exit;
    }

    /*
     * Check for valid utility name and execute.
     */
    if ( argc > 1 && *(argvW[1]) ) {

        len = wcslen(arg = argvW[1]);
        for ( pProg = pProgList->pFirst; pProg != NULL; pProg = pProg->pNext ) {

            if ( (len >= pProg->CommandLen) &&
                 !_wcsnicmp( arg, pProg->Command, len ) ) {

                pProgramCall = pProg;
                break;
            }
        }

        if ( pProgramCall ) {

                if ( ExecProgram(pProgramCall, argc - 2, &argvW[2]) )
                goto exit;

        } else if ( ((arg[0] == L'-') || (arg[0] == L'/')) &&
                    (arg[1] == L'?') ) {

            /*
             * Help requested.
             */
            Usage(FALSE);
            status = SUCCESS;
            goto exit;

        } else {

            /*
             * Bad command line.
             */
            Usage(TRUE);
            goto exit;
        }

    } else {

        /*
         * Nothing on command line.
         */
        Usage(TRUE);
        goto exit;
    }

exit:
    if ( pProgList )
        RegFreeUtilityCommandList(pProgList);   // let's be tidy

    return(status);

} /* main() */


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }

    ProgramUsage(UTILITY_NAME, pProgList, bError);

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\shadow\shadow.h ===
/***********************************************************************
*
*  SHADOW.H
*     This module contains typedefs and defines required for
*     the SHADOW utility.
*
*  Copyright Citrix Systems Inc. 1994
* 
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   scottn  $  Butch Davis
*
* $Log:   T:\nt\private\utils\citrix\shadow\VCS\shadow.h  $
*  
*     Rev 1.7   30 Oct 1997 21:02:52   scottn
*  A few MS changes
*
*     Rev 1.6   10 Oct 1997 00:48:28   scottn
*  Make help like MS.
*
*     Rev 1.5   Oct 07 1997 09:31:02   billm
*  change winstation to session
*
*     Rev 1.4   07 Feb 1997 15:56:56   bradp
*  update
*
*     Rev 1.3   11 Sep 1996 09:21:46   bradp
*  update
*
*     Rev 1.2   22 Feb 1995 13:52:04   butchd
*  update
*
*     Rev 1.1   16 Dec 1994 17:15:54   bradp
*  update
*
*     Rev 1.0   29 Apr 1994 13:11:02   butchd
*  Initial revision.
*
*************************************************************************/

/*
 * Token string definitions.
 */
#define TOKEN_WS                        L""
#define TOKEN_TIMEOUT                   L"/timeout"
#define TOKEN_VERBOSE                   L"/v"
#define TOKEN_HELP                      L"/?"
#define TOKEN_SERVER                    L"/server"

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_NAME 256            // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_WINSTATION_NOT_FOUND                  102
#define IDS_ERROR_INVALID_LOGONID                       103
#define IDS_ERROR_LOGONID_NOT_FOUND                     104
#define IDS_ERROR_SHADOW_FAILURE                        105
#define IDS_ERROR_SERVER                                106

#define IDS_SHADOWING_WINSTATION                        200
#define IDS_SHADOWING_LOGONID                           201
#define IDS_SHADOWING_DONE                              202
#define IDS_ERROR_NOT_TS                                203
#define IDS_SHADOWING_WARNING                           204

#define IDS_USAGE_1                                     300
#define IDS_USAGE_2                                     301
#define IDS_USAGE_3                                     302
#define IDS_USAGE_4                                     303
#define IDS_USAGE_5                                     304
#define IDS_USAGE_6                                     305
#define IDS_USAGE_7                                     306
#define IDS_USAGE_8                                     307
#define IDS_USAGE_9                                     308
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\shadow\shadow.c ===
/*************************************************************************
*
* shadow.c
*
* Shadow utility
*
* Copyright 1994, Citrix Systems Inc.
*
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   tyl  $  Mike Discavage
*
* $Log:   N:\nt\private\utils\citrix\shadow\VCS\shadow.c  $
*
*     Rev 1.20   May 04 1998 17:37:40   tyl
*  bug 2019 - oem to ansi
*
*     Rev 1.19   Jun 26 1997 18:25:40   billm
*  move to WF40 tree
*
*     Rev 1.18   23 Jun 1997 15:39:22   butchd
*  update
*
*     Rev 1.17   15 Feb 1997 15:57:34   miked
*  update
*
*     Rev 1.16   07 Feb 1997 15:56:54   bradp
*  update
*
*     Rev 1.15   13 Nov 1996 17:14:40   miked
*  update
*
*     Rev 1.14   30 Sep 1996 08:34:28   butchd
*  update
*
*     Rev 1.13   11 Sep 1996 09:21:44   bradp
*  update
*
*
*************************************************************************/

#define NT

/*
 *  Includes
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>

#include <windows.h>
#include <winnlsp.h>

// #include <ntddkbd.h>
// #include <ntddmou.h>
#include <winsta.h>

#include <utilsub.h>

#include <kbd.h> // for KBDCTRL                                    KLB 07-15-95

#include "shadow.h"
#include "printfoa.h"


// max length of the locale string
#define MAX_LOCALE_STRING 64


/*
 * Global variables
 */
USHORT help_flag = FALSE;
USHORT v_flag = FALSE;
WINSTATIONNAME WSName;
ULONG LogonId;
ULONG Timeout;  // timeout in seconds
HANDLE hServerName = SERVERNAME_CURRENT;
WCHAR  ServerName[MAX_NAME+1];


TOKMAP ptm[] = {
      {TOKEN_WS,            TMFLAG_REQUIRED, TMFORM_STRING,
                                WINSTATIONNAME_LENGTH, WSName },

      {TOKEN_SERVER,        TMFLAG_OPTIONAL, TMFORM_STRING,
                                 MAX_NAME, ServerName },

      {TOKEN_TIMEOUT,       TMFLAG_OPTIONAL, TMFORM_ULONG,
                                sizeof(ULONG), &Timeout },

      {TOKEN_VERBOSE,       TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                                sizeof(USHORT), &v_flag },

      {TOKEN_HELP,          TMFLAG_OPTIONAL, TMFORM_BOOLEAN,
                                sizeof(USHORT), &help_flag },

      {0, 0, 0, 0, 0}
};


/*
 * Private function prototypes.
 */
void Usage(BOOLEAN bError);



/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main( INT argc, CHAR **argv )
{
    WCHAR *CmdLine;
    WCHAR **argvW, *endptr;
    ULONG rc;
    int i;
    BOOLEAN Result;
    WCHAR   wszString[MAX_LOCALE_STRING + 1];

    setlocale(LC_ALL, ".OCP");
    
    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);

    SetThreadUILanguage(0);

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || rc ) {

        if ( !help_flag ) {
            Usage(TRUE);
            return(FAILURE);

        } else {
            Usage(FALSE);
            return(SUCCESS);
        }
    }

        //Check if we are running under Terminal Server
        if(!AreWeRunningTerminalServices())
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }

    /*
     * Validate the shadowee.
     */
    if ( !iswdigit(*WSName) ) {

        /*
         * Treat the entered string as a WinStation name.
         *
         */

        if ( !LogonIdFromWinStationName(hServerName, WSName, &LogonId) ) {
            StringErrorPrintf(IDS_ERROR_WINSTATION_NOT_FOUND, WSName);
            return(FAILURE);
        }

        Message(IDS_SHADOWING_WARNING);
        if ( v_flag )
            StringMessage(IDS_SHADOWING_WINSTATION, WSName);

    } else {

        /*
         * Treated the entered string as a LogonId.
         */
        LogonId = wcstoul(WSName, &endptr, 10);
        if ( *endptr ) {                            
            StringErrorPrintf(IDS_ERROR_INVALID_LOGONID, WSName);
            return(FAILURE);
        }
        if ( !WinStationNameFromLogonId(hServerName, LogonId, WSName) ) {
            ErrorPrintf(IDS_ERROR_LOGONID_NOT_FOUND, LogonId);
            return(FAILURE);
        }

        Message(IDS_SHADOWING_WARNING);
        if ( v_flag )
            Message(IDS_SHADOWING_LOGONID, LogonId);
    }

    // Let the warning be displayed
    Sleep(500);

    /*
     * Start shadowing.
     */
    if ( IsTokenPresent(ptm, TOKEN_TIMEOUT) ) {
        Result = WinStationShadow( SERVERNAME_CURRENT,
                                   ServerName,
                                   LogonId,
                                   (BYTE)Timeout,
                                   (WORD)-1);
    } else {
        Result = WinStationShadow( SERVERNAME_CURRENT,
                                   ServerName,
                                   LogonId,
                                   VK_MULTIPLY,
                                   KBDCTRL ); // ctrl-*
    }

    /*
     * Return success or failure.
     */
    if ( !Result ) {

        ErrorPrintf(IDS_ERROR_SHADOW_FAILURE, GetLastError());
        PutStdErr( GetLastError(), 0 );
        return(FAILURE);

    } else {

        if ( v_flag )
            Message(IDS_SHADOWING_DONE);

        return(SUCCESS);
    }

}  /* main() */



/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 * EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {

        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        ErrorPrintf(IDS_USAGE_1);
        ErrorPrintf(IDS_USAGE_2);
        ErrorPrintf(IDS_USAGE_3);
        ErrorPrintf(IDS_USAGE_4);
        ErrorPrintf(IDS_USAGE_5);
        ErrorPrintf(IDS_USAGE_6);
        ErrorPrintf(IDS_USAGE_7);
        ErrorPrintf(IDS_USAGE_8);
        ErrorPrintf(IDS_USAGE_9);

    } else {

        Message(IDS_USAGE_1);
        Message(IDS_USAGE_2);
        Message(IDS_USAGE_3);
        Message(IDS_USAGE_4);
        Message(IDS_USAGE_5);
        Message(IDS_USAGE_6);
        Message(IDS_USAGE_7);
        Message(IDS_USAGE_8);
        Message(IDS_USAGE_9);
    }

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\shutdown\tsshutdn.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*************************************************************************
*
*  TSSHUTDN.H
*     This module contains typedefs and defines for the TSSHUTDN utility.
*
*
*************************************************************************/



/*
 * Token string definitions.
 */
#define TOKEN_TIME                      L" "
#define TOKEN_HELP                      L"/?"
#define TOKEN_VERBOSE                   L"/v"
#define TOKEN_REBOOT                    L"/reboot"
#define TOKEN_POWERDOWN                 L"/powerdown"
#define TOKEN_FAST                      L"/now"

#if 0
#define TOKEN_DUMP                      L"/dump"
#endif

#define TOKEN_SERVER                    L"/server"
#define TOKEN_DELAY                     L"/delay"

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_INVALID_TIME                          102
#define IDS_ERROR_SHUTDOWN_FAILED                       103
#define IDS_SHUTTING_DOWN                               104
#define IDS_SHUTDOWN_DONE                               105
#define IDS_SHUTDOWN_REBOOT                             106
#define IDS_SHUTDOWN_POWERDOWN                          107
#define IDS_SHUTDOWN_WRITEPROT                          108
#define IDS_ERROR_SERVER                                109
#define IDS_LOGOFF_USERS                                110
#define IDS_ERROR_INVALID_DELAY                         111
#define IDS_ERROR_NO_RIGHTS                             112
#define IDS_NOTIFYING_USERS                             113
#define IDS_SENDING_WINSTATION                          114
#define IDS_ERROR_SENDING_WINSTATION                    115
#define IDS_SHUTDOWN_TITLE                              116
#define IDS_SHUTDOWN_MESSAGE                            117
#define IDS_USAGE                                       118
#define IDS_ERROR_NOT_TS								119
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\cfgcomp\cfgbkend.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*********************************************************************************************
*
*
* Module Name:
*
*                       CfgBkEnd.cpp
*
* Abstract:
*                       This Module is generated by the ATL Wizard. This has the
*                       the exported functiond DllGetClassObject,DllRegisterServer
*                       DllUnRegisterServer, DllCanUnloadNow
*
*
* Author:
*
*
* Revision:
*
*
************************************************************************************************/


// Note: Proxy/Stub Information
//              To build a separate proxy/stub DLL,
//              run nmake -f CfgBkEndps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "CfgBkEnd.h"

#include "CfgBkEnd_i.c"
#include "PtrArray.h"
#include <winsta.h>
#include <regapi.h>
#include "Defines.h"
#include "CfgComp.h"


CComModule _Module;
HINSTANCE g_hInstance;

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_CfgComp, CCfgComp)
END_OBJECT_MAP()

/**************************************************************************************/
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
        if (dwReason == DLL_PROCESS_ATTACH)
        {
        _Module.Init(ObjectMap, hInstance);

                DisableThreadLibraryCalls(hInstance);

                g_hInstance = hInstance;
        }
        else if (dwReason == DLL_PROCESS_DETACH)
                _Module.Term();
        return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

extern "C"
STDAPI DllCanUnloadNow(void)
{
        return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
extern "C"
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
        return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
        // registers object, typelib and all interfaces in typelib
    // except we don't need to register a typelib pass in false
    // alhen
        return _Module.RegisterServer( FALSE );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
        _Module.UnregisterServer();
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\shutdown\tsshutdn.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*************************************************************************
*
*  TSSHUTDN.C
*     This module is the TSSHUTDN utility code.
*
*
*************************************************************************/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>

#include <stdio.h>
#include <wchar.h>
#include <windows.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <stdlib.h>
#include <utilsub.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <winnlsp.h>

#include "tsshutdn.h"
#include "printfoa.h"


// max length of the locale string
#define MAX_LOCALE_STRING 64

#define DEFAULT_WAIT_TIME  60
#define DEFAULT_LOGOFF_DELAY 30
#define MAX_MESSAGE_LENGTH 256

WCHAR  WSTime[MAX_IDS_LEN+2];
WCHAR  WDTime[MAX_IDS_LEN+2];
USHORT help_flag = FALSE;
USHORT v_flag    = FALSE;
USHORT RebootFlag = FALSE;
USHORT PowerDownFlag = FALSE;
USHORT FastFlag = FALSE;
#if 0
USHORT DumpFlag = FALSE;
#endif
HANDLE hServerName = SERVERNAME_CURRENT;
WCHAR  ServerName[MAX_IDS_LEN+1];

TOKMAP ptm[] =
{
   {TOKEN_TIME,     TMFLAG_OPTIONAL, TMFORM_S_STRING, MAX_IDS_LEN, WSTime},

   {TOKEN_SERVER,   TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN, ServerName},

   {TOKEN_DELAY,    TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN, WDTime},

   {TOKEN_HELP,     TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},

   {TOKEN_VERBOSE,  TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &v_flag},

   {TOKEN_REBOOT,   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &RebootFlag},

   {TOKEN_POWERDOWN,TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &PowerDownFlag},

   {TOKEN_FAST,     TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &FastFlag},

#if 0
   {TOKEN_DUMP,     TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &DumpFlag},
#endif

   {0, 0, 0, 0, 0}
};


/*
 * Local function prototypes.
 */
void Usage( BOOLEAN bError );
void NotifyUsers( ULONG WaitTime );
void NotifyWinStations( PLOGONIDW, ULONG, ULONG );
BOOLEAN CheckShutdownPrivilege();



/*************************************************************************
*
*  main
*     Main function and entry point of the TSSHUTDN utility.
*
*  ENTRY:
*     argc  - count of the command line arguments.
*     argv  - vector of strings containing the command line arguments.
*
*  EXIT
*     Nothing.
*
*************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    int   rc, i;
    ULONG Error;
    WCHAR *CmdLine;
    WCHAR **argvW, *endptr;
    ULONG ShutdownFlags = WSD_SHUTDOWN | WSD_LOGOFF;
    ULONG WaitTime = DEFAULT_WAIT_TIME;
    ULONG LogoffDelay = DEFAULT_LOGOFF_DELAY;
    WCHAR wszString[MAX_LOCALE_STRING + 1];

    setlocale(LC_ALL, ".OCP");

    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);
    
    SetThreadUILanguage(0);

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    WSTime[0] = L'\0';
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || (rc && !(rc & PARSE_FLAG_NO_PARMS)) ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

        // If no remote server was specified, then check if we are running under Terminal Server
        if ((!IsTokenPresent(ptm, TOKEN_SERVER) ) && (!AreWeRunningTerminalServices()))
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }

    // Make sure the user has the proper privilege
    // SM should really do the check
    /*
    if( !CheckShutdownPrivilege() ) {
        ErrorPrintf(IDS_ERROR_NO_RIGHTS);
        return(FAILURE);
    }
    */

    // Make sure its a number
    if ( WSTime[0] ) {

        if( !iswdigit(WSTime[0]) ) {
            StringErrorPrintf(IDS_ERROR_INVALID_TIME, WSTime);
            return(FAILURE);
        }

        WaitTime = wcstoul(WSTime, &endptr, 10);
        if ( *endptr ) {
            StringErrorPrintf(IDS_ERROR_INVALID_TIME, WSTime);
            return(FAILURE);
        }
    }

    // Make sure its a number
    if ( WDTime[0] ) {

        if( !iswdigit(WDTime[0]) ) {
            StringErrorPrintf(IDS_ERROR_INVALID_DELAY, WDTime);
            return(FAILURE);
        }

        LogoffDelay = wcstoul(WDTime, &endptr, 10);
        if ( *endptr ) {
            StringErrorPrintf(IDS_ERROR_INVALID_DELAY, WDTime);
            return(FAILURE);
        }
    }

#if 0
    /*
     * If /dump option was specified, call NT function directly
     */
    if ( DumpFlag ) {
        NtShutdownSystem( ShutdownDump );   // will not return
    }
#endif

    if( RebootFlag ) {
        ShutdownFlags |= WSD_REBOOT;
    }

    if( PowerDownFlag )
        ShutdownFlags |= WSD_POWEROFF;

    if( FastFlag ) {
        ShutdownFlags |= WSD_FASTREBOOT;
        ShutdownFlags &= ~WSD_LOGOFF;
        WaitTime = 0;
    }

    if( WaitTime ) {
        NotifyUsers( WaitTime );
    }

    /*
     * If necessary, force all WinStations to logoff
     */
    if ( ShutdownFlags & WSD_LOGOFF ) {
        Message( IDS_SHUTTING_DOWN, 0 );
        if ( !WinStationShutdownSystem( hServerName, WSD_LOGOFF ) ) {
            Error = GetLastError();
            ErrorPrintf( IDS_ERROR_SHUTDOWN_FAILED, Error );
            PutStdErr( Error, 0 );
            return( FAILURE );
        }
        Message( IDS_LOGOFF_USERS, 0);
        if (LogoffDelay) {
            NotifyUsers( LogoffDelay );
        }
        Message( IDS_SHUTDOWN_DONE, 0 );
    }

    /*
     * Inform user of impending reboot/poweroff
     */
    if ( ShutdownFlags & WSD_REBOOT ) {
        Message( IDS_SHUTDOWN_REBOOT, 0 );
        Sleep( 4000 );
    } else if ( ShutdownFlags & WSD_POWEROFF ) {
        Message( IDS_SHUTDOWN_POWERDOWN, 0 );
        Sleep( 4000 );
    }

    /*
     * Perform system shutdown, reboot, or poweroff, depending on flags
     */
    if( WinStationShutdownSystem( hServerName, ShutdownFlags & ~WSD_LOGOFF ) != ERROR_SUCCESS )
    {
        PutStdErr( GetLastError(), 0 );
    }

    // WinStationShutdownSystem is done asynchronously.
    // No way to know when the shudown is completed.
    //if ( !(ShutdownFlags & WSD_REBOOT) && !( ShutdownFlags & WSD_POWEROFF ) ) {
    //    /*
    //     * If we get here, shutdown is complete, all disks are write protected.
    //     */
    //    Message(IDS_SHUTDOWN_WRITEPROT, 0);
    //}

    return(SUCCESS);

} /* main() */


/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 *  EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    WCHAR sz1[1024];
    LoadString( NULL, IDS_USAGE, sz1, 1024 );
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
        fwprintf(stderr, sz1);

    } else {

        fwprintf(stdout,sz1);
    }

}  /* Usage() */


/*****************************************************************************
 *
 *  NotifyUsers
 *
 *   Notify Users that the system is being shutdown
 *
 * ENTRY:
 *   WaitTime (input)
 *     Amount of time to give them to log off.
 *
 * EXIT:
 *
 ****************************************************************************/

void
NotifyUsers( ULONG WaitTime )
{
    BOOLEAN Result;
    ULONG Entries;
    ULONG Error;
    PLOGONIDW ptr;

    //
    // Get all of the WinStations call the function to notify them.
    //
    if ( WinStationEnumerateW( hServerName, &ptr, &Entries ) ) {

        NotifyWinStations( ptr, Entries, WaitTime );
        WinStationFreeMemory(ptr);

    } else {

        Error = GetLastError();
#if DBG
        printf("TSSHUTDN: Error emumerating Sessions %d\n",Error);
#endif
        return;
    }

    Message(IDS_NOTIFYING_USERS);

    // Now wait the wait time
    SleepEx( WaitTime*1000, FALSE );

    return;
}

/*****************************************************************************
 *
 *  NotifyWinStations
 *
 *   Notify the group of WinStations about the impending system shutdown
 *
 * ENTRY:
 *   pId (input)
 *     Array of LOGONIDW's
 *
 *   Entries (input)
 *     Number of entries in array
 *
 *   WaitTime (input)
 *     Amount of time to wait in seconds
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

void
NotifyWinStations(
    PLOGONIDW pId,
    ULONG     Entries,
    ULONG     WaitTime
    )
{
    ULONG Index;
    PLOGONIDW p;
    ULONG Response;
    BOOLEAN Result;
    WCHAR mBuf[MAX_MESSAGE_LENGTH+2];
//    PWCHAR pTitle = L"SYSTEM SHUTDOWN";
    PWCHAR pTitle;
    WCHAR sz1[256], sz2[512];

    LoadString( NULL, IDS_SHUTDOWN_TITLE, sz1, 256 );
    pTitle = &(sz1[0]);

    // Create the message
    LoadString( NULL, IDS_SHUTDOWN_MESSAGE, sz2, 512 );
    _snwprintf( mBuf, MAX_MESSAGE_LENGTH, sz2, WaitTime);

    for( Index=0; Index < Entries; Index++ ) {

        p = &pId[Index];
        if( p->State != State_Active ) continue;

        // Notify this WinStation
    if( v_flag ) {
            StringMessage(IDS_SENDING_WINSTATION, p->WinStationName);
        }

#if DBG
        if( v_flag ) {
            printf("Open, Now really sending message to Session %ws\n", p->WinStationName);
        }
#endif

        Result = WinStationSendMessage(
                     hServerName,
                     p->LogonId,
                     pTitle,
                     (wcslen(pTitle)+1)*sizeof(WCHAR),
                     mBuf,
                     (wcslen(mBuf)+1)*sizeof(WCHAR),
                     MB_OK,
                     WaitTime,
                     &Response,
                     TRUE
                     );

        if( !Result ) {
            StringErrorPrintf(IDS_ERROR_SENDING_WINSTATION, p->WinStationName);
        }

    }
}

/*****************************************************************************
 *
 *  CheckShutdownPrivilege
 *
 *   Check whether the current process has shutdown permission.
 *
 * ENTRY:
 *
 * EXIT:
 *
 *
 ****************************************************************************/

BOOLEAN
CheckShutdownPrivilege()
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;

    //
    // Try the thread token first
    //

    Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
                                TRUE,
                                TRUE,
                                &WasEnabled);

    if (Status == STATUS_NO_TOKEN) {

        //
        // No thread token, use the process token
        //

        Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
                                    TRUE,
                                    FALSE,
                                    &WasEnabled);
    }

    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\cfgcomp\cfgcomp.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*********************************************************************************************
*
*
* Module Name: 
*
*            CfgComp.h
*
* Abstract:
*            This contains the declaration for the functions in CfgBkEnd.
*
* 
* Author: Arathi Kundapur: a-akunda
*
* 
* Revision:  
*    
*
************************************************************************************************/

#ifndef __CFGCOMP_H_
#define __CFGCOMP_H_

#include "resource.h"       // main symbols
#include "PtrArray.h"    // Added by ClassView

extern HINSTANCE g_hInstance;
/////////////////////////////////////////////////////////////////////////////
// CCfgComp
class ATL_NO_VTABLE CCfgComp : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CCfgComp, &CLSID_CfgComp>,
    public ICfgComp,
    public ISettingsComp ,
    public IUserSecurity
{
public:
    CCfgComp()
    {
        m_bInitialized = FALSE;
        m_bAdmin = FALSE;

        lstrcpy( m_szConsole , L"Console" );
        /*
        LoadString(g_hInstance, IDS_SYSTEM_CONSOLE_NAME,
                m_szConsole, WINSTATIONNAME_LENGTH );
                */

    }
    ~CCfgComp()
    {
        UnInitialize();
    }

DECLARE_REGISTRY_RESOURCEID(IDR_CFGCOMP)
DECLARE_NOT_AGGREGATABLE(CCfgComp)

BEGIN_COM_MAP(CCfgComp)
    COM_INTERFACE_ENTRY(ICfgComp)
    COM_INTERFACE_ENTRY(ISettingsComp)
    COM_INTERFACE_ENTRY(IUserSecurity)
END_COM_MAP()

// ICfgComp Methods
public:
    // STDMETHOD(SetDefaultSecurity)(ULONG Offset);

    // STDMETHOD(GetDefaultSecurity)(ULONG * pDefaultSecurity);

    STDMETHOD(SetInternetConLic)(BOOL bInternetConLic , PDWORD );

    STDMETHOD(GetInternetConLic)(BOOL * pbInternetConLic , PDWORD );

    STDMETHOD(SetLicensingMode)(ULONG ulMode , PDWORD, PDWORD );

    STDMETHOD(GetLicensingMode)(ULONG *pulMode , PDWORD );

    STDMETHOD(GetLicensingModeInfo)(ULONG ulMode , WCHAR **pwszName, WCHAR **pwszDescription, PDWORD );

    STDMETHOD(GetLicensingModeList)(ULONG *pcModes , ULONG **prgulModes, PDWORD );


    STDMETHOD(SetUseTempDirPerSession)(BOOL bTempDirPerSession);

    STDMETHOD(GetUseTempDirPerSession)(BOOL *  pbTempDir);

    STDMETHOD(SetDelDirsOnExit)(BOOL bDelDirsOnExit);

    STDMETHOD(GetDelDirsOnExit)(BOOL * pDelDirsOnExit);

    // STDMETHOD(SetCachedSessions)(DWORD dCachedSessions);

    STDMETHOD_(BOOL, IsAsyncDeviceAvailable)(LPCTSTR pDeviceName);

    STDMETHOD(DeleteWS)(PWINSTATIONNAME pWs);
    
    STDMETHOD(IsNetWorkConnectionUnique)(WCHAR * WdName, WCHAR * PdName, ULONG LanAdapter , BOOL * pUnique);
    
    STDMETHOD(GetDefaultUserConfig)(WCHAR * WdName,long * pSize,PUSERCONFIG* ppUser);
    
    STDMETHOD(CreateNewWS)(WS WinstationInfo,long UserCnfgSize, PUSERCONFIG pUserConfig, PASYNCCONFIGW pAsyncConfig);
    
    STDMETHOD(GetWSInfo)(PWINSTATIONNAME pWSName, long * Size, WS **ppWS);
    
    STDMETHOD(UpDateWS)( PWS , DWORD Data , PDWORD, BOOLEAN bPerformMerger );
    
    STDMETHOD(GetDefaultSecurityDescriptor)(long * pSize,PSECURITY_DESCRIPTOR  *ppSecurityDescriptor);
    
    STDMETHOD(IsSessionReadOnly)(BOOL * pReadOnly);
    
    STDMETHOD(RenameWinstation)(PWINSTATIONNAMEW pOldWinstation, PWINSTATIONNAMEW pNewWinstation);
    
    STDMETHOD(EnableWinstation)(PWINSTATIONNAMEW pWSName, BOOL fEnable);
    
    STDMETHOD(SetUserConfig)(PWINSTATIONNAMEW pWsName, ULONG size, PUSERCONFIG pUserConfig , PDWORD );
    
    STDMETHOD(GetLanAdapterList)(WCHAR * pdName, ULONG * pNumAdapters,ULONG * pSize,WCHAR ** ppData);

    STDMETHOD(GetLanAdapterList2)(WCHAR * pdName, ULONG * pNumAdapters, PGUIDTBL *);

    STDMETHOD( BuildGuidTable )( PGUIDTBL * , int , WCHAR * );
    
    STDMETHOD(GetTransportTypes)(WCHAR * Name, NameType Type,ULONG *pNumWd,ULONG * pSize, WCHAR **ppData);
    
    STDMETHOD(IsWSNameUnique)(PWINSTATIONNAMEW pWSName,BOOL * pUnique);
    
    STDMETHOD(GetWdTypeList)(ULONG *pNumWd,ULONG * pSize, WCHAR **ppData);
    
    STDMETHOD(GetWinstationList)(ULONG * NumWinstations, ULONG * Size, PWS * ppWS);
    
    STDMETHOD(Initialize)();
    
    STDMETHOD(GetEncryptionLevels)(WCHAR * pName, NameType Type,ULONG * pNumEncryptionLevels,Encryption ** ppEncryption);
    
    STDMETHOD(GetUserConfig)(PWINSTATIONNAMEW pWsName, long * pSize,PUSERCONFIG * ppUser, BOOLEAN bPerformMerger);
    
    STDMETHOD(SetSecurityDescriptor)(PWINSTATIONNAMEW pWsName,DWORD Size,PSECURITY_DESCRIPTOR pSecurityDescriptor);
    
    STDMETHOD(GetSecurityDescriptor)(PWINSTATIONNAMEW pWSName,long * pSize,PSECURITY_DESCRIPTOR *ppSecurityDescriptor);

    STDMETHOD( ForceUpdate )( void );

    STDMETHOD( Refresh )( void );

    STDMETHOD( GetWdType )( PWDNAMEW , PULONG );

    STDMETHOD( GetTransportType )( WCHAR * , WCHAR * , DWORD * );

    STDMETHOD( IsAsyncUnique )( WCHAR * , WCHAR * , BOOL * );

    STDMETHOD( SetAsyncConfig )( WCHAR * , NameType , PASYNCCONFIGW , PDWORD );

    STDMETHOD( GetAsyncConfig )( WCHAR * , NameType , PASYNCCONFIGW );

    STDMETHOD( GetDeviceList )( WCHAR * , NameType , ULONG * , LPBYTE * );

    STDMETHOD( GetConnTypeName )( int  , WCHAR * );

    STDMETHOD( GetHWReceiveName )( int ,  WCHAR * );

    STDMETHOD( GetHWTransmitName )( int , WCHAR * );

    STDMETHOD( GetModemCallbackString )( int , WCHAR * );

    STDMETHOD( GetCaps )( WCHAR * , ULONG * );

    STDMETHOD( QueryLoggedOnCount )( WCHAR * , LONG * );

	STDMETHOD( GetNumofWinStations )(WCHAR *,WCHAR *, PULONG );

    STDMETHOD( UpdateSessionDirectory )( PDWORD );    

    STDMETHOD( GetColorDepth )(  /* in */ PWINSTATIONNAMEW pWs, /* out */ BOOL * , /* out */ PDWORD );

    STDMETHOD( SetColorDepth )(  /* in */ PWINSTATIONNAMEW pWs, /* in */ BOOL, /* out */ PDWORD );

    STDMETHOD( GetKeepAliveTimeout )(  /* in */ PWINSTATIONNAMEW pWs, /* out */ BOOL * , /* out */ PDWORD );

    STDMETHOD( SetKeepAliveTimeout )(  /* in */ PWINSTATIONNAMEW pWs, /* in */ BOOL, /* out */ PDWORD );

    STDMETHOD( GetProfilePath )(  /* out */ BSTR * , /* out */ PDWORD );

    STDMETHOD( SetProfilePath )(  /* in */ BSTR , /* out */ PDWORD );

    STDMETHOD( GetHomeDir )(  /* out */ BSTR * , /* out */ PDWORD );

    STDMETHOD( SetHomeDir )(  /* in */ BSTR , /* out */ PDWORD );



//ISettingComp Methods

    // STDMETHOD( GetCachedSessions )(DWORD * );

	STDMETHOD( SetActiveDesktopState )( /* in */ BOOL , /* out */ PDWORD );

	STDMETHOD( GetActiveDesktopState )( /* out */ PBOOL , /* out */ PDWORD );

    STDMETHOD( GetTermSrvMode )( /* out */ PDWORD , /* out */ PDWORD );

    STDMETHOD( GetWdKey )( /* in */ WCHAR * , /* out , string */ WCHAR * );

    STDMETHOD( GetUserPerm )( /* out */ BOOL * , /* out */ DWORD * );

    STDMETHOD( SetUserPerm )( /* in */ BOOL , /* out */ PDWORD );

    STDMETHOD( GetSalemHelpMode )( /* out */ BOOL *, /* out */ PDWORD );

    STDMETHOD( SetSalemHelpMode )( /* in */ BOOL, /* out */ PDWORD );
    
    STDMETHOD( GetDenyTSConnections )( /* out */ BOOL * , /* out */ PDWORD );

    STDMETHOD( SetDenyTSConnections )( /* in */ BOOL, /* out */ PDWORD );

    STDMETHOD( GetSingleSessionState )(  /* out */ BOOL * , /* out */ PDWORD );

    STDMETHOD( SetSingleSessionState )(  /* in */ BOOL, /* out */ PDWORD );

    STDMETHOD( GetTimeZoneRedirection )( /* out */ BOOL * , /* out */ PDWORD );

    STDMETHOD( SetTimeZoneRedirection )( /* in */ BOOL, /* out */ PDWORD );

    STDMETHOD( GetDisableForcibleLogoff )(  /* out */ BOOL * , /* out */ PDWORD );

    STDMETHOD( SetDisableForcibleLogoff )(  /* in */ BOOL, /* out */ PDWORD );


//IUserSecurity Methods
    STDMETHOD( ModifyUserAccess )( /* in */ WCHAR *pwszWinstaName ,
                                   /* in */ WCHAR *pwszAccountName ,
                                   /* in */ DWORD  dwMask ,
                                   /* in */ BOOL   fDel ,
                                   /* in */ BOOL   fAllow ,
                                   /* in */ BOOL   fNew ,
                                   /* in */ BOOL   fAuditing ,
                                   /* out*/ PDWORD pdwStatus );

    STDMETHOD( ModifyDefaultSecurity )( /* in */ WCHAR *pwszWinstaName ,
                                   /* in */ WCHAR *pwszAccountName ,
                                   /* in */ DWORD  dwMask ,
                                   /* in */ BOOL   fDel ,
                                   /* in */ BOOL   fAllow ,
                                   /* in */ BOOL   fAuditing ,
                                   /* out*/ PDWORD pdwStatus );

    STDMETHOD( GetUserPermList )( /* in */ WCHAR *pwszWinstaName ,
                                  /* out*/ PDWORD pcbItems ,
                                  /* out*/ PUSERPERMLIST *ppUserPermList,
                                  /* in */ BOOL fAudit );

    
private:
    // PSECURITY_DESCRIPTOR ReadSecurityDescriptor(ULONG index);
    // HRESULT SetDefaultSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurity);

    DWORD
    RemoveUserEntriesInACL(
        LPCTSTR pszUserName,
        PACL pAcl,
        PACL* ppNewAcl
    );

    DWORD
    GetUserSid(
        LPCTSTR pszUserName,
        PSID* ppUserSid
    );

    HRESULT 
    SetSecurityDescriptor(
        BOOL bDefaultSecurity,    
        PWINSTATIONNAMEW pWsName,
        DWORD Size,
        PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

    BOOL
    ValidDefaultSecurity(
        const WCHAR* pwszName
    );

    HRESULT
    ModifyWinstationSecurity(
        BOOL bDefaultSecurity,
        WCHAR *pwszWinstaName ,
        WCHAR *pwszAccountName ,
        DWORD  dwMask ,
        BOOL   fDel ,
        BOOL   fAllow ,
        BOOL   fNew ,
        BOOL   fAuditing ,
        PDWORD pdwStatus 
    );

    void DeleteWDArray();
    STDMETHODIMP FillWdArray();
    STDMETHODIMP FillWsArray();
    STDMETHODIMP InsertInWSArray( PWINSTATIONNAMEW pWSName,PWINSTATIONCONFIG2W pWSConfig,
                                   PWS * ppObject );
    void DeleteWSArray();
    PWD GetWdObject(PWDNAMEW pWdName);
    PWS GetWSObject(WINSTATIONNAMEW WSName);
    STDMETHOD(UnInitialize)();
    BOOL GetResourceStrings( int * , int , WCHAR * );
    HRESULT GetWinStationSecurity(BOOL bDefault, PWINSTATIONNAMEW pWSName,PSECURITY_DESCRIPTOR *ppSecurityDescriptor);
    //Function borrowed from security.c in tscfg project

    DWORD ValidateSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor);
    // BOOL CompareSD(PSECURITY_DESCRIPTOR pSd1,PSECURITY_DESCRIPTOR pSd2);
    BOOL RegServerAccessCheck(REGSAM samDesired);
    void GetPdConfig( WDNAME WdKey,WINSTATIONCONFIG2W& WsConfig);

    void VerifyGuidsExistence( PGUIDTBL * , int , WCHAR *);
    HRESULT AdjustLanaId( PGUIDTBL * , int , int , PDWORD , PDWORD , int* , int );


    
    CPtrArray m_WDArray;
    BOOL m_bInitialized;
    BOOL m_bAdmin;
    CPtrArray m_WSArray;
    TCHAR m_szConsole[WINSTATIONNAME_LENGTH + 1];
};

#endif //__CFGCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\cfgcomp\ptrarray.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*********************************************************************************************
*
*
* Module Name: 
*
*			Ptrarray.h
*
* Abstract:
*			This is file has declaration of CPtrArray class borrowed from MFC
* 
* Author:
*
* 
* Revision:  
*    
*
************************************************************************************************/


#ifndef PTRARRAY_H_
#define PTRARRAY_H_

class CPtrArray 
{
public:

// Construction
	CPtrArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	BOOL SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	void* GetAt(int nIndex) const;
	void SetAt(int nIndex, void* newElement);
	void*& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const void** GetData() const;
	void** GetData();

	// Potentially growing the array
	BOOL SetAtGrow(int nIndex, void* newElement);
	BOOL Add(void* newElement);
	int Append(const CPtrArray& src);
	void Copy(const CPtrArray& src);

	// overloaded operator helpers
	void* operator[](int nIndex) const;
	void*& operator[](int nIndex);

	// Operations that move elements around
	BOOL InsertAt(int nIndex, void* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CPtrArray* pNewArray);

// Implementation
protected:
	void** m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CPtrArray();
protected:
	// local typedefs for class templates
//	typedef void* BASE_TYPE;
//	typedef void* BASE_ARG_TYPE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\cfgcomp\cfgcomp.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*********************************************************************************************
*
*
* Module Name:
*
*            CfgComp.cpp
*
* Abstract:
*            This Module contains the implemetation of functions for the CfgBkEnd Component
*
* Author: Arathi Kundapur. a-akunda
* Owner:  alhen
*
*
* Revision: 
*
*
************************************************************************************************/



#include "stdafx.h"
#define SECURITY_WIN32
#include "PtrArray.h"
#include "CfgBkEnd.h"
#include <winsta.h>
#include <regapi.h>
#include "defines.h"
#include "CfgComp.h"
#include "Security.h"
#include <utildll.h>
#define INITGUID
#include "objbase.h"
#include "initguid.h"
#include <netcfgx.h>
#include <cfg.h>
#include "devguid.h"
#include <aclapi.h>
#include <sddl.h>

#define REG_GUID_TABLE      REG_CONTROL_TSERVER L"\\lanatable\\"
#define REG_GUID_TABLE_T    REG_CONTROL_TSERVER L"\\lanatable"
#define LANA_ID             L"LanaId"

#define ARRAYSIZE( rg ) sizeof( rg ) / sizeof( rg[0] )

#ifdef DBG
bool g_fDebug = false;
#endif

/***********************************************************************************************************/

#define RELEASEPTR(iPointer)    if(iPointer) \
                                        { \
                                             iPointer->Release();\
                                             iPointer = NULL;\
                                        }
/***************************************************************************************************************/

LPTSTR g_pszDefaultSecurity[] = {
        L"DefaultSecurity",
        L"ConsoleSecurity"
    };

DWORD g_numDefaultSecurity = sizeof(g_pszDefaultSecurity)/sizeof(g_pszDefaultSecurity[0]);

        

BOOL TestUserForAdmin( );

DWORD RecursiveDeleteKey( HKEY hKeyParent , LPTSTR lpszKeyChild );

/***************************************************************************************************************

  Name:      GetSecurityDescriptor

  Purpose:   Gets the Security Descriptor for a Winstation

  Returns:   HRESULT.

  Params:
             in:    pWSName - Name of the Winstation.
             out:   pSize - Size of the allocated buffer
                    ppSecurityDescriptor - Pointer to the buffer containing the security descriptor


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetSecurityDescriptor(PWINSTATIONNAMEW pWSName, long * pSize,PSECURITY_DESCRIPTOR * ppSecurityDescriptor)
{
     HRESULT hResult = S_OK;

    if(NULL == pSize || NULL == ppSecurityDescriptor || NULL == pWSName)
        return E_INVALIDARG;

    *pSize =0;

    *ppSecurityDescriptor = NULL;

    hResult = GetWinStationSecurity(FALSE, pWSName,(PSECURITY_DESCRIPTOR *)ppSecurityDescriptor);

    
    if( SUCCEEDED( hResult ) && *ppSecurityDescriptor != NULL )
    {
        *pSize = GetSecurityDescriptorLength(*ppSecurityDescriptor);
    }
    return hResult;
}

/***************************************************************************************************************

  Name:      SetSecurityDescriptor

  Purpose:   Sets the Security Descriptor for a Winstation

  Returns:   HRESULT.

  Params:
             in:    pWsName - Name of the Winstation.
                    Size - Size of the allocated buffer
                    pSecurityDescriptor - Pointer to the Security Descriptor


 ****************************************************************************************************************/

BOOL
CCfgComp::ValidDefaultSecurity(
    const WCHAR* pwszName
    )
/*++

--*/
{
    for( DWORD i=0; i < g_numDefaultSecurity; i++ )
    {
        if( lstrcmpi( g_pszDefaultSecurity[i], pwszName ) == 0 )
        {
            break;
        }
    }

    return ( i >= g_numDefaultSecurity ) ? FALSE : TRUE;
}


HRESULT 
CCfgComp::SetSecurityDescriptor(
    BOOL bDefaultSecurity,    
    PWINSTATIONNAMEW pWsName,
    DWORD Size,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
/*++

--*/
{
    HRESULT hResult = S_OK;
    HKEY Handle1 = NULL, Handle2 = NULL;

    //Check if the caller has write permissions.
    if(!m_bAdmin)
    {
        ODS( L"SetSecurityDescriptor : User Is not Admin. \n" );
        return E_ACCESSDENIED;
    }

    //Check the parametes for NULL
    if(NULL == pWsName || NULL == pSecurityDescriptor || 0 == Size)
        return E_INVALIDARG;

    if( TRUE == bDefaultSecurity && FALSE == ValidDefaultSecurity( pWsName ) )
    {
        return E_INVALIDARG;
    }

    //Check for the validity of the Winstation name

    /*if(NULL == GetWSObject(pWsName))  //Commented out to get Rename Work. This might not be needed .
        return E_INVALIDARG;*/

    //Check if the data passed is a valid security descriptor

     if(ERROR_SUCCESS != ValidateSecurityDescriptor((PSECURITY_DESCRIPTOR)pSecurityDescriptor))
        return E_INVALIDARG;

    if(Size != GetSecurityDescriptorLength((PSECURITY_DESCRIPTOR)pSecurityDescriptor))
        return E_INVALIDARG;

    //Make the Resitry entries required.

    if( RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,KEY_ALL_ACCESS, &Handle1 ) != ERROR_SUCCESS )
    {
        return E_FAIL;
    }

    if( TRUE == bDefaultSecurity )
    {
        if( RegSetValueEx( Handle1, pWsName, 0, REG_BINARY,(BYTE *)pSecurityDescriptor, Size ) != ERROR_SUCCESS )
        {
            hResult = E_FAIL;
        }
    }
    else
    {
        if( RegOpenKeyEx(Handle1, pWsName, 0, KEY_ALL_ACCESS, &Handle2 ) != ERROR_SUCCESS )
        {
            RegCloseKey(Handle1);

            return E_FAIL;
        }

        if( RegSetValueEx( Handle2, L"Security", 0, REG_BINARY,(BYTE *)pSecurityDescriptor, Size ) != ERROR_SUCCESS )
        {
            hResult = E_FAIL;
        }
    }

    if( Handle1 != NULL )
    {
        RegCloseKey(Handle1);
    }

    if( Handle2 != NULL )
    {
        RegCloseKey(Handle2);
    }

    return hResult;
}


STDMETHODIMP CCfgComp::SetSecurityDescriptor(PWINSTATIONNAMEW pWsName, DWORD Size,PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    return SetSecurityDescriptor( FALSE, pWsName, Size, pSecurityDescriptor );
}    

/***************************************************************************************************************

  Name:      GetUserConfig

  Purpose:   Gets the UserConfig for a Winstation

  Returns:   HRESULT.

  Params:
             in:    pWSName - Name of the Winstation.
             out:   pSize - Size of the allocated buffer
                    ppUser - Pointer to the buffer containing the UserConfig


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetUserConfig(PWINSTATIONNAMEW pWsName, long * pSize, PUSERCONFIG * ppUser, BOOLEAN bPerformMerger)
{
    HRESULT hResult = S_OK;
    WINSTATIONCONFIG2W WSConfig;
    LONG Size = 0;
    ULONG Length = 0;

    *pSize = 0;
    *ppUser = NULL;

    //Read the information from the registry.

    POLICY_TS_MACHINE p;
    memset(&p, 0, sizeof(POLICY_TS_MACHINE));
    if((ERROR_SUCCESS != RegWinStationQueryEx(NULL,&p,pWsName,&WSConfig,sizeof(WINSTATIONCONFIG2W),&Length,bPerformMerger)))
        return E_FAIL;

    Size = sizeof(WSConfig.Config.User);
    *ppUser = (PUSERCONFIG)CoTaskMemAlloc(Size);
    if(*ppUser == NULL)
        return E_OUTOFMEMORY;

    CopyMemory((PVOID)*ppUser,(CONST VOID *)&WSConfig.Config.User,Size);
    *pSize = Size;


    return hResult;
}

/***************************************************************************************************************

  Name:      GetEncryptionLevels

  Purpose:   Gets the Encyption Levels for a Winstation

  Returns:   HRESULT.

  Params:
             in:    pName - Name of the Winstation or the Winstation Driver depending the value of Type
                    Type - Specifies whether the Name is a Winstation name or WD Name (WsName, WdName)
             out:   pNumEncryptionLevels - Number of Encryption Levels
                    ppEncryption - Pointer to the buffer containing the Encryption Levels


 ****************************************************************************************************************/

STDMETHODIMP CCfgComp::GetEncryptionLevels(WCHAR * pName, NameType Type,ULONG * pNumEncryptionLevels,Encryption ** ppEncryption)
{
    HRESULT hResult = S_OK;
    PWD pWD = NULL;
    PWS pWS = NULL;
    ULONG NumLevels = 0, Size =0 ,i = 0;
    EncryptionLevel *pEncryptionLevels = NULL;

    //Check the parameters
    if(NULL == pNumEncryptionLevels || NULL == pName || NULL == ppEncryption)
        return E_INVALIDARG;
    *pNumEncryptionLevels = 0;
     *ppEncryption = NULL;

    //Get the pointer to the appropriate WD object.
    if(Type == WsName)
    {
        pWS = GetWSObject(pName);
        if(NULL == pWS)
            return E_INVALIDARG;
        pWD = GetWdObject(pWS->wdName);
        if(NULL == pWD)
            return E_FAIL;
    }
    else if(Type == WdName)
    {
        pWD = GetWdObject(pName);
        if(NULL == pWD)
            return E_INVALIDARG;
    }
    else
        return E_INVALIDARG;

    //Check if this object has the extension dll associated with it.
    //Check if the function for encryption levels was exposed in the dll
    if(!(pWD->hExtensionDLL && pWD->lpfnExtEncryptionLevels))
        return E_FAIL;

    //Get the EncryptionLevels. The Strings should be seperately extracted from the resource
    NumLevels = (pWD->lpfnExtEncryptionLevels)(&pWS->wdName, &pEncryptionLevels);
    if(NULL == pEncryptionLevels)
        return E_FAIL;

    Size = sizeof(Encryption);
    Size = NumLevels * sizeof(Encryption);
    *ppEncryption = (Encryption*)CoTaskMemAlloc(Size);
    if(*ppEncryption == NULL)
        return E_OUTOFMEMORY;

    //copy the relevent data to the Encryption structure

    for(i = 0; i < NumLevels; i++)
    {
        //Extract the string corresponding to the levels.
        if(0 == LoadString(pWD->hExtensionDLL,pEncryptionLevels[i].StringID,
                          ((*ppEncryption)[i]).szLevel, sizeof( ( ( *ppEncryption )[ i ] ).szLevel ) / sizeof( TCHAR ) ) )
        {
            hResult = E_FAIL;
            break;
        }
        ((*ppEncryption)[i]).RegistryValue = pEncryptionLevels[i].RegistryValue;

        ((*ppEncryption)[i]).szDescr[ 0 ] = 0;

        if( pWD->lpfnExtGetEncryptionLevelDescr != NULL )
        {
            int nResID = 0;

            if( ( pWD->lpfnExtGetEncryptionLevelDescr )( pEncryptionLevels[i].RegistryValue , &nResID ) != -1 )
            {
                LoadString( pWD->hExtensionDLL , nResID ,  ((*ppEncryption)[i]).szDescr , sizeof( ( (*ppEncryption )[ i ] ).szDescr ) / sizeof( TCHAR ) );
            }
        }

        ((*ppEncryption)[i]).Flags = pEncryptionLevels[i].Flags;

    }

    *pNumEncryptionLevels = NumLevels;



    //pEncrptionLevels need not be cleaned up as it is global data in Rdpcfgex.dll
    if(FAILED(hResult))
    {
        if(*ppEncryption)
        {
            CoTaskMemFree(*ppEncryption);
            *ppEncryption = NULL;
            *pNumEncryptionLevels = 0;
        }
    }
    return hResult;
}

/***************************************************************************************************************

  Name:      FillWdArray

  Purpose:   Internal function to fill the m_WdArray

  Returns:   HRESULT.

  Params:

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::FillWdArray()
{

    //Use the functionalities already provided by the regapi,
    //instead of reinventing the wheel

    long Status;
    ULONG Index, Index2, ByteCount, Entries, Entries2;
    PDNAMEW PdKey;
    WDNAMEW WdKey;
    LONG QStatus;
    WDCONFIG2W WdConfig;
    PDCONFIG3W PdConfig;
    TCHAR WdDll[MAX_PATH];
    HRESULT hResult = S_OK;
    /*
    TCHAR * pPdName = NULL;
    */
    PWD pWd = NULL;

    //Delete if there are already entries in the list
    DeleteWDArray();

    //Enumerate the WD's from the Registry
    for ( Index = 0, Entries = 1, ByteCount = sizeof(WDNAMEW);
          (Status =
           RegWdEnumerateW( NULL,
                           &Index,
                           &Entries,
                           WdKey,
                           &ByteCount )) == ERROR_SUCCESS;
          ByteCount = sizeof(WDNAMEW) )

     {
        if ((QStatus = RegWdQueryW( NULL, WdKey, &WdConfig,
                                     sizeof(WdConfig),
                                     &ByteCount)) != ERROR_SUCCESS )
        {
            hResult = E_FAIL;
            break;

        }

        /*
         * Only place this Wd in the WdList if it's DLL is present
         * on the system.
         */
        GetSystemDirectory( WdDll, MAX_PATH );
        lstrcat( WdDll, TEXT("\\Drivers\\") );
        lstrcat( WdDll, WdConfig.Wd.WdDLL );
        lstrcat( WdDll, TEXT(".sys" ) );
        if ( lstr_access( WdDll, 0 ) != 0 )
            continue;

        /*
         * Create a new WdList object and initialize from WdConfig
         * structure, adding it to the end of the WdList.
         */
        pWd = new WD;
        if(NULL == pWd)
        {
            hResult = E_OUTOFMEMORY;
            break;
        }

        lstrcpy(pWd->wdName,WdConfig.Wd.WdName);
        lstrcpy(pWd->wdKey,WdKey);

        pWd->wd2 = WdConfig;

        // Load the extension DLL for this WD
        pWd->hExtensionDLL = ::LoadLibrary(WdConfig.Wd.CfgDLL);
        if(pWd->hExtensionDLL)
        {
//            ODS( L"Loaded extension dll\n" );
            // Get the entry points
            pWd->lpfnExtStart = (LPFNEXTSTARTPROC)::GetProcAddress(pWd->hExtensionDLL, szStart);

            pWd->lpfnExtEnd = (LPFNEXTENDPROC)::GetProcAddress(pWd->hExtensionDLL, szEnd);

            pWd->lpfnExtEncryptionLevels = (LPFNEXTENCRYPTIONLEVELSPROC)::GetProcAddress(pWd->hExtensionDLL, szEncryptionLevels);

            pWd->lpfnExtDeleteObject = (LPFNEXTDELETEOBJECTPROC)::GetProcAddress(pWd->hExtensionDLL, szDeleteObject);

            pWd->lpfnExtRegQuery = (LPFNEXTREGQUERYPROC)::GetProcAddress(pWd->hExtensionDLL, szRegQuery);

            pWd->lpfnExtRegCreate = (LPFNEXTREGCREATEPROC)::GetProcAddress(pWd->hExtensionDLL, szRegCreate);

            pWd->lpfnExtRegDelete = (LPFNEXTREGDELETEPROC)::GetProcAddress(pWd->hExtensionDLL, szRegDelete);

            pWd->lpfnExtDupObject = (LPFNEXTDUPOBJECTPROC)::GetProcAddress(pWd->hExtensionDLL, szDupObject);

            pWd->lpfnGetCaps = ( LPFNEXTGETCAPABILITIES )::GetProcAddress( pWd->hExtensionDLL , szGetCaps );

            pWd->lpfnExtGetEncryptionLevelDescr =
                ( LPFNEXTGETENCRYPTIONLEVELDESCPROC )::GetProcAddress( pWd->hExtensionDLL , szGetEncryptionLevelDescr );


            // Call the ExtStart() function in the extension DLL
            if(pWd->lpfnExtStart)(*pWd->lpfnExtStart)(&WdConfig.Wd.WdName);

        }

        if( !m_WDArray.Add( pWd) )
        {
            ODS(L"CFGBKEND:FillWdArray adding wd failed\n" );
            delete pWd;
            hResult = E_OUTOFMEMORY;
            break;
        }



         //Get the names of the Transport drivers associated with this WD
        for ( Index2 = 0, Entries2 = 1, ByteCount = sizeof(PDNAMEW);
                (Status = RegPdEnumerateW(NULL,WdKey,TRUE,&Index2,&Entries2,PdKey,&ByteCount)) == ERROR_SUCCESS;
                 ByteCount = sizeof(PDNAMEW))
              {
                     PDCONFIG3W *pPdConfig = NULL;

                     if ((QStatus = RegPdQueryW(NULL,WdKey,TRUE,PdKey,&PdConfig,sizeof(PdConfig),&ByteCount)) != ERROR_SUCCESS)
                     {
                         hResult = E_FAIL;
                         break;
                     }

                    /*
                     * Create a new PdName and initialize from PdConfig
                     * structure, then add to the TdName list.
                     */

                    pPdConfig = new PDCONFIG3W;

                    if( pPdConfig == NULL )
                    {
                        hResult = E_OUTOFMEMORY;

                        break;
                    }

                    *pPdConfig = PdConfig;

                    if( !pWd->PDConfigArray.Add( pPdConfig ) )
                    {
                        ODS( L"CFGBKEND:FillWdArray adding PDCONFIG3W failed\n" );
                        delete pPdConfig;
                        hResult = E_OUTOFMEMORY;
                        break;
                    }


                    /*
                    pPdName = new PDNAMEW;
                    if(NULL == pPdName)
                    {
                        hResult = E_OUTOFMEMORY;
                        break;

                    }

                    lstrcpy((TCHAR *)pPdName,PdConfig.Data.PdName);

                    pWd->PDNameArray.Add(pPdName);
                    */
            }
        }

        if(FAILED(hResult))
        {
            //Error has occured, cleanup m_WDArray
            DeleteWDArray();
        }

        return hResult;

}

/***************************************************************************************************************

  Name:      Initialize

  Purpose:   Initializes the object

  Returns:   HRESULT.

  Params:

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::Initialize()
{
    HRESULT hResult = S_OK;

    #ifdef DBG

    HKEY hKey;

    LONG lStatus;

    // To control debug spewage add/remove this regkey

    lStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
        L"Software\\Microsoft\\TSCC\\Debug",
        0,
        KEY_READ,
        &hKey );

    if( lStatus == ERROR_SUCCESS )
    {
        g_fDebug = true;

        RegCloseKey( hKey );
    }

    #endif

    //If already initialized, return
    if(m_bInitialized)
        return CFGBKEND_ALREADY_INITIALIZED;

    //Is the user the admin?
    /*
    if(RegWinStationAccessCheck(NULL, KEY_ALL_ACCESS))
    {
       m_bAdmin = FALSE;
    }
    else
    {
        m_bAdmin = TRUE;
    }
    */

    m_bAdmin = TestUserForAdmin( );

    // Fill up the WdArray with information regarding the Wd's installed on this machine.
    hResult = FillWdArray();
    if(SUCCEEDED(hResult))
    {
        //Fill up the WsArray with the info about the WS's on this machine.
        hResult = FillWsArray();
    }

    if(SUCCEEDED(hResult))
        m_bInitialized = TRUE;
    else
    {
        //if Failed, Cleanup the memory used.
        DeleteWSArray();
        DeleteWDArray();
    }

    return hResult;
}

/***************************************************************************************************************

  Name:      FillWsArray

  Purpose:   Internal function to fill m_WsArray

  Returns:   HRESULT.

  Params:

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::FillWsArray()
{
    LONG Status;
    ULONG Index, ByteCount, Entries;
    WINSTATIONNAMEW WSName;
    PWS  pWsObject = NULL;
    HRESULT hResult = S_OK;
    WINSTATIONCONFIG2W* pWSConfig = NULL;
    ULONG Size = 0;

    //Ensure that the WS is empty.
    DeleteWSArray();

    Index = 0;

    Size = sizeof(WINSTATIONCONFIG2W);
    pWSConfig = (WINSTATIONCONFIG2W*)LocalAlloc(LMEM_FIXED, Size);

    if(pWSConfig == NULL)
    {
        return E_FAIL;
    }

    //Enumerate Winstations
    for ( Index = 0, Entries = 1, ByteCount = sizeof(WINSTATIONNAMEW);
          (Status =
           RegWinStationEnumerateW( NULL, &Index, &Entries,
                                   WSName, &ByteCount )) == ERROR_SUCCESS;
          ByteCount = sizeof(WINSTATIONNAMEW) )
    {   
        ULONG Length;        
     
        Status = RegWinStationQueryW(NULL,
                                     WSName,
                                     pWSConfig,
                                     sizeof(WINSTATIONCONFIG2W), &Length);
        if(Status)
        {
            continue;
        }

        //Insert a WS object into the m_WSArray.
        hResult = InsertInWSArray(WSName, pWSConfig, &pWsObject);
        if (FAILED(hResult))
            break;                  
    }
    
    if(pWSConfig != NULL)
    {
        LocalFree(pWSConfig);
        pWSConfig = NULL;    
    }
                
    if(FAILED(hResult))
    {
        DeleteWSArray();
    }

    return hResult;
}

/***************************************************************************************************************

  Name:      InsertInWSArray

  Purpose:   Internal function to Insert a new WS in the m_WsArray

  Returns:   HRESULT.

  Params:
             in:    pWSName - Name of the Winstation.
                    pWSConfig - PWINSTATIONCONFIG2W structure
             out:    ppObject - Pointer to the new object


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::InsertInWSArray( PWINSTATIONNAMEW pWSName,
                                        PWINSTATIONCONFIG2W pWSConfig,
                                        PWS * ppObject )
{
    int Index = 0,Size = 0;
    BOOL bAdded;
    PWS pObject;
    HRESULT hResult = S_OK;

    if (pWSName == NULL || pWSConfig == NULL || ppObject == NULL)
        return E_INVALIDARG;

    //Create a new WS object and initialize.
    pObject = new WS;
    if ( NULL == pObject )
        return E_OUTOFMEMORY;

    // make sure the winstation name doesn't exceed our buffer length
    if (lstrlen(pWSName) > WINSTATIONNAME_LENGTH)
        return E_INVALIDARG;

    lstrcpy(pObject->Name, pWSName);

    pObject->fEnableWinstation = pWSConfig->Create.fEnableWinStation ? 1 : 0;

    lstrcpy( pObject->pdName, pWSConfig->Pd[0].Create.PdName );

    pObject->PdClass = (DWORD)pWSConfig->Pd[0].Create.SdClass;

    // New addition

    if( pObject->PdClass == SdAsync )
    {
        lstrcpy( pObject->DeviceName , pWSConfig->Pd[0].Params.Async.DeviceName );
    }

    //

    lstrcpy( pObject->wdName, pWSConfig->Wd.WdName );

    lstrcpy( pObject->Comment, pWSConfig->Config.Comment );

    pObject->LanAdapter = (pObject->PdClass == SdNetwork) ? pWSConfig->Pd[0].Params.Network.LanAdapter : ( ULONG )-1;

    pObject->uMaxInstanceCount = pWSConfig->Create.MaxInstanceCount;


     //Traverse the WSArray and insert this new WS,
     //keeping the list sorted by Name.

    PWS pTempWs = NULL;
    for ( Index = 0, bAdded = FALSE,Size = m_WSArray.GetSize();
            Index < Size; Index++ )
    {


        pTempWs = (PWS)m_WSArray[Index];

        if ( lstrcmpi( pTempWs->Name,pObject->Name ) > 0)
        {
            if( !m_WSArray.InsertAt(Index, pObject ) )
            {
                ODS( L"CFGBKEND:InsertInWSArray failed\n" );
                delete pObject;
                *ppObject = NULL;
                return E_OUTOFMEMORY;
            }


            bAdded = TRUE;

            break;
        }
    }


    //If we haven't yet added the WS, add it now to the tail
    if( !bAdded )
    {
        if( !m_WSArray.Add(pObject) )
        {
            ODS( L"CFGBKEND:InsertInWSArray failed\n" );
            delete pObject;
            *ppObject = NULL;
            return E_OUTOFMEMORY;
        }
    }

    //Set the ppObject referenced WS pointer to the new WS
    //pointer and return the index of the new WS
    *ppObject = pObject;
    return hResult;

}  // end CCfgComp::InsertInWSArray


/***************************************************************************************************************

  Name:      GetWdObject

  Purpose:   Internal function to get a WD object from m_WdArray

  Returns:   PWD - pointer to a WD object.

  Params:
             in:    pWd - Name of the WD

 ****************************************************************************************************************/
PWD CCfgComp::GetWdObject(PWDNAMEW pWdName)
{
    PWD pObject;

    int Size  = 0,Index = 0;
    
    //Traverse the WD list
    for (Index = 0, Size = m_WDArray.GetSize(); Index < Size; Index ++)
    {
        pObject = (PWD)m_WDArray[Index];

        if ( !lstrcmpi( pObject->wdName, pWdName ) )
        {
            return(pObject);
        }
        /* when PWD includes WDCONFIG2

        if( !lstrcmpi( pObject->wd2.Wd.WdName , pWdName ) )
        {
            return pObject;
        }
        */
    }

    return(NULL);

}  // end GetWdObject

//--------------------------------------------------------------------------------------------------------------
// expected return values WDF_ICA or WDF_TSHARE
//--------------------------------------------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetWdType( PWDNAMEW pWdName , PULONG pulType )
{
    if( pWdName == NULL || pulType == NULL )
    {
        return E_INVALIDARG;
    }

    PWD pwdObject = GetWdObject( pWdName );

    if( pwdObject != NULL )
    {
        *pulType = pwdObject->wd2.Wd.WdFlag;

        return S_OK;
    }

    return E_FAIL;
}

/***************************************************************************************************************

  Name:      GetWSObject

  Purpose:   Internal function to get a WS Object from m_WsArray

  Returns:   PWS - Pointer to a WS Object.

  Params:
             in:    pWSName - Name of the Winstation.


 ****************************************************************************************************************/
PWS CCfgComp::GetWSObject(WINSTATIONNAMEW WSName)
{
    PWS pObject;

    int Size  = 0,Index = 0;

    //Refresh( );

    //Traverse the WD list
    for (Index = 0, Size = m_WSArray.GetSize(); Index < Size; Index ++)
    {

        pObject = (PWS)m_WSArray[Index];

        if ( !lstrcmpi( pObject->Name, WSName ) )
        {
            return(pObject);
        }
    }

    return(NULL);

}  // end GetWdObject



/***************************************************************************************************************

  Name:      GetWinStationSecurity

  Purpose:   Internal function used to Get Winstation Security

  Returns:   HRESULT.

  Params:
             in:    pWSName - Name of the Winstation.
             out:   ppSecurityDescriptor - Pointer to the buffer containing the security descriptor


 ****************************************************************************************************************/
HRESULT CCfgComp::GetWinStationSecurity( BOOL bDefault, PWINSTATIONNAMEW pWSName,PSECURITY_DESCRIPTOR *ppSecurityDescriptor )
{

    DWORD SDLength = 0;

    DWORD ValueType =0;

    HKEY Handle1 = NULL;

    HKEY Handle2 = NULL;

    HRESULT hResult = S_OK;

    //BOOL bDefault = FALSE;

    WCHAR ValueName[32]; // Just some number enough to hold string "Security" and DefaultSecurity"
    
    DWORD dwError = ERROR_SUCCESS;

    if(NULL == ppSecurityDescriptor)
    {
        return E_INVALIDARG;
    }

    if( TRUE == bDefault )
    {
        if(NULL == pWSName )
        {
            //Default Security
            lstrcpy( ValueName, L"DefaultSecurity" );
        }
        else if( lstrlen(pWSName) > sizeof(ValueName) / sizeof(ValueName[0]) - 1 )
        {
            ODS( L"CFGBKEND : GetWinStationSecurity -- default security key name is too long\n" );

            return E_INVALIDARG;
        }
        else
        {
            ZeroMemory( ValueName, sizeof(ValueName) );
            lstrcpy( ValueName, pWSName );
        }
    }
    else
    {
        lstrcpy( ValueName, L"Security" );
    }

    *ppSecurityDescriptor = NULL;

    if( RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,KEY_READ, &Handle1 ) != ERROR_SUCCESS)
    {
        ODS( L"CFGBKEND : GetWinStationSecurity -- RegOpenKey failed\n" );

        return E_FAIL;
    }

    if(!bDefault)
    {
        if( RegOpenKeyEx( Handle1, pWSName , 0 , KEY_READ/*KEY_ALL_ACCESS*/, &Handle2 )!= ERROR_SUCCESS)
        {
            ODS( L"CFGBKEND : GetWinStationSecurity -- RegOpenKey( 2 ) failed\n" );

            RegCloseKey(Handle1);

            return E_FAIL;

        }

        RegCloseKey(Handle1);

        Handle1 = Handle2;

        Handle2 = NULL;
    }
    
    dwError = RegQueryValueEx( Handle1, ValueName, NULL, &ValueType,NULL, &SDLength );

    if( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(Handle1);

        //I custom SD is not found, try default SD
        //Check bDefault flag to avoid infinite recursion
        if(dwError == ERROR_FILE_NOT_FOUND && !bDefault)
        {
            if(_wcsicmp(pWSName,L"Console"))
            {
                //Not a console session
                return GetWinStationSecurity(TRUE, NULL, ppSecurityDescriptor);
            }
            else
            {
                //This is a console session
                //It has different default SD
                return GetWinStationSecurity(TRUE, L"ConsoleSecurity", ppSecurityDescriptor);
            }
        }
        else
        {
            ODS( L"CFGBKEND : GetWinStationSecurity -- RegQueryValueEx failed for -- " );
            ODS( ValueName );
            ODS( L"\n" );

            return E_FAIL;
        }
    }

    //Return error if not correct data type
    if (ValueType != REG_BINARY)
    {
        ODS( L"CFGBKEND : GetWinStationSecurity -- ValueType != REG_BINARY\n" );

        RegCloseKey(Handle1);

        return ERROR_FILE_NOT_FOUND;
    }


    //Allocate a buffer to read the Security info and read it
    // ACLUI uses LocalFree
    // *ppSecurityDescriptor = CoTaskMemAlloc(SDLength);

    *ppSecurityDescriptor = ( PSECURITY_DESCRIPTOR )LocalAlloc( LMEM_FIXED , SDLength );

    if ( *ppSecurityDescriptor == NULL )
    {
        RegCloseKey(Handle1);

        return E_OUTOFMEMORY;
    }
    
    
    if( RegQueryValueEx( Handle1,ValueName, NULL, &ValueType,(BYTE *) *ppSecurityDescriptor, &SDLength ) == ERROR_SUCCESS )
    {
        //Check for a valid SD before returning.
        if( ERROR_SUCCESS != ValidateSecurityDescriptor( *ppSecurityDescriptor ) )
        {
            hResult = E_FAIL;
        }
    }
    else
    {
        hResult = E_FAIL;
    }

    if(Handle1)
    {
        RegCloseKey(Handle1);
        Handle1 = NULL;
    }
    if(Handle2)
    {
        RegCloseKey(Handle2);
        Handle2 = NULL;
    }
    if(FAILED(hResult))
    {
        if( *ppSecurityDescriptor != NULL )
        {
            // CoTaskMemFree(*ppSecurityDescriptor);
            LocalFree( *ppSecurityDescriptor );
            *ppSecurityDescriptor = NULL;
        }

    }
    return hResult;

}  // GetWinStationSecurity

//This function is borrowed from security.c in the tscfg project

/***************************************************************************************************************

  Name:      ValidateSecurityDescriptor

  Purpose:   Internal function to Validate a Security Descriptor

  Returns:   DWORD - Error Status.

  Params:
             in:    pSecurityDescriptor - pointer to a security Descriptor.

 ****************************************************************************************************************/
DWORD CCfgComp::ValidateSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    // DWORD Error = ERROR_SUCCESS;

    if( IsValidSecurityDescriptor( pSecurityDescriptor ) )
    {
        return ERROR_SUCCESS;
    }
    else
    {
        return GetLastError( );
    }
    

}  // end ValidateSecurityDescriptor

/***************************************************************************************************************

  Name:      GetWinstationList

  Purpose:   Gets the List of Winstations installed on a Machine

  Returns:   HRESULT.

  Params:
             out:   NumWinstations - pointer to the Number of Winstations returned.
                    Size - pointer to the size of allocated buffer.
                    ppWS - Pointer to the allocated buffer containing the WS Structures


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetWinstationList(ULONG * NumWinstations, ULONG * Size, PWS * ppWS)
{
    HRESULT hResult = S_OK;

    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;

    WS * pWSTemp = NULL;
    if(NULL == NumWinstations || NULL == Size || NULL == ppWS)
        return E_INVALIDARG;


    *NumWinstations = 0;
    *Size = 0;
    *ppWS = NULL;

    ULONG Num = m_WSArray.GetSize();

    *ppWS = (PWS)CoTaskMemAlloc(Num * sizeof(WS));
    if(NULL == *ppWS)
        return E_OUTOFMEMORY;

    pWSTemp = (WS *)(*ppWS);
    for(ULONG i = 0; i < Num ; i++)
    {
        lstrcpy(pWSTemp[i].Name,((WS *)m_WSArray[i])->Name);
        lstrcpy(pWSTemp[i].pdName,((WS *)m_WSArray[i])->pdName);
        lstrcpy(pWSTemp[i].wdName,((WS *)m_WSArray[i])->wdName);
        lstrcpy(pWSTemp[i].Comment,((WS *)m_WSArray[i])->Comment);
        pWSTemp[i].uMaxInstanceCount =((WS *)m_WSArray[i])->uMaxInstanceCount;
        pWSTemp[i].fEnableWinstation =((WS *)m_WSArray[i])->fEnableWinstation;
        pWSTemp[i].LanAdapter = ((WS *)m_WSArray[i])->LanAdapter;
        pWSTemp[i].PdClass = ((WS *)m_WSArray[i])->PdClass;
    }
    *NumWinstations = Num;
    *Size = Num * sizeof(WS);

    return hResult;
}

/***************************************************************************************************************

  Name:      GetWdTypeList

  Purpose:   Gets the List of Winstation Drivers

  Returns:   HRESULT.

  Params:
             out:   pNumWd - pointer to the number of entries returned.
                    pSize - pointer to the size of the allocated buffer
                    ppData - Pointer to an array of WDNAMEW


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetWdTypeList(ULONG * pNumWd, ULONG * pSize, WCHAR ** ppData)
{
    HRESULT hResult = S_OK;

    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;


    if(NULL == pNumWd || NULL == pSize || NULL == ppData)
        return E_INVALIDARG;
    WDNAMEW * pWdTemp = NULL;

    *pNumWd = 0;
    *pSize = 0;
    *ppData = NULL;

    ULONG Num = m_WDArray.GetSize();

    *ppData = (WCHAR *)CoTaskMemAlloc(Num * sizeof(WDNAMEW));
    if(NULL == *ppData)
        return E_OUTOFMEMORY;

    pWdTemp = (WDNAMEW *)(*ppData);
    for(ULONG i = 0; i < Num ; i++)
    {
        lstrcpy(pWdTemp[i],((WD *)m_WDArray[i])->wdName);
    }
    *pNumWd = Num;
    *pSize = Num * sizeof(WS);

    return hResult;

}

/***************************************************************************************************************

  Name:      IsWSNameUnique

  Purpose:   Checks if the Name is already not an existing winstation

  Returns:   HRESULT.

  Params:
             in:    pWSName - Name of the Winstation.
             out:   pUnique - pointer to whether the winstation name is unique

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::IsWSNameUnique(PWINSTATIONNAMEW pWSName,BOOL * pUnique)
{
    if(NULL == pWSName || NULL == pUnique)
        return E_INVALIDARG;

    *pUnique = FALSE;

    if((NULL == GetWSObject(pWSName)) && (lstrcmpi(pWSName,m_szConsole)))
        *pUnique = TRUE;

    return S_OK;
}

/***************************************************************************************************************

  Name:      GetTransportTypes

  Purpose:   Gets the Security Descriptor for a Winstation

  Returns:   HRESULT.

  Params:
             in:    Name - Name of the Winstation or WD depending on the value of Type.
                    Type - Specifies whether the Name is a Winstation name or WD Name (WsName, WdName)
             out:   pNumPd - pointer to the number of Transport types returned
                    pSize - Size of the allocated buffer
                    ppSecurityDescriptor - Pointer to the buffer containing the Transport types supported


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetTransportTypes(WCHAR * Name, NameType Type,ULONG * pNumPd, ULONG * pSize, WCHAR * * ppData)
{
    HRESULT hResult = S_OK;

    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;

    if(NULL == pNumPd || NULL == pSize || NULL == ppData || NULL == Name)
        return E_INVALIDARG;

    WD * pWD = NULL;
    WS * pWS = NULL;

    *pNumPd = 0;
    *pSize = 0;
    *ppData = NULL;

    PDNAMEW * pPdTemp = NULL;

    if(Type == WsName)
    {
        pWS = GetWSObject(Name);
        if(NULL == pWS)
            return E_INVALIDARG;
        pWD = GetWdObject(pWS->wdName);
        if(NULL == pWD)
            return E_FAIL;
    }
    else if(Type == WdName)
    {
        pWD = GetWdObject(Name);
        if(NULL == pWD)
            return E_INVALIDARG;
    }
    else
        return E_INVALIDARG;


    // ULONG Num = (pWD->PDNameArray).GetSize();

    ULONG Num = ( pWD->PDConfigArray ).GetSize( );

    *ppData = (WCHAR *)CoTaskMemAlloc(Num * sizeof(PDNAMEW));
    if(NULL == *ppData)
        return E_OUTOFMEMORY;

    pPdTemp = (PDNAMEW *)(*ppData);
    for(ULONG i = 0; i < Num ; i++)
    {
        // PDNAMEW * pPdName = (PDNAMEW *)pWD->PDNameArray[i];
        PDNAMEW * pPdName = &( ( PDCONFIG3W * )pWD->PDConfigArray[i] )->Data.PdName;

        lstrcpy(pPdTemp[i], *pPdName);
    }
    *pNumPd = Num;
    *pSize = Num * sizeof(PDNAMEW);

    return hResult;
}

/***************************************************************************************************************

  Name:      GetLanAdapterList

  Purpose:   Gets the List of Lan Adapters associated with a given protocol

  Returns:   HRESULT.

  Params:
             in:    pdName - Name of the protocol.
             out:   pNumAdapters:pointer to the number of Lan adapters returned
                    pSize - Size of the allocated buffer
                    ppSecurityDescriptor - Pointer to An Array of DEVICENAME's


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetLanAdapterList(WCHAR * pdName, ULONG * pNumAdapters, ULONG * pSize, WCHAR ** ppData)
{
    HRESULT hResult = S_OK, hr = S_OK;

    //If not initialized return error
    if(!m_bInitialized)
    {
        ODS( L"CCfgComp::GetLanAdapterList returned CFGBKEND_E_NOT_INITIALIZED\n" );

        return CFGBKEND_E_NOT_INITIALIZED;
    }

    if(NULL == pdName || NULL == ppData || NULL == pNumAdapters || NULL == pSize)
    {
        ODS( L"CCfgComp::GetLanAdapterList returned INVALIDARG \n" );

        return E_INVALIDARG;
    }

    *pNumAdapters = 0;
    *pSize = 0;
    *ppData = NULL;

    int NumAdapters = 0;
    TCHAR * pszDevice = NULL;
    int length = 0;
    DEVICENAMEW * pTempPointer = NULL;

    CPtrArray DeviceArray;

     //Interface pointer declarations

    TCHAR szProtocol[256];
    INetCfg * pnetCfg = NULL;
    INetCfgClass * pNetCfgClass = NULL;
    INetCfgClass * pNetCfgClassAdapter = NULL;
    INetCfgComponent * pNetCfgComponent = NULL;
    INetCfgComponent * pNetCfgComponentprot = NULL;
    IEnumNetCfgComponent * pEnumComponent = NULL;
    INetCfgComponentBindings * pBinding = NULL;
    LPWSTR pDisplayName = NULL;
    DWORD dwCharacteristics;
    ULONG count = 0;


    if( 0 == lstrcmpi( pdName , L"tcp" ) )
    {
        lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_TCPIP);
    }
    else if( 0 == lstrcmpi( pdName , L"netbios" ) )
    {
        lstrcpy(szProtocol,NETCFG_SERVICE_CID_MS_NETBIOS);
    }
    else if( 0 == lstrcmpi( pdName, L"ipx" ) )
    {
        lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_NWIPX);
    }
    else if( 0 == lstrcmpi( pdName , L"spx" ) )
    {
        lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_NWSPX);
    }
    else
    {
        return E_INVALIDARG;
    }
    /*
    * Assumption: No NetBios Lana MAPPING
    */
    //The First entry will be "All Lan Adapters"

    pszDevice = new TCHAR[DEVICENAME_LENGTH];

    if(NULL == pszDevice)
    {
        return E_OUTOFMEMORY;
    }

    length = LoadString(g_hInstance,IDS_ALL_LAN_ADAPTERS, pszDevice, DEVICENAME_LENGTH );

    NumAdapters++;

    if( !DeviceArray.Add(pszDevice) )
    {
        ODS(L"CCfgComp::GetLanAdapterList failed to add device name\n" );
        delete[] pszDevice;
        return E_OUTOFMEMORY;

    }



    do
    {
        ODS( L"CFGBKEND : CoCreateInstance\n" );

        hResult = CoCreateInstance(CLSID_CNetCfg,NULL,CLSCTX_SERVER,IID_INetCfg,(LPVOID *)&pnetCfg);

        if( FAILED( hResult ) )
        {
            ODS( L"CFGBKEND : CoCreateInstance(CLSID_CNetCfg) failed\n" );

            break;
        }

        if( pnetCfg != NULL )
        {
            ODS( L"pnetCfg->Initialize\n" );

            // shaun cox changed the netcfgx.idl file
            // alhen

            hResult = pnetCfg->Initialize( NULL );

            if( FAILED( hResult ) || pnetCfg == NULL )
            {
                ODS( L"CFGBKEND : netCfg::Init failed\n" );

                break;
            }

            if( lstrcmpi( szProtocol , NETCFG_SERVICE_CID_MS_NETBIOS ) == 0 )
            {

                ODS( L"pnetCfg->QueryNetCfgClass for GUID_DEVCLASS_NETSERVICE\n" );

                hResult = pnetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NETSERVICE ,IID_INetCfgClass,(void **)&pNetCfgClass);

                if( FAILED( hResult ) || pNetCfgClass == NULL)
                {
                    ODS( L"CFGBKEND : pnetCfg->QueryNetCfgClass failed\n" );

                    break;
                }
            }
            else
            {
                ODS( L"pnetCfg->QueryNetCfgClass for GUID_DEVCLASS_NETTRANS\n" );

                hResult = pnetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NETTRANS ,IID_INetCfgClass,(void **)&pNetCfgClass);

                if( FAILED( hResult ) || pNetCfgClass == NULL)
                {
                    ODS( L"CFGBKEND : pnetCfg->QueryNetCfgClass failed\n" );

                    break;
                }
            }


            ODS( L"pnetCfg->QueryNetCfgClass\n" );

            hResult = pnetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NET ,IID_INetCfgClass,(void **)&pNetCfgClassAdapter);

            if( FAILED( hResult ) || pNetCfgClassAdapter == NULL )
            {
                ODS( L"CFGBKEND : pnetCfg->QueryNetCfgClass failed\n" );

                break;
            }

            ODS( L"pNetCfgClass->FindComponent\n");

            hResult = pNetCfgClass->FindComponent(szProtocol,&pNetCfgComponentprot);

            if( FAILED( hResult ) || pNetCfgComponentprot == NULL)
            {
                ODS( L"CFGBKEND : pnetCfg->FindComponent\n" );

                break;
            }

            ODS( L"pNetCfgComponentprot->QueryInterface\n" );

            hResult = pNetCfgComponentprot->QueryInterface(IID_INetCfgComponentBindings,(void **)&pBinding);

            if( FAILED( hResult ) || pBinding == NULL )
            {
                ODS( L"CFGBKEND : pNetCfgComponentprot->QueryInterface(IID_INetCfgComponentBindings ) failed \n " );
                break;
            }

            ODS( L"pNetCfgClassAdapter->EnumComponents\n" );

            hResult = pNetCfgClassAdapter->EnumComponents(&pEnumComponent);

            RELEASEPTR(pNetCfgClassAdapter);

            if( FAILED( hResult ) || pEnumComponent == NULL )
            {
                ODS( L"CFGBKEND : pNetCfgClassAdapter->EnumComponents failed \n" );
                break;
            }

            // hResult = S_OK;

            while(TRUE)
            {
                ODS( L"pEnumComponent->Next(1,&pNetCfgComponent,&count) \n" );

                hr = pEnumComponent->Next(1,&pNetCfgComponent,&count);

                if(count == 0 || NULL == pNetCfgComponent)
                {
                    break;
                }

                ODS( L"pNetCfgComponent->GetCharacteristics(&dwCharacteristics) \n" );

                hr = pNetCfgComponent->GetCharacteristics(&dwCharacteristics);

                if( FAILED( hr ) )
                {
                    RELEASEPTR(pNetCfgComponent);

                    ODS( L"CFGBKEND : pNetCfgComponent->GetCharacteristics failed\n" );

                    continue;
                }

                if(dwCharacteristics & NCF_PHYSICAL)
                {
                    ODS( L"pBinding->IsBoundTo(pNetCfgComponent)\n" );

                    if(S_OK == pBinding->IsBoundTo(pNetCfgComponent))
                    {
                        ODS( L"pNetCfgComponent->GetDisplayName(&pDisplayName)\n" );

                        hResult = pNetCfgComponent->GetDisplayName(&pDisplayName);

                        if( FAILED( hResult ) )
                        {
                            ODS( L"CFGBKEND : pNetCfgComponent->GetDisplayName failed\n");
                            RELEASEPTR(pNetCfgComponent);
                            continue;
                        }

                        // this is not a leak Device array copies the ptr
                        // and we release towards the end

                        pszDevice = new TCHAR[DEVICENAME_LENGTH];

                        if(NULL == pszDevice)
                        {
                            hResult = E_OUTOFMEMORY;
                            break;
                        }

                        lstrcpy(pszDevice,pDisplayName);

                        DBGMSG( L"CFGBKEND: Adapter name %ws\n" , pszDevice );

                        if( !DeviceArray.Add(pszDevice) )
                        {
                            ODS( L"CFGBKEND: device name not added to list\n" );
                            delete[] pszDevice;
                            hResult = E_OUTOFMEMORY;
                            break;
                        }

                        NumAdapters++;

                        CoTaskMemFree(pDisplayName);
                    
                    }  
                }
                RELEASEPTR(pNetCfgComponent);
            }
        }

    }while( 0 );


    ODS( L"RELEASEPTR(pBinding)\n" );

    RELEASEPTR(pBinding);

    ODS( L"RELEASEPTR(pEnumComponent)\n" );

    RELEASEPTR(pEnumComponent);

    ODS( L"RELEASEPTR(pNetCfgComponentprot)\n" );

    RELEASEPTR(pNetCfgComponentprot);

    ODS( L"RELEASEPTR(pNetCfgComponent)\n" );

    RELEASEPTR(pNetCfgComponent);

    ODS( L"RELEASEPTR(pNetCfgClass)\n" );

    RELEASEPTR(pNetCfgClass);

    if( pnetCfg != NULL )
    {
        pnetCfg->Uninitialize();
    }

    ODS( L"RELEASEPTR(pnetCfg)\n" );

    RELEASEPTR(pnetCfg);

    if( SUCCEEDED( hResult ) )
    {
        //Allocate Memory using CoTaskMemAlloc and copy data

        *ppData = (WCHAR *)CoTaskMemAlloc(NumAdapters * sizeof(TCHAR) * DEVICENAME_LENGTH);

        if(*ppData == NULL)
        {
            hResult = E_OUTOFMEMORY;
        }
        else
        {
            pTempPointer = (DEVICENAMEW *)(*ppData);

            for(int i=0; i<NumAdapters; i++)
            {
                lstrcpy(pTempPointer[i],(TCHAR *)DeviceArray[i]);
            }
        }

    }

    for(int i=0;i < DeviceArray.GetSize();i++)
    {
        ODS( L"Deleteing DeviceArray\n" );

        // I told u so.

        delete [] DeviceArray[i];
    }

    *pNumAdapters = NumAdapters;

    return hResult;
}

/***************************************************************************************************************

  Name:      GetLanAdapterList2

  Purpose:   Gets the List of Lan Adapters associated with a given protocol
             Determine if lan ids are valid

  Returns:   HRESULT.

  Params:
             in:    pdName - Name of the protocol.
             out:   pNumAdapters: pointer to the number of Lan adapters returned
                    ppGuidtbl:

  GUIDTBL

  -----------------------------
  DispName    display name [ 128 ]
  guidNIC     32 byte buffer
  dwLana       value is set if regkey entry exist otherwise it will be created in the order obtained
  dwStatus    Any errors reported on a particular guid entry
  -----------------------------


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetLanAdapterList2(WCHAR * pdName, ULONG * pNumAdapters , PGUIDTBL *ppGuidtbl )
{
    HRESULT hResult = S_OK;

    int nMaxLanAdapters = 4;

    //If not initialized return error
    if(!m_bInitialized)
    {
        ODS( L"CCfgComp::GetLanAdapterList2 returned CFGBKEND_E_NOT_INITIALIZED\n" );

        return CFGBKEND_E_NOT_INITIALIZED;
    }

    if(NULL == pdName || NULL == pNumAdapters )
    {
        ODS( L"CCfgComp::GetLanAdapterList2 returned INVALIDARG \n" );

        return E_INVALIDARG;
    }

    *pNumAdapters = 0;

    int NumAdapters = 0;

    //

    *ppGuidtbl = ( PGUIDTBL )CoTaskMemAlloc( sizeof( GUIDTBL ) * nMaxLanAdapters );

    if( *ppGuidtbl == NULL )
    {
        return E_OUTOFMEMORY;
    }

    ZeroMemory( *ppGuidtbl , sizeof( GUIDTBL ) * nMaxLanAdapters );

     //Interface pointer declarations

    TCHAR szProtocol[256];

    INetCfg * pnetCfg = NULL;

    INetCfgClass * pNetCfgClass = NULL;

    INetCfgClass * pNetCfgClassAdapter = NULL;

    INetCfgComponent * pNetCfgComponent = NULL;

    INetCfgComponent * pNetCfgComponentprot = NULL;

    IEnumNetCfgComponent * pEnumComponent = NULL;

    INetCfgComponentBindings * pBinding = NULL;

    LPWSTR pDisplayName = NULL;

    DWORD dwCharacteristics;

    ULONG count = 0;


    if( 0 == lstrcmpi( pdName , L"tcp" ) )
    {
        lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_TCPIP);
    }
    else if( 0 == lstrcmpi( pdName , L"netbios" ) )
    {
        lstrcpy(szProtocol,NETCFG_SERVICE_CID_MS_NETBIOS);
    }
    else if( 0 == lstrcmpi( pdName, L"ipx" ) )
    {
        lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_NWIPX);
    }
    else if( 0 == lstrcmpi( pdName , L"spx" ) )
    {
        //lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_NWSPX);
        lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_NWIPX);
    }
    else
    {
        return E_INVALIDARG;
    }
    /*
    * Assumption: No NetBios Lana MAPPING
    */
    //The First entry will be "All Lan Adapters"

    if( lstrcmpi( pdName , L"netbios" ) != 0 )
    {
        LoadString( g_hInstance , IDS_ALL_LAN_ADAPTERS , (*ppGuidtbl )[0].DispName , DEVICENAME_LENGTH );

        NumAdapters++;
    }



    do
    {
        ODS( L"CFGBKEND:GetLanAdapterList2 CoCreateInstance\n" );

        hResult = CoCreateInstance(CLSID_CNetCfg,NULL,CLSCTX_SERVER,IID_INetCfg,(LPVOID *)&pnetCfg);

        if( FAILED( hResult ) )
        {
            ODS( L"CFGBKEND:GetLanAdapterList2 CoCreateInstance(CLSID_CNetCfg) failed\n" );

            break;
        }

        if( pnetCfg != NULL )
        {
            ODS( L"CFGBKEND:GetLanAdapterList2 pnetCfg->Initialize\n" );

            // shaun cox changed the netcfgx.idl file
            // alhen

            hResult = pnetCfg->Initialize( NULL );

            if( FAILED( hResult ) )
            {
                ODS( L"CFGBKEND:GetLanAdapterList2 netCfg::Init failed\n" );

                break;
            }

            if( lstrcmpi( szProtocol , NETCFG_SERVICE_CID_MS_NETBIOS ) == 0 )
            {

                ODS( L"CFGBKEND:GetLanAdapterList2 pnetCfg->QueryNetCfgClass for GUID_DEVCLASS_NETSERVICE\n" );

                hResult = pnetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NETSERVICE ,IID_INetCfgClass,(void **)&pNetCfgClass);

                if( FAILED( hResult ) || pNetCfgClass == NULL)
                {
                    ODS( L"CFGBKEND:GetLanAdapterList2 pnetCfg->QueryNetCfgClass failed\n" );

                    break;
                }
            }
            else
            {
                ODS( L"CFGBKEND:GetLanAdapterList2 pnetCfg->QueryNetCfgClass for GUID_DEVCLASS_NETTRANS\n" );

                hResult = pnetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NETTRANS ,IID_INetCfgClass,(void **)&pNetCfgClass);

                if( FAILED( hResult ) || pNetCfgClass == NULL)
                {
                    ODS( L"CFGBKEND:GetLanAdapterList2 pnetCfg->QueryNetCfgClass failed\n" );

                    break;
                }
            }


            ODS( L"CFGBKEND:GetLanAdapterList2 pnetCfg->QueryNetCfgClass\n" );

            hResult = pnetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NET ,IID_INetCfgClass,(void **)&pNetCfgClassAdapter);

            if( FAILED( hResult ) || pNetCfgClassAdapter == NULL )
            {
                ODS( L"CFGBKEND:GetLanAdapterList2 pnetCfg->QueryNetCfgClass failed\n" );

                break;
            }

            ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgClass->FindComponent\n");

            hResult = pNetCfgClass->FindComponent(szProtocol,&pNetCfgComponentprot);

            if( FAILED( hResult ) || pNetCfgComponentprot == NULL)
            {
                ODS( L"CFGBKEND:GetLanAdapterList2 pnetCfg->FindComponent\n" );

                break;
            }

            ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgComponentprot->QueryInterface\n" );

            hResult = pNetCfgComponentprot->QueryInterface(IID_INetCfgComponentBindings,(void **)&pBinding);

            if( FAILED( hResult ) || pBinding == NULL )
            {
                ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgComponentprot->QueryInterface(IID_INetCfgComponentBindings ) failed \n " );
                break;
            }

            ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgClassAdapter->EnumComponents\n" );

            hResult = pNetCfgClassAdapter->EnumComponents(&pEnumComponent);

            RELEASEPTR(pNetCfgClassAdapter);

            if( FAILED( hResult ) || pEnumComponent == NULL )
            {
                ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgClassAdapter->EnumComponents failed \n" );
                break;
            }

            // hResult = S_OK;

            while(TRUE)
            {
                ODS( L"CFGBKEND:GetLanAdapterList2 pEnumComponent->Next(1,&pNetCfgComponent,&count) \n" );

                hResult = pEnumComponent->Next(1,&pNetCfgComponent,&count);

                if(count == 0 || NULL == pNetCfgComponent)
                {
                    break;
                }

                ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgComponent->GetCharacteristics(&dwCharacteristics) \n" );

                hResult = pNetCfgComponent->GetCharacteristics(&dwCharacteristics);

                if( FAILED( hResult ) )
                {
                    RELEASEPTR(pNetCfgComponent);

                    ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgComponent->GetCharacteristics failed\n" );

                    continue;
                }

                DBGMSG( L"dwCharacteritics are 0x%x\n", dwCharacteristics );

                if((dwCharacteristics & NCF_PHYSICAL) ||
					((dwCharacteristics & NCF_VIRTUAL) && !(dwCharacteristics & NCF_HIDDEN)))
                {
                    ODS( L"CFGBKEND:GetLanAdapterList2 pBinding->IsBoundTo(pNetCfgComponent)\n" );

                    if(S_OK == pBinding->IsBoundTo(pNetCfgComponent))
                    {
                        if( NumAdapters >= nMaxLanAdapters )
                        {
                            // add four more adapters
                            nMaxLanAdapters += 4;

                            *ppGuidtbl = ( PGUIDTBL )CoTaskMemRealloc( *ppGuidtbl , sizeof( GUIDTBL ) * nMaxLanAdapters );

                            if( *ppGuidtbl == NULL )
                            {
                                RELEASEPTR(pNetCfgComponent);
                                return E_OUTOFMEMORY;
                            }
                        }

                        ULONG ulDeviceStatus = 0;

                        hResult = pNetCfgComponent->GetDeviceStatus( &ulDeviceStatus );

                        if( FAILED( hResult ) )
                        {
                            DBGMSG( L"CFGBKEND:GetLanAdapterList2 GetDevice failed with 0x%x\n" , hResult );

                            RELEASEPTR(pNetCfgComponent);
                            continue;
                        }

                        DBGMSG( L"GetDevice status returned 0x%x\n" , ulDeviceStatus );

                        if( ulDeviceStatus == CM_PROB_DEVICE_NOT_THERE )
                        {
                            ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgComponent->GetDeviceStatus PNP device not there\n");
                            RELEASEPTR(pNetCfgComponent);
                            continue;
                        }

                        ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgComponent->GetDisplayName\n" );
                                                    
                        hResult = pNetCfgComponent->GetDisplayName(&pDisplayName);

                        if( FAILED( hResult ) )
                        {
                            ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgComponent->GetDisplayName failed\n");
                            RELEASEPTR(pNetCfgComponent);
                            continue;
                        }

                        ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgComponent->GetInstanceGuid\n" );

                        hResult = pNetCfgComponent->GetInstanceGuid( & ( ( *ppGuidtbl )[ NumAdapters ].guidNIC ) );

                        if( FAILED( hResult ) )
                        {
                            ODS( L"CFGBKEND:GetLanAdapterList2 pNetCfgComponent->GetInstanceGuid failed\n");
                            RELEASEPTR(pNetCfgComponent);

                            continue;
                        }

                        lstrcpy( ( *ppGuidtbl )[ NumAdapters ].DispName , pDisplayName );

                        // the lana value will be adjusted if guid entry exist

                        // ( *ppGuidtbl )[ NumAdapters ].dwLana = ( DWORD )NumAdapters;

                        NumAdapters++;

                        CoTaskMemFree(pDisplayName);
                    }                                    
                }
                RELEASEPTR(pNetCfgComponent);
            }
        }

    }while( 0 );


    ODS( L"RELEASEPTR(pBinding)\n" );

    RELEASEPTR(pBinding);

    ODS( L"RELEASEPTR(pEnumComponent)\n" );

    RELEASEPTR(pEnumComponent);

    ODS( L"RELEASEPTR(pNetCfgComponentprot)\n" );

    RELEASEPTR(pNetCfgComponentprot);

    ODS( L"RELEASEPTR(pNetCfgComponent)\n" );

    RELEASEPTR(pNetCfgComponent);

    ODS( L"RELEASEPTR(pNetCfgClass)\n" );

    RELEASEPTR(pNetCfgClass);

    if( pnetCfg != NULL )
    {
        pnetCfg->Uninitialize();
    }

    ODS( L"RELEASEPTR(pnetCfg)\n" );

    RELEASEPTR(pnetCfg);

    if( SUCCEEDED( hResult ) )
    {
        //
        // Verify the existence of the guidtable and its entries
        // also re-assign lana ids.
        //

        VerifyGuidsExistence( ppGuidtbl , ( int )NumAdapters , pdName );

    }


    *pNumAdapters = NumAdapters;

    return hResult;
}

/***************************************************************************************************************

  Name:      VerifyGuidsExistence

  Purpose:   Determines the existence of the guid entries and reassigns lana ids

  Note:      ppGuidtbl passed in is valid

  Returns:   void

  Params:    [in] GUIDTBL **
             [in] number of guid entries

***************************************************************************************************************/
void CCfgComp::VerifyGuidsExistence( PGUIDTBL *ppGuidtbl , int cItems , WCHAR *pdName )
{
    HKEY hKey;

    DWORD dwStatus;

    TCHAR tchRootKey[ MAX_PATH ];

    TCHAR tchGuid[ 40 ];

    ODS( L"CFGBKEND:VerifyGuidsExistence\n" );

    int nStart = 1;

    if( lstrcmpi( pdName , L"netbios" ) == 0 )
    {
        nStart = 0;
    }

    for( int idx = nStart ; idx < cItems ; ++idx )
    {
        lstrcpy( tchRootKey , REG_GUID_TABLE );

        StringFromGUID2( ( *ppGuidtbl )[ idx ].guidNIC , tchGuid , ARRAYSIZE( tchGuid ) );

        lstrcat( tchRootKey , tchGuid );

        dwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE , tchRootKey , 0 , KEY_READ , &hKey );

        ( *ppGuidtbl )[ idx ].dwStatus = dwStatus;

        if( dwStatus == ERROR_SUCCESS )
        {
            DWORD dwSize = sizeof( DWORD );

            RegQueryValueEx( hKey , LANA_ID , NULL , NULL , ( LPBYTE ) &( ( *ppGuidtbl )[ idx ].dwLana ) , &dwSize );

            DBGMSG( L"CFGBKEND: VerifyGuidsExistence LanaId retrieved = %d\n" , ( *ppGuidtbl )[ idx ].dwLana );
        }
        else
        {
            ODS( L"CFGBKEND: VerifyGuidsExistence NIC must be new\n" );

            ( *ppGuidtbl )[ idx ].dwLana = 0 ;
        }


        RegCloseKey( hKey );
    }

    return;
}

/***************************************************************************************************************

  Name:      BuildGuidTable

  Purpose:   Given valid table entries reconstruct table

  Note:      ppGuidtbl passed in is valid and 1 base

  Returns:   HRESULT

  Params:    [in] GUIDTBL **
             [in] number of guid entries

***************************************************************************************************************/
HRESULT CCfgComp::BuildGuidTable( PGUIDTBL *ppGuidtbl , int cItems , WCHAR *pdName )
{
    HKEY hKey;

    HKEY hSubKey;

    DWORD dwStatus;

    DWORD dwDisp;

    DWORD dwSize = sizeof( DWORD );

    TCHAR tchRootKey[ MAX_PATH ];

    TCHAR tchGuid[ 40 ];

    DWORD rgdwOldLanaIds[ 256 ] = { 0 }; // man what machine will hold 256 nics?

    // get last lanaIndex

    dwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE , REG_GUID_TABLE , 0 , KEY_READ , &hKey );

    DWORD dwMaxIdVal = 0;

    DWORD dwVal = 0;

    int nOldAdapters = 0;

    if( dwStatus == ERROR_SUCCESS )
    {
        do
        {
            dwStatus = RegEnumKey( hKey , nOldAdapters , tchGuid , sizeof( tchGuid ) / sizeof( TCHAR ) );

            if( dwStatus != ERROR_SUCCESS )
            {
                break;
            }

            if( RegOpenKeyEx( hKey , tchGuid , 0 , KEY_READ , &hSubKey ) == ERROR_SUCCESS )
            {
                RegQueryValueEx( hSubKey , LANA_ID , NULL , NULL , ( LPBYTE ) &dwVal , &dwSize );

                rgdwOldLanaIds[ nOldAdapters ] = dwVal;

                // calculate max value

                if( dwMaxIdVal < dwVal )
                {
                    dwMaxIdVal = dwVal;
                }

                RegCloseKey( hSubKey );
            }

            nOldAdapters++;

            _ASSERTE( nOldAdapters < 256 );

        } while( 1 );

        RegCloseKey( hKey );
    }

    // remove old table

    RecursiveDeleteKey( HKEY_LOCAL_MACHINE , REG_GUID_TABLE_T );

    // create new table

    int nStart = 1;

    if( lstrcmpi( pdName , L"netbios" ) == 0 )
    {
        nStart = 0;
    }

    for( int idx = nStart ; idx < cItems ; ++idx )
    {
        lstrcpy( tchRootKey , REG_GUID_TABLE );

        StringFromGUID2( ( *ppGuidtbl )[ idx ].guidNIC , tchGuid , ARRAYSIZE( tchGuid ) );

        lstrcat( tchRootKey , tchGuid );

        // modify lana id

        if( ( *ppGuidtbl )[ idx ].dwStatus != ERROR_SUCCESS )
        {
            ( *ppGuidtbl )[ idx ].dwLana = 0;

            AdjustLanaId( ppGuidtbl , cItems , idx , &dwMaxIdVal , rgdwOldLanaIds , &nOldAdapters , nStart );
        }

        dwStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE , tchRootKey , 0 ,  NULL , REG_OPTION_NON_VOLATILE , KEY_READ|KEY_WRITE , NULL , &hKey , &dwDisp );

        ( *ppGuidtbl )[ idx ].dwStatus = dwStatus;


        if( dwStatus == ERROR_SUCCESS )
        {
            RegSetValueEx( hKey , LANA_ID , 0 , REG_DWORD , ( LPBYTE )& ( ( *ppGuidtbl )[ idx ].dwLana ) , sizeof( DWORD ) );

            RegCloseKey( hKey );
        }
    }

    return S_OK;
}

/*-----------------------------------------------------------------------------------------------
     AdjustLanaId

    PARAMETERS: pGuidtbl : Table of queried entries
                cItems   : Number of items in list
                idx      : Entry to modify lana
                pdwMaxIndex : New max value of lana index

    NOTES:      Since Lana is a dword; after 2^32-1 iterations lana ids will recycle to
                the first available entry
-----------------------------------------------------------------------------------------------*/
HRESULT CCfgComp::AdjustLanaId( PGUIDTBL *ppGuidtbl , int cItems , int idx , PDWORD pdwMaxId , PDWORD pdwOldLanaIds , int* pnOldItems , int nStart )
{
    // find the maxium value for the lana_id


    for( int i = nStart ; i < cItems ; ++i )
    {
        if( *pdwMaxId < ( *ppGuidtbl )[ i ].dwLana )
        {
            *pdwMaxId = ( *ppGuidtbl )[ i ].dwLana ;
        }
    }

    *pdwMaxId = *pdwMaxId + 1;

    // check for overflow max id will be 0xfffffffe

    if( *pdwMaxId == ( DWORD )-1 )
    {
        *pdwMaxId = 1;

        do
        {
            for( i = 0 ; i < *pnOldItems; ++i )
            {
                if( *pdwMaxId == pdwOldLanaIds[ i ] )
                {
                    *pdwMaxId = *pdwMaxId + 1;

                    break;
                }
            }

            if( i >= *pnOldItems )
            {
                // no duplicate found use the current maxid

                break;
            }

        } while( 1 );


    }

    ( *ppGuidtbl )[ idx ].dwLana = *pdwMaxId;

    // add new entry to the old table

    if( *pnOldItems < 256 )
    {
        pdwOldLanaIds[ *pnOldItems ] = *pdwMaxId;

        *pnOldItems = *pnOldItems + 1;
    }

    return S_OK;
}



//----------------------------------------------------------------------------------------------
// Delete a key and all of its descendents.
//----------------------------------------------------------------------------------------------
DWORD RecursiveDeleteKey( HKEY hKeyParent , LPTSTR lpszKeyChild )
{
        // Open the child.
        HKEY hKeyChild;

        DWORD dwRes = RegOpenKeyEx(hKeyParent, lpszKeyChild , 0 , KEY_WRITE | KEY_READ, &hKeyChild);

        if (dwRes != ERROR_SUCCESS)
        {
                return dwRes;
        }

        // Enumerate all of the decendents of this child.

        FILETIME time;

        TCHAR szBuffer[256];

        DWORD dwSize = sizeof( szBuffer ) / sizeof( TCHAR );

        while( RegEnumKeyEx( hKeyChild , 0 , szBuffer , &dwSize , NULL , NULL , NULL , &time ) == S_OK )
        {
        // Delete the decendents of this child.

                dwRes = RecursiveDeleteKey(hKeyChild, szBuffer);

                if (dwRes != ERROR_SUCCESS)
                {
                        RegCloseKey(hKeyChild);

                        return dwRes;
                }

                dwSize = sizeof( szBuffer ) / sizeof( TCHAR );
        }

        // Close the child.

        RegCloseKey( hKeyChild );

        // Delete this child.

        return RegDeleteKey( hKeyParent , lpszKeyChild );
}

/***************************************************************************************************************

  Name:      SetUserConfig

  Purpose:   Sets the UserConfig for a Winstation

  Returns:   HRESULT.

  Params:
             in:    pWSName - Name of the Winstation.
                    pUserConfig - Pointer to the UserConfig to be set

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::SetUserConfig(PWINSTATIONNAMEW pWsName, ULONG /*size*/, PUSERCONFIG pUserConfig , PDWORD pdwStatus)
{
    *pdwStatus = ERROR_INVALID_PARAMETER;

    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;

    //Check if the caller has write permissions.
    if( !m_bAdmin)
    {
        *pdwStatus = ERROR_ACCESS_DENIED;
        ODS( L"CFGBKEND: ERROR_ACCESS_DENIED\n" );
        return E_ACCESSDENIED;
    }

    //Check the parameters for NULL
    if(NULL == pWsName || NULL == pUserConfig)
    {
        return E_INVALIDARG;
    }

    //Check for the validity of the Winstation name
    if(NULL == GetWSObject(pWsName))
    {
        *pdwStatus = ERROR_INVALID_NAME;
        return E_INVALIDARG;
    }

    *pdwStatus = RegCreateUserConfigW(NULL, pWsName, pUserConfig);

    return S_OK;
}

/***************************************************************************************************************

  Name:      EnableWinstation

  Purpose:   Enables/Disables a given Winstation

  Returns:   HRESULT.

  Params:
             in:    pWSName - Name of the Winstation.
                    fEnable - TRUE: Enable, FALSE:Disable

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::EnableWinstation(PWINSTATIONNAMEW pWSName, BOOL fEnable)
{

    WINSTATIONCONFIG2W WsConfig;
    LONG Status;
    ULONG Length;

    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;

    //Check if the caller has write permissions.
    if(!m_bAdmin)
        return E_ACCESSDENIED;

    //Check the parametes for NULL
    if(NULL == pWSName)
        return E_INVALIDARG;


    //Check for the validity of the Winstation name, this would eliminate the system console

    if(NULL == GetWSObject(pWSName))
        return E_INVALIDARG;

    // Query the registry for WinStation data
    Status = RegWinStationQueryW( NULL,pWSName,&WsConfig,sizeof(WINSTATIONCONFIG2W), &Length);
    if(Status)
        return E_FAIL;

    WsConfig.Create.fEnableWinStation = fEnable;
    Status = RegWinStationCreateW(NULL,pWSName,FALSE,&WsConfig,sizeof(WsConfig));
    if ( Status)
        return E_FAIL;

    return S_OK;
}

/***************************************************************************************************************

  Name:      RenameWinstation

  Purpose:   Renames a given Winstation

  Returns:   HRESULT.

  Params:
             in:    pOldWinstation - Name of the Winstation to be renamed.
                    pNewWinstation - New Name for the Winstation

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::RenameWinstation(PWINSTATIONNAMEW pOldWinstation, PWINSTATIONNAMEW pNewWinstation)
{

    WINSTATIONCONFIG2W WsConfig;
    LONG Status, size = 0;
    ULONG Length; BOOL Unique;
    void * pExtObject = NULL;
    void * pExtDupObject = NULL;
    HRESULT hResult = S_OK;
    PWD pWD = NULL;
    PWS pWS = NULL;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;


    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;
    //Check if the caller has write permissions.

    if(!m_bAdmin)
        return E_ACCESSDENIED;

    //Check the parametes for NULL

    if(NULL == pOldWinstation || NULL == pNewWinstation)
        return E_INVALIDARG;

    //Check winstation names are of valid lengths
    if ( lstrlen(pOldWinstation) > WINSTATIONNAME_LENGTH || lstrlen(pNewWinstation) > WINSTATIONNAME_LENGTH )
        return E_INVALIDARG;

    IsWSNameUnique(pNewWinstation,&Unique);
    if(!Unique)
        return E_INVALIDARG;


    //The new Winstation Name cannot be Console

    if(0 ==(lstrcmpi(pNewWinstation,m_szConsole)))
        return E_INVALIDARG;

    //Check the length of the new winstation name

    if(lstrlen(pNewWinstation) > WINSTATIONNAME_LENGTH)
        return E_INVALIDARG;

    //Check for the validity of the Winstation name, this would eliminate the system console

    pWS = GetWSObject(pOldWinstation);
    if(NULL == pWS)
        return E_INVALIDARG;

    //Get the WD object associated with this Winstation.

    pWD = GetWdObject(pWS->wdName);
    if(NULL == pWD)
        return E_FAIL;

    //Query the registry for WinStation data
    Status = RegWinStationQueryW(NULL,pOldWinstation,&WsConfig,sizeof(WINSTATIONCONFIG2W), &Length);
    if(Status)
        return E_FAIL;


    //Get the ExtensionObject data(third party) this will be used for Creating and Deleting the registry keys.

    if(pWD->lpfnExtRegQuery && pWD->hExtensionDLL)
    {
        pExtObject = (pWD->lpfnExtRegQuery)(pOldWinstation, &(WsConfig.Pd[0]));

    }

    // Get the Security descriptor for the old Winstation
    // Must free pSecurityDescriptor via LocalFree]

    // check to see if previous winstation had a security key defined --
    // we do this so that if the default security was used we don't
    // create a "security" keyvalue in the new winstation

    HKEY hKeyWinstation;
    HKEY hKeyWinstationName;

    if( RegOpenKeyEx(
            HKEY_LOCAL_MACHINE ,
            WINSTATION_REG_NAME,
            0,
            KEY_READ,
            &hKeyWinstation ) == ERROR_SUCCESS)
    {
        if( RegOpenKeyEx( 
                hKeyWinstation ,
                pOldWinstation ,
                0 ,
                KEY_READ,
                &hKeyWinstationName ) == ERROR_SUCCESS)
        {
            if( RegQueryValueEx( 
                    hKeyWinstationName ,
                    L"Security" ,
                    NULL ,
                    NULL ,
                    NULL ,
                    NULL ) == ERROR_SUCCESS )
            {                
                hResult = GetSecurityDescriptor(
                            pOldWinstation ,
                            &size ,
                            &pSecurityDescriptor );
            }

            RegCloseKey( hKeyWinstationName );
        }

        RegCloseKey( hKeyWinstation );
    }

    if( FAILED( hResult ) )
    {
        DBGMSG( L"CFGBKEND!RenameWinstation GetSecurityDescriptor failed 0x%x\n " , hResult );
        return E_FAIL;
    }

    do
    {
        //Create a new registry key with the data.

        Status = RegWinStationCreateW(NULL,pNewWinstation,TRUE,&WsConfig,sizeof(WsConfig));

        if( Status != ERROR_SUCCESS )
        {
            hResult = E_FAIL;

            break;
        }

        //Create new extension data.

        if(pWD->lpfnExtDupObject && pWD->hExtensionDLL && pExtObject)
        {
            pExtDupObject = (pWD->lpfnExtDupObject)(pExtObject);

            if(pWD->lpfnExtRegCreate && pWD->hExtensionDLL && pExtDupObject)
            {
                (pWD->lpfnExtRegCreate)(pNewWinstation,pExtDupObject,TRUE);
            }
        }

        //Set the Security information from the previous Winstation

        if( pSecurityDescriptor != NULL )
        {
            hResult = SetSecurityDescriptor(pNewWinstation,size,pSecurityDescriptor);

            if( FAILED( hResult ) )
            {
                break;
            }
        }

        //delete old extension data

        if(pWD->lpfnExtRegDelete && pWD->hExtensionDLL && pExtObject)
        {
            if( ERROR_SUCCESS != ( ( pWD->lpfnExtRegDelete )( pOldWinstation , pExtObject ) ) )
            {
                hResult = CFGBKEND_EXTDELETE_FAILED;
            }
        }


        //Delete old registy key

        Status = RegWinStationDeleteW(NULL,pOldWinstation);

        if( Status != ERROR_SUCCESS )
        {
            //delete the new winstation that was created

            if(pWD->lpfnExtRegDelete && pWD->hExtensionDLL && pExtDupObject)
            {
                (pWD->lpfnExtRegDelete)(pNewWinstation,pExtDupObject);
            }

            RegWinStationDeleteW(NULL,pNewWinstation);

            hResult = E_FAIL;

            break;
       }

        //update the object created in the list of winstation objects.

        lstrcpy(pWS->Name, pNewWinstation);

    } while( 0 );

    //Release pSecurityDescriptor Memory

    if( pSecurityDescriptor != NULL )
    {
        LocalFree( pSecurityDescriptor );
    }

    //Delete the Extension Objects.

    if(pWD->lpfnExtDeleteObject && pWD->hExtensionDLL)
    {
        if( pExtObject )
            (pWD->lpfnExtDeleteObject)(pExtObject);

        if(pExtDupObject)
            (pWD->lpfnExtDeleteObject)(pExtDupObject);

    }

    if(hResult == CFGBKEND_EXTDELETE_FAILED)
    {
        if(pWD->lpfnExtRegDelete && pWD->hExtensionDLL && pExtObject)
            (pWD->lpfnExtRegDelete)(pOldWinstation,pExtObject);
    }

    // force termsrv to re-read settings!!!

    hResult = ForceUpdate( );

    return hResult;

}

/***************************************************************************************************************

  Name:      IsSessionReadOnly

  Purpose:   Checks if the Current session readonly.

  Returns:   HRESULT.

  Params:
             out:   pReadOnly - pointer to whether the current session is readonly.

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::IsSessionReadOnly(BOOL * pReadOnly)
{
    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;

    if(NULL == pReadOnly)
        return E_INVALIDARG;

    *pReadOnly = !m_bAdmin;

    return S_OK;
}

/***************************************************************************************************************

  Name:      UnInitialize

  Purpose:   Uninitializes the Object

  Returns:   HRESULT.

  Params:

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::UnInitialize()
{
    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;

    DeleteWDArray();
    DeleteWSArray();
    m_bInitialized = FALSE;
    return S_OK;
}

/***************************************************************************************************************

  Name:      DeleteWDArray

  Purpose:   Internal function to delete m_WdArray

  Returns:   void.

  Params:

 ****************************************************************************************************************/
void CCfgComp::DeleteWDArray()
{
    for(int i = 0; i < m_WDArray.GetSize();i++)
    {
        PWD pWd = ( PWD )m_WDArray[ i ];

        if( pWd != NULL )
        {
            if( pWd->hExtensionDLL != NULL )
            {
//                ODS( L"Freeing extension dll\n" );
                FreeLibrary( pWd->hExtensionDLL );
            }

            for( int j = 0 ; j < pWd->PDConfigArray.GetSize( ); j++ )
            {
                if( pWd->PDConfigArray[ j ] != NULL )
                {
                    delete[] pWd->PDConfigArray[ j ];
                }
            }

            delete[] m_WDArray[i];
        }
    }

    m_WDArray.RemoveAll( );

    return;


}

/***************************************************************************************************************

  Name:      DeleteWSArray

  Purpose:   Internal function to delete m_WSArray

  Returns:   void.

  Params:

 ****************************************************************************************************************/
void CCfgComp::DeleteWSArray()
{
    for(int i = 0; i <m_WSArray.GetSize();i++)
    {
        if(m_WSArray[i])
            delete [] m_WSArray[i];
    }

    m_WSArray.RemoveAll( );
    return;

}


/***************************************************************************************************************

  Name:      GetDefaultSecurityDescriptor

  Purpose:   Gets the Default Security Descriptor for a Winstation

  Returns:   HRESULT.

  Params:
             out:   pSize - Size of the allocated buffer
                    ppSecurityDescriptor - Pointer to the buffer containing the security descriptor


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetDefaultSecurityDescriptor(long * pSize, PSECURITY_DESCRIPTOR * ppSecurityDescriptor)
{
    HRESULT hResult = S_OK;

    //If not initialized return error
    if( !m_bInitialized )
    {
        return CFGBKEND_E_NOT_INITIALIZED;
    }

    if(NULL == pSize || NULL == ppSecurityDescriptor)
    {
        return E_INVALIDARG;
    }

    *pSize = 0;

    *ppSecurityDescriptor = NULL;

    //Try Getting Default Security Descriptor

    hResult = GetWinStationSecurity(TRUE, NULL,(PSECURITY_DESCRIPTOR *)ppSecurityDescriptor);

    if(SUCCEEDED(hResult) && *ppSecurityDescriptor != NULL )
    {
        *pSize = GetSecurityDescriptorLength( *ppSecurityDescriptor );
    }

    return hResult;
}


/***************************************************************************************************************

  Name:      UpDateWS

  Purpose:   UpDates the Winstation Information

  Returns:   HRESULT.

  Params:
             in:    winstationInfo - WS
                    Data - Data fields to be updated


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::UpDateWS( PWS pWinstationInfo, DWORD Data , PDWORD pdwStatus, BOOLEAN bPerformMerger )
{
    WINSTATIONCONFIG2W WSConfig;
    ULONG Length;

    _ASSERTE( pWinstationInfo != NULL );

    *pdwStatus = 0;

    if( pWinstationInfo == NULL || !( Data & UPDATE_ALL ) )
    {
        return E_INVALIDARG;
    }

    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;


    //Check if the caller has write permissions.
    if( !m_bAdmin)
    {
        *pdwStatus = ERROR_ACCESS_DENIED;

        return E_ACCESSDENIED;
    }

    //Check for the validity of the Winstation name, this would eliminate the system console

    if(NULL == GetWSObject( pWinstationInfo->Name ) )
    {
        *pdwStatus = ERROR_INVALID_NAME;

        return E_INVALIDARG;
    }

    // Query the registry for WinStation data
    POLICY_TS_MACHINE p;
    memset(&p, 0, sizeof(POLICY_TS_MACHINE));
    *pdwStatus = RegWinStationQueryEx( NULL, &p, pWinstationInfo->Name,&WSConfig,sizeof(WINSTATIONCONFIG2W), &Length, bPerformMerger);

    if( *pdwStatus != ERROR_SUCCESS )
    {
        return E_FAIL;
    }

    if( Data & UPDATE_LANADAPTER )
    {
        WSConfig.Pd[0].Params.Network.LanAdapter = pWinstationInfo->LanAdapter;
    }

    if( Data & UPDATE_ENABLEWINSTATION )
    {
        WSConfig.Create.fEnableWinStation = pWinstationInfo->fEnableWinstation;
    }

    if( Data & UPDATE_MAXINSTANCECOUNT )
    {
        WSConfig.Create.MaxInstanceCount = pWinstationInfo->uMaxInstanceCount;
    }

    if( Data & UPDATE_COMMENT )
    {
        lstrcpy( WSConfig.Config.Comment , pWinstationInfo->Comment );
    }

    /*
    switch(Data)
    {
    case LANADAPTER:
        WSConfig.Pd[0].Params.Network.LanAdapter = winstationInfo.LanAdapter;
        break;
    case ENABLEWINSTATION:
        WSConfig.Create.fEnableWinStation = winstationInfo.fEnableWinstation;
        break;
    case MAXINSTANCECOUNT:
        WSConfig.Create.MaxInstanceCount = winstationInfo.uMaxInstanceCount;
        break;
    case COMMENT:
        lstrcpy(WSConfig.Config.Comment,winstationInfo.Comment);
        break;
    // case ASYNC:
    //    break;
    case ALL:
        WSConfig.Pd[0].Params.Network.LanAdapter = winstationInfo.LanAdapter;
        WSConfig.Create.fEnableWinStation = winstationInfo.fEnableWinstation;
        WSConfig.Create.MaxInstanceCount = winstationInfo.uMaxInstanceCount;
        lstrcpy(WSConfig.Config.Comment,winstationInfo.Comment);
        break;
    default:
        return E_INVALIDARG;
        break;
    }

  */
    *pdwStatus = RegWinStationCreateW( NULL , pWinstationInfo->Name , FALSE , &WSConfig , sizeof( WSConfig ) );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        return E_FAIL;
    }

    // force termsrv to re-read settings!!!

    return ForceUpdate( );

}

/***************************************************************************************************************

  Name:      GetWSInfo

  Purpose:   Gets Information about a Winstation

  Returns:   HRESULT.

  Params:
             in:    pWSName - Name of the Winstation.
             out:   pSize - Size of the allocated buffer
                    ppWS - Pointer to the buffer containing the WS


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetWSInfo(PWINSTATIONNAME pWSName, long * pSize, WS ** ppWS)
{

    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;

    PWS pWS1 = NULL;
    if(NULL == pWSName || NULL == pSize || NULL == ppWS)
        return E_INVALIDARG;

    *ppWS = NULL;

    *pSize = 0;


    pWS1 = GetWSObject(pWSName);
    if(NULL == pWS1)
        return E_INVALIDARG;

    *ppWS = (WS *)CoTaskMemAlloc(sizeof(WS));
    if(NULL == *ppWS)
        return E_OUTOFMEMORY;

    CopyMemory((PVOID)*ppWS,(CONST VOID *)pWS1,sizeof(WS));
    *pSize = sizeof(WS);

    return S_OK;
}

/***************************************************************************************************************

  Name:      CreateNewWS

  Purpose:   Creates a new WS

  Returns:   HRESULT.

  Params:
             in:    WinstationInfo - Info about new UI.
                    UserCnfgSize - Size of the Userconfig Buffer
                    pserConfig - Pointer to USERCONFIG.
                    pAsyncConfig - Can be NULL if async is not used

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::CreateNewWS(WS WinstationInfo, long UserCnfgSize, PUSERCONFIG pUserConfig,PASYNCCONFIGW pAsyncConfig)
{
    WINSTATIONCONFIG2W WSConfig;

    WDCONFIG2W WdConfig;

    PDCONFIG3W PdConfig;

    BOOL Unique;

    ULONG ByteCount;

    HRESULT hResult = S_OK;

    PWD pWd = NULL;

    DWORD dwStatus = ERROR_SUCCESS;

    //If not initialized return error
    if(!m_bInitialized)
    {
        ODS( L"CFGBKEND : CreateNewWS not initialized\n" );

        return CFGBKEND_E_NOT_INITIALIZED;
    }

    do
    {
        //Check if the caller has write permissions.
        if(!m_bAdmin)
        {
            ODS( L"CFGBKEND : CreateNewWS not Admin\n" );

            hResult = E_ACCESSDENIED;

            break;
        }

        pWd = GetWdObject(WinstationInfo.wdName);

        if(NULL == pWd)
        {
            ODS( L"CFGBKEND : CreateNewWS no WD Object found\n" );

            hResult = E_INVALIDARG;

            break;
        }


        if(UserCnfgSize != sizeof(USERCONFIGW) && pUserConfig == NULL)
        {
            ODS( L"CFGBKEND : CreateNewWS UserConfig invalid\n" );

            hResult = E_INVALIDARG;

            break;
        }

        //See if the Name of the Winstation is Unique
        hResult = IsWSNameUnique(WinstationInfo.Name,&Unique);

        if( FAILED( hResult ) )
        {
            break;
        }

        if(0 == Unique)
        {
            ODS( L"CFGBKEND : CreateNewWS WINSTA name not unique\n" );

            hResult = E_INVALIDARG;

            break;
        }

        //Check the length of the new winstation name

        if(lstrlen(WinstationInfo.Name) > WINSTATIONNAME_LENGTH)
        {
            hResult = E_INVALIDARG;

            break;
        }


        //Now begins the actual work.

        ZeroMemory(&WSConfig, sizeof(WINSTATIONCONFIG2W));

        //WINSTATIONCONFIG2W.Create

        WSConfig.Create.fEnableWinStation = WinstationInfo.fEnableWinstation;

        WSConfig.Create.MaxInstanceCount = WinstationInfo.uMaxInstanceCount;

        //WINSTATIONCONFIG2W.Wd

        dwStatus = RegWdQueryW(NULL,pWd->wdKey, &WdConfig,sizeof(WdConfig),&ByteCount);

        if(ERROR_SUCCESS != dwStatus )
        {
            DBGMSG( L"CFGBKEND : CreateNewWS@RegWdQuery failed with 0x%x\n" , dwStatus );

            hResult = E_FAIL;

            break;
        }

        WSConfig.Wd = WdConfig.Wd;

        //WINSTATIONCONFIG2W.Config

        lstrcpy(WSConfig.Config.Comment,WinstationInfo.Comment);

        CopyMemory( ( PVOID )&WSConfig.Config.User , ( CONST VOID * )pUserConfig , UserCnfgSize );

        //WINSTATIONCONFIG2W.Pd

        dwStatus = RegPdQueryW( NULL , pWd->wdKey , TRUE , WinstationInfo.pdName , &PdConfig , sizeof(PdConfig) , &ByteCount );

        if( ERROR_SUCCESS != dwStatus )
        {
            DBGMSG( L"CFGBKEND : CreateNewWS RegPdQuery failed with 0x%x\n" , dwStatus );

            hResult = E_FAIL;

            break;
        }

        WSConfig.Pd[0].Create = PdConfig.Data;

        WSConfig.Pd[0].Params.SdClass = (SDCLASS)WinstationInfo.PdClass;

        if(SdNetwork == (SDCLASS)WinstationInfo.PdClass)
        {
            WSConfig.Pd[0].Params.Network.LanAdapter = WinstationInfo.LanAdapter;
        }
        else if(SdAsync == (SDCLASS)WinstationInfo.PdClass)
        {
            if(NULL != pAsyncConfig)
            {
                pAsyncConfig->fConnectionDriver = *( pAsyncConfig->ModemName ) ? TRUE : FALSE;

                WSConfig.Pd[0].Params.Async = *pAsyncConfig;

                CDCONFIG cdConfig;

                SetupAsyncCdConfig( pAsyncConfig , &cdConfig );

                if( cdConfig.CdName[ 0 ] != 0 )
                {
                    dwStatus = RegCdCreateW( NULL , pWd->wdKey , cdConfig.CdName , TRUE , &cdConfig , sizeof( CDCONFIG ) );

                    if( dwStatus != ERROR_SUCCESS )
                    {
                        DBGMSG( L"CFGBKEND: RegCdCreateW returned 0x%x\n", dwStatus );

                        if( dwStatus == ERROR_ALREADY_EXISTS )
                        {
                            hResult = S_FALSE;
                        }
                        else if( dwStatus == ERROR_CANTOPEN )
                        {
                            hResult = E_ACCESSDENIED;

                            break;
                        }
                        else
                        {
                            hResult = E_FAIL;

                            break;
                        }
                    }

                    WSConfig.Cd = cdConfig;
                }

            }

        }

        //Get the additional Pd's. Currently only ICA has this.

        GetPdConfig(pWd->wdKey,WSConfig);

        //Try Creating

        dwStatus = ( DWORD )RegWinStationCreate( NULL , WinstationInfo.Name , TRUE , &WSConfig , sizeof(WINSTATIONCONFIG2) );

        if( dwStatus != ERROR_SUCCESS )
        {
            DBGMSG( L"CFGBKEND : CreateNewWS@RegWinStationCreate failed 0x%x\n" , dwStatus );

            hResult = E_FAIL;

            break;
        }

        //Create the extension Data, Currently only ICA has this

        void * pExtObject = NULL;

        if(pWd->lpfnExtRegQuery && pWd->hExtensionDLL)
        {
            pExtObject = (pWd->lpfnExtRegQuery)(L"", &(WSConfig.Pd[0]));

        }

        if(pExtObject)
        {
            if(pWd->lpfnExtRegCreate)
            {
                (pWd->lpfnExtRegCreate)(WinstationInfo.Name,pExtObject,TRUE);
            }
        }

        //Delete the extension object

        if(pWd->lpfnExtDeleteObject && pExtObject)
        {
            (pWd->lpfnExtDeleteObject )(pExtObject );
        }

        //Add the Winstation to our local list.

        PWS pObject = NULL;

        hResult = InsertInWSArray(WinstationInfo.Name,&WSConfig,&pObject);

        if( SUCCEEDED( hResult ) )
        {
            hResult = ForceUpdate( );
        }
        else
        {
            break;
        }

    }while( 0 );


    return hResult;
}

/***************************************************************************************************************

  Name:      GetDefaultUserConfig

  Purpose:   Gets the Default User Configuration for a given Winstation Driver

  Returns:   HRESULT.

  Params:
             in:    WdName - Name of the Winstation Driver.
             out:   pSize - Size of the allocated buffer
                    ppUser - Pointer to the buffer containing the UserConfig


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::GetDefaultUserConfig(WCHAR * WdName,long * pSize, PUSERCONFIG * ppUser)
{
    LONG QStatus;
    WDCONFIG2W WdConfig;
    ULONG ByteCount;
    PWD pWd = NULL;

    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;


    if(NULL == pSize || NULL == ppUser || NULL == WdName)
        return E_INVALIDARG;

    pWd = GetWdObject(WdName);
    if(NULL == pWd)
        return E_INVALIDARG;

    if (( QStatus = RegWdQueryW( NULL, pWd->wdKey, &WdConfig,
                                     sizeof(WdConfig),
                                     &ByteCount )) != ERROR_SUCCESS )
        return E_FAIL;

    *ppUser = (PUSERCONFIG)CoTaskMemAlloc(sizeof(WdConfig.User));
    if(*ppUser == NULL)
        return E_OUTOFMEMORY;

    CopyMemory((PVOID)*ppUser,(CONST VOID *)&WdConfig.User,sizeof(WdConfig.User));
    *pSize = sizeof(WdConfig.User);

    return S_OK;
}

/***************************************************************************************************************

  Name:      IsNetWorkConnectionUnique

  Purpose:   Checks if the combination of Winstation driver name, LanAdapter and the transport is Unique.

  Returns:   HRESULT.

  Params:
             in:    WdName - Name of the Winstation Driver.
                    PdName - Name of the Transport
                    LanAdapter - LanAdapter Index
            out:    pUnique - pointer to whether the information is unique or not.

 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::IsNetWorkConnectionUnique(WCHAR * WdName, WCHAR * PdName, ULONG LanAdapter, BOOL * pUnique)
{
    //If not initialized return error
    if( !m_bInitialized )
    {
        return CFGBKEND_E_NOT_INITIALIZED;
    }

    //Check for uniqueness of this combination,
    //Transport, Type , LanAdapter
    if( NULL == WdName || NULL == PdName || NULL == pUnique )
    {
        return E_INVALIDARG;
    }

    *pUnique = TRUE;

    int nSize = m_WSArray.GetSize();

    for(int i = 0; i < nSize; i++ )
    {
        if(lstrcmpi(WdName,((WS *)(m_WSArray[i]))->wdName) == 0 )
        {
            if(lstrcmpi(PdName,((WS *)(m_WSArray[i]))->pdName) == 0)
            {
                // Make sure there's not a lanadapter configured for all settings

                if( ( LanAdapter == 0 ) ||

                    ( LanAdapter == ( ( WS * )( m_WSArray[ i ] ) )->LanAdapter ) ||

                    ( ( ( WS * )( m_WSArray[ i ] ) )->LanAdapter == 0 ) )

                    //( oldLanAdapter != ( ( WS * )( m_WSArray[ i ] ) )->LanAdapter && ( ( WS * )( m_WSArray[ i ] ) )->LanAdapter == 0 ) )
                {
                    *pUnique = FALSE;

                    break;
                }
            }
        }

    }

    return S_OK;
}

/***************************************************************************************************************

  Name:      DeleteWS

  Purpose:   Deletes a given Winstation

  Returns:   HRESULT.

  Params:
             in:    pWSName - Name of the Winstation.
             out:   pSize - Size of the allocated buffer
                    ppSecurityDescriptor - Pointer to the buffer containing the security descriptor


 ****************************************************************************************************************/
STDMETHODIMP CCfgComp::DeleteWS(PWINSTATIONNAME pWs)
{
    HRESULT hResult = S_OK;
    PWS pWinsta = NULL;
    PWD pWD = NULL;
    void * pExtObject = NULL;
    WINSTATIONCONFIG2W WsConfig;
    ULONG Length = 0;
    long Status;

    //If not initialized return error
    if(!m_bInitialized)
        return CFGBKEND_E_NOT_INITIALIZED;

    //Check if the caller has write permissions.
    if(!m_bAdmin)
        return E_ACCESSDENIED;

    //Check if Valid Winstation Name
    if(NULL == pWs || lstrlen(pWs) > WINSTATIONNAME_LENGTH)
        return E_INVALIDARG;

    //Check for the validity of the Winstation name,

    pWinsta = GetWSObject(pWs);
    if(NULL == pWinsta)
        return E_INVALIDARG;

    //Get the WD object associated with this Winstation.

    pWD = GetWdObject(pWinsta->wdName);
    if(NULL == pWD)
        return E_FAIL;

    //Query the registry for WinStation data
    Status = RegWinStationQueryW(NULL,pWs,&WsConfig,sizeof(WINSTATIONCONFIG2W), &Length);
    if(Status)
        return E_FAIL;

#if 0 // tscc now uses aclui
    // Remove name entry keys
    TCHAR tchRegPath[ MAX_PATH ] = TEXT( "system\\currentcontrolset\\control\\Terminal Server\\winstations\\" );

    HKEY hKey;

    lstrcat( tchRegPath , pWs );

    lstrcat( tchRegPath , L"\\NamedEntries" );

    OutputDebugString( tchRegPath );

    if( RegOpenKey( HKEY_LOCAL_MACHINE , tchRegPath , &hKey ) == ERROR_SUCCESS )
    {
        RegDeleteValue( hKey , L"cbSize" );

        RegDeleteValue( hKey , L"NE" );

        RegCloseKey( hKey );

        RegDeleteKey( HKEY_LOCAL_MACHINE , tchRegPath );
    }

#endif

    //Get the ExtensionObject data(third party) this will be used for Creating and Deleting the registry keys.

    if(pWD->lpfnExtRegQuery && pWD->hExtensionDLL)
    {
        pExtObject = (pWD->lpfnExtRegQuery)(pWs, &(WsConfig.Pd[0]));
        if(pWD->lpfnExtRegDelete && pExtObject)
        {
            //Try Deleting the Extension entries in the registy
            if(ERROR_SUCCESS != (pWD->lpfnExtRegDelete)(pWs,pExtObject))
                hResult = CFGBKEND_EXTDELETE_FAILED;
            //Delete the extension object. It will not be used further.
            if(pWD->lpfnExtDeleteObject)
                (pWD->lpfnExtDeleteObject)(pExtObject);
        }

    }


    //Delete registy key
    Status = RegWinStationDeleteW(NULL,pWs);
    if (Status)
        return Status;

    //update our list of winstation objects.

    PWS pObject;
    int Size  = 0,Index = 0;

    /*
     * Traverse the WD list
     */
    for (Index = 0, Size = m_WSArray.GetSize(); Index < Size; Index ++)
    {

        pObject = (PWS)m_WSArray[Index];

        if ( !lstrcmpi( pObject->Name, pWs ) )
        {
           m_WSArray.RemoveAt(Index,1);
           delete pObject;
           break;
        }
    }

    return hResult;
}

//----------------------------------------------------------------------
// good to call when you've updated the winstation security descriptor
//----------------------------------------------------------------------

STDMETHODIMP CCfgComp::ForceUpdate( void )
{
    if( !m_bInitialized )
    {
        ODS( L"CFGBKEND : CCfgComp::ForceUpdate return NOT_INIT\n" );

        return CFGBKEND_E_NOT_INITIALIZED;
    }

    //Check if the caller has write permissions.

    if(!m_bAdmin)
    {
        ODS( L"CFGBKEND : CCfgComp::ForceUpdate -- not admin\n" );

        return E_ACCESSDENIED;
    }

    if( _WinStationReadRegistry( SERVERNAME_CURRENT ) )
    {
        return S_OK;
    }

    ODS( L"CFGBKEND : ForceUpdate failed Winstation not updated\n" );

    return E_FAIL;
}

//----------------------------------------------------------------------
// Must delete the array completely first.
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::Refresh( void )
{
    //Check if the caller has write permissions.

    /* bugid 364103
    if(!m_bAdmin)
    {
        return E_ACCESSDENIED;
    }
    */

    HRESULT hr = FillWdArray();

    if( SUCCEEDED( hr) )
    {
        hr = FillWsArray();
    }

    return hr;
}

//----------------------------------------------------------------------
// Obtain Winstation SDCLASS type
// m_WDArray must already be initialized
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetTransportType( WCHAR *wszDriverName , WCHAR *wszTransportType , DWORD *sdtype )
{
    _ASSERTE( wszDriverName != NULL || wszTransportType != NULL || sdtype != NULL );

    if( wszDriverName == NULL || wszTransportType == NULL || sdtype == NULL )
    {
        return E_INVALIDARG;
    }

    *sdtype = SdNone;

    PWD pWd = GetWdObject( wszDriverName );

    if( pWd != NULL )
    {
        BOOL bFound = FALSE;

        for( int i = 0; i < pWd->PDConfigArray.GetSize( ) ; ++i )
        {
            if( lstrcmpi( wszTransportType , ( ( PDCONFIG3W *)pWd->PDConfigArray[ i ] )->Data.PdName ) == 0 )
            {
                bFound = TRUE;

                break;
            }
        }

        if( bFound )
        {
            *sdtype = ( ( PDCONFIG3W * )pWd->PDConfigArray[ i ] )->Data.SdClass;

            return S_OK;
        }

    }

    return E_FAIL;
}

//----------------------------------------------------------------------
// Async's are unique if device name protocol type vary from other
// winstations.
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::IsAsyncUnique( WCHAR *wszDeviceName , WCHAR *wszProtocolType , BOOL *pbUnique )
{
    _ASSERTE( wszDecoratedName != NULL || wszProtocolType != NULL || pbUnique != NULL );

    if( wszDeviceName == NULL || wszProtocolType == NULL || pbUnique == NULL )
    {
        return E_INVALIDARG;
    }

    *pbUnique = TRUE;

    // Traverse the WinStationList.

    for( int i = 0; i < m_WSArray.GetSize(); i++ )
    {
        if( lstrcmpi( wszProtocolType , ( ( WS * )( m_WSArray[ i ] ) )->wdName ) == 0 )
        {
            if( SdAsync == ( ( WS *)( m_WSArray[i] ) )->PdClass )
            {
                if( !lstrcmpi( wszDeviceName , ( ( WS * )( m_WSArray[ i ] ) )->DeviceName ) == 0 )
                {
                    *pbUnique = FALSE;

                    break;
                }
            }
        }

    }

    return S_OK;
}

//----------------------------------------------------------------------
// Pull async configuration from the registry
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetAsyncConfig( WCHAR *wszName , NameType nt , PASYNCCONFIGW pAsync )
{
    if( wszName == NULL || pAsync == NULL )
    {
        ODS( L"CFGBKEND: Invalid arg @ GetAsyncConfig\n" );

        return E_INVALIDARG;
    }

    WINSTATIONCONFIG2W WSConfig2;

    ULONG ulLength = 0;

    if( nt == WsName )
    {
        //Read the information from the registry.
        if( RegWinStationQueryW( NULL , wszName , &WSConfig2 , sizeof( WINSTATIONCONFIG2W) , &ulLength ) != ERROR_SUCCESS )
        {
            ODS( L"CFGBKEND: RegWinStationQueryW failed @ GetAsyncConfig\n " );

            return E_FAIL;
        }

        *pAsync = WSConfig2.Pd[0].Params.Async;
    }
    else if( nt == WdName )
    {
        PWD pObject = GetWdObject( wszName );

        if( pObject == NULL )
        {
            return E_UNEXPECTED;
        }

        *pAsync = pObject->wd2.Async;
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

//----------------------------------------------------------------------
// Push async config back in to the registry
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::SetAsyncConfig( WCHAR *wszName , NameType nt , PASYNCCONFIGW pAsync , PDWORD pdwStatus )
{
    *pdwStatus = 0;

    if( wszName == NULL || pAsync == NULL )
    {
        ODS( L"CFGBKEND: Invalid arg @ SetAsyncConfig\n" );

        *pdwStatus = ERROR_INVALID_PARAMETER;

        return E_INVALIDARG;
    }

    WINSTATIONCONFIG2W WSConfig2;

    // WDCONFIG2W wdConfig2;

    ULONG ulLength = 0;

    if( nt == WsName )
    {
        //Read the information from the registry.
        CDCONFIG cdConfig;

        ZeroMemory( ( PVOID )&cdConfig , sizeof( CDCONFIG ) );

        if( ( *pdwStatus = RegWinStationQueryW( NULL , wszName , &WSConfig2 , sizeof( WINSTATIONCONFIG2W) , &ulLength ) ) != ERROR_SUCCESS )
        {
            ODS( L"CFGBKEND: RegWinStationQueryW failed @ SetAsyncConfig\n" );

            return E_FAIL;
        }

        pAsync->fConnectionDriver = *( pAsync->ModemName ) ? TRUE : FALSE;

        SetupAsyncCdConfig( pAsync , &cdConfig );

        WSConfig2.Pd[0].Params.Async = *pAsync;

        WSConfig2.Cd = cdConfig;


        if( ( *pdwStatus = RegWinStationCreateW( NULL , wszName , FALSE , &WSConfig2 , sizeof( WINSTATIONCONFIG2W ) ) ) != ERROR_SUCCESS )
        {
            ODS( L"CFGBKEND: RegWinStationCreateW failed @ SetAsyncConfig\n" );

            return E_FAIL;
        }
    }
    /*else if( nt == WdName )
    {
        PWD pObject = GetWdObject( wszName );

        if( pObject == NULL )
        {
            ODS( L"CFGBKEND: Failed to obtain WD @ SetAsyncConfig\n" );

            *pdwStatus = ERROR_INVALID_NAME;

            return E_FAIL;
        }

        if( ( *pdwStatus = RegWdQueryW(  NULL , pObject->wdKey , &wdConfig2 , sizeof( WDCONFIG2W ) , &ulLength )  ) != ERROR_SUCCESS )
        {
            ODS( L"CFGBKEND: RegWdQueryW failed @ SetAsyncConfig driver name is " );
            ODS( pObject->wdKey );
            ODS( L"\n" );

            return E_FAIL;
        }

        wdConfig2.Async = *pAsync;

        if( ( *pdwStatus = RegWdCreateW( NULL , pObject->wdKey , FALSE , &wdConfig2 , sizeof( WDCONFIG2W ) ) ) != ERROR_SUCCESS )
        {
            ODS( L"CFGBKEND: RegWdCreateW failed @ SetAsyncConfig\n" );

            return E_FAIL;
        }
    }*/
    else
    {
        *pdwStatus = ERROR_INVALID_PARAMETER;

        return E_INVALIDARG;
    }


    return S_OK;
}

//----------------------------------------------------------------------
// GetDeviceList expects the name of the WD
// the return is a BLOB PDPARAMs containing ASYNCCONFG's
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetDeviceList( WCHAR *wszName , NameType Type , ULONG *pulItems , LPBYTE *ppBuffer )
{
    PWD pObject = NULL;

    if( wszName == NULL || pulItems == NULL )
    {
        ODS( L"CFGBKEND : @GetDeviceList - Driver or WinSta Name invalid\n" );

        return E_INVALIDARG;
    }

    if( Type == WsName )
    {
        PWS pWS = GetWSObject( wszName );
        if( NULL == pWS )
        {
            ODS( L"CFGBKEND : @GetDeviceList - No winsta object found\n" );

            return E_INVALIDARG;
        }

        pObject = GetWdObject( pWS->wdName );

        if( NULL == pObject )
        {
            ODS( L"CFGBKEND : @GetDeviceList - No WD object found\n" );
            return E_FAIL;
        }
    }
    else
    {
        pObject = GetWdObject( wszName );
    }

    if( pObject == NULL )
    {
        ODS( wszName ); ODS( L" - @GetDeviceList - driver object not found\n" );

        return E_UNEXPECTED;
    }

    PDCONFIG3W *pPdConfig3 = NULL;

    int nItems = ( pObject->PDConfigArray ).GetSize( );

    for( int i = 0; i < nItems ; i++)
    {
        if( SdAsync == ( ( PDCONFIG3W * )pObject->PDConfigArray[i] )->Data.SdClass )
        {
            pPdConfig3 = ( PDCONFIG3W * )pObject->PDConfigArray[i];

            break;
        }

    }

    if( pPdConfig3 == NULL )
    {
        ODS( L"@GetDeviceList - PDCONFIG3 not found for ASYNC\n" );

        return E_UNEXPECTED;
    }

    // Get the list of PDPARAMS -- last param if true queries registry for com devices
    // if false uses DosDevices to obtain list

    ODS( L"CFGBKEND : Calling WinEnumerateDevices\n" );

    LPBYTE lpBuffer = ( LPBYTE )WinEnumerateDevices( NULL , pPdConfig3 , pulItems , FALSE );

    if( lpBuffer == NULL )
    {
        ODS( L"CFGBKEND : WinEnumerateDevices failed @ CCfgComp::GetDeviceList\n" );

        return E_OUTOFMEMORY;
    }

    // don't forget to free with LocalFree

    *ppBuffer = lpBuffer;

    return S_OK;
}

//----------------------------------------------------------------------
// GetConnType retreives the name of the connection type for an Async
// device.  The list of resource ids is match the order of the
// CONNECTCONFIG enum data type.
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetConnTypeName( int idxItem , WCHAR *rgwszConnectName )
{
    int rgIds[] = { IDS_CONNECT_CTS , IDS_CONNECT_DSR , IDS_CONNECT_RI ,

                    IDS_CONNECT_DCD , IDS_CONNECT_FIRST_CHARACTER ,

                    IDS_CONNECT_ALWAYS , -1 };


    _ASSERTE( rgwszConnectName != NULL );

    _ASSERTE( idxItem >= 0 && idxItem < ARRAYSIZE( rgIds ) );

    if( rgIds[ idxItem ] == -1 )
    {
        return S_FALSE;
    }

    if( !GetResourceStrings( rgIds , idxItem , rgwszConnectName ) )
    {
        ODS( L"Error happen in CCfgComp::GetConnTypeName\n" );

        return E_FAIL;
    }

    return S_OK;
}

//----------------------------------------------------------------------
// GetModemCallbackString
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetModemCallbackString( int idxItem , WCHAR *rgwszModemCallBackString )
{
    int rgIds[] = { IDS_MODEM_CALLBACK_DISABLED , IDS_MODEM_CALLBACK_ROVING , IDS_MODEM_CALLBACK_FIXED , -1 };

    _ASSERTE( rgwszModemCallBackString != NULL );

    _ASSERTE( idxItem >= 0 && idxItem < ARRAYSIZE( rgIds ) );

    if( rgIds[ idxItem ] == -1 )
    {
        return S_FALSE;
    }

    if( !GetResourceStrings( rgIds , idxItem , rgwszModemCallBackString ) )
    {
        ODS( L"Error happen in CCfgComp::GetConnTypeName\n" );

        return E_FAIL;
    }

    return S_OK;
}

//----------------------------------------------------------------------
// Returns the name of hardware flow control receive string
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetHWReceiveName( int idxItem , WCHAR *rgwszHWRName )
{
    int rgIds[] = { IDS_ASYNC_ADVANCED_HWRX_NOTHING ,

                    IDS_ASYNC_ADVANCED_HWRX_TURN_OFF_RTS ,

                    IDS_ASYNC_ADVANCED_HWRX_TURN_OFF_DTR , -1

                  };

    _ASSERTE( rgwszHWRName != NULL );

    _ASSERTE( idxItem >= 0 && idxItem < ARRAYSIZE( rgIds ) );

    if( rgIds[ idxItem ] == -1 )
    {
        return S_FALSE;
    }

    if( !GetResourceStrings( rgIds , idxItem , rgwszHWRName ) )
    {
        ODS( L"Error happen in CCfgComp::GetHWReceiveName\n" );

        return E_FAIL;
    }

    return S_OK;
}

//----------------------------------------------------------------------
// returns the name of hardware flow control transmit string
//----------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetHWTransmitName( int idxItem , WCHAR *rgwzHWTName )
{
    int rgIds[] = { IDS_ASYNC_ADVANCED_HWTX_ALWAYS ,

                    IDS_ASYNC_ADVANCED_HWTX_WHEN_CTS_IS_ON,

                    IDS_ASYNC_ADVANCED_HWTX_WHEN_DSR_IS_ON,

                    -1
                  };

    _ASSERTE( rgwszHWRName != NULL );

    _ASSERTE( idxItem >= 0 && idxItem < ARRAYSIZE( rgIds ) );

    if( rgIds[ idxItem ] == -1 )
    {
        return S_FALSE;
    }

    if( !GetResourceStrings( rgIds , idxItem , rgwzHWTName ) )
    {
        ODS( L"Error happen in CCfgComp::GetHWReceiveName\n" );

        return E_FAIL;
    }

    return S_OK;
}

//----------------------------------------------------------------------
// Internal method call -- helper function.
//----------------------------------------------------------------------
BOOL CCfgComp::GetResourceStrings( int *prgIds , int iItem , WCHAR *rgwszList )
{
    _ASSERTE( rgwszList != NULL );

    if( rgwszList == NULL )
    {
        ODS( L"rgwszList is NULL @ CCfgComp::GetResourceStrings\n" );

        return FALSE;
    }

    TCHAR tchConType[ 80 ];

    if( LoadString( _Module.GetResourceInstance( ) , prgIds[ iItem ] , tchConType , sizeof( tchConType ) / sizeof( TCHAR ) ) == 0 )
    {
        ODS( L"String resource not found @ CCfgComp::GetResourceStrings\n" );

        return FALSE;
    }

    // copy enough characters

    lstrcpyn( rgwszList , tchConType , sizeof( tchConType ) / sizeof(TCHAR) );


    return TRUE;
}

//----------------------------------------------------------------------
HRESULT CCfgComp::GetCaps( WCHAR *szWdName , ULONG *pMask )
{
    if( szWdName == NULL || pMask == NULL )
    {
        ODS( L"CCfgComp::GetCaps returned INVALIDARG\n" );

        return E_INVALIDARG;
    }

    PWD pObject = GetWdObject( szWdName );

    if( pObject == NULL )
    {
        return E_UNEXPECTED;
    }


    if( pObject->lpfnGetCaps != NULL )
    {
        *pMask = ( pObject->lpfnGetCaps )( );
    }

    return S_OK;
}


//----------------------------------------------------------------------
HRESULT CCfgComp::QueryLoggedOnCount( WCHAR *pWSName , PLONG pCount )
{
    ODS( L"CFGBKEND : CCfgComp::QueryLoggedOnCount\n" );

    *pCount = 0;

    ULONG Entries = 0;

    TCHAR *p;

    PLOGONID pLogonId;

    if(FALSE == WinStationEnumerate( NULL , &pLogonId, &Entries))
    {
        return E_FAIL;
    }

    if( pLogonId )
    {
        for( ULONG i = 0; i < Entries; i++ )
        {
            /*
             * Check active, connected, and shadowing WinStations, and increment
             * the logged on count if the specified name matches the 'root'
             * name of current winstation.
             */

            if( ( pLogonId[i].State == State_Active ) || ( pLogonId[i].State == State_Connected ) || ( pLogonId[i].State == State_Shadow ) )
            {
                // remove appended connection number

                p = _tcschr( pLogonId[i].WinStationName , TEXT('#') );

                if( p != NULL )
                {
                    *p = TEXT('\0');
                }


                if( !lstrcmpi( pWSName, pLogonId[i].WinStationName ) )
                {
                    *pCount += 1 ;
                }
            }
        }

        WinStationFreeMemory(pLogonId);
    }

    return S_OK;

}  // end QueryLoggedOnCount

/*
//-----------------------------------------------------------------------------
// returns the number of configured winstations
//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetNumofWinStations( PULONG nWinsta )
{
    if( nWinsta == NULL )
    {
        ODS( L"CFGBKEND : GetNumofWinStations - INVALID ARG\n" );

        return E_INVALIDARG;
    }

    *nWinsta = ( ULONG )m_WSArray.GetSize();

    return S_OK;
}
*/
//-----------------------------------------------------------------------------
// returns the number of configured winstations
//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetNumofWinStations(WCHAR * WdName,WCHAR * PdName, PULONG nWinsta )
{
    if( nWinsta == NULL || NULL == WdName || NULL == PdName )
    {
        ODS( L"CFGBKEND : GetNumofWinStations - INVALID ARG\n" );

        return E_INVALIDARG;
    }

    ULONG lCount = 0;
    for( int i = 0; i < m_WSArray.GetSize(); i++ )
    {
         if(lstrcmpi(WdName,( ( WS *)( m_WSArray[i] ) )->wdName) == 0 )
         {
             if(lstrcmpi( PdName , ( ( WS * )( m_WSArray[ i ] ) )->pdName ) == 0 )
             {
                lCount++;
             }
         }

     }

        *nWinsta = lCount;

    return S_OK;
}

//-----------------------------------------------------------------------------
STDMETHODIMP_(BOOL) CCfgComp::IsAsyncDeviceAvailable(LPCTSTR pDeviceName)
{
    /*
     * If this is an async WinStation, the device is the same as the
     * one we're checking, but this is not the current WinStation being
     * edited, return FALSE.
     * THIS NEEDS TO BE REVIEWED - alhen
     */

    //return TRUE;

    if( pDeviceName != NULL )
    {
        for( int i = 0; i < m_WSArray.GetSize(); i++ )
        {
            if( SdAsync == ( ( WS *)( m_WSArray[i] ) )->PdClass )
            {
                if( lstrcmpi( pDeviceName , ( ( WS * )( m_WSArray[ i ] ) )->DeviceName ) == 0 )
                {
                    return FALSE;
                }
            }

        }
    }

    return TRUE;


}

#if 0 // removed for final
//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetCachedSessions(DWORD * pCachedSessions)
{
    HKEY Handle = NULL;
      DWORD ValueBuffer = 0;
    DWORD ValueType = 0;
    LONG Status = 0;

    DWORD ValueSize = sizeof(ValueBuffer);

    if(NULL == pCachedSessions)
    {
        return E_INVALIDARG;
    }

    *pCachedSessions = 0;

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                       KEY_READ, &Handle );
    if ( Status == ERROR_SUCCESS )
    {

        Status = RegQueryValueEx( Handle,
                                  REG_CITRIX_IDLEWINSTATIONPOOLCOUNT,
                                  NULL,
                                  &ValueType,
                                  (LPBYTE) &ValueBuffer,
                                  &ValueSize );
        if ( Status == ERROR_SUCCESS )
        {
            if(ValueType == REG_DWORD)
            {
                *pCachedSessions = ValueBuffer;
            }
            else
            {
                Status = E_FAIL;
            }
        }


     }
     if(Handle)
     {
         RegCloseKey(Handle);
     }
     return Status;

}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::SetCachedSessions(DWORD dCachedSessions)
{
    // TODO: Add your implementation code here
    LONG Status = 0;
    HKEY Handle = NULL;

    if(RegServerAccessCheck(KEY_ALL_ACCESS))
    {
        return E_ACCESSDENIED;
    }

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                       KEY_READ | KEY_SET_VALUE, &Handle );
    if ( Status == ERROR_SUCCESS )
    {
        Status = RegSetValueEx(Handle,REG_CITRIX_IDLEWINSTATIONPOOLCOUNT,
                              0,REG_DWORD,(const BYTE *)&dCachedSessions,
                              sizeof(dCachedSessions));

     }
     if(Handle)
     {
         RegCloseKey(Handle);
     }

    return Status;
}

#endif // removed

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetDelDirsOnExit(BOOL * pDelDirsOnExit)
{
    HKEY Handle = NULL;
      DWORD ValueBuffer = 0;
    DWORD ValueType = 0;
    LONG Status = 0;

    DWORD ValueSize = sizeof(ValueBuffer);

    if(NULL == pDelDirsOnExit)
    {
        return E_INVALIDARG;
    }

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                       KEY_READ, &Handle );
    if ( Status == ERROR_SUCCESS )
    {

        Status = RegQueryValueEx( Handle,
                                  REG_CITRIX_DELETETEMPDIRSONEXIT,
                                  NULL,
                                  &ValueType,
                                  (LPBYTE) &ValueBuffer,
                                  &ValueSize );
        if ( Status == ERROR_SUCCESS )
        {
            if(ValueType == REG_DWORD)
            {
                if(ValueBuffer)
                {
                    *pDelDirsOnExit = TRUE;
                }
                else
                {
                    *pDelDirsOnExit = FALSE;
                }
            }
            else
            {
                Status = E_FAIL;
            }
        }


     }
     if(Handle)
     {
         RegCloseKey(Handle);
     }
     return Status;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::SetDelDirsOnExit(BOOL bDelDirsOnExit)
{
    LONG Status = 0;
    HKEY Handle = NULL;

    /* admin only
    if(RegServerAccessCheck(KEY_ALL_ACCESS))
    {
        return E_ACCESSDENIED;
    }
    */
    if( !m_bAdmin )
    {
        ODS( L"CCfgComp::SetDelDirsOnExit not admin\n" );        

        return E_ACCESSDENIED;
    }    

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                       KEY_READ | KEY_SET_VALUE, &Handle );
    if ( Status == ERROR_SUCCESS )
    {
        Status = RegSetValueEx(Handle,REG_CITRIX_DELETETEMPDIRSONEXIT,
                              0,REG_DWORD,(const BYTE *)&bDelDirsOnExit,
                              sizeof(bDelDirsOnExit));

     }
     if(Handle)
     {
         RegCloseKey(Handle);
     }

    return Status;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetUseTempDirPerSession(BOOL * pbTempDir)
{
    HKEY Handle = NULL;
      DWORD ValueBuffer = 0;
    DWORD ValueType = 0;
    LONG Status = 0;

    DWORD ValueSize = sizeof(ValueBuffer);

    if(NULL == pbTempDir)
    {
        return E_INVALIDARG;
    }

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                       KEY_READ, &Handle );
    if ( Status == ERROR_SUCCESS )
    {

        Status = RegQueryValueEx( Handle,
                                  REG_TERMSRV_PERSESSIONTEMPDIR,
                                  NULL,
                                  &ValueType,
                                  (LPBYTE) &ValueBuffer,
                                  &ValueSize );
        if ( Status == ERROR_SUCCESS )
        {
            if(ValueType == REG_DWORD)
            {
                if(ValueBuffer)
                {
                    *pbTempDir = TRUE;
                }
                else
                {
                    *pbTempDir = FALSE;
                }
            }
            else
            {
                Status = E_FAIL;
            }
        }


     }
     if(Handle)
     {
         RegCloseKey(Handle);
     }
     return Status;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::SetUseTempDirPerSession(BOOL bTempDirPerSession)
{
    LONG Status = 0;
    HKEY Handle = NULL;

    /* admin only bugid294645
    if(RegServerAccessCheck(KEY_ALL_ACCESS))
    {
        return E_ACCESSDENIED;
    }
    */
    if( !m_bAdmin )
    {
        ODS( L"CCfgComp::SetUseTempDirPerSession not admin\n" );        

        return E_ACCESSDENIED;
    }

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                       KEY_READ | KEY_SET_VALUE, &Handle );
    if ( Status == ERROR_SUCCESS )
    {
        Status = RegSetValueEx(Handle,REG_TERMSRV_PERSESSIONTEMPDIR,
                              0,REG_DWORD,(const BYTE *)&bTempDirPerSession,
                              sizeof(bTempDirPerSession));

     }
     if(Handle)
     {
         RegCloseKey(Handle);
     }

    return Status;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetInternetConLic( BOOL *pbInternetConLic , PDWORD pdwStatus )
{
    // shouldn't be called on post-Win2000 machines
    _ASSERTE( FALSE );

    UNREFERENCED_PARAMETER(pbInternetConLic);

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = ERROR_NOT_SUPPORTED;

    return E_FAIL;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::SetInternetConLic( BOOL bInternetConLic , PDWORD pdwStatus )
{
    // shouldn't be called on post-Win2000 machines
    _ASSERTE( FALSE );

    UNREFERENCED_PARAMETER(bInternetConLic);

    if( pdwStatus == NULL )
    {        
        return E_INVALIDARG;
    }

    *pdwStatus = ERROR_NOT_SUPPORTED;

    return E_FAIL;
}


//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetLicensingMode( ULONG * pulMode , PDWORD pdwStatus )
{
    BOOL fRet;
    HRESULT hr = S_OK;

    if( NULL == pulMode || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    HANDLE hServer = ServerLicensingOpen(NULL);

    if (NULL == hServer)
    {
        *pdwStatus = GetLastError();
        return E_FAIL;
    }

    fRet = ServerLicensingGetPolicy(
                                    hServer,
                                    pulMode
                                    );
    if (fRet)
    {
        *pdwStatus = ERROR_SUCCESS;
    }
    else
    {
        *pdwStatus = GetLastError();
        hr = E_FAIL;
    }

    ServerLicensingClose(hServer);

    return hr;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetLicensingModeInfo( ULONG ulMode , WCHAR **pwszName, WCHAR **pwszDescription, PDWORD pdwStatus )
{
#define MAX_LICENSING_STRING_LEN 1024
    UINT                nNameResource, nDescResource;
    int                 nRet;

    if( NULL == pwszName || NULL == pwszDescription || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = ERROR_SUCCESS;
    *pwszName = NULL;
    *pwszDescription = NULL;

    switch (ulMode)
    {
        case 1:
            nNameResource = IDS_LICENSING_RA_NAME;
            nDescResource = IDS_LICENSING_RA_DESC;
            break;
        case 2:
            nNameResource = IDS_LICENSING_PERSEAT_NAME;
            nDescResource = IDS_LICENSING_PERSEAT_DESC;
            break;
        case 4:
            nNameResource = IDS_LICENSING_PERUSER_NAME;
            nDescResource = IDS_LICENSING_PERUSER_DESC;
            break;
        default:
            return E_INVALIDARG;
            break;
    }

    *pwszName = (WCHAR *) CoTaskMemAlloc((MAX_LICENSING_STRING_LEN+1)*sizeof(WCHAR));

    if (NULL == *pwszName)
    {
        *pdwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto return_failure;
    }

    *pwszDescription = (WCHAR *) CoTaskMemAlloc((MAX_LICENSING_STRING_LEN+1)*sizeof(WCHAR));

    if (NULL == *pwszDescription)
    {
        *pdwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto return_failure;
    }

    nRet = LoadString(g_hInstance,
                      nNameResource,
                      *pwszName,
                      MAX_LICENSING_STRING_LEN+1);

    if (0 == nRet)
    {
        *pdwStatus = GetLastError();
        goto return_failure;
    }

    nRet = LoadString(g_hInstance,
                      nDescResource,
                      *pwszDescription,
                      MAX_LICENSING_STRING_LEN+1);

    if (0 == nRet)
    {
        *pdwStatus = GetLastError();
        goto return_failure;
    }
    
    return S_OK;

return_failure:
    if (NULL != *pwszName)
    {
        CoTaskMemFree(*pwszName);
        *pwszName = NULL;
    }

    if (NULL != *pwszDescription)
    {
        CoTaskMemFree(*pwszDescription);
        *pwszDescription = NULL;
    }

    return E_FAIL;
}


//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetLicensingModeList( ULONG *pcModes , ULONG **prgulModes, PDWORD pdwStatus )
{
    ULONG       *rgulModes = NULL;
    BOOL        fRet;
    HRESULT     hr = S_OK;

    if( NULL == pcModes || NULL == prgulModes || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    HANDLE hServer = ServerLicensingOpen(NULL);

    if (NULL == hServer)
    {
        *pdwStatus = GetLastError();
        return E_FAIL;
    }

    fRet = ServerLicensingGetAvailablePolicyIds(
                                            hServer,
                                            &rgulModes,
                                            pcModes
                                            );

    if (fRet)
    {
        *pdwStatus = ERROR_SUCCESS;

        *prgulModes = (ULONG *) CoTaskMemAlloc((*pcModes)*sizeof(ULONG));

        if (NULL != *prgulModes)
        {
            memcpy(*prgulModes,rgulModes,(*pcModes)*sizeof(ULONG));
        }
        else
        {
            *pdwStatus = ERROR_NOT_ENOUGH_MEMORY;
            hr = E_FAIL;
        }

        LocalFree(rgulModes);
    }
    else
    {
        *pdwStatus = GetLastError();
        hr = E_FAIL;
    }

    return hr;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::SetLicensingMode( ULONG ulMode , PDWORD pdwStatus, PDWORD pdwNewStatus )
{
    if( pdwStatus == NULL || pdwNewStatus == NULL )
    {        
        return E_INVALIDARG;
    }

    HANDLE hServer = ServerLicensingOpen(NULL);

    if (NULL == hServer)
    {
        *pdwStatus = GetLastError();
        return E_FAIL;
    }

    *pdwStatus = ServerLicensingSetPolicy(hServer,
                                        ulMode,
                                        pdwNewStatus);

    ServerLicensingClose(hServer);

    return ((*pdwStatus == ERROR_SUCCESS) && (*pdwNewStatus == ERROR_SUCCESS)) ? S_OK : E_FAIL;
}

//-----------------------------------------------------------------------------
// pUserPerm ==  TRUE if security is relaxed
// FALSE for tight security
//-----------------------------------------------------------------------------

STDMETHODIMP CCfgComp::SetUserPerm( BOOL bUserPerm , PDWORD pdwStatus )
{
	if( !m_bAdmin )
	{
		ODS( L"CFGBKEND:SetUserPerm not admin\n" );

		return E_ACCESSDENIED;
	}

	if( pdwStatus == NULL )
	{
		ODS( L"CFGBKEND-SetUserPerm invalid arg\n" );

		return E_INVALIDARG;
	}

	HKEY hKey;

	*pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
							   REG_CONTROL_TSERVER,
							   0 ,
							   KEY_READ | KEY_SET_VALUE,
							   &hKey );


    if( *pdwStatus != ERROR_SUCCESS )
    {
		DBGMSG( L"CFGBKEND-SetUserPerm RegOpenKeyEx failed 0x%x\n", *pdwStatus );

		return E_FAIL;
	}

	*pdwStatus = RegSetValueEx( hKey ,
								L"TSUserEnabled" ,
								0 ,
								REG_DWORD ,
								( const PBYTE )&bUserPerm ,
								sizeof( BOOL ) );

	if( *pdwStatus != ERROR_SUCCESS )
	{
		DBGMSG( L"CFGBKEND-SetUserPerm RegSetValueEx failed 0x%x\n" , *pdwStatus );

		return E_FAIL;
	}

	RegCloseKey( hKey );

	return S_OK;
}

//-----------------------------------------------------------------------------
// pUserPerm ==  TRUE if security is relaxed
// FALSE for tight security
//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetUserPerm( BOOL *pbUserPerm  , PDWORD pdwStatus )
{
	HKEY hKey;

	DWORD dwSize = sizeof( DWORD );

    DWORD dwValue;

    if( pbUserPerm == NULL || pdwStatus == NULL )
    {
		ODS( L"CFGBKEND-GetUserPerm invalid arg\n" );

        return E_INVALIDARG;
    }

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
							   REG_CONTROL_TSERVER,
							   0 ,
							   KEY_READ ,
							   &hKey );

    if( *pdwStatus != ERROR_SUCCESS )
	{
		DBGMSG( L"CFGBKEND-GetUserPerm RegOpenKeyEx failed 0x%x\n", *pdwStatus );

		return E_FAIL;
	}

	*pdwStatus = RegQueryValueEx( hKey,
                                  L"TSUserEnabled",
                                  NULL,                                  
                                  NULL,
                                  ( LPBYTE )&dwValue,
                                  &dwSize );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        DBGMSG( L"CFGBKEND-GetUserPerm RegQueryValueEx failed 0x%x\n", *pdwStatus );

		// not a true failure this means the key does not exist
        // set to one for relaxed security

        dwValue = 1;

        *pdwStatus = S_OK;
	}

    RegCloseKey( hKey );

    *pbUserPerm =  !( ( BOOL )( dwValue == 0 ) );

    return S_OK;
}

#if 1
//-----------------------------------------------------------------------------
//Private function
//-----------------------------------------------------------------------------
void CCfgComp::GetPdConfig( WDNAME WdKey,WINSTATIONCONFIG2W& WsConfig)
{
    LONG Status;
    PDCONFIG3 PdConfig;PDCONFIG3 PdSelected;PDCONFIG3 PdConfig2;
    ULONG Index = 0, Entries, ByteCount = sizeof(PDNAME);
    PDNAME PdKey;
    // BOOL bFound = FALSE;

    ULONG ByteCount2 = sizeof(PDNAME);
    ULONG Index1 = 1; // start off with one since WsConfig.Pd[0] is already populated
    
    do
    {
        Entries = 1;
        // outer loop searches for keys in /Wds / ( wdname ) /Tds
        Status = RegPdEnumerate(NULL,WdKey,TRUE,&Index,&Entries,PdKey,&ByteCount);

        if(Status != ERROR_SUCCESS)
        {
           break;
        }

        Status = RegPdQuery( NULL,WdKey,TRUE,PdKey,&PdConfig,sizeof(PdConfig),&ByteCount );

        if(Status != ERROR_SUCCESS)
        {
           break;
        }

        if(0 == lstrcmpi(WsConfig.Pd[0].Create.PdName, PdConfig.Data.PdName))
        {
            PdSelected = PdConfig;
            // bFound = TRUE;
            // 
            ULONG Index2 = 0;
            
            do
            {   
                // innerloop forces the search in Wds/ (wdname )/ Pds
                // Index must now be set to zero so that we get the first item

                Status = RegPdEnumerate(NULL,WdKey,FALSE,&Index2,&Entries,PdKey,&ByteCount2);

                if(Status != ERROR_SUCCESS)
                {
                      break;
                }
                
                Status = RegPdQuery( NULL,WdKey,FALSE,PdKey,&PdConfig2,sizeof(PdConfig),&ByteCount2);
                

                if(Status != ERROR_SUCCESS)
                {
                      break;
                }
                
                for( UINT i = 0; i < PdSelected.RequiredPdCount ; i++)
                {
                    if(0 == lstrcmpi(PdSelected.RequiredPds[i],PdConfig2.Data.PdName))
                    {
                        WsConfig.Pd[Index1].Create = PdConfig2.Data;
                        WsConfig.Pd[Index1].Params.SdClass = PdConfig2.Data.SdClass;
                        Index1++;

                        if(Index1 > MAX_PDCONFIG)
                        {
                            break;
                        }
                    }
                }
                
            }while(1);

        }

        /*
        if(bFound)
        {
            break;
        }
        */

     }while(1);

    return;
}

#endif 

#if 0
//-----------------------------------------------------------------------------
//Private function
//-----------------------------------------------------------------------------
void CCfgComp::GetPdConfig( WDNAME WdKey,WINSTATIONCONFIG2W& WsConfig)
{
    LONG Status;
    PDCONFIG3 PdConfig;
	PDCONFIG3 PdSelected;
	PDCONFIG3 PdConfig2;

    ULONG Index = 0, Entries = 1, ByteCount = sizeof(PDNAME);
    PDNAME PdKey;
    BOOL bFound = FALSE;

    ULONG ByteCount2 = sizeof(PDNAME);
    ULONG Index1 = 1;
    do
    {
        Status = RegPdEnumerate(NULL,WdKey,TRUE,&Index,&Entries,PdKey,&ByteCount);
        if(Status != ERROR_SUCCESS)
        {
           break;
        }
        
		// we could speed this up by enumerating only for the protocol type

		/*
		Status = RegPdQuery( NULL,WdKey,TRUE,PdKey,&PdConfig,sizeof(PdConfig),&ByteCount );
        if(Status != ERROR_SUCCESS)
        {
           break;
        }
		*/
		DBGMSG( L"CFGBKEND: PdKey is at first %ws\n", PdKey );

		DBGMSG( L"CFGBKEND: WsConfig.Pd[0].Create.PdName is %ws\n", WsConfig.Pd[0].Create.PdName );

        if( 0 == lstrcmpi(WsConfig.Pd[0].Create.PdName, PdKey ) ) //PdConfig.Data.PdName))
        {
			Status = RegPdQuery( NULL,WdKey,TRUE,PdKey,&PdConfig,sizeof(PdConfig),&ByteCount );

			if(Status != ERROR_SUCCESS)
			{
				break;
			}

            PdSelected = PdConfig;

            bFound = TRUE;

			// why didn't we reset Index to zero?

			Index = 0;

			// why didn't we reset Entries back to one?

			Entries = 1;

            do
            {
				DBGMSG( L"CFGBKEND: WdKey is %ws\n" , WdKey );

				DBGMSG( L"CFGBKEND: PdKey before Enum is %ws\n", PdKey );

				
                Status = RegPdEnumerate(NULL,WdKey,FALSE,&Index,&Entries,PdKey,&ByteCount2);

                if(Status != ERROR_SUCCESS)
                {
                      break;
                }
				
				DBGMSG( L"CFGBKEND: PdKey is %ws\n", PdKey );

                Status = RegPdQuery( NULL,WdKey,FALSE,PdKey,&PdConfig2,sizeof(PdConfig),&ByteCount2);

                if(Status != ERROR_SUCCESS)
                {
					ODS(L"RegPdQuery failed\n" );
                      break;
                }

				ODS(L"RegPdQuery ok\n" );
				
				
                for( UINT i = 0; i < PdSelected.RequiredPdCount ; i++)
                {
					DBGMSG( L"CFGBKEND: Required pd name %s\n", PdConfig2.Data.PdName );

					DBGMSG( L"CFGBKEND: ReqName is list is %s\n", PdSelected.RequiredPds[i] );

                    if( 0 == lstrcmpi( PdSelected.RequiredPds[i] , PdConfig2.Data.PdName ) )
                    {
						DBGMSG( L"CFGBKEND: Copying pdconfig2 for pd name %s\n" , PdConfig2.Data.PdName );

                        WsConfig.Pd[Index1].Create = PdConfig2.Data;

                        WsConfig.Pd[Index1].Params.SdClass = PdConfig2.Data.SdClass;

                        Index1++;

                        if(Index1 > MAX_PDCONFIG)
                        {
                            break;
                        }
                    }
                }
				

            }while(1);

        }

        if(bFound)
        {
            break;
        }

     }while(1);

    return;
}

#endif 
#if 0 // removed for final
//-----------------------------------------------------------------------------
//Private function
//-----------------------------------------------------------------------------
BOOL CCfgComp::CompareSD(PSECURITY_DESCRIPTOR pSd1,PSECURITY_DESCRIPTOR pSd2)
{
    DWORD dwErr;
    ULONG index1 = 0;
    //int index2 = 0;
    ULONG    cAce1 = 0;
    EXPLICIT_ACCESS *pAce1 = NULL;

    ULONG    cAce2 = 0;
    EXPLICIT_ACCESS *pAce2 = NULL;
    BOOL bMatch = TRUE;

    if (!IsValidSecurityDescriptor(pSd1) || !IsValidSecurityDescriptor(pSd2))
    {
        return FALSE;
    }

    dwErr = LookupSecurityDescriptorParts(
             NULL,
             NULL,
             &cAce1,
             &pAce1,
             NULL,
             NULL,
             pSd1);
    if (ERROR_SUCCESS != dwErr)
    {
        return FALSE;
    }
    dwErr = LookupSecurityDescriptorParts(
             NULL,
             NULL,
             &cAce2,
             &pAce2,
             NULL,
             NULL,
             pSd2);
    if (ERROR_SUCCESS != dwErr)
    {
        bMatch = FALSE;
        goto cleanup;
    }
    if(cAce1 != cAce2)
    {
        bMatch = FALSE;
        goto cleanup;
    }
    for(index1 = 0; index1 < cAce1; index1++)
    {
        //for(index2 = 0; index2 < cAce1; index2++)
        {
            if ( _tcscmp(GetTrusteeName(&pAce1[index1].Trustee),GetTrusteeName(&pAce2[index1].Trustee)) ||
                (pAce1[index1].grfAccessPermissions != pAce2[index1].grfAccessPermissions)||
                (pAce1[index1].grfAccessMode != pAce2[index1].grfAccessMode ))
            {
                bMatch = FALSE;
                break;
            }

        }
    }

cleanup:
    if(pAce1)
    {
        LocalFree(pAce1);
    }
    if(pAce2)
    {
        LocalFree(pAce2);
    }
    return bMatch;

}

#endif

//-----------------------------------------------------------------------------
BOOL CCfgComp::RegServerAccessCheck(REGSAM samDesired)
{
    LONG Status = 0;
    HKEY Handle = NULL;

    /*
     * Attempt to open the registry
     * at the requested access level.
     */
    if ( (Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                                 samDesired, &Handle )) == ERROR_SUCCESS  )
    {
        RegCloseKey( Handle );
    }

    return( Status );

}

#if 0 // removed for final release
//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetDefaultSecurity(ULONG * pDefaultSecurity)
{
    HRESULT hResult = S_OK;
    //Check the parameters
    if(NULL == pDefaultSecurity)
    {
        return E_INVALIDARG;
    }

    *pDefaultSecurity = 0;

    PSECURITY_DESCRIPTOR pDefaultDescriptor = NULL;
    PSECURITY_DESCRIPTOR pTempDescriptor = NULL;

    pDefaultDescriptor = ReadSecurityDescriptor(0);
    if(NULL == pDefaultDescriptor)
    {
        *pDefaultSecurity = 0;
        return hResult;
    }

    for(int i = 0; i < NUM_DEFAULT_SECURITY; i++)
    {
        pTempDescriptor = ReadSecurityDescriptor(i+1);
        if(NULL == pTempDescriptor)
        {
            continue;
        }
        if(TRUE == CompareSD(pDefaultDescriptor,pTempDescriptor))
        {
            *pDefaultSecurity = i+1;
            break;
        }
        else
        {
            LocalFree(pTempDescriptor);
            pTempDescriptor = NULL;
        }
    }

    if(pDefaultDescriptor)
    {
        LocalFree(pDefaultDescriptor);
    }
    if(pTempDescriptor)
    {
        LocalFree(pTempDescriptor);
    }
    return hResult;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::SetDefaultSecurity(ULONG Offset)
{
    HRESULT hResult;

    if( !m_bAdmin )
    {
        return E_ACCESSDENIED;
    }

    if(0 == Offset)
    {
        return E_INVALIDARG;
    }

    PSECURITY_DESCRIPTOR pTempDescriptor = NULL;

    pTempDescriptor = ReadSecurityDescriptor(Offset);

    if(NULL == pTempDescriptor)
    {
        return E_FAIL;
    }

    hResult = SetDefaultSecurityDescriptor( pTempDescriptor );

    if( pTempDescriptor != NULL )
    {
        LocalFree(pTempDescriptor);
    }

    return hResult;
}

//-----------------------------------------------------------------------------
PSECURITY_DESCRIPTOR CCfgComp::ReadSecurityDescriptor(ULONG index)
{
    PBYTE pData = NULL;
    TCHAR * pValue = NULL;
    HLOCAL hLocal;
    HKEY Handle = NULL;
    DWORD ValueType = 0;
    DWORD ValueSize=0;
    LONG Status = 0;

    switch(index)
    {

    case 0:
        pValue = REG_DEF_SECURITY;
        break;
    case 1:
        pValue = REG_REMOTE_SECURITY;
        break;
    case 2:
        pValue = REG_APPL_SECURITY;
        break;
    case 3:
        pValue = REG_ANON_SECURITY;
        break;

    default:
        return NULL;
    }

    if(NULL == pValue)
    {
        return NULL;
    }

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,
                       KEY_READ, &Handle );
    if ( Status == ERROR_SUCCESS )
    {

        Status = RegQueryValueEx( Handle,
                                  pValue,
                                  NULL,
                                  &ValueType,
                                  NULL,
                                  &ValueSize );
        if(Status != ERROR_SUCCESS)
        {
            return NULL;
        }
        hLocal = LocalAlloc(LMEM_FIXED, ValueSize);
        if(NULL == hLocal)
        {
            return pData;
        }
        pData = (LPBYTE)LocalLock(hLocal);
        if(NULL == pData)
        {
            return NULL;
        }
        Status = RegQueryValueEx( Handle,
                                  pValue,
                                  NULL,
                                  &ValueType,
                                  pData,
                                  &ValueSize );
        if(Status != ERROR_SUCCESS)
        {
            RegCloseKey(Handle);
            LocalFree(pData);
            return NULL;
        }


     }
     if(Handle)
     {
         RegCloseKey(Handle);
     }
     return (PSECURITY_DESCRIPTOR)pData;

}

//-----------------------------------------------------------------------------
HRESULT CCfgComp::SetDefaultSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurity)
{
    if(NULL == pSecurity)
    {
        return E_INVALIDARG;
    }

    if(ValidateSecurityDescriptor(pSecurity)!=ERROR_SUCCESS)
    {
        return E_INVALIDARG;
    }

    HKEY Handle = NULL;
    LONG Status = 0;
    ULONG Size = 0;

    Size = GetSecurityDescriptorLength(pSecurity);

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,
                       KEY_READ |KEY_SET_VALUE , &Handle );
    if ( Status == ERROR_SUCCESS )
    {
        Status = RegSetValueEx(Handle,
                               REG_DEF_SECURITY,
                               0,
                               REG_BINARY,
                               (BYTE *)pSecurity,
                               Size);
        if(Status != ERROR_SUCCESS)
        {
            return E_FAIL;
        }

    }

    if( Handle )
    {
        RegCloseKey(Handle);
    }


    if( !_WinStationReInitializeSecurity( SERVERNAME_CURRENT ) )
    {
        ODS( L"CFGBKEND: _WinStationReInitializeSecurity failed\n" );

        return E_FAIL;
    }



    return S_OK;
}

#endif //

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::SetActiveDesktopState( /* in */ BOOL bActivate , /* out */ PDWORD pdwStatus )
{
        // HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\NoActiveDesktop
        if( !m_bAdmin )
        {
                ODS( L"CFGBKEND : SetActiveDesktopState caller does not have admin rights\n" );

                *pdwStatus = ERROR_ACCESS_DENIED;

                return E_ACCESSDENIED;

        }

        // try to open key

        HKEY hKey;

        *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                                                        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer" ) ,
                                                        0,
                                                        KEY_READ | KEY_WRITE ,
                                                        &hKey );

        if( *pdwStatus != ERROR_SUCCESS )
        {
                if( bActivate )
                {
                        ODS( L"CFGBKEND : SetActiveDesktopState -- RegOpenEx unable to open key\n" );

                        return E_FAIL;
                }
                else
                {
                        // the key doesn't exist but we were trying to disable anyway donot pro
                        // we should assert( 0 ) here  because we should not be disabling what
                        // could not have been enabled

                        return S_FALSE;
                }
        }

        if( !bActivate )
        {
                DWORD dwValue = 1;

                *pdwStatus = RegSetValueEx( hKey ,
                                                                    TEXT( "NoActiveDesktop" ),
                                                                        NULL,
                                                                        REG_DWORD,
                                                                        ( LPBYTE )&dwValue ,
                                                                        sizeof( DWORD ) );
        }
        else
        {
                *pdwStatus = RegDeleteValue( hKey , TEXT( "NoActiveDesktop" ) );
        }

        RegCloseKey( hKey );


        if( *pdwStatus != NO_ERROR )
        {
                ODS( L"CFGBKEND : SetActiveDesktopState returned error\n" );

                return E_FAIL;
        }


        return S_OK;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetActiveDesktopState( /* out */ PBOOL pbActive , /* out */PDWORD pdwStatus)
{
        if( pbActive == NULL )
        {
                ODS( L"CFGBKEND : GetActiveDesktop -- invaild arg\n" );

                *pdwStatus = ERROR_FILE_NOT_FOUND;

                return E_INVALIDARG;
        }

                // try to open key

        HKEY hKey;

        *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                                                        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer" ) ,
                                                        0,
                                                        KEY_READ ,
                                                        &hKey );

        if( *pdwStatus != ERROR_SUCCESS )
        {
                ODS( L"CFGBKEND : GetActiveDesktopState -- RegOpenEx unable to open key\n" );

                return E_FAIL;

        }

        DWORD dwData = 0;

        DWORD dwSize = sizeof( DWORD );

        *pdwStatus = RegQueryValueEx( hKey ,
                                      TEXT( "NoActiveDesktop" ) ,
                                      NULL ,
                                      NULL ,
                                      ( LPBYTE )&dwData ,
                                      &dwSize );

        // Status of this key is enabled if the key does not exist

        if( *pdwStatus == ERROR_SUCCESS )
        {
                *pbActive = !( BOOL )dwData;
        }

        RegCloseKey( hKey );

        if( *pdwStatus != ERROR_SUCCESS )
        {
                DBGMSG( L"CFGBKEND : GetActiveDesktopState -- error ret 0x%x\n" , *pdwStatus );

                if( *pdwStatus == ERROR_FILE_NOT_FOUND )
                {
                        *pbActive = TRUE;

                        return S_FALSE;
                }

                return E_FAIL;
        }

        return S_OK;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetTermSrvMode( /* out */ PDWORD pdwMode , PDWORD pdwStatus )
{
    ODS( L"CFGBKEND : GetTermSrvMode\n" );

    if( pdwMode == NULL || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    HKEY hKey;

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                               REG_CONTROL_TSERVER,
                               0,
                               KEY_READ ,
                               &hKey );

        if( *pdwStatus != ERROR_SUCCESS )
        {
                ODS( L"CFGBKEND : GetTermSrvMode -- RegOpenEx unable to open key\n" );

                return E_FAIL;

        }

        DWORD dwData = 0;

        DWORD dwSize = sizeof( DWORD );

        *pdwStatus = RegQueryValueEx( hKey ,
                                  TEXT( "TSAppCompat" ) ,
                                  NULL ,
                                  NULL ,
                                  ( LPBYTE )&dwData ,
                                  &dwSize );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND : GetTermSrvMode -- RegQueryValueEx failed\n" );

        *pdwMode = 1; // for application server
    }
    else
    {
        *pdwMode = dwData;

    }

    RegCloseKey( hKey );

    return S_OK;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetSalemHelpMode( BOOL *pVal, PDWORD pdwStatus)
{
    HKEY hKey;

    ODS( L"CFGBKEND : GetSalemHelpMode\n" );

    if( pVal == NULL || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                               REG_CONTROL_GETHELP,
                               0,
                               KEY_READ ,
                               &hKey );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND : GetSalemHelpMode -- RegOpenEx unable to open key\n" );
        *pVal = 1;   // default to help is available

        // don't want to fail caller so return S_OK
        return S_OK;
    }

    DWORD dwData = 0;

    DWORD dwSize = sizeof( DWORD );

    *pdwStatus = RegQueryValueEx( hKey ,
                              POLICY_TS_REMDSK_ALLOWTOGETHELP,
                              NULL ,
                              NULL ,
                              ( LPBYTE )&dwData ,
                              &dwSize );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND : GetSalemHelpMode -- RegQueryValueEx failed\n" );
        *pVal = 1; // assume help is available
    }
    else
    {
        *pVal = dwData;

    }

    RegCloseKey( hKey );
    return S_OK;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::SetSalemHelpMode( BOOL val, PDWORD pdwStatus )
{
    HKEY hKey;

    ODS( L"CFGBKEND : SetSalemHelpMode\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            REG_CONTROL_GETHELP,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                        );
    
    if( ERROR_SUCCESS != *pdwStatus )
    {
        ODS( L"CFGBKEND : SetSalemHelpMode -- RegCreateKeyEx failed\n" );
        return E_FAIL;
    }

    DWORD dwValue;
    dwValue = (val) ? 1 : 0;

    *pdwStatus = RegSetValueEx(
                            hKey,
                            POLICY_TS_REMDSK_ALLOWTOGETHELP,
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwValue,
                            sizeof(DWORD)
                        );

    RegCloseKey(hKey);

    return (ERROR_SUCCESS == *pdwStatus ) ? S_OK : E_FAIL;
}

//-----------------------------------------------------------------------------
HRESULT CCfgComp::GetSingleSessionState( BOOL *pVal, PDWORD pdwStatus )
{
    HKEY hKey;
    TCHAR tchRegPath[ MAX_PATH ] = TEXT( "system\\currentcontrolset\\control\\Terminal Server" );


    ODS( L"CFGBKEND : GetSingleSessionState\n" );

    if( pVal == NULL || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                               tchRegPath ,
                               0,
                               KEY_READ ,
                               &hKey );

    if( *pdwStatus != ERROR_SUCCESS )
    {        
        ODS( L"CFGBKEND : GetSingleSessionState -- RegOpenKeyEx unable to open key\n" );
        
        return S_OK;
    }

    DWORD dwData = 0;

    DWORD dwSize = sizeof( DWORD );

    *pdwStatus = RegQueryValueEx( hKey ,
                              L"fSingleSessionPerUser",
                              NULL ,
                              NULL ,
                              ( LPBYTE )&dwData ,
                              &dwSize );

    if( *pdwStatus == ERROR_SUCCESS )
    {        
        *pVal = dwData;
    }
    else
    {
        ODS( L"CFGBKEND : GetSingleSessionState -- RegQueryValueEx failed\n" );
    }

    RegCloseKey( hKey );
    return S_OK;
}

//----------------------------------------------------------------------------

HRESULT CCfgComp::SetSingleSessionState( BOOL val, PDWORD pdwStatus )
{
    HKEY hKey;
    TCHAR tchRegPath[ MAX_PATH ] = TEXT( "system\\currentcontrolset\\control\\Terminal Server" );

    ODS( L"CFGBKEND : SetSingleSessionState\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    
    *pdwStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            tchRegPath,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                        );
    
    if( ERROR_SUCCESS != *pdwStatus )
    {
        ODS( L"CFGBKEND : SetSingleSessionState -- RegCreateKeyEx failed\n" );

        if (ERROR_ACCESS_DENIED == *pdwStatus)
            return E_ACCESSDENIED;
        else
            return E_FAIL;
    }

    DWORD dwValue;
    dwValue = (val) ? 1 : 0;

    *pdwStatus = RegSetValueEx(
                            hKey,
                            L"fSingleSessionPerUser",
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwValue,
                            sizeof(DWORD)
                        );
    if( ERROR_SUCCESS != *pdwStatus )
    {
        ODS( L"CFGBKEND : SetSingleSessionState -- RegSetValueEx failed\n" );

        if (ERROR_ACCESS_DENIED == *pdwStatus)
            return E_ACCESSDENIED;
        else
            return E_FAIL;
    }
    RegCloseKey(hKey);
    UpdateSessionDirectory(pdwStatus);


    return (ERROR_SUCCESS == *pdwStatus ) ? S_OK : E_FAIL;
}

//-----------------------------------------------------------------------------
HRESULT CCfgComp::GetDisableForcibleLogoff( BOOL *pVal, PDWORD pdwStatus )
{
    HKEY hKey = NULL;
    TCHAR tchRegPath[ MAX_PATH ] = TEXT( "system\\currentcontrolset\\control\\Terminal Server" );


    ODS( L"CFGBKEND : GetDisableForcibleLogoff\n" );

    if( pVal == NULL || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }
    *pVal = 0;

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                               tchRegPath ,
                               0,
                               KEY_READ ,
                               &hKey );

    if( *pdwStatus != ERROR_SUCCESS )
    {        
        ODS( L"CFGBKEND : GetSingleSessionState -- RegOpenKeyEx unable to open key\n" );
        
        return S_OK;
    }

    DWORD dwData = 0;

    DWORD dwSize = sizeof( DWORD );

    *pdwStatus = RegQueryValueEx( hKey ,
                              L"fDisableForcibleLogoff",
                              NULL ,
                              NULL ,
                              ( LPBYTE )&dwData ,
                              &dwSize );

    if( *pdwStatus == ERROR_SUCCESS )
    {        
        *pVal = dwData;
    }
    else
    {
        ODS( L"CFGBKEND : GetDisableForcibleLogoff -- RegQueryValueEx failed\n" );
    }

    if(hKey)
    {
        RegCloseKey( hKey );
    }
    return S_OK;
}

//----------------------------------------------------------------------------

HRESULT CCfgComp::SetDisableForcibleLogoff( BOOL val, PDWORD pdwStatus )
{
    HKEY hKey = NULL;
    TCHAR tchRegPath[ MAX_PATH ] = TEXT( "system\\currentcontrolset\\control\\Terminal Server" );

    ODS( L"CFGBKEND : SetDisableForceLogoff\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    
    *pdwStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            tchRegPath,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                        );
    
    if( ERROR_SUCCESS != *pdwStatus )
    {
        ODS( L"CFGBKEND : SetDisableForceLogoff -- RegCreateKeyEx failed\n" );

        if (ERROR_ACCESS_DENIED == *pdwStatus)
            return E_ACCESSDENIED;
        else
            return E_FAIL;
    }

    DWORD dwValue;
    dwValue = (val) ? 1 : 0;

    *pdwStatus = RegSetValueEx(
                            hKey,
                            L"fDisableForcibleLogoff",
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwValue,
                            sizeof(DWORD)
                        );
    if( ERROR_SUCCESS != *pdwStatus )
    {
        ODS( L"CFGBKEND : SetDisableForceLogoff -- RegSetValueEx failed\n" );

        if (ERROR_ACCESS_DENIED == *pdwStatus)
            return E_ACCESSDENIED;
        else
            return E_FAIL;
    }

    if(hKey)
    {
        RegCloseKey(hKey);    
    }

    return (ERROR_SUCCESS == *pdwStatus ) ? S_OK : E_FAIL;
}


//-----------------------------------------------------------------------------
HRESULT CCfgComp::GetColorDepth ( PWINSTATIONNAME pWs, BOOL *pVal, PDWORD pdwStatus )
{
    HKEY hKey;
    TCHAR tchRegPath[ MAX_PATH ] = TEXT( "system\\currentcontrolset\\control\\Terminal Server\\winstations\\" );

    // make sure winstation name isn't longer than it should be
    if (lstrlen(pWs) > WINSTATIONNAME_LENGTH)
    {
        return E_INVALIDARG;
    }

	if(pWs != NULL)
	{
		lstrcat( tchRegPath , pWs );
	}

    ODS( L"CFGBKEND : GetColorDepth\n" );

    if( pVal == NULL || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                               tchRegPath ,
                               0,
                               KEY_READ ,
                               &hKey );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND : GetColorDepth -- RegOpenKeyEx unable to open key\n" );
       
        return E_FAIL;
    }

    DWORD dwData = 0;

    DWORD dwSize = sizeof( DWORD );

    *pdwStatus = RegQueryValueEx( hKey ,
                              L"fInheritColorDepth",
                              NULL ,
                              NULL ,
                              ( LPBYTE )&dwData ,
                              &dwSize );

    if( *pdwStatus == ERROR_SUCCESS )
    {         
        *pVal = dwData;
    }
    else
    {
        ODS( L"CFGBKEND : GetColorDepth -- RegQueryValueEx failed\n" );
    }

    RegCloseKey( hKey );

    return S_OK;
}

//----------------------------------------------------------------------------

HRESULT CCfgComp::SetColorDepth( PWINSTATIONNAME pWs, BOOL val, PDWORD pdwStatus )
{
    HKEY hKey;
    TCHAR tchRegPath[ MAX_PATH ] = TEXT( "system\\currentcontrolset\\control\\Terminal Server\\winstations\\" );

    // make sure winstation name isn't longer than it should be
    if (lstrlen(pWs) > WINSTATIONNAME_LENGTH)
    {
        return E_INVALIDARG;
    }

	if(pWs != NULL)
	{
		lstrcat( tchRegPath , pWs );
	}

    ODS( L"CFGBKEND : SetColorDepth\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            tchRegPath ,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                        );
    
    if( ERROR_SUCCESS != *pdwStatus )
    {
        ODS( L"CFGBKEND : SetColorDepth -- RegCreateKeyEx failed\n" );
        return E_FAIL;
    }

    DWORD dwValue;
    dwValue = (val) ? 1 : 0;

    *pdwStatus = RegSetValueEx(
                            hKey,
                            L"fInheritColorDepth",
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwValue,
                            sizeof(DWORD)
                        );

    RegCloseKey(hKey);

    return (ERROR_SUCCESS == *pdwStatus ) ? S_OK : E_FAIL;
}





//-----------------------------------------------------------------------------
HRESULT CCfgComp::GetKeepAliveTimeout ( PWINSTATIONNAME pWs, BOOL *pVal, PDWORD pdwStatus )
{
    HKEY hKey;
    TCHAR tchRegPath[ MAX_PATH ] = TEXT( "system\\currentcontrolset\\control\\Terminal Server\\winstations\\" );

    // make sure winstation name isn't longer than it should be
    if (lstrlen(pWs) > WINSTATIONNAME_LENGTH)
    {
        return E_INVALIDARG;
    }

    if(pWs != NULL)
    {
	    lstrcat( tchRegPath , pWs );
    }

    ODS( L"CFGBKEND : GetKeepAliveTimeout\n" );

    if( pVal == NULL || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                               tchRegPath ,
                               0,
                               KEY_READ ,
                               &hKey );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND : GetKeepAliveTimeout -- RegOpenKeyEx unable to open key\n" );
       
        return E_FAIL;
    }

    DWORD dwData = 0;

    DWORD dwSize = sizeof( DWORD );

    *pdwStatus = RegQueryValueEx( hKey ,
                              L"KeepAliveTimeout",
                              NULL ,
                              NULL ,
                              ( LPBYTE )&dwData ,
                              &dwSize );

    if( *pdwStatus == ERROR_SUCCESS )
    {         
        *pVal = dwData;
    }
    else
    {
        ODS( L"CFGBKEND : GetKeepAliveTimeout -- RegQueryValueEx failed\n" );
    }

    RegCloseKey( hKey );

    return S_OK;
}

//----------------------------------------------------------------------------

HRESULT CCfgComp::SetKeepAliveTimeout( PWINSTATIONNAME pWs, BOOL val, PDWORD pdwStatus )
{
    HKEY hKey;
    TCHAR tchRegPath[ MAX_PATH ] = TEXT( "system\\currentcontrolset\\control\\Terminal Server\\winstations\\" );
    
    // make sure winstation name isn't longer than it should be
    if (lstrlen(pWs) > WINSTATIONNAME_LENGTH)
    {
        return E_INVALIDARG;
    }

	if(pWs != NULL)
	{
		lstrcat( tchRegPath , pWs );
	}

    ODS( L"CFGBKEND : SetKeepAliveTimeout\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            tchRegPath ,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                        );
    
    if( ERROR_SUCCESS != *pdwStatus )
    {
        ODS( L"CFGBKEND : SetKeepAliveTimeout -- RegCreateKeyEx failed\n" );
        return E_FAIL;
    }

    DWORD dwValue;
    dwValue = (val) ? 1 : 0;

    *pdwStatus = RegSetValueEx(
                            hKey,
                            L"KeepAliveTimeout",
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwValue,
                            sizeof(DWORD)
                        );

    RegCloseKey(hKey);

    return (ERROR_SUCCESS == *pdwStatus ) ? S_OK : E_FAIL;
}




//-----------------------------------------------------------------------------
HRESULT CCfgComp::GetDenyTSConnections ( BOOL *pVal, PDWORD pdwStatus )
{
    HKEY hKey;

    ODS( L"CFGBKEND : GetDenyTSConnections\n" );

    if( pVal == NULL || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                               REG_CONTROL_TSERVER  ,
                               0,
                               KEY_READ ,
                               &hKey );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND : GetDenyTSConnections -- RegOpenKeyEx unable to open key\n" );        

        return S_OK;
    }

    DWORD dwData = 0;

    DWORD dwSize = sizeof( DWORD );

    *pdwStatus = RegQueryValueEx( hKey ,
                              L"fDenyTSConnections",
                              NULL ,
                              NULL ,
                              ( LPBYTE )&dwData ,
                              &dwSize );

    if( *pdwStatus == ERROR_SUCCESS )
    {
        *pVal = dwData;
    }
    else
    {
        ODS( L"CFGBKEND : GetDenyTSConnections -- RegQueryValueEx failed\n" );
    }

    RegCloseKey( hKey );
    return S_OK;
}

//----------------------------------------------------------------------------

HRESULT CCfgComp::SetDenyTSConnections( BOOL val, PDWORD pdwStatus )
{
    HKEY hKey;

    ODS( L"CFGBKEND : SetDenyTSConnections\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            REG_CONTROL_TSERVER ,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                        );
    
    if( ERROR_SUCCESS != *pdwStatus )
    {
        ODS( L"CFGBKEND : SetDenyTSConnections -- RegCreateKeyEx failed\n" );
        return E_FAIL;
    }

    DWORD dwValue;
    dwValue = (val) ? 1 : 0;

    *pdwStatus = RegSetValueEx(
                            hKey,
                            L"fDenyTSConnections",
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwValue,
                            sizeof(DWORD)
                        );

    RegCloseKey(hKey);

    return (ERROR_SUCCESS == *pdwStatus ) ? S_OK : E_FAIL;
}

//-----------------------------------------------------------------------------

HRESULT CCfgComp::GetProfilePath ( BSTR *pbstrVal, PDWORD pdwStatus )
{
    HKEY hKey;
    DWORD dwSize = 0;
    static TCHAR tchData[ MAX_PATH ] ;
    dwSize = sizeof( tchData);

    ODS( L"CFGBKEND : GetProfilePath\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                               REG_CONTROL_TSERVER  ,
                               0,
                               KEY_READ ,
                               &hKey );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND : GetProfilePath -- RegOpenKeyEx unable to open key\n" );        

        return E_FAIL;
    }

    dwSize = sizeof( tchData );

    *pdwStatus = RegQueryValueEx( hKey ,
                              L"WFProfilePath",
                              NULL ,
                              NULL ,
                              (LPBYTE)&tchData ,
                              &dwSize );

    if( *pdwStatus == ERROR_SUCCESS )
    {
        *pbstrVal = SysAllocString (tchData);
    }
    else
    {
        ODS( L"CFGBKEND : GetProfilePath -- RegQueryValueEx failed\n" );
    }

    RegCloseKey( hKey );

    return S_OK;
}


//----------------------------------------------------------------------------

HRESULT CCfgComp::SetProfilePath( BSTR bstrVal, PDWORD pdwStatus )
{
    HKEY hKey;

    ODS( L"CFGBKEND : SetProfilePath\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    
    *pdwStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            REG_CONTROL_TSERVER,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                        );
    
    
    if( ERROR_SUCCESS != *pdwStatus )
    {
        ODS( L"CFGBKEND : SetProfilePath -- RegCreateKeyEx failed\n" );
        return E_FAIL;
    }

    *pdwStatus = RegSetValueEx(
                            hKey,
                            L"WFProfilePath",
                            0,
                            REG_SZ,
                            ( LPBYTE const )(bstrVal) ,
                            (lstrlen(bstrVal)+1)*sizeof(WCHAR)
                            );

    ODS( L"CFGBKEND : SetProfilePath -- RegCreateKeyEx failed\n" );

    if(bstrVal != NULL)
    {
        SysFreeString(bstrVal);
    }

    RegCloseKey(hKey);

    return (ERROR_SUCCESS == *pdwStatus ) ? S_OK : E_FAIL;
}



//-----------------------------------------------------------------------------

HRESULT CCfgComp::GetHomeDir ( BSTR *pbstrVal, PDWORD pdwStatus )
{
    HKEY hKey;
    DWORD dwSize = 0;
    static TCHAR tchData[ MAX_PATH ] ;
    dwSize = sizeof( tchData);

    ODS( L"CFGBKEND : GetHomeDir\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                               REG_CONTROL_TSERVER  ,
                               0,
                               KEY_READ ,
                               &hKey );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND : GetProfilePath -- RegOpenKeyEx unable to open key\n" );        

        return E_FAIL;
    }

    *pdwStatus = RegQueryValueEx( hKey ,
                              L"WFHomeDir",
                              NULL ,
                              NULL ,
                              (LPBYTE)&tchData ,
                              &dwSize );

    if( *pdwStatus == ERROR_SUCCESS )
    {
        *pbstrVal = SysAllocString (tchData);
    }
    else
    {
        ODS( L"CFGBKEND : GetHomeDir -- RegQueryValueEx failed\n" );
    }

    RegCloseKey( hKey );

    return S_OK;
}


//----------------------------------------------------------------------------

HRESULT CCfgComp::SetHomeDir( BSTR bstrVal, PDWORD pdwStatus )
{
    HKEY hKey = NULL; 


    ODS( L"CFGBKEND : SetHomeDir\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            REG_CONTROL_TSERVER ,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                        );
    

    
    if( ERROR_SUCCESS != *pdwStatus )
    {
        ODS( L"CFGBKEND : SetHomeDir -- RegCreateKeyEx failed\n" );
        return E_FAIL;
    }

    *pdwStatus = RegSetValueEx(
                            hKey,
                            L"WFHomeDir",
                            0,
                            REG_SZ,
                            ( LPBYTE const )(bstrVal) ,
                            (lstrlen(bstrVal)+1)*sizeof(WCHAR)
                        );
    if(bstrVal != NULL)
    {
        SysFreeString(bstrVal);
    }

    if(hKey)
    {
        RegCloseKey(hKey);
    }

    return (ERROR_SUCCESS == *pdwStatus ) ? S_OK : E_FAIL;
}


//-----------------------------------------------------------------------------
HRESULT CCfgComp::GetTimeZoneRedirection ( BOOL *pVal, PDWORD pdwStatus )
{
    HKEY hKey;

    ODS( L"CFGBKEND : GetTimeZoneRedirection\n" );

    if( pVal == NULL || pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }
    *pVal = 0;

    *pdwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                               REG_CONTROL_TSERVER,
                               0,
                               KEY_READ ,
                               &hKey );

    if( *pdwStatus != ERROR_SUCCESS )
    {
        ODS( L"CFGBKEND : GetTimeZoneRedirection -- RegOpenKeyEx unable to open key\n" );        

        return S_OK;
    }

    DWORD dwData = 0;

    DWORD dwSize = sizeof( DWORD );

    *pdwStatus = RegQueryValueEx( hKey ,
                              L"fEnableTimeZoneRedirection",
                              NULL ,
                              NULL ,
                              ( LPBYTE )&dwData ,
                              &dwSize );

    if( *pdwStatus == ERROR_SUCCESS )
    {
        *pVal = dwData;
    }
    else
    {
        ODS( L"CFGBKEND : GetTimeZoneRedirection -- RegQueryValueEx failed\n" );
    }

    RegCloseKey( hKey );
    return S_OK;
}


//----------------------------------------------------------------------------

HRESULT CCfgComp::SetTimeZoneRedirection( BOOL val, PDWORD pdwStatus )
{
    HKEY hKey;
  
    ODS( L"CFGBKEND : SetTimeZoneRedirection\n" );

    if( pdwStatus == NULL )
    {
        return E_INVALIDARG;
    }

    *pdwStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            REG_CONTROL_TSERVER,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                        );
    
    if( ERROR_SUCCESS != *pdwStatus )
    {
        ODS( L"CFGBKEND : SetTimeZoneRedirection -- RegCreateKeyEx failed\n" );
        return E_FAIL;
    }

    DWORD dwValue;
    dwValue = (val) ? 1 : 0;

    *pdwStatus = RegSetValueEx(
                            hKey,
                            L"fEnableTimeZoneRedirection",
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwValue,
                            sizeof(DWORD)
                        );

    RegCloseKey(hKey);

    return (ERROR_SUCCESS == *pdwStatus ) ? S_OK : E_FAIL;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::GetWdKey( WCHAR *wdname ,  WCHAR *wdkey )
{
    if( wdname == NULL || wdkey == NULL )
    {
        return E_INVALIDARG;
    }

    PWD pWD = GetWdObject( wdname );

    if(NULL == pWD)
    {
        return E_FAIL;
    }

    lstrcpy( wdkey , pWD->wdKey );

    return S_OK;
}

/*=-----------------------------------------------------------------------------

  pwszWinstaName  -- name of winstation to modify.
  pwszAccountName -- is the netbios name of the user we want to modify.
  dwMask          -- winstation specific access.
  fDel            -- TRUE to delete all DACL or SACL for the specifed 
                     account if it exist, FALSE to add entry.
  fAllow          -- TRUE to allow, FALSE to deny, parameter ignored if
                     fDel is set to TRUE
  fNew            -- TRUE removes all existing entries for this account
                     FALSE no action taken, parameter ignored if fDel
                     is set to TRUE.
  fAuditing       -- TRUE, modify SACL, FALSE modify DACL.
  pdwStatus       -- status of operation

Remark:


    fDel    fNew        Operation
    ------- -------     ------------------------------------------
    TRUE    ignored     Delete all entries for the specified user.
    FALSE   TRUE        Delete all entries then add allow or deny
                        entry for the specified user.
    FALSE   FALSE       Add allow or deny entry for the specified user,
                        no modify to existing entries.

 =----------------------------------------------------------------------------*/
STDMETHODIMP CCfgComp::ModifyUserAccess( WCHAR *pwszWinstaName ,
                                         WCHAR *pwszAccountName ,
                                         DWORD  dwMask ,
                                         BOOL   fDel ,
                                         BOOL   fAllow ,
                                         BOOL   fNew ,
                                         BOOL   fAuditing ,
                                         PDWORD pdwStatus )
{
    return ModifyWinstationSecurity( FALSE, 
                                     pwszWinstaName,
                                     pwszAccountName,
                                     dwMask,
                                     fDel,
                                     fAllow,
                                     fNew,
                                     fAuditing,
                                     pdwStatus
                                );
}

//-----------------------------------------------------------------------------
STDMETHODIMP CCfgComp::ModifyDefaultSecurity( WCHAR *pwszWinstaName ,
                                              WCHAR *pwszAccountName ,
                                              DWORD  dwMask ,
                                              BOOL   fDel ,
                                              BOOL   fAllow ,
                                              BOOL   fAuditing ,
                                              PDWORD pdwStatus )
{
    HRESULT hr = S_OK;

    if( NULL == pwszWinstaName || 0 == lstrlen(pwszWinstaName) )
    {
        for( DWORD i = 0; i < g_numDefaultSecurity && SUCCEEDED(hr) ; i++ )
        {
            hr = ModifyWinstationSecurity( 
                                     TRUE, 
                                     g_pszDefaultSecurity[i],
                                     pwszAccountName,
                                     dwMask,
                                     fDel,
                                     fAllow,
                                     FALSE,     // never recreate default security
                                     fAuditing,
                                     pdwStatus
                                );
        }
    }
    else
    {
        hr = ModifyWinstationSecurity( 
                                    TRUE, 
                                    pwszWinstaName,
                                    pwszAccountName,
                                    dwMask,
                                    fDel,
                                    fAllow,
                                    FALSE,     // never recreate default security
                                    fAuditing,
                                    pdwStatus
                                );
    }


    return hr;
}

DWORD
CCfgComp::GetUserSid(
    LPCTSTR pwszAccountName,
    PSID* ppUserSid
    )
/*++

Abstract:

    Retrieve User SID for user account.

Parameter:

    pwszAccountName : Name of the account to retrieve SID.
    ppUserSid : Pointer to PSID to receive SID for the account.

Returns:

    ERROR_SUCCESS or Error Code

Note :

    Retrieve only local account or domain account.

--*/
{
    DWORD cbSid = 0;
    DWORD cbDomain = 0;
    PSID pSID = NULL;
    LPTSTR pszDomain = NULL;
    BOOL bStatus;
    DWORD dwStatus = ERROR_SUCCESS;    
    SID_NAME_USE seUse;   

    bStatus = LookupAccountName( 
                            NULL ,
                            pwszAccountName ,
                            NULL ,
                            &cbSid,
                            NULL ,
                            &cbDomain,
                            &seUse);

    if( FALSE == bStatus )
    {
        dwStatus = GetLastError();
        if( ERROR_INSUFFICIENT_BUFFER != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }
    }

    dwStatus = ERROR_SUCCESS;

    pSID = ( PSID )LocalAlloc( LMEM_FIXED , cbSid );
    pszDomain = ( LPTSTR )LocalAlloc( LMEM_FIXED , sizeof(WCHAR) * (cbDomain + 1) );

    if( pSID == NULL || pszDomain == NULL )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    if( !LookupAccountName( NULL ,
                            pwszAccountName ,
                            pSID ,
                            &cbSid,
                            pszDomain ,
                            &cbDomain,
                            &seUse ) )
    {
        dwStatus = GetLastError();
    }
    else
    {
        *ppUserSid = pSID;
        pSID = NULL;
    }


CLEANUPANDEXIT:

    if( NULL != pszDomain )
    {
        LocalFree( pszDomain );
    }

    if( NULL != pSID )
    {
        LocalFree( pSID );
    }

    return dwStatus;
}    


DWORD
CCfgComp::RemoveUserEntriesInACL(
    LPCTSTR pszUserName,
    PACL pAcl,
    PACL* ppNewAcl
    )
/*++

Abstract :

    Remote all DACL or SACL from ACL for the account.

Parameters:

    pszUserName : Name of the user account to be removed from ACL list.
    pAcl : Pointer to ACL.
    ppNewAcl : Pointer to PACL to receive resulting ACL.


Returns:

    ERROR_SUCCESS
    ERROR_FILE_NOT_FOUND    All ACL are flagged as INHERITED_ACE.
    other error code

--*/
{
    PSID pSystemAcctSid = NULL;
    DWORD SidSize = 0;
    DWORD index = 0;
    DWORD dwStatus;
    DWORD dwNumNewEntries = 0;
    PSID pUserSid = NULL;
    ULONG cbExplicitEntries = 0;
    PEXPLICIT_ACCESS prgExplicitEntries = NULL;
    PEXPLICIT_ACCESS prgExplicitEntriesNew = NULL;
    ACL emptyACL;

    //
    // System account SID that we don't allow removing from our
    // winstation security descriptor.
    //
    // Local System            S-1-5-18
    // Local Service           S-1-5-19
    // Network Service         S-1-5-20
    //
    WELL_KNOWN_SID_TYPE RestrictedSid[] = {
                            WinLocalSystemSid,
                            WinLocalServiceSid,
                            WinNetworkServiceSid                
                        };
    DWORD numRestrictedSid = sizeof(RestrictedSid)/sizeof(RestrictedSid[0]);

    // 
    // We can use this funtion since we don't use INHERITED_ACE
    //
    dwStatus = GetExplicitEntriesFromAcl( 
                                    pAcl ,
                                    &cbExplicitEntries,
                                    &prgExplicitEntries
                                );

    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    if( 0 == cbExplicitEntries )
    {
        dwStatus = ERROR_FILE_NOT_FOUND;
        goto CLEANUPANDEXIT;
    }

    dwStatus = GetUserSid( pszUserName, &pUserSid );
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    // Check if SID is one of system account, if so, reject removing it from
    // our winstation security.
    pSystemAcctSid = LocalAlloc( LPTR, SECURITY_MAX_SID_SIZE );
    if( NULL == pSystemAcctSid ) 
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    for( index = 0; index < numRestrictedSid; index++ )
    {
        SidSize = SECURITY_MAX_SID_SIZE;
        if( !CreateWellKnownSid(RestrictedSid[index], NULL, pSystemAcctSid, &SidSize) )
        {
            dwStatus = GetLastError();
            break;
        }

        if( EqualSid(pSystemAcctSid, pUserSid) )
        {
            dwStatus = ERROR_NOT_SUPPORTED;
            break;
        }
    }

    if( index < numRestrictedSid )
    {
        goto CLEANUPANDEXIT;
    }

    // create a big enough buffer
    prgExplicitEntriesNew = ( PEXPLICIT_ACCESS )LocalAlloc( LMEM_FIXED , sizeof( EXPLICIT_ACCESS ) * cbExplicitEntries );
    if( prgExplicitEntriesNew == NULL )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }
                
    for( ULONG idx = 0 ; idx < cbExplicitEntries; idx++ )
    {
        if( prgExplicitEntries[ idx ].Trustee.TrusteeForm == TRUSTEE_IS_SID )
        {
            if( !EqualSid( pUserSid, prgExplicitEntries[ idx ].Trustee.ptstrName ) )
            {
                // this one we can keep
                // copy over EXPLICIT_ACCESS
                prgExplicitEntriesNew[ dwNumNewEntries ].grfAccessPermissions = prgExplicitEntries[ idx ].grfAccessPermissions;
                prgExplicitEntriesNew[ dwNumNewEntries ].grfAccessMode = prgExplicitEntries[ idx ].grfAccessMode;
                prgExplicitEntriesNew[ dwNumNewEntries ].grfInheritance = prgExplicitEntries[ idx ].grfInheritance;

                BuildTrusteeWithSid( &prgExplicitEntriesNew[ dwNumNewEntries ].Trustee , prgExplicitEntries[ idx ].Trustee.ptstrName );
                dwNumNewEntries++;
            }
        }
    }

    if( !InitializeAcl( &emptyACL, sizeof(ACL), ACL_REVISION ) )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    // SetEntriesInAcl() make a copy of old ACL if count of explicit entries is 0, if
    // we passed in NULL in third parameter, it will return NULL ACL which is same as
    // everyone access refer to ds\security\ntmarta\newsrc\seia.cxx 
    // AccRewriteSetEntriesInAcl()
    //
    // Note: Actual bug in 728764 is the way we call BuildSecurityDescriptor() not here.
    dwStatus = SetEntriesInAcl( 
                            dwNumNewEntries,
                            prgExplicitEntriesNew, 
                            &emptyACL, 
                            ppNewAcl 
                        );

CLEANUPANDEXIT:

    if( pSystemAcctSid != NULL )
    {
        LocalFree( pSystemAcctSid );
    }

    if( pUserSid != NULL )
    {
        LocalFree( pUserSid );
    }

    if( prgExplicitEntriesNew != NULL )
    {
        LocalFree( prgExplicitEntriesNew );
    }

    if( NULL != prgExplicitEntries )
    {
        LocalFree( prgExplicitEntries );
    }

    return dwStatus;
}


PSECURITY_DESCRIPTOR
BuildSelfRelativeEmptyDACLSD()
/*++

Routine Description:

    Build a Self-relative security descriptor with empty DACL.

Parameters:

    None.

Return:

    Pointer to SECURITY_DESCRIPTOR contains only empty DACL, no owner, group or
    SACL or NULL if error, use GetLastError() to retrive the actual error code.

--*/
{
    SECURITY_DESCRIPTOR EmptyDACLSD;
    ACL EmptyACL;
    DWORD cbSize = 0;
    PSECURITY_DESCRIPTOR pSelfRelativeEmptySD = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    if( !InitializeSecurityDescriptor( &EmptyDACLSD, SECURITY_DESCRIPTOR_REVISION ) )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }
            
    if( !InitializeAcl( &EmptyACL, sizeof(ACL), ACL_REVISION ) )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    if( !SetSecurityDescriptorDacl( &EmptyDACLSD, TRUE, &EmptyACL, FALSE ) ) 
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    if( !IsValidSecurityDescriptor(&EmptyDACLSD) )
    {
        SetLastError( ERROR_INTERNAL_ERROR );
        dwStatus = ERROR_INTERNAL_ERROR;
        goto CLEANUPANDEXIT;
    }

    if( !MakeSelfRelativeSD( &EmptyDACLSD, NULL, &cbSize ) ) 
    {
        if( cbSize == 0 )
        {
            dwStatus = GetLastError();
            goto CLEANUPANDEXIT;
        }
    }

    pSelfRelativeEmptySD = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cbSize );
    if( NULL == pSelfRelativeEmptySD )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    if( !MakeSelfRelativeSD( &EmptyDACLSD, pSelfRelativeEmptySD, &cbSize ) )
    {
        dwStatus = GetLastError();
    }

CLEANUPANDEXIT:

    if( ERROR_SUCCESS != dwStatus )
    {
        if( pSelfRelativeEmptySD != NULL ) 
        {
            LocalFree(pSelfRelativeEmptySD);
            pSelfRelativeEmptySD = NULL;
        }
    }

    return pSelfRelativeEmptySD;
}    

HRESULT
CCfgComp::ModifyWinstationSecurity(
        BOOL bDefaultSecurity,          
        WCHAR *pwszWinstaName ,
        WCHAR *pwszAccountName ,
        DWORD  dwMask , 
        BOOL   fDel ,       // delete existing ACL entries for user passed in
        BOOL   fAllow ,     // Grant/Deny ACL
        BOOL   fNew ,       // New entries
        BOOL   fAuditing ,
        PDWORD pdwStatus 
        )
/*++

Abstract :

    Modify specific winstation security.

Parameters:

    bDefaultSecurity : TRUE to modify default security, FALSE otherwise.  Current
                       default security are ConsoleSecurity and DefaultSecurity.
    pwszWinstaName : Name of the winstation or default security to be modified, if
                     bDefaultSecurity is TRUE, valid winstation name are ConsoleSecurity 
                     and DefaultSecurity.
    pwszAccountName : is the netbios name of the user we want to modify.
    dwMask          : winstation specific access.
    fDel            : TRUE to delete all DACL or SACL for the specifed 
                      account if it exist, FALSE to add entry.
    fAllow          : TRUE to allow, FALSE to deny, parameter ignored if
                      fDel is set to TRUE
    fNew            : TRUE removes all existing entries for this account
                      FALSE no action taken, parameter ignored if fDel
                      is set to TRUE.
    fAuditing       : TRUE, modify SACL, FALSE modify DACL.
    pdwStatus       : Return status of operation

Returns:

    S_OK, E_FAIL, E_INVALIDARG, win32 status code is returned via *pdwStatus.

Remark:


    fDel    fNew        Operation
    ------- -------     ------------------------------------------
    TRUE    ignored     Delete all entries for the specified user.
    FALSE   TRUE        Delete all entries then add allow or deny
                        entry for the specified user.
    FALSE   FALSE       Add allow or deny entry for the specified user,
                        no modify to existing entries.

--*/
{
    EXPLICIT_ACCESS ea;
    HRESULT hr;
    PACL pNewAcl = NULL;
    PACL pAcl    = NULL;

    BOOL bOwnerDefaulted    = FALSE;
    BOOL bDaclDefaulted     = FALSE;
    BOOL bDaclPresent       = FALSE;
    BOOL bSaclPresent       = FALSE;
    BOOL bSaclDefaulted     = FALSE;

    PSECURITY_DESCRIPTOR pSD;
    LONG lSize = 0;
    DWORD dwSDLen = 0;
    PACL pSacl = NULL;       
    PACL pDacl = NULL;
   
    PSECURITY_DESCRIPTOR pNewSD = NULL;

    if( pwszAccountName == NULL || pdwStatus == NULL )
    {
        ODS( L"CCfgComp::ModifyUserAccess -- invalid arg\n" );

        return E_INVALIDARG;
    }

    *pdwStatus = 0;


    if( TRUE == bDefaultSecurity )
    {
        if( FALSE == ValidDefaultSecurity( pwszWinstaName ) )
        {
            *pdwStatus = ERROR_INVALID_PARAMETER;
            return E_INVALIDARG;
        }
    }
    else if( pwszWinstaName == NULL  )
    {
        *pdwStatus = ERROR_INVALID_PARAMETER;
        return E_INVALIDARG;
    }
    
    hr = GetWinStationSecurity( bDefaultSecurity, pwszWinstaName , &pSD );

    if( SUCCEEDED( hr ) )
    {
        if( pSD != NULL )
        {
            lSize = GetSecurityDescriptorLength(pSD);
        }
        else
        {
            hr = E_FAIL;
            *pdwStatus = ERROR_INTERNAL_ERROR;
        }
    }
    else
    {
        *pdwStatus = ERROR_INTERNAL_ERROR;
        return hr;
    }
    
    if( fAuditing )
    {
        if( pSD != NULL && !GetSecurityDescriptorSacl( pSD ,
                                        &bSaclPresent,
                                        &pAcl,
                                        &bSaclDefaulted ) )
        {
            *pdwStatus = GetLastError( ) ;

            hr = E_FAIL;
        }
    }
    else
    {        
        if( pSD != NULL && !GetSecurityDescriptorDacl( pSD ,
                                        &bDaclPresent,
                                        &pAcl,
                                        &bDaclDefaulted ) )
        {
            *pdwStatus = GetLastError( ) ;

            hr = E_FAIL;
        }
    }

    // remove all entries for this user
    
    if( SUCCEEDED( hr ) )
    {        
        if( fNew || fDel )
        {
            // SetEntriesInAcl() does not remove DENY_ACCESS ACL,
            // pAcl will point to DACL or SACL depends on fAuditing
            // flag.
            *pdwStatus = RemoveUserEntriesInACL(
                                                pwszAccountName,
                                                pAcl,
                                                &pNewAcl
                                            );

            if( *pdwStatus == ERROR_SUCCESS)
            {
                // DO NOTHING.
            }
            else if( *pdwStatus == ERROR_FILE_NOT_FOUND )
            {
                pNewAcl = pAcl;
                *pdwStatus = ERROR_SUCCESS;
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }

    if( SUCCEEDED(hr) && !fDel )
    {
        // auditing is requested build SACL

        if( fAuditing )
        {            

            BuildExplicitAccessWithName( &ea , 
                                         pwszAccountName ,
                                         dwMask ,
                                         fAllow ? SET_AUDIT_SUCCESS : SET_AUDIT_FAILURE ,
                                         NO_INHERITANCE );

            *pdwStatus = SetEntriesInAcl( 1 , &ea , pAcl , &pNewAcl );

            if( *pdwStatus != ERROR_SUCCESS )
            {
                hr = E_FAIL;
            }
        }
        else
        {
            BuildExplicitAccessWithName( &ea , 
                                         pwszAccountName ,
                                         dwMask ,
                                         fAllow ? GRANT_ACCESS : DENY_ACCESS ,
                                         NO_INHERITANCE );

            *pdwStatus = SetEntriesInAcl( 1 , &ea , pAcl , &pNewAcl );

            if( *pdwStatus != ERROR_SUCCESS )
            {
                hr = E_FAIL;
            }
        }
    }

    // re-build SD.

    ULONG cbExplicitEntriesDACL = 0;
    PEXPLICIT_ACCESS prgExplicitEntriesDACL = NULL;
    ULONG cbExplicitEntriesSACL = 0;
    PEXPLICIT_ACCESS prgExplicitEntriesSACL = NULL;


    if( SUCCEEDED( hr ) )
    {
    
        if( fAuditing )
        {

            if( GetExplicitEntriesFromAcl( pNewAcl ,
                                           &cbExplicitEntriesSACL ,
                                           &prgExplicitEntriesSACL ) != ERROR_SUCCESS )
            {
                ODS( L"CFGBKEND! GetExplicitEntriesFromAcl failed\n" );

                *pdwStatus = GetLastError();

                hr = E_FAIL;
            }

            if( !GetSecurityDescriptorDacl( pSD , &bDaclPresent , &pDacl , &bDaclDefaulted ) )
            {
                ODS( L"CFGBKEND! GetSecurityDescriptorDacl failed\n" );

                *pdwStatus = GetLastError();

                hr = E_FAIL;
            }
            else 
            {
                if( GetExplicitEntriesFromAcl( pDacl ,
                                               &cbExplicitEntriesDACL ,
                                               &prgExplicitEntriesDACL ) != ERROR_SUCCESS )
                {
                    ODS( L"CFGBKEND! GetExplicitEntriesFromAcl failed\n" );

                    *pdwStatus = GetLastError();

                    hr = E_FAIL;
                }
            }

        }
        else
        {
            if( GetExplicitEntriesFromAcl( pNewAcl ,
                                           &cbExplicitEntriesDACL ,
                                           &prgExplicitEntriesDACL ) != ERROR_SUCCESS )
            {
                ODS( L"CFGBKEND! GetExplicitEntriesFromAcl failed\n" );

                *pdwStatus = GetLastError();

                hr = E_FAIL;
            }

            if( !GetSecurityDescriptorSacl( pSD , &bSaclPresent , &pSacl , &bSaclDefaulted ) )
            {
                ODS( L"CFGBKEND! GetSecurityDescriptorSacl failed\n" );

                *pdwStatus = GetLastError();

                hr = E_FAIL;
            }
            else
            {                              

                if( GetExplicitEntriesFromAcl( pSacl ,
                                               &cbExplicitEntriesSACL ,
                                               &prgExplicitEntriesSACL ) != ERROR_SUCCESS )
                {
                    ODS( L"CFGBKEND! GetExplicitEntriesFromAcl failed\n" );

                    *pdwStatus = GetLastError();

                    hr = E_FAIL;
                }
            }
        }


        if( SUCCEEDED(hr) )
        {
            TRUSTEE trustmeOwner;
            PSID pOwner;

            if( !GetSecurityDescriptorOwner( pSD , &pOwner , &bOwnerDefaulted ) )
            {
                ODS( L"CFGBKEND! GetSecurityDescriptorOwner failed\n" );

                *pdwStatus = GetLastError();
                hr = E_FAIL;
            }

            if( SUCCEEDED( hr ) )
            {
                PSECURITY_DESCRIPTOR pOldSd = NULL;

                BuildTrusteeWithSid( &trustmeOwner , pOwner );

                if( cbExplicitEntriesDACL == 0 )
                {
                    // refer to MSDN on pOldSd parameter and when it can't/can be NULL
                    // calling SetSecurityDescriptorDacl() with Empty DACL after 
                    // BuildSecurityDescriptor() result in 0x519 error, so go with long
                    // way of creating a self-relatvie SD containing empty DACL.
                    pOldSd = BuildSelfRelativeEmptyDACLSD();
                    if( NULL == pOldSd )
                    {
                        *pdwStatus = GetLastError();
                        hr = HRESULT_FROM_WIN32( *pdwStatus );
                    }
                }
                
                if( SUCCEEDED(hr) )
                {
                    // refer to MSDN on pOldSd parameter and when it can't/can be NULL
                    // calling SetSecurityDescriptorDacl() with Empty DACL after 
                    // BuildSecurityDescriptor() result in 0x519 error, so go with long
                    // way of creating a self-relatvie SD containing empty DACL.
                    *pdwStatus = BuildSecurityDescriptor( &trustmeOwner ,
                                            &trustmeOwner ,
                                            cbExplicitEntriesDACL ,
                                            prgExplicitEntriesDACL,
                                            cbExplicitEntriesSACL,
                                            prgExplicitEntriesSACL,
                                            pOldSd,
                                            &dwSDLen , 
                                            &pNewSD );

                    hr = HRESULT_FROM_WIN32( *pdwStatus );
                }
                
                if( NULL != pOldSd )
                {
                    LocalFree( pOldSd );
                }
            }

            if( SUCCEEDED( hr ) )
            {
                hr = SetSecurityDescriptor( bDefaultSecurity, pwszWinstaName , dwSDLen , pNewSD );
            
                if( pNewSD != NULL )
                {
                    LocalFree( pNewSD );
                }
            }
        }
    }


    if( NULL != prgExplicitEntriesDACL )
    {
        LocalFree( prgExplicitEntriesDACL );
    }

    if( NULL != prgExplicitEntriesSACL )
    {
        LocalFree( prgExplicitEntriesSACL );
    }

    if( pSD != NULL )
    {
        LocalFree( pSD );
    }
        
    //
    // pNewAcl might point to pAcl, check RemoteUserEntriesInAcl() on above.
    //
    if( pNewAcl != NULL && pNewAcl != pAcl )
    {
        LocalFree( pNewAcl );
    }

    return hr;
    
}


/*=----------------------------------------------------------------------------------------------------------------
  GetUserPermList
  [ in ] pwszWinstaName Name of winstation
  [ out] pcbItems       The number of items in the user permission list
  [ out] ppUserPermList structure defined in idldefs.h

 =----------------------------------------------------------------------------------------------------------------*/
STDMETHODIMP CCfgComp::GetUserPermList( WCHAR *pwszWinstaName , PDWORD pcbItems , PUSERPERMLIST *ppUserPermList , BOOL fAudit )
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pSD = NULL;
    BOOL bAclDefaulted;
    BOOL bAclPresent;
    PACL pAcl = NULL;
    LONG lSize;
    ULONG cbExplicitEntries = 0;
    PEXPLICIT_ACCESS prgExplicitEntries = NULL;


    hr = GetSecurityDescriptor( pwszWinstaName , &lSize , &pSD );

    if( SUCCEEDED( hr ) )
    {
        if( fAudit )
        {
            if( !GetSecurityDescriptorSacl( pSD ,
                                            &bAclPresent,
                                            &pAcl,
                                            &bAclDefaulted ) )
            { 
                ODS( L"CFGBKEND!GetUserPermList GetSecurityDescriptorSacl failed\n" );

                hr = E_FAIL;
            }
        }
        else if( !GetSecurityDescriptorDacl( pSD ,
                                             &bAclPresent,
                                             &pAcl,
                                             &bAclDefaulted ) )
        { 
            ODS( L"CFGBKEND!GetUserPermList GetSecurityDescriptorDacl failed\n" );

            hr = E_FAIL;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        if( GetExplicitEntriesFromAcl( pAcl ,
                                       &cbExplicitEntries ,
                                       &prgExplicitEntries ) != ERROR_SUCCESS )
        {
            ODS( L"CFGBKEND!GetUserPermList GetExplicitEntriesFromAcl failed\n" );

            hr = E_FAIL;
        }

        *pcbItems = cbExplicitEntries;
    }

    if( SUCCEEDED( hr ) )
    {
        *ppUserPermList = ( PUSERPERMLIST )CoTaskMemAlloc( sizeof( USERPERMLIST ) * cbExplicitEntries );

        if( *ppUserPermList != NULL )
        {
            for( ULONG i = 0; i < cbExplicitEntries; ++i )
            {
                ( *ppUserPermList )[ i ].Name[ 0 ] = 0;
                ( *ppUserPermList )[ i ].Sid[ 0 ] = 0;

                if( prgExplicitEntries[ i ].Trustee.TrusteeForm == TRUSTEE_IS_SID )
                {
                    WCHAR szDomain[ 120 ];
                    WCHAR szUser[ 128 ];
                    DWORD dwSizeofName = sizeof( szUser  ) / sizeof( WCHAR );
                    DWORD dwSizeofDomain = sizeof( szDomain ) / sizeof( WCHAR );
                    SID_NAME_USE snu;                

                    if( LookupAccountSid( NULL ,
                                          prgExplicitEntries[ i ].Trustee.ptstrName ,
                                          szUser ,
                                          &dwSizeofName ,
                                          szDomain , 
                                          &dwSizeofDomain ,
                                          &snu ) )
                    {
                        if( dwSizeofDomain > 0 )
                        {
                            lstrcpy( ( *ppUserPermList )[ i ].Name , szDomain );
                            lstrcat( ( *ppUserPermList )[ i ].Name , L"\\" );
                        }

                        lstrcat( ( *ppUserPermList )[ i ].Name , szUser );

                        LPTSTR pszSid = NULL;

                        if( ConvertSidToStringSid( prgExplicitEntries[ i ].Trustee.ptstrName , &pszSid ) )
                        {
                            if( pszSid != NULL )
                            {
                                lstrcpyn( ( *ppUserPermList )[ i ].Sid , pszSid , 256 );
                            
                                LocalFree( pszSid );
                            }
                        }
                    }

                }
                else if( prgExplicitEntries[ i ].Trustee.TrusteeForm == TRUSTEE_IS_NAME )
                {
                    lstrcpy( ( *ppUserPermList )[ i ].Name , GetTrusteeName( &prgExplicitEntries[ i ].Trustee ) );

                    // todo reverse lookup for sid
                    // not sure if we'll ever need this
                }
                
                ( *ppUserPermList )[ i ].Mask = prgExplicitEntries[ i ].grfAccessPermissions;

                ( *ppUserPermList )[ i ].Type = prgExplicitEntries[ i ].grfAccessMode;
            }
        }
        else
        {
            ODS( L"CFGBKEND!GetUserPermList no mem for UserPermList\n" );

            hr = E_OUTOFMEMORY;
        }
    }

    if( prgExplicitEntries != NULL )
    {
        LocalFree( prgExplicitEntries );
    }

    if( pSD != NULL )
    {
        LocalFree( pSD );
    }

    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CCfgComp::UpdateSessionDirectory( PDWORD pdwStatus )
{
    HRESULT hr = S_OK;

    if( !_WinStationUpdateSettings( SERVERNAME_CURRENT,
            WINSTACFG_SESSDIR ,
            0 ) )    
    {
        hr = E_FAIL;
    }

    *pdwStatus = GetLastError( );

    return hr;
}
//-----------------------------------------------------------------------------

/*****************************************************************************
 *
 *  TestUserForAdmin
 *
 *   Returns whether the current thread is running under admin
 *   security.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 * alhen
 *
 * Code is from
 *   HOWTO: Determine if Running In User Context of Local Admin Acct
 *          Last reviewed: March 4, 1998
 *          Article ID: Q118626
 *
 * corrected by alhen "common coding errors"
 *
 *
 ****************************************************************************/

BOOL TestUserForAdmin( )
{

    PSID psidAdministrators = NULL;

    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;

    BOOL bSuccess;

        BOOL bIsMember = FALSE;


        bSuccess = AllocateAndInitializeSid( &siaNtAuthority , 2 ,

                                    SECURITY_BUILTIN_DOMAIN_RID,

                                    DOMAIN_ALIAS_RID_ADMINS,

                                    0, 0, 0, 0, 0, 0,

                                    &psidAdministrators );

    if( bSuccess )
        {
                CheckTokenMembership( NULL , psidAdministrators , &bIsMember );

                FreeSid( psidAdministrators );
        }

    return bIsMember;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\cfgcomp\defines.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*********************************************************************************************
*
*
* Module Name: 
*
*			Defines.h
*
* Abstract:
*			This is file with some internal definitions
* 
* Author:
*
* 
* Revision:  
*    
*
************************************************************************************************/


#ifndef _DEFINES_H
#define _DEFINES_H_


#ifdef UNICODE
#define lstr_access _waccess
#else
#define lstr_access _access
#endif

// Flags for EncryptionLevel.Flags
const WORD ELF_DEFAULT  = 0x0001;    // This is the default value

typedef void* PEXTOBJECT;

typedef struct _EncLevel {
    WORD StringID;
    DWORD RegistryValue;    
    WORD Flags;
} EncryptionLevel;

#define REG_DEF_SECURITY                      L"DefaultSecurity"
#define REG_REMOTE_SECURITY                   L"RemoteAdmin"
#define REG_APPL_SECURITY                     L"AppServer"
#define REG_ANON_SECURITY                     L"Anonymous"



typedef void (WINAPI *LPFNEXTSTARTPROC) (WDNAMEW *pWdName);
typedef void (WINAPI *LPFNEXTENDPROC) (void);

typedef LONG (WINAPI *LPFNEXTENCRYPTIONLEVELSPROC) (WDNAMEW *pWdName, EncryptionLevel **);

typedef LONG ( WINAPI *LPFNEXTGETENCRYPTIONLEVELDESCPROC )( int idx , int *pnResid );

typedef void (WINAPI *LPFNEXTDIALOGPROC) (HWND, PEXTOBJECT);
typedef void (WINAPI *LPFNEXTDELETEOBJECTPROC) (PEXTOBJECT);
typedef PEXTOBJECT (WINAPI *LPFNEXTDUPOBJECTPROC) (PEXTOBJECT);
typedef PEXTOBJECT (WINAPI *LPFNEXTREGQUERYPROC) (PWINSTATIONNAMEW, PPDCONFIGW);
typedef LONG (WINAPI *LPFNEXTREGCREATEPROC) (PWINSTATIONNAMEW, PEXTOBJECT, BOOLEAN);
typedef LONG (WINAPI *LPFNEXTREGDELETEPROC) (PWINSTATIONNAMEW, PEXTOBJECT);
typedef BOOL (WINAPI *LPFNEXTCOMPAREOBJECTSPROC) (PEXTOBJECT, PEXTOBJECT);
typedef ULONG (WINAPI *LPFNEXTGETCAPABILITIES) (void);



typedef struct tagWD
{
	WDNAMEW wdName;
	WDNAMEW wdKey;
    WDCONFIG2 wd2;
	HINSTANCE  hExtensionDLL;
    LPFNEXTSTARTPROC lpfnExtStart;    
    LPFNEXTENDPROC lpfnExtEnd;
    LPFNEXTENCRYPTIONLEVELSPROC lpfnExtEncryptionLevels;
    LPFNEXTGETENCRYPTIONLEVELDESCPROC lpfnExtGetEncryptionLevelDescr;
	LPFNEXTDELETEOBJECTPROC lpfnExtDeleteObject;
	LPFNEXTREGQUERYPROC lpfnExtRegQuery;
	LPFNEXTREGCREATEPROC lpfnExtRegCreate;
	LPFNEXTREGDELETEPROC lpfnExtRegDelete;
	LPFNEXTDUPOBJECTPROC lpfnExtDupObject;
    LPFNEXTGETCAPABILITIES lpfnGetCaps;
	// CPtrArray PDNameArray;
    CPtrArray PDConfigArray; // PDCONFIG3W

} WD;


/*typedef struct tagWS
{
	WINSTATIONNAMEW Name;
	PDNAMEW pdName;
	WDNAMEW wdName;
	WCHAR Comment[WINSTATIONCOMMENT_LENGTH + 1];
	ULONG uMaxInstanceCount;
	BOOL fEnableWinstation;
	ULONG LanAdapter;
	SDCLASS SdClass;
} WS;*/


typedef WD * PWD;

static CHAR szStart[] = "ExtStart";
static CHAR szEnd[] = "ExtEnd";
static CHAR szDialog[] = "ExtDialog";
static CHAR szDeleteObject[] = "ExtDeleteObject";
static CHAR szDupObject[] = "ExtDupObject";
static CHAR szRegQuery[] = "ExtRegQuery";
static CHAR szRegCreate[] = "ExtRegCreate";
static CHAR szRegDelete[] = "ExtRegDelete";
static CHAR szCompareObjects[] = "ExtCompareObjects";
static CHAR szEncryptionLevels[] = "ExtEncryptionLevels";
static CHAR szGetCapabilities[] = "ExtGetCapabilities";
static CHAR szGetEncryptionLevelDescr[] = "ExtGetEncryptionLevelDescr";
static CHAR szGetCaps[] = "ExtGetCapabilities";
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\cfgcomp\idldefs.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*********************************************************************************************
*
*
* Module Name: 
*
*			idldefs.h
*
* Abstract:
*			This is file with some definitions.
* 
* Author:Arathi Kundapur. a-akunda
*
* 
* Revision:  
*    
*
************************************************************************************************/

#include<Accctrl.h>
typedef struct _Encyption
{
    TCHAR szLevel[128];   // tscfg uses this 128 value, check if this is the restriction on the size in the ext dll.
    TCHAR szDescr[256];   // new field for description
    DWORD RegistryValue;    
    WORD Flags;
} Encryption;

#define NUM_DEFAULT_SECURITY 3
typedef enum _NameType
{
	WdName,
	WsName
} NameType;


/*typedef struct tagWS
{
	WINSTATIONNAME Name;
	PDNAME pdName;
	WDNAME wdName;
	TCHAR Comment[WINSTATIONCOMMENT_LENGTH+1];
	ULONG uMaxInstanceCount;
	BOOL fEnableWinstation;
	ULONG LanAdapter;
	SDCLASS SdClass;
} WS;*/

/*
typedef enum _UpDateDataType
{
	LANADAPTER,
	ENABLEWINSTATION,
	MAXINSTANCECOUNT,
	COMMENT,
	ALL

} UpDateDataType;


const DWORD UDPATE_LANADAPTER       =   0x00000001;
const DWORD UDPATE_ENABLEWINSTAION  =   0x00000002;
const DWORD UDPATE_MAXINSTANCECOUNT =   0x00000004;
const DWORD UDPATE_COMMENT          =   0x00000008;
*/
typedef struct tagWS
{
	WCHAR Name[32 + 1];   // WINSTATIONNAME_LENGTH
	WCHAR pdName[32 + 1]; // Protocol name PDNAME,PDNAME_LENGTH 
	WCHAR wdName[32 + 1]; // winstation driver NAME, WDNAME_LENGTH
	WCHAR Comment[60 +1]; // WINSTATIONCOMMENT_LENGTH
    WCHAR DeviceName[ 128 + 1 ]; // DEVICENAME_LENGTH
	ULONG uMaxInstanceCount;
	BOOL fEnableWinstation;
	ULONG LanAdapter;
	DWORD PdClass;
    
} WS;

typedef WS * PWS;

typedef struct tagGuidTbl
{
    WCHAR DispName[ 128 ]; // DEVICENAME_LENGTH
    GUID  guidNIC;
    DWORD dwLana;
    DWORD dwStatus;

} GUIDTBL , *PGUIDTBL;

typedef struct tagUserPermList
{
    WCHAR Name[ 256 ];
    WCHAR Sid[ 256 ];
    DWORD Mask;
    ACCESS_MODE Type;

} USERPERMLIST , *PUSERPERMLIST;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\cfgcomp\ptrarray.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*********************************************************************************************
*
*
* Module Name: 
*
*			Ptrarray.cpp
*
* Abstract:
*			This is file has implementation of CPtrArray class borrowed from MFC
* 
* Author:
*
* 
* Revision:  
*    
*
************************************************************************************************/


#include "stdafx.h"
#include "PtrArray.h"
#include <windows.h>
#include <assert.h>


CPtrArray::CPtrArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CPtrArray::~CPtrArray()
{
	delete[] (BYTE*)m_pData;
}

//
// inform user whether or not setsize failed or not
//

BOOL CPtrArray::SetSize(int nNewSize, int nGrowBy)
{   
	assert(nNewSize >= 0);

	if (nGrowBy != -1)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		delete[] (BYTE*)m_pData;
		m_pData = NULL;
		m_nSize = m_nMaxSize = 0;
        
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
#ifdef SIZE_T_MAX
		assert(nNewSize <= SIZE_T_MAX/sizeof(void*));    // no overflow
#endif
		m_pData = (void**) new BYTE[nNewSize * sizeof(void*)];

        if( m_pData != NULL )
        {
            memset(m_pData, 0, nNewSize * sizeof(void*));  // zero fill
            m_nSize = m_nMaxSize = nNewSize;            
        }
        else
        {
            m_nSize = m_nMaxSize = 0;
            return FALSE;
        }

	}
	else if (nNewSize <= m_nMaxSize)
	{
		
		if (nNewSize > m_nSize)
		{
			// initialize the new elements

			memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));

		}

		m_nSize = nNewSize;        
	}
	else
	{
		// otherwise, grow array
		int nGrowBy = m_nGrowBy;
		if (nGrowBy == 0)
		{
			// heuristically determine growth when nGrowBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowBy = min(1024, max(4, m_nSize / 8));
		}
		int nNewMax;
		if (nNewSize < m_nMaxSize + nGrowBy)
			nNewMax = m_nMaxSize + nGrowBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		assert(nNewMax >= m_nMaxSize);  // no wrap around
#ifdef SIZE_T_MAX
		assert(nNewMax <= SIZE_T_MAX/sizeof(void*)); // no overflow
#endif
		void** pNewData = (void**) new BYTE[nNewMax * sizeof(void*)];

		// copy new data from old
        if( pNewData != NULL )
        {
            memcpy(pNewData, m_pData, m_nSize * sizeof(void*));
        
		    // construct remaining elements
		    assert(nNewSize > m_nSize);

		    memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));
        
    		// get rid of old stuff (note: no destructors called)
	    	delete[] (BYTE*)m_pData;
		    m_pData = pNewData;
		    m_nSize = nNewSize;
		    m_nMaxSize = nNewMax;
        }
        else
        {
            return FALSE;
        }
	}

    return TRUE;
    
}

int CPtrArray::Append(const CPtrArray& src)
{
	assert(this != &src);   // cannot append to itself

	int nOldSize = m_nSize;
	
    SetSize(m_nSize + src.m_nSize);

	memcpy(m_pData + nOldSize, src.m_pData, src.m_nSize * sizeof(void*));

	return nOldSize;
}

void CPtrArray::Copy(const CPtrArray& src)
{

	assert(this != &src);   // cannot append to itself

    SetSize( src.m_nSize );

	if( m_pData != NULL )
    {
        memcpy(m_pData, src.m_pData, src.m_nSize * sizeof(void*));
    }

}

void CPtrArray::FreeExtra()
{

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		assert(m_nSize <= SIZE_T_MAX/sizeof(void*)); // no overflow
#endif
		void** pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (void**) new BYTE[m_nSize * sizeof(void*)];
			// copy new data from old
            if( pNewData != NULL )
            {
                memcpy(pNewData, m_pData, m_nSize * sizeof(void*));
            }
            else
            {
                m_nSize = 0;
            }
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

/////////////////////////////////////////////////////////////////////////////

BOOL CPtrArray::SetAtGrow(int nIndex, void* newElement)
{

	assert(nIndex >= 0);

	if (nIndex >= m_nSize)
    {
        if( !SetSize( nIndex+1 ) )        
        {
            return FALSE;
        }
    }
    
    if( m_pData != NULL )
    {
        m_pData[nIndex] = newElement;

        return TRUE;
    }

    return FALSE;
}

BOOL CPtrArray::InsertAt(int nIndex, void* newElement, int nCount)
{

	assert(nIndex >= 0);    // will expand to meet need
	assert(nCount > 0);     // zero or negative size not allowed

	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		if( !SetSize(nIndex + nCount ) )  // grow so nIndex is valid
        {
            return FALSE;
        }
	}
	else
	{
		// inserting in the middle of the array
		int nOldSize = m_nSize;
		
        if( !SetSize(m_nSize + nCount) )  // grow it to new size
        {
            return FALSE;
        }
		
        // shift old data up to fill gap
		memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
			(nOldSize-nIndex) * sizeof(void*));

		// re-init slots we copied from

		memset(&m_pData[nIndex], 0, nCount * sizeof(void*));

	}

	// insert new value in the gap
	assert(nIndex + nCount <= m_nSize);
	while (nCount--)
		m_pData[nIndex++] = newElement;

    return TRUE;
}

void CPtrArray::RemoveAt(int nIndex, int nCount)
{
	assert(nIndex >= 0);
	assert(nCount >= 0);
	assert(nIndex + nCount <= m_nSize);

	// just remove a range
	int nMoveCount = m_nSize - (nIndex + nCount);

	if (nMoveCount)
		memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
			nMoveCount * sizeof(void*));
	m_nSize -= nCount;
}

void CPtrArray::InsertAt(int nStartIndex, CPtrArray* pNewArray)
{
	assert(pNewArray != NULL);
	assert(nStartIndex >= 0);

	if (pNewArray->GetSize() > 0)
	{
		if( InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize()) )
        {
            for (int i = 0; i < pNewArray->GetSize(); i++)
            {
                SetAt(nStartIndex + i, pNewArray->GetAt(i));
            }
        }
	}
}

int CPtrArray::GetSize() const
	{ return m_nSize; }
int CPtrArray::GetUpperBound() const
	{ return m_nSize-1; }
void CPtrArray::RemoveAll()
	{ SetSize(0); }
void* CPtrArray::GetAt(int nIndex) const
	{ assert(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
void CPtrArray::SetAt(int nIndex, void* newElement)
	{ assert(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }
void*& CPtrArray::ElementAt(int nIndex)
	{ assert(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
const void** CPtrArray::GetData() const
	{ return (const void**)m_pData; }
void** CPtrArray::GetData()
	{ return (void**)m_pData; }
BOOL CPtrArray::Add(void* newElement)
{ 
    int nIndex = m_nSize;

    if( !SetAtGrow(nIndex, newElement) )
    {
        return FALSE;
    }

    return TRUE;
 }
void* CPtrArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
void*& CPtrArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\cfgcomp\stdafx.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\cfgcomp\resource.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CfgBkEnd.rc
//
#define IDS_ASYNC_ADVANCED_HWRX_NOTHING 76
#define IDS_ASYNC_ADVANCED_HWRX_TURN_OFF_RTS 77
#define IDS_ASYNC_ADVANCED_HWRX_TURN_OFF_DTR 78
#define IDS_ASYNC_ADVANCED_HWTX_ALWAYS  79
#define IDS_ASYNC_ADVANCED_HWTX_WHEN_CTS_IS_ON 80
#define IDS_ASYNC_ADVANCED_HWTX_WHEN_DSR_IS_ON 81
#define IDS_CONNECT_CTS                 82
#define IDS_CONNECT_DSR                 83
#define IDS_CONNECT_RI                  84
#define IDS_CONNECT_DCD                 85
#define IDS_CONNECT_FIRST_CHARACTER     86
#define IDS_CONNECT_ALWAYS              87
#define IDS_MODEM_CALLBACK_DISABLED     88
#define IDS_MODEM_CALLBACK_ROVING       89
#define IDS_MODEM_CALLBACK_FIXED        90
#define IDS_PROJNAME                    100
#define IDR_CFGCOMP                     101
#define IDS_SYSTEM_CONSOLE_NAME         101
#define IDS_ALL_LAN_ADAPTERS            105
#define IDS_REMOTE_SECURITY             106
#define IDS_APPLICATION_SECURITY        107
#define IDS_ANONYMOUS_SECURITY          108

#define IDS_LICENSING_RA_NAME 1000
#define IDS_LICENSING_RA_DESC 1001
#define IDS_LICENSING_PERSEAT_NAME 1002
#define IDS_LICENSING_PERSEAT_DESC 1003
#define IDS_LICENSING_PERUSER_NAME 1004
#define IDS_LICENSING_PERUSER_DESC 1005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\sdk\lib\lib.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "tswiz_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\sdk\xss\lib\lib.c ===
//Copyright (c) 2000 Microsoft Corporation
#include "SrvSetEx_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\asyncdlg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

#include "stdafx.h"
#include <winsta.h>
#include "resource.h"
#include "asyncdlg.h"
#include <utildll.h>

//Most of the code for this has been borrowed from tscfg.

extern void ErrMessage( HWND hwndOwner , INT_PTR iResourceID );

static int LedIds[NUM_LEDS] =
{
    IDC_ATDLG_DTR,
    IDC_ATDLG_RTS,
    IDC_ATDLG_CTS,
    IDC_ATDLG_DSR,
    IDC_ATDLG_DCD,
    IDC_ATDLG_RI
};

INT_PTR CBInsertInstancedName( LPCTSTR pName , HWND hCombo );

void ParseRootAndInstance( LPCTSTR pString, LPTSTR pRoot, long *pInstance );

//---------------------------------------------------------------------------------------------------
CAsyncDlg::CAsyncDlg( )
{
    m_hDlg = NULL;

    m_pCfgcomp = NULL;

    m_nHexBase = 0;

    m_szWinstation[ 0 ] = 0;

    m_szWDName[ 0 ] = 0;

    ZeroMemory( &m_ac , sizeof( ASYNCCONFIG ) );

    ZeroMemory( &m_uc , sizeof( USERCONFIG ) );

    ZeroMemory( &m_oldAC , sizeof( ASYNCCONFIG ) );

    m_nOldAsyncDeviceNameSelection = ( INT )-1;

    m_nOldAsyncConnectType = ( INT )-1;

    m_nOldBaudRate = ( INT )-1;

    m_nOldModemCallBack = ( INT )-1;
}

//---------------------------------------------------------------------------------------------------
BOOL CAsyncDlg::OnInitDialog( HWND hDlg , LPTSTR szWDName , LPTSTR szWinstationName ,  ICfgComp *pCfgcomp )
{
    TCHAR tchName[ 80 ];

    TCHAR tchErrTitle[ 80 ];

    TCHAR tchErrMsg[ 256 ];

    TCHAR szDecoratedName[ DEVICENAME_LENGTH + MODEMNAME_LENGTH + 1 ];

    ASSERT( pCfgcomp != NULL );

    if( m_pCfgcomp == NULL )
    {
        m_pCfgcomp = pCfgcomp;

        m_pCfgcomp->AddRef( );
    }

    m_hDlg = hDlg;

    m_oldAC = m_ac;    

    if( szWinstationName != NULL )
    {
        lstrcpyn( m_szWinstation , szWinstationName , SIZE_OF_BUFFER( m_szWinstation ) - sizeof( TCHAR ) );
    }

    if( szWDName != NULL )
    {
        lstrcpyn( m_szWDName , szWDName , SIZE_OF_BUFFER( m_szWDName ) - sizeof( TCHAR ) );
    }

    // initialize controls

    int idx = 0;

    HRESULT hr;

    SendMessage( GetDlgItem( hDlg , IDC_ASYNC_CONNECT ) , CB_RESETCONTENT , 0 , 0 );

    while( SUCCEEDED( ( hr = pCfgcomp->GetConnTypeName( idx , tchName ) ) ) )
    {
        if( hr ==  S_FALSE )
        {
            break;
        }

        SendMessage( GetDlgItem( hDlg , IDC_ASYNC_CONNECT ) , CB_ADDSTRING , 0 , ( LPARAM )tchName );

        idx++;
    }

    idx = 0;

    SendMessage( GetDlgItem( hDlg , IDC_ASYNC_MODEMCALLBACK ) , CB_RESETCONTENT , 0 , 0 );

    while( SUCCEEDED( ( hr = pCfgcomp->GetModemCallbackString( idx , tchName ) ) ) )
    {
        if( hr == S_FALSE )
        {
            break;
        }

        SendMessage( GetDlgItem( hDlg , IDC_ASYNC_MODEMCALLBACK ) , CB_ADDSTRING , 0 , ( LPARAM )tchName );

        idx++;
    }

    // fill in device list

    ULONG ulItems = 0;

    LPBYTE pBuffer = NULL;

    HWND hCombo = GetDlgItem( hDlg , IDC_ASYNC_DEVICENAME );

    SendMessage( hCombo , CB_RESETCONTENT , 0 , 0 );

    // szWDname is used for creating a new connection
    // szWinstaionName is used if we're editing an existing connection

    TCHAR *pszName = NULL;

    NameType type = WdName;

    if( szWDName == NULL )
    {
        pszName = szWinstationName;

        type = WsName;
    }
    else
    {
        pszName = szWDName;
    }

    ASSERT( pszName != NULL );

    hr = pCfgcomp->GetDeviceList( pszName , type ,  &ulItems , &pBuffer );

    if( SUCCEEDED(  hr ) )
    {
        PPDPARAMS pPdParams = NULL;

		DBGMSG( L"TSCC : GetDeviceList returned %d devices that are available\n" , ulItems );

        for( idx = 0 , pPdParams = ( PPDPARAMS )pBuffer; idx < ( int )ulItems ; idx++, pPdParams++ )
        {
            // Form decorated name.

#ifdef DBG
			TCHAR temsg[ 128 ];

			wsprintf( temsg , L"TSCC : %d ) %s is a device\n" , idx , pPdParams->Async.DeviceName );

			ODS( temsg );
#endif

            FormDecoratedAsyncDeviceName( szDecoratedName, &( pPdParams->Async ) );

            if( pCfgcomp->IsAsyncDeviceAvailable( pPdParams->Async.DeviceName ) )
            {
                CBInsertInstancedName( szDecoratedName , hCombo );
            }

#if 0 // this block was taken from tscfg and to this date it still does not make any sense

            /*
              Don't add this device to the list if it is already in use by a
              WinStation other than the current one.
             */

              if (FALSE == pCfgcomp->IsAsyncDeviceAvailable(pPdParams->Async.DeviceName))
                  continue;


            // Insert the name into the combo-box if it's not a TAPI modem
            // or it is a TAPI modem that's not being used by RAS and it's
            // port is currently available.

            INT_PTR nRet = SendMessage( hCombo , CB_FINDSTRINGEXACT , ( WPARAM )-1 , ( LPARAM )pPdParams->Async.DeviceName );

            if( !*( pPdParams->Async.ModemName ) || ( /*!pPdParams->Async.Parity &&*/ ( nRet != ( INT_PTR )CB_ERR ) ) )
            {
                CBInsertInstancedName( szDecoratedName , hCombo );
            }
#endif

            // If this device is a modem, make sure that the raw port this
            // device is configured on is not present in the list.  This will
            // also take care of removing the raw port for TAPI modems that are
            // configured for use by RAS, in which case neither the configured.
            // TAPI modem(s) or raw port will be present in the list.

            INT_PTR nRet = SendMessage( hCombo , CB_FINDSTRINGEXACT , ( WPARAM )-1 , ( LPARAM )pPdParams->Async.DeviceName );

            if( *( pPdParams->Async.ModemName ) && ( nRet != CB_ERR ) )
            {
                ODS(L"Deleting item\n");

                SendMessage( hCombo , CB_DELETESTRING ,  ( WPARAM )nRet , 0 );
            }

        }

        LocalFree( pBuffer );


    }

    // Always make sure that the currently configured device is in

    if( m_ac.DeviceName[0] != 0  )
    {
        FormDecoratedAsyncDeviceName( szDecoratedName , &m_ac );

        INT_PTR nRet = SendMessage( hCombo , CB_FINDSTRINGEXACT , ( WPARAM )-1 , ( LPARAM )szDecoratedName );

        if( nRet == CB_ERR )
        {
            nRet = CBInsertInstancedName( szDecoratedName , hCombo );
        }

        SendMessage( hCombo , CB_SETCURSEL , ( WPARAM )nRet , 0 );

        m_nOldAsyncDeviceNameSelection = (int)nRet;

    }
    else
    {
        SendMessage( hCombo , CB_SETCURSEL , ( WPARAM )0, 0 );

        m_nOldAsyncDeviceNameSelection = 0;

    }

    INT_PTR iitem = SendMessage( hCombo , CB_GETCOUNT , ( WPARAM )0 , ( LPARAM )0);
    if(0 == iitem || CB_ERR == iitem)
    {
        LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErrTitle , SIZE_OF_BUFFER( tchErrTitle ) );

        LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_NODEVICES , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) );

        MessageBox( hDlg , tchErrMsg , tchErrTitle , MB_OK | MB_ICONERROR );

        return FALSE;
    }


    // Set the BAUDRATE combo-box selection (in it's edit field) and limit the
    // edit field text.

    TCHAR string[ULONG_DIGIT_MAX];

    wsprintf( string, TEXT("%lu"), m_ac.BaudRate );

    m_nOldBaudRate = ( INT )m_ac.BaudRate;

    HWND hBaud = GetDlgItem( hDlg , IDC_ASYNC_BAUDRATE );

    SendMessage( hBaud , CB_RESETCONTENT , 0 , 0 );

    SetDlgItemText( hDlg , IDC_ASYNC_BAUDRATE , string );

    SendMessage(hBaud , CB_LIMITTEXT , ULONG_DIGIT_MAX - 1 , 0  );


    //The Baud rate field should contain only numbers

    HWND  hEdit = GetWindow(hBaud,GW_CHILD);

    if(hEdit)
    {
        LONG Style = GetWindowLong(hEdit, GWL_STYLE);
        SetWindowLong(hEdit,GWL_STYLE, Style | ES_NUMBER);
    }


    TCHAR TempString[100]; // Number enough to hold the baud rate values


    //Add the default strings to the BaudRate Field

    lstrcpy(TempString, L"9600");

    SendMessage(hBaud , CB_ADDSTRING ,(WPARAM)0 ,(LPARAM)(LPCTSTR)TempString );

    lstrcpy(TempString, L"19200");

    SendMessage(hBaud , CB_ADDSTRING ,(WPARAM)0 ,(LPARAM)(LPCTSTR)TempString );

    lstrcpy(TempString, L"38400");

    SendMessage(hBaud , CB_ADDSTRING ,(WPARAM)0 ,(LPARAM)(LPCTSTR)TempString );

    lstrcpy(TempString, L"57600");

    SendMessage(hBaud , CB_ADDSTRING ,(WPARAM)0 ,(LPARAM)(LPCTSTR)TempString );

    lstrcpy(TempString, L"115200");

    SendMessage(hBaud , CB_ADDSTRING ,(WPARAM)0 ,(LPARAM)(LPCTSTR)TempString );

    lstrcpy(TempString, L"230400");

    SendMessage(hBaud , CB_ADDSTRING ,(WPARAM)0 ,(LPARAM)(LPCTSTR)TempString );


     // Set the CONNECT combo-box selection.

    SendMessage( GetDlgItem( hDlg , IDC_ASYNC_CONNECT ) , CB_SETCURSEL , m_ac.Connect.Type , 0 );

    m_nOldAsyncConnectType = ( INT )m_ac.Connect.Type;

    // CoTaskMemFree( pac );


    HWND hCbxModemCallback = GetDlgItem( hDlg , IDC_ASYNC_MODEMCALLBACK );

    // Set the MODEMCALLBACK combo-box selection, phone number, and 'inherit'
    // checkboxes, based on the current UserConfig settings.

    SendMessage( hCbxModemCallback , CB_SETCURSEL , ( WPARAM )m_uc.Callback , 0 );

    m_nOldModemCallBack = ( INT )m_uc.Callback;

    SetDlgItemText( hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER , m_uc.CallbackNumber );

    CheckDlgButton( hDlg , IDC_ASYNC_MODEMCALLBACK_INHERIT , m_uc.fInheritCallback );

    CheckDlgButton( hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT , m_uc.fInheritCallbackNumber );

    OnSelchangeAsyncDevicename( );

    return TRUE;

}

//---------------------------------------------------------------------------------------------------
BOOL CAsyncDlg::OnSelchangeAsyncModemcallback()
{
    HWND hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK);

    /*
     * Ignore this notification if the combo box is in a dropped-down
     * state.
     */
    if( SendMessage( hCbx , CB_GETDROPPEDSTATE , 0 , 0 ) )
    {
        return FALSE;
    }

    /*
     * Fetch current callback selection.
     */

    INT index = (INT)SendMessage(hCbx,CB_GETCURSEL,0,0);

    if( index != m_nOldModemCallBack )
    {
        m_uc.Callback = (CALLBACKCLASS)index;

        m_nOldModemCallBack = index;

        if( index == 0 ) // disabled
        {
            EnableWindow( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER ) , FALSE );

            //EnableWindow( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT ) , FALSE );
        }
        else
        {
            // inusre that these controls are in the proper state

            OnClickedAsyncModemcallbackPhonenumberInherit();
        }

        return TRUE;
    }

    return FALSE;

}  // end OnSelchangeAsyncModemcallback

//---------------------------------------------------------------------------------------------------
void CAsyncDlg::OnSelchangeAsyncModemcallbackPhoneNumber()
{
    GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER);

    /*
     * Fetch current callback Phone number.
     */
    GetDlgItemText(m_hDlg, IDC_ASYNC_MODEMCALLBACK_PHONENUMBER, m_uc.CallbackNumber,SIZE_OF_BUFFER(m_uc.CallbackNumber));

    return;

}  // end OnSelchangeAsyncModemcallback

//---------------------------------------------------------------------------------------------------
BOOL CAsyncDlg::OnSelchangeAsyncConnect()
{
    HWND hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_CONNECT );

    /*
     * Ignore this notification if the combo box is in a dropped-down
     * state.
     */
    if( SendMessage( hCbx , CB_GETDROPPEDSTATE , 0 , 0 ) )
    {
        return FALSE;
    }

    INT index = ( INT )SendMessage(hCbx,CB_GETCURSEL,0,0);

    if( index != m_nOldAsyncConnectType )
    {
        m_ac.Connect.Type = (ASYNCCONNECTCLASS)index;

        m_nOldAsyncConnectType = index;

        return TRUE;
    }

    return FALSE;
}  // end CAsyncDlg::OnSelchangeAsyncConnect

//---------------------------------------------------------------------------------------------------
BOOL CAsyncDlg::OnSelchangeAsyncBaudrate()
{
    HWND hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_BAUDRATE );

    ODS( L"TSCC : OnSelchangeAsyncBaudrate\n" );

    TCHAR string[ULONG_DIGIT_MAX], *endptr = NULL;

    /*
     * Ignore this notification if the combo box is in a dropped-down
     * state.
     */
    if( SendMessage( hCbx , CB_GETDROPPEDSTATE , 0 , 0 ) )
    {
        return FALSE;
    }

    //GetDlgItemText(m_hDlg, IDC_ASYNC_BAUDRATE, string,ULONG_DIGIT_MAX);
    int idx = ( int )SendMessage( hCbx , CB_GETCURSEL , 0 , 0 );

    SendMessage( hCbx , CB_GETLBTEXT , ( WPARAM )idx , ( LPARAM )&string[ 0 ] );

    INT nBaudRate = ( INT )wcstoul(string, &endptr, 10);

    if( m_nOldBaudRate != nBaudRate )
    {
        m_ac.BaudRate = nBaudRate;

        m_nOldBaudRate = nBaudRate;

        return TRUE;
    }

    return FALSE;

}  // end CAsyncDlg::OnSelchangeAsyncBaudrate

//---------------------------------------------------------------------------------------------------
void CAsyncDlg::OnClickedModemProperties()
{
    if ( !ConfigureModem( m_ac.ModemName, m_hDlg) )
    {
        ErrMessage(m_hDlg,IDP_ERROR_MODEM_PROPERTIES_NOT_AVAILABLE);
    }
    return;

}

//---------------------------------------------------------------------------------------------------
BOOL CAsyncDlg::OnSelchangeAsyncDevicename( )
{
    HWND hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_DEVICENAME );

    BOOL bModemEnableFlag, bDirectEnableFlag;

    INT_PTR index;

    int nModemCmdShow, nDirectCmdShow;

    // Ignore this notification if the combo box is in a dropped-down state.

    if( SendMessage( hCbx , CB_GETDROPPEDSTATE , 0 , 0 ) )
    {
        return TRUE;
    }

    if( ( index = SendMessage( hCbx , CB_GETCURSEL , 0 , 0 ) ) != CB_ERR )
    {

        if( m_nOldAsyncDeviceNameSelection != index )
        {
            TCHAR szDeviceName[DEVICENAME_LENGTH+MODEMNAME_LENGTH+1];

            // Fetch current selection and parse into device and modem names.
            
            TCHAR tchErrMsg[ 512 ];

            TCHAR tchbuf[ 356 ];

            TCHAR tchErrTitle[ 80 ];

            LONG lCount = 0;            

            if( m_pCfgcomp != NULL )
            {
                m_pCfgcomp->QueryLoggedOnCount( m_szWinstation , &lCount );               

                if( lCount > 0 )
                {
                    if( *m_ac.ModemName != 0 )
                    {
                        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_CHANGE_ASYNC , tchbuf , SIZE_OF_BUFFER( tchbuf ) ) );
                    }
                    else
                    {
                        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_CHANGE_MODEM , tchbuf , SIZE_OF_BUFFER( tchbuf ) ) );
                    }

                    wsprintf( tchErrMsg , tchbuf , m_szWinstation );
                    
                    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchErrTitle , SIZE_OF_BUFFER( tchErrTitle ) ) );

                    if( MessageBox( m_hDlg , tchErrMsg , tchErrTitle , MB_YESNO | MB_ICONEXCLAMATION ) == IDNO )
                    {
                        SendMessage( hCbx , CB_SETCURSEL , ( WPARAM )m_nOldAsyncDeviceNameSelection , 0 );

                        return FALSE;

                    }
                }
            }


            SendMessage( hCbx , CB_GETLBTEXT , ( WPARAM )index , ( LPARAM )&szDeviceName[0] );

            ParseDecoratedAsyncDeviceName( szDeviceName , &m_ac );

            m_nOldAsyncDeviceNameSelection = (INT)index;
        }
        else
        {
            return FALSE;
        }

    }


    /*
     * The SetDefaults, Advanced, and Test buttons and Device Connect
     * and Baud fields are enabled if the configuration is non-modem.
     * Otherwise, the Configure Modem button and modem callback fields
     * are enabled.  (The Install Modems buttons is always enabled).
     */
    if( ( *m_ac.ModemName != 0 ) )
    {

        bModemEnableFlag = TRUE;
        nModemCmdShow = SW_SHOW;
        bDirectEnableFlag = FALSE;
        nDirectCmdShow = SW_HIDE;

    } else {

        bModemEnableFlag = FALSE;
        nModemCmdShow = SW_HIDE;
        bDirectEnableFlag = TRUE;
        nDirectCmdShow = SW_SHOW;

    }

    ShowWindow( GetDlgItem( m_hDlg, IDL_ASYNC_MODEMCALLBACK) , nModemCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDL_ASYNC_MODEMCALLBACK ) , bModemEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_MODEM_PROP_PROP) , nModemCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_MODEM_PROP_PROP ) , bModemEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_MODEM_PROP_WIZ) , nModemCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_MODEM_PROP_WIZ ) , bModemEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDL_ASYNC_MODEMCALLBACK1 ) , nModemCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDL_ASYNC_MODEMCALLBACK1 ) , bModemEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_ASYNC_MODEMCALLBACK ) , nModemCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_ASYNC_MODEMCALLBACK ) , bModemEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_ASYNC_MODEMCALLBACK_INHERIT ) , nModemCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_ASYNC_MODEMCALLBACK_INHERIT ) , bModemEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDL_ASYNC_MODEMCALLBACK_PHONENUMBER ) , nModemCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDL_ASYNC_MODEMCALLBACK_PHONENUMBER ) , bModemEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_ASYNC_MODEMCALLBACK_PHONENUMBER ) , nModemCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_ASYNC_MODEMCALLBACK_PHONENUMBER ) , bModemEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT ) , nModemCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT ) , bModemEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDL_ASYNC_CONNECT ) , nDirectCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDL_ASYNC_CONNECT ) , bDirectEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_ASYNC_CONNECT ) , nDirectCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_ASYNC_CONNECT ) , bDirectEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDL_ASYNC_BAUDRATE ) , nDirectCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDL_ASYNC_BAUDRATE ) , bDirectEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_ASYNC_BAUDRATE ) , nDirectCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_ASYNC_BAUDRATE ) , bDirectEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_ASYNC_DEFAULTS ) , nDirectCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_ASYNC_DEFAULTS ) , bDirectEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_ASYNC_ADVANCED ) , nDirectCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_ASYNC_ADVANCED ) , bDirectEnableFlag );

    ShowWindow( GetDlgItem( m_hDlg, IDC_ASYNC_TEST ) , nDirectCmdShow );

    EnableWindow( GetDlgItem( m_hDlg, IDC_ASYNC_TEST ) , bDirectEnableFlag );



    // If this is a modem device, properly set the callback fields.

    if( ( *m_ac.ModemName != 0 ) )
    {
        OnClickedAsyncModemcallbackInherit( );

        OnClickedAsyncModemcallbackPhonenumberInherit( );
    }

    return TRUE;
}

//---------------------------------------------------------------------------------------------------
void CAsyncDlg::OnClickedAsyncModemcallbackInherit( )
{
    BOOL bChecked = ( BOOL )SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_INHERIT ) , BM_GETCHECK , 0 , 0 );

    BOOL bEnable = !bChecked;

    m_uc.fInheritCallback = bChecked;

    EnableWindow( GetDlgItem( m_hDlg , IDL_ASYNC_MODEMCALLBACK1 ) , bEnable );

    EnableWindow( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK ) , bEnable );

    // now check to see if we need to enable the modem callback number

    if( bChecked )
    {
        if( SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK) , CB_GETCURSEL , 0 , 0 ) == 0 )
        {
            if( !( BOOL )SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT ) , BM_GETCHECK , 0 , 0 ) )
            {
                EnableWindow( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER ) , TRUE );

                // EnableWindow( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT ) , TRUE );
            }
        }
    }
    else
    {
        if( (INT)SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK) , CB_GETCURSEL , 0 , 0 ) == 0 )
        {
            if( !( BOOL )SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT ) , BM_GETCHECK , 0 , 0 ) )
            {
                EnableWindow( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER ) , FALSE );

                // EnableWindow( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT ) , FALSE );
            }
        }
    }

    return;
}


//---------------------------------------------------------------------------------------------------
void CAsyncDlg::OnClickedAsyncModemcallbackPhonenumberInherit( )
{
    BOOL bChecked = ( BOOL )SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT ) , BM_GETCHECK , 0 , 0 );

    BOOL bEnable = !bChecked;

    m_uc.fInheritCallbackNumber = bChecked;

    if( !bChecked )
    {
        if( !( BOOL )SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_INHERIT ) , BM_GETCHECK , 0 , 0 ) )
        {
            if( SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK) , CB_GETCURSEL , 0 , 0 ) == 0 )
            {
                EnableWindow( GetDlgItem( m_hDlg , IDL_ASYNC_MODEMCALLBACK_PHONENUMBER ) , FALSE );

                EnableWindow( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER ) , FALSE );

                return;
            }
        }
    }

    EnableWindow( GetDlgItem( m_hDlg , IDL_ASYNC_MODEMCALLBACK_PHONENUMBER ) , bEnable );

    EnableWindow( GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER ) , bEnable );

    return;
}

//---------------------------------------------------------------------------------------------------
BOOL CAsyncDlg::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl , PBOOL pfPersisted )
{
    UNREFERENCED_PARAMETER( hwndCtrl );

    if( wNotifyCode == BN_CLICKED )
    {
        if( wID == IDC_ASYNC_DEFAULTS )
        {
            if( SetDefaults( ) == S_OK )
            {
                *pfPersisted = FALSE;
            }
        }
        else if( wID == IDC_ASYNC_ADVANCED )
        {
            if( DoAsyncAdvance( ) == S_OK )
            {
                *pfPersisted = FALSE;
            }

        }
        else if( wID == IDC_ASYNC_TEST )
        {
            DoAsyncTest( );
        }
        else if( wID == IDC_ASYNC_MODEMCALLBACK_INHERIT )
        {
            OnClickedAsyncModemcallbackInherit();

            *pfPersisted = FALSE;
        }
        else if( wID == IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT )
        {
            OnClickedAsyncModemcallbackPhonenumberInherit();

            *pfPersisted = FALSE;
        }
        else if(wID == IDC_MODEM_PROP_PROP || wID == IDC_MODEM_PROP_WIZ)
        {
            OnClickedModemProperties();
        }

    }
    else if( wNotifyCode == CBN_SELCHANGE )
    {
        if(wID == IDC_ASYNC_DEVICENAME)
        {
            if( OnSelchangeAsyncDevicename( ) )
            {
                *pfPersisted = FALSE;
            }

        }
        else if(wID == IDC_ASYNC_CONNECT)
        {
            if( OnSelchangeAsyncConnect() )
            {
                *pfPersisted = FALSE;
            }
        }
        else if(wID == IDC_ASYNC_BAUDRATE)
        {
            if( OnSelchangeAsyncBaudrate() )
            {
                *pfPersisted = FALSE;
            }
        }
        else if(wID == IDC_ASYNC_MODEMCALLBACK)
        {
            if( OnSelchangeAsyncModemcallback() )
            {
                *pfPersisted = FALSE;
            }
        }

    }
    /*else if( wNotifyCode == CBN_KILLFOCUS)
    {
        if(wID == IDC_ASYNC_BAUDRATE)
        {
            OnSelchangeAsyncBaudrate();
        }

    }*/
    else if(wNotifyCode == EN_CHANGE )
    {
        if(wID == IDC_ASYNC_MODEMCALLBACK_PHONENUMBER)
        {
            OnSelchangeAsyncModemcallbackPhoneNumber();

            *pfPersisted = FALSE;
        }

    }


    return TRUE;

}

//---------------------------------------------------------------------------------------------------
BOOL CAsyncDlg::AsyncRelease( )
{
    if( m_pCfgcomp != NULL )
    {
        m_pCfgcomp->Release( );
    }

    return TRUE;
}

//---------------------------------------------------------------------------------------------------
HRESULT CAsyncDlg::SetAsyncFields(ASYNCCONFIG& AsyncConfig , PUSERCONFIG pUc)
{
    HRESULT hres = S_OK;

    if( pUc == NULL )
    {
        return E_INVALIDARG;
    }

    // check for variation

    lstrcpy( AsyncConfig.DeviceName , m_ac.DeviceName );

    if( memcmp( ( PVOID )&AsyncConfig , ( PVOID )&m_ac , sizeof( ASYNCCONFIG ) ) == 0 )
    {
        if( memcmp( pUc->CallbackNumber , m_uc.CallbackNumber , sizeof( m_uc.CallbackNumber ) ) == 0 &&

            pUc->fInheritCallback == m_uc.fInheritCallback &&

            pUc->fInheritCallbackNumber == m_uc.fInheritCallbackNumber )

        {
            return S_FALSE;
        }
    }


    BOOL bSelectDefault = !( *AsyncConfig.DeviceName);

    HWND hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_DEVICENAME );

    HWND hCbxCallback = GetDlgItem( m_hDlg , IDC_ASYNC_MODEMCALLBACK );

    TCHAR szDeviceName[DEVICENAME_LENGTH+MODEMNAME_LENGTH+1];

    /*
     * Set the DEVICE combo-box selection from the current selection.
     */
    FormDecoratedAsyncDeviceName( szDeviceName, &AsyncConfig );


    if( SendMessage( hCbx , CB_SELECTSTRING , ( WPARAM )-1 , ( LPARAM )szDeviceName ) == CB_ERR )
    {
        /*
         * Can't select current async DeviceName in combo-box.  If this is
         * because we're supposed to select a default device name, select
         * the first device in the list.
         */
        if( bSelectDefault )
        {
            SendMessage( hCbx , CB_SETCURSEL , 0 , 0 );
        }
        else
        {
            hres = E_FAIL;
        }
    }

    /*
     * Set the MODEMCALLBACK combo-box selection, phone number, and 'inherit'
     * checkboxes, based on the current UserConfig settings.
     */
    SendMessage( hCbxCallback , CB_SETCURSEL , m_uc.Callback , 0 );

    SetDlgItemText( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER, m_uc.CallbackNumber );

    CheckDlgButton( m_hDlg , IDC_ASYNC_MODEMCALLBACK_INHERIT , m_uc.fInheritCallback );

    CheckDlgButton( m_hDlg , IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT , m_uc.fInheritCallbackNumber );

    /*
     * Set the BAUDRATE combo-box selection (in it's edit field) and limit the
     * edit field text.
     */

    TCHAR string[ULONG_DIGIT_MAX];

    wsprintf( string, TEXT("%lu"), AsyncConfig.BaudRate );

    SetDlgItemText( m_hDlg , IDC_ASYNC_BAUDRATE, string );

    SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_BAUDRATE ) , CB_LIMITTEXT ,  ULONG_DIGIT_MAX-1  , 0);

    HWND  hEdit = GetWindow(GetDlgItem( m_hDlg , IDC_ASYNC_BAUDRATE ),GW_CHILD);

    if(hEdit)
    {
        LONG Style = GetWindowLong(hEdit, GWL_STYLE);
        SetWindowLong(hEdit,GWL_STYLE, Style | ES_NUMBER);
    }

    /*
     * Set the CONNECT combo-box selection.
     */

    SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_CONNECT) , CB_SETCURSEL , AsyncConfig.Connect.Type , 0 );

    // copy over default values

    CopyMemory( ( PVOID )&m_ac , ( PVOID )&AsyncConfig , sizeof( ASYNCCONFIGW ) );

    return hres;

}

//---------------------------------------------------------------------------------------------------
BOOL CAsyncDlg::GetAsyncFields(ASYNCCONFIG& AsyncConfig, USERCONFIG UsrCfg)
{
    /*
     * Fetch the currently selected DEVICENAME string.
     */
    HWND hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_DEVICENAME );

    ASSERT( hCbx != NULL );

    if( !SendMessage( hCbx , CB_GETCOUNT , 0 , 0 ) || SendMessage( hCbx , CB_GETCURSEL , 0 , 0 ) == CB_ERR )
    {
        ErrMessage( m_hDlg , IDS_INVALID_DEVICE );

        return FALSE;
    }

    /*
     * Get the MODEMCALLBACK phone number (callback state and 'user specified'
     * flags are already gotten).
     */

    GetDlgItemText(m_hDlg,IDC_ASYNC_MODEMCALLBACK_PHONENUMBER,
                    UsrCfg.CallbackNumber,
                    SIZE_OF_BUFFER(UsrCfg.CallbackNumber) );

    /*
     * Fetch and convert the BAUDRATE combo-box selection (in it's edit field).
     */
    {
        TCHAR string[ULONG_DIGIT_MAX], *endptr;
        ULONG ul;

        GetDlgItemText(m_hDlg,IDC_ASYNC_BAUDRATE, string, ULONG_DIGIT_MAX);
        ul = wcstoul( string, &endptr, 10 );

        if ( *endptr != TEXT('\0') )
        {

            /*
             * Invalid character in Baud Rate field.
             */
            ErrMessage( m_hDlg , IDS_INVALID_DEVICE );

            return FALSE;

        }
        else
        {
            AsyncConfig.BaudRate = ul;
        }
    }

    /*
     * Fetch the CONNECT combo-box selection and set/reset the break
     * disconnect flag.
     */

    AsyncConfig.Connect.Type = (ASYNCCONNECTCLASS)SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_CONNECT ) , CB_GETCURSEL , 0 , 0 );
    if(AsyncConfig.Connect.Type == Connect_FirstChar)
    {
        AsyncConfig.Connect.fEnableBreakDisconnect = 1;
    }
    else
    {
        AsyncConfig.Connect.fEnableBreakDisconnect = 0;
    }

    return(TRUE);

}  // end CAsyncDlg::GetAsyncFields

//---------------------------------------------------------------------------------------------------
// returns  E_FAIL  for general error
//          S_OK    for default values saved
//          S_FALSE for default values have not been changed
//---------------------------------------------------------------------------------------------------
HRESULT CAsyncDlg::SetDefaults()
{
    ASYNCCONFIG AsyncConfig;

    PUSERCONFIG pUserConfig = NULL;

    HRESULT hResult;

    hResult = m_pCfgcomp->GetAsyncConfig(m_szWDName,WdName,&AsyncConfig);

    if( SUCCEEDED( hResult ) )
    {
        LONG lsz;

        hResult = m_pCfgcomp->GetUserConfig( m_szWinstation , &lsz , &pUserConfig, TRUE );
    }

    if( SUCCEEDED( hResult ) )
    {
        hResult = SetAsyncFields( AsyncConfig , pUserConfig );
    }

    if( pUserConfig != NULL )
    {
        CoTaskMemFree( pUserConfig );

    }

    return hResult;

}

//---------------------------------------------------------------------------------------------------
HRESULT CAsyncDlg::DoAsyncAdvance( )
{
     CAdvancedAsyncDlg AADlg;

     //Initialize the dialog's member variables.

     AADlg.m_Async = m_ac;

     AADlg.m_bReadOnly =  FALSE;

     AADlg.m_bModem = FALSE;

     AADlg.m_nHexBase = m_nHexBase;

     PWS pWs = NULL;

     LONG lSize = 0;

     if( m_szWDName[ 0 ] != 0 )
     {
         ODS( L"CAsyncDlg::DoAsyncAdvance m_pCfgcomp->GetWdType\n" );

         VERIFY_S( S_OK , m_pCfgcomp->GetWdType( m_szWDName , ( ULONG *)&AADlg.m_nWdFlag ) );
     }
     else if( SUCCEEDED( m_pCfgcomp->GetWSInfo( m_szWinstation , &lSize , &pWs ) ) )
     {
         ODS( L"CAsyncDlg::DoAsyncAdvance with m_szWinstation -- m_pCfgcomp->GetWdType\n" );

         VERIFY_S( S_OK , m_pCfgcomp->GetWdType( pWs->wdName , ( ULONG *)&AADlg.m_nWdFlag ) ) ;

         CoTaskMemFree( pWs );
     }

     AADlg.m_pCfgcomp = m_pCfgcomp; // addref here

     // Invoke dialog

     INT_PTR nRet = ::DialogBoxParam( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDD_ASYNC_ADVANCED ) , m_hDlg , CAdvancedAsyncDlg::DlgProc  , ( LPARAM )&AADlg );

     if( nRet == IDOK )
     {
         // Fetch the dialog's member variables.

         if( memcmp( ( PVOID )&m_ac ,( PVOID )&AADlg.m_Async , sizeof( ASYNCCONFIG ) ) != 0 )
         {
             m_ac = AADlg.m_Async;

             m_nHexBase = AADlg.m_nHexBase;

             return S_OK;
         }
     }

     return S_FALSE;
}

//---------------------------------------------------------------------------------------------------
BOOL CAsyncDlg::DoAsyncTest( )
{
    CAsyncTestDlg ATDlg( m_pCfgcomp );

    // WINSTATIONCONFIG2W wsconfig;

    HWND hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_DEVICENAME );

    ASSERT( hCbx != NULL );

    if( !SendMessage( hCbx , CB_GETCOUNT , 0 , 0 ) || SendMessage( hCbx , CB_GETCURSEL , 0 , 0 ) == CB_ERR )
    {
        ErrMessage( m_hDlg , IDS_INVALID_DEVICE );

        return FALSE;
    }

    ATDlg.m_ac = m_ac;

    ATDlg.m_pWSName = m_szWinstation;

    // Invoke the dialog.

    INT_PTR nRet = ::DialogBoxParam( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDD_ASYNC_TEST ) , m_hDlg , CAsyncTestDlg::DlgProc  , ( LPARAM )&ATDlg);

    if( nRet == IDOK )
    {
        m_ac = ATDlg.m_ac;
    }

    return TRUE;
}

//*******************************************************************************
//
// Help functions from Citrix
//
/*******************************************************************************
 *
 *  CBInsertInstancedName - helper function
 *
 *      Insert the specified 'instanced' name into the specified combo box,
 *      using a special sort based on the 'root' name and 'instance' count.
 *
 *  ENTRY:
 *      pName (input)
 *          Pointer to name string to insert.
 *      pComboBox (input)
 *          Pointer to CComboBox object to insert name string into.
 *
 *  EXIT:
 *      (int) Combo box list index of name after insertion, or error code.
 *
 ******************************************************************************/

INT_PTR CBInsertInstancedName( LPCTSTR pName, HWND hCombo )
{
    INT_PTR i, count, result;

    TCHAR NameRoot[64], ListRoot[64];

    if( pName == NULL || *pName == 0 )
    {
        ODS( L"TSCC: Invalid Arg @ CBInsertInstancedName\n" );
        return -1;
    }

    LPTSTR ListString = NULL;

    long NameInstance, ListInstance;

    /*
     * Form the root and instance for this name
     */
    ParseRootAndInstance( pName, NameRoot, &NameInstance );

    /*
     * Traverse combo box to perform insert.
     */
    for ( i = 0, count = SendMessage( hCombo , CB_GETCOUNT , 0 , 0 ); i < count; i++ ) {

        /*
         * Fetch current combo (list) box string.
         */
        if( ListString != NULL )
        {
            SendMessage( hCombo , CB_GETLBTEXT , ( WPARAM )i , ( LPARAM )ListString );
        }


        /*
         * Parse the root and instance of the list box string.
         */
        ParseRootAndInstance( ListString, ListRoot, &ListInstance );

        /*
         * If the list box string's root is greater than the our name string's
         * root, or the root strings are the same but the list instance is
         * greater than the name string's instance, or the root strings are
         * the same and the instances are the same but the entire list string
         * is greater than the entire name string, the name string belongs
         * at the current list position: insert it there.
         */

        if ( ((result = lstrcmpi( ListRoot, NameRoot )) > 0) ||
             ((result == 0) &&
              (ListInstance > NameInstance)) ||
             ((result == 0) &&
              (ListInstance == NameInstance) &&
              ( ListString != NULL && lstrcmpi(ListString, pName) > 0) ) )
        {
            return SendMessage( hCombo , CB_INSERTSTRING , ( WPARAM )i , ( LPARAM )pName );
        }
    }

    /*
     * Insert this name at the end of the list.
     */
    return SendMessage( hCombo , CB_INSERTSTRING , ( WPARAM )-1 , ( LPARAM )pName );

}  // end CBInsertInstancedName


/*******************************************************************************
 *
 *  ParseRootAndInstance - helper function
 *
 *      Parse the 'root' string and instance count for a specified string.
 *
 *  ENTRY:
 *      pString (input)
 *          Points to the string to parse.
 *      pRoot (output)
 *          Points to the buffer to store the parsed 'root' string.
 *      pInstance (output)
 *          Points to the int variable to store the parsed instance count.
 *
 *  EXIT:
 *      ParseRootAndInstance will parse only up to the first blank character
 *      of the string (if a blank exists).
 *      If the string contains no 'instance' count (no trailing digits), the
 *      pInstance variable will contain -1.  If the string consists entirely
 *      of digits, the pInstance variable will contain the conversion of those
 *      digits and pRoot will contain a null string.
 *
 ******************************************************************************/

void
ParseRootAndInstance( LPCTSTR pString,
                      LPTSTR pRoot,
                      long *pInstance )
{
    LPCTSTR end, p;
    TCHAR szString[256];

    if( pString == NULL || pString[ 0 ] == 0 )
    {
        ODS( L"TSCC: Invalid arg @ ParseRootAndInstance\n" );

        return;
    }

    /*
     * Make a copy of the string and terminate at first blank (if present).
     */
    lstrcpyn(szString, pString, SIZE_OF_BUFFER( szString ) );

    // szString[ lstrlen(szString) - 1 ] = TEXT('\0');

    TCHAR *pTemp = szString;

    while( *pTemp && *pTemp != L' ' )
    {
        pTemp++;
    }


    p = &(pTemp[lstrlen(pTemp)-1]);

    /*
     * Parse the instance portion of the string.
     */
    end = p;

    while( (p >= pTemp) && !IsCharAlpha(*p) )
        p--;

    if ( p == end ) {

        /*
         * No trailing digits: indicate no 'instance' and make the 'root'
         * the whole string.
         */
        *pInstance = -1;
        lstrcpy( pRoot, pTemp );

    } else {

        /*
         * Trailing digits found (or entire string was digits): calculate
         * 'instance' and copy the 'root' string (null if all digits).
         */
        end = p;
        *pInstance = (int)_tcstol( p+1, NULL, 10 );

        /*
         * Copy 'root' string.
         */
        for ( p = szString; p <= end; pRoot++, p++ )
            *pRoot = *p;

        /*
         * Terminate 'root' string.
         */
        *pRoot = TEXT('\0');
    }

}  // end ParseRootAndInstance



////////////////////////////////////////////////////////////////////////////////
CAdvancedAsyncDlg::CAdvancedAsyncDlg()
{
    m_hDlg = NULL;

}  // end CAdvancedAsyncDlg::CAdvancedAsyncDlg

//---------------------------------------------------------------------------------------------------
BOOL CAdvancedAsyncDlg::HandleEnterEscKey(int nID)
{
    /*
     * Check HW Flow Receive and Transmit combo boxes.
     */
    HWND hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_HWRX );

    ASSERT( hCbx != NULL );

    if( SendMessage( hCbx , CB_GETDROPPEDSTATE , 0 , 0 ) )
    {
        if( nID == IDCANCEL )
        {
            // select original selection

            SendMessage( hCbx , CB_SETCURSEL , ( WPARAM )m_Async.FlowControl.HardwareReceive , 0 );
        }

        SendMessage( hCbx , CB_SHOWDROPDOWN , ( WPARAM )FALSE , 0 );

        return FALSE;
    }

    hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_HWTX );

    ASSERT( hCbx != NULL );

    if( SendMessage( hCbx , CB_GETDROPPEDSTATE , 0 , 0 ) )
    {
        if( nID == IDCANCEL )
        {
            // select original selection

            SendMessage( hCbx , CB_SETCURSEL , ( WPARAM )m_Async.FlowControl.HardwareTransmit , 0 );

        }

        SendMessage( hCbx , CB_SHOWDROPDOWN , ( WPARAM )FALSE , 0 );

        return FALSE;
    }

    /*
     * No combo boxes are down; process Enter/Esc.
     */

    return TRUE;

}  // end CAdvancedAsyncDlg::HandleEnterEscKey

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::SetFields()
{
    int nId = 0;

    /*
     * Set the FLOWCONTROL radio buttons.
     */
    switch( m_Async.FlowControl.Type ) {

        case FlowControl_None:
            nId = IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE;
            break;

        case FlowControl_Hardware:
            nId = IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE;
            break;

        case FlowControl_Software:
            nId = IDC_ASYNC_ADVANCED_FLOWCONTROL_SOFTWARE;
            break;
    }

    CheckRadioButton( m_hDlg ,
                      IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE,
                      IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE,
                      nId );

    /*
     * Set the text of the Hardware flowcontrol button.
     */
    SetHWFlowText();


    /*
     * If a modem is defined, disable the Flow Control fields, since they cannot
     * be modified (must match modem's flow control established in Modem dialog).
     */
    if( m_bModem )
    {
        for ( nId = IDL_ASYNC_ADVANCED_FLOWCONTROL; nId <= IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE; nId++ )
        {
            EnableWindow( GetDlgItem( m_hDlg , nId ) ,  FALSE);
        }
    }

    /*
     * Call member functions to set the Global, Hardware, and Software fields.
     */
    SetGlobalFields();
    SetHWFields();
    SetSWFields();

}  // end CAdvancedAsyncDlg::SetFields

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::SetHWFlowText( )
{
    TCHAR tchStr[ 256 ];

    LoadString( _Module.GetResourceInstance( ) , IDS_HARDWARE , tchStr , SIZE_OF_BUFFER( tchStr ) );       

    switch ( m_Async.FlowControl.HardwareReceive )
    {

        case ReceiveFlowControl_None:

            lstrcat( tchStr , TEXT(" (.../") );

            break;

        case ReceiveFlowControl_RTS:

            lstrcat( tchStr , TEXT(" (RTS/") );

            break;

        case ReceiveFlowControl_DTR:

            lstrcat( tchStr , TEXT(" (DTR/") ) ;

            break;
    }

    switch ( m_Async.FlowControl.HardwareTransmit )
    {
        case TransmitFlowControl_None:

            lstrcat( tchStr , TEXT("...)" ) );

            break;

        case TransmitFlowControl_CTS:

            lstrcat( tchStr , TEXT("CTS)") );

            break;

        case TransmitFlowControl_DSR:

            lstrcat( tchStr ,  TEXT("DSR)") );

            break;
    }

    SetDlgItemText( m_hDlg , IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE , tchStr );

}  // end CAdvancedAsyncDlg::SetHWFlowText

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::SetGlobalFields()
{
    /*
     * Select proper DTR radio button.
     */
    CheckRadioButton( m_hDlg , IDC_ASYNC_ADVANCED_DTROFF, IDC_ASYNC_ADVANCED_DTRON,
                      IDC_ASYNC_ADVANCED_DTROFF +
                      (int)m_Async.FlowControl.fEnableDTR );

    /*
     * Select proper RTS radio button.
     */
    CheckRadioButton( m_hDlg , IDC_ASYNC_ADVANCED_RTSOFF, IDC_ASYNC_ADVANCED_RTSON,
                      IDC_ASYNC_ADVANCED_RTSOFF +
                      (int)m_Async.FlowControl.fEnableRTS );

    /*
     * Set the PARITY radio buttons.
     */
    CheckRadioButton( m_hDlg , IDC_ASYNC_ADVANCED_PARITY_NONE,
                      IDC_ASYNC_ADVANCED_PARITY_SPACE,
                      IDC_ASYNC_ADVANCED_PARITY_NONE +
                        (int)m_Async.Parity );

    /*
     * Set the STOPBITS radio buttons.
     */
    CheckRadioButton( m_hDlg , IDC_ASYNC_ADVANCED_STOPBITS_1,
                      IDC_ASYNC_ADVANCED_STOPBITS_2,
                      IDC_ASYNC_ADVANCED_STOPBITS_1 +
                        (int)m_Async.StopBits );

    /*
     * Set the BYTESIZE radio buttons.
     *
     * NOTE: the constant '7' that is subtracted from the stored ByteSize
     * must track the lowest allowed byte size / BYTESIZE radio button.
     */
    CheckRadioButton( m_hDlg , IDC_ASYNC_ADVANCED_BYTESIZE_7,
                      IDC_ASYNC_ADVANCED_BYTESIZE_8,
                      IDC_ASYNC_ADVANCED_BYTESIZE_7 +
                        ((int)m_Async.ByteSize - 7) );

    /*
     * If the currently selected Wd is an ICA type, disable the BYTESIZE
     * group box and buttons - user can't change from default.
     */
    if ( m_nWdFlag & WDF_ICA )
    {
        int i;

        for( i =  IDL_ASYNC_ADVANCED_BYTESIZE ; i <= IDC_ASYNC_ADVANCED_BYTESIZE_8; i++ )
        {
            EnableWindow( GetDlgItem( m_hDlg , i ) , FALSE );
        }
    }

}  // end CAdvancedAsyncDlg::SetGlobalFields

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::SetHWFields()
{
    int i;

    /*
     * Initialize HW Receive class combo-box
     */
    HWND hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_HWRX );

    ASSERT( hCbx != NULL );

    SendMessage( hCbx , CB_SETCURSEL , ( WPARAM )m_Async.FlowControl.HardwareReceive , 0 );

    /*
     * If HW flow control is selected AND the HW Receive class is set to
     * ReceiveFlowControl_DTR, disable the DTR controls & labels.
     * Otherwise, enable the DTR control & labels.
     */
    for( i = IDL_ASYNC_ADVANCED_DTRSTATE ; i <= IDC_ASYNC_ADVANCED_DTRON ; i++ )
    {
        EnableWindow( GetDlgItem( m_hDlg , i ) , ( ( m_Async.FlowControl.Type == FlowControl_Hardware) &&
             (m_Async.FlowControl.HardwareReceive == ReceiveFlowControl_DTR) ) ? FALSE : TRUE );
    }

    /*
     * Initialize HW Transmit class combo-box.
     */

    hCbx = GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_HWTX);

    SendMessage( hCbx , CB_SETCURSEL , ( WPARAM )m_Async.FlowControl.HardwareTransmit , 0  );

    /*
     * If HW flow control is selected AND the HW Receive class is set to
     * ReceiveFlowControl_RTS, disable the RTS controls & labels.
     * Otherwise, enable the RTS control & labels.
     */

    for( i = IDL_ASYNC_ADVANCED_RTSSTATE ; i <= IDC_ASYNC_ADVANCED_RTSON ; i++ )
    {
        EnableWindow( GetDlgItem( m_hDlg , i ) , ( ( m_Async.FlowControl.Type == FlowControl_Hardware) &&
             ( m_Async.FlowControl.HardwareReceive == ReceiveFlowControl_RTS ) ) ? FALSE : TRUE );
    }

    /*
     * Enable or disable all HW fields.
     */

    for( i = IDL_ASYNC_ADVANCED_HARDWARE ; i <= IDC_ASYNC_ADVANCED_HWTX ; i++ )
    {

        EnableWindow( GetDlgItem( m_hDlg , i ) , m_Async.FlowControl.Type == FlowControl_Hardware );
    }

}  // end CAdvancedAsyncDlg::SetHWFields


//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::SetSWFields()
{
    TCHAR string[UCHAR_DIGIT_MAX];

    /*
     * Initialize Xon character edit control.
     */
    wsprintf( string, ( m_nHexBase ? TEXT("0x%02X") : TEXT("%d")) , (UCHAR)m_Async.FlowControl.XonChar );

    SetDlgItemText( m_hDlg , IDC_ASYNC_ADVANCED_XON , string );

    SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_XON ) , EM_SETMODIFY , ( WPARAM )FALSE , 0 );

    SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_XON ) , EM_LIMITTEXT , ( WPARAM )UCHAR_DIGIT_MAX-1 , 0 );

    /*
     * Initialize Xoff character edit control.
     */
    wsprintf( string, ( m_nHexBase ? TEXT( "0x%02X" ) : TEXT( "%d" ) ) , ( UCHAR )m_Async.FlowControl.XoffChar );

    SetDlgItemText( m_hDlg , IDC_ASYNC_ADVANCED_XOFF, string );

    SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_XOFF ) , EM_SETMODIFY , ( WPARAM )FALSE , 0 );

    SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_XOFF ) , EM_LIMITTEXT , ( WPARAM )UCHAR_DIGIT_MAX-1 , 0 );

    /*
     * Initialize the Xon/Xoff base control.
     */
    CheckRadioButton( m_hDlg , IDC_ASYNC_ADVANCED_BASEDEC, IDC_ASYNC_ADVANCED_BASEHEX,
                      ( int )( IDC_ASYNC_ADVANCED_BASEDEC + m_nHexBase ) );

    /*
     * Enable or disable all SW fields.
     */
    for( int i = IDL_ASYNC_ADVANCED_SOFTWARE ; i <= IDC_ASYNC_ADVANCED_BASEHEX ; i++ )
    {
        EnableWindow( GetDlgItem( m_hDlg , i ) , m_Async.FlowControl.Type == FlowControl_Software );
    }

}  // end CAdvancedAsyncDlg::SetSWFields

//---------------------------------------------------------------------------------------------------
BOOL CAdvancedAsyncDlg::GetFields()
{
    /*
     * Call member functions to get the Flow Control, Global, Hardware, and
     * Software fields.
     */
    GetFlowControlFields();

    if ( !GetGlobalFields() )
        return(FALSE);

    if ( !GetHWFields() )
        return(FALSE);

    if ( !GetSWFields(TRUE) )
        return(FALSE);

    return(TRUE);

}  // end CAdvancedAsyncDlg::GetFields

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::GetFlowControlFields()
{
    switch( GetCheckedRadioButton( IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE ,  IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE )  )
    {

        case IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE:
            m_Async.FlowControl.Type = FlowControl_None;
            break;

        case IDC_ASYNC_ADVANCED_FLOWCONTROL_SOFTWARE:
            m_Async.FlowControl.Type = FlowControl_Software;
            break;

        case IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE:
            m_Async.FlowControl.Type = FlowControl_Hardware;
            break;
    }

}  // end CAdvancedAsyncDlg::GetFlowControlFields

//---------------------------------------------------------------------------------------------------
BOOL CAdvancedAsyncDlg::GetGlobalFields()
{
    /*
     * Fetch DTR state.
     */
    m_Async.FlowControl.fEnableDTR =
            (GetCheckedRadioButton( IDC_ASYNC_ADVANCED_DTROFF,
                                    IDC_ASYNC_ADVANCED_DTRON )
                    - IDC_ASYNC_ADVANCED_DTROFF);

    /*
     * Fetch RTS state.
     */
    m_Async.FlowControl.fEnableRTS =
            (GetCheckedRadioButton( IDC_ASYNC_ADVANCED_RTSOFF,
                                    IDC_ASYNC_ADVANCED_RTSON )
                    - IDC_ASYNC_ADVANCED_RTSOFF);

    /*
     * Fetch the selected PARITY.
     */
    m_Async.Parity = (ULONG)
        (GetCheckedRadioButton( IDC_ASYNC_ADVANCED_PARITY_NONE,
                                IDC_ASYNC_ADVANCED_PARITY_SPACE )
                - IDC_ASYNC_ADVANCED_PARITY_NONE);

    /*
     * Fetch the selected STOPBITS.
     */
    m_Async.StopBits = (ULONG)
        (GetCheckedRadioButton( IDC_ASYNC_ADVANCED_STOPBITS_1,
                                IDC_ASYNC_ADVANCED_STOPBITS_2 )
                - IDC_ASYNC_ADVANCED_STOPBITS_1);

    /*
     * Fetch the selected BYTESIZE.
     *
     * NOTE: the constant '7' that is added to the stored ByteSize
     * must track the lowest allowed byte size / BYTESIZE radio button.
     */
    m_Async.ByteSize = (ULONG)
        (GetCheckedRadioButton( IDC_ASYNC_ADVANCED_BYTESIZE_7,
                                IDC_ASYNC_ADVANCED_BYTESIZE_8 )
                - IDC_ASYNC_ADVANCED_BYTESIZE_7 + 7);

    return(TRUE);

}  // end CAdvancedAsyncDlg::GetGlobalFields

//---------------------------------------------------------------------------------------------------
BOOL CAdvancedAsyncDlg::GetHWFields()
{
    /*
     * Fetch the HW receive flow class.
     */
    m_Async.FlowControl.HardwareReceive = ( RECEIVEFLOWCONTROLCLASS )
        SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_HWRX ) , CB_GETCURSEL , 0 , 0 );

    /*
     * Fetch the HW transmit flow class.
     */
    m_Async.FlowControl.HardwareTransmit = ( TRANSMITFLOWCONTROLCLASS )
        SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_HWTX ) , CB_GETCURSEL , 0 , 0 );

    return TRUE;

}  // end CAdvancedAsyncDlg::GetHWFields

//---------------------------------------------------------------------------------------------------
BOOL CAdvancedAsyncDlg::GetSWFields( BOOL bValidate )
{
    TCHAR string[UCHAR_DIGIT_MAX], *endptr;
    ULONG ul;
    INT_PTR nNewHexBase, base;

    /*
     * Determine the current state of the base controls and save.
     */
    nNewHexBase = (GetCheckedRadioButton( IDC_ASYNC_ADVANCED_BASEDEC,
                                          IDC_ASYNC_ADVANCED_BASEHEX )
                                            - IDC_ASYNC_ADVANCED_BASEDEC);

    /*
     * Fetch and convert XON character.
     */
    GetDlgItemText( m_hDlg , IDC_ASYNC_ADVANCED_XON , string , SIZE_OF_BUFFER( string ) );

    /*
     * If the edit box is modified, use the 'new' base for conversion.
     */
    base = SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_XON ) , EM_GETMODIFY , 0 , 0 ) ?  nNewHexBase : m_nHexBase ;

    ul = _tcstoul( string, &endptr, (base ? 16 : 10) );

    /*
     * If validation is requested and there is a problem with the input,
     * complain and allow user to fix.
     */
    if( bValidate && ( (*endptr != TEXT('\0') ) || ( ul > 255 ) ) )
    {

        /*
         * Invalid character in field or invalid value.
         */
        // ERROR_MESSAGE((IDP_INVALID_XONXOFF))

        /*
         * Set focus to the control so that it can be fixed.
         */
        SetFocus( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_XON ) );

        return FALSE;
    }

    /*
     * Save the Xon character.
     */
    m_Async.FlowControl.XonChar = (UCHAR)ul;

    /*
     * Fetch and convert XOFF character.
     */
    GetDlgItemText( m_hDlg , IDC_ASYNC_ADVANCED_XOFF , string , SIZE_OF_BUFFER( string ) );

    /*
     * If the edit box is modified, use the 'new' base for conversion.
     */

    base = SendMessage( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_XOFF ) , EM_GETMODIFY , 0 , 0 ) ?  nNewHexBase : m_nHexBase ;

    ul = _tcstoul( string, &endptr, (base ? 16 : 10) );

    /*
     * If validation is requested and there is a problem with the input,
     * complain and allow user to fix.
     */
    if( bValidate && ( (*endptr != TEXT('\0' )) || ( ul > 255 ) ) )
    {
        /*
         * Invalid character in field or invalid value.
         */
        // ERROR_MESSAGE((IDP_INVALID_XONXOFF))

        /*
         * Set focus to the control so that it can be fixed.
         */
        SetFocus( GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_XOFF ) );

        return FALSE;
    }

    /*
     * Save the Xoff character.
     */
    m_Async.FlowControl.XoffChar = (UCHAR)ul;

    /*
     * Save the current base state.
     */
    m_nHexBase = nNewHexBase;

    return TRUE;

}  // end CAdvancedAsyncDlg::GetSWFields


////////////////////////////////////////////////////////////////////////////////
// CAdvancedAsyncDlg message map
BOOL CAdvancedAsyncDlg::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    switch( wNotifyCode )
    {
    case BN_CLICKED:
        if( wID == IDC_ASYNC_ADVANCED_BASEDEC )
        {
            OnClickedAsyncAdvancedBasedec( );
        }
        else if( wID == IDC_ASYNC_ADVANCED_BASEHEX )
        {
            OnClickedAsyncAdvancedBasehex( );
        }
        else if( wID == IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE )
        {
            OnClickedAsyncAdvancedFlowcontrolHardware( );
        }
        else if( wID == IDC_ASYNC_ADVANCED_FLOWCONTROL_SOFTWARE )
        {
            OnClickedAsyncAdvancedFlowcontrolSoftware( );
        }
        else if( wID == IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE )
        {
            OnClickedAsyncAdvancedFlowcontrolNone( );
        }
        else if( wID == IDOK )
        {
            OnOK( );

            return EndDialog( m_hDlg , IDOK );
        }
        else if( wID == IDCANCEL )
        {
            OnCancel( );

            return EndDialog( m_hDlg , IDCANCEL );
        }
        else if( wID == ID_HELP )
        {
            TCHAR tchHelpFile[ MAX_PATH ];

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ASYNC_HELPFILE , tchHelpFile , SIZE_OF_BUFFER( tchHelpFile ) ) );
            
            WinHelp( GetParent( hwndCtrl ) , tchHelpFile , HELP_CONTEXT , HID_ASYNCADVANCE );
        }

        break;

    case CBN_CLOSEUP:

        if( wID == IDC_ASYNC_ADVANCED_HWRX )
        {
            OnCloseupAsyncAdvancedHwrx( );
        }
        else if( wID == IDC_ASYNC_ADVANCED_HWTX )
        {
            OnCloseupAsyncAdvancedHwtx( );
        }
        break;

    case CBN_SELCHANGE:

        if( wID == IDC_ASYNC_ADVANCED_HWRX )
        {
            OnSelchangeAsyncAdvancedHwrx( );
        }
        else if( wID == IDC_ASYNC_ADVANCED_HWTX )
        {
            OnSelchangeAsyncAdvancedHwtx( );
        }
        break;

    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////
// CAdvancedAsyncDlg commands

//---------------------------------------------------------------------------------------------------
BOOL CAdvancedAsyncDlg::OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );
    UNREFERENCED_PARAMETER( lp );

    // int i;
    TCHAR tchString[ 80 ];

    HWND hCbx = GetDlgItem( hDlg , IDC_ASYNC_ADVANCED_HWRX );

    ASSERT( hCbx != NULL );

    // Load up combo boxes with strings.

    m_hDlg = hDlg;

    int idx = 0;

    HRESULT hr;

    while( SUCCEEDED( ( hr =  m_pCfgcomp->GetHWReceiveName( idx , tchString ) ) ) )
    {
        if( hr == S_FALSE )
        {
            break;
        }

        SendMessage( hCbx , CB_ADDSTRING , 0 , ( LPARAM )tchString );

        idx++;
    }

    hCbx = GetDlgItem( hDlg , IDC_ASYNC_ADVANCED_HWTX);

    ASSERT( hCbx != NULL );

    idx = 0;

    while( SUCCEEDED( ( hr =  m_pCfgcomp->GetHWTransmitName( idx , tchString ) ) ) )
    {
        if( hr == S_FALSE )
        {
            break;
        }

        SendMessage( hCbx , CB_ADDSTRING , 0 , ( LPARAM )tchString );

        idx++;
    }

    // Initalize all dialog fields.

    SetFields();

    /*


    if ( m_bReadOnly ) {

        /*
         * Document is 'read-only': disable all dialog controls and labels
         * except for CANCEL & HELP buttons.

        for ( i=IDL_ASYNC_ADVANCED_FLOWCONTROL;
              i <=IDC_ASYNC_ADVANCED_BYTESIZE_8; i++ )
            GetDlgItem(i)->EnableWindow(FALSE);
        GetDlgItem(IDOK)->EnableWindow(FALSE);
    }
    */

    return(TRUE);

}  // end CAdvancedAsyncDlg::OnInitDialog

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnClickedAsyncAdvancedFlowcontrolHardware()
{
    GetFlowControlFields();
    SetFields();

}  // end CAdvancedAsyncDlg::OnClickedAsyncAdvancedFlowcontrolHardware

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnClickedAsyncAdvancedFlowcontrolSoftware()
{
    GetFlowControlFields();
    SetFields();

}  // end CAdvancedAsyncDlg::OnClickedAsyncAdvancedFlowcontrolSoftware

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnClickedAsyncAdvancedFlowcontrolNone()
{
    GetFlowControlFields();
    SetFields();

}  // end CAdvancedAsyncDlg::OnClickedAsyncAdvancedFlowcontrolNone

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnCloseupAsyncAdvancedHwrx()
{
    OnSelchangeAsyncAdvancedHwrx();

}  // end CAdvancedAsyncDlg::OnCloseupAsyncAdvancedHwrx

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnSelchangeAsyncAdvancedHwrx()
{
    HWND hCbx  = GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_HWRX );

    ASSERT( hCbx != NULL );

    /*
     * Ignore this notification if the combo box is in a dropped-down
     * state.
     */
    if( SendMessage( hCbx , CB_GETDROPPEDSTATE , 0 , 0 ) )
    {
        return;
    }

    /*
     * Fetch and Set the Hardware fields to update.
     */
    GetHWFields();
    SetHWFields();
    SetHWFlowText();

}  // end CAdvancedAsyncDlg::OnSelchangeAsyncAdvancedHwrx

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnCloseupAsyncAdvancedHwtx()
{
    OnSelchangeAsyncAdvancedHwtx();

}  // end CAdvancedAsyncDlg::OnCloseupAsyncAdvancedHwtx

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnSelchangeAsyncAdvancedHwtx()
{
    HWND hCbx  = GetDlgItem( m_hDlg , IDC_ASYNC_ADVANCED_HWTX );

    ASSERT( hCbx != NULL );

    /*
     * Ignore this notification if the combo box is in a dropped-down
     * state.
     */
    if( SendMessage( hCbx , CB_GETDROPPEDSTATE , 0 , 0 ) )
    {
        return;
    }



    /*
     * Fetch and Set the Hardware fields to update.
     */
    GetHWFields();
    SetHWFields();
    SetHWFlowText();

}  // end CAdvancedAsyncDlg::OnSelchangeAsyncAdvancedHwtx

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnClickedAsyncAdvancedBasedec()
{
    /*
     * Get/Set the SW fields to display in decimal base.
     */
    GetSWFields(FALSE);
    SetSWFields();

}  // end CAdvancedAsyncDlg::OnClickedAsyncAdvancedBasedec

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnClickedAsyncAdvancedBasehex()
{
    /*
     * Get/Set the SW fields to display in hexadecimal base.
     */
    GetSWFields(FALSE);
    SetSWFields();

}  // end CAdvancedAsyncDlg::OnClickedAsyncAdvancedBasehex

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnOK()
{
    /*
     * If the Enter key was pressed while a combo box was dropped down, ignore
     * it (treat as combo list selection only).
     */
    if ( !HandleEnterEscKey(IDOK) )
        return;

    /*
     * Fetch the field contents.  Return (don't close dialog) if a problem
     * was found.
     */
    GetFields();


}  // end CAdvancedAsyncDlg::OnOK

//---------------------------------------------------------------------------------------------------
void CAdvancedAsyncDlg::OnCancel()
{
    /*
     * If the Esc key was pressed while a combo box was dropped down, ignore
     * it (treat as combo close-up and cancel only).
     */
    HandleEnterEscKey( IDCANCEL );

}  // end CAdvancedAsyncDlg::OnCancel

//---------------------------------------------------------------------------------------------------
int CAdvancedAsyncDlg::GetCheckedRadioButton( int nIDFirstButton, int nIDLastButton )
{
    for (int nID = nIDFirstButton; nID <= nIDLastButton; nID++)
    {
        if( IsDlgButtonChecked( m_hDlg , nID ) )
        {
            return nID; // id that matched
        }
    }

    return 0; // invalid ID
}

//---------------------------------------------------------------------------------------------------
INT_PTR CALLBACK CAdvancedAsyncDlg::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CAdvancedAsyncDlg *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CAdvancedAsyncDlg *pDlg = ( CAdvancedAsyncDlg * )lp;

        SetWindowLongPtr( hwnd , DWLP_USER, ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CAdvancedAsyncDlg ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CAdvancedAsyncDlg * )GetWindowLongPtr( hwnd , DWLP_USER);

        if( IsBadReadPtr( pDlg , sizeof( CAdvancedAsyncDlg ) ) )
        {
            return 0;
        }
    }

    switch( msg )
    {

    /*case WM_DESTROY:

        pDlg->OnDestroy( );

        break;*/

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            // pDlg->OnContextMenu( ( HWND )wp , pt );
        }

        break;

    case WM_HELP:

        // pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    /*case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );*/
    }

    return 0;
}
/***********************************************************************************************************/

//---------------------------------------------------------------------------------------------------
void CEchoEditControl::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    UNREFERENCED_PARAMETER( nRepCnt );
    UNREFERENCED_PARAMETER( nFlags );
    /*
     * Tell dialog to write the character to the device unless we're
     * currently processing edit control output.  This flag check is needed
     * because the CEdit::Cut() member function will generate an OnChar()
     * event, which we need to ignore ('\b' processing).
     */

    if( !m_bProcessingOutput )
    {
        ODS( L"CEchoEditControl::OnChar -- WM_ASYNCTESTWRITECHAR( S )\n" );

        ::SendMessage( m_hDlg , WM_ASYNCTESTWRITECHAR, nChar, 0 );
    }

    /*
     * Pass character on to the edit control.  This will do nothing if
     * the edit control is 'read only'.  To cause a 'local echo' effect,
     * set the edit control to 'read/write'.
     */

}

//---------------------------------------------------------------------------------------------------
void CEchoEditControl::SubclassDlgItem( HWND hDlg , int nRes )
{
    HWND hCtrl = GetDlgItem( hDlg , nRes );

    ASSERT( hCtrl != NULL );

    m_oldproc = ( WNDPROC )SetWindowLongPtr( hCtrl , GWLP_WNDPROC , ( LONG_PTR )CEchoEditControl::WndProc );

    SetWindowLongPtr( hCtrl , GWLP_USERDATA , ( LONG_PTR )this );

}

//---------------------------------------------------------------------------------------------------
LRESULT CALLBACK CEchoEditControl::WndProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CEchoEditControl *pEdit = ( CEchoEditControl * )GetWindowLongPtr( hwnd , GWLP_USERDATA );

    if( pEdit == NULL )
    {
        ODS( L"CEchoEditControl static object not set\n" );

        return 0;
    }

    switch( msg )
    {

    case WM_CHAR:

        pEdit->OnChar( ( TCHAR )wp , LOWORD( lp ) , HIWORD( lp ) );

        break;
    }

    if( pEdit->m_oldproc != NULL )
    {
        return ::CallWindowProc( pEdit->m_oldproc , hwnd , msg ,wp , lp ) ;
    }

    return DefWindowProc( hwnd , msg ,wp , lp );
}

//---------------------------------------------------------------------------------------------------
CLed::CLed( HBRUSH hBrush )
{
    m_hBrush = hBrush;

    m_bOn = FALSE;
}

//---------------------------------------------------------------------------------------------------
void CLed::Subclass( HWND hDlg  , int nRes )
{
    HWND hCtrl = GetDlgItem( hDlg , nRes );

    ASSERT( hCtrl != NULL );

    m_hWnd = hCtrl;

    m_oldproc = ( WNDPROC )SetWindowLongPtr( hCtrl , GWLP_WNDPROC , ( LONG_PTR )CLed::WndProc );

    SetWindowLongPtr( hCtrl , GWLP_USERDATA , ( LONG_PTR )this );
}

//---------------------------------------------------------------------------------------------------
void CLed::Update(int nOn)
{
    m_bOn = nOn ? TRUE : FALSE;

    InvalidateRect( m_hWnd , NULL , FALSE );

    UpdateWindow( m_hWnd );
}

//---------------------------------------------------------------------------------------------------
void CLed::Toggle()
{
    ODS(L"CLed::Toggle\n");

    m_bOn = !m_bOn;

    InvalidateRect( m_hWnd , NULL , FALSE );

    // UpdateWindow( m_hWnd );
}

void CLed::OnPaint( HWND hwnd )
{
    RECT rect;
    PAINTSTRUCT ps;

    ODS(L"CLed::OnPaint\n");

    HDC dc = BeginPaint( hwnd , &ps );

    HBRUSH brush;

    GetClientRect( hwnd , &rect );

#ifdef USING_3DCONTROLS
    (rect.right)--;
    (rect.bottom)--;
    brush = ( HBRUSH )GetStockObject( GRAY_BRUSH );

    FrameRect( dc , &rect, brush );

    (rect.top)++;
    (rect.left)++;
    (rect.right)++;
    (rect.bottom)++;

    brush = ( HBRUSH )GetStockObject( WHITE_BRUSH );

    FrameRect( dc , &rect, brush );

    (rect.top)++;
    (rect.left)++;
    (rect.right) -= 2;
    (rect.bottom) -= 2;
#else

    brush = ( HBRUSH )GetStockObject( BLACK_BRUSH );
    FrameRect( dc , &rect , brush );
    (rect.top)++;
    (rect.left)++;
    (rect.right)--;
    (rect.bottom)--;
#endif
    DBGMSG( L"led should be %s\n" , m_bOn ? L"red" : L"grey" );

    brush = m_bOn ? m_hBrush : ( HBRUSH )GetStockObject( LTGRAY_BRUSH );

    FillRect( dc , &rect , brush );

    EndPaint( hwnd , &ps );

}

//---------------------------------------------------------------------------------------------------
LRESULT CALLBACK CLed::WndProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CLed *pWnd = ( CLed * )GetWindowLongPtr( hwnd , GWLP_USERDATA );

    if( pWnd == NULL )
    {
        ODS( L"CLed is not available\n" );

        return 0;
    }


    switch( msg )
    {

    case WM_PAINT:

        pWnd->OnPaint( hwnd );

        break;
    }

    if( pWnd->m_oldproc != NULL )
    {
        return ::CallWindowProc( pWnd->m_oldproc , hwnd , msg ,wp , lp ) ;
    }

    return DefWindowProc( hwnd , msg ,wp , lp );

}

//---------------------------------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////
// CThread class construction / destruction, implementation

/*******************************************************************************
 *
 *  CThread - CThread constructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CThread::CThread()
{
    m_hThread = NULL;

    m_dwThreadID = 0;
}  // end CThread::CThread


/*******************************************************************************
 *
 *  ~CThread - CThread destructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/
CThread::~CThread()
{
}  // end CThread::~CThread


////////////////////////////////////////////////////////////////////////////////
// CThread operations: primary thread

/*******************************************************************************
 *
 *  CreateThread - CThread implementation function
 *
 *      Class wrapper for the Win32 CreateThread API.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

HANDLE CThread::CreateThread( DWORD cbStack , DWORD fdwCreate )
{
    /*
     * Simple wrapper for Win32 CreateThread API.
     */
    return( m_hThread = ::CreateThread( NULL, cbStack, ThreadEntryPoint , ( LPVOID ) this, fdwCreate, &m_dwThreadID ) );

}  // end CThread::CreateThread


////////////////////////////////////////////////////////////////////////////////
// CThread operations: secondary thread

/*******************************************************************************
 *
 *  ThreadEntryPoint - CThread implementation function
 *                     (SECONDARY THREAD)
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

DWORD __stdcall CThread::ThreadEntryPoint( LPVOID lpParam )
{
    CThread *pThread;
    DWORD dwResult = ( DWORD )-1;

    /*
     * (lpParam is actually the 'this' pointer)
     */
    pThread = (CThread*)lpParam;



    /*
     * Run the thread.
     */
    if( pThread != NULL )
    {
        dwResult = pThread->RunThread();
    }

    /*
     * Return the result.
     */
    return(dwResult);

}  // end CThread::ThreadEntryPoint
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
// CATDlgInputThread class construction / destruction, implementation

/*******************************************************************************
 *
 *  CATDlgInputThread - CATDlgInputThread constructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CATDlgInputThread::CATDlgInputThread()
{
    /*
     * Initialize member variables.
     */
    m_bExit = FALSE;
    m_ErrorStatus = ERROR_SUCCESS;
    m_hConsumed = NULL;

    ZeroMemory( &m_OverlapSignal , sizeof( OVERLAPPED ) );
    ZeroMemory( &m_OverlapRead   , sizeof( OVERLAPPED ) );

    //m_OverlapSignal.hEvent = NULL;
    //m_OverlapRead.hEvent = NULL;
    m_BufferBytes = 0;


}  // end CATDlgInputThread::CATDlgInputThread


/*******************************************************************************
 *
 *  ~CATDlgInputThread - CATDlgInputThread destructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CATDlgInputThread::~CATDlgInputThread()
{
    /*
     * Close the semaphore and events when the CATDlgInputThread
     * object is destroyed.
     */
    if ( m_hConsumed )
        CloseHandle(m_hConsumed);

    if ( m_OverlapRead.hEvent )
        CloseHandle(m_OverlapRead.hEvent);

    if ( m_OverlapSignal.hEvent )
        CloseHandle(m_OverlapSignal.hEvent);

}  // end CATDlgInputThread::~CATDlgInputThread


/*******************************************************************************
 *
 *  RunThread - CATDlgInputThread secondary thread main function loop
 *              (SECONDARY THREAD)
 *
 *  ENTRY:
 *  EXIT:
 *      (DWORD) exit status for the secondary thread.
 *
 ******************************************************************************/

DWORD
CATDlgInputThread::RunThread()
{
    HANDLE hWait[2];
    DWORD Status;
    int iStat;

    /*
     * Initialize for overlapped status and read input.
     */
    m_hConsumed = CreateSemaphore( NULL , 0 , MAX_STATUS_SEMAPHORE_COUNT , NULL );

    m_OverlapRead.hEvent = CreateEvent( NULL , TRUE , FALSE , NULL );

    m_OverlapSignal.hEvent = CreateEvent( NULL , TRUE , FALSE , NULL );

    if ( m_hConsumed == NULL || m_OverlapRead.hEvent == NULL || m_OverlapSignal.hEvent == NULL ||
         !SetCommMask( m_hDevice , EV_CTS | EV_DSR | EV_ERR | EV_RING | EV_RLSD | EV_BREAK ) )
    {

        NotifyAbort(IDP_ERROR_CANT_INITIALIZE_INPUT_THREAD);
        return(1);
    }

    /*
     * Query initial comm status to initialize dialog with (return if error).
     */
    if ( (iStat = CommStatusAndNotify()) != -1 )
        return(iStat);

    /*
     *  Post Read for input data.
     */
    if ( (iStat = PostInputRead()) != -1 )
        return(iStat);

    /*
     *  Post Read for status.
     */
    if ( (iStat = PostStatusRead()) != -1 )
        return(iStat);

    /*
     * Loop till exit requested.
     */
    for ( ; ; ) {

        /*
         * Wait for either input data or an comm status event.
         */
        hWait[0] = m_OverlapRead.hEvent;
        hWait[1] = m_OverlapSignal.hEvent;

        ODS( L"CATDlgInputThread::RunThread waiting on either event to be signaled\n");
        Status = WaitForMultipleObjects(2, hWait, FALSE, INFINITE);

        /*
         * Check for exit.
         */
        if ( m_bExit )
        {
            ODS( L"CATDlgInputThread::RunThread exiting\n" );

            return(0);
        }

        if ( Status == WAIT_OBJECT_0 ) {

            /*
             * Read event:
             * Get result of overlapped read.
             */

            ODS(L"CATDlgInputThread::RunThread Read event signaled\n" );

            if ( !GetOverlappedResult( m_hDevice,
                                       &m_OverlapRead,
                                       &m_BufferBytes,
                                       TRUE ) ) {

                NotifyAbort(IDP_ERROR_GET_OVERLAPPED_RESULT_READ);
                return(1);
            }

            /*
             * Notify dialog.
             */
            if ( (iStat = CommInputNotify()) != -1 )
                return(iStat);

            /*
             *  Post Read for input data.
             */
            if ( (iStat = PostInputRead()) != -1 )
                return(iStat);

        } else if ( Status == WAIT_OBJECT_0+1 ) {

            ODS(L"CATDlgInputThread::RunThread Signal event signaled\n" );

            /*
             * Comm status event:
             * Query comm status and notify dialog.
             */
            if ( (iStat = CommStatusAndNotify()) != -1 )
                return(iStat);

            /*
             *  Post Read for status.
             */
            if ( (iStat = PostStatusRead()) != -1 )
                return(iStat);


        } else {

            /*
             * Unknown event: Abort.
             */
            NotifyAbort(IDP_ERROR_WAIT_FOR_MULTIPLE_OBJECTS);
            return(1);
        }
    }

}  // end CATDlgInputThread::RunThread


////////////////////////////////////////////////////////////////////////////////
// CATDlgInputThread operations: primary thread

/*******************************************************************************
 *
 *  SignalConsumed - CATDlgInputThread member function: public operation
 *
 *      Release the m_hConsumed semaphore to allow secondary thread to continue
 *      running.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CATDlgInputThread::SignalConsumed()
{
    ReleaseSemaphore( m_hConsumed, 1, NULL );

}  // end CATDlgInputThread::SignalConsumed


/*******************************************************************************
 *
 *  ExitThread - CATDlgInputThread member function: public operation
 *
 *      Tell the secondary thread to exit and cleanup after.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CATDlgInputThread::ExitThread()
{
    DWORD dwReturnCode;
    int i;
    // CWaitCursor wait;

    /*
     * If the thread was not created properly, just delete object and return.
     */
    if ( !m_hThread ) {
        delete this;
        return;
    }

    /*
     * Set the m_bExit flag to TRUE, wake up the run thread's WaitCommEvent() by
     * resetting device's Comm mask, and bump the consumed semaphore to assure exit.
     */
    m_bExit = TRUE;
    SetCommMask(m_hDevice, 0);
    SignalConsumed();

    /*
     * Purge the recieve buffer and any pending read.
     */
    PurgeComm(m_hDevice, PURGE_RXABORT | PURGE_RXCLEAR);

    /*
     * Wait a while for the thread to exit.
     */
    for ( i = 0, GetExitCodeThread( m_hThread, &dwReturnCode );
          (i < MAX_SLEEP_COUNT) && (dwReturnCode == STILL_ACTIVE); i++ ) {

        Sleep(100);
        GetExitCodeThread( m_hThread, &dwReturnCode );
    }

    /*
     * If the thread has still not exited, terminate it.
     */
    if( dwReturnCode == STILL_ACTIVE )
    {
        TerminateThread( m_hThread, 1 );

        ODS( L"Thread terminated irregularly\n" );
    }

    /*
     * Close the thread handle and delete this CATDlgInputThread object
     */
    CloseHandle( m_hThread );

    delete this;

}  // end CATDlgInputThread::ExitThread


////////////////////////////////////////////////////////////////////////////////
// CATDlgInputThread operations: secondary thread

/*******************************************************************************
 *
 *  NotifyAbort - CATDlgInputThread member function: private operation
 *              (SECONDARY THREAD)
 *
 *      Notify the dialog of thread abort and reason.
 *
 *  ENTRY:
 *      idError (input)
 *          Resource id for error message.
 *  EXIT:
 *
 ******************************************************************************/

void
CATDlgInputThread::NotifyAbort(UINT idError )
{
    TCHAR tchErrTitle[ 80 ];

    TCHAR tchErrMsg[ 256 ];
    //::PostMessage(m_hDlg, WM_ASYNCTESTABORT, idError, GetLastError());
    LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErrTitle , SIZE_OF_BUFFER( tchErrTitle ) );

    LoadString( _Module.GetResourceInstance( ) , idError , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) );

    MessageBox( m_hDlg , tchErrMsg , tchErrTitle , MB_OK | MB_ICONERROR );


}  // end CATDlgInputThread::NotifyAbort


/*******************************************************************************
 *
 *  CommInputNotify - CATDlgInputThread member function: private operation
 *              (SECONDARY THREAD)
 *
 *      Notify the dialog of comm input.
 *
 *  ENTRY:
 *  EXIT:
 *      -1 no error and continue thread
 *      0 if ExitThread was requested by parent
 *
 ******************************************************************************/

int
CATDlgInputThread::CommInputNotify()
{
    /*
     * Tell the dialog that we've got some new input.
     */
    ::PostMessage(m_hDlg, WM_ASYNCTESTINPUTREADY, 0, 0);

    ODS( L"TSCC:CATDlgInputThread::CommInputNotify WM_ASYNCTESTINPUTREADY (P)\n" );
    ODS( L"TSCC:CATDlgInputThread::CommInputNotify waiting on semaphore\n" );
    WaitForSingleObject(m_hConsumed, INFINITE);
    ODS( L"TSCC:CATDlgInputThread::CommInputNotify semaphore signaled\n" );

    /*
     * Check for thread exit request.
     */
    if ( m_bExit )
        return(0);
    else
        return(-1);

}  // end CATDlgInputThread::CommInputNotify


/*******************************************************************************
 *
 *  CommStatusAndNotify - CATDlgInputThread member function: private operation
 *              (SECONDARY THREAD)
 *
 *      Read the comm port status and notify dialog.
 *
 *  ENTRY:
 *  EXIT:
 *      -1 no error and continue thread
 *      0 if ExitThread was requested by parent
 *      1 error condition
 *
 ******************************************************************************/

int
CATDlgInputThread::CommStatusAndNotify()
{
    PFLOWCONTROLCONFIG pFlow = NULL;
    DWORD ModemStatus = 0;
	DWORD Error = 0;

    if ( !GetCommModemStatus(m_hDevice, &ModemStatus) ) {

        /*
         * We can't query the comm information; tell the primary thread
         * that we've aborted, and return error (will exit thread).
         */
        NotifyAbort(IDP_ERROR_GET_COMM_MODEM_STATUS);
        return(1);
    }

    /*
     *  Update modem status
     */
    m_Status.AsyncSignal = ModemStatus;

    /*
     *  Or in status of DTR and RTS
     */
    // pFlow = &m_PdConfig.Params.Async.FlowControl;

    pFlow = &m_ac.FlowControl;

    if ( pFlow->fEnableDTR )
        m_Status.AsyncSignal |= MS_DTR_ON;
    if ( pFlow->fEnableRTS )
        m_Status.AsyncSignal |= MS_RTS_ON;

    /*
     *  OR in new event mask
     */
    m_Status.AsyncSignalMask |= m_EventMask;

    /*
     *  Update async error counters
     */
    if ( m_EventMask & EV_ERR ) {
        (VOID) ClearCommError( m_hDevice, &Error, NULL );
        if ( Error & CE_OVERRUN )
            m_Status.Output.AsyncOverrunError++;
        if ( Error & CE_FRAME )
            m_Status.Input.AsyncFramingError++;
        if ( Error & CE_RXOVER )
            m_Status.Input.AsyncOverflowError++;
        if ( Error & CE_RXPARITY )
            m_Status.Input.AsyncParityError++;
    }

    /*
     * Tell the dialog that we've got some new status information.
     */
    ::PostMessage(m_hDlg, WM_ASYNCTESTSTATUSREADY, 0, 0);

    ODS( L"TSCC:CATDlgInputThread::CommStatusAndNotify WM_ASYNCTESTSTATUSREADY( P )\n");
    ODS( L"TSCC:CATDlgInputThread::CommStatusAndNotify waiting on semaphore\n" );
    WaitForSingleObject(m_hConsumed, INFINITE);
    ODS( L"TSCC:CATDlgInputThread::CommStatusAndNotify semaphore signaled\n" );


    /*
     * Check for thread exit request.
     */
    if ( m_bExit )
        return(0);
    else
        return(-1);

}  // end CATDlgInputThread::CommStatusAndNotify


/*******************************************************************************
 *
 *  PostInputRead - CATDlgInputThread member function: private operation
 *              (SECONDARY THREAD)
 *
 *      Post a ReadFile operation for the device, processing as long as data
 *      is present.
 *
 *  ENTRY:
 *  EXIT:
 *      -1 if read operation posted sucessfully
 *      0 if ExitThread was requested by parent
 *      1 if error condition
 *
 ******************************************************************************/

int
CATDlgInputThread::PostInputRead()
{
    int iStat;

    // TCHAR tchErrTitle[ 80 ];

    // TCHAR tchErrMsg[ 256 ];

    ODS(L"TSCC:CATDlgInputThread::PostInputRead\n");


    /*
     * Post read for input data, processing immediataly if not 'pending'.
     */

    while ( ReadFile( m_hDevice, m_Buffer, MAX_COMMAND_LEN,
                   &m_BufferBytes, &m_OverlapRead ) )
    {
        DBGMSG( L"Buffer received %s\n",m_Buffer );

        if ( (iStat = CommInputNotify()) != -1 )
            return(iStat);
    }

    /*
     *  Make sure read is pending (not some other error).
     */
    if ( GetLastError() != ERROR_IO_PENDING )
    {
        DBGMSG( L"ReadFile returned 0x%x\n" , GetLastError() );

        NotifyAbort(IDP_ERROR_READ_FILE);
    /*    LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErrTitle , sizeof( tchErrTitle ) );

        LoadString( _Module.GetResourceInstance( ) , IDP_ERROR_READ_FILE , tchErrMsg , sizeof( tchErrMsg ) );

        MessageBox( m_hDlg , tchErrMsg , tchErrTitle , MB_OK | MB_ICONERROR );*/

        EndDialog(m_hDlg, IDCANCEL);

        return(1);
    }

    /*
     * Return 'posted sucessfully' status.
     */
    return(-1);

}  // end CATDlgInputThread::PostInputRead


/*******************************************************************************
 *
 *  PostStatusRead - CATDlgInputThread member function: private operation
 *              (SECONDARY THREAD)
 *
 *      Post a WaitCommStatus operation for the device.
 *
 *  ENTRY:
 *  EXIT:
 *      -1 if status operation posted sucessfully
 *      1 if error condition
 *
 ******************************************************************************/

int
CATDlgInputThread::PostStatusRead()
{
    /*
     * Post read for comm status.
     */
    ODS( L"CATDlgInputThread::PostStatusRead\n");

    if ( !WaitCommEvent(m_hDevice, &m_EventMask, &m_OverlapSignal) ) {

        /*
         *  Make sure comm status read is pending (not some other error).
         */
        if ( GetLastError() != ERROR_IO_PENDING ) {

            NotifyAbort(IDP_ERROR_WAIT_COMM_EVENT);
            return(1);
        }
    }

    /*
     * Return 'posted sucessfully' status.
     */
    return(-1);

}  // end CATDlgInputThread::PostStatusRead
////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// CAsyncTestDlg class construction / destruction, implementation

/*******************************************************************************
 *
 *  CAsyncTestDlg - CAsyncTestDlg constructor
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to MFC CDialog::CDialog documentation)
 *
 ******************************************************************************/

CAsyncTestDlg::CAsyncTestDlg(ICfgComp * pCfgComp) :
      m_hDevice(INVALID_HANDLE_VALUE),
      m_hRedBrush(NULL),
      m_LEDToggleTimer(0),
      m_pATDlgInputThread(NULL),
      m_CurrentPos(0),
      m_hModem(NULL),
      m_bDeletedWinStation(FALSE)
{
    /*
     * Create a solid RED brush for painting the 'LED's when 'on'.
     */
    m_hRedBrush = CreateSolidBrush( RGB( 255 , 0 , 0 ) );

    /*
     * Initialize member variables.
     */

    FillMemory( &m_Status , sizeof( PROTOCOLSTATUS ) , 0 );

    FillMemory( &m_OverlapWrite , sizeof( OVERLAPPED ) , 0 );

    /*
     * Create the led objects.
     */
    for( int i = 0 ; i < NUM_LEDS ; i++ )
    {
        m_pLeds[i] = new CLed(m_hRedBrush);

    }

    m_pCfgComp = pCfgComp;

    if( pCfgComp != NULL )
    {
        m_pCfgComp->AddRef();
    }


}  // end CAsyncTestDlg::CAsyncTestDlg


/*******************************************************************************
 *
 *  ~CAsyncTestDlg - CAsyncTestDlg destructor
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to MFC CDialog::~CDialog documentation)
 *
 ******************************************************************************/

CAsyncTestDlg::~CAsyncTestDlg()
{
    /*
     * Zap our led objects.
     */
    for( int i = 0; i < NUM_LEDS; i++ )
    {
        if( m_pLeds[i] != NULL  )
        {
            delete m_pLeds[i];
        }
    }
    if(m_pCfgComp != NULL )
    {
        m_pCfgComp->Release();
    }

}  // end CAsyncTestDlg::~CAsyncTestDlg


////////////////////////////////////////////////////////////////////////////////
// CAsyncTestDlg operations

/*******************************************************************************
 *
 *  NotifyAbort - CAsyncTestDlg member function: private operation
 *
 *      Post a WM_ASYNCTESTABORT message to notify the dialog of
 *      abort and reason.
 *
 *  ENTRY:
 *      idError (input)
 *          Resource id for error message.
 *  EXIT:
 *
 ******************************************************************************/

void CAsyncTestDlg::NotifyAbort( UINT idError )
{
    TCHAR tchErrTitle[ 80 ];

    TCHAR tchErrMsg[ 256 ];

    LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErrTitle , SIZE_OF_BUFFER( tchErrTitle ) );

    LoadString( _Module.GetResourceInstance( ) , idError , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) );

    MessageBox( m_hDlg , tchErrMsg , tchErrTitle , MB_OK | MB_ICONERROR );


}  // end CAsyncTestDlg::NotifyAbort


/*******************************************************************************
 *
 *  DeviceSetParams - CAsyncTestDlg member function: private operation
 *
 *      Set device parameters for opened device.
 *
 *  ENTRY:
 *  EXIT:
 *    TRUE - no error; FALSE error.
 *
 ******************************************************************************/

BOOL CAsyncTestDlg::DeviceSetParams()
{
    PASYNCCONFIG pAsync;
    PFLOWCONTROLCONFIG pFlow;
    DCB Dcb;

    /*
     *  Get pointer to async parameters
     */
    // pAsync = &m_PdConfig0.Params.Async;

    pAsync = &m_ac;

    /*
     *  Get current DCB
     */
    if( !GetCommState( m_hDevice, &Dcb ) )
    {
        return(FALSE);
    }

    /*
     *  Set defaults
     */
    Dcb.fOutxCtsFlow      = FALSE;
    Dcb.fOutxDsrFlow      = FALSE;
    Dcb.fTXContinueOnXoff = TRUE;
    Dcb.fOutX             = FALSE;
    Dcb.fInX              = FALSE;
    Dcb.fErrorChar        = FALSE;
    Dcb.fNull             = FALSE;
    Dcb.fAbortOnError     = FALSE;

    /*
     *  Set Communication parameters
     */
    Dcb.BaudRate        = pAsync->BaudRate;
    Dcb.Parity          = (BYTE) pAsync->Parity;
    Dcb.StopBits        = (BYTE) pAsync->StopBits;
    Dcb.ByteSize        = (BYTE) pAsync->ByteSize;
    Dcb.fDsrSensitivity = pAsync->fEnableDsrSensitivity;

    pFlow = &pAsync->FlowControl;

    /*
     *  Initialize default DTR state
     */
    if ( pFlow->fEnableDTR )
        Dcb.fDtrControl = DTR_CONTROL_ENABLE;
    else
        Dcb.fDtrControl = DTR_CONTROL_DISABLE;

    /*
     *  Initialize default RTS state
     */
    if ( pFlow->fEnableRTS )
        Dcb.fRtsControl = RTS_CONTROL_ENABLE;
    else
        Dcb.fRtsControl = RTS_CONTROL_DISABLE;

    /*
     *  Initialize flow control
     */
    switch ( pFlow->Type ) {

        /*
         *  Initialize hardware flow control
         */
        case FlowControl_Hardware :

            switch ( pFlow->HardwareReceive ) {
                case ReceiveFlowControl_RTS :
                    Dcb.fRtsControl = RTS_CONTROL_HANDSHAKE;
                    break;
                case ReceiveFlowControl_DTR :
                    Dcb.fDtrControl = DTR_CONTROL_HANDSHAKE;
                    break;
            }
            switch ( pFlow->HardwareTransmit ) {
                case TransmitFlowControl_CTS :
                    Dcb.fOutxCtsFlow = TRUE;
                    break;
                case TransmitFlowControl_DSR :
                    Dcb.fOutxDsrFlow = TRUE;
                    break;
            }
            break;

        /*
         *  Initialize software flow control
         */
        case FlowControl_Software :
            Dcb.fOutX    = pFlow->fEnableSoftwareTx;
            Dcb.fInX     = pFlow->fEnableSoftwareRx;
            Dcb.XonChar  = (char) pFlow->XonChar;
            Dcb.XoffChar = (char) pFlow->XoffChar;
            break;

        case FlowControl_None :
            break;

    }

    /*
     *  Set new DCB
     */
    if ( !SetCommState( m_hDevice, &Dcb ) )
        return(FALSE);

    return( TRUE );

}  // end CAsyncTestDlg::DeviceSetParams


/*******************************************************************************
 *
 *  DeviceWrite - CAsyncTestDlg member function: private operation
 *
 *      Write out m_Buffer contents (m_BufferBytes length) to the m_hDevice.
 *
 *  ENTRY:
 *  EXIT:
 *    TRUE - no error; FALSE error.
 *
 ******************************************************************************/

BOOL CAsyncTestDlg::DeviceWrite()
{
    DWORD Error, BytesWritten;

    /*
     *  Write data
     */
    ODS( L"TSCC:CAsyncTestDlg::DeviceWrite Writing out to buffer\n" );

    if ( !WriteFile( m_hDevice, m_Buffer, m_BufferBytes,
                     &BytesWritten, &m_OverlapWrite ) )
    {
        DBGMSG( L"TSCC:CAsyncTestDlg::DeviceWrite WriteFile returned 0x%x\n" , GetLastError() );

        if ( (Error = GetLastError()) == ERROR_IO_PENDING )
        {
            /*
             *  Wait for write to complete (this may block till timeout)
             */
            if ( !GetOverlappedResult( m_hDevice, &m_OverlapWrite,
                                       &BytesWritten, TRUE ) )
            {
                CancelIo( m_hDevice );

                NotifyAbort(IDP_ERROR_GET_OVERLAPPED_RESULT_WRITE);

                return(FALSE);
            }

        } else {

            NotifyAbort(IDP_ERROR_WRITE_FILE);
            return(FALSE);
        }
    }

    return(TRUE);

}  // end CAsyncTestDlg::DeviceWrite

//---------------------------------------------------------------------
cwnd * CAsyncTestDlg::GetDlgItem( int nRes )
{
    HWND hCtrl = ::GetDlgItem( m_hDlg , nRes );

    for( int i = 0; i < NUM_LEDS; i++ )
    {
        if( m_pLeds[ i ] != NULL )
        {
            if( m_pLeds[ i ]->m_hWnd == hCtrl )
            {
                return m_pLeds[ i ];
            }
        }
    }

    return 0;
}

/*******************************************************************************
 *
 *  SetInfoFields - CAsyncTestDlg member function: private operation
 *
 *      Update the fields in the dialog with new data, if necessary.
 *
 *  ENTRY:
 *      pCurrent (input)
 *          points to COMMINFO structure containing the current Comm Input data.
 *      pNew (input)
 *          points to COMMINFO structure containing the new Comm Input data.
 *
 *  EXIT:
 *
 ******************************************************************************/

void CAsyncTestDlg::SetInfoFields( PPROTOCOLSTATUS pCurrent , PPROTOCOLSTATUS pNew )
{
    BOOL    bSetTimer = FALSE;

    /*
     * Set new LED states if state change, or set up for quick toggle if
     * no state changed, but change(s) were detected since last query.
     */
    if( ( pCurrent->AsyncSignal & MS_DTR_ON ) != ( pNew->AsyncSignal & MS_DTR_ON ) )
    {
        pNew->AsyncSignalMask &= ~EV_DTR;

        ((CLed *)GetDlgItem(IDC_ATDLG_DTR))->Update(pNew->AsyncSignal & MS_DTR_ON);

    } else if ( pNew->AsyncSignalMask & EV_DTR ) {

        pCurrent->AsyncSignal ^= MS_DTR_ON;

        ((CLed *)GetDlgItem(IDC_ATDLG_DTR))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->AsyncSignal & MS_RTS_ON) !=
         (pNew->AsyncSignal & MS_RTS_ON) ) {

        pNew->AsyncSignalMask &= ~EV_RTS;
        ((CLed *)GetDlgItem(IDC_ATDLG_RTS))->
            Update(pNew->AsyncSignal & MS_RTS_ON);

    } else if ( pNew->AsyncSignalMask & EV_RTS ) {

        pCurrent->AsyncSignal ^= MS_RTS_ON;

        ((CLed *)GetDlgItem(IDC_ATDLG_RTS))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->AsyncSignal & MS_CTS_ON) !=
         (pNew->AsyncSignal & MS_CTS_ON) ) {

        pNew->AsyncSignalMask &= ~EV_CTS;
        ((CLed *)GetDlgItem(IDC_ATDLG_CTS))->
            Update(pNew->AsyncSignal & MS_CTS_ON);

    } else if ( pNew->AsyncSignalMask & EV_CTS ) {

        pCurrent->AsyncSignal ^= MS_CTS_ON;

        ((CLed *)GetDlgItem(IDC_ATDLG_CTS))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->AsyncSignal & MS_RLSD_ON) !=
         (pNew->AsyncSignal & MS_RLSD_ON) ) {

        pNew->AsyncSignalMask &= ~EV_RLSD;
        ((CLed *)GetDlgItem(IDC_ATDLG_DCD))->
            Update(pNew->AsyncSignal & MS_RLSD_ON);

    } else if ( pNew->AsyncSignalMask & EV_RLSD ) {

        pCurrent->AsyncSignal ^= MS_RLSD_ON;

        ((CLed *)GetDlgItem(IDC_ATDLG_DCD))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->AsyncSignal & MS_DSR_ON) !=
         (pNew->AsyncSignal & MS_DSR_ON) ) {

        pNew->AsyncSignalMask &= ~EV_DSR;
        ((CLed *)GetDlgItem(IDC_ATDLG_DSR))->
            Update(pNew->AsyncSignal & MS_DSR_ON);

    } else if ( pNew->AsyncSignalMask & EV_DSR ) {

        pCurrent->AsyncSignal ^= MS_DSR_ON;

        ((CLed *)GetDlgItem(IDC_ATDLG_DSR))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->AsyncSignal & MS_RING_ON) !=
         (pNew->AsyncSignal & MS_RING_ON) ) {

        pNew->AsyncSignalMask &= ~EV_RING;
        ((CLed *)GetDlgItem(IDC_ATDLG_RI))->
            Update(pNew->AsyncSignal & MS_RING_ON);

    } else if ( pNew->AsyncSignalMask & EV_RING ) {

        pCurrent->AsyncSignal ^= MS_RING_ON;

        ((CLed *)GetDlgItem(IDC_ATDLG_RI))->Toggle();

        bSetTimer = TRUE;
    }

    /*
     * Create our led toggle timer if needed.
     */
    if ( bSetTimer && !m_LEDToggleTimer )
    {
        m_LEDToggleTimer = SetTimer( m_hDlg , IDD_ASYNC_TEST , ASYNC_LED_TOGGLE_MSEC, NULL );
    }

}  // end CAsyncTestDlg::SetInfoFields


////////////////////////////////////////////////////////////////////////////////
// CAsyncTestDlg message map

BOOL CAsyncTestDlg::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED )
    {
        if( wID == IDC_ATDLG_MODEM_DIAL )
        {
            OnClickedAtdlgModemDial( );
        }
        else if( wID == IDC_ATDLG_MODEM_INIT )
        {
            OnClickedAtdlgModemInit( );
        }
        else if( wID == IDC_ATDLG_MODEM_LISTEN )
        {
            OnClickedAtdlgModemListen( );
        }
        else if( wID == IDOK )
        {
            EndDialog( m_hDlg , IDOK );
        }
        else if( wID == IDCANCEL )
        {
            EndDialog( m_hDlg , IDCANCEL );
        }
        else if( wID == ID_HELP )
        {
            TCHAR tchHelpFile[ MAX_PATH ];

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ASYNC_HELPFILE , tchHelpFile , SIZE_OF_BUFFER( tchHelpFile ) ) );

            WinHelp( GetParent( hwndCtrl ) , tchHelpFile , HELP_CONTEXT , HID_ASYNCTEST );
        }

    }


    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////
// CAsyncTestDlg commands

/*******************************************************************************
 *
 *  OnInitDialog - CAsyncTestDlg member function: command (override)
 *
 *      Performs the dialog intialization.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnInitDialog documentation)
 *      WM_ASYNCTESTABORT message(s) will have been posted on error.
 *
 ******************************************************************************/

BOOL CAsyncTestDlg::OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );
    UNREFERENCED_PARAMETER( lp );

    int i;

    DEVICENAME DeviceName;

    COMMTIMEOUTS CommTimeouts;

    TCHAR tchErrTitle[ 80 ];

    TCHAR tchErrMsg[ 256 ];

    m_hDlg = hDlg;

//#ifdef WINSTA
    ULONG LogonId;
//#endif // WINSTA


    /*
     * Fill in the device and baud fields.
     */
    SetDlgItemText( hDlg , IDL_ATDLG_DEVICE , m_ac.DeviceName );

    SetDlgItemInt( hDlg , IDL_ATDLG_BAUD , m_ac.BaudRate , FALSE );


    /*
     * If a WinStation memory object is currently present, reset it.
     */
//#ifdef WINSTA
    if ( m_pWSName != NULL ) //&& LogonIdFromWinStationName( SERVERNAME_CURRENT , m_pWSName , &LogonId ) )
    {
        LONG Status;

        ULONG Length;

        LONG lCount = 0;

        TCHAR tchbuf[ 256 ];

        if( m_pCfgComp != NULL )
        {
            ODS( L"TSCC : Testing for live connections\n" );

            m_pCfgComp->QueryLoggedOnCount( m_pWSName,&lCount);

            if( lCount )
            {
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_WRN_TSTCON , tchbuf , SIZE_OF_BUFFER( tchbuf ) ) );

                wsprintf( tchErrMsg , tchbuf , m_pWSName);

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchErrTitle , SIZE_OF_BUFFER( tchErrTitle ) ) );

                if( MessageBox( hDlg , tchbuf , tchErrTitle , MB_YESNO | MB_ICONEXCLAMATION ) == IDNO )
                {
                    PostMessage( hDlg , WM_COMMAND , MAKEWPARAM( IDOK, BN_CLICKED ) , (LPARAM)(::GetDlgItem( hDlg , IDOK ) ) );

                    return(TRUE);   // exit dialog via posted 'OK' click
                }
            }
        }

        Status = RegWinStationQuery( SERVERNAME_CURRENT,
                                           m_pWSName,
                                           &m_WSConfig,
                                           sizeof(WINSTATIONCONFIG2),
                                           &Length );
        if(Status)
        {
            NotifyAbort(IDP_ERROR_DISABLE);
            return(TRUE);
        }

        m_WSConfig.Create.fEnableWinStation = FALSE;

        Status = RegWinStationCreate( SERVERNAME_CURRENT,
                                            m_pWSName,
                                            FALSE,
                                            &m_WSConfig,
                                            sizeof(WINSTATIONCONFIG2 ) ) ;
        if(Status)
        {
            NotifyAbort(IDP_ERROR_DISABLE);
            return(TRUE);
        }

        /*
         * Do the reset.  If, for some reason, the reset was unsucessful,
         * the device open will fail (below).
         */
        // CWaitCursor wait;
        if( LogonIdFromWinStationName( SERVERNAME_CURRENT , m_pWSName , &LogonId ) )
        {

            BOOL b = ( BOOL )WinStationReset(SERVERNAME_CURRENT, LogonId, TRUE);

            DBGMSG( L"TSCC:CAsyncTestDlg::OnInitDialog WinStationReset returned %s\n", b ? L"TRUE" : L"FALSE" );

            //m_bDeletedWinStation = TRUE;
        }


        m_bDeletedWinStation = TRUE;
    }
//#endif // WINSTA

    /*
     * Open the specified device.
     */
    lstrcpy( DeviceName, TEXT("\\\\.\\") );

    // lstrcat( DeviceName, m_PdConfig0.Params.Async.DeviceName );

    lstrcat( DeviceName, m_ac.DeviceName );

    if( ( m_hDevice = CreateFile( DeviceName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  0,                  // exclusive access
                                  NULL,               // no security attr
                                  OPEN_EXISTING,      // must exist
                                  FILE_FLAG_OVERLAPPED,
                                  NULL                // no template
                                ) ) == INVALID_HANDLE_VALUE )
    {
        NotifyAbort(IDP_ERROR_CANT_OPEN_DEVICE);
    /*    LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErrTitle , sizeof( tchErrTitle ) );

        LoadString( _Module.GetResourceInstance( ) , IDP_ERROR_CANT_OPEN_DEVICE , tchErrMsg , sizeof( tchErrMsg ) );

        MessageBox( hDlg , tchErrMsg , tchErrTitle , MB_OK | MB_ICONERROR );*/

        return(FALSE);
    }

    /*
     * Set device timeouts & communication parameters and create an event
     * for overlapped writes.
     */
    FillMemory( &CommTimeouts , sizeof( COMMTIMEOUTS ) , 0 );

    CommTimeouts.ReadIntervalTimeout = 1;           // 1 msec

    CommTimeouts.WriteTotalTimeoutConstant = 1000;  // 1 second

    m_OverlapWrite.hEvent = CreateEvent( NULL , TRUE , FALSE, NULL );

    if( !SetCommTimeouts(m_hDevice, &CommTimeouts) || !DeviceSetParams() || m_OverlapWrite.hEvent == NULL )
    {

        NotifyAbort(IDP_ERROR_CANT_INITIALIZE_DEVICE);
        ODS( L"IDP_ERROR_CANT_INITIALIZE_DEVICE\n" );

    /*    LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErrTitle , sizeof( tchErrTitle ) );

        LoadString( _Module.GetResourceInstance( ) , IDP_ERROR_CANT_INITIALIZE_DEVICE , tchErrMsg , sizeof( tchErrMsg ) );

        MessageBox( hDlg , tchErrMsg , tchErrTitle , MB_OK | MB_ICONERROR );*/


        return(TRUE);
    }

    /*
     * Create the input thread object and initialize it's member variables.
     */
    m_pATDlgInputThread = new CATDlgInputThread;

    m_pATDlgInputThread->m_hDlg = m_hDlg;

    m_pATDlgInputThread->m_hDevice = m_hDevice;

    // m_pATDlgInputThread->m_PdConfig = m_PdConfig0;

    m_pATDlgInputThread->m_ac = m_ac;

    if( !m_pATDlgInputThread->CreateThread() )
    {
        NotifyAbort(IDP_ERROR_CANT_CREATE_INPUT_THREAD);
        ODS( L"IDP_ERROR_CANT_CREATE_INPUT_THREAD\n" );

        return(TRUE);
    }

    /*
     * Hide the modem string buttons if a modem is not configured, or disable
     * buttons that are not valid.
     */
    for( int id = IDC_ATDLG_MODEM_INIT ; id <= IDC_ATDLG_PHONE_NUMBER ; id++ )
    {
        EnableWindow( ::GetDlgItem( hDlg , id) , FALSE);

        ShowWindow( ::GetDlgItem( hDlg , id) , SW_HIDE);
    }

    /*
     * Subclass the edit field to pass messages to dialog first.
     */
    m_EditControl.m_hDlg = m_hDlg;

    m_EditControl.m_bProcessingOutput = FALSE;

    m_EditControl.SubclassDlgItem( hDlg , IDC_ATDLG_EDIT );

    /*
     * Determine the edit control's font and format offset metrics.
     */

    TEXTMETRIC tm;
    RECT Rect;
    HDC dc;
    HFONT hFont , hOldFont;

    dc = GetDC( m_EditControl.m_hWnd );

    hFont = ( HFONT )SendMessage( m_EditControl.m_hWnd , WM_GETFONT , 0 , 0 );

    hOldFont = ( HFONT )SelectObject( dc , hFont);

    GetTextMetrics( dc , &tm );

    SelectObject( dc , hOldFont);

    ReleaseDC( m_EditControl.m_hWnd , dc );

    m_EditControl.m_FontHeight = tm.tmHeight;

    m_EditControl.m_FontWidth = tm.tmMaxCharWidth;

    SendMessage( m_EditControl.m_hWnd , EM_GETRECT , 0 , ( LPARAM )&Rect );

    m_EditControl.m_FormatOffsetY = Rect.top;

    m_EditControl.m_FormatOffsetX = Rect.left;


    /*
     * Subclass the led controls and default to 'off'.
     */
    for( i = 0; i < NUM_LEDS; i++ )
    {
        m_pLeds[i]->Subclass( hDlg , LedIds[i] );

        m_pLeds[i]->Update(0);

    }

    return ( TRUE );

}  // end CAsyncTestDlg::OnInitDialog


/*******************************************************************************
 *
 *  OnTimer - CAsyncTestDlg member function: command (override)
 *
 *      Used for quick 'LED toggle'.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CWnd::OnTimer documentation)
 *
 ******************************************************************************/

void CAsyncTestDlg::OnTimer(UINT nIDEvent)
{
    /*
     * Process this timer event if it it our 'LED toggle' event.
     */
    ODS( L"TSCC:CAsyncTestDlg::OnTimer \n" );

    if( nIDEvent == m_LEDToggleTimer )
    {
        ODS( L"TSCC:CAsyncTestDlg::OnTimer hit event\n" );
        /*
         * Toggle each LED that is flagged as 'changed'.
         */
        ODS( L"TSCC:led toggle " );

        if( m_Status.AsyncSignalMask & EV_DTR )
        {
            ODS( L"dtr\n");

            ( ( CLed * )GetDlgItem( IDC_ATDLG_DTR ) )->Toggle();
        }

        if( m_Status.AsyncSignalMask & EV_RTS )
        {
            ODS(L"rts\n");

            ( ( CLed * )GetDlgItem( IDC_ATDLG_RTS ) )->Toggle();
        }

        if( m_Status.AsyncSignalMask & EV_CTS )
        {
            ODS(L"cts\n");
            ( ( CLed * )GetDlgItem( IDC_ATDLG_CTS ) )->Toggle();
        }

        if( m_Status.AsyncSignalMask & EV_RLSD )
        {
            ODS(L"rlsd\n");

            ( ( CLed * )GetDlgItem( IDC_ATDLG_DCD ) )->Toggle();
        }

        if( m_Status.AsyncSignalMask & EV_DSR )
        {
            ODS(L"dsr\n");

            ( ( CLed * )GetDlgItem( IDC_ATDLG_DSR ) )->Toggle();
        }

        if( m_Status.AsyncSignalMask & EV_RING )
        {
            ODS(L"ring\n" );
            ( ( CLed * )GetDlgItem( IDC_ATDLG_RI ) )->Toggle();
        }


        /*
         * Kill this timer event and indicate so.
         */

        KillTimer( m_hDlg , m_LEDToggleTimer );

        m_LEDToggleTimer = 0;
    }

}  // end CAsyncTestDlg::OnTimer


/*******************************************************************************
 *
 *  OnAsyncTestError - CAsyncTestDlg member function: command
 *
 *      Handle the Async Test Dialog error conditions.
 *
 *  ENTRY:
 *      wParam (input)
 *          Contains message ID for error.
 *      wLparam (input)
 *          Contains error code (GetLastError or API-specific return code)
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate error handling complete.
 *
 ******************************************************************************/
/*#define STANDARD_ERROR_MESSAGE(x) { if ( 1 ) StandardErrorMessage x ; }

LRESULT
CAsyncTestDlg::OnAsyncTestError( WPARAM wParam, LPARAM lParam )
{
    /*
     * Handle special and default errors.
     */

    /*switch ( wParam )
    {

        case IDP_ERROR_MODEM_SET_INFO:
        case IDP_ERROR_MODEM_GET_DIAL:
        case IDP_ERROR_MODEM_GET_INIT:
        case IDP_ERROR_MODEM_GET_LISTEN:
            break;

        case IDP_ERROR_DISABLE:
            StandardErrorMessage( L"Test", (HWND)LOGONID_NONE, (HINSTANCE)lParam,
                                     wParam, (UINT)m_pWSName,0 );
            break;

        default:
            StandardErrorMessage( L"Test",(HWND) LOGONID_NONE, (HINSTANCE)lParam, (UINT)wParam, lParam,0);
            break;
    }

    return(0);

} // end CAsyncTestDlg::OnAsyncTestError*/


/*******************************************************************************
 *
 *  OnAsyncTestAbort - CAsyncTestDlg member function: command
 *
 *      Handle the Async Test Dialog abort conditions.
 *
 *  ENTRY:
 *      wParam (input)
 *          Contains message ID for error.
 *      wLparam (input)
 *          Contains error code (GetLastError)
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate error handling complete.  Will
 *          have posted an 'Ok' (Exit) button click to cause exit.
 *
 ******************************************************************************/

LRESULT CAsyncTestDlg::OnAsyncTestAbort( WPARAM wParam, LPARAM lParam )
{
    UNREFERENCED_PARAMETER( lParam );
    /*
     * Call OnAsyncTestError() to output message.
     */
    //OnAsyncTestError(wParam, lParam);
    NotifyAbort((UINT)wParam);
    /*
     * Post a click for 'OK' (Exit) button to exit dialog.
     */
    PostMessage( m_hDlg , WM_COMMAND , MAKEWPARAM( IDOK, BN_CLICKED ) , (LPARAM)::GetDlgItem( m_hDlg , IDOK ) );

    return(0);


} // end CAsyncTestDlg::OnAsyncTestAbort


/*******************************************************************************
 *
 *  OnAsyncTestStatusReady - CAsyncTestDlg member function: command
 *
 *      Update dialog with comm status information.
 *
 *  ENTRY:
 *      wParam (input)
 *          not used (0)
 *      wLparam (input)
 *          not used (0)
 *  EXIT:
 *      (LRESULT) always returns 0.
 *
 ******************************************************************************/

LRESULT
CAsyncTestDlg::OnAsyncTestStatusReady( WPARAM wParam, LPARAM lParam )
{
    UNREFERENCED_PARAMETER( wParam );
    UNREFERENCED_PARAMETER( lParam );

    /*
     * Update dialog fields with information from the input thread's
     * PROTOCOLSTATUS structure.
     */
    SetInfoFields( &m_Status, &(m_pATDlgInputThread->m_Status) );

    /*
     * Set our working PROTOCOLSTATUS structure to the new one and signal
     * the thread that we're done.
     */
    m_Status = m_pATDlgInputThread->m_Status;

    m_pATDlgInputThread->SignalConsumed();

    return(0);

} // end CAsyncTestDlg::OnAsyncTestStatusReady


/*******************************************************************************
 *
 *  OnAsyncTestInputReady - CAsyncTestDlg member function: command
 *
 *      Update dialog with comm input data.
 *
 *  ENTRY:
 *      wParam (input)
 *          not used (0)
 *      wLparam (input)
 *          not used (0)
 *  EXIT:
 *      (LRESULT) always returns 0.
 *
 ******************************************************************************/

LRESULT
CAsyncTestDlg::OnAsyncTestInputReady( WPARAM wParam, LPARAM lParam )
{
    UNREFERENCED_PARAMETER( wParam );
    UNREFERENCED_PARAMETER( lParam );

    BYTE OutBuf[MAX_COMMAND_LEN+2];

    int i, j;

    /*
     * Copy the thread's buffer and count locally.
     */
    m_BufferBytes = m_pATDlgInputThread->m_BufferBytes;

    CopyMemory( m_Buffer , m_pATDlgInputThread->m_Buffer , m_BufferBytes );

    /*
     * Always return caret to the current position before processing, and set
     * edit control to 'read/write' so that character overwrites can occur
     * properly.  Finally, flag control for no redraw until all updates are completed,
     * and flag 'processing output' to avoid OnChar() recursion during '\b' processing.
     */

    SendMessage( m_EditControl.m_hWnd , EM_SETSEL , m_CurrentPos , m_CurrentPos );

    SendMessage( m_EditControl.m_hWnd , EM_SETREADONLY , ( WPARAM )FALSE , 0 );

    SendMessage( m_EditControl.m_hWnd , WM_SETREDRAW , ( WPARAM )FALSE , 0 );

    /*
     * Loop to traverse the buffer, with special processing for certain
     * control characters.
     */
    for ( i = 0, j = 0; m_BufferBytes; i++, m_BufferBytes-- )
    {
        switch( m_Buffer[i] )
        {
        case '\b':
            /*
            * If there is data in the output buffer, write it now.
            */
            if( j )
            {
                OutputToEditControl(OutBuf, &j);
            }

            /*
            * Output the '\b' (will actually cut current character from buffer)
            */
            OutBuf[j++] = '\b';

            OutputToEditControl(OutBuf, &j);

            continue;

        case '\r':
            /*
             * If there is data in the output buffer, write it now.
             */
            if( j )
            {
                OutputToEditControl(OutBuf, &j);
            }

            /*
             * Output the '\r' (will not actually output, but will special case
             * for caret positioning and screen update).
             */

            OutBuf[j++] = '\r';

            OutputToEditControl(OutBuf, &j);

            continue;

        case '\n':
            /*
             * If there is data in the output buffer, write it now.
             */

            if( j )
            {
                OutputToEditControl(OutBuf, &j);
            }

            /*
             * Output the '\n' (will actually quietly output the '\r' and take
             * care of scolling).
             */
            OutBuf[j++] = '\n';

            OutputToEditControl(OutBuf, &j);

            continue;
        }

        /*
         * Add this character to the output buffer.
         */
        OutBuf[j++] = m_Buffer[i];
    }

    /*
     * If there is anything remaining in the output buffer, output it now.
     */
    if( j )
    {
        OutputToEditControl(OutBuf, &j);
    }

    /*
     * Place edit control back in 'read only' mode, flag 'not processing output',
     * set redraw flag for control, and validate the entire control (updates have
     * already taken place).
     */
    SendMessage( m_EditControl.m_hWnd , EM_SETREADONLY , ( WPARAM )TRUE , 0 );

    SendMessage( m_EditControl.m_hWnd , WM_SETREDRAW , ( WPARAM )TRUE , 0 );

    ValidateRect( m_EditControl.m_hWnd , NULL );

    /*
     * Signal thread that we're done with input so that it can continue.
     * NOTE: we don't do this at the beginning of the routine even though
     * we could (for more parallelism), since a constantly chatty async
     * line would cause WM_ASYNCTESTINPUTREADY messages to always be posted
     * to our message queue, effectively blocking any other message processing
     * (like telling the dialog to exit!).
     */

    m_pATDlgInputThread->SignalConsumed();

    return(0);

} // end CAsyncTestDlg::OnAsyncTestInputReady

/*******************************************************************************/
void CAsyncTestDlg::OutputToEditControl( BYTE *pBuffer, int *pIndex )
{
    RECT Rect, ClientRect;

    BOOL bScroll = FALSE;

    INT_PTR CurrentLine = SendMessage( m_EditControl.m_hWnd , EM_LINEFROMCHAR , ( WPARAM )m_CurrentPos , 0 );

    INT_PTR FirstVisibleLine = SendMessage( m_EditControl.m_hWnd , EM_GETFIRSTVISIBLELINE , 0 , 0  );

    INT_PTR CurrentLineIndex = SendMessage( m_EditControl.m_hWnd , EM_LINEINDEX , ( WPARAM )CurrentLine , 0 );


    /*
     * Calculate clip rectangle.
     */
    Rect.top = ( ( int )( CurrentLine - FirstVisibleLine ) * m_EditControl.m_FontHeight )
                + m_EditControl.m_FormatOffsetY;

    Rect.bottom = Rect.top + m_EditControl.m_FontHeight;

    Rect.left = m_EditControl.m_FormatOffsetX +( ( int )( m_CurrentPos - CurrentLineIndex ) * m_EditControl.m_FontWidth );

    Rect.right = Rect.left + (*pIndex * m_EditControl.m_FontWidth);

    /*
     * Handle special cases.
     */
    if ( pBuffer[0] == '\b' ) {

        /*
         * If we're already at the beginning of the line, clear buffer index
         * and return (don't do anything).
         */
        if ( m_CurrentPos == CurrentLineIndex ) {

            *pIndex = 0;
            return;
        }

        /*
         * Position the caret back one character and select through current character.
         */
        SendMessage( m_EditControl.m_hWnd , EM_SETSEL , m_CurrentPos - 1 , m_CurrentPos );

        /*
         * Cut the character out of the edit buffer.
         */
        m_EditControl.m_bProcessingOutput = TRUE;

        SendMessage( m_EditControl.m_hWnd , WM_CUT , 0 , 0 );

        m_EditControl.m_bProcessingOutput = FALSE;

        /*
         * Decrement current position and zero index to suppress further output.  Also,
         * widen the clipping rectangle back one character.
         */
        Rect.left -= m_EditControl.m_FontWidth;

        m_CurrentPos--;

        *pIndex = 0;

    }
    else if( pBuffer[0] == '\r' )
    {

        /*
         * Position the caret at the beginning of the current line.
         */
        m_CurrentPos = CurrentLineIndex;

        SendMessage( m_EditControl.m_hWnd , EM_SETSEL , m_CurrentPos, m_CurrentPos );

        /*
         * Zero index to keep from actually outputing to edit buffer.
         */
        *pIndex = 0;

    }
    else if( pBuffer[0] == '\n' )
    {

        /*
         * Position selection point at end of the current edit buffer.
         */

        m_CurrentPos = GetWindowTextLength( m_EditControl.m_hWnd );

        SendMessage( m_EditControl.m_hWnd , EM_SETSEL , m_CurrentPos , -1 );

        /*
         * Cause '\r' '\n' pair to be output to edit buffer.
         */
        pBuffer[0] = '\r';
        pBuffer[1] = '\n';
        *pIndex = 2;

        /*
         * See if scrolling needed.
         */
        GetClientRect( m_EditControl.m_hWnd , &ClientRect );


        if ( (Rect.bottom + m_EditControl.m_FontHeight) > ClientRect.bottom )
            bScroll = TRUE;

    }
    else
    {

        /*
         * Set selection from current position through *pIndex characters.  This
         * will perform desired 'overwrite' function if current position is not at
         * the end of the edit buffer.
         */

        SendMessage( m_EditControl.m_hWnd , EM_SETSEL , m_CurrentPos , m_CurrentPos + *pIndex );
    }

    /*
     * If necessary, update the dialog's edit box with the buffer data.
     */
    if( *pIndex )
    {


#ifdef UNICODE
        TCHAR OutBuffer[MAX_COMMAND_LEN+1];

        mbstowcs(OutBuffer, (PCHAR)pBuffer, *pIndex);
        OutBuffer[*pIndex] = TEXT('\0');
        SendMessage( m_EditControl.m_hWnd , EM_REPLACESEL , ( WPARAM )FALSE , ( LPARAM )OutBuffer );
#else
        pBuffer[*pIndex] = BYTE('\0');

        SendMessage( m_EditControl.m_hWnd , EM_REPLACESEL , ( WPARAM )FALSE , ( LPARAM )pBuffer );

#endif // UNICODE
    }

    /*
     * Update the current line.
     */


    SendMessage( m_EditControl.m_hWnd , WM_SETREDRAW , ( WPARAM )TRUE , 0 );

    ValidateRect( m_EditControl.m_hWnd , NULL );

    InvalidateRect( m_EditControl.m_hWnd , &Rect , FALSE );

    UpdateWindow( m_EditControl.m_hWnd );
    /*
     * If scrolling is required to see the new line, do so.
     */
    if( bScroll )
    {
        SendMessage( m_EditControl.m_hWnd , EM_LINESCROLL , 0 , 1 );
    }

    SendMessage( m_EditControl.m_hWnd , WM_SETREDRAW , ( WPARAM )FALSE , 0 );

    /*
     * Update current position and clear buffer index.
     */

    m_CurrentPos += *pIndex;

    *pIndex = 0;


} // end CAsyncTestDlg::OutputToEditControl


/*******************************************************************************
 *
 *  OnAsyncTestWriteChar - CAsyncTestDlg member function: command
 *
 *      Place the specified character in m_Buffer, set m_BufferBytes to 1,
 *      and call DeviceWrite() to output the character to the device.
 *
 *  ENTRY:
 *      wParam (input)
 *          Character to write.
 *      lParam (input)
 *          not used (0)
 *  EXIT:
 *      (LRESULT) always returns 0.
 *
 ******************************************************************************/

LRESULT CAsyncTestDlg::OnAsyncTestWriteChar( WPARAM wParam, LPARAM lParam )
{
    UNREFERENCED_PARAMETER( wParam );
    UNREFERENCED_PARAMETER( lParam );
    /*
     * Write the byte to the device.
     */
    m_Buffer[0] = (BYTE)wParam;

    m_BufferBytes = 1;

    DeviceWrite();

    return(0);

}  // end CAsyncTestDlg::OnAsyncTestWriteChar


/*******************************************************************************
 *
 *  OnClickedAtdlgModemDial - CAsyncTestDlg member function: command
 *
 *      Send the modem dial string.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void CAsyncTestDlg::OnClickedAtdlgModemDial()
{
}  // end CAsyncTestDlg::OnClickedAtdlgModemDial


/*******************************************************************************
 *
 *  OnClickedAtdlgModemInit - CAsyncTestDlg member function: command
 *
 *      Send the modem init string.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void CAsyncTestDlg::OnClickedAtdlgModemInit()
{
}  // end CAsyncTestDlg::OnClickedAtdlgModemInit


/*******************************************************************************
 *
 *  OnClickedAtdlgModemListen - CAsyncTestDlg member function: command
 *
 *      Send the modem listen string.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void CAsyncTestDlg::OnClickedAtdlgModemListen()
{
    lstrcpy((TCHAR *)m_Buffer, m_szModemListen);

    m_BufferBytes = lstrlen((TCHAR *)m_Buffer);

    DeviceWrite();


}  // end CAsyncTestDlg::OnClickedAtdlgModemListen


/*******************************************************************************
 *
 *  OnNcDestroy - CAsyncTestDlg member function: command
 *
 *      Clean up before deleting dialog object.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CWnd::OnNcDestroy documentation)
 *
 ******************************************************************************/

void
CAsyncTestDlg::OnNcDestroy()
{
    if( m_LEDToggleTimer )
    {
        KillTimer( m_hDlg , m_LEDToggleTimer );
    }

    if( m_pATDlgInputThread )
    {
        m_pATDlgInputThread->ExitThread();
    }

    if( m_hDevice != INVALID_HANDLE_VALUE )
    {
        PurgeComm(m_hDevice, PURGE_TXABORT | PURGE_TXCLEAR);
    }

    if( m_OverlapWrite.hEvent != NULL )
    {
        CloseHandle(m_OverlapWrite.hEvent);
    }

    if( m_hDevice != INVALID_HANDLE_VALUE )
    {
        CloseHandle(m_hDevice);
    }

    if( m_bDeletedWinStation && m_pWSName )
    {
        m_WSConfig.Create.fEnableWinStation = TRUE;

        if( RegWinStationCreate( SERVERNAME_CURRENT , m_pWSName , FALSE , &m_WSConfig , sizeof(WINSTATIONCONFIG2) ) != ERROR_SUCCESS )
        {
            _WinStationReadRegistry(SERVERNAME_CURRENT);

        }
    }

    DeleteObject(m_hRedBrush);

}  // end CAsyncTestDlg::OnNcDestroy
////////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK CAsyncTestDlg::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CAsyncTestDlg *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CAsyncTestDlg *pDlg = ( CAsyncTestDlg * )lp;

        SetWindowLongPtr( hwnd , DWLP_USER, ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CAsyncTestDlg ) ) )
        {
            if(FALSE == pDlg->OnInitDialog( hwnd , wp , lp ))
                PostMessage(hwnd,WM_CLOSE,0,0);
        }

        return 0;
    }

    else
    {
        pDlg = ( CAsyncTestDlg * )GetWindowLongPtr( hwnd , DWLP_USER);

        if( IsBadReadPtr( pDlg , sizeof( CAsyncTestDlg ) ) )
        {
            return 0;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnNcDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_TIMER:

        pDlg->OnTimer( ( UINT )wp );

        break;

    case WM_ASYNCTESTERROR:

        ODS(L"TSCC:CAsyncTestDlg WM_ASYNCTESTERROR (R)\n" );

        pDlg->NotifyAbort((UINT)wp);

        break;

    case WM_ASYNCTESTABORT:

        ODS(L"TSCC:CAsyncTestDlg WM_ASYNCTESTABORT (R)\n" );

        pDlg->OnAsyncTestAbort( wp , lp );

        break;

    case WM_ASYNCTESTSTATUSREADY:

        ODS(L"TSCC:CAsyncTestDlg WM_ASYNCTESTSTATUSREADY (R)\n" );

        pDlg->OnAsyncTestStatusReady( wp , lp );

        break;

    case WM_ASYNCTESTINPUTREADY:

        ODS(L"TSCC:CAsyncTestDlg WM_ASYNCTESTINPUTREADY (R)\n" );

        pDlg->OnAsyncTestInputReady( wp , lp );

        break;

    case WM_ASYNCTESTWRITECHAR:

        ODS(L"TSCC:CAsyncTestDlg WM_ASYNCTESTWRITECHAR (R)\n" );

        pDlg->OnAsyncTestWriteChar( wp , lp );

        break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\cfgcomp\stdafx.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__BB0D717D_3C44_11D2_BB98_3078302C2030__INCLUDED_)
#define AFX_STDAFX_H__BB0D717D_3C44_11D2_BB98_3078302C2030__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>


#ifdef DBG

extern bool g_fDebug;

#define ODS( x ) \
if( g_fDebug ) OutputDebugString( x ); \

#define DBGMSG( x , y ) \
    {\
    TCHAR tchErr[80]; \
    if( g_fDebug ) {\
    wsprintf( tchErr , x , y ); \
    ODS( tchErr ); \
    }\
    }

#else
#define ODS
#define DBGMSG

#endif
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.




#endif // !defined(AFX_STDAFX_H__BB0D717D_3C44_11D2_BB98_3078302C2030__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\baspdlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _BASPDLG_H
#define _BASPDLG_H

#include <prsht.h>


//---------------------------------------------------------------------
// CDialogBase - as the name implies base class for all the dialogs
//---------------------------------------------------------------------
class CDialogPropBase
{
protected:
    BOOL m_bPersisted;

    HWND m_hWnd;

    //HMENU m_hmenu;

public:
    virtual BOOL OnInitDialog( HWND hwnd , WPARAM , LPARAM ){ m_hWnd = hwnd;  return FALSE; }

    virtual BOOL OnDestroy( ){ return( TRUE /*DestroyMenu( m_hmenu )*/ ); }

    virtual BOOL GetPropertySheetPage( PROPSHEETPAGE& ){ return FALSE;}

    virtual BOOL PersistSettings( HWND ){ return FALSE;} 

    virtual BOOL IsValidSettings( HWND ){ return TRUE;}

    virtual BOOL OnNotify( int , LPNMHDR , HWND );

    virtual BOOL OnContextMenu( HWND , POINT& );

    virtual BOOL OnHelp( HWND , LPHELPINFO );

    CDialogPropBase( ){}

    //virtual ~CDialogBase( );
};

#endif //_BASPDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\baswdlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _BASWDLG_H
#define _BASWDLG_H

#include <prsht.h>
//---------------------------------------------------------------------
// CDialogBase - as the name implies base class for all the dialogs
//---------------------------------------------------------------------
class CDialogWizBase
{
protected:
    BOOL m_bPersisted;

    HWND m_hWnd;

public:
    virtual BOOL OnInitDialog( HWND , WPARAM , LPARAM ) = 0;

    virtual BOOL OnDestroy( ){ return TRUE ; }

    virtual BOOL GetPropertySheetPage( PROPSHEETPAGE& ){ return FALSE;}

    virtual BOOL PersistSettings( HWND ){ return FALSE;} 

    virtual BOOL IsValidSettings( HWND ){ return TRUE;}

    virtual BOOL OnNotify( int , LPNMHDR , HWND );

    //virtual BOOL OnContextMenu( HWND , POINT& ){ return TRUE; }

    //virtual BOOL OnHelp( HWND , LPHELPINFO ){ return TRUE; }

    CDialogWizBase( ){}

    //virtual ~CDialogWizBase( );
};

#endif //_BASWDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\asyncdlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

#ifndef _ASYNCDLG_H
#define _ASYNCDLG_H

#define ULONG_DIGIT_MAX 12
#define UINT_DIGIT_MAX 7
#define UCHAR_DIGIT_MAX 5

#define WM_ADDWINSTATION        (WM_USER + 0)
#define WM_LISTINITERROR        (WM_USER + 1)
#define WM_EDITSETFIELDSERROR   (WM_USER + 2)
#define WM_ASYNCTESTERROR       (WM_USER + 3)
#define WM_ASYNCTESTABORT       (WM_USER + 4)
#define WM_ASYNCTESTSTATUSREADY (WM_USER + 5)
#define WM_ASYNCTESTINPUTREADY  (WM_USER + 6)
#define WM_ASYNCTESTWRITECHAR   (WM_USER + 7)

#define NUM_LEDS    6
#define MAX_COMMAND_LEN 255


////////////////////////////////////////////////////////////////////////////////
class CAsyncDlg
{
    HWND m_hDlg;

    ICfgComp * m_pCfgcomp;

    INT_PTR m_nHexBase;

    TCHAR m_szWinstation[ WINSTATIONNAME_LENGTH + 1 ];

    TCHAR m_szWDName[ WDNAME_LENGTH + 1 ];

    INT m_nOldAsyncDeviceNameSelection;

    INT m_nOldAsyncConnectType;

    INT m_nOldBaudRate;

    INT m_nOldModemCallBack;
    
public:

    ASYNCCONFIG m_ac;

    ASYNCCONFIG m_oldAC;

    USERCONFIG m_uc;


public:

    CAsyncDlg( );

    BOOL OnInitDialog( HWND , LPTSTR , LPTSTR , ICfgComp * );

    void OnClickedAsyncModemcallbackPhonenumberInherit( );

    void OnClickedAsyncModemcallbackInherit( );

    void OnClickedModemProperties();

    BOOL OnSelchangeAsyncDevicename( );

    BOOL OnSelchangeAsyncConnect();

    BOOL OnSelchangeAsyncModemcallback() ;

    void OnSelchangeAsyncModemcallbackPhoneNumber() ;


    BOOL OnSelchangeAsyncBaudrate();

   
    BOOL OnCommand( WORD , WORD , HWND , PBOOL );

    HRESULT SetDefaults( );

    HRESULT DoAsyncAdvance( );

    BOOL DoAsyncTest( );

    BOOL AsyncRelease( );

    BOOL GetAsyncFields(ASYNCCONFIG& AsyncConfig,USERCONFIG UsrCfg);

    HRESULT SetAsyncFields(ASYNCCONFIG& AsyncConfig , PUSERCONFIG );
   
};

////////////////////////////////////////////////////////////////////////////////
class CAdvancedAsyncDlg 
{

/*
 * Member variables.
 */
    
public:
    ASYNCCONFIG m_Async;
    BOOL m_bReadOnly;
    BOOL m_bModem;
    INT_PTR m_nHexBase;
    ULONG m_nWdFlag;
    HWND m_hDlg;
    ICfgComp *m_pCfgcomp;

/* 
 * Implementation.
 */
public:
    CAdvancedAsyncDlg();

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL OnCommand( WORD , WORD , HWND );

    int GetCheckedRadioButton( int , int );

    BOOL OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp );

/*
 * Operations.
 */
protected:
    BOOL HandleEnterEscKey(int nID);
    void SetFields();
    void SetHWFlowText();
    void SetGlobalFields();
    void SetHWFields();
    void SetSWFields();
    BOOL GetFields();
    void GetFlowControlFields();
    BOOL GetGlobalFields();
    BOOL GetHWFields();
    BOOL GetSWFields( BOOL bValidate );

/*
 * Message map / commands.
 */
protected:
    
    void OnClickedAsyncAdvancedFlowcontrolHardware();
    void OnClickedAsyncAdvancedFlowcontrolSoftware();
    void OnClickedAsyncAdvancedFlowcontrolNone();
    void OnClickedAsyncAdvancedBasedec();
    void OnClickedAsyncAdvancedBasehex();
    void OnCloseupAsyncAdvancedHwrx();
    void OnSelchangeAsyncAdvancedHwrx();
    void OnCloseupAsyncAdvancedHwtx();
    void OnSelchangeAsyncAdvancedHwtx();
    void OnOK();
    void OnCancel();
    


}; 

////////////////////////////////////////////////////////////////////////////////
class cwnd
{
public:

    HWND m_hWnd;

    WNDPROC m_oldproc;

};


////////////////////////////////////////////////////////////////////////////////
// CEchoEditControl class
//
class CEchoEditControl : public cwnd
{
friend class CAsyncTestDlg;

/*
 * Member variables.
 */
public:
    BOOL m_bProcessingOutput;
    HWND m_hDlg;
    int m_FontHeight;
    int m_FontWidth;
    int m_FormatOffsetX;
    int m_FormatOffsetY;

/*
 * Message map / commands.
 */
    
    void OnChar (UINT nChar, UINT nRepCnt, UINT nFlags);

    void SubclassDlgItem( HWND , int  );

    static LRESULT CALLBACK WndProc( HWND , UINT , WPARAM , LPARAM );
    
};  // end CEchoEditControl class interface

////////////////////////////////////////////////////////////////////////////////
// CLed class
//
class CLed : public cwnd
{

private:
    HBRUSH          m_hBrush;
    BOOL            m_bOn;

/* 
 * Implementation.
 */
public:
    CLed( HBRUSH hBrush );

/*
 * Operations.
 */
public:
    void Subclass( HWND , int  );
    void Update(int nOn);
    void Toggle();

/*
 * Message map / commands.
 */


    void OnPaint( HWND );

    static LRESULT CALLBACK WndProc( HWND , UINT , WPARAM , LPARAM );


};


////////////////////////////////////////////////////////////////////////////////
class CThread
{

/*
 * Member variables.
 */
public:
    HANDLE m_hThread;
    DWORD m_dwThreadID;

/*
 * Implementation
 */
public:

    virtual ~CThread();


    CThread();

    static DWORD __stdcall ThreadEntryPoint(LPVOID lpParam);

    virtual DWORD RunThread() = 0;

/*
 * Operations: primary thread
 */

    HANDLE CreateThread( DWORD cbStack = 0 , DWORD fdwCreate = 0 );

};  // end CThread class interface

////////////////////////////////////////////////////////////////////////////////
// CATDlgInputThread class
//
#define MAX_STATUS_SEMAPHORE_COUNT 1
#define MAX_SLEEP_COUNT 10

class CATDlgInputThread : public CThread
{

/*
 * Member variables.
 */
public:
    HWND m_hDlg;
    HANDLE m_hDevice;
    ASYNCCONFIG m_ac;
    PROTOCOLSTATUS m_Status;
    BYTE m_Buffer[MAX_COMMAND_LEN+1];
    DWORD m_BufferBytes;

    DWORD m_ErrorStatus;
    HANDLE m_hConsumed;
    BOOL m_bExit;
    DWORD m_EventMask;
    OVERLAPPED m_OverlapSignal;
    OVERLAPPED m_OverlapRead;

/*
 * Implementation
 */

    CATDlgInputThread();

    virtual ~CATDlgInputThread();
    virtual DWORD RunThread();

/*
 * Operations: primary thread.
 */

    void SignalConsumed();
    void ExitThread();

/*
 * Operations: secondary thread.
 */

    void NotifyAbort( UINT idError );
    int CommInputNotify();
    int CommStatusAndNotify();
    int PostInputRead();
    int PostStatusRead();

};  // end CATDlgInputThread class interface



///////////////////////////////////////////////////////////////////////////////
// CAsyncTestDlg class
//

class CAsyncTestDlg 
{

/*
 * Member variables.
 */
    HWND m_hDlg;

    ICfgComp * m_pCfgComp;

    
    
public:
    ASYNCCONFIG m_ac;
    PDCONFIG m_PdConfig1;
    PWINSTATIONNAME m_pWSName;
    CEchoEditControl m_EditControl;

protected:
    
    HANDLE  m_hDevice;
    HBRUSH  m_hRedBrush;
    UINT_PTR  m_LEDToggleTimer;
    PROTOCOLSTATUS m_Status;
    CATDlgInputThread *m_pATDlgInputThread;
    OVERLAPPED m_OverlapWrite;
    BYTE    m_Buffer[MAX_COMMAND_LEN+1];
    INT_PTR m_CurrentPos;
    DWORD   m_BufferBytes;
    TCHAR   m_szModemInit[MAX_COMMAND_LEN+1];
    TCHAR   m_szModemDial[MAX_COMMAND_LEN+1];
    TCHAR   m_szModemListen[MAX_COMMAND_LEN+1];
    HANDLE  m_hModem;
    BOOL    m_bDeletedWinStation;
    CLed *  m_pLeds[NUM_LEDS];
    WINSTATIONCONFIG2 m_WSConfig;


/* 
 * Implementation.
 */
public:
    CAsyncTestDlg(ICfgComp * pCfgComp = NULL);
    ~CAsyncTestDlg();

/*
 * Operations.
 */

    void NotifyAbort( UINT idError );
    BOOL DeviceSetParams();
    BOOL DeviceWrite();
    void SetInfoFields( PPROTOCOLSTATUS pCurrent, PPROTOCOLSTATUS pNew );
    void OutputToEditControl( BYTE *pBuffer, int *pIndex );

/*
 * Message map / commands.
 */

    BOOL OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp );

    BOOL OnCommand( WORD , WORD , HWND );

    void OnTimer(UINT nIDEvent);
    LRESULT OnAsyncTestError(WPARAM wParam, LPARAM lParam);
    LRESULT OnAsyncTestAbort(WPARAM wParam, LPARAM lParam);
    LRESULT OnAsyncTestStatusReady(WPARAM wParam, LPARAM lParam);
    LRESULT OnAsyncTestInputReady(WPARAM wParam, LPARAM lParam);
    LRESULT OnAsyncTestWriteChar(WPARAM wParam, LPARAM lParam);
    void OnClickedAtdlgModemDial();
    void OnClickedAtdlgModemInit();
    void OnClickedAtdlgModemListen();
    void OnNcDestroy();
    cwnd *GetDlgItem( int nRes );
    

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );



};  // end CAsyncTestDlg class interface 

#define ASYNC_LED_TOGGLE_MSEC   200

    
#endif // _ASYNCDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\comp.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
//
// 08/13/98
// alhen
//
#include "stdafx.h"
#include "tscc.h"
#include "compdata.h"
#include "comp.h"
#include "tsprsht.h"
#include "sdlgs.h"

INT_PTR CALLBACK RenameDlgProc( HWND , UINT , WPARAM , LPARAM );

void ErrMessage( HWND hwndOwner , INT_PTR iResourceID );

extern void xxxErrMessage( HWND hwnd , INT_PTR nResMessageId , INT_PTR nResTitleId , UINT nFlags );

extern void TscAccessDeniedMsg( HWND hwnd );

extern void TscGeneralErrMsg( HWND hwnd );

BOOL IsValidConnectionName( LPTSTR szConName , PDWORD );

extern void SnodeErrorHandler( HWND hParent , INT nObjectId , DWORD dwStatus );

extern void ReportStatusError( HWND hwnd , DWORD dwStatus );

extern BOOL g_bAppSrvMode;

//extern BOOL g_bEditMode;

//--------------------------------------------------------------------------
CComp::CComp( CCompdata* pCompdata )
{
    m_pConsole = NULL;

    m_pCompdata = pCompdata;

    m_pResultData = NULL;

    m_pHeaderCtrl = NULL;

    m_pConsoleVerb = NULL;

    m_pImageResult = NULL;

    m_pDisplayHelp = NULL;

    m_nSettingCol = 0;
    
    m_nAttribCol = 0;

    m_cRef = 1; // addref at ctor

}

//--------------------------------------------------------------------------
CComp::~CComp( )
{
}

//--------------------------------------------------------------------------
STDMETHODIMP CComp::QueryInterface( REFIID riid , PVOID *ppv )
{
    HRESULT hr = S_OK;

    if( riid == IID_IUnknown )
    {
        *ppv = ( LPUNKNOWN )( LPCOMPONENT )this;
    }
    else if( riid == IID_IComponent )
    {
        *ppv = ( LPCOMPONENT )this;
    }
    else if( riid == IID_IExtendContextMenu )
    {
        *ppv = ( LPEXTENDCONTEXTMENU )this;
    }
    else if( riid == IID_IExtendPropertySheet )
    {
        *ppv = ( LPEXTENDPROPERTYSHEET )this;
    }
    else
    {
        *ppv = 0;

        hr = E_NOINTERFACE;
    }

    AddRef( );

    return hr;
}
    
//--------------------------------------------------------------------------
STDMETHODIMP_( ULONG ) CComp::AddRef( )
{
    return InterlockedIncrement( ( LPLONG )&m_cRef );
}

//--------------------------------------------------------------------------
STDMETHODIMP_( ULONG )CComp::Release( )
{
    if( InterlockedDecrement( ( LPLONG )&m_cRef ) == 0 )
    {
        delete this;

        return 0;
    }

    return m_cRef;
}

//--------------------------------------------------------------------------
STDMETHODIMP CComp::Initialize( LPCONSOLE lpConsole )
{
    HRESULT hr;

    ASSERT( lpConsole != NULL );

    m_pConsole = lpConsole;
    
    m_pConsole->AddRef( );

    // VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_MAINFOLDERNAME , m_strDispName , sizeof( m_strDispName ) ) );

    do
    {
        if( FAILED( ( hr = m_pConsole->QueryInterface( IID_IResultData , ( LPVOID *)&m_pResultData ) ) ) )
        {
            break;
        }

        if( FAILED( ( hr = m_pConsole->QueryInterface( IID_IHeaderCtrl , ( LPVOID *)&m_pHeaderCtrl ) ) ) )
        {
            break;
        }

        if( FAILED( ( hr = m_pConsole->QueryConsoleVerb( &m_pConsoleVerb ) ) ) )
        {
            break;
        }

        if( FAILED( ( hr = m_pConsole->QueryInterface( IID_IDisplayHelp , ( LPVOID * )&m_pDisplayHelp ) ) ) )
        {
            break;
        }

        hr = m_pConsole->QueryResultImageList( &m_pImageResult );
        
    }while( 0 );
    
    return hr;
}

//--------------------------------------------------------------------------
STDMETHODIMP CComp::Notify( LPDATAOBJECT pDataObj , MMC_NOTIFY_TYPE event , LPARAM arg , LPARAM  )
{
    switch( event )
    {
    case MMCN_ACTIVATE:

        ODS( L"IComponent -- MMCN_ACTIVATE\n" );

        //Bug 483485 - we want to call OnRefresh so that MMC can get the current window's pointer list. The
        //only reason this problem wasn't seen more often is that OnShow is called when one of the left nodes
        //is clicked on which does something similar to OnRefresh, so it was masking the problem. This isn't
        //sufficient when accessing the result nodes immediately after switching windows though
        if (arg) //We only refresh the activated node. This is also called for deactivation with arg = false
            OnRefresh(pDataObj);

        break;

    case MMCN_ADD_IMAGES:

        ODS( L"IComponent -- MMCN_ADD_IMAGES\n" );

        OnAddImages( );

        break;

    case MMCN_BTN_CLICK:

        ODS( L"IComponent -- MMCN_BTN_CLICK\n" );

        break;

    case MMCN_CLICK:

        ODS( L"IComponent -- MMCN_CLICK\n" );

        break;

    case MMCN_DBLCLICK:

        ODS( L"IComponent -- MMCN_DBLCLICK\n" );

        // enables navigation to inner folders.
        // final item launches default verb
        OnDblClk( pDataObj );

        return S_FALSE;

    case MMCN_DELETE:

        ODS( L"IComponent -- MMCN_DELETE\n" );

        OnDelete( pDataObj );

        break;

    case MMCN_EXPAND:

        ODS( L"IComponent -- MMCN_EXPAND\n" );

        break;

    case MMCN_MINIMIZED:

        ODS( L"IComponent -- MMCN_MINIMIZED\n" );

        break;

    case MMCN_PROPERTY_CHANGE:

        ODS( L"IComponent -- MMCN_PROPERTY_CHANGE\n" );

        break;

    case MMCN_REMOVE_CHILDREN:

        ODS( L"IComponent -- MMCN_REMOVE_CHILDREN\n" );

        break;

    case MMCN_REFRESH:

        ODS( L"IComponent -- MMCN_REFRESH\n" );
        OnRefresh( pDataObj );

        break;

    case MMCN_RENAME:

        ODS( L"IComponent -- MMCN_RENAME\n" );

        break;

    case MMCN_SELECT:

        ODS( L"IComponent -- MMCN_SELECT\n" );

        OnSelect( pDataObj , ( BOOL )LOWORD( arg ) , ( BOOL )HIWORD( arg ) );

        break;

    case MMCN_SHOW:

        ODS( L"IComponent -- MMCN_SHOW\n" );

        OnShow( pDataObj , ( BOOL )arg );

        break;

    case MMCN_VIEW_CHANGE:

        ODS( L"IComponent -- MMCN_VIEW_CHANGE\n" );

        OnViewChange( );

        break;

    case MMCN_CONTEXTHELP:

        ODS( L"IComponent -- MMCN_CONTEXTHELP\n" );

        OnHelp( pDataObj );

        break;

    case MMCN_SNAPINHELP:

        ODS( L"IComponent -- MMCN_SNAPINHELP\n" );

        break;


    default:
        ODS( L"CComp::Notify - event not registered\n" );
    }

    return S_OK;
}

//--------------------------------------------------------------------------
// pDataobject represents the current selected scope folder
// this should only be our main folder in the scope pane
//--------------------------------------------------------------------------
HRESULT CComp::OnShow( LPDATAOBJECT pDataobject , BOOL bSelect )
{
    TCHAR tchBuffer[ 256 ];

    HRESULT hr = S_FALSE;

    ASSERT( pDataobject != NULL );    

    if( bSelect && m_pCompdata->IsSettingsFolder( pDataobject ) )
    {
        // set up columns for services folder 

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_SETTINGS_COLUMN1 , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) );

        if( m_nSettingCol == 0 && m_nAttribCol == 0 )
        {
            SetColumnsForSettingsPane( );
        }
        
        ODS( L"TSCC:Comp@OnShow inserting columns\n" );

        if( m_nSettingCol == 0 )
        {
            hr = m_pHeaderCtrl->InsertColumn( 0 , tchBuffer , 0 , MMCLV_AUTO );
        }
        else
        {
            hr = m_pHeaderCtrl->InsertColumn( 0 , tchBuffer , 0 , m_nSettingCol );
        }


        if( SUCCEEDED( hr ) )
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ATTRIB_COLUMN2 , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) );

            if( m_nAttribCol == 0 )
            {
                hr = m_pHeaderCtrl->InsertColumn( 1 , tchBuffer , 0 , MMCLV_AUTO );            
            }
            else
            {
                hr = m_pHeaderCtrl->InsertColumn( 1 , tchBuffer , 0 , m_nAttribCol );
            }

        }

        AddSettingsinResultPane( );        
    }

    else if( bSelect && m_pCompdata->IsConnectionFolder( pDataobject ) )
    {        
        // set up column headers for connection folder 
        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_COLCONNECT , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) );
        
        hr = m_pHeaderCtrl->InsertColumn( 0 , tchBuffer , 0 , MMCLV_AUTO );

        if( SUCCEEDED( hr ) )
        {
            //SetColumnWidth( 0 );

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_COLTRANSPORT , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) );
            
            hr = m_pHeaderCtrl->InsertColumn( 1 , tchBuffer , 0 , MMCLV_AUTO );
        }

        if( SUCCEEDED( hr ) )
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_COLTYPE , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) );

            // ui master dirty trick 120 equals fudge factor

            hr = m_pHeaderCtrl->InsertColumn( 2 , tchBuffer , 0 , 120/*MMCLV_AUTO*/ );
        }
        

        if( SUCCEEDED( hr ) )
        {
            //SetColumnWidth( 2 );

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_COLCOMMENT , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) );

            hr = m_pHeaderCtrl->InsertColumn( 3 , tchBuffer , 0 , MMCLV_AUTO );
        }

        // insert items
        if( SUCCEEDED( hr ) )
        {
            hr = InsertItemsinResultPane( );
        }
    }

    return hr;
}

//--------------------------------------------------------------------------
BOOL CComp::OnAddImages( )
{
    HICON hiconConnect = LoadIcon( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDI_ICON_CON ) );

    HICON hiconDiscon  = LoadIcon( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDI_ICON_DISCON ) );

    HICON hiconBullet = LoadIcon( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDI_ICON_BULLET ) );

    m_pImageResult->ImageListSetIcon( ( PLONG_PTR  )hiconConnect , 1 );

    m_pImageResult->ImageListSetIcon( ( PLONG_PTR )hiconDiscon , 2 );

    m_pImageResult->ImageListSetIcon( ( PLONG_PTR )hiconBullet , 3 );

    
    return TRUE;
}

//--------------------------------------------------------------------------
// update resultitems in result pane and note scopeitems
//--------------------------------------------------------------------------
BOOL CComp::OnViewChange( )
{
    RESULTDATAITEM rdi;

    ZeroMemory( &rdi , sizeof( RESULTDATAITEM ) );

    rdi.mask = RDI_PARAM;

    m_pResultData->GetItem( &rdi );

    if( rdi.bScopeItem )
    {
        return FALSE;
    }
    
    if( SUCCEEDED( InsertItemsinResultPane( ) ) )
    {
        return TRUE;
    }

    return FALSE;
}

BOOL CComp::OnFullRefresh(LPDATAOBJECT pdo)
{
    if (m_pCompdata->IsConnectionFolder(pdo))
    {
        if (!SUCCEEDED(InsertAndBuildItemsinResultPane()))
            return FALSE;
    }

    if (m_pCompdata->IsSettingsFolder(pdo))
    { 
        if (!SUCCEEDED(AddSettingsinResultPane()))
            return FALSE;
    }

    return TRUE;
}
    
BOOL CComp::OnRefresh(LPDATAOBJECT pdo)
{    
    if (m_pCompdata->IsConnectionFolder(pdo))
    {
        if (!SUCCEEDED(InsertItemsinResultPane()))
            return FALSE;
    }

    if (m_pCompdata->IsSettingsFolder(pdo))
    { 
        if (!SUCCEEDED(AddSettingsinResultPane()))
            return FALSE;
    }

    return TRUE;
}
    


//--------------------------------------------------------------------------
STDMETHODIMP CComp::Destroy( MMC_COOKIE  /* reserved */ )
{
    ODS( L"IComponent releasing interfaces\n" );

    if( m_pResultData != NULL )
    {
        m_pResultData->Release( );
    }

    if( m_pConsole != NULL )
    {
        m_pConsole->Release( );
    }

    if( m_pHeaderCtrl != NULL )
    {
        m_pHeaderCtrl->Release( );
    }

    if( m_pConsoleVerb != NULL )
    {
        m_pConsoleVerb->Release( );
    }

    if( m_pImageResult != NULL )
    {
        m_pImageResult->Release( );
    }

    if( m_pDisplayHelp != NULL )
    {
        m_pDisplayHelp->Release( );
    }

    return S_OK;
}

//--------------------------------------------------------------------------
STDMETHODIMP CComp::GetResultViewType( MMC_COOKIE  , LPOLESTR*  , PLONG plView )
{
    *plView = MMC_VIEW_OPTIONS_NONE;
    
    return S_FALSE;
}

//--------------------------------------------------------------------------
STDMETHODIMP CComp::QueryDataObject( MMC_COOKIE ck , DATA_OBJECT_TYPES dtype , LPDATAOBJECT* ppDataObject )
{
    if( dtype == CCT_RESULT )
    {
        *ppDataObject = ( LPDATAOBJECT )ck;

        ( ( LPDATAOBJECT )*ppDataObject)->AddRef( );

    }

    else if( m_pCompdata != NULL )
    {
       return m_pCompdata->QueryDataObject( ck , dtype , ppDataObject );
    }

    return S_OK;
}

//--------------------------------------------------------------------------
STDMETHODIMP CComp::GetDisplayInfo( LPRESULTDATAITEM pRdi )
{
    ASSERT( pRdi != NULL );

    if( pRdi == NULL )
    {
        return E_INVALIDARG;
    }

    if( pRdi->bScopeItem )
    {
        CBaseNode *pScopeNode = ( CBaseNode * )pRdi->lParam;

        if( pScopeNode != NULL )
        {
            if( pScopeNode->GetNodeType( ) == MAIN_NODE )
            {
                //
                if( pRdi->mask & RDI_STR )
                {
                    if( pRdi->nCol == 0 )
                    {
                        // pRdi->str is NULL in this call

                        pRdi->str = ( LPOLESTR )m_pCompdata->m_tchMainFolderName; //m_strDispName; 
                    }
            
                }
            }
            else if( pScopeNode->GetNodeType( ) == SETTINGS_NODE )
            {
                if( pRdi->mask & RDI_STR )
                {
                    if( pRdi->nCol == 0 )
                    {
                        // pRdi->str is NULL in this call

                        pRdi->str = ( LPOLESTR )m_pCompdata->m_tchSettingsFolderName; //L"Server Settings"; 
                    }
            
                }
            }
        }


        if( pRdi->mask & RDI_IMAGE )  
        {
            ODS( TEXT("RDI_IMAGE -- in CComponent::GetDisplayInfo\n") );

            pRdi->nImage = ( ( CBaseNode * )pRdi->lParam )->GetImageIdx( );

        }

    }
    else
    {
        // populate result pane
        CBaseNode *pItem = ( CBaseNode * )pRdi->lParam;

        if( pItem != NULL )
        {
            if( pItem->GetNodeType( ) == RESULT_NODE )
            {
                CResultNode *pNode = ( CResultNode * )pRdi->lParam;

                if( pRdi->mask & RDI_STR )
                {
                    switch( pRdi->nCol )
                    {
                        case 0:
            
                            pRdi->str = pNode->GetConName( );
                
                        break;

                        case 1:

                            pRdi->str = pNode->GetTTName( );

                        break;

                        case 2:

                            pRdi->str = pNode->GetTypeName( );
                
                        break;

                        case 3:

                            pRdi->str = pNode->GetComment( );

                        break;
                    }
                }
            }
            else if( pItem->GetNodeType( ) == RSETTINGS_NODE )
            {
                CSettingNode *pNode = ( CSettingNode *)pRdi->lParam;

                if( pRdi->mask & RDI_STR )
                {
                    switch( pRdi->nCol )
                    {
                        case 0:

                            pRdi->str = pNode->GetAttributeName( );

                            break;

                        case 1:

                            if( pNode->GetObjectId( ) >= CUSTOM_EXTENSION )
                            {
                                DWORD dwStatus;

                                pNode->SetAttributeValue( 0 , &dwStatus );
                            }

                            pRdi->str = pNode->GetCachedValue( );

                            break;
                    }
                }
            }
        }
    }

    return S_OK;
}

//--------------------------------------------------------------------------
// Returns S_OK if they are similar S_FALSE otherwise
//--------------------------------------------------------------------------
STDMETHODIMP CComp::CompareObjects( LPDATAOBJECT , LPDATAOBJECT )
{
    return S_OK;
}

//--------------------------------------------------------------------------


//This has been added for when the user selects the Refresh menu item. We want
//to rebuild the result node list because it can change thru an external script.
//We're safe in doing this because Refresh can only be called when the focus
//is not on a result node. If it can be, there's a danger of pointer corruption
//in MMC, so we have to call InsertItemsinResultPane which is safer but not
//as complete a refresh operation.
HRESULT CComp::InsertAndBuildItemsinResultPane( )
{
    HRESULT hr;
  
    if( m_pCompdata == NULL )
        return E_UNEXPECTED;
    
    //This removes the node information from the data in MMC
    if( FAILED( hr = m_pResultData->DeleteAllRsltItems( ) ) )
        return hr;
 
    if( FAILED( m_pCompdata->UpdateAllResultNodes( ) ) )
    {       
        ODS( L"InsertItemsinResultPane - UpdateAllResultNodes failed!!\n" ) ;
        return FALSE;
    }

    //This puts the data for the nodes into m_pCompdata and also sends that same information to MMC
    if( FAILED( hr = m_pCompdata->InsertFolderItems( m_pResultData ) ) )
        return hr;

    return hr;
}


HRESULT CComp::InsertItemsinResultPane( )
{
    HRESULT hr;
  
    if( m_pCompdata == NULL )
        return E_UNEXPECTED;
    
    //This removes the node information from the data in MMC
    if( FAILED( hr = m_pResultData->DeleteAllRsltItems( ) ) )
        return hr;

    //This is no longer being called because it's dangerous to modify all the result node pointers
    //during execution since there's a chance they'll get out of sync with MMC's result node
    //pointer list. This wasn't happening before because this is only called during an OnRefresh
    //operation, which could only be called when items in the left pane were selected. Now, however,
    //OnRefresh is called when switching between windows (bug 483485 - it has to be for MMC to get
    //the current window's pointer list), so it's possible for a result node to have the focus,
    //in which case the pointers don't get updated correctly and everything falls apart. When a
    //refresh operation is triggered by the menu item, the focus has to be in the left pane so
    //another method is used that includes this call to UpdateAllResultNodes
    /*if( FAILED( m_pCompdata->UpdateAllResultNodes( ) ) )
    {       
        ODS( L"InsertItemsinResultPane - UpdateAllResultNodes failed!!\n" ) ;
        return FALSE;
    }*/

    //This puts the data for the nodes into m_pCompdata and also sends that same information to MMC
    if( FAILED( hr = m_pCompdata->InsertFolderItems( m_pResultData ) ) )
        return hr;

    return hr;
}
        
//--------------------------------------------------------------------------
HRESULT CComp::AddSettingsinResultPane( )
{
    HRESULT hr;
      
    if( m_pCompdata == NULL )
        return E_UNEXPECTED;

    //This removes the node information from the data in MMC
    if( FAILED( hr = m_pResultData->DeleteAllRsltItems( ) ) )
        return hr;

    if( FAILED( hr = m_pCompdata->InsertSettingItems( m_pResultData ) ) )
        return hr;

    return hr;
}

//--------------------------------------------------------------------------
HRESULT CComp::OnSelect( LPDATAOBJECT pdo , BOOL bScope , BOOL bSelected )
{   
    CBaseNode *pNode = static_cast< CBaseNode * >( pdo );
    
    if( pNode == NULL ) 
    {
        return S_FALSE;
    }

    if( m_pConsoleVerb == NULL )
    {
        return E_UNEXPECTED;
    }

    // Item is being deselected and we're not interested currently

    if( !bSelected )
    {
        return S_OK;
    }
        
    // pNode == NULL if the folder item is being viewed in the result pane
    // settings node is ignored for this release
    
    if( bScope && pNode->GetNodeType( ) == MAIN_NODE )
    {
        m_pConsoleVerb->SetVerbState( MMC_VERB_REFRESH , ENABLED , TRUE );

        m_pConsoleVerb->SetDefaultVerb( MMC_VERB_OPEN );

    }
    else if( pNode->GetNodeType() == SETTINGS_NODE )
    {
        m_pConsoleVerb->SetVerbState( MMC_VERB_REFRESH , ENABLED , TRUE );
    }
    else if( pNode->GetNodeType() == RESULT_NODE )
    {
        m_pConsoleVerb->SetVerbState( MMC_VERB_DELETE , ENABLED , TRUE );

        //m_pConsoleVerb->SetVerbState( MMC_VERB_REFRESH , ENABLED , TRUE );

        m_pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES , ENABLED , TRUE );

        m_pConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES );
    }

    return S_OK;
}

//--------------------------------------------------------------------------
STDMETHODIMP CComp::AddMenuItems( LPDATAOBJECT pdo , LPCONTEXTMENUCALLBACK pcmc , PLONG pl )
{
    // CONTEXTMENUITEM cmi;

    if( pdo == NULL || pcmc == NULL )
    {
        return E_UNEXPECTED;
    }
    
    // do not allow scope node types

    if( m_pCompdata->IsConnectionFolder( pdo ) || m_pCompdata->IsSettingsFolder( pdo ) )
    {
        return S_FALSE;
    }

    CBaseNode *pNode = NULL;

    pNode = static_cast< CBaseNode * >( pdo );
    
    if( pNode == NULL )
    {
        return S_FALSE;
    }

    // hey root node has no menu items to insert.

    if( pNode->GetNodeType() == 0 )
    {
        return S_FALSE;
    }
   
    if( pNode->AddMenuItems( pcmc , pl ) )
    {        
        return S_OK;
    }

    return E_FAIL;

}

//--------------------------------------------------------------------------
// Toggles connection 
//--------------------------------------------------------------------------
STDMETHODIMP CComp::Command( LONG lCmd , LPDATAOBJECT pdo )
{
    TCHAR buf[ 512 ];
                    
    TCHAR tchmsg[ 256 ];

    HRESULT hr;

    if( pdo == NULL )
    {
        return E_UNEXPECTED;
    }

    HWND hMain;

    if( FAILED( m_pConsole->GetMainWindow( &hMain ) ) )
    {
        hMain = NULL;
    }
    
    CResultNode *pNode = NULL;
    
    CSettingNode *pSetNode = NULL;

    if( pdo == NULL )
    {
        return S_FALSE;
    }

    if( ( ( CBaseNode * )pdo )->GetNodeType( ) == RSETTINGS_NODE )
    {
        pSetNode = ( CSettingNode * )pdo;

        BOOL bVal;

        DWORD dwStatus = 0;

        switch( lCmd )
        {
        case IDM_SETTINGS_PROPERTIES:
            
            OnDblClk( pdo );

            break;

        case IDM_SETTINGS_DELTEMPDIRSONEXIT:
        
        case IDM_SETTINGS_USETMPDIR:

        case IDM_SETTINGS_ADP:

        case IDM_SETTINGS_SS:
            {
                bVal = ( BOOL )pSetNode->xx_GetValue( );
                
                HCURSOR hCursor = SetCursor( LoadCursor( NULL , MAKEINTRESOURCE( IDC_WAIT ) ) );
                
                hr = pSetNode->SetAttributeValue( !bVal , &dwStatus );
                
                if( FAILED( hr ) )
                {
                    SnodeErrorHandler( hMain , pSetNode->GetObjectId( ) , dwStatus );
                }


                //
                // We might want to move this code into OnRefresh() but for now, this is fix for
                // not updating attribute value and don't want to cause other regression
                //
                HRESULT hr;
                HRESULTITEM itemID;
         
                hr = m_pResultData->FindItemByLParam( (LPARAM) pdo, &itemID );

                if( SUCCEEDED(hr) )
                {
                    m_pResultData->UpdateItem( itemID );
                }

                SetCursor( hCursor );                                 
            }

            break;

        default:

            if( pSetNode->GetObjectId() >= CUSTOM_EXTENSION )
            {
                IExtendServerSettings *pEss = reinterpret_cast< IExtendServerSettings * >( pSetNode->GetInterface() );

                if( pEss != NULL )
                {
                    pEss->ExecMenuCmd( lCmd , hMain , &dwStatus );

                    // this forces the ui to be updated.
                    
                    if( dwStatus == UPDATE_TERMSRV || dwStatus == UPDATE_TERMSRV_SESSDIR )
                    {
                        ICfgComp *pCfgcomp = NULL;

                        m_pCompdata->GetServer( &pCfgcomp );                        

                        if( pCfgcomp != NULL )
                        {
                            ODS( L"TSCC!ExecMenuCmd forcing termsrv update\n" );

                            if( dwStatus == UPDATE_TERMSRV_SESSDIR )
                            {
                                HCURSOR hCursor = SetCursor( LoadCursor( NULL ,
                                        MAKEINTRESOURCE( IDC_WAIT ) ) );

                                if( FAILED( pCfgcomp->UpdateSessionDirectory( &dwStatus ) ) )
                                {
                                    ReportStatusError( hMain , dwStatus );
                                }
                                
                                HRESULTITEM itemID;

                                hr = m_pResultData->FindItemByLParam( (LPARAM) pdo, &itemID );

                                if( SUCCEEDED(hr) )
                                {
                                    m_pResultData->UpdateItem( itemID );
                                } 

                                SetCursor(hCursor);
                            }
                            else
                            {
                                pCfgcomp->ForceUpdate( );
                            }

                            pCfgcomp->Release();
                        }

                    }

                    pSetNode->SetAttributeValue( 0 , &dwStatus );                    
                }
            }
        }

    }
    else if( ( ( CBaseNode * )pdo )->GetNodeType( ) == RESULT_NODE )
    {
        pNode = ( CResultNode * )pdo;

        if( lCmd == IDM_ENABLE_CONNECTION )
        {
            if( pNode->m_bEditMode )
            {
                xxxErrMessage( hMain , IDS_ERR_INEDITMODE , IDS_WARN_TITLE , MB_OK | MB_ICONWARNING );
            
                return S_FALSE;
            }

            ICfgComp *pCfgcomp;

            if( pNode->GetServer( &pCfgcomp ) != 0 )
            {
                WS *pWs;

                LONG lSz;

                if( SUCCEEDED( pCfgcomp->GetWSInfo( pNode->GetConName( ) , &lSz , &pWs ) ) )
                {
                    BOOL bProceed = TRUE;

                    pWs->fEnableWinstation = !pNode->GetConnectionState( );

                    if( pWs->fEnableWinstation == 0 )
                    {
                        
                        LONG lCount;

                        // check to see if anyone is connected 

                        pCfgcomp->QueryLoggedOnCount( pNode->GetConName( ) , &lCount );

                        if( lCount > 0 )
                        {
                            LoadString( _Module.GetResourceInstance( ) , IDS_DISABLELIVECONNECTION , tchmsg , SIZE_OF_BUFFER( tchmsg ) );
                        }
                        else
                        {
                            LoadString( _Module.GetResourceInstance( ) , IDS_DISABLECONNECTION , tchmsg , SIZE_OF_BUFFER( tchmsg ) );
                        }

                        wsprintf( buf , tchmsg , pNode->GetConName( ) );

                        LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchmsg , SIZE_OF_BUFFER( tchmsg ) );

                        
                        if( MessageBox( hMain , buf , tchmsg , MB_ICONWARNING | MB_YESNO ) == IDNO )
                        {
                            bProceed = FALSE;
                        }
                    }

                    if( bProceed )
                    {
                        /*pNode->EnableConnection( pWs->fEnableWinstation );

                        pNode->SetImageIdx( ( pWs->fEnableWinstation ? 1 : 2 )  );
                    
                        pCfgcomp->UpDateWS( pWs , UPDATE_ENABLEWINSTATION );
                    
                        m_pConsole->UpdateAllViews( ( LPDATAOBJECT )pNode , 0 , 0 );
                        */

                        DWORD dwStatus;

                        if( FAILED( hr = pCfgcomp->UpDateWS( pWs , UPDATE_ENABLEWINSTATION , &dwStatus, TRUE ) ) )
                        {
                            if( hr == E_ACCESSDENIED )
                            {
                                TscAccessDeniedMsg( hMain );
                            }
                            else
                            {
                                TscGeneralErrMsg( hMain );
                            }
                        }
                        else
                        {
                            pNode->EnableConnection( pWs->fEnableWinstation );
                            
                            pNode->SetImageIdx( ( pWs->fEnableWinstation ? 1 : 2 )  );

                            m_pConsole->UpdateAllViews( ( LPDATAOBJECT )pNode , 0 , 0 );
                        }                    
                    
                    }

                    if(pWs->fEnableWinstation && pWs->PdClass == SdAsync)
                    {
                        ASYNCCONFIGW AsyncConfig;

                        HRESULT hResult = pCfgcomp->GetAsyncConfig( pWs->Name , WsName , &AsyncConfig );

                        if( SUCCEEDED( hResult ) )
                        {
                            if( AsyncConfig.ModemName[0] )
                            {                               
                                LoadString( _Module.GetResourceInstance( ) , IDS_REBOOT_REQD , buf , SIZE_OF_BUFFER( buf ) );

                                LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchmsg , SIZE_OF_BUFFER( tchmsg ) );

                                MessageBox( hMain , buf , tchmsg , MB_ICONWARNING | MB_OK );
                            }
                        }
                    }

                    CoTaskMemFree( pWs );
                }

                pCfgcomp->Release( );
            }            

        }
        else if( lCmd == IDM_RENAME_CONNECTION )
        {            
            if( pNode->m_bEditMode )
            {
                xxxErrMessage( hMain , IDS_ERR_INEDITMODE , IDS_WARN_TITLE , MB_OK | MB_ICONWARNING );
            
                return S_FALSE;
            }

            ::DialogBoxParam( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDD_RENAME ) , hMain , RenameDlgProc , ( LPARAM )pNode );
        }    
    }

    return S_OK;
}

//--------------------------------------------------------------------------
STDMETHODIMP CComp::CreatePropertyPages( LPPROPERTYSHEETCALLBACK psc , LONG_PTR Handle , LPDATAOBJECT pdo )
{
    HRESULT hr = E_OUTOFMEMORY;

    if( psc == NULL )
    {
        return E_UNEXPECTED;
    }
    
    CPropsheet *pPropsheet = new CPropsheet( );

    if( pPropsheet != NULL )
    {
        HWND hMain;
        
        if( FAILED( m_pConsole->GetMainWindow( &hMain ) ) )
        {
            hMain = NULL;
        }
    
        if( FAILED( ( hr = pPropsheet->InitDialogs( hMain , psc , dynamic_cast< CResultNode *>( pdo ) , Handle ) ) ) )
        {
            delete pPropsheet;
        }
        
    }

    return hr;
}

//--------------------------------------------------------------------------
STDMETHODIMP CComp::QueryPagesFor( LPDATAOBJECT pdo )
{
    if( dynamic_cast< CResultNode *>( pdo ) == NULL )
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

//--------------------------------------------------------------------------
BOOL CComp::OnDelete( LPDATAOBJECT pDo )
{
    CResultNode *pNode = dynamic_cast< CResultNode *>( pDo );

    if( pNode == NULL )
    {
        ODS( L"TSCC: OnDelete, node == NULL\n");

        return FALSE;
    }

    if( pNode->m_bEditMode )
    {
        HWND hMain;
        
        if( FAILED( m_pConsole->GetMainWindow( &hMain ) ) )
        {
            hMain = NULL;
        }

        xxxErrMessage( hMain , IDS_ERR_INEDITMODE , IDS_WARN_TITLE , MB_OK | MB_ICONWARNING );

        return FALSE;
    }


    return m_pCompdata->OnDeleteItem( pDo );
}
    

//--------------------------------------------------------------------------
// CResultNode passed in on init
//--------------------------------------------------------------------------
INT_PTR CALLBACK RenameDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp )
{
    CResultNode *pNode;

    TCHAR tchNewName[ 60 ];

    // HWND h;

    switch( msg )
    {
    case WM_INITDIALOG :

        pNode = ( CResultNode *)lp;

        ASSERT( pNode != NULL );
        
        // ok to store null -- it's initializing DWLP_USER area

        SetWindowLongPtr( hDlg , DWLP_USER , ( LONG_PTR )pNode );

        // Insert name

        ICfgComp *pCfgcomp;

        if( pNode == NULL )
        {
            break;
        }

        if( pNode->GetServer( &pCfgcomp ) == 0 )
        {
            ASSERT( 0 );

            break;
        }
        
        SetWindowText( GetDlgItem( hDlg , IDC_STATIC_CURRENT_NAME ) , pNode->GetConName( ) );

        pCfgcomp->Release( );

        SetFocus( GetDlgItem( hDlg , IDC_EDIT_NEWNAME ) );
    
        SendMessage( GetDlgItem( hDlg , IDC_EDIT_NEWNAME ) , EM_SETLIMITTEXT , ( WPARAM )( WINSTATIONNAME_LENGTH - WINSTATION_NAME_TRUNCATE_BY ) , 0 );

        break;

    case WM_COMMAND:

        if( LOWORD( wp ) == IDOK )
        {
            pNode = ( CResultNode *)GetWindowLongPtr( hDlg , DWLP_USER );

            if( pNode == NULL )
            {
                break;
            }

            DWORD dwErr = 0;

            if( GetWindowText( GetDlgItem( hDlg , IDC_EDIT_NEWNAME ) , tchNewName , SIZE_OF_BUFFER( tchNewName ) ) == 0 ||

                !IsValidConnectionName( tchNewName , &dwErr ) )
            {
                if( dwErr == ERROR_INVALID_FIRSTCHARACTER )
                {
                    ErrMessage( hDlg , IDS_ERR_INVALIDFIRSTCHAR );
                }
                else
                {
                    ErrMessage( hDlg , IDS_ERR_INVALIDCHARS );
                }               

                SetFocus( GetDlgItem( hDlg , IDC_EDIT_NEWNAME ) );

                SendMessage( GetDlgItem( hDlg , IDC_EDIT_NEWNAME ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );
                
                return 0;
            }

            // verify the name is unique

            ICfgComp *pCfgcomp;

            
            if( pNode->GetServer( &pCfgcomp ) == 0 )
            {
                ODS( L"GetServer failed in RenameDlgProc\n" );

                break;
            }

            do
            {
                BOOL bUnique = FALSE;

                if( FAILED( pCfgcomp->IsWSNameUnique( ( PWINSTATIONNAMEW )tchNewName , &bUnique ) ) )
                {
                    break;
                }
            
                if( !bUnique )
                {

                    ErrMessage( hDlg , IDS_ERR_WINNAME );
                    
                    pCfgcomp->Release( );

                    SetFocus( GetDlgItem( hDlg , IDC_EDIT_NEWNAME ) );

                    SendMessage( GetDlgItem( hDlg , IDC_EDIT_NEWNAME ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );

                    return 0;
                }

                HRESULT hr;

                LONG lCount;

                TCHAR tchWrnBuf[ 256 ];

                TCHAR tchOutput[ 512 ];

                
                // check to see if anyone is connected 
                
                pCfgcomp->QueryLoggedOnCount( pNode->GetConName( ) , &lCount );
                
                if( lCount > 0 )
                {
                   
                    if( lCount == 1 )
                    {
                        LoadString( _Module.GetResourceInstance() , IDS_RENAME_WRN_SINGLE , tchWrnBuf , SIZE_OF_BUFFER( tchWrnBuf ) );
                    }
                    else
                    {
                        LoadString( _Module.GetResourceInstance() , IDS_RENAME_WRN_PL , tchWrnBuf , SIZE_OF_BUFFER( tchWrnBuf ) );
                    }

                    wsprintf( tchOutput , tchWrnBuf , pNode->GetConName( ) );

                    LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchWrnBuf , SIZE_OF_BUFFER( tchWrnBuf ) );

                    if( MessageBox( hDlg , tchOutput , tchWrnBuf , MB_ICONWARNING | MB_YESNO ) == IDNO )
                    {
                        break;
                    }
                }


                if( FAILED( hr = pCfgcomp->RenameWinstation( ( PWINSTATIONNAMEW )pNode->GetConName( ) , ( PWINSTATIONNAMEW )tchNewName ) ) )
                {
                    ODS( L"TSCC: RenameWinstation failed\n" );

                    if( hr == E_ACCESSDENIED )
                    {
                        TscAccessDeniedMsg( hDlg );
                    }
                    else
                    {
                        TscGeneralErrMsg( hDlg );
                    }

                    break;
                }
                
                /*
                LONG lCount;

                TCHAR tchWrnBuf[ 256 ];

                TCHAR tchOutput[ 512 ];

                
                // check to see if anyone is connected 
                
                pCfgcomp->QueryLoggedOnCount( pNode->GetConName( ) , &lCount );
                
                if( lCount > 0 )
                {
                   
                    if( lCount == 1 )
                    {
                        LoadString( _Module.GetResourceInstance() , IDS_RENAME_WRN_SINGLE , tchWrnBuf , SIZE_OF_BUFFER( tchWrnBuf ) );
                    }
                    else
                    {
                        LoadString( _Module.GetResourceInstance() , IDS_RENAME_WRN_PL , tchWrnBuf , SIZE_OF_BUFFER( tchWrnBuf ) );
                    }

                    wsprintf( tchOutput , tchWrnBuf , pNode->GetConName( ) );

                    LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchWrnBuf , SIZE_OF_BUFFER( tchWrnBuf ) );

                    MessageBox( hDlg , tchOutput , tchWrnBuf , MB_OK | MB_ICONWARNING );
                }
                */

                WS *pWs;

                LONG lSz;

                if( SUCCEEDED( pCfgcomp->GetWSInfo(tchNewName , &lSz , &pWs ) ) )
                {
                    if(pWs->fEnableWinstation && pWs->PdClass == SdAsync)
                    {
                        ASYNCCONFIGW AsyncConfig;

                        HRESULT hResult = pCfgcomp->GetAsyncConfig( pWs->Name , WsName , &AsyncConfig );
                        
                        if( SUCCEEDED( hResult ) )
                        {
                            if( AsyncConfig.ModemName[0] )
                            {
                                LoadString( _Module.GetResourceInstance( ) , IDS_REBOOT_REQD , tchOutput , SIZE_OF_BUFFER( tchOutput ) );
                                
                                LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchWrnBuf , SIZE_OF_BUFFER( tchWrnBuf ) );
                                
                                MessageBox( hDlg , tchOutput , tchWrnBuf , MB_ICONWARNING | MB_OK );
                            }
                        }
                    }

                    CoTaskMemFree( pWs );
                }
                        
                pNode->SetConName( tchNewName , SIZE_OF_BUFFER( tchNewName ) );

            }while( 0 );
            
            pCfgcomp->Release( );

            EndDialog( hDlg , 0 );

        }
        else if( LOWORD( wp ) == IDCANCEL )
        {
            EndDialog( hDlg , 0 );
        }

        break;
    }

    return 0;
}

//--------------------------------------------------------------------------
BOOL IsValidConnectionName( LPTSTR szConName , PDWORD pdwErr )
{
    TCHAR tchInvalidChars[ 80 ];

    tchInvalidChars[0] = 0;

    if( szConName == NULL || pdwErr == NULL )
    {
        return FALSE;
    }

    if( _istdigit( szConName[ 0 ] ) )
    {
        *pdwErr = ERROR_INVALID_FIRSTCHARACTER;

        return FALSE;
    }
    
    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance() , IDS_INVALID_CHARS , tchInvalidChars , SIZE_OF_BUFFER( tchInvalidChars ) ) );

    int nLen = lstrlen( tchInvalidChars );

    while( *szConName )
    {
        for( int idx = 0 ; idx < nLen ; idx++ )
        {
            if( *szConName == tchInvalidChars[ idx ] )
            {
                *pdwErr = ERROR_ILLEGAL_CHARACTER;

                return FALSE;
            }
        }

        szConName++;
    }

    *pdwErr = ERROR_SUCCESS;

    return TRUE;
}

//----------------------------------------------------------------------            
BOOL CComp::OnHelp( LPDATAOBJECT pDo )
{
    TCHAR tchTopic[ 80 ];

    HRESULT hr = E_FAIL;

    if( pDo == NULL || m_pDisplayHelp == NULL )    
    {
        return hr;
    }

    INT_PTR nNodeType = ( ( CBaseNode * )pDo )->GetNodeType();

    if( nNodeType == RESULT_NODE || nNodeType == MAIN_NODE || nNodeType == 0 )
    {
        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance() , IDS_TSCCHELPTOPIC , tchTopic , SIZE_OF_BUFFER( tchTopic ) ) );
        
        hr = m_pDisplayHelp->ShowTopic( tchTopic );
        
    }
    else if( nNodeType == SETTINGS_NODE || nNodeType == RSETTINGS_NODE )
    {
        if( nNodeType == SETTINGS_NODE )
        {
            IExtendServerSettings *pEss = NULL;

            INT iRet = -1;

            CSettingNode *pNode = dynamic_cast< CSettingNode *>( pDo );

            if( pNode != NULL )
            {
                if( pNode->GetObjectId( ) >= CUSTOM_EXTENSION )
                {
                    pEss = reinterpret_cast< IExtendServerSettings * >( pNode->GetInterface( ) );

                    if( pEss != NULL )
                    {
                        pEss->OnHelp( &iRet );

                        if( iRet == 0 )
                        {
                            return TRUE;
                        }
                    }
                }
            }
        }

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance() , IDS_SETTINGSHELP , tchTopic , SIZE_OF_BUFFER( tchTopic ) ) );
        
        hr = m_pDisplayHelp->ShowTopic( tchTopic );
    }

    return ( SUCCEEDED( hr ) ? TRUE : FALSE );
}

//----------------------------------------------------------------------            
BOOL CComp::OnDblClk( LPDATAOBJECT pDo )
{
    CSettingNode *pNode = dynamic_cast< CSettingNode *>( pDo );

    if( pNode == NULL )
    {
        // we're only concerned about Setting nodes

        return FALSE;
    }

    HWND hMain;

    if( FAILED( m_pConsole->GetMainWindow( &hMain ) ) )
    {
        hMain = NULL;
    }

    INT nObjectId = pNode->GetObjectId( );
    
    switch( nObjectId )
    {
        /*
    case 0:
        
        ::DialogBoxParam( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDD_CACHED_SESSIONS ) , hMain , CachedSessionsDlgProc , ( LPARAM )pNode );
        
        break;*/

    case DELETED_DIRS_ONEXIT:

        ::DialogBoxParam( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDD_YESNODIALOG ) , hMain , DeleteTempDirsDlgProc , ( LPARAM )pNode );

        break;

    case PERSESSION_TEMPDIR:

        ::DialogBoxParam( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDD_DIALOG_PERSESSION ) , hMain , UsePerSessionTempDirsDlgProc , ( LPARAM )pNode );

        break;

    /*
    case DEF_CONSECURITY:

        ::DialogBoxParam( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDD_DEFCONSEC ) , hMain , DefConSecurityDlgProc , ( LPARAM )pNode );

        break;

     */

    case LICENSING:

        ::DialogBoxParam( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDD_LICENSING ) , hMain , LicensingDlgProc , ( LPARAM )pNode );

        break;

    case ACTIVE_DESK:

        ::DialogBoxParam( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDD_ADP_DIALOG ) , hMain , ConfigActiveDesktop , ( LPARAM )pNode );

        break;

    case USERSECURITY:

        // error if we're trying to modify property in remote admin mode

        if( !g_bAppSrvMode )
        {
            xxxErrMessage( hMain , IDS_REMOTEADMIN_ONLY , IDS_WARN_TITLE , MB_OK | MB_ICONINFORMATION );

            break;
        }

        ::DialogBoxParam( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDD_PROPPAGE_TERMINAL_SERVER_PERM ) , hMain , UserPermCompat , ( LPARAM )pNode );

        break;

    case SINGLE_SESSION:

        ::DialogBoxParam( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDD_SINGLE_SESSION) , hMain , ConfigSingleSession , ( LPARAM )pNode );

        break;

    default:

        if( nObjectId >= CUSTOM_EXTENSION )
        {
            IExtendServerSettings *pEss = reinterpret_cast< IExtendServerSettings * >( pNode->GetInterface() );

            if( pEss != NULL )
            {          
                DWORD dwStatus;

                pEss->InvokeUI( hMain , &dwStatus );
               
                if( dwStatus == UPDATE_TERMSRV || dwStatus == UPDATE_TERMSRV_SESSDIR )
                {
                    ICfgComp *pCfgcomp = NULL;

                    m_pCompdata->GetServer( &pCfgcomp );

                    if( pCfgcomp != NULL )
                    {
                        ODS( L"TSCC!Comp OnDblClk forcing termsrv update\n" );

                        if( dwStatus == UPDATE_TERMSRV_SESSDIR )
                        {
                            HCURSOR hCursor = SetCursor( LoadCursor( NULL ,
                                    MAKEINTRESOURCE( IDC_WAIT ) ) );

                            if( FAILED( pCfgcomp->UpdateSessionDirectory( &dwStatus ) ) )
                            {
                                ReportStatusError( hMain , dwStatus );
                            }

                            SetCursor(hCursor);
                        }
                        else
                        {
                            pCfgcomp->ForceUpdate( );
                        }

                        pCfgcomp->Release();
                    }

                }
            }
        }


    }

    return TRUE;
}

/*
//----------------------------------------------------------------------            
HRESULT CComp::SetColumnWidth( int nCol )
{
    HWND hMain;

    int nCurColLen;

    CResultNode *pNode;

    do
    {
        if( FAILED( m_pHeaderCtrl->GetColumnWidth( nCol , &nCurColLen ) ) )
        {
            break;
        }
          
        if( FAILED( m_pConsole->GetMainWindow( &hMain ) ) )
        {
            break;
        }
    
        HDC hdc = GetDC( hMain );
        
        SIZE sz;

        int idx = 0;

        TCHAR *psz;
        
        while( ( pNode = *m_pCompdata->GetResultNode( idx ) ) != NULL )
        {           
            
            switch( nCol )
            {
            case 0:
                
                psz = pNode->GetConName( );
                
                break;

            case 1:
                
                psz = pNode->GetTTName( );

                break;

            case 2:
                
                psz = pNode->GetTypeName( );
                
                break;

            // comment is too big allow user to adjust size
            }



            GetTextExtentPoint32( hdc , psz , lstrlen( psz ) , &sz );

            if( sz.cx > nCurColLen )
            {
                nCurColLen = sz.cx;
            }

            idx++;
        }
        
        
        m_pHeaderCtrl->SetColumnWidth( nCol , nCurColLen );
        
        ReleaseDC( hMain , hdc );

    } while( 0 );


    return S_OK;
}

*/

//----------------------------------------------------------------------                            
HRESULT CComp::SetColumnsForSettingsPane( )
{
    HWND hParent;

    SIZE sz = { 0 , 0 };

    TCHAR tchBuffer[ 256 ];

    INT nMaxLen;
    
    if( FAILED( m_pConsole->GetMainWindow( &hParent ) ) )
    {
        hParent = NULL;
    }
  
    HDC hdc = GetDC( hParent );

    if( hdc != NULL )
    {

        m_pCompdata->GetMaxTextLengthSetting( tchBuffer , &nMaxLen );
    
        VERIFY_S( TRUE , GetTextExtentPoint32( hdc , tchBuffer , nMaxLen , &sz ) );

        m_nSettingCol = sz.cx - 16 ; // remove icon width from column width

        m_pCompdata->GetMaxTextLengthAttribute( tchBuffer , &nMaxLen );
    
        VERIFY_S( TRUE , GetTextExtentPoint32( hdc , tchBuffer , nMaxLen , &sz ) );
    
        m_nAttribCol = sz.cx;

        ReleaseDC( hParent , hdc );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\comp.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef __COMP_H_
#define __COMP_H_

#include <mmc.h>

/*
#define IDM_ENABLE_CONNECTION 102

#define IDM_RENAME_CONNECTION 103

#define IDM_SETTINGS_PROPERTIES 104

#define IDM_SETTINGS_DELTEMPDIRSONEXIT 105

#define IDM_SETTINGS_USETMPDIR 106
*/

class CComp:
  public IComponent,
  public IExtendContextMenu,
  public IExtendPropertySheet
  // public IExtendControlbar,
  
{
public:

    CComp( CCompdata *);
    ~CComp();

    //
    // IUnknown
    //

    STDMETHOD( QueryInterface )( REFIID , PVOID * );
    
    STDMETHOD_( ULONG , AddRef )( );

    STDMETHOD_( ULONG , Release )( );

    //
    // IComponent interface members
    //

    STDMETHOD( Initialize )( LPCONSOLE );

    STDMETHOD( Notify )( LPDATAOBJECT , MMC_NOTIFY_TYPE , LPARAM , LPARAM );

    STDMETHOD( Destroy )( MMC_COOKIE  );

    STDMETHOD( GetResultViewType )( MMC_COOKIE , LPOLESTR* , PLONG );

    STDMETHOD( QueryDataObject )( MMC_COOKIE , DATA_OBJECT_TYPES , LPDATAOBJECT* );

    STDMETHOD( GetDisplayInfo )( LPRESULTDATAITEM );

    STDMETHOD( CompareObjects )( LPDATAOBJECT , LPDATAOBJECT );

    HRESULT OnShow( LPDATAOBJECT , BOOL );

    HRESULT InsertAndBuildItemsinResultPane( );
    HRESULT InsertItemsinResultPane( );

    HRESULT AddSettingsinResultPane( );

    HRESULT OnSelect( LPDATAOBJECT , BOOL , BOOL );

    //
    // IExtendContextMenu
    

    STDMETHOD( AddMenuItems )( LPDATAOBJECT , LPCONTEXTMENUCALLBACK , PLONG );

    STDMETHOD( Command )( LONG , LPDATAOBJECT );


    STDMETHOD( CreatePropertyPages )( LPPROPERTYSHEETCALLBACK , LONG_PTR , LPDATAOBJECT );

    STDMETHOD( QueryPagesFor )( LPDATAOBJECT );

    BOOL OnFullRefresh( LPDATAOBJECT );
    BOOL OnRefresh( LPDATAOBJECT );

    BOOL OnDelete( LPDATAOBJECT );

    BOOL OnViewChange( );

    BOOL OnAddImages( );

    BOOL OnHelp( LPDATAOBJECT );

    BOOL OnDblClk( LPDATAOBJECT );

    // HRESULT SetColumnWidth( int );

    HRESULT SetColumnsForSettingsPane( );
  
private:

    ULONG m_cRef;

    LPCONSOLE m_pConsole;

    CCompdata* m_pCompdata;   

    LPRESULTDATA m_pResultData;

    LPHEADERCTRL m_pHeaderCtrl;

    LPCONSOLEVERB m_pConsoleVerb;

    LPIMAGELIST m_pImageResult;

    LPDISPLAYHELP m_pDisplayHelp;

    INT m_nSettingCol;

    INT m_nAttribCol;

    // TCHAR m_strDispName[80];

    // IConsoleVerb*    m_ipConsoleVerb;

    
    
    // LPTOOLBAR        m_ipToolbar1;

    // LPCONTROLBAR     m_ipControlbar;
    
    // HBITMAP          m_hbmp16x16;
    
    // HBITMAP          m_hbmp32x32;
        
    // HBITMAP          m_hbmpToolbar1;
    
    
    
    // LONG             m_nFileCount;

};

#endif // __COMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\compdata.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// Compdata.h : Declaration of the CCompdata

#ifndef __COMPDATA_H_
#define __COMPDATA_H_

#include "resource.h"       // main symbols
#include <mmc.h>
#include "tarray.h"
#include "twiz.h"
#include "rnodes.h"
#include "snodes.h"

//#include "cfgbkend.h"

#define IDM_CREATECON 101

#define MS_DIALOG_COUNT 8

#define FIN_PAGE 7

#define LAN_PAGE 5

#define ASYNC_PAGE 6


//enum { DELETED_DIRS_ONEXIT , PERSESSION_TEMPDIR , DEF_CONSECURITY , LICENSING , MAX_SETTINGS };

/////////////////////////////////////////////////////////////////////////////
// CCompdata
class ATL_NO_VTABLE CCompdata : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCompdata, &CLSID_Compdata>,
    public IExtendContextMenu,
    public ISnapinAbout,
    public ISnapinHelp,
	public IComponentData
{

public:
	
	
DECLARE_REGISTRY_RESOURCEID( IDR_COMPDATA )

DECLARE_NOT_AGGREGATABLE( CCompdata )

BEGIN_COM_MAP( CCompdata )

	COM_INTERFACE_ENTRY( IComponentData )

    COM_INTERFACE_ENTRY( ISnapinAbout )

    COM_INTERFACE_ENTRY( IExtendContextMenu )

    COM_INTERFACE_ENTRY( ISnapinHelp )

END_COM_MAP()

// ICompdata
public:
    
    CCompdata();

    STDMETHOD( CompareObjects )( LPDATAOBJECT , LPDATAOBJECT );

	STDMETHOD( GetDisplayInfo )( LPSCOPEDATAITEM );

	STDMETHOD( QueryDataObject )( MMC_COOKIE , DATA_OBJECT_TYPES , LPDATAOBJECT * );

	STDMETHOD( Notify )( LPDATAOBJECT , MMC_NOTIFY_TYPE , LPARAM , LPARAM );

	STDMETHOD( CreateComponent )( LPCOMPONENT * );

	STDMETHOD( Initialize )( LPUNKNOWN );

    STDMETHOD( Destroy )();

    //IExtendContextMenu

    STDMETHOD( AddMenuItems )( LPDATAOBJECT , LPCONTEXTMENUCALLBACK , PLONG );

    STDMETHOD( Command )( LONG , LPDATAOBJECT );

    // ISnapinAbout
    
    STDMETHOD( GetSnapinDescription )( LPOLESTR * );

    STDMETHOD( GetProvider )( LPOLESTR * );

    STDMETHOD( GetSnapinVersion )( LPOLESTR *  );

    STDMETHOD( GetSnapinImage )( HICON * );

    STDMETHOD( GetStaticFolderImage )( HBITMAP * , HBITMAP *, HBITMAP *, COLORREF * );

    // ISnapinHelp

    STDMETHOD( GetHelpTopic )( LPOLESTR * );


    //IComponentdata helper methods

    BOOL ExpandScopeTree( LPDATAOBJECT , BOOL , HSCOPEITEM );

    BOOL InitDialogObjects( );

    BOOL BuildWizardPath( );

    BOOL FreeDialogObjects( );

    BOOL IsConnectionFolder( LPDATAOBJECT );

    BOOL IsSettingsFolder( LPDATAOBJECT );

    HRESULT BuildResultNodes( );

    //    BOOL GetResultNode( int , CResultNode** );

    CResultNode * GetResultNode( int );

    HRESULT InsertFolderItems( LPRESULTDATA );

    int GetServer( ICfgComp ** );

    BOOL OnDeleteItem( LPDATAOBJECT );

    HRESULT UpdateAllResultNodes( );
    
    HRESULT InsertSettingItems( LPRESULTDATA );

    HRESULT BuildSettingsNodes( );

    BOOL GetMaxTextLengthSetting( LPTSTR , PINT );

    BOOL GetMaxTextLengthAttribute( LPTSTR , PINT );
    
private:

    LPCONSOLE m_pConsole;

    LPCONSOLENAMESPACE m_pConsoleNameSpace;

    //LPDATAOBJECT m_pMainRoot;

	CBaseNode *m_pMainRoot[ 2 ];

    ICfgComp *m_pCfgcomp;



public:

	TCHAR m_tchMainFolderName[ 80 ];

    TCHAR m_tchSettingsFolderName[ 80 ];

    CDialogWizBase *m_pDlg[ MS_DIALOG_COUNT ];

    CArrayT< HPROPSHEETPAGE > m_hPages;

    CArrayT< CResultNode * > m_rnNodes;

    CArrayT< CSettingNode * > m_rgsNodes;//[ MAX_SETTINGS ];
   
};

#endif //__COMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\dataobj.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "stdafx.h"
#include "tscc.h"
#include "dataobj.h"
#include "resource.h"
#include "rnodes.h"

extern const GUID GUID_ResultNode;

static UINT s_cfInternal;// = RegisterClipboardFormat( TEXT( "TSCC" ) );   

static UINT s_cfDisplayName;// = RegisterClipboardFormat( CCF_DISPLAY_NAME );

static UINT s_cfNodeType;// = RegisterClipboardFormat( CCF_NODETYPE );

static UINT s_cfSnapinClsid;// = RegisterClipboardFormat( CCF_SNAPIN_CLASSID );

static UINT s_cfSZNodeType;// = RegisterClipboardFormat( CCF_SZNODETYPE );

static UINT s_cfSZWinstaName;


//--------------------------------------------------------------------------
// ctor
//--------------------------------------------------------------------------
CBaseNode::CBaseNode( )
{
    // The ndmgr gets the dataobj via IComponent and then calls release
    // so dataobj should have an implicit addref

    m_cref = 1;

    if( s_cfInternal == 0 )
    {
        s_cfInternal = RegisterClipboardFormat( TEXT( "TSCC" ) );   
    }

    if( s_cfSZWinstaName == 0 )
    {
        s_cfSZWinstaName = RegisterClipboardFormat( TEXT( "TSCC_WINSTANAME" ) );
    }

    if( s_cfDisplayName == 0 )
    {
        s_cfDisplayName = RegisterClipboardFormat( CCF_DISPLAY_NAME );
    }

    if( s_cfNodeType == 0 )
    {
        s_cfNodeType = RegisterClipboardFormat( CCF_NODETYPE );
    }

    if( s_cfSnapinClsid == 0 )
    {
        s_cfSnapinClsid = RegisterClipboardFormat( CCF_SNAPIN_CLASSID );
    }

    if( s_cfSZNodeType == 0 )
    {
        s_cfSZNodeType = RegisterClipboardFormat( CCF_SZNODETYPE );
    }

	m_nNodeType = 0;
	
}

//--------------------------------------------------------------------------
// Standard QI behavior
//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::QueryInterface( REFIID riid , PVOID *ppv )
{
    if( riid == IID_IUnknown )
    {
        *ppv = ( LPUNKNOWN )this;
    }
    else if( riid == IID_IDataObject )
    {
        *ppv = ( LPDATAOBJECT )this;
    }
    else
    {
        *ppv = NULL;

        return E_NOINTERFACE;
    }

    AddRef( );

    return S_OK;
}

//--------------------------------------------------------------------------
// Standard addref
//--------------------------------------------------------------------------
STDMETHODIMP_( ULONG )CBaseNode::AddRef(  )
{
    return InterlockedIncrement( ( LPLONG )&m_cref );
}

//--------------------------------------------------------------------------
// Same as addref no need for cs
//--------------------------------------------------------------------------
STDMETHODIMP_( ULONG )CBaseNode::Release( )
{
    if( InterlockedDecrement( ( LPLONG )&m_cref ) == 0 )
    {
         ODS( L"CBaseNode -- Releasing Dataobj\n" );

        delete this;

        return 0;
    }

    return m_cref;
}

//--------------------------------------------------------------------------
// Trust me ndmgr will call this with a fury
//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::GetDataHere( LPFORMATETC pF , LPSTGMEDIUM pMedium)
{
    HRESULT hr = DV_E_FORMATETC;
        
    const CLIPFORMAT cf = pF->cfFormat;
  
    IStream *pStream = NULL;
  
    pMedium->pUnkForRelease = NULL;
    

    hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );

    if( SUCCEEDED( hr ) ) 
    {
        if( cf == s_cfDisplayName )
        {
            TCHAR szDispname[ 128 ]; // = TEXT("Terminal Server Connection Configuration" );

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NAMESTRING , szDispname , SIZE_OF_BUFFER( szDispname ) ) );

            // Include null terminator 

            hr = pStream->Write( szDispname , SIZE_OF_BUFFER( szDispname )/* + sizeof( TCHAR )*/ , NULL );
        }
        else if( cf == s_cfInternal )
        {
            // The nodemgr will use this copy and pass it back to us in
            // functions such as ::Notify

            ODS( L"GetDataHere -- s_cfInternal used\n" );

            hr = pStream->Write( this , sizeof( CBaseNode ) , NULL );
        }
        else if( cf == s_cfSZWinstaName )
        {
            CResultNode *pNode = dynamic_cast< CResultNode *>( this );

            hr = E_FAIL; // generic failure

            // if we're talking about a connection base node get the winstation name

            ODS( L"GetDataHere -- current winstaname\n" );

            if( pNode != NULL )
            {
                LPTSTR szConName = pNode->GetConName( );

                hr = pStream->Write( szConName , lstrlen( szConName ) * sizeof( TCHAR ) + sizeof( TCHAR ) , NULL  );
            }
        }            
        else if( cf == s_cfNodeType )
        {
            const GUID *pGuid = NULL;

			if( GetNodeType( ) == MAIN_NODE )
			{
			    ODS( L"GetDataHere -- NodeType is MAIN_NODE\n" );

				pGuid = &GUID_MainNode;
			}
            else if( GetNodeType( ) == SETTINGS_NODE )
            {
                ODS( L"GetDataHere -- NodeType is SETTINGS_NODE\n" );

                pGuid = &GUID_SettingsNode;
            }
			else if( GetNodeType( ) == RESULT_NODE )
			{
				ODS( L"GetDataHere -- NodeType is RESULT_NODE\n" );

				pGuid = &GUID_ResultNode;
			}
			else
			{
				ODS( L"GetDataHere -- NodeType is userdefined\n ");

				pGuid = &GUID_ResultNode;
			}

            hr = pStream->Write( ( PVOID )pGuid , sizeof( GUID ) , NULL );
        }
		else if( cf == s_cfSZNodeType )
        {
            TCHAR szGUID[ 40 ];

			if( GetNodeType( ) == MAIN_NODE )
			{
				StringFromGUID2( GUID_MainNode , szGUID , SIZE_OF_BUFFER( szGUID ) );
			}
            else if( GetNodeType( ) == SETTINGS_NODE )
            {
                StringFromGUID2( GUID_SettingsNode , szGUID , SIZE_OF_BUFFER( szGUID ) );
            }                
			else if( GetNodeType( ) == RESULT_NODE )
			{
				StringFromGUID2( GUID_ResultNode , szGUID , SIZE_OF_BUFFER( szGUID ) );
			}
			else
			{
				StringFromGUID2( GUID_ResultNode , szGUID , SIZE_OF_BUFFER( szGUID ) );
			}

            // write nodetype in String format -- ok

            hr = pStream->Write( szGUID , sizeof( szGUID ) , NULL );
        }
        else if( cf == s_cfSnapinClsid )
        {
            // write out snapin's clsid

            hr = pStream->Write( &CLSID_Compdata , sizeof( CLSID ) , NULL );
        }

        pStream->Release( );

    } // CreateStreamOnHGlobal
     
    return hr;
   
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::GetData( LPFORMATETC , LPSTGMEDIUM )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::QueryGetData( LPFORMATETC )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::GetCanonicalFormatEtc( LPFORMATETC , LPFORMATETC )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::SetData( LPFORMATETC , LPSTGMEDIUM , BOOL )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::EnumFormatEtc( DWORD , LPENUMFORMATETC * )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::DAdvise( LPFORMATETC , ULONG , LPADVISESINK , PULONG )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::DUnadvise( DWORD )
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------
STDMETHODIMP CBaseNode::EnumDAdvise( LPENUMSTATDATA * )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\compdata.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// Compdata.cpp : Implementation of CCompdata
#include "stdafx.h"
#include <ntverp.h>
#include "tscc.h"
#include "dataobj.h"
#include "Compdata.h"
#include "comp.h"
#include <regapi.h>
#include "cfgbkend_i.c"

void ErrMessage( HWND hwndOwner , INT_PTR iResourceID );

extern void xxxErrMessage( HWND hwnd , INT_PTR nResMessageId , INT_PTR nResTitleId , UINT nFlags );

extern void TscAccessDeniedMsg( HWND hwnd );

extern void TscGeneralErrMsg( HWND hwnd );

void InitWarningThread( PVOID pvParam );

BOOL g_bAppSrvMode = FALSE;

#ifdef DBG

bool g_fDebug = false;

#endif

//extern "C" BOOL RegisterCheckListWndClass( void );
/////////////////////////////////////////////////////////////////////////////
// CCompdata

//----------------------------------------------------------------------------------------------------------
CCompdata::CCompdata( )
{
    m_pConsole = NULL;

    m_pConsoleNameSpace = NULL;

    m_pCfgcomp = NULL;

    m_pMainRoot[ 0 ] = NULL;

    m_pMainRoot[ 1 ] = NULL;    


}

//----------------------------------------------------------------------------------------------------------
// NDMGR is asking for us to return a view of our doc ( MFC talk )
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::CreateComponent( LPCOMPONENT * ppComponent)
{
    *ppComponent = ( LPCOMPONENT )new CComp( this );

    if( *ppComponent == NULL )
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
// Obtain interfaces used by for the scope pane
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::Initialize( LPUNKNOWN pUnk )
{
    HRESULT hr;

#ifdef DBG

    HKEY hKey;

    LONG lStatus;

    // To control debug spewage add/remove this regkey

    lStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
        L"Software\\Microsoft\\TSCC\\Debug",
        0,
        KEY_READ,
        &hKey );

    if( lStatus == ERROR_SUCCESS )
    {
        g_fDebug = true;

        RegCloseKey( hKey );
    }

#endif

    hr = pUnk->QueryInterface( IID_IConsole , ( LPVOID *)&m_pConsole );

    if( FAILED( hr ) )
    {
        return hr;
    }

    hr = pUnk->QueryInterface( IID_IConsoleNameSpace , ( LPVOID * )&m_pConsoleNameSpace );

    if( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = CoCreateInstance( CLSID_CfgComp , NULL , CLSCTX_INPROC_SERVER , IID_ICfgComp , ( LPVOID *)&m_pCfgcomp );

    if( FAILED( hr ) )
    {
        return hr;
    }

    hr = m_pCfgcomp->Initialize( );

    if( FAILED( hr ) )
    {
        return hr;
    }

    // RegisterCheckListWndClass( );
    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_MAINFOLDERNAME , m_tchMainFolderName , SIZE_OF_BUFFER( m_tchMainFolderName ) ) );

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_SETTINGSFOLDER , m_tchSettingsFolderName , SIZE_OF_BUFFER( m_tchSettingsFolderName ) ) );    

    hr = BuildSettingsNodes( );

    if( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = BuildResultNodes( );
     
    return hr;
}



//----------------------------------------------------------------------------------------------------------
// Dispatch to notification handlers
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::Notify( LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = NOERROR;

    switch( event )
    {
    case MMCN_RENAME:

        ODS( L"IComponentdata -- MMCN_RENAME\n");

        break;

    case MMCN_EXPAND:

        ODS( L"IComponentdata -- MMCN_EXPAND\n" );

        ExpandScopeTree( lpDataObject , ( BOOL ) arg , ( HSCOPEITEM )param );

        break;

    case MMCN_DELETE:

        ODS( L"IComponentdata -- MMCN_DELETE\n" );
        break;

    case MMCN_PROPERTY_CHANGE:

        ODS( L"IComponentdata -- MMCN_PROPERTY_CHANGE\n" );

        break;

    default:
        ODS( L"CCompdata::Notify - - event not defined!\n" );
        hr = E_NOTIMPL;
    }

    return hr;
}

//----------------------------------------------------------------------------------------------------------
// Prepareing for parent entry
BOOL CCompdata::ExpandScopeTree( LPDATAOBJECT pRoot , BOOL bExpand , HSCOPEITEM hConsole )
{   
    SCOPEDATAITEM sdi;

    if( !bExpand )
    {
        return FALSE;
    }

    CBaseNode *pNode = dynamic_cast< CBaseNode *>( pRoot );

    if( pNode == NULL )
    {
        return FALSE;
    }

    if( pNode->GetNodeType( ) != 0 ) // ROOT_NODE add subscope items
    {
        return FALSE;
    }

    // make sure we're not re-adding

    for( int i = 0 ; i < 2 ; i++ )
    {
        if( m_pMainRoot[ i ] != NULL )
        {
            return TRUE;
        }
    }

    for( i = 0 ; i < 2 ; i++ )
    {
        m_pMainRoot[ i ] = ( CBaseNode * )new CBaseNode;
        
        if( m_pMainRoot[ i ] == NULL )
        {
            ODS( L"TSCC: Scope node failed allocation\n" );

            return FALSE;
        }

        m_pMainRoot[ i ]->SetNodeType( i + MAIN_NODE );

        //m_pMainRoot[ i ]->AddRef( );
   
        ZeroMemory( &sdi , sizeof( SCOPEDATAITEM ) );

        sdi.mask = SDI_STR | SDI_PARAM | SDI_PARENT;
    
        sdi.displayname = MMC_CALLBACK;

        sdi.relativeID = hConsole;

        sdi.lParam = (LPARAM)m_pMainRoot[ i ];

        if( FAILED( m_pConsoleNameSpace->InsertItem( &sdi ) ) )
        {
            //sdi.ID;

            return FALSE;
        }
    }

    return TRUE;
}

//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::CompareObjects( LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{ 
    if( lpDataObjectA == lpDataObjectB )
    {
        return S_OK;
    }

    return E_FAIL;
}

//----------------------------------------------------------------------------------------------------------
// Not yet finished
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetDisplayInfo( LPSCOPEDATAITEM pItem)
{
    CBaseNode *pNode = ( CBaseNode * )pItem->lParam;

    if( pItem->mask & SDI_STR )
    {
        if( pNode->GetNodeType( ) == MAIN_NODE )
        {
            //pItem->displayname = ( LPOLESTR )L"Connections"; 
            
            pItem->displayname = ( LPOLESTR )m_tchMainFolderName;
        }
        else if( pNode->GetNodeType( ) == SETTINGS_NODE )
        {            
            // pItem->displayname = ( LPOLESTR )L"Server Settings";

            pItem->displayname = ( LPOLESTR )m_tchSettingsFolderName;
        }
    }
    
    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::QueryDataObject( MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT * ppDataObject)
{
    *ppDataObject = NULL;

    switch( type )
    {

    case CCT_SCOPE:
    case CCT_SNAPIN_MANAGER:

        if( cookie == 0 )
        {
            *ppDataObject = ( LPDATAOBJECT )new CBaseNode( );
        }
        else
        {
            *ppDataObject = ( LPDATAOBJECT )cookie;

            // this is the only scopenode keep this one alive

            ( ( LPDATAOBJECT )*ppDataObject)->AddRef( );
        }

        break;

    case CCT_RESULT:
        
        // here we can cast from cookie for each node

        break;

    case CCT_UNINITIALIZED:

        // ok thanks

        break;

    }
    
    return ( *ppDataObject == NULL ) ? E_FAIL : S_OK ;
    
}

//----------------------------------------------------------------------------------------------------------
// Free all used interfaces
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::Destroy( )
{
    if( m_pConsole != NULL )
    {
        m_pConsole->Release( );
    }

    if( m_pConsoleNameSpace != NULL )
    {
        m_pConsoleNameSpace->Release( );
    }

    if( m_pMainRoot[ 0 ] != NULL )
    {   
    
        DWORD dwRef = m_pMainRoot[ 0 ]->Release( );
        
        DBGMSG( TEXT("Ref count for main node ended in %d\n" ) , dwRef );

    }

    if( m_pMainRoot[ 1 ] != NULL )
    {
        DWORD dwRef = m_pMainRoot[ 1 ]->Release( );
        
        DBGMSG( TEXT("Ref count for settings node ended in %d\n" ) , dwRef );
    }

    
    int items = m_rnNodes.GetSize( );

    for( int idx = 0 ; idx < items; ++idx )
    {
        CResultNode *pNode = *m_rnNodes.GetAt( idx );

        if( pNode != NULL )
        {
            pNode->FreeServer( );

            pNode->Release( );
        }
    }

    m_rnNodes.DeleteArray( );

    items = m_rgsNodes.GetSize( );

    for( idx = 0 ; idx < items; idx++ )
    {
        CSettingNode *pNode = *m_rgsNodes.GetAt( idx );

        if( pNode != NULL )
        {
            pNode->Release( );
        }
    }    

    m_rgsNodes.DeleteArray( );
    
    if( m_pCfgcomp != NULL )
    {
        m_pCfgcomp->Release( );
    }

    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
// Places our menu items as spec'd
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::AddMenuItems( LPDATAOBJECT pNode , LPCONTEXTMENUCALLBACK pCtxMenu , PLONG plInsertion )
{
    TCHAR tchBuffer1[ 128 ];

    TCHAR tchBuffer2[ 128 ];

    ASSERT( pNode != NULL );

    ASSERT( pCtxMenu != NULL );

    ASSERT( plInsertion != NULL );

    if( pNode != m_pMainRoot[ 0 ] )
    {
        return S_FALSE;
    }

    CONTEXTMENUITEM ctxmi;

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_CTXM_NAME , tchBuffer1 , SIZE_OF_BUFFER( tchBuffer1 ) ) );

    ctxmi.strName = tchBuffer1;

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_CTXM_STATUS , tchBuffer2 , SIZE_OF_BUFFER( tchBuffer2 ) ) );

    ctxmi.strStatusBarText = tchBuffer2;

    ctxmi.lCommandID = IDM_CREATECON;

    ctxmi.lInsertionPointID =  CCM_INSERTIONPOINTID_PRIMARY_TOP ;

    ctxmi.fFlags = 0;

    ctxmi.fSpecialFlags = 0;

    *plInsertion |= CCM_INSERTIONALLOWED_TOP;

    //VERIFY_S( S_OK , pCtxMenu->AddItem( &ctxmi ) );

    //ctxmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;

    return pCtxMenu->AddItem( &ctxmi );

}

//----------------------------------------------------------------------------------------------------------
// This is where the wizard will kick off
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::Command( LONG lCommand , LPDATAOBJECT pNode )
{
    HWND hMain;

    if( pNode != m_pMainRoot[ 0 ] )
    {
        return S_FALSE;
    }

    if( lCommand == IDM_CREATECON )
    {
        // insure that no other connections are being edited

        for( int i = 0 ; i < m_rnNodes.GetSize( ); i++ )
        {
            CResultNode *pNd = *m_rnNodes.GetAt( i );

            if( pNd != NULL )
            {
                if( pNd->m_bEditMode )
                {   
                    if( FAILED( m_pConsole->GetMainWindow( &hMain ) ) )
                    {
                        hMain = NULL;
                    }
                
                    xxxErrMessage( hMain , IDS_ERR_INEDITMODE , IDS_WARN_TITLE , MB_OK | MB_ICONWARNING );
                    
                    return E_FAIL;
                }
            }
        }

        // check for admin rights.
        BOOL bReadOnly;

        m_pCfgcomp->IsSessionReadOnly( &bReadOnly );

        if( bReadOnly )
        {
           if( FAILED( m_pConsole->GetMainWindow( &hMain ) ) )
           {
               hMain = NULL;
           }
           // report access denied
           
           TscAccessDeniedMsg( hMain );

            return S_FALSE;
        }

        if( !InitDialogObjects( ) )
        {
            return E_FAIL;
        }

        BuildWizardPath( );

        FreeDialogObjects( );
    }

    m_pConsole->UpdateAllViews( ( LPDATAOBJECT )m_rnNodes.GetAt( 0 ) , 0 , 0 );

    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
// Try to allocate
BOOL CCompdata::InitDialogObjects( )
{    
    try
    {
        m_pDlg[ 0 ] = ( CDialogWizBase * )new CWelcome( );

        m_pDlg[ 1 ] = ( CDialogWizBase * )new CConType( this );

        m_pDlg[ 2 ] = ( CDialogWizBase * )new CSecurity( this );

        // m_pDlg[ 3 ] = ( CDialogWizBase * )new CTimeout( );

        // m_pDlg[ 4 ] = ( CDialogWizBase * )new CAutoLogon( );

        // m_pDlg[ 5 ] = ( CDialogWizBase * )new CInitProg( );

        m_pDlg[ 3 ] = ( CDialogWizBase * )new CRemotectrl( );

        // m_pDlg[ 7 ] = ( CDialogWizBase * )new CWallPaper( );

        m_pDlg[ 4 ] = ( CDialogWizBase * )new CConProp( this );

        m_pDlg[ 5 ] = ( CDialogWizBase * )new CLan( this );

        m_pDlg[ 6 ] = ( CDialogWizBase * )new CAsync( this );

        m_pDlg[ 7 ] = ( CDialogWizBase * )new CFin( this );
    }
    catch(...)
    {
        return FALSE;
    }

    return TRUE;
}

//----------------------------------------------------------------------------------------------------------
BOOL CCompdata::BuildWizardPath( )
{
    // build up ms propsheetheader

    PROPSHEETPAGE psp;

    PROPSHEETHEADER psh;

    for( int idx = 0 ;  idx < MS_DIALOG_COUNT ; ++idx )
    {
        if( m_pDlg[ idx ] != NULL )
        {
            m_pDlg[ idx ]->GetPropertySheetPage( psp );

            m_hPages.Insert( CreatePropertySheetPage( &psp ) );
        }
    }

    // obtain clsid of IExtendwizard object

    // forward IWizardProvider to object

    // add last page CFin

    ZeroMemory( &psh , sizeof( PROPSHEETHEADER ) );

    psh.dwSize = sizeof( PROPSHEETHEADER );

    psh.hInstance = _Module.GetModuleInstance( );

    if( m_pConsole != NULL )
    {
        m_pConsole->GetMainWindow( &psh.hwndParent );
    }

    //psh.pszCaption = MAKEINTRESOURCE( IDS_WIZARDTITLE ); //NULL

    psh.dwFlags =  PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER ;

    psh.pszbmWatermark = MAKEINTRESOURCE( IDB_TSCC_LOGO );

    psh.pszbmHeader    = MAKEINTRESOURCE( IDB_TSCC_ICON );

    psh.phpage         = m_hPages.ExposeArray( );

    psh.nStartPage     = 0;

    psh.nPages         = m_hPages.GetSize( );

    PropertySheet( &psh );
   
    return TRUE;
}

//----------------------------------------------------------------------------------------------------------
BOOL CCompdata::FreeDialogObjects( )
{
    for( int idx = 0 ; idx < MS_DIALOG_COUNT ; ++idx )
    {
        if( m_pDlg[ idx ] != NULL )
        {
            delete m_pDlg[ idx ];
        }
    }

    m_hPages.DeleteArray( );

    return TRUE;
}

//----------------------------------------------------------------------------------------------------------
BOOL CCompdata::IsConnectionFolder( LPDATAOBJECT pObject )
{
    if( SUCCEEDED( CompareObjects( pObject , m_pMainRoot[ 0 ] ) ) )
    {
        return TRUE;
    }
 
    return FALSE;
}

//----------------------------------------------------------------------------------------------------------
BOOL CCompdata::IsSettingsFolder( LPDATAOBJECT pObject )
{
    if( SUCCEEDED( CompareObjects( pObject , m_pMainRoot[ 1 ] ) ) )
    {
        return TRUE;
    }

    return FALSE;
}


//----------------------------------------------------------------------------------------------------------
HRESULT CCompdata::UpdateAllResultNodes( )
{
    HWND hMain;
    
    if( FAILED( m_pConsole->GetMainWindow( &hMain ) ) )
    {
        hMain = NULL;
    }

    int items = m_rnNodes.GetSize( );

    for( int idx = 0 ; idx < items; ++idx )
    {
        CResultNode *pNode = *m_rnNodes.GetAt( idx );

        if( pNode != NULL )
        {
            if( pNode->m_bEditMode )
            {
                 // ErrMessage( NULL , IDS_ERR_INEDITMODE );
                
                xxxErrMessage( hMain , IDS_ERR_INEDITMODE , IDS_WARN_TITLE , MB_OK | MB_ICONWARNING );

                 return E_FAIL;
            }
        }
    }


    HRESULT hr = m_pCfgcomp->Refresh( );
    
    if( FAILED( hr ) )
    {
        ODS( L"m_pCfgcomp->Refresh - failed\n" );

        if( hr == E_ACCESSDENIED )
        {
            TscAccessDeniedMsg( hMain );
        }
       