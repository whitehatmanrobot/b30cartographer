er:
	if (FAILED(hr)) { 
	    WCHAR * wszError;
	    HRESULT hr2=GetSystemErrorString(hr, &wszError);
	    if (FAILED(hr2)) {
		_IgnoreError(hr2, "GetSystemErrorString");
	    } else {
		DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_REMOTE_INSTALL_ERROR, *wszIter, wszError); 
		LocalFree(wszError);
	    }
	} else { 
	    DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_REMOTE_INSTALL_SUCCESS, *wszIter); 
	}

	if (NULL != hKeySvcCli) { 
	    RKeyCloseKeyService(hKeySvcCli, NULL); 
	    hKeySvcCli = NULL;
	}
    }

    hr = S_OK; 
 error:
    if (NULL != hToken) { 
	CloseHandle(hToken); 
    }
    if (bImpersonated) { 
	RevertToSelf();
    }
    if (NULL != blobPFX.pb) { 
	MyUnmapFile(blobPFX.pb); 
    }
    if (NULL != hKeySvcCli) { 
	RKeyCloseKeyService(hKeySvcCli, NULL /*reserved*/); 
    }
    if (NULL != szMachineName) { 
	LocalFree(szMachineName); 
    } 
    if (bFreeServerList) { 
	for (StringIter wszIter = vServers.begin(); wszIter != vServers.end(); wszIter++) { 
	    LocalFree(*wszIter);
	}
    }
    if (FAILED(hr) && E_INVALIDARG!=hr) {
        WCHAR * wszError;
        HRESULT hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_ERROR_GENERAL, wszError); 
            LocalFree(wszError);
        }
    }
    return hr; 
}



//--------------------------------------------------------------------
extern "C" int WINAPI WinMain
(HINSTANCE   hinstExe, 
 HINSTANCE   hinstExePrev, 
 LPSTR       pszCommandLine,
 int         nCommandShow)
{
    g_hThisModule = hinstExe; 

    HRESULT hr;
    CmdArgs caArgs;
    int      nArgs     = 0; 
    WCHAR  **rgwszArgs = NULL; 

    hr = InitializeConsoleOutput(); 
    _JumpIfError(hr, error, "InitializeConsoleOutput"); 

    rgwszArgs = CommandLineToArgvW(GetCommandLineW(), &nArgs);
    if (nArgs < 0 || NULL == rgwszArgs) {
        _JumpError(HRESULT_FROM_WIN32(GetLastError()), error, "GetCommandLineW"); 
    }

    // analyze args
    caArgs.nArgs=nArgs;
    caArgs.nNextArg=1;
    caArgs.rgwszArgs=rgwszArgs;

    // check for help command
    if (true==CheckNextArg(&caArgs, L"?", NULL) || caArgs.nNextArg==caArgs.nArgs) {
        PrintHelp();

    // Default to the "install" command.  
    } else {
	hr = RemoteInstall(&caArgs); 
	_JumpIfError(hr, error, "RemoteInstall"); 
    }

    

    hr=S_OK;
error:
    return hr;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\trpfx\printlib.cpp ===
//--------------------------------------------------------------------
// DebugWPrintf - implementation
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 11-11-2001
//
// Various print routines
//

#include "pch.h"

typedef BOOLEAN (WINAPI * SetThreadUILanguageFunc)(DWORD dwReserved);

extern HINSTANCE                 g_hThisModule;  
       HANDLE                    g_hStdout                 = NULL; 
       BOOL                      g_bSetLocale              = FALSE; 
       SetThreadUILanguageFunc   g_pfnSetThreadUILanguage  = NULL; 


//--------------------------------------------------------------------
void DebugWPrintf_(const WCHAR * wszFormat, ...)
{
    WCHAR wszBuf[1024];
    va_list vlArgs;
    va_start(vlArgs, wszFormat);
    _vsnwprintf(wszBuf, 1024, wszFormat, vlArgs);
    va_end(vlArgs);

    OutputDebugStringW(wszBuf);
}

//--------------------------------------------------------------------
HRESULT MySetThreadUILanguage(DWORD dwParam)
{
    HMODULE  hKernel32Dll  = NULL;
    HRESULT  hr; 

    if (NULL == g_pfnSetThreadUILanguage) { 
	hKernel32Dll = LoadLibraryW(L"kernel32.dll");
	if (NULL == hKernel32Dll) { 
	    _JumpLastError(hr, error, "LoadLibraryW"); 
	}

	g_pfnSetThreadUILanguage = (SetThreadUILanguageFunc)GetProcAddress(hKernel32Dll, "SetThreadUILanguage");
	if (NULL == g_pfnSetThreadUILanguage) { 
	    _JumpLastError(hr, error, "GetProcAddress"); 
	}
    }

    g_pfnSetThreadUILanguage(dwParam);

    hr = S_OK; 
 error:
    if (NULL != hKernel32Dll) { 
	FreeLibrary(hKernel32Dll); 
    }
    return hr; 
}

//--------------------------------------------------------------------
HRESULT InitializeConsoleOutput() { 
    HRESULT hr; 

    g_hStdout = GetStdHandle(STD_OUTPUT_HANDLE); 
    if (INVALID_HANDLE_VALUE == g_hStdout) { 
        _JumpLastError(hr, error, "GetStdHandle"); 
    }

    hr = MySetThreadUILanguage(0); 
    _JumpIfError(hr, error, "MySetThreadUILanguage"); 

    hr = S_OK; 
 error:    
    return S_OK; 
}

//--------------------------------------------------------------------
BOOL FileIsConsole(
    HANDLE fp
    )
{
    DWORD htype;

    htype = GetFileType(fp);
    htype &= ~FILE_TYPE_REMOTE;
    return htype == FILE_TYPE_CHAR;
}

//--------------------------------------------------------------------
HRESULT MyWriteConsole(
    HANDLE  fp,
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    )
{
    HRESULT hr;
    LPSTR  lpAnsiBuffer = NULL;

    //
    // Jump through hoops for output because:
    //
    //    1.  printf() family chokes on international output (stops
    //        printing when it hits an unrecognized character)
    //
    //    2.  WriteConsole() works great on international output but
    //        fails if the handle has been redirected (i.e., when the
    //        output is piped to a file)
    //
    //    3.  WriteFile() works great when output is piped to a file
    //        but only knows about bytes, so Unicode characters are
    //        printed as two Ansi characters.
    //

    if (FileIsConsole(fp))
    {
	hr = WriteConsole(fp, lpBuffer, cchBuffer, &cchBuffer, NULL);
        _JumpIfError(hr, error, "WriteConsole");
    }
    else
    {
	lpAnsiBuffer = (LPSTR) LocalAlloc(LPTR, cchBuffer * sizeof(WCHAR));
	_JumpIfOutOfMemory(hr, error, lpAnsiBuffer); 

	cchBuffer = WideCharToMultiByte(CP_OEMCP,
					0,
					lpBuffer,
					cchBuffer,
					lpAnsiBuffer,
					cchBuffer * sizeof(WCHAR),
					NULL,
					NULL);
	
	if (cchBuffer != 0)
        {
	    if (!WriteFile(fp, lpAnsiBuffer, cchBuffer, &cchBuffer, NULL))
            {
		hr = GetLastError();
		_JumpError(hr, error, "WriteFile");
	    }
	}
	else
        {
	    hr = GetLastError();
	    _JumpError(hr, error, "WideCharToMultiByte");
	}
    }

    hr = S_OK; 
error:
    if (NULL != lpAnsiBuffer)
        LocalFree(lpAnsiBuffer);

    return hr;
}


//--------------------------------------------------------------------
VOID DisplayMsg(DWORD dwSource, DWORD dwMsgId, ... )
{
    DWORD    dwBytesWritten;
    DWORD    dwLen;
    LPWSTR   pwszDisplayBuffer  = NULL;
    va_list  ap;

    va_start(ap, dwMsgId);

    dwLen = FormatMessageW(dwSource | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                           NULL, 
                           dwMsgId, 
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           (LPWSTR)&pwszDisplayBuffer, 
                           0, 
                           &ap);

    if (dwLen && pwszDisplayBuffer) {
        MyWriteConsole(g_hStdout, pwszDisplayBuffer, dwLen);

    }

    if (NULL != pwszDisplayBuffer) { LocalFree(pwszDisplayBuffer); }

    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\trpfx\utils.cpp ===
//--------------------------------------------------------------------
// utils - implementation
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 11-11-2001
//
// Various utility functions


#include "pch.h"

//--------------------------------------------------------------------------------
//
// File Manipulation Utility Functions
//
//--------------------------------------------------------------------------------

//---------------------------------------------------------------------------------
HRESULT MyMapFile(LPWSTR wszFileName, LPBYTE *ppbFile, DWORD *pcbFile)
{
    BYTE           *pbFile        = NULL; 
    HANDLE          hFile         = NULL; 
    HRESULT         hr; 
    HANDLE          hFileMapping  = NULL; 
    LARGE_INTEGER   liFileSize; 

    hFile = CreateFile(wszFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); 
    if (INVALID_HANDLE_VALUE == hFile) { 
	_JumpLastError(hr, error, "CreateFile"); 
    }

    if (!GetFileSizeEx(hFile, &liFileSize)) { 
	_JumpLastError(hr, error, "GetFileSizeEx"); 
    }

    if (0 != liFileSize.HighPart) { 
	hr = HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES); 
	_JumpError(hr, error, "MyMapFile: file too large"); 
    }

    hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL); 
    if (NULL == hFileMapping) { 
	_JumpLastError(hr, error, "CreateFileMapping"); 
    }

    pbFile = (BYTE *)MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, liFileSize.LowPart); 
    if (NULL == pbFile) { 
	_JumpLastError(hr, error, "MapViewOfFile"); 
    }

    // Success!  Assign out params:
    *ppbFile = pbFile; 
    *pcbFile = liFileSize.LowPart; 
    hr = S_OK; 
 error:
    if(hFile) { 
	CloseHandle(hFile);
    }
    if(hFileMapping) {
	CloseHandle(hFileMapping);
    }
    return hr;
}


//---------------------------------------------------------------------------------
HRESULT MyUnmapFile(LPCVOID pvBaseAddress) { 
    HRESULT hr; 

    if (!UnmapViewOfFile(pvBaseAddress)) { 
	_JumpLastError(hr, error, "UnmapViewOfFile"); 
    }

    hr = S_OK; 
 error:
    return hr; 
}


//--------------------------------------------------------------------------------
//
// String Manipulation Utility Functions
//
//--------------------------------------------------------------------------------


//--------------------------------------------------------------------------
void InitKeysvcUnicodeString(PKEYSVC_UNICODE_STRING pUnicodeString, LPCWSTR wszString) {
    pUnicodeString->Length         = wcslen(wszString) * sizeof(WCHAR);
    pUnicodeString->MaximumLength  = pUnicodeString->Length + sizeof(WCHAR);
    pUnicodeString->Buffer         = (USHORT *)wszString;
}

//--------------------------------------------------------------------------
LPSTR MBFromWide(LPCWSTR wsz) {
    LPSTR   sz = NULL;
    DWORD   cb = 0;

    _MyAssert(NULL != wsz);
    if(NULL == wsz) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    if( (cb = WideCharToMultiByte(0, 0, wsz, -1, NULL, 0, NULL, NULL)) == 0   ||
        (sz = (char *) LocalAlloc(LPTR, cb)) == NULL  ||
        (cb = WideCharToMultiByte(0, 0, wsz, -1, sz, cb, NULL, NULL)) == 0 ) {

        if(GetLastError() == ERROR_SUCCESS)
            SetLastError(ERROR_OUTOFMEMORY);

        return(NULL);
    }

    return(sz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tsca\tsca.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tsca.cpp
//
//  Contents:   Simplified Cryptographic API (SCA) Tests
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    08-Mar-96   philh   created
//              20-Aug-96   jeffspel name changes
//              
//--------------------------------------------------------------------------

#define CMS_PKCS7       1

#ifdef CMS_PKCS7
#define CRYPT_SIGN_MESSAGE_PARA_HAS_CMS_FIELDS      1
#endif  // CMS_PKCS7

#define CRYPT_DECRYPT_MESSAGE_PARA_HAS_EXTRA_FIELDS 1

#include <windows.h>
#include <assert.h>
#include "wincrypt.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>
#include <memory.h>
#include <time.h>
#include <malloc.h>
#include <dbgdef.h>

// #define ENABLE_SCA_STREAM_TEST              1
#define SCA_STREAM_ENABLE_FLAG              0x80000000
#define SCA_INDEFINITE_STREAM_FLAG          0x40000000

//+-------------------------------------------------------------------------
// Parameters, data used to encode the messages.
//--------------------------------------------------------------------------
static DWORD dwCryptProvType = PROV_RSA_FULL;
static DWORD dwPubKeyBitLen = 0;
static LPCSTR pszHashName = "md5";
static LPCSTR pszEncryptName = "rc2";
static DWORD dwEncryptBitLen = 0;
static BOOL fEncryptIV = FALSE;
static BOOL fVerbose = FALSE;

static HCERTSTORE hCertStore = 0;
static LPSTR pszMsgCertFilename = NULL;
static LPSTR pszMsgEncodedFilename = NULL;
static LPSTR pszReadEncodedFilename = NULL;
static BOOL fDetached = FALSE;
static DWORD dwMsgEncodingType = PKCS_7_ASN_ENCODING;
static DWORD dwCertEncodingType = X509_ASN_ENCODING;
static DWORD dwSignKeySpec = AT_SIGNATURE;
static BOOL fInnerSigned = FALSE;
static LPSTR pszCertNameFindStr = NULL;

#ifdef ENABLE_SCA_STREAM_TEST
static BOOL fStream = FALSE;
static BOOL fIndefiniteStream = FALSE;
#endif

BOOL fNoRecipients = FALSE;
BOOL fAllRecipients = FALSE;
BOOL fDhRecipient = FALSE;
BOOL fEncapsulatedContent = FALSE;
#ifdef CMS_PKCS7
BOOL fSP3Encrypt = FALSE;
BOOL fDefaultGetSigner = FALSE;
BOOL fRecipientKeyId = FALSE;
BOOL fSignerKeyId = FALSE;
BOOL fHashEncryptionAlgorithm = FALSE;

BOOL fNoSalt = FALSE;
#define MAX_SALT_LEN    11
BYTE rgbSalt[MAX_SALT_LEN];
CMSG_RC4_AUX_INFO RC4AuxInfo;

BOOL fSilentKey = FALSE;

#endif


#define MAX_MSG_CERT        30
#define MAX_MSG_CRL         30
#define MAX_RECIPIENT_CERT  50

#define MAX_HASH_LEN      20

static LPCSTR pszMsgContent = "Message Content Message Content";
static LPCSTR pszMsgContent2 = "Second Message Content";
static LPCSTR pszMsgContent3 = "Third Message Content";
static const BYTE *pbToBeEncoded = (const BYTE *) pszMsgContent;
static DWORD cbToBeEncoded = strlen(pszMsgContent) + 1;

#define DETACHED_CONTENT_CNT    3
static const BYTE *rgpbDetachedToBeEncoded[DETACHED_CONTENT_CNT] = {
    (const BYTE *) pszMsgContent,
    (const BYTE *) pszMsgContent2,
    (const BYTE *) pszMsgContent3
};
static DWORD rgcbDetachedToBeEncoded[DETACHED_CONTENT_CNT] = {
    strlen(pszMsgContent) + 1,
    strlen(pszMsgContent2) + 1,
    strlen(pszMsgContent3) + 1
};

#define DELTA_LESS_LENGTH   8
#define DELTA_MORE_LENGTH   32

static CMSG_RC2_AUX_INFO RC2AuxInfo;

BOOL fAuthAttr = FALSE;
#define AUTH_ATTR_COUNT     2
BYTE    attr1[] = {0x04, 0x0c, 'A','t','t','r','i','b','u','t','e',' ','1',0};
BYTE    attr2[] = {0x04, 0x0c, 'A','t','t','r','i','b','u','t','e',' ','2',0};
BYTE    attr3[] = {0x04, 0x0c, 'A','t','t','r','i','b','u','t','e',' ','3',0};
CRYPT_ATTR_BLOB rgatrblob1[] = {
    { sizeof( attr1), attr1}
};
CRYPT_ATTR_BLOB rgatrblob2[] = {
    { sizeof( attr2), attr2},
    { sizeof( attr3), attr3}
};
CRYPT_ATTRIBUTE rgAuthAttr[AUTH_ATTR_COUNT] = {
    {"1.2.3.5.7",  1, rgatrblob1},
    {"1.2.3.5.11", 2, rgatrblob2}
};

static inline IsDSSProv(
    IN DWORD dwProvType
    )
{
    return (PROV_DSS == dwProvType || PROV_DSS_DH == dwProvType);
}


//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
static void PrintError(LPCSTR pszMsg)
{
    printf("%s\n", pszMsg);
}
static void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

static void CheckLessLength(
    LPCSTR pszMsg,
    BOOL fResult,
    DWORD cbActual,
    DWORD cbExpected
    )
{
    if (fResult)
        printf("%s failed => expected ERROR_MORE_DATA\n", pszMsg);
    else {
        DWORD dwErr = GetLastError();
        if (fVerbose)
            printf("%s with less length got expected error => 0x%x (%d)\n",
                pszMsg, dwErr, dwErr);
        if (ERROR_MORE_DATA != dwErr)
            printf("%s failed => LastError = %d, expected = %d\n",
                pszMsg, dwErr, ERROR_MORE_DATA);
    }

    if (cbActual != cbExpected)
        printf("%s failed => ", pszMsg);
    if (fVerbose || cbActual != cbExpected)
        printf("cbData = %d, expected = %d\n", cbActual, cbExpected);
}

static void CheckMoreLength(
    LPCSTR pszMsg,
    DWORD cbActual,
    DWORD cbExpected
    )
{
    if (cbActual != cbExpected) {
        printf("%s failed => ", pszMsg);
        printf("cbData = %d, expected = %d\n", cbActual, cbExpected);
    }
}

//+-------------------------------------------------------------------------
//  Test allocation and free routines
//--------------------------------------------------------------------------
static void *TestAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        PrintLastError("TestAlloc");
    }
    return pv;
}
static void TestFree(
    IN void *pv
    )
{
    if (pv)
        free(pv);
}

static BOOL AllocAndEncodeObject(
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    fResult = CryptEncodeObject(
            dwCertEncodingType,
            lpszStructType,
            pvStructInfo,
            NULL,           // pbEncoded
            &cbEncoded);
    if (!fResult || cbEncoded == 0) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptEncodeObject(StructType: %d, cbEncoded == 0)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptEncodeObject(StructType: %s, cbEncoded == 0)",
                lpszStructType);
        PrintLastError("");
        goto ErrorReturn;
    }

    if (NULL == (pbEncoded = (BYTE *) TestAlloc(cbEncoded)))
        goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            lpszStructType,
            pvStructInfo,
            pbEncoded,
            &cbEncoded
            )) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptEncodeObject(StructType: %d)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptEncodeObject(StructType: %s)",
                lpszStructType);
        PrintLastError("");
        goto ErrorReturn;
    }
    fResult = TRUE;

CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

static PCCRYPT_OID_INFO GetOIDInfo(LPCSTR pszName, DWORD dwGroupId = 0)
{
    WCHAR wszName[256];
    PCCRYPT_OID_INFO pInfo;

    MultiByteToWideChar(
        CP_ACP,
        0,                      // dwFlags
        pszName,
        -1,                     // null terminated
        wszName,
        sizeof(wszName) / sizeof(wszName[0]));

    return CryptFindOIDInfo(
        CRYPT_OID_INFO_NAME_KEY,
        (void *) wszName,
        dwGroupId
        );
}

static LPCSTR GetOID(LPCSTR pszName, DWORD dwGroupId = 0)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = GetOIDInfo(pszName, dwGroupId))
        return pInfo->pszOID;
    else
        return NULL;
}

static ALG_ID GetAlgid(LPCSTR pszName, DWORD dwGroupId = 0)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = GetOIDInfo(pszName, dwGroupId))
        return pInfo->Algid;
    else
        return 0;
}

#define CROW 16
static void PrintBytes(LPCSTR pszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;

    while (cbSize > 0)
    {
        printf("%s", pszHdr);
        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            printf(" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                printf("%c", pb[i]);
            else
                printf(".");
        pb += cb;
        printf("'\n");
    }
}

//+-------------------------------------------------------------------------
//  Allocate and read an encoded DER blob from a file
//--------------------------------------------------------------------------
static BOOL ReadDERFromFile(
	LPCSTR	pszFileName,
	PBYTE	*ppbDER,
	PDWORD	pcbDER
	)
{
	BOOL		fRet;
    HANDLE      hFile = 0;
	PBYTE		pbDER = NULL;
    DWORD       cbDER;
    DWORD       cbRead;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile( pszFileName, GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL))) {
        printf( "can't open %s\n", pszFileName);
        goto ErrorReturn;
    }

    cbDER = GetFileSize( hFile, NULL);
    if (cbDER == 0) {
        printf( "empty file %s\n", pszFileName);
        goto ErrorReturn;
    }
    if (NULL == (pbDER = (PBYTE)TestAlloc(cbDER))) {
        printf( "can't alloc %d bytes\n", cbDER);
        goto ErrorReturn;
    }
    if (!ReadFile( hFile, pbDER, cbDER, &cbRead, NULL) ||
            (cbRead != cbDER)) {
        printf( "can't read %s\n", pszFileName);
        goto ErrorReturn;
    }

	*ppbDER = pbDER;
	*pcbDER = cbDER;
	fRet = TRUE;
CommonReturn:
    if (hFile)
        CloseHandle(hFile);
	return fRet;
ErrorReturn:
    if (pbDER)
        TestFree(pbDER);
	*ppbDER = NULL;
	*pcbDER = 0;
	fRet = FALSE;
	goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
static BOOL WriteDERToFile(
	LPCSTR	pszFileName,
	PBYTE	pbDER,
	DWORD	cbDER
	)
{
    BOOL fResult;

    // Write the Encoded Blob to the file
    HANDLE hFile;
    hFile = CreateFile(pszFileName,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        fResult = FALSE;
        PrintLastError("WriteDERToFile::CreateFile");
    } else {
        DWORD dwBytesWritten;
        if (!(fResult = WriteFile(
                hFile,
                pbDER,
                cbDER,
                &dwBytesWritten,
                NULL            // lpOverlapped
                )))
            PrintLastError("WriteDERToFile::WriteFile");
        CloseHandle(hFile);
    }
    return fResult;
}

static HCERTSTORE OpenStore(LPCSTR pszStoreFilename)
{
    HCERTSTORE hStore;
    HANDLE hFile = 0;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile(pszStoreFilename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL))) {
        printf( "can't open %s\n", pszStoreFilename);

        hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            dwCertEncodingType,
            0,                      // hProv
            0,                      // dwFlags
            NULL                    // pvPara
            );
    } else {
        hStore = CertOpenStore(
            CERT_STORE_PROV_FILE,
            dwCertEncodingType,
            0,                      // hProv
            0,                      // dwFlags
            hFile
            );
        CloseHandle(hFile);
    }

    if (hStore == NULL)
        PrintLastError("CertOpenStore");
    return hStore;
}

static void SaveStore(HCERTSTORE hStore, LPCSTR pszSaveFilename)
{
    HANDLE hFile;
    hFile = CreateFile(pszSaveFilename,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        printf( "can't open %s\n", pszSaveFilename);
        PrintLastError("CloseStore::CreateFile");
    } else {
        if (!CertSaveStore(
                hStore,
                0,                          // dwEncodingType,
                CERT_STORE_SAVE_AS_STORE,
                CERT_STORE_SAVE_TO_FILE,
                (void *) hFile,
                0                           // dwFlags
                ))
            PrintLastError("CertSaveStore");
        CloseHandle(hFile);
    }
}

static void DisplayCert(PCCERT_CONTEXT pCert);
static void DisplayCrl(PCCRL_CONTEXT pCrl);

//+-------------------------------------------------------------------------
//  Functions for initializing and freeing SCA parameters
//--------------------------------------------------------------------------
static BOOL InitSignPara(OUT PCRYPT_SIGN_MESSAGE_PARA pPara);
static void FreeSignPara(IN PCRYPT_SIGN_MESSAGE_PARA pPara);
static BOOL InitVerifyPara(OUT PCRYPT_VERIFY_MESSAGE_PARA pPara);
static void FreeVerifyPara(IN PCRYPT_VERIFY_MESSAGE_PARA pPara);
static BOOL InitEncryptPara(
    OUT PCRYPT_ENCRYPT_MESSAGE_PARA pPara,
    OUT DWORD *pcRecipientCert,
    OUT PCCERT_CONTEXT **pppRecipientCert
    );
static void FreeEncryptPara(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT *ppRecipientCert
    );
static BOOL InitDecryptPara(OUT PCRYPT_DECRYPT_MESSAGE_PARA pPara);
static void FreeDecryptPara(IN PCRYPT_DECRYPT_MESSAGE_PARA pPara);
static BOOL InitHashPara(OUT PCRYPT_HASH_MESSAGE_PARA pPara);
static void FreeHashPara(IN PCRYPT_HASH_MESSAGE_PARA pPara);


//+-------------------------------------------------------------------------
//  Top Level Test Functions
//--------------------------------------------------------------------------
static BOOL TestSign()
{
    BOOL fResult;
    CRYPT_SIGN_MESSAGE_PARA SignPara;
    CRYPT_VERIFY_MESSAGE_PARA VerifyPara;
    BYTE *pbSignedBlob = NULL;
    DWORD cbSignedBlob;
    BYTE *pbDecoded = NULL;
    DWORD cbDecoded;
    DWORD *pcbDecoded;
    PCCERT_CONTEXT pSignerCert = NULL;
    PCCERT_CONTEXT pSignerCert2 = NULL;
    LONG lSignerCount;
    BYTE *pbDecoded2 = NULL;
    DWORD cbDecoded2;
    DWORD dwMsgType;
    DWORD cbData;
    DWORD dwInnerContentType = 0x1233467;

    DWORD cToBeSigned;
    const BYTE **ppbToBeSigned;
    DWORD *pcbToBeSigned;

    ppbToBeSigned = rgpbDetachedToBeEncoded;
    pcbToBeSigned = rgcbDetachedToBeEncoded;
    if (fDetached)
        cToBeSigned = DETACHED_CONTENT_CNT;
    else if (0 == cbToBeEncoded) {
        cToBeSigned = 0;
        ppbToBeSigned = NULL;
        pcbToBeSigned = NULL;
    } else
        cToBeSigned = 1;

    if (pszReadEncodedFilename)
        fResult = TRUE;
    else
        fResult = InitSignPara(&SignPara);
    fResult &= InitVerifyPara(&VerifyPara);
    if (!fResult) goto ErrorReturn;

    if (pszReadEncodedFilename) {
        if (!ReadDERFromFile(
                pszReadEncodedFilename,
                &pbSignedBlob,
                &cbSignedBlob
                ))
            goto ErrorReturn;
    } else {
        cbSignedBlob = 1;       // bad length should be ignored
        fResult = CryptSignMessage(
                &SignPara,
                fDetached,
                cToBeSigned,
                ppbToBeSigned,
                pcbToBeSigned,
                NULL,           // pbSignedBlob
                &cbSignedBlob
                );
        if (!fResult || cbSignedBlob == 0) {
            PrintLastError("CryptSignMessage(cb == 0)");
            goto ErrorReturn;
        }
        if (NULL == (pbSignedBlob = (BYTE *) TestAlloc(
                cbSignedBlob + DELTA_MORE_LENGTH)))
            goto ErrorReturn;
        if (!CryptSignMessage(
                &SignPara,
                fDetached,
                cToBeSigned,
                ppbToBeSigned,
                pcbToBeSigned,
                pbSignedBlob,
                &cbSignedBlob
                )) {
            PrintLastError("CryptSignMessage");
            goto ErrorReturn;
        }

        cbData = cbSignedBlob - DELTA_LESS_LENGTH;
        fResult = CryptSignMessage(
                &SignPara,
                fDetached,
                cToBeSigned,
                ppbToBeSigned,
                pcbToBeSigned,
                pbSignedBlob,
                &cbData
                );
        // Note, length varies for DSS
        if (!IsDSSProv(dwCryptProvType))
            CheckLessLength("CryptSignMessage", fResult, cbData, cbSignedBlob);

        cbData = cbSignedBlob + DELTA_MORE_LENGTH;
        if (!CryptSignMessage(
                &SignPara,
                fDetached,
                cToBeSigned,
                ppbToBeSigned,
                pcbToBeSigned,
                pbSignedBlob,
                &cbData
                )) {
            PrintLastError("CryptSignMessage");
            goto ErrorReturn;
        }
        // Note, length varies for DSS
        if (!IsDSSProv(dwCryptProvType))
            CheckMoreLength("CryptSignMessage", cbData, cbSignedBlob);

        cbSignedBlob = cbData;
    }

    if (NULL == pszReadEncodedFilename && pszMsgEncodedFilename)
        WriteDERToFile(pszMsgEncodedFilename, pbSignedBlob, cbSignedBlob);

    if (pszMsgCertFilename) {
        HCERTSTORE hMsgCertStore;
        if (hMsgCertStore = CryptGetMessageCertificates(
                dwMsgEncodingType | dwCertEncodingType,
                0,                                      // hCryptProv,
                0,                                      // dwFlags
                pbSignedBlob,
                cbSignedBlob
                )) {
            SaveStore(hMsgCertStore, pszMsgCertFilename);
            CertCloseStore(hMsgCertStore, 0);
        } else
            PrintLastError("CryptGetMessageCertificates");
    }

    lSignerCount = CryptGetMessageSignerCount(dwMsgEncodingType,
        pbSignedBlob, cbSignedBlob);
    if (lSignerCount < 0)
        PrintLastError("CryptGetMessageSignerCount");
    else if (fVerbose)
        printf("Signer Count: %d\n", lSignerCount);

    if (fDetached) {
        if (!CryptVerifyDetachedMessageSignature(
                &VerifyPara,
                0,              // dwSignerIndex
                pbSignedBlob,
                cbSignedBlob,
                DETACHED_CONTENT_CNT,
                rgpbDetachedToBeEncoded,
                rgcbDetachedToBeEncoded,
                &pSignerCert
                )) {
            PrintLastError("CryptVerifyDetachedMessageSignature");
            goto ErrorReturn;
        }
    } else {
        cbDecoded = 3;          // bad length should be ignored
        if (!CryptVerifyMessageSignature(
                &VerifyPara,
                0,              // dwSignerIndex
                pbSignedBlob,
                cbSignedBlob,
                NULL,           // pbDecoded
                &cbDecoded,
                NULL            // ppSignerCert
                )) {
            PrintLastError("CryptVerifyMessageSignature");
            goto ErrorReturn;
        }
        if (cbDecoded == 0)
            // Message doesn't contain any content, only certs and CRLs
            pcbDecoded = NULL;
        else {
            pcbDecoded = &cbDecoded;
            if (NULL == (pbDecoded = (BYTE *) TestAlloc(
                cbDecoded + DELTA_MORE_LENGTH)))
                    goto ErrorReturn;
        }
        if (!CryptVerifyMessageSignature(
                &VerifyPara,
                0,              // dwSignerIndex
                pbSignedBlob,
                cbSignedBlob,
                pbDecoded,
                pcbDecoded,
                &pSignerCert
                )) {
            if (GetLastError() == CRYPT_E_NO_SIGNER) {
                printf("message has no signers\n");

                // Try again with all out parameters set to NULL.
                // GetSignerCertificate should still be called
                fResult = CryptVerifyMessageSignature(
                        &VerifyPara,
                        0,              // dwSignerIndex
                        pbSignedBlob,
                        cbSignedBlob,
                        NULL,           // pbDecoded
                        NULL,           // pcbDecoded
                        NULL            // ppSignerCert
                        );
                if (fResult) {
                    printf("CryptVerifyMessageSignature(no signer, NULL outs)");
                    printf(" failed => returned SUCCESS\n");
                } else if (GetLastError() != CRYPT_E_NO_SIGNER)
                    PrintLastError("CryptVerifyMessageSignature(no signer, NULL outs)");
            } else {
                PrintLastError("CryptVerifyMessageSignature");
                goto ErrorReturn;
            }
        }

        if (cbDecoded > DELTA_LESS_LENGTH) {
            cbData = cbDecoded - DELTA_LESS_LENGTH;
            fResult = CryptVerifyMessageSignature(
                &VerifyPara,
                0,              // dwSignerIndex
                pbSignedBlob,
                cbSignedBlob,
                pbDecoded,
                &cbData,
                NULL            // ppSignerCert
                );
            CheckLessLength("CryptVerifyMessageSignature", fResult, cbData,
                cbDecoded);

            cbData = cbDecoded + DELTA_MORE_LENGTH;
            if (!CryptVerifyMessageSignature(
                    &VerifyPara,
                    0,              // dwSignerIndex
                    pbSignedBlob,
                    cbSignedBlob,
                    pbDecoded,
                    &cbData,
                    NULL            // ppSignerCert
                    )) {
                if (GetLastError() == CRYPT_E_NO_SIGNER)
                    printf("message has no signers\n");
                else {
                    PrintLastError("CryptVerifyMessageSignature");
                    goto ErrorReturn;
                }
            }
            CheckMoreLength("CryptVerifyMessageSignature", cbData, cbDecoded);
        }
    }
    if (pSignerCert) {
        if (fVerbose) {
            printf("-----  Verifier  -----\n");
            DisplayCert(pSignerCert);
        }
    } else
        printf("no verifier cert\n");

    if (!fDetached) {
        if (!pszReadEncodedFilename) {
            if (cbDecoded == cbToBeEncoded &&
                memcmp(pbDecoded, pbToBeEncoded, cbDecoded) == 0) {
                    if (fVerbose)
                        printf("SUCCESS:: Decoded == ToBeEncoded\n");
            } else
                printf("*****  ERROR:: Decoded != ToBeEncoded\n");
        }
        if (fVerbose) {
            printf("Decoded bytes::\n");
            PrintBytes("  ", pbDecoded, cbDecoded);
        }

        if (pszReadEncodedFilename && pszMsgEncodedFilename)
            WriteDERToFile(pszMsgEncodedFilename, pbDecoded, cbDecoded);

        cbDecoded2 = cbDecoded;
        if (cbDecoded2 ) {
            if (NULL == (pbDecoded2 = (BYTE *) TestAlloc(
                cbDecoded2 + DELTA_MORE_LENGTH)))
                    goto ErrorReturn;
        }
        if (!CryptDecodeMessage(
                CMSG_ALL_FLAGS,
                NULL,               // pDecryptPara
                &VerifyPara,
                0,                  // dwSignerIndex
                pbSignedBlob,
                cbSignedBlob,
                0,                  // dwPrevInnerContentType
                &dwMsgType,
                &dwInnerContentType,
                pbDecoded2,
                &cbDecoded2,
                NULL,               // ppXchgCert
                &pSignerCert2
                )) {
            if (GetLastError() == CRYPT_E_NO_SIGNER)
                printf("message has no signers\n");
            else {
                PrintLastError("CryptDecodeMessage(CMSG_SIGNED)");
                goto ErrorReturn;
            }
        }
        if (cbDecoded2 > DELTA_LESS_LENGTH) {
            cbData = cbDecoded2 - DELTA_LESS_LENGTH;
            fResult = CryptDecodeMessage(
                CMSG_ALL_FLAGS,
                NULL,               // pDecryptPara
                &VerifyPara,
                0,                  // dwSignerIndex
                pbSignedBlob,
                cbSignedBlob,
                0,                  // dwPrevInnerContentType
                &dwMsgType,
                NULL,               // pdwInnerContentType
                pbDecoded2,
                &cbData,
                NULL,               // ppXchgCert
                NULL                // ppSignerCert
                );
            CheckLessLength("CryptDecodeMessage(SIGN)", fResult, cbData,
                cbDecoded2);

            cbData = cbDecoded2 + DELTA_MORE_LENGTH;
            if (!CryptDecodeMessage(
                    CMSG_ALL_FLAGS,
                    NULL,               // pDecryptPara
                    &VerifyPara,
                    0,                  // dwSignerIndex
                    pbSignedBlob,
                    cbSignedBlob,
                    0,                  // dwPrevInnerContentType
                    &dwMsgType,
                    &dwInnerContentType,
                    pbDecoded2,
                    &cbData,
                    NULL,               // ppXchgCert
                    NULL                // ppSignerCert
                    )) {
                if (GetLastError() == CRYPT_E_NO_SIGNER)
                    printf("message has no signers\n");
                else {
                    PrintLastError("CryptDecodeMessage(CMSG_SIGNED)");
                    goto ErrorReturn;
                }
            }
            CheckMoreLength("CryptDecodeMessage", cbData, cbDecoded2);
        }

        if (dwMsgType != CMSG_SIGNED)
            printf("failed :: dwMsgType(%d) != CMSG_SIGNED\n", dwMsgType);
        else if (fVerbose)
            printf("SUCCESS:: CryptDecodeMessage(CMSG_SIGNED)\n");
#ifdef CMS_PKCS7
        if ((fEncapsulatedContent && dwInnerContentType != CMSG_HASHED) ||
                (!fEncapsulatedContent && dwInnerContentType != CMSG_DATA)) {
#else
        if (dwInnerContentType != CMSG_DATA) {
#endif // CMS_PKCS7
            if (pszReadEncodedFilename)
                printf("SIGNED InnerContentType = %d\n", dwInnerContentType);
            else {
#ifdef CMS_PKCS7
                if (fEncapsulatedContent)
                    printf("SIGNED failed :: dwInnerContentType(%d) != CMSG_HASHED\n",
                        dwInnerContentType);
                else
#endif // CMS_PKCS7
                    printf("SIGNED failed :: dwInnerContentType(%d) != CMSG_DATA\n",
                        dwInnerContentType);
            }
        }
        if (cbDecoded2 != cbDecoded ||
                (cbDecoded > 0 &&
                    memcmp(pbDecoded, pbDecoded2, cbDecoded) != 0))
            printf("failed :: bad decoded content for CryptDecodeMessage(CMSG_SIGNED)\n");
        if (pSignerCert && (pSignerCert2 == NULL ||
                !CertCompareCertificate(dwCertEncodingType, 
                    pSignerCert->pCertInfo, pSignerCert2->pCertInfo)))
            printf("failed :: bad signer cert for CryptDecodeMessage(CMSG_SIGNED)\n");
            
    }

    fResult = TRUE;
    goto CommonReturn;
            
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (!pszReadEncodedFilename)
        FreeSignPara(&SignPara);
    FreeVerifyPara(&VerifyPara);
    if (pbSignedBlob)
        TestFree(pbSignedBlob);
    if (pbDecoded)
        TestFree(pbDecoded);
    if (pbDecoded2)
        TestFree(pbDecoded2);
    if (pSignerCert)
        CertFreeCertificateContext(pSignerCert);
    if (pSignerCert2)
        CertFreeCertificateContext(pSignerCert2);
    return fResult;
}

static BOOL TestEnvelope()
{
    BOOL fResult;
    CRYPT_ENCRYPT_MESSAGE_PARA EncryptPara;
    DWORD cRecipientCert;
    PCCERT_CONTEXT *ppRecipientCert;
    CRYPT_DECRYPT_MESSAGE_PARA DecryptPara;
    BYTE *pbEncryptedBlob = NULL;
    DWORD cbEncryptedBlob;
    BYTE *pbDecoded = NULL;
    DWORD cbDecoded;
    PCCERT_CONTEXT pXchgCert = NULL;
    BYTE *pbDecoded2 = NULL;
    DWORD cbDecoded2;
    DWORD dwMsgType;
    PCCERT_CONTEXT pXchgCert2 = NULL;
    DWORD cbData;

    DWORD dwInnerContentType = 0x1233467;

    if (pszReadEncodedFilename)
        fResult = TRUE;
    else
        fResult = InitEncryptPara(&EncryptPara, &cRecipientCert,
            &ppRecipientCert);
    fResult &= InitDecryptPara(&DecryptPara);
    if (!fResult) goto ErrorReturn;

    if (pszReadEncodedFilename) {
        if (!ReadDERFromFile(
                pszReadEncodedFilename,
                &pbEncryptedBlob,
                &cbEncryptedBlob
                ))
            goto ErrorReturn;
    } else {
        fResult = CryptEncryptMessage(
                &EncryptPara,
                cRecipientCert,
                ppRecipientCert,
                pbToBeEncoded,
                cbToBeEncoded,
                NULL,           // pbEncryptedBlob
                &cbEncryptedBlob
                );
        if (!fResult || cbEncryptedBlob == 0) {
            PrintLastError("CryptEncryptMessage(cb == 0)");
            goto ErrorReturn;
        }
        if (NULL == (pbEncryptedBlob = (BYTE *) TestAlloc(
                cbEncryptedBlob + DELTA_MORE_LENGTH)))
            goto ErrorReturn;
        fResult = CryptEncryptMessage(
                &EncryptPara,
                cRecipientCert,
                ppRecipientCert,
                pbToBeEncoded,
                cbToBeEncoded,
                pbEncryptedBlob,
                &cbEncryptedBlob
                );
        if (!fResult) {
            PrintLastError("CryptEncryptMessage");
            goto ErrorReturn;
        }

        cbData = cbEncryptedBlob - DELTA_LESS_LENGTH;
        fResult = CryptEncryptMessage(
                &EncryptPara,
                cRecipientCert,
                ppRecipientCert,
                pbToBeEncoded,
                cbToBeEncoded,
                pbEncryptedBlob,
                &cbData
                );
        // Note, length varies for DH
        if (!fDhRecipient)
            CheckLessLength("CryptEncryptMessage", fResult, cbData,
                cbEncryptedBlob);

        cbData = cbEncryptedBlob + DELTA_MORE_LENGTH;
        fResult = CryptEncryptMessage(
                &EncryptPara,
                cRecipientCert,
                ppRecipientCert,
                pbToBeEncoded,
                cbToBeEncoded,
                pbEncryptedBlob,
                &cbData
                );
        if (!fResult) {
            PrintLastError("CryptEncryptMessage");
            goto ErrorReturn;
        }

        // Note, length varies for DH
        if (!fDhRecipient)
            CheckMoreLength("CryptEncryptMessage", cbData, cbEncryptedBlob);

        cbEncryptedBlob = cbData;
    }

    if (NULL == pszReadEncodedFilename && pszMsgEncodedFilename)
        WriteDERToFile(pszMsgEncodedFilename, pbEncryptedBlob, cbEncryptedBlob);

    cbDecoded = 0;
    fResult = CryptDecryptMessage(
            &DecryptPara,
            pbEncryptedBlob,
            cbEncryptedBlob,
            NULL,           // pbDecoded
            &cbDecoded,
            NULL            // ppXchgCert
            );
    if (!fResult && GetLastError() == CRYPT_E_RECIPIENT_NOT_FOUND)
        printf("message has no recipients\n");
    else if (!fResult || (cbToBeEncoded > 0 && cbDecoded == 0 &&
            NULL == pszReadEncodedFilename)) {
        PrintLastError("CryptDecryptMessage(cb == 0)");
        goto ErrorReturn;
    }
    if (NULL == (pbDecoded = (BYTE *) TestAlloc(cbDecoded + DELTA_MORE_LENGTH)))
        goto ErrorReturn;
    if (!CryptDecryptMessage(
            &DecryptPara,
            pbEncryptedBlob,
            cbEncryptedBlob,
            pbDecoded,
            &cbDecoded,
            &pXchgCert
            )) {
        if (GetLastError() == CRYPT_E_RECIPIENT_NOT_FOUND)
            printf("message has no recipients\n");
        else {
            PrintLastError("CryptDecryptMessage");
            goto ErrorReturn;
        }
    }

    if (pszReadEncodedFilename && pszMsgEncodedFilename)
        WriteDERToFile(pszMsgEncodedFilename, pbDecoded, cbDecoded);

    if (cbDecoded > DELTA_LESS_LENGTH) {
        cbData = cbDecoded - DELTA_LESS_LENGTH;
        fResult = CryptDecryptMessage(
                &DecryptPara,
                pbEncryptedBlob,
                cbEncryptedBlob,
                pbDecoded,
                &cbData,
                NULL                // ppXchgCert
                );
        CheckLessLength("CryptDecryptMessage", fResult, cbData, cbDecoded);
    }

    cbData = cbDecoded + DELTA_MORE_LENGTH;
    if (!CryptDecryptMessage(
            &DecryptPara,
            pbEncryptedBlob,
            cbEncryptedBlob,
            pbDecoded,
            &cbData,
            NULL                // ppXchgCert
            )) {
        if (GetLastError() == CRYPT_E_RECIPIENT_NOT_FOUND)
            printf("message has no recipients\n");
        else {
            PrintLastError("CryptDecryptMessage");
            goto ErrorReturn;
        }
    }
    CheckMoreLength("CryptDecryptMessage", cbData, cbDecoded);

    if (pXchgCert) {
        if (fVerbose) {
            printf("-----  XchgCert  -----\n");
            DisplayCert(pXchgCert);
        }
    } else
        printf("no xchg cert\n");

    if (!pszReadEncodedFilename && !fNoRecipients) {
        if (cbDecoded == cbToBeEncoded &&
            memcmp(pbDecoded, pbToBeEncoded, cbDecoded) == 0) {
                if (fVerbose)
                    printf("SUCCESS:: Decoded == ToBeEncoded\n");
        } else
            printf("*****  ERROR:: Decoded != ToBeEncoded\n");
    }
    if (fVerbose) {
        printf("Decoded bytes::\n");
        PrintBytes("  ", pbDecoded, cbDecoded);
    }

    cbDecoded2 = cbDecoded;
    if (NULL == (pbDecoded2 = (BYTE *) TestAlloc(
            cbDecoded2 + DELTA_MORE_LENGTH)))
        goto ErrorReturn;
    if (!CryptDecodeMessage(
            CMSG_ALL_FLAGS,
            &DecryptPara,
            NULL,               // pVerifyPara
            0,                  // dwSignerIndex
            pbEncryptedBlob,
            cbEncryptedBlob,
            0,                  // dwPrevInnerContentType
            &dwMsgType,
            &dwInnerContentType,
            pbDecoded2,
            &cbDecoded2,
            &pXchgCert2,
            NULL                // pSignerCert
            )) {
        if (GetLastError() == CRYPT_E_RECIPIENT_NOT_FOUND)
            printf("message has no recipients\n");
        else {
            PrintLastError("CryptDecodeMessage(CMSG_ENVELOPED)");
            goto ErrorReturn;
        }
    }
    if (cbDecoded2 > DELTA_LESS_LENGTH) {
        cbData = cbDecoded2 - DELTA_LESS_LENGTH;
        fResult = CryptDecodeMessage(
            CMSG_ALL_FLAGS,
            &DecryptPara,
            NULL,               // pVerifyPara
            0,                  // dwSignerIndex
            pbEncryptedBlob,
            cbEncryptedBlob,
            0,                  // dwPrevInnerContentType
            &dwMsgType,
            NULL,               // pdwInnerContentType
            pbDecoded2,
            &cbData,
            NULL,               // ppXchgCert
            NULL                // ppSignerCert
            );
        CheckLessLength("CryptDecodeMessage(ENVELOPE)", fResult, cbData,
            cbDecoded2);
    }

    cbData = cbDecoded2 + DELTA_MORE_LENGTH;
    if (!CryptDecodeMessage(
            CMSG_ALL_FLAGS,
            &DecryptPara,
            NULL,               // pVerifyPara
            0,                  // dwSignerIndex
            pbEncryptedBlob,
            cbEncryptedBlob,
            0,                  // dwPrevInnerContentType
            &dwMsgType,
            &dwInnerContentType,
            pbDecoded2,
            &cbData,
            NULL,               // ppXchgCert
            NULL                // ppSignerCert
            )) {
        if (GetLastError() == CRYPT_E_RECIPIENT_NOT_FOUND)
            printf("message has no recipients\n");
        else {
            PrintLastError("CryptDecodeMessage(CMSG_ENVELOPED)");
            goto ErrorReturn;
        }
    }
    CheckMoreLength("CryptDecodeMessage(ENVELOPE)", cbData, cbDecoded2);

    if (dwMsgType != CMSG_ENVELOPED)
        printf("failed :: dwMsgType(%d) != CMSG_ENVELOPED\n", dwMsgType);
    else if (fVerbose)
        printf("SUCCESS:: CryptDecodeMessage(CMSG_ENVELOPED)\n");
    if (!pszReadEncodedFilename) {
#ifdef CMS_PKCS7
        if ((fEncapsulatedContent && dwInnerContentType != CMSG_HASHED) ||
                (!fEncapsulatedContent && dwInnerContentType != CMSG_DATA)) {
#else
        if (dwInnerContentType != CMSG_DATA) {
#endif // CMS_PKCS7
#ifdef CMS_PKCS7
                if (fEncapsulatedContent)
                    printf("ENVELOPE failed :: dwInnerContentType(%d) != CMSG_HASHED\n",
                        dwInnerContentType);
                else
#endif // CMS_PKCS7
                printf("ENVELOPE failed :: dwInnerContentType(%d) != CMSG_DATA\n",
                    dwInnerContentType);
        }
    }
    if (cbDecoded2 != cbDecoded ||
            (cbDecoded > 0 &&
                memcmp(pbDecoded, pbDecoded2, cbDecoded) != 0))
        printf("failed :: bad decoded content for CryptDecodeMessage(CMSG_ENVELOPED)\n");
    if (pXchgCert && (pXchgCert2 == NULL ||
            !CertCompareCertificate(dwCertEncodingType, 
                pXchgCert->pCertInfo, pXchgCert2->pCertInfo)))
        printf("failed :: bad xchg cert for CryptDecodeMessage(CMSG_ENVELOPED)\n");

    fResult = TRUE;
    goto CommonReturn;
            
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (!pszReadEncodedFilename)
        FreeEncryptPara(&EncryptPara, cRecipientCert, ppRecipientCert);
    FreeDecryptPara(&DecryptPara);
    if (pbEncryptedBlob)
        TestFree(pbEncryptedBlob);
    if (pbDecoded)
        TestFree(pbDecoded);
    if (pbDecoded2)
        TestFree(pbDecoded2);
    if (pXchgCert)
        CertFreeCertificateContext(pXchgCert);
    if (pXchgCert2)
        CertFreeCertificateContext(pXchgCert2);
    return fResult;
}

static BOOL TestSignAndEnvelope()
{
    BOOL fResult;
    CRYPT_SIGN_MESSAGE_PARA SignPara;
    CRYPT_VERIFY_MESSAGE_PARA VerifyPara;
    CRYPT_ENCRYPT_MESSAGE_PARA EncryptPara;
    DWORD cRecipientCert;
    PCCERT_CONTEXT *ppRecipientCert;
    CRYPT_DECRYPT_MESSAGE_PARA DecryptPara;

    BYTE *pbEncodedBlob = NULL;
    DWORD cbEncodedBlob;
    BYTE *pbDecoded = NULL;
    DWORD cbDecoded;
    PCCERT_CONTEXT pSignerCert = NULL;
    PCCERT_CONTEXT pXchgCert = NULL;

    DWORD cbData;

    fResult = InitSignPara(&SignPara);
    fResult &= InitVerifyPara(&VerifyPara);
    fResult &= InitEncryptPara(&EncryptPara, &cRecipientCert, &ppRecipientCert);
    fResult &= InitDecryptPara(&DecryptPara);
    if (!fResult) goto ErrorReturn;

    if (fInnerSigned || fEncapsulatedContent) {
        SignPara.dwFlags |= CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG;
        EncryptPara.dwInnerContentType = CMSG_SIGNED;
    }

    fResult = CryptSignAndEncryptMessage(
            &SignPara,
            &EncryptPara,
            cRecipientCert,
            ppRecipientCert,
            pbToBeEncoded,
            cbToBeEncoded,
            NULL,           // pbEncodedBlob
            &cbEncodedBlob
            );
    if (!fResult || cbEncodedBlob == 0) {
        PrintLastError("CryptSignAndEncryptMessage(cb == 0)");
        goto ErrorReturn;
    }
    if (NULL == (pbEncodedBlob = (BYTE *) TestAlloc(
            cbEncodedBlob + DELTA_MORE_LENGTH)))
        goto ErrorReturn;
    fResult = CryptSignAndEncryptMessage(
        &SignPara,
        &EncryptPara,
        cRecipientCert,
        ppRecipientCert,
        pbToBeEncoded,
        cbToBeEncoded,
        pbEncodedBlob,
        &cbEncodedBlob
        );
    if (!fResult){
        PrintLastError("CryptSignAndEncryptMessage");
        goto ErrorReturn;
    }

    cbData = cbEncodedBlob - DELTA_LESS_LENGTH;
    fResult = CryptSignAndEncryptMessage(
        &SignPara,
        &EncryptPara,
        cRecipientCert,
        ppRecipientCert,
        pbToBeEncoded,
        cbToBeEncoded,
        pbEncodedBlob,
        &cbData
        );
    // Note, length varies for DSS or DH
    if (!IsDSSProv(dwCryptProvType) && !fDhRecipient)
        CheckLessLength("CryptSignAndEncryptMessage", fResult, cbData,
            cbEncodedBlob);

    cbData = cbEncodedBlob + DELTA_MORE_LENGTH;
    fResult = CryptSignAndEncryptMessage(
        &SignPara,
        &EncryptPara,
        cRecipientCert,
        ppRecipientCert,
        pbToBeEncoded,
        cbToBeEncoded,
        pbEncodedBlob,
        &cbData
        );
    if (!fResult){
        PrintLastError("CryptSignAndEncryptMessage");
        goto ErrorReturn;
    }
    // Note, length varies for DSS or DH
    if (!IsDSSProv(dwCryptProvType) && !fDhRecipient)
        CheckMoreLength("CryptSignAndEncryptMessage", cbData, cbEncodedBlob);
    cbEncodedBlob = cbData;

    if (pszMsgEncodedFilename)
        WriteDERToFile(pszMsgEncodedFilename, pbEncodedBlob, cbEncodedBlob);

    fResult = CryptDecryptAndVerifyMessageSignature(
            &DecryptPara,
            &VerifyPara,
            0,              // dwSignerIndex
            pbEncodedBlob,
            cbEncodedBlob,
            NULL,           // pbDecoded
            &cbDecoded,
            NULL,           // ppXchgCert
            NULL            // ppSignerCert
            );
    if (!fResult || cbDecoded == 0) {
        PrintLastError("CryptDecryptAndVerifyMessageSignature(cb == 0)");
        goto ErrorReturn;
    }
    if (NULL == (pbDecoded = (BYTE *) TestAlloc(
            cbDecoded + DELTA_MORE_LENGTH)))
        goto ErrorReturn;
    if (!CryptDecryptAndVerifyMessageSignature(
            &DecryptPara,
            &VerifyPara,
            0,              // dwSignerIndex
            pbEncodedBlob,
            cbEncodedBlob,
            pbDecoded,
            &cbDecoded,
            &pXchgCert,
            &pSignerCert
            )) {
        PrintLastError("CryptDecryptAndVerifyMessageSignature");
        goto ErrorReturn;
    }

    cbData = cbDecoded - DELTA_LESS_LENGTH;
    fResult = CryptDecryptAndVerifyMessageSignature(
            &DecryptPara,
            &VerifyPara,
            0,              // dwSignerIndex
            pbEncodedBlob,
            cbEncodedBlob,
            pbDecoded,
            &cbData,
            NULL,           // ppXchgCert
            NULL            // ppSignerCert
            );
    CheckLessLength("CryptDecryptAndVerifyMessageSignature", fResult, cbData,
        cbDecoded);

    cbData = cbDecoded + DELTA_MORE_LENGTH;
    if (!CryptDecryptAndVerifyMessageSignature(
            &DecryptPara,
            &VerifyPara,
            0,              // dwSignerIndex
            pbEncodedBlob,
            cbEncodedBlob,
            pbDecoded,
            &cbData,
            NULL,           // ppXchgCert
            NULL            // ppSignerCert
            )) {
        PrintLastError("CryptDecryptAndVerifyMessageSignature");
        goto ErrorReturn;
    }
    CheckMoreLength("CryptDecryptAndVerifyMessageSignature", cbData,
        cbDecoded);

    if (pXchgCert) {
        if (fVerbose) {
            printf("-----  XchgCert  -----\n");
            DisplayCert(pXchgCert);
        }
    } else
        printf("no xchg cert\n");
    if (pSignerCert) {
        if (fVerbose) {
            printf("-----  Verifier  -----\n");
            DisplayCert(pSignerCert);
        }
    } else
        printf("no verifier cert\n");

    if (cbDecoded == cbToBeEncoded &&
        memcmp(pbDecoded, pbToBeEncoded, cbDecoded) == 0) {
            if (fVerbose)
                printf("SUCCESS:: Decoded == ToBeEncoded\n");
    } else
        printf("*****  ERROR:: Decoded != ToBeEncoded\n");
    if (fVerbose) {
        printf("Decoded bytes::\n");
        PrintBytes("  ", pbDecoded, cbDecoded);
    }

    fResult = TRUE;
    goto CommonReturn;
            
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    FreeSignPara(&SignPara);
    FreeVerifyPara(&VerifyPara);
    FreeEncryptPara(&EncryptPara, cRecipientCert, ppRecipientCert);
    FreeDecryptPara(&DecryptPara);
    if (pbEncodedBlob)
        TestFree(pbEncodedBlob);
    if (pbDecoded)
        TestFree(pbDecoded);
    if (pSignerCert)
        CertFreeCertificateContext(pSignerCert);
    if (pXchgCert)
        CertFreeCertificateContext(pXchgCert);
    return fResult;
}

static BOOL TestHash()
{
    BOOL fResult;
    CRYPT_HASH_MESSAGE_PARA HashPara;
    CRYPT_VERIFY_MESSAGE_PARA VerifyPara;
    BYTE *pbHashedBlob = NULL;
    DWORD cbHashedBlob;
    BYTE *pbDecoded = NULL;
    DWORD cbDecoded;
    BYTE *pbDecoded2 = NULL;
    DWORD cbDecoded2;
    DWORD dwMsgType;

    DWORD cbData;
    DWORD dwInnerContentType = 0x1233467;

    fResult = InitHashPara(&HashPara);
    if (!fResult) goto ErrorReturn;

    cbHashedBlob = 0;
    fResult = CryptHashMessage(
            &HashPara,
            fDetached,
            fDetached ? DETACHED_CONTENT_CNT : 1,
            rgpbDetachedToBeEncoded,
            rgcbDetachedToBeEncoded,
            NULL,           // pbHashedBlob
            &cbHashedBlob,
            NULL,           // pbComputedHash
            NULL            // pcbComputedHash
            );
    if (!fResult || cbHashedBlob == 0) {
        PrintLastError("CryptHashMessage(cb == 0)");
        goto ErrorReturn;
    }
    if (NULL == (pbHashedBlob = (BYTE *) TestAlloc(
            cbHashedBlob + DELTA_MORE_LENGTH)))
        goto ErrorReturn;
    if (!CryptHashMessage(
            &HashPara,
            fDetached,
            fDetached ? DETACHED_CONTENT_CNT : 1,
            rgpbDetachedToBeEncoded,
            rgcbDetachedToBeEncoded,
            pbHashedBlob,
            &cbHashedBlob,
            NULL,           // pbComputedHash
            NULL            // pcbComputedHash
            )) {
        PrintLastError("CryptHashMessage");
        goto ErrorReturn;
    }

    cbData = cbHashedBlob - DELTA_LESS_LENGTH;
    fResult = CryptHashMessage(
            &HashPara,
            fDetached,
            fDetached ? DETACHED_CONTENT_CNT : 1,
            rgpbDetachedToBeEncoded,
            rgcbDetachedToBeEncoded,
            pbHashedBlob,
            &cbData,
            NULL,           // pbComputedHash
            NULL            // pcbComputedHash
            );
    CheckLessLength("CryptHashMessage", fResult, cbData, cbHashedBlob);

    cbData = cbHashedBlob + DELTA_MORE_LENGTH;
    if (!CryptHashMessage(
            &HashPara,
            fDetached,
            fDetached ? DETACHED_CONTENT_CNT : 1,
            rgpbDetachedToBeEncoded,
            rgcbDetachedToBeEncoded,
            pbHashedBlob,
            &cbData,
            NULL,           // pbComputedHash
            NULL            // pcbComputedHash
            )) {
        PrintLastError("CryptHashMessage");
        goto ErrorReturn;
    }
    CheckMoreLength("CryptHashMessage", cbData, cbHashedBlob);

    if (pszMsgEncodedFilename)
        WriteDERToFile(pszMsgEncodedFilename, pbHashedBlob, cbHashedBlob);

    if (fDetached) {
        if (!CryptVerifyDetachedMessageHash(
                &HashPara,
                pbHashedBlob,
                cbHashedBlob,
                DETACHED_CONTENT_CNT,
                rgpbDetachedToBeEncoded,
                rgcbDetachedToBeEncoded,
                NULL,           // pbComputedHash
                NULL            // pcbComputedHash
                )) {
            PrintLastError("CryptVerifyDetachedMessageHash");
            goto ErrorReturn;
        }
    } else {
        fResult = CryptVerifyMessageHash(
                &HashPara,
                pbHashedBlob,
                cbHashedBlob,
                NULL,           // pbDecoded
                &cbDecoded,
                NULL,           // pbComputedHash
                NULL            // pcbComputedHash
                );
        if (!fResult || cbDecoded == 0) {
            PrintLastError("CryptVerifyMessageHash(cb == 0)");
            goto ErrorReturn;
        }
        if (NULL == (pbDecoded = (BYTE *) TestAlloc(
                cbDecoded + DELTA_MORE_LENGTH)))
            goto ErrorReturn;
        if (!CryptVerifyMessageHash(
                &HashPara,
                pbHashedBlob,
                cbHashedBlob,
                pbDecoded,
                &cbDecoded,
                NULL,           // pbComputedHash
                NULL            // pcbComputedHash
                )) {
            PrintLastError("CryptVerifyMessageHash");
            goto ErrorReturn;
        }

        cbData = cbDecoded - DELTA_LESS_LENGTH;
        fResult = CryptVerifyMessageHash(
                &HashPara,
                pbHashedBlob,
                cbHashedBlob,
                pbDecoded,
                &cbData,
                NULL,           // pbComputedHash
                NULL            // pcbComputedHash
                );
        CheckLessLength("CryptVerifyMessageHash", fResult, cbData, cbDecoded);

        cbData = cbDecoded + DELTA_MORE_LENGTH;
        if (!CryptVerifyMessageHash(
                &HashPara,
                pbHashedBlob,
                cbHashedBlob,
                pbDecoded,
                &cbData,
                NULL,           // pbComputedHash
                NULL            // pcbComputedHash
                )) {
            PrintLastError("CryptVerifyMessageHash");
            goto ErrorReturn;
        }
        CheckMoreLength("CryptVerifyMessageHash", cbData, cbDecoded);
    }

    if (!fDetached) {
        if (cbDecoded == cbToBeEncoded &&
            memcmp(pbDecoded, pbToBeEncoded, cbDecoded) == 0) {
                if (fVerbose)
                    printf("SUCCESS:: Decoded == ToBeEncoded\n");
        } else
            printf("*****  ERROR:: Decoded != ToBeEncoded\n");
        if (fVerbose) {
            printf("Decoded bytes::\n");
            PrintBytes("  ", pbDecoded, cbDecoded);
        }

        cbDecoded2 = cbDecoded;
        if (cbDecoded2 ) {
            if (NULL == (pbDecoded2 = (BYTE *) TestAlloc(cbDecoded2)))
                    goto ErrorReturn;
        }
        InitVerifyPara(&VerifyPara);
        if (!CryptDecodeMessage(
                CMSG_ALL_FLAGS,
                NULL,               // pDecryptPara
                &VerifyPara,
                0,                  // dwSignerIndex
                pbHashedBlob,
                cbHashedBlob,
                0,                  // dwPrevInnerContentType
                &dwMsgType,
                &dwInnerContentType,
                pbDecoded2,
                &cbDecoded2,
                NULL,               // ppXchgCert
                NULL                // ppSignCert
                )) {
            PrintLastError("CryptDecodeMessage(CMSG_HASHED)");
            goto ErrorReturn;
        }
        if (dwMsgType != CMSG_HASHED)
            printf("failed :: dwMsgType(%d) != CMSG_HASHED\n", dwMsgType);
        else if (fVerbose)
            printf("SUCCESS:: CryptDecodeMessage(CMSG_HASHED)\n");
        if (dwInnerContentType != CMSG_DATA) {
                printf("HASHED failed :: dwInnerContentType(%d) != CMSG_DATA\n",
                    dwInnerContentType);
        }
        if (cbDecoded2 != cbDecoded ||
                (cbDecoded > 0 &&
                    memcmp(pbDecoded, pbDecoded2, cbDecoded) != 0))
            printf("failed :: bad decoded content for CryptDecodeMessage(CMSG_HASHED)\n");
    }

    fResult = TRUE;
    goto CommonReturn;
            
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    FreeHashPara(&HashPara);
    if (pbHashedBlob)
        TestFree(pbHashedBlob);
    if (pbDecoded)
        TestFree(pbDecoded);
    if (pbDecoded2)
        TestFree(pbDecoded2);
    return fResult;
}

static BOOL TestComputedHash()
{
    BOOL fResult;
    CRYPT_HASH_MESSAGE_PARA HashPara;
    BYTE *pbHashedBlob = NULL;
    DWORD cbHashedBlob;
    BYTE *pbDecoded = NULL;
    DWORD cbDecoded;

    BYTE rgbEncodedComputedHash[MAX_HASH_LEN];
    BYTE rgbDecodedComputedHash[MAX_HASH_LEN];
    DWORD cbEncodedComputedHash;
    DWORD cbDecodedComputedHash;

    fResult = InitHashPara(&HashPara);
    if (!fResult) goto ErrorReturn;

    cbHashedBlob = 0;
    cbEncodedComputedHash = 0;
    fResult = CryptHashMessage(
            &HashPara,
            fDetached,
            fDetached ? DETACHED_CONTENT_CNT : 1,
            rgpbDetachedToBeEncoded,
            rgcbDetachedToBeEncoded,
            NULL,           // pbHashedBlob
            &cbHashedBlob,
            NULL,           // pbComputedHash
            &cbEncodedComputedHash
            );
    if (!fResult || cbHashedBlob == 0) {
        PrintLastError("CryptHashMessage(cb == 0)");
        goto ErrorReturn;
    }
    if (cbEncodedComputedHash == 0) {
        PrintLastError("CryptHashMessage(cbComputedHash == 0)");
        goto ErrorReturn;
    }
    if (cbEncodedComputedHash > MAX_HASH_LEN) {
        PrintLastError("CryptHashMessage(cbComputedHash > MAX_HASH_LEN)");
        goto ErrorReturn;
    }

    if (NULL == (pbHashedBlob = (BYTE *) TestAlloc(cbHashedBlob)))
        goto ErrorReturn;
    if (!CryptHashMessage(
            &HashPara,
            fDetached,
            fDetached ? DETACHED_CONTENT_CNT : 1,
            rgpbDetachedToBeEncoded,
            rgcbDetachedToBeEncoded,
            pbHashedBlob,
            &cbHashedBlob,
            rgbEncodedComputedHash,
            &cbEncodedComputedHash
            )) {
        PrintLastError("CryptHashMessage");
        goto ErrorReturn;
    }
    if (fVerbose) {
        printf("Encoded Computed Hash::\n");
        PrintBytes("  ", rgbEncodedComputedHash, cbEncodedComputedHash);
    }

    if (pszMsgEncodedFilename)
        WriteDERToFile(pszMsgEncodedFilename, pbHashedBlob, cbHashedBlob);

    if (fDetached) {
        cbDecodedComputedHash = MAX_HASH_LEN;
        if(!CryptVerifyDetachedMessageHash(
                &HashPara,
                pbHashedBlob,
                cbHashedBlob,
                DETACHED_CONTENT_CNT,
                rgpbDetachedToBeEncoded,
                rgcbDetachedToBeEncoded,
                rgbDecodedComputedHash,
                &cbDecodedComputedHash
                )) {
            PrintLastError("CryptVerifyDetachedMessageHash");
            goto ErrorReturn;
        }
        if (cbDecodedComputedHash == 0) {
            PrintLastError("CryptVerifyDetachedMessageHash(cbComputedHash == 0)");
            goto ErrorReturn;
        }
        if (cbDecodedComputedHash > MAX_HASH_LEN) {
            PrintLastError("CryptVerifyDetachedMessageHash(cbComputedHash > MAX_HASH_LEN)");
            goto ErrorReturn;
        }
    } else {
        cbDecoded = 0;
        cbDecodedComputedHash = 0;
        fResult = CryptVerifyMessageHash(
                &HashPara,
                pbHashedBlob,
                cbHashedBlob,
                NULL,           // pbDecoded
                &cbDecoded,
                NULL,           // pbComputedHash
                &cbDecodedComputedHash
                );
        if (!fResult || cbDecoded == 0) {
            PrintLastError("CryptVerifyMessageHash(cb == 0)");
            goto ErrorReturn;
        }
        if (cbDecodedComputedHash == 0) {
            PrintLastError("CryptVerifyMessageHash(cbComputedHash == 0)");
            goto ErrorReturn;
        }
        if (cbDecodedComputedHash > MAX_HASH_LEN) {
            PrintLastError("CryptVerifyMessageHash(cbComputedHash > MAX_HASH_LEN)");
            goto ErrorReturn;
        }
        if (NULL == (pbDecoded = (BYTE *) TestAlloc(cbDecoded)))
            goto ErrorReturn;
        if(!CryptVerifyMessageHash(
                &HashPara,
                pbHashedBlob,
                cbHashedBlob,
                pbDecoded,
                &cbDecoded,
                rgbDecodedComputedHash,
                &cbDecodedComputedHash
                )) {
            PrintLastError("CryptVerifyMessageHash");
            goto ErrorReturn;
        }
    }

    if (fVerbose) {
        printf("Decoded Computed Hash::\n");
        PrintBytes("  ", rgbDecodedComputedHash, cbDecodedComputedHash);
    }

    if (cbDecodedComputedHash == cbEncodedComputedHash &&
            memcmp(rgbDecodedComputedHash, rgbEncodedComputedHash,
                cbDecodedComputedHash) == 0) {
        if (fVerbose)
            printf("SUCCESS:: Computed Hash Decoded == ToBeEncoded\n");
    } else
        printf("*****  ERROR:: Computed Hash Decoded != ToBeEncoded\n");

    if (!fDetached) {
        if (cbDecoded == cbToBeEncoded &&
            memcmp(pbDecoded, pbToBeEncoded, cbDecoded) == 0) {
                if (fVerbose)
                    printf("SUCCESS:: Decoded == ToBeEncoded\n");
        } else
            printf("*****  ERROR:: Decoded != ToBeEncoded\n");
        if (fVerbose) {
            printf("Decoded bytes::\n");
            PrintBytes("  ", pbDecoded, cbDecoded);
        }
    }

    fResult = TRUE;
    goto CommonReturn;
            
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    FreeHashPara(&HashPara);
    if (pbHashedBlob)
        TestFree(pbHashedBlob);
    if (pbDecoded)
        TestFree(pbDecoded);
    return fResult;
}

static BOOL TestNoCertSign()
{
    BOOL fResult;
    HCRYPTPROV hCryptProv = 0;
    CRYPT_KEY_SIGN_MESSAGE_PARA SignPara;
    CRYPT_KEY_VERIFY_MESSAGE_PARA VerifyPara;
    BYTE *pbSignedBlob = NULL;
    DWORD cbSignedBlob;
    BYTE *pbDecoded = NULL;
    DWORD cbDecoded;

    PCERT_PUBLIC_KEY_INFO pPublicKeyInfo1 = NULL;
    PCERT_PUBLIC_KEY_INFO pPublicKeyInfo2 = NULL;
    DWORD cbInfo;
    BYTE *pbEncodedKey = NULL;
    DWORD cbEncodedKey;

    fResult = CryptAcquireContext(
            &hCryptProv,
            NULL,           // pszContainer
            NULL,           // pszProvider
            dwCryptProvType,
            0               // dwFlags
            );
    if (!fResult) {
        hCryptProv = 0;
        PrintLastError("TestNoCertSign::CryptAcquireContext");
        goto ErrorReturn;
    }

    cbInfo = 0;
    fResult = CryptExportPublicKeyInfo(
            hCryptProv,
            dwSignKeySpec,
            dwCertEncodingType,
            NULL,           // pPubKeyInfo
            &cbInfo
            );
    if (!fResult || cbInfo == 0) {
        PrintLastError("CryptExportPublicKeyInfo(cb == 0)");
        goto ErrorReturn;
    }
    if (NULL == (pPublicKeyInfo1 = (PCERT_PUBLIC_KEY_INFO) TestAlloc(cbInfo)))
        goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hCryptProv,
            dwSignKeySpec,
            dwCertEncodingType,
            pPublicKeyInfo1,
            &cbInfo
            )) {
        PrintLastError("CryptExportPublicKeyInfo");
        goto ErrorReturn;
    }

    cbEncodedKey = 0;
    fResult = CryptEncodeObject(
            dwCertEncodingType,
            X509_PUBLIC_KEY_INFO,
            pPublicKeyInfo1,
            NULL,           // pbEncodedKey
            &cbEncodedKey
            );
    if (!fResult || cbEncodedKey == 0) {
        PrintLastError("CryptEncodeObject(cb == 0)");
        goto ErrorReturn;
    }
    if (NULL == (pbEncodedKey = (BYTE *) TestAlloc(cbEncodedKey)))
        goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_PUBLIC_KEY_INFO,
            pPublicKeyInfo1,
            pbEncodedKey,
            &cbEncodedKey
            )) {
        PrintLastError("CryptEncodeObject");
        goto ErrorReturn;
    }

    memset(&SignPara, 0, sizeof(SignPara));
    SignPara.cbSize = sizeof(SignPara);
    SignPara.dwMsgAndCertEncodingType =
        dwMsgEncodingType | dwCertEncodingType;
    SignPara.hCryptProv = hCryptProv;
    SignPara.dwKeySpec = dwSignKeySpec;
    if (NULL == (SignPara.HashAlgorithm.pszObjId = (LPSTR) GetOID(
            pszHashName, CRYPT_HASH_ALG_OID_GROUP_ID))) {
        printf("Failed => unknown hash name (%s)\n", pszHashName);
        goto ErrorReturn;
    }

    if (IsDSSProv(dwCryptProvType)) {
        SignPara.cbSize = sizeof(SignPara);
        SignPara.PubKeyAlgorithm.pszObjId = (LPSTR) GetOID(
            "Dss", CRYPT_PUBKEY_ALG_OID_GROUP_ID);
    } else
        SignPara.cbSize = offsetof(CRYPT_KEY_SIGN_MESSAGE_PARA,
            PubKeyAlgorithm);

    memset(&VerifyPara, 0, sizeof(VerifyPara));
    VerifyPara.cbSize = sizeof(VerifyPara);
    VerifyPara.dwMsgEncodingType = dwMsgEncodingType;
    VerifyPara.hCryptProv = 0;

    cbSignedBlob = 0;
    fResult = CryptSignMessageWithKey(
            &SignPara,
            pbEncodedKey,
            cbEncodedKey,
            NULL,           // pbSignedBlob
            &cbSignedBlob
            );
    if (!fResult || cbSignedBlob == 0) {
        PrintLastError("CryptSignMessageWithKey(cb == 0)");
        goto ErrorReturn;
    }
    if (NULL == (pbSignedBlob = (BYTE *) TestAlloc(cbSignedBlob)))
        goto ErrorReturn;
    if (!CryptSignMessageWithKey(
            &SignPara,
            pbEncodedKey,
            cbEncodedKey,
            pbSignedBlob,
            &cbSignedBlob
            )) {
        PrintLastError("CryptSignMessageWithKey");
        goto ErrorReturn;
    }

    if (pszMsgEncodedFilename)
        WriteDERToFile(pszMsgEncodedFilename, pbSignedBlob, cbSignedBlob);

    // First get the encoded public key info (ie, don't verify the signature)
    cbDecoded = 0;
    fResult = CryptVerifyMessageSignatureWithKey(
            &VerifyPara,
            NULL,           // pPublicKeyInfo
            pbSignedBlob,
            cbSignedBlob,
            NULL,           // pbDecoded
            &cbDecoded
            );
    if (!fResult || cbDecoded == 0) {
        PrintLastError("CryptVerifyMessageSignatureWithKey(cb == 0)");
        goto ErrorReturn;
    }
    if (NULL == (pbDecoded = (BYTE *) TestAlloc(cbDecoded)))
        goto ErrorReturn;
    if(!CryptVerifyMessageSignatureWithKey(
            &VerifyPara,
            NULL,           // pPublicKeyInfo
            pbSignedBlob,
            cbSignedBlob,
            pbDecoded,
            &cbDecoded
            )) {
        PrintLastError("CryptVerifyMessageSignatureWithKey");
        goto ErrorReturn;
    }

    // Now decode the public key info stored in the signed message
    cbInfo = 0;
    fResult = CryptDecodeObject(
            dwCertEncodingType,
            X509_PUBLIC_KEY_INFO,
            pbDecoded,
            cbDecoded,
            0,                  // dwFlags
            NULL,               // pInfo
            &cbInfo
            );
    if (!fResult || cbInfo == 0) {
        PrintLastError("CryptDecodeObject(cb == 0)");
        goto ErrorReturn;
    }
    if (NULL == (pPublicKeyInfo2 = (PCERT_PUBLIC_KEY_INFO) TestAlloc(cbInfo)))
        goto ErrorReturn;
    if (!CryptDecodeObject(
            dwCertEncodingType,
            X509_PUBLIC_KEY_INFO,
            pbDecoded,
            cbDecoded,
            0,                              // dwFlags
            pPublicKeyInfo2,
            &cbInfo
            )) {
        PrintLastError("CryptDecodeObject");
        goto ErrorReturn;
    }

    if (fVerbose) {
        printf("Decoded Algorithm Identifier:: %s\n",
            pPublicKeyInfo2->Algorithm.pszObjId);
        printf("Decoded public key bytes::\n");
        PrintBytes("  ",  pPublicKeyInfo2->PublicKey.pbData,
            pPublicKeyInfo2->PublicKey.cbData);
    }

    if (strcmp(pPublicKeyInfo1->Algorithm.pszObjId,
            pPublicKeyInfo2->Algorithm.pszObjId) == 0 &&
        CertComparePublicKeyInfo(
            dwCertEncodingType,
                pPublicKeyInfo1,
                pPublicKeyInfo2)) {
        if (fVerbose)
            printf("SUCCESS:: Decoded PublicKeyInfo == PublicKeyInfo\n");
    } else {
        printf("*****  ERROR:: Decoded PublicKeyInfo != PublicKeyInfo\n");
        if (fVerbose) {
            printf("Expected Algorithm Identifier:: %s\n",
                pPublicKeyInfo1->Algorithm.pszObjId);
            printf("Expected public key bytes::\n");
            PrintBytes("  ",  pPublicKeyInfo1->PublicKey.pbData,
                pPublicKeyInfo1->PublicKey.cbData);
        }
        goto ErrorReturn;
    }

    // Use the public key info to verify the signature
    if (!CryptVerifyMessageSignatureWithKey(
            &VerifyPara,
            pPublicKeyInfo2,
            pbSignedBlob,
            cbSignedBlob,
            NULL,           // pbDecoded
            NULL            // pcbDecoded
            )) {
        PrintLastError("CryptVerifyMessageSignatureWithKey(pPublicKeyInfo verify)");
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;
            
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);
    if (pPublicKeyInfo1)
        TestFree(pPublicKeyInfo1);
    if (pPublicKeyInfo2)
        TestFree(pPublicKeyInfo2);
    if (pbSignedBlob)
        TestFree(pbSignedBlob);
    if (pbDecoded)
        TestFree(pbDecoded);
    if (pbEncodedKey)
        TestFree(pbEncodedKey);
    return fResult;
}


static BOOL TimeStampTest(PCRYPT_TIME_STAMP_REQUEST_INFO pTSInfo) {
    BYTE *                          pbDer       = NULL;
    DWORD                           cbEncode    = 0;
    DWORD                           cbDecode    = 0;
    PCRYPT_TIME_STAMP_REQUEST_INFO  pbTSInfo    = NULL;
    BOOL                            fOk         = TRUE;

    // encode it
    if( 
        !CryptEncodeObject(
            CRYPT_ASN_ENCODING,
            PKCS_TIME_REQUEST,
            pTSInfo,
            NULL,
            &cbEncode)                                  ||
       (pbDer = (PBYTE) _alloca(cbEncode)) == NULL      ||
       !CryptEncodeObject(
            CRYPT_ASN_ENCODING,
            PKCS_TIME_REQUEST,
            pTSInfo,
            pbDer,
            &cbEncode)  )
    {
        goto CryptEncodeTimeRequestError;
    }
        

    // decode it
    if( 
        !CryptDecodeObject(
            CRYPT_ASN_ENCODING,
            PKCS_TIME_REQUEST,
            pbDer,
            cbEncode,
            CRYPT_DECODE_NOCOPY_FLAG,
            NULL,
            &cbDecode)              ||
        (pbTSInfo = (PCRYPT_TIME_STAMP_REQUEST_INFO) _alloca(cbDecode)) == NULL  ||
        !CryptDecodeObject(
		    CRYPT_ASN_ENCODING,
		    PKCS_TIME_REQUEST,
            pbDer,
            cbEncode,
            CRYPT_DECODE_NOCOPY_FLAG,
            pbTSInfo,
            &cbDecode) )
    {
        goto CryptDecodeTimeRequestError;
    }

    // compare encoded data with decoded data
    if(
        _stricmp(pTSInfo->pszTimeStampAlgorithm, pbTSInfo->pszTimeStampAlgorithm)          ||
        _stricmp(pTSInfo->pszContentType, pbTSInfo->pszContentType)                        ||
        pTSInfo->Content.cbData != pbTSInfo->Content.cbData                                ||
        pTSInfo->cAttribute != pbTSInfo->cAttribute                                       )
    {
        goto CompareTimeRequestError;
    }

    if(pTSInfo->Content.cbData != 0  &&
        memcmp(pTSInfo->Content.pbData, pbTSInfo->Content.pbData, pTSInfo->Content.cbData) )
    {
        goto CompareTimeRequestError;
    }

CommonReturn:
 
    return(fOk);

ErrorReturn:

    fOk = FALSE;
    goto CommonReturn;

    // TRACE_ERROR(BuildTimeStampError);
    TRACE_ERROR(CryptEncodeTimeRequestError);
    TRACE_ERROR(CryptDecodeTimeRequestError);
    TRACE_ERROR(CompareTimeRequestError);
}

static BOOL TestTimeStamp()
{
    CRYPT_TIME_STAMP_REQUEST_INFO   TSInfo;
    BOOL                            fOk;
    
    BYTE rgTestData[] = {
        0x1b, 0xf6, 0x92, 0xee, 0x6c, 0x44, 0xc5, 0xed, 0x51, 0xe4, 0x1a, 0xac, 0x21, 0x07, 0x2f, 0x63,
        0x6b, 0xc9, 0x27, 0x30, 0x90, 0xb8, 0x3c, 0xa6, 0x75, 0xf8, 0x17, 0x5a, 0x28, 0x2b, 0xe7, 0x3f,
        0xd7, 0x47, 0xad, 0x82, 0x1a, 0x34, 0x37, 0x27, 0x22, 0xd2, 0x64, 0x8b, 0x24, 0xe6, 0x42, 0x55,
        0x8a, 0xfe, 0xd1, 0xb4, 0xcf, 0x96, 0xa3, 0xea, 0x90, 0xf9, 0x2b, 0xeb, 0x16, 0x27, 0xaa, 0x5b
    };
    
    // initialize the timestamp structure
    TSInfo.pszTimeStampAlgorithm = szOID_RSA_signingTime;
    TSInfo.pszContentType = szOID_RSA_data;
    TSInfo.Content.cbData = sizeof(rgTestData);
    TSInfo.Content.pbData = rgTestData;
    TSInfo.cAttribute = 0; 
    TSInfo.rgAttribute = NULL;

    if( (fOk = TimeStampTest(&TSInfo) ) == TRUE ) {
        TSInfo.Content.cbData = 0;
        TSInfo.Content.pbData = NULL;    
        fOk = TimeStampTest(&TSInfo);
    }
    
    return(fOk);
}

static BOOL TestPKCS10Attr() {

    CRYPT_ENROLLMENT_NAME_VALUE_PAIR    nameValuePair   = {L"Name", L"Value"};
    PCRYPT_ENROLLMENT_NAME_VALUE_PAIR   pNameValuePair  = NULL;
    DWORD                               cb              = 0;
    CRYPT_DATA_BLOB                     blob;
    BOOL                                fOk             = TRUE;

    BYTE                                signatureData[] = {0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA};
    CRYPT_CSP_PROVIDER                  cspProvider     = {32, L"My CSP", {sizeof(signatureData), signatureData, 0}};
    PCRYPT_CSP_PROVIDER                 pCSPProvider    = NULL;
    
    memset(&blob, 0, sizeof(CRYPT_DATA_BLOB));

    if(!CryptEncodeObjectEx(
        CRYPT_ASN_ENCODING,
        szOID_ENROLLMENT_NAME_VALUE_PAIR,
        &nameValuePair,
        CRYPT_ENCODE_ALLOC_FLAG,
        NULL,
        &blob.pbData,
        &blob.cbData
        ))
        goto ErrorCryptEncodeNameValuePair;

    if(!CryptDecodeObjectEx(
        CRYPT_ASN_ENCODING,
        szOID_ENROLLMENT_NAME_VALUE_PAIR,
        blob.pbData,
        blob.cbData,
        CRYPT_ENCODE_ALLOC_FLAG,
        NULL,
        &pNameValuePair,
        &cb
        ))
        goto ErrorCryptDecodeNameValuePair;

    if(
        wcscmp(nameValuePair.pwszName, pNameValuePair->pwszName)    ||
        wcscmp(nameValuePair.pwszValue, pNameValuePair->pwszValue)  )
        goto CompareNameValuePair;
            

    // szOID_ENROLLMENT_CSP_PROVIDER
    assert(blob.pbData != NULL);
    LocalFree(blob.pbData);
    memset(&blob, 0, sizeof(CRYPT_DATA_BLOB));
    cb = 0;

    if(!CryptEncodeObjectEx(
        CRYPT_ASN_ENCODING,
        szOID_ENROLLMENT_CSP_PROVIDER,
        &cspProvider,
        CRYPT_ENCODE_ALLOC_FLAG,
        NULL,
        &blob.pbData,
        &blob.cbData
        ))
        goto ErrorCryptEncodeCSPProvider;

    if(!CryptDecodeObjectEx(
        CRYPT_ASN_ENCODING,
        szOID_ENROLLMENT_CSP_PROVIDER,
        blob.pbData,
        blob.cbData,
        CRYPT_ENCODE_ALLOC_FLAG,
        NULL,
        &pCSPProvider,
        &cb
        ))
        goto ErrorCryptDecodeCSPProvider;

    if(
        wcscmp(cspProvider.pwszProviderName, pCSPProvider->pwszProviderName)    ||
        cspProvider.Signature.cbData != pCSPProvider->Signature.cbData  ||
        cspProvider.Signature.cUnusedBits != pCSPProvider->Signature.cUnusedBits  ||
        cspProvider.dwKeySpec != pCSPProvider->dwKeySpec                            ||
        memcmp(cspProvider.Signature.pbData, pCSPProvider->Signature.pbData, cspProvider.Signature.cbData)  )
        goto CompareCSPProvider;

CommonReturn:

    if(blob.pbData != NULL)
        LocalFree(blob.pbData);
        
    if(pNameValuePair != NULL)
        LocalFree(pNameValuePair);
        
    if(pCSPProvider != NULL)
        LocalFree(pCSPProvider);
        
    return(fOk);

ErrorReturn:

    fOk = FALSE;
    goto CommonReturn;

    // TRACE_ERROR(BuildTimeStampError);
    TRACE_ERROR(ErrorCryptEncodeNameValuePair);
    TRACE_ERROR(ErrorCryptDecodeNameValuePair);
    TRACE_ERROR(CompareNameValuePair);
    TRACE_ERROR(ErrorCryptEncodeCSPProvider);
    TRACE_ERROR(ErrorCryptDecodeCSPProvider);
    TRACE_ERROR(CompareCSPProvider);

}



typedef BOOL (*PFN_TEST)(void);
static struct
{
    LPCSTR      pszName;
    PFN_TEST    pfn;
} Tests[] = {
    "Sign",             TestSign,
    "Envelope",         TestEnvelope,
    "SignAndEnvelope",  TestSignAndEnvelope,
    "Hash",             TestHash,
    "ComputedHash",     TestComputedHash,
    "NoCertSign",       TestNoCertSign,
    "TimeStamp",        TestTimeStamp,
    "PKCS10Attr",       TestPKCS10Attr
};
#define NTESTS (sizeof(Tests)/sizeof(Tests[0]))

static void Usage(void)
{
    int i;

    printf("Usage: tsca [options] <StoreFilename> [<TestName>] [<CertNameString>]\n");
    printf("Options are:\n");
#ifdef CMS_PKCS7
    printf("  -EncapsulatedContent  - CMS encapsulated content\n");
    printf("  -SP3Encrypt           - SP3 compatible encrypt\n");
    printf("  -DefaultGetSigner     - Use default GetSignerCertificate\n");
    printf("  -NoRecipients         - No Envelope Recipients\n");
    printf("  -AllRecipients        - All Envelope Recipients in store\n");
    printf("  -RecipientKeyId       - Use KeyId for recipients\n");
    printf("  -SignerKeyId          - Use KeyId for signers\n");
    printf("  -HashEncryptionAlgorithm - Use signature as hash encrypt algorithm\n");
    printf("  -NoSalt               - NoSalt for RC4\n");
    printf("  -SilentKey            - Silent private key usage\n");
#endif  // CMS_PKCS7
    printf("  -h                    - This message\n");
    printf("  -A                    - Authenticated Attributes\n");
    printf("  -D                    - Detached Hash or Signature\n");
    printf("  -I                    - Inner Signed Content for SignAndEnvelope\n");
    printf("  -X                    - Sign using keyeXchange\n");
    printf("  -l                    - Print command line\n");
    printf("  -v                    - Verbose\n");
    printf("  -H<name>              - Hash algorithm, default of \"md5\"\n");
    printf("  -E<name>              - Encrypt algorithm, default of \"rc2\"\n");
    printf("  -e<EncryptBitLen>     - Encrypt key bit length\n");
    printf("  -i                    - Include IV in encrypt parameters\n");
    printf("  -p<provider>          - Specify crypto provider type number\n");
    printf("  -P<PubKeyBitLen>      - Public key bit length\n");
    printf("  -r<filename>          - Read encoded message from file\n");
    printf("  -m<filename>          - Write encoded message to file\n");
    printf("  -c<filename>          - Write message cert store to file\n");
    printf("  -0                    - Zero length content\n");
#ifdef ENABLE_SCA_STREAM_TEST
    printf("  -s                    - Enable streaming\n");
    printf("  -S                    - Enable indefinite length streaming\n");
#endif
    printf("\n");
    printf("Tests are (case insensitive name):\n");
    for (i = 0; i < NTESTS; i++)
        printf("  %s\n", Tests[i].pszName);
    printf("\n");
    printf("Default: ALL Tests\n");
}


int _cdecl main(int argc, char * argv[]) 
{
    BOOL fResult;
    LPSTR pszStoreFilename = NULL;
    LPSTR pszTestName = NULL;
    int TestIdx = 0;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
#ifdef CMS_PKCS7
            if (0 == _stricmp(argv[0]+1, "EncapsulatedContent")) {
                fEncapsulatedContent = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "SP3Encrypt")) {
                fSP3Encrypt = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "DefaultGetSigner")) {
                fDefaultGetSigner = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "NoRecipients")) {
                fNoRecipients = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "AllRecipients")) {
                fAllRecipients = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "RecipientKeyId")) {
                fRecipientKeyId = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "SignerKeyId")) {
                fSignerKeyId = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "HashEncryptionAlgorithm")) {
                fHashEncryptionAlgorithm = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "NoSalt")) {
                fNoSalt = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "SilentKey")) {
                fSilentKey = TRUE;
            } else {
#endif  // CMS_PKCS7
                switch(argv[0][1])
                {
                case 'A':
                    fAuthAttr = TRUE;
                    break;
                case 'D':
                    fDetached = TRUE;
                    break;
                case 'I':
                    fInnerSigned = TRUE;
                    break;
                case 'l':
                    printf("command line: %s\n", GetCommandLine());
                    break;
                case 'p':
                    dwCryptProvType = strtoul( argv[0]+2, NULL, 0);
                    break;
                case 'P':
                    dwPubKeyBitLen = strtoul( argv[0]+2, NULL, 0);
                    break;
                case 'H':
                    pszHashName = argv[0]+2;
                    break;
                case 'E':
                    pszEncryptName = argv[0]+2;
                    break;
                case 'e':
                    dwEncryptBitLen = strtoul( argv[0]+2, NULL, 0);
                    break;
                case 'i':
                    fEncryptIV = TRUE;
                    break;
                case 'v':
                    fVerbose = TRUE;
                    break;
                case 'X':
                    dwSignKeySpec = AT_KEYEXCHANGE;
                    break;
                case 'm':
                    pszMsgEncodedFilename = argv[0]+2;
                    if (*pszMsgEncodedFilename == '\0') {
                        printf("Need to specify filename\n");
                        Usage();
                        return -1;
                    }
                    break;
                case 'c':
                    pszMsgCertFilename = argv[0]+2;
                    if (*pszMsgCertFilename == '\0') {
                        printf("Need to specify filename\n");
                        Usage();
                        return -1;
                    }
                    break;
                case 'r':
                    pszReadEncodedFilename = argv[0]+2;
                    if (*pszReadEncodedFilename == '\0') {
                        printf("Need to specify filename\n");
                        Usage();
                        return -1;
                    }
                    break;
                case '0':
                    cbToBeEncoded = 0;
                    rgcbDetachedToBeEncoded[0] = 0;
                    break;
    #ifdef ENABLE_SCA_STREAM_TEST
                case 'S':
                    fIndefiniteStream = TRUE;
                case 's':
                    fStream = TRUE;
                    break;
    #endif
                case 'h':
                default:
                    Usage();
                    return -1;
                }
#ifdef CMS_PKCS7
            }
#endif  // CMS_PKCS7
        } else {
            if (pszStoreFilename == NULL)
                pszStoreFilename = argv[0];
            else if(pszTestName == NULL)
                pszTestName = argv[0];
            else if (pszCertNameFindStr == NULL)
                pszCertNameFindStr = argv[0];
            else {
                printf("Too many arguments\n");
                Usage();
                return -1;
            }
        }
    }

    if (pszStoreFilename == NULL) {
        printf("missing store filename\n");
        Usage();
        return -1;
    }

    if (pszTestName) {
        for (TestIdx = 0; TestIdx < NTESTS; TestIdx++) {
            if (_stricmp(pszTestName, Tests[TestIdx].pszName) == 0)
                break;
        }
        if (TestIdx >= NTESTS) {
            printf("Bad TestName: %s\n", pszTestName);
            Usage();
            return -1;
        }
            
    } else
        TestIdx = 0;

    if (fDetached) printf("Detached Enabled ");
    if (pszReadEncodedFilename)
        printf("Reading encoded msg from file: %s ", pszReadEncodedFilename);
    if (pszMsgEncodedFilename)
        printf("Writing encoded msg to file: %s ", pszMsgEncodedFilename);
    if (pszMsgCertFilename)
        printf("Writing msg cert store to file: %s ", pszMsgCertFilename);
    printf("\n");

    // Attempt to open the store
    hCertStore = OpenStore(pszStoreFilename);
    if (hCertStore == NULL)
        goto ErrorReturn;

    for ( ; TestIdx < NTESTS; TestIdx++) {
        printf("Starting %s Test\n", Tests[TestIdx].pszName);
        fResult = Tests[TestIdx].pfn();
        if (fResult)
            printf("Passed\n");
        else
            printf("Failed\n");
        printf("\n");
        if (pszTestName)
            break;
    }

ErrorReturn:
    if (hCertStore) {
        if (!CertCloseStore(hCertStore, CERT_CLOSE_STORE_CHECK_FLAG))
            PrintLastError("CertCloseStore");
    }
    return 0;
}

static BOOL NameAttributeValueCompare(
    IN const BYTE *pbValue,
    IN DWORD cbValue,
    IN PCERT_NAME_BLOB pName
    )
{
    BOOL fResult;
    PCERT_NAME_INFO pInfo = NULL;
    DWORD cbInfo;
    DWORD cRDN, cAttr;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;
    
    cbInfo = 0;
    fResult = CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pName->pbData,
            pName->cbData,
            0,                      // dwFlags
            NULL,                   // pInfo
            &cbInfo
            );
    if (!fResult || cbInfo == 0) {
        PrintLastError(
            "NameAttributeValueCompare::CryptDecodeObject(cbInfo == 0)");
        goto ErrorReturn;
    }
    pInfo = (PCERT_NAME_INFO) TestAlloc(cbInfo);
    if (pInfo == NULL) goto ErrorReturn;
    if (!CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pName->pbData,
            pName->cbData,
            0,                              // dwFlags
            pInfo,
            &cbInfo
            )) {
        PrintLastError("NameAttributeValueCompare::CryptDecodeObject");
        goto ErrorReturn;
    }

    for (cRDN = pInfo->cRDN, pRDN = pInfo->rgRDN; cRDN > 0; cRDN--, pRDN++) {
        for (cAttr = pRDN->cRDNAttr, pAttr = pRDN->rgRDNAttr;
                                                cAttr > 0; cAttr--, pAttr++) {
            if (pAttr->Value.cbData == cbValue &&
                    memcmp(pAttr->Value.pbData, pbValue, cbValue) == 0) {
                fResult = TRUE;
                goto CommonReturn;
            }
        }
    }
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}

static PCCERT_CONTEXT FindCertWithKey(IN DWORD dwKeySpec)
{
    PCCERT_CONTEXT pCert;
    void *pvFindPara;
    DWORD dwFindType;

    if (pszCertNameFindStr) {
        dwFindType = CERT_FIND_SUBJECT_STR_A;
        pvFindPara = (void *) pszCertNameFindStr;
    } else {
        dwFindType = CERT_FIND_ANY;
        pvFindPara = NULL;
    }

    // Find the first certificate in the store with a CRYPT_KEY_PROV_INFO
    // property matching the specified dwSignKeySpec, dwCryptProvType and
    // dwPubKeyBitLen
    pCert = NULL;
    while (TRUE) {
        pCert = CertFindCertificateInStore(
            hCertStore,
            dwCertEncodingType,
            0,                      // dwFindFlags,
            dwFindType,
            pvFindPara,
            pCert
            );
        if (pCert == NULL)
            break;

        PCRYPT_KEY_PROV_INFO pInfo = NULL;
        DWORD cbInfo = 0;
        CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,
            &cbInfo
            );
        if (cbInfo >= sizeof(CRYPT_KEY_PROV_INFO) &&
                (pInfo = (PCRYPT_KEY_PROV_INFO) TestAlloc(cbInfo))) {
            BOOL fMatch = FALSE;
            if (CertGetCertificateContextProperty(
                        pCert,
                        CERT_KEY_PROV_INFO_PROP_ID,
                        pInfo,
                        &cbInfo) && 
                    dwKeySpec == pInfo->dwKeySpec &&
                    dwCryptProvType == pInfo->dwProvType) {
                if (0 == dwPubKeyBitLen)
                    fMatch = TRUE;
                else
                    fMatch = (dwPubKeyBitLen == CertGetPublicKeyLength(
                        pCert->dwCertEncodingType,
                        &pCert->pCertInfo->SubjectPublicKeyInfo));
            }
            TestFree(pInfo);
            if (fMatch)
                break;
        }
    }
    return pCert;
}
    

static BOOL InitSignPara(OUT PCRYPT_SIGN_MESSAGE_PARA pPara)
{
    BOOL fResult;
    PCCERT_CONTEXT pCert;
    PCCERT_CONTEXT pIssuer;
    PCCRL_CONTEXT pCrl;
    DWORD dwFlags;
    BYTE bIntendedKeyUsage;

    memset(pPara, 0, sizeof(*pPara));
    pPara->cbSize = sizeof(*pPara);
    pPara->dwMsgEncodingType = dwMsgEncodingType;
    if (NULL == (pPara->HashAlgorithm.pszObjId = (LPSTR) GetOID(
            pszHashName, CRYPT_HASH_ALG_OID_GROUP_ID))) {
        printf("Failed => unknown hash name (%s) for signing\n",
            pszHashName);
        goto ErrorReturn;
    }


#ifdef ENABLE_SCA_STREAM_TEST
    if (fStream) {
        pPara->dwFlags |= SCA_STREAM_ENABLE_FLAG;
        if (fIndefiniteStream)
            pPara->dwFlags |= SCA_INDEFINITE_STREAM_FLAG;
    }
#endif

#ifdef CMS_PKCS7
    if (fSignerKeyId)
        pPara->dwFlags |= CRYPT_MESSAGE_KEYID_SIGNER_FLAG;
    if (fEncapsulatedContent) {
        pPara->dwFlags |= CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG;
        pPara->dwInnerContentType = CMSG_HASHED;
    }

    if (fSilentKey)
        pPara->dwFlags |= CRYPT_MESSAGE_SILENT_KEYSET_FLAG;
#endif  // CMS_PKCS7

    pPara->rgpMsgCert = (PCCERT_CONTEXT*) TestAlloc(
        sizeof(PCCERT_CONTEXT) * MAX_MSG_CERT);
    if (pPara->rgpMsgCert == NULL) goto ErrorReturn;
    pPara->rgpMsgCrl = (PCCRL_CONTEXT*) TestAlloc(
        sizeof(PCCRL_CONTEXT) * MAX_MSG_CRL);
    if (pPara->rgpMsgCrl == NULL) goto ErrorReturn;

    pCert = FindCertWithKey(dwSignKeySpec);
    if (pCert == NULL) {
        PrintError("Couldn't find a cert having a key provider");
        goto ErrorReturn;
    } else if (fVerbose) {
        printf("-----  Signer  -----\n");
        DisplayCert(pCert);
    }

#ifdef CMS_PKCS7
    if (fHashEncryptionAlgorithm) {
        pPara->HashEncryptionAlgorithm = pCert->pCertInfo->SignatureAlgorithm;
    }
#endif  // CMS_PKCS7

    pPara->pSigningCert = pCert;
    pPara->cMsgCert = 1;
    pPara->rgpMsgCert[0] = pCert;

    // Add the cert's issuer certs to the message. Add the issuer CRLs to
    // the message.
    while (TRUE) {
        dwFlags = 0;
        pIssuer = CertGetIssuerCertificateFromStore(
            hCertStore,
            pCert,
            NULL,           // pPrevIssuerContext
            &dwFlags
            );
        if (pIssuer == NULL) break;
        if (pPara->cMsgCert == MAX_MSG_CERT) {
            PrintError("cMsgCert == MAX_MSG_CERT");
            CertFreeCertificateContext(pIssuer);
            break;
        }
        pCert = pIssuer;
        pPara->rgpMsgCert[pPara->cMsgCert++] = pCert;

        pCrl = NULL;
        while (TRUE) {
            dwFlags = 0;
            pCrl = CertGetCRLFromStore(
                pIssuer->hCertStore,
                pIssuer,
                pCrl,
                &dwFlags
                );
            if (pCrl == NULL) break;
            if (pPara->cMsgCrl == MAX_MSG_CRL) {
                PrintError("cMsgCrl == MAX_MSG_CRL");
                CertFreeCRLContext(pCrl);
                break;
            }
            pPara->rgpMsgCrl[pPara->cMsgCrl++] = CertDuplicateCRLContext(pCrl);
        }
    }

    if (fAuthAttr) {
        pPara->cAuthAttr = AUTH_ATTR_COUNT;
        pPara->rgAuthAttr = rgAuthAttr;
    }

    if (fVerbose) {
        DWORD i;

        printf("Msg Certs: %d MsgCrls: %d\n", pPara->cMsgCert, pPara->cMsgCrl);
        for (i = 0; i < pPara->cMsgCert; i++) {
            printf("-----  Msg Cert[%i]  -----\n", i);
            DisplayCert(pPara->rgpMsgCert[i]);
        }
        for (i = 0; i < pPara->cMsgCrl; i++) {
            printf("-----  Msg Crl[%i]  -----\n", i);
            DisplayCrl(pPara->rgpMsgCrl[i]);
        }
    }
    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    FreeSignPara(pPara);
    fResult = FALSE;
CommonReturn:
    return fResult;
}

static void FreeSignPara(IN PCRYPT_SIGN_MESSAGE_PARA pPara)
{
    while (pPara->cMsgCert-- > 0)
        CertFreeCertificateContext(pPara->rgpMsgCert[pPara->cMsgCert]);
    while (pPara->cMsgCrl-- > 0)
        CertFreeCRLContext(pPara->rgpMsgCrl[pPara->cMsgCrl]);

    if (pPara->rgpMsgCert)
        TestFree(pPara->rgpMsgCert);
    if (pPara->rgpMsgCrl)
        TestFree(pPara->rgpMsgCrl);
    memset(pPara, 0, sizeof(*pPara));
}

static PCCERT_CONTEXT WINAPI GetSignerCertificate(
    IN void *pvGetArg,
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pSignerId,    // Only the Issuer and SerialNumber
                                // fields are used
    IN HCERTSTORE hMsgCertStore
    )
{
    if (fVerbose)
        printf("GetSignerCertificate pSignerId = 0x%p\n", pSignerId);
    return CertGetSubjectCertificateFromStore(hMsgCertStore, dwCertEncodingType,
        pSignerId);
}

static BOOL InitVerifyPara(OUT PCRYPT_VERIFY_MESSAGE_PARA pPara)
{
    memset(pPara, 0, sizeof(*pPara));
    pPara->cbSize = sizeof(*pPara);
    pPara->dwMsgAndCertEncodingType =
        dwMsgEncodingType | dwCertEncodingType;
#ifdef ENABLE_SCA_STREAM_TEST
    if (fStream)
        pPara->dwMsgAndCertEncodingType |= SCA_STREAM_ENABLE_FLAG;
#endif
    pPara->hCryptProv = 0;
#ifdef CMS_PKCS7
    if (!fDefaultGetSigner)
#endif
        pPara->pfnGetSignerCertificate = GetSignerCertificate;
    return TRUE;
}

static void FreeVerifyPara(IN PCRYPT_VERIFY_MESSAGE_PARA pPara)
{
}

#define IV_LENGTH 8
static BOOL GetIV(BYTE rgbIV[IV_LENGTH])
{

    SYSTEMTIME st;
    GetSystemTime(&st);
    assert(IV_LENGTH == sizeof(FILETIME));
    SystemTimeToFileTime(&st, (LPFILETIME) rgbIV);
    return TRUE;
}


static BOOL InitEncryptPara(
    OUT PCRYPT_ENCRYPT_MESSAGE_PARA pPara,
    OUT DWORD *pcRecipientCert,
    OUT PCCERT_CONTEXT **pppRecipientCert
    )
{
    BOOL fResult;
    PCCERT_CONTEXT pCert;
    BYTE bIntendedKeyUsage;

    PCRYPT_OBJID_BLOB pAlgPara;

    *pppRecipientCert = NULL;
    memset(pPara, 0, sizeof(*pPara));
    pPara->cbSize = sizeof(*pPara);
    pPara->dwMsgEncodingType = dwMsgEncodingType;
    pPara->hCryptProv = 0;

#ifdef ENABLE_SCA_STREAM_TEST
    if (fStream) {
        pPara->dwFlags |= SCA_STREAM_ENABLE_FLAG;
        if (fIndefiniteStream)
            pPara->dwFlags |= SCA_INDEFINITE_STREAM_FLAG;
    }
#endif

#ifdef CMS_PKCS7
    if (fRecipientKeyId)
        pPara->dwFlags |= CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG;

    if (fEncapsulatedContent) {
        pPara->dwFlags |= CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG;
        pPara->dwInnerContentType = CMSG_HASHED;
    }
#endif  // CMS_PKCS7

    if (NULL == (pPara->ContentEncryptionAlgorithm.pszObjId = (LPSTR) GetOID(
            pszEncryptName, CRYPT_ENCRYPT_ALG_OID_GROUP_ID))) {
        printf("Failed => unknown encrypt name (%s)\n", pszEncryptName);
        goto ErrorReturn;
    }
    pAlgPara = &pPara->ContentEncryptionAlgorithm.Parameters;

    if (0 != dwEncryptBitLen && CALG_RC2 == GetAlgid(
            pszEncryptName, CRYPT_ENCRYPT_ALG_OID_GROUP_ID)) {
        if (fEncryptIV) {
            CRYPT_RC2_CBC_PARAMETERS RC2Parameters;

            switch (dwEncryptBitLen) {
                case 40:
                    RC2Parameters.dwVersion = CRYPT_RC2_40BIT_VERSION;
                    break;
                case 64:
                    RC2Parameters.dwVersion = CRYPT_RC2_64BIT_VERSION;
                    break;
                case 128:
                    RC2Parameters.dwVersion = CRYPT_RC2_128BIT_VERSION;
                    break;
                default:
                    printf("Failed => unknown RC2 length (%d)\n",
                        dwEncryptBitLen);
                    goto ErrorReturn;
            }
            RC2Parameters.fIV = fEncryptIV;
            if (fEncryptIV) {
                if (!GetIV(RC2Parameters.rgbIV))
                    goto ErrorReturn;
            }

            if (!AllocAndEncodeObject(
                    PKCS_RC2_CBC_PARAMETERS,
                    &RC2Parameters,
                    &pAlgPara->pbData,
                    &pAlgPara->cbData))
                goto ErrorReturn;
        } else {
            RC2AuxInfo.cbSize = sizeof(RC2AuxInfo);
            RC2AuxInfo.dwBitLen = dwEncryptBitLen;
            pPara->pvEncryptionAuxInfo = &RC2AuxInfo;
#ifdef CMS_PKCS7
            if (fSP3Encrypt)
                RC2AuxInfo.dwBitLen |= CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;
#endif
        }
    } else if (CALG_RC4 == GetAlgid(pszEncryptName,
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID)) {
        if (fEncryptIV) {
            CRYPT_DATA_BLOB Salt;
            DWORD i;

            for (i = 0; i < MAX_SALT_LEN; i++)
                rgbSalt[i] = (BYTE) i;

            Salt.cbData = MAX_SALT_LEN;
            Salt.pbData = rgbSalt;

            if (!AllocAndEncodeObject(
                    X509_OCTET_STRING,
                    &Salt,
                    &pAlgPara->pbData,
                    &pAlgPara->cbData
                    ))
                goto ErrorReturn;
        } else if (0 != dwEncryptBitLen) {
            memset(&RC4AuxInfo, 0, sizeof(RC4AuxInfo));
            RC4AuxInfo.cbSize = sizeof(RC4AuxInfo);
            RC4AuxInfo.dwBitLen = dwEncryptBitLen;
            if (fNoSalt)
                RC4AuxInfo.dwBitLen |= CMSG_RC4_NO_SALT_FLAG;
            pPara->pvEncryptionAuxInfo = &RC4AuxInfo;
        }
    } else if (fEncryptIV) {
        BYTE rgbIV[IV_LENGTH];
        CRYPT_DATA_BLOB Data;

        Data.pbData = rgbIV;
        Data.cbData = sizeof(rgbIV);

        if (!GetIV(rgbIV))
            goto ErrorReturn;
        if (!AllocAndEncodeObject(
                X509_OCTET_STRING,
                &Data,
                &pAlgPara->pbData,
                &pAlgPara->cbData))
            goto ErrorReturn;
    }
#ifdef CMS_PKCS7
    else if (fSP3Encrypt) {
        RC2AuxInfo.cbSize = sizeof(RC2AuxInfo);
        RC2AuxInfo.dwBitLen = CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;
        pPara->pvEncryptionAuxInfo = &RC2AuxInfo;
    }
#endif

    *pcRecipientCert = 0;
    *pppRecipientCert = (PCCERT_CONTEXT*) TestAlloc(
        sizeof(PCCERT_CONTEXT) * MAX_RECIPIENT_CERT);
    if (*pppRecipientCert == NULL) goto ErrorReturn;

#ifdef CMS_PKCS7
    if (fNoRecipients)
        ;
    else if (fAllRecipients) {
        pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hCertStore, pCert)) {
            if (*pcRecipientCert == MAX_RECIPIENT_CERT) {
                PrintError("cRecipientCert == MAX_RECIPIENT_CERT");
                CertFreeCertificateContext(pCert);
                break;
            }
            (*pppRecipientCert)[*pcRecipientCert] =
                CertDuplicateCertificateContext(pCert);
            *pcRecipientCert += 1;
        }
    } else
#endif  // CMS_PKCS7
    if (0 != dwPubKeyBitLen && !IsDSSProv(dwCryptProvType)) {
        // Get exchange cert of the specified key length
        pCert = FindCertWithKey(AT_KEYEXCHANGE);
        if (pCert == NULL) {
            printf(
                "Failed => couldn't find an exchange cert with key length (%d)\n",
                    dwPubKeyBitLen);
            goto ErrorReturn;
        } else {
            (*pppRecipientCert)[*pcRecipientCert] = pCert;
            *pcRecipientCert += 1;
        }
    } else {
        // Find certificates in the store with xchg key usage
        pCert = NULL;
        while (TRUE) {
            pCert = CertEnumCertificatesInStore(
                hCertStore,
                pCert);
            if (pCert == NULL)
                break;

            CertGetIntendedKeyUsage(
                dwCertEncodingType,
                pCert->pCertInfo,
                &bIntendedKeyUsage,
                1                   // cbKeyUsage
                );
            if (bIntendedKeyUsage &
                    (CERT_KEY_ENCIPHERMENT_KEY_USAGE |
                        CERT_DATA_ENCIPHERMENT_KEY_USAGE |
                        CERT_KEY_AGREEMENT_KEY_USAGE)) {
                if (*pcRecipientCert == MAX_RECIPIENT_CERT) {
                    PrintError("cRecipientCert == MAX_RECIPIENT_CERT");
                    CertFreeCertificateContext(pCert);
                    break;
                }
                (*pppRecipientCert)[*pcRecipientCert] =
                    CertDuplicateCertificateContext(pCert);
                *pcRecipientCert += 1;
            }
        }
    }

#ifdef CMS_PKCS7
    if (fNoRecipients)
        ;
    else
#endif  // CMS_PKCS7
    if (*pcRecipientCert == 0) {
        PrintError("Couldn't find a recipient xchg cert");
        goto ErrorReturn;
    } else {
        DWORD i;

        if (fVerbose)
            printf("Recipient Certs: %d\n", *pcRecipientCert);
        for (i = 0; i < *pcRecipientCert; i++) {
            if (fVerbose) {
                printf("-----  Recipient Cert[%i]  -----\n", i);
                DisplayCert((*pppRecipientCert)[i]);
            }

            if (!fDhRecipient) {
                PCERT_INFO pCertInfo = (*pppRecipientCert)[i]->pCertInfo;
                PCERT_PUBLIC_KEY_INFO pPublicKeyInfo =
                    &pCertInfo->SubjectPublicKeyInfo;
                PCCRYPT_OID_INFO pOIDInfo;
                ALG_ID aiPubKey;

                if (pOIDInfo = CryptFindOIDInfo(
                        CRYPT_OID_INFO_OID_KEY,
                        pPublicKeyInfo->Algorithm.pszObjId,
                        CRYPT_PUBKEY_ALG_OID_GROUP_ID))
                    aiPubKey = pOIDInfo->Algid;
                else
                    aiPubKey = 0;

                if (aiPubKey == CALG_DH_SF || aiPubKey == CALG_DH_EPHEM) {
                    printf("Has Diffie Hellman recipients\n");
                    fDhRecipient = TRUE;
                }
            }
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    FreeEncryptPara(pPara, *pcRecipientCert, *pppRecipientCert);
    *pcRecipientCert = 0;
    *pppRecipientCert = NULL;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

static void FreeEncryptPara(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT *ppRecipientCert
    )
{
    TestFree(pPara->ContentEncryptionAlgorithm.Parameters.pbData);
    pPara->ContentEncryptionAlgorithm.Parameters.pbData = NULL;
    if (ppRecipientCert) {
        while (cRecipientCert-- > 0) {
            CertFreeCertificateContext(ppRecipientCert[cRecipientCert]);
        }
        TestFree(ppRecipientCert);
    }
}

static BOOL InitDecryptPara(OUT PCRYPT_DECRYPT_MESSAGE_PARA pPara)
{
    memset(pPara, 0, sizeof(*pPara));
    pPara->cbSize = sizeof(*pPara);
    pPara->dwMsgAndCertEncodingType =
        dwMsgEncodingType | dwCertEncodingType;
#ifdef ENABLE_SCA_STREAM_TEST
    if (fStream)
        pPara->dwMsgAndCertEncodingType |= SCA_STREAM_ENABLE_FLAG;
#endif
    pPara->rghCertStore = (HCERTSTORE*) TestAlloc(sizeof(HCERTSTORE));


    if (fSilentKey)
        pPara->dwFlags |= CRYPT_MESSAGE_SILENT_KEYSET_FLAG;

    if (pPara->rghCertStore) {
        pPara->rghCertStore[0] = hCertStore;
        pPara->cCertStore = 1;
        return TRUE;
    } else
        return FALSE;
}

static void FreeDecryptPara(IN PCRYPT_DECRYPT_MESSAGE_PARA pPara)
{
    if (pPara->rghCertStore) {
        TestFree(pPara->rghCertStore);
        pPara->rghCertStore = 0;
    }
}

static BOOL InitHashPara(OUT PCRYPT_HASH_MESSAGE_PARA pPara)
{
    memset(pPara, 0, sizeof(*pPara));
    pPara->cbSize = sizeof(*pPara);
    pPara->dwMsgEncodingType = dwMsgEncodingType;
    pPara->hCryptProv = 0;
    if (NULL == (pPara->HashAlgorithm.pszObjId = (LPSTR) GetOID(
            pszHashName, CRYPT_HASH_ALG_OID_GROUP_ID))) {
        printf("Failed => unknown hash name (%s)\n", pszHashName);
        return FALSE;
    }
    return TRUE;
}

static void FreeHashPara(IN PCRYPT_HASH_MESSAGE_PARA pPara)
{
}

static BOOL DecodeName(BYTE *pbEncoded, DWORD cbEncoded)
{
    BOOL fResult;
    PCERT_NAME_INFO pInfo = NULL;
    DWORD cbInfo;
    DWORD i,j;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;
    
    cbInfo = 0;
    fResult = CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pbEncoded,
            cbEncoded,
            0,                      // dwFlags
            NULL,                   // pInfo
            &cbInfo
            );
    if (!fResult || cbInfo == 0) {
        PrintLastError("DecodeName::CryptDecodeObject(cbInfo == 0)");
        goto ErrorReturn;
    }
    pInfo = (PCERT_NAME_INFO) TestAlloc(cbInfo);
    if (pInfo == NULL) goto ErrorReturn;
    if (!CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pbEncoded,
            cbEncoded,
            0,                              // dwFlags
            pInfo,
            &cbInfo
            )) {
        PrintLastError("DecodeName::CryptDecodeObject");
        goto ErrorReturn;
    }

    for (i = 0, pRDN = pInfo->rgRDN; i < pInfo->cRDN; i++, pRDN++) {
        for (j = 0, pAttr = pRDN->rgRDNAttr; j < pRDN->cRDNAttr; j++, pAttr++) {
            LPSTR pszObjId = pAttr->pszObjId;
            if (pszObjId == NULL)
                pszObjId = "<NULL OBJID>";
            if ((pAttr->dwValueType == CERT_RDN_ENCODED_BLOB) ||
                (pAttr->dwValueType == CERT_RDN_OCTET_STRING)) {
                printf("  [%d,%d] %s ValueType: %d\n",
                    i, j, pszObjId, pAttr->dwValueType);
            } else
                printf("  [%d,%d] %s %s\n",
                    i, j, pszObjId, pAttr->Value.pbData);
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}

static void DisplayCert(PCCERT_CONTEXT pCert)
{
    printf("Subject::\n");
    DecodeName(pCert->pCertInfo->Subject.pbData,
        pCert->pCertInfo->Subject.cbData);
    printf("Issuer::\n");
    DecodeName(pCert->pCertInfo->Issuer.pbData,
        pCert->pCertInfo->Issuer.cbData);

    {
        DWORD cb;
        BYTE *pb;
        printf("SerialNumber::");
        for (cb = pCert->pCertInfo->SerialNumber.cbData,
             pb = pCert->pCertInfo->SerialNumber.pbData + (cb - 1);
                                                        cb > 0; cb--, pb--) {
            printf(" %02X", *pb);
        }
        printf("\n");
    }
}

static void PrintCrlEntries(DWORD cEntry, PCRL_ENTRY pEntry)
{
    DWORD i; 

    for (i = 0; i < cEntry; i++, pEntry++) {
        DWORD cb;
        BYTE *pb;
        printf(" [%d] SerialNumber::", i);
        for (cb = pEntry->SerialNumber.cbData,
             pb = pEntry->SerialNumber.pbData + (cb - 1); cb > 0; cb--, pb++) {
            printf(" %02X", *pb);
        }
        printf("\n");

    }
}

static void DisplayCrl(PCCRL_CONTEXT pCrl)
{
    printf("Issuer::\n");
    DecodeName(pCrl->pCrlInfo->Issuer.pbData,
        pCrl->pCrlInfo->Issuer.cbData);

    if (pCrl->pCrlInfo->cCRLEntry == 0)
        printf("Entries:: NONE\n");
    else {
        printf("Entries::\n");
        PrintCrlEntries(pCrl->pCrlInfo->cCRLEntry,
            pCrl->pCrlInfo->rgCRLEntry);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tstgdir\tstgdir.cpp ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993
//
//  File:       tstgdir.cpp
//
//  Contents:   Recursive directory display of a storage
//              document
//
//  Functions:	main
//
//  History:    04 Nov 94 - Created by philh
//
//-------------------------------------------------------------------------

#include <windows.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>



static int indent = 0;
static BOOL fVerbose = FALSE;
static BOOL fDebug = FALSE;
static BOOL fRead  = FALSE;
static BOOL fReadVerbose  = FALSE;
static BOOL fBrief  = FALSE;

#define READ_BUF_SIZE 10000
static BYTE readBuf[READ_BUF_SIZE];

static CLSID NullClsid;


typedef struct
{
    SCODE sc;
    char *text;
} StatusCodeText;

static StatusCodeText scodes[] =
{
    S_OK, "S_OK",
    S_FALSE, "S_FALSE",
    STG_E_INVALIDFUNCTION, "STG_E_INVALIDFUNCTION",
    STG_E_FILENOTFOUND, "STG_E_FILENOTFOUND",
    STG_E_PATHNOTFOUND, "STG_E_PATHNOTFOUND",
    STG_E_TOOMANYOPENFILES, "STG_E_TOOMANYOPENFILES",
    STG_E_ACCESSDENIED, "STG_E_ACCESSDENIED",
    STG_E_INVALIDHANDLE, "STG_E_INVALIDHANDLE",
    STG_E_INSUFFICIENTMEMORY, "STG_E_INSUFFICIENTMEMORY",
    STG_E_INVALIDPOINTER, "STG_E_INVALIDPOINTER",
    STG_E_NOMOREFILES, "STG_E_NOMOREFILES",
    STG_E_DISKISWRITEPROTECTED, "STG_E_DISKISWRITEPROTECTED",
    STG_E_SEEKERROR, "STG_E_SEEKERROR",
    STG_E_WRITEFAULT, "STG_E_WRITEFAULT",
    STG_E_READFAULT, "STG_E_READFAULT",
    STG_E_SHAREVIOLATION, "STG_E_SHAREVIOLATION",
    STG_E_LOCKVIOLATION, "STG_E_LOCKVIOLATION",
    STG_E_FILEALREADYEXISTS, "STG_E_FILEALREADYEXISTS",
    STG_E_INVALIDPARAMETER, "STG_E_INVALIDPARAMETER",
    STG_E_MEDIUMFULL, "STG_E_MEDIUMFULL",
    STG_E_ABNORMALAPIEXIT, "STG_E_ABNORMALAPIEXIT",
    STG_E_INVALIDHEADER, "STG_E_INVALIDHEADER",
    STG_E_INVALIDNAME, "STG_E_INVALIDNAME",
    STG_E_UNKNOWN, "STG_E_UNKNOWN",
    STG_E_UNIMPLEMENTEDFUNCTION, "STG_E_UNIMPLEMENTEDFUNCTION",
    STG_E_INVALIDFLAG, "STG_E_INVALIDFLAG",
    STG_E_INUSE, "STG_E_INUSE",
    STG_E_NOTCURRENT, "STG_E_NOTCURRENT",
    STG_E_REVERTED, "STG_E_REVERTED",
    STG_E_CANTSAVE, "STG_E_CANTSAVE",
    STG_E_OLDFORMAT, "STG_E_OLDFORMAT",
    STG_E_OLDDLL, "STG_E_OLDDLL",
    STG_E_SHAREREQUIRED, "STG_E_SHAREREQUIRED",
    STG_E_NOTFILEBASEDSTORAGE, "STG_E_NOTFILEBASEDSTORAGE",
    STG_E_EXTANTMARSHALLINGS, "STG_E_EXTANTMARSHALLINGS",
    E_NOINTERFACE, "E_NOINTERFACE",
    STG_S_CONVERTED, "STG_S_CONVERTED"
};
#define NSCODETEXT (sizeof(scodes)/sizeof(scodes[0]))


// Convert a HRESULT to text
static char *hResultText(HRESULT hResult)
{
    static char buf[80];
    int i;

    for (i = 0; i<NSCODETEXT; i++)
	if (scodes[i].sc == hResult)
	    return scodes[i].text;
    sprintf(buf, "%lx", hResult);
    return buf;
}

static void DirPrintf(const char * Format, ...)
{
    int i = indent;
    va_list pArgs;
    char    aBuf[256];

    while (i-- > 0)
        printf("  ");

    va_start( pArgs, Format );
    vsprintf(aBuf, Format, pArgs);
    printf("%s", aBuf);
}


#pragma pack(1)
struct SplitGuid
{
    DWORD dw1;
    WORD w1;
    WORD w2;
    BYTE b[8];
};
#pragma pack()

static char *GuidText(GUID *pguid)
{
    static char buf[39];
    SplitGuid *psg = (SplitGuid *)pguid;

    sprintf(buf, "{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            psg->dw1, psg->w1, psg->w2, psg->b[0], psg->b[1], psg->b[2],
            psg->b[3], psg->b[4], psg->b[5], psg->b[6], psg->b[7]);
    return buf;
}

static char *FileTimeText(FILETIME *pft)
{
    static char buf[80];
    FILETIME ftLocal;
    struct tm ctm;
    SYSTEMTIME st;
        
    FileTimeToLocalFileTime(pft, &ftLocal);
    if (FileTimeToSystemTime(&ftLocal, &st))
    {
        ctm.tm_sec = st.wSecond;
        ctm.tm_min = st.wMinute;
        ctm.tm_hour = st.wHour;
        ctm.tm_mday = st.wDay;
        ctm.tm_mon = st.wMonth-1;
        ctm.tm_year = st.wYear-1900;
        ctm.tm_wday = st.wDayOfWeek;
        ctm.tm_yday  = 0;
        ctm.tm_isdst = 0;
        strcpy(buf, asctime(&ctm));
        buf[strlen(buf)-1] = 0;
    }
    else
        sprintf(buf, "<FILETIME %08lX:%08lX>", pft->dwHighDateTime,
                pft->dwLowDateTime);
    return buf;
}

static void DispStatStg(STATSTG *pStatStg)
{
    char *szSTGTY;

    switch (pStatStg->type) {
        case STGTY_STORAGE:
            szSTGTY = "STGTY_STORAGE";
            break;
        case STGTY_STREAM:
            szSTGTY = "STGTY_STREAM";
            break;
        case STGTY_LOCKBYTES:
            szSTGTY = "STGTY_LOCKBYTES";
            break;
        default:
            szSTGTY = "STGTY_???";
    }

    
    if (pStatStg->type == STGTY_STREAM)
        DirPrintf("%S %s size:%ld\n", pStatStg->pwcsName, szSTGTY,
            pStatStg->cbSize.LowPart);
    else {
        DirPrintf("%S %s\n", pStatStg->pwcsName, szSTGTY);
        if (!fBrief && pStatStg->clsid != NullClsid)
            DirPrintf("CLSID: %s\n", GuidText(&pStatStg->clsid));
    }
    if (fVerbose) {
        DirPrintf("size: %ld,%ld Mode: %lx StateBits: %lx Locks: %ld\n",
            pStatStg->cbSize.HighPart, pStatStg->cbSize.LowPart,
            pStatStg->grfMode, pStatStg->grfStateBits,
            pStatStg->grfLocksSupported);
        if ((pStatStg->mtime.dwHighDateTime != 0) ||
            (pStatStg->mtime.dwLowDateTime != 0))
            DirPrintf("mtime %s\n", FileTimeText(&pStatStg->mtime));
        if ((pStatStg->ctime.dwHighDateTime != 0) ||
            (pStatStg->ctime.dwLowDateTime != 0))
            DirPrintf("ctime %s\n", FileTimeText(&pStatStg->ctime));
        if ((pStatStg->atime.dwHighDateTime != 0) ||
            (pStatStg->atime.dwLowDateTime != 0))
            DirPrintf("atime %s\n", FileTimeText(&pStatStg->atime));
    }
}

#define CROW 16
void BinText(ULONG cbSize, BYTE *pb)
{
    ULONG cb, i;

    while (cbSize > 0)
    {
        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            printf(" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                printf("%c", pb[i]);
            else
                printf(".");
        pb += cb;
        printf("'\n");
    }
}

void DispStream(IStream *pstm);
void DispStorage(IStorage *pstg);


void DispStream(IStream *pstm)
{
    HRESULT hResult;
    STATSTG statStg;

	hResult = pstm->Stat(&statStg, STATFLAG_DEFAULT);
    if (SUCCEEDED(hResult)) {
        DispStatStg(&statStg);
        if (statStg.pwcsName != NULL)
            CoTaskMemFree(statStg.pwcsName);
    } else {
        DirPrintf("Stat => %lx\n", hResult);
        return;
    }

    if (fRead) {
	    ULONG ulTotalRead = 0;
	    ULONG ulBytesRead;
        int i = 0;
        while (TRUE) {
            ulBytesRead = 0;
            hResult = pstm->Read(readBuf, READ_BUF_SIZE, &ulBytesRead);
            if (FAILED(hResult)) {
                DirPrintf("IStream->Read => %lx\n", hResult);
                break;
            }
            if (fReadVerbose) {
                DirPrintf("%lu bytes starting at offset: 0x%08lX\n",
                    ulBytesRead, ulTotalRead);
                BinText(ulBytesRead, readBuf);
            }
            ulTotalRead += ulBytesRead;
            if (ulBytesRead < READ_BUF_SIZE)
                break;
            i++;
            if (i % 10 == 0) {
                if (fReadVerbose)
                    DirPrintf("Read %ld bytes\n", ulTotalRead);
                else
                    DirPrintf("Read %ld bytes\r", ulTotalRead);
            }
        }
        DirPrintf("Read %ld bytes\n", ulTotalRead);
    }
}


void DispStorage(IStorage *pstg)
{
    HRESULT	hResult;
    DWORD	grfMode;
    STATSTG statStg;
    CLSID readClsid;

    IStorage *pstgChild;
    IStream *pstmChild;
    IEnumSTATSTG *penumStatStg;

	hResult = pstg->Stat(&statStg, STATFLAG_DEFAULT);
    if (SUCCEEDED(hResult)) {
        DispStatStg(&statStg);
        if (statStg.pwcsName != NULL)
            CoTaskMemFree(statStg.pwcsName);
    } else {
        DirPrintf("Stat => %s\n", hResultText(hResult));
        return;
    }
        
    hResult = ReadClassStg(pstg, &readClsid);
    if (SUCCEEDED(hResult)) {
        if (readClsid != statStg.clsid)
            DirPrintf("ReadClassStg CLSID: %s\n", GuidText(&readClsid));
    } else
		DirPrintf("ReadClassStg => %s\n", hResultText(hResult));

    indent += 2;
    hResult = pstg->EnumElements(0, NULL, 0, &penumStatStg);
    if (FAILED(hResult))
		DirPrintf("EnumElements => %lx\n", hResult);
    else {
        while(TRUE) {
            hResult = penumStatStg->Next(1, &statStg, NULL);
            if (hResult == S_FALSE) break;
            if (FAILED(hResult)) {
                DirPrintf("EnumStatStg => %lx\n", hResult);
                break;
            } else {
                switch (statStg.type) {
                case STGTY_STORAGE:
                    if ((statStg.pwcsName == NULL) || 
                        (statStg.pwcsName[0] == L'.'))
                        DispStatStg(&statStg);
                    else {
                        grfMode =
                            STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE;
                        hResult = pstg->OpenStorage(
                            statStg.pwcsName,
                            NULL,               // pstgPriority
                            grfMode,
                            NULL,               // snbExclude
                            0,                  // dwReserved
                            &pstgChild);
                        if (FAILED(hResult)) {
                            DispStatStg(&statStg);
                            DirPrintf("OpenStorage => %lx\n", hResult);
                        } else {
                            if (fDebug) {
                                DirPrintf("---  Enum  ---\n");
                                DispStatStg(&statStg);
                                DirPrintf("---  Enum  ---\n");
                            }
                            DispStorage(pstgChild);
                            pstgChild->Release();
                        }
                    }
                    break;
                case STGTY_STREAM:
                    if ((statStg.pwcsName == NULL) || 
                        (statStg.pwcsName[0] == L'.'))
                        DispStatStg(&statStg);
                    else {
                        grfMode =
                            STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE;
                        hResult = pstg->OpenStream(
                            statStg.pwcsName,
                            NULL,               // pReserved1
                            grfMode,
                            0,                  // dwReserved2
                            &pstmChild);
                        if (FAILED(hResult)) {
                            DispStatStg(&statStg);
                            DirPrintf("OpenStream => %lx\n", hResult);
                        } else {
                            if (fDebug) {
                                DirPrintf("---  Enum  ---\n");
                                DispStatStg(&statStg);
                                DirPrintf("---  Enum  ---\n");
                            }
                            DispStream(pstmChild);
                            pstmChild->Release();
                        }
                    }
                    break;
                default:
                    DispStatStg(&statStg);
                }
                if (statStg.pwcsName != NULL)
                    CoTaskMemFree(statStg.pwcsName);
            }
        } // while loop
        penumStatStg->Release();
    }
    indent -= 2;
}

static void Usage(void)
{
    printf("Usage: tstgdir [options] <filename>\n");
    printf("Options are:\n");
    printf("  -h    - This message\n");
    printf("  -b    - Brief\n");
    printf("  -d    - Debug\n");
    printf("  -r    - Read streams (don't display)\n");
    printf("  -R    - Read streams (display contents)\n");
    printf("  -v    - Verbose\n");
    printf("\n");
}


int _cdecl main(int argc, char * argv[]) 
{
    WCHAR wcsFile[_MAX_PATH];
    HRESULT	hResult;
    DWORD	grfMode;
    IStorage *pstgRoot;

    wcscpy(wcsFile, L"");
    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'b':
                fBrief = TRUE;
                break;
            case 'd':
                fDebug = TRUE;
                break;
            case 'R':
                fReadVerbose = TRUE;
            case 'r':
                fRead = TRUE;
                break;
            case 'v':
                fVerbose = TRUE;
                break;
            case 'h':
            default:
                Usage();
                return -1;
            }
        }
        else
            mbstowcs(wcsFile, argv[0], strlen(argv[0]) + 1);
    }

    if (wcsFile[0] == L'\0') {
        printf("missing filename\n");
        Usage();
        return -1;
    }

    if (fVerbose)
        fBrief = FALSE;


    if (FAILED(hResult = CoInitialize(NULL))) {
        printf("CoInitialize => %s\n", hResultText(hResult));
        return -1;
    }

    grfMode = STGM_DIRECT | STGM_READ | STGM_SHARE_DENY_WRITE;
    hResult = StgOpenStorage(wcsFile,
               NULL,    //pstgPriority
               grfMode,
               NULL,    // snbExclude
               0,       //dwReserved
               &pstgRoot);
    if (FAILED(hResult)) {
        CoUninitialize();
        printf("StgOpenStorage => %s\n", hResultText(hResult));
        return -1;
    }

    DispStorage(pstgRoot);
    pstgRoot->Release();

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tsstore\tsstore.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tsstore.cpp
//
//  Contents:   System Store Tests: Register, Unregister or Enum
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    26-Aug-97   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"
#include "unicode.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


static void Usage(void)
{
    printf(
      "Usage: tsstore [options] <TestName> [<SystemName> [<PhysicalName>]]\n");
    printf("Options are:\n");
    printf("  -h                            - This message\n");
    printf("  -e<Expected Error>            - For example, -e0x0\n");
    printf("  -f<number>                    - Flags (excludes store location)\n");
    printf("  -P<string>                    - Store Location Parameter\n");
    printf("  -R<string>                    - Current User Relocate\n");
    printf("  -RHKCU\\<string>               - Current User Relocate\n");
    printf("  -RHKLM\\<string>               - Local Machine Relocate\n");
    printf("  -RNULL                        - Test NULL HKEY Relocate\n");
    printf("  -v                            - Verbose\n");
    printf("\n");
    printf("Store Location:\n");
    printf("  -lCurrentUser                 - Store Location: CurrentUser\n");
    printf("  -lLocalMachine                - Store Location: LocalMachine\n");
    printf("  -lCurrentService              - Store Location: CurrentService\n");
    printf("  -lServices                    - Store Location: Services\n");
    printf("  -lUsers                       - Store Location: Users\n");
    printf("  -lCUGP                        - Store Location: CU GroupPolicy\n");
    printf("  -lLMGP                        - Store Location: LM GroupPolicy\n");
    printf("  -lEnterprise                  - Store Location: LM Enterprise\n");
    printf("  -L<number>                    - Store Location: ID Number\n");
    printf("\n");
    printf("RegPhy parameters:\n");
    printf("  -pOpenStoreProvider <string>  - For example, System\n");
    printf("  -pOpenStoreProvider #<number> - For example, #10\n");
    printf("  -pOpenParameters <string>     - For example, My\n");
    printf("  -pOpenEncodingType <number>   - For example, 0x00010001\n");
    printf("  -pOpenFlags <number>          - For example, 0x00010000\n");
    printf("  -pFlags <number>              - For example, 0x1\n");
    printf("  -pPriority <number>           - For example, 0\n");
    printf("\n");
    printf("TestNames (case insensitive):\n");
    printf("  Enum                          - Enum ALL recursively, default\n");
    printf("  EnumLoc                       - Enum store locations\n");
    printf("  EnumSys                       - Enum -l or -L store location\n");
    printf("  EnumPhy <SysName>             - Enum physical stores\n");
    printf("  RegSys <SysName>              - Register system store\n");
    printf("  UnregSys <SysName>            - Unregister, delete system store\n");
    printf("  RegPhy <SysName> <PhyName>    - Register physical store\n");
    printf("  UnregPhy <SysName> <PhyName>  - Unregister physical store\n");
    printf("\n");
    printf("Defaults:\n");
    printf("  Enum\n");
    printf("  -e0x0\n");
    printf("  -f0x0\n");
    printf("  -lCurrentUser\n");
    printf("  -pOpenStoreProvider System\n");
    printf("\n");
}


#define SYSTEM_STORE_PROVIDER_FLAG   0x1
#define ASCII_STORE_PROVIDER_FLAG    0x2
#define UNICODE_STORE_PROVIDER_FLAG  0x4

#define CONST_OID_STR_PREFIX_CHAR   '#'

static DWORD GetStoreProviderTypeFlags(
    IN LPCSTR pszStoreProvider
    )
{
    DWORD dwFlags = 0;

    if (0xFFFF < (DWORD_PTR) pszStoreProvider &&
            CONST_OID_STR_PREFIX_CHAR == pszStoreProvider[0])
        // Convert "#<number>" string to its corresponding constant OID value
        pszStoreProvider = (LPCSTR)(DWORD_PTR) atol(pszStoreProvider + 1);

    dwFlags = UNICODE_STORE_PROVIDER_FLAG;
    if (CERT_STORE_PROV_FILENAME_A == pszStoreProvider)
        dwFlags = ASCII_STORE_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_FILENAME_W == pszStoreProvider)
        dwFlags = UNICODE_STORE_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_SYSTEM_A == pszStoreProvider)
        dwFlags = SYSTEM_STORE_PROVIDER_FLAG | ASCII_STORE_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_SYSTEM_W == pszStoreProvider)
        dwFlags = SYSTEM_STORE_PROVIDER_FLAG | UNICODE_STORE_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_SYSTEM_REGISTRY_A == pszStoreProvider)
        dwFlags = SYSTEM_STORE_PROVIDER_FLAG | ASCII_STORE_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_SYSTEM_REGISTRY_W == pszStoreProvider)
        dwFlags = SYSTEM_STORE_PROVIDER_FLAG | UNICODE_STORE_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_PHYSICAL_W == pszStoreProvider)
        dwFlags = SYSTEM_STORE_PROVIDER_FLAG | UNICODE_STORE_PROVIDER_FLAG;
    else if (0xFFFF < (DWORD_PTR) pszStoreProvider) {
        if (0 == _stricmp(sz_CERT_STORE_PROV_FILENAME_W, pszStoreProvider))
            dwFlags = UNICODE_STORE_PROVIDER_FLAG;
        else if (0 == _stricmp(sz_CERT_STORE_PROV_SYSTEM_W, pszStoreProvider))
            dwFlags = SYSTEM_STORE_PROVIDER_FLAG | UNICODE_STORE_PROVIDER_FLAG;
        else if (0 == _stricmp(sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                pszStoreProvider))
            dwFlags = SYSTEM_STORE_PROVIDER_FLAG | UNICODE_STORE_PROVIDER_FLAG;
        else if (0 == _stricmp(sz_CERT_STORE_PROV_PHYSICAL_W,
                pszStoreProvider))
            dwFlags = SYSTEM_STORE_PROVIDER_FLAG | UNICODE_STORE_PROVIDER_FLAG;
    }

    return dwFlags;
}

static BOOL IsSystemStoreProvider(
    IN LPCSTR pszStoreProvider
    )
{
    return GetStoreProviderTypeFlags(pszStoreProvider) &
        SYSTEM_STORE_PROVIDER_FLAG;
}
static BOOL IsAsciiOpenParameters(
    IN LPCSTR pszStoreProvider
    )
{
    return GetStoreProviderTypeFlags(pszStoreProvider) &
        ASCII_STORE_PROVIDER_FLAG;
}

static BOOL IsUnicodeOpenParameters(
    IN LPCSTR pszStoreProvider
    )
{
    return GetStoreProviderTypeFlags(pszStoreProvider) &
        UNICODE_STORE_PROVIDER_FLAG;
}

static void DisplayOpenFlags(
    IN LPCSTR pszHdr,
    IN LPCSTR pszStoreProvider,
    IN DWORD dwFlags
    )
{
    printf("%s = 0x%x :: ", pszHdr, dwFlags);
    if (IsSystemStoreProvider(pszStoreProvider)) {
        DWORD dwLocationID = (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK) >>
            CERT_SYSTEM_STORE_LOCATION_SHIFT;
        if (CERT_SYSTEM_STORE_CURRENT_USER_ID == dwLocationID)
            printf("CurrentUser");
        else if (CERT_SYSTEM_STORE_LOCAL_MACHINE_ID == dwLocationID)
            printf("LocalMachine");
        else if (CERT_SYSTEM_STORE_CURRENT_SERVICE_ID == dwLocationID)
            printf("CurrentService");
        else if (CERT_SYSTEM_STORE_SERVICES_ID == dwLocationID)
            printf("Services");
        else if (CERT_SYSTEM_STORE_USERS_ID == dwLocationID)
            printf("Users");
        else if (CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID ==
                dwLocationID)
            printf("CurrentUserGroupPolicy");
        else if (CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID ==
                dwLocationID)
            printf("LocalMachineGroupPolicy");
        else if (CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID ==
                dwLocationID)
            printf("LocalMachineEnterprise");
        else
            printf("StoreLocation = %d", dwLocationID);
    }

    if (dwFlags & CERT_STORE_DELETE_FLAG)
        printf(", DELETE");
    if (dwFlags & CERT_STORE_READONLY_FLAG)
        printf(", READONLY");
    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        printf(", BACKUP_RESTORE");
    if (dwFlags & CERT_STORE_OPEN_EXISTING_FLAG)
        printf(", OPEN_EXISTING");
    if (dwFlags & CERT_STORE_CREATE_NEW_FLAG)
        printf(", CREATE_NEW");
    if (dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG)
        printf(", MAXIMUM_ALLOWED");
    if (dwFlags & CERT_STORE_MANIFOLD_FLAG)
        printf(", MANIFOLD");
    if (dwFlags & CERT_STORE_ENUM_ARCHIVED_FLAG)
        printf(", ENUM_ARCHIVED");
    if (dwFlags & CERT_STORE_UPDATE_KEYID_FLAG)
        printf(", UPDATE_KEYID");
    printf("\n");
}

static void DisplayPhysicalStoreInfo(
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo
    )
{
    DWORD dwFlags;
    LPCSTR pszStoreProvider = pStoreInfo->pszOpenStoreProvider;
    if (0xFFFF >= (DWORD_PTR) pszStoreProvider)
        printf("      OpenStoreProvider: %d", (DWORD)(DWORD_PTR) pszStoreProvider);
    else
        printf("      OpenStoreProvider: %s", pszStoreProvider);

    if (0xFFFF < (DWORD_PTR) pszStoreProvider &&
            CONST_OID_STR_PREFIX_CHAR == pszStoreProvider[0])
        // Convert "#<number>" string to its corresponding constant OID value
        pszStoreProvider = (LPCSTR)(DWORD_PTR) atol(pszStoreProvider + 1);
    if (0xFFFF >= (DWORD_PTR) pszStoreProvider) {
        if (CERT_STORE_PROV_FILENAME_A == pszStoreProvider)
            printf(" (FILENAME_A)");
        else if (CERT_STORE_PROV_FILENAME_W == pszStoreProvider)
            printf(" (FILENAME_W)");
        else if (CERT_STORE_PROV_SYSTEM_A == pszStoreProvider)
            printf(" (SYSTEM_A)");
        else if (CERT_STORE_PROV_SYSTEM_W == pszStoreProvider)
            printf(" (SYSTEM_W)");
        else if (CERT_STORE_PROV_SYSTEM_REGISTRY_A == pszStoreProvider)
            printf(" (SYSTEM_REGISTRY_A)");
        else if (CERT_STORE_PROV_SYSTEM_REGISTRY_W == pszStoreProvider)
            printf(" (SYSTEM_REGISTRY_W)");
        else if (CERT_STORE_PROV_PHYSICAL_W == pszStoreProvider)
            printf(" (PHYSICAL_W)");
    }
    printf("\n");

    printf("      OpenEncodingType: 0x%x\n", pStoreInfo->dwOpenEncodingType);
    DisplayOpenFlags("      OpenFlags", pStoreInfo->pszOpenStoreProvider,
        pStoreInfo->dwOpenFlags);

    if (0 == pStoreInfo->OpenParameters.cbData)
        printf("      OpenParameters:: NONE\n");
    else if (IsSystemStoreProvider(pStoreInfo->pszOpenStoreProvider)) {
        if (IsUnicodeOpenParameters(pStoreInfo->pszOpenStoreProvider))
            printf("      OpenParameters: %S\n",
                pStoreInfo->OpenParameters.pbData);
        else
            printf("      OpenParameters: %s\n",
                pStoreInfo->OpenParameters.pbData);
    } else {
        printf("      OpenParameters::\n");
        PrintBytes("        ",
            pStoreInfo->OpenParameters.pbData,
            pStoreInfo->OpenParameters.cbData
            );
    }

    dwFlags = pStoreInfo->dwFlags;
    printf("      Flags: 0x%x", dwFlags);
    if (dwFlags)
        printf(" ::");
    if (dwFlags & CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG)
        printf(" ADD_ENABLE");
    if (dwFlags & CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG)
        printf(" OPEN_DISABLE");
    if (dwFlags & CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG)
        printf(" REMOTE_OPEN_DISABLE_FLAG");
    if (dwFlags & CERT_PHYSICAL_STORE_INSERT_COMPUTER_NAME_ENABLE_FLAG)
        printf(" INSERT_COMPUTER_NAME_ENABLE_FLAG");
    printf("\n");

    printf("      Priority: %d\n", pStoreInfo->dwPriority);
}

typedef struct _ENUM_ARG {
    BOOL        fAll;
    BOOL        fVerbose;
    DWORD       dwFlags;
    const void  *pvStoreLocationPara;
    HKEY        hKeyBase;
} ENUM_ARG, *PENUM_ARG;

static BOOL GetSystemName(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN PENUM_ARG pEnumArg,
    OUT LPCWSTR *ppwszSystemName
    )
{

    *ppwszSystemName = NULL;

    if (pEnumArg->hKeyBase &&
            0 == (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG)) {
        printf("failed => RELOCATE_FLAG not set in callback\n");
        return FALSE;
    } else if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pRelocatePara;

        if (NULL == pEnumArg->hKeyBase) {
            printf("failed => RELOCATE_FLAG is set in callback\n");
            return FALSE;
        }
        pRelocatePara = (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvSystemStore;
        if (pRelocatePara->hKeyBase != pEnumArg->hKeyBase) {
            printf("failed => wrong hKeyBase passed to callback\n");
            return FALSE;
        }
        *ppwszSystemName = pRelocatePara->pwszSystemStore;
    } else
        *ppwszSystemName = (LPCWSTR) pvSystemStore;
    return TRUE;
}

static BOOL WINAPI EnumPhyCallback(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved,
    IN OPTIONAL void *pvArg
    )
{
    PENUM_ARG pEnumArg = (PENUM_ARG) pvArg;
    LPCWSTR pwszSystemStore;

    if (!GetSystemName(pvSystemStore, dwFlags, pEnumArg, &pwszSystemStore))
        return FALSE;

    printf("    %S", pwszStoreName);
    if (pEnumArg->fVerbose &&
            (dwFlags & CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG))
        printf(" (implicitly created)");
    printf("\n");
    if (pEnumArg->fVerbose)
        DisplayPhysicalStoreInfo(pStoreInfo);
    return TRUE;
}


static BOOL WINAPI EnumSysCallback(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN PCERT_SYSTEM_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved,
    IN OPTIONAL void *pvArg
    )
{
    PENUM_ARG pEnumArg = (PENUM_ARG) pvArg;
    LPCWSTR pwszSystemStore;

    if (!GetSystemName(pvSystemStore, dwFlags, pEnumArg, &pwszSystemStore))
        return FALSE;

    printf("  %S\n", pwszSystemStore);
    if (pEnumArg->fAll || pEnumArg->fVerbose) {
        dwFlags &= CERT_SYSTEM_STORE_MASK;
        dwFlags |= pEnumArg->dwFlags & ~CERT_SYSTEM_STORE_MASK;
        if (!CertEnumPhysicalStore(
                pvSystemStore,
                dwFlags,
                pEnumArg,
                EnumPhyCallback
                )) {
            DWORD dwErr = GetLastError();
            if (!(ERROR_FILE_NOT_FOUND == dwErr ||
                    ERROR_NOT_SUPPORTED == dwErr))
                PrintLastError("    CertEnumPhysicalStore");
        }
    }
    return TRUE;
}

static BOOL WINAPI EnumLocCallback(
    IN LPCWSTR pwszStoreLocation,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    IN OPTIONAL void *pvArg
    )
{
    PENUM_ARG pEnumArg = (PENUM_ARG) pvArg;
    DWORD dwLocationID = (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK) >>
        CERT_SYSTEM_STORE_LOCATION_SHIFT;

    printf("======   %S   ======\n", pwszStoreLocation);

    if (pEnumArg->fAll) {
        dwFlags &= CERT_SYSTEM_STORE_MASK;
        dwFlags |= pEnumArg->dwFlags & ~CERT_SYSTEM_STORE_LOCATION_MASK;
        if (!CertEnumSystemStore(
                dwFlags,
                (void *) pEnumArg->pvStoreLocationPara,
                pEnumArg,
                EnumSysCallback
                )) {
            DWORD dwErr = GetLastError();
            if (E_INVALIDARG == dwErr && pEnumArg->pvStoreLocationPara)
                // \\ComputerName, ServiceName, or \\ComputerName\Service
                // not supported for all store locations
                ;
            else if (!(ERROR_FILE_NOT_FOUND == dwErr ||
                    ERROR_PROC_NOT_FOUND == dwErr))
                PrintLastError("  CertEnumSystemStore");
        }
    }
    return TRUE;
}


int _cdecl main(int argc, char * argv[]) 
{
    BOOL fResult;
    int status = 0;
    DWORD dwError;
    BOOL fVerbose = FALSE;
    DWORD dwExpectedError = 0;
    DWORD dwLocationID = CERT_SYSTEM_STORE_CURRENT_USER_ID;
    DWORD dwFlags = 0;
    CERT_PHYSICAL_STORE_INFO PhyStoreInfo;
    memset(&PhyStoreInfo, 0, sizeof(PhyStoreInfo));
    PhyStoreInfo.cbSize = sizeof(PhyStoreInfo);
    PhyStoreInfo.pszOpenStoreProvider = sz_CERT_STORE_PROV_SYSTEM_W;

    ENUM_ARG EnumArg;

    LPSTR pszStoreParameters = NULL;            // not allocated
    LPSTR pszStoreLocationPara = NULL;          // not allocated 
    LPWSTR pwszStoreParameters = NULL;
    LPWSTR pwszSystemName = NULL;
    LPWSTR pwszPhysicalName = NULL;
    LPWSTR pwszStoreLocationPara = NULL;

    void *pvSystemName;                         // not allocated
    void *pvStoreLocationPara;                  // not allocated

#define TEST_NAME_INDEX     0
#define SYS_NAME_INDEX      1
#define PHY_NAME_INDEX      2
#define MAX_NAME_CNT        3
    DWORD dwNameCnt = 0;
    LPCSTR rgpszName[MAX_NAME_CNT];
    LPCSTR pszTestName;

    BOOL fRelocate = FALSE;
    HKEY hKeyRelocate = HKEY_CURRENT_USER;
    LPSTR pszRelocate = NULL;                   // not allocated
    CERT_SYSTEM_STORE_RELOCATE_PARA SystemNameRelocatePara;
    CERT_SYSTEM_STORE_RELOCATE_PARA StoreLocationRelocatePara;
    HKEY hKeyBase = NULL;

    while (--argc>0) {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'l':
                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "CurrentUser"))
                        dwLocationID = CERT_SYSTEM_STORE_CURRENT_USER_ID;
                    else if (0 == _stricmp(argv[0]+2, "LocalMachine"))
                        dwLocationID = CERT_SYSTEM_STORE_LOCAL_MACHINE_ID;
                    else if (0 == _stricmp(argv[0]+2, "CurrentService"))
                        dwLocationID = CERT_SYSTEM_STORE_CURRENT_SERVICE_ID;
                    else if (0 == _stricmp(argv[0]+2, "Services"))
                        dwLocationID = CERT_SYSTEM_STORE_SERVICES_ID;
                    else if (0 == _stricmp(argv[0]+2, "Users"))
                        dwLocationID = CERT_SYSTEM_STORE_USERS_ID;
                    else if (0 == _stricmp(argv[0]+2, "CUGP"))
                        dwLocationID =
                            CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID;
                    else if (0 == _stricmp(argv[0]+2, "LMGP"))
                        dwLocationID =
                            CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID;
                    else if (0 == _stricmp(argv[0]+2, "Enterprise"))
                        dwLocationID =
                            CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID;
                    else {
                        printf("Need to specify -l<StoreLocation>\n");
                        goto BadUsage;
                    }
                } else {
                    printf("Need to specify -l<StoreLocation>\n");
                    goto BadUsage;
                }
                break;
            case 'L':
                dwLocationID = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'P':
                pszStoreLocationPara = argv[0]+2;
                break;
            case 'R':
                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "NULL")) {
                        hKeyRelocate = NULL;
                        pszRelocate = NULL;
                    } else if (0 == _strnicmp(argv[0]+2, "HKCU", 4)) {
                        hKeyRelocate = HKEY_CURRENT_USER;
                        pszRelocate = argv[0]+2+4;
                        if ('\\' == *pszRelocate)
                            pszRelocate++;
                    } else if (0 == _strnicmp(argv[0]+2, "HKLM", 4)) {
                        hKeyRelocate = HKEY_LOCAL_MACHINE;
                        pszRelocate = argv[0]+2+4;
                        if ('\\' == *pszRelocate)
                            pszRelocate++;
                    } else {
                        hKeyRelocate = HKEY_CURRENT_USER;
                        pszRelocate = argv[0]+2;
                    }
                } else {
                    hKeyRelocate = HKEY_CURRENT_USER;
                    pszRelocate = NULL;
                }
                fRelocate = TRUE;
                break;
            case 'f':
                dwFlags = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'p':
                if (argc < 2 || argv[1][0] == '-') {
                    printf("Option (%s) : missing parameter argument\n",
                        argv[0]);
                    goto BadUsage;
                }

                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "OpenStoreProvider")) {
                        if (CONST_OID_STR_PREFIX_CHAR == argv[1][0])
                            // Convert "#<number>" string to its
                            // corresponding constant OID value
                            PhyStoreInfo.pszOpenStoreProvider =
                                (LPSTR)(DWORD_PTR) atol(argv[1] + 1);
                        else
                            PhyStoreInfo.pszOpenStoreProvider = argv[1];
                    } else if (0 == _stricmp(argv[0]+2, "OpenEncodingType"))
                        PhyStoreInfo.dwOpenEncodingType =
                            strtoul(argv[1], NULL, 0);
                    else if (0 == _stricmp(argv[0]+2, "OpenFlags"))
                        PhyStoreInfo.dwOpenFlags = strtoul(argv[1], NULL, 0);
                    else if (0 == _stricmp(argv[0]+2, "OpenParameters"))
                        pszStoreParameters = argv[1];
                    else if (0 == _stricmp(argv[0]+2, "Flags"))
                        PhyStoreInfo.dwFlags = strtoul(argv[1], NULL, 0);
                    else if (0 == _stricmp(argv[0]+2, "Priority"))
                        PhyStoreInfo.dwPriority = strtoul(argv[1], NULL, 0);
                    else {
                        printf("Invalid -p<ParameterName>\n");
                        goto BadUsage;
                    }
                } else {
                    printf("Need to specify -p<ParameterName>\n");
                    goto BadUsage;
                }
                argc -= 1;
                argv += 1;
                break;

            case 'v':
                fVerbose = TRUE;
                break;
            case 'e':
                dwExpectedError = strtoul(argv[0]+2, NULL, 0);
                break;

            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            if (MAX_NAME_CNT <= dwNameCnt) {
                printf("Too many names starting with:: %s\n", argv[0]);
                goto BadUsage;
            }
            rgpszName[dwNameCnt++] = argv[0];
        }
    }


    printf("command line: %s\n", GetCommandLine());
    if (pszStoreLocationPara)
        pwszStoreLocationPara = AllocAndSzToWsz(pszStoreLocationPara);

    if (0 == dwNameCnt)
        rgpszName[dwNameCnt++] = "Enum";
    pszTestName = rgpszName[TEST_NAME_INDEX];

    if (SYS_NAME_INDEX < dwNameCnt)
        pwszSystemName = AllocAndSzToWsz(rgpszName[SYS_NAME_INDEX]);
    if (PHY_NAME_INDEX < dwNameCnt)
        pwszPhysicalName = AllocAndSzToWsz(rgpszName[PHY_NAME_INDEX]);

    dwFlags &= ~CERT_SYSTEM_STORE_LOCATION_MASK;
    dwFlags |= (dwLocationID << CERT_SYSTEM_STORE_LOCATION_SHIFT) &
        CERT_SYSTEM_STORE_LOCATION_MASK;

    DisplayOpenFlags("Flags", sz_CERT_STORE_PROV_SYSTEM_W, dwFlags);


    if (fRelocate) {
        printf("Relocation Enabled:  ");

        if (hKeyRelocate) {
            LONG err;

            if (HKEY_CURRENT_USER == hKeyRelocate)
                printf("HKEY_CURRENT_USER\\%s\n", pszRelocate);
            else if (HKEY_LOCAL_MACHINE == hKeyRelocate)
                printf("HKEY_LOCAL_MACHINE\\%s\n", pszRelocate);
            else
                printf("???\\%s\n", pszRelocate);

            if (ERROR_SUCCESS != (err = RegOpenKeyExA(
                    hKeyRelocate,
                    pszRelocate,
                    0,                      // dwReserved
                    KEY_ALL_ACCESS,
                    &hKeyBase))) {
                printf("RegOpenKeyExA(%s) failed => %d 0x%x\n",
                    pszRelocate, err, err);
                goto ErrorReturn;
            }

        } else
            printf("NULL hKeyBase\n");

        dwFlags |= CERT_SYSTEM_STORE_RELOCATE_FLAG;

        SystemNameRelocatePara.hKeyBase = hKeyBase;
        SystemNameRelocatePara.pwszSystemStore = pwszSystemName;
        pvSystemName = &SystemNameRelocatePara;

        StoreLocationRelocatePara.hKeyBase = hKeyBase;
        StoreLocationRelocatePara.pwszSystemStore = pwszStoreLocationPara;
        pvStoreLocationPara = &StoreLocationRelocatePara;
    } else {
        pvSystemName = pwszSystemName;
        pvStoreLocationPara = pwszStoreLocationPara;
    }

    memset(&EnumArg, 0, sizeof(EnumArg));
    EnumArg.fVerbose = fVerbose;
    EnumArg.dwFlags = dwFlags;
    EnumArg.hKeyBase = hKeyBase;
    if (pwszStoreLocationPara) {
        printf("System Store Location Parameter :: %S\n",
            pwszStoreLocationPara);
        EnumArg.pvStoreLocationPara = pvStoreLocationPara;
    } else if (fRelocate)
        EnumArg.pvStoreLocationPara = pvStoreLocationPara;

    {
        WCHAR wszCurrentComputer[_MAX_PATH + 1];
        DWORD cch = _MAX_PATH;
        if (!GetComputerNameU(wszCurrentComputer, &cch))
            PrintLastError("GetComputeName");
        else
            printf("CurrentComputer :: %S\n", wszCurrentComputer);
    }

    printf("\n");
    if (0 == _stricmp("Enum", pszTestName)) {
        printf("Enumeration of ALL System Stores\n\n");
        EnumArg.fAll = TRUE;
        fResult = CertEnumSystemStoreLocation(
            dwFlags,
            &EnumArg,
            EnumLocCallback
            );
    } else if (0 == _stricmp("EnumLoc", pszTestName)) {
        printf("Enumeration of System Store Locations\n\n");
        fResult = CertEnumSystemStoreLocation(
            dwFlags,
            &EnumArg,
            EnumLocCallback
            );
    } else if (0 == _stricmp("EnumSys", pszTestName)) {
        printf("Enumeration of System Stores\n\n");
        fResult = CertEnumSystemStore(
            dwFlags,
            pvStoreLocationPara,
            &EnumArg,
            EnumSysCallback
            );
    } else if (0 == _stricmp("EnumPhy", pszTestName)) {
        if (NULL == pwszSystemName) {
            printf("Missing <SystemName>\n");
            goto BadUsage;
        }

        printf("Enumeration of Physical Stores for System Store %S\n",
            pwszSystemName);

        fResult = CertEnumPhysicalStore(
            pvSystemName,
            dwFlags,
            &EnumArg,
            EnumPhyCallback
            );
    } else if (0 == _stricmp("RegSys", pszTestName)) {
        if (NULL == pwszSystemName) {
            printf("Missing <SystemName>\n");
            goto BadUsage;
        }
        printf("Registering System Store %S\n", pwszSystemName);
        fResult = CertRegisterSystemStore(
            pvSystemName,
            dwFlags,
            NULL,           // pSystemStoreInfo
            NULL            // pvReserved
            );
    } else if (0 == _stricmp("UnregSys", pszTestName)) {
        if (NULL == pwszSystemName) {
            printf("Missing <SystemName>\n");
            goto BadUsage;
        }
        printf("Unregistering System Store %S\n", pwszSystemName);
        fResult = CertUnregisterSystemStore(
            pvSystemName,
            dwFlags
            );
        if (!fResult && 0 == dwExpectedError) {
            if (ERROR_FILE_NOT_FOUND == GetLastError()) {
                if (fVerbose)
                    printf("System store doesn't exist\n");
                fResult = TRUE;
            }
        }
    } else if (0 == _stricmp("RegPhy", pszTestName)) {
        if (NULL == pwszSystemName) {
            printf("Missing <SystemName>\n");
            goto BadUsage;
        }
        if (NULL == pwszPhysicalName) {
            printf("Missing <PhysicalName>\n");
            goto BadUsage;
        }
        printf("Registering Physical Store (%S) in System Store (%S)\n",
            pwszPhysicalName, pwszSystemName);

        if (pszStoreParameters) {
            if (IsUnicodeOpenParameters(PhyStoreInfo.pszOpenStoreProvider)) {
                if (pwszStoreParameters = AllocAndSzToWsz(
                        pszStoreParameters)) {
                    PhyStoreInfo.OpenParameters.pbData =
                        (BYTE *) pwszStoreParameters;
                    PhyStoreInfo.OpenParameters.cbData =
                        (wcslen(pwszStoreParameters) + 1) * sizeof(WCHAR);
                }
            } else {
                PhyStoreInfo.OpenParameters.pbData =
                    (BYTE *) pszStoreParameters;
                PhyStoreInfo.OpenParameters.cbData =
                    strlen(pszStoreParameters) + 1;
            }
        }
        printf("Physical Store Info::\n");
            DisplayPhysicalStoreInfo(&PhyStoreInfo);
        fResult = CertRegisterPhysicalStore(
            pvSystemName,
            dwFlags,
            pwszPhysicalName,
            &PhyStoreInfo,
            NULL            // pvReserved
            );
    } else if (0 == _stricmp("UnregPhy", pszTestName)) {
        if (NULL == pwszSystemName) {
            printf("Missing <SystemName>\n");
            goto BadUsage;
        }
        if (NULL == pwszPhysicalName) {
            printf("Missing <PhysicalName>\n");
            goto BadUsage;
        }
        printf("Unregistering Physical Store (%S) in System Store (%S)\n",
            pwszPhysicalName, pwszSystemName);
        fResult = CertUnregisterPhysicalStore(
            pvSystemName,
            dwFlags,
            pwszPhysicalName
            );
    } else {
        printf("Invalid TestName: %s\n", pszTestName);
        goto BadUsage;
    }

    printf("\n");

    if (fResult) {
        dwError = 0;
        printf("Successful %s\n", pszTestName);
    } else
        dwError = GetLastError();

    if (dwError != dwExpectedError) {
        if (!fResult)
            PrintLastError(pszTestName);
        status = -1;
        printf("Failed. Expected error => 0x%x (%d) \n",
            dwExpectedError, dwExpectedError);
    } else
        status = 0;

CommonReturn:
    if (hKeyBase)
        RegCloseKey(hKeyBase);
    TestFree(pwszStoreParameters);
    TestFree(pwszSystemName);
    TestFree(pwszPhysicalName);
    TestFree(pwszStoreLocationPara);
    return status;

ErrorReturn:
    status = -1;
    goto CommonReturn;

BadUsage:
    Usage();
    status = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tstore2\tstore2.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tstore2.cpp
//
//  Contents:   Cert Store API Tests: Create and Add a chain of certificates
//              and CRLs to the store.
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    07-Mar-96   philh   created
//              31-May-96   helles  Removed check for a particular error code,
//                                  NTE_PROV_TYPE_NOT_DEF, since this can get
//                                  overwritten due to known problem with
//                                  the msvcr40d.dll on Win95.
//              07-Jun-96   HelleS  Added printing the command line
//              20-Aug-96   jeffspel name changes
//
//--------------------------------------------------------------------------


#define CMS_PKCS7   1

#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "setcert.h"
#include "signcde.h"
#include "softpub.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <stddef.h>

//#define TEST_PROV_DSS   PROV_DSS
#define TEST_PROV_DSS   PROV_DSS_DH

// # of bytes for a hash. Such as, SHA1 (20) or MD5 (16)
#define MAX_HASH_LEN  20

#if 1
// client authentication doesn't know about sha1
#define SIGNATURE_ALG_OBJID     szOID_RSA_MD5RSA
#else
#define SIGNATURE_ALG_OBJID     szOID_OIWSEC_sha1RSASign
#endif

#define DSS_SIGNATURE_ALG_OBJID szOID_X957_SHA1DSA

#define ENH_1024_CONTAINER_NAME_A "Regression 1024"
#define ENH_1024_CONTAINER_NAME_W L"Regression 1024"
#define ENH_2048_CONTAINER_NAME_A "Regression 2048"
#define ENH_2048_CONTAINER_NAME_W L"Regression 2048"
#define DSS_512_CONTAINER_NAME_A "Regression 512"
#define DSS_512_CONTAINER_NAME_W L"Regression 512"

//+-------------------------------------------------------------------------
// Parameters, data used to encode the messages.
//--------------------------------------------------------------------------
static DWORD dwCertEncodingType = X509_ASN_ENCODING;
static DWORD dwMsgEncodingType = PKCS_7_ASN_ENCODING;
static DWORD dwMsgAndCertEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
static SYSTEMTIME TestTime;
static LPSTR pszContainer = NULL;
static LPWSTR pwszContainer = NULL;
static HCRYPTPROV hRSACryptProv = 0;
static HCRYPTPROV hEnh1024CryptProv = 0;
static HCRYPTPROV hEnh2048CryptProv = 0;
static HCRYPTPROV hDSSCryptProv = 0;
static HCRYPTPROV hDSS512CryptProv = 0;
static BOOL fGenerate = FALSE;
static BOOL fExportable = FALSE;
static BOOL fUserProtected = FALSE;
static BOOL fProviders = FALSE;
static BOOL fMachine = FALSE;
static BOOL fInheritParameters = FALSE;

#define TIME_INVALID_PARA_FLAG      0x00000001
#define REVOKED_PARA_FLAG           0x00000002
#define PROV_PARA_FLAG              0x00000004
#define XCHG_PARA_FLAG              0x00000008
#define CA_PARA_FLAG                0x00000010
#define NO_NAME_PARA_FLAG           0x00000020
#define ALT_DIR_NAME_PARA_FLAG      0x00000040
#define SET_PARA_FLAG               0x00000080
#define ALL_EXT_PARA_FLAG           0x00000100
#define SPC_EXT_PARA_FLAG           0x00000200
#define SPC_COM_PARA_FLAG           0x00000400
#define SPC_AGENCY_PARA_FLAG        0x00000800
#define SPC_AGENCY_INFO_PARA_FLAG   0x00001000
// "Valid" certs to give to other companies to test interoperability
#define VALID_PARA_FLAG             0x00002000
#define DELTA_CRL_PARA_FLAG         0x00004000
#define AUX1_PARA_FLAG              0x00010000
#define AUX2_PARA_FLAG              0x00020000
// For duplicate, use previous cert's serial number
#define DUPLICATE_PARA_FLAG         0x00040000
#define NO_EXT_PARA_FLAG            0x00080000
#define DUPLICATE_CRL_PARA_FLAG     0x00100000
#define NO_CRL_EXT_PARA_FLAG        0x00200000
#define GENERALIZED_TIME_PARA_FLAG  0x00400000
#define NETSCAPE_PARA_FLAG          0x00800000

#define CTL1_PARA_FLAG              0x01000000
#define CTL2_PARA_FLAG              0x02000000
#define USE1_PARA_FLAG              0x04000000
#define USE2_PARA_FLAG              0x08000000
#define HTTP_PARA_FLAG              0x10000000

#define DSS_PARA_FLAG               0x80000000
#define DSS_512_PARA_FLAG           0x40000000
#define ENH_1024_PARA_FLAG          0x40000000
#define ENH_2048_PARA_FLAG          0x20000000


#define szSignManifold    "Signer Manifold"
#define szXchgManifold    "Recipient Manifold"

typedef struct _CERT_PARA {
    LPSTR       pszName;
    DWORD       dwIssuer;
    DWORD       dwFlags;
    LPSTR       pszManifold;
} CERT_PARA;

#define BASE_OR_DELTA_CA_ISSUER             1
#define UPDATE_CTL_SIGNER                   1

#define POLICY_ROOT                         0
#define POLICY_CA                           1

#define CERT_CNT   76
static CERT_PARA CertPara[CERT_CNT] = {
    "root",         0, CA_PARA_FLAG,                            // 0
                            NULL,
    "CA",           0, CA_PARA_FLAG |
                            DUPLICATE_CRL_PARA_FLAG,            // 1
                            NULL,
    "TestRoot",     2, CA_PARA_FLAG |
                            ENH_2048_PARA_FLAG |
                            VALID_PARA_FLAG,                    // 2
                            NULL,
    "TestSigner",   2, PROV_PARA_FLAG | VALID_PARA_FLAG |
                            USE1_PARA_FLAG,                     // 3
                            szSignManifold,
    "TestRecipient",2, PROV_PARA_FLAG | XCHG_PARA_FLAG |
                            VALID_PARA_FLAG | USE1_PARA_FLAG,   // 4
                            szXchgManifold,
    "me",           1, PROV_PARA_FLAG |
                            ENH_1024_PARA_FLAG |
                            USE2_PARA_FLAG,                     // 5
                            NULL,
    "me",           1, PROV_PARA_FLAG |
                            ENH_1024_PARA_FLAG |
                            XCHG_PARA_FLAG,                     // 6
                            NULL,
    "setrevoked",   1, REVOKED_PARA_FLAG | PROV_PARA_FLAG |
                            SET_PARA_FLAG |
                            ENH_2048_PARA_FLAG,                 // 7
                            NULL,
    "setrevoked",   1, REVOKED_PARA_FLAG | XCHG_PARA_FLAG |
                            SET_PARA_FLAG |
                            PROV_PARA_FLAG | ENH_2048_PARA_FLAG,// 8
                            NULL,
    "time invalid", 1, TIME_INVALID_PARA_FLAG,                  // 9
                            NULL,
    "setkeith",     1, SET_PARA_FLAG,                           // 10
                            NULL,
    "setkeith",     1, XCHG_PARA_FLAG | USE2_PARA_FLAG |        // 11
                            SET_PARA_FLAG,
                            NULL,
    "kevin",        1, 0,                                       // 12
                            NULL,
    "kevin",        1, XCHG_PARA_FLAG | USE2_PARA_FLAG,         // 13
                            NULL,
    "all ext",      1, ALL_EXT_PARA_FLAG | AUX1_PARA_FLAG |
                            SET_PARA_FLAG |
                            ALT_DIR_NAME_PARA_FLAG |
                            AUX2_PARA_FLAG |
                            USE1_PARA_FLAG | USE2_PARA_FLAG,    // 14
                            NULL,
    "MSPub",       17, SPC_EXT_PARA_FLAG | SPC_COM_PARA_FLAG |
                            PROV_PARA_FLAG | USE1_PARA_FLAG,    // 15
                            NULL,
    "PhilPub",     17, SPC_EXT_PARA_FLAG | PROV_PARA_FLAG |
                            USE2_PARA_FLAG,                     // 16
                            NULL,
    "MSAgency",     1, SPC_EXT_PARA_FLAG | SPC_AGENCY_PARA_FLAG |
                            PROV_PARA_FLAG | CA_PARA_FLAG,      // 17
                            NULL,
    "AgencyInfo",   1, SPC_AGENCY_INFO_PARA_FLAG,               // 18
                            NULL,
    "duplicate1",   1, AUX1_PARA_FLAG | NO_EXT_PARA_FLAG |
                            USE1_PARA_FLAG,                     // 19
                            NULL,
    "duplicate2",   1, AUX2_PARA_FLAG | NO_EXT_PARA_FLAG |
                            DUPLICATE_PARA_FLAG |
                            USE2_PARA_FLAG,                     // 20
                            NULL,
    "GeneralRoot",  21, CA_PARA_FLAG |
                            GENERALIZED_TIME_PARA_FLAG |
                            PROV_PARA_FLAG |
                            DSS_PARA_FLAG,                      // 21
                            NULL,
    "GeneralTime",  21,  GENERALIZED_TIME_PARA_FLAG |
                            PROV_PARA_FLAG |
                            DSS_512_PARA_FLAG |
                            DSS_PARA_FLAG,                      // 22
                            NULL,
    "Generalrevoked", 21, REVOKED_PARA_FLAG | DSS_PARA_FLAG,    // 23
                            NULL,
    "NoCRLExtCA",   0, CA_PARA_FLAG | NO_CRL_EXT_PARA_FLAG,     // 24
                            NULL,
    "NoCRLExtrevoked", 24, REVOKED_PARA_FLAG,                   // 25
                            NULL,
    "NetscapeCA",   0, NETSCAPE_PARA_FLAG | CA_PARA_FLAG |
                            DSS_PARA_FLAG |
                            REVOKED_PARA_FLAG,                  // 26
                            NULL,
    "Netscape",    26, NETSCAPE_PARA_FLAG | REVOKED_PARA_FLAG,  // 27
                            NULL,
    "Ctl0",         1, CTL1_PARA_FLAG | NO_EXT_PARA_FLAG,       // 28
                            NULL,
    "Ctl1",         2, CTL1_PARA_FLAG,                          // 29
                            NULL,
    "Ctl1Invalid",  2, CTL1_PARA_FLAG | TIME_INVALID_PARA_FLAG |
                            DUPLICATE_PARA_FLAG,                // 30
                            NULL,
    "Ctl2",         1, CTL2_PARA_FLAG,                          // 31
                            NULL,
    "Ctl2Invalid",  1, CTL2_PARA_FLAG | TIME_INVALID_PARA_FLAG |
                            DUPLICATE_PARA_FLAG,                // 32
                            NULL,
    "Http2",        1, CTL2_PARA_FLAG | HTTP_PARA_FLAG |
                            NO_EXT_PARA_FLAG,                   // 33
                            NULL,
    "Http2Invalid", 1, CTL2_PARA_FLAG | TIME_INVALID_PARA_FLAG |
                            DUPLICATE_PARA_FLAG | HTTP_PARA_FLAG |
                            NO_EXT_PARA_FLAG,                   // 34
                            NULL,
    "NoNameIssuer1", 0, CA_PARA_FLAG | ALT_DIR_NAME_PARA_FLAG,  // 35
                            NULL,
    "NoNameSubject1", 35, NO_NAME_PARA_FLAG,                    // 36
                            NULL,
    "NoNameIssuer2", 0, CA_PARA_FLAG | ALT_DIR_NAME_PARA_FLAG,  // 37
                            NULL,
    "NoNameSubject2", 37, NO_NAME_PARA_FLAG |
                            ALT_DIR_NAME_PARA_FLAG,             // 38
                            NULL,
    "Hellman",  21, XCHG_PARA_FLAG | NO_EXT_PARA_FLAG |
                            PROV_PARA_FLAG |
                            DSS_PARA_FLAG,                      // 39
                            NULL,
    "TestSigner2", 2, PROV_PARA_FLAG | VALID_PARA_FLAG |
                            USE1_PARA_FLAG,                     // 40
                            szSignManifold,
    "TestRecipient2", 2, PROV_PARA_FLAG | XCHG_PARA_FLAG |
                            VALID_PARA_FLAG | USE1_PARA_FLAG,   // 41
                            szXchgManifold,
    "TestSigner3", 2, PROV_PARA_FLAG | VALID_PARA_FLAG |
                            USE1_PARA_FLAG,                     // 42
                            szSignManifold,
    "UTF8", 2, VALID_PARA_FLAG | NO_EXT_PARA_FLAG,              // 43
                            NULL,
    "DssRoot", 44, CA_PARA_FLAG | VALID_PARA_FLAG |
                            NO_EXT_PARA_FLAG |
                            DSS_PARA_FLAG,                      // 44
                            NULL,
    "DssCA", 44, CA_PARA_FLAG | VALID_PARA_FLAG |
                            NO_EXT_PARA_FLAG |
                            DSS_PARA_FLAG,                      // 45
                            NULL,
    "DssEnd", 45, VALID_PARA_FLAG | NO_EXT_PARA_FLAG |
                            PROV_PARA_FLAG |
                            DSS_PARA_FLAG,                      // 46
                            NULL,
    "ZeroNotAfter", 2, VALID_PARA_FLAG |
                            PROV_PARA_FLAG,                     // 47
                            NULL,
    "V1", 48, CA_PARA_FLAG | VALID_PARA_FLAG |
                            NO_EXT_PARA_FLAG |
                            NO_CRL_EXT_PARA_FLAG,               // 48
                            NULL,
    "V2", 48, VALID_PARA_FLAG | NO_EXT_PARA_FLAG,               // 49
                            NULL,
    "DeltaEndValid", 1, DELTA_CRL_PARA_FLAG,                    // 50
                            NULL,
    "DeltaNoValid", 1, DELTA_CRL_PARA_FLAG | NO_EXT_PARA_FLAG,  // 51
                            NULL,
    "DeltaEndRevoked", 1, DELTA_CRL_PARA_FLAG |                 // 52
                            REVOKED_PARA_FLAG,
                            NULL,
    "DeltaCAValid", 1, DELTA_CRL_PARA_FLAG |                    // 53
                            CA_PARA_FLAG,
                            NULL,
    "DeltaCARevoked", 1, DELTA_CRL_PARA_FLAG |                  // 54
                            CA_PARA_FLAG |
                            REVOKED_PARA_FLAG,
                            NULL,
    "NoCDPValid",   1, DELTA_CRL_PARA_FLAG,                     // 55
                            NULL,
    "NoCDPRevoked", 1, DELTA_CRL_PARA_FLAG |                    // 56
                            REVOKED_PARA_FLAG,
                            NULL,
    "UnsupportedCDP", 1, DELTA_CRL_PARA_FLAG |                  // 57
                            REVOKED_PARA_FLAG,
                            NULL,
    "NotPermitted", 1, ALT_DIR_NAME_PARA_FLAG,                  // 58
                            NULL,
    "Excluded",     1, ALT_DIR_NAME_PARA_FLAG,                  // 59
                            NULL,

    "TestAIARoot", 60, CA_PARA_FLAG | NO_EXT_PARA_FLAG |        // 60
                            NO_CRL_EXT_PARA_FLAG,
                            NULL,
    "TestAIARevokeRoot", 61, CA_PARA_FLAG | NO_EXT_PARA_FLAG |  // 61
                            NO_CRL_EXT_PARA_FLAG,
                            NULL,
    "TestAIACA",  60, CA_PARA_FLAG | NO_EXT_PARA_FLAG |         // 62
                            NO_CRL_EXT_PARA_FLAG,
                            NULL,
    "TestAIACA",  61, CA_PARA_FLAG | NO_EXT_PARA_FLAG |
                            NO_CRL_EXT_PARA_FLAG |
                            REVOKED_PARA_FLAG,                  // 63
                            NULL,
    "TestAIAEnd",  63, NO_EXT_PARA_FLAG,                        // 64
                            NULL,
    "MissingNCCA", 0, CA_PARA_FLAG,                             // 65
                            NULL,
    "MissingNCEnd", 65, 0,                                      // 66
                            NULL,
    "TestAIAExpireRoot", 67, CA_PARA_FLAG | NO_EXT_PARA_FLAG |  // 67
                            NO_CRL_EXT_PARA_FLAG,
                            NULL,
    "TestAIACA",  67, CA_PARA_FLAG | NO_EXT_PARA_FLAG |
                            NO_CRL_EXT_PARA_FLAG |
                            TIME_INVALID_PARA_FLAG,             // 68
                            NULL,

    "InvalidKeyUsageCA",    2, CA_PARA_FLAG | VALID_PARA_FLAG,  // 69
                            NULL,
    "InvalidKeyUsageEnd",   69, NO_EXT_PARA_FLAG,               // 70
                            NULL,

    "RolloverRoot", 71, CA_PARA_FLAG | VALID_PARA_FLAG | NO_EXT_PARA_FLAG |
                            DSS_PARA_FLAG,                      // 71
                            NULL,
    "RolloverCA", 71, CA_PARA_FLAG | VALID_PARA_FLAG | NO_EXT_PARA_FLAG |
                            DSS_PARA_FLAG,                      // 72
                            NULL,
    "RolloverEnd", 72, VALID_PARA_FLAG |
                            DSS_PARA_FLAG,                      // 73
                            NULL,

    "RolloverRoot", 2, CA_PARA_FLAG | VALID_PARA_FLAG | NO_EXT_PARA_FLAG|
                            ENH_1024_PARA_FLAG,
                            NULL,                               // 74
    "RolloverRoot", 74, CA_PARA_FLAG | VALID_PARA_FLAG | NO_EXT_PARA_FLAG |
                            DSS_PARA_FLAG,                      // 75
                            NULL,
};

#define ROLLOVER_CROSS_CERT 74


#define EXPIRED_CRL_FLAG                    0x00000001
#define REMOVE_FROM_CRL_FLAG                0x00000002
#define HOLD_CRL_FLAG                       0x00000004
#define FRESHEST_CRL_FLAG                   0x00000010
#define NO_FRESHEST_CDP_CRL_FLAG            0x00000020
#define NO_IDP_CRL_FLAG                     0x00000100
#define ONLY_USERS_CRL_FLAG                 0x00000200
#define ONLY_CAS_CRL_FLAG                   0x00000400
#define UNSUPPORTED_IDP_OPTIONS_CRL_FLAG    0x00000800
#define UNSUPPORTED_CRITICAL_EXT_CRL_FLAG   0x00001000
#define NO_ENTRIES_CRL_FLAG                 0x00002000

typedef struct _BASE_DELTA_CRL_PARA {
    int         iBase;
    DWORD       dwFlags;
} BASE_DELTA_CRL_PARA;

static BASE_DELTA_CRL_PARA BaseDeltaCrlPara[] = {
    // Users Only: Base and Delta
    1, ONLY_USERS_CRL_FLAG,
    1, ONLY_USERS_CRL_FLAG | FRESHEST_CRL_FLAG,

    // CAs Only: Base and Delta
    2, ONLY_CAS_CRL_FLAG,
    2, ONLY_CAS_CRL_FLAG | FRESHEST_CRL_FLAG,

    // Base has entries, Delta has no entries
    3, HOLD_CRL_FLAG,
    3, NO_ENTRIES_CRL_FLAG | FRESHEST_CRL_FLAG,

    // Base has no entries, Delta has entries
    4, NO_ENTRIES_CRL_FLAG,
    4, FRESHEST_CRL_FLAG,

    // Base has entries, Delta has remove entries
    5, HOLD_CRL_FLAG,
    5, REMOVE_FROM_CRL_FLAG | FRESHEST_CRL_FLAG,

    // Valid base, delta has unsupported IDP options
    6, HOLD_CRL_FLAG,
    6, FRESHEST_CRL_FLAG | UNSUPPORTED_IDP_OPTIONS_CRL_FLAG,

    // Expired base, valid delta
    7, EXPIRED_CRL_FLAG,
    7, FRESHEST_CRL_FLAG,

    // Valid base, expired delta
    8, 0,
    8, EXPIRED_CRL_FLAG | FRESHEST_CRL_FLAG,
    

    // Expired base, without a freshest CDP extension
    9, EXPIRED_CRL_FLAG | NO_FRESHEST_CDP_CRL_FLAG,
    9, FRESHEST_CRL_FLAG,

    // Base without IDP and no freshest, delta CRL
    10, NO_IDP_CRL_FLAG | NO_FRESHEST_CDP_CRL_FLAG,

    // Base and Delta CRL with unsupported critical ext
    11, UNSUPPORTED_CRITICAL_EXT_CRL_FLAG,
    11, UNSUPPORTED_CRITICAL_EXT_CRL_FLAG | FRESHEST_CRL_FLAG,

    // Valid base with number > above delta indicator
    100, 0,
};
#define BASE_DELTA_CRL_CNT              \
                (sizeof(BaseDeltaCrlPara)/sizeof(BaseDeltaCrlPara[0]))

typedef struct _UPDATE_CTL_PARA {
    BOOL        fTimeInvalid;
    LPSTR       pszUsageObjId;
    LPSTR       pszListIdentifier;
    LPWSTR      pwszUrl;
} UPDATE_CTL_PARA;

static UPDATE_CTL_PARA UpdateCtlPara[] = {
    FALSE, "1.3.2000.1", "UpdateCtl1", L"file://testupdate1.ctl",
    TRUE,  "1.3.2000.1", "UpdateCtl1", L"file://testupdate1.ctl",
    FALSE, "1.3.2000.2", "UpdateCtl2", L"file://testupdate2.ctl",
    TRUE,  "1.3.2000.2", "UpdateCtl2", L"file://testupdate2.ctl",
};
#define UPDATE_CTL_CNT  (sizeof(UpdateCtlPara)/sizeof(UpdateCtlPara[0]))


#define STRING_OTHER_NAME_OID   "1.2.3.4.2600.1"
#define OCTET_OTHER_NAME_OID    "1.2.3.4.2600.2"

#define RDN_CNT         4
#define ATTR_CNT        4

#define ATTR_0_OBJID    szOID_COMMON_NAME
#define ATTR_1_OBJID    "1.2.1"
#define ATTR_2_OBJID    "1.2.2"
#define UTF8_NAME       L"*** UTF8 ***"

// Attr[0] - CertPara[].pszName
// Attr[1] - "xchg" | "sign"
// Attr[2] - "default" | pszContainer

static LPSTR rgpszUsageIdentifier[] = {
    "1.2.3.0",                          // 0
    "1.2.3.1",                          // 1
    "1.2.3.2",                          // 2
    "1.2.3.2.1"                         // 3
};

static CTL_USAGE rgCtlUsage[] = {
    1, &rgpszUsageIdentifier[0],        // 0
    1, &rgpszUsageIdentifier[1],        // 1
    2, &rgpszUsageIdentifier[2],        // 2
    3, &rgpszUsageIdentifier[1]         // 3
};

static PCCERT_CONTEXT rgpCertContext[CERT_CNT];

void MySystemTimeToFileTime(
    SYSTEMTIME *pSystemTime,
    FILETIME   *pFileTime
    )
{
    SYSTEMTIME TmpTime;

    if (!SystemTimeToFileTime(pSystemTime, pFileTime)) {
        TmpTime = *pSystemTime;

        // Following is a fix for Feb 29, 2000 when advancing the year forward or backward.
        TmpTime.wDay = 1;
        SystemTimeToFileTime(&TmpTime, pFileTime);
    }
}

//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
static void PrintError(LPCSTR pszMsg)
{
    printf("%s\n", pszMsg);
}
static void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}


//+-------------------------------------------------------------------------
//  Test allocation and free routines
//--------------------------------------------------------------------------
static
LPVOID
WINAPI
TestAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;
    pv = malloc(cbBytes);
    if (pv == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        PrintLastError("TestAlloc");
    }
    return pv;
}


static
VOID
WINAPI
TestFree(
    IN LPVOID pv
    )
{
    if (pv)
        free(pv);
}

//+-------------------------------------------------------------------------
//  Allocate and convert a multi-byte string to a wide string
//--------------------------------------------------------------------------
static LPWSTR AllocAndSzToWsz(LPCSTR psz)
{
    size_t  cb;
    LPWSTR  pwsz = NULL;

    if (-1 == (cb = mbstowcs( NULL, psz, strlen(psz))))
        goto bad_param;
    cb += 1;        // terminating NULL
    if (NULL == (pwsz = (LPWSTR)TestAlloc( cb * sizeof(WCHAR)))) {
        PrintLastError("AllocAndSzToWsz");
        goto failed;
    }
    if (-1 == mbstowcs( pwsz, psz, cb))
        goto bad_param;
    goto common_return;

bad_param:
    PrintError("Bad AllocAndSzToWsz");
failed:
    if (pwsz) {
        TestFree(pwsz);
        pwsz = NULL;
    }
common_return:
    return pwsz;
}

static HCRYPTPROV GetCryptProv(
    DWORD dwProvType,
    LPCSTR pszProvider = NULL,
    LPCSTR pszInContainer = pszContainer,
    DWORD dwBitLen = 0
    )
{
    HCRYPTPROV hProv = 0;
    BOOL fResult;
    DWORD dwFlags;

    if (fMachine)
        dwFlags = CRYPT_MACHINE_KEYSET;
    else
        dwFlags = 0;

    fResult = CryptAcquireContext(
            &hProv,
            pszInContainer,
            pszProvider,
            dwProvType,
            dwFlags
            );

    if (fResult) {
        if (fGenerate) {
            // Delete the existing keys
            CryptReleaseContext(hProv, 0);
            printf("Deleting existing private keys\n");
    
            // Note: for CRYPT_DELETEKEYSET, the returned hProv is undefined
            // and must not be released.
            fResult = CryptAcquireContext(
                    &hProv,
                    pszInContainer,
                    pszProvider,
                    dwProvType,
                    dwFlags | CRYPT_DELETEKEYSET
                    );
            if (!fResult) {
                PrintLastError("CryptAcquireContext(CRYPT_DELETEKEYSET)");
                return 0;
            }
            hProv = 0;
        }
    }

    if (0 == hProv) {
        printf("Creating new private keys\n");
        fResult = CryptAcquireContext(
                &hProv,
                pszInContainer,
                pszProvider,
                dwProvType,
                dwFlags | CRYPT_NEWKEYSET
                );
        if (!fResult || hProv == 0) {
            PrintLastError("CryptAcquireContext(CRYPT_NEWKEYSET)");
            return 0;
        }
    }

    HCRYPTKEY hKey = 0;
    dwFlags = dwBitLen << 16;
    if (fExportable)
        dwFlags |= CRYPT_EXPORTABLE;
    if (fUserProtected)
        dwFlags |= CRYPT_USER_PROTECTED;

    if (CryptGetUserKey(
            hProv,
            AT_SIGNATURE,
            &hKey
            )) {
        printf("Using existing SIGNATURE private key\n");
        CryptDestroyKey(hKey);
        hKey = 0;
    } else {
        printf("Generating SIGNATURE private key\n");
        fResult = CryptGenKey(
                hProv,
                AT_SIGNATURE,
                dwFlags,
                &hKey
                );
        if (!fResult || hKey == 0)
            PrintLastError("CryptGenKey(AT_SIGNATURE)");
        else
            CryptDestroyKey(hKey);
    }

    if (PROV_DSS == dwProvType)
        return hProv;

    if (CryptGetUserKey(
            hProv,
            AT_KEYEXCHANGE,
            &hKey
            )) {
        printf("Using existing EXCHANGE private key\n");
        CryptDestroyKey(hKey);
        hKey = 0;
    } else {
        printf("Generating EXCHANGE private key\n");
        hKey = 0;
        fResult = CryptGenKey(
                hProv,
                AT_KEYEXCHANGE,
                dwFlags,
                &hKey
                );
        if (!fResult || hKey == 0)
            PrintLastError("CryptGenKey(AT_KEYEXCHANGE)");
        else
            CryptDestroyKey(hKey);
    }

    return hProv;
}

static HCERTSTORE OpenStore(LPCSTR pszStoreFilename)
{
    HCERTSTORE hStore;
    HANDLE hFile = 0;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile(pszStoreFilename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL))) {
        hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            dwCertEncodingType,
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            );
    } else {
        hStore = CertOpenStore(
            CERT_STORE_PROV_FILE,
            dwCertEncodingType,
            0,                      // hCryptProv
            0,                      // dwFlags
            hFile
            );
        CloseHandle(hFile);
    }

    if (hStore == NULL)
        PrintLastError("CertOpenStore");

    return hStore;
}

static void SaveStore(HCERTSTORE hStore, LPCSTR pszSaveFilename)
{
    HANDLE hFile;
    hFile = CreateFile(pszSaveFilename,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        printf( "can't open %s\n", pszSaveFilename);
        PrintLastError("CloseStore::CreateFile");
    } else {
        if (!CertSaveStore(
                hStore,
                0,                          // dwEncodingType,
                CERT_STORE_SAVE_AS_STORE,
                CERT_STORE_SAVE_TO_FILE,
                (void *) hFile,
                0                           // dwFlags
                ))
            PrintLastError("CertSaveStore");
        CloseHandle(hFile);
    }
}

static CRYPT_ENCODE_PARA TestEncodePara = {
    offsetof(CRYPT_ENCODE_PARA, pfnFree) + sizeof(TestEncodePara.pfnFree),
    TestAlloc,
    TestFree
};

static BOOL AllocAndEncodeObject(
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;

    fResult = CryptEncodeObjectEx(
        dwCertEncodingType,
        lpszStructType,
        pvStructInfo,
        CRYPT_ENCODE_ALLOC_FLAG,
        &TestEncodePara,
        (void *) ppbEncoded,
        pcbEncoded
        );

    if (!fResult) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptEncodeObject(StructType: %d)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptEncodeObject(StructType: %s)",
                lpszStructType);
        PrintLastError("");
    }

    return fResult;
}

static BOOL CreateEnhancedKeyUsage(
        IN DWORD dwFlags,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    PCTL_USAGE pCtlUsage;

    dwFlags &= USE1_PARA_FLAG | USE2_PARA_FLAG;

    switch (dwFlags) {
        case 0:
            pCtlUsage = &rgCtlUsage[0];
            break;
        case USE1_PARA_FLAG:
            pCtlUsage = &rgCtlUsage[1];
            break;
        case USE2_PARA_FLAG:
            pCtlUsage = &rgCtlUsage[2];
            break;
        case USE1_PARA_FLAG | USE2_PARA_FLAG:
        default:
            pCtlUsage = &rgCtlUsage[3];
            break;
    }

    return AllocAndEncodeObject(
        X509_ENHANCED_KEY_USAGE,
        (const void *) pCtlUsage,
        ppbEncoded,
        pcbEncoded
        );
}


static BOOL CreateNextUpdateLocation(
        DWORD dwCert,
        BOOL fProp,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded,
        IN OPTIONAL LPWSTR pwszUrl = NULL
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_ALT_NAME_INFO AltNameInfo;
    CERT_ALT_NAME_ENTRY rgAltNameEntry[5];

    rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgAltNameEntry[0].pwszRfc822Name = L"RFC822";
    rgAltNameEntry[1].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[1].pwszURL = L"file://file1.ctl";
    rgAltNameEntry[2].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[2].pwszURL = L"http://timestamp/ctltest/http1.ctl";

    rgAltNameEntry[3].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[3].pwszURL = L"file://file2.ctl";
    rgAltNameEntry[4].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[4].pwszURL = L"http://timestamp/ctltest/http2.ctl";

    if (dwCert == UPDATE_CTL_SIGNER) {
        rgAltNameEntry[1].pwszURL = L"file://nonexistant1.ctl";
        rgAltNameEntry[2].pwszURL = L"file://nonexistant2.ctl";
        if (pwszUrl)
            rgAltNameEntry[3].pwszURL = pwszUrl;
        else
            rgAltNameEntry[3].pwszURL = L"file://testupdate1.ctl";
        rgAltNameEntry[4].pwszURL = L"file://nonexistant3.ctl";
        AltNameInfo.cAltEntry = 5;
        AltNameInfo.rgAltEntry = &rgAltNameEntry[0];
    } else if (fProp) {
        if (CertPara[dwCert].dwFlags & HTTP_PARA_FLAG)
            AltNameInfo.cAltEntry = 2;
        else
            AltNameInfo.cAltEntry = 1;
        AltNameInfo.rgAltEntry = &rgAltNameEntry[3];
    } else {
        if (CertPara[dwCert].dwFlags & HTTP_PARA_FLAG)
            AltNameInfo.cAltEntry = 5;
        else
            AltNameInfo.cAltEntry = 2;
        AltNameInfo.rgAltEntry = &rgAltNameEntry[0];
    }

    if (!AllocAndEncodeObject(
            X509_ALTERNATE_NAME,
            &AltNameInfo,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL AddCert(
    HCERTSTORE hStore,
    DWORD dwCert,
    BYTE *pbEncoded,
    DWORD cbEncoded)
{
    BOOL fResult;
    PCCERT_CONTEXT pCert = NULL;

    fResult = CertAddEncodedCertificateToStore(hStore, dwCertEncodingType,
        pbEncoded, cbEncoded, CERT_STORE_ADD_NEW, NULL);
    if (!fResult) {
        if (GetLastError() == CRYPT_E_EXISTS) {
            printf("Cert already exists in store. Adding duplicate\n");
            fResult = CertAddEncodedCertificateToStore(hStore,
                dwCertEncodingType, pbEncoded, cbEncoded,
                CERT_STORE_ADD_ALWAYS, &pCert);
        }
        if (!fResult)
            PrintLastError("CertAddEncodedCertificateToStore");
    } else {
        fResult = CertAddEncodedCertificateToStore(hStore,
            dwCertEncodingType, pbEncoded, cbEncoded,
                CERT_STORE_ADD_USE_EXISTING, &pCert);
        if (!fResult)
            PrintLastError("CertAddEncodedCertificateToStore");
    }
    if (pCert) {
        if (CertPara[dwCert].dwFlags & PROV_PARA_FLAG) {
            CRYPT_KEY_PROV_INFO KeyProvInfo;
            memset(&KeyProvInfo, 0, sizeof(KeyProvInfo));
            if ((CertPara[dwCert].dwFlags & DSS_PARA_FLAG) &&
                    (CertPara[dwCert].dwFlags & DSS_512_PARA_FLAG))
                KeyProvInfo.pwszContainerName = DSS_512_CONTAINER_NAME_W;
            else if (CertPara[dwCert].dwFlags & ENH_1024_PARA_FLAG)
                KeyProvInfo.pwszContainerName = ENH_1024_CONTAINER_NAME_W;
            else if (CertPara[dwCert].dwFlags & ENH_2048_PARA_FLAG)
                KeyProvInfo.pwszContainerName = ENH_2048_CONTAINER_NAME_W;
            else if (pwszContainer)
                KeyProvInfo.pwszContainerName = pwszContainer;
            if (CertPara[dwCert].dwFlags & DSS_PARA_FLAG)
                KeyProvInfo.dwProvType = TEST_PROV_DSS;
            else
                KeyProvInfo.dwProvType = PROV_RSA_FULL;
            if (CertPara[dwCert].dwFlags & XCHG_PARA_FLAG) {
                KeyProvInfo.dwFlags = CERT_SET_KEY_PROV_HANDLE_PROP_ID;
                KeyProvInfo.dwKeySpec = AT_KEYEXCHANGE;
            } else
                KeyProvInfo.dwKeySpec = AT_SIGNATURE;
            if (fMachine)
                KeyProvInfo.dwFlags |= CRYPT_MACHINE_KEYSET;

            fResult = CertSetCertificateContextProperty(
                pCert,
                CERT_KEY_PROV_INFO_PROP_ID,
                0,                          // dwFlags
                &KeyProvInfo
                );
            if (!fResult)
                PrintLastError("CertSetCertificateContextProperty");
        }

        if (((CertPara[dwCert].dwFlags & (USE1_PARA_FLAG | USE2_PARA_FLAG)) &&
                (CertPara[dwCert].dwFlags &
                    (NO_EXT_PARA_FLAG | VALID_PARA_FLAG)))
                        ||
            (CertPara[dwCert].dwFlags & (USE1_PARA_FLAG | USE2_PARA_FLAG)) ==
                (USE1_PARA_FLAG | USE2_PARA_FLAG)) {

            CRYPT_DATA_BLOB Data;
            DWORD dwFlags = CertPara[dwCert].dwFlags;
            if (0 == (CertPara[dwCert].dwFlags &
                    (NO_EXT_PARA_FLAG | VALID_PARA_FLAG)))
                dwFlags = 0;
            if (CreateEnhancedKeyUsage(
                    dwFlags,
                    &Data.pbData,
                    &Data.cbData)) {
                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_CTL_USAGE_PROP_ID,
                        0,                          // dwFlags
                        &Data
                        ))
                    PrintLastError(
                        "CertSetCertificateContextProperty(CTL_USAGE)");
                TestFree(Data.pbData);
            }
        }

        if (CertPara[dwCert].dwFlags & AUX1_PARA_FLAG) {
            DWORD i;
            CRYPT_DATA_BLOB Data[4];
            BYTE rgbAux0[] = {0x11, 0x0};
            BYTE rgbAux1[] = {0x11, 0x1};
            BYTE rgbAux2[] = {0x11, 0x2, 0x2};
            BYTE rgbAux3[] = {0x11, 0x3, 0x3, 0x3};

            Data[0].pbData = NULL;
            Data[0].cbData = 0;
            Data[1].pbData = rgbAux1;
            Data[1].cbData = sizeof(rgbAux1);
            Data[2].pbData = rgbAux2;
            Data[2].cbData = sizeof(rgbAux2);
            Data[3].pbData = rgbAux3;
            Data[3].cbData = sizeof(rgbAux3);

            for (i = 0; i < 4; i++) {
                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_FIRST_USER_PROP_ID + i,
                        0,                          // dwFlags
                        &Data[i]
                        )) {
                    fResult = FALSE;
                    PrintLastError("CertSetCertificateContextProperty");
                    break;
                }
            }
        }

        if (CertPara[dwCert].dwFlags & AUX2_PARA_FLAG) {
            DWORD i;
            CRYPT_DATA_BLOB Data[3];
            BYTE rgbAux0[] = {0x22, 0x2, 0x2};
            BYTE rgbAux1[] = {0x22, 0x3, 0x3, 0x3};
            BYTE rgbAux2[] = {0x22, 0x4, 0x4, 0x4, 0x4, 0x12, 0x34};

            Data[0].pbData = rgbAux0;
            Data[0].cbData = sizeof(rgbAux0);
            Data[1].pbData = rgbAux1;
            Data[1].cbData = sizeof(rgbAux1);
            Data[2].pbData = rgbAux2;
            Data[2].cbData = sizeof(rgbAux2);

            for (i = 0; i < 3; i++) {
                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_FIRST_USER_PROP_ID + 2 + i,
                        0,                          // dwFlags
                        &Data[i]
                        )) {
                    fResult = FALSE;
                    PrintLastError("CertSetCertificateContextProperty");
                    break;
                }
            }

            if (CertPara[dwCert].dwFlags & AUX1_PARA_FLAG) {
                // Delete CERT_FIRST_USER_PROP_ID + 1
                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_FIRST_USER_PROP_ID + 1,
                        0,                          // dwFlags
                        NULL
                        )) {
                    fResult = FALSE;
                    PrintLastError("CertSetCertificateContextProperty");
                }
            }
        }
        CertFreeCertificateContext(pCert);
    }
    return fResult;
}

static BOOL AddCrl(
    HCERTSTORE hStore,
    DWORD dwCert,
    DWORD dwAuxFlags,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    BOOL fDuplicate = FALSE
    )
{
    BOOL fResult;
    PCCRL_CONTEXT pCrl = NULL;

    fResult = CertAddEncodedCRLToStore(hStore, dwCertEncodingType,
        pbEncoded, cbEncoded, CERT_STORE_ADD_NEW, NULL);
    if (!fResult) {
        if (GetLastError() == CRYPT_E_EXISTS) {
            if (fDuplicate ||
                    0 == strcmp("TestAIACA", CertPara[dwCert].pszName)) {
                printf("CRL already exists in store. Adding duplicate\n");
                fResult = CertAddEncodedCRLToStore(hStore,
                    dwCertEncodingType, pbEncoded, cbEncoded,
                    CERT_STORE_ADD_ALWAYS, &pCrl);
            }
        }
        if (!fResult)
            PrintLastError("CertAddEncodedCRLToStore");
    } else {
        if (fDuplicate)
            printf("AddCrl failed => ADD_NEW duplicate succeeded\n");

        fResult = CertAddEncodedCRLToStore(hStore,
            dwCertEncodingType, pbEncoded, cbEncoded,
                CERT_STORE_ADD_USE_EXISTING, &pCrl);
        if (!fResult)
            PrintLastError("CertAddEncodedCRLToStore");
    }
    if (pCrl) {
        if (dwAuxFlags & AUX1_PARA_FLAG) {
            DWORD i;
            CRYPT_DATA_BLOB Data[4];
            BYTE rgbAux0[] = {0x11, 0x0};
            BYTE rgbAux1[] = {0x11, 0x1};
            BYTE rgbAux2[] = {0x11, 0x2, 0x2};
            BYTE rgbAux3[] = {0x11, 0x3, 0x3, 0x3};

            Data[0].pbData = NULL;
            Data[0].cbData = 0;
            Data[1].pbData = rgbAux1;
            Data[1].cbData = sizeof(rgbAux1);
            Data[2].pbData = rgbAux2;
            Data[2].cbData = sizeof(rgbAux2);
            Data[3].pbData = rgbAux3;
            Data[3].cbData = sizeof(rgbAux3);

            for (i = 0; i < 4; i++) {
                if (!CertSetCRLContextProperty(
                        pCrl,
                        CERT_FIRST_USER_PROP_ID + i,
                        0,                          // dwFlags
                        &Data[i]
                        )) {
                    fResult = FALSE;
                    PrintLastError("CertSetCRLContextProperty");
                    break;
                }
            }
        }

        if (dwAuxFlags & AUX2_PARA_FLAG) {
            DWORD i;
            CRYPT_DATA_BLOB Data[3];
            BYTE rgbAux0[] = {0x22, 0x2, 0x2};
            BYTE rgbAux1[] = {0x22, 0x3, 0x3, 0x3};
            BYTE rgbAux2[] = {0x22, 0x4, 0x4, 0x4, 0x4, 0x12, 0x34};

            Data[0].pbData = rgbAux0;
            Data[0].cbData = sizeof(rgbAux0);
            Data[1].pbData = rgbAux1;
            Data[1].cbData = sizeof(rgbAux1);
            Data[2].pbData = rgbAux2;
            Data[2].cbData = sizeof(rgbAux2);

            for (i = 0; i < 3; i++) {
                if (!CertSetCRLContextProperty(
                        pCrl,
                        CERT_FIRST_USER_PROP_ID + 2 + i,
                        0,                          // dwFlags
                        &Data[i]
                        )) {
                    fResult = FALSE;
                    PrintLastError("CertSetCRLContextProperty");
                    break;
                }
            }
        }
        CertFreeCRLContext(pCrl);
    }
    return fResult;
}


static BOOL AddCtl(
    HCERTSTORE hStore,
    DWORD dwCert,
    BYTE *pbEncoded,
    DWORD cbEncoded)
{
    BOOL fResult;
    PCCTL_CONTEXT pCtl = NULL;

    fResult = CertAddEncodedCTLToStore(hStore, dwMsgAndCertEncodingType,
        pbEncoded, cbEncoded, CERT_STORE_ADD_NEW, NULL);
    if (!fResult) {
        if (GetLastError() == CRYPT_E_EXISTS) {
            printf("CTL already exists in store. Adding duplicate\n");
            fResult = CertAddEncodedCTLToStore(hStore,
                dwMsgAndCertEncodingType, pbEncoded, cbEncoded,
                CERT_STORE_ADD_ALWAYS, &pCtl);
        }
        if (!fResult)
            PrintLastError("CertAddEncodedCTLToStore");
    } else {
        fResult = CertAddEncodedCTLToStore(hStore,
            dwMsgAndCertEncodingType, pbEncoded, cbEncoded,
                CERT_STORE_ADD_USE_EXISTING, &pCtl);
        if (!fResult)
            PrintLastError("CertAddEncodedCTLToStore");
    }
    if (pCtl) {
        if (0 == (CertPara[dwCert].dwFlags & NO_EXT_PARA_FLAG)) {
            CRYPT_DATA_BLOB Data;

            if (CreateNextUpdateLocation(
                    dwCert,
                    TRUE,               // fProp
                    &Data.pbData,
                    &Data.cbData)) {
                if (!CertSetCTLContextProperty(
                        pCtl,
                        CERT_NEXT_UPDATE_LOCATION_PROP_ID,
                        0,                          // dwFlags
                        &Data
                        ))
                    PrintLastError(
                        "CertSetCertificateContextProperty(NEXT_UPDATE)");
                TestFree(Data.pbData);
            }
        }
        CertFreeCTLContext(pCtl);
    }
    return fResult;
}

#define AKI2_KEYID              0
#define AKI2_NONE               1
#define AKI2_FULL               2
#define AKI2_BAD_KEYID          3
#define AKI2_BAD_ISSUER         4
#define AKI2_BAD_SERIAL_NUMBER  5

#define AKI2_CNT                6

// On 02-May-01 updated to not look at the IssuerAndSerialNumber in the CRL's
// AKI
#define AKI2_BAD_CNT            1



static BOOL EncodeCert(DWORD dwCert, BYTE **ppbEncoded, DWORD *pcbEncoded);
static BOOL EncodeCrl(
    DWORD dwCert,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded,
    DWORD dwAki = AKI2_KEYID
    );
static BOOL EncodeBaseOrDeltaCrl(
    DWORD dwIssuer,
    int iBase,
    DWORD dwFlags,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded
    );
static BOOL EncodeCtl(DWORD dwCert, DWORD dwEncodeFlags, BYTE **ppbEncoded,
        DWORD *pcbEncoded);

static BOOL EncodeUpdateCtl(
    BOOL fTimeInvalid,
    LPSTR pszUsageObjId,
    LPSTR pszListIdentifier,
    LPWSTR pwszUrl,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded
    );



static void Usage(void)
{
    printf("Usage: tstore2 [options] <StoreFilename>\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -c<name>              - Crypto key container name\n");
    printf("  -g                    - Generate new keys\n");
    printf("  -E                    - Exportable private keys\n");
    printf("  -U                    - User protected private keys\n");
    printf("  -M                    - Store in local Machine, not current User\n");
    printf("  -P                    - Use enhanced and DSS providers\n");
    printf("  -I                    - Inherit DSS public key parameters\n");
    printf("  -K                    - Keep extra Crls\n");
    printf("\n");
}


int _cdecl main(int argc, char * argv[])
{
    LPSTR pszStoreFilename = NULL;
    HANDLE hStore = 0;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    DWORD i;
    BOOL fKeepCrls = FALSE;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'c':
                pszContainer = argv[0]+2;
                pwszContainer = AllocAndSzToWsz(pszContainer);
                if (*pszContainer == '\0') {
                    printf("Need to specify crypto key container name\n");
                    Usage();
                    return -1;
                }
                break;
            case 'g':
                fGenerate = TRUE;
                break;
            case 'E':
                fExportable = TRUE;
                break;
            case 'U':
                fUserProtected = TRUE;
                break;
            case 'M':
                fMachine = TRUE;
                break;
            case 'P':
                fProviders = TRUE;
                break;
            case 'I':
                fInheritParameters = TRUE;
                break;
            case 'K':
                fKeepCrls = TRUE;
                break;
            case 'h':
            default:
                Usage();
                return -1;
            }
        } else
            pszStoreFilename = argv[0];
    }


    if (pszStoreFilename == NULL) {
        printf("missing store filename\n");
        Usage();
        return -1;
    }

    printf("command line: %s\n", GetCommandLine());

    // Get time used time stamping and serial numbers
    GetSystemTime(&TestTime);
    TestTime.wMilliseconds = 0;

    printf("Getting RSA provider\n");
    hRSACryptProv = GetCryptProv(PROV_RSA_FULL, MS_DEF_PROV_A);
    if (hRSACryptProv == 0)
        return -1;

    printf("Getting DSS provider\n");
    hDSSCryptProv = GetCryptProv(TEST_PROV_DSS);

    if (fProviders) {
        printf("Getting Enhanced RSA provider (1024 bit)\n");
        hEnh1024CryptProv = GetCryptProv(PROV_RSA_FULL, MS_ENHANCED_PROV_A,
            ENH_1024_CONTAINER_NAME_A, 1024);
        if (hEnh1024CryptProv == 0)
            return -1;

        printf("Getting Enhanced RSA provider (2048 bit)\n");
        hEnh2048CryptProv = GetCryptProv(PROV_RSA_FULL, MS_ENHANCED_PROV_A,
            ENH_2048_CONTAINER_NAME_A, 2048);
        if (hEnh2048CryptProv == 0)
            return -1;

        printf("Getting DSS provider (512 bit)\n");
        hDSS512CryptProv = GetCryptProv(TEST_PROV_DSS, NULL,
            DSS_512_CONTAINER_NAME_A, 512);
    } else {
        // Disable all enhanced provider flags
        for (i = 0; i < CERT_CNT; i++)
            CertPara[i].dwFlags &= ~(DSS_512_PARA_FLAG |
                ENH_1024_PARA_FLAG | ENH_2048_PARA_FLAG);
    }

    // Attempt to open the store
    hStore = OpenStore(pszStoreFilename);
    if (hStore == NULL)
        goto ErrorReturn;

    // Encode certs and CRLs and add to the store.
    for (i = 0; i < CERT_CNT; i++) {
        if (EncodeCert(i, &pbEncoded, &cbEncoded)) {
            rgpCertContext[i] = CertCreateCertificateContext(
                dwCertEncodingType, pbEncoded, cbEncoded);
            AddCert(hStore, i, pbEncoded, cbEncoded);
            TestFree(pbEncoded);
            pbEncoded = NULL;
        }

        if (CertPara[i].dwFlags & CA_PARA_FLAG) {
            if (0 == strncmp(CertPara[i].pszName, "Rollover", 8)) {
                // No CRL for rollover certs
                ;
            } else if (CertPara[i].dwFlags & DUPLICATE_CRL_PARA_FLAG) {
                DWORD dwAki;
                for (dwAki = 0; dwAki < AKI2_CNT; dwAki++) {
                    if (EncodeCrl(i, &pbEncoded, &cbEncoded, dwAki)) {
                        if (AKI2_BAD_SERIAL_NUMBER == dwAki)
                            // Modify the signature
                            pbEncoded[cbEncoded -1] ^= 0xFF;

                        AddCrl(hStore, i, AUX1_PARA_FLAG, pbEncoded, cbEncoded);
                        AddCrl(hStore, i, AUX2_PARA_FLAG, pbEncoded, cbEncoded,
                            TRUE);
                        TestFree(pbEncoded);
                        pbEncoded = NULL;
                    }
                }
            } else {
                if (EncodeCrl(i, &pbEncoded, &cbEncoded)) {
                    AddCrl(hStore, i, 0, pbEncoded, cbEncoded);
                    TestFree(pbEncoded);
                    pbEncoded = NULL;
                }
            }
        }
    }

    // Test CertFindCRLInStore(CRL_FIND_ISSUED_BY)
    for (i = 0; i < CERT_CNT; i++) {
        if ((CA_PARA_FLAG | DUPLICATE_CRL_PARA_FLAG) ==
                ((CA_PARA_FLAG | DUPLICATE_CRL_PARA_FLAG) &
                    CertPara[i].dwFlags)) {
            PCCERT_CONTEXT pIssuer = rgpCertContext[i];
            DWORD dwCnt;
            PCCRL_CONTEXT pCrl;

            printf("CertFindCRLInStore(CRL_FIND_ISSUED_BY) [%d]\n", i);

            dwCnt = 0;
            pCrl = NULL;
            while (pCrl = CertFindCRLInStore(
                    hStore,
                    dwCertEncodingType,
                    0,                      // dwFindFlags
                    CRL_FIND_ISSUED_BY,
                    (const void *) pIssuer,
                    pCrl
                    ))
                dwCnt++;
            if ((AKI2_CNT * 2) != dwCnt)
                printf("CRL_FIND_ISSUED_BY failed count => expected: %d actual: %d\n",
                    AKI2_CNT * 2, dwCnt);

            dwCnt = 0;
            pCrl = NULL;
            while (pCrl = CertFindCRLInStore(
                    hStore,
                    dwCertEncodingType,
                    CRL_FIND_ISSUED_BY_AKI_FLAG,
                    CRL_FIND_ISSUED_BY,
                    (const void *) pIssuer,
                    pCrl
                    ))
                dwCnt++;
            if (((AKI2_CNT - AKI2_BAD_CNT) * 2) != dwCnt)
                printf("CRL_FIND_ISSUED_BY(AKI_FLAG) failed count => expected: %d actual: %d\n",
                    (AKI2_CNT - AKI2_BAD_CNT) * 2, dwCnt);

            dwCnt = 0;
            pCrl = NULL;
            while (pCrl = CertFindCRLInStore(
                    hStore,
                    dwCertEncodingType,
                    CRL_FIND_ISSUED_BY_SIGNATURE_FLAG,
                    CRL_FIND_ISSUED_BY,
                    (const void *) pIssuer,
                    pCrl
                    ))
                dwCnt++;
            if (((AKI2_CNT - 1) * 2) != dwCnt)
                printf("CRL_FIND_ISSUED_BY(SIGNATURE_FLAG) failed count => expected: %d actual: %d\n",
                    (AKI2_CNT - 1) * 2, dwCnt);

            if (!fKeepCrls) {
                // Delete all but the last pair of duplicates

                dwCnt = 0;
                pCrl = NULL;
                while (pCrl = CertFindCRLInStore(
                        hStore,
                        dwCertEncodingType,
                        0,                      // dwFindFlags
                        CRL_FIND_ISSUED_BY,
                        (const void *) pIssuer,
                        pCrl
                        )) {
                    PCCRL_CONTEXT pDeleteCrl = CertDuplicateCRLContext(pCrl);
                    CertDeleteCRLFromStore(pDeleteCrl);
                    if (((AKI2_CNT - 1) * 2) == ++dwCnt) {
                        CertFreeCRLContext(pCrl);
                        break;
                    }
                }

                dwCnt = 0;
                pCrl = NULL;
                while (pCrl = CertFindCRLInStore(
                        hStore,
                        dwCertEncodingType,
                        CRL_FIND_ISSUED_BY_AKI_FLAG |
                            CRL_FIND_ISSUED_BY_SIGNATURE_FLAG,
                        CRL_FIND_ISSUED_BY,
                        (const void *) pIssuer,
                        pCrl
                        ))
                    dwCnt++;
                if (2 != dwCnt)
                    printf("CRL_FIND_ISSUED_BY(After delete) failed count => expected: %d actual: %d\n",
                        2, dwCnt);
            }
        }
    }

    // Encode CTLs and add to the store.
    for (i = 0; i < CERT_CNT; i++) {
        if (CertPara[i].dwFlags & (CTL1_PARA_FLAG | CTL2_PARA_FLAG)) {
            if (EncodeCtl(i, 0, &pbEncoded, &cbEncoded)) {
                AddCtl(hStore, i, pbEncoded, cbEncoded);
                TestFree(pbEncoded);
                pbEncoded = NULL;
            }
            if (EncodeCtl(
                    i,
#ifdef CMS_PKCS7
                    CMSG_CMS_ENCAPSULATED_CTL_FLAG |
#endif  // CMS_PKCS7
                    CMSG_ENCODE_SORTED_CTL_FLAG |
                        ((CertPara[i].dwFlags & CTL1_PARA_FLAG) ? 0 :
                            CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG),
                    &pbEncoded,
                    &cbEncoded)) {
                AddCtl(hStore, i, pbEncoded, cbEncoded);
                TestFree(pbEncoded);
                pbEncoded = NULL;
            }
        }
    }

    for (i = 0; i < BASE_DELTA_CRL_CNT; i++) {
        if (EncodeBaseOrDeltaCrl(
                BASE_OR_DELTA_CA_ISSUER,
                BaseDeltaCrlPara[i].iBase,
                BaseDeltaCrlPara[i].dwFlags,
                &pbEncoded,
                &cbEncoded)) {
            BOOL fResult;

            fResult = CertAddEncodedCRLToStore(hStore,
                dwCertEncodingType, pbEncoded, cbEncoded,
                    CERT_STORE_ADD_ALWAYS, NULL);
            if (!fResult)
                PrintLastError("CertAddEncodedCRLToStore");
            TestFree(pbEncoded);
            pbEncoded = NULL;
        }
    }

    for (i = 0; i < UPDATE_CTL_CNT; i++) {
        if (EncodeUpdateCtl(
                UpdateCtlPara[i].fTimeInvalid,
                UpdateCtlPara[i].pszUsageObjId,
                UpdateCtlPara[i].pszListIdentifier,
                UpdateCtlPara[i].pwszUrl,
                &pbEncoded,
                &cbEncoded)) {
            BOOL fResult;

            fResult = CertAddEncodedCTLToStore(hStore,
                dwMsgAndCertEncodingType, pbEncoded, cbEncoded,
                    CERT_STORE_ADD_ALWAYS, NULL);
            if (!fResult)
                PrintLastError("CertAddEncodedCTLToStore");
            TestFree(pbEncoded);
            pbEncoded = NULL;
        }
    }

    for (i = 0; i < CERT_CNT; i++)
        CertFreeCertificateContext(rgpCertContext[i]);


    SaveStore(hStore, pszStoreFilename);

ErrorReturn:
    if (pbEncoded)
        TestFree(pbEncoded);

    if (hStore) {
        if (!CertCloseStore(hStore, 0))
            PrintLastError("CertCloseStore");
    }

    if (hRSACryptProv)
        CryptReleaseContext(hRSACryptProv, 0);
    if (hEnh1024CryptProv)
        CryptReleaseContext(hEnh1024CryptProv, 0);
    if (hEnh2048CryptProv)
        CryptReleaseContext(hEnh2048CryptProv, 0);
    if (hDSSCryptProv)
        CryptReleaseContext(hDSSCryptProv, 0);
    if (hDSS512CryptProv)
        CryptReleaseContext(hDSS512CryptProv, 0);

    if (pwszContainer)
        TestFree(pwszContainer);

    printf("Done.\n");

    return 0;
}


static BOOL AllocAndSignToBeSigned(
    DWORD dwIssuer,
    BYTE *pbToBeSigned,
    DWORD cbToBeSigned,
    PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    BYTE **ppbSignature,
    DWORD *pcbSignature)
{
    BOOL fResult;
    BYTE *pbSignature = NULL;
    DWORD cbSignature;
    HCRYPTPROV hProv;

    if (CertPara[dwIssuer].dwFlags & DSS_PARA_FLAG) {
        if (CertPara[dwIssuer].dwFlags & DSS_512_PARA_FLAG)
            hProv = hDSS512CryptProv;
        else
            hProv = hDSSCryptProv;
    } else if (CertPara[dwIssuer].dwFlags & ENH_1024_PARA_FLAG)
        hProv = hEnh1024CryptProv;
    else if (CertPara[dwIssuer].dwFlags & ENH_2048_PARA_FLAG)
        hProv = hEnh2048CryptProv;
    else
        hProv = hRSACryptProv;

    cbSignature = 0;
    CryptSignCertificate(
                hProv,
                AT_SIGNATURE,
                dwCertEncodingType,
                pbToBeSigned,
                cbToBeSigned,
                pSignatureAlgorithm,
                NULL,                   // pvHashAuxInfo
                NULL,                   // pbSignature
                &cbSignature
                );
    if (cbSignature == 0) {
        PrintLastError("AllocAndSignToBeSigned::CryptSignCertificate(cb == 0)");
        goto ErrorReturn;
    }
    pbSignature = (BYTE *) TestAlloc(cbSignature);
    if (pbSignature == NULL) goto ErrorReturn;
    if (!CryptSignCertificate(
                hProv,
                AT_SIGNATURE,
                dwCertEncodingType,
                pbToBeSigned,
                cbToBeSigned,
                pSignatureAlgorithm,
                NULL,                   // pvHashAuxInfo
                pbSignature,
                &cbSignature
                )) {
        PrintLastError("AllocAndSignToBeSigned::CryptSignCertificate");
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    if (pbSignature) {
        TestFree(pbSignature);
        pbSignature = NULL;
    }
    cbSignature = 0;
CommonReturn:
    *ppbSignature = pbSignature;
    *pcbSignature = cbSignature;
    return fResult;
}

static BOOL EncodeSignedContent(
    DWORD dwIssuer,
    BYTE *pbToBeSigned,
    DWORD cbToBeSigned,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded)
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbSignature = NULL;
    DWORD cbSignature;
    CERT_SIGNED_CONTENT_INFO CertEncoding;

    CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm = {
        SIGNATURE_ALG_OBJID, 0, 0
    };

    if (CertPara[dwIssuer].dwFlags & DSS_PARA_FLAG)
        SignatureAlgorithm.pszObjId = DSS_SIGNATURE_ALG_OBJID;

    if (!AllocAndSignToBeSigned(dwIssuer, pbToBeSigned, cbToBeSigned,
            &SignatureAlgorithm, &pbSignature, &cbSignature))
        goto ErrorReturn;

    memset(&CertEncoding, 0, sizeof(CertEncoding));
    CertEncoding.ToBeSigned.pbData = pbToBeSigned;
    CertEncoding.ToBeSigned.cbData = cbToBeSigned;
    CertEncoding.SignatureAlgorithm = SignatureAlgorithm;
    CertEncoding.Signature.pbData = pbSignature;
    CertEncoding.Signature.cbData = cbSignature;

    if (!AllocAndEncodeObject(
            X509_CERT,
            &CertEncoding,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbSignature)
        TestFree(pbSignature);
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}


static BOOL GetPublicKey(
    DWORD dwCert,
    PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo)
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;
    DWORD dwKeySpec;
    HCRYPTPROV hProv;

    if (CertPara[dwCert].dwFlags & XCHG_PARA_FLAG)
        dwKeySpec = AT_KEYEXCHANGE;
    else
        dwKeySpec = AT_SIGNATURE;

    if (CertPara[dwCert].dwFlags & DSS_PARA_FLAG) {
        if (CertPara[dwCert].dwFlags & DSS_512_PARA_FLAG)
            hProv = hDSS512CryptProv;
        else
            hProv = hDSSCryptProv;
    } else if (CertPara[dwCert].dwFlags & ENH_1024_PARA_FLAG)
        hProv = hEnh1024CryptProv;
    else if (CertPara[dwCert].dwFlags & ENH_2048_PARA_FLAG)
        hProv = hEnh2048CryptProv;
    else
        hProv = hRSACryptProv;

    cbPubKeyInfo = 0;
    CryptExportPublicKeyInfo(
        hProv,
        dwKeySpec,
        dwCertEncodingType,
        NULL,               // pPubKeyInfo
        &cbPubKeyInfo
        );
    if (cbPubKeyInfo == 0) {
        PrintLastError("GetPublicKey::CryptExportPublicKeyInfo(cb == 0)");
        goto ErrorReturn;
    }
    pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) TestAlloc(cbPubKeyInfo);
    if (pPubKeyInfo == NULL) goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hProv,
            dwKeySpec,
            dwCertEncodingType,
            pPubKeyInfo,
            &cbPubKeyInfo
            )) {
        PrintLastError("GetPublicKey::CryptExportPublicKeyInfo");
        goto ErrorReturn;
    }

    if (fInheritParameters) {
        DWORD dwIssuer = CertPara[dwCert].dwIssuer;

        if (dwCert != dwIssuer &&
                0 == (CertPara[dwCert].dwFlags & XCHG_PARA_FLAG) &&
                0 == (CertPara[dwCert].dwFlags & DSS_512_PARA_FLAG) &&
                0 != (CertPara[dwCert].dwFlags & DSS_PARA_FLAG) &&
                0 == (CertPara[dwIssuer].dwFlags & DSS_512_PARA_FLAG) &&
                0 != (CertPara[dwIssuer].dwFlags & DSS_PARA_FLAG)) {
            pPubKeyInfo->Algorithm.Parameters.cbData = 0;
            pPubKeyInfo->Algorithm.Parameters.pbData = NULL;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    if (pPubKeyInfo) {
        TestFree(pPubKeyInfo);
        pPubKeyInfo = NULL;
    }
CommonReturn:
    *ppPubKeyInfo = pPubKeyInfo;
    return fResult;
}

#define SHA1_HASH_LEN 20
static BOOL Sha1HashPublicKey(
    DWORD dwCert,
    BYTE rgbHash[SHA1_HASH_LEN]
    )
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbHash;

    // Get Certificates's PUBLIC KEY. SHA1 hash the encoded public key.
    if (!GetPublicKey(dwCert, &pPubKeyInfo)) goto ErrorReturn;

#if 1
    cbHash = SHA1_HASH_LEN;
    if (!CryptHashPublicKeyInfo(
            0,                  // hCryptProv
            CALG_SHA1,
            0,
            dwCertEncodingType,
            pPubKeyInfo,
            rgbHash,
            &cbHash)) {
        PrintLastError("Sha1HashPublicKey::CryptHashPublicKeyInfo");
        goto ErrorReturn;
    }
#else
    cbHash = SHA1_HASH_LEN;
    if (!CryptHashCertificate(
            0,                  // hCryptProv
            CALG_SHA1,
            0,                  // dwFlags
            pPubKeyInfo->PublicKey.pbData,
            pPubKeyInfo->PublicKey.cbData,
            rgbHash,
            &cbHash)) {
        PrintLastError("Sha1HashPublicKey::CryptHashCertificate");
        goto ErrorReturn;
    }
#endif

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    memset(rgbHash, 0, SHA1_HASH_LEN);
CommonReturn:
    if (pPubKeyInfo)
        TestFree(pPubKeyInfo);
    return fResult;
}

static void CreateNameInfo(
    DWORD dwCert,
    PCERT_NAME_INFO pInfo,
    PCERT_RDN pRDN,
    CERT_RDN_ATTR rgAttr[]
    )
{
    LPSTR pszKey;
    LPSTR pszUser;
    DWORD i;


    assert(RDN_CNT == ATTR_CNT);
    for (i = 0; i < RDN_CNT; i++) {
        pRDN[i].cRDNAttr = 1;
        pRDN[i].rgRDNAttr = &rgAttr[i];
    }

    if (CertPara[dwCert].dwFlags & NO_NAME_PARA_FLAG) {
        pInfo->cRDN = 0;
        pInfo->rgRDN = NULL;
    } else if (CertPara[dwCert].dwFlags & VALID_PARA_FLAG) {
        pInfo->cRDN = 1;
        pInfo->rgRDN = pRDN;
    } else if (CertPara[dwCert].dwFlags & CA_PARA_FLAG) {
        pInfo->cRDN = RDN_CNT - 1;
        pInfo->rgRDN = pRDN;
    } else {
        pInfo->cRDN = RDN_CNT;
        pInfo->rgRDN = pRDN;
    }

    rgAttr[0].pszObjId = ATTR_0_OBJID;
    if (0 == strcmp("UTF8", CertPara[dwCert].pszName)) {
        rgAttr[0].dwValueType = CERT_RDN_UTF8_STRING;
        rgAttr[0].Value.pbData = (BYTE *) UTF8_NAME;
        rgAttr[0].Value.cbData = wcslen(UTF8_NAME) * sizeof(WCHAR);
    } else {
        rgAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
        rgAttr[0].Value.pbData = (BYTE *) CertPara[dwCert].pszName;
        rgAttr[0].Value.cbData = strlen(CertPara[dwCert].pszName);
    }

    rgAttr[1].pszObjId = ATTR_1_OBJID;
    rgAttr[1].dwValueType = CERT_RDN_PRINTABLE_STRING;
    if (CertPara[dwCert].dwFlags & XCHG_PARA_FLAG)
        pszKey = "xchg";
    else
        pszKey = "sign";
    rgAttr[1].Value.pbData = (BYTE *) pszKey;
    rgAttr[1].Value.cbData = strlen(pszKey);

    rgAttr[2].pszObjId = ATTR_2_OBJID;
    rgAttr[2].dwValueType = CERT_RDN_PRINTABLE_STRING;
    if (pszContainer)
        pszUser = pszContainer;
    else
        pszUser = "default";
    rgAttr[2].Value.pbData = (BYTE *) pszUser;
    rgAttr[2].Value.cbData = strlen(pszUser);

    rgAttr[3].pszObjId = szOID_RSA_emailAddr;
    rgAttr[3].dwValueType = CERT_RDN_IA5_STRING;
    rgAttr[3].Value.pbData = (BYTE *) "  MyEmail@WhereEver.com ";
    rgAttr[3].Value.cbData = strlen("  MyEmail@WhereEver.com ");

    assert(ATTR_CNT == 3+1);
}

static BOOL CreateAuthorityKeyId(
        DWORD dwIssuer,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbNameEncoded = NULL;
    DWORD cbNameEncoded;
    CERT_AUTHORITY_KEY_ID_INFO KeyIdInfo;

    CERT_RDN rgRDN[RDN_CNT];
    CERT_RDN_ATTR rgAttr[ATTR_CNT];
    CERT_NAME_INFO Name;
    FILETIME SerialNumber;

    memset(&KeyIdInfo, 0, sizeof(KeyIdInfo));

    // Issuer's KeyId
    KeyIdInfo.KeyId.pbData = (BYTE *) &dwIssuer;
    KeyIdInfo.KeyId.cbData = sizeof(dwIssuer);

    // Issuer's Issuer
    CreateNameInfo(CertPara[dwIssuer].dwIssuer,
        &Name, rgRDN, rgAttr);

    if (!AllocAndEncodeObject(
            X509_NAME,
            &Name,
            &pbNameEncoded,
            &cbNameEncoded))
        goto ErrorReturn;

    KeyIdInfo.CertIssuer.pbData = pbNameEncoded;
    KeyIdInfo.CertIssuer.cbData = cbNameEncoded;

    // Issuer's SerialNumber
    {
        SYSTEMTIME SystemTime = TestTime;
        SystemTime.wMilliseconds += (WORD) dwIssuer;
        MySystemTimeToFileTime(&SystemTime, &SerialNumber);
    }
    KeyIdInfo.CertSerialNumber.pbData = (BYTE *) &SerialNumber;
    KeyIdInfo.CertSerialNumber.cbData = sizeof(SerialNumber);

    if (!AllocAndEncodeObject(
            X509_AUTHORITY_KEY_ID,
            &KeyIdInfo,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbNameEncoded)
        TestFree(pbNameEncoded);

    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateAuthorityKeyId2(
        DWORD dwCert,
        DWORD dwIssuer,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded,
        IN DWORD dwAki = AKI2_KEYID
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbNameEncoded = NULL;
    DWORD cbNameEncoded;
    CERT_AUTHORITY_KEY_ID2_INFO KeyId2Info;
    CERT_ALT_NAME_ENTRY AltNameEntry;

    BYTE rgbPubKeyHash[SHA1_HASH_LEN];

    CERT_RDN rgRDN[RDN_CNT];
    CERT_RDN_ATTR rgAttr[ATTR_CNT];
    CERT_NAME_INFO Name;
    FILETIME SerialNumber;

    memset(&KeyId2Info, 0, sizeof(KeyId2Info));

    // Issuer's KeyId
    if (AKI2_BAD_KEYID == dwAki)
        memset(rgbPubKeyHash, 0xba, sizeof(rgbPubKeyHash));
    else
        Sha1HashPublicKey(dwIssuer, rgbPubKeyHash);
    KeyId2Info.KeyId.pbData = rgbPubKeyHash;
    KeyId2Info.KeyId.cbData = sizeof(rgbPubKeyHash);

    if (AKI2_FULL == dwAki ||
            AKI2_BAD_ISSUER == dwAki ||
            AKI2_BAD_SERIAL_NUMBER == dwAki ||
            (CertPara[dwCert].dwFlags & ALL_EXT_PARA_FLAG)) {

        if (AKI2_BAD_ISSUER == dwAki) {
            Name.cRDN = 1;
            Name.rgRDN = rgRDN;
            rgRDN[0].cRDNAttr = 1;
            rgRDN[0].rgRDNAttr = rgAttr;

            rgAttr[0].pszObjId = szOID_COMMON_NAME;
            rgAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
            rgAttr[0].Value.pbData = (BYTE *) "AKI2BadIssuer";
            rgAttr[0].Value.cbData = strlen("AKI2BadIssuer");
        } else
            // Issuer's Issuer
            CreateNameInfo(CertPara[dwIssuer].dwIssuer,
                &Name, rgRDN, rgAttr);

        if (!AllocAndEncodeObject(
                X509_NAME,
                &Name,
                &pbNameEncoded,
                &cbNameEncoded))
            goto ErrorReturn;

        AltNameEntry.dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
        AltNameEntry.DirectoryName.pbData = pbNameEncoded;
        AltNameEntry.DirectoryName.cbData = cbNameEncoded;
        KeyId2Info.AuthorityCertIssuer.cAltEntry = 1;
        KeyId2Info.AuthorityCertIssuer.rgAltEntry = &AltNameEntry;

        // Issuer's SerialNumber
        {
            SYSTEMTIME SystemTime = TestTime;
            if (AKI2_BAD_SERIAL_NUMBER == dwAki)
                SystemTime.wMilliseconds += CERT_CNT;
            else
                SystemTime.wMilliseconds += (WORD) dwIssuer;
            MySystemTimeToFileTime(&SystemTime, &SerialNumber);
        }
        KeyId2Info.AuthorityCertSerialNumber.pbData = (BYTE *) &SerialNumber;
        KeyId2Info.AuthorityCertSerialNumber.cbData = sizeof(SerialNumber);
    }

    if (!AllocAndEncodeObject(
            X509_AUTHORITY_KEY_ID2,
            &KeyId2Info,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbNameEncoded)
        TestFree(pbNameEncoded);

    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateAuthorityInfoAccess(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD dwIssuer = CertPara[dwCert].dwIssuer;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbNameEncoded = NULL;
    DWORD cbNameEncoded;
    CERT_AUTHORITY_INFO_ACCESS AuthorityInfoAccess;

#define ACCESS_DESCR_COUNT  12 
    CERT_ACCESS_DESCRIPTION rgAccess[ACCESS_DESCR_COUNT];

    CERT_RDN rgRDN[RDN_CNT];
    CERT_RDN_ATTR rgAttr[ATTR_CNT];
    CERT_NAME_INFO Name;

    // Issuer's Issuer
    CreateNameInfo(CertPara[dwIssuer].dwIssuer, &Name, rgRDN, rgAttr);

    if (!AllocAndEncodeObject(
            X509_NAME,
            &Name,
            &pbNameEncoded,
            &cbNameEncoded))
        goto ErrorReturn;

    rgAccess[0].pszAccessMethod = szOID_PKIX_OCSP;
    rgAccess[0].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[0].AccessLocation.pwszURL = L"URL to the stars";
    rgAccess[1].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[1].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
    rgAccess[1].AccessLocation.DirectoryName.pbData = pbNameEncoded;
    rgAccess[1].AccessLocation.DirectoryName.cbData = cbNameEncoded;
    rgAccess[2].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[2].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgAccess[2].AccessLocation.pwszRfc822Name = L"issuer@mail.com";
    rgAccess[3].pszAccessMethod = szOID_PKIX_OCSP;
    rgAccess[3].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[3].AccessLocation.pwszURL = L"URL to the POLICY";
    rgAccess[4].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[4].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[4].AccessLocation.pwszURL = L"http://URLToTheIssuerCertificate";
    rgAccess[5].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[5].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[5].AccessLocation.pwszURL = L"ldap://ntdev.microsoft.com/c=us??sub";
    rgAccess[6].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[6].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[6].AccessLocation.pwszURL = L"file://FileToTheIssuerCertificate";
    rgAccess[7].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[7].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[7].AccessLocation.pwszURL = L"file://FileToTheIssuerCertificate";
    rgAccess[8].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[8].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[8].AccessLocation.pwszURL = L"file://FileToTheIssuerCertificate";
    rgAccess[9].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[9].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[9].AccessLocation.pwszURL = L"file://FileToTheIssuerCertificate";
    rgAccess[10].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[10].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[10].AccessLocation.pwszURL = L"http://crl.verisign.com/class1.crl";
    rgAccess[11].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[11].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[11].AccessLocation.pwszURL = L"http://crl.microsoft.com/pki/crl/products/CodeSignPCA.crl";

    memset(&AuthorityInfoAccess, 0, sizeof(AuthorityInfoAccess));
    if (0 == strcmp("TestAIAEnd", CertPara[dwCert].pszName)) {
        rgAccess[0].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
        rgAccess[0].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
        rgAccess[0].AccessLocation.pwszURL = L"file://TestAIACA.p7b";
        AuthorityInfoAccess.cAccDescr = 1;
        AuthorityInfoAccess.rgAccDescr = rgAccess;
    } else if (0 == strcmp("RolloverCA", CertPara[dwCert].pszName)) {
        rgAccess[0].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
        rgAccess[0].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
        rgAccess[0].AccessLocation.pwszURL = L"file://RolloverAIARoot.p7b";
        AuthorityInfoAccess.cAccDescr = 1;
        AuthorityInfoAccess.rgAccDescr = rgAccess;
    } else if (0 == strcmp("kevin", CertPara[dwCert].pszName)) {
        rgAccess[0].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
        rgAccess[0].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
        rgAccess[0].AccessLocation.pwszURL = L"http://vbl03ca.ntdev.microsoft.com/CertEnroll/vbl03ca.ntdev.microsoft.com_Microsoft%20Windows%20VBL03CA.crt";
        AuthorityInfoAccess.cAccDescr = 1;
        AuthorityInfoAccess.rgAccDescr = rgAccess;
    } else if (CertPara[dwCert].dwFlags & ALL_EXT_PARA_FLAG) {
        AuthorityInfoAccess.cAccDescr = 11;
        AuthorityInfoAccess.rgAccDescr = &rgAccess[1];
    } else {
        AuthorityInfoAccess.cAccDescr = 1;
        AuthorityInfoAccess.rgAccDescr = rgAccess;
    }

    if (!AllocAndEncodeObject(
            X509_AUTHORITY_INFO_ACCESS,
            &AuthorityInfoAccess,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbNameEncoded)
        TestFree(pbNameEncoded);

    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BYTE CrlIPAddress[] =    {1,2,3,4};
#define CRL_DNS_NAME            L"CRL.DNS.NAME.COM"
#define CRL_EMAIL_NAME          L"email@CRL.DNS.NAME.COM"
#define CRL_URL_NAME1           L"file://crltest1.p7b"
#define CRL_URL_NAME2           L"file://crltest2.p7b"
#define CRL_REGISTERED_ID       "1.2.3.4.5.6"

static BYTE rgbCrlOtherName[] = {0x02, 0x02, 0x11, 0x22};
static CERT_OTHER_NAME CrlOtherName = {
    "1.2.33.44.55.66", sizeof(rgbCrlOtherName), rgbCrlOtherName };

#define CRL_DIST_POINTS_DELTA_FLAG          0x1
#define CRL_DIST_POINTS_UNSUPPORTED_FLAG    0x2

static BOOL CreateCrlDistPoints(
        DWORD dwIssuer,
        BOOL dwFlags,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CRL_DIST_POINTS_INFO CrlDistPointsInfo;

    BYTE bReasonFlags;
    CERT_ALT_NAME_ENTRY rgAltNameEntry[9];
    CERT_ALT_NAME_ENTRY rgIssuerAltNameEntry[1];
    CRL_DIST_POINT rgDistPoint[5];

    CERT_RDN rgRDN[RDN_CNT];
    CERT_RDN_ATTR rgAttr[ATTR_CNT];
    CERT_NAME_INFO Name;
    BYTE *pbIssuerNameEncoded = NULL;
    DWORD cbIssuerNameEncoded;

    if (dwFlags & CRL_DIST_POINTS_DELTA_FLAG) {
        // ISSUER
        CreateNameInfo(dwIssuer, &Name, rgRDN, rgAttr);
        if (!AllocAndEncodeObject(
                X509_NAME,
                &Name,
                &pbIssuerNameEncoded,
                &cbIssuerNameEncoded
                ))
            goto ErrorReturn;


        rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
        rgAltNameEntry[0].pwszDNSName = CRL_DNS_NAME;
        rgAltNameEntry[1].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
        rgAltNameEntry[1].pwszRfc822Name = CRL_EMAIL_NAME;
        rgAltNameEntry[2].dwAltNameChoice = CERT_ALT_NAME_IP_ADDRESS;
        rgAltNameEntry[2].IPAddress.pbData = CrlIPAddress;
        rgAltNameEntry[2].IPAddress.cbData = sizeof(CrlIPAddress);
        rgAltNameEntry[3].dwAltNameChoice = CERT_ALT_NAME_REGISTERED_ID;
        rgAltNameEntry[3].pszRegisteredID = CRL_REGISTERED_ID;
        rgAltNameEntry[4].dwAltNameChoice = CERT_ALT_NAME_URL;
        rgAltNameEntry[4].pwszURL = CRL_URL_NAME2;
        rgAltNameEntry[5].dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
        rgAltNameEntry[5].pOtherName = &CrlOtherName;
        rgAltNameEntry[6].dwAltNameChoice = CERT_ALT_NAME_URL;
        rgAltNameEntry[6].pwszURL = CRL_URL_NAME1;
        rgAltNameEntry[7].dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
        rgAltNameEntry[7].DirectoryName.pbData = pbIssuerNameEncoded;
        rgAltNameEntry[7].DirectoryName.cbData = cbIssuerNameEncoded;
        rgAltNameEntry[8].dwAltNameChoice = CERT_ALT_NAME_URL;
        rgAltNameEntry[8].pwszURL = L"file://BadUnsupportedChoice.crl";


        rgIssuerAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_URL;
        rgIssuerAltNameEntry[0].pwszURL = L"CRL Issuer URL";

        memset(rgDistPoint, 0, sizeof(rgDistPoint));

        // [0] has unsupported ReasonFlags
        rgDistPoint[0].DistPointName.dwDistPointNameChoice =
            CRL_DIST_POINT_FULL_NAME;
        rgDistPoint[0].DistPointName.FullName.cAltEntry = 1;
        rgDistPoint[0].DistPointName.FullName.rgAltEntry = &rgAltNameEntry[8];
        rgDistPoint[0].ReasonFlags.cbData = 1;
        rgDistPoint[0].ReasonFlags.pbData = &bReasonFlags;
        rgDistPoint[0].ReasonFlags.cUnusedBits = 1;
        bReasonFlags = CRL_REASON_KEY_COMPROMISE_FLAG |
            CRL_REASON_CA_COMPROMISE_FLAG;
        // [1] has unsupported CRLIssuer
        rgDistPoint[1].DistPointName.dwDistPointNameChoice =
            CRL_DIST_POINT_FULL_NAME;
        rgDistPoint[1].DistPointName.FullName.cAltEntry = 1;
        rgDistPoint[1].DistPointName.FullName.rgAltEntry = &rgAltNameEntry[8];
        rgDistPoint[1].CRLIssuer.cAltEntry = 1;
        rgDistPoint[1].CRLIssuer.rgAltEntry = rgIssuerAltNameEntry;
        // [2] is empty
        rgDistPoint[3].DistPointName.dwDistPointNameChoice =
            CRL_DIST_POINT_FULL_NAME;
        rgDistPoint[3].DistPointName.FullName.cAltEntry = 5;
        rgDistPoint[3].DistPointName.FullName.rgAltEntry = &rgAltNameEntry[0];
        rgDistPoint[4].DistPointName.dwDistPointNameChoice =
            CRL_DIST_POINT_FULL_NAME;
        rgDistPoint[4].DistPointName.FullName.cAltEntry = 3;
        rgDistPoint[4].DistPointName.FullName.rgAltEntry = &rgAltNameEntry[5];

        memset(&CrlDistPointsInfo, 0, sizeof(CrlDistPointsInfo));
        CrlDistPointsInfo.rgDistPoint = &rgDistPoint[0];
        if (dwFlags & CRL_DIST_POINTS_UNSUPPORTED_FLAG)
            CrlDistPointsInfo.cDistPoint = 1;
        else
            CrlDistPointsInfo.cDistPoint = 5;
    } else {
        rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_URL;
        rgAltNameEntry[0].pwszURL = L"file://test1.crl";

        memset(rgDistPoint, 0, sizeof(rgDistPoint));
        rgDistPoint[0].DistPointName.dwDistPointNameChoice =
            CRL_DIST_POINT_FULL_NAME;
        rgDistPoint[0].DistPointName.FullName.cAltEntry = 1;
        rgDistPoint[0].DistPointName.FullName.rgAltEntry = &rgAltNameEntry[0];

        memset(&CrlDistPointsInfo, 0, sizeof(CrlDistPointsInfo));
        CrlDistPointsInfo.rgDistPoint = &rgDistPoint[0];
        CrlDistPointsInfo.cDistPoint = 1;
    }

    if (!AllocAndEncodeObject(
            X509_CRL_DIST_POINTS,
            &CrlDistPointsInfo,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if(pbIssuerNameEncoded)
        TestFree(pbIssuerNameEncoded);
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}


static BOOL CreateCertIssuingDistPoint(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CRL_ISSUING_DIST_POINT Info;

    BYTE bOnlySomeReasonFlags;
    CERT_ALT_NAME_ENTRY rgAltNameEntry[2];

    rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[0].pwszURL = L"file://test1.crl";
    rgAltNameEntry[1].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[1].pwszURL = L"file://test1.crl";

    memset(&Info, 0, sizeof(Info));
    Info.DistPointName.dwDistPointNameChoice =
        CRL_DIST_POINT_FULL_NAME;
    Info.DistPointName.FullName.cAltEntry = 2;
    Info.DistPointName.FullName.rgAltEntry = &rgAltNameEntry[0];

    Info.OnlySomeReasonFlags.cbData = 1;
    Info.OnlySomeReasonFlags.pbData = &bOnlySomeReasonFlags;
    Info.OnlySomeReasonFlags.cUnusedBits = 1;
    bOnlySomeReasonFlags = CRL_REASON_KEY_COMPROMISE_FLAG |
        CRL_REASON_CA_COMPROMISE_FLAG;

    Info.fIndirectCRL = TRUE;
    Info.fOnlyContainsUserCerts = TRUE;
    Info.fOnlyContainsCACerts = TRUE;

    if (!AllocAndEncodeObject(
            X509_ISSUING_DIST_POINT,
            &Info,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateCrlIssuingDistPoint(
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CRL_ISSUING_DIST_POINT Info;

    CERT_ALT_NAME_ENTRY rgAltNameEntry[1];

    rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[0].pwszURL = L"file://test1.crl";

    memset(&Info, 0, sizeof(Info));
    Info.DistPointName.dwDistPointNameChoice =
        CRL_DIST_POINT_FULL_NAME;
    Info.DistPointName.FullName.cAltEntry = 1;
    Info.DistPointName.FullName.rgAltEntry = &rgAltNameEntry[0];

    if (!AllocAndEncodeObject(
            szOID_ISSUING_DIST_POINT,
            &Info,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateNameConstraints(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCERT_NAME_CONSTRAINTS_INFO pInfo;

    CERT_NAME_CONSTRAINTS_INFO RootInfo;
    CERT_GENERAL_SUBTREE rgRootPermitted[15];
    CERT_GENERAL_SUBTREE rgRootExcluded[15];

    CERT_NAME_CONSTRAINTS_INFO CaInfo;
    CERT_GENERAL_SUBTREE rgCaPermitted[15];

    CERT_NAME_CONSTRAINTS_INFO MissingInfo;
    CERT_GENERAL_SUBTREE rgMissingPermitted[15];
    CERT_GENERAL_SUBTREE rgMissingExcluded[15];

    BYTE rgbMissing[3] = {2, 1, 1};        // INTEGER
    CERT_OTHER_NAME MissingOtherName =
        {"1.2.3.4.5.6", sizeof(rgbMissing), rgbMissing};

    BYTE rgbEmpty[2] = {5, 0};        // NULL
    CERT_OTHER_NAME AnyOctetOtherName =
        {OCTET_OTHER_NAME_OID, sizeof(rgbEmpty), rgbEmpty};
    CERT_OTHER_NAME AnyStringOtherName =
        {STRING_OTHER_NAME_OID, sizeof(rgbEmpty), rgbEmpty};

    CERT_NAME_VALUE NameValue;
    CERT_OTHER_NAME PermittedUPNOtherName;
    BYTE *pbPermittedUPNNameEncoded = NULL;
    DWORD cbPermittedUPNNameEncoded;

    CERT_OTHER_NAME ExcludedUPNOtherName;
    BYTE *pbExcludedUPNNameEncoded = NULL;
    DWORD cbExcludedUPNNameEncoded;

    CERT_OTHER_NAME AnyUPNOtherName;
    BYTE *pbAnyUPNNameEncoded = NULL;
    DWORD cbAnyUPNNameEncoded;

    CERT_OTHER_NAME PermittedStringOtherName;
    BYTE *pbPermittedStringOtherNameEncoded = NULL;
    DWORD cbPermittedStringOtherNameEncoded;

    CERT_OTHER_NAME ExcludedStringOtherName;
    BYTE *pbExcludedStringOtherNameEncoded = NULL;
    DWORD cbExcludedStringOtherNameEncoded;

    BYTE rgbDefaultIPAddress[] = {1,1,0,0, 255,255,0,0};
    BYTE rgbAllExtIPAddress[] = {
        1,    2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,  16,
        255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0xF0};
    BYTE rgbExcludedIPAddress[] = {2,2,2,2, 255,254,254,254};

    CERT_RDN rgRDN[3];
    CERT_RDN_ATTR rgAttr[3];
    CERT_NAME_INFO NameInfo;
    BYTE *pbPermittedNameEncoded = NULL;
    DWORD cbPermittedNameEncoded;
    BYTE *pbExcludedNameEncoded = NULL;
    DWORD cbExcludedNameEncoded;
    BYTE *pbAnyOUNameEncoded = NULL;
    DWORD cbAnyOUNameEncoded;
    BYTE *pbAnyNameEncoded = NULL;
    DWORD cbAnyNameEncoded;
    LPSTR pszSign = "\n sign \r";

    DWORD i;

    NameValue.dwValueType = CERT_RDN_BMP_STRING;
    NameValue.Value.pbData = (BYTE *) L"  @UPN.COM   ";
    NameValue.Value.cbData = 0;
    if (!AllocAndEncodeObject(
            X509_UNICODE_ANY_STRING,
            &NameValue,
            &pbPermittedUPNNameEncoded,
            &cbPermittedUPNNameEncoded))
        goto ErrorReturn;

    PermittedUPNOtherName.pszObjId = szOID_NT_PRINCIPAL_NAME;
    PermittedUPNOtherName.Value.pbData = pbPermittedUPNNameEncoded;
    PermittedUPNOtherName.Value.cbData = cbPermittedUPNNameEncoded;

    NameValue.dwValueType = CERT_RDN_UNIVERSAL_STRING;
    NameValue.Value.pbData = (BYTE *) L"  excluded@UPN.com  ";
    NameValue.Value.cbData = 0;
    if (!AllocAndEncodeObject(
            X509_UNICODE_ANY_STRING,
            &NameValue,
            &pbExcludedUPNNameEncoded,
            &cbExcludedUPNNameEncoded))
        goto ErrorReturn;

    ExcludedUPNOtherName.pszObjId = szOID_NT_PRINCIPAL_NAME;
    ExcludedUPNOtherName.Value.pbData = pbExcludedUPNNameEncoded;
    ExcludedUPNOtherName.Value.cbData = cbExcludedUPNNameEncoded;

    NameValue.dwValueType = CERT_RDN_PRINTABLE_STRING;
    NameValue.Value.pbData = (BYTE *) L"";
    NameValue.Value.cbData = 0;
    if (!AllocAndEncodeObject(
            X509_UNICODE_ANY_STRING,
            &NameValue,
            &pbAnyUPNNameEncoded,
            &cbAnyUPNNameEncoded))
        goto ErrorReturn;

    AnyUPNOtherName.pszObjId = szOID_NT_PRINCIPAL_NAME;
    AnyUPNOtherName.Value.pbData = pbAnyUPNNameEncoded;
    AnyUPNOtherName.Value.cbData = cbAnyUPNNameEncoded;

    NameValue.dwValueType = CERT_RDN_VISIBLE_STRING;
    NameValue.Value.pbData = (BYTE *) L"  String@OtherName   ";
    NameValue.Value.cbData = 0;
    if (!AllocAndEncodeObject(
            X509_UNICODE_ANY_STRING,
            &NameValue,
            &pbPermittedStringOtherNameEncoded,
            &cbPermittedStringOtherNameEncoded))
        goto ErrorReturn;

    PermittedStringOtherName.pszObjId = STRING_OTHER_NAME_OID;
    PermittedStringOtherName.Value.pbData = pbPermittedStringOtherNameEncoded;
    PermittedStringOtherName.Value.cbData = cbPermittedStringOtherNameEncoded;

    NameValue.dwValueType = CERT_RDN_GRAPHIC_STRING;
    NameValue.Value.pbData = (BYTE *) L"  excludedString@OtherName  ";
    NameValue.Value.cbData = 0;
    if (!AllocAndEncodeObject(
            X509_UNICODE_ANY_STRING,
            &NameValue,
            &pbExcludedStringOtherNameEncoded,
            &cbExcludedStringOtherNameEncoded))
        goto ErrorReturn;

    ExcludedStringOtherName.pszObjId = STRING_OTHER_NAME_OID;
    ExcludedStringOtherName.Value.pbData = pbExcludedStringOtherNameEncoded;
    ExcludedStringOtherName.Value.cbData = cbExcludedStringOtherNameEncoded;


    for (i = 0; i < 3; i++) {
        rgRDN[i].cRDNAttr = 1;
        rgRDN[i].rgRDNAttr = &rgAttr[i];
    }

    // Any
    rgAttr[0].pszObjId = ATTR_0_OBJID;
    rgAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
    rgAttr[0].Value.pbData = NULL;
    rgAttr[0].Value.cbData = 0;

    rgAttr[1].pszObjId = ATTR_1_OBJID;
    rgAttr[1].dwValueType = CERT_RDN_PRINTABLE_STRING;
    rgAttr[1].Value.pbData = (BYTE *) pszSign;
    rgAttr[1].Value.cbData = strlen(pszSign);

    rgAttr[2].pszObjId = ATTR_2_OBJID;
    rgAttr[2].dwValueType = CERT_RDN_PRINTABLE_STRING;
    rgAttr[2].Value.pbData = (BYTE *) "default";
    rgAttr[2].Value.cbData = strlen("default");

    NameInfo.cRDN = 3;
    NameInfo.rgRDN = rgRDN;

    if (!AllocAndEncodeObject(
            X509_NAME,
            &NameInfo,
            &pbPermittedNameEncoded,
            &cbPermittedNameEncoded
            ))
        goto ErrorReturn;

    rgAttr[0].pszObjId = ATTR_0_OBJID;
    rgAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
    rgAttr[0].Value.pbData = (BYTE *) "excluded";
    rgAttr[0].Value.cbData = strlen("excluded");
    NameInfo.cRDN = 1;
    NameInfo.rgRDN = rgRDN;

    if (!AllocAndEncodeObject(
            X509_NAME,
            &NameInfo,
            &pbExcludedNameEncoded,
            &cbExcludedNameEncoded
            ))
        goto ErrorReturn;

    rgAttr[0].pszObjId = szOID_ORGANIZATIONAL_UNIT_NAME;
    rgAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
    rgAttr[0].Value.pbData = NULL;
    rgAttr[0].Value.cbData = 0;
    NameInfo.cRDN = 1;
    NameInfo.rgRDN = rgRDN;

    if (!AllocAndEncodeObject(
            X509_NAME,
            &NameInfo,
            &pbAnyOUNameEncoded,
            &cbAnyOUNameEncoded
            ))
        goto ErrorReturn;

    NameInfo.cRDN = 0;
    NameInfo.rgRDN = rgRDN;

    if (!AllocAndEncodeObject(
            X509_NAME,
            &NameInfo,
            &pbAnyNameEncoded,
            &cbAnyNameEncoded
            ))
        goto ErrorReturn;

    memset(&rgRootPermitted, 0, sizeof(rgRootPermitted));
    rgRootPermitted[0].Base.dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
    rgRootPermitted[0].Base.pwszDNSName = L"dns Name  ";
    rgRootPermitted[1].Base.dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgRootPermitted[1].Base.pwszRfc822Name = L"  eMail.COM";
    rgRootPermitted[2].Base.dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
    rgRootPermitted[2].Base.pwszDNSName = L" kevin  ";
    rgRootPermitted[3].Base.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgRootPermitted[3].Base.pwszURL = L".url.com";
    rgRootPermitted[4].Base.dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
    rgRootPermitted[4].Base.pOtherName = &PermittedUPNOtherName;

    rgRootPermitted[5].Base.dwAltNameChoice = CERT_ALT_NAME_IP_ADDRESS;
    rgRootPermitted[5].Base.IPAddress.pbData = rgbDefaultIPAddress;
    rgRootPermitted[5].Base.IPAddress.cbData = sizeof(rgbDefaultIPAddress);
    rgRootPermitted[6].Base.dwAltNameChoice = CERT_ALT_NAME_IP_ADDRESS;
    rgRootPermitted[6].Base.IPAddress.pbData = rgbAllExtIPAddress;
    rgRootPermitted[6].Base.IPAddress.cbData = sizeof(rgbAllExtIPAddress);

    rgRootPermitted[7].Base.dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgRootPermitted[7].Base.pwszRfc822Name = L" MyEmail@WhereEver.com  ";

    rgRootPermitted[8].Base.dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
    rgRootPermitted[8].Base.DirectoryName.pbData = pbPermittedNameEncoded;
    rgRootPermitted[8].Base.DirectoryName.cbData = cbPermittedNameEncoded;
    rgRootPermitted[9].Base.dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
    rgRootPermitted[9].Base.DirectoryName.pbData = pbAnyOUNameEncoded;
    rgRootPermitted[9].Base.DirectoryName.cbData = cbAnyOUNameEncoded;

    rgRootPermitted[10].Base.dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
    rgRootPermitted[10].Base.pOtherName = &PermittedStringOtherName;
    rgRootPermitted[11].Base.dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
    rgRootPermitted[11].Base.pOtherName = &AnyOctetOtherName;

    rgRootPermitted[12].Base.dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgRootPermitted[12].Base.pwszRfc822Name = L"Cool@email.not";


    memset(&rgRootExcluded, 0, sizeof(rgRootExcluded));
    rgRootExcluded[0].Base.dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
    rgRootExcluded[0].Base.pwszDNSName = L"www.ExcLuDed.dns.com  ";
    rgRootExcluded[1].Base.dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgRootExcluded[1].Base.pwszRfc822Name = L"Excluded@email.com";
    rgRootExcluded[2].Base.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgRootExcluded[2].Base.pwszURL = L"excluded.url.com";
    rgRootExcluded[3].Base.dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
    rgRootExcluded[3].Base.pOtherName = &ExcludedUPNOtherName;

    rgRootExcluded[4].Base.dwAltNameChoice = CERT_ALT_NAME_IP_ADDRESS;
    rgRootExcluded[4].Base.IPAddress.pbData = rgbExcludedIPAddress;
    rgRootExcluded[4].Base.IPAddress.cbData = sizeof(rgbExcludedIPAddress);

    rgRootExcluded[5].Base.dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
    rgRootExcluded[5].Base.DirectoryName.pbData = pbExcludedNameEncoded;
    rgRootExcluded[5].Base.DirectoryName.cbData = cbExcludedNameEncoded;

    rgRootExcluded[6].Base.dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
    rgRootExcluded[6].Base.pOtherName = &ExcludedStringOtherName;


    memset(&RootInfo, 0, sizeof(RootInfo));
    RootInfo.cPermittedSubtree = 13;
    RootInfo.rgPermittedSubtree = rgRootPermitted;
    RootInfo.cExcludedSubtree = 7;
    RootInfo.rgExcludedSubtree = rgRootExcluded;


    memset(&rgCaPermitted, 0, sizeof(rgCaPermitted));
    rgCaPermitted[0].Base.dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
    rgCaPermitted[0].Base.pwszDNSName = L"";
    rgCaPermitted[1].Base.dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgCaPermitted[1].Base.pwszRfc822Name = L"";
    rgCaPermitted[2].Base.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgCaPermitted[2].Base.pwszURL = L"";
    rgCaPermitted[3].Base.dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
    rgCaPermitted[3].Base.pOtherName = &AnyUPNOtherName;
    rgCaPermitted[4].Base.dwAltNameChoice = CERT_ALT_NAME_IP_ADDRESS;
    rgCaPermitted[4].Base.IPAddress.pbData = NULL;
    rgCaPermitted[4].Base.IPAddress.cbData = 0;
    rgCaPermitted[5].Base.dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
    rgCaPermitted[5].Base.DirectoryName.pbData = pbAnyNameEncoded;
    rgCaPermitted[5].Base.DirectoryName.cbData = cbAnyNameEncoded;

    rgCaPermitted[6].Base.dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
    rgCaPermitted[6].Base.pOtherName = &AnyOctetOtherName;
    rgCaPermitted[7].Base.dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
    rgCaPermitted[7].Base.pOtherName = &AnyStringOtherName;


    memset(&CaInfo, 0, sizeof(CaInfo));
    CaInfo.cPermittedSubtree = 8;
    CaInfo.rgPermittedSubtree = rgCaPermitted;
    CaInfo.cExcludedSubtree = 0;
    CaInfo.rgExcludedSubtree = NULL;

    memset(&rgMissingPermitted, 0, sizeof(rgMissingPermitted));
    rgMissingPermitted[0].Base.dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
    rgMissingPermitted[0].Base.pwszDNSName = L"a super dns Name  ";
    rgMissingPermitted[0].dwMinimum = 1;
    rgMissingPermitted[1].Base.dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
    rgMissingPermitted[1].Base.pOtherName = &MissingOtherName;

    memset(&rgMissingExcluded, 0, sizeof(rgMissingExcluded));
    rgMissingExcluded[0].Base.dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
    rgMissingExcluded[0].Base.pwszDNSName = L"www.ReallyExcLuDed.dns.com  ";
    rgMissingExcluded[1].Base.dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
    rgMissingExcluded[1].Base.pwszDNSName = L"www.ExcLuDed.dns.com  ";
    rgMissingExcluded[1].fMaximum = TRUE;
    rgMissingExcluded[1].dwMaximum = 2;
    rgMissingExcluded[2].Base.dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
    rgMissingExcluded[2].Base.pOtherName = &MissingOtherName;

    memset(&MissingInfo, 0, sizeof(MissingInfo));
    MissingInfo.cPermittedSubtree = 2;
    MissingInfo.rgPermittedSubtree = rgMissingPermitted;
    MissingInfo.cExcludedSubtree = 3;
    MissingInfo.rgExcludedSubtree = rgMissingExcluded;

    if (dwCert == POLICY_ROOT)
        pInfo = &RootInfo;
    else if (dwCert == POLICY_CA)
        pInfo = &CaInfo;
    else if (0 == strcmp(CertPara[dwCert].pszName, "MissingNCCA"))
        pInfo = &MissingInfo;
    else
        goto ErrorReturn;

    if (!AllocAndEncodeObject(
            X509_NAME_CONSTRAINTS,
            pInfo,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    TestFree(pbPermittedUPNNameEncoded);
    TestFree(pbExcludedUPNNameEncoded);
    TestFree(pbAnyUPNNameEncoded);
    TestFree(pbPermittedNameEncoded);
    TestFree(pbExcludedNameEncoded);
    TestFree(pbPermittedStringOtherNameEncoded);
    TestFree(pbExcludedStringOtherNameEncoded);
    TestFree(pbAnyOUNameEncoded);
    TestFree(pbAnyNameEncoded);

    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreatePolicyMappings(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCERT_POLICY_MAPPINGS_INFO pInfo;

    CERT_POLICY_MAPPING rgRootPolicyMapping[] = {
        "1.1.22", "1.2.22.1",
        "1.1.22", "1.2.22.2",       // multiple subjects may map to same issuer
        "1.1.4444", "1.2.4444",
        "1.1.4444", "1.1.4444",     // multiple subjects for same issuer
        "1.1.22.333", "1.2.22.1",   // duplicate subject
        "1.1.22", "1.2.22.3",
        "1.1.333", "1.2.333.1",
        "1.1.333", "1.2.333.2",
        "1.1.333", "1.2.333.3",
        "1.1.22", "1.2.22.3",       // multiple subjects for same issuer
        "1.1.22", "1.2.22.3",       // duplicate subject
        "1.1.22", "1.2.22.4",       // multiple subjects for same issuer
    };
    CERT_POLICY_MAPPINGS_INFO RootInfo = {
        sizeof(rgRootPolicyMapping) / sizeof(rgRootPolicyMapping[0]),
        rgRootPolicyMapping
    };

    CERT_POLICY_MAPPING rgCaPolicyMapping[] = {
        "1.1.1", "1.3.1.1",
        "1.1.1", "1.3.1.2",
        "1.2.22.2", "1.3.22.2.1",   // -> 1.1.22
        "1.2.22.2", "1.3.22.2.2",   // -> 1.1.22
    };
    CERT_POLICY_MAPPINGS_INFO CaInfo = {
        sizeof(rgCaPolicyMapping) / sizeof(rgCaPolicyMapping[0]),
        rgCaPolicyMapping
    };

    if (dwCert == POLICY_ROOT)
        pInfo = &RootInfo;
    else if (dwCert == POLICY_CA)
        pInfo = &CaInfo;
    else
        goto ErrorReturn;

    if (!AllocAndEncodeObject(
            X509_POLICY_MAPPINGS,
            pInfo,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}


static BOOL CreatePolicyConstraints(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCERT_POLICY_CONSTRAINTS_INFO pInfo;

    CERT_POLICY_CONSTRAINTS_INFO RootInfo = {
        TRUE,       // fRequireExplicitPolicy
        1,          // dwRequireExplicitPolicySkipCerts
        TRUE,       // fInhibitPolicyMapping
        1           // dwInhibitPolicyMappingSkipCerts
    };

    CERT_POLICY_CONSTRAINTS_INFO CaInfo = {
        TRUE,       // fRequireExplicitPolicy
        0,          // dwRequireExplicitPolicySkipCerts
        TRUE,       // fInhibitPolicyMapping
        0           // dwInhibitPolicyMappingSkipCerts
    };

    if (dwCert == POLICY_ROOT)
        pInfo = &RootInfo;
    else if (dwCert == POLICY_CA)
        pInfo = &CaInfo;
    else if (dwCert == ROLLOVER_CROSS_CERT) {
        CaInfo.dwRequireExplicitPolicySkipCerts = 2;
        pInfo = &CaInfo;
    } else
        goto ErrorReturn;
        
    if (!AllocAndEncodeObject(
            X509_POLICY_CONSTRAINTS,
            pInfo,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateCrossCertDistPoints(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CROSS_CERT_DIST_POINTS_INFO Info;
    CERT_ALT_NAME_INFO rgDistPoint[2];
    CERT_ALT_NAME_ENTRY rgAltNameEntry[3];

    rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[0].pwszURL = L"file://vsgood.cer";
    rgAltNameEntry[1].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[1].pwszURL = L"file://nt.store";
    rgAltNameEntry[2].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[2].pwszURL = L"file://win95.store";

    rgDistPoint[0].cAltEntry = 1;
    rgDistPoint[0].rgAltEntry = &rgAltNameEntry[0];
    rgDistPoint[1].cAltEntry = 2;
    rgDistPoint[1].rgAltEntry = &rgAltNameEntry[1];

    memset(&Info, 0, sizeof(Info));
    Info.dwSyncDeltaTime = 60 * 60 * 8;
    Info.cDistPoint = 2;
    Info.rgDistPoint = rgDistPoint;

    if (!AllocAndEncodeObject(
            X509_CROSS_CERT_DIST_POINTS,
            &Info,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateKeyId(
        DWORD dwIssuer,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BYTE rgbPubKeyHash[SHA1_HASH_LEN];
    CRYPT_DATA_BLOB KeyIdentifier;

    Sha1HashPublicKey(dwIssuer, rgbPubKeyHash);

    KeyIdentifier.pbData = rgbPubKeyHash;
    KeyIdentifier.cbData = sizeof(rgbPubKeyHash);

    return AllocAndEncodeObject(
        X509_OCTET_STRING,
        &KeyIdentifier,
        ppbEncoded,
        pcbEncoded
        );
}

static BOOL CreateKeyAttributes(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_KEY_ATTRIBUTES_INFO KeyAttrInfo;
    CERT_PRIVATE_KEY_VALIDITY KeyValidity;

    BYTE bIntendedKeyUsage;

    memset(&KeyAttrInfo, 0, sizeof(KeyAttrInfo));

    if (CertPara[dwCert].dwFlags & CA_PARA_FLAG) {
        // Issuer's KeyId
        KeyAttrInfo.KeyId.pbData = (BYTE *) &dwCert;
        KeyAttrInfo.KeyId.cbData = sizeof(dwCert);
    }

    if (CertPara[dwCert].dwFlags & XCHG_PARA_FLAG)
        bIntendedKeyUsage = CERT_KEY_ENCIPHERMENT_KEY_USAGE |
            CERT_DATA_ENCIPHERMENT_KEY_USAGE | CERT_KEY_AGREEMENT_KEY_USAGE;
    else
        bIntendedKeyUsage =
            CERT_DIGITAL_SIGNATURE_KEY_USAGE | CERT_NON_REPUDIATION_KEY_USAGE;
    if (CertPara[dwCert].dwFlags & CA_PARA_FLAG)
        bIntendedKeyUsage |= CERT_KEY_CERT_SIGN_KEY_USAGE;

    KeyAttrInfo.IntendedKeyUsage.pbData = &bIntendedKeyUsage;
    KeyAttrInfo.IntendedKeyUsage.cbData = 1;
    KeyAttrInfo.IntendedKeyUsage.cUnusedBits = 1;

    {
        SYSTEMTIME SystemTime = TestTime;

        SystemTime.wMilliseconds = 123;
        MySystemTimeToFileTime(&SystemTime, &KeyValidity.NotBefore);
        SystemTime.wYear += 2;
        SystemTime.wMilliseconds = 456;

        MySystemTimeToFileTime(&SystemTime, &KeyValidity.NotAfter);
    }
    KeyAttrInfo.pPrivateKeyUsagePeriod = &KeyValidity;

    if (!AllocAndEncodeObject(
            X509_KEY_ATTRIBUTES,
            &KeyAttrInfo,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateKeyUsageRestriction(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_KEY_USAGE_RESTRICTION_INFO KeyUsageInfo;
    BYTE bRestrictedKeyUsage;

    LPSTR rgpszCertPolicyElementId[4] = {
        "1.2.333.1",
        "1.2.333.22",
        "1.2.333.333",
        "1.2.333.4444"
    };
    CERT_POLICY_ID rgCertPolicyId[3] = {
        0, NULL,
        1, rgpszCertPolicyElementId,
        4, rgpszCertPolicyElementId
    };

    LPSTR rgpszSpcCertPolicyElementId[2] = {
        SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID,
        SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID
    };
    CERT_POLICY_ID rgSpcCertPolicyId[2] = {
        1, &rgpszSpcCertPolicyElementId[0],
        1, &rgpszSpcCertPolicyElementId[1]
    };

    memset(&KeyUsageInfo, 0, sizeof(KeyUsageInfo));

    if (CertPara[dwCert].dwFlags & XCHG_PARA_FLAG)
        bRestrictedKeyUsage = CERT_KEY_ENCIPHERMENT_KEY_USAGE |
            CERT_DATA_ENCIPHERMENT_KEY_USAGE | CERT_KEY_AGREEMENT_KEY_USAGE;
    else
        bRestrictedKeyUsage =
            CERT_DIGITAL_SIGNATURE_KEY_USAGE | CERT_NON_REPUDIATION_KEY_USAGE;
    if (CertPara[dwCert].dwFlags & CA_PARA_FLAG)
        bRestrictedKeyUsage |= CERT_KEY_CERT_SIGN_KEY_USAGE;

    KeyUsageInfo.RestrictedKeyUsage.pbData = &bRestrictedKeyUsage;
    KeyUsageInfo.RestrictedKeyUsage.cbData = 1;
    KeyUsageInfo.RestrictedKeyUsage.cUnusedBits = 1;

    if (CertPara[dwCert].dwFlags & SPC_AGENCY_PARA_FLAG) {
        KeyUsageInfo.cCertPolicyId = 2;
        KeyUsageInfo.rgCertPolicyId = rgSpcCertPolicyId;
    } else if (CertPara[dwCert].dwFlags & SPC_COM_PARA_FLAG) {
        KeyUsageInfo.cCertPolicyId = 1;
        KeyUsageInfo.rgCertPolicyId = &rgSpcCertPolicyId[1];
    } else if (CertPara[dwCert].dwFlags & SPC_EXT_PARA_FLAG) {
        KeyUsageInfo.cCertPolicyId = 1;
        KeyUsageInfo.rgCertPolicyId = &rgSpcCertPolicyId[0];
    } else if (CertPara[dwCert].dwFlags & ALL_EXT_PARA_FLAG) {
        KeyUsageInfo.cCertPolicyId = 3;
        KeyUsageInfo.rgCertPolicyId = rgCertPolicyId;
    }


    if (!AllocAndEncodeObject(
            X509_KEY_USAGE_RESTRICTION,
            &KeyUsageInfo,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateBasicConstraints(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbSubtreesEncoded = NULL;
    DWORD cbSubtreesEncoded;
    CERT_NAME_BLOB rgSubtreesConstraint[2];

    CERT_BASIC_CONSTRAINTS_INFO BasicConstraintsInfo;
    BYTE bSubjectType;

    memset(&BasicConstraintsInfo, 0, sizeof(BasicConstraintsInfo));

    if (CertPara[dwCert].dwFlags & CA_PARA_FLAG) {
        bSubjectType = CERT_CA_SUBJECT_FLAG;
        BasicConstraintsInfo.fPathLenConstraint = TRUE;
        BasicConstraintsInfo.dwPathLenConstraint = dwCert + 1;
    } else
        bSubjectType = CERT_END_ENTITY_SUBJECT_FLAG;
    BasicConstraintsInfo.SubjectType.pbData = &bSubjectType;
    BasicConstraintsInfo.SubjectType.cbData = 1;
    BasicConstraintsInfo.SubjectType.cUnusedBits = 6;

    if (CertPara[dwCert].dwFlags & ALL_EXT_PARA_FLAG) {
        CERT_RDN rgRDN[RDN_CNT];
        CERT_RDN_ATTR rgAttr[ATTR_CNT];
        CERT_NAME_INFO Name;

        CreateNameInfo(dwCert, &Name, rgRDN, rgAttr);
        cbSubtreesEncoded = 0;

        if (!AllocAndEncodeObject(
                X509_NAME,
                &Name,
                &pbSubtreesEncoded,
                &cbSubtreesEncoded
                ))
            goto ErrorReturn;

        BasicConstraintsInfo.cSubtreesConstraint = 2;
        BasicConstraintsInfo.rgSubtreesConstraint = rgSubtreesConstraint;
        rgSubtreesConstraint[0].pbData = pbSubtreesEncoded;
        rgSubtreesConstraint[0].cbData = cbSubtreesEncoded;
        rgSubtreesConstraint[1].pbData = pbSubtreesEncoded;
        rgSubtreesConstraint[1].cbData = cbSubtreesEncoded;
    }

    if (!AllocAndEncodeObject(
            X509_BASIC_CONSTRAINTS,
            &BasicConstraintsInfo,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbSubtreesEncoded)
        TestFree(pbSubtreesEncoded);
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateKeyUsage(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CRYPT_BIT_BLOB KeyUsageInfo;
    BYTE bKeyUsage;

    memset(&KeyUsageInfo, 0, sizeof(KeyUsageInfo));

    if (CertPara[dwCert].dwFlags & XCHG_PARA_FLAG)
        bKeyUsage = CERT_KEY_ENCIPHERMENT_KEY_USAGE |
            CERT_DATA_ENCIPHERMENT_KEY_USAGE | CERT_KEY_AGREEMENT_KEY_USAGE;
    else
        bKeyUsage =
            CERT_DIGITAL_SIGNATURE_KEY_USAGE | CERT_NON_REPUDIATION_KEY_USAGE;
    if (0 == strcmp(CertPara[dwCert].pszName, "InvalidKeyUsageCA"))
        // No cert signing usage for this cert
        ;
    else if (CertPara[dwCert].dwFlags & CA_PARA_FLAG)
        bKeyUsage |= CERT_KEY_CERT_SIGN_KEY_USAGE;

    KeyUsageInfo.pbData = &bKeyUsage;
    KeyUsageInfo.cbData = 1;
    KeyUsageInfo.cUnusedBits = 1;

    if (!AllocAndEncodeObject(
            X509_KEY_USAGE,
            &KeyUsageInfo,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateBasicConstraints2(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    CERT_BASIC_CONSTRAINTS2_INFO BasicConstraints2Info;

    memset(&BasicConstraints2Info, 0, sizeof(BasicConstraints2Info));

    if (dwCert == POLICY_ROOT || dwCert == ROLLOVER_CROSS_CERT) {
        BasicConstraints2Info.fCA = TRUE;
        BasicConstraints2Info.fPathLenConstraint = TRUE;
        BasicConstraints2Info.dwPathLenConstraint = 1;
    } else if (dwCert == POLICY_CA) {
        BasicConstraints2Info.fCA = TRUE;
        BasicConstraints2Info.fPathLenConstraint = TRUE;
        BasicConstraints2Info.dwPathLenConstraint = 0;
    } else if (CertPara[dwCert].dwFlags & CA_PARA_FLAG) {
        BasicConstraints2Info.fCA = TRUE;
        BasicConstraints2Info.fPathLenConstraint = TRUE;
        if (0 == strcmp(CertPara[dwCert].pszName, "TestRoot"))
            BasicConstraints2Info.dwPathLenConstraint = 2;
        else
            BasicConstraints2Info.dwPathLenConstraint = dwCert + 1;
    } else
        BasicConstraints2Info.fCA = FALSE;

    if (!AllocAndEncodeObject(
            X509_BASIC_CONSTRAINTS2,
            &BasicConstraints2Info,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreatePolicies(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BYTE rgbQualifier2[] = {5, 0};                      // NULL
    BYTE rgbQualifier4[] = {4, 8, 1,2,3,4,5,6,7,8};     // Octet String

    CERT_POLICY_QUALIFIER_INFO rgQualifierInfo[4] = {
        "1.2.1", 0, NULL,
        "1.2.2", sizeof(rgbQualifier2), rgbQualifier2,
        "1.2.3", 0, NULL,
        "1.2.4", sizeof(rgbQualifier4), rgbQualifier4
    };

    // Root has the following policies:
    //  1.1.1
    //  1.1.55555
    //  1.1.22
    //  1.1.333
    //  1.1.4444
    CERT_POLICY_INFO rgRootPolicyInfo[] = {
        "1.1.1", 0, NULL,
        "1.1.55555", 0, NULL,
        "1.1.22", 2, rgQualifierInfo,
        "1.1.333", 2, &rgQualifierInfo[2],
        "1.1.333", 0, NULL,                     // duplicate, should be removed
        "1.1.4444", 1, rgQualifierInfo,
        "1.1.4444", 0, NULL,                    // duplicate
        "1.1.1", 0, NULL,                       // duplicate
        "1.1.1", 0, NULL,                       // duplicate
    };

    // After mapping, the CA has the following policies:
    //  1.1.1
    //  1.1.22
    //  1.1.333
    //  1.1.4444
    CERT_POLICY_INFO rgCaPolicyInfo[] = {
        "1.2.22.1", 0, NULL,    // 1.1.22
        "1.2.22.2", 0, NULL,    // 1.1.22
        "1.2.22.3", 0, NULL,    // 1.1.22
        "1.2.333.1", 0, NULL,   // 1.1.333
        "1.2.333.2", 0, NULL,   // 1.1.333
        "1.2.4444", 0, NULL,    // 1.1.4444
        "1.1.4444", 0, NULL,    // 1.1.4444
        "1.1.1", 0, NULL,       // 1.1.1
        "1.2.333.3", 0, NULL,   // 1.1.333
        "1.2.55555", 0, NULL,   // no mapping
    };

    // After mapping, the cert has the following policies:
    //  1.1.1
    //  1.1.22
    CERT_POLICY_INFO rgPolicyInfo[] = {
        "1.1.55555", 0, NULL,       // no mapping via ca
        "1.3.22.2.1", 0, NULL,      // 1.2.22.2 -> 1.1.22
        "1.3.1.1", 0, NULL,         // 1.1.1
        "1.2.55555", 0, NULL,       // no mapping via root
    };

    // After mapping, the cert has the following policies:
    //  1.1.1
    //  1.1.22
    //  1.1.4444
    CERT_POLICY_INFO rgAllExtPolicyInfo[] = {
        "1.3.1.2", 0, NULL,         // 1.1.1
        "1.3.22.2.2", 0, NULL,      // 1.2.22.2 -> 1.1.22
        "1.1.55555", 0, NULL,       // no mapping via ca
        "1.2.55555", 0, NULL,       // not mapping via root
        "1.1.4444", 0, NULL,        // 1.1.4444
    };

    CERT_POLICY_INFO rgSpcPolicyInfo[2] = {
        SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID, 0, NULL,
        SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID, 0, NULL
    };

    CERT_POLICY_INFO rgDssCAPolicyInfo[] = {
        szOID_ANY_CERT_POLICY, 0, NULL,
    };

    CERT_POLICY_INFO rgDssEndPolicyInfo[] = {
        "1.1.4444", 0, NULL,
        "1.1.55555", 0, NULL,
    };

    CERT_POLICIES_INFO PoliciesInfo;
    memset(&PoliciesInfo, 0, sizeof(PoliciesInfo));

    if (0 == strcmp(CertPara[dwCert].pszName, "DssCA")) {
        PoliciesInfo.cPolicyInfo = sizeof(rgDssCAPolicyInfo) /
            sizeof(rgDssCAPolicyInfo[0]);
        PoliciesInfo.rgPolicyInfo = rgDssCAPolicyInfo;
    } else if (0 == strcmp(CertPara[dwCert].pszName, "DssEnd")) {
        PoliciesInfo.cPolicyInfo = sizeof(rgDssEndPolicyInfo) /
            sizeof(rgDssEndPolicyInfo[0]);
        PoliciesInfo.rgPolicyInfo = rgDssEndPolicyInfo;
    } else if (POLICY_ROOT == dwCert) {
        PoliciesInfo.cPolicyInfo = sizeof(rgRootPolicyInfo) /
            sizeof(rgRootPolicyInfo[0]);
        PoliciesInfo.rgPolicyInfo = rgRootPolicyInfo;
    } else if (POLICY_CA == dwCert) {
        PoliciesInfo.cPolicyInfo = sizeof(rgCaPolicyInfo) /
            sizeof(rgCaPolicyInfo[0]);
        PoliciesInfo.rgPolicyInfo = rgCaPolicyInfo;
    } else if (CertPara[dwCert].dwFlags & SPC_AGENCY_PARA_FLAG) {
        PoliciesInfo.cPolicyInfo = 2;
        PoliciesInfo.rgPolicyInfo = rgSpcPolicyInfo;
    } else if (CertPara[dwCert].dwFlags & SPC_COM_PARA_FLAG) {
        PoliciesInfo.cPolicyInfo = 1;
        PoliciesInfo.rgPolicyInfo = &rgSpcPolicyInfo[1];
    } else if (CertPara[dwCert].dwFlags & SPC_EXT_PARA_FLAG) {
        PoliciesInfo.cPolicyInfo = 1;
        PoliciesInfo.rgPolicyInfo = &rgSpcPolicyInfo[0];
    } else if (CertPara[dwCert].dwFlags & ALL_EXT_PARA_FLAG) {
        PoliciesInfo.cPolicyInfo = sizeof(rgAllExtPolicyInfo) /
            sizeof(rgAllExtPolicyInfo[0]);
        PoliciesInfo.rgPolicyInfo = rgAllExtPolicyInfo;
    } else {
        PoliciesInfo.cPolicyInfo = sizeof(rgPolicyInfo) /
            sizeof(rgPolicyInfo[0]);
        PoliciesInfo.rgPolicyInfo = rgPolicyInfo;
    }

    return AllocAndEncodeObject(
            X509_CERT_POLICIES,
            &PoliciesInfo,
            ppbEncoded,
            pcbEncoded);
}

static BOOL CreateSMIMECapabilities(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BYTE rgb128BitLen[] = {2, 2, 0, 128};   // Integer
    BYTE rgb40BitLen[] = {2, 1, 40};        // Integer

    CRYPT_SMIME_CAPABILITY rgCapability[4] = {
        szOID_RSA_DES_EDE3_CBC, 0, NULL,
        szOID_RSA_RC2CBC, sizeof(rgb128BitLen), rgb128BitLen,
        szOID_RSA_RC2CBC, sizeof(rgb40BitLen), rgb40BitLen,
        szOID_RSA_preferSignedData, 0, NULL
    };

    CRYPT_SMIME_CAPABILITIES Capabilities = {
        sizeof(rgCapability)/sizeof(rgCapability[0]), rgCapability
    };

    return AllocAndEncodeObject(
            PKCS_SMIME_CAPABILITIES,
            &Capabilities,
            ppbEncoded,
            pcbEncoded);
}


static BOOL CreateAltName(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_ALT_NAME_INFO AltNameInfo;
#define ALT_NAME_ENTRY_CNT  15
    CERT_ALT_NAME_ENTRY rgAltNameEntry[ALT_NAME_ENTRY_CNT];
    DWORD i;

    BYTE *pbNameEncoded = NULL;
    DWORD cbNameEncoded;

    CERT_OTHER_NAME UPNOtherName;
    BYTE *pbUPNNameEncoded = NULL;
    DWORD cbUPNNameEncoded;

    CERT_OTHER_NAME StringOtherName;
    BYTE *pbStringOtherNameEncoded = NULL;
    DWORD cbStringOtherNameEncoded;
    DWORD dwStringOtherNameValueType = CERT_RDN_UTF8_STRING;

    LPWSTR pwszEmail = NULL;
    LPWSTR pwszUrl = NULL;
    LPWSTR pwszUPN = NULL;
    LPWSTR pwszStringOtherName = NULL;
    LPWSTR pwszDns = NULL;

    BYTE rgbOctetOtherName[] = {0x04, 0x02, 0x11, 0x22};
    CERT_OTHER_NAME OctetOtherName;
    PCERT_OTHER_NAME pOctetOtherName = NULL;

    LPSTR pszRegisteredID = NULL;

    BYTE rgbDefaultIPAddress[] = {1,1,0,0};
    BYTE rgbAllExtIPAddress[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17};
    BYTE rgbExcludedIPAddress[] = {2,2,3,3};
    BYTE rgbNotPermittedIPAddress[] = {3,3,3,3};
    BYTE *pbIPAddress = NULL;
    DWORD cbIPAddress = 0;

    if (CertPara[dwCert].dwFlags &
            (NO_NAME_PARA_FLAG | ALT_DIR_NAME_PARA_FLAG)) {
        pwszEmail = L"Name@email.com";
    }

    if (CertPara[dwCert].dwFlags & ALL_EXT_PARA_FLAG) {
        pwszEmail = L"   AllExt@email.com    ";
        pwszUrl = L" http://www.AllExt.url.com:388/more url stuff";
        pwszDns = L"DNS name";
        pwszUPN = L"AllExt@UPN.com";
        pwszStringOtherName = L"AllExtString@OtherName";
        dwStringOtherNameValueType = CERT_RDN_TELETEX_STRING;
        pbIPAddress = rgbAllExtIPAddress;
        cbIPAddress = sizeof(rgbAllExtIPAddress);
    } else if (0 == strcmp(CertPara[dwCert].pszName, "Excluded")) {
        pwszEmail = L" Excluded@email.com  ";
        pwszUrl = L" http://Excluded.url.com/more url stuff";
        pwszDns = L"www.excluded.dns.com";
        pwszUPN = L"excluded@UPN.com";
        pwszStringOtherName = L"ExcludedString@OtherName";
        dwStringOtherNameValueType = CERT_RDN_IA5_STRING;
        pbIPAddress = rgbExcludedIPAddress;
        cbIPAddress = sizeof(rgbExcludedIPAddress);
    } else if (0 == strcmp(CertPara[dwCert].pszName, "NotPermitted")) {
        pwszEmail = L"JoeCool@email.not"; 
        pwszUrl = L"http://www.url.not/more url stuff";
        pwszDns = L"www.excluded.dns.not";
        pwszUPN = L"notpermitted@UPN.not";
        pwszStringOtherName = L"String@OtherNameNot";
        dwStringOtherNameValueType = CERT_RDN_GENERAL_STRING;
        pbIPAddress = rgbNotPermittedIPAddress;
        cbIPAddress = sizeof(rgbNotPermittedIPAddress);

        OctetOtherName.pszObjId = OCTET_OTHER_NAME_OID;
        OctetOtherName.Value.pbData = rgbOctetOtherName;
        OctetOtherName.Value.cbData = sizeof(rgbOctetOtherName);
        pOctetOtherName = &OctetOtherName;

        pszRegisteredID = "1.2.3.4.5.6.7";
    } else {
        pwszUPN = L"    Default@UPN.com   ";
        pwszStringOtherName = L"    DefaultString@OtherName   ";
        dwStringOtherNameValueType = CERT_RDN_UTF8_STRING;
        pbIPAddress = rgbDefaultIPAddress;
        cbIPAddress = sizeof(rgbDefaultIPAddress);
    }

    if (0 == strcmp(CertPara[dwCert].pszName, "MissingNCEnd")) {
        OctetOtherName.pszObjId = OCTET_OTHER_NAME_OID;
        OctetOtherName.Value.pbData = rgbOctetOtherName;
        OctetOtherName.Value.cbData = sizeof(rgbOctetOtherName);
        pOctetOtherName = &OctetOtherName;
    }


    i = 0;
    if (pwszEmail) {
        rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
        rgAltNameEntry[0].pwszRfc822Name = pwszEmail;
        i++;
    }

    if (pwszUPN) {
        CERT_NAME_VALUE UPNNameValue;

        UPNNameValue.dwValueType = CERT_RDN_UTF8_STRING;
        UPNNameValue.Value.pbData = (BYTE *) pwszUPN;
        UPNNameValue.Value.cbData = 0;
        if (!AllocAndEncodeObject(
                X509_UNICODE_ANY_STRING,
                &UPNNameValue,
                &pbUPNNameEncoded,
                &cbUPNNameEncoded))
            goto ErrorReturn;

        UPNOtherName.pszObjId = szOID_NT_PRINCIPAL_NAME;
        UPNOtherName.Value.pbData = pbUPNNameEncoded;
        UPNOtherName.Value.cbData = cbUPNNameEncoded;

        rgAltNameEntry[i].dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
        rgAltNameEntry[i].pOtherName = &UPNOtherName;
        i++;
    }

    if (pwszStringOtherName) {
        CERT_NAME_VALUE OtherNameValue;

        OtherNameValue.dwValueType = dwStringOtherNameValueType;
        OtherNameValue.Value.pbData = (BYTE *) pwszStringOtherName;
        OtherNameValue.Value.cbData = 0;
        if (!AllocAndEncodeObject(
                X509_UNICODE_ANY_STRING,
                &OtherNameValue,
                &pbStringOtherNameEncoded,
                &cbStringOtherNameEncoded))
            goto ErrorReturn;

        StringOtherName.pszObjId = STRING_OTHER_NAME_OID;
        StringOtherName.Value.pbData = pbStringOtherNameEncoded;
        StringOtherName.Value.cbData = cbStringOtherNameEncoded;

        rgAltNameEntry[i].dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
        rgAltNameEntry[i].pOtherName = &StringOtherName;
        i++;
    }

    if (pwszUrl) {
        rgAltNameEntry[i].dwAltNameChoice = CERT_ALT_NAME_URL;
        rgAltNameEntry[i].pwszURL = pwszUrl;
        i++;
    }

    if (pwszDns) {
        rgAltNameEntry[i].dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
        rgAltNameEntry[i].pwszDNSName = pwszDns;
        i++;
    }

    if (pszRegisteredID) {
        rgAltNameEntry[i].dwAltNameChoice = CERT_ALT_NAME_REGISTERED_ID;
        rgAltNameEntry[i].pszRegisteredID = pszRegisteredID;
        i++;
    }

    if (pbIPAddress && cbIPAddress) {
        rgAltNameEntry[i].dwAltNameChoice = CERT_ALT_NAME_IP_ADDRESS;
        rgAltNameEntry[i].IPAddress.pbData = pbIPAddress;
        rgAltNameEntry[i].IPAddress.cbData = cbIPAddress;
        i++;
    }

    if (pOctetOtherName) {
        rgAltNameEntry[i].dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
        rgAltNameEntry[i].pOtherName = pOctetOtherName;
        i++;
    }


    if (CertPara[dwCert].dwFlags & ALT_DIR_NAME_PARA_FLAG) {
        CERT_NAME_INFO NameInfo;
        CERT_RDN rgRDN[1];
        CERT_RDN_ATTR rgAttr[1];

        NameInfo.cRDN = 1;
        NameInfo.rgRDN = rgRDN;

        rgRDN[0].cRDNAttr = 1;
        rgRDN[0].rgRDNAttr = rgAttr;

        rgAttr[0].pszObjId = szOID_ORGANIZATIONAL_UNIT_NAME;
        rgAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
        rgAttr[0].Value.pbData = (BYTE *) CertPara[dwCert].pszName;
        rgAttr[0].Value.cbData = strlen(CertPara[dwCert].pszName);

        if (!AllocAndEncodeObject(
                X509_NAME,
                &NameInfo,
                &pbNameEncoded,
                &cbNameEncoded))
            goto ErrorReturn;

        rgAltNameEntry[i].dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
        rgAltNameEntry[i].DirectoryName.pbData = pbNameEncoded;
        rgAltNameEntry[i].DirectoryName.cbData = cbNameEncoded;
        i++;
    }

    AltNameInfo.cAltEntry = i;
    AltNameInfo.rgAltEntry = rgAltNameEntry;

    if (!AllocAndEncodeObject(
            X509_ALTERNATE_NAME,
            &AltNameInfo,
            &pbEncoded,
            &cbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    TestFree(pbNameEncoded);
    TestFree(pbUPNNameEncoded);
    TestFree(pbStringOtherNameEncoded);
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateSETAccountAlias(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    BOOL bInfo;

    if (CertPara[dwCert].dwFlags & ALL_EXT_PARA_FLAG)
        bInfo = TRUE;
    else
        bInfo = FALSE;


    if (!AllocAndEncodeObject(
            X509_SET_ACCOUNT_ALIAS,
            &bInfo,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateSETHashedRootKey(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    BYTE i;
    BYTE rgbInfo[SET_HASHED_ROOT_LEN];

    for (i = 0; i < SET_HASHED_ROOT_LEN; i++)
        rgbInfo[i] = i;

    if (!AllocAndEncodeObject(
            X509_SET_HASHED_ROOT_KEY,
            rgbInfo,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateSETCertificateType(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    CRYPT_BIT_BLOB Info;
    BYTE rgbType[2] = {0,0};

    if (dwCert < 8)
        rgbType[0] = 1 << (dwCert % 8);
    else
        rgbType[1] = 0x40 << (dwCert % 2);
    Info.pbData = rgbType;
    Info.cbData = 2;
    Info.cUnusedBits = 6;

    if (!AllocAndEncodeObject(
            X509_SET_CERTIFICATE_TYPE,
            &Info,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateSETMerchantData(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    SET_MERCHANT_DATA_INFO Info;

    memset(&Info, 0, sizeof(Info));
    if (CertPara[dwCert].dwFlags & ALL_EXT_PARA_FLAG) {
        Info.pszMerID = "ID";
        Info.pszMerAcquirerBIN = "0123456";
        Info.pszMerTermID = "TermID";
        Info.pszMerName = "Name";
        Info.pszMerCity = "City";
        Info.pszMerStateProvince = "StateProvince";
        Info.pszMerPostalCode = "PostalCode";
        Info.pszMerCountry = "Country/Region";
        Info.pszMerPhone = "Phone";
        Info.fMerPhoneRelease = TRUE;
        Info.fMerAuthFlag = TRUE;
    } else {
        Info.pszMerID = "";
        Info.pszMerAcquirerBIN = "";
        Info.pszMerTermID = "";
        Info.pszMerName = "";
        Info.pszMerCity = "";
        Info.pszMerStateProvince = "";
        Info.pszMerPostalCode = "";
        Info.pszMerCountry = "";
        Info.pszMerPhone = "";
        Info.fMerPhoneRelease = FALSE;
        Info.fMerAuthFlag = FALSE;
    }


    if (!AllocAndEncodeObject(
            X509_SET_MERCHANT_DATA,
            &Info,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateSpcSpAgency(
        DWORD dwCert,
        DWORD dwLevel,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    SPC_LINK UrlLink;
    SPC_LINK MonikerLink;
#define MONIKER_DATA "Moniker Serialized Data"
    SPC_LINK FileLink;
    SPC_IMAGE Image;
    SPC_SP_AGENCY_INFO AgencyInfo;

#define BIT_MAP "Bit Map"
#define META_FILE "Metafile"
#define ENHANCED_META_FILE "Enhanced Metafile"
#define GIF_FILE "Gif File"

    int i;

    UrlLink.dwLinkChoice = SPC_URL_LINK_CHOICE;
    UrlLink.pwszUrl = L"http://microsoft.com";

    MonikerLink.dwLinkChoice = SPC_MONIKER_LINK_CHOICE;
    for (i = 0; i < sizeof(MonikerLink.Moniker.ClassId); i++)
        MonikerLink.Moniker.ClassId[i] = (BYTE) (i + 1);
    MonikerLink.Moniker.SerializedData.cbData = strlen(MONIKER_DATA);
    MonikerLink.Moniker.SerializedData.pbData = (BYTE *) MONIKER_DATA;

    FileLink.dwLinkChoice = SPC_FILE_LINK_CHOICE;
    FileLink.pwszFile = L"Unicode File Link";

    memset(&Image, 0, sizeof(Image));
    memset(&AgencyInfo, 0, sizeof(AgencyInfo));

    AgencyInfo.pLogoImage = &Image;

    if (dwLevel >= 1) {
        AgencyInfo.pPolicyInformation = &UrlLink;
        AgencyInfo.pwszPolicyDisplayText = L"MICROSOFT PRODUCTS POLICY";
        AgencyInfo.pLogoImage = NULL;
    }

    if (dwLevel >= 2) {
        AgencyInfo.pPolicyInformation = &UrlLink;
        AgencyInfo.pwszPolicyDisplayText = L"Unicode String";
        Image.Bitmap.cbData = strlen(BIT_MAP);
        Image.Bitmap.pbData = (BYTE *) BIT_MAP;
    }

    if (dwLevel >= 3) {
        AgencyInfo.pwszPolicyDisplayText = L"Policy Display Unicode String";
        AgencyInfo.pLogoLink = &MonikerLink;
        Image.pImageLink = &FileLink;
        Image.Metafile.cbData = strlen(META_FILE);
        Image.Metafile.pbData = (BYTE *) META_FILE;
        Image.EnhancedMetafile.cbData = strlen(ENHANCED_META_FILE);
        Image.EnhancedMetafile.pbData = (BYTE *) ENHANCED_META_FILE;
        Image.GifFile.cbData = strlen(GIF_FILE);
        Image.GifFile.pbData = (BYTE *) GIF_FILE;
    }

    if (!AllocAndEncodeObject(
            SPC_SP_AGENCY_INFO_STRUCT,
            &AgencyInfo,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateSpcCommonName(
        DWORD dwCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

#define SPC_AGENCY_NAME L"Microsoft Code Signing Agency"
#define SPC_COM_NAME "Microsoft Software Products"

    CERT_NAME_VALUE NameValue;

    if (CertPara[dwCert].dwFlags & SPC_AGENCY_PARA_FLAG) {
        NameValue.dwValueType = CERT_RDN_UNICODE_STRING;
        NameValue.Value.pbData =  (BYTE *) SPC_AGENCY_NAME;
        NameValue.Value.cbData = wcslen(SPC_AGENCY_NAME) * sizeof(WCHAR);
    } else if (CertPara[dwCert].dwFlags & SPC_COM_PARA_FLAG) {
        NameValue.dwValueType = CERT_RDN_IA5_STRING;
        NameValue.Value.pbData =  (BYTE *) SPC_COM_NAME;
        NameValue.Value.cbData = strlen(SPC_COM_NAME);
    } else {
        NameValue.dwValueType = CERT_RDN_PRINTABLE_STRING;
        NameValue.Value.pbData =  (BYTE *) CertPara[dwCert].pszName;
        NameValue.Value.cbData = strlen(CertPara[dwCert].pszName);
    }

    if (!AllocAndEncodeObject(
            X509_NAME_VALUE,
            &NameValue,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateCRLReason(
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    static int iReason = -1;

    iReason += 1;

    iReason = iReason % CRL_REASON_CERTIFICATE_HOLD;
    return AllocAndEncodeObject(
        X509_ENUMERATED,
        (const void *) &iReason,
        ppbEncoded,
        pcbEncoded
        );
}

static BOOL EncodeCert(DWORD dwCert, BYTE **ppbEncoded, DWORD *pcbEncoded)
{
    BOOL fResult;
    BYTE *pbSubjectEncoded = NULL;
    DWORD cbSubjectEncoded;
    BYTE *pbIssuerEncoded = NULL;
    DWORD cbIssuerEncoded;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded;

    BYTE *pbKeyIdEncoded = NULL;
    DWORD cbKeyIdEncoded;
    BYTE *pbKeyId2Encoded = NULL;
    DWORD cbKeyId2Encoded;
    BYTE *pbSubjectKeyIdEncoded = NULL;
    DWORD cbSubjectKeyIdEncoded;
    BYTE *pbAuthorityInfoAccessEncoded = NULL;
    DWORD cbAuthorityInfoAccessEncoded;
    BYTE *pbCrlDistPointsEncoded = NULL;
    DWORD cbCrlDistPointsEncoded;
    BYTE *pbKeyAttrEncoded = NULL;
    DWORD cbKeyAttrEncoded;
    BYTE *pbAltNameEncoded = NULL;
    DWORD cbAltNameEncoded;
    BYTE *pbIssuerAltNameEncoded = NULL;
    DWORD cbIssuerAltNameEncoded;
    BYTE *pbKeyUsageRestrictionEncoded = NULL;
    DWORD cbKeyUsageRestrictionEncoded;
    BYTE *pbBasicConstraintsEncoded = NULL;
    DWORD cbBasicConstraintsEncoded;
    BYTE *pbKeyUsageEncoded = NULL;
    DWORD cbKeyUsageEncoded;
    BYTE *pbBasicConstraints2Encoded = NULL;
    DWORD cbBasicConstraints2Encoded;
    BYTE *pbPoliciesEncoded = NULL;
    DWORD cbPoliciesEncoded;

    BYTE *pbSETAccountAliasEncoded = NULL;
    DWORD cbSETAccountAliasEncoded;
    BYTE *pbSETHashedRootKeyEncoded = NULL;
    DWORD cbSETHashedRootKeyEncoded;
    BYTE *pbSETCertificateTypeEncoded = NULL;
    DWORD cbSETCertificateTypeEncoded;
    BYTE *pbSETMerchantDataEncoded = NULL;
    DWORD cbSETMerchantDataEncoded;

    BYTE *pbSpcSpAgencyEncoded0 = NULL;
    DWORD cbSpcSpAgencyEncoded0;
    BYTE *pbSpcSpAgencyEncoded1 = NULL;
    DWORD cbSpcSpAgencyEncoded1;
    BYTE *pbSpcSpAgencyEncoded2 = NULL;
    DWORD cbSpcSpAgencyEncoded2;
    BYTE *pbSpcCommonNameEncoded = NULL;
    DWORD cbSpcCommonNameEncoded;

    BYTE *pbNetscapeCertType = NULL;
    DWORD cbNetscapeCertType;
    BYTE *pbNetscapeComment = NULL;
    DWORD cbNetscapeComment;
    BYTE *pbNetscapeBaseUrl = NULL;
    DWORD cbNetscapeBaseUrl;
    BYTE *pbNetscapeRevUrl = NULL;
    DWORD cbNetscapeRevUrl;

    BYTE *pbEnhancedKeyUsageEncoded = NULL;
    DWORD cbEnhancedKeyUsageEncoded;

    BYTE *pbSMIMECapabilitiesEncoded = NULL;
    DWORD cbSMIMECapabilitiesEncoded;

    BYTE *pbIDPEncoded = NULL;
    DWORD cbIDPEncoded;
    BYTE *pbNameConstraintsEncoded = NULL;
    DWORD cbNameConstraintsEncoded;

    BYTE *pbPolicyMappingsEncoded = NULL;
    DWORD cbPolicyMappingsEncoded;
    BYTE *pbPolicyConstraintsEncoded = NULL;
    DWORD cbPolicyConstraintsEncoded;
    BYTE *pbCrossCertDistPointsEncoded = NULL;
    DWORD cbCrossCertDistPointsEncoded;

    FILETIME SerialNumber;

    CERT_RDN rgRDN[RDN_CNT];
    CERT_RDN_ATTR rgAttr[ATTR_CNT];
    CERT_NAME_INFO Name;
    CERT_INFO Cert;

    DWORD dwIssuer = CertPara[dwCert].dwIssuer;

    DWORD dwCrlDistFlags;

#define CERT_EXTENSION_CNT 30
    CERT_EXTENSION rgExt[CERT_EXTENSION_CNT];

    // SUBJECT
    CreateNameInfo(dwCert, &Name, rgRDN, rgAttr);
    if (!AllocAndEncodeObject(
            X509_NAME,
            &Name,
            &pbSubjectEncoded,
            &cbSubjectEncoded
            ))
        goto ErrorReturn;

    // ISSUER
    CreateNameInfo(dwIssuer, &Name, rgRDN, rgAttr);
    if (!AllocAndEncodeObject(
            X509_NAME,
            &Name,
            &pbIssuerEncoded,
            &cbIssuerEncoded
            ))
        goto ErrorReturn;

    // PUBLIC KEY
    if (!GetPublicKey(dwCert, &pPubKeyInfo)) goto ErrorReturn;

    // CERT
    memset(&Cert, 0, sizeof(Cert));
    Cert.dwVersion = CERT_V3;
    {
        SYSTEMTIME SystemTime = TestTime;
        if (CertPara[dwCert].dwFlags & DUPLICATE_PARA_FLAG)
            // Use same serial number as previous certificate
            SystemTime.wMilliseconds += (WORD) (dwCert - 1);
        else
            SystemTime.wMilliseconds += (WORD) dwCert;
        MySystemTimeToFileTime(&SystemTime, &SerialNumber);
    }
    Cert.SerialNumber.pbData = (BYTE *) &SerialNumber;
    Cert.SerialNumber.cbData = sizeof(SerialNumber);
    if (CertPara[dwIssuer].dwFlags & DSS_PARA_FLAG)
        Cert.SignatureAlgorithm.pszObjId = DSS_SIGNATURE_ALG_OBJID;
    else
        Cert.SignatureAlgorithm.pszObjId = SIGNATURE_ALG_OBJID;
    Cert.Issuer.pbData = pbIssuerEncoded;
    Cert.Issuer.cbData = cbIssuerEncoded;

    {
        SYSTEMTIME SystemTime = TestTime;

        if (CertPara[dwCert].dwFlags & TIME_INVALID_PARA_FLAG) {
            MySystemTimeToFileTime(&SystemTime, &Cert.NotAfter);
            SystemTime.wYear--;
            MySystemTimeToFileTime(&SystemTime, &Cert.NotBefore);
        } else if (CertPara[dwCert].dwFlags & GENERALIZED_TIME_PARA_FLAG) {
            SystemTime.wYear = 1920;
            MySystemTimeToFileTime(&SystemTime, &Cert.NotBefore);
            SystemTime.wYear = 2070;

            if (CertPara[dwCert].dwFlags & CA_PARA_FLAG)
                SystemTime.wHour = 1;
            else
                SystemTime.wHour = 0;
            SystemTime.wMinute = 59 - (WORD) dwCert;
            SystemTime.wSecond = 0;
            MySystemTimeToFileTime(&SystemTime, &Cert.NotAfter);
        } else if (0 == strcmp("ZeroNotAfter", CertPara[dwCert].pszName)) {
            MySystemTimeToFileTime(&SystemTime, &Cert.NotBefore);
            // NotAfter has already been zeroed
        } else {
            MySystemTimeToFileTime(&SystemTime, &Cert.NotBefore);
            SystemTime.wYear++;
            if (CertPara[dwCert].dwFlags & CA_PARA_FLAG)
                SystemTime.wHour = 1;
            else
                SystemTime.wHour = 0;
            if (dwCert < 60) {
                SystemTime.wMinute = 59 - (WORD) dwCert;
                SystemTime.wSecond = 0;
            } else {
                SystemTime.wMinute = 0;
                SystemTime.wSecond = 0;
            }
            MySystemTimeToFileTime(&SystemTime, &Cert.NotAfter);
        }
    }

    Cert.Subject.pbData = pbSubjectEncoded;
    Cert.Subject.cbData = cbSubjectEncoded;
    Cert.SubjectPublicKeyInfo = *pPubKeyInfo;

    // Cert Extensions
    if (!CreateAuthorityKeyId(
            dwIssuer,
            &pbKeyIdEncoded,
            &cbKeyIdEncoded))
        goto ErrorReturn;
    if (!CreateAuthorityKeyId2(
            dwCert,
            dwIssuer,
            &pbKeyId2Encoded,
            &cbKeyId2Encoded))
        goto ErrorReturn;
    if (!CreateAuthorityInfoAccess(
            dwCert,
            &pbAuthorityInfoAccessEncoded,
            &cbAuthorityInfoAccessEncoded))
        goto ErrorReturn;

    dwCrlDistFlags = 0;
    if (CertPara[dwCert].dwFlags & DELTA_CRL_PARA_FLAG)
        dwCrlDistFlags |= CRL_DIST_POINTS_DELTA_FLAG;
    if (0 == strcmp(CertPara[dwCert].pszName, "UnsupportedCDP"))
        dwCrlDistFlags |= CRL_DIST_POINTS_UNSUPPORTED_FLAG;
    if (!CreateCrlDistPoints(
            CertPara[dwCert].dwIssuer,
            dwCrlDistFlags,
            &pbCrlDistPointsEncoded,
            &cbCrlDistPointsEncoded))
        goto ErrorReturn;

    if (!CreateKeyAttributes(
            dwCert,
            &pbKeyAttrEncoded,
            &cbKeyAttrEncoded))
        goto ErrorReturn;
    if (!CreateAltName(
            dwCert,
            &pbAltNameEncoded,
            &cbAltNameEncoded))
        goto ErrorReturn;
    if (!CreateKeyUsageRestriction(
            dwCert,
            &pbKeyUsageRestrictionEncoded,
            &cbKeyUsageRestrictionEncoded))
        goto ErrorReturn;
    if (!CreateBasicConstraints(
            dwCert,
            &pbBasicConstraintsEncoded,
            &cbBasicConstraintsEncoded))
        goto ErrorReturn;
    if (!CreateKeyUsage(
            dwCert,
            &pbKeyUsageEncoded,
            &cbKeyUsageEncoded))
        goto ErrorReturn;
    if (!CreateBasicConstraints2(
            dwCert,
            &pbBasicConstraints2Encoded,
            &cbBasicConstraints2Encoded))
        goto ErrorReturn;
    if (!CreatePolicies(
            dwCert,
            &pbPoliciesEncoded,
            &cbPoliciesEncoded))
        goto ErrorReturn;

    if (CertPara[dwCert].dwFlags & SPC_AGENCY_INFO_PARA_FLAG) {
        if (!CreateSpcSpAgency(
                dwCert,
                0,          // dwLevel
                &pbSpcSpAgencyEncoded0,
                &cbSpcSpAgencyEncoded0))
            goto ErrorReturn;
        if (!CreateSpcSpAgency(
                dwCert,
                2,          // dwLevel
                &pbSpcSpAgencyEncoded1,
                &cbSpcSpAgencyEncoded1))
            goto ErrorReturn;
        if (!CreateSpcSpAgency(
                dwCert,
                3,          // dwLevel
                &pbSpcSpAgencyEncoded2,
                &cbSpcSpAgencyEncoded2))
            goto ErrorReturn;
    } else if (CertPara[dwCert].dwFlags & SPC_EXT_PARA_FLAG) {
        if (!CreateSpcSpAgency(
                dwCert,
                1,          // dwLevel
                &pbSpcSpAgencyEncoded0,
                &cbSpcSpAgencyEncoded0))
            goto ErrorReturn;
        if (!CreateSpcCommonName(
                dwCert,
                &pbSpcCommonNameEncoded,
                &cbSpcCommonNameEncoded))
            goto ErrorReturn;
    } else {
        if (!CreateSETAccountAlias(
                dwCert,
                &pbSETAccountAliasEncoded,
                &cbSETAccountAliasEncoded))
            goto ErrorReturn;
        if (!CreateSETHashedRootKey(
                dwCert,
                &pbSETHashedRootKeyEncoded,
                &cbSETHashedRootKeyEncoded))
            goto ErrorReturn;
        if (!CreateSETCertificateType(
                dwCert,
                &pbSETCertificateTypeEncoded,
                &cbSETCertificateTypeEncoded))
            goto ErrorReturn;
        if (!CreateSETMerchantData(
                dwCert,
                &pbSETMerchantDataEncoded,
                &cbSETMerchantDataEncoded))
            goto ErrorReturn;
    }


    rgExt[0].pszObjId = szOID_AUTHORITY_KEY_IDENTIFIER;
    rgExt[0].fCritical = FALSE;
    rgExt[0].Value.pbData = pbKeyIdEncoded;
    rgExt[0].Value.cbData = cbKeyIdEncoded;
    rgExt[1].pszObjId = szOID_KEY_ATTRIBUTES;
    rgExt[1].fCritical = FALSE;
    rgExt[1].Value.pbData = pbKeyAttrEncoded;
    rgExt[1].Value.cbData = cbKeyAttrEncoded;
    rgExt[2].pszObjId = szOID_BASIC_CONSTRAINTS;
    rgExt[2].fCritical = FALSE;
    rgExt[2].Value.pbData = pbBasicConstraintsEncoded;
    rgExt[2].Value.cbData = cbBasicConstraintsEncoded;
    rgExt[3].pszObjId = szOID_KEY_USAGE_RESTRICTION;
    rgExt[3].fCritical = FALSE;
    rgExt[3].Value.pbData = pbKeyUsageRestrictionEncoded;
    rgExt[3].Value.cbData = cbKeyUsageRestrictionEncoded;
    rgExt[4].pszObjId = szOID_KEY_USAGE;
    rgExt[4].fCritical = FALSE;
    rgExt[4].Value.pbData = pbKeyUsageEncoded;
    rgExt[4].Value.cbData = cbKeyUsageEncoded;
    rgExt[5].pszObjId = szOID_BASIC_CONSTRAINTS2;
    rgExt[5].fCritical = FALSE;
    rgExt[5].Value.pbData = pbBasicConstraints2Encoded;
    rgExt[5].Value.cbData = cbBasicConstraints2Encoded;
    rgExt[6].pszObjId = szOID_CERT_POLICIES;
    rgExt[6].fCritical = FALSE;
    rgExt[6].Value.pbData = pbPoliciesEncoded;
    rgExt[6].Value.cbData = cbPoliciesEncoded;

    rgExt[7].pszObjId = szOID_SUBJECT_ALT_NAME;
    rgExt[7].fCritical = FALSE;
    if (0 == strcmp(CertPara[dwCert].pszName, "InvalidNCEnd_AV")) {
        static BYTE rgbExt[] = {5,0};

        rgExt[7].Value.pbData = rgbExt;
        rgExt[7].Value.cbData = 0;  // sizeof(rgbExt);
    } else {
        rgExt[7].Value.pbData = pbAltNameEncoded;
        rgExt[7].Value.cbData = cbAltNameEncoded;
    }

    if (CertPara[dwCert].dwFlags & NO_EXT_PARA_FLAG)
        Cert.cExtension = 0;
    else if (CertPara[dwCert].dwFlags & VALID_PARA_FLAG)
        Cert.cExtension = 6;
    else if (CertPara[dwCert].dwFlags & SPC_AGENCY_INFO_PARA_FLAG) {
        rgExt[8].pszObjId = SPC_SP_AGENCY_INFO_OBJID;
        rgExt[8].fCritical = TRUE;
        rgExt[8].Value.pbData = pbSpcSpAgencyEncoded2;
        rgExt[8].Value.cbData = cbSpcSpAgencyEncoded2;
        rgExt[9].pszObjId = SPC_SP_AGENCY_INFO_OBJID;
        rgExt[9].fCritical = FALSE;
        rgExt[9].Value.pbData = pbSpcSpAgencyEncoded0;
        rgExt[9].Value.cbData = cbSpcSpAgencyEncoded0;
        rgExt[10].pszObjId = SPC_SP_AGENCY_INFO_OBJID;
        rgExt[10].fCritical = FALSE;
        rgExt[10].Value.pbData = pbSpcSpAgencyEncoded1;
        rgExt[10].Value.cbData = cbSpcSpAgencyEncoded1;
        Cert.cExtension = 11;
    } else if (CertPara[dwCert].dwFlags & SPC_EXT_PARA_FLAG) {
        rgExt[8].pszObjId = SPC_SP_AGENCY_INFO_OBJID;
        rgExt[8].fCritical = FALSE;
        rgExt[8].Value.pbData = pbSpcSpAgencyEncoded0;
        rgExt[8].Value.cbData = cbSpcSpAgencyEncoded0;
        if (CertPara[dwCert].dwFlags &
                (SPC_AGENCY_PARA_FLAG | SPC_COM_PARA_FLAG)) {
            rgExt[9].pszObjId = SPC_COMMON_NAME_OBJID;
            rgExt[9].fCritical = FALSE;
            rgExt[9].Value.pbData = pbSpcCommonNameEncoded;
            rgExt[9].Value.cbData = cbSpcCommonNameEncoded;
            Cert.cExtension = 10;
        } else
            Cert.cExtension = 9;
    } else if (CertPara[dwCert].dwFlags & NETSCAPE_PARA_FLAG) {
        BYTE bCertType;
        CRYPT_BIT_BLOB BitBlob;
        CERT_NAME_VALUE Comment;
        CERT_NAME_VALUE RevUrl;
        CERT_NAME_VALUE BaseUrl;

        BitBlob.pbData = &bCertType;
        BitBlob.cbData = 1;
        BitBlob.cUnusedBits = 2;
        if (CertPara[dwCert].dwFlags & CA_PARA_FLAG)
            bCertType = NETSCAPE_SSL_CA_CERT_TYPE;
        else
            bCertType = NETSCAPE_SSL_CLIENT_AUTH_CERT_TYPE;

        if (!AllocAndEncodeObject(
                X509_BITS,
                &BitBlob,
                &pbNetscapeCertType,
                &cbNetscapeCertType))
            goto ErrorReturn;
        rgExt[8].pszObjId = szOID_NETSCAPE_CERT_TYPE;
        rgExt[8].fCritical = FALSE;
        rgExt[8].Value.pbData = pbNetscapeCertType;
        rgExt[8].Value.cbData = cbNetscapeCertType;

        memset(&Comment, 0, sizeof(Comment));
        Comment.dwValueType = CERT_RDN_IA5_STRING;
        Comment.Value.pbData = (BYTE *) L"This is an IA5 Netscape Comment";
        if (!AllocAndEncodeObject(
                X509_UNICODE_ANY_STRING,
                &Comment,
                &pbNetscapeComment,
                &cbNetscapeComment))
            goto ErrorReturn;
        rgExt[9].pszObjId = szOID_NETSCAPE_COMMENT;
        rgExt[9].fCritical = FALSE;
        rgExt[9].Value.pbData = pbNetscapeComment;
        rgExt[9].Value.cbData = cbNetscapeComment;

        memset(&BaseUrl, 0, sizeof(BaseUrl));
        BaseUrl.dwValueType = CERT_RDN_IA5_STRING;
#if 0
        BaseUrl.Value.pbData = (BYTE *) L"http://status.verisign.com/";
#else
        BaseUrl.Value.pbData = (BYTE *) L"https://www.netscape.com/";
#endif
        if (!AllocAndEncodeObject(
                X509_UNICODE_ANY_STRING,
                &BaseUrl,
                &pbNetscapeBaseUrl,
                &cbNetscapeBaseUrl))
            goto ErrorReturn;
        rgExt[10].pszObjId = szOID_NETSCAPE_BASE_URL;
        rgExt[10].fCritical = FALSE;
        rgExt[10].Value.pbData = pbNetscapeBaseUrl;
        rgExt[10].Value.cbData = cbNetscapeBaseUrl;

        memset(&RevUrl, 0, sizeof(RevUrl));
        RevUrl.dwValueType = CERT_RDN_IA5_STRING;
#if 0
        RevUrl.Value.pbData = (BYTE *) L"status/check/ver/1/ID/";
#else
        RevUrl.Value.pbData = (BYTE *) L"cgi-bin/check-rev.cgi?";
#endif
        if (!AllocAndEncodeObject(
                X509_UNICODE_ANY_STRING,
                &RevUrl,
                &pbNetscapeRevUrl,
                &cbNetscapeRevUrl))
            goto ErrorReturn;
        if (CertPara[dwCert].dwFlags & CA_PARA_FLAG)
            rgExt[11].pszObjId = szOID_NETSCAPE_CA_REVOCATION_URL;
        else
            rgExt[11].pszObjId = szOID_NETSCAPE_REVOCATION_URL;
        rgExt[11].fCritical = FALSE;
        rgExt[11].Value.pbData = pbNetscapeRevUrl;
        rgExt[11].Value.cbData = cbNetscapeRevUrl;

        Cert.cExtension = 12;
    } else if (CertPara[dwCert].dwFlags & SET_PARA_FLAG) {
        rgExt[8].pszObjId = szOID_SET_ACCOUNT_ALIAS;
        rgExt[8].fCritical = FALSE;
        rgExt[8].Value.pbData = pbSETAccountAliasEncoded;
        rgExt[8].Value.cbData = cbSETAccountAliasEncoded;
        rgExt[9].pszObjId = szOID_SET_HASHED_ROOT_KEY;
        rgExt[9].fCritical = FALSE;
        rgExt[9].Value.pbData = pbSETHashedRootKeyEncoded;
        rgExt[9].Value.cbData = cbSETHashedRootKeyEncoded;
        rgExt[10].pszObjId = szOID_SET_CERTIFICATE_TYPE;
        rgExt[10].fCritical = FALSE;
        rgExt[10].Value.pbData = pbSETCertificateTypeEncoded;
        rgExt[10].Value.cbData = cbSETCertificateTypeEncoded;
        rgExt[11].pszObjId = szOID_SET_MERCHANT_DATA;
        rgExt[11].fCritical = FALSE;
        rgExt[11].Value.pbData = pbSETMerchantDataEncoded;
        rgExt[11].Value.cbData = cbSETMerchantDataEncoded;
        Cert.cExtension = 12;
    } else {
        Cert.cExtension = 8;
    }

    if ((CertPara[dwCert].dwFlags & DELTA_CRL_PARA_FLAG) ||
            (0 == (CertPara[dwCert].dwFlags &
                (NO_EXT_PARA_FLAG | VALID_PARA_FLAG)))) {
        DWORD cExt = Cert.cExtension;

        if (0 == (CertPara[CertPara[dwCert].dwIssuer].dwFlags &
                NO_CRL_EXT_PARA_FLAG)) {
            if (0 != strncmp(CertPara[dwCert].pszName, "NoCDP", 5)) {
                rgExt[cExt].pszObjId = szOID_CRL_DIST_POINTS;
                rgExt[cExt].fCritical = FALSE;
                rgExt[cExt].Value.pbData = pbCrlDistPointsEncoded;
                rgExt[cExt].Value.cbData = cbCrlDistPointsEncoded;
                cExt++;
            }
        }

        if (0 == strcmp(CertPara[dwCert].pszName, "DeltaEndValid")) {
            rgExt[cExt].pszObjId = szOID_FRESHEST_CRL;
            rgExt[cExt].fCritical = FALSE;
            rgExt[cExt].Value.pbData = pbCrlDistPointsEncoded;
            rgExt[cExt].Value.cbData = cbCrlDistPointsEncoded;
            cExt++;
        }

        Cert.cExtension = cExt;
    }

    if (0 == strcmp(CertPara[dwCert].pszName, "DssCA") ||
            0 == strcmp(CertPara[dwCert].pszName, "DssEnd")) {
        DWORD cExt = Cert.cExtension;
        PCTL_USAGE pCtlUsage;

        rgExt[cExt].pszObjId = szOID_CERT_POLICIES;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbPoliciesEncoded;
        rgExt[cExt].Value.cbData = cbPoliciesEncoded;
        cExt++;

        if (0 == strcmp(CertPara[dwCert].pszName, "DssCA"))
            pCtlUsage = &rgCtlUsage[0];
        else
            pCtlUsage = &rgCtlUsage[2];

        if (!AllocAndEncodeObject(
                X509_ENHANCED_KEY_USAGE,
                (const void *) pCtlUsage,
                &pbEnhancedKeyUsageEncoded,
                &cbEnhancedKeyUsageEncoded))
            goto ErrorReturn;

        rgExt[cExt].pszObjId = szOID_ENHANCED_KEY_USAGE;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbEnhancedKeyUsageEncoded;
        rgExt[cExt].Value.cbData = cbEnhancedKeyUsageEncoded;
        cExt++;

        Cert.cExtension = cExt;
    } else if (0 == strcmp("TestAIAEnd", CertPara[dwCert].pszName)) {
        DWORD cExt = Cert.cExtension;

        rgExt[cExt].pszObjId = szOID_AUTHORITY_INFO_ACCESS;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbAuthorityInfoAccessEncoded;
        rgExt[cExt].Value.cbData = cbAuthorityInfoAccessEncoded;
        cExt++;

        Cert.cExtension = cExt;
    } else if (0 == strcmp(CertPara[dwCert].pszName, "RolloverRoot") ||
            0 == (CertPara[dwCert].dwFlags &
                (NO_EXT_PARA_FLAG | VALID_PARA_FLAG))) {
        DWORD cExt = Cert.cExtension;

        rgExt[cExt].pszObjId = szOID_AUTHORITY_KEY_IDENTIFIER2;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbKeyId2Encoded;
        rgExt[cExt].Value.cbData = cbKeyId2Encoded;
        cExt++;

        if (0 != strcmp(CertPara[dwCert].pszName, "RolloverRoot")) {
            rgExt[cExt].pszObjId = szOID_AUTHORITY_INFO_ACCESS;
            rgExt[cExt].fCritical = FALSE;
            rgExt[cExt].Value.pbData = pbAuthorityInfoAccessEncoded;
            rgExt[cExt].Value.cbData = cbAuthorityInfoAccessEncoded;
            cExt++;
        }

#if 1
        if (TRUE) {
#else
        if (CertPara[dwCert].dwFlags & CA_PARA_FLAG) {
#endif
            if (!CreateKeyId(
                    dwCert,
                    &pbSubjectKeyIdEncoded,
                    &cbSubjectKeyIdEncoded))
                goto ErrorReturn;
            rgExt[cExt].pszObjId = szOID_SUBJECT_KEY_IDENTIFIER;
            rgExt[cExt].fCritical = FALSE;
            rgExt[cExt].Value.pbData = pbSubjectKeyIdEncoded;
            rgExt[cExt].Value.cbData = cbSubjectKeyIdEncoded;
            cExt++;
        }

        if (CertPara[dwCert].dwFlags & (USE1_PARA_FLAG | USE2_PARA_FLAG)) {
            if (!CreateEnhancedKeyUsage(
                    CertPara[dwCert].dwFlags,
                    &pbEnhancedKeyUsageEncoded,
                    &cbEnhancedKeyUsageEncoded))
                goto ErrorReturn;
            rgExt[cExt].pszObjId = szOID_ENHANCED_KEY_USAGE;
            rgExt[cExt].fCritical = FALSE;
            rgExt[cExt].Value.pbData = pbEnhancedKeyUsageEncoded;
            rgExt[cExt].Value.cbData = cbEnhancedKeyUsageEncoded;
            cExt++;
        }

        Cert.cExtension = cExt;
    } else if (0 == strcmp(CertPara[dwCert].pszName, "RolloverCA")) {
        DWORD cExt = Cert.cExtension;

        rgExt[cExt].pszObjId = szOID_AUTHORITY_INFO_ACCESS;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbAuthorityInfoAccessEncoded;
        rgExt[cExt].Value.cbData = cbAuthorityInfoAccessEncoded;
        cExt++;

        Cert.cExtension = cExt;
    }


    if (dwCert == POLICY_ROOT || dwCert == POLICY_CA) {
        // 0 - Root
        // 1 - CA

        DWORD cExt = Cert.cExtension;

        if (!CreatePolicyMappings(
                dwCert,
                &pbPolicyMappingsEncoded,
                &cbPolicyMappingsEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_POLICY_MAPPINGS;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbPolicyMappingsEncoded;
        rgExt[cExt].Value.cbData = cbPolicyMappingsEncoded;
        cExt++;

        if (!CreatePolicyConstraints(
                dwCert,
                &pbPolicyConstraintsEncoded,
                &cbPolicyConstraintsEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_POLICY_CONSTRAINTS;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbPolicyConstraintsEncoded;
        rgExt[cExt].Value.cbData = cbPolicyConstraintsEncoded;
        cExt++;

        if (!CreateNameConstraints(
                dwCert,
                &pbNameConstraintsEncoded,
                &cbNameConstraintsEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_NAME_CONSTRAINTS;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbNameConstraintsEncoded;
        rgExt[cExt].Value.cbData = cbNameConstraintsEncoded;
        cExt++;

        Cert.cExtension = cExt;

    } else if (dwCert == ROLLOVER_CROSS_CERT) {
        DWORD cExt = Cert.cExtension;

        if (!CreatePolicyConstraints(
                dwCert,
                &pbPolicyConstraintsEncoded,
                &cbPolicyConstraintsEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_POLICY_CONSTRAINTS;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbPolicyConstraintsEncoded;
        rgExt[cExt].Value.cbData = cbPolicyConstraintsEncoded;
        cExt++;

        Cert.cExtension = cExt;

    } else if (0 == strcmp(CertPara[dwCert].pszName, "MissingNCCA")) {
        DWORD cExt = Cert.cExtension;

        if (!CreateNameConstraints(
                dwCert,
                &pbNameConstraintsEncoded,
                &cbNameConstraintsEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_NAME_CONSTRAINTS;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbNameConstraintsEncoded;
        rgExt[cExt].Value.cbData = cbNameConstraintsEncoded;
        cExt++;

        Cert.cExtension = cExt;

    } else if (0 == strcmp(CertPara[dwCert].pszName, "InvalidNCCA_AV")) {
        DWORD cExt = Cert.cExtension;
        static BYTE rgbExt[] = {5,0};

        rgExt[cExt].pszObjId = szOID_NAME_CONSTRAINTS;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = rgbExt;
        rgExt[cExt].Value.cbData = 0;  // sizeof(rgbExt);
        cExt++;

        Cert.cExtension = cExt;

    } else if (CertPara[dwCert].dwFlags & ALL_EXT_PARA_FLAG) {
        DWORD cExt = Cert.cExtension;

        if (!CreateSMIMECapabilities(
                dwCert,
                &pbSMIMECapabilitiesEncoded,
                &cbSMIMECapabilitiesEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_RSA_SMIMECapabilities;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbSMIMECapabilitiesEncoded;
        rgExt[cExt].Value.cbData = cbSMIMECapabilitiesEncoded;
        cExt++;

        if (!CreateCertIssuingDistPoint(
                dwCert,
                &pbIDPEncoded,
                &cbIDPEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_ISSUING_DIST_POINT;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbIDPEncoded;
        rgExt[cExt].Value.cbData = cbIDPEncoded;
        cExt++;

        if (!CreateCrossCertDistPoints(
                dwCert,
                &pbCrossCertDistPointsEncoded,
                &cbCrossCertDistPointsEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_CROSS_CERT_DIST_POINTS;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbCrossCertDistPointsEncoded;
        rgExt[cExt].Value.cbData = cbCrossCertDistPointsEncoded;
        cExt++;

        Cert.cExtension = cExt;
    }

    if (CertPara[dwCert].dwFlags & ALT_DIR_NAME_PARA_FLAG) {
        DWORD cExt = Cert.cExtension;

        if (!CreateAltName(
                dwIssuer,
                &pbIssuerAltNameEncoded,
                &cbIssuerAltNameEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_ISSUER_ALT_NAME2;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbIssuerAltNameEncoded;
        rgExt[cExt].Value.cbData = cbIssuerAltNameEncoded;
        cExt++;

        Cert.cExtension = cExt;
    }

    if (CertPara[dwCert].pszManifold) {
        DWORD cExt = Cert.cExtension;

        rgExt[cExt].pszObjId = szOID_CERT_MANIFOLD;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = (BYTE *) CertPara[dwCert].pszManifold;
        rgExt[cExt].Value.cbData = strlen(CertPara[dwCert].pszManifold);
        cExt++;

        Cert.cExtension = cExt;
    }

    if (0 == strcmp("V1", CertPara[dwCert].pszName)) {
        Cert.dwVersion = CERT_V1;
        Cert.cExtension = 0;
    } else if (0 == strcmp("V2", CertPara[dwCert].pszName)) {
        Cert.dwVersion = CERT_V2;
        Cert.cExtension = 0;

#define ISSUER_UNIQUE_ID    "Issuer Unique Id"
#define SUBJECT_UNIQUE_ID   "Subject Unique Id"
        Cert.IssuerUniqueId.pbData = (BYTE *) ISSUER_UNIQUE_ID;
        Cert.IssuerUniqueId.cbData = strlen(ISSUER_UNIQUE_ID);
        Cert.IssuerUniqueId.cUnusedBits = 0;

        Cert.SubjectUniqueId.pbData = (BYTE *) SUBJECT_UNIQUE_ID;
        Cert.SubjectUniqueId.cbData = strlen(SUBJECT_UNIQUE_ID);
        Cert.SubjectUniqueId.cUnusedBits = 0;
    }

    Cert.rgExtension = rgExt;

    if (!AllocAndEncodeObject(
            X509_CERT_TO_BE_SIGNED,
            &Cert,
            &pbCertEncoded,
            &cbCertEncoded))
        goto ErrorReturn;

    if (!EncodeSignedContent(
            dwIssuer,
            pbCertEncoded,
            cbCertEncoded,
            ppbEncoded,
            pcbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbKeyIdEncoded)
        TestFree(pbKeyIdEncoded);
    if (pbKeyId2Encoded)
        TestFree(pbKeyId2Encoded);
    if (pbSubjectKeyIdEncoded)
        TestFree(pbSubjectKeyIdEncoded);
    if (pbAuthorityInfoAccessEncoded)
        TestFree(pbAuthorityInfoAccessEncoded);
    if (pbCrlDistPointsEncoded)
        TestFree(pbCrlDistPointsEncoded);
    if (pbKeyAttrEncoded)
        TestFree(pbKeyAttrEncoded);
    if (pbAltNameEncoded)
        TestFree(pbAltNameEncoded);
    if (pbIssuerAltNameEncoded)
        TestFree(pbIssuerAltNameEncoded);
    if (pbKeyUsageRestrictionEncoded)
        TestFree(pbKeyUsageRestrictionEncoded);
    if (pbBasicConstraintsEncoded)
        TestFree(pbBasicConstraintsEncoded);
    if (pbKeyUsageEncoded)
        TestFree(pbKeyUsageEncoded);
    if (pbBasicConstraints2Encoded)
        TestFree(pbBasicConstraints2Encoded);
    if (pbPoliciesEncoded)
        TestFree(pbPoliciesEncoded);
    if (pbSETAccountAliasEncoded)
        TestFree(pbSETAccountAliasEncoded);
    if (pbSETHashedRootKeyEncoded)
        TestFree(pbSETHashedRootKeyEncoded);
    if (pbSETCertificateTypeEncoded)
        TestFree(pbSETCertificateTypeEncoded);
    if (pbSETMerchantDataEncoded)
        TestFree(pbSETMerchantDataEncoded);
    if (pbSpcSpAgencyEncoded0)
        TestFree(pbSpcSpAgencyEncoded0);
    if (pbSpcSpAgencyEncoded1)
        TestFree(pbSpcSpAgencyEncoded1);
    if (pbSpcSpAgencyEncoded2)
        TestFree(pbSpcSpAgencyEncoded2);
    if (pbSpcCommonNameEncoded)
        TestFree(pbSpcCommonNameEncoded);
    if (pbNetscapeCertType)
        TestFree(pbNetscapeCertType);
    if (pbNetscapeComment)
        TestFree(pbNetscapeComment);
    if (pbNetscapeRevUrl)
        TestFree(pbNetscapeRevUrl);
    if (pbNetscapeBaseUrl)
        TestFree(pbNetscapeBaseUrl);

    if (pbSubjectEncoded)
        TestFree(pbSubjectEncoded);
    if (pbIssuerEncoded)
        TestFree(pbIssuerEncoded);
    if (pPubKeyInfo)
        TestFree(pPubKeyInfo);
    if (pbCertEncoded)
        TestFree(pbCertEncoded);
    if (pbEnhancedKeyUsageEncoded)
        TestFree(pbEnhancedKeyUsageEncoded);
    if (pbSMIMECapabilitiesEncoded)
        TestFree(pbSMIMECapabilitiesEncoded);
    if (pbIDPEncoded)
        TestFree(pbIDPEncoded);
    if (pbNameConstraintsEncoded)
        TestFree(pbNameConstraintsEncoded);
    if (pbPolicyMappingsEncoded)
        TestFree(pbPolicyMappingsEncoded);
    if (pbPolicyConstraintsEncoded)
        TestFree(pbPolicyConstraintsEncoded);
    if (pbCrossCertDistPointsEncoded)
        TestFree(pbCrossCertDistPointsEncoded);

    return fResult;
}

static BOOL EncodeCrl(
    DWORD dwCert,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded,
    DWORD dwAki
    )
{
    BOOL fResult;
    BYTE *pbIssuerEncoded = NULL;
    DWORD cbIssuerEncoded;
    BYTE *pbCrlEncoded = NULL;
    DWORD cbCrlEncoded;
    BYTE *pbKeyId2Encoded = NULL;
    DWORD cbKeyId2Encoded;
    BYTE *pbIDPEncoded = NULL;
    DWORD cbIDPEncoded;
    DWORD i;

    CERT_RDN rgRDN[RDN_CNT];
    CERT_RDN_ATTR rgAttr[ATTR_CNT];
    CERT_NAME_INFO Name;

    CRL_ENTRY rgEntry[CERT_CNT];
    CRL_INFO Crl;

    FILETIME SerialNumber[CERT_CNT];

#define CRL_EXTENSION_CNT 2
    CERT_EXTENSION rgExt[CRL_EXTENSION_CNT];

    // Max of 1 extension per entry
    CERT_EXTENSION rgEntryExt[CERT_CNT];
    memset(rgEntryExt, 0, sizeof(rgEntryExt));

    // ISSUER
    CreateNameInfo(dwCert, &Name, rgRDN, rgAttr);
    if (!AllocAndEncodeObject(
            X509_NAME,
            &Name,
            &pbIssuerEncoded,
            &cbIssuerEncoded
            ))
        goto ErrorReturn;

    // CRL
    memset(&Crl, 0, sizeof(Crl));
    Crl.dwVersion = CRL_V2;
    if (CertPara[dwCert].dwFlags & DSS_PARA_FLAG)
        Crl.SignatureAlgorithm.pszObjId = DSS_SIGNATURE_ALG_OBJID;
    else
        Crl.SignatureAlgorithm.pszObjId = SIGNATURE_ALG_OBJID;
    Crl.Issuer.pbData = pbIssuerEncoded;
    Crl.Issuer.cbData = cbIssuerEncoded;

    {
        SYSTEMTIME SystemTime = TestTime;

        if (CertPara[dwCert].dwFlags & GENERALIZED_TIME_PARA_FLAG) {
            SystemTime.wYear = 1921;
            MySystemTimeToFileTime(&SystemTime, &Crl.ThisUpdate);
            SystemTime.wYear = 2071;
            MySystemTimeToFileTime(&SystemTime, &Crl.NextUpdate);
        } else {
            MySystemTimeToFileTime(&SystemTime, &Crl.ThisUpdate);
            if (0 == (CertPara[dwCert].dwFlags & NO_CRL_EXT_PARA_FLAG)) {
                SystemTime.wYear++;
                MySystemTimeToFileTime(&SystemTime, &Crl.NextUpdate);
            }
        }
    }

    Crl.cCRLEntry = 0;
    Crl.rgCRLEntry = rgEntry;
    for (i = 0; i < CERT_CNT; i++) {
        if (CertPara[i].dwIssuer == dwCert &&
            (CertPara[i].dwFlags & REVOKED_PARA_FLAG)) {
            DWORD j;

            SYSTEMTIME SystemTime = TestTime;

            j = Crl.cCRLEntry++;
            memset(&rgEntry[j], 0, sizeof(rgEntry[j]));

            SystemTime.wMilliseconds += (WORD) i;
            MySystemTimeToFileTime(&SystemTime, &SerialNumber[j]);

            rgEntry[j].SerialNumber.pbData = (BYTE *) &SerialNumber[j];
            rgEntry[j].SerialNumber.cbData = sizeof(SerialNumber[j]);
            if (CertPara[dwCert].dwFlags & GENERALIZED_TIME_PARA_FLAG) {
                SystemTime.wYear = 1922;
                MySystemTimeToFileTime(&SystemTime, &rgEntry[j].RevocationDate);
            } else
                MySystemTimeToFileTime(&SystemTime, &rgEntry[j].RevocationDate);

            if (0 == (CertPara[dwCert].dwFlags & NO_CRL_EXT_PARA_FLAG)) {
                if (!CreateCRLReason(
                        &rgEntryExt[j].Value.pbData,
                        &rgEntryExt[j].Value.cbData))
                    goto ErrorReturn;
                rgEntryExt[j].pszObjId = szOID_CRL_REASON_CODE;
                rgEntryExt[j].fCritical = FALSE;
                rgEntry[j].cExtension = 1;
                rgEntry[j].rgExtension = &rgEntryExt[j];
            }

        }
    }

    if (AKI2_NONE != dwAki &&
            0 == (CertPara[dwCert].dwFlags & NO_CRL_EXT_PARA_FLAG)) {
        // Crl Extensions
        if (!CreateAuthorityKeyId2(
                dwCert,
                dwCert,
                &pbKeyId2Encoded,
                &cbKeyId2Encoded,
                dwAki
                ))
            goto ErrorReturn;

        rgExt[0].pszObjId = szOID_AUTHORITY_KEY_IDENTIFIER2;
        rgExt[0].fCritical = FALSE;
        rgExt[0].Value.pbData = pbKeyId2Encoded;
        rgExt[0].Value.cbData = cbKeyId2Encoded;

        if (!CreateCrlIssuingDistPoint(
                &pbIDPEncoded,
                &cbIDPEncoded
                ))
            goto ErrorReturn;

        rgExt[1].pszObjId = szOID_ISSUING_DIST_POINT;
        rgExt[1].fCritical = FALSE;
        rgExt[1].Value.pbData = pbIDPEncoded;
        rgExt[1].Value.cbData = cbIDPEncoded;

        Crl.cExtension = CRL_EXTENSION_CNT;
        Crl.rgExtension = rgExt;
    }

    if (0 == strcmp("V1", CertPara[dwCert].pszName)) {
        Crl.dwVersion = CRL_V1;
        Crl.cExtension = 0;
    }

    if (!AllocAndEncodeObject(
            X509_CERT_CRL_TO_BE_SIGNED,
            &Crl,
            &pbCrlEncoded,
            &cbCrlEncoded
            ))
        goto ErrorReturn;

    if (!EncodeSignedContent(
            dwCert,
            pbCrlEncoded,
            cbCrlEncoded,
            ppbEncoded,
            pcbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbKeyId2Encoded)
        TestFree(pbKeyId2Encoded);
    if (pbIDPEncoded)
        TestFree(pbIDPEncoded);
    if (pbIssuerEncoded)
        TestFree(pbIssuerEncoded);
    if (pbCrlEncoded)
        TestFree(pbCrlEncoded);
    for (i = 0; i < CERT_CNT; i++) {
        if (rgEntryExt[i].Value.pbData)
            TestFree(rgEntryExt[i].Value.pbData);
    }

    return fResult;
}

static BOOL EncodeBaseOrDeltaCrl(
    DWORD dwIssuer,
    int iBase,
    DWORD dwFlags,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded
    )
{
    BOOL fResult;
    DWORD i;
    BYTE *pbIssuerNameEncoded = NULL;
    DWORD cbIssuerNameEncoded;
    BYTE *pbCDPEncoded = NULL;
    DWORD cbCDPEncoded;
    BYTE *pbBaseEncoded;
    DWORD cbBaseEncoded;
    BYTE *pbIDPEncoded = NULL;
    DWORD cbIDPEncoded;
    BYTE *pbCrlEncoded = NULL;
    DWORD cbCrlEncoded;

    CERT_RDN rgRDN[RDN_CNT];
    CERT_RDN_ATTR rgAttr[ATTR_CNT];
    CERT_NAME_INFO Name;
    FILETIME SerialNumber[CERT_CNT];
    CRL_ENTRY rgEntry[CERT_CNT];
    CRL_INFO Crl;
    CERT_EXTENSION rgExt[10];
    DWORD cExt = 0;

    // Max of 1 extension per entry
    CERT_EXTENSION rgEntryExt[CERT_CNT];
    memset(rgEntryExt, 0, sizeof(rgEntryExt));

    // ISSUER
    CreateNameInfo(dwIssuer, &Name, rgRDN, rgAttr);
    if (!AllocAndEncodeObject(
            X509_NAME,
            &Name,
            &pbIssuerNameEncoded,
            &cbIssuerNameEncoded
            ))
        goto ErrorReturn;

    // CRL
    memset(&Crl, 0, sizeof(Crl));
    Crl.dwVersion = CRL_V2;
    if (CertPara[dwIssuer].dwFlags & DSS_PARA_FLAG)
        Crl.SignatureAlgorithm.pszObjId = DSS_SIGNATURE_ALG_OBJID;
    else
        Crl.SignatureAlgorithm.pszObjId = SIGNATURE_ALG_OBJID;
    Crl.Issuer.pbData = pbIssuerNameEncoded;
    Crl.Issuer.cbData = cbIssuerNameEncoded;

    {
        SYSTEMTIME SystemTime = TestTime;

        if (dwFlags & EXPIRED_CRL_FLAG) {
            SystemTime.wYear = 1997;
            MySystemTimeToFileTime(&SystemTime, &Crl.ThisUpdate);
            SystemTime.wYear = 1998;
            MySystemTimeToFileTime(&SystemTime, &Crl.NextUpdate);
        } else if (CertPara[dwIssuer].dwFlags & GENERALIZED_TIME_PARA_FLAG) {
            SystemTime.wYear = 1921;
            MySystemTimeToFileTime(&SystemTime, &Crl.ThisUpdate);
            SystemTime.wYear = 2071;
            MySystemTimeToFileTime(&SystemTime, &Crl.NextUpdate);
        } else {
            MySystemTimeToFileTime(&SystemTime, &Crl.ThisUpdate);
            if (0 == (CertPara[dwIssuer].dwFlags & NO_CRL_EXT_PARA_FLAG)) {
                SystemTime.wYear++;
                MySystemTimeToFileTime(&SystemTime, &Crl.NextUpdate);
            }
        }
    }

    Crl.cCRLEntry = 0;
    Crl.rgCRLEntry = rgEntry;
    if (0 == (dwFlags & NO_ENTRIES_CRL_FLAG)) {
      for (i = 0; i < CERT_CNT; i++) {
        if (CertPara[i].dwIssuer == dwIssuer &&
            (CertPara[i].dwFlags & REVOKED_PARA_FLAG)) {
            DWORD j;

            SYSTEMTIME SystemTime = TestTime;

            j = Crl.cCRLEntry++;
            memset(&rgEntry[j], 0, sizeof(rgEntry[j]));

            SystemTime.wMilliseconds += (WORD) i;
            MySystemTimeToFileTime(&SystemTime, &SerialNumber[j]);

            rgEntry[j].SerialNumber.pbData = (BYTE *) &SerialNumber[j];
            rgEntry[j].SerialNumber.cbData = sizeof(SerialNumber[j]);
            if (CertPara[dwIssuer].dwFlags & GENERALIZED_TIME_PARA_FLAG) {
                SystemTime.wYear = 1922;
                MySystemTimeToFileTime(&SystemTime, &rgEntry[j].RevocationDate);
            } else
                MySystemTimeToFileTime(&SystemTime, &rgEntry[j].RevocationDate);

            if (dwFlags & REMOVE_FROM_CRL_FLAG) {
                int iReason = CRL_REASON_REMOVE_FROM_CRL;
                if (!AllocAndEncodeObject(
                        X509_ENUMERATED,
                        (const void *) &iReason,
                        &rgEntryExt[j].Value.pbData,
                        &rgEntryExt[j].Value.cbData))
                    goto ErrorReturn;
                rgEntryExt[j].pszObjId = szOID_CRL_REASON_CODE;
                rgEntryExt[j].fCritical = TRUE;
                rgEntry[j].cExtension = 1;
                rgEntry[j].rgExtension = &rgEntryExt[j];
            } else if (0 == (CertPara[dwIssuer].dwFlags & NO_CRL_EXT_PARA_FLAG)) {
                if (dwFlags & HOLD_CRL_FLAG) {
                    int iReason = CRL_REASON_CERTIFICATE_HOLD;
                    if (!AllocAndEncodeObject(
                            X509_ENUMERATED,
                            (const void *) &iReason,
                            &rgEntryExt[j].Value.pbData,
                            &rgEntryExt[j].Value.cbData))
                        goto ErrorReturn;
                } else {
                    if (!CreateCRLReason(
                            &rgEntryExt[j].Value.pbData,
                            &rgEntryExt[j].Value.cbData))
                        goto ErrorReturn;
                }
                rgEntryExt[j].pszObjId = szOID_CRL_REASON_CODE;
                rgEntryExt[j].fCritical = FALSE;
                rgEntry[j].cExtension = 1;
                rgEntry[j].rgExtension = &rgEntryExt[j];
            }

        }
      }
    }

    // Extensions
    memset(&rgExt, 0, sizeof(rgExt));
    if (!AllocAndEncodeObject(
            X509_INTEGER,
            (const void *) &iBase,
            &pbBaseEncoded,
            &cbBaseEncoded))
        goto ErrorReturn;
    if (dwFlags & FRESHEST_CRL_FLAG) {
        rgExt[0].pszObjId = szOID_DELTA_CRL_INDICATOR;
        rgExt[0].fCritical = TRUE;
    } else {
        rgExt[0].pszObjId = szOID_CRL_NUMBER;
        rgExt[0].fCritical = FALSE;
    }
    rgExt[0].Value.pbData = pbBaseEncoded;
    rgExt[0].Value.cbData = cbBaseEncoded;
    cExt = 1;

    if (dwFlags & UNSUPPORTED_CRITICAL_EXT_CRL_FLAG) {
        rgExt[cExt].pszObjId = "1.2.3.4.1999.2000";
        rgExt[cExt].fCritical = TRUE;
        rgExt[cExt].Value.pbData = pbBaseEncoded;
        rgExt[cExt].Value.cbData = cbBaseEncoded;
        cExt++;
    }

    if (0 == (dwFlags & FRESHEST_CRL_FLAG) &&
            0 == (dwFlags & NO_FRESHEST_CDP_CRL_FLAG)) {
        if (!CreateCrlDistPoints(
                dwIssuer,
                CRL_DIST_POINTS_DELTA_FLAG,
                &pbCDPEncoded,
                &cbCDPEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_FRESHEST_CRL;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbCDPEncoded;
        rgExt[cExt].Value.cbData = cbCDPEncoded;
        cExt++;
    }



    if (0 == (dwFlags & NO_IDP_CRL_FLAG)) {
        CRL_ISSUING_DIST_POINT IDP;
        PCERT_ALT_NAME_INFO pIDPAltNameInfo;
        
        CERT_ALT_NAME_ENTRY rgIDPAltNameEntry[8];
        BYTE bOnlySomeReasonFlags;

        memset(&IDP, 0, sizeof(IDP));
        if (dwFlags & UNSUPPORTED_IDP_OPTIONS_CRL_FLAG) {
            IDP.OnlySomeReasonFlags.cbData = 1;
            IDP.OnlySomeReasonFlags.pbData = &bOnlySomeReasonFlags;
            IDP.OnlySomeReasonFlags.cUnusedBits = 1;
            bOnlySomeReasonFlags = CRL_REASON_KEY_COMPROMISE_FLAG |
                CRL_REASON_CA_COMPROMISE_FLAG;

            IDP.fIndirectCRL = TRUE;
        }

        if (dwFlags & ONLY_USERS_CRL_FLAG)
            IDP.fOnlyContainsUserCerts = TRUE;
        if (dwFlags & ONLY_CAS_CRL_FLAG)
            IDP.fOnlyContainsCACerts = TRUE;

        IDP.DistPointName.dwDistPointNameChoice = CRL_DIST_POINT_FULL_NAME;

        rgIDPAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
        rgIDPAltNameEntry[0].pOtherName = &CrlOtherName;
        rgIDPAltNameEntry[1].dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
        rgIDPAltNameEntry[1].DirectoryName.pbData = pbIssuerNameEncoded;
        rgIDPAltNameEntry[1].DirectoryName.cbData = cbIssuerNameEncoded;
        rgIDPAltNameEntry[2].dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
        rgIDPAltNameEntry[2].pwszDNSName = CRL_DNS_NAME;
        rgIDPAltNameEntry[3].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
        rgIDPAltNameEntry[3].pwszRfc822Name = CRL_EMAIL_NAME;
        rgIDPAltNameEntry[4].dwAltNameChoice = CERT_ALT_NAME_REGISTERED_ID;
        rgIDPAltNameEntry[4].pszRegisteredID = CRL_REGISTERED_ID;
        rgIDPAltNameEntry[5].dwAltNameChoice = CERT_ALT_NAME_IP_ADDRESS;
        rgIDPAltNameEntry[5].IPAddress.pbData = CrlIPAddress;
        rgIDPAltNameEntry[5].IPAddress.cbData = sizeof(CrlIPAddress);
        rgIDPAltNameEntry[6].dwAltNameChoice = CERT_ALT_NAME_URL;
        rgIDPAltNameEntry[6].pwszURL = CRL_URL_NAME2;
        rgIDPAltNameEntry[7].dwAltNameChoice = CERT_ALT_NAME_URL;
        rgIDPAltNameEntry[7].pwszURL = CRL_URL_NAME1;

        pIDPAltNameInfo = &IDP.DistPointName.FullName;
        switch (iBase) {
            case 1:
                pIDPAltNameInfo->cAltEntry = 1;
                pIDPAltNameInfo->rgAltEntry = &rgIDPAltNameEntry[0];
                break;
            case 2:
                pIDPAltNameInfo->cAltEntry = 1;
                pIDPAltNameInfo->rgAltEntry = &rgIDPAltNameEntry[1];
                break;
            case 3:
                pIDPAltNameInfo->cAltEntry = 2;
                pIDPAltNameInfo->rgAltEntry = &rgIDPAltNameEntry[2];
                break;
            case 4:
                pIDPAltNameInfo->cAltEntry = 2;
                pIDPAltNameInfo->rgAltEntry = &rgIDPAltNameEntry[4];
                break;
            default:
                pIDPAltNameInfo->cAltEntry = 2;
                pIDPAltNameInfo->rgAltEntry = &rgIDPAltNameEntry[6];
                break;
        }

        if (!AllocAndEncodeObject(
                szOID_ISSUING_DIST_POINT,
                &IDP,
                &pbIDPEncoded,
                &cbIDPEncoded))
            goto ErrorReturn;

        rgExt[cExt].pszObjId = szOID_ISSUING_DIST_POINT;
        rgExt[cExt].fCritical = TRUE;
        rgExt[cExt].Value.pbData = pbIDPEncoded;
        rgExt[cExt].Value.cbData = cbIDPEncoded;
        cExt++;
    }

    Crl.cExtension = cExt;
    Crl.rgExtension = rgExt;

    if (!AllocAndEncodeObject(
            X509_CERT_CRL_TO_BE_SIGNED,
            &Crl,
            &pbCrlEncoded,
            &cbCrlEncoded
            ))
        goto ErrorReturn;

    if (!EncodeSignedContent(
            dwIssuer,
            pbCrlEncoded,
            cbCrlEncoded,
            ppbEncoded,
            pcbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbIssuerNameEncoded)
        TestFree(pbIssuerNameEncoded);
    if (pbBaseEncoded)
        TestFree(pbBaseEncoded);
    if (pbCDPEncoded)
        TestFree(pbCDPEncoded);
    if (pbIDPEncoded)
        TestFree(pbIDPEncoded);
    if (pbCrlEncoded)
        TestFree(pbCrlEncoded);
    for (i = 0; i < CERT_CNT; i++) {
        if (rgEntryExt[i].Value.pbData)
            TestFree(rgEntryExt[i].Value.pbData);
    }

    return fResult;
}

static BOOL EncodeCtl(DWORD dwCert, DWORD dwEncodeFlags, BYTE **ppbEncoded,
        DWORD *pcbEncoded)
{
    BOOL fResult;

    BYTE *pbNextUpdateLoc = NULL;
    DWORD cbNextUpdateLoc;
    BYTE *pbCtlEncoded = NULL;
    DWORD cbCtlEncoded;

    DWORD dwFlags;
    DWORD dwCtlFlags;
    DWORD dwUseFlag;
    DWORD i;

    struct {
        FILETIME    ft;
        DWORD       dwCert;
    } SequenceNumber;

    PCTL_USAGE pCtlUsage;           // not allocated

    BYTE rgbHash[CERT_CNT][MAX_HASH_LEN];
    BYTE rgbZero[1] = {0};

    BYTE NullDer[] = {0x05, 0x00};
    BYTE IntegerDer[] = {0x02, 0x01, 0x35};
    CRYPT_ATTR_BLOB rgAttrBlob[2] = {
            2, (BYTE *) NullDer,
            3, (BYTE *) IntegerDer
    };
    CRYPT_ATTRIBUTE rgAttr[] = {
        "1.2.3.4.5.0",
            1, rgAttrBlob,
        "1.2.1.1.1.1.1.1",
            2, rgAttrBlob
    };

    CMSG_SIGNER_ENCODE_INFO SignerInfo;
    CMSG_SIGNED_ENCODE_INFO SignInfo;
    CRYPT_ATTRIBUTE SignerAttr;
    CRYPT_ATTR_BLOB SignerAttrBlob;
    CERT_BLOB CertBlob;

    CTL_ENTRY rgEntry[CERT_CNT];
#define CTL_EXTENSION_CNT 1
    CERT_EXTENSION rgExt[CTL_EXTENSION_CNT];
    CTL_INFO Ctl;

    if (NULL == rgpCertContext[dwCert])
        goto ErrorReturn;

    dwFlags = CertPara[dwCert].dwFlags;

    // CTL
    memset(&Ctl, 0, sizeof(Ctl));
    Ctl.dwVersion = CTL_V1;

    dwCtlFlags = dwFlags & (CTL1_PARA_FLAG | CTL2_PARA_FLAG);
    dwUseFlag = 0;
    switch (dwCtlFlags) {
        case CTL1_PARA_FLAG:
            if (dwFlags & NO_EXT_PARA_FLAG)
                pCtlUsage = &rgCtlUsage[0];
            else {
                pCtlUsage = &rgCtlUsage[1];
                dwUseFlag = USE1_PARA_FLAG;
            }
            break;
        case CTL2_PARA_FLAG:
            pCtlUsage = &rgCtlUsage[2];
            dwUseFlag = USE2_PARA_FLAG;
            break;
        case CTL1_PARA_FLAG | CTL2_PARA_FLAG:
        default:
            pCtlUsage = &rgCtlUsage[3];
            break;
    }
    Ctl.SubjectUsage = *pCtlUsage;

    if (dwFlags & CTL2_PARA_FLAG) {
        DWORD dwIdx;
        if (dwFlags & TIME_INVALID_PARA_FLAG) {
            assert(dwFlags & DUPLICATE_PARA_FLAG);
            dwIdx = dwCert - 1;
        } else
            dwIdx = dwCert;
        Ctl.ListIdentifier.pbData = (BYTE *) CertPara[dwIdx].pszName;
        Ctl.ListIdentifier.cbData = strlen(CertPara[dwIdx].pszName);

        MySystemTimeToFileTime(&TestTime, &SequenceNumber.ft);
        SequenceNumber.dwCert = dwCert;
        Ctl.SequenceNumber.pbData = (BYTE *) &SequenceNumber;
        Ctl.SequenceNumber.cbData = sizeof(SequenceNumber);
    }


    {
        SYSTEMTIME SystemTime = TestTime;

        if (dwFlags & TIME_INVALID_PARA_FLAG) {
            SystemTime.wYear -=2;
            MySystemTimeToFileTime(&SystemTime, &Ctl.ThisUpdate);
            SystemTime.wYear++;
            MySystemTimeToFileTime(&SystemTime, &Ctl.NextUpdate);
        } else {
            MySystemTimeToFileTime(&SystemTime, &Ctl.ThisUpdate);
            if (dwUseFlag) {
                SystemTime.wYear++;
                MySystemTimeToFileTime(&SystemTime, &Ctl.NextUpdate);
            }
        }
    }

    Ctl.SubjectAlgorithm.pszObjId = szOID_OIWSEC_sha1;

    Ctl.cCTLEntry = 0;
    Ctl.rgCTLEntry = rgEntry;

    for (i = 0; i < CERT_CNT; i++) {
        if (CertPara[i].dwFlags & dwUseFlag) {
            DWORD j;
            DWORD cbHash;

            if (NULL == rgpCertContext[i])
                continue;

            j = Ctl.cCTLEntry++;
            memset(&rgEntry[j], 0, sizeof(rgEntry[j]));

            cbHash = MAX_HASH_LEN;
            if (CertGetCertificateContextProperty(
                    rgpCertContext[i],
                    CERT_SHA1_HASH_PROP_ID,
                    rgbHash[j],
                    &cbHash)) {
                rgEntry[j].SubjectIdentifier.pbData = rgbHash[j];
                rgEntry[j].SubjectIdentifier.cbData = cbHash;
            } else {
                PrintLastError(
                    "CertGetCertificateContextProperty(SHA1_HASH)");
                rgEntry[j].SubjectIdentifier.pbData = rgbZero;
                rgEntry[j].SubjectIdentifier.cbData = sizeof(rgbZero);
            }

            if (CertPara[i].dwFlags & ALL_EXT_PARA_FLAG) {
                rgEntry[j].cAttribute = sizeof(rgAttr) / sizeof(rgAttr[0]);
                rgEntry[j].rgAttribute = rgAttr;
            }
        }

    }

    if (!CreateNextUpdateLocation(
            dwCert,
            FALSE,              // fProp
            &pbNextUpdateLoc,
            &cbNextUpdateLoc))
        goto ErrorReturn;

    // Ctl Extensions

    rgExt[0].pszObjId = szOID_NEXT_UPDATE_LOCATION;
    rgExt[0].fCritical = FALSE;
    rgExt[0].Value.pbData = pbNextUpdateLoc;
    rgExt[0].Value.cbData = cbNextUpdateLoc;

    if (0 == (CertPara[dwCert].dwFlags & NO_EXT_PARA_FLAG)) {
        Ctl.cExtension = 1;
        Ctl.rgExtension = rgExt;
    }

    memset(&SignerInfo, 0, sizeof(SignerInfo));
    SignerInfo.cbSize = sizeof(SignerInfo);
    SignerInfo.pCertInfo = rgpCertContext[dwCert]->pCertInfo;
    if (CertPara[dwCert].dwFlags & DSS_PARA_FLAG) {
        if (CertPara[dwCert].dwFlags & DSS_512_PARA_FLAG)
            SignerInfo.hCryptProv = hDSS512CryptProv;
        else
            SignerInfo.hCryptProv = hDSSCryptProv;
    } else if (CertPara[dwCert].dwFlags & ENH_1024_PARA_FLAG)
        SignerInfo.hCryptProv = hEnh1024CryptProv;
    else if (CertPara[dwCert].dwFlags & ENH_2048_PARA_FLAG)
        SignerInfo.hCryptProv = hEnh2048CryptProv;
    else
        SignerInfo.hCryptProv = hRSACryptProv;
    SignerInfo.dwKeySpec = AT_SIGNATURE;
    SignerInfo.HashAlgorithm.pszObjId = szOID_OIWSEC_sha1;

    if (dwFlags & CTL2_PARA_FLAG) {
        // Signer Attributes
        memset(&SignerAttr, 0, sizeof(SignerAttr));
        SignerAttr.pszObjId = szOID_NEXT_UPDATE_LOCATION;
        SignerAttr.cValue = 1;
        SignerAttr.rgValue = &SignerAttrBlob;
        SignerAttrBlob.pbData = pbNextUpdateLoc;
        SignerAttrBlob.cbData = cbNextUpdateLoc;

        SignerInfo.cAuthAttr = 1;
        SignerInfo.rgAuthAttr = &SignerAttr;
        SignerInfo.cUnauthAttr = 1;
        SignerInfo.rgUnauthAttr = &SignerAttr;
    }

    memset(&SignInfo, 0, sizeof(SignInfo));
    SignInfo.cbSize = sizeof(SignInfo);
    if (dwUseFlag) {
        SignInfo.cSigners = 1;
        SignInfo.rgSigners = &SignerInfo;
        SignInfo.cCertEncoded = 1;
        CertBlob.pbData = rgpCertContext[dwCert]->pbCertEncoded;
        CertBlob.cbData = rgpCertContext[dwCert]->cbCertEncoded;
        SignInfo.rgCertEncoded = &CertBlob;
    }

    cbCtlEncoded = 0;
    if (!CryptMsgEncodeAndSignCTL(
            dwMsgEncodingType,
            &Ctl,
            &SignInfo,
            dwEncodeFlags,
            NULL,               // pbEncoded
            &cbCtlEncoded
            ) || 0 == cbCtlEncoded) {
        PrintLastError("EncodeCtl::CryptMsgEncodeAndSignCTL(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbCtlEncoded = (BYTE *) TestAlloc(cbCtlEncoded);
    if (pbCtlEncoded == NULL) goto ErrorReturn;
    if (!CryptMsgEncodeAndSignCTL(
            dwMsgEncodingType,
            &Ctl,
            &SignInfo,
            dwEncodeFlags,
            pbCtlEncoded,
            &cbCtlEncoded
            )) {
        PrintLastError("EncodeCtl::CryptMsgEncodeAndSignCTL");
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbCtlEncoded)
        TestFree(pbCtlEncoded);
    pbCtlEncoded = NULL;
    cbCtlEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbNextUpdateLoc)
        TestFree(pbNextUpdateLoc);
    *ppbEncoded = pbCtlEncoded;
    *pcbEncoded = cbCtlEncoded;

    return fResult;
}

static BOOL EncodeUpdateCtl(
    BOOL fTimeInvalid,
    LPSTR pszUsageObjId,
    LPSTR pszListIdentifier,
    LPWSTR pwszUrl,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded
    )
{
    BOOL fResult;

    BYTE *pbNextUpdateLoc = NULL;
    DWORD cbNextUpdateLoc;
    BYTE *pbCtlEncoded = NULL;
    DWORD cbCtlEncoded;

    CERT_BLOB CertBlob;
    CMSG_SIGNER_ENCODE_INFO SignerInfo;
    CMSG_SIGNED_ENCODE_INFO SignInfo;
    CERT_EXTENSION rgExt[1];
    CTL_INFO Ctl;

    if (NULL == rgpCertContext[UPDATE_CTL_SIGNER])
        goto ErrorReturn;

    // CTL
    memset(&Ctl, 0, sizeof(Ctl));
    Ctl.dwVersion = CTL_V1;
    Ctl.SubjectUsage.cUsageIdentifier = 1;
    Ctl.SubjectUsage.rgpszUsageIdentifier = &pszUsageObjId;

    Ctl.ListIdentifier.pbData = (BYTE *) pszListIdentifier;
    Ctl.ListIdentifier.cbData = strlen(pszListIdentifier);


    {
        SYSTEMTIME SystemTime = TestTime;

        if (fTimeInvalid) {
            SystemTime.wYear -=2;
            MySystemTimeToFileTime(&SystemTime, &Ctl.ThisUpdate);
            SystemTime.wYear++;
            MySystemTimeToFileTime(&SystemTime, &Ctl.NextUpdate);
        } else {
            MySystemTimeToFileTime(&SystemTime, &Ctl.ThisUpdate);
            SystemTime.wYear++;
            MySystemTimeToFileTime(&SystemTime, &Ctl.NextUpdate);
        }
    }

    Ctl.SubjectAlgorithm.pszObjId = szOID_OIWSEC_sha1;

    if (!CreateNextUpdateLocation(
            UPDATE_CTL_SIGNER,  // dwCert
            FALSE,              // fProp
            &pbNextUpdateLoc,
            &cbNextUpdateLoc,
            pwszUrl))
        goto ErrorReturn;

    // Ctl Extensions

    rgExt[0].pszObjId = szOID_NEXT_UPDATE_LOCATION;
    rgExt[0].fCritical = FALSE;
    rgExt[0].Value.pbData = pbNextUpdateLoc;
    rgExt[0].Value.cbData = cbNextUpdateLoc;

    Ctl.cExtension = 1;
    Ctl.rgExtension = rgExt;

    memset(&SignerInfo, 0, sizeof(SignerInfo));
    SignerInfo.cbSize = sizeof(SignerInfo);
    SignerInfo.pCertInfo = rgpCertContext[UPDATE_CTL_SIGNER]->pCertInfo;
    SignerInfo.hCryptProv = hRSACryptProv;
    SignerInfo.dwKeySpec = AT_SIGNATURE;
    SignerInfo.HashAlgorithm.pszObjId = szOID_OIWSEC_sha1;

    memset(&SignInfo, 0, sizeof(SignInfo));
    SignInfo.cbSize = sizeof(SignInfo);
    SignInfo.cSigners = 1;
    SignInfo.rgSigners = &SignerInfo;
    SignInfo.cCertEncoded = 1;
    CertBlob.pbData = rgpCertContext[UPDATE_CTL_SIGNER]->pbCertEncoded;
    CertBlob.cbData = rgpCertContext[UPDATE_CTL_SIGNER]->cbCertEncoded;
    SignInfo.rgCertEncoded = &CertBlob;

    cbCtlEncoded = 0;
    if (!CryptMsgEncodeAndSignCTL(
            dwMsgEncodingType,
            &Ctl,
            &SignInfo,
            0,                  // dwEncodeFlags
            NULL,               // pbEncoded
            &cbCtlEncoded
            ) || 0 == cbCtlEncoded) {
        PrintLastError("EncodeUpdateCtl::CryptMsgEncodeAndSignCTL(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbCtlEncoded = (BYTE *) TestAlloc(cbCtlEncoded);
    if (pbCtlEncoded == NULL) goto ErrorReturn;
    if (!CryptMsgEncodeAndSignCTL(
            dwMsgEncodingType,
            &Ctl,
            &SignInfo,
            0,                  // dwEncodeFlags
            pbCtlEncoded,
            &cbCtlEncoded
            )) {
        PrintLastError("EncodeUpdateCtl::CryptMsgEncodeAndSignCTL");
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbCtlEncoded)
        TestFree(pbCtlEncoded);
    pbCtlEncoded = NULL;
    cbCtlEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbNextUpdateLoc)
        TestFree(pbNextUpdateLoc);
    *ppbEncoded = pbCtlEncoded;
    *pcbEncoded = cbCtlEncoded;

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tstore\tstore.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tstore.cpp
//
//  Contents:   Cert Store API Tests
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    04-Mar-96   philh   created
//				07-Jun-96   HelleS	Added printing the command line
//              20-Aug-96   jeffspel name changes
//
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"
#include "crypthlp.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

//
// FIsWinNT: check OS type on x86.  On non-x86, assume WinNT
//

#ifdef _M_IX86

static BOOL WINAPI FIsWinNT(void) {

    static BOOL fIKnow = FALSE;
    static BOOL fIsWinNT = FALSE;

    OSVERSIONINFO osVer;

    if(fIKnow)
        return(fIsWinNT);

    memset(&osVer, 0, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if( GetVersionEx(&osVer) )
        fIsWinNT = (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

    // even on an error, this is as good as it gets
    fIKnow = TRUE;

   return(fIsWinNT);
}

#else

static BOOL WINAPI FIsWinNT(void) {
    return(TRUE);
}

#endif

static void PrintExpectedError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("%s got expected error => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

void PrintNoError(LPCSTR pszMsg)
{
    printf("%s failed => expected error\n", pszMsg);
}

static BOOL AddCert(HCERTSTORE hStore, LPSTR pszAddFilename,
        DWORD dwAddDisposition, BOOL fExpectError)
{
    BYTE *pbEncoded;
    DWORD cbEncoded;
    BOOL fResult;
    PCCERT_CONTEXT pCert = NULL;

    if (!ReadDERFromFile(pszAddFilename, &pbEncoded, &cbEncoded)) {
        PrintLastError("AddCert");
        return FALSE;
    }

    fResult = FALSE;
    if (!CertAddEncodedCertificateToStore(hStore, dwCertEncodingType,
            pbEncoded, cbEncoded, dwAddDisposition, &pCert)) {
        if (fExpectError)
            PrintExpectedError("CertAddEncodedCertificateToStore");
        else
            PrintLastError("CertAddEncodedCertificateToStore");
    } else {
        if (fExpectError)
            PrintNoError("CertAddEncodedCertificateToStore");
        else
            fResult = TRUE;
        printf("=====  Added Cert  =====\n");
        DisplayCert(pCert, 0, 0);
        CertFreeCertificateContext(pCert);
    }

    TestFree(pbEncoded);
    return fResult;
}

static BOOL ReadCert(
        HCERTSTORE hStore,
        LPSTR pszReadFilename,
        DWORD dwDisplayFlags)
{
    BOOL fResult;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    PCCERT_CONTEXT pCert;

    if (!ReadDERFromFile(pszReadFilename, &pbEncoded, &cbEncoded)) {
        PrintLastError("ReadCert");
        return FALSE;
    }

    pCert = CertCreateCertificateContext(
        dwCertEncodingType,
        pbEncoded,
        cbEncoded
        );
    if (pCert == NULL) {
        fResult = FALSE;
        PrintLastError("CertCreateCertificateContext");
    } else {
        fResult = TRUE;
        DisplayCert2(hStore, pCert, dwDisplayFlags);
        CertFreeCertificateContext(pCert);
    }

    TestFree(pbEncoded);
    return fResult;
}

// Attempt to read as a file containing an embedded PKCS#7 via SIP
static HCERTSTORE OpenSIPStoreFile(
    LPSTR pszStoreFilename)
{
    HCERTSTORE hStore = NULL;
    LPWSTR pwszStoreFilename = NULL;
    CRYPT_DATA_BLOB SignedData;
    memset(&SignedData, 0, sizeof(SignedData));
    DWORD dwGetEncodingType;

    GUID gSubject;
    SIP_DISPATCH_INFO SipDispatch;
    SIP_SUBJECTINFO SubjectInfo;

    if (NULL == (pwszStoreFilename = AllocAndSzToWsz(pszStoreFilename)))
        goto CommonReturn;

    if (!CryptSIPRetrieveSubjectGuid(
            pwszStoreFilename,
            NULL,                       // hFile
            &gSubject)) goto CommonReturn;

    memset(&SipDispatch, 0, sizeof(SipDispatch));
    SipDispatch.cbSize = sizeof(SipDispatch);
    if (!CryptSIPLoad(
            &gSubject,
            0,                  // dwFlags
            &SipDispatch)) goto CommonReturn;

    memset(&SubjectInfo, 0, sizeof(SubjectInfo));
    SubjectInfo.cbSize = sizeof(SubjectInfo);
    SubjectInfo.pgSubjectType = (GUID*) &gSubject;
    SubjectInfo.hFile = INVALID_HANDLE_VALUE;
    SubjectInfo.pwsFileName = pwszStoreFilename;
    // SubjectInfo.pwsDisplayName = 
    // SubjectInfo.lpSIPInfo = 
    // SubjectInfo.dwReserved = 
    // SubjectInfo.hProv = 
    // SubjectInfo.DigestAlgorithm =
    // SubjectInfo.dwFlags =
    SubjectInfo.dwEncodingType = dwMsgAndCertEncodingType;
    // SubjectInfo.lpAddInfo =
        
    if (!SipDispatch.pfGet(
            &SubjectInfo, 
            &dwGetEncodingType,
            0,                          // dwIndex
            &SignedData.cbData,
            NULL                        // pbSignedData
            ) || 0 == SignedData.cbData)
        goto CommonReturn;
    if (NULL == (SignedData.pbData = (BYTE *) TestAlloc(SignedData.cbData)))
        goto CommonReturn;
    if (!SipDispatch.pfGet(
            &SubjectInfo, 
            &dwGetEncodingType,
            0,                          // dwIndex
            &SignedData.cbData,
            SignedData.pbData
            ))
        goto CommonReturn;

    hStore = CertOpenStore(
        CERT_STORE_PROV_PKCS7,
        dwMsgAndCertEncodingType,
        0,                      // hCryptProv
        0,                      // dwFlags
        (const void *) &SignedData
        );

    if (hStore) {
        WCHAR wszGUID[128];
        StringFromGUID2(gSubject, wszGUID, 128);
        printf("Opening Store as SIP Subject GUID:: %S \n", wszGUID);
    }

CommonReturn:
    TestFree(pwszStoreFilename);
    TestFree(SignedData.pbData);
    return hStore;
}

static HCERTSTORE OpenCertStoreFile(
    LPSTR pszStoreFilename)
{
    HCERTSTORE hStore;

    if (hStore = OpenSIPStoreFile(pszStoreFilename))
        return hStore;

    return NULL;
}

static BOOL AddCrl(HCERTSTORE hStore, LPSTR pszAddFilename, 
        DWORD dwAddDisposition, BOOL fExpectError)
{
    BYTE *pbEncoded;
    DWORD cbEncoded;
    BOOL fResult;
    PCCRL_CONTEXT pCrl = NULL;

    if (!ReadDERFromFile(pszAddFilename, &pbEncoded, &cbEncoded)) {
        PrintLastError("AddCrl");
        return FALSE;
    }

    fResult = FALSE;
    if (!CertAddEncodedCRLToStore(hStore, dwCertEncodingType, pbEncoded,
            cbEncoded, dwAddDisposition, &pCrl)) {
        if (fExpectError)
            PrintExpectedError("CertAddEncodedCRLToStore");
        else
            PrintLastError("CertAddEncodedCRLToStore");
    } else {
        if (fExpectError)
            PrintNoError("CertAddEncodedCRLToStore");
        else
            fResult = TRUE;
        printf("=====  Added CRL  =====\n");
        DisplayCrl(pCrl, 0);
        CertFreeCRLContext(pCrl);
    }

    TestFree(pbEncoded);
    return fResult;
}

static BOOL ReadCrl(
        LPSTR pszReadFilename,
        DWORD dwDisplayFlags)
{
    BOOL fResult;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    PCCRL_CONTEXT pCrl;

    if (!ReadDERFromFile(pszReadFilename, &pbEncoded, &cbEncoded)) {
        PrintLastError("ReadCrl");
        return FALSE;
    }

    pCrl = CertCreateCRLContext(
        dwCertEncodingType,
        pbEncoded,
        cbEncoded
        );
    if (pCrl == NULL) {
        fResult = FALSE;
        PrintLastError("CertCreateCRLContext");
    } else {
        fResult = TRUE;
        DisplayCrl(pCrl, dwDisplayFlags);
        CertFreeCRLContext(pCrl);
    }

    TestFree(pbEncoded);
    return fResult;
}

// Attempt to read as a file containing an encoded CRL.
static HCERTSTORE OpenCrlStoreFile(
    LPSTR pszStoreFilename)
{
    HCERTSTORE hStore;
    BYTE *pbEncoded;
    DWORD cbEncoded;

    if (!ReadDERFromFile(pszStoreFilename, &pbEncoded, &cbEncoded))
        return NULL;
    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        return NULL;

    if (!CertAddEncodedCRLToStore(
            hStore,
            dwCertEncodingType,
            pbEncoded,
            cbEncoded,
            CERT_STORE_ADD_ALWAYS,
            NULL                    // ppCrlContext
            )) {
        CertCloseStore(hStore, 0);
        hStore = NULL;
    }

    TestFree(pbEncoded);
    return hStore;
}

static BOOL AddRootCtl(
    HCERTSTORE hStore,
    PCCTL_CONTEXT pCtl,
    DWORD dwAddDisposition,
    BOOL fExpectError
    )
{
    BOOL fResult;
    DWORD i;
    DWORD cCtlEntry = pCtl->pCtlInfo->cCTLEntry;
    PCTL_ENTRY pCtlEntry = pCtl->pCtlInfo->rgCTLEntry;
    HCERTSTORE hMsgStore = NULL;

    hMsgStore = CertOpenStore(
        CERT_STORE_PROV_MSG,
        dwMsgAndCertEncodingType,
        0,                      // hCryptProv
        0,                      // dwFlags
        (const void *) pCtl->hCryptMsg
        );

    if (NULL == hMsgStore) {
        PrintLastError("Open Msg Store");
        goto ErrorReturn;
    }

    // Loop through entries. Either add or remove the certificate from the
    // store

    for (i = 0; i< cCtlEntry; i++, pCtlEntry++) {
        PCRYPT_ATTRIBUTE pDelAttr;

        pDelAttr = CertFindAttribute(
            szOID_REMOVE_CERTIFICATE,
            pCtlEntry->cAttribute,
            pCtlEntry->rgAttribute
            );
        if (pDelAttr) {
            BYTE rgbDelValue[] = {0x02, 0x1, 0x1};
            if (0 == pDelAttr->cValue || 3 != pDelAttr->rgValue[0].cbData ||
                    0 != memcmp(pDelAttr->rgValue[0].pbData, rgbDelValue, 3))
                printf("Failed ==> bad delete attribute for Cert[%d]\n", i);
            else {
                PCCERT_CONTEXT pDelCert;

                pDelCert = CertFindCertificateInStore(
                    hStore,
                    0,                  // dwCertEncodingType
                    0,                  // dwFindFlags
                    CERT_FIND_SHA1_HASH,
                    (const void *) &pCtlEntry->SubjectIdentifier,
                    NULL                //pPrevCertContext
                    );
                if (pDelCert) {
                    if (CertDeleteCertificateFromStore(pDelCert))
                        printf("=====  Deleted Root Cert[%d]  =====\n", i);
                    else
                        printf("Failed ==> delete Cert[%d]\n", i);
                }
            }
        } else {
            PCCERT_CONTEXT pAddCert;

            pAddCert = CertFindCertificateInStore(
                hMsgStore,
                0,                  // dwCertEncodingType
                0,                  // dwFindFlags
                CERT_FIND_SHA1_HASH,
                (const void *) &pCtlEntry->SubjectIdentifier,
                NULL                //pPrevCertContext
                );
            if (pAddCert) {
                if (!CertSetCertificateContextPropertiesFromCTLEntry(
                        pAddCert,
                        pCtlEntry,
                        CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG
                        ))
                    printf("Failed ==> SetPropFromCTLEntry for Cert [%d]\n",
                        i);
                else {
                    if (!CertAddCertificateContextToStore(
                            hStore,
                            pAddCert,
                            dwAddDisposition,
                            NULL                // ppStoreContext
                            ))
                        printf("Failed ==> Add Cert [%d]\n", i);
                    else
                        printf("=====  Added Root Cert[%d]  =====\n", i);
                }
                CertFreeCertificateContext(pAddCert);
            } else
                printf("Failed ==> No Cert [%d]\n", i);
        }
    }

    fResult = TRUE;

CommonReturn:
    if (hMsgStore)
        CertCloseStore(hMsgStore, 0);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL AddCtl(HCERTSTORE hStore, LPSTR pszAddFilename, 
        DWORD dwAddDisposition, BOOL fExpectError)
{
    BYTE *pbEncoded;
    DWORD cbEncoded;
    BOOL fResult;
    PCCTL_CONTEXT pCtl = NULL;

    if (!ReadDERFromFile(pszAddFilename, &pbEncoded, &cbEncoded)) {
        PrintLastError("AddCtl");
        return FALSE;
    }

    // Determine if Root CTL
    pCtl = CertCreateCTLContext(
        dwMsgAndCertEncodingType,
        pbEncoded,
        cbEncoded
        );
    if (pCtl) {
        PCTL_USAGE pSubjectUsage = &pCtl->pCtlInfo->SubjectUsage;

        if (0 == pSubjectUsage->cUsageIdentifier ||
                0 != strcmp(pSubjectUsage->rgpszUsageIdentifier[0],
                        szOID_ROOT_LIST_SIGNER)) {
            CertFreeCTLContext(pCtl);
            pCtl = NULL;
        }
    }

    fResult = FALSE;
    if (pCtl) {
        fResult = AddRootCtl(
            hStore,
            pCtl,
            dwAddDisposition,
            fExpectError
            );
        CertFreeCTLContext(pCtl);
    } else if (!CertAddEncodedCTLToStore(hStore, dwMsgAndCertEncodingType, pbEncoded,
            cbEncoded, dwAddDisposition, &pCtl)) {
        if (fExpectError)
            PrintExpectedError("CertAddEncodedCTLToStore");
        else
            PrintLastError("CertAddEncodedCTLToStore");
    } else {
        if (fExpectError)
            PrintNoError("CertAddEncodedCTLToStore");
        else
            fResult = TRUE;
        printf("=====  Added CTL  =====\n");
        DisplayCtl(pCtl, 0, hStore);
        CertFreeCTLContext(pCtl);
    }

    TestFree(pbEncoded);
    return fResult;
}

static BOOL ReadCtl(
        LPSTR pszReadFilename,
        DWORD dwDisplayFlags)
{
    BOOL fResult;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    PCCTL_CONTEXT pCtl;

    if (!ReadDERFromFile(pszReadFilename, &pbEncoded, &cbEncoded)) {
        PrintLastError("ReadCtl");
        return FALSE;
    }

    pCtl = CertCreateCTLContext(
        dwMsgAndCertEncodingType,
        pbEncoded,
        cbEncoded
        );
    if (pCtl == NULL) {
        fResult = FALSE;
        PrintLastError("CertCreateCTLContext");
    } else {
        fResult = TRUE;
        DisplayCtl(pCtl, dwDisplayFlags, NULL);
        CertFreeCTLContext(pCtl);
    }

    TestFree(pbEncoded);
    return fResult;
}

// Attempt to read as a file containing an encoded CTL.
static HCERTSTORE OpenCtlStoreFile(
    LPSTR pszStoreFilename)
{
    HCERTSTORE hStore;
    BYTE *pbEncoded;
    DWORD cbEncoded;

    if (!ReadDERFromFile(pszStoreFilename, &pbEncoded, &cbEncoded))
        return NULL;
    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        goto CommonReturn;

    if (!CertAddEncodedCTLToStore(
            hStore,
            dwMsgAndCertEncodingType,
            pbEncoded,
            cbEncoded,
            CERT_STORE_ADD_ALWAYS,
            NULL                    // ppCtlContext
            )) {
        CertCloseStore(hStore, 0);
        hStore = NULL;
    }

CommonReturn:
    TestFree(pbEncoded);
    return hStore;
}

static PCCERT_CONTEXT GetNthCert(
    IN HCERTSTORE hStore,
    IN DWORD N
    )
{
    PCCERT_CONTEXT pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
        if (0 == N--)
            break;
    }
    return pCert;
}

static void SetKeyProvParams(
    IN PCCERT_CONTEXT pCert
    )
{
    CRYPT_KEY_PROV_INFO Info;
    CRYPT_KEY_PROV_PARAM Param[3];
    DWORD i;
    BYTE rgb[11*3];

    Info.pwszContainerName = L"Test Container With Parameters";
    Info.pwszProvName = L"test provider with parameters";
    Info.dwProvType = 77;
    Info.dwFlags = 0x12345678;
    Info.cProvParam = 3;
    Info.rgProvParam = Param;
    Info.dwKeySpec = 66;

    for (i = 0; i < sizeof(rgb); i++)
        rgb[i] = (BYTE) i;

    for (i = 0; i < 3; i++) {
        Param[i].dwParam = 0x10 + i;
        if (i == 0)
            Param[i].pbData = NULL;
        else
            Param[i].pbData = rgb;
        Param[i].cbData = i * 11;
        Param[i].dwFlags = 1 << i;
    }

    if (!CertSetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            0,                          // dwFlags
            &Info
            ))
        PrintLastError("CertSetCertificateContextProperty(KeyProvParams)");
}



static void Usage(void)
{
    printf("Usage: tstore [options] <StoreName>\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -b                    - Brief\n");
    printf("  -c                    - Verify ALL checks enabled\n");
    printf("  -cSign                - Verify Signature check enabled\n");
    printf("  -cTime                - Verify Time Validity check enabled\n");
    printf("  -d                    - Delete cert/CRL/CTL\n");
    printf("  -dALL                 - Delete all certs/CRLs/CTLs\n");
    printf("  -P                    - Set or Delete property\n");
    printf("  -PKey                 - Find or Delete KeyProvInfo property\n");
    printf("  -PSilentKey           - Silent Find or Delete KeyProvInfo property\n");
    printf("  -PArchive             - Find or Delete Archive property\n");
    printf("  -PKeyProvParam        - Set KeyProvInfo with parameters\n");
    printf("  -F                    - Test Force store close\n");
    printf("  -e<number>            - Cert encoding type\n");
    printf("  -f<number>            - Open dwFlags\n");
    printf("  -E                    - Error is expected for add, delete or set\n");
    printf("  -i<number>            - Cert/CRL/CTL index\n");
    printf("  -l                    - List (Default)\n");
    printf("  -R                    - Revocation (CRL)\n");
    printf("  -T                    - Trust (CTL)\n");
    printf("  -N                    - Enable change Notify\n");
    printf("  -C                    - Commit before close\n");
    printf("  -CForce               - Force Commit before close\n");
    printf("  -CClear               - Clear Commit before close\n");
    printf("  -s                    - Open the \"StoreName\" System store\n");
    printf("  -s<StoreProviderName> - Open using store provider\n");
    printf("  -v                    - Verbose\n");
    printf("  -u                    - UI Dialog Viewer\n");
    printf("  -a<filename>          - Add encoded cert/CRL/CTL from file\n");
    printf("  -A<filename>          - Add (replace) encoded cert/CRL/CTL from file\n");
    printf("  -I<filename>          - Add (inherit properties) encoded cert/CRL/CTL from file\n");
    printf("  -p<filename>          - Put encoded cert/CRL/CTL to file\n");
    printf("  -r<filename>          - Read encoded cert/CRL/CTL from file\n");
    printf("  -t                    - Save thumprints (digests/hashes) in store\n");
    printf("  -K                    - Display Public Key Thumbprint\n");
    printf("  -S[<SaveFilename>]    - Save store to file\n");
    printf("  -7[<SaveFilename>]    - PKCS# 7 formated save\n");
    printf("\n");
    printf("Default: list of certs for the store\n");
}


int _cdecl main(int argc, char * argv[])
{
    DWORD dwDisplayFlags = 0;
    LONG lIndex = -1;
    BOOL fDelete = FALSE;
    BOOL fDeleteAll = FALSE;
    DWORD dwOpenFlags = 0;
    BOOL fExpectError = FALSE;
    BOOL fProperty = FALSE;
    BOOL fKeyProperty = FALSE;
    BOOL fKeyProvParam = FALSE;
    BOOL fSilentKey = FALSE;
    BOOL fArchiveProperty = FALSE;
    DWORD dwContextType = CERT_STORE_CERTIFICATE_CONTEXT;
    BOOL fThumbprint = FALSE;
    BOOL fSystemStore = FALSE;
    BOOL fForceClose = FALSE;
    BOOL fSave = FALSE;
    BOOL fPKCS7Save = FALSE;
    DWORD dwAddDisposition = CERT_STORE_ADD_USE_EXISTING;
    LPSTR pszAddFilename = NULL;
    LPSTR pszPutFilename = NULL;
    LPSTR pszReadFilename = NULL;
    LPSTR pszStoreFilename = NULL;
    LPSTR pszSaveFilename = NULL;

    LPSTR pszStoreProvider = NULL;
    HCERTSTORE hStore;

    BOOL fNotify = FALSE;
    HANDLE hEvent = NULL;
    BOOL fCommit = FALSE;
    DWORD dwCommitFlags = 0;

    BOOL fDeferClose = FALSE;
#define DEFER_CERT_CNT  5
    PCCERT_CONTEXT rgpDeferCert[DEFER_CERT_CNT];
    memset(rgpDeferCert, 0, sizeof(rgpDeferCert));

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'c':
                dwDisplayFlags |= DISPLAY_CHECK_FLAG;
                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "Sign"))
                        dwDisplayFlags |= DISPLAY_CHECK_SIGN_FLAG;
                    else if (0 == _stricmp(argv[0]+2, "Time"))
                        dwDisplayFlags |= DISPLAY_CHECK_TIME_FLAG;
                    else {
                        printf("Need to specify -cSign | -cTime\n");
                        Usage();
                        return -1;
                    }
                }
                break;
            case 'b':
                dwDisplayFlags |= DISPLAY_BRIEF_FLAG;
                break;
            case 'v':
                dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                break;
            case 'u':
                dwDisplayFlags |= DISPLAY_UI_FLAG;
                break;
            case 'K':
                dwDisplayFlags |= DISPLAY_KEY_THUMB_FLAG;
                break;
            case 'd':
                if (argv[0][2]) {
                    if (0 != _stricmp(argv[0]+2, "ALL")) {
                        printf("Need to specify -dALL\n");
                        Usage();
                        return -1;
                    }
                    fDeleteAll = TRUE;
                } else
                    fDelete = TRUE;
                break;
            case 'P':
                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "Key"))
                        fKeyProperty = TRUE;
                    else if (0 == _stricmp(argv[0]+2, "Archive"))
                        fArchiveProperty = TRUE;
                    else if (0 == _stricmp(argv[0]+2, "KeyProvParam"))
                        fKeyProvParam = TRUE;
                    else if (0 == _stricmp(argv[0]+2, "SilentKey")) {
                        fKeyProperty = TRUE;
                        fSilentKey = TRUE;
                    } else {
                        printf("Need to specify -PKey\n");
                        Usage();
                        return -1;
                    }
                } else
                    fProperty = TRUE;
                break;
            case 'F':
                fForceClose = TRUE;
                break;
            case 'R':
                dwContextType = CERT_STORE_CRL_CONTEXT;
                break;
            case 'T':
                dwContextType = CERT_STORE_CTL_CONTEXT;
                break;
            case 'N':
                fNotify = TRUE;
                break;
            case 'C':
                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "Force"))
                        dwCommitFlags |= CERT_STORE_CTRL_COMMIT_FORCE_FLAG;
                    else if (0 == _stricmp(argv[0]+2, "Clear"))
                        dwCommitFlags |= CERT_STORE_CTRL_COMMIT_CLEAR_FLAG;
                    else {
                        printf("Need to specify -CForce or -CClear\n");
                        Usage();
                        return -1;
                    }
                }
                fCommit = TRUE;
                break;
            case 's':
                if (argv[0][2])
                    pszStoreProvider = argv[0]+2;
                fSystemStore = TRUE;
                break;
            case 't':
                fThumbprint = TRUE;
                break;
            case 'l':
                break;
            case 'e':
                dwCertEncodingType = (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;
            case 'f':
                dwOpenFlags = (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;
            case 'E':
                fExpectError = TRUE;
                break;
            case 'i':
                lIndex = (DWORD) strtol(argv[0]+2, NULL, 0);
                break;
            case 'a':
            case 'A':
            case 'I':
                pszAddFilename = argv[0]+2;
                if (*pszAddFilename == '\0') {
                    printf("Need to specify filename\n");
                    Usage();
                    return -1;
                }
                if (argv[0][1] == 'A')
                    dwAddDisposition = CERT_STORE_ADD_REPLACE_EXISTING;
                else if (argv[0][1] == 'I')
                    dwAddDisposition =
                        CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES;
                else
                    dwAddDisposition = CERT_STORE_ADD_USE_EXISTING;
                break;
            case 'p':
                pszPutFilename = argv[0]+2;
                if (*pszPutFilename == '\0') {
                    printf("Need to specify filename\n");
                    Usage();
                    return -1;
                }
                break;
            case 'r':
                pszReadFilename = argv[0]+2;
                if (*pszReadFilename == '\0') {
                    printf("Need to specify filename\n");
                    Usage();
                    return -1;
                }
                break;
            case '7':
                fPKCS7Save = TRUE;
            case 'S':
                fSave = TRUE;
                if (argv[0][2])
                    pszSaveFilename = argv[0]+2;
                break;
            case 'h':
            default:
                Usage();
                return -1;
            }
        } else
            pszStoreFilename = argv[0];
    }

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG)
        dwDisplayFlags &= ~DISPLAY_BRIEF_FLAG;


    if (pszStoreFilename == NULL) {
        printf("missing store filename\n");
        Usage();
        return -1;
    }

    if (pszSaveFilename == NULL) {
        if (!fSystemStore)
            pszSaveFilename = pszStoreFilename;
        else if (fSave) {
            printf("missing save filename\n");
            Usage();
            return -1;
        }
    }

    if (lIndex < 0 && (fDelete || pszPutFilename)) {
        printf("Must specify index value\n");
        Usage();
        return -1;
    }
    
    printf("command line: %s\n", GetCommandLine());
    {
        DWORD dwFileVersionMS;    /* e.g. 0x00030075 = "3.75" */
        DWORD dwFileVersionLS;    /* e.g. 0x00000031 = "0.31" */
        if (I_CryptGetFileVersion(L"crypt32.dll",
                &dwFileVersionMS, &dwFileVersionLS))
            printf("crypt32.dll file version:: %d.%d.%d.%d\n",
                (dwFileVersionMS >> 16) & 0xFFFF,
                dwFileVersionMS & 0xFFFF,
                (dwFileVersionLS >> 16) & 0xFFFF,
                dwFileVersionLS & 0xFFFF
                );
        else
            PrintLastError("I_CryptGetFileVersion(crypt32.dll)");
    }

    hStore = NULL;
    if (pszStoreProvider) {
        LPWSTR pwszStore;
        if (pwszStore = AllocAndSzToWsz(pszStoreFilename)) {
            hStore = CertOpenStore(
                pszStoreProvider,
                0,                      // dwEncodingType
                0,                      // hCryptProv
                dwOpenFlags,
                pwszStore
                );
            TestFree(pwszStore);
        }
        if (hStore == NULL) {
            if (dwOpenFlags & CERT_STORE_DELETE_FLAG) {
                if (0 == GetLastError())
                    printf("Successful delete store\n");
                else
                    PrintLastError("CertOpenStore(CERT_STORE_DELETE_FLAG)");
                return 0;
            } else {
                PrintLastError("CertOpenStore");
                return -1;
            }
        }
    } else if (!fSystemStore) {
        // Attempt to open as encoded certificate CRL or CTL file
        switch (dwContextType) {
            case CERT_STORE_CRL_CONTEXT:
                hStore = OpenCrlStoreFile(pszStoreFilename);
                break;
            case CERT_STORE_CTL_CONTEXT:
                hStore = OpenCtlStoreFile(pszStoreFilename);
                break;
            case CERT_STORE_CERTIFICATE_CONTEXT:
                hStore = OpenCertStoreFile(pszStoreFilename);
            default:
                break;
        }
    }
    
    if (NULL == hStore) {
        // Attempt to open the store
        if (!fSystemStore && fCommit) {
            dwOpenFlags |= CERT_FILE_STORE_COMMIT_ENABLE_FLAG;
            pszSaveFilename = NULL;
        }
        dwOpenFlags |= CERT_STORE_SET_LOCALIZED_NAME_FLAG;
        hStore = OpenStoreEx(fSystemStore, pszStoreFilename, dwOpenFlags);
        if (hStore == NULL)
            return -1;
    }

    if (dwOpenFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG) {
        printf("CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG was set\n");
        if (!fForceClose)
            fDeferClose = TRUE;
    }

#if 0
    if (fNotify && fSystemStore && !FIsWinNT()) {
        printf("Change Notify not supported for Win95 Registry\n");
        fNotify = FALSE;
    }
#endif

    if (fNotify) {
        // Create event to be notified
        if (NULL == (hEvent = CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL)))     // lpszEventName
            PrintLastError("CreateEvent");
        else {
            // Register the event to be signaled when the store changes
            if (!CertControlStore(
                    hStore,
                    0,              // dwFlags
                    CERT_STORE_CTRL_NOTIFY_CHANGE,
                    &hEvent
                    )) {
                PrintLastError("CertControlStore(NOTIFY_CHANGE)");
                fNotify = FALSE;
            } else
               Sleep(5);        // Allow callback thread to be scheduled
        }
    }

    if (pszReadFilename) {
        printf("Reading\n");
        switch (dwContextType) {
            case CERT_STORE_CRL_CONTEXT:
                ReadCrl(pszReadFilename, dwDisplayFlags);
                break;
            case CERT_STORE_CTL_CONTEXT:
                ReadCtl(pszReadFilename, dwDisplayFlags);
                break;
            default:
                ReadCert(hStore, pszReadFilename, dwDisplayFlags);
        }
    } else if (pszAddFilename) {
        BOOL fResult;
        printf("Adding\n");
        switch (dwContextType) {
            case CERT_STORE_CRL_CONTEXT:
                fResult = AddCrl(hStore, pszAddFilename, dwAddDisposition,
                    fExpectError);
                break;
            case CERT_STORE_CTL_CONTEXT:
                fResult = AddCtl(hStore, pszAddFilename, dwAddDisposition,
                    fExpectError);
                break;
            default:
                fResult = AddCert(hStore, pszAddFilename, dwAddDisposition,
                    fExpectError);
        }
        if (fResult)
            fSave = TRUE;
    } else if (fDeleteAll & !fArchiveProperty) {
        printf("Deleting All\n");
        if (CERT_STORE_CRL_CONTEXT == dwContextType) {
            PCCRL_CONTEXT pCrl;
            while (pCrl = CertEnumCRLsInStore(hStore, NULL)) {
                if (!CertDeleteCRLFromStore(pCrl)) {
                    if (fExpectError)
                        PrintExpectedError("CertDeleteCRLFromStore");
                    else
                        PrintLastError("CertDeleteCRLFromStore");
                    break;
                } else if (fExpectError)
                    PrintNoError("CertDeleteCRLFromStore");
                else
                    fSave = TRUE;
            }
        } else if (CERT_STORE_CTL_CONTEXT == dwContextType) {
            PCCTL_CONTEXT pCtl;
            while (pCtl = CertEnumCTLsInStore(hStore, NULL)) {
                if (!CertDeleteCTLFromStore(pCtl)) {
                    if (fExpectError)
                        PrintExpectedError("CertDeleteCTLFromStore");
                    else
                        PrintLastError("CertDeleteCTLFromStore");
                    break;
                } else if (fExpectError)
                    PrintNoError("CertDeleteCTLFromStore");
                else
                    fSave = TRUE;
            }
        } else {
            PCCERT_CONTEXT pCert;
            while (pCert = CertEnumCertificatesInStore(hStore, NULL)) {
                if (!CertDeleteCertificateFromStore(pCert)) {
                    if (fExpectError)
                        PrintExpectedError("CertDeleteCertificateFromStore");
                    else
                        PrintLastError("CertDeleteCertificateFromStore");
                    break;
                } else if (fExpectError)
                    PrintNoError("CertDeleteCertificateFromStore");
                else
                    fSave = TRUE;
            }
        }
    } else if (CERT_STORE_CRL_CONTEXT == dwContextType) {
        BOOL fFound = FALSE;
        LONG i;
        PCCRL_CONTEXT pCrl = NULL;
        DWORD dwFlags;

        for (i = 0;; i++) {
            dwFlags = CERT_STORE_TIME_VALIDITY_FLAG;
            pCrl = CertGetCRLFromStore(
                hStore,
                NULL,   // pIssuerContext
                pCrl,
                &dwFlags);
            if (pCrl == NULL)
                break;
            if ((lIndex >= 0) && (lIndex != i))
                continue;
            fFound = TRUE;
            if (fProperty) {
                CRYPT_DATA_BLOB Data;
                BYTE rgbAux[] = {0xDE, 0xAD, 0xBE, 0xEF};
                Data.pbData = rgbAux;
                Data.cbData = sizeof(rgbAux);
                if (!CertSetCRLContextProperty(
                        pCrl,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        &Data
                        )) {
                    if (fExpectError)
                        PrintExpectedError("CertSetCRLContextProperty");
                    else
                        PrintLastError("CertSetCRLContextProperty");
                } else if (fExpectError)
                    PrintNoError("CertSetCRLContextProperty");
                else
                    fSave = TRUE;
            }
            if (fDelete) {
                printf("Deleting\n");
                if (!CertDeleteCRLFromStore(pCrl)) {
                    if (fExpectError)
                        PrintExpectedError("CertDeleteCRLFromStore");
                    else
                        PrintLastError("CertDeleteCRLFromStore");
                } else if (fExpectError)
                    PrintNoError("CertDeleteCRLFromStore");
                else
                    fSave = TRUE;
                break;
            } else if (pszPutFilename) {
                printf("Putting\n");
                if (!WriteDERToFile(
                        pszPutFilename,
                        pCrl->pbCrlEncoded,
                        pCrl->cbCrlEncoded
                        ))
                    PrintLastError("Put CRL::WriteDERToFile");
                CertFreeCRLContext(pCrl);
                break;
            } else {
                if (fThumbprint)
                    fSave = TRUE;
                printf("=====  %d  =====\n", i);
                DisplayCrl(pCrl, dwDisplayFlags);
                DisplayVerifyFlags("CRL", dwFlags);
                if (lIndex == i) {
                    CertFreeCRLContext(pCrl);
                    break;
                }
            }
        }

        if (!fFound)
            printf("CRL not found\n");
    } else if (CERT_STORE_CTL_CONTEXT == dwContextType) {
        BOOL fFound = FALSE;
        LONG i;
        PCCTL_CONTEXT pCtl = NULL;

        for (i = 0;; i++) {
            pCtl = CertEnumCTLsInStore(
                hStore,
                pCtl);
            if (pCtl == NULL)
                break;
            if ((lIndex >= 0) && (lIndex != i))
                continue;
            fFound = TRUE;
            if (fProperty) {
                CRYPT_DATA_BLOB Data;
                BYTE rgbAux[] = {0xDE, 0xAD, 0xBE, 0xEF};
                Data.pbData = rgbAux;
                Data.cbData = sizeof(rgbAux);
                if (!CertSetCTLContextProperty(
                        pCtl,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        &Data
                        )) {
                    if (fExpectError)
                        PrintExpectedError("CertSetCTLContextProperty");
                    else
                        PrintLastError("CertSetCTLContextProperty");
                } else if (fExpectError)
                    PrintNoError("CertSetCTLContextProperty");
                else
                    fSave = TRUE;
            }
            if (fDelete) {
                printf("Deleting\n");
                if (!CertDeleteCTLFromStore(pCtl)) {
                    if (fExpectError)
                        PrintExpectedError("CertDeleteCTLFromStore");
                    else
                        PrintLastError("CertDeleteCTLFromStore");
                } else if (fExpectError)
                    PrintNoError("CertDeleteCTLFromStore");
                else
                    fSave = TRUE;
                break;
            } else if (pszPutFilename) {
                printf("Putting\n");
                if (!WriteDERToFile(
                        pszPutFilename,
                        pCtl->pbCtlEncoded,
                        pCtl->cbCtlEncoded
                        ))
                    PrintLastError("Put CTL::WriteDERToFile");
                CertFreeCTLContext(pCtl);
                break;
            } else {
                if (fThumbprint)
                    fSave = TRUE;
                printf("=====  %d  =====\n", i);
                DisplayCtl(pCtl, dwDisplayFlags, hStore);
                if (lIndex == i) {
                    CertFreeCTLContext(pCtl);
                    break;
                }
            }
        }

        if (!fFound)
            printf("CTL not found\n");
    } else {
        BOOL fFound = FALSE;
        LONG i;
        PCCERT_CONTEXT pCert = NULL;

        pCert = NULL;
        for (i = 0;; i++) {
            pCert = CertEnumCertificatesInStore(
                hStore,
                pCert);
            if (pCert == NULL)
                break;
            if ((lIndex >= 0) && (lIndex != i))
                continue;
            fFound = TRUE;

            if (fForceClose)
                CertDuplicateCertificateContext(pCert);
            else if (fDeferClose) {
                CertFreeCertificateContext(rgpDeferCert[0]);
                rgpDeferCert[0] = CertDuplicateCertificateContext(pCert);
            }
            if (fProperty && !fDelete) {
                CRYPT_DATA_BLOB Data;
                BYTE rgbAux[] = {0xDE, 0xAD, 0xBE, 0xEF};
                Data.pbData = rgbAux;
                Data.cbData = sizeof(rgbAux);
                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        &Data
                        )) {
                    if (fExpectError)
                        PrintExpectedError("CertSetCertificateContextProperty");
                    else
                        PrintLastError("CertSetCertificateContextProperty");
                } else if (fExpectError)
                    PrintNoError("CertSetCertificateContextProperty");
                else
                    fSave = TRUE;

                // Test that we properly update the PROV_HANDLE and KEY_SPEC
                // properties
                HCRYPTPROV hProv = (HCRYPTPROV) 0x12345678;
                HCRYPTPROV hProv2 = 0;
                DWORD dwKeySpec = 0xdeadbeef;
                DWORD dwKeySpec2 = 0;
                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_KEY_PROV_HANDLE_PROP_ID,
                        CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                        (void *) hProv
                        ))
                    PrintLastError(
                        "CertSetCertificateContextProperty(PROV_HANDLE)");
                else if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_KEY_SPEC_PROP_ID,
                        0,                          // dwFlags
                        &dwKeySpec
                        ))
                    PrintLastError(
                        "CertSetCertificateContextProperty(KEY_SPEC)");
                else {
                    DWORD cbData = sizeof(hProv);
                    CERT_KEY_CONTEXT KeyContext;
                    if (!CertGetCertificateContextProperty(
                            pCert,
                            CERT_KEY_PROV_HANDLE_PROP_ID,
                            &hProv2,
                            &cbData))
                        PrintLastError(
                            "CertGetCertificateContextProperty(PROV_HANDLE)");
                    else if (hProv2 != hProv)
                        PrintLastError(
                            "PROV_HANDLE property not updated properly\n");

                    cbData = sizeof(dwKeySpec);
                    if (!CertGetCertificateContextProperty(
                            pCert,
                            CERT_KEY_SPEC_PROP_ID,
                            &dwKeySpec2,
                            &cbData))
                        PrintLastError(
                            "CertGetCertificateContextProperty(KEY_SPEC)");
                    else if (dwKeySpec2 != dwKeySpec)
                        PrintLastError(
                            "KEY_SPEC property not updated properly\n");

                    cbData = sizeof(KeyContext);
                    if (!CertGetCertificateContextProperty(
                            pCert,
                            CERT_KEY_CONTEXT_PROP_ID,
                            &KeyContext,
                            &cbData))
                        PrintLastError(
                            "CertGetCertificateContextProperty(KEY_CONTEXT)");
                    else if (KeyContext.dwKeySpec != dwKeySpec ||
                            KeyContext.hCryptProv != hProv)
                        PrintLastError(
                            "KEY_CONTEXT property not updated properly\n");
                }

                hProv = 0;
                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_KEY_PROV_HANDLE_PROP_ID,
                        0,                          // dwFlags
                        (void *) hProv
                        ))
                    PrintLastError(
                        "CertSetCertificateContextProperty(PROV_HANDLE)");
            }

            if (fKeyProperty && !fDelete) {
                if (!CryptFindCertificateKeyProvInfo(
                        pCert,
                        fSilentKey ? CRYPT_FIND_SILENT_KEYSET_FLAG : 0,
                        NULL            // pvReserved
                        )) {
                    if (fExpectError)
                        PrintExpectedError("CryptFindCertificateKeyProvInfo");
                    else
                        PrintLastError("CryptFindCertificateKeyProvInfo");
                } else {
                    printf("Found KEY_PROV_INFO property\n");

                    if (fExpectError)
                        PrintNoError("CryptFindCertificateKeyProvInfo");
                    else {
                        HCRYPTPROV hProv1 = 0;
                        HCRYPTPROV hProv2 = 0;
                        DWORD dwKeySpec1;
                        DWORD dwKeySpec2;
                        BOOL fCallerFreeProv;

                        fSave = TRUE;
                        
                        dwKeySpec1 = 0x12341111;
                        fCallerFreeProv = TRUE;
                        if (!CryptAcquireCertificatePrivateKey(
                                pCert,
                                (fSilentKey ? CRYPT_ACQUIRE_SILENT_FLAG : 0) |
                                CRYPT_ACQUIRE_CACHE_FLAG |
                                    CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
                                NULL,                           // pvReserved
                                &hProv1,
                                &dwKeySpec1,
                                &fCallerFreeProv
                                ))
                            PrintLastError("CryptAcquireCertificatePrivateKey");
                        else if (fCallerFreeProv)
                            printf("failed => cached acquire returned FreeProv\n");
                        dwKeySpec2 = 0x12342222;
                        fCallerFreeProv = FALSE;
                        if (!CryptAcquireCertificatePrivateKey(
                                pCert,
                                (fSilentKey ? CRYPT_ACQUIRE_SILENT_FLAG : 0) |
                                    CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
                                NULL,                           // pvReserved
                                &hProv2,
                                &dwKeySpec2,
                                &fCallerFreeProv
                                ))
                            PrintLastError("CryptAcquireCertificatePrivateKey");
                        else {
                            if (!fCallerFreeProv)
                                printf("failed => uncached acquire didn't return FreeProv\n");
                            if (hProv2 == hProv1)
                                printf("failed => uncached == cached hProv\n");
                            if (dwKeySpec2 != dwKeySpec1)
                                printf("failed => uncached != cached dwKeySpec\n");

                            CryptReleaseContext(hProv2, 0);
                        }

                        if (hProv1) {
                            dwKeySpec2 = 0x12343333;
                            fCallerFreeProv = TRUE;
                            if (!CryptAcquireCertificatePrivateKey(
                                    pCert,
                                    (fSilentKey ? CRYPT_ACQUIRE_SILENT_FLAG : 0) |
                                        CRYPT_ACQUIRE_CACHE_FLAG |
                                        CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
                                    NULL,                           // pvReserved
                                    &hProv2,
                                    &dwKeySpec2,
                                    &fCallerFreeProv
                                    ))
                                PrintLastError("CryptAcquireCertificatePrivateKey");
                            else {
                                if (fCallerFreeProv)
                                    printf("failed => uncached acquire returned FreeProv\n");
                                if (hProv2 != hProv1)
                                    printf("failed => cached != cached hProv\n");
                                if (dwKeySpec2 != dwKeySpec1)
                                    printf("failed => cached != cached dwKeySpec\n");
                            }
                        }
                    }
                }
            }

            if (fArchiveProperty) {
                CRYPT_DATA_BLOB ArchiveBlob = { 0, NULL };

                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_ARCHIVED_PROP_ID,
                        0,                          // dwFlags
                        (fDelete || fDeleteAll) ? NULL : &ArchiveBlob
                        )) {
                    if (fExpectError)
                        PrintExpectedError(
                            "CertSetCertificateContextProperty(ARCHIVE)");
                    else
                        PrintLastError(
                            "CertSetCertificateContextProperty(ARCHIVE)");
                }
            } else if (fDelete) {
                if (fProperty || fKeyProperty) {
                    DWORD PropId;

                    if (fKeyProperty) {
                        printf("Deleting KEY_PROV_INFO property\n");
                        PropId = CERT_KEY_PROV_INFO_PROP_ID;
                    } else {
                        printf("Deleting property\n");
                        PropId = CERT_FIRST_USER_PROP_ID;
                    }
                    if (!CertSetCertificateContextProperty(
                            pCert,
                            PropId,
                            0,                          // dwFlags
                            NULL
                            )) {
                        if (fExpectError)
                            PrintExpectedError("CertSetCertificateContextProperty");
                        else
                            PrintLastError("CertSetCertificateContextProperty");
                    } else if (fExpectError)
                        PrintNoError("CertSetCertificateContextProperty");
                    else
                        fSave = TRUE;
                    CertFreeCertificateContext(pCert);
                } else {
                    printf("Deleting\n");
                    if (!CertDeleteCertificateFromStore(pCert)) {
                        if (fExpectError)
                            PrintExpectedError("CertDeleteCertificateFromStore");
                        else
                            PrintLastError("CertDeleteCertificateFromStore");
                    } else if (fExpectError)
                        PrintNoError("CertDeleteCertificateFromStore");
                    else
                        fSave = TRUE;
                }
                break;
            } else if (pszPutFilename) {
                printf("Putting\n");
                if (!WriteDERToFile(
                        pszPutFilename,
                        pCert->pbCertEncoded,
                        pCert->cbCertEncoded
                        ))
                    PrintLastError("Put Cert::WriteDERToFile");
                CertFreeCertificateContext(pCert);
                break;
            } else {
                if (fKeyProvParam) {
                    printf("Setting KeyProvInfo parameters\n");
                    SetKeyProvParams(pCert);
                }

                if (fThumbprint)
                    fSave = TRUE;
                printf("=====  %d  =====\n", i);
                DisplayCert(pCert, dwDisplayFlags);
                if (lIndex == i) {
                    CertFreeCertificateContext(pCert);
                    break;
                }
            }
        }

        if (!fFound)
            printf("Certificate not found\n");

        if (fForceClose) {
            // Do incomplete enumerations to test out external store
            // logic
            pCert = GetNthCert(hStore, 0);
            CertFreeCertificateContext(pCert);

            pCert = GetNthCert(hStore, 0);
            GetNthCert(hStore, (i-1)/2);
            GetNthCert(hStore, i-1);
        } else if (fDeferClose) {
            rgpDeferCert[1] = GetNthCert(hStore, 0);
            CertFreeCertificateContext(rgpDeferCert[1]);

            rgpDeferCert[1] = GetNthCert(hStore, 0);
            rgpDeferCert[2] = GetNthCert(hStore, (i-1)/2);
            rgpDeferCert[3] = GetNthCert(hStore, i-1);
        }
    }

    if (fSave && pszSaveFilename)
        SaveStoreEx(hStore, fPKCS7Save, pszSaveFilename);

    if (fCommit) {
        printf("Committing store changes::");
        if (dwCommitFlags & CERT_STORE_CTRL_COMMIT_FORCE_FLAG)
            printf(" FORCE");
        if (dwCommitFlags & CERT_STORE_CTRL_COMMIT_CLEAR_FLAG)
            printf(" CLEAR");
        printf("\n");
        if (!CertControlStore(
                hStore,
                dwCommitFlags,
                CERT_STORE_CTRL_COMMIT,
                NULL
                ))
            PrintLastError("CertControlStore(COMMIT)");
    }

    if (fNotify) {
        BOOL fSignaled;
        // Check if event was signaled
        if (WAIT_TIMEOUT == WaitForSingleObjectEx(
                hEvent,
                100,                        // dwMilliseconds
                FALSE                       // bAlertable
                ))
            fSignaled = FALSE;
        else
            fSignaled = TRUE;

        if (!fSignaled) {
            printf("No store change notify\n");
            if (pszAddFilename || fDeleteAll || fDelete || fProperty)
                printf("failed => expected notify for add, delete or property\n");
        } else {
            printf("There was a store change notify\n");
            if (!(pszAddFilename || fDeleteAll || fDelete || fProperty))
                printf("failed => unexpected notify\n");

            if (!CertControlStore(
                    hStore,
                    0,              // dwFlags
                    CERT_STORE_CTRL_RESYNC,
                    NULL            // pvCtrlPara
                    ))
                PrintLastError("CertControlStore(RESYNC)");
            else {
                printf("\n");
                printf(">>>>>  After Resync  >>>>>\n");
                DisplayStore(hStore, DISPLAY_BRIEF_FLAG);
            }
        }
    }

    if (hEvent)
        CloseHandle(hEvent);

    if (fForceClose) {
        CertDuplicateStore(hStore);
        if (CertCloseStore(hStore, 
                CERT_CLOSE_STORE_CHECK_FLAG | CERT_CLOSE_STORE_FORCE_FLAG))
            printf("failed => CertCloseStore(FORCE) didn't fail as expected\n");
        else
            printf("CertCloseStore(FORCE) returned expected nonzero status: 0x%x\n",
                GetLastError());
    } else  if (fDeferClose) {
        // Check if any defered certificates
        DWORD i;

        fDeferClose = FALSE;
        for (i = 0; i < DEFER_CERT_CNT; i++) {
            if (rgpDeferCert[i]) {
                fDeferClose = TRUE;
                break;
            }
        }

        if (fDeferClose) {
            CertDuplicateStore(hStore);
            CertCloseStore(hStore, 0);

            if (CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG))
                printf("failed => CertCloseStore(DEFER) didn't fail as expected\n");
            else
                printf("CertCloseStore(DEFER) returned expected nonzero status: 0x%x\n",
                    GetLastError());
            for (i = 0; i < DEFER_CERT_CNT; i++) {
                CertFreeCertificateContext(rgpDeferCert[i]);
            }
        } else {
            if (!CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG))
                PrintLastError("CertCloseStore(DEFER)");
        }
    } else {
        if (!CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG))
            PrintLastError("CertCloseStore");
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\ttrust\hashexample.cpp ===
//+-------------------------------------------------------------------------
//  File:       hashexample.cpp
//
//  Contents:   An example calling WTHelperGetFileHash to get the hash
//              of a signed file
//--------------------------------------------------------------------------

#include <windows.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <wintrustp.h>

#define MAX_HASH_LEN    20


// Returns ERROR_SUCCESS if the file has a valid signed hash
LONG GetSignedFileHashExample(
    IN LPCWSTR pwszFilename,
    OUT BYTE rgbFileHash[MAX_HASH_LEN],
    OUT DWORD *pcbFileHash,
    OUT ALG_ID *pHashAlgid
    )
{
    return WTHelperGetFileHash(
        pwszFilename,
        0,              // dwFlags
        NULL,           // pvReserved
        rgbFileHash,
        pcbFileHash,
        pHashAlgid
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tstore4\tstore4.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tstore4.cpp
//
//  Contents:   Test certificate store resync and notify change functions
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    28-Aug-97   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


static void Usage(void)
{
    printf("Usage: tstore4 [options] <SystemStoreName>\n");
    printf("Options are:\n");
    printf("  -h            - This message\n");
    printf("  -v            - Verbose\n");
    printf("  -t<number>    - Timeout (milliseconds, default INFINITE)\n");
    printf("  -f<number>    - Flags\n");
    printf("  -i            - Iterations (default to infinite)\n");
    printf("  -a            - Auto Resync\n");
    printf("  -A            - Auto Resync (user prompt to display)\n");
    printf("  -s            - System store (ignored)\n");
    printf("  -RefreshCUGP  - Refresh client CurrentUser GPT\n");
    printf("  -RefreshLMGP  - Refresh client LocalMachine GPT\n");
    printf("\n");
}

typedef BOOL (WINAPI *PFN_REFRESH_POLICY)(
    IN BOOL bMachine
    );

#define sz_USERENV_DLL                  "userenv.dll"
#define sz_RefreshPolicy                "RefreshPolicy"

static void CallRefreshPolicy(
    IN BOOL fMachine
    )
{
    HMODULE hDll = NULL;

    PFN_REFRESH_POLICY pfnRefreshPolicy;

    if (NULL == (hDll = LoadLibraryA(sz_USERENV_DLL))) {
        PrintLastError("LoadLibrary(userenv.dll)");
        goto ErrorReturn;
    }

    if (NULL == (pfnRefreshPolicy = 
            (PFN_REFRESH_POLICY) GetProcAddress(
                hDll, sz_RefreshPolicy))) {
        PrintLastError("GetProcAddress(RefreshPolicy)");
        goto ErrorReturn;
    }

    if (!pfnRefreshPolicy(fMachine)) {
        PrintLastError("RefreshPolicy");
        goto ErrorReturn;
    }

ErrorReturn:
    if (hDll)
        FreeLibrary(hDll);

    return;
}


int _cdecl main(int argc, char * argv[]) 
{
    BOOL fResult;
    int status = 0;
    DWORD i;
    DWORD dwError;
    DWORD dwDisplayFlags = DISPLAY_BRIEF_FLAG;
    HCERTSTORE hStoreToClose = NULL;
    HCERTSTORE hStore = NULL;
    DWORD dwFlags = CERT_STORE_READONLY_FLAG;
    DWORD dwMilliseconds = INFINITE;
    BOOL fAutoResync = FALSE;
    BOOL fUserPrompt = FALSE;
    DWORD dwIterations = 0;

    BOOL fRefreshPolicy = FALSE;
    BOOL fMachine = FALSE;

    HANDLE hEvent = NULL;
    HANDLE hEvent2 = NULL;
    HANDLE hEventToClose = NULL;

    LPSTR pszSystemName = NULL;     // not allocated

    SYSTEMTIME SystemTime;
    FILETIME FileTime;

    while (--argc>0) {
        if (**++argv == '-')
        {
            if (0 == _stricmp(argv[0]+1, "RefreshCUGP")) {
                fRefreshPolicy = TRUE;
                fMachine = FALSE;
            } else if (0 == _stricmp(argv[0]+1, "RefreshLMGP")) {
                fRefreshPolicy = TRUE;
                fMachine = TRUE;
            } else {
                switch(argv[0][1])
                {

                case 'v':
                    dwDisplayFlags = DISPLAY_VERBOSE_FLAG;
                    break;
                case 'i':
                    dwIterations = strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'f':
                    dwFlags = strtoul(argv[0]+2, NULL, 0);
                    break;
                case 't':
                    dwMilliseconds = strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'A':
                    fUserPrompt = TRUE;
                case 'a':
                    fAutoResync = TRUE;
                    break;

                case 's':
                    break;
                case 'h':
                default:
                    goto BadUsage;
                }
            }
        } else {
            if (pszSystemName) {
                printf("Too many names starting with:: %s\n", argv[0]);
                goto BadUsage;
            }
            pszSystemName = argv[0];
        }
    }


    printf("command line: %s\n", GetCommandLine());

    if (fRefreshPolicy) {
        CallRefreshPolicy(fMachine);
        goto SuccessReturn;
    }

    if (NULL == pszSystemName) {
        printf("Missing <SystemStoreName>\n");
        goto BadUsage;
    }

    hStore = OpenStoreEx(TRUE, pszSystemName, dwFlags);

    if (NULL == hStore) {
        PrintLastError("CertOpenStore");
        goto ErrorReturn;
    }

    // Create event to be notified
    if (NULL == (hEvent = CreateEvent(
            NULL,       // lpsa
            FALSE,      // fManualReset
            FALSE,      // fInitialState
            NULL))) {   // lpszEventName
        PrintLastError("CreateEvent");
        goto ErrorReturn;
    }

    // Create second event to be notified
    if (NULL == (hEvent2 = CreateEvent(
            NULL,       // lpsa
            FALSE,      // fManualReset
            FALSE,      // fInitialState
            NULL))) {   // lpszEventName
        PrintLastError("CreateEvent");
        goto ErrorReturn;
    }


    if (!fUserPrompt) {
        hStoreToClose = OpenStoreEx(TRUE, pszSystemName, dwFlags);
        if (NULL == hStoreToClose) {
            PrintLastError("CertOpenStore(StoreToClose)");
            goto ErrorReturn;
        }

        if (NULL == (hEventToClose = CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL))) {   // lpszEventName
            PrintLastError("CreateEvent");
            goto ErrorReturn;
        }

        // Register the event to be signaled when the store changes
        if (!CertControlStore(
                hStoreToClose,
                0,              // dwFlags
                CERT_STORE_CTRL_NOTIFY_CHANGE,
                &hEventToClose
                )) {
            PrintLastError("CertControlStore(NOTIFY_CHANGE)");
            goto ErrorReturn;
        }

        // Register second event to be signaled when the store changes
        if (!CertControlStore(
                hStoreToClose,
                0,              // dwFlags
                CERT_STORE_CTRL_NOTIFY_CHANGE,
                &hEventToClose
                )) {
            PrintLastError("CertControlStore(NOTIFY_CHANGE)");
            goto ErrorReturn;
        }

        // Register the event to be signaled when the store changes
        if (!CertControlStore(
                hStore,
                0,              // dwFlags
                CERT_STORE_CTRL_NOTIFY_CHANGE,
                &hEvent
                )) {
            PrintLastError("CertControlStore(NOTIFY_CHANGE)");
            goto ErrorReturn;
        }

        // Register second event to be signaled when the store changes
        if (!CertControlStore(
                hStore,
                0,              // dwFlags
                CERT_STORE_CTRL_NOTIFY_CHANGE,
                &hEvent2
                )) {
            PrintLastError("CertControlStore(NOTIFY_CHANGE)");
            goto ErrorReturn;
        }

        CertCloseStore(hStoreToClose, 0);
        hStoreToClose = NULL;
    }

    if (fAutoResync) {
        printf("Auto Resync is enabled\n");
        if (!CertControlStore(
                hStore,
                0,              // dwFlags
                CERT_STORE_CTRL_AUTO_RESYNC,
                NULL            // pvCtrlPara
                )) {
            PrintLastError("CertControlStore(AUTO_RESYNC)");
            goto ErrorReturn;
        }
    }

    // Loop and wait for store changes
    i = 0;
    while (TRUE) {
        if (fUserPrompt) {
            int c;
            fputs("Waiting to sync (q)uit ->", stdout);
            fflush(stdin);
            fflush(stdout);
            c = getchar();
            if ('q' == c)
                break;
        } else {
            DWORD dwWait;
            dwWait = WaitForSingleObjectEx(
                    hEvent,
                    dwMilliseconds,
                    FALSE                       // bAlertable
                    );
            if (!(WAIT_OBJECT_0 == dwWait || WAIT_TIMEOUT == dwWait)) {
                PrintLastError("WaitForSingleObjectEx");
                goto ErrorReturn;
            }

        }

        i++;

        GetSystemTime(&SystemTime);
        SystemTimeToFileTime(&SystemTime, &FileTime);

        printf("\n");
        if (fAutoResync) {
            printf(">>>>>  Auto Resync[%d] at: %s  >>>>>\n",
                i, FileTimeText(&FileTime));

            if (!fUserPrompt) {
                if (!CertControlStore(
                        hStore,
                        0,              // dwFlags
                        CERT_STORE_CTRL_RESYNC,
                        &hEvent
                        )) {
                    PrintLastError("CertControlStore(RESYNC, for AutoResync)");
                    goto ErrorReturn;
                }
            }

            DisplayStore(hStore, dwDisplayFlags);
        } else {
            printf(">>>>>  Before Resync[%d]  >>>>>\n", i);
            DisplayStore(hStore, dwDisplayFlags);

            if (!CertControlStore(
                    hStore,
                    0,              // dwFlags
                    CERT_STORE_CTRL_RESYNC,
                    fUserPrompt ? NULL : &hEvent
                    )) {
                PrintLastError("CertControlStore(RESYNC)");
                goto ErrorReturn;
            }


            printf("\n");
            printf(">>>>>  After Resync[%d] at: %s  >>>>>\n",
                i, FileTimeText(&FileTime));
            DisplayStore(hStore, dwDisplayFlags);
        }

        if (!fUserPrompt) {
            // Check that the second event is still signalled
            DWORD dwWait;
            dwWait = WaitForSingleObjectEx(
                    hEvent2,
                    0,
                    FALSE                       // bAlertable
                    );
            if (WAIT_OBJECT_0 != dwWait) {
                printf("@@@@ second event NOT signaled 0x%x @@@@\n", dwWait);
            } else {
                printf("second event signalled\n");
                if (!CertControlStore(
                        hStore,
                        0,              // dwFlags
                        CERT_STORE_CTRL_RESYNC,
                        &hEvent2
                        )) {
                    PrintLastError(
                        "CertControlStore(RESYNC, for second event)");
                    goto ErrorReturn;
                }
            }
        }

        if (0 != dwIterations && i == dwIterations)
            break;
    }

SuccessReturn:
    status = 0;

CommonReturn:
    if (hEvent)
        CloseHandle(hEvent);
    if (hEvent2)
        CloseHandle(hEvent2);
    if (hEventToClose)
        CloseHandle(hEventToClose);
    if (hStoreToClose)
        CertCloseStore(hStoreToClose, 0);
    if (hStore)
        CertCloseStore(hStore, 0);
    return status;

BadUsage:
    Usage();
    status = -1;
    goto CommonReturn;

ErrorReturn:
    status = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tstore5\tstore5.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tstore5.cpp
//
//  Contents:   Test certificate store collection and context link functions
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    06-Sep-97   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


static void Usage(void)
{
    printf("Usage: tstore5 [options] <StoreName1> <StoreName2>\n");
    printf("Options are:\n");
    printf("  -h                - This message\n");
    printf("  -C                - Collection tests (default)\n");
    printf("  -L                - Context Link tests\n");
    printf("  -C -L             - Context Links enumerated in Collection\n");
    printf("  -R                - Replace contexts that exist\n");
    printf("  -A                - Always add a new context\n");
    printf("  -P                - Set property\n");
    printf("  -v                - Verbose\n");
    printf("  -b                - Brief\n");
    printf("  -f<number>        - Open System Store Flags\n");
    printf("\n");
    printf("If <StoreName> has embedded \".\", File. Otherwise System Store\n");
}


int _cdecl main(int argc, char * argv[]) 
{
    int status;
    DWORD i;
    DWORD dwDisplayFlags = 0;
    DWORD dwOpenFlags = 0;
    DWORD dwAddDisposition = CERT_STORE_ADD_USE_EXISTING;
    BOOL fVerbose = FALSE;
    BOOL fProperty = FALSE;

#define COLLECTION_TEST_FLAG    0x1
#define LINK_TEST_FLAG          0x2
    DWORD dwTestFlags = 0;

#define MAX_STORE_CNT       32
    DWORD dwStoreCnt = 0;
    LPCSTR rgpszStore[MAX_STORE_CNT];
    HCERTSTORE rghStore[MAX_STORE_CNT];
    memset(rghStore, 0, sizeof(rghStore));
    HCERTSTORE hCollectionStore = NULL;
    HCERTSTORE hLinkStore = NULL;

    PCCERT_CONTEXT pSiblingCert = NULL;
    PCCRL_CONTEXT pSiblingCrl = NULL;
    PCCTL_CONTEXT pSiblingCtl = NULL;

    PCCERT_CONTEXT pLinkCert = NULL;
    PCCRL_CONTEXT pLinkCrl = NULL;
    PCCTL_CONTEXT pLinkCtl = NULL;

    DWORD dwCertAddCnt = 0;
    DWORD dwCrlAddCnt = 0;
    DWORD dwCtlAddCnt = 0;

    while (--argc>0) {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {

            case 'C':
                dwTestFlags |= COLLECTION_TEST_FLAG;
                break;
            case 'L':
                dwTestFlags |= LINK_TEST_FLAG;
                break;
            case 'v':
                fVerbose = TRUE;
                dwDisplayFlags = DISPLAY_VERBOSE_FLAG;
                break;
            case 'b':
                dwDisplayFlags = DISPLAY_BRIEF_FLAG;
                break;
            case 'f':
                dwOpenFlags = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'R':
                dwAddDisposition = CERT_STORE_ADD_REPLACE_EXISTING;
                break;
            case 'A':
                dwAddDisposition = CERT_STORE_ADD_ALWAYS;
                break;
            case 'P':
                fProperty = TRUE;
                break;

            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            if (MAX_STORE_CNT <= dwStoreCnt) {
                printf("Too many store names starting with:: %s\n", argv[0]);
                goto BadUsage;
            }
            rgpszStore[dwStoreCnt++] = argv[0];
        }
    }


    printf("command line: %s\n", GetCommandLine());

    if (0 == dwStoreCnt) {
        printf("Missing store names\n");
        goto BadUsage;
    }

    // Attempt to open the store names
    for (i = 0; i < dwStoreCnt; i++) {
        DWORD dwFlags;
        BOOL fSystemStore;
        LPCSTR psz;
        char ch;

        // Check if store name has an embedded ".".
        fSystemStore = TRUE;
        psz = rgpszStore[i];
        while (ch = *psz++) {
            if ('.' == ch) {
                fSystemStore = FALSE;
                break;
            }
        }

        
        if (fSystemStore &&
                0 == (dwOpenFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
            dwFlags = dwOpenFlags | CERT_SYSTEM_STORE_CURRENT_USER;
        else
            dwFlags = dwOpenFlags;

        rghStore[i] = OpenSystemStoreOrFile(fSystemStore, rgpszStore[i],
            dwOpenFlags);
    }

    if (0 == dwTestFlags)
        dwTestFlags = COLLECTION_TEST_FLAG;

    if (dwTestFlags & COLLECTION_TEST_FLAG) {
        // Open collection store
        hCollectionStore = CertOpenStore(
            CERT_STORE_PROV_COLLECTION,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            );
        if (NULL == hCollectionStore) {
            PrintLastError("CertOpenStore(COLLECTION)");
            goto ErrorReturn;
        }
    }

    if (dwTestFlags & LINK_TEST_FLAG) {
        HCERTSTORE hParentStore;

        // Open memory store to hold the context links
        hLinkStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            );
        if (NULL == hLinkStore) {
            PrintLastError("CertOpenStore(MEMORY)");
            goto ErrorReturn;
        }

        if (dwTestFlags & COLLECTION_TEST_FLAG) {
            if (!CertAddStoreToCollection(
                    hCollectionStore,
                    hLinkStore,
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                    0                                       // dwPriority
                    )) {
                PrintLastError("CertAddStoreToCollection");
                goto ErrorReturn;
            }
            hParentStore = hCollectionStore;
        } else
            hParentStore = hLinkStore;

        // Loop through stores and add the certificate, CRL and CTL contexts
        // as links
        for (i = 0; i < dwStoreCnt; i++) {
            HCERTSTORE hStore;
            PCCERT_CONTEXT pCert;
            PCCRL_CONTEXT pCrl;
            PCCTL_CONTEXT pCtl;
            DWORD dwCrlFlags;

            if (NULL == (hStore = rghStore[i]))
                continue;

            pCert = NULL;
            while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
                if (!CertAddCertificateLinkToStore(
                        hLinkStore,
                        pCert,
                        dwAddDisposition,
                        (0 == dwCertAddCnt) ? &pLinkCert : NULL
                        )) {
                    PrintLastError("CertAddCertificateLinkToStore");
                    goto ErrorReturn;
                }
                if (0 == dwCertAddCnt) {
                    if (NULL == pLinkCert) {
                        printf("failed => didn't return cert link\n");
                        goto ErrorReturn;
                    }
                    pSiblingCert = CertDuplicateCertificateContext(pCert);
                }
                dwCertAddCnt++;

                if (CertAddCertificateLinkToStore(
                        hLinkStore,
                        pCert,
                        CERT_STORE_ADD_NEW,
                        NULL                    // ppStoreCert
                        ))
                    printf("failed => expected CertAddCertificateLinkToStore(ADD_NEW) to fail\n");
                else if (CRYPT_E_EXISTS != GetLastError()) {
                    PrintLastError("CertAddCertificateLinkToStore(ADD_NEW)");
                    printf("failed => expected CRYPT_E_EXISTS\n");
                    
                }
            }

            dwCrlFlags = 0;
            pCrl = NULL;
            while (pCrl = CertGetCRLFromStore(hStore, NULL, pCrl,
                    &dwCrlFlags)) {
                if (!CertAddCRLLinkToStore(
                        hLinkStore,
                        pCrl,
                        dwAddDisposition,
                        (0 == dwCrlAddCnt) ? &pLinkCrl : NULL
                        )) {
                    PrintLastError("CertAddCRLLinkToStore");
                    goto ErrorReturn;
                }
                if (0 == dwCrlAddCnt) {
                    if (NULL == pLinkCrl) {
                        printf("failed => didn't return crl link\n");
                        goto ErrorReturn;
                    }
                    pSiblingCrl = CertDuplicateCRLContext(pCrl);
                }
                dwCrlAddCnt++;

                if (CertAddCRLLinkToStore(
                        hLinkStore,
                        pCrl,
                        CERT_STORE_ADD_NEW,
                        NULL                    // ppStoreCrl
                        ))
                    printf("failed => expected CertAddCRLLinkToStore(ADD_NEW) to fail\n");
                else if (CRYPT_E_EXISTS != GetLastError()) {
                    PrintLastError("CertAddCRLLinkToStore(ADD_NEW)");
                    printf("failed => expected CRYPT_E_EXISTS\n");
                    
                }
            }

            pCtl = NULL;
            while (pCtl = CertEnumCTLsInStore(hStore, pCtl)) {
                if (!CertAddCTLLinkToStore(
                        hLinkStore,
                        pCtl,
                        dwAddDisposition,
                        (0 == dwCtlAddCnt) ? &pLinkCtl : NULL
                        )) {
                    PrintLastError("CertAddCTLLinkToStore");
                    goto ErrorReturn;
                }
                if (0 == dwCtlAddCnt) {
                    if (NULL == pLinkCtl) {
                        printf("failed => didn't return crl link\n");
                        goto ErrorReturn;
                    }
                    pSiblingCtl = CertDuplicateCTLContext(pCtl);
                }
                dwCtlAddCnt++;

                if (CertAddCTLLinkToStore(
                        hLinkStore,
                        pCtl,
                        CERT_STORE_ADD_NEW,
                        NULL                    // ppStoreCtl
                        ))
                    printf("failed => expected CertAddCTLLinkToStore(ADD_NEW) to fail\n");
                else if (CRYPT_E_EXISTS != GetLastError()) {
                    PrintLastError("CertAddCTLLinkToStore(ADD_NEW)");
                    printf("failed => expected CRYPT_E_EXISTS\n");
                    
                }
            }
        }

        printf("Added %d Certificates\n", dwCertAddCnt);
        printf("Added %d CRLs\n", dwCrlAddCnt);
        printf("Added %d CTLs\n", dwCtlAddCnt);

        printf("\n");
        printf("$$$$$  Certificate Context Links  $$$$$\n");
        DisplayStore(hParentStore, dwDisplayFlags);

        if (fProperty) {
            CRYPT_DATA_BLOB LinkSetData;
            BYTE rgbLinkSet[4] = {0xDE, 0xAD, 0xBE, 0xEF};
            LinkSetData.pbData = rgbLinkSet;
            LinkSetData.cbData = sizeof(rgbLinkSet);
            CRYPT_DATA_BLOB SiblingSetData;
            BYTE rgbSiblingSet[4] = {0xDE, 0xAF, 0xCA, 0xFE};
            SiblingSetData.pbData = rgbSiblingSet;
            SiblingSetData.cbData = sizeof(rgbSiblingSet);
            BYTE rgbGet[4];
            DWORD cbData;

            if (pLinkCert) {
                printf("Setting Certificate Context Link Property\n");

                // First make sure the property is deleted
                CertSetCertificateContextProperty(
                        pLinkCert,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        NULL
                        );
                cbData = sizeof(rgbGet);
                if (CertGetCertificateContextProperty(
                        pLinkCert,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData) || CRYPT_E_NOT_FOUND != GetLastError()) {
                    printf("failed => expected link property to be deleted\n");
                    PrintLastError("CertGetCertificateContextProperty(LINK)");
                }

                cbData = sizeof(rgbGet);
                if (CertGetCertificateContextProperty(
                        pSiblingCert,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData) || CRYPT_E_NOT_FOUND != GetLastError()) {
                    printf("failed => expected sibling property to be deleted\n");
                    PrintLastError("CertGetCertificateContextProperty(SIBLING)");
                }

                // Set property in link. It should also be visible in sibling
                cbData = sizeof(rgbGet);
                memset(rgbGet, 0, sizeof(rgbGet));
                if (!CertSetCertificateContextProperty(
                        pLinkCert,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        &LinkSetData
                        ))
                    PrintLastError("CertSetCertificateContextProperty(LINK)");
                else if (!CertGetCertificateContextProperty(
                        pSiblingCert,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData))
                    PrintLastError("CertGetCertificateContextProperty(SIBLING)");
                else if (cbData != sizeof(rgbLinkSet) ||
                        0 != memcmp(rgbGet, rgbLinkSet, cbData))
                    printf("failed => cert sibling not updated with link property\n");

                // Set property in sibling. It should also be visible in link
                cbData = sizeof(rgbGet);
                memset(rgbGet, 0, sizeof(rgbGet));
                if (!CertSetCertificateContextProperty(
                        pSiblingCert,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        &SiblingSetData
                        ))
                    PrintLastError("CertSetCertificateContextProperty(SIBLING)");
                else if (!CertGetCertificateContextProperty(
                        pLinkCert,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData))
                    PrintLastError("CertGetCertificateContextProperty(LINK)");
                else if (cbData != sizeof(rgbSiblingSet) ||
                        0 != memcmp(rgbGet, rgbSiblingSet, cbData))
                    printf("failed => cert link not updated with sibling property\n");
            }

            if (pLinkCrl) {
                printf("Setting CRL Context Link Property\n");

                // First make sure the property is deleted
                CertSetCRLContextProperty(
                        pLinkCrl,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        NULL
                        );
                cbData = sizeof(rgbGet);
                if (CertGetCRLContextProperty(
                        pLinkCrl,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData) || CRYPT_E_NOT_FOUND != GetLastError()) {
                    printf("failed => expected link property to be deleted\n");
                    PrintLastError("CertGetCRLContextProperty(LINK)");
                }

                cbData = sizeof(rgbGet);
                if (CertGetCRLContextProperty(
                        pSiblingCrl,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData) || CRYPT_E_NOT_FOUND != GetLastError()) {
                    printf("failed => expected sibling property to be deleted\n");
                    PrintLastError("CertGetCRLContextProperty(SIBLING)");
                }

                // Set property in link. It should also be visible in sibling
                cbData = sizeof(rgbGet);
                memset(rgbGet, 0, sizeof(rgbGet));
                if (!CertSetCRLContextProperty(
                        pLinkCrl,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        &LinkSetData
                        ))
                    PrintLastError("CertSetCRLContextProperty(LINK)");
                else if (!CertGetCRLContextProperty(
                        pSiblingCrl,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData))
                    PrintLastError("CertGetCRLContextProperty(SIBLING)");
                else if (cbData != sizeof(rgbLinkSet) ||
                        0 != memcmp(rgbGet, rgbLinkSet, cbData))
                    printf("failed => CRL sibling not updated with link property\n");

                // Set property in sibling. It should also be visible in link
                cbData = sizeof(rgbGet);
                memset(rgbGet, 0, sizeof(rgbGet));
                if (!CertSetCRLContextProperty(
                        pSiblingCrl,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        &SiblingSetData
                        ))
                    PrintLastError("CertSetCRLContextProperty(SIBLING)");
                else if (!CertGetCRLContextProperty(
                        pLinkCrl,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData))
                    PrintLastError("CertGetCRLContextProperty(LINK)");
                else if (cbData != sizeof(rgbSiblingSet) ||
                        0 != memcmp(rgbGet, rgbSiblingSet, cbData))
                    printf("failed => CRL link not updated with sibling property\n");
            }

            if (pLinkCtl) {
                printf("Setting CTL Context Link Property\n");

                // First make sure the property is deleted
                CertSetCTLContextProperty(
                        pLinkCtl,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        NULL
                        );
                cbData = sizeof(rgbGet);
                if (CertGetCTLContextProperty(
                        pLinkCtl,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData) || CRYPT_E_NOT_FOUND != GetLastError()) {
                    printf("failed => expected link property to be deleted\n");
                    PrintLastError("CertGetCTLContextProperty(LINK)");
                }

                cbData = sizeof(rgbGet);
                if (CertGetCTLContextProperty(
                        pSiblingCtl,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData) || CRYPT_E_NOT_FOUND != GetLastError()) {
                    printf("failed => expected sibling property to be deleted\n");
                    PrintLastError("CertGetCTLContextProperty(SIBLING)");
                }

                // Set property in link. It should also be visible in sibling
                cbData = sizeof(rgbGet);
                memset(rgbGet, 0, sizeof(rgbGet));
                if (!CertSetCTLContextProperty(
                        pLinkCtl,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        &LinkSetData
                        ))
                    PrintLastError("CertSetCTLContextProperty(LINK)");
                else if (!CertGetCTLContextProperty(
                        pSiblingCtl,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData))
                    PrintLastError("CertGetCTLContextProperty(SIBLING)");
                else if (cbData != sizeof(rgbLinkSet) ||
                        0 != memcmp(rgbGet, rgbLinkSet, cbData))
                    printf("failed => CTL sibling not updated with link property\n");

                // Set property in sibling. It should also be visible in link
                cbData = sizeof(rgbGet);
                memset(rgbGet, 0, sizeof(rgbGet));
                if (!CertSetCTLContextProperty(
                        pSiblingCtl,
                        CERT_FIRST_USER_PROP_ID,
                        0,                          // dwFlags
                        &SiblingSetData
                        ))
                    PrintLastError("CertSetCTLContextProperty(SIBLING)");
                else if (!CertGetCTLContextProperty(
                        pLinkCtl,
                        CERT_FIRST_USER_PROP_ID,
                        rgbGet,
                        &cbData))
                    PrintLastError("CertGetCTLContextProperty(LINK)");
                else if (cbData != sizeof(rgbSiblingSet) ||
                        0 != memcmp(rgbGet, rgbSiblingSet, cbData))
                    printf("failed => CTL link not updated with sibling property\n");
            }
        }

        if (pLinkCert) {
            CertDeleteCertificateFromStore(pLinkCert);
            pLinkCert = NULL;
        }
        if (pLinkCrl) {
            CertDeleteCRLFromStore(pLinkCrl);
            pLinkCrl = NULL;
        }
        if (pLinkCtl) {
            CertDeleteCTLFromStore(pLinkCtl);
            pLinkCtl = NULL;
        }
    } else {
        PCCERT_CONTEXT pCert;

        for (i = 0; i < dwStoreCnt; i++) {
            if (NULL == rghStore[i])
                continue;
            if (!CertAddStoreToCollection(
                    hCollectionStore,
                    rghStore[i],
                    0,                      // dwUpdateFlags
                    i                       // dwPriority
                    )) {
                PrintLastError("CertAddStoreToCollection");
                goto ErrorReturn;
            }
        }
        printf("\n");
        printf("$$$$$  Collection Stores  $$$$$\n");
        DisplayStore(hCollectionStore, dwDisplayFlags);


        // Get first cert and duplicate. It should be in last store.
        // Remove the last store and the second to last store. Continue
        // the enumeration. 
        if (pCert = CertEnumCertificatesInStore(hCollectionStore, NULL)) {
            pLinkCert = CertDuplicateCertificateContext(pCert);
            if (0 < dwStoreCnt && rghStore[dwStoreCnt - 1]) {
                CertRemoveStoreFromCollection(
                    hCollectionStore,
                    rghStore[dwStoreCnt - 1]
                    );
                // Also close the last store
                CertCloseStore(rghStore[dwStoreCnt - 1], 0);
                rghStore[dwStoreCnt - 1] = NULL;
            }
            if (1 < dwStoreCnt && rghStore[dwStoreCnt - 2])
                CertRemoveStoreFromCollection(
                    hCollectionStore,
                    rghStore[dwStoreCnt - 2]
                    );

            printf("$$$$$  Collection Certificates after removing last 2 stores  $$$$$\n");
            i = 0;
            while (pCert = CertEnumCertificatesInStore(hCollectionStore,
                    pCert)) {
                printf("=====  %d  =====\n", i);
                DisplayCert(pCert, DISPLAY_BRIEF_FLAG);
                i++;
            }
        }
    }

    status = 0;

CommonReturn:
    if (pSiblingCert)
        CertFreeCertificateContext(pSiblingCert);
    if (pLinkCert)
        CertFreeCertificateContext(pLinkCert);
    if (pLinkCrl)
        CertFreeCRLContext(pLinkCrl);
    if (pSiblingCrl)
        CertFreeCRLContext(pSiblingCrl);
    if (pLinkCtl)
        CertFreeCTLContext(pLinkCtl);
    if (pSiblingCtl)
        CertFreeCTLContext(pSiblingCtl);

    for (i = 1; i < dwStoreCnt; i++) {
        if (rghStore[i])
            CertCloseStore(rghStore[i], 0);
    }

    if (hCollectionStore) {
        if (!CertCloseStore(hCollectionStore, CERT_CLOSE_STORE_CHECK_FLAG))
            PrintLastError("CertCloseStore(COLLECTION)");
    }
    if (hLinkStore) {
        if (!CertCloseStore(hLinkStore, CERT_CLOSE_STORE_CHECK_FLAG))
            PrintLastError("CertCloseStore(LINK)");
    }

    if (0 < dwStoreCnt) {
        if (rghStore[0]) {
            if (!CertCloseStore(rghStore[0], CERT_CLOSE_STORE_CHECK_FLAG))
                PrintLastError("CertCloseStore(SIBLING[0])");
        }
    }

    return status;

BadUsage:
    Usage();
    status = -1;
    goto CommonReturn;

ErrorReturn:
    status = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tstore3\tstore3.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tstore3.cpp
//
//  Contents:   Cert Store API Tests: 
//               - CertGetSubjectCertificateFromStore: serial numbers with
//                  leading 0's or 0xFF's
//               - Open two system stores. Ensure certs and CRLs are
//                   written through
//               - CertStoreSave: test SaveToMemory for serialized and PKCS7
//               - Call CertOpenSystemStoreW
//               - Get hash property for a created context
//               - Do a CertVerifySubjectCertificateContext for a
//                   certificate in a store and a certificate context.
//                   Should pass for both a store certificate and 
//                   a certificate context. The certificate context
//                   uses the default hCryptProv.
//               - Close a store with a not freed certificate context.
//                   Should get a warning at closing. 
//               - Delete and recalculate the hash property for a
//                   certificate context after the store has been closed.
//               - Delete the certificate context after the store has
//                   been closed
//               - Duplicate a certificate. Delete it from the store.
//                   Also delete its duplicate. Close the store.
//               - Check that CertCloseStore preserves last error
//               - Win95 test (Win95 has following registry limitations:
//                  Max single key value of 16K, max total value length
//                  per key of 64K)
//  
//                  - Write 8 certificates > 10k to same system store
//                  - Write same certificate to two system stores
//                  - Set large property > 16K to force certificates to
//                    be saved to a file.
//                  - Verify written properties.
//                  - Delete large property. File should be deleted and
//                    certificate stored in registry.
//                  - Rewrite large property. Delete certificate.
//               - Check CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG
//
//  Functions:  main
//
//  History:    11-Jan-97   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#define SIGNATURE_ALG_OBJID     szOID_RSA_MD5RSA
#define TEST_ISSUER_NAME        "TestIssuer"
static HCRYPTPROV hCryptProv = 0;

static void PrintExpectedError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("%s got expected error => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

void PrintNoError(LPCSTR pszMsg)
{
    printf("%s failed => expected error\n", pszMsg);
}

static BOOL EncodeIssuer(
    OUT BYTE **ppbIssuerEncoded,
    OUT DWORD *pcbIssuerEncoded
    )
{
    BOOL fResult;
    BYTE *pbIssuerEncoded = NULL;
    DWORD cbIssuerEncoded;

    CERT_RDN_ATTR rgAttr[1];
    CERT_RDN rgRDN[1];
    CERT_NAME_INFO Name;

    Name.cRDN = 1;
    Name.rgRDN = rgRDN;
    rgRDN[0].cRDNAttr = 1;
    rgRDN[0].rgRDNAttr = rgAttr;

    rgAttr[0].pszObjId = szOID_COMMON_NAME;
    rgAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
    rgAttr[0].Value.pbData = (BYTE *) TEST_ISSUER_NAME;
    rgAttr[0].Value.cbData = strlen(TEST_ISSUER_NAME);

    CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            NULL,               // pbEncoded
            &cbIssuerEncoded
            );
    if (cbIssuerEncoded == 0) {
        PrintLastError("EncodeIssuer::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbIssuerEncoded = (BYTE *) TestAlloc(cbIssuerEncoded);
    if (pbIssuerEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            pbIssuerEncoded,
            &cbIssuerEncoded
            )) {
        PrintLastError("EncodeIssuer::CryptEncodeObject");
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    *ppbIssuerEncoded = pbIssuerEncoded;
    *pcbIssuerEncoded = cbIssuerEncoded;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    if (pbIssuerEncoded) {
        TestFree(pbIssuerEncoded);
        pbIssuerEncoded = 0;
    }
    cbIssuerEncoded = 0;
    goto CommonReturn;
}

static BOOL GetPublicKey(
    PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo)
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;
    DWORD dwKeySpec;

    dwKeySpec = AT_SIGNATURE;
    CryptExportPublicKeyInfo(
        hCryptProv,
        dwKeySpec,
        dwCertEncodingType,
        NULL,               // pPubKeyInfo
        &cbPubKeyInfo
        );
    if (cbPubKeyInfo == 0) {
        PrintLastError("GetPublicKey::CryptExportPublicKeyInfo(cb == 0)");
        goto ErrorReturn;
    }
    pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) TestAlloc(cbPubKeyInfo);
    if (pPubKeyInfo == NULL) goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hCryptProv,
            dwKeySpec,
            dwCertEncodingType,
            pPubKeyInfo,
            &cbPubKeyInfo
            )) {
        PrintLastError("GetPublicKey::CryptExportPublicKeyInfo");
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    *ppPubKeyInfo = pPubKeyInfo;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    if (pPubKeyInfo) {
        TestFree(pPubKeyInfo);
        pPubKeyInfo = NULL;
    }
    goto CommonReturn;
}

static BOOL EncodeCert(
    IN PCRYPT_INTEGER_BLOB pSerialNumber,
    OUT BYTE **ppbCertEncoded,
    OUT DWORD *pcbCertEncoded
    )
{
    BOOL fResult;
    BYTE *pbIssuerEncoded = NULL;
    DWORD cbIssuerEncoded;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded;
    CERT_INFO Cert;
    
    if (!EncodeIssuer(&pbIssuerEncoded, &cbIssuerEncoded)) goto ErrorReturn;

    // PUBLIC KEY
    if (!GetPublicKey(&pPubKeyInfo)) goto ErrorReturn;

    // CERT
    memset(&Cert, 0, sizeof(Cert));
    Cert.dwVersion = CERT_V3;
    Cert.SerialNumber = *pSerialNumber;
    Cert.SignatureAlgorithm.pszObjId = SIGNATURE_ALG_OBJID;
    Cert.Issuer.pbData = pbIssuerEncoded;
    Cert.Issuer.cbData = cbIssuerEncoded;

    {
        SYSTEMTIME SystemTime;
        GetSystemTime(&SystemTime);

        SystemTimeToFileTime(&SystemTime, &Cert.NotBefore);
        SystemTime.wYear++;
        if (!SystemTimeToFileTime(&SystemTime, &Cert.NotAfter)) {
	    SystemTime.wDay = 1;	
            SystemTimeToFileTime(&SystemTime, &Cert.NotAfter);
        } 
    }

    Cert.Subject.pbData = pbIssuerEncoded;
    Cert.Subject.cbData = cbIssuerEncoded;
    Cert.SubjectPublicKeyInfo = *pPubKeyInfo;

    CryptSignAndEncodeCertificate(
            hCryptProv,
            AT_SIGNATURE,
            dwCertEncodingType,
            X509_CERT_TO_BE_SIGNED,
            &Cert,
            &Cert.SignatureAlgorithm,
            NULL,                       // pvHashAuxInfo
            NULL,                       // pbEncoded
            &cbCertEncoded
            );
    if (cbCertEncoded == 0) {
        PrintLastError("CryptSignAndEncodeCertificate(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbCertEncoded = (BYTE *) TestAlloc(cbCertEncoded);
    if (pbCertEncoded == NULL) goto ErrorReturn;
    if (!CryptSignAndEncodeCertificate(
            hCryptProv,
            AT_SIGNATURE,
            dwCertEncodingType,
            X509_CERT_TO_BE_SIGNED,
            &Cert,
            &Cert.SignatureAlgorithm,
            NULL,                       // pvHashAuxInfo
            pbCertEncoded,
            &cbCertEncoded
            )) {
        PrintLastError("CryptSignAndEncodeCertificate");
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    if (pbIssuerEncoded)
        TestFree(pbIssuerEncoded);
    if (pPubKeyInfo)
        TestFree(pPubKeyInfo);
    *ppbCertEncoded = pbCertEncoded;
    *pcbCertEncoded = cbCertEncoded;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    if (pbCertEncoded) {
        TestFree(pbCertEncoded);
        pbCertEncoded = 0;
    }
    cbCertEncoded = 0;
    goto CommonReturn;
}

static PCCERT_CONTEXT GetSubject(
    IN HCERTSTORE hStore,
    IN PCRYPT_INTEGER_BLOB pSerialNumber
    )
{
    BOOL fResult = TRUE;
    PCCERT_CONTEXT pCert;
    CERT_INFO CertInfo;

    memset(&CertInfo, 0, sizeof(CertInfo));
    if (!EncodeIssuer(&CertInfo.Issuer.pbData, &CertInfo.Issuer.cbData))
        return NULL;

    CertInfo.SerialNumber = *pSerialNumber;
    pCert = CertGetSubjectCertificateFromStore(hStore, dwCertEncodingType,
        &CertInfo);
    if (NULL == pCert)
        PrintLastError("GetSubject");
    TestFree(CertInfo.Issuer.pbData);
    return pCert;
}

static BOOL TestGetSubject(
    IN LPSTR pszMsg,
    IN HCERTSTORE hStore,
    IN DWORD cSerialNumber,
    IN CRYPT_INTEGER_BLOB rgSerialNumber[],
    IN BOOL rgfExpectedGet[]
    )
{
    BOOL fResult = TRUE;
    DWORD i;
    CERT_INFO CertInfo;
    memset(&CertInfo, 0, sizeof(CertInfo));

    if (!EncodeIssuer(&CertInfo.Issuer.pbData, &CertInfo.Issuer.cbData))
        return FALSE;

    for (i = 0; i < cSerialNumber; i++) {
        PCCERT_CONTEXT pCert;

        CertInfo.SerialNumber = rgSerialNumber[i];
        pCert = CertGetSubjectCertificateFromStore(hStore, dwCertEncodingType,
            &CertInfo);
        if (pCert) {
            if (!rgfExpectedGet[i]) {
                fResult = FALSE;
                printf("%s SerialNumber[%d] failed => expected error\n",
                    pszMsg, i);
            }
            CertFreeCertificateContext(pCert);
        } else if (rgfExpectedGet[i]) {
            DWORD dwErr = GetLastError();
            fResult = FALSE;
            printf("%s SerialNumber[%d] failed => 0x%x (%d) \n", pszMsg, i,
                dwErr, dwErr);
        }
        
    }
    TestFree(CertInfo.Issuer.pbData);
    return fResult;
}

static DWORD WINAPI VerifyCertSignThreadProc(
    LPVOID lpThreadParameter
    )
{
    PCCERT_CONTEXT pCert0 = (PCCERT_CONTEXT) lpThreadParameter;
    DWORD dwFlags = CERT_STORE_SIGNATURE_FLAG | CERT_STORE_TIME_VALIDITY_FLAG;

    if (!CertVerifySubjectCertificateContext(pCert0, pCert0, &dwFlags))
        PrintLastError("CertVerifySubjectCertificateContext(Thread, SIGNATURE)");
    else if (dwFlags != 0) {
        printf("CertVerifySubjectCertificateContext(Thread, SIGNATURE) failed =>");
        printf("dwFlags = 0x%x\n", dwFlags);
    }

    return 0;
}

static BOOL DoTest()
{
    BOOL fResult;
    DWORD dwErr;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded;
    CERT_INFO CertInfo;
    memset(&CertInfo, 0, sizeof(CertInfo));
    PCCERT_CONTEXT pCert = NULL;
    PCCERT_CONTEXT pCert0 = NULL;
    PCCERT_CONTEXT pCertDup = NULL;

    HCERTSTORE hStore1 = NULL;
    HCERTSTORE hStore2 = NULL;
    HCERTSTORE hStore3 = NULL;

    CRYPT_DATA_BLOB SerializeStore;
    memset(&SerializeStore, 0, sizeof(SerializeStore));
    HCERTSTORE hSerializeStore = NULL;

    CRYPT_DATA_BLOB PKCS7Store;
    memset(&PKCS7Store, 0, sizeof(PKCS7Store));
    HCERTSTORE hPKCS7Store = NULL;
    DWORD i;
    DWORD dwFlags;

    CRYPT_DATA_BLOB SmallStore;
#define DELTA_LESS_LENGTH    8

    BYTE rgbSerial0[] = {0x7f, 0x7e, 0x7d, 0x7c, 0x7b};
    BYTE rgbSerial1[] = {0x81, 0x82, 0x83};
    BYTE rgbSerial2[] = {0x00, 0x00, 0x7f, 0x7e, 0x7d, 0x7c, 0x7b};
    BYTE rgbSerial3[] = {0xFF, 0xFF, 0xFF, 0x81, 0x82, 0x83};
    BYTE rgbSerial4[] = {0x7f, 0x7e, 0x7d, 0x7c, 0x7b, 0x00, 0x00};
    BYTE rgbSerial5[] = {0x81, 0x82, 0x83, 0xFF, 0xFF, 0xFF};
    BYTE rgbSerial6[] = {0x7f, 0x7e, 0x7d, 0x7c, 0x7b, 0xFF};
    BYTE rgbSerial7[] = {0x81, 0x82, 0x83, 0x00};

    CRYPT_INTEGER_BLOB rgSerialNumber[] = {
        sizeof(rgbSerial0), rgbSerial0,
        sizeof(rgbSerial1), rgbSerial1,
        sizeof(rgbSerial2), rgbSerial2,
        sizeof(rgbSerial3), rgbSerial3,
        sizeof(rgbSerial4), rgbSerial4,
        sizeof(rgbSerial5), rgbSerial5,
        sizeof(rgbSerial6), rgbSerial6,
        sizeof(rgbSerial7), rgbSerial7,
    };

    BOOL rgfExpectedGet[] = {
        TRUE,
        TRUE,
        FALSE,
        FALSE,
        TRUE,
        TRUE,
        FALSE,
        FALSE
    };

    BOOL rgfDeleteExpectedGet[] = {
        TRUE,
        FALSE
    };

    BYTE rgbAux0[] = {0x00};
    BYTE rgbAux1[] = {0x11, 0x11};
    BYTE rgbAux2[] = {0x22, 0x22, 0x22};
    BYTE rgbAux[8];
    CRYPT_DATA_BLOB AuxData;

    BYTE rgbStoreHash[MAX_HASH_LEN];
    DWORD cbStoreHash;
    BYTE rgbStoreHash2[MAX_HASH_LEN];
    DWORD cbStoreHash2;
    BYTE rgbContextHash[MAX_HASH_LEN];
    DWORD cbContextHash;

    if (!EncodeIssuer(&CertInfo.Issuer.pbData, &CertInfo.Issuer.cbData))
        goto ErrorReturn;

    if (NULL == (hStore1 = CertOpenSystemStoreW(hCryptProv, L"Test"))) {
        PrintLastError("CertOpenSystemStoreW(Test)");
        goto ErrorReturn;
    }

    // Delete all certs in the store
    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hStore1, pCert)) {
        PCCERT_CONTEXT pDeleteCert = CertDuplicateCertificateContext(pCert);
        CertDeleteCertificateFromStore(pDeleteCert);
    }

    // Add two certs to the store
    for (i = 0; i < 2; i++) {
        if (!EncodeCert(&rgSerialNumber[i], &pbCertEncoded, &cbCertEncoded))
            goto ErrorReturn;
        if (!CertAddEncodedCertificateToStore(
                hStore1,
                dwCertEncodingType,
                pbCertEncoded,
                cbCertEncoded,
                CERT_STORE_ADD_NEW,
                NULL)) {                // ppCertContext
            PrintLastError("CertAddEncodedCertificateToStore");
            goto ErrorReturn;
        }
        if (0 == i) {
            // Create certificate context for future use
            if (NULL == (pCert0 = CertCreateCertificateContext(
                    dwCertEncodingType,
                    pbCertEncoded,
                    cbCertEncoded))) {
                PrintLastError("CertCreateCertificateContext");
                goto ErrorReturn;
            }
        }
        TestFree(pbCertEncoded);
        pbCertEncoded = NULL;
    }

    TestGetSubject(
        "Store1",
        hStore1,
        sizeof(rgSerialNumber)/sizeof(rgSerialNumber[0]),
        rgSerialNumber,
        rgfExpectedGet
        );

    // All the certificates should have been pushed through to the
    // registry
    if (NULL == (hStore2 = CertOpenSystemStoreA(0, "Test"))) {
        PrintLastError("CertOpenSystemStoreA(Test)");
        goto ErrorReturn;
    }
    TestGetSubject(
        "Store2",
        hStore2,
        sizeof(rgSerialNumber)/sizeof(rgSerialNumber[0]),
        rgSerialNumber,
        rgfExpectedGet
        );

    CertInfo.SerialNumber = rgSerialNumber[4];
    // Update different properties on the same certificate via different
    // stores
    if (NULL == (pCert = CertGetSubjectCertificateFromStore(
            hStore1, dwCertEncodingType, &CertInfo))) {
        PrintLastError("CertGetSubjectCertificateFromStore");
        goto ErrorReturn;
    }

    AuxData.pbData = rgbAux0;
    AuxData.cbData = sizeof(rgbAux0);
    if (!CertSetCertificateContextProperty(
            pCert,
            CERT_FIRST_USER_PROP_ID + 0,
            0,                          // dwFlags
            &AuxData
            )) {
        PrintLastError("CertSetCertificateContextProperty");
        goto ErrorReturn;
    }
    CertFreeCertificateContext(pCert);
    pCert = NULL;

    if (NULL == (pCert = CertGetSubjectCertificateFromStore(
            hStore2, dwCertEncodingType, &CertInfo))) {
        PrintLastError("CertGetSubjectCertificateFromStore");
        goto ErrorReturn;
    }

    AuxData.pbData = rgbAux1;
    AuxData.cbData = sizeof(rgbAux1);
    if (!CertSetCertificateContextProperty(
            pCert,
            CERT_FIRST_USER_PROP_ID + 1,
            0,                          // dwFlags
            &AuxData
            )) {
        PrintLastError("CertSetCertificateContextProperty");
        goto ErrorReturn;
    }
    CertFreeCertificateContext(pCert);
    pCert = NULL;

    // Reopen store. The properties should have been pushed through
    // to the registry.
    if (NULL == (hStore3 = CertOpenSystemStoreA(0, "Test"))) {
        PrintLastError("CertOpenSystemStoreA(Test)");
        goto ErrorReturn;
    }

    TestGetSubject(
        "Store3",
        hStore3,
        sizeof(rgSerialNumber)/sizeof(rgSerialNumber[0]),
        rgSerialNumber,
        rgfExpectedGet
        );

    // Display certs in the store
    pCert = NULL;
    i = 0;
    printf("###### Test Store Certificates Before Delete ######\n");
    while (pCert = CertEnumCertificatesInStore(hStore3, pCert)) {
        printf("=====  %d  =====\n", i);
        DisplayCert(pCert, DISPLAY_BRIEF_FLAG);
        i++;
    }

    // Save certificates to in memory serialized store and in memory
    // PKCS #7 store
    if (!CertSaveStore(
            hStore3,
            0,                          // dwCertEncodingType,
            CERT_STORE_SAVE_AS_STORE,
            CERT_STORE_SAVE_TO_MEMORY,
            &SerializeStore,
            0)) {                       // dwFlags
        PrintLastError("CertSaveStore(CERT_STORE_SAVE_AS_STORE)");
        goto ErrorReturn;
    }
    if (NULL == (SerializeStore.pbData = (BYTE *) TestAlloc(
            SerializeStore.cbData)))
        goto ErrorReturn;
    if (!CertSaveStore(
            hStore3,
            0,                          // dwCertEncodingType,
            CERT_STORE_SAVE_AS_STORE,
            CERT_STORE_SAVE_TO_MEMORY,
            &SerializeStore,
            0)) {                       // dwFlags
        PrintLastError("CertSaveStore(CERT_STORE_SAVE_AS_STORE)");
        goto ErrorReturn;
    }

    // The following should fail with ERROR_MORE_DATA
    SmallStore = SerializeStore;
    SmallStore.cbData -= DELTA_LESS_LENGTH;
    if (CertSaveStore(
            hStore3,
            0,                          // dwCertEncodingType,
            CERT_STORE_SAVE_AS_STORE,
            CERT_STORE_SAVE_TO_MEMORY,
            &SmallStore,
            0))                         // dwFlags
        PrintNoError("CertSaveStore(CERT_STORE_SAVE_AS_STORE, insufficient length)");
    else {
        DWORD dwErr = GetLastError();
        PrintExpectedError("CertSaveStore(CERT_STORE_SAVE_AS_STORE, insufficient length)");
        if (ERROR_MORE_DATA != dwErr) {
            printf("CertSaveStore(CERT_STORE_SAVE_AS_STORE) failed => ");
            printf("LastError = %d, expected = %d\n", dwErr, ERROR_MORE_DATA);
        }
    }
        
    if (SmallStore.cbData != SerializeStore.cbData) {
        printf("CertSaveStore(CERT_STORE_SAVE_AS_STORE) failed => ");
        printf("cbData = %d, expected = %d\n",
            SmallStore.cbData, SerializeStore.cbData);
    } else {
        printf("cbData = %d, expected = %d\n",
            SmallStore.cbData, SerializeStore.cbData);
    }
    

    if (!CertSaveStore(
            hStore3,
            0,                          // dwCertEncodingType,
            CERT_STORE_SAVE_AS_STORE,
            CERT_STORE_SAVE_TO_MEMORY,
            &SerializeStore,
            0)) {                       // dwFlags
        PrintLastError("CertSaveStore(CERT_STORE_SAVE_AS_STORE)");
        goto ErrorReturn;
    }

    if (!CertSaveStore(
            hStore3,
            dwCertEncodingType | dwMsgEncodingType,
            CERT_STORE_SAVE_AS_PKCS7,
            CERT_STORE_SAVE_TO_MEMORY,
            &PKCS7Store,
            0)) {                       // dwFlags
        PrintLastError("CertSaveStore(CERT_STORE_SAVE_AS_PKCS7)");
        goto ErrorReturn;
    }
    if (NULL == (PKCS7Store.pbData = (BYTE *) TestAlloc(
            PKCS7Store.cbData)))
        goto ErrorReturn;
    if (!CertSaveStore(
            hStore3,
            dwCertEncodingType | dwMsgEncodingType,
            CERT_STORE_SAVE_AS_PKCS7,
            CERT_STORE_SAVE_TO_MEMORY,
            &PKCS7Store,
            0)) {                       // dwFlags
        PrintLastError("CertSaveStore(CERT_STORE_SAVE_AS_PKCS7)");
        goto ErrorReturn;
    }

    // The following should fail with ERROR_MORE_DATA
    SmallStore = PKCS7Store;
    SmallStore.cbData -= DELTA_LESS_LENGTH;
    if (CertSaveStore(
            hStore3,
            dwCertEncodingType | dwMsgEncodingType,
            CERT_STORE_SAVE_AS_PKCS7,
            CERT_STORE_SAVE_TO_MEMORY,
            &SmallStore,
            0))
        PrintNoError("CertSaveStore(CERT_STORE_SAVE_AS_PKCS7, insufficient length)");
    else {
        DWORD dwErr = GetLastError();
        PrintExpectedError("CertSaveStore(CERT_STORE_SAVE_AS_PKCS7, insufficient length)");
        if (ERROR_MORE_DATA != dwErr) {
            printf("CertSaveStore(CERT_STORE_SAVE_AS_PKCS7) failed => ");
            printf("LastError = %d, expected = %d\n", dwErr, ERROR_MORE_DATA);
        }
    }

    if (SmallStore.cbData != PKCS7Store.cbData) {
        printf("CertSaveStore(CERT_STORE_SAVE_AS_PKCS7) failed => ");
        printf("cbData = %d, expected = %d\n",
            SmallStore.cbData, PKCS7Store.cbData);
    } else {
        printf("cbData = %d, expected = %d\n",
            SmallStore.cbData, PKCS7Store.cbData);
    }

    if (!CertSaveStore(
            hStore3,
            dwCertEncodingType | dwMsgEncodingType,
            CERT_STORE_SAVE_AS_PKCS7,
            CERT_STORE_SAVE_TO_MEMORY,
            &PKCS7Store,
            0)) {                       // dwFlags
        PrintLastError("CertSaveStore(CERT_STORE_SAVE_AS_PKCS7)");
        goto ErrorReturn;
    }
    CertCloseStore(hStore3, 0);
    hStore3 = NULL;

    // Open in memory serialized store.
    if (NULL == (hSerializeStore = CertOpenStore(
            CERT_STORE_PROV_SERIALIZED,
            0,                              // dwEncodingType
            0,                              // hCryptProv
            0,                              // dwFlags
            (const void *) &SerializeStore))) {
        PrintLastError("CertOpenStore(SERIALIZED)");
        goto ErrorReturn;
    }
    TestGetSubject(
        "SerializeStore",
        hSerializeStore,
        sizeof(rgSerialNumber)/sizeof(rgSerialNumber[0]),
        rgSerialNumber,
        rgfExpectedGet
        );

    // Display certs in the store
    pCert = NULL;
    i = 0;
    printf("###### Serialized Store Certificates ######\n");
    while (pCert = CertEnumCertificatesInStore(hSerializeStore, pCert)) {
        printf("=====  %d  =====\n", i);
        DisplayCert(pCert, DISPLAY_VERBOSE_FLAG);
        i++;
    }

    // Open in memory PKCS7 store.
    if (NULL == (hPKCS7Store = CertOpenStore(
            CERT_STORE_PROV_PKCS7,
            dwCertEncodingType | dwMsgEncodingType,
            0,                              // hCryptProv
            0,                              // dwFlags
            (const void *) &PKCS7Store))) {
        PrintLastError("CertOpenStore(SERIALIZED)");
        goto ErrorReturn;
    }
    TestGetSubject(
        "PKCS7Store",
        hPKCS7Store,
        sizeof(rgSerialNumber)/sizeof(rgSerialNumber[0]),
        rgSerialNumber,
        rgfExpectedGet
        );

    // Display certs in the store
    pCert = NULL;
    i = 0;
    printf("###### PKCS7 Store Certificates ######\n");
    while (pCert = CertEnumCertificatesInStore(hPKCS7Store, pCert)) {
        printf("=====  %d  =====\n", i);
        DisplayCert(pCert, DISPLAY_VERBOSE_FLAG);
        i++;
    }

    // Delete the certificate in one store and update its property
    // in the other store. Should get an error.
    CertInfo.SerialNumber = rgSerialNumber[1];
    if (NULL == (pCert = CertGetSubjectCertificateFromStore(
            hStore1, dwCertEncodingType, &CertInfo))) {
        PrintLastError("CertGetSubjectCertificateFromStore");
        goto ErrorReturn;
    }
    if (!CertDeleteCertificateFromStore(pCert)) {
        PrintLastError("CertDeleteCertificateFromStore");
        goto ErrorReturn;
    }

    if (NULL == (pCert = CertGetSubjectCertificateFromStore(
            hStore2, dwCertEncodingType, &CertInfo))) {
        PrintLastError("CertGetSubjectCertificateFromStore");
        goto ErrorReturn;
    }
    AuxData.pbData = rgbAux2;
    AuxData.cbData = sizeof(rgbAux2);
    if (!CertSetCertificateContextProperty(
            pCert,
            CERT_FIRST_USER_PROP_ID + 2,
            0,                          // dwFlags
            &AuxData
            ))
        PrintExpectedError("CertSetCertificateContextProperty(deleted in other store)");
    else
        PrintNoError("CertSetCertificateContextProperty(deleted in other store)");
    CertFreeCertificateContext(pCert);
    pCert = NULL;


    // Reopen store. The certificate delete should have pushed through
    // to the registry.
    if (NULL == (hStore3 = CertOpenSystemStoreA(0, "Test"))) {
        PrintLastError("CertOpenSystemStoreA(Test)");
        goto ErrorReturn;
    }

    TestGetSubject(
        "After Delete Store3",
        hStore3,
        sizeof(rgfDeleteExpectedGet)/sizeof(rgfDeleteExpectedGet[0]),
        rgSerialNumber,
        rgfDeleteExpectedGet
        );

    // Display certs in the store
    pCert = NULL;
    i = 0;
    printf("###### Test Store Certificates After Delete ######\n");
    while (pCert = CertEnumCertificatesInStore(hStore3, pCert)) {
        printf("=====  %d  =====\n", i);
        DisplayCert(pCert, DISPLAY_VERBOSE_FLAG);
        i++;
    }

    // Check that we can get the hash property for a created context.
    // Compare with the hash of the same certificate in a store.
    CertInfo.SerialNumber = rgSerialNumber[0];
    if (NULL == (pCert = CertGetSubjectCertificateFromStore(
            hSerializeStore, dwCertEncodingType, &CertInfo))) {
        PrintLastError("CertGetSubjectCertificateFromStore(SerializeStore)");
        goto ErrorReturn;
    }
    cbStoreHash = MAX_HASH_LEN;
    if (!CertGetCertificateContextProperty(pCert, CERT_SHA1_HASH_PROP_ID,
            rgbStoreHash, &cbStoreHash)) {
        PrintLastError("CertGetCertificateContextProperty(SerializeStore)");
        goto ErrorReturn;
    }

    cbContextHash = MAX_HASH_LEN;
    if (!CertGetCertificateContextProperty(pCert0, CERT_SHA1_HASH_PROP_ID,
            rgbContextHash, &cbContextHash))
        PrintLastError("CertGetCertificateContextProperty(created context)");
    else if (cbContextHash != cbStoreHash ||
        0 != memcmp(rgbContextHash, rgbStoreHash, cbContextHash)) {
        printf("CertGetCertificateContextProperty(created context) failed => ");
        printf("hash didn't compare with store's hash\n");
    }


    // Do a CertVerifySubjectCertificateContext for a
    // certificate in a store and a certificate context.
    // Should pass for both a store certificate and 
    // a certificate context. The certificate context
    // uses the default provider.
    dwFlags = CERT_STORE_SIGNATURE_FLAG | CERT_STORE_TIME_VALIDITY_FLAG;
    if (!CertVerifySubjectCertificateContext(pCert, pCert, &dwFlags))
        PrintLastError("CertVerifySubjectCertificateContext(in store)");
    else if (dwFlags != 0) {
        printf("CertVerifySubjectCertificateContext(in store) failed =>");
        printf("dwFlags = 0x%x\n", dwFlags);
    }

    dwFlags = CERT_STORE_TIME_VALIDITY_FLAG;
    if (!CertVerifySubjectCertificateContext(pCert0, pCert0, &dwFlags))
        PrintLastError("CertVerifySubjectCertificateContext(context, TIME_VALIDITY)");
    else if (dwFlags != 0) {
        printf("CertVerifySubjectCertificateContext(context, TIME_VALIDITY) failed =>");
        printf("dwFlags = 0x%x\n", dwFlags);
    }

    dwFlags = CERT_STORE_SIGNATURE_FLAG | CERT_STORE_TIME_VALIDITY_FLAG;
    if (!CertVerifySubjectCertificateContext(pCert0, pCert0, &dwFlags))
        PrintLastError("CertVerifySubjectCertificateContext(context, SIGNATURE)");
    else if (dwFlags != 0) {
        printf("CertVerifySubjectCertificateContext(context, SIGNATURE) failed =>");
        printf("dwFlags = 0x%x\n", dwFlags);
    }


    {
        // Install DefaultContext applicable to all threads in process.
        // Create another thread that does the verify. For testing purposes,
        // will modify the CryptVerifyCertificateSignature to sleep while
        // holding a refCount on the DefaultContext. Will do an Uninstall
        // that should cause us to wait until the Verify returns.

        HCRYPTPROV hProv = 0;

        if (!CryptAcquireContext(
                &hProv,
                NULL,               // pszContainer
                NULL,               // pszProvider,
                PROV_RSA_FULL,
                CRYPT_VERIFYCONTEXT // dwFlags
                )) {
            PrintLastError(
                "CryptAcquireContext(PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)");
        } else {
            HCRYPTDEFAULTCONTEXT hDefaultContext;

            if (!CryptInstallDefaultContext(
                    hProv,
                    CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID,
                    (const void *) szOID_RSA_MD5RSA,
                    CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG,
                    NULL,                           // pvReserved
                    &hDefaultContext
                    )) {
                PrintLastError("CryptInstallDefaultContext");
            } else {
                HANDLE hThread;
                DWORD dwThreadId;

                if (NULL == (hThread = CreateThread(
                        NULL,           // lpThreadAttributes
                        0,              // dwStackSize
                        VerifyCertSignThreadProc,
                        (void *) pCert0,
                        0,              // dwCreationFlags
                        &dwThreadId
                        )))
                    PrintLastError("CreateThread");
                else
                    CloseHandle(hThread);

                Sleep(500);
                if (!CryptUninstallDefaultContext(
                        hDefaultContext,
                        0,                  // dwFlags
                        NULL                // pvReserved
                        ))
                    PrintLastError("CryptUninstallDefaultContext");
            }
            CryptReleaseContext(hProv, 0);
        }
    }

    // Close a store with a not freed certificate context. Should get a warning
    // at closing. 
    fResult = CertCloseStore(hSerializeStore, CERT_CLOSE_STORE_CHECK_FLAG);
    hSerializeStore = NULL;
    if (fResult)
        PrintNoError("CertCloseStore(with not freed certificate)");
    else
        PrintExpectedError("CertCloseStore(with not freed certificate)");

    // Delete and recalculate the hash property for a certificate context
    // after the store has been closed.
    if (!CertSetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            0,                          // dwFlags
            NULL                        // pvData
            ))
        PrintLastError("CertSetCertificateContextProperty(SHA1, delete after close store)");
    cbStoreHash2 = MAX_HASH_LEN;
    if (!CertGetCertificateContextProperty(pCert, CERT_SHA1_HASH_PROP_ID,
            rgbStoreHash2, &cbStoreHash2))
        PrintLastError("CertGetCertificateContextProperty(SHA1, after close store)");
    else if (cbStoreHash2 != cbStoreHash ||
        0 != memcmp(rgbStoreHash2, rgbStoreHash, cbStoreHash2)) {
        printf("CertGetCertificateContextProperty(SHA1, after close store) failed => ");
        printf("hash didn't compare with store's hash\n");
    }

    // Delete the certificate context after the store has been closed
    if (!CertDeleteCertificateFromStore(pCert))
        PrintLastError("CertDeleteCertificateFromStore(after close store)");
    pCert = NULL;

    // Duplicate a certificate. Delete it from the store. Also delete its
    // duplicate. Close the store.
    if (NULL == (pCert = CertGetSubjectCertificateFromStore(
            hPKCS7Store, dwCertEncodingType, &CertInfo))) {
        PrintLastError("CertGetSubjectCertificateFromStore(PKCS7)");
        goto ErrorReturn;
    }
    pCertDup = CertDuplicateCertificateContext(pCert);
    if (!CertDeleteCertificateFromStore(pCert))
        PrintLastError("CertDeleteCertificateFromStore(PKCS7)");
    pCert = NULL;
    if (!CertDeleteCertificateFromStore(pCertDup))
        PrintLastError("CertDeleteCertificateFromStore(PKCS7, duplicated cert)");
    pCertDup = NULL;

    // Also check that last error is preserved for no errors
#define EXPECTED_LAST_ERROR     0x11223344
    SetLastError(EXPECTED_LAST_ERROR);
    fResult = CertCloseStore(hPKCS7Store, CERT_CLOSE_STORE_CHECK_FLAG);
    hPKCS7Store = NULL;
    if (!fResult)
        PrintError("CertCloseStore(PKCS7, after two deletes)");
    else if (EXPECTED_LAST_ERROR != (dwErr = GetLastError())) {
        printf("CertCloseStore failed => globbered last error.");
        printf(" Expected 0x%x (%d), got 0x%x (%d)\n",
            EXPECTED_LAST_ERROR, EXPECTED_LAST_ERROR, dwErr, dwErr);
    }
    

    fResult = TRUE;
CommonReturn:
    if (pbCertEncoded)
        TestFree(pbCertEncoded);
    if (CertInfo.Issuer.pbData)
        TestFree(CertInfo.Issuer.pbData);
    if (SerializeStore.pbData)
        TestFree(SerializeStore.pbData);
    if (PKCS7Store.pbData)
        TestFree(PKCS7Store.pbData);

    if (hStore1)
        CertCloseStore(hStore1, 0);
    if (hStore2)
        CertCloseStore(hStore2, 0);
    if (hStore3)
        CertCloseStore(hStore3, 0);
    if (hSerializeStore)
        CertCloseStore(hSerializeStore, 0);
    if (hPKCS7Store)
        CertCloseStore(hPKCS7Store, 0);

    if (pCert)
        CertFreeCertificateContext(pCert);
    if (pCert0)
        CertFreeCertificateContext(pCert0);
    if (pCertDup)
        CertFreeCertificateContext(pCertDup);

    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL DoWin95Test()
{

#define WIN95_ADD_CERT_CNT  8
#define WIN95_ADD_CB_PROP   10000

#define WIN95_STORE_CNT     2
    LPWSTR rgpwszStore[WIN95_STORE_CNT] = {
        L"Test0",
        L"Test1"
    };

#define WIN95_PROP_CNT      5
    DWORD rgcbProp[WIN95_PROP_CNT][WIN95_STORE_CNT] = {
        100,        200,            // 0
        0x5000,     0x6000,         // 1
        0x1000,     0x6300,         // 2
        0x30,       0x300,          // 3
        0x4300,     0x4200          // 4
    };
        
    DWORD dwSerialNumber;
    CRYPT_INTEGER_BLOB SerialNumber = {
        sizeof(dwSerialNumber), (BYTE *) &dwSerialNumber
    };

    BOOL fResult;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded;
    PCCERT_CONTEXT pCert = NULL;
    HCERTSTORE hStore = NULL;
    CRYPT_DATA_BLOB Prop;
    BYTE *pbProp = NULL;
    DWORD cbProp;
    DWORD cb;
    DWORD i, j, k;
    DWORD cAdd;

    if (NULL == (hStore = CertOpenSystemStoreW(NULL, L"Test"))) {
        PrintLastError("CertOpenSystemStoreW");
        goto ErrorReturn;
    }
    // Delete all certs in the store
    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
        PCCERT_CONTEXT pDeleteCert = CertDuplicateCertificateContext(pCert);
        CertDeleteCertificateFromStore(pDeleteCert);
    }

    if (NULL == (pbProp = (BYTE *) TestAlloc(
            WIN95_ADD_CB_PROP + WIN95_ADD_CERT_CNT)))
        goto ErrorReturn;
    // Add certs each having a property of 10,000 + cAdd bytes in length
    for (cAdd = 0; cAdd < WIN95_ADD_CERT_CNT; cAdd++) {
        dwSerialNumber = cAdd;

        if (!EncodeCert(&SerialNumber, &pbCertEncoded, &cbCertEncoded))
            goto ErrorReturn;

        // Add encoded certificate to store.
        fResult = CertAddEncodedCertificateToStore(
                hStore,
                dwCertEncodingType,
                pbCertEncoded,
                cbCertEncoded,
                CERT_STORE_ADD_NEW,
                &pCert);
        TestFree(pbCertEncoded);
        pbCertEncoded = NULL;
        if (!fResult) {
            printf("AddEncodedCertificate[%d]", cAdd);
            PrintLastError("");
            break;
        }

        Prop.pbData = pbProp;
        Prop.cbData = WIN95_ADD_CB_PROP + cAdd;
        for (k = 0; k < WIN95_ADD_CB_PROP + cAdd; k++)
            pbProp[k] = (BYTE) cAdd;
        fResult = CertSetCertificateContextProperty(
                pCert,
                CERT_FIRST_USER_PROP_ID,
                0,                          // dwFlags
                &Prop
                );
        CertFreeCertificateContext(pCert);
        pCert = NULL;

        if (!fResult) {
            printf("SetProperty for AddedCertificate[%d]", cAdd);
            PrintLastError("");
            break;
        }
    }

    CertCloseStore(hStore, 0);
    hStore = NULL;

    // Verify that we can successfully read the added certs.
    if (NULL == (hStore = CertOpenSystemStoreW(NULL, L"Test"))) {
        PrintLastError("CertOpenSystemStoreW");
        goto ErrorReturn;
    }
    while (cAdd--) {
        dwSerialNumber = cAdd;
        pCert = GetSubject(hStore, &SerialNumber);
        if (NULL == pCert) {
            printf("GetAddedCertificate[%d]\n", cAdd);
            PrintLastError("");
        } else {
            cbProp = WIN95_ADD_CB_PROP + WIN95_ADD_CERT_CNT;
            
            if (!CertGetCertificateContextProperty(
                    pCert,
                    CERT_FIRST_USER_PROP_ID,
                    pbProp,
                    &cbProp)) {
                printf("GetProperty for AddedCertificate[%d]", cAdd);
                PrintLastError("");
            } else if (cbProp != WIN95_ADD_CB_PROP + cAdd) {
                printf("GetProperty for AddedCertificate[%d] failed => ", cAdd);
                printf("cbProp = %d, not expected = %d\n",
                    cbProp, WIN95_ADD_CB_PROP + cAdd);
            } else {
                for (k = 0; k < cbProp; k++) {
                    if (pbProp[k] != (BYTE) cAdd) {
                        printf("GetProperty for AddedCertificate[%d] failed => ", cAdd);
                        printf("not expected value\n");
                        break;
                    }
                }
            }
            CertFreeCertificateContext(pCert);
            pCert = NULL;
        }
    }

    CertCloseStore(hStore, 0);
    hStore = NULL;
    TestFree(pbProp);
    pbProp = NULL;

    dwSerialNumber = 0x12345678;
    if (!EncodeCert(&SerialNumber, &pbCertEncoded, &cbCertEncoded))
        goto ErrorReturn;

    for (j = 0; j < WIN95_STORE_CNT; j++) {
        if (NULL == (hStore = CertOpenSystemStoreW(
                NULL, rgpwszStore[j]))) {
            printf("%s => ", rgpwszStore[j]);
            PrintLastError("CertOpenSystemStoreW");
            goto ErrorReturn;
        }

        // Delete all certs in the store
        pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
            PCCERT_CONTEXT pDeleteCert = CertDuplicateCertificateContext(pCert);
            CertDeleteCertificateFromStore(pDeleteCert);
        }

        // Add encoded certificate to store.
        if (!CertAddEncodedCertificateToStore(
                hStore,
                dwCertEncodingType,
                pbCertEncoded,
                cbCertEncoded,
                CERT_STORE_ADD_NEW,
                &pCert)) {                // ppCertContext
            printf("%s => ", rgpwszStore[j]);
            PrintLastError("CertAddEncodedCertificateToStore");
            goto ErrorReturn;
        }

        cb = rgcbProp[0][j];
        if (NULL == (pbProp = (BYTE *) TestAlloc(cb)))
            goto ErrorReturn;
        Prop.pbData = pbProp;
        Prop.cbData = cb;
        for (k = 0; k < cb; k++)
            pbProp[k] = (BYTE) (j + 1);
        if (!CertSetCertificateContextProperty(
                pCert,
                CERT_FIRST_USER_PROP_ID,
                0,                          // dwFlags
                &Prop
                )) {
            printf("%s => ", rgpwszStore[j]);
            PrintLastError("CertSetCertificateContextProperty");
            goto ErrorReturn;
        }

        TestFree(pbProp);
        pbProp = NULL;
        CertFreeCertificateContext(pCert);
        pCert = NULL;
        CertCloseStore(hStore, 0);
        hStore = NULL;
    }

    TestFree(pbCertEncoded);
    pbCertEncoded = NULL;

    // Loop and read previous property. compare. write new property.
    for (i = 1; i < WIN95_PROP_CNT; i++) {
        for (j = 0; j < WIN95_STORE_CNT; j++) {

            if (NULL == (hStore = CertOpenSystemStoreW(
                    NULL, rgpwszStore[j]))) {
                printf("Prop[%d] Store[%d] ", i, j);
                PrintLastError("CertOpenSystemStoreW");
                goto ErrorReturn;
            }

            pCert = GetSubject(hStore, &SerialNumber);
            if (NULL == pCert) {
                printf("Prop[%d] Store[%d] ", i, j);
                PrintLastError("GetSubject");
                goto ErrorReturn;
            }

            if (!CertGetCertificateContextProperty(
                    pCert,
                    CERT_FIRST_USER_PROP_ID,
                    NULL,                       // pbProp
                    &cbProp)) {
                printf("Prop[%d] Store[%d] ", i, j);
                PrintLastError("CertGetCertificateContextProperty");
                goto ErrorReturn;
            }

            cb = rgcbProp[i-1][j];
            if (cbProp != cb) {
                printf("Prop[%d] Store[%d] ", i, j);
                printf("GetProperty failed => ");
                printf("cbProp = %d, not expected = %d\n", cbProp, cb);
                goto ErrorReturn;
            }

            if (NULL == (pbProp = (BYTE *) TestAlloc(cbProp)))
                goto ErrorReturn;
            if (!CertGetCertificateContextProperty(
                    pCert,
                    CERT_FIRST_USER_PROP_ID,
                    pbProp,
                    &cbProp)) {
                printf("Prop[%d] Store[%d] ", i, j);
                PrintLastError("CertGetCertificateContextProperty");
                goto ErrorReturn;
            }
            for (k = 0; k < cbProp; k++) {
                if (pbProp[k] != (BYTE) (j + 1)) {
                    printf("Prop[%d] Store[%d] ", i, j);
                    printf("GetProperty failed => ");
                    printf("not expected value\n");
                    goto ErrorReturn;
                }
            }

            TestFree(pbProp);
            pbProp = NULL;

            cb = rgcbProp[i][j];
            if (NULL == (pbProp = (BYTE *) TestAlloc(cb)))
                goto ErrorReturn;
            Prop.pbData = pbProp;
            Prop.cbData = cb;
            for (k = 0; k < cb; k++)
                pbProp[k] = (BYTE) (j + 1);
            if (!CertSetCertificateContextProperty(
                    pCert,
                    CERT_FIRST_USER_PROP_ID,
                    0,                          // dwFlags
                    &Prop
                    )) {
                printf("Prop[%d] Store[%d] cb=%d ", i, j, cb);
                PrintLastError("CertSetCertificateContextProperty");
                goto ErrorReturn;
            }

            TestFree(pbProp);
            pbProp = NULL;
            CertFreeCertificateContext(pCert);
            pCert = NULL;
            CertCloseStore(hStore, 0);
            hStore = NULL;
        }
    }
    

    fResult = TRUE;
CommonReturn:
    TestFree(pbProp);
    TestFree(pbCertEncoded);
    if (hStore)
        CertCloseStore(hStore, 0);
    if (pCert)
        CertFreeCertificateContext(pCert);

    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL DoDeferCloseTest() 
{
    BOOL fResult;

    BYTE rgbSerial[] = {0x7f, 0x7e, 0x7d, 0x7c, 0x7b};
    CRYPT_INTEGER_BLOB SerialNumber = {
        sizeof(rgbSerial), rgbSerial
    };

    HCERTSTORE hStore = NULL;
    PCCERT_CONTEXT pCert = NULL;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded;

    if (!EncodeCert(&SerialNumber, &pbCertEncoded, &cbCertEncoded))
            goto ErrorReturn;


    // ---------------------------------------------------------------------
    // Do defer close with no duplicated contexts
    // ---------------------------------------------------------------------
    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                              // dwEncodingType
            0,                              // hCryptProv
            CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
            NULL))) {                       // pvPara
        PrintLastError("CertOpenStore(MEMORY, DEFER)");
        goto ErrorReturn;
    }

    if (!CertAddEncodedCertificateToStore(
            hStore,
            dwCertEncodingType,
            pbCertEncoded,
            cbCertEncoded,
            CERT_STORE_ADD_NEW,
            NULL)) {                // ppCertContext
        PrintLastError("CertAddEncodedCertificateToStore");
        goto ErrorReturn;
    }

    fResult = CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    hStore = NULL;
    if (fResult)
        printf("Defer close with no duplicated contexts\n");
    else
        PrintLastError("CertCloseStore(DEFER, no duplicated contexts");

    // ---------------------------------------------------------------------
    // Do defer close with duplicated contexts
    // ---------------------------------------------------------------------
    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                              // dwEncodingType
            0,                              // hCryptProv
            CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
            NULL))) {                       // pvPara
        PrintLastError("CertOpenStore(MEMORY, DEFER)");
        goto ErrorReturn;
    }

    if (!CertAddEncodedCertificateToStore(
            hStore,
            dwCertEncodingType,
            pbCertEncoded,
            cbCertEncoded,
            CERT_STORE_ADD_NEW,
            &pCert)) {                // ppCertContext
        PrintLastError("CertAddEncodedCertificateToStore");
        goto ErrorReturn;
    }

    fResult = CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    hStore = NULL;
    if (fResult)
        PrintExpectedError("CertCloseStore(DEFER, with duplicated certificate)");
    else
        printf("Defer close with duplicated contexts\n");

    CertFreeCertificateContext(pCert);
    pCert = NULL;

    // ---------------------------------------------------------------------
    // Do context delete after a defer close
    // ---------------------------------------------------------------------
    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                              // dwEncodingType
            0,                              // hCryptProv
            CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
            NULL))) {                       // pvPara
        PrintLastError("CertOpenStore(MEMORY, DEFER)");
        goto ErrorReturn;
    }

    if (!CertAddEncodedCertificateToStore(
            hStore,
            dwCertEncodingType,
            pbCertEncoded,
            cbCertEncoded,
            CERT_STORE_ADD_NEW,
            &pCert)) {                // ppCertContext
        PrintLastError("CertAddEncodedCertificateToStore");
        goto ErrorReturn;
    }

    fResult = CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    hStore = NULL;
    if (fResult)
        PrintExpectedError("CertCloseStore(DEFER, with duplicated certificate)");
    else
        printf("Defer close with context to be deleted after\n");

    CertDeleteCertificateFromStore(pCert);
    pCert = NULL;

    fResult = TRUE;
CommonReturn:
    TestFree(pbCertEncoded);
    if (hStore)
        CertCloseStore(hStore, 0);
    if (pCert)
        CertFreeCertificateContext(pCert);

    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}


int _cdecl main(int argc, char * argv[]) 
{
    printf("command line: %s\n", GetCommandLine());

    hCryptProv = GetCryptProv();
    if (hCryptProv == 0)
        return -1;

    DoTest();
    DoWin95Test();
    DoDeferCloseTest();

    CryptReleaseContext(hCryptProv, 0);
    printf("Done.\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\ttrust\ttrust.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       ttrust.cpp
//
//  Contents:   WinVerifyTrust Chain Tests
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    06-Feb-98   philh   created
//--------------------------------------------------------------------------

#define CERT_CHAIN_PARA_HAS_EXTRA_FIELDS        1

#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "wintrust.h"
#include "wintrustp.h"
#include "softpub.h"
#include "certtest.h"
#include "crypthlp.h"
#include "unicode.h"

#include "wininet.h"
#ifndef SECURITY_FLAG_IGNORE_REVOCATION
#   define SECURITY_FLAG_IGNORE_REVOCATION          0x00000080
#   define SECURITY_FLAG_IGNORE_UNKNOWN_CA          0x00000100
#endif

#ifndef SECURITY_FLAG_IGNORE_WRONG_USAGE
#   define  SECURITY_FLAG_IGNORE_WRONG_USAGE        0x00000200
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <winwlx.h>

BOOL fFlushCrl = FALSE;

extern BOOL WINAPI ChainWlxLogoffEvent (PWLX_NOTIFICATION_INFO pNotificationInfo);

static void PrintStatus(
    IN LPCSTR pszMsg,
    IN LONG lStatus
    )
{
    printf("%s", pszMsg);
    switch (lStatus) {
         case CRYPT_E_MSG_ERROR:
            printf("CRYPT_E_MSG_ERROR");
            break;
         case CRYPT_E_UNKNOWN_ALGO:
            printf("CRYPT_E_UNKNOWN_ALGO");
            break;
         case CRYPT_E_OID_FORMAT:
            printf("CRYPT_E_OID_FORMAT");
            break;
         case CRYPT_E_INVALID_MSG_TYPE:
            printf("CRYPT_E_INVALID_MSG_TYPE");
            break;
         case CRYPT_E_UNEXPECTED_ENCODING:
            printf("CRYPT_E_UNEXPECTED_ENCODING");
            break;
         case CRYPT_E_AUTH_ATTR_MISSING:
            printf("CRYPT_E_AUTH_ATTR_MISSING");
            break;
         case CRYPT_E_HASH_VALUE:
            printf("CRYPT_E_HASH_VALUE");
            break;
         case CRYPT_E_INVALID_INDEX:
            printf("CRYPT_E_INVALID_INDEX");
            break;
         case CRYPT_E_ALREADY_DECRYPTED:
            printf("CRYPT_E_ALREADY_DECRYPTED");
            break;
         case CRYPT_E_NOT_DECRYPTED:
            printf("CRYPT_E_NOT_DECRYPTED");
            break;
         case CRYPT_E_RECIPIENT_NOT_FOUND:
            printf("CRYPT_E_RECIPIENT_NOT_FOUND");
            break;
         case CRYPT_E_CONTROL_TYPE:
            printf("CRYPT_E_CONTROL_TYPE");
            break;
         case CRYPT_E_ISSUER_SERIALNUMBER:
            printf("CRYPT_E_ISSUER_SERIALNUMBER");
            break;
         case CRYPT_E_SIGNER_NOT_FOUND:
            printf("CRYPT_E_SIGNER_NOT_FOUND");
            break;
         case CRYPT_E_ATTRIBUTES_MISSING:
            printf("CRYPT_E_ATTRIBUTES_MISSING");
            break;
         case CRYPT_E_STREAM_MSG_NOT_READY:
            printf("CRYPT_E_STREAM_MSG_NOT_READY");
            break;
         case CRYPT_E_STREAM_INSUFFICIENT_DATA:
            printf("CRYPT_E_STREAM_INSUFFICIENT_DATA");
            break;
         case CRYPT_E_BAD_LEN:
            printf("CRYPT_E_BAD_LEN");
            break;
         case CRYPT_E_BAD_ENCODE:
            printf("CRYPT_E_BAD_ENCODE");
            break;
         case CRYPT_E_FILE_ERROR:
            printf("CRYPT_E_FILE_ERROR");
            break;
         case CRYPT_E_NOT_FOUND:
            printf("CRYPT_E_NOT_FOUND");
            break;
         case CRYPT_E_EXISTS:
            printf("CRYPT_E_EXISTS");
            break;
         case CRYPT_E_NO_PROVIDER:
            printf("CRYPT_E_NO_PROVIDER");
            break;
         case CRYPT_E_SELF_SIGNED:
            printf("CRYPT_E_SELF_SIGNED");
            break;
         case CRYPT_E_DELETED_PREV:
            printf("CRYPT_E_DELETED_PREV");
            break;
         case CRYPT_E_NO_MATCH:
            printf("CRYPT_E_NO_MATCH");
            break;
         case CRYPT_E_UNEXPECTED_MSG_TYPE:
            printf("CRYPT_E_UNEXPECTED_MSG_TYPE");
            break;
         case CRYPT_E_NO_KEY_PROPERTY:
            printf("CRYPT_E_NO_KEY_PROPERTY");
            break;
         case CRYPT_E_NO_DECRYPT_CERT:
            printf("CRYPT_E_NO_DECRYPT_CERT");
            break;
         case CRYPT_E_BAD_MSG:
            printf("CRYPT_E_BAD_MSG");
            break;
         case CRYPT_E_NO_SIGNER:
            printf("CRYPT_E_NO_SIGNER");
            break;
         case CRYPT_E_PENDING_CLOSE:
            printf("CRYPT_E_PENDING_CLOSE");
            break;
         case CRYPT_E_REVOKED:
            printf("CRYPT_E_REVOKED");
            break;
         case CRYPT_E_NO_REVOCATION_DLL:
            printf("CRYPT_E_NO_REVOCATION_DLL");
            break;
         case CRYPT_E_NO_REVOCATION_CHECK:
            printf("CRYPT_E_NO_REVOCATION_CHECK");
            break;
         case CRYPT_E_REVOCATION_OFFLINE:
            printf("CRYPT_E_REVOCATION_OFFLINE");
            break;
         case CRYPT_E_NOT_IN_REVOCATION_DATABASE:
            printf("CRYPT_E_NOT_IN_REVOCATION_DATABASE");
            break;
         case CRYPT_E_INVALID_NUMERIC_STRING:
            printf("CRYPT_E_INVALID_NUMERIC_STRING");
            break;
         case CRYPT_E_INVALID_PRINTABLE_STRING:
            printf("CRYPT_E_INVALID_PRINTABLE_STRING");
            break;
         case CRYPT_E_INVALID_IA5_STRING:
            printf("CRYPT_E_INVALID_IA5_STRING");
            break;
         case CRYPT_E_INVALID_X500_STRING:
            printf("CRYPT_E_INVALID_X500_STRING");
            break;
         case CRYPT_E_NOT_CHAR_STRING:
            printf("CRYPT_E_NOT_CHAR_STRING");
            break;
         case CRYPT_E_FILERESIZED:
            printf("CRYPT_E_FILERESIZED");
            break;
         case CRYPT_E_SECURITY_SETTINGS:
            printf("CRYPT_E_SECURITY_SETTINGS");
            break;
         case CRYPT_E_NO_VERIFY_USAGE_DLL:
            printf("CRYPT_E_NO_VERIFY_USAGE_DLL");
            break;
         case CRYPT_E_NO_VERIFY_USAGE_CHECK:
            printf("CRYPT_E_NO_VERIFY_USAGE_CHECK");
            break;
         case CRYPT_E_VERIFY_USAGE_OFFLINE:
            printf("CRYPT_E_VERIFY_USAGE_OFFLINE");
            break;
         case CRYPT_E_NOT_IN_CTL:
            printf("CRYPT_E_NOT_IN_CTL");
            break;
         case CRYPT_E_NO_TRUSTED_SIGNER:
            printf("CRYPT_E_NO_TRUSTED_SIGNER");
            break;
         case CERTSRV_E_BAD_REQUESTSUBJECT:
            printf("CERTSRV_E_BAD_REQUESTSUBJECT");
            break;
         case CERTSRV_E_NO_REQUEST:
            printf("CERTSRV_E_NO_REQUEST");
            break;
         case CERTSRV_E_BAD_REQUESTSTATUS:
            printf("CERTSRV_E_BAD_REQUESTSTATUS");
            break;
         case CERTSRV_E_PROPERTY_EMPTY:
            printf("CERTSRV_E_PROPERTY_EMPTY");
            break;
         case TRUST_E_SYSTEM_ERROR:
            printf("TRUST_E_SYSTEM_ERROR");
            break;
         case TRUST_E_NO_SIGNER_CERT:
            printf("TRUST_E_NO_SIGNER_CERT");
            break;
         case TRUST_E_COUNTER_SIGNER:
            printf("TRUST_E_COUNTER_SIGNER");
            break;
         case TRUST_E_CERT_SIGNATURE:
            printf("TRUST_E_CERT_SIGNATURE");
            break;
         case TRUST_E_TIME_STAMP:
            printf("TRUST_E_TIME_STAMP");
            break;
         case TRUST_E_BAD_DIGEST:
            printf("TRUST_E_BAD_DIGEST");
            break;
         case TRUST_E_BASIC_CONSTRAINTS:
            printf("TRUST_E_BASIC_CONSTRAINTS");
            break;
         case TRUST_E_FINANCIAL_CRITERIA:
            printf("TRUST_E_FINANCIAL_CRITERIA");
            break;
         case TRUST_E_PROVIDER_UNKNOWN:
            printf("TRUST_E_PROVIDER_UNKNOWN");
            break;
         case TRUST_E_ACTION_UNKNOWN:
            printf("TRUST_E_ACTION_UNKNOWN");
            break;
         case TRUST_E_SUBJECT_FORM_UNKNOWN:
            printf("TRUST_E_SUBJECT_FORM_UNKNOWN");
            break;
         case TRUST_E_SUBJECT_NOT_TRUSTED:
            printf("TRUST_E_SUBJECT_NOT_TRUSTED");
            break;
         case TRUST_E_EXPLICIT_DISTRUST:
            printf("TRUST_E_EXPLICIT_DISTRUST");
            break;
         case DIGSIG_E_ENCODE:
            printf("DIGSIG_E_ENCODE");
            break;
         case DIGSIG_E_DECODE:
            printf("DIGSIG_E_DECODE");
            break;
         case DIGSIG_E_EXTENSIBILITY:
            printf("DIGSIG_E_EXTENSIBILITY");
            break;
         case DIGSIG_E_CRYPTO:
            printf("DIGSIG_E_CRYPTO");
            break;
         case PERSIST_E_SIZEDEFINITE:
            printf("PERSIST_E_SIZEDEFINITE");
            break;
         case PERSIST_E_SIZEINDEFINITE:
            printf("PERSIST_E_SIZEINDEFINITE");
            break;
         case PERSIST_E_NOTSELFSIZING:
            printf("PERSIST_E_NOTSELFSIZING");
            break;
         case TRUST_E_NOSIGNATURE:
            printf("TRUST_E_NOSIGNATURE");
            break;
         case CERT_E_EXPIRED:
            printf("CERT_E_EXPIRED");
            break;
         case CERT_E_VALIDITYPERIODNESTING:
            printf("CERT_E_VALIDITYPERIODNESTING");
            break;
         case CERT_E_ROLE:
            printf("CERT_E_ROLE");
            break;
         case CERT_E_PATHLENCONST:
            printf("CERT_E_PATHLENCONST");
            break;
         case CERT_E_CRITICAL:
            printf("CERT_E_CRITICAL");
            break;
         case CERT_E_PURPOSE:
            printf("CERT_E_PURPOSE");
            break;
         case CERT_E_ISSUERCHAINING:
            printf("CERT_E_ISSUERCHAINING");
            break;
         case CERT_E_MALFORMED:
            printf("CERT_E_MALFORMED");
            break;
         case CERT_E_UNTRUSTEDROOT:
            printf("CERT_E_UNTRUSTEDROOT");
            break;
         case CERT_E_UNTRUSTEDCA:
            printf("CERT_E_UNTRUSTEDCA");
            break;
         case CERT_E_CHAINING:
            printf("CERT_E_CHAINING");
            break;
         case TRUST_E_FAIL:
            printf("TRUST_E_FAIL");
            break;
         case CERT_E_REVOKED:
            printf("CERT_E_REVOKED");
            break;
         case CERT_E_UNTRUSTEDTESTROOT:
            printf("CERT_E_UNTRUSTEDTESTROOT");
            break;
         case CERT_E_REVOCATION_FAILURE:
            printf("CERT_E_REVOCATION_FAILURE");
            break;
         case CERT_E_CN_NO_MATCH:
            printf("CERT_E_CN_NO_MATCH");
            break;
         case CERT_E_WRONG_USAGE:
            printf("CERT_E_WRONG_USAGE");
            break;
          default:
            break;
    }

    printf (" 0x%x (%d)\n", lStatus, lStatus);
}

static void PrintError(
    IN LPCSTR pszMsg,
    IN DWORD dwErr
    )
{
    PrintStatus(pszMsg, (LONG) dwErr);
}

static void Usage(void)
{
    printf("Usage: ttrust [options] <filename>\n");
    printf("Options are:\n");
    printf("  -Cert                 - Default\n");
    printf("  -File\n");
    printf("  -Driver\n");
    printf("  -Https\n");
    printf("  -Chain\n");
    printf("  -ChainCallback\n");
    printf("  -NTAuth\n");
    printf("  -NTAuthNameConstraint\n");
    printf("  -Safer\n");
    printf("\n");
    printf("  -UseIE4Trust\n");
    printf("  -NoIE4Chain\n");
    printf("  -NoUsage\n");
    printf("  -OrUsage\n");
    printf("  -OrPolicy\n");
    printf("  -LifetimeSigning\n");
    printf("  -MicrosoftRoot\n");
    printf("  -MicrosoftTestRoot\n");
    printf("  -NotMicrosoftRoot\n");
    printf("  -FlushCrl\n");
    printf("  -DeferClosing\n");
    printf("\n");
    printf("  -DisplayKnownUsages\n");
    printf("  -LogoffNotification\n");
    printf("\n");
    printf("  -UINone               - Default\n");
    printf("  -UIAll\n");
    printf("  -UINoBad\n");
    printf("  -UINoGood\n");
    printf("\n");
    printf("  -RevokeNone           - Default\n");
    printf("  -RevokeChain\n");
    printf("\n");
    printf("  -DontOpenStores\n");
    printf("  -OpenOnlyRoot\n");
    printf("\n");
    printf("  -HttpsIgnoreRevocation\n");
    printf("  -HttpsIgnoreUnknownCa\n");
    printf("  -HttpsIgnoreWrongUsage\n");
    printf("  -HttpsIgnoreCertDateInvalid\n");
    printf("  -HttpsIgnoreCertCNInvalid\n");
    printf("\n");
    printf("  -Client               - Default\n");
    printf("  -Server\n");
    printf("\n");
    printf("  -InstallThreadDefaultContext\n");
    printf("  -InstallProcessDefaultContext\n");
    printf("  -AutoReleaseDefaultContext\n");
    printf("  -NULLDefaultContext\n");
    printf("  -MultiDefaultContext\n");
    printf("\n");
    printf("  -AuthenticodeFlags <Number>\n");
    printf("  -DeleteSaferRegKey\n");
    printf("  -EnableRootAutoUpdate\n");
    printf("  -DisableRootAutoUpdate\n");
    printf("  -EnableUntrustedRootLogging\n");
    printf("  -DisableUntrustedRootLogging\n");
    printf("  -EnablePartialChainLogging\n");
    printf("  -DisablePartialChainLogging\n");
    printf("  -EnableNTAuthRequired\n");
    printf("  -DisableNTAuthRequired\n");
    printf("  -EnableNotDefinedNameConstraint\n");
    printf("  -DisableNotDefinedNameConstraint\n");
    printf("  -EnableAuthRoot\n");
    printf("  -DisableAuthRoot\n");
    printf("  -RegistryOnlyExit\n");
    printf("\n");
    printf("Cert Chain Config Registry Values (0xFFFFFFFF deletes):\n");
    printf("  -DisableMandatoryBasicConstraints <Number>\n");
    printf("  -DisableAIAUrlRetrieval <Number>\n");
    printf("  -MaxAIAUrlCountInCert <Number>\n");
    printf("  -MaxAIAUrlRetrievalCountPerChain <Number>\n");
    printf("  -MaxAIAUrlRetrievalByteCount <Number>\n");
    printf("  -MaxAIAUrlRetrievalCertCount <Number>\n");
    printf("\n");
    printf("  -h                    - This message\n");
    printf("  -b                    - Brief\n");
    printf("  -v                    - Verbose\n");
    printf("  -q[<Number>]          - Quiet, expected error\n");
    printf("  -e<Number>            - Expected trust error status\n");
    printf("  -i<Number>            - Expected trust info status\n");
    printf("  -u<OID String>        - Usage OID string -u1.3.6.1.5.5.7.3.3\n");
    printf("  -p<OID String>        - Policy OID string -u1.3.6.1.5.5.7.3.3\n");
    printf("  -s<SystemStore>       - Additional System Store\n");
    printf("  -S<FileSystemStore>   - Additional File System Store\n");
    printf("  -n<ServerName>        - Https ServerName\n");
    printf("  -f<Number>            - Flags\n");
    printf("  -t<Number>            - Url timeout (milliseconds)\n");
    printf("  -r<Number>            - Revocation freshness (seconds)\n");
    printf("\n");
}

static PCCERT_CONTEXT ReadCert(
    IN LPSTR pszCert
    )
{
    BOOL fResult;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    PCCERT_CONTEXT pCert;

    if (!ReadDERFromFile(pszCert, &pbEncoded, &cbEncoded)) {
        PrintLastError("ReadCert");
        return NULL;
    }

    pCert = CertCreateCertificateContext(
        dwCertEncodingType,
        pbEncoded,
        cbEncoded
        );
    if (pCert == NULL)
        PrintLastError("CertCreateCertificateContext");

    TestFree(pbEncoded);
    return pCert;
}

static void DisplayPeterSigner(
    IN CRYPT_PROVIDER_SGNR *pProvSign,
    IN DWORD dwDisplayFlags
    )
{
    DWORD idxCert;


    printf("Verify Time: %s\n", FileTimeText(&pProvSign->sftVerifyAsOf));
    if (pProvSign->dwSignerType) {
        printf("Signer Type: 0x%x", pProvSign->dwSignerType);
        if (pProvSign->dwSignerType == SGNR_TYPE_TIMESTAMP)
            printf(" TIMESTAMP");
        printf("\n");
    }

    if (pProvSign->dwError)
        PrintError("Error: ", pProvSign->dwError);

    if (0 == pProvSign->csCertChain) {
        printf("No Certificates\n");
        return;
    }

    for (idxCert = 0; idxCert < pProvSign->csCertChain; idxCert++) {
        CRYPT_PROVIDER_CERT *pProvCert;
        printf("-----  Cert [%d]  -----\n", idxCert);

        pProvCert = WTHelperGetProvCertFromChain(pProvSign, idxCert);
        if (pProvCert) {
            if (pProvCert->dwError)
                PrintError("Error: ", pProvCert->dwError);
            if (pProvCert->dwRevokedReason)
                PrintError("RevokedReason: ", pProvCert->dwRevokedReason);
            printf("Confidence:: 0x%x ", pProvCert->dwConfidence);
            if ((pProvCert->dwConfidence & CERT_CONFIDENCE_HIGHEST) ==
                    CERT_CONFIDENCE_HIGHEST)
                printf("Highest ");
            else {
                if (pProvCert->dwConfidence & CERT_CONFIDENCE_SIG)
                    printf("Signature ");
                if (pProvCert->dwConfidence & CERT_CONFIDENCE_TIME)
                    printf("Time ");
                if (pProvCert->dwConfidence & CERT_CONFIDENCE_TIMENEST)
                    printf("TimeNest ");
                if (pProvCert->dwConfidence & CERT_CONFIDENCE_AUTHIDEXT)
                    printf("AuthorityID ");
                if (pProvCert->dwConfidence & CERT_CONFIDENCE_HYGIENE)
                    printf("Hygiene ");
            }
            printf("\n");
            if (pProvCert->fTrustListSignerCert)
                printf("TrustListSignerCert ");
            if (pProvCert->fCommercial)
                printf("Commercial ");
            if (pProvCert->fTrustedRoot)
                printf("TrustedRoot ");
            if (pProvCert->fSelfSigned)
                printf("SelfSigned ");
            if (pProvCert->fTestCert)
                printf("TestCert ");
            printf("\n");
            DisplayCert(pProvCert->pCert, dwDisplayFlags);

            if (pProvCert->pTrustListContext) {
                printf("-----  Outlook CTL  -----\n");
                DisplayCtl(
                    (PCCTL_CONTEXT) pProvCert->pTrustListContext,
                    dwDisplayFlags
                    );
            }

            if (pProvCert->dwCtlError)
                PrintError("Ctl Error: ", pProvCert->dwCtlError);

            if (pProvCert->pCtlContext) {
                printf("-----  CTL  -----\n");
                DisplayCtl(pProvCert->pCtlContext, dwDisplayFlags);
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Synopsis:   Chain Display Functions
//
//----------------------------------------------------------------------------
LPSTR rgszErrorStatus[] = {

    "CERT_TRUST_IS_NOT_TIME_VALID",             // 0x00000001
    "CERT_TRUST_IS_NOT_TIME_NESTED",            // 0x00000002
    "CERT_TRUST_IS_REVOKED",                    // 0x00000004
    "CERT_TRUST_IS_NOT_SIGNATURE_VALID",        // 0x00000008
    "CERT_TRUST_IS_NOT_VALID_FOR_USAGE",        // 0x00000010
    "CERT_TRUST_IS_UNTRUSTED_ROOT",             // 0x00000020
    "CERT_TRUST_REVOCATION_STATUS_UNKNOWN",     // 0x00000040
    "CERT_TRUST_IS_CYCLIC",                     // 0x00000080
    "CERT_TRUST_INVALID_EXTENSION",             // 0x00000100
    "CERT_TRUST_INVALID_POLICY_CONSTRAINTS",    // 0x00000200
    "CERT_TRUST_INVALID_BASIC_CONSTRAINTS",     // 0x00000400
    "CERT_TRUST_INVALID_NAME_CONSTRAINTS",      // 0x00000800
    "CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT", // 0x00001000
    "CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT",// 0x00002000
    "CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT", // 0x00004000
    "CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT",  // 0x00008000
    "CERT_TRUST_IS_PARTIAL_CHAIN",              // 0x00010000
    "CERT_TRUST_CTL_IS_NOT_TIME_VALID",         // 0x00020000
    "CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID",    // 0x00040000
    "CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE",    // 0x00080000
    "Unknown Error Status",                     // 0x00100000
    "Unknown Error Status",                     // 0x00200000
    "Unknown Error Status",                     // 0x00400000
    "Unknown Error Status",                     // 0x00800000
    "CERT_TRUST_IS_OFFLINE_REVOCATION",         // 0x01000000
    "CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY",      // 0x02000000
    "Unknown Error Status",                     // 0x04000000
    "Unknown Error Status",                     // 0x08000000
    "Unknown Error Status",                     // 0x10000000
    "Unknown Error Status",                     // 0x20000000
    "Unknown Error Status",                     // 0x40000000
    "Unknown Error Status"                      // 0x80000000
};

LPSTR rgszInfoStatus[] = {

    "CERT_TRUST_HAS_EXACT_MATCH_ISSUER",// 0x00000001
    "CERT_TRUST_HAS_KEY_MATCH_ISSUER",  // 0x00000002
    "CERT_TRUST_HAS_NAME_MATCH_ISSUER", // 0x00000004
    "CERT_TRUST_IS_SELF_SIGNED",        // 0x00000008
    "Unknown Info Status",              // 0x00000010
    "Unknown Info Status",              // 0x00000020
    "Unknown Info Status",              // 0x00000040
    "Unknown Info Status",              // 0x00000080
    "CERT_TRUST_HAS_PREFERRED_ISSUER",  // 0x00000100
    "CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY", // 0x00000200
    "CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS",  // 0x00000400
    "Unknown Info Status",              // 0x00000800
    "Unknown Info Status",              // 0x00001000
    "Unknown Info Status",              // 0x00002000
    "Unknown Info Status",              // 0x00004000
    "Unknown Info Status",              // 0x00008000
    "CERT_TRUST_IS_COMPLEX_CHAIN",      // 0x00010000
    "Unknown Info Status",              // 0x00020000
    "Unknown Info Status",              // 0x00040000
    "Unknown Info Status",              // 0x00080000
    "Unknown Info Status",              // 0x00100000
    "Unknown Info Status",              // 0x00200000
    "Unknown Info Status",              // 0x00400000
    "Unknown Info Status",              // 0x00800000
    "Unknown Info Status",              // 0x01000000
    "Unknown Info Status",              // 0x02000000
    "Unknown Info Status",              // 0x04000000
    "Unknown Info Status",              // 0x08000000
    "Unknown Info Status",              // 0x10000000
    "Unknown Info Status",              // 0x20000000
    "Unknown Info Status",              // 0x40000000
    "Unknown Info Status"               // 0x80000000
};

void DisplayTrustStatus(
    IN PCERT_TRUST_STATUS pStatus
    )
{
    DWORD dwMask;
    DWORD cCount;

    printf(
       "Trust Status (E=0x%lx,I=0x%lx)\n\n",
       pStatus->dwErrorStatus,
       pStatus->dwInfoStatus
       );

    dwMask = 1;
    for ( cCount = 0; cCount < 32; cCount++ )
    {
        if ( pStatus->dwErrorStatus & dwMask )
        {
            if ( strcmp( rgszErrorStatus[ cCount ], "Unknown Error Status" ) != 0 )
            {
                printf("%s\n", rgszErrorStatus[ cCount ]);
            }
        }

        dwMask = dwMask << 1;
    }

    dwMask = 1;
    for ( cCount = 0; cCount < 32; cCount++ )
    {
        if ( pStatus->dwInfoStatus & dwMask )
        {
            if ( strcmp( rgszInfoStatus[ cCount ], "Unknown Info Status" ) != 0 )
            {
                printf("%s\n", rgszInfoStatus[ cCount ]);
            }
        }

        dwMask = dwMask << 1;
    }

    printf("\n");
}

void DisplayRevocationFreshnessTime(
    IN DWORD dwTime         // seconds
    )
{
    DWORD dwRemain;
    DWORD dwSec;
    DWORD dwMin;
    DWORD dwHour;
    DWORD dwDay;

    dwRemain = dwTime;
    dwSec = dwRemain % 60;
    dwRemain /= 60;             // total minutes

    dwMin = dwRemain % 60;
    dwRemain /= 60;             // total hours

    dwHour = dwRemain % 24;
    dwDay = dwRemain / 24;


    printf("Revocation Freshness Time : %d (%d day %d hour %d min %d sec)\n",
        dwTime, dwDay, dwHour, dwMin, dwSec);
}

void DisplayChainElement(
    IN PCERT_CHAIN_ELEMENT pElement,
    IN DWORD dwDisplayFlags
    )
{
    DisplayCert( pElement->pCertContext, dwDisplayFlags );
    printf("\n");
    if (pElement->pRevocationInfo) {
        PCERT_REVOCATION_INFO pRevocationInfo = pElement->pRevocationInfo;
        PrintError("RevocationResult: ", pRevocationInfo->dwRevocationResult);
        if (pRevocationInfo->pszRevocationOid)
            printf("RevocationOid: %s\n", pRevocationInfo->pszRevocationOid);

        if (pRevocationInfo->fHasFreshnessTime)
            DisplayRevocationFreshnessTime(
                pRevocationInfo->dwFreshnessTime);

        if (pRevocationInfo->pCrlInfo) {
            PCERT_REVOCATION_CRL_INFO pCrlInfo = pRevocationInfo->pCrlInfo;

            if (pCrlInfo->pBaseCrlContext) {
                printf("Base CRL\n");
                DisplayCrl(pCrlInfo->pBaseCrlContext, dwDisplayFlags );
            }

            if (pCrlInfo->pDeltaCrlContext) {
                printf("Delta CRL\n");
                DisplayCrl(pCrlInfo->pDeltaCrlContext, dwDisplayFlags );
            }

            if (pCrlInfo->pCrlEntry) {
                if (pCrlInfo->fDeltaCrlEntry)
                    printf("Delta ");
                else
                    printf("Base ");
                printf("CRL entry\n");
                PrintCrlEntries(1, pCrlInfo->pCrlEntry, dwDisplayFlags);
            }

        }

        printf("\n");
    }

    if (NULL == pElement->pIssuanceUsage)
        printf("Any Issuance Usages\n");
    else if (0 == pElement->pIssuanceUsage->cUsageIdentifier)
        printf("No Issuance Usages\n");
    else {
        printf("Issuance Usages\n");

        LPSTR *ppszId = pElement->pIssuanceUsage->rgpszUsageIdentifier;
        DWORD cId = pElement->pIssuanceUsage->cUsageIdentifier;
        DWORD i;

        for (i = 0; i < cId; i++, ppszId++)
            printf("    [%d] %s\n", i, *ppszId);
    }

    if (NULL == pElement->pApplicationUsage)
        printf("Any Application Usages\n");
    else if (0 == pElement->pApplicationUsage->cUsageIdentifier)
        printf("No Application Usages\n");
    else {
        printf("Application Usages\n");

        LPSTR *ppszId = pElement->pApplicationUsage->rgpszUsageIdentifier;
        DWORD cId = pElement->pApplicationUsage->cUsageIdentifier;
        DWORD i;

        for (i = 0; i < cId; i++, ppszId++)
            printf("    [%d] %s\n", i, *ppszId);
    }

    printf("\n");

    if (pElement->pwszExtendedErrorInfo) {
        printf("Extended Error Information::\n%S\n",
            pElement->pwszExtendedErrorInfo);
    }

    DisplayTrustStatus( &pElement->TrustStatus );
}

void DisplaySimpleChain(
    IN PCERT_SIMPLE_CHAIN pChain,
    IN DWORD dwDisplayFlags = 0
    )
{
    DWORD cElement;

    if (pChain->fHasRevocationFreshnessTime)
        DisplayRevocationFreshnessTime(
            pChain->dwRevocationFreshnessTime);

    DisplayTrustStatus( &pChain->TrustStatus );

    if (fFlushCrl && pChain->cElement >= 2) {
        if (CryptFlushTimeValidObject(
                TIME_VALID_OID_FLUSH_CRL_FROM_CERT,
                (LPVOID) pChain->rgpElement[0]->pCertContext,   // pvPara
                pChain->rgpElement[1]->pCertContext,            // pIssuer
                0,                                              // dwFlags
                NULL                                            // pvReserved
                ))
            printf("Successful FlushCrl\n");
        else
            PrintLastError("FlushCrl");

    }

    printf("Chain Element Count = %d\n", pChain->cElement);
    for ( cElement = 0; cElement < pChain->cElement; cElement++ )
    {
        printf("Chain Element [%d]\n", cElement);
        DisplayChainElement( pChain->rgpElement[ cElement ], dwDisplayFlags );
    }
}

void DisplayKirtChain(
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN DWORD dwDisplayFlags
    )
{
    DWORD cChain;

    if (NULL == pChainContext)
        return;

    printf("Chain Context\n\n");
    if (pChainContext->fHasRevocationFreshnessTime)
        DisplayRevocationFreshnessTime(
            pChainContext->dwRevocationFreshnessTime);
    DisplayTrustStatus( (PCERT_TRUST_STATUS)&pChainContext->TrustStatus );
    printf("Simple Chain Count = %d\n\n", pChainContext->cChain );

    for ( cChain = 0; cChain < pChainContext->cChain; cChain++ )
    {
        printf("Simple Chain [%d]\n", cChain);
        DisplaySimpleChain( pChainContext->rgpChain[ cChain ], dwDisplayFlags );
    }

    if (pChainContext->cLowerQualityChainContext) {
        DWORD i;

        printf("Lower Quality Chain Count = %d\n\n",
            pChainContext->cLowerQualityChainContext);
        for (i = 0; i < pChainContext->cLowerQualityChainContext; i++) {
            printf("Lower Quality Chain [%d]\n", i);
            DisplayKirtChain(pChainContext->rgpLowerQualityChainContext[i],
                dwDisplayFlags);
        }

    }
}

void DisplayChainPolicyCallbackSigner(
    IN PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO pSigner
    )
{
    if (pSigner->dwSignerType) {
        printf("Signer Type: 0x%x", pSigner->dwSignerType);
        if (pSigner->dwSignerType == SGNR_TYPE_TIMESTAMP)
            printf(" TIMESTAMP");
        printf("\n");
    }

    if (pSigner->dwError)
        PrintError("Error: ", pSigner->dwError);
    if (pSigner->pMsgSignerInfo)
        printf("pMsgSignerInfo: 0x%p\n", pSigner->pMsgSignerInfo);

    DisplayKirtChain(pSigner->pChainContext, DISPLAY_BRIEF_FLAG);
    
}

#define CHAIN_POLICY_ARG    (DWORD_PTR)0x8765beef
HRESULT
WINAPI
ChainPolicyCallback(
    IN PCRYPT_PROVIDER_DATA pProvData,
    IN DWORD dwStepError,
    IN DWORD dwRegPolicySettings,
    IN DWORD cSigner,
    IN PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO *rgpSigner,
    IN void *pvPolicyArg
    )
{
    printf(">>>>>  ChainPolicyCallback  <<<<<\n");
    if (pvPolicyArg != (void *) CHAIN_POLICY_ARG)
        printf("failed => wrong pvPolicyArg\n");

    if (dwStepError)
        PrintError("StepError: ", dwStepError);
    if (dwRegPolicySettings)
        printf("RegPolicySettings: 0x%p\n");

    if (0 == cSigner)
        printf("No Signers\n");
    else {
        DWORD idxSigner;
        for (idxSigner = 0; idxSigner < cSigner; idxSigner++) {
            DWORD idxCounterSigner;
            PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO pSigner =
                rgpSigner[idxSigner];

            printf("======  Signer [%d]  ======\n", idxSigner);
            DisplayChainPolicyCallbackSigner(pSigner);

            for (idxCounterSigner = 0;
                    idxCounterSigner < pSigner->cCounterSigner;
                                                    idxCounterSigner++) {
                PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO pCounterSigner =
                    pSigner->rgpCounterSigner[idxCounterSigner];

                printf("\n");
                printf("======  CounterSigner [%d,%d]  ======\n",
                        idxSigner, idxCounterSigner);
                DisplayChainPolicyCallbackSigner(pCounterSigner);
            }
        }
    }
    return TRUST_E_FAIL;
}


static BOOL fInstallDefaultContext = FALSE;
static DWORD dwDefaultContextFlags = 0;
static BOOL fNULLDefaultContext = FALSE;
static BOOL fMultiDefaultContext = FALSE;

static LPSTR rgpszDefaultContextOID[] = {
    // 0
    szOID_OIWSEC_sha1RSASign,
    // 1
    szOID_OIWSEC_shaRSA,
    // 2
    szOID_RSA_MD5RSA,
    // 3
    szOID_OIWSEC_md5RSA,
    // 4
    szOID_RSA_MD2RSA,
    // 5
    szOID_RSA_MD4RSA,
    // 6
    szOID_OIWSEC_md4RSA,
    // 7
    szOID_OIWSEC_md4RSA2,
    // 8
    szOID_OIWDIR_md2RSA,
    // 9
    szOID_RSA_SHA1RSA,
};

static CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA rgMultiOIDPara[] = {
     1, &rgpszDefaultContextOID[3],
     2, &rgpszDefaultContextOID[2],
    10, &rgpszDefaultContextOID[0],
     4, &rgpszDefaultContextOID[6],
     1, &rgpszDefaultContextOID[8],
};

#define NUM_MULTI_OID_PARA (sizeof(rgMultiOIDPara) / sizeof(rgMultiOIDPara[0]))
static HCRYPTDEFAULTCONTEXT rghDefaultContext[NUM_MULTI_OID_PARA];
static DWORD cDefaultContext = 0;
static HCRYPTPROV hDefaultContextProv = 0;


static void InstallDefaultContext()
{
    if (!CryptAcquireContext(
            &hDefaultContextProv,
            NULL,               // pszContainer
            NULL,               // pszProvider,
            PROV_RSA_FULL,
            CRYPT_VERIFYCONTEXT // dwFlags
            )) {
        PrintLastError(
            "CryptAcquireContext(PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)");
        hDefaultContextProv = 0;
        return;
    }

    if (fMultiDefaultContext) {
        DWORD dwFlags = dwDefaultContextFlags;
        for (cDefaultContext = 0; cDefaultContext < NUM_MULTI_OID_PARA;
                                                        cDefaultContext++) {
            if (!CryptInstallDefaultContext(
                    hDefaultContextProv,
                    CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID,
                    (const void *) &rgMultiOIDPara[cDefaultContext],
                    dwFlags,
                    NULL,                           // pvReserved
                    &rghDefaultContext[cDefaultContext]
                    )) {
                PrintLastError("CryptInstallDefaultContext");
                break;
            }

            dwFlags &= ~CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG;
        }
    } else {
        LPSTR pszOID;

        if (fNULLDefaultContext)
            pszOID = NULL;
        else
            pszOID = szOID_RSA_MD5RSA;

        if (!CryptInstallDefaultContext(
                hDefaultContextProv,
                CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID,
                (const void *) pszOID,
                dwDefaultContextFlags,
                NULL,                           // pvReserved
                &rghDefaultContext[0]
                ))
            PrintLastError("CryptInstallDefaultContext");
        else
            cDefaultContext = 1;
    }

    if (0 == cDefaultContext) {
        CryptReleaseContext(hDefaultContextProv, 0);
        hDefaultContextProv = 0;
    }
}

static void FreeDefaultContext()
{
    if (dwDefaultContextFlags & CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG)
        return;

    if (0 < cDefaultContext) {
        if (!CryptUninstallDefaultContext(
                rghDefaultContext[0],
                0,                  // dwFlags
                NULL                // pvReserved
                ))
            PrintLastError("CryptUninstallDefaultContext");
        rghDefaultContext[0] = NULL;

        while (cDefaultContext-- > 0){
            if (!CryptUninstallDefaultContext(
                    rghDefaultContext[cDefaultContext],
                    0,                  // dwFlags
                    NULL                // pvReserved
                    ))
                PrintLastError("CryptUninstallDefaultContext");
        }
    }

    if (hDefaultContextProv)
        CryptReleaseContext(hDefaultContextProv, 0);
}


BOOL NTAuthVerify(
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN DWORD dwExpectedErr
    )
{
    BOOL fResult = TRUE;
    DWORD dwErr;
    HCERTSTORE hNTAuthStore = NULL;
    PCERT_SIMPLE_CHAIN pChain;
    PCCERT_CONTEXT pCACert;             // don't free
    PCCERT_CONTEXT pAddCert = NULL;

    CERT_CHAIN_POLICY_PARA PolicyPara;
    memset(&PolicyPara, 0, sizeof(PolicyPara));
    PolicyPara.cbSize = sizeof(PolicyPara);
    PolicyPara.dwFlags = CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG |
        CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG;

    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    memset(&PolicyStatus, 0, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);

    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_NT_AUTH,
            pChainContext,
            &PolicyPara,
            &PolicyStatus
            )) {
        PrintLastError(
            "CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_NT_AUTH)");
        goto ErrorReturn;
    }
    dwErr = PolicyStatus.dwError;

    if ((CRYPT_E_NO_REVOCATION_CHECK == dwExpectedErr ||
            CRYPT_E_REVOCATION_OFFLINE == dwExpectedErr)) {
        if (CERT_E_UNTRUSTEDCA != dwErr) {
            PrintStatus("NTAuth failed without CERT_E_UNTRUSTEDCA when revocation checking => ", (LONG) dwErr);
            fResult = FALSE;
        }
    } else if (dwExpectedErr != dwErr) {
        PrintStatus("Expected => ", (LONG) dwExpectedErr);
        PrintStatus("NTAuth failed => ", (LONG) dwErr);
        fResult = FALSE;
    }

    if (CERT_E_UNTRUSTEDCA != dwErr)
        goto CommonReturn;

    pChain = pChainContext->rgpChain[0];
    if (2 > pChain->cElement) {
        printf("NTAuth:: failed => missing CA cert\n");
        goto ErrorReturn;
    }
    pCACert = pChain->rgpElement[1]->pCertContext;

    hNTAuthStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_REGISTRY_W, 
        0,                  // dwEncodingType
        0,                  // hCryptProv
        CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE,
        L"NTAuth"
        );
    if (NULL == hNTAuthStore) {
        PrintLastError("CertOpenStore(NTAuth)");
        goto ErrorReturn;
    }

    if (!CertAddCertificateContextToStore(
            hNTAuthStore,
            pCACert,
            CERT_STORE_ADD_NEW,
            &pAddCert
            )) {
        PrintLastError("CertAddCertificateContextToStore(NTAuth CA)");
        goto ErrorReturn;
    }
    // Need to sleep to allow the registry notification to occur.
    Sleep(200);

    // With the CA cert added, the verify policy should succeed
    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_NT_AUTH,
            pChainContext,
            &PolicyPara,
            &PolicyStatus
            )) {
        PrintLastError(
            "CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_NT_AUTH)");
        fResult = FALSE;
    } else if (0 != PolicyStatus.dwError) {
        if ((CRYPT_E_NO_REVOCATION_CHECK == dwExpectedErr ||
                CRYPT_E_REVOCATION_OFFLINE == dwExpectedErr)
                        &&
                dwExpectedErr == PolicyStatus.dwError) {
            PrintStatus("NTAuth got expected error adding NTAuth CA = ",
                (LONG) dwExpectedErr);
        } else {
            PrintStatus("NTAuth failed after adding NTAuth CA with dwError = ",
                (LONG) PolicyStatus.dwError);
            fResult = FALSE;
        }
    }

    CertDeleteCertificateFromStore(pAddCert);
    pAddCert = NULL;
    // Need to sleep to allow the registry notification to occur.
    Sleep(200);

    // With the CA cert deleted, the verify policy should fail
    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_NT_AUTH,
            pChainContext,
            &PolicyPara,
            &PolicyStatus
            )) {
        PrintLastError(
            "CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_NT_AUTH)");
        fResult = FALSE;
    } else if (CERT_E_UNTRUSTEDCA != PolicyStatus.dwError) {
        PrintStatus("NTAuth failed without CERT_E_UNTRUSTEDCA after deleting NTAuth CA with dwError = ",
            (LONG) PolicyStatus.dwError);
        fResult = FALSE;
    }

CommonReturn:
    if (hNTAuthStore)
        CertCloseStore(hNTAuthStore, 0);
    return fResult;
ErrorReturn:
    if (pAddCert)
        CertDeleteCertificateFromStore(pAddCert);
    fResult = FALSE;
    goto CommonReturn;
}

BOOL NTAuthNameConstraintVerify(
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN DWORD dwExpectedErr
    )
{
    BOOL fResult = FALSE;
    DWORD dwErr;

    CERT_CHAIN_POLICY_PARA PolicyPara;
    memset(&PolicyPara, 0, sizeof(PolicyPara));
    PolicyPara.cbSize = sizeof(PolicyPara);
    PolicyPara.dwFlags = CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG;

    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    memset(&PolicyStatus, 0, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);

    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_NT_AUTH,
            pChainContext,
            &PolicyPara,
            &PolicyStatus
            )) {
        PrintLastError(
            "CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_NT_AUTH)");
        goto CommonReturn;
    }
    dwErr = PolicyStatus.dwError;

    if (dwExpectedErr == dwErr) {
        PrintStatus("NTAuthNameConstraint returned expected => ",
            (LONG) dwExpectedErr);
        fResult = TRUE;
    } else {
        PrintStatus("Expected => ", (LONG) dwExpectedErr);
        PrintStatus("NTAuthNameConstraint failed => ", (LONG) dwErr);
    }


CommonReturn:
    return fResult;
}

void DeleteSaferRegKey()
{
    HKEY hKey = NULL;
    LONG err;

    if (ERROR_SUCCESS != (err = RegOpenKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_TRUST_PUB_SAFER_LOCAL_MACHINE_REGPATH,
            0,                      // dwReserved
            KEY_ALL_ACCESS,
            &hKey
            ))) {
        if (ERROR_FILE_NOT_FOUND != err)
            PrintError("RegOpenKey(SAFER) failed", (DWORD) err);
        goto CommonReturn;
    }

    RegDeleteValueU(hKey, CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME);

CommonReturn:
    if (hKey)
        RegCloseKey(hKey);
}

void SetSaferRegKeyValue(
    IN LPCWSTR pwszValueName,
    IN DWORD dwValue
    )
{
    LONG err;
    DWORD dwDisposition;
    HKEY hKey = NULL;

    if (ERROR_SUCCESS != (err = RegCreateKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_TRUST_PUB_SAFER_LOCAL_MACHINE_REGPATH,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            MAXIMUM_ALLOWED,
            NULL,                   // lpSecurityAttributes
            &hKey,
            &dwDisposition))) {
        PrintError("RegCreateKey(SAFER) failed", (DWORD) err);
        goto CommonReturn;
    }

    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hKey,
            pwszValueName,
            0,          // dwReserved
            REG_DWORD,
            (BYTE *) &dwValue,
            sizeof(DWORD)))) {
        PrintError("RegSetValue(SAFER) failed", (DWORD) err);
        goto CommonReturn;
    }

CommonReturn:
    if (hKey)
        RegCloseKey(hKey);
}


void SetRootAutoUpdateValue(
    IN DWORD dwValue
    )
{
    LONG err;
    DWORD dwDisposition;
    HKEY hKey = NULL;

    if (ERROR_SUCCESS != (err = RegCreateKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_OCM_SUBCOMPONENTS_LOCAL_MACHINE_REGPATH,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            MAXIMUM_ALLOWED,
            NULL,                   // lpSecurityAttributes
            &hKey,
            &dwDisposition))) {
        PrintError("RegCreateKey(OCM Subcomponents) failed", (DWORD) err);
        goto CommonReturn;
    }

    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hKey,
            CERT_OCM_SUBCOMPONENTS_ROOT_AUTO_UPDATE_VALUE_NAME,
            0,          // dwReserved
            REG_DWORD,
            (BYTE *) &dwValue,
            sizeof(DWORD)))) {
        PrintError("RegSetValue(RootAutoUpdate) failed", (DWORD) err);
        goto CommonReturn;
    }

CommonReturn:
    if (hKey)
        RegCloseKey(hKey);
}

void SetAuthRootAutoUpdateFlags(
    IN DWORD dwSetValue,
    IN BOOL fEnable
    )
{
    LONG err;
    DWORD dwDisposition;
    HKEY hKey = NULL;
    DWORD dwValue = 0;
    DWORD cbValue = sizeof(dwValue);
    DWORD dwType = 0;

    if (ERROR_SUCCESS != (err = RegCreateKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_AUTH_ROOT_AUTO_UPDATE_LOCAL_MACHINE_REGPATH,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            MAXIMUM_ALLOWED,
            NULL,                   // lpSecurityAttributes
            &hKey,
            &dwDisposition))) {
        PrintError("RegCreateKey(AuthRootAutoUpdate) failed", (DWORD) err);
        goto CommonReturn;
    }

    RegQueryValueExU(
        hKey,
        CERT_AUTH_ROOT_AUTO_UPDATE_FLAGS_VALUE_NAME,
        NULL,       // pdwReserved
        &dwType,
        (BYTE *) &dwValue,
        &cbValue
        );

    if (fEnable)
        dwValue |= dwSetValue;
    else
        dwValue &= ~dwSetValue;

    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hKey,
            CERT_AUTH_ROOT_AUTO_UPDATE_FLAGS_VALUE_NAME,
            0,          // dwReserved
            REG_DWORD,
            (BYTE *) &dwValue,
            sizeof(DWORD)))) {
        PrintError("RegSetValue(AuthRootAutoUpdate) failed", (DWORD) err);
        goto CommonReturn;
    }

CommonReturn:
    if (hKey)
        RegCloseKey(hKey);
}

void SetProtectedRootsFlags(
    IN DWORD dwSetValue,
    IN BOOL fEnable
    )
{
    LONG err;
    DWORD dwDisposition;
    HKEY hKey = NULL;
    DWORD dwValue = 0;
    DWORD cbValue = sizeof(dwValue);
    DWORD dwType = 0;

    if (ERROR_SUCCESS != (err = RegCreateKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_PROT_ROOT_FLAGS_REGPATH,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            MAXIMUM_ALLOWED,
            NULL,                   // lpSecurityAttributes
            &hKey,
            &dwDisposition))) {
        PrintError("RegCreateKey(ProtectedRoots) failed", (DWORD) err);
        goto CommonReturn;
    }

    RegQueryValueExU(
        hKey,
        CERT_PROT_ROOT_FLAGS_VALUE_NAME,
        NULL,       // pdwReserved
        &dwType,
        (BYTE *) &dwValue,
        &cbValue
        );

    if (fEnable)
        dwValue |= dwSetValue;
    else
        dwValue &= ~dwSetValue;

    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hKey,
            CERT_PROT_ROOT_FLAGS_VALUE_NAME,
            0,          // dwReserved
            REG_DWORD,
            (BYTE *) &dwValue,
            sizeof(DWORD)))) {
        PrintError("RegSetValue(ProtectedRootsFlags) failed", (DWORD) err);
        goto CommonReturn;
    }

CommonReturn:
    if (hKey)
        RegCloseKey(hKey);
}

void SetCertChainConfigRegKeyValue(
    IN LPCSTR pszValueName,
    IN DWORD dwValue
    )
{
    LONG err;
    DWORD dwDisposition;
    HKEY hKey = NULL;

    if (ERROR_SUCCESS != (err = RegCreateKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_CHAIN_CONFIG_REGPATH,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            MAXIMUM_ALLOWED,
            NULL,                   // lpSecurityAttributes
            &hKey,
            &dwDisposition))) {
        PrintError("RegCreateKey(CERT_CHAIN_CONFIG) failed", (DWORD) err);
        goto CommonReturn;
    }

    if (0xFFFFFFFF == dwValue) {
        err = RegDeleteValueA(hKey, pszValueName);
        if (ERROR_FILE_NOT_FOUND == err)
            ;
        else if (ERROR_SUCCESS != err) {
            printf("RegDeleteValue(%s) failed => 0x%x (%d)\n",
                pszValueName, (DWORD) err, (DWORD) err);
            goto CommonReturn;
        }
    } else {
        if (ERROR_SUCCESS != (err = RegSetValueExA(
                hKey,
                pszValueName,
                0,          // dwReserved
                REG_DWORD,
                (BYTE *) &dwValue,
                sizeof(DWORD)))) {
            printf("RegSetValue(%s) failed => 0x%x (%d)\n",
                pszValueName, (DWORD) err, (DWORD) err);
            goto CommonReturn;
            goto CommonReturn;
        }
    }

CommonReturn:
    if (hKey)
        RegCloseKey(hKey);
}

int _cdecl main(int argc, char * argv[]) 
{


    BOOL fResult;
    int status;
    LONG lStatus;
    DWORD dwDisplayFlags = 0;
    DWORD i;

#define TRUST_TYPE_CERT     1
#define TRUST_TYPE_FILE     2
#define TRUST_TYPE_HTTPS    3
#define TRUST_TYPE_DRIVER   4
    DWORD dwTrustType = TRUST_TYPE_CERT;

    BOOL fChain = FALSE;
    BOOL fChainCallback = FALSE;
    DWORD dwFlags = 0;
    BOOL fQuiet = FALSE;
    LONG lWVTExpected = 0;

    LPSTR pszCertOrFile = NULL;         // not allocated
    LPSTR pszUsageOID = NULL;           // not allocated
    LPSTR pszSignerUsage = szOID_KP_CTL_USAGE_SIGNING;

    GUID wvtFileActionID = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    GUID wvtCertActionID = WINTRUST_ACTION_GENERIC_CERT_VERIFY;
    GUID wvtHttpsActionID = HTTPSPROV_ACTION;
    GUID wvtDriverActionID = DRIVER_ACTION_VERIFY;
    GUID wvtChainActionID = WINTRUST_ACTION_GENERIC_CHAIN_VERIFY;
    GUID *pwvtActionID;

    CRYPT_PROVIDER_DATA *pProvData;     // not allocated

    WINTRUST_FILE_INFO wvtFileInfo;
    memset(&wvtFileInfo, 0, sizeof(wvtFileInfo));
    wvtFileInfo.cbStruct = sizeof(wvtFileInfo);
    wvtFileInfo.pcwszFilePath = NULL;

#define MAX_CERT_STORE  10
    HCERTSTORE rghStore[MAX_CERT_STORE];

    WINTRUST_CERT_INFO wvtCertInfo;
    memset(&wvtCertInfo, 0, sizeof(wvtCertInfo));
    wvtCertInfo.cbStruct = sizeof(wvtCertInfo);
    wvtCertInfo.psCertContext = NULL;
    wvtCertInfo.chStores = 0;
    wvtCertInfo.pahStores = rghStore;
    wvtCertInfo.dwFlags = 0;
    wvtCertInfo.pcwszDisplayName = L"Cert Display Name";

    HTTPSPolicyCallbackData httpsPolicyCallbackData;
    memset(&httpsPolicyCallbackData, 0, sizeof(httpsPolicyCallbackData));
    httpsPolicyCallbackData.cbStruct = sizeof(httpsPolicyCallbackData);
    httpsPolicyCallbackData.dwAuthType = AUTHTYPE_CLIENT;
    httpsPolicyCallbackData.fdwChecks = 0;

    DRIVER_VER_INFO DriverVerInfo;
    memset(&DriverVerInfo, 0, sizeof(DriverVerInfo));
    DriverVerInfo.cbStruct = sizeof(DriverVerInfo);

    CERT_CHAIN_PARA ChainPara;
    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);

#define MAX_USAGE_CNT               16
    LPSTR rgpszUsageOID[MAX_USAGE_CNT];
    DWORD cUsageOID = 0;
    DWORD dwUsageType = USAGE_MATCH_TYPE_AND;

#define MAX_POLICY_CNT              16
    LPSTR rgpszPolicyOID[MAX_POLICY_CNT];
    DWORD cPolicyOID = 0;
    DWORD dwPolicyUsageType = USAGE_MATCH_TYPE_AND;

    WTD_GENERIC_CHAIN_POLICY_CREATE_INFO ChainInfo;
    memset(&ChainInfo, 0, sizeof(ChainInfo));
    ChainInfo.cbSize = sizeof(ChainInfo);
    ChainInfo.pChainPara = &ChainPara;

    WTD_GENERIC_CHAIN_POLICY_DATA wtdChainPolicyData;
    memset(&wtdChainPolicyData, 0, sizeof(wtdChainPolicyData));
    wtdChainPolicyData.cbSize = sizeof(wtdChainPolicyData);
    wtdChainPolicyData.pvPolicyArg = (void *) CHAIN_POLICY_ARG;


    WINTRUST_DATA wvtData;
    memset(&wvtData, 0, sizeof(wvtData));
    wvtData.cbStruct = sizeof(wvtData);
    wvtData.pPolicyCallbackData = NULL;
    wvtData.dwUIChoice = WTD_UI_NONE;
    wvtData.fdwRevocationChecks = WTD_REVOKE_NONE;
    wvtData.dwUnionChoice = WTD_CHOICE_CERT;
    wvtData.pCert = &wvtCertInfo;
    wvtData.dwStateAction = WTD_STATEACTION_IGNORE;
    wvtData.hWVTStateData = NULL;
    wvtData.dwProvFlags = 0;

    BOOL fDisplayKnownUsages = FALSE;
    BOOL fNTAuth = FALSE;
    BOOL fNTAuthNameConstraint = FALSE;

    BOOL fLogoffNotification = FALSE;

    BOOL fDeferClosing = FALSE;

    BOOL fExpectedTrustErrorStatus  = FALSE;
    DWORD dwExpectedTrustErrorStatus = 0;
    BOOL fExpectedTrustInfoStatus  = FALSE;
    DWORD dwExpectedTrustInfoStatus = 0;

    DWORD dwUrlRetrievalTimeout = 0;
    BOOL fCheckRevocationFreshnessTime = FALSE;
    DWORD dwRevocationFreshnessTime;

    BOOL fSafer = FALSE;
    BOOL fMicrosoftRoot = FALSE;
    BOOL fMicrosoftTestRoot = FALSE;
    BOOL fNotMicrosoftRoot = FALSE;


    while (--argc>0) {
        if (**++argv == '-')
        {
            if (0 == _stricmp(argv[0]+1, "Cert")) {
                wvtData.dwUnionChoice = WTD_CHOICE_CERT;
                dwTrustType = TRUST_TYPE_CERT;
            } else if (0 == _stricmp(argv[0]+1, "File")) {
                wvtData.dwUnionChoice = WTD_CHOICE_FILE;
                dwTrustType = TRUST_TYPE_FILE;
            } else if (0 == _stricmp(argv[0]+1, "Driver")) {
                wvtData.dwUnionChoice = WTD_CHOICE_FILE;
                dwTrustType = TRUST_TYPE_DRIVER;
            } else if (0 == _stricmp(argv[0]+1, "Https")) {
                wvtData.dwUnionChoice = WTD_CHOICE_CERT;
                dwTrustType = TRUST_TYPE_HTTPS;

            } else if (0 == _stricmp(argv[0]+1, "Chain")) {
                fChain = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "ChainCallback")) {
                fChain = TRUE;
                fChainCallback = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "NTAuth")) {
                fNTAuth = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "NTAuthNameConstraint")) {
                fNTAuth = TRUE;
                fNTAuthNameConstraint = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "Safer")) {
                wvtData.dwUnionChoice = WTD_CHOICE_FILE;
                dwTrustType = TRUST_TYPE_FILE;
                fSafer = TRUE;

            } else if (0 == _stricmp(argv[0]+1, "Client")) {
                httpsPolicyCallbackData.dwAuthType = AUTHTYPE_CLIENT;
            } else if (0 == _stricmp(argv[0]+1, "Server")) {
                httpsPolicyCallbackData.dwAuthType = AUTHTYPE_SERVER;

            } else if (0 == _stricmp(argv[0]+1, "UIAll")) {
                wvtData.dwUIChoice = WTD_UI_ALL;
            } else if (0 == _stricmp(argv[0]+1, "UINone")) {
                wvtData.dwUIChoice = WTD_UI_NONE;
            } else if (0 == _stricmp(argv[0]+1, "UINoBad")) {
                wvtData.dwUIChoice = WTD_UI_NOBAD;
            } else if (0 == _stricmp(argv[0]+1, "UINoGood")) {
                wvtData.dwUIChoice = WTD_UI_NOGOOD;
            } else if (0 == _stricmp(argv[0]+1, "RevokeNone")) {
                wvtData.fdwRevocationChecks = WTD_REVOKE_NONE;
            } else if (0 == _stricmp(argv[0]+1, "RevokeChain")) {
                wvtData.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;

            } else if (0 == _stricmp(argv[0]+1, "UseIE4Trust")) {
                wvtData.dwProvFlags |= WTD_USE_IE4_TRUST_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "NoIE4Chain")) {
                wvtData.dwProvFlags |= WTD_NO_IE4_CHAIN_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "NoUsage")) {
                wvtData.dwProvFlags |= WTD_NO_POLICY_USAGE_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "OrUsage")) {
                dwUsageType = USAGE_MATCH_TYPE_OR;
            } else if (0 == _stricmp(argv[0]+1, "OrPolicy")) {
                dwPolicyUsageType = USAGE_MATCH_TYPE_OR;
            } else if (0 == _stricmp(argv[0]+1, "LifetimeSigning")) {
                wvtData.dwProvFlags |= WTD_LIFETIME_SIGNING_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "MicrosoftRoot")) {
                fMicrosoftRoot = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "MicrosoftTestRoot")) {
                fMicrosoftTestRoot = TRUE;
                fMicrosoftRoot = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "NotMicrosoftRoot")) {
                fNotMicrosoftRoot = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "FlushCrl")) {
                fFlushCrl = TRUE;

            } else if (0 == _stricmp(argv[0]+1, "DeferClosing")) {
                fDeferClosing = TRUE;

            } else if (0 == _stricmp(argv[0]+1, "DisplayKnownUsages")) {
                fDisplayKnownUsages = TRUE;

            } else if (0 == _stricmp(argv[0]+1, "HttpsIgnoreRevocation")) {
                httpsPolicyCallbackData.fdwChecks |=
                    SECURITY_FLAG_IGNORE_REVOCATION;
            } else if (0 == _stricmp(argv[0]+1, "HttpsIgnoreUnknownCA")) {
                httpsPolicyCallbackData.fdwChecks |=
                    SECURITY_FLAG_IGNORE_UNKNOWN_CA;
            } else if (0 == _stricmp(argv[0]+1, "HttpsIgnoreWrongUsage")) {
                httpsPolicyCallbackData.fdwChecks |=
                    SECURITY_FLAG_IGNORE_WRONG_USAGE;
            } else if (0 == _stricmp(argv[0]+1, "HttpsIgnoreCertDateInvalid")) {
                httpsPolicyCallbackData.fdwChecks |=
                    SECURITY_FLAG_IGNORE_CERT_DATE_INVALID;
            } else if (0 == _stricmp(argv[0]+1, "HttpsIgnoreCertCNInvalid")) {
                httpsPolicyCallbackData.fdwChecks |=
                    SECURITY_FLAG_IGNORE_CERT_CN_INVALID;

            } else if (0 == _stricmp(argv[0]+1, "DontOpenStores")) {
                wvtCertInfo.dwFlags = WTCI_DONT_OPEN_STORES;
            } else if (0 == _stricmp(argv[0]+1, "OpenOnlyRoot")) {
                wvtCertInfo.dwFlags = WTCI_OPEN_ONLY_ROOT;

            } else if (0 == _stricmp(argv[0]+1,
                    "InstallThreadDefaultContext")) {
                fInstallDefaultContext = TRUE;
                dwDefaultContextFlags &= ~CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG;
            } else if (0 == _stricmp(argv[0]+1,
                    "InstallProcessDefaultContext")) {
                fInstallDefaultContext = TRUE;
                dwDefaultContextFlags |= CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG;
            } else if (0 == _stricmp(argv[0]+1,
                    "AutoReleaseDefaultContext")) {
                dwDefaultContextFlags |=
                    CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG;
            } else if (0 == _stricmp(argv[0]+1,
                    "NULLDefaultContext")) {
                fNULLDefaultContext = TRUE;
            } else if (0 == _stricmp(argv[0]+1,
                    "MultiDefaultContext")) {
                fMultiDefaultContext = TRUE;
            } else if (0 == _stricmp(argv[0]+1,
                    "LogoffNotification")) {
                fLogoffNotification = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "AuthenticodeFlags")) {
                DWORD dwFlags;

                if (argc < 2 || argv[1][0] == '-') {
                    printf("Option (-AuthenticodeFlags) : missing number argument\n");
                    goto BadUsage;
                }
                dwFlags = strtoul(argv[1], NULL, 0);
                argc -= 1;
                argv += 1;

                SetSaferRegKeyValue(
                    CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME, dwFlags);
            } else if (0 == _stricmp(argv[0]+1, "DisableMandatoryBasicConstraints") ||
                    0 == _stricmp(argv[0]+1, "DisableAIAUrlRetrieval") ||
                    0 == _stricmp(argv[0]+1, "MaxAIAUrlCountInCert") ||
                    0 == _stricmp(argv[0]+1, "MaxAIAUrlRetrievalCountPerChain") ||
                    0 == _stricmp(argv[0]+1, "MaxAIAUrlRetrievalByteCount") ||
                    0 == _stricmp(argv[0]+1, "MaxAIAUrlRetrievalCertCount")) {
                LPCSTR pszOption = argv[0]+1;
                DWORD dwValue;

                if (argc < 2 || argv[1][0] == '-') {
                    printf("Option (-%s) : missing number argument\n",
                        pszOption);
                    goto BadUsage;
                }
                dwValue = strtoul(argv[1], NULL, 0);
                argc -= 1;
                argv += 1;

                SetCertChainConfigRegKeyValue(pszOption, dwValue);
            } else if (0 == _stricmp(argv[0]+1, "DeleteSaferRegKey")) {
                DeleteSaferRegKey();
            } else if (0 == _stricmp(argv[0]+1, "EnableRootAutoUpdate")) {
                SetRootAutoUpdateValue(0x1);
            } else if (0 == _stricmp(argv[0]+1, "DisableRootAutoUpdate")) {
                SetRootAutoUpdateValue(0x0);
            } else if (0 == _stricmp(argv[0]+1, "EnableUntrustedRootLogging")) {
                SetAuthRootAutoUpdateFlags(
                    CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG,
                    FALSE);
            } else if (0 == _stricmp(argv[0]+1,
                    "DisableUntrustedRootLogging")) {
                SetAuthRootAutoUpdateFlags(
                    CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG,
                    TRUE);
            } else if (0 == _stricmp(argv[0]+1, "EnablePartialChainLogging")) {
                SetAuthRootAutoUpdateFlags(
                    CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG,
                    FALSE);
            } else if (0 == _stricmp(argv[0]+1,
                    "DisablePartialChainLogging")) {
                SetAuthRootAutoUpdateFlags(
                    CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG,
                    TRUE);
            } else if (0 == _stricmp(argv[0]+1, "EnableNTAuthRequired")) {
                SetProtectedRootsFlags(
                    CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG,
                    FALSE);
            } else if (0 == _stricmp(argv[0]+1,
                    "DisableNTAuthRequired")) {
                SetProtectedRootsFlags(
                    CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG,
                    TRUE);
            } else if (0 == _stricmp(argv[0]+1, "EnableNotDefinedNameConstraint")) {
                SetProtectedRootsFlags(
                    CERT_PROT_ROOT_DISABLE_NOT_DEFINED_NAME_CONSTRAINT_FLAG,
                    FALSE);
            } else if (0 == _stricmp(argv[0]+1, "DisableNotDefinedNameConstraint")) {
                SetProtectedRootsFlags(
                    CERT_PROT_ROOT_DISABLE_NOT_DEFINED_NAME_CONSTRAINT_FLAG,
                    TRUE);
            } else if (0 == _stricmp(argv[0]+1, "EnableAuthRoot")) {
                SetProtectedRootsFlags(
                    CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG,
                    FALSE);
            } else if (0 == _stricmp(argv[0]+1, "DisableAuthRoot")) {
                SetProtectedRootsFlags(
                    CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG,
                    TRUE);
            } else if (0 == _stricmp(argv[0]+1, "RegistryOnlyExit")) {
                goto RegistryOnlyExit;
            } else {
                switch(argv[0][1])
                {
                case 's':
                case 'S':
                    if (wvtCertInfo.chStores >= MAX_CERT_STORE) {
                        printf("Exceed maximum number of stores %d\n",
                            MAX_CERT_STORE);
                        goto BadUsage;
                    }
                    if (NULL == (rghStore[wvtCertInfo.chStores] =
                            OpenSystemStoreOrFile(
                                argv[0][1] == 's',  // fSystemStore
                                argv[0]+2,
                                0                   // dwFlags
                                )))
                        goto BadUsage;
                    wvtCertInfo.chStores++;
                    break;

                case 'b':
                    dwDisplayFlags |= DISPLAY_BRIEF_FLAG;
                    break;
                case 'v':
                    dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                    break;
                case 'u':
                    if (MAX_USAGE_CNT <= cUsageOID) {
                        printf("Too many usages\n");
                        goto BadUsage;
                    }
                    if (0 == cUsageOID)
                        pszUsageOID = argv[0]+2;
                    rgpszUsageOID[cUsageOID++] = argv[0]+2;
                    break;
                case 'p':
                    if (MAX_POLICY_CNT <= cPolicyOID) {
                        printf("Too many policies\n");
                        goto BadUsage;
                    }
                    rgpszPolicyOID[cPolicyOID++] = argv[0]+2;
                    break;
                case 'n':
                    httpsPolicyCallbackData.pwszServerName = 
                        AllocAndSzToWsz(argv[0]+2);
                    break;
                case 'f':
                    dwFlags = (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'e':
                    fExpectedTrustErrorStatus = TRUE;
                        dwExpectedTrustErrorStatus =
                            (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'i':
                    fExpectedTrustInfoStatus = TRUE;
                        dwExpectedTrustInfoStatus =
                            (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 't':
                    dwUrlRetrievalTimeout = (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'r':
                    fCheckRevocationFreshnessTime = TRUE;
                    dwRevocationFreshnessTime =
                        (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'q':
                    fQuiet = TRUE;
                    if (argv[0][2])
                        lWVTExpected = (LONG) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'h':
                default:
                    goto BadUsage;
                }
            }
        } else {
            if (pszCertOrFile) {
                printf("Multiple certs or filenames not supported\n");
                goto BadUsage;
            }
            pszCertOrFile = argv[0];
        }
    }

    if (NULL == pszCertOrFile) {
        printf("Missing cert or filename\n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    if (fDisplayKnownUsages) {
        PCCRYPT_OID_INFO *ppOidInfo = NULL;

        if (WTHelperGetKnownUsages(WTH_ALLOC, &ppOidInfo)) {
            for (DWORD i = 0; ppOidInfo[i]; i++)
                printf("Usage[%d]:: OID: %s Name: %S\n",
                    i, ppOidInfo[i]->pszOID, ppOidInfo[i]->pwszName);
            WTHelperGetKnownUsages(WTH_FREE, &ppOidInfo);
        }
    }

    switch (wvtData.dwUnionChoice) {
        case WTD_CHOICE_FILE:
            if (TRUST_TYPE_DRIVER == dwTrustType) {
                pwvtActionID = &wvtDriverActionID;
                wvtData.pPolicyCallbackData = (void *) &DriverVerInfo;
            } else {
                pwvtActionID = &wvtFileActionID;
            }
            wvtData.pFile = &wvtFileInfo;
            wvtFileInfo.pcwszFilePath = AllocAndSzToWsz(pszCertOrFile);
            break;
        case WTD_CHOICE_CERT:
            if (TRUST_TYPE_HTTPS == dwTrustType) {
                pwvtActionID = &wvtHttpsActionID;
                wvtData.pPolicyCallbackData =
                    (void *) &httpsPolicyCallbackData;
            } else {
                pwvtActionID = &wvtCertActionID;
                wvtData.pPolicyCallbackData = (void *) pszUsageOID;
            }
            wvtData.pCert = &wvtCertInfo;
            if (NULL == (wvtCertInfo.psCertContext =
                    (CERT_CONTEXT *) ReadCert(pszCertOrFile)))
                goto ErrorReturn;

            if (fDeferClosing && 1 == wvtCertInfo.chStores) {

                HCERTSTORE hDeferStore = NULL;
                PCCERT_CONTEXT pDeferCert = NULL;
                PCCERT_CONTEXT pAddCert = NULL;
                PCCERT_CHAIN_CONTEXT pDeferChain = NULL;
                CERT_CHAIN_PARA DeferChainPara;

                if (NULL == (hDeferStore = CertOpenStore(
                        CERT_STORE_PROV_MEMORY,
                        X509_ASN_ENCODING,
                        0,
                        CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                        NULL))) {
                    PrintLastError("CertOpenStore(DeferClosing)");
                    goto ErrorReturn;
                }

                while (pAddCert = CertEnumCertificatesInStore(
                        wvtCertInfo.pahStores[0],
                        pAddCert))
                    CertAddCertificateContextToStore(
                        hDeferStore,
                        pAddCert,
                        CERT_STORE_ADD_USE_EXISTING,
                        NULL
                        );

                if (!CertAddCertificateContextToStore(
                        hDeferStore,
                        wvtCertInfo.psCertContext,
                        CERT_STORE_ADD_USE_EXISTING,
                        &pDeferCert
                        )) {
                    PrintLastError("CertAddCertificateContextToStore(DeferClosing)");
                    CertCloseStore(hDeferStore, 0);
                    goto ErrorReturn;
                }

                CertCloseStore(hDeferStore, 0);

                memset(&DeferChainPara, 0, sizeof(DeferChainPara));
                DeferChainPara.cbSize = sizeof(DeferChainPara);

                CertGetCertificateChain(
                    NULL,                   // hChainEngine
                    pDeferCert,
                    NULL,                   // pTime
                    hDeferStore,
                    &DeferChainPara,
                    CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
                    NULL,                   // pvReserved
                    &pDeferChain
                    );

                CertFreeCertificateContext(pDeferCert);
                if (pDeferChain)
                    CertFreeCertificateChain(pDeferChain);
            }
            break;
        default:
            goto BadUsage;
    }

    if (fChain) {
        pwvtActionID = &wvtChainActionID;
        if (fChainCallback || dwFlags || cUsageOID || cPolicyOID ||
                0 != dwUrlRetrievalTimeout || fCheckRevocationFreshnessTime) {
            wvtData.pPolicyCallbackData = (void *) &wtdChainPolicyData;
            if (fChainCallback)
                wtdChainPolicyData.pfnPolicyCallback = ChainPolicyCallback;
            if (dwFlags || cUsageOID || cPolicyOID ||
                    0 != dwUrlRetrievalTimeout ||
                    fCheckRevocationFreshnessTime) {
                ChainInfo.dwFlags = dwFlags;
                wtdChainPolicyData.pSignerChainInfo = &ChainInfo;
                wtdChainPolicyData.pCounterSignerChainInfo = &ChainInfo;

                ChainPara.RequestedUsage.dwType = dwUsageType;
                ChainPara.RequestedUsage.Usage.cUsageIdentifier = cUsageOID;
                ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier =
                        rgpszUsageOID;

                ChainPara.RequestedIssuancePolicy.dwType = dwPolicyUsageType;
                ChainPara.RequestedIssuancePolicy.Usage.cUsageIdentifier =
                    cPolicyOID;
                ChainPara.RequestedIssuancePolicy.Usage.rgpszUsageIdentifier =
                        rgpszPolicyOID;

                ChainPara.dwUrlRetrievalTimeout = dwUrlRetrievalTimeout;
                ChainPara.fCheckRevocationFreshnessTime =
                    fCheckRevocationFreshnessTime;
                ChainPara.dwRevocationFreshnessTime = dwRevocationFreshnessTime;
            }
        }

        if (0 != (dwFlags & CERT_CHAIN_CACHE_END_CERT) &&
                WTD_CHOICE_CERT == wvtData.dwUnionChoice) {
            // Do an extra verify to ensure the cache is loaded on the
            // next call
            wvtData.dwStateAction = WTD_STATEACTION_IGNORE;
            WinVerifyTrust(
                NULL,               // hwnd
                pwvtActionID,
                &wvtData
                );

            CertFreeCertificateContext(wvtCertInfo.psCertContext);
            if (NULL == (wvtCertInfo.psCertContext =
                    (CERT_CONTEXT *) ReadCert(pszCertOrFile)))
                goto ErrorReturn;
        }
    }

    if (fExpectedTrustErrorStatus || fExpectedTrustInfoStatus)
        wvtData.dwStateAction = WTD_STATEACTION_VERIFY;
    else if (fQuiet && !fNTAuth)
        wvtData.dwStateAction = WTD_STATEACTION_IGNORE;
    else
        wvtData.dwStateAction = WTD_STATEACTION_VERIFY;

    if (fInstallDefaultContext)
        InstallDefaultContext();

    if (fSafer) {
        DWORD dwFlags;
        BOOL fHasValue;
        DWORD dwLastError;

        wvtData.dwProvFlags |= WTD_SAFER_FLAG;
        lStatus = WinVerifyTrust(
                NULL,               // hwnd
                pwvtActionID,
                &wvtData
                );
        dwLastError = GetLastError();


        fHasValue = I_CryptReadTrustedPublisherDWORDValueFromRegistry(
                CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME,
                &dwFlags
                );
        printf("AuthenticodeFlags: ");
        if (fHasValue)
            printf("0x%x\n", dwFlags);
        else
            printf("NONE\n");

        dwFlags = 0;
        WintrustGetRegPolicyFlags(&dwFlags);
        printf("WintrustFlags: 0x%x\n", dwFlags);

        PrintStatus("LastError: ", (LONG) dwLastError);

        if (wvtFileInfo.pcwszFilePath) {
            BYTE rgbFileHash[20];
            DWORD cbFileHash = 20;
            ALG_ID HashAlgid = 0;
            LONG lHashStatus;
            PCCRYPT_OID_INFO pOIDInfo;

            lHashStatus = WTHelperGetFileHash(
                wvtFileInfo.pcwszFilePath,
                0,              // dwFlags
                NULL,           // pvReserved
                rgbFileHash,
                &cbFileHash,
                &HashAlgid
                );

            PrintStatus("HashStatus: ", lHashStatus);
            printf("HashAlgid: 0x%x", HashAlgid);
            pOIDInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_ALGID_KEY,
                &HashAlgid,
                CRYPT_HASH_ALG_OID_GROUP_ID
                );
            if (pOIDInfo)
                printf(" %S", pOIDInfo->pwszName);
            
            printf("\n");
            if (cbFileHash) {
                PrintBytes("File Hash:: ", rgbFileHash, cbFileHash);
            }
        }
    } else
        lStatus = WinVerifyTrust(
                NULL,               // hwnd
                pwvtActionID,
                &wvtData
                );

    if (fExpectedTrustErrorStatus || fExpectedTrustInfoStatus) {
        if (NULL == (pProvData = WTHelperProvDataFromStateData(
                wvtData.hWVTStateData))) {
            printf("TrustStatus:: failed => no WVTStateData\n");
            goto ErrorReturn;
        }

        fResult = FALSE;
        if (0 == pProvData->csSigners)
            printf("TrustStatus:: failed => No Signers\n");
        else {
            CRYPT_PROVIDER_SGNR *pProvSign;

            pProvSign = WTHelperGetProvSignerFromChain(
                pProvData,
                0,              // idxSigner
                FALSE,          // fCounterSigner
                0               // idxCounterSigner
                );
            if (pProvSign && pProvSign->pChainContext) {
                const CERT_TRUST_STATUS *pTrustStatus =
                    &pProvSign->pChainContext->TrustStatus;

                fResult = TRUE;
                if (fExpectedTrustErrorStatus) {
                    if (dwExpectedTrustErrorStatus == pTrustStatus->dwErrorStatus) {
                        if (0 != dwExpectedTrustErrorStatus)
                            printf("ChainContext has Expected TrustErrorStatus => 0x%x\n",
                                dwExpectedTrustErrorStatus);
                    } else {
                        fResult = FALSE;
                        printf("Expected => 0x%x ChainContext TrustErrorStatus failed => 0x%x\n",
                            dwExpectedTrustErrorStatus,
                            pTrustStatus->dwErrorStatus
                            );
                    }
                }

                if (fExpectedTrustInfoStatus) {
                    if (dwExpectedTrustInfoStatus == pTrustStatus->dwInfoStatus) {
                        if (0 != dwExpectedTrustInfoStatus)
                            printf("ChainContext has Expected TrustInfoStatus => 0x%x\n",
                                dwExpectedTrustInfoStatus);
                    } else {
                        fResult = FALSE;
                        printf("Expected => 0x%x ChainContext TrustInfoStatus failed => 0x%x\n",
                            dwExpectedTrustInfoStatus,
                            pTrustStatus->dwInfoStatus
                            );
                    }
                }

                if (fMicrosoftRoot || fNotMicrosoftRoot) {
                    // Check if the top level certificate contains the public
                    // key for the Microsoft root.

                    CERT_CHAIN_POLICY_PARA MicrosoftRootPolicyPara;
                    CERT_CHAIN_POLICY_STATUS MicrosoftRootPolicyStatus;

                    memset(&MicrosoftRootPolicyPara, 0,
                        sizeof(MicrosoftRootPolicyPara));
                    MicrosoftRootPolicyPara.cbSize =
                        sizeof(MicrosoftRootPolicyPara);
                    memset(&MicrosoftRootPolicyStatus, 0,
                        sizeof(MicrosoftRootPolicyStatus));
                    MicrosoftRootPolicyStatus.cbSize =
                        sizeof(MicrosoftRootPolicyStatus);

                    if (fMicrosoftTestRoot)
                        MicrosoftRootPolicyPara.dwFlags |=
                            MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG;

                    if (!CertVerifyCertificateChainPolicy(
                            CERT_CHAIN_POLICY_MICROSOFT_ROOT,
                            pProvSign->pChainContext,
                            &MicrosoftRootPolicyPara,
                            &MicrosoftRootPolicyStatus
                            )) {
                        PrintLastError("CERT_CHAIN_POLICY_MICROSOFT_ROOT");
                    } else {
                        if (fMicrosoftRoot) {
                            if (0 == MicrosoftRootPolicyStatus.dwError)
                                printf("ChainContext has Expected Microsoft Root\n");
                            else
                                printf("failed => not a Microsoft Root\n");
                        }

                        if (fNotMicrosoftRoot) {
                            if (0 != MicrosoftRootPolicyStatus.dwError)
                                printf("ChainContext has Expected Not a Microsoft Root\n");
                            else
                                printf("failed => has a Microsoft Root\n");
                        }
                    }
                }

            } else
                printf("TrustStatus:: failed => no first signer\n");
        }

        wvtData.dwStateAction = WTD_STATEACTION_CLOSE;
        WinVerifyTrust(
            NULL,               // hwnd
            pwvtActionID,
            &wvtData
            );

        if (fResult)
            goto SuccessReturn;
        else
            goto ErrorReturn;
    } else if (fQuiet) {
        if (TRUST_TYPE_DRIVER == dwTrustType) {
            if (DriverVerInfo.pcSignerCertContext) {
                CertFreeCertificateContext(DriverVerInfo.pcSignerCertContext);
            }
        }

        if (fNTAuth) {
            if (NULL == (pProvData = WTHelperProvDataFromStateData(
                    wvtData.hWVTStateData))) {
                printf("NTAuth:: failed => no WVTStateData\n");
                goto ErrorReturn;
            }

            fResult = FALSE;
            if (0 == pProvData->csSigners)
                printf("NTAuth:: failed => No Signers\n");
            else {
                CRYPT_PROVIDER_SGNR *pProvSign;

                pProvSign = WTHelperGetProvSignerFromChain(
                    pProvData,
                    0,              // idxSigner
                    FALSE,          // fCounterSigner
                    0               // idxCounterSigner
                    );
                if (pProvSign && pProvSign->pChainContext) {
                    if (fNTAuthNameConstraint)
                        fResult = NTAuthNameConstraintVerify(
                            pProvSign->pChainContext, (DWORD) lWVTExpected);
                    else
                        fResult = NTAuthVerify(pProvSign->pChainContext,
                            (DWORD) lWVTExpected);
                } else
                    printf("NTAuth:: failed => no first signer\n");
            }

            wvtData.dwStateAction = WTD_STATEACTION_CLOSE;
            WinVerifyTrust(
                NULL,               // hwnd
                pwvtActionID,
                &wvtData
                );

            if (fResult)
                goto SuccessReturn;
            else
                goto ErrorReturn;
        } else if (lStatus == lWVTExpected) {
            if (ERROR_SUCCESS != lStatus)
                PrintStatus("WinVerifyTrust returned expected => ", lStatus);
            goto SuccessReturn;
        } else {
            PrintStatus("Expected => ", lWVTExpected);
            PrintStatus("WinVerifyTrust(Verify) failed => ", lStatus);
            goto ErrorReturn;
        }
    }

    if (ERROR_SUCCESS != lStatus) {
        if (fFlushCrl && CERT_E_EXPIRED == lStatus)
            ;
        else
            PrintStatus("WinVerifyTrust(Verify) failed => ", lStatus);
    }

    if (NULL == (pProvData = WTHelperProvDataFromStateData(
            wvtData.hWVTStateData))) {
        printf("failed => no WVTStateData\n");
        goto ErrorReturn;
    }

    if (pProvData->dwError)
        PrintError("Low Level system error: ", pProvData->dwError);
    for (i = 0; i < pProvData->cdwTrustStepErrors; i++) {
        if (pProvData->padwTrustStepErrors[i]) {
            printf(">>>>>  Step Error [%d] : ", i);
            PrintError("", pProvData->padwTrustStepErrors[i]);
        }
    }

    if (TRUST_TYPE_DRIVER == dwTrustType) {
        if (DriverVerInfo.pcSignerCertContext) {
            CertFreeCertificateContext(DriverVerInfo.pcSignerCertContext);
        }
        printf("Driver version: %S signedBy: %S\n",
            DriverVerInfo.wszVersion, DriverVerInfo.wszSignedBy);
    }
    

    if (0 == pProvData->csSigners)
        printf("No Signers\n");
    else {
        DWORD idxSigner;
        for (idxSigner = 0; idxSigner < pProvData->csSigners; idxSigner++) {
            CRYPT_PROVIDER_SGNR *pProvSign;

            printf("======  Signer [%d]  ======\n", idxSigner);

            pProvSign = WTHelperGetProvSignerFromChain(
                pProvData,
                idxSigner,
                FALSE,          // fCounterSigner
                0               // idxCounterSigner
                );
            if (pProvSign) {
                DWORD idxCounterSigner;

                DisplayPeterSigner(pProvSign, dwDisplayFlags);
                DisplayKirtChain(pProvSign->pChainContext, dwDisplayFlags);
                if (fNTAuth && !fNTAuthNameConstraint &&
                        pProvSign->pChainContext)
                    NTAuthVerify(pProvSign->pChainContext, CERT_E_UNTRUSTEDCA);

                for (idxCounterSigner = 0;
                        idxCounterSigner < pProvSign->csCounterSigners;
                                                        idxCounterSigner++) {
                    CRYPT_PROVIDER_SGNR *pProvCounterSign;
                    printf("\n");
                    printf("======  CounterSigner [%d,%d]  ======\n",
                            idxSigner, idxCounterSigner);
                    pProvCounterSign = WTHelperGetProvSignerFromChain(
                        pProvData,
                        idxSigner,
                        TRUE,           // fCounterSigner
                        idxCounterSigner
                        );
                    DisplayPeterSigner(pProvCounterSign, dwDisplayFlags);
                    DisplayKirtChain(pProvCounterSign->pChainContext,
                        dwDisplayFlags);
                }
            }
        }
    }



    wvtData.dwStateAction = WTD_STATEACTION_CLOSE;
    lStatus = WinVerifyTrust(
                NULL,               // hwnd
                pwvtActionID,
                &wvtData
                );
    if (ERROR_SUCCESS != lStatus) {
        PrintStatus("WinVerifyTrust(Close) failed => ", lStatus);
        goto ErrorReturn;
    }
                

SuccessReturn:
    printf("Passed\n");
RegistryOnlyExit:
    status = 0;

CommonReturn:
    if (fLogoffNotification) {
        int c;
        fputs("Waiting to call ChainWlxLogoffEvent ->", stdout);
        fflush(stdin);
        fflush(stdout);
        c = getchar();

        ChainWlxLogoffEvent(NULL);

        fputs("Finished call ->", stdout);
        fflush(stdin);
        fflush(stdout);
        c = getchar();
    }

    if (fInstallDefaultContext)
        FreeDefaultContext();

    while(wvtCertInfo.chStores--) {
        if (!CertCloseStore(wvtCertInfo.pahStores[wvtCertInfo.chStores],
                CERT_CLOSE_STORE_CHECK_FLAG))
            PrintLastError("CertCloseStore");
    }
    CertFreeCertificateContext(wvtCertInfo.psCertContext);

    TestFree((LPWSTR) wvtFileInfo.pcwszFilePath);
    TestFree(httpsPolicyCallbackData.pwszServerName);

    return status;
ErrorReturn:
    status = -1;
    printf("Failed\n");
    goto CommonReturn;

BadUsage:
    Usage();
    goto ErrorReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\ttrust\wvtexample.cpp ===
//+-------------------------------------------------------------------------
//  File:       wvtexample.cpp
//
//  Contents:   An example calling WinVerifyTrust for Safer
//--------------------------------------------------------------------------

#include <windows.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <softpub.h>


void SaferVerifyFileExample(
    IN LPCWSTR pwszFilename
    )
{
    LONG lStatus;
    DWORD dwLastError;

    GUID wvtFileActionID = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    WINTRUST_FILE_INFO wvtFileInfo;
    WINTRUST_DATA wvtData;

    //
    // Initialize the WinVerifyTrust input data structure
    //
    memset(&wvtData, 0, sizeof(wvtData));   // default all fields to 0
    wvtData.cbStruct = sizeof(wvtData);
    // wvtData.pPolicyCallbackData =        // use default code signing EKU
    // wvtData.pSIPClientData =             // no data to pass to SIP

    // Display UI if not already trusted or disallowed. Note, admin policy
    // may disable UI.
    wvtData.dwUIChoice = WTD_UI_ALL;

    // wvtData.fdwRevocationChecks =        // do revocation checking if
                                            // enabled by admin policy or
                                            // IE advanced user options
    wvtData.dwUnionChoice = WTD_CHOICE_FILE;
    wvtData.pFile = &wvtFileInfo;

    // wvtData.dwStateAction =              // default verification
    // wvtData.hWVTStateData =              // not applicable for default
    // wvtData.pwszURLReference =           // not used

    // Enable safer semantics:
    //   - if the subject isn't signed, return immediately without UI
    //   - ignore NO_CHECK revocation errors
    //   - always search the code hash and publisher databases, even when
    //     UI has been disabled in dwUIChoice.
    wvtData.dwProvFlags = WTD_SAFER_FLAG;

    //
    // Initialize the WinVerifyTrust file info data structure
    //
    memset(&wvtFileInfo, 0, sizeof(wvtFileInfo));   // default all fields to 0
    wvtFileInfo.cbStruct = sizeof(wvtFileInfo);
    wvtFileInfo.pcwszFilePath = pwszFilename;
    // wvtFileInfo.hFile =              // allow WVT to open
    // wvtFileInfo.pgKnownSubject       // allow WVT to determine

    //
    // Call WinVerifyTrust
    //
    lStatus = WinVerifyTrust(
                NULL,               // hwnd
                &wvtFileActionID,
                &wvtData
                );


    //
    // Process the WinVerifyTrust errors
    //

    switch (lStatus) {
        case ERROR_SUCCESS:
            // Signed file:
            //   - Hash representing the subject is trusted.
            //   - Trusted publisher without any verification errors.
            //   - UI was disabled in dwUIChoice. No publisher or timestamp
            //     chain errors.
            //   - UI was enabled in dwUIChoice and the user clicked "Yes"
            //     when asked to install and run the signed subject.
            break;

        case TRUST_E_NOSIGNATURE:
            // The file wasn't signed or had an invalid signature

            // Get the reason for no signature
            dwLastError = GetLastError();

            if (TRUST_E_NOSIGNATURE == dwLastError ||
                    TRUST_E_SUBJECT_FORM_UNKNOWN == dwLastError ||
                    TRUST_E_PROVIDER_UNKNOWN == dwLastError) {
                // The file wasn't signed
            } else {
                // Invalid signature or error opening the file
            }
            break;

        case TRUST_E_EXPLICIT_DISTRUST:
            // The hash representing the subject or the publisher is
            // disallowed by the admin or user
            break;

        case TRUST_E_SUBJECT_NOT_TRUSTED:
            // The user clicked "No" when asked to install and run
            break;

        case CRYPT_E_SECURITY_SETTINGS:
            // The hash representing the subject or the publisher wasn't
            // explicitly trusted by the admin and admin policy has
            // disabled user trust. No signature, publisher or timestamp
            // errors.
            break;

        default:
            // UI was disabled in dwUIChoice or admin policy has disabled
            // user trust.  lStatus contains the publisher or timestamp
            // chain error.
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\turlcache\turlcache.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       turlcache.cpp
//
//  Contents:   Test to display and delete Cryptnet Url cache entries
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    02-Feb-02   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "crypthlp.h"
#include "cryptnet.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


BOOL fExactMatch = FALSE;
BOOL fOneMatch = FALSE;     // at least one match
BOOL fNoMatch = FALSE;      // no matches


typedef struct _TEST_DELETE_ARG {
    LPCWSTR     pwszUrlSubString;   // NULL implies delete all
    DWORD       cUrlCacheEntry;
    LPWSTR      *rgpwszUrl;
    LPWSTR      *rgpwszMetaDataFileName;
    LPWSTR      *rgpwszContentFileName;
} TEST_DELETE_ARG, *PTEST_DELETE_ARG;

typedef struct _TEST_DISPLAY_ARG {
    LPCWSTR     pwszUrlSubString;   // NULL implies display all
    DWORD       dwDisplayFlags;
    BOOL        fContent;
    BOOL        fRawBytes;
    DWORD       cUrl;
} TEST_DISPLAY_ARG, *PTEST_DISPLAY_ARG;

typedef struct _TEST_SET_SYNC_TIME_ARG {
    LPCWSTR     pwszUrlSubString;
    BOOL        fVerbose;
    FILETIME    LastSyncTime;
    DWORD       cUrl;
} TEST_SET_SYNC_TIME_ARG, *PTEST_SET_SYNC_TIME_ARG;


static void Usage(void)
{
    printf("Usage: turlcache [options] [<Url SubString>]\n");
    printf("\n");
    printf("Options are:\n");
    printf("  -d                    - Delete Url Cache Entry\n");
    printf("  -dALL                 - Delete All Url Cache Entries\n");
    printf("  -c                    - Display Url Cache Content\n");
    printf("  -r                    - Display Url Cache Raw Bytes\n");
    printf("  -e                    - Exact match\n");
    printf("  -1                    - At least one match without an error\n");
    printf("  -0                    - No matches without an error\n");
    printf("  -h                    - This message\n");
    printf("  -b                    - Brief\n");
    printf("  -v                    - Verbose\n");
    printf("  -S<number>            - SyncTime delta seconds\n");
    printf("\n");
}

BOOL
TestIsUrlMatch(
    LPCWSTR pwszCacheUrl,
    LPCWSTR pwszUrlSubString        // already in lower case
    )
{
    BOOL fResult = FALSE;

    LPWSTR pwszLowerCaseCacheUrl = NULL;
    if (NULL == pwszUrlSubString)
        return TRUE;

    if (fExactMatch) {
        if (0 == wcscmp(pwszCacheUrl, pwszUrlSubString))
            return TRUE;
        else
            return FALSE;
    }

    // Do case insensitive substring in string matching

    pwszLowerCaseCacheUrl = (LPWSTR) TestAlloc(
        (wcslen(pwszCacheUrl) + 1) * sizeof(WCHAR));
    if (pwszLowerCaseCacheUrl) {
        wcscpy(pwszLowerCaseCacheUrl, pwszCacheUrl);
        _wcslwr(pwszLowerCaseCacheUrl);

        if (wcsstr(pwszLowerCaseCacheUrl, pwszUrlSubString))
            fResult = TRUE;

        TestFree(pwszLowerCaseCacheUrl);
    }

    return fResult;
}

BOOL
WINAPI
TestDeleteUrlCacheEntryCallback(
    IN const CRYPTNET_URL_CACHE_ENTRY *pUrlCacheEntry,
    IN DWORD dwFlags,
    IN LPVOID pvReserved,
    IN LPVOID pvArg
    )
{
    BOOL fResult;
    PTEST_DELETE_ARG pArg = (PTEST_DELETE_ARG) pvArg;
    DWORD cbUrl;
    LPWSTR pwszUrl = NULL;
    LPWSTR *ppwszUrl = NULL;
    DWORD cbMetaDataFileName;
    LPWSTR pwszMetaDataFileName = NULL;
    LPWSTR *ppwszMetaDataFileName = NULL;
    DWORD cbContentFileName;
    LPWSTR pwszContentFileName = NULL;
    LPWSTR *ppwszContentFileName = NULL;
    DWORD cUrlCacheEntry;

    if (!TestIsUrlMatch(pUrlCacheEntry->pwszUrl, pArg->pwszUrlSubString))
        return TRUE;

    cbUrl = (wcslen(pUrlCacheEntry->pwszUrl) + 1) * sizeof(WCHAR);
    cbMetaDataFileName =
        (wcslen(pUrlCacheEntry->pwszMetaDataFileName) + 1) * sizeof(WCHAR);
    cbContentFileName =
        (wcslen(pUrlCacheEntry->pwszContentFileName) + 1) * sizeof(WCHAR);


    pwszUrl = (LPWSTR) TestAlloc(cbUrl);
    pwszMetaDataFileName = (LPWSTR) TestAlloc(cbMetaDataFileName);
    pwszContentFileName = (LPWSTR) TestAlloc(cbContentFileName);

    if (NULL == pwszUrl ||
            NULL == pwszMetaDataFileName ||
            NULL == pwszContentFileName)
        goto ErrorReturn;

    cUrlCacheEntry = pArg->cUrlCacheEntry;

    ppwszUrl = (LPWSTR *) TestRealloc(
        pArg->rgpwszUrl, sizeof(LPWSTR) * (cUrlCacheEntry + 1));
    if (NULL == ppwszUrl)
        goto ErrorReturn;
    pArg->rgpwszUrl = ppwszUrl;

    ppwszMetaDataFileName = (LPWSTR *) TestRealloc(
        pArg->rgpwszMetaDataFileName, sizeof(LPWSTR) * (cUrlCacheEntry + 1));
    if (NULL == ppwszMetaDataFileName)
        goto ErrorReturn;
    pArg->rgpwszMetaDataFileName = ppwszMetaDataFileName;

    ppwszContentFileName = (LPWSTR *) TestRealloc(
        pArg->rgpwszContentFileName, sizeof(LPWSTR) * (cUrlCacheEntry + 1));
    if (NULL == ppwszContentFileName)
        goto ErrorReturn;
    pArg->rgpwszContentFileName = ppwszContentFileName;

    memcpy(pwszUrl, pUrlCacheEntry->pwszUrl, cbUrl);
    ppwszUrl[cUrlCacheEntry] = pwszUrl;

    memcpy(pwszMetaDataFileName, pUrlCacheEntry->pwszMetaDataFileName,
        cbMetaDataFileName);
    ppwszMetaDataFileName[cUrlCacheEntry] = pwszMetaDataFileName;

    memcpy(pwszContentFileName, pUrlCacheEntry->pwszContentFileName,
        cbContentFileName);
    ppwszContentFileName[cUrlCacheEntry] = pwszContentFileName;

    pArg->cUrlCacheEntry = cUrlCacheEntry + 1;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    TestFree(pwszUrl);
    TestFree(pwszMetaDataFileName);
    TestFree(pwszContentFileName);
    fResult = FALSE;
    goto CommonReturn;
}


BOOL TestDeleteUrlCacheEntry(
    IN LPCWSTR pwszUrlSubString,    // NULL implies delete all
    IN BOOL fVerbose
    )
{
    BOOL fResult;
    TEST_DELETE_ARG TestArg;
    DWORD i;
    DWORD cDeleted = 0;

    memset(&TestArg, 0, sizeof(TestArg));
    TestArg.pwszUrlSubString = pwszUrlSubString;

    fResult = I_CryptNetEnumUrlCacheEntry(
        0,          // dwFlags
        NULL,       // pvReserved
        &TestArg,
        TestDeleteUrlCacheEntryCallback
        );
    if (!fResult)
        PrintLastError("I_CryptNetEnumUrlCacheEntry(Delete)");

    for (i = 0; i < TestArg.cUrlCacheEntry; i++) {
        BOOL fDelete = TRUE;

        if (!DeleteFileW(TestArg.rgpwszContentFileName[i])) {
            fDelete = FALSE;
            printf("Failed Content DeleteFile(%S) for Url: %S\n",
                TestArg.rgpwszContentFileName[i],
                TestArg.rgpwszUrl[i]
                );
            PrintLastError("DeleteFilew(Content)");
        }

        if (!DeleteFileW(TestArg.rgpwszMetaDataFileName[i])) {
            fDelete = FALSE;
            printf("Failed MetaData DeleteFile(%S) for Url: %S\n",
                TestArg.rgpwszMetaDataFileName[i],
                TestArg.rgpwszUrl[i]
                );
            PrintLastError("DeleteFilew(MetaData)");
        }

        if (fDelete) {
            if (fVerbose)
                printf("Successful Delete for Url: %S\n",
                    TestArg.rgpwszUrl[i]);

            cDeleted++;
        }

        TestFree(TestArg.rgpwszUrl[i]);
        TestFree(TestArg.rgpwszContentFileName[i]);
        TestFree(TestArg.rgpwszMetaDataFileName[i]);
    }

    TestFree(TestArg.rgpwszUrl);
    TestFree(TestArg.rgpwszContentFileName);
    TestFree(TestArg.rgpwszMetaDataFileName);

    printf("\nDeleted %d Url Cache Entries\n", cDeleted);
    if (fOneMatch && 0 == cDeleted) {
        printf("Delete failed => no matched entries\n");
        fResult = FALSE;
    }
    if (fNoMatch && 0 != cDeleted) {
        printf("Delete failed => expected no matched entries\n");
        fResult = FALSE;
    }

    return fResult;
}


//+-------------------------------------------------------------------------
//  Allocate and read an encoded DER blob from a file
//--------------------------------------------------------------------------
BOOL ReadDERFromFile(
    LPCWSTR  pwszFileName,
    PBYTE   *ppbDER,
    PDWORD  pcbDER
    )
{
    BOOL        fRet;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    PBYTE       pbDER = NULL;
    DWORD       cbDER;
    DWORD       cbRead;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFileW( pwszFileName, GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL))) {
        printf( "can't open %S\n", pwszFileName);
        goto ErrorReturn;
    }

    cbDER = GetFileSize( hFile, NULL);
    if (cbDER == 0) {
        printf( "empty file %S\n", pwszFileName);
        goto ErrorReturn;
    }
    if (NULL == (pbDER = (PBYTE)TestAlloc(cbDER))) {
        printf( "can't alloc %d bytes\n", cbDER);
        goto ErrorReturn;
    }
    if (!ReadFile( hFile, pbDER, cbDER, &cbRead, NULL) ||
            (cbRead != cbDER)) {
        printf( "can't read %S\n", pwszFileName);
        goto ErrorReturn;
    }

    *ppbDER = pbDER;
    *pcbDER = cbDER;
    fRet = TRUE;
CommonReturn:
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    return fRet;
ErrorReturn:
    if (pbDER)
        TestFree(pbDER);
    *ppbDER = NULL;
    *pcbDER = 0;
    fRet = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
BOOL WriteDERToFile(
    LPCWSTR pwszFileName,
    PBYTE   pbDER,
    DWORD   cbDER
    )
{
    BOOL fResult;

    // Write the Encoded Blob to the file
    HANDLE hFile;
    hFile = CreateFileW(pwszFileName,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_SYSTEM,
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        fResult = FALSE;
        PrintLastError("WriteDERToFile::CreateFile");
    } else {
        DWORD dwBytesWritten;
        if (!(fResult = WriteFile(
                hFile,
                pbDER,
                cbDER,
                &dwBytesWritten,
                NULL            // lpOverlapped
                )))
            PrintLastError("WriteDERToFile::WriteFile");
        CloseHandle(hFile);
    }
    return fResult;
}

HCERTSTORE TestCreateStoreFromUrlCacheContent(
    IN DWORD cBlob,
    IN DWORD *pcbBlob,
    IN PBYTE pbContent
    )
{
    BOOL fResult = TRUE;
    HCERTSTORE hStore = NULL; 
    DWORD      cCount;
    int        iQueryResult;
    DWORD      dwQueryErr = 0;
    PBYTE      pb;
                       
    if ( ( hStore = CertOpenStore(
                        CERT_STORE_PROV_MEMORY,
                        0,
                        NULL,
                        0,
                        NULL
                        ) ) == NULL )
    {
        PrintLastError("CertOpenStore(Memory)");
        return NULL;
    }
    
    //  0 =>  no CryptQueryObject()
    //  1 =>  1 successful CryptQueryObject()
    // -1 =>  all CryptQueryObject()'s failed
    iQueryResult = 0;

    for ( cCount = 0, pb = pbContent; 
              ( fResult == TRUE ) && ( cCount < cBlob ); 
                  pb += pcbBlob[cCount], cCount++ )
    {
        CERT_BLOB Blob;
        HCERTSTORE hChildStore = NULL;

        // Skip empty blobs. I have seen empty LDAP attributes containing
        // a single byte set to 0.
        if (0 == pcbBlob[cCount] ||
                (1 == pcbBlob[cCount] && 0 == pb[0]))
        {
            continue;
        }

        Blob.pbData = pb;
        Blob.cbData = pcbBlob[cCount];

        if (CryptQueryObject(
                       CERT_QUERY_OBJECT_BLOB,
                       (LPVOID) &Blob,
                       CERT_QUERY_CONTENT_FLAG_CERT |
                            CERT_QUERY_CONTENT_FLAG_CTL |
                            CERT_QUERY_CONTENT_FLAG_CRL |
                            CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |
                            CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT |
                            CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL |
                            CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL |
                            CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
                            CERT_QUERY_CONTENT_FLAG_CERT_PAIR,
                            CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       &hChildStore,
                       NULL,
                       NULL
                       ))
        {
            fResult = I_CertUpdateStore( hStore, hChildStore, 0, NULL );
            CertCloseStore( hChildStore, 0 );
            iQueryResult = 1;
        }
        else if (iQueryResult == 0)
        {
            iQueryResult = -1;
            dwQueryErr = GetLastError();
        }
    }

    if ( fResult == TRUE && iQueryResult < 0)
    {
        fResult = FALSE;
        SetLastError(dwQueryErr);
    }

    if (!fResult)
    {
        PrintLastError("TestCreateStoreFromUrlCacheContent");
        CertCloseStore( hStore, 0 );
        hStore = NULL;
    }
    

    return hStore;
}

LPCSTR FileTimeTextWithoutMilliseconds(FILETIME *pft)
{
    static char buf[80];
    FILETIME ftLocal;
    struct tm ctm;
    SYSTEMTIME st;

    FileTimeToLocalFileTime(pft, &ftLocal);
    if (FileTimeToSystemTime(&ftLocal, &st))
    {
        ctm.tm_sec = st.wSecond;
        ctm.tm_min = st.wMinute;
        ctm.tm_hour = st.wHour;
        ctm.tm_mday = st.wDay;
        ctm.tm_mon = st.wMonth-1;
        ctm.tm_year = st.wYear-1900;
        ctm.tm_wday = st.wDayOfWeek;
        ctm.tm_yday  = 0;
        ctm.tm_isdst = 0;
        strcpy(buf, asctime(&ctm));
        buf[strlen(buf)-1] = 0;
    }
    else
        sprintf(buf, "<FILETIME %08lX:%08lX>", pft->dwHighDateTime,
                pft->dwLowDateTime);
    return buf;
}


BOOL
WINAPI
TestDisplayUrlCacheEntryCallback(
    IN const CRYPTNET_URL_CACHE_ENTRY *pUrlCacheEntry,
    IN DWORD dwFlags,
    IN LPVOID pvReserved,
    IN LPVOID pvArg
    )
{
    PTEST_DISPLAY_ARG pArg = (PTEST_DISPLAY_ARG) pvArg;
    DWORD cbBlob;
    DWORD i;
    PBYTE pbContent = NULL;
    DWORD cbContent;

    BOOL fDetails;


    if (pArg->fRawBytes || pArg->fContent ||
            (pArg->dwDisplayFlags & DISPLAY_VERBOSE_FLAG))
        fDetails = TRUE;
    else
        fDetails = FALSE;


    if (!TestIsUrlMatch(pUrlCacheEntry->pwszUrl, pArg->pwszUrlSubString))
        return TRUE;

    cbBlob = 0;
    for (i = 0; i < pUrlCacheEntry->cBlob; i++)
        cbBlob += pUrlCacheEntry->pcbBlob[i];

    if (fDetails) {
        printf("\n");
        printf(
"=========================================================================\n");
    }

    printf("%s %9d  %S\n",
        FileTimeTextWithoutMilliseconds((FILETIME *) &pUrlCacheEntry->LastSyncTime),
        cbBlob,
        pUrlCacheEntry->pwszUrl
        );
    
    if (fDetails) {
        printf(
"=========================================================================\n");

        if (pArg->dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
            printf("MetaDataFileName: %S\n",
                pUrlCacheEntry->pwszMetaDataFileName);
            printf("ContentFileName : %S\n",
                pUrlCacheEntry->pwszContentFileName);
        }

        if (!ReadDERFromFile(
                pUrlCacheEntry->pwszContentFileName,
                &pbContent,
                &cbContent
                ))
            goto ErrorReturn;

        if (cbBlob != cbContent) {
            printf("Invalid content length: %d, expected: %d\n",
                cbContent, cbBlob);

            if (cbBlob > cbContent)
                goto ErrorReturn;
        }

        if (pArg->fRawBytes) {
            PBYTE pb = pbContent;

            for (i = 0; i < pUrlCacheEntry->cBlob; i++) {
                printf("----  Blob[%d]  ----\n", i);
                PrintBytes("    ", pb, pUrlCacheEntry->pcbBlob[i]);
                pb += pUrlCacheEntry->pcbBlob[i];
            }
        }


        if (pArg->fContent) {
            HCERTSTORE hStore;

            hStore = TestCreateStoreFromUrlCacheContent(
                 pUrlCacheEntry->cBlob,
                pUrlCacheEntry->pcbBlob,
                pbContent
                );

            if (hStore) {
                DisplayStore(hStore, pArg->dwDisplayFlags);
                CertCloseStore(hStore, 0);
            }
        }
    }

CommonReturn:
    TestFree(pbContent);
    pArg->cUrl++;
    return TRUE;

ErrorReturn:
    goto CommonReturn;
}


BOOL TestDisplayUrlCacheEntry(
    IN LPCWSTR pwszUrlSubString,    // NULL implies display all
    IN DWORD dwDisplayFlags,
    IN BOOL fContent,
    IN BOOL fRawBytes
    )
{
    BOOL fResult;
    TEST_DISPLAY_ARG TestArg;

    memset(&TestArg, 0, sizeof(TestArg));
    TestArg.pwszUrlSubString = pwszUrlSubString;
    TestArg.dwDisplayFlags = dwDisplayFlags;
    TestArg.fContent = fContent;
    TestArg.fRawBytes = fRawBytes;

    fResult = I_CryptNetEnumUrlCacheEntry(
        0,          // dwFlags
        NULL,       // pvReserved
        &TestArg,
        TestDisplayUrlCacheEntryCallback
        );
    if (!fResult)
        PrintLastError("I_CryptNetEnumUrlCacheEntry(Display)");

    printf("\nDisplayed %d Url Cache Entries\n", TestArg.cUrl);
    if (fOneMatch && 0 == TestArg.cUrl) {
        printf("Display failed => no matched entries\n");
        fResult = FALSE;
    }
    if (fNoMatch && 0 != TestArg.cUrl) {
        printf("Display failed => expected no matched entries\n");
        fResult = FALSE;
    }

    return fResult;
}

#if 0
from \nt\ds\security\cryptoapi\pki\rpor\rporprov.h
typedef struct _SCHEME_CACHE_META_DATA_HEADER {
    DWORD           cbSize;
    DWORD           dwMagic;
    DWORD           cBlob;
    DWORD           cbUrl;
    FILETIME        LastSyncTime;
} SCHEME_CACHE_META_DATA_HEADER, *PSCHEME_CACHE_META_DATA_HEADER;
#endif

#define TEST_LAST_SYNC_TIME_META_DATA_OFFSET    (sizeof(DWORD) * 4)
#define TEST_MIN_META_DATA_SIZE                 \
    (TEST_LAST_SYNC_TIME_META_DATA_OFFSET + sizeof(FILETIME))

BOOL
WINAPI
TestSetSyncTimeCallback(
    IN const CRYPTNET_URL_CACHE_ENTRY *pUrlCacheEntry,
    IN DWORD dwFlags,
    IN LPVOID pvReserved,
    IN LPVOID pvArg
    )
{
    BOOL fResult;
    BYTE *pbMetaData = NULL;
    DWORD cbMetaData;

    PTEST_SET_SYNC_TIME_ARG pArg = (PTEST_SET_SYNC_TIME_ARG) pvArg;

    if (!TestIsUrlMatch(pUrlCacheEntry->pwszUrl, pArg->pwszUrlSubString))
        return TRUE;

    printf("SetSyncTime for: %S\n", pUrlCacheEntry->pwszUrl);
    if (pArg->fVerbose)
        printf("MetaDataFileName: %S\n", pUrlCacheEntry->pwszMetaDataFileName);

    if (!ReadDERFromFile(
            pUrlCacheEntry->pwszMetaDataFileName,
            &pbMetaData,
            &cbMetaData
            ))
        goto ErrorReturn;

    if (TEST_MIN_META_DATA_SIZE > cbMetaData) {
        printf("Invalid meta data file length: %d, expected at least: %d\n",
            cbMetaData, TEST_MIN_META_DATA_SIZE);
        goto ErrorReturn;
    }

    memcpy(pbMetaData + TEST_LAST_SYNC_TIME_META_DATA_OFFSET,
        &pArg->LastSyncTime, sizeof(FILETIME));

    if (!WriteDERToFile(
            pUrlCacheEntry->pwszMetaDataFileName,
            pbMetaData,
            cbMetaData
            ))
        goto ErrorReturn;


    pArg->cUrl++;

CommonReturn:
    TestFree(pbMetaData);
    return TRUE;

ErrorReturn:
    goto CommonReturn;
}

BOOL TestSetSyncTime(
    IN LPCWSTR pwszUrlSubString,    // NULL implies delete all
    IN BOOL fVerbose,
    IN LONG lDeltaSeconds
    )
{
    BOOL fResult;
    TEST_SET_SYNC_TIME_ARG TestArg;
    FILETIME CurrentTime;

    memset(&TestArg, 0, sizeof(TestArg));
    TestArg.pwszUrlSubString = pwszUrlSubString;
    TestArg.fVerbose = fVerbose;

    GetSystemTimeAsFileTime(&CurrentTime);

    if (lDeltaSeconds >= 0)
        I_CryptIncrementFileTimeBySeconds(
            &CurrentTime,
            (DWORD) lDeltaSeconds,
            &TestArg.LastSyncTime
            );
    else
        I_CryptDecrementFileTimeBySeconds(
            &CurrentTime,
            (DWORD) -lDeltaSeconds,
            &TestArg.LastSyncTime
            );

    fResult = I_CryptNetEnumUrlCacheEntry(
        0,          // dwFlags
        NULL,       // pvReserved
        &TestArg,
        TestSetSyncTimeCallback
        );
    if (!fResult)
        PrintLastError("I_CryptNetEnumUrlCacheEntry(SetSyncTime)");

    printf("\nSetSyncTime for %d Url Cache Entries\n", TestArg.cUrl);
    if (fOneMatch && 0 == TestArg.cUrl) {
        printf("SetSyncTime failed => no matched entries\n");
        fResult = FALSE;
    }
    if (fNoMatch && 0 != TestArg.cUrl) {
        printf("SetSyncTime failed => expected no matched entries\n");
        fResult = FALSE;
    }

    return fResult;
}

int _cdecl main(int argc, char * argv[]) 
{
    int status;
    LPWSTR pwszUrlSubString = NULL;
    BOOL fVerbose = FALSE;
    DWORD dwDisplayFlags = 0;
    BOOL fContent = FALSE;
    BOOL fRawBytes = FALSE;

    BOOL fDelete = FALSE;
    BOOL fDeleteAll = FALSE;
    BOOL fSyncTime = FALSE;
    LONG lSyncTimeDeltaSeconds = 0;

    while (--argc>0) {
        if (**++argv == '-')
        {
            {
                switch(argv[0][1])
                {
                case 'd':
                    fDelete = TRUE;
                    if (argv[0][2]) {
                        if (0 != _stricmp(argv[0]+2, "ALL")) {
                            printf("Need to specify -dALL\n");
                            goto BadUsage;
                        }
                        fDeleteAll = TRUE;
                    }
                    break;
                case 'b':
                    dwDisplayFlags |= DISPLAY_BRIEF_FLAG;
                    break;
                case 'v':
                    fVerbose = TRUE;
                    dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                    break;
                case 'c':
                    fContent = TRUE;
                    break;
                case 'r':
                    fRawBytes = TRUE;
                    break;
                case 'e':
                    fExactMatch = TRUE;
                    break;
                case '1':
                    fOneMatch = TRUE;
                    break;
                case '0':
                    fNoMatch = TRUE;
                    break;
                case 'S':
                    fSyncTime = TRUE;
                    lSyncTimeDeltaSeconds = strtol(argv[0]+2, NULL, 0);
                    break;
                case 'h':
                default:
                    goto BadUsage;
                }
            }
        } else {
            if (pwszUrlSubString) {
                printf("Multiple Url Subtrings:: %S %s\n",
                    pwszUrlSubString, argv[0]);
                goto BadUsage;
            }
            pwszUrlSubString = AllocAndSzToWsz(argv[0]);
        }
    }

    printf("command line: %s\n", GetCommandLine());

    if (!fExactMatch && pwszUrlSubString)
        _wcslwr(pwszUrlSubString);

    if (fDelete) {
        if (!fDeleteAll && NULL == pwszUrlSubString) {
            printf("Missing Url Substring for Delete\n");
            goto BadUsage;
        }

        if (!TestDeleteUrlCacheEntry(
                fDeleteAll ? NULL : pwszUrlSubString, // NULL implies delete all
                fVerbose
                ))
            goto ErrorReturn;
    } else if (fSyncTime) {
        if (NULL == pwszUrlSubString) {
            printf("Missing Url Substring for SetSyncTime\n");
            goto BadUsage;
        }
        if (!TestSetSyncTime(
                pwszUrlSubString,
                fVerbose,
                lSyncTimeDeltaSeconds
                ))
            goto ErrorReturn;
    } else {
        if (!TestDisplayUrlCacheEntry(
                pwszUrlSubString,    // NULL implies display all
                dwDisplayFlags,
                fContent,
                fRawBytes
                ))
            goto ErrorReturn;
    }

    printf("Passed\n");
    status = 0;

CommonReturn:
    TestFree(pwszUrlSubString);

    return status;
ErrorReturn:
    status = -1;
    printf("Failed\n");
    goto CommonReturn;

BadUsage:
    Usage();
    goto ErrorReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\turlread\turlread.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       turlread.cpp
//
//  Contents:   Read the specified URL using the wininet APIs
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    26-Feb-96   philh   created
//              
//--------------------------------------------------------------------------

#include <windows.h>
#include <assert.h>
#include <wininet.h>

#ifndef MAX_CACHE_ENTRY_INFO_SIZE
#   include <winineti.h>
#endif

#include <sensapi.h>

#include "wincrypt.h"
#include "crypthlp.h"
#include "cryptnet.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <time.h>

// Fix for SP4, where ICU_BROWSER_MODE isn't defined
#ifndef ICU_BROWSER_MODE
#define ICU_BROWSER_MODE ICU_ENCODE_SPACES_ONLY
#endif

static void Usage(void)
{
    printf("Usage: turlread [options] <URL>\n");
    printf("Options are:\n");
    printf("  -d                    - Delete cached URL\n");
    printf("  -i                    - Get cached URL information\n");
    printf("  -o                    - Offline only\n");
    printf("  -w                    - Wire only\n");
    printf("  -cBrowser             - Canonicalize => Browser (default)\n");
    printf("  -cNone                - Canonicalize => None\n");
    printf("  -cSpaces              - Canonicalize => Spaces\n");
    printf("  -cAll                 - Canonicalize => All\n");
    printf("  -U                    - Unicode\n");
    printf("  -s                    - Get internet state\n");
    printf("  -n                    - Get host Name from URL\n");
    printf("  -S<number>            - SyncTime delta seconds\n");
    printf("  -h                    - This message\n");
    printf("\n");
}

static void DisplayCacheEntryInfoA(
    LPSTR pszUrl
    )
{
    BOOL fResult;

    DWORD cbCachEntryInfo;
    BYTE rgbCachEntryInfo[MAX_CACHE_ENTRY_INFO_SIZE];
    LPINTERNET_CACHE_ENTRY_INFOA pCacheEntryInfo =
        (LPINTERNET_CACHE_ENTRY_INFOA) &rgbCachEntryInfo[0];

    DWORD dwEntryType;

    cbCachEntryInfo = sizeof(rgbCachEntryInfo);
    fResult = GetUrlCacheEntryInfoA(
        pszUrl,
        pCacheEntryInfo,
        &cbCachEntryInfo);
    if (!fResult)
        PrintLastError("GetUrlCachEntryInfo");
    else if (cbCachEntryInfo == 0)
        printf("GetUrlCachEntryInfo returned no bytes\n");
    else {
        printf("UrlCachEntryInfo (%d bytes)::\n", cbCachEntryInfo);
        printf("  StructSize: %d\n", pCacheEntryInfo->dwStructSize);
        printf("  SourceUrlName: %s\n", pCacheEntryInfo->lpszSourceUrlName);
        printf("  LocalFileName: %s\n", pCacheEntryInfo->lpszLocalFileName);
        printf("  FileExtension: %s\n", pCacheEntryInfo->lpszFileExtension);

        dwEntryType = pCacheEntryInfo->CacheEntryType;
        printf("  CacheEntryType: 0x%x", dwEntryType);
        if (dwEntryType & NORMAL_CACHE_ENTRY)
            printf(" NORMAL");
        if (dwEntryType & STICKY_CACHE_ENTRY)
            printf(" STICKY");
        if (dwEntryType & EDITED_CACHE_ENTRY)
            printf(" EDITED");
        if (dwEntryType & TRACK_OFFLINE_CACHE_ENTRY)
            printf(" TRACK_OFFLINE");
        if (dwEntryType & TRACK_ONLINE_CACHE_ENTRY)
            printf(" TRACK_ONLINE");
        if (dwEntryType & SPARSE_CACHE_ENTRY)
            printf(" SPARSE");
        if (dwEntryType & COOKIE_CACHE_ENTRY)
            printf(" COOKIE");
        if (dwEntryType & URLHISTORY_CACHE_ENTRY)
            printf(" URLHISTORY");
        printf("\n");

        printf("  UseCount: %d\n", pCacheEntryInfo->dwUseCount);
        printf("  HitRate: %d\n", pCacheEntryInfo->dwHitRate);
        printf("  FileSize: %d\n", pCacheEntryInfo->dwSizeLow);
        printf("  LastModifiedTime:: %s\n",
            FileTimeText(&pCacheEntryInfo->LastModifiedTime));
        printf("  ExpireTime:: %s\n",
            FileTimeText(&pCacheEntryInfo->ExpireTime));
        printf("  LastAccessTime:: %s\n",
            FileTimeText(&pCacheEntryInfo->LastAccessTime));
        printf("  LastSyncTime:: %s\n",
            FileTimeText(&pCacheEntryInfo->LastSyncTime));
        printf("  ExemptDelta:: %d\n", pCacheEntryInfo->dwExemptDelta);

        if (pCacheEntryInfo->dwHeaderInfoSize) {
            printf("  HeaderInfo::\n");
            PrintBytes("  ", (BYTE *) pCacheEntryInfo->lpHeaderInfo,
                pCacheEntryInfo->dwHeaderInfoSize);
        }
    }
}

static void DisplayCacheEntryInfoW(
    LPWSTR pwszUrl
    )
{
    BOOL fResult;
    char szUrl[_MAX_PATH + 1];

    DWORD cbCachEntryInfo;
    BYTE rgbCachEntryInfo[MAX_CACHE_ENTRY_INFO_SIZE];
    LPINTERNET_CACHE_ENTRY_INFOW pCacheEntryInfo =
        (LPINTERNET_CACHE_ENTRY_INFOW) &rgbCachEntryInfo[0];

    WideCharToMultiByte(
        CP_ACP,
        0,                      // dwFlags
        pwszUrl,
        -1,                     // Null terminated
        szUrl,
        sizeof(szUrl),
        NULL,                   // lpDefaultChar
        NULL                    // lpfUsedDefaultChar
        );

    cbCachEntryInfo = sizeof(rgbCachEntryInfo);
#if 0
    // BUG the signature of the following API was changed around 1804.
    // Changed from szUrl to wszUrl

    fResult = GetUrlCacheEntryInfoW(
        szUrl,
        pCacheEntryInfo,
        &cbCachEntryInfo);
#else
    fResult = FALSE;
    SetLastError((DWORD) E_NOTIMPL);
#endif
    if (!fResult)
        PrintLastError("GetUrlCachEntryInfo");
    else if (cbCachEntryInfo == 0)
        printf("GetUrlCachEntryInfo returned no bytes\n");
    else {
        printf("UrlCachEntryInfo (%d bytes)::\n", cbCachEntryInfo);
        printf("  SourceUrlName: %s\n", pCacheEntryInfo->lpszSourceUrlName);
        printf("  LocalFileName: %S\n", pCacheEntryInfo->lpszLocalFileName);
        printf("  UseCount: %d\n", pCacheEntryInfo->dwUseCount);
        printf("  HitRate: %d\n", pCacheEntryInfo->dwHitRate);
        printf("  FileSize: %d\n", pCacheEntryInfo->dwSizeLow);
        printf("  LastModifiedTime:: %s\n",
            FileTimeText(&pCacheEntryInfo->LastModifiedTime));
        printf("  ExpireTime:: %s\n",
            FileTimeText(&pCacheEntryInfo->ExpireTime));
        printf("  LastAccessTime:: %s\n",
            FileTimeText(&pCacheEntryInfo->LastAccessTime));
        printf("  LastSyncTime:: %s\n",
            FileTimeText(&pCacheEntryInfo->LastSyncTime));
    }
}


static void SetSyncTime(
    LPSTR pszUrl,
    LONG lDeltaSeconds
    )
{
    DWORD dwFieldControl = CACHE_ENTRY_SYNCTIME_FC;
    INTERNET_CACHE_ENTRY_INFOA CacheEntry;
    FILETIME CurrentTime;
    BOOL fResult;

    memset(&CacheEntry, 0, sizeof(CacheEntry));
    CacheEntry.dwStructSize = sizeof(CacheEntry);

    GetSystemTimeAsFileTime(&CurrentTime);

    if (lDeltaSeconds >= 0)
        I_CryptIncrementFileTimeBySeconds(
            &CurrentTime,
            (DWORD) lDeltaSeconds,
            &CacheEntry.LastSyncTime
            );
    else
        I_CryptDecrementFileTimeBySeconds(
            &CurrentTime,
            (DWORD) -lDeltaSeconds,
            &CacheEntry.LastSyncTime
            );

    fResult = SetUrlCacheEntryInfoA( pszUrl, &CacheEntry, dwFieldControl );

    if (!fResult)
        PrintLastError("SetUrlCacheEntryInfoA");
}

#if 0
static void DisplayDestinationReachableA(
    LPSTR pszUrl
    )
{
    BOOL fResult;
    QOCINFO qocInfo;

    memset(&qocInfo, 0, sizeof(qocInfo));
    qocInfo.dwSize = sizeof(qocInfo);

    fResult = IsDestinationReachableA(pszUrl, &qocInfo);

    if (fResult) {
        printf("Url is reachable, InSpeed: %d OutSpeed: %d dwFlags: 0x%x\n",
            qocInfo.dwInSpeed, qocInfo.dwOutSpeed, qocInfo.dwFlags);
    } else
        PrintLastError("IsDestinationReachable");
}
#endif

static void ReadUrl(
    HINTERNET hInternetFile
    )
{
    BOOL fResult;
    DWORD cb;
    DWORD cbTotal;

    cb = 0;
    fResult = InternetQueryDataAvailable(
        hInternetFile,
        &cb,
        0,                  // dwFlags
        0                   // dwContext
        );
    if (!fResult)
        PrintLastError("InternetQueryDataAvailable");
    else
        printf("NumberOfBytesAvailable: %d\n", cb);

    cbTotal = 0;
    while (TRUE) {
        BYTE rgb[512];
        memset(rgb, 0, sizeof(rgb));
        DWORD cbRead = 0;

        fResult = InternetReadFile(
            hInternetFile,
            rgb,
            sizeof(rgb),
            &cbRead);

        if (cbRead) {
            cbTotal += cbRead;
            if (!fResult)
                PrintLastError("InternetReadFile(cbRead != 0)");
            printf("Bytes read from URL::\n");
            PrintBytes("  ", rgb, cbRead);
        } else {
            if (!fResult)
                PrintLastError("InternetReadFile(cbRead == 0)");

            break;
        }
    }

    printf("Total number of bytes read: %d\n", cbTotal);
}

static void OfflineUrlA(
    LPSTR pszUrl
    )
{
    HINTERNET hInternetSession = NULL;
    HINTERNET hInternetFile = NULL;
    DWORD dwFlags;

    printf("****  OFFLINE  ****\n");
    dwFlags = INTERNET_FLAG_OFFLINE;
    hInternetSession = InternetOpenA(
        "CRL Agent",                    // lpszAgent
        INTERNET_OPEN_TYPE_PRECONFIG,   // dwAccessType
        NULL,                           // lpszProxy
        NULL,                           // lpszProxyBypass
        dwFlags
        );
    if (NULL == hInternetSession) {
        PrintLastError("InternetOpen");
        goto CommonReturn;
    }


    hInternetFile = InternetOpenUrlA(
        hInternetSession,
        pszUrl,
        "Accept: */*\r\n",  // lpszHeaders
        (DWORD) -1L,        // dwHeadersLength
//        INTERNET_FLAG_RELOAD, // dwFlags
        INTERNET_FLAG_IGNORE_CERT_CN_INVALID,
        0                   // dwContext
        );
    if (NULL == hInternetFile) {
        PrintLastError("InternetOpenUrl");
        goto CommonReturn;
    }

    DisplayCacheEntryInfoA(pszUrl);
    ReadUrl(hInternetFile);

CommonReturn:
    if (hInternetFile) {
        if (!InternetCloseHandle(hInternetFile))
            PrintLastError("InternetCloseHandle(File)");
    }
    if (hInternetSession) {
        if (!InternetCloseHandle(hInternetSession))
            PrintLastError("InternetCloseHandle(Session)");
    }
}

static void OfflineUrlW(
    LPWSTR pwszUrl
    )
{
    HINTERNET hInternetSession = NULL;
    HINTERNET hInternetFile = NULL;
    DWORD dwFlags;

    printf("****  OFFLINE  ****\n");
    dwFlags = INTERNET_FLAG_OFFLINE;
    hInternetSession = InternetOpenW(
        L"CRL Agent",                    // lpszAgent
        INTERNET_OPEN_TYPE_PRECONFIG,   // dwAccessType
        NULL,                           // lpszProxy
        NULL,                           // lpszProxyBypass
        dwFlags
        );
    if (NULL == hInternetSession) {
        PrintLastError("InternetOpenW");
        goto CommonReturn;
    }


    hInternetFile = InternetOpenUrlW(
        hInternetSession,
        pwszUrl,
        L"Accept: */*\r\n",  // lpszHeaders
        (DWORD) -1L,        // dwHeadersLength
//        INTERNET_FLAG_RELOAD, // dwFlags
        INTERNET_FLAG_IGNORE_CERT_CN_INVALID,
        0                   // dwContext
        );
    if (NULL == hInternetFile) {
        PrintLastError("InternetOpenUrlW");
        goto CommonReturn;
    }

    DisplayCacheEntryInfoW(pwszUrl);
    ReadUrl(hInternetFile);

CommonReturn:
    if (hInternetFile) {
        if (!InternetCloseHandle(hInternetFile))
            PrintLastError("InternetCloseHandle(File)");
    }
    if (hInternetSession) {
        if (!InternetCloseHandle(hInternetSession))
            PrintLastError("InternetCloseHandle(Session)");
    }
}


typedef struct _QUERY_INFO {
    LPSTR   pszInfo;
    DWORD   dwInfo;
} QUERY_INFO, *PQUERY_INFO;

static QUERY_INFO rgQueryInfo[] = {
#if 0
    "HTTP_QUERY_MIME_VERSION-Req",
        HTTP_QUERY_MIME_VERSION | HTTP_QUERY_FLAG_REQUEST_HEADERS,
    "HTTP_QUERY_CONTENT_TYPE-Req",
        HTTP_QUERY_CONTENT_TYPE | HTTP_QUERY_FLAG_REQUEST_HEADERS,
    "HTTP_QUERY_CONTENT_TRANSFER_ENCODING-Req",
        HTTP_QUERY_CONTENT_TRANSFER_ENCODING | HTTP_QUERY_FLAG_REQUEST_HEADERS,
    "HTTP_QUERY_CONTENT_LENGTH-Req",
        HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_REQUEST_HEADERS,
#endif

    "Request WINHTTP_QUERY_RAW_HEADERS_CRLF",
        HTTP_QUERY_RAW_HEADERS_CRLF | HTTP_QUERY_FLAG_REQUEST_HEADERS,
    "HTTP_QUERY_MIME_VERSION", HTTP_QUERY_MIME_VERSION,
    "HTTP_QUERY_CONTENT_TYPE", HTTP_QUERY_CONTENT_TYPE,
    "HTTP_QUERY_CONTENT_TRANSFER_ENCODING",
        HTTP_QUERY_CONTENT_TRANSFER_ENCODING,
    "HTTP_QUERY_CONTENT_LENGTH", HTTP_QUERY_CONTENT_LENGTH,
    "HTTP_QUERY_CONTENT_LENGTH-Num",
        HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER,

    "HTTP_QUERY_VERSION", HTTP_QUERY_VERSION, 
    "HTTP_QUERY_STATUS_CODE", HTTP_QUERY_STATUS_CODE, 
    "HTTP_QUERY_STATUS_CODE-Num",
        HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
    "HTTP_QUERY_STATUS_TEXT", HTTP_QUERY_STATUS_TEXT, 
    "HTTP_QUERY_RAW_HEADERS", HTTP_QUERY_RAW_HEADERS, 
    "HTTP_QUERY_RAW_HEADERS_CRLF", HTTP_QUERY_RAW_HEADERS_CRLF, 
    "HTTP_QUERY_CONTENT_ENCODING", HTTP_QUERY_CONTENT_ENCODING, 
    "HTTP_QUERY_LOCATION", HTTP_QUERY_LOCATION, 
    "HTTP_QUERY_ORIG_URI", HTTP_QUERY_ORIG_URI, 
    "HTTP_QUERY_REQUEST_METHOD", HTTP_QUERY_REQUEST_METHOD, 
    "HTTP_QUERY_DATE",
        HTTP_QUERY_DATE | HTTP_QUERY_FLAG_SYSTEMTIME,
    "HTTP_QUERY_EXPIRES",
        HTTP_QUERY_EXPIRES | HTTP_QUERY_FLAG_SYSTEMTIME,
    "HTTP_QUERY_LAST_MODIFIED",
        HTTP_QUERY_LAST_MODIFIED | HTTP_QUERY_FLAG_SYSTEMTIME,
};

#define NQUERYINFO  (sizeof(rgQueryInfo)/sizeof(rgQueryInfo[0]))

static void DisplayQueryInfo(IN HINTERNET hInternetFile, IN BOOL fUnicode)
{
    DWORD i;
    for (i = 0; i < NQUERYINFO; i++) {
        DWORD dwIndex;
        BOOL fFirst;

        fFirst = TRUE;
        dwIndex = 0;
        while (TRUE) {
            BYTE rgbBuf[4096];
            DWORD cbBuf;
            DWORD dwThisIndex = dwIndex;
            BOOL fResult;
            DWORD dwValue;
            SYSTEMTIME st;

            memset(rgbBuf, 0, sizeof(rgbBuf));
            cbBuf = sizeof(rgbBuf);
    
            if (rgQueryInfo[i].dwInfo & HTTP_QUERY_FLAG_NUMBER) {
                dwValue = 0x183679;
                cbBuf = sizeof(dwValue);
                fResult = HttpQueryInfoA(
                    hInternetFile,
                    rgQueryInfo[i].dwInfo,
                    &dwValue,
                    &cbBuf,
                    &dwIndex);
            } else if (rgQueryInfo[i].dwInfo & HTTP_QUERY_FLAG_SYSTEMTIME) {
                cbBuf = sizeof(st);
                fResult = HttpQueryInfoA(
                    hInternetFile,
                    rgQueryInfo[i].dwInfo,
                    &st,
                    &cbBuf,
                    &dwIndex);
            } else if (fUnicode)
                fResult = HttpQueryInfoW(
                    hInternetFile,
                    rgQueryInfo[i].dwInfo,
                    rgbBuf,
                    &cbBuf,
                    &dwIndex);
            else
                fResult = HttpQueryInfoA(
                    hInternetFile,
                    rgQueryInfo[i].dwInfo,
                    rgbBuf,
                    &cbBuf,
                    &dwIndex);
            if (!fResult) {
                DWORD dwErr = GetLastError();
                if (fFirst || ERROR_HTTP_HEADER_NOT_FOUND != dwErr)
                    printf("HttpQueryInfo(%s) failed => 0x%x (%d) \n",
                        rgQueryInfo[i].pszInfo, dwErr, dwErr);
                break;
            } else if (rgQueryInfo[i].dwInfo & HTTP_QUERY_FLAG_NUMBER) {
                printf("%s[%d]:: 0x%x (%d)\n",
                    rgQueryInfo[i].pszInfo, dwThisIndex, dwValue, dwValue);
            } else if (rgQueryInfo[i].dwInfo & HTTP_QUERY_FLAG_SYSTEMTIME) {
                FILETIME ft;
                if (!SystemTimeToFileTime(&st, &ft)) {
                    DWORD dwErr = GetLastError();
                    printf("SystemTimeToFileTime(%s) failed => 0x%x (%d) \n",
                        rgQueryInfo[i].pszInfo, dwErr, dwErr);
                } else
                    printf("%s[%d]:: %s\n", rgQueryInfo[i].pszInfo,
                        dwThisIndex, FileTimeText(&ft));
            } else {
                printf("%s[%d]::\n",
                    rgQueryInfo[i].pszInfo, dwThisIndex);
                PrintBytes("  ", rgbBuf, cbBuf);
            }
            fFirst = FALSE;
            if (dwThisIndex == dwIndex) {
#if 0
                printf("HttpQueryInfo(%s) dwIndex not advanced\n",
                    rgQueryInfo[i].pszInfo);
#endif
                break;
            }
        }
    }
}

static void OnlineUrlA(
    LPSTR pszUrl
    )
{
    HINTERNET hInternetSession = NULL;
    HINTERNET hInternetFile = NULL;
    DWORD dwFlags;

    printf("****  ONLINE  ****\n");

#if 0
    DisplayDestinationReachableA(pszUrl);
#endif

    dwFlags = 0;
    hInternetSession = InternetOpenA(
        "CRL Agent",                    // lpszAgent
        INTERNET_OPEN_TYPE_PRECONFIG,   // dwAccessType
        NULL,                           // lpszProxy
        NULL,                           // lpszProxyBypass
        dwFlags
        );
    if (NULL == hInternetSession) {
        PrintLastError("InternetOpen");
        goto CommonReturn;
    }


    hInternetFile = InternetOpenUrlA(
        hInternetSession,
        pszUrl,
        "Accept: */*\r\n",  // lpszHeaders
        (DWORD) -1L,        // dwHeadersLength
        INTERNET_FLAG_RELOAD | INTERNET_FLAG_IGNORE_CERT_CN_INVALID,
        0                   // dwContext
        );
    if (NULL == hInternetFile) {
        PrintLastError("InternetOpenUrl");
        goto CommonReturn;
    }

    DisplayQueryInfo(hInternetFile, FALSE);
    ReadUrl(hInternetFile);
    DisplayCacheEntryInfoA(pszUrl);

CommonReturn:
    if (hInternetFile) {
        if (!InternetCloseHandle(hInternetFile))
            PrintLastError("InternetCloseHandle(File)");
    }
    if (hInternetSession) {
        if (!InternetCloseHandle(hInternetSession))
            PrintLastError("InternetCloseHandle(Session)");
    }
}

static void OnlineUrlW(
    LPWSTR pwszUrl
    )
{
    HINTERNET hInternetSession = NULL;
    HINTERNET hInternetFile = NULL;
    DWORD dwFlags;

    printf("****  ONLINE  ****\n");
    dwFlags = 0;
    hInternetSession = InternetOpenW(
        L"CRL Agent",                   // lpszAgent
        INTERNET_OPEN_TYPE_PRECONFIG,   // dwAccessType
        NULL,                           // lpszProxy
        NULL,                           // lpszProxyBypass
        dwFlags
        );
    if (NULL == hInternetSession) {
        PrintLastError("InternetOpenW");
        goto CommonReturn;
    }


    hInternetFile = InternetOpenUrlW(
        hInternetSession,
        pwszUrl,
        L"Accept: */*\r\n",  // lpszHeaders
        (DWORD) -1L,        // dwHeadersLength
        INTERNET_FLAG_RELOAD | INTERNET_FLAG_IGNORE_CERT_CN_INVALID,
        0                   // dwContext
        );
    if (NULL == hInternetFile) {
        PrintLastError("InternetOpenUrlW");
        goto CommonReturn;
    }

    DisplayQueryInfo(hInternetFile, TRUE);
    ReadUrl(hInternetFile);
    DisplayCacheEntryInfoW(pwszUrl);

CommonReturn:
    if (hInternetFile) {
        if (!InternetCloseHandle(hInternetFile))
            PrintLastError("InternetCloseHandle(File)");
    }
    if (hInternetSession) {
        if (!InternetCloseHandle(hInternetSession))
            PrintLastError("InternetCloseHandle(Session)");
    }
}

void DisplayInternetState()
{
    DWORD dwFlags = 0;
    BOOL fResult;

    fResult = InternetGetConnectedState(&dwFlags, 0);
    if (!fResult)
        printf("NO ");
    printf("Internet Connection, dwFlags: 0x%x", dwFlags);

    if (dwFlags & INTERNET_CONNECTION_MODEM)
        printf(" MODEM");
    if (dwFlags & INTERNET_CONNECTION_LAN)
        printf(" LAN");
    if (dwFlags & INTERNET_CONNECTION_PROXY)
        printf(" PROXY");
    if (dwFlags & INTERNET_CONNECTION_MODEM_BUSY)
        printf(" MODEM_BUSY");
    if (dwFlags & INTERNET_RAS_INSTALLED)
        printf(" RAS_INSTALLED");
    if (dwFlags & INTERNET_CONNECTION_OFFLINE)
        printf(" OFFLINE");
    if (dwFlags & INTERNET_CONNECTION_CONFIGURED)
        printf(" CONFIGURED");
    printf("\n");


    dwFlags = 0;
    fResult = IsNetworkAlive(&dwFlags);
    if (fResult) {
        printf("Network Alive, dwFlags: 0x%x", dwFlags);

        if (dwFlags & NETWORK_ALIVE_LAN)
            printf(" LAN");
        if (dwFlags & NETWORK_ALIVE_WAN)
            printf(" WAN");
        if (dwFlags & NETWORK_ALIVE_AOL)
            printf(" AOL");
        printf("\n");
    } else {
        DWORD dwErr = GetLastError();
        printf("Network disconnected, 0x%x  (%d)\n", dwErr, dwErr);
    }

}


int _cdecl main(int argc, char * argv[]) 
{
    BOOL fResult;
    LPSTR pszUrl = NULL;
    WCHAR wszUrl[_MAX_PATH + 1];
    LPWSTR pwszUrl = NULL;
    BOOL fUnicode = FALSE;
    char szCanonicalizedUrl[_MAX_PATH + 1];
    WCHAR wszCanonicalizedUrl[_MAX_PATH + 1];
    DWORD cb;
    BOOL fDelete = FALSE;
    BOOL fCacheInfo = FALSE;
    BOOL fOfflineOnly = FALSE;
    BOOL fWireOnly = FALSE;
#define NO_CANONICALIZE     0xFFFFFFFF
    DWORD dwCanonicalizeFlags = ICU_BROWSER_MODE;

    BOOL fSyncTime = FALSE;
    LONG lSyncTimeDeltaSeconds = 0;

    BOOL fHostName = FALSE;
    WCHAR wszHostName[_MAX_PATH + 1];
    
    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'U':
                fUnicode = TRUE;
                break;
            case 'd':
                fDelete = TRUE;
                break;
            case 'i':
                fCacheInfo = TRUE;
                break;
            case 'o':
                fOfflineOnly = TRUE;
                break;
            case 'w':
                fWireOnly = TRUE;
                break;
            case 'c':
                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "None"))
                        dwCanonicalizeFlags = NO_CANONICALIZE;
                    else if (0 == _stricmp(argv[0]+2, "Spaces"))
                        dwCanonicalizeFlags = ICU_ENCODE_SPACES_ONLY;
                    else if (0 == _stricmp(argv[0]+2, "Browser"))
                        dwCanonicalizeFlags = ICU_BROWSER_MODE;
                    else if (0 == _stricmp(argv[0]+2, "All"))
                        dwCanonicalizeFlags = 0;
                    else {
                        printf("Need to specify -cNone | -cSpaces | -cBrowser | -cAll\n");
                        goto BadUsage;
                    }
                } else {
                    printf("Need to specify -cNone | -cSpaces | -cBrowser | -cAll\n");
                    goto BadUsage;
                }
                break;
            case 's':
                DisplayInternetState();
                goto CommonReturn;
            case 'n':
                fHostName = TRUE;
                break;
            case 'S':
                fSyncTime = TRUE;
                lSyncTimeDeltaSeconds = strtol(argv[0]+2, NULL, 0);
                break;
            case 'h':
            default:
                goto BadUsage;
            }
        } else
            pszUrl = argv[0];
    }


    if (pszUrl == NULL) {
        printf("missing URL\n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    if (fHostName) {
        MultiByteToWideChar(
                CP_ACP,
                0,                      // dwFlags
                pszUrl,
                -1,                     // null terminated
                wszUrl,
                sizeof(wszUrl) / sizeof(wszUrl[0]));

        wszHostName[0] = L'\0';
        fResult = I_CryptNetGetHostNameFromUrl (
            wszUrl,
            sizeof(wszHostName) / sizeof(wszHostName[0]),
            wszHostName
            );
        if (!fResult)
            PrintLastError("I_CryptNetGetHostNameFromUrl");
        else
            printf("HostName :: %S\n", wszHostName);

        goto CommonReturn;
    }

    if (fUnicode) {
        MultiByteToWideChar(
                CP_ACP,
                0,                      // dwFlags
                pszUrl,
                -1,                     // null terminated
                wszUrl,
                sizeof(wszUrl) / sizeof(wszUrl[0]));

        if (NO_CANONICALIZE == dwCanonicalizeFlags) {
            pwszUrl = wszUrl;
            printf("Unicode Url:: %S\n", pwszUrl);
        } else {
            cb = sizeof(wszCanonicalizedUrl);
            fResult = InternetCanonicalizeUrlW(
                wszUrl,
                wszCanonicalizedUrl,
                &cb,
                dwCanonicalizeFlags
                );
            if (!fResult) {
                PrintLastError("InternetCanonicalizeUrlW");
                goto CommonReturn;
            } else if (cb) {
                printf("Unicode CanonicalizedUrl:: %S\n", wszCanonicalizedUrl);
                pwszUrl = wszCanonicalizedUrl;
            } else {
                printf("Unicode CanonicalizedUrl:: returned empty string\n");
                goto CommonReturn;
            }
        }

        if (fDelete) {
            printf("Unicode DeleteUrlCacheEntry not supported\n");
        } else if (fSyncTime) {
            printf("Unicode SyncTime not supported\n");
        } else if (fCacheInfo) {
            DisplayCacheEntryInfoW(pwszUrl);
        } else if (fOfflineOnly) {
            OfflineUrlW(pwszUrl);
        } else if (fWireOnly) {
            OnlineUrlW(pwszUrl);
        } else {
            OfflineUrlW(pwszUrl);
            OnlineUrlW(pwszUrl);
        }
    } else {
        if (NO_CANONICALIZE == dwCanonicalizeFlags) {
            printf("Url:: %s\n", pszUrl);
        } else {
            cb = sizeof(szCanonicalizedUrl);
            fResult = InternetCanonicalizeUrlA(
                pszUrl,
                szCanonicalizedUrl,
                &cb,
                dwCanonicalizeFlags
                );
            if (!fResult) {
                PrintLastError("InternetCanonicalizeUrlA");
                goto CommonReturn;
            } else if (cb) {
                printf("CanonicalizedUrl:: %s\n", szCanonicalizedUrl);
                pszUrl = szCanonicalizedUrl;
            } else {
                printf("CanonicalizedUrl:: returned empty string\n");
                goto CommonReturn;
            }
        }

        if (fDelete) {
            if (!DeleteUrlCacheEntry(pszUrl)) {
                if (ERROR_FILE_NOT_FOUND != GetLastError())
                    PrintLastError("DeleteUrlCacheEntry");
            }
        } else if (fSyncTime) {
            SetSyncTime(pszUrl, lSyncTimeDeltaSeconds);
        } else if (fCacheInfo) {
            DisplayCacheEntryInfoA(pszUrl);
        } else if (fOfflineOnly) {
            OfflineUrlA(pszUrl);
        } else if (fWireOnly) {
            OnlineUrlA(pszUrl);
        } else {
            OfflineUrlA(pszUrl);
            OnlineUrlA(pszUrl);
        }
    }

CommonReturn:
    return 0;
BadUsage:
    Usage();
    goto CommonReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\passrec\passrec.c ===
//
//  keymigrt.c
//
//  Copyright (c) Microsoft Corp, 2000
//
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>

#include <shlobj.h>

#include <wincrypt.h>
#define SECURITY_WIN32
#include <security.h>
#include <secext.h>
#include "passrec.h"

#include <stdio.h>



extern BOOL GetUserSid(HANDLE   hClientToken,
           PSID*    ppSid,
           DWORD*   lpcbSid);

extern DWORD GetLocalSystemToken(HANDLE* phRet);


void Usage();


int __cdecl wmain(int cArg, wchar_t *rgszArg[])
{

    DWORD dwBehavior = 0;
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTPROV hProv = 0;
    HANDLE      hToken = NULL;
    int i;

    LPWSTR wszFilename = NULL;

    LPWSTR wszPassword = NULL;

    BOOL   fGenerate = FALSE;

    PSID pCurrentSid = NULL;
    DWORD cbCurrentSid = 0;

    UNICODE_STRING UserName;
    UNICODE_STRING Password;

    WCHAR UserNameBuffer[MAX_PATH];

    PBYTE pbRecoveryPrivate = NULL;

    DWORD cbRecoveryPrivate = 0;
    HANDLE hPrivate = INVALID_HANDLE_VALUE;



    if(cArg < 2)
    {
        Usage();
    }

    // Parse command line

    for(i=1; i < cArg; i++)
    {
        LPWSTR szCurrentArg = rgszArg[i];

        if((*szCurrentArg != L'-') &&
           (*szCurrentArg != L'/'))
        {
            Usage();
            goto error;
        }
        szCurrentArg++;

        while(*szCurrentArg)
        {
        
            switch(*szCurrentArg++)
            {
                case L'n':
                case L'N':
                    if(cArg < i+2)
                    {
                        Usage();
                        goto error;
                    }
                    if(*szCurrentArg)
                    {
                        if(cArg < i+1)
                        {
                            Usage();
                            goto error;
                        }

                        wszFilename = szCurrentArg;
                    }
                    else
                    {
                        if(cArg < i+2)
                        {
                            Usage();
                            goto error;
                        }
                        i++;
                        wszFilename = rgszArg[i];
                    }
                    i++;
                    wszPassword = rgszArg[i];
                    fGenerate = TRUE;
                    break;
            
                case L'r':
                case L'R':
                    if(cArg < i+1)
                    {
                        Usage();
                        goto error;
                    }
                    if(*szCurrentArg)
                    {
                        wszFilename = szCurrentArg;
                    }
                    else
                    {
                        if(cArg < i+1)
                        {
                            Usage();
                            goto error;
                        }
                        i++;
                        wszFilename = rgszArg[i];
                    }
                    break;

                default:
                    Usage();
                    goto error;
            }

            
        }
    }

    
    if(fGenerate)
    {
    
     
        ULONG Length = MAX_PATH;


        Password.Buffer = wszPassword;
        Password.Length = wcslen(wszPassword)*sizeof(WCHAR);
        Password.MaximumLength = Password.Length + sizeof(WCHAR);

        UserName.Buffer = UserNameBuffer;
        UserName.Length = MAX_PATH;
        UserName.MaximumLength = MAX_PATH*sizeof(WCHAR);

        if(!GetUserNameW(UserNameBuffer, &Length))
        {
            dwError = GetLastError();
            printf("Could not get user name:%lx\n", dwError);
            goto error;
        }
        UserName.Length = (USHORT)Length*sizeof(WCHAR);


        if(!GetUserSid(NULL,
           &pCurrentSid,
           &cbCurrentSid))
        {
            printf("Could not get user sid:%lx\n", dwError);
            dwError = GetLastError();
            goto error;

        }
        dwError = GetLocalSystemToken(&hToken);
        if(ERROR_SUCCESS != dwError)
        {
            printf("Could not retrieve local system token:%lx\n", dwError);
            goto error;
        }

        if(!ImpersonateLoggedOnUser(hToken))
        {
            dwError = GetLastError();
            printf("Could not impersonate local system:%lx\n", dwError);
            goto error;

        }


        dwError = PRGenerateRecoveryKey(
                           pCurrentSid,
                           &UserName,
                           &Password,
                           &pbRecoveryPrivate,
                           &cbRecoveryPrivate);

        RevertToSelf();

        if(ERROR_SUCCESS != dwError)
        {
            printf("Could not generate recovery key:%lx\n", dwError);
            goto error;
        }


        hPrivate = CreateFileW(wszFilename, 
                               GENERIC_WRITE,
                               0,
                               NULL,
                               CREATE_ALWAYS,
                               0,
                               NULL);
        if(INVALID_HANDLE_VALUE == hPrivate)
        {
            dwError = GetLastError();
            printf("Could not open recovery key file:%lx\n", dwError);
            goto error;
        }

        if(!WriteFile(hPrivate, pbRecoveryPrivate, cbRecoveryPrivate, &cbRecoveryPrivate, NULL))
        {
            dwError = GetLastError();
            printf("Could not write recovery key file:%lx\n", dwError);
            goto error;
        }


    }
    else
    {

        if(!ImpersonateSelf(SecurityImpersonation))
        {
            dwError = GetLastError();
            printf("Could not impersonate self:%lx\n", dwError);
            goto error;

        }

        hPrivate = CreateFileW(wszFilename, 
                               GENERIC_READ,
                               0,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL);
        if(INVALID_HANDLE_VALUE == hPrivate)
        {
            dwError = GetLastError();
            printf("Could not open recovery key file:%lx\n", dwError);
            goto error;
        }

        cbRecoveryPrivate = GetFileSize(hPrivate, NULL);

        if(-1 == cbRecoveryPrivate)
        {
            dwError = GetLastError();
            printf("Could not retrieve recovery key file size:%lx\n", dwError);
            goto error;

        }

        pbRecoveryPrivate = (PBYTE)LocalAlloc(LMEM_FIXED, cbRecoveryPrivate);

        if(NULL == pbRecoveryPrivate)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            printf("Memory allocation failure:%lx\n", dwError);
            goto error;
        }

        if(!ReadFile(hPrivate, pbRecoveryPrivate, cbRecoveryPrivate, &cbRecoveryPrivate, NULL))
        {
            dwError = GetLastError();
            printf("Could not read recovery key file:%lx\n", dwError);
            goto error;
        }


        dwError = PRRecoverPassword(
                                    pbRecoveryPrivate,
                                    cbRecoveryPrivate,
                                    &Password);

        if(ERROR_SUCCESS == dwError)
        {
            printf("Recovered Password: %S\n", Password.Buffer);
            ZeroMemory(Password.Buffer, Password.MaximumLength);
            LocalFree(Password.Buffer);
        }

        RevertToSelf();
    }


error:

    if(hToken)
    {
        CloseHandle(hToken);
    }

    if(hPrivate != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hPrivate);
    }
    if(pbRecoveryPrivate)
    {
        ZeroMemory(pbRecoveryPrivate, cbRecoveryPrivate);

        LocalFree(pbRecoveryPrivate);
    }

    if(pCurrentSid)
    {
        LocalFree(pCurrentSid);
    }



    return (ERROR_SUCCESS == dwError)?0:-1;

}


void Usage()
{
    printf("Password Recovery Utility\n");
    printf("Usage: passrec -n filename password\n");
    printf("       passrec -r filename \n\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\passrec\systok.cpp ===
//
//  chngpwd.cpp
//
//  Copyright (c) Microsoft Corp, 1998
//
//  This file contains source code for testing protected storage's key
//  backup and recovery capabilities under a real world scenario, by creating
//  a local user account, performing a data protection operation, and then
//  change the pwd, then performing data unprotect, and comparing the data.
//
//  History:
//
//  Todds       8/15/98     Created
//
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <wincrypt.h>
#include <userenv.h>
#include <lm.h>
#include <psapi.h>

#define TERROR(msg)          LogError(__FILE__, __LINE__, msg)
#define TERRORVAL(msg, val)  LogErrorVal(__FILE__, __LINE__, msg, val)
#define TCOMMENT(msg)        LogComment(msg)
#define MyAlloc(cb)          HeapAlloc(GetProcessHeap(), 0, cb)
#define MyFree(pv)           HeapFree(GetProcessHeap(), 0, pv)
#define WSZ_BYTECOUNT(s)     (2 * wcslen(s) + 2)
#define CHECK_NULL(s)        if (s == NULL) \
                                LogError(__FILE__, __LINE__, L"## CHECK_NULL ##")

#define MAX_BLOBS           20
#define MAX_PROCESSES       200
#define MAX_SD              2048
#define BLOB_INCREMENT      0x4001 // 1 page + 1 byte...




//
//  Error Logging Functions  # defined as follows to include
//  Line and FILE macros:
//
//  TERROR       -   LogError()
//  TERRORVAL    -   LogErrorVal()
//
//

void
LogError(LPSTR szFile,
         int iLine,
         LPWSTR wszMsg)
{

    //
    //  Event log or testutil logging later...
    //

    WCHAR buffer[512];
    swprintf(buffer, L"ERROR Line: %i -> %s\n", iLine, wszMsg);
    OutputDebugStringW(buffer);
    wprintf(buffer);


}

void
LogErrorVal(LPSTR  szFile,
            int    iLine,
            LPWSTR wszMsg,
            DWORD  dwVal)
{

    WCHAR buffer[256]; // this should be adequate.
    swprintf(buffer, L"%s Error:: %x", wszMsg, dwVal);
    LogError(szFile, iLine, buffer);
}

void
LogComment(LPWSTR wszMsg)
{

    //
    //  Event log or testutil logging later...
    //

    WCHAR buffer[512];
    OutputDebugStringW(wszMsg);
    wprintf(wszMsg);
}



void 
DumpBin(CRYPT_DATA_BLOB hash)
{

    WCHAR buff[256], out[256];
    ULONG cb;

    swprintf(out, L"");
    while (hash.cbData > 0) {
        cb = min(4, hash.cbData);
        hash.cbData -= cb;
        for (; cb > 0; cb--, hash.pbData++) {
            swprintf(buff, L"%02X", *hash.pbData);
            wcscat(out, buff);
        }
        wcscat(out, L" ");
    }
    
    wcscat(out, L"\n");

    TCOMMENT(out);
}
//
//  SetSidOnAcl
//


BOOL
SetSidOnAcl(
    PSID pSid,
    PACL pAclSource,
    PACL *pAclDestination,
    DWORD AccessMask,
	BYTE AceFlags,
    BOOL bAddSid
    )
{
    ACL_SIZE_INFORMATION AclInfo;
    DWORD dwNewAclSize, dwErr = S_OK;
    LPVOID pAce;
    DWORD AceCounter;
    BOOL bSuccess=FALSE; // assume this function will fail

    //
    // If we were given a NULL Acl, just provide a NULL Acl
    //
    if(pAclSource == NULL) {
        *pAclDestination = NULL;
        return TRUE;
    }

    if(!IsValidSid(pSid)) return FALSE;

    if(!GetAclInformation(
        pAclSource,
        &AclInfo,
        sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation
        )) return FALSE;

    //
    // compute size for new Acl, based on addition or subtraction of Ace
    //
    if(bAddSid) {
        dwNewAclSize=AclInfo.AclBytesInUse  +
            sizeof(ACCESS_ALLOWED_ACE)  +
            GetLengthSid(pSid)          -
            sizeof(DWORD)               ;
    }
    else {
        dwNewAclSize=AclInfo.AclBytesInUse  -
            sizeof(ACCESS_ALLOWED_ACE)  -
            GetLengthSid(pSid)          +
            sizeof(DWORD)               ;
    }

    *pAclDestination = (PACL)MyAlloc(dwNewAclSize);

    if(*pAclDestination == NULL) 
    {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        return FALSE;
    }

    
    //
    // initialize new Acl
    //
    if(!InitializeAcl(
            *pAclDestination, 
            dwNewAclSize, 
            ACL_REVISION
            )){
        dwErr = GetLastError();
        TERRORVAL(L"InitilizeAcl failed!", dwErr);
        goto ret;
    }

    //
    // if appropriate, add ace representing pSid
    //
    if(bAddSid) {
		PACCESS_ALLOWED_ACE pNewAce;

        if(!AddAccessAllowedAce(
            *pAclDestination,
            ACL_REVISION,
            AccessMask,
            pSid
            )) {
            dwErr = GetLastError();
            TERRORVAL(L"AddAccessAllowedAce failed!", dwErr);
            goto ret;
        }

		//
		// get pointer to ace we just added, so we can change the AceFlags
		//
		if(!GetAce(
			*pAclDestination,
			0, // this is the first ace in the Acl
			(void**) &pNewAce
			)){
        
            dwErr = GetLastError();
            TERRORVAL(L"GetAce failed!", dwErr);
            goto ret;
        }

		pNewAce->Header.AceFlags = AceFlags;	
    }

    //
    // copy existing aces to new Acl
    //
    for(AceCounter = 0 ; AceCounter < AclInfo.AceCount ; AceCounter++) {
        //
        // fetch existing ace
        //
        if(!GetAce(pAclSource, AceCounter, &pAce)){
            dwErr = GetLastError();
            TERRORVAL(L"GetAce failed!", dwErr);
            goto ret;
        }
        //
        // check to see if we are removing the Ace
        //
        if(!bAddSid) {
            //
            // we only care about ACCESS_ALLOWED aces
            //
            if((((PACE_HEADER)pAce)->AceType) == ACCESS_ALLOWED_ACE_TYPE) {
                PSID pTempSid=(PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;
                //
                // if the Sid matches, skip adding this Sid
                //
                if(EqualSid(pSid, pTempSid)) continue;
            }
        }

        //
        // append ace to Acl
        //
        if(!AddAce(
            *pAclDestination,
            ACL_REVISION,
            MAXDWORD,  // maintain Ace order
            pAce,
            ((PACE_HEADER)pAce)->AceSize
            )) {
         
            dwErr = GetLastError();
            TERRORVAL(L"AddAccessAllowedAce failed!", dwErr);
            goto ret;
        }
    }

    bSuccess=TRUE; // indicate success

    
ret:

    //
    // free memory if an error occurred
    //
    if(!bSuccess) {
        if(*pAclDestination != NULL)
            MyFree(*pAclDestination);
    }

    

    return bSuccess;
}
//
//  AddSIDToKernelObject()
//
//  This function takes a given SID and dwAccess and adds it to a given token.
//
//  **  Be sure to restore old kernel object
//  **  using call to GetKernelObjectSecurity()
//
BOOL
AddSIDToKernelObjectDacl(PSID                   pSid,
                         DWORD                  dwAccess,
                         HANDLE                 OriginalToken,
                         PSECURITY_DESCRIPTOR*  ppSDOld)
{

    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_DESCRIPTOR     sdNew;
    DWORD                   cbByte = MAX_SD, cbNeeded = 0, dwErr = 0; 
    PACL                    pOldDacl = NULL, pNewDacl = NULL;
    BOOL                    fDaclPresent, fDaclDefaulted, fRet = FALSE;                    
   
    pSD = (PSECURITY_DESCRIPTOR) MyAlloc(cbByte);
    if (NULL == pSD) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        return FALSE;
    }

    if (!InitializeSecurityDescriptor(
                &sdNew, 
                SECURITY_DESCRIPTOR_REVISION
                )) {

        dwErr = GetLastError();
        TERRORVAL(L"InitializeSecurityDescriptor failed!", dwErr);
        goto ret;
    }

    if (!GetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        pSD,
        cbByte,
        &cbNeeded
        )) {
        
        dwErr = GetLastError();
        if (cbNeeded > MAX_SD && dwErr == ERROR_MORE_DATA) { 
    
            MyFree(pSD);
            pSD = NULL;
            pSD = (PSECURITY_DESCRIPTOR) MyAlloc(cbNeeded);
            if (NULL == pSD) {
                TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
                dwErr = E_OUTOFMEMORY;
                goto ret;
            }
            
            dwErr = S_OK;
            if (!GetKernelObjectSecurity(
                OriginalToken,
                DACL_SECURITY_INFORMATION,
                pSD,
                cbNeeded,
                &cbNeeded
                )) {
                dwErr = GetLastError();
            }
            
        }
        
        if (dwErr != S_OK) {
            TERRORVAL(L"GetKernelObjectSecurity failed!", dwErr);
            goto ret;
        }
    }
    
    if (!GetSecurityDescriptorDacl(
        pSD,
        &fDaclPresent,
        &pOldDacl,
        &fDaclDefaulted
        )) {
        dwErr = GetLastError();
        TERRORVAL(L"GetSecurityDescriptorDacl failed!", dwErr);
        goto ret;
    }
    
    if (!SetSidOnAcl(
        pSid,
        pOldDacl,
        &pNewDacl,
        dwAccess,
        0,
        TRUE
        )) {
        goto ret;
    }
    
    if (!SetSecurityDescriptorDacl(
        &sdNew,
        TRUE,
        pNewDacl,
        FALSE
        )) {
        dwErr = GetLastError();
        TERRORVAL(L"SetSecurityDescriptorDacl failed!", dwErr);
        goto ret;
    } 
    
    if (!SetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        &sdNew
        )) {
        
        dwErr = GetLastError();
        TERRORVAL(L"SetKernelObjectSecurity failed!", dwErr);
        goto ret;
    }
    
    *ppSDOld = pSD;
    fRet = TRUE;

ret:

    if (NULL != pNewDacl) {
        MyFree(pNewDacl);
    }

    if (!fRet) {
        if (NULL != pSD) {
            MyFree(pSD);
            *ppSDOld = NULL;
        }

    }
       
    return fRet;
}


//
//  DataFree()
//
//  Utility for freeing array of DATA_BLOB structs
//
void
DataFree(DATA_BLOB* arDataBlob, 
         BOOL       fCryptAlloc)
{

    if (arDataBlob == NULL) return; // not alloc'd
    
    for (DWORD i = 0; i < MAX_BLOBS;i++) {

        if (arDataBlob[i].pbData != NULL) {
            
            if (!fCryptAlloc) { 
                MyFree(arDataBlob[i].pbData);
            } else { // Data member alloc'd by DataProtect call
                LocalFree(arDataBlob[i].pbData);
            }
        }
       
    }

    MyFree(arDataBlob);
}

    


BOOL
SetPrivilege(
    HANDLE hToken,          // token handle
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious=sizeof(TOKEN_PRIVILEGES);

    if(!LookupPrivilegeValue( NULL, Privilege, &luid )) return FALSE;

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    //
    // second pass.  set privilege based on previous setting
    //
    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;

    if(bEnablePrivilege) {
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    }
    else {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
            tpPrevious.Privileges[0].Attributes);
    }

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    return TRUE;
}

BOOL
SetCurrentPrivilege(
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    BOOL bSuccess=FALSE; // assume failure
    HANDLE hToken;

    if (!OpenThreadToken(
            GetCurrentThread(), 
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            FALSE,
            &hToken)){       
                
        if(!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            )) return FALSE;
    }

    if(SetPrivilege(hToken, Privilege, bEnablePrivilege)) bSuccess=TRUE;
    CloseHandle(hToken);

    return bSuccess;
}


//
//  GetUserSid
//
//  This function takes a token, and returns the user SID from that token.
//
//  Note:   SID must be freed by MyFree()
//          hToken is optional...  NULL means we'll grab it.
//
extern "C" BOOL
GetUserSid(HANDLE   hClientToken,
           PSID*    ppSid,
           DWORD*   lpcbSid)
{
    DWORD                       cbUserInfo = 0;
    PTOKEN_USER                 pUserInfo = NULL;
    PUCHAR                      pnSubAuthorityCount = 0;
    DWORD                       cbSid = 0;
    BOOL                        fRet = FALSE;
    HANDLE                      hToken = hClientToken;
    
    *ppSid = NULL;

    if (NULL == hClientToken) {
        
        if (!OpenThreadToken(   
            GetCurrentThread(),
            TOKEN_QUERY,
            FALSE,
            &hToken
            )) { 
            
            // not impersonating, use process token...
            if (!OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_QUERY,
                &hToken
                )) {

                TERRORVAL(L"OpenProcessToken failed!", GetLastError());
                return FALSE;
            }
        }
    }
    
    // this will fail, usually w/ ERROR_INSUFFICIENT_BUFFER
    GetTokenInformation(
        hToken, 
        TokenUser, 
        NULL, 
        0, 
        &cbUserInfo
        );
    
    pUserInfo = (PTOKEN_USER) MyAlloc(cbUserInfo);
    if (NULL == pUserInfo) {
        TERRORVAL(L"ALLOC FAILURE!", E_OUTOFMEMORY);
        return FALSE;
    }
    
    if (!GetTokenInformation(
        hToken,
        TokenUser,
        pUserInfo,
        cbUserInfo,
        &cbUserInfo
        )) {
        
        TERRORVAL(L"GetTokenInformation failed!", GetLastError());
        goto ret;
    }
 
    //
    //  Now that we've got the SID AND ATTRIBUTES struct, get the SID lenght,
    //  alloc room, and return *just the SID*
    //
    if (!IsValidSid(pUserInfo->User.Sid)) goto ret;
    pnSubAuthorityCount = GetSidSubAuthorityCount(pUserInfo->User.Sid);
    cbSid = GetSidLengthRequired(*pnSubAuthorityCount);

    *ppSid = (PSID) MyAlloc(cbSid);
    if (NULL == *ppSid ) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        goto ret;
    }

    if (!CopySid(
            cbSid,
            *ppSid, 
            pUserInfo->User.Sid
            )) {
        
        TERRORVAL(L"CopySid failed!", GetLastError());
        goto copyerr;
    }

    *lpcbSid = cbSid; // may be useful later on...
    fRet = TRUE;

ret:
    if (NULL == hClientToken && NULL != hToken) { // supplied our own
        CloseHandle(hToken);
    }

    if (NULL != pUserInfo) {
        MyFree(pUserInfo);
    }

    return fRet;

copyerr:

    if (NULL != *ppSid) {
        MyFree(*ppSid);
        *ppSid = NULL;
    }

    goto ret;
}

//
//  IsLocalSystem()
//  This function makes the determination if the given process token
//  is running as local system.
//
BOOL
IsLocalSystem(HANDLE hToken) 
{


    PSID                        pLocalSid = NULL, pTokenSid = NULL;
    SID_IDENTIFIER_AUTHORITY    IDAuthorityNT      = SECURITY_NT_AUTHORITY;
    DWORD                       cbSid = 0;    
    BOOL                        fRet = FALSE;

    if (!GetUserSid(
            hToken,
            &pTokenSid,
            &cbSid
            )) {
        goto ret;
    }

    if (!AllocateAndInitializeSid(
                &IDAuthorityNT,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0,0,0,0,0,0,0,
                &pLocalSid
                )) {

        TERRORVAL(L"AllocateAndInitializeSid failed!", GetLastError());
        goto ret;
    }

    if (EqualSid(pLocalSid, pTokenSid)) {
        fRet = TRUE; // got one!
    } 

ret:

    if (NULL != pTokenSid) {
        MyFree(pTokenSid);
    }

    if (NULL != pLocalSid) {
        FreeSid(pLocalSid);
    }

    return fRet;
}




//
//  GetLocalSystemToken()
//
//  This function grabs a process token from a LOCAL SYSTEM process and uses it
//  to run as local system for the duration of the test
//
extern "C" DWORD
GetLocalSystemToken(HANDLE* phRet)
{

    HANDLE  hProcess = NULL;
    HANDLE  hPToken = NULL, hPTokenNew = NULL, hPDupToken = NULL;

    DWORD   rgPIDs[MAX_PROCESSES], cbNeeded = 0, dwErr = S_OK, i = 0;
    DWORD   cbrgPIDs = sizeof(DWORD) * MAX_PROCESSES;

    PSECURITY_DESCRIPTOR    pSD = NULL;
    PSID                    pSid = NULL;
    DWORD                   cbSid = 0;
    BOOL                    fSet = FALSE;

    //  SLOW BUFFERs
    BYTE    rgByte[MAX_SD], rgByte2[MAX_SD];
    DWORD   cbByte = MAX_SD, cbByte2 = MAX_SD;
  
    *phRet = NULL;

    if(!SetCurrentPrivilege(SE_DEBUG_NAME, TRUE)) {
        TERROR(L"SetCurrentPrivilege (debug) failed!");
        return E_FAIL;
    }

    if(!SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME, TRUE)) {
        TERROR(L"SetCurrentPrivilege (to) failed!");
        return E_FAIL;
    }

    if (!EnumProcesses(
                rgPIDs,
                cbrgPIDs,
                &cbNeeded
                )) {

        dwErr = GetLastError();
        TERRORVAL(L"EnumProcesses failed!", dwErr);
        goto ret;
    }

    //
    //  Get current user's sid for use in expanding SD.
    //
    if (!GetUserSid(
        NULL, 
        &pSid,
        &cbSid
        )) {
        goto ret;
    }

    //
    //  Walk processes until we find one that's running as
    //  local system
    //
    for (i = 1; i < (cbNeeded / sizeof(DWORD)); i++) {

        hProcess = OpenProcess(
                    PROCESS_ALL_ACCESS,
                    FALSE,
                    rgPIDs[i]
                    );
        
        if (NULL == hProcess) {
            dwErr = GetLastError();
            TERRORVAL(L"OpenProcess failed!", dwErr);
            goto ret;
        }

        if (!OpenProcessToken(
                    hProcess,
                    READ_CONTROL | WRITE_DAC,
                    &hPToken
                    )) {

            dwErr = GetLastError();
            TERRORVAL(L"OpenProcessToken failed!", dwErr);
            goto ret;
        }

        //
        //  We've got a token, but we can't use it for 
        //  TOKEN_DUPLICATE access.  So, instead, we'll go
        //  ahead and whack the DACL on the object to grant us
        //  this access, and get a new token.
        //  **** BE SURE TO RESTORE hProcess to Original SD!!! ****
        //
        if (!AddSIDToKernelObjectDacl(
                         pSid,
                         TOKEN_DUPLICATE,
                         hPToken,
                         &pSD
                         )) {
            goto ret;
        }
                       
        fSet = TRUE;
        
        if (!OpenProcessToken(
            hProcess,
            TOKEN_DUPLICATE,
            &hPTokenNew
            )) {
            
            dwErr = GetLastError();
            TERRORVAL(L"OpenProcessToken failed!", dwErr);
            goto ret;
        }
        
        //
        //  Duplicate the token
        //
        if (!DuplicateTokenEx(
                    hPTokenNew,
                    TOKEN_ALL_ACCESS,
                    NULL,
                    SecurityImpersonation,
                    TokenPrimary,
                    &hPDupToken
                    )) {

            dwErr = GetLastError();
            TERRORVAL(L"DuplicateToken failed!", dwErr);
            goto ret;
        }

        if (IsLocalSystem(hPDupToken)) {
            *phRet = hPDupToken;
            break; // found a local system token
        }

        //  Loop cleanup
        if (!SetKernelObjectSecurity(
            hPToken,
            DACL_SECURITY_INFORMATION,
            pSD
            )) {

            dwErr = GetLastError();
            TERRORVAL(L"SetKernelObjectSecurity failed!", dwErr);
            goto ret;
        } 
        
        fSet = FALSE;
        
        if (NULL != hPDupToken) {
            CloseHandle(hPDupToken);
            hPDupToken = NULL;
        }

        if (NULL != pSD) { 
            MyFree(pSD);
            pSD = NULL;
        }

        if (NULL != hPToken) {
            CloseHandle(hPToken);
            hPToken = NULL;
        }

        if (NULL != hProcess) {
            CloseHandle(hProcess);
            hProcess = NULL;
        }

    } // ** FOR ** 

ret:


    //***** REMEMBER TO RESTORE ORIGINAL SD TO OBJECT*****
    
    if (fSet) {
        
        if (!SetKernelObjectSecurity(
            hPToken,
            DACL_SECURITY_INFORMATION,
            pSD
            )) {
            
            dwErr = GetLastError();
            TERRORVAL(L"SetKernelObjectSecurity failed (cleanup)!", dwErr);
        } 
    }

    if (NULL != pSid) {
        MyFree(pSid);
    }

    if (NULL != hPToken) {
        CloseHandle(hPToken);
    }
    
    if (NULL != pSD) {
        MyFree(pSD);
    }

    if (NULL != hProcess) {
        CloseHandle(hProcess);
    }
    
    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tx500str\tx500str.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tx500str.cpp
//
//  Contents:   X500 Certificate Name String API Tests
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    18-Feb-97   philh   created
//              
//--------------------------------------------------------------------------

#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <time.h>

#define ALL_STR_TYPES   0xFFFFFFFF
static BOOL fVerbose = FALSE;

static void FormatAndParseCertNames(
    IN LPCSTR pszCertFilename,
    IN DWORD dwStrType,
    IN BOOL fSubject
    );


static void GetCertNameFromFile(
    IN LPCSTR pszCertFilename,
    IN DWORD dwGetNameStringType,
    IN LPSTR pszAttrOID,
    IN DWORD dwStrType,
    IN BOOL fSubject,
    IN DWORD dwExpectedErr
    );


static void ParseX500Name(
    IN LPCSTR pszName,
    IN DWORD dwStrType,
    IN DWORD dwExpectedErr,
    IN int iExpectedErrOffset
    );

static void ParsePredefinedX500Names();

#define CROW 8
void PrintWords(LPCSTR pszHdr, WORD *pw, DWORD cwSize)
{
    ULONG cw, i;

    while (cwSize > 0)
    {
        printf("%s", pszHdr);
        cw = min(CROW, cwSize);
        cwSize -= cw;
        for (i = 0; i<cw; i++)
            printf(" %04X", pw[i]);
        for (i = cw; i<CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i<cw; i++)
            if (pw[i] >= 0x20 && pw[i] <= 0x7f)
                printf("%C", pw[i]);
            else
                printf(".");
        pw += cw;
        printf("'\n");
    }
}

static void Usage(void)
{
    int i;

    printf("Usage: tx500str [options]\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -n<X500 Name>         - For example \"CN=Joe Cool, O=Microsoft\"\n");
    printf("  -e<number>            - Expected Error\n");
    printf("  -o<number>            - Expected Error Offset\n");
    printf("  -c<Cert Filename>     - Read encoded cert file for names\n");
    printf("  -S                    - Format cert's Subject (default)\n");
    printf("  -I                    - Format cert's Issuer\n");
    printf("  -f<number>            - Name string formatting type\n");
    printf("  -fAll                 - Name string formatting (All types)\n");
    printf("  -v                    - Verbose\n");


    printf("  -g                    - CertGetNameString(SIMPLE_DISPLAY)\n");
    printf("  -g<number>            - CertGetNameString type\n");
    printf("  -a<OID>               - Attribute OID, for example, -a2.5.4.3\n");

    printf("\n");
    printf("Default: Cycle through predefined list of X500 test names\n");
}

int _cdecl main(int argc, char * argv[]) 
{
    LPSTR pszName = NULL;
    LPSTR pszCertFilename = NULL;
    DWORD dwStrType = 0;
    DWORD dwExpectedErr = 0;
    int iExpectedErrOffset = -1;
    BOOL fSubject = TRUE;

    BOOL fGetCertName = FALSE;
    DWORD dwGetNameStringType = CERT_NAME_SIMPLE_DISPLAY_TYPE;
    LPSTR pszAttrOID = NULL;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'c':
                pszCertFilename = argv[0]+2;
                if (*pszCertFilename == '\0') {
                    printf("Need to specify filename\n");
                    goto BadUsage;
                }
                break;
            case 'n':
                pszName = argv[0]+2;
                if (*pszName == '\0') {
                    printf("Need to specify X500 name\n");
                    goto BadUsage;
                }
                break;
            case 'f':
                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "ALL"))
                        dwStrType = ALL_STR_TYPES;
                    else
                        dwStrType = (DWORD) strtoul(argv[0]+2, NULL, 0);
                } else {
                    printf("Need to specify -fALL or -f<number>\n");
                    goto BadUsage;
                }
                break;
            case 'e':
                if (argv[0][2])
                    dwExpectedErr = (DWORD) strtoul(argv[0]+2, NULL, 0);
                else {
                    printf("Need to specify -e<number>\n");
                    goto BadUsage;
                }
                break;
            case 'o':
                if (argv[0][2])
                    iExpectedErrOffset = strtol(argv[0]+2, NULL, 0);
                else {
                    printf("Need to specify -o<number>\n");
                    goto BadUsage;
                }
                break;
            case 'v':
                fVerbose = TRUE;
                break;
            case 'S':
                fSubject = TRUE;
                break;
            case 'I':
                fSubject = FALSE;
                break;


            case 'g':
                fGetCertName = TRUE;
                if (argv[0][2])
                    dwGetNameStringType = (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;
            case 'a':
                pszAttrOID = argv[0]+2;
                break;

            case 'h':
            default:
                goto BadUsage;
            }
        } else
            goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    if (pszName) {
        printf("Parsing ");
        ParseX500Name(
            pszName,
            dwStrType,
            dwExpectedErr,
            iExpectedErrOffset
            );
    } else if (pszCertFilename) {
        printf("Reading encoded certificate file: %s\n", pszCertFilename);

        if (fGetCertName)
            GetCertNameFromFile(
                pszCertFilename,
                dwGetNameStringType,
                pszAttrOID,
                dwStrType,
                fSubject,
                dwExpectedErr
                );
        else
            FormatAndParseCertNames(
                pszCertFilename,
                dwStrType,
                fSubject
                );
    } else {
        printf("Parsing predefined X500 test names\n", pszName);
        ParsePredefinedX500Names();
    }

CommonReturn:
    return 0;
BadUsage:
    Usage();
    goto CommonReturn;
}

static void *TestDecodeObject(
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded
    )
{
    DWORD cbInfo;
    void *pvInfo;
    
    // Set to bogus value. pvInfo == NULL, should cause it to be ignored.
    cbInfo = 0x12345678;
    CryptDecodeObject(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            0,                      // dwFlags
            NULL,                   // pvInfo
            &cbInfo
            );
    if (cbInfo == 0) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptDecodeObject(StructType: %d, pvInfo == NULL)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptDecodeObject(StructType: %s, pvInfo == NULL)",
                lpszStructType);
        PrintLastError("");
        return NULL;
    }
    if (NULL == (pvInfo = TestAlloc(cbInfo)))
        return NULL;
    if (!CryptDecodeObject(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            0,                      // dwFlags
            pvInfo,
            &cbInfo
            )) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptDecodeObject(StructType: %d)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptDecodeObject(StructType: %s)",
                lpszStructType);
        PrintLastError("");
        TestFree(pvInfo);
        return NULL;
    }

    return pvInfo;
}

static BOOL DecodeName(BYTE *pbEncoded, DWORD cbEncoded, DWORD dwStrType)
{
    BOOL fResult;
    PCERT_NAME_INFO pInfo = NULL;
    DWORD i,j;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;

    CERT_NAME_BLOB Name;
    DWORD cwsz;
    LPWSTR pwsz;
    
    if (NULL == (pInfo = (PCERT_NAME_INFO) TestDecodeObject(
            X509_NAME,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    for (i = 0, pRDN = pInfo->rgRDN; i < pInfo->cRDN; i++, pRDN++) {
        for (j = 0, pAttr = pRDN->rgRDNAttr; j < pRDN->cRDNAttr; j++, pAttr++) {
            LPSTR pszObjId = pAttr->pszObjId;
            if (pszObjId == NULL)
                pszObjId = "<NULL OBJID>";
            printf("  [%d,%d] %s ValueType: %d\n",
                i, j, pszObjId, pAttr->dwValueType);
            if (pAttr->Value.cbData)
                PrintBytes("    ", pAttr->Value.pbData, pAttr->Value.cbData);
            else
                printf("    NO Value Bytes\n");
        }
    }

    if (dwStrType == 0xFFFFFFFF)
        goto GoodReturn;
    Name.pbData = pbEncoded;
    Name.cbData = cbEncoded;
    if (0 == (dwStrType & 0xFFFF))
        dwStrType |= CERT_X500_NAME_STR;

    cwsz = CertNameToStrW(
        dwCertEncodingType,
        &Name,
        dwStrType,
        NULL,                   // pwsz
        0);                     // cwsz
    if (pwsz = (LPWSTR) TestAlloc(cwsz * sizeof(WCHAR))) {
        CertNameToStrW(
            dwCertEncodingType,
            &Name,
            dwStrType,
            pwsz,
            cwsz);
        printf("  %S\n", pwsz);
        TestFree(pwsz);
    }

GoodReturn:
    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}

static void ParseUnicodeX500Name(
    IN LPCWSTR pwszName,
    IN DWORD dwStrFlags
    )
{
    BOOL fResult;
    DWORD i;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    CERT_NAME_BLOB Name;
    DWORD cwsz;
    LPWSTR pwsz;

    printf("Unicode name::\n");
    PrintWords("  ", (WORD *) pwszName, wcslen(pwszName));

    fResult = CertStrToNameW(
        dwCertEncodingType,
        pwszName,
        dwStrFlags | 0,             // dwStrType
        NULL,                       // pvReserved
        NULL,                       // pbEncoded
        &cbEncoded,
        NULL                        // pwszError
        );
    if (!fResult) {
        PrintLastError("CertStrToNameW");
        return;
    }

    if (NULL == (pbEncoded = (BYTE *) TestAlloc(cbEncoded)))
        return;
    if (!CertStrToNameW(
            dwCertEncodingType,
            pwszName,
            dwStrFlags | 0,             // dwStrType
            NULL,                       // pvReserved
            pbEncoded,
            &cbEncoded,
            NULL                        // pwszError
            ))
        PrintLastError("CertStrToNameW");
    else if (fVerbose)
        DecodeName(pbEncoded, cbEncoded, 0xFFFFFFFF);

    // Decode name to see if we come up with what was passed in
    Name.pbData = pbEncoded;
    Name.cbData = cbEncoded;
    cwsz = CertNameToStrW(
        dwCertEncodingType,
        &Name,
        dwStrFlags | CERT_X500_NAME_STR,
        NULL,                   // pwsz
        0);                     // cwsz
    if (pwsz = (LPWSTR) TestAlloc(cwsz * sizeof(WCHAR))) {
        cwsz = CertNameToStrW(
            dwCertEncodingType,
            &Name,
            dwStrFlags | CERT_X500_NAME_STR,
            pwsz,
            cwsz);
        cwsz--;
        if (cwsz != wcslen(pwszName)) {
            printf("  failed => CertNameToStrW length of %d != %d\n",
                cwsz, wcslen(pwszName));
            PrintWords("  ", (WORD *) pwsz, cwsz);
        } else if (0 != memcmp(pwsz, pwszName, cwsz * sizeof(WCHAR))) {
            printf("  failed => CertNameToStrW didn't match input\n");
            PrintWords("  ", (WORD *) pwsz, cwsz);
        }
        TestFree(pwsz);
    }

    TestFree(pbEncoded);
}

typedef struct _X500_NAMES {
    LPCSTR      pszName;
    DWORD       dwStrType;
    DWORD       dwErr;          // 0 => expect success
    int         iErrOffset;     // -1 => expect NULL pszError
} X500_NAMES, *PX500_NAMES;

//             1         2         3         4         5         6
//   0123456789012345678901234567890123456789012345678901234567890

static const X500_NAMES rgX500Names[] = {
    "CN=Joe Cool", 0, 0, -1,
    "CN=Joe Cool;", 0, 0, -1,
    "CN=Joe Cool,", 0, 0, -1,
    "CN=Joe Cool+   ", 0, 0, -1,
    "Cn=Joe Cool+T= +   ", 0, 0, -1,
    "cn=Joe Cool+t= ,   ", 0, 0, -1,
    "cn=\"Joe Cool ,;+\"\"-#\t<>=\"", 0, 0, -1,
    "cN=Joe Cool + T = Programmer; OU= Micro  , OiD.1.2.3.4=#01 02", 0, 0, -1,
    "  1.2.3.4  =  #  0123456789abcdef 13  + SN = wow", 0, 0, -1,
    "1.2.3.4=\"# 0123456789abcdef 13 string not octet\"  + oid.1.2.3.4.1=#0123456789abcdef13 + SN = wow", 0, 0, -1,
    "oiD.1.2.3.4.5=#12\t34  \t45  \t 78;1.2.3=#45; 1.2.3.1=#87", 0, 0, -1,
    
    "C=US; L=Internet; St=Washington + Street=Microsoft Way", 0, 0, -1,
    "C=U#; L=Internet; Street=Microsoft Way", 0,
        (DWORD) CRYPT_E_INVALID_PRINTABLE_STRING, 3,
    "Email=joeC@microsoft.com", 0, 0, -1,
    "Email=joe\xB0oeC@microsoft.com", 0,
        (DWORD) CRYPT_E_INVALID_IA5_STRING, 9,
    "C=US; OU=Microsoft; St=Way +  L= Internet + Email=joe\xB0oeC@microsoft.com",
        0, (DWORD) CRYPT_E_INVALID_IA5_STRING, 53,
    "C=US; OU=Microsoft; St=Way +  L= Internet + Email=joejoeC@microsoft.com",
        0, 0, -1,
    "Email=\"\"\"Cool\"\" Guy\xB0@microsoft.com\"",
        0, (DWORD) CRYPT_E_INVALID_IA5_STRING, 19,
    "C=US; OU=Microsoft; St=Way +  L= Internet +  Email=\"\"\"Cool\"\" Guy\xB0@microsoft.com\"",
        0, (DWORD) CRYPT_E_INVALID_IA5_STRING, 64,
    "C=US; OU=Microsoft; St=Way +  L= Internet +  Email=\"\"\"Cool\"\" Guy@microsoft.com\"",
        0, 0, -1,
    "T = Numeric ; 2.5.4.24=0123456789 0123456789", 0, 0, -1,
    "T = Bad Numeric ; 2.5.4.24=0123456789abcdef 0123456789",
        0, (DWORD) CRYPT_E_INVALID_NUMERIC_STRING, 37,
    "  CN  =  \" Joe \"\"Cool\"\"\"    ", 0, 0, -1,
    "  CN  =  \"   Joe \"\"Cool\"\"    \"  ;T=quoted lead and trail spaces  ",
        0, 0, -1,
    "CN  =  Joe \"Cool\"   ", (DWORD) CERT_NAME_STR_NO_QUOTING_FLAG, 0, -1,
    "CN=Joe \"\"Cool\"\"   ", 0, (DWORD) CRYPT_E_INVALID_X500_STRING, 7,
    "  CN  =  \"Joe \"\"Cool\"\"   ", 0, (DWORD) CRYPT_E_INVALID_X500_STRING, 9,
    "CM=Joe Cool", 0, (DWORD) CRYPT_E_INVALID_X500_STRING, 0,
    "Cn=Joe Cool, Ox=wrong",
        0, (DWORD) CRYPT_E_INVALID_X500_STRING, 13,
    "OID.1.2=#01 02 g", 0, (DWORD) CRYPT_E_INVALID_X500_STRING, 8,
    "1.2=# ; T= empty ascii hex", 0, (DWORD) CRYPT_E_INVALID_X500_STRING, 4,
    "OID.1.2=#00; OID.1..3.1=#01; T=Consecutive dots",
        0, (DWORD) CRYPT_E_INVALID_X500_STRING, 13,
    "1.2=#f; T= Odd ascii hex", 0, 0, -1,
    "1.2=#12e; T= Odd ascii hex", 0, 0, -1,

    "CN = Joe, Cool ; OU = Microsoft, xyz; T=CERT_NAME_STR_SEMICOLON_FLAG",
        CERT_NAME_STR_SEMICOLON_FLAG, 0, -1,
    "CN = Joe, Cool ; OU = Microsoft, xyz",
        0, (DWORD) CRYPT_E_INVALID_X500_STRING, 10,
    "CN = Joe; Cool , OU = Microsoft; xyz, T=CERT_NAME_STR_COMMA_FLAG",
        CERT_NAME_STR_COMMA_FLAG, 0, -1,
    "CN = Joe; Cool , OU = Microsoft; xyz",
        0, (DWORD) CRYPT_E_INVALID_X500_STRING, 10,
    "CN = Joe, Cool ; More stuff  \n  OU = Microsoft; xyz \nT=CERT_NAME_STR_CRLF_FLAG",
        CERT_NAME_STR_CRLF_FLAG, 0, -1,
    "CN = Joe, Cool ; More stuff  \n  OU = Microsoft; xyz",
        0, (DWORD) CRYPT_E_INVALID_X500_STRING, 10,
    "CN = Joe Cool + more cool  ; L= Wa + more local; T=CERT_NAME_STR_NO_PLUS_FLAG",
        CERT_NAME_STR_NO_PLUS_FLAG, 0, -1,
    "CN = Joe Cool + more cool  ; L= Wa + more local;",
        0, (DWORD) CRYPT_E_INVALID_X500_STRING, 16,
    "CN = Joe Cool , OU = Microsoft  xyz  T=IgnoredEqualDelimiter",
        0, 0, -1,

    "CN = Joe Cool; T=CERT_SIMPLE_NAME_STR",
        CERT_SIMPLE_NAME_STR, (DWORD) E_INVALIDARG, -1,

    "CN=xyz; =; T=EmptyX500Key",
        0, (DWORD) CRYPT_E_INVALID_X500_STRING, 8,
    "O", 0, (DWORD) CRYPT_E_INVALID_X500_STRING, 0,
    "", 0, 0, -1
};
#define NX500NAMES (sizeof(rgX500Names) / sizeof(rgX500Names[0]))

static void ParsePredefinedX500Names()
{
    // Note, fffe and ffff aren't valid UTF8 characters
    LPWSTR pwszUnicodeName =
        L"DC=microsoft, "
        L"DC=com, "
        L"DC=\x0001 \x0002 \x007e \x007f, "
        L"DC=\x0080 \x0081 \x07fe \x07ff, "
        L"DC=\x0800 \x0801 \xfffc \xfffd, "
        L"CN=UNICODE, "
        L"OID.1.2.3.1=\x0001 \x0002 \x007e \x007f, "
        L"OID.1.2.3.2=\x0080 \x0081 \x07fe \x07ff, "
        L"OID.1.2.3.3=\x0800 \x0801 \xfffc \xfffd"
        ;

    WCHAR rgwszUnicode[3 + 1 + 0xFFFC + 1 + 1 + 1];
    DWORD i;
    DWORD j;

    wcscpy(rgwszUnicode, L"CN=\"");
    j = 4;
    for (i = 1; i <= 0xFF; i++) {
        rgwszUnicode[j++] = (WCHAR) i;
        if ((WCHAR) i == L'\"')
            rgwszUnicode[j++] = L'\"';
    }
    for (i = 0x7E0; i <= 0x820; i++)
        rgwszUnicode[j++] = (WCHAR) i;

    for (i = 0xFFE0; i <= 0xFFFD; i++)
        rgwszUnicode[j++] = (WCHAR) i;

    rgwszUnicode[j] = L'\0';

    wcscat(rgwszUnicode, L"\"");


    for (i = 0; i < NX500NAMES; i++)
        ParseX500Name(
            rgX500Names[i].pszName,
            rgX500Names[i].dwStrType,
            rgX500Names[i].dwErr,
            rgX500Names[i].iErrOffset
            );

    for (i = 0; i < NX500NAMES; i++)
        ParseX500Name(
            rgX500Names[i].pszName,
            rgX500Names[i].dwStrType | CERT_NAME_STR_REVERSE_FLAG,
            rgX500Names[i].dwErr,
            rgX500Names[i].iErrOffset
            );

    ParseUnicodeX500Name(pwszUnicodeName, 0);
    ParseUnicodeX500Name(pwszUnicodeName,
        CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG);
    ParseUnicodeX500Name(pwszUnicodeName, 
        CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG |
        CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG);
    ParseUnicodeX500Name(pwszUnicodeName,
        CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG);
    ParseUnicodeX500Name(pwszUnicodeName,
        CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG |
        CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG);

    ParseUnicodeX500Name(rgwszUnicode, 0);
    ParseUnicodeX500Name(rgwszUnicode,
        CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG);
    ParseUnicodeX500Name(rgwszUnicode,
        CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG |
        CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG);
}


static void ParseX500Name(
    IN LPCSTR pszName,
    IN DWORD dwStrType,
    IN DWORD dwExpectedErr,
    IN int iExpectedErrOffset
    )
{
    BOOL fResult;
    DWORD i;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    LPCSTR pszError;

    printf("<%s>\n", pszName);
    fResult = CertStrToNameA(
        dwCertEncodingType,
        pszName,
        dwStrType,
        NULL,                       // pvReserved
        NULL,                       // pbEncoded
        &cbEncoded,
        &pszError
        );
    if (!fResult) {
        DWORD dwErr = GetLastError();
        if (0 == dwExpectedErr)
            printf("  failed => unexpected error %d 0x%x\n", dwErr, dwErr);
        else if (dwErr != dwExpectedErr)
            printf("  failed => expected error %d 0x%x got %d 0x%x\n",
                dwExpectedErr, dwExpectedErr, dwErr, dwErr);
        if (pszError) {
            int iErrOffset = (int)(INT_PTR) (pszError - pszName);
            LPSTR pszNameErr = (LPSTR) _alloca(iErrOffset + 1 + 1);
            memcpy(pszNameErr, pszName, iErrOffset + 1);
            pszNameErr[iErrOffset + 1] = '\0';
            printf("  Error at offset %d  <%s\n", iErrOffset, pszNameErr);
            if (iExpectedErrOffset < 0)
                printf("  failed => unexpected error offset\n");
            else if (iExpectedErrOffset != iErrOffset)
                printf("  failed => expected error offset %d\n",
                    iExpectedErrOffset);
        } else if (iExpectedErrOffset >= 0)
            printf("  failed => expected error offset %d\n",
                iExpectedErrOffset);
    } else if (dwExpectedErr)
        printf("  failed => expected error %d 0x%x\n", 
            dwExpectedErr, dwExpectedErr);
    else {
        if (NULL == (pbEncoded = (BYTE *) TestAlloc(cbEncoded)))
            return;
        if (!CertStrToNameA(
                dwCertEncodingType,
                pszName,
                dwStrType,
                NULL,                       // pvReserved
                pbEncoded,
                &cbEncoded,
                &pszError
                ))
            PrintLastError("CertStrToName");
        else {
            if (pszError != NULL)
                printf("  failed => expected NULL pszError\n");
            if (fVerbose)
                DecodeName(pbEncoded, cbEncoded, dwStrType);
        }
        TestFree(pbEncoded);
    }
}

static LPWSTR NameToStr(
    IN PCERT_NAME_BLOB pName,
    IN DWORD dwStrType
    )
{
    DWORD cwsz;
    LPWSTR pwsz;

    cwsz = CertNameToStrW(
        dwCertEncodingType,
        pName,
        dwStrType,
        NULL,                   // pwsz
        0);                     // cwsz
    if (cwsz <= 1) {
        PrintLastError("CertNameToStr");
        return NULL;
    }
    if (pwsz = (LPWSTR) TestAlloc(cwsz * sizeof(WCHAR))) {
        cwsz = CertNameToStrW(
            dwCertEncodingType,
            pName,
            dwStrType,
            pwsz,
            cwsz);
    }
    return pwsz;
}

static BOOL StrToName(
    IN LPCWSTR pwszName,
    IN DWORD dwStrType,
    OUT PCERT_NAME_BLOB pName
    )
{
    BOOL fResult;
    LPCWSTR pwszError;
    memset(pName, 0, sizeof(*pName));

    fResult = CertStrToNameW(
        dwCertEncodingType,
        pwszName,
        dwStrType,
        NULL,                       // pvReserved
        NULL,                       // pbEncoded
        &pName->cbData,
        &pwszError
        );
    if (!fResult) {
        PrintLastError("CertStrToNameW");

        if (pwszError) {
            int iErrOffset = (int)(INT_PTR) (pwszError - pwszName);
            LPWSTR pwszNameErr = (LPWSTR) _alloca((iErrOffset + 1 + 1) * 2);
            memcpy(pwszNameErr, pwszName, (iErrOffset + 1) * 2);
            pwszNameErr[iErrOffset + 1] = L'\0';
            printf("Error at <%S\n", pwszNameErr);
        }

        return FALSE;
    }

    if (NULL == (pName->pbData = (BYTE *) TestAlloc(pName->cbData)))
        return FALSE;
    fResult = CertStrToNameW(
            dwCertEncodingType,
            pwszName,
            dwStrType,
            NULL,                       // pvReserved
            pName->pbData,
            &pName->cbData,
            NULL                        // pwszError
            );
    if (!fResult) {
        PrintLastError("CertStrToNameW");
        TestFree(pName->pbData);
        pName->pbData = NULL;
        return FALSE;
    }

    return TRUE;
}

static void FormatAndParseName(
    IN PCERT_NAME_BLOB pName,
    IN DWORD dwStrType
    )
{
    LPWSTR pwszName = NULL;
    CERT_NAME_BLOB Name2;
    memset(&Name2, 0, sizeof(Name2));
    LPWSTR pwszName2 = NULL;

    pwszName = NameToStr(pName, dwStrType);
    if (NULL == pwszName)
        goto ErrorReturn;
    printf("<%S>\n", pwszName);
    if (!StrToName(pwszName, dwStrType, &Name2))
        goto ErrorReturn;

    pwszName2 = NameToStr(&Name2, dwStrType);
    if (NULL == pwszName2)
        goto ErrorReturn;
    if (wcslen(pwszName) != wcslen(pwszName2) ||
            0 != wcscmp(pwszName, pwszName2)) {
        printf("failed => re-formatted name mismatch\n");
        printf("Re-formatted::\n");
        printf("<%S>\n", pwszName2);
    }

    if (pName->cbData != Name2.cbData ||
            0 != memcmp(pName->pbData, Name2.pbData, Name2.cbData)) {
        printf("failed => re-encoded name mismatch\n");
        printf("Input::\n");
        PrintBytes("    ", pName->pbData, pName->cbData);
        DecodeName(pName->pbData, pName->cbData, 0xFFFFFFFF);
        printf("Re-encoded::\n");
        PrintBytes("    ", Name2.pbData, Name2.cbData);
        DecodeName(Name2.pbData, Name2.cbData, 0xFFFFFFFF);
    }


ErrorReturn:
    if (pwszName)
        TestFree(pwszName);
    if (pwszName2)
        TestFree(pwszName2);
    if (Name2.pbData)
        TestFree(Name2.pbData);
}


    
static void FormatAndParseCertNames(
    IN LPCSTR pszCertFilename,
    IN DWORD dwStrType,
    IN BOOL fSubject
    )
{
    CERT_BLOB Cert;
    PCCERT_CONTEXT pCertContext = NULL;
    PCERT_NAME_BLOB pName;
    static DWORD rgdwStrType[] = {
        CERT_OID_NAME_STR,
        CERT_X500_NAME_STR,
        CERT_OID_NAME_STR | CERT_NAME_STR_SEMICOLON_FLAG |
            CERT_NAME_STR_NO_QUOTING_FLAG,
        CERT_X500_NAME_STR | CERT_NAME_STR_NO_QUOTING_FLAG |
            CERT_NAME_STR_CRLF_FLAG,
        CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
        CERT_X500_NAME_STR | CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG |
            CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG,
        CERT_X500_NAME_STR | CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG,
        0
    };
    DWORD *pdwStrType;
    
    
    if (!ReadDERFromFile(pszCertFilename, &Cert.pbData, &Cert.cbData))
        return;

    if (NULL == (pCertContext = CertCreateCertificateContext(
            dwCertEncodingType, Cert.pbData, Cert.cbData))) {
        PrintLastError("CertCreateCertificateContext");
        goto ErrorReturn;
    }

    if (fSubject) {
        printf("Subject::\n");
        pName = &pCertContext->pCertInfo->Subject;
    } else {
        printf("Issuer::\n");
        pName = &pCertContext->pCertInfo->Issuer;
    }

    if (fVerbose)
        DecodeName(pName->pbData, pName->cbData, 0xFFFFFFFF);

    if (dwStrType != 0xFFFFFFFF) {
        if (dwStrType == 0)
            dwStrType = CERT_X500_NAME_STR;
        FormatAndParseName(pName, dwStrType);
    } else {
        pdwStrType = rgdwStrType;
        while (dwStrType = *pdwStrType++) {
            FormatAndParseName(pName, dwStrType);
            printf("\n");
        }
    }

ErrorReturn:
    CertFreeCertificateContext(pCertContext);
    TestFree(Cert.pbData);
}

static void GetCertNameFromFile(
    IN LPCSTR pszCertFilename,
    IN DWORD dwGetNameStringType,
    IN LPSTR pszAttrOID,
    IN DWORD dwStrType,
    IN BOOL fSubject,
    IN DWORD dwExpectedErr
    )
{
    CERT_BLOB Cert;
    PCCERT_CONTEXT pCertContext = NULL;
    LPWSTR pwsz = NULL;
    LPSTR psz = NULL;
    DWORD cch;
    DWORD dwFlags;
    void *pvTypePara;

    dwFlags = dwGetNameStringType &  0xFFFF0000;
    dwGetNameStringType &= 0x0000FFFF;
    switch (dwGetNameStringType) {
        case CERT_NAME_RDN_TYPE:
            pvTypePara = &dwStrType;
            break;
        case CERT_NAME_ATTR_TYPE:
            pvTypePara = pszAttrOID;
            break;
        default:
            pvTypePara = NULL;
    }

    if (!ReadDERFromFile(pszCertFilename, &Cert.pbData, &Cert.cbData))
        return;

    if (NULL == (pCertContext = CertCreateCertificateContext(
            dwCertEncodingType, Cert.pbData, Cert.cbData))) {
        PrintLastError("CertCreateCertificateContext");
        goto ErrorReturn;
    }

    if (fSubject) {
        printf("Unicode Subject::\n");
        dwFlags |= 0;
    } else {
        printf("Unicode Issuer::\n");
        dwFlags |= CERT_NAME_ISSUER_FLAG;
    }

    cch = CertGetNameStringW(
        pCertContext,
        dwGetNameStringType,
        dwFlags,
        pvTypePara,
        NULL,                   // pwsz
        0);                     // cch
    if (cch <= 1) {
        DWORD dwErr = GetLastError();

        printf("  CertGetNameStringW returned empty string\n");
        if (0 == dwExpectedErr)
            printf("  failed => unexpected error %d 0x%x\n", dwErr, dwErr);
        else if (dwErr != dwExpectedErr)
            printf("  failed => expected error %d 0x%x got %d 0x%x\n",
                dwExpectedErr, dwExpectedErr, dwErr, dwErr);
    } else if (dwExpectedErr)
        printf("  failed => expected error %d 0x%x\n", 
            dwExpectedErr, dwExpectedErr);
    else if (pwsz = (LPWSTR) TestAlloc(cch * sizeof(WCHAR))) {
        cch = CertGetNameStringW(
            pCertContext,
            dwGetNameStringType,
            dwFlags,
            pvTypePara,
            pwsz,
            cch);
        printf("  <%S>\n", pwsz);
    }

    if (!fVerbose)
        goto CommonReturn;

    if (fSubject) {
        printf("ASCII Subject::\n");
        dwFlags = 0;
    } else {
        printf("ASCII Issuer::\n");
        dwFlags = CERT_NAME_ISSUER_FLAG;
    }

    cch = CertGetNameStringA(
        pCertContext,
        dwGetNameStringType,
        dwFlags,
        pvTypePara,
        NULL,                   // psz
        0);                     // cch
    if (cch <= 1) {
        DWORD dwErr = GetLastError();

        printf("  CertGetNameStringA returned empty string\n");
        if (0 == dwExpectedErr)
            printf("  failed => unexpected error %d 0x%x\n", dwErr, dwErr);
        else if (dwErr != dwExpectedErr)
            printf("  failed => expected error %d 0x%x got %d 0x%x\n",
                dwExpectedErr, dwExpectedErr, dwErr, dwErr);
    } else if (dwExpectedErr)
        printf("  failed => expected error %d 0x%x\n", 
            dwExpectedErr, dwExpectedErr);
    else if (psz = (LPSTR) TestAlloc(cch)) {
        cch = CertGetNameStringA(
            pCertContext,
            dwGetNameStringType,
            dwFlags,
            pvTypePara,
            psz,
            cch);
        printf("  <%s>\n", psz);
    }


CommonReturn:
ErrorReturn:
    CertFreeCertificateContext(pCertContext);
    TestFree(Cert.pbData);
    TestFree(pwsz);
    TestFree(psz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptext\cryptext.cpp ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       cryptext.cpp
//
//  Contents:   Implements
//              1) DllMain, DLLCanUnloadNow, and DLLGetClassObject
//              2) the class factory code
//
// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL,
//		run nmake -f cryptextps.mk in the project directory.
//
//  History:    16-09-1997 xiaohs   created
//
//--------------------------------------------------------------


#include "stdafx.h"
#include <shlobj.h>
#include "initguid.h"
#include "cryptext.h"

#include "cryptext_i.c"

#include "private.h"
#include "CryptPKO.h"
#include "CryptSig.h"

HINSTANCE   g_hmodThisDll = NULL;	// Handle to this DLL itself.


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CryptPKO, CCryptPKO)
	OBJECT_ENTRY(CLSID_CryptSig, CCryptSig)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
        g_hmodThisDll=hInstance;
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr=S_OK;

   	// registers object, typelib and all interfaces in typelib
	if(S_OK !=(hr= _Module.RegisterServer(TRUE)))
        return hr;

    //register the entries for the MIME handler
    return RegisterMimeHandler();
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{

    UnregisterMimeHandler();

   	_Module.UnregisterServer();


	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\txenrol\txenrol.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:	txenrol.cpp
//
//  Contents:	XEnroll C++ Tests
//
//  History:	03-Nov-97	keithv	Created
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "xenroll.h"
#include "unicode.h"

#define SECURITY_WIN32
#include <security.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <malloc.h>

#define NO_OSS_DEBUG
#include <dbgdef.h>

//globals
char *g_pszDNName = NULL;
char *g_pszCAXchgFileName = NULL;
char *g_pszCMCFileName = NULL;
char *g_pszCMCResponseFileName = NULL;
char *g_pszKeyContainer = NULL;
DWORD g_cStress = 1;
DWORD g_dwTestID = MAXDWORD;
BOOL  g_fPause = FALSE;
BOOL  g_fVerb = FALSE;
char *g_pszPKCS7FileName = NULL;
char *g_pszPFXFileName = NULL;
char *g_pszPFXPassword = NULL;

#define TXEnrollLocalScope(ScopeName) struct ScopeName##TheLocalScope { public
#define TXEnrollEndLocalScope } local

#define HASHFROMCERT(a, b) CryptHashCertificate(NULL, 0, X509_ASN_ENCODING, (a)->pbCertEncoded, (a)->cbCertEncoded, (b)->pbData, &(b)->cbData)

#define PRINT_ERROR(Error)              \
Error##:                                 \
    printf("failed => %s, Error = %08x\n", #Error, GetLastError()); \
    goto ERROR_RETURN_LABEL;

#define PRINT_ERROR2(Error, hr)              \
Error##:                                 \
    printf("failed => %s, Error = 0x%08x\n", #Error, (hr)); \
    goto ERROR_RETURN_LABEL;

#define PRINT_ERROR_IF(Error, hr, condition) \
Error##: \
    { \
        if (condition) { \
            printf("failed => %s, Error = 0x%08x\n", #Error, (hr)); \
        } \
        goto ERROR_RETURN_LABEL; \
    }

static BOOL B64EncodeBlob(PCRYPT_DATA_BLOB pBlob, PCRYPT_DATA_BLOB pBlobB64) {

    DWORD   cchBlob     = 0;
    DWORD   err         = ERROR_SUCCESS;

    assert(pBlobB64 != NULL  &&  pBlob != NULL);
    memset(pBlobB64, 0, sizeof(CRYPT_DATA_BLOB));

    // base64 encode the cert
    if (CryptBinaryToStringW(
            pBlob->pbData,
            pBlob->cbData,
            CRYPT_STRING_BASE64,
            NULL,
            &cchBlob))
    {
        pBlobB64->pbData = (PBYTE) malloc(cchBlob * sizeof(WCHAR));
        
        if(pBlobB64->pbData == NULL)
            err = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        err = GetLastError();
        assert(ERROR_SUCCESS != err);
    }

    if(err == ERROR_SUCCESS) {
        if (!CryptBinaryToStringW(
            pBlob->pbData,
            pBlob->cbData,
            CRYPT_STRING_BASE64,
            (LPWSTR) pBlobB64->pbData,
            &cchBlob))
        {
            err = GetLastError();
            assert(ERROR_SUCCESS != err);
        }
    }

    if(err != ERROR_SUCCESS) {
        SetLastError(err);
        memset(pBlobB64, 0, sizeof(CRYPT_DATA_BLOB));
        return(FALSE);
    }

    pBlobB64->cbData = cchBlob * sizeof(WCHAR);
    return(TRUE);

}

static BOOL BSTREncodeBlob(PCRYPT_DATA_BLOB pBlob, BSTR * pbstr) {

    CRYPT_DATA_BLOB blob64;
    BOOL            fRet    = TRUE;
    
    assert(pbstr != NULL);
    memset(&blob64, 0, sizeof(CRYPT_DATA_BLOB));

    if( !B64EncodeBlob(pBlob, &blob64) )
        return(FALSE);
        
    if( NULL == (*pbstr = SysAllocStringByteLen((LPCSTR) blob64.pbData, blob64.cbData)) )
        fRet = FALSE;

    if(blob64.pbData != NULL)
        free(blob64.pbData);

    return(fRet);
}


static HRESULT GetCertificateContextPropertySimple(IN  PCCERT_CONTEXT    pCertContext, 
						   IN  DWORD             dwPropID,
						   OUT PCRYPT_DATA_BLOB  dataBlob)
{
    BOOL fDone = FALSE;
    dataBlob->pbData = NULL; 
    dataBlob->cbData = 0x150; 
    
    do { 
	if (dataBlob->pbData != NULL) { LocalFree(dataBlob->pbData); } 
	
	dataBlob->pbData = (LPBYTE)LocalAlloc(LPTR, dataBlob->cbData);
	if (dataBlob->pbData == NULL) { return E_OUTOFMEMORY; } 
	
	if (!CertGetCertificateContextProperty
	    (pCertContext, 
	     dwPropID, 
	     (LPVOID)dataBlob->pbData, 
	     &(dataBlob->cbData)))
	{
	    if (GetLastError() != ERROR_MORE_DATA)
		return HRESULT_FROM_WIN32(GetLastError());
	}
	else 
	{
	    fDone = TRUE;
	}
    } while (!fDone); 
    
    return S_OK;
}


static HRESULT ResyncIEnrollRequestStore(IN OUT IEnroll4 **ppIEnroll4)
{
    CRYPT_DATA_BLOB  hashBlob; 
    HRESULT          hr; 

    ZeroMemory(&hashBlob,   sizeof(hashBlob)); 
 
   
    // Get the thumbprint of the created request. 
    if (S_OK != (hr = (*ppIEnroll4)->get_ThumbPrintWStr(&hashBlob)))
	goto get_ThumbPrintWStrError; 
    
    hashBlob.pbData = (LPBYTE)LocalAlloc(LPTR, hashBlob.cbData); 
    if (NULL == hashBlob.pbData)
	goto MemoryError; 
    
    if (S_OK != (hr = (*ppIEnroll4)->get_ThumbPrintWStr(&hashBlob)))
	goto get_ThumbPrintWStrError; 
 
    (*ppIEnroll4)->Release(); 

    if (NULL == (*ppIEnroll4 = PIEnroll4GetNoCOM()))
        goto PIEnroll4GetNoCOMError;

    if (S_OK != (hr = (*ppIEnroll4)->put_ThumbPrintWStr(hashBlob)))
        goto put_ThumbPrintWStrError; 

    hr = S_OK; 
 ErrorReturn:
    return hr; 

TRACE_ERROR(get_ThumbPrintWStrError); 
SET_HRESULT(MemoryError,              E_OUTOFMEMORY); 
SET_HRESULT(PIEnroll4GetNoCOMError,   HRESULT_FROM_WIN32(GetLastError())); 
TRACE_ERROR(put_ThumbPrintWStrError); 
}

static HRESULT FindPendingRequest(IN  IEnroll4         *pIEnroll4,
				  IN  PCCERT_CONTEXT    pCertContext, 
                                  IN  HRESULT           hrExpected, 
				  OUT LONG             *plIndex)
{
    CRYPT_DATA_BLOB hashBlob; 
    CRYPT_DATA_BLOB hashBlobExpected; 
    HRESULT         hr; 
    LONG            lIndex; 

    ZeroMemory(&hashBlob,         sizeof(hashBlob)); 
    ZeroMemory(&hashBlobExpected, sizeof(hashBlobExpected)); 
    
    if (NULL == pIEnroll4 || NULL == pCertContext || NULL == plIndex)
	goto InvalidArgError; 

    if (S_OK != (hr = GetCertificateContextPropertySimple
		 (pCertContext, 
		  CERT_HASH_PROP_ID, 
		  &hashBlobExpected))) 
        goto GetCertificateContextPropertySimpleError; 

    // Initialize the enumeration. 
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(XEPR_ENUM_FIRST, 0, NULL)))
        goto enumPendingRequestWStrError1; 

    for (lIndex = 0; TRUE; lIndex++)
    {
	hashBlob.pbData = NULL; 
	hashBlob.cbData = 0; 
	
	if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr
		     (lIndex, 
		      XEPR_HASH, 
		      (LPVOID)&hashBlob)))
	    goto enumPendingRequestWStrError2; 
	
	hashBlob.pbData = (LPBYTE)LocalAlloc(LPTR, hashBlob.cbData);
	if (NULL == hashBlob.pbData)
	    goto MemoryError; 
	
	if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr
		     (lIndex, 
		      XEPR_HASH, 
		      (LPVOID)&hashBlob)))
	    goto enumPendingRequestWStrError3; 

	// We've found the request we want. 
	if ((hashBlobExpected.cbData == hashBlob.cbData) &&
	    (0                       == memcmp(hashBlobExpected.pbData, hashBlob.pbData, hashBlob.cbData)))
	    break; 
    }

    // Success:  assign the OUT param. 
    *plIndex = lIndex; 
    hr = S_OK; 

 CommonReturn:
    if (NULL != hashBlob.pbData) { LocalFree(hashBlob.pbData); } 
    return hr; 

 ErrorReturn:
    goto CommonReturn; 

PRINT_ERROR_IF(enumPendingRequestWStrError1,              hr, (hrExpected != hr));
PRINT_ERROR_IF(enumPendingRequestWStrError2,              hr, (hrExpected != hr));
PRINT_ERROR_IF(enumPendingRequestWStrError3,              hr, (hrExpected != hr));
PRINT_ERROR_IF(GetCertificateContextPropertySimpleError,  hr, (hrExpected != hr)); 
PRINT_ERROR2(InvalidArgError,                             hr = E_INVALIDARG);
PRINT_ERROR2(MemoryError,                                 hr = E_OUTOFMEMORY); 
}

static PCCERT_CONTEXT GetCertOutOfStore(PCRYPT_DATA_BLOB pBlobRequest, DWORD dwStoreFlags, LPWSTR pwszStoreName)
{

    HCERTSTORE          hStoreRequest       = NULL;
    PCERT_REQUEST_INFO  pReqInfo            = NULL;
    PCCERT_CONTEXT      pCertContextRequest = NULL;
   
    if( !CryptQueryObject(CERT_QUERY_OBJECT_BLOB,
                       pBlobRequest,
                       CERT_QUERY_CONTENT_FLAG_PKCS10,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       CRYPT_DECODE_ALLOC_FLAG,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       (const void **) &pReqInfo) )
        goto ErrorCryptQueryObject;

    if( NULL == (hStoreRequest = CertOpenStore(
                CERT_STORE_PROV_SYSTEM,
                X509_ASN_ENCODING,
                NULL,
                dwStoreFlags | CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG, 
                pwszStoreName)) )
        goto ErrorOpenRequestStore;

    // Now get this out of the request store
    if( NULL == (pCertContextRequest = CertFindCertificateInStore(
        hStoreRequest,
        CRYPT_ASN_ENCODING,
        0,
        CERT_FIND_PUBLIC_KEY,
        (void *) &pReqInfo->SubjectPublicKeyInfo,
        NULL)) )
        goto ErrorCertGetRequestCert;

CommonReturn:

    if(hStoreRequest != NULL)
        CertCloseStore(hStoreRequest, 0);
        
    if(pReqInfo != NULL)
        LocalFree(pReqInfo);

    return(pCertContextRequest);

ErrorReturn:

    if(pCertContextRequest != NULL)
        CertFreeCertificateContext(pCertContextRequest);
    pCertContextRequest = NULL;        
 
    goto CommonReturn;
    
PRINT_ERROR(ErrorCryptQueryObject);
PRINT_ERROR(ErrorOpenRequestStore);
PRINT_ERROR(ErrorCertGetRequestCert);
}

static PCCERT_CONTEXT GetCertOutOfRequestStoreMachine(PCRYPT_DATA_BLOB pBlobRequest) {
    return GetCertOutOfStore
	(pBlobRequest, 
	 CERT_SYSTEM_STORE_LOCAL_MACHINE, 
	 L"REQUEST"); 
}

static PCCERT_CONTEXT GetCertOutOfRequestStore(PCRYPT_DATA_BLOB pBlobRequest) {
    return GetCertOutOfStore
	(pBlobRequest, 
	 CERT_SYSTEM_STORE_CURRENT_USER, 
	 L"REQUEST"); 
}

// This version assumes the PKCS 10 is within a PKCS 7
static PCCERT_CONTEXT GetCertOutOfRequestStore2(
    PCRYPT_DATA_BLOB pBlob7)
{
    CRYPT_DATA_BLOB Blob10;
    CRYPT_VERIFY_MESSAGE_PARA VerifyPara;
    PCCERT_CONTEXT pCert;

    Blob10.pbData = NULL;
    Blob10.cbData = 0;
    memset(&VerifyPara, 0, sizeof(VerifyPara));
    VerifyPara.cbSize = sizeof(VerifyPara);
    VerifyPara.dwMsgAndCertEncodingType =
        PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;

    if (!CryptVerifyMessageSignature(
            &VerifyPara,
            0,                  // dwSignerIndex
            pBlob7->pbData,
            pBlob7->cbData,
            Blob10.pbData,
            &Blob10.cbData,
            NULL                // ppSignerCert
            ) || 0 == Blob10.cbData)
        goto ErrorCryptVerifyMessageSignature;

    if (NULL == (Blob10.pbData = (PBYTE) _alloca(Blob10.cbData)))
        goto ErrorOutOfMemory;

    if (!CryptVerifyMessageSignature(
            &VerifyPara,
            0,                  // dwSignerIndex
            pBlob7->pbData,
            pBlob7->cbData,
            Blob10.pbData,
            &Blob10.cbData,
            NULL                // ppSignerCert
            ))
        goto ErrorCryptVerifyMessageSignature;

    pCert = GetCertOutOfRequestStore(&Blob10);

CommonReturn:
    return pCert;

ErrorReturn:
    pCert = NULL;
    goto CommonReturn;

PRINT_ERROR(ErrorCryptVerifyMessageSignature);
PRINT_ERROR(ErrorOutOfMemory);
}

static PCRYPT_DATA_BLOB MakePKCS7ResponseEx(
    PCRYPT_DATA_BLOB pBlobRequest,
    PCRYPT_HASH_BLOB pHash,
    BOOL             fUser)
{

    HCERTSTORE          hStorePKCS7         = NULL;
    PCCERT_CONTEXT      pCertContextRequest = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS7          = NULL;

    PCRYPT_KEY_PROV_INFO pKeyProvInfo       = NULL;
    DWORD               cbKeyProvInfo       = 0;
    HCRYPTPROV          hProv               = NULL;
    PCCERT_CONTEXT      pCertContextNew     = NULL;

    CRYPT_DATA_BLOB     blobPKCS7;


    if (fUser)
    {
        pCertContextRequest =  GetCertOutOfRequestStore(pBlobRequest);
    }
    else
    {
        pCertContextRequest =  GetCertOutOfRequestStoreMachine(pBlobRequest);
    }

    if( NULL == pCertContextRequest)
        goto ErrorGetCertOutOfRequestStore;

    // get the prov info off of the cert
    if(
        !CertGetCertificateContextProperty(
            pCertContextRequest,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,
            &cbKeyProvInfo
            )                                                                       ||
        (NULL == (pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) _alloca(cbKeyProvInfo)))   ||
        !CertGetCertificateContextProperty(
            pCertContextRequest,
            CERT_KEY_PROV_INFO_PROP_ID,
            pKeyProvInfo,
            &cbKeyProvInfo
            )  )
        goto ErrorCertGetCertificateContextProperty;

    // get and hProv off of this certificate
    if( !CryptAcquireCertificatePrivateKey(
        pCertContextRequest,
        0,
        NULL,
        &hProv,
        NULL,
        NULL
        ) )
        goto ErrorCryptAcquireCertificatePrivateKey;

    // build a self-signed cert with this key
    if( NULL == (pCertContextNew = CertCreateSelfSignCertificate(
        hProv,          
        &pCertContextRequest->pCertInfo->Subject,
        0,
        pKeyProvInfo,
        &pCertContextRequest->pCertInfo->SignatureAlgorithm,
        NULL,
        NULL,
        NULL
        )) )
        goto ErrorCertCreateSelfSignCertificate;

    // make a pkcs7
    if( NULL == (hStorePKCS7 = CertOpenStore(
                CERT_STORE_PROV_MEMORY,
                X509_ASN_ENCODING,
                NULL,
                0,
                NULL)) )
        goto ErrorOpenPKCS7Store;

    if( !CertAddCertificateContextToStore(
            hStorePKCS7,
            pCertContextNew,
            CERT_STORE_ADD_USE_EXISTING,
            NULL) ) 
        goto ErrorCertAddToPKCS7Store;  

    assert(pHash != NULL);
    if( !HASHFROMCERT(pCertContextNew, pHash))
        goto ErrorHASHFROMCERT;
        
    memset(&blobPKCS7, 0, sizeof(blobPKCS7));
    if(!CertSaveStore(
            hStorePKCS7,
            PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING,
            CERT_STORE_SAVE_AS_PKCS7,
            CERT_STORE_SAVE_TO_MEMORY,
            &blobPKCS7,
            0) )
            goto ErrorCreatePKCS7;

    pBlobPKCS7 = (PCRYPT_DATA_BLOB) malloc(sizeof(CRYPT_DATA_BLOB) + blobPKCS7.cbData);
    if(NULL == pBlobPKCS7) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto OutOfMemory;
    }
    *pBlobPKCS7 = blobPKCS7;
    pBlobPKCS7->pbData = ((PBYTE) pBlobPKCS7) + sizeof(CRYPT_DATA_BLOB);
   
    if( !CertSaveStore(
            hStorePKCS7,
            PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING,
            CERT_STORE_SAVE_AS_PKCS7,
            CERT_STORE_SAVE_TO_MEMORY,
            pBlobPKCS7,
            0)) 
        goto ErrorCreatePKCS7;

CommonReturn:

    if(hStorePKCS7 != NULL)
        CertCloseStore(hStorePKCS7, 0);

    if(pCertContextRequest != NULL)
        CertFreeCertificateContext(pCertContextRequest);
        
    if(pCertContextNew != NULL)
        CertFreeCertificateContext(pCertContextNew);

    if(hProv != NULL)
        CryptReleaseContext(hProv, 0);

    return(pBlobPKCS7);

ErrorReturn:

    if(pBlobPKCS7 != NULL)
        free(pBlobPKCS7);
    pBlobPKCS7 = NULL;

    goto CommonReturn;

PRINT_ERROR(ErrorCertCreateSelfSignCertificate);
PRINT_ERROR(ErrorCertGetCertificateContextProperty);
PRINT_ERROR(ErrorCryptAcquireCertificatePrivateKey);
PRINT_ERROR(ErrorGetCertOutOfRequestStore);
PRINT_ERROR(ErrorOpenPKCS7Store);
PRINT_ERROR(ErrorCertAddToPKCS7Store);
PRINT_ERROR(ErrorCreatePKCS7);
PRINT_ERROR(OutOfMemory);
PRINT_ERROR(ErrorHASHFROMCERT);
}

static PCRYPT_DATA_BLOB MakePKCS7ResponseMachine(
    PCRYPT_DATA_BLOB pBlobRequest,
    PCRYPT_HASH_BLOB pHash)
{
    return MakePKCS7ResponseEx(pBlobRequest, pHash, FALSE);
}

static PCRYPT_DATA_BLOB MakePKCS7Response(
    PCRYPT_DATA_BLOB pBlobRequest,
    PCRYPT_HASH_BLOB pHash)
{
    return MakePKCS7ResponseEx(pBlobRequest, pHash, TRUE);
}

static PCRYPT_DATA_BLOB GetPKCS10FromPKCS7(PCRYPT_DATA_BLOB pPKCS7) {

    CRYPT_VERIFY_MESSAGE_PARA   MsgPara;
    PCCERT_CONTEXT              pCert       = NULL;
    CRYPT_DATA_BLOB             blob;
    PCRYPT_DATA_BLOB            pBlob       = NULL;

    assert(pPKCS7 != NULL);
    memset(&blob, 0, sizeof(CRYPT_DATA_BLOB));

    memset(&MsgPara, 0, sizeof(CRYPT_VERIFY_MESSAGE_PARA));
    MsgPara.cbSize  = sizeof(CRYPT_VERIFY_MESSAGE_PARA);
    MsgPara.dwMsgAndCertEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;

    if( !CryptVerifyMessageSignature(
        &MsgPara,
        0,
        pPKCS7->pbData,
        pPKCS7->cbData,
        NULL,
        &blob.cbData,
        NULL
        ) )
        goto ErrorCryptVerifyMessageSignature;

    if( (pBlob = (PCRYPT_DATA_BLOB) malloc(blob.cbData + sizeof(CRYPT_DATA_BLOB))) == NULL ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto OutOfMemory;
    }
    pBlob->pbData = ((BYTE *) pBlob) + sizeof(CRYPT_DATA_BLOB);
    pBlob->cbData = blob.cbData;
    
    if( !CryptVerifyMessageSignature(
        &MsgPara,
        0,
        pPKCS7->pbData,
        pPKCS7->cbData,
        pBlob->pbData,
        &blob.cbData,
        &pCert
        ) )
        goto ErrorCryptVerifyMessageSignature;

CommonReturn:

    if(pCert != NULL)
        CertFreeCertificateContext(pCert);   
    
    return(pBlob);

ErrorReturn:

    if(pBlob != NULL)
        free(pBlob);
    pBlob = NULL;

    goto CommonReturn;

PRINT_ERROR(ErrorCryptVerifyMessageSignature);
PRINT_ERROR(OutOfMemory);
}

void DeleteCertPrivateKey(PCCERT_CONTEXT pCert) {
    PCRYPT_KEY_PROV_INFO pKeyProvInfo       = NULL;
    DWORD               cbKeyProvInfo       = 0;
    HCRYPTPROV          hProv;

    BYTE                rgbKeyIdHash[20];
    CRYPT_HASH_BLOB     KeyIdentifier;


    // get the prov info off of the cert
    if(
        !CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,
            &cbKeyProvInfo
            )                                                                       ||
        (NULL == (pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) _alloca(cbKeyProvInfo)))   ||
        !CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            pKeyProvInfo,
            &cbKeyProvInfo
            )  )
        goto ErrorCertGetCertificateContextProperty;

    // Note: for CRYPT_DELETEKEYSET, the returned hProv is undefined and
    // must not be released.
    if( !CryptAcquireContextU(&hProv,
         pKeyProvInfo->pwszContainerName,
         pKeyProvInfo->pwszProvName,
         pKeyProvInfo->dwProvType,
         (pKeyProvInfo->dwFlags & ~CERT_SET_KEY_CONTEXT_PROP_ID) |
             CRYPT_DELETEKEYSET) )
        goto ErrorCryptDeleteKeySet;


    // Also delete the private key identifier

    KeyIdentifier.pbData = rgbKeyIdHash;
    KeyIdentifier.cbData = sizeof(rgbKeyIdHash);
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_IDENTIFIER_PROP_ID,
            KeyIdentifier.pbData,
            &KeyIdentifier.cbData
            ))
        goto ErrorCertGetCertificateKeyIdentifierProperty;

    if (!CryptSetKeyIdentifierProperty(
            &KeyIdentifier,
            0,                  // dwPropId
            CRYPT_KEYID_DELETE_FLAG |
                pKeyProvInfo->dwFlags & CRYPT_KEYID_MACHINE_FLAG,
            NULL,               // pwszComputerName
            NULL,               // pvReserved
            NULL                // pvData
            )) {
        DWORD dwErr = GetLastError();
        if (ERROR_FILE_NOT_FOUND != dwErr)
            goto ErrorDeleteKeyIdentifier;
    }

CommonReturn:
    return;

ErrorReturn:
    goto CommonReturn;

PRINT_ERROR(ErrorCertGetCertificateContextProperty)
PRINT_ERROR(ErrorCryptDeleteKeySet)
PRINT_ERROR(ErrorCertGetCertificateKeyIdentifierProperty)
PRINT_ERROR(ErrorDeleteKeyIdentifier)
}

BOOL RemoveCertFromStore(PCRYPT_HASH_BLOB pHash, LPCWSTR wszStore, DWORD dwStoreFlags) {

    BOOL            fRet        = TRUE;
    HCERTSTORE      hStore      =  NULL;
    DWORD           err         = GetLastError();
    PCCERT_CONTEXT  pCert       = NULL;
    
   // open the my store
    if( NULL == (hStore = CertOpenStore(
                CERT_STORE_PROV_SYSTEM,
                X509_ASN_ENCODING,
                NULL,
                dwStoreFlags,
                wszStore)) )
        goto ErrorOpenStore;

    // find the cert by hash
    if( NULL == (pCert = CertFindCertificateInStore(
        hStore,
        X509_ASN_ENCODING,
        0,
        CERT_FIND_HASH,
        pHash,
        NULL ) ))
        goto ErrorCertFindCertificateInStore; 

    // delete the cert's private key
    DeleteCertPrivateKey(pCert);

    //delete the cert
    if( !CertDeleteCertificateFromStore(pCert) ) {
        pCert = NULL;
        goto ErrorCertDeleteCertificateFromStore;
    }
    pCert = NULL;

CommonReturn:

    if(pCert != NULL)
        CertFreeCertificateContext(pCert);
        
    if(hStore != NULL)
        CertCloseStore(hStore, 0);
        
    SetLastError(err);
    return(fRet);

ErrorReturn:

    fRet = FALSE;
    err = GetLastError();
    goto CommonReturn;

PRINT_ERROR(ErrorOpenStore);
PRINT_ERROR(ErrorCertFindCertificateInStore);
PRINT_ERROR(ErrorCertDeleteCertificateFromStore);
}

// Define a struct which will hold the data we need to test with.  
typedef struct _PENDING_INFO { 
    DWORD     dwRequestID; 
    LPWSTR    pwszCADNS; 
    LPWSTR    pwszCAName;
    LPWSTR    pwszFriendlyName; 
    DWORD     dwStoreFlags; 
    LPWSTR    pwszStoreName; 
    HRESULT   hrExpectedResult; 
} PENDING_INFO; 

class TXEnrollPendingAPITester { 
public:
    BOOL TestMethod_enumPendingRequestWStr(IEnroll4        *pIEnroll4,
					   CRYPT_DATA_BLOB  pkcs10Request,
					   PENDING_INFO    *pPendingInfo);

    BOOL TestMethod_removePendingRequestWStr(IEnroll4 *pIEnroll4); 

    BOOL TestMethod_setPendingInfoWStr(IEnroll4         *pIEnroll4,
				       CRYPT_DATA_BLOB   pkcs10Request,
				       PENDING_INFO   *pPendingInfo);

    BOOL TestProperty_ThumbPrintWStr(IEnroll4 *pIEnroll4);

    

};

BOOL TXEnrollPendingAPITester::TestMethod_removePendingRequestWStr(IEnroll4 *pIEnroll4)
{
    BOOL            fResult; 
    CRYPT_DATA_BLOB hashBlob; 
    CRYPT_DATA_BLOB pkcs10Blob; 
    HRESULT         hr; 
    LONG            lIndex; 
    LONG            lRequestID        = 0; 
    PCCERT_CONTEXT  pCertContext      = NULL;
    WCHAR           pwszCADNS[]       = L"duncanb1.ntdev.microsoft.com";
    WCHAR           pwszCAName[]      = L"Test RPR"; 
    WCHAR           pwszFriendlyName[]= L"\0"; 
    WCHAR           wszDNName[]       = L"CN=Xenroll TestMethod_removePendingRequestWStr Test";

    ZeroMemory(&hashBlob,   sizeof(hashBlob)); 
    ZeroMemory(&pkcs10Blob, sizeof(pkcs10Blob)); 

    // 
    // Case 0)  Removal of a request in the REQUEST (normal case). 
    //

    if (S_OK != (hr = pIEnroll4->resetExtensions()))
	goto resetExtensionsError;
    
    if (S_OK != (hr = pIEnroll4->resetAttributes()))
	goto resetAttributesError;
    
    // Small key size so the test runs faster. 
    if (S_OK != (hr = pIEnroll4->put_GenKeyFlags(384 << 16)))
	goto put_GenKeyFlagsError; 
    
    // Create a request to test on. 
    if (S_OK != (hr = pIEnroll4->createRequestWStr
		 (XECR_PKCS10_V2_0,
		  wszDNName, 
                  NULL,
		  &pkcs10Blob)))
	goto createRequestWStrError;

    // Set pending info on the request, so it can be accessed via the pending API: 
    if (S_OK != (hr = pIEnroll4->setPendingRequestInfoWStr
		 (lRequestID, 
		  pwszCADNS,
		  pwszCAName,
		  pwszFriendlyName)))
	goto setPendingRequestInfoWStrError;

    if (S_OK != (hr = ResyncIEnrollRequestStore(&pIEnroll4)))
        goto ResyncIEnrollRequestStoreError; 

    pCertContext = GetCertOutOfRequestStore(&pkcs10Blob);
    if (NULL == pCertContext)
	goto GetCertOutOfRequestStoreError; 

    // Verify that the request is in the REQUEST store: 
    if (S_OK != (hr = FindPendingRequest
		 (pIEnroll4,
		  pCertContext, 
                  S_OK, 
		  &lIndex)))
	goto RequestNotAddedToStoreError; 

    // Get the thumbprint of the created request. 
    if (S_OK != (hr = pIEnroll4->get_ThumbPrintWStr(&hashBlob)))
	goto get_ThumbPrintWStrError; 
    
    hashBlob.pbData = (LPBYTE)LocalAlloc(LPTR, hashBlob.cbData); 
    if (NULL == hashBlob.pbData)
	goto MemoryError; 
    
    if (S_OK != (hr = pIEnroll4->get_ThumbPrintWStr(&hashBlob)))
	goto get_ThumbPrintWStrError; 

    // Remove the request from the request store: 
    if (S_OK != (hr = pIEnroll4->removePendingRequestWStr(hashBlob)))
	goto removePendingRequestWStrError; 

    // Verify that it is actually gone: 
    if (HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND) != (hr = FindPendingRequest
						  (pIEnroll4, 
						   pCertContext, 
                                                   HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND), 
						   &lIndex)))
    {
        if (!FAILED(hr))
            hr = E_FAIL; 
	goto PendingRequestNotRemovedError; 
    }

    // No need to delete the request, the pending API has already done this. 
    pkcs10Blob.pbData = NULL; 

    // 
    // Case 1) invalid arg: 
    // 

    { 
	CRYPT_DATA_BLOB invalidBlob; 

	ZeroMemory(&invalidBlob, sizeof(invalidBlob));
	if (E_INVALIDARG != (hr = pIEnroll4->removePendingRequestWStr(invalidBlob)))
	    goto removePendingRequestWStrError; 
    }

    // 
    // Case 2) cert not found: 
    // 

    if (HRESULT_FROM_WIN32(CRYPT_E_NOT_FOUND) != (hr = pIEnroll4->removePendingRequestWStr
						  (hashBlob)))
    {
        if (!FAILED(hr)) 
            hr = E_FAIL; 
	goto removePendingRequestWStrError; 
    }


    fResult = TRUE; 

 CommonReturn:
    if (NULL != pkcs10Blob.pbData) 
    { 
        pCertContext = GetCertOutOfRequestStore(&pkcs10Blob);
        if (NULL != pCertContext) 
        {
            CertDeleteCertificateFromStore(pCertContext);           
        }
            
        LocalFree(pkcs10Blob.pbData); 
    } 
    if (NULL != hashBlob.pbData)   { LocalFree(hashBlob.pbData); } 

    return fResult; 

 ErrorReturn:
    SetLastError(hr);
    fResult = FALSE;
    goto CommonReturn; 

PRINT_ERROR2(createRequestWStrError,         hr); 
PRINT_ERROR2(get_ThumbPrintWStrError,        hr); 
PRINT_ERROR2(GetCertOutOfRequestStoreError,  hr = GetLastError());
PRINT_ERROR2(MemoryError,                    hr = E_OUTOFMEMORY);
PRINT_ERROR2(PendingRequestNotRemovedError,  hr); 
PRINT_ERROR2(put_GenKeyFlagsError,           hr); 
PRINT_ERROR2(RequestNotAddedToStoreError,    hr); 
PRINT_ERROR2(removePendingRequestWStrError,  hr); 
PRINT_ERROR2(resetExtensionsError,           hr);
PRINT_ERROR2(resetAttributesError,           hr);
PRINT_ERROR2(ResyncIEnrollRequestStoreError, hr); 
PRINT_ERROR2(setPendingRequestInfoWStrError, hr);
}

BOOL TXEnrollPendingAPITester::TestProperty_ThumbPrintWStr(IEnroll4 *pIEnroll4)
{
    DWORD const       dw_NUM_CASES = 3; 

    BOOL              fResult; 
    CRYPT_DATA_BLOB   hashBlobs         [dw_NUM_CASES]; 
    CRYPT_DATA_BLOB   hashBlobsExpected [dw_NUM_CASES]; 
    CRYPT_DATA_BLOB   pkcs10Blobs       [dw_NUM_CASES];
    DWORD             dwCase; 
    DWORD             dwRequestIDExpected; 
    HRESULT           hr                    = S_OK; 
    LONG              lIndex; 
    PCCERT_CONTEXT    pCertContexts     [dw_NUM_CASES]; 
    
    WCHAR             wszDNName[]      = L"CN=Xenroll TestProperty_ThumbPrintWStr Test";

    PENDING_INFO      pendingInfo = 
    { 100, L"duncanb.ntdev.microsoft.com", L"ThumbPrint Test", L"TT Test", 0, NULL, S_OK }; 

    ZeroMemory(&hashBlobs[0],         sizeof(hashBlobs)); 
    ZeroMemory(&hashBlobsExpected[0], sizeof(hashBlobsExpected));
    ZeroMemory(&pkcs10Blobs[0],       sizeof(pkcs10Blobs)); 
    ZeroMemory(&pCertContexts[0],     sizeof(pCertContexts)); 

    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //
    // Declare locally-scoped helper functions:
    //
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    TXEnrollLocalScope(TestProperty_ThumbPrintWStrHelper):
	HRESULT GetThumbPrintAndCertContext(IN   IEnroll4        *pIEnroll4,  
					    IN   CRYPT_DATA_BLOB  pkcs10Request, 
					    OUT  PCRYPT_DATA_BLOB pThumbPrintBlob, 
					    OUT  PCCERT_CONTEXT  *ppCertContext)
	{
	    HRESULT hr; 

	    pThumbPrintBlob->pbData = NULL; 
	    *ppCertContext = NULL;

	    *ppCertContext = GetCertOutOfRequestStore(&pkcs10Request); 
	    if (NULL == *ppCertContext)
		goto GetCertOutOfRequestStoreError; 

	    // Use get_ThumbPrintWStr to get the hash of the request.
	    if (S_OK != (hr = pIEnroll4->get_ThumbPrintWStr(pThumbPrintBlob)))
		goto get_ThumbPrintWStrError; 
	    
	    pThumbPrintBlob->pbData = (LPBYTE)LocalAlloc(LPTR, pThumbPrintBlob->cbData); 
	    if (NULL == pThumbPrintBlob->pbData)
		goto MemoryError; 

	    if (S_OK != (hr = pIEnroll4->get_ThumbPrintWStr(pThumbPrintBlob)))
		goto get_ThumbPrintWStrError; 

	    hr = S_OK; 

	CommonReturn:
	    return hr; 
	    
	ErrorReturn: 
	    if (NULL != pThumbPrintBlob->pbData) { LocalFree(pThumbPrintBlob->pbData); } 
	    if (NULL != *ppCertContext)          { CertDeleteCertificateFromStore(*ppCertContext); } 

	    pThumbPrintBlob->pbData = NULL;
	    *ppCertContext          = NULL; 
	    goto CommonReturn; 

	    PRINT_ERROR2(get_ThumbPrintWStrError,       hr); 
	    PRINT_ERROR2(GetCertOutOfRequestStoreError, hr = GetLastError()); 
	    PRINT_ERROR2(MemoryError,                   hr = E_OUTOFMEMORY);
	}

    TXEnrollEndLocalScope;

    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //
    // Case 0:  Check that thumbprint returned is the hash of the last created cert.  
    //
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    dwCase = 0; 

    if (S_OK != (hr = pIEnroll4->resetExtensions()))
	goto resetExtensionsError;
    
    if (S_OK != (hr = pIEnroll4->resetAttributes()))
	goto resetAttributesError;
    
    // Small key size so the test runs faster. 
    if (S_OK != (hr = pIEnroll4->put_GenKeyFlags(384 << 16)))
	goto put_GenKeyFlagsError; 
    
    // Create a request to test on. 
    if (S_OK != (hr = pIEnroll4->createRequestWStr
		 (XECR_PKCS10_V2_0,
		  wszDNName, 
                  NULL,
		  &pkcs10Blobs[dwCase])))
	goto createRequestWStrError;
    
    // Make sure xenroll syncs up its request store!
    if (S_OK != (hr = ResyncIEnrollRequestStore(&pIEnroll4)))
        goto ResyncIEnrollRequestStoreError;   

    // Get a PCCERT_CONTEXT and thumbprint from the request: 
    if (S_OK != (hr = local.GetThumbPrintAndCertContext
		 (pIEnroll4, 
		  pkcs10Blobs[dwCase], 
		  &hashBlobs[dwCase], 
		  &pCertContexts[dwCase])))
	goto GetThumbPrintAndCertContextError; 

    // Manually get the HASH of the request. 
    if (S_OK != (hr = GetCertificateContextPropertySimple
		 (pCertContexts[dwCase], 
		  CERT_HASH_PROP_ID, 
		  &hashBlobsExpected[dwCase])))
	goto GetCertificateContextPropertySimpleError; 


    if (!
	((hashBlobs[dwCase].cbData == hashBlobsExpected[dwCase].cbData) &&
	 (0                        == memcmp(hashBlobs[dwCase].pbData, hashBlobsExpected[dwCase].pbData, hashBlobs[dwCase].cbData))))
	goto get_ThumbPrintWStrError; 


    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //
    // Case 1:  Make sure that put_ThumbPrintWStr is used as the target of setPendingInfoWStr().
    // 
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    dwCase++; 

    // Flush the first request from the pending cache.  
    //
    if (S_OK != (hr = pIEnroll4->createRequestWStr
		 (XECR_PKCS10_V2_0,
		  wszDNName,
                  NULL,
		  &pkcs10Blobs[dwCase])))
	goto createRequestWStrError;

    // Make sure xenroll syncs up its request store!
    if (S_OK != (hr = ResyncIEnrollRequestStore(&pIEnroll4)))
        goto ResyncIEnrollRequestStoreError;   

    // Get a PCCERT_CONTEXT and thumbprint from the request: 
    if (S_OK != (hr = local.GetThumbPrintAndCertContext
		 (pIEnroll4, 
		  pkcs10Blobs[dwCase], 
		  &hashBlobs[dwCase], 
		  &pCertContexts[dwCase])))
	goto GetThumbPrintAndCertContextError; 

    // Manually specify the previous request through put_ThumbPrint: 
    if (S_OK != (hr = pIEnroll4->put_ThumbPrintWStr(hashBlobs[dwCase-1])))
	goto put_ThumbPrintWStrError; 

    if (S_OK != (hr = pIEnroll4->setPendingRequestInfoWStr
		 (pendingInfo.dwRequestID, 
		  pendingInfo.pwszCADNS,
		  pendingInfo.pwszCAName, 
		  pendingInfo.pwszFriendlyName)))
	goto setPendingRequestInfoWStrError; 

    if (S_OK != (hr = FindPendingRequest(pIEnroll4, pCertContexts[dwCase-1], S_OK, &lIndex)))
	goto FindPendingRequestError; 
    
    // Success -- if put_ThumbPrintWstr was not working correctly, it would not be possible
    // to find pending info associated with the previous cert context.  

    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //
    // Case 2:  Make sure that put_ThumbPrintWStr is used as the target of get_ThumbPrintWStr
    // 
    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    dwCase++; 

    // Flush the previous request from the pending cache.  
    //
    if (S_OK != (hr = pIEnroll4->createRequestWStr
		 (XECR_PKCS10_V2_0,
		  wszDNName,
          NULL,
		  &pkcs10Blobs[dwCase])))
	goto createRequestWStrError;

    // Make sure xenroll syncs up its request store!
    if (S_OK != (hr = ResyncIEnrollRequestStore(&pIEnroll4)))
        goto ResyncIEnrollRequestStoreError;   

    pCertContexts[dwCase] = GetCertOutOfRequestStore(&pkcs10Blobs[dwCase]); 
    if (NULL == pCertContexts[dwCase])
	goto GetCertOutOfRequestStoreError; 

    // Manually specify a request through put_ThumbPrint: 
    //
    if (S_OK != (hr = pIEnroll4->put_ThumbPrintWStr(hashBlobs[dwCase-1])))
	goto put_ThumbPrintWStrError; 
   
    // Extract the request through get_ThumbPrintWStr: 
    //
    if (S_OK != (hr = pIEnroll4->get_ThumbPrintWStr(&hashBlobs[dwCase])))
	goto put_ThumbPrintWStrError; 

    hashBlobs[dwCase].pbData = (LPBYTE)LocalAlloc(LPTR, hashBlobs[dwCase].cbData); 
    if (NULL == hashBlobs[dwCase].pbData)
	goto MemoryError; 

    if (S_OK != (hr = pIEnroll4->get_ThumbPrintWStr(&hashBlobs[dwCase])))
	goto put_ThumbPrintWStrError; 

    if (!
	((hashBlobs[dwCase].cbData == hashBlobs[dwCase-1].cbData) &&
	 (0                        == memcmp(hashBlobs[dwCase].pbData, hashBlobs[dwCase-1].pbData, hashBlobs[dwCase].cbData))))
	goto get_ThumbPrintWStrError; 
    

    fResult = TRUE; 

 CommonReturn:
    if (NULL != pIEnroll4) { pIEnroll4->Release(); }

    for (dwCase = 0; dwCase < dw_NUM_CASES; dwCase++)
    {
	if (NULL != pkcs10Blobs[dwCase].pbData)        { LocalFree(pkcs10Blobs[dwCase].pbData); } 
	if (NULL != hashBlobs[dwCase].pbData)          { LocalFree(hashBlobs[dwCase].pbData); } 
	if (NULL != hashBlobsExpected[dwCase].pbData)  { LocalFree(hashBlobsExpected[dwCase].pbData); } 
	if (NULL != pCertContexts[dwCase])             { CertDeleteCertificateFromStore(pCertContexts[dwCase]); }
    }

    return fResult; 

 ErrorReturn:
    fResult = FALSE;
    SetLastError(hr); 
    goto CommonReturn; 

PRINT_ERROR2(createRequestWStrError, hr); 
PRINT_ERROR2(FindPendingRequestError, hr); 
PRINT_ERROR2(get_ThumbPrintWStrError, hr); 
PRINT_ERROR(GetCertOutOfRequestStoreError); 
PRINT_ERROR2(GetCertificateContextPropertySimpleError, hr);
PRINT_ERROR2(GetThumbPrintAndCertContextError, hr);
PRINT_ERROR2(MemoryError, E_OUTOFMEMORY); 
PRINT_ERROR2(put_GenKeyFlagsError, hr); 
PRINT_ERROR2(put_ThumbPrintWStrError, hr); 
PRINT_ERROR2(resetAttributesError, hr);
PRINT_ERROR2(resetExtensionsError, hr); 
PRINT_ERROR2(ResyncIEnrollRequestStoreError, hr); 
PRINT_ERROR2(setPendingRequestInfoWStrError, hr); 
}
BOOL TXEnrollPendingAPITester::TestMethod_enumPendingRequestWStr(IEnroll4        *pIEnroll4,
								 CRYPT_DATA_BLOB  pkcs10Blob, 
								 PENDING_INFO    *pPendingInfo)
{
    BOOL              fResult; 
    CRYPT_DATA_BLOB   caDNSBlob; 
    CRYPT_DATA_BLOB   caNameBlob; 
    CRYPT_DATA_BLOB   friendlyNameBlob; 
    CRYPT_DATA_BLOB   hashBlob; 
    CRYPT_DATA_BLOB   hashBlobExpected; 
    CRYPT_DATA_BLOB   v1TemplateNameBlob; 
    DWORD             dwRequestID; 
    FILETIME          ftDate; 
    FILETIME          ftDateExpected; 
    HRESULT           hr = S_OK; 
    LONG              lIndex; 
    PCCERT_CONTEXT    pCertContext = NULL; 

    // Init:
    ZeroMemory(&caDNSBlob,          sizeof(CRYPT_DATA_BLOB)); 
    ZeroMemory(&caNameBlob,         sizeof(CRYPT_DATA_BLOB)); 
    ZeroMemory(&friendlyNameBlob,   sizeof(CRYPT_DATA_BLOB)); 
    ZeroMemory(&hashBlob,           sizeof(CRYPT_DATA_BLOB)); 
    ZeroMemory(&hashBlobExpected,   sizeof(CRYPT_DATA_BLOB)); 
    ZeroMemory(&v1TemplateNameBlob, sizeof(CRYPT_DATA_BLOB)); 

    if (NULL == pIEnroll4 || NULL == pPendingInfo)
	goto InvalidArgError; 
    
    pCertContext = GetCertOutOfStore(&pkcs10Blob, pPendingInfo->dwStoreFlags, pPendingInfo->pwszStoreName); 
    if (NULL == pCertContext)
	goto GetCertOutOfStoreError; 
    
    if (S_OK != (hr = GetCertificateContextPropertySimple
		 (pCertContext, 
		  CERT_HASH_PROP_ID, 
		  &hashBlobExpected)))
	goto GetCertificateContextPropertySimpleError; 
    
    // Initialize the enumeration.  
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(XEPR_ENUM_FIRST, 0, NULL)))
	goto enumPendingRequestWStrError; 

    for (lIndex = 0; TRUE; lIndex++) // Find the index of the pending request in the request store: 
    {
	hashBlob.pbData = NULL; 
	hashBlob.cbData = 0; 
	
	if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr
		     (lIndex, 
		      XEPR_HASH, 
		      (LPVOID)&hashBlob)))
	    goto enumPendingRequestWStrError; 
	
	hashBlob.pbData = (LPBYTE)LocalAlloc(LPTR, hashBlob.cbData);
	if (NULL == hashBlob.pbData)
	    goto MemoryError; 
	
	if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr
		     (lIndex, 
		      XEPR_HASH, 
		      (LPVOID)&hashBlob)))
	    goto enumPendingRequestWStrError; 
	
	// We've found the request we want. 
	if ((hashBlobExpected.cbData == hashBlob.cbData) &&
	    (0                       == memcmp(hashBlobExpected.pbData, hashBlob.pbData, hashBlob.cbData)))
	    break; 
    }
    
    // Test XEPR_REQUESTID property: 
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_REQUESTID, (LPVOID)&dwRequestID)))
	goto enumPendingRequestWStrError;                     
    
    if (dwRequestID != pPendingInfo->dwRequestID)
	goto pendingInfoDoesntMatchError; 

    // Test XEPR_CANAME property: 
    caNameBlob.pbData = NULL; 
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_CANAME, (LPVOID)&caNameBlob)))
	goto enumPendingRequestWStrError;                     

    caNameBlob.pbData = (LPBYTE)LocalAlloc(LPTR, caNameBlob.cbData);
    if (NULL == caNameBlob.pbData)
	goto MemoryError; 
    
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_CANAME, (LPVOID)&caNameBlob)))
	goto enumPendingRequestWStrError;                     
    
    if (0 != wcscmp((LPWSTR)caNameBlob.pbData, pPendingInfo->pwszCAName))
	goto enumPendingRequestWStrError;                     

    // Test XEPR_CADNS property: 
    caDNSBlob.pbData = NULL; 
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_CADNS, (LPVOID)&caDNSBlob)))
	goto enumPendingRequestWStrError;                     
    
    caDNSBlob.pbData = (LPBYTE)LocalAlloc(LPTR, caDNSBlob.cbData);
    if (NULL == caDNSBlob.pbData)
	goto MemoryError; 
    
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_CADNS, (LPVOID)&caDNSBlob)))
	goto enumPendingRequestWStrError;                     
    
    if (0 != wcscmp((LPWSTR)caDNSBlob.pbData, pPendingInfo->pwszCADNS))
	goto enumPendingRequestWStrError;                     
    
    // Test XEPR_CAFRIENDLYNAME property: 

    // Note: it is legal to pass NULL when setting the friendly name property.  In this case, 
    //       the friendly name property is set to the empty string. 
    if (NULL == pPendingInfo->pwszFriendlyName) { pPendingInfo->pwszFriendlyName = L""; } 

    friendlyNameBlob.pbData = NULL; 
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_CAFRIENDLYNAME, (LPVOID)&friendlyNameBlob)))
	goto enumPendingRequestWStrError;                     
    
    friendlyNameBlob.pbData = (LPBYTE)LocalAlloc(LPTR, friendlyNameBlob.cbData);
    if (NULL == friendlyNameBlob.pbData)
	goto MemoryError; 
    
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_CAFRIENDLYNAME, (LPVOID)&friendlyNameBlob)))
	goto enumPendingRequestWStrError;                     
    
    if (0 != wcscmp((LPWSTR)friendlyNameBlob.pbData, pPendingInfo->pwszFriendlyName))
	goto enumPendingRequestWStrError;                     
    
    // Test XEPR_V1TEMPLATENAME property: 
    
#if 0
    v1TemplateNameBlob.pbData = NULL; 
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_V1TEMPLATENAME, (LPVOID)&v1TemplateNameBlob)))
	goto enumPendingRequestWStrError;                     

    v1TemplateNameBlob.pbData = (LPBYTE)LocalAlloc(LPTR, v1TemplateNameBlob.cbData);
    if (NULL == v1TemplateNameBlob.pbData)
	goto ErrorReturn; 
	    
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_V1TEMPLATENAME, (LPVOID)&v1TemplateNameBlob)))
	goto enumPendingRequestWStrError;                     

    if (0 != wcscmp(pwszV1TemplateNameExpected, (LPWSTR)v1TemplateNameBlob.pbData))
	goto enumPendingRequestWStrError;                     
#endif
    // Test XEPR_DATE property: 
    if (S_OK != (hr = pIEnroll4->enumPendingRequestWStr(lIndex, XEPR_DATE, (LPVOID)&ftDate)))
	goto enumPendingRequestWStrError;                     
	    
    ftDateExpected = pCertContext->pCertInfo->NotAfter; 
    if (0 != memcmp((LPVOID)&ftDateExpected, (LPVOID)&ftDate, sizeof(FILETIME)))
	goto enumPendingRequestWStrError; 

    // Test XEPR_V2TEMPLATEOID property:

    // XEPR_V2TEMPLATEOID property not yet impl. 
    
    // Test XEPR_VERSION property: 
    
    // XEPR_VERSION property not yet impl. 
    
    fResult = TRUE; 

 CommonReturn: 
    if (NULL != caDNSBlob.pbData)           { LocalFree(caDNSBlob.pbData); } 
    if (NULL != caNameBlob.pbData)          { LocalFree(caNameBlob.pbData); } 
    if (NULL != friendlyNameBlob.pbData)    { LocalFree(friendlyNameBlob.pbData); } 
    if (NULL != hashBlob.pbData)            { LocalFree(hashBlob.pbData); } 
    if (NULL != v1TemplateNameBlob.pbData)  { LocalFree(v1TemplateNameBlob.pbData); } 
    if (NULL != pCertContext)               { CertFreeCertificateContext(pCertContext); } 
    return fResult; 

 ErrorReturn: 
    fResult = FALSE; 
    SetLastError(hr); 
    goto CommonReturn;  

PRINT_ERROR2(enumPendingRequestWStrError, hr); 
PRINT_ERROR2(GetCertificateContextPropertySimpleError, hr); 
PRINT_ERROR2(GetCertOutOfStoreError, hr = GetLastError());
PRINT_ERROR2(InvalidArgError, hr = E_INVALIDARG); 
PRINT_ERROR2(MemoryError, hr = E_OUTOFMEMORY); 
PRINT_ERROR2(pendingInfoDoesntMatchError, hr = E_FAIL);
}

BOOL TXEnrollPendingAPITester::TestMethod_setPendingInfoWStr(IEnroll4        *pIEnroll4,
							     CRYPT_DATA_BLOB  pkcs10Blob, 
							     PENDING_INFO    *pPendingInfo)
{
    BOOL             fResult; 
    CRYPT_DATA_BLOB  dataBlob; 
    DWORD            dwSize; 
    LPBYTE           pbPendingInfo; 
    HRESULT          hr = S_OK; 
    PCCERT_CONTEXT   pCertContext       = NULL;
    WCHAR            wszDNNName[]       = L"CN=Xenroll setPendingInfoWStr Test 1";

    ZeroMemory(&dataBlob, sizeof(dataBlob)); 

    if (NULL == pIEnroll4 || NULL == pPendingInfo)
	goto InvalidArgError; 
	    
    hr = pIEnroll4->setPendingRequestInfoWStr
	(pPendingInfo->dwRequestID, 
	 pPendingInfo->pwszCADNS,
	 pPendingInfo->pwszCAName, 
	 pPendingInfo->pwszFriendlyName);
    
    if (hr != pPendingInfo->hrExpectedResult)
	goto setPendingRequestInfoWStrError;

    if (hr != S_OK) 
    { 
	// This test was supposed to fail.  
	fResult = TRUE; 
	goto CommonReturn; 
    }

    pCertContext = GetCertOutOfStore(&pkcs10Blob, pPendingInfo->dwStoreFlags, pPendingInfo->pwszStoreName); 
    if (NULL == pCertContext)
	goto GetCertOutOfStoreError; 

    if (!CertGetCertificateContextProperty
	(pCertContext, 
	 CERT_ENROLLMENT_PROP_ID, 
	 NULL, 
	 &(dataBlob.cbData)))
	goto CertGetCertificateContextPropertyError; 
    
    dataBlob.pbData = (LPBYTE)LocalAlloc(LPTR, dataBlob.cbData);
    if (NULL == dataBlob.pbData)
	goto MemoryError; 
	
    if (!CertGetCertificateContextProperty
	(pCertContext, 
	 CERT_ENROLLMENT_PROP_ID, 
	 dataBlob.pbData, 
	 &(dataBlob.cbData)))
	goto CertGetCertificateContextPropertyError; 
    
    // Is request ID set correctly?
    pbPendingInfo = dataBlob.pbData; 
    if (0 != memcmp(pbPendingInfo, &pPendingInfo->dwRequestID, sizeof(DWORD))) 
        goto setPendingRequestInfoWStrError; 
    pbPendingInfo += sizeof(DWORD); 
 
    // Is CADNS set correctly?
    dwSize = wcslen(pPendingInfo->pwszCADNS) + 1; 
    if (0 != memcmp(pbPendingInfo, &dwSize, sizeof(DWORD)))
        goto setPendingRequestInfoWStrError; 
    pbPendingInfo += sizeof(DWORD); 

    if (0 != memcmp(pbPendingInfo, pPendingInfo->pwszCADNS, sizeof(WCHAR) * dwSize))
        goto setPendingRequestInfoWStrError; 
    pbPendingInfo += sizeof(WCHAR) * dwSize; 

    // Is CAName set correctly?
    dwSize = wcslen(pPendingInfo->pwszCAName) + 1; 
    if (0 != memcmp(pbPendingInfo, &dwSize, sizeof(DWORD)))
        goto setPendingRequestInfoWStrError; 
    pbPendingInfo += sizeof(DWORD); 

    if (0 != memcmp(pbPendingInfo, pPendingInfo->pwszCAName, sizeof(WCHAR) * dwSize))
        goto setPendingRequestInfoWStrError; 
    pbPendingInfo += sizeof(WCHAR) * dwSize; 
    
    // Is friendly name set correctly?

    // Note: it is legal to pass NULL when setting the friendly name property.  In this case, 
    //       the friendly name property is set to the empty string. 
    if (NULL == pPendingInfo->pwszFriendlyName) { pPendingInfo->pwszFriendlyName = L""; } 

    dwSize = wcslen(pPendingInfo->pwszFriendlyName) + 1; 
    if (0 != memcmp(pbPendingInfo, &dwSize, sizeof(DWORD)))
        goto setPendingRequestInfoWStrError; 
    pbPendingInfo += sizeof(DWORD); 

    if (0 != memcmp(pbPendingInfo, pPendingInfo->pwszFriendlyName, sizeof(WCHAR) * dwSize))
        goto setPendingRequestInfoWStrError; 
    pbPendingInfo += sizeof(WCHAR) * dwSize; 

    // Success!
    fResult = TRUE; 
 CommonReturn:
    if (NULL != dataBlob.pbData) { LocalFree(dataBlob.pbData); } 
    if (NULL != pCertContext)    { CertFreeCertificateContext(pCertContext); } 

    return fResult; 
    
 ErrorReturn: 
    fResult = FALSE; 
    SetLastError(hr); 
    goto CommonReturn; 

PRINT_ERROR2(CertGetCertificateContextPropertyError, hr = GetLastError()); 
PRINT_ERROR2(GetCertOutOfStoreError, hr = GetLastError());
PRINT_ERROR2(InvalidArgError, hr = E_INVALIDARG);
PRINT_ERROR2(MemoryError, hr = E_OUTOFMEMORY);
PRINT_ERROR2(setPendingRequestInfoWStrError, hr); 
}

static BOOL WriteBlobToFile(LPCWSTR wszFile, DWORD dwFlags, PCRYPT_DATA_BLOB pBlob) {

    HANDLE      hFile   = NULL;
    BOOL        fRet    = TRUE;
    DWORD       cb      = 0;

    // open the File
    if( fRet = ((hFile = CreateFileW(
        wszFile,
        GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL)) != NULL && hFile != INVALID_HANDLE_VALUE) ) {

        // write out the data
        fRet = WriteFile(
            hFile,
            pBlob->pbData,
            pBlob->cbData,
            &cb,
            NULL);

        CloseHandle(hFile);
    }

    return(fRet);
}

// Basic operation, create keys, gen request, accept cert.
BOOL Test1() {

    IEnroll *	        pIEnroll            = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS7          = NULL;

    CRYPT_DATA_BLOB     blobPKCS10;
    BYTE                arSha1Hash[20];
    CRYPT_HASH_BLOB     hash =  {sizeof(arSha1Hash), arSha1Hash};
    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;
    LPWSTR              szwHashAlg = NULL;

    memset(&blobPKCS10, 0, sizeof(blobPKCS10));

    // TEST 1 Normal usage
    pIEnroll = PIEnrollGetNoCOM();

    if(S_OK != pIEnroll->get_HashAlgorithmWStr(&szwHashAlg)  ||
        wcscmp(szwHashAlg, L"1.3.14.3.2.26") ) {
        SetLastError(NTE_BAD_HASH);
        goto ErrorNoHashAlg;
    }

    if(S_OK != pIEnroll->put_HashAlgorithmWStr(L"MD2") ) {
        SetLastError(NTE_BAD_HASH);
        goto ErrorNoHashAlg;
    }

    if(S_OK != pIEnroll->get_HashAlgorithmWStr(&szwHashAlg)  ||
        wcscmp(szwHashAlg, L"1.2.840.113549.2.2") ) {
        SetLastError(NTE_BAD_HASH);
        goto ErrorNoHashAlg;
    }

    // enroll for a new cert
    if( S_OK != (hr = pIEnroll->createPKCS10WStr(L"CN=XEnroll Test", L"1.2.3.4, 1.2.6.7", &blobPKCS10)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
        }

    if( NULL == (pBlobPKCS7 = MakePKCS7Response(&blobPKCS10, &hash)) )
        goto ErrorMakePKCS7Response;

    // accept the new cert
    if( S_OK != (hr = pIEnroll->acceptPKCS7Blob(pBlobPKCS7)) ) {
        SetLastError(hr);
        goto ErrorAcceptPKCS7;
        }
        
    if( !RemoveCertFromStore(&hash, L"MY", CERT_SYSTEM_STORE_CURRENT_USER) )
        goto ErrorRemoveCertFromStore;
        
CommonReturn:

    if(pBlobPKCS7 != NULL)
        free(pBlobPKCS7);

    if(pIEnroll != NULL)
	    pIEnroll->Release();

    if(blobPKCS10.pbData != NULL)
        LocalFree(blobPKCS10.pbData);

    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorNoHashAlg);
PRINT_ERROR(ErrorCreatePkCS10);
PRINT_ERROR(ErrorAcceptPKCS7);
PRINT_ERROR(ErrorMakePKCS7Response);
PRINT_ERROR(ErrorRemoveCertFromStore);
}

// Test basic operation but with no EKU or no DN name
BOOL Test2() {

    IEnroll *	        pIEnroll            = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS7          = NULL;

    CRYPT_DATA_BLOB     blobPKCS10;
    BYTE                arSha1Hash[20];
    CRYPT_HASH_BLOB     hash =  {sizeof(arSha1Hash), arSha1Hash};
    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;

    // TEST 1 Normal usage
    pIEnroll = PIEnrollGetNoCOM();

    // enroll for a new cert
    memset(&blobPKCS10, 0, sizeof(blobPKCS10));
    if( S_OK != (hr = pIEnroll->createPKCS10WStr(NULL, NULL, &blobPKCS10)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
        }

    if( NULL == (pBlobPKCS7 = MakePKCS7Response(&blobPKCS10, &hash)) )
        goto ErrorMakePKCS7Response;

    // accept the new cert
    if( S_OK != (hr = pIEnroll->acceptPKCS7Blob(pBlobPKCS7)) ) {
        SetLastError(hr);
        goto ErrorAcceptPKCS7;
        }
        
    if( !RemoveCertFromStore(&hash, L"MY", CERT_SYSTEM_STORE_CURRENT_USER) )
        goto ErrorRemoveCertFromStore;
        
CommonReturn:

    if(pBlobPKCS7 != NULL)
        free(pBlobPKCS7);

    if(pIEnroll != NULL)
	    pIEnroll->Release();
	    
    if(blobPKCS10.pbData != NULL)
        LocalFree(blobPKCS10.pbData);

    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorCreatePkCS10);
PRINT_ERROR(ErrorAcceptPKCS7);
PRINT_ERROR(ErrorMakePKCS7Response);
PRINT_ERROR(ErrorRemoveCertFromStore);
}

// Test Renewal, Create original cert, create renewal request, create renewed cert
BOOL Test3() {

    IEnroll *	        pIEnroll            = NULL;
    IEnroll *	        pIEnroll2           = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS7          = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS72         = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS102        = NULL;
    PCCERT_CONTEXT      pCert1              = NULL;

    CRYPT_DATA_BLOB     blobPKCS10;
    CRYPT_DATA_BLOB     blobPKCS102;
    BYTE                arSha1Hash[20];
    BYTE                arSha1Hash2[20];
    CRYPT_HASH_BLOB     hash =  {sizeof(arSha1Hash), arSha1Hash};
    CRYPT_HASH_BLOB     hash2 = {sizeof(arSha1Hash2), arSha1Hash2};
    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;

    // TEST 1 Normal usage
    pIEnroll = PIEnrollGetNoCOM();

    // enroll for a new cert
    memset(&blobPKCS10, 0, sizeof(blobPKCS10));
    if( S_OK != (hr = pIEnroll->createPKCS10WStr(NULL, NULL, &blobPKCS10)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
        }

    if( NULL == (pBlobPKCS7 = MakePKCS7Response(&blobPKCS10, &hash)) )
        goto ErrorMakePKCS7Response;

    // accept the new cert
    if( S_OK != (hr = pIEnroll->acceptPKCS7Blob(pBlobPKCS7)) ) {
        SetLastError(hr);
        goto ErrorAcceptPKCS7;
        }

    // get the cert just created
    if( NULL == (pCert1 = pIEnroll->getCertContextFromPKCS7(pBlobPKCS7)) ) {
        goto ErrorGetCertContextFromPKCS7;
        }

    pIEnroll2 = PIEnrollGetNoCOM();
    
    // enroll for a new cert, Really I will get a 7 back with a 10 in it.
    if( S_OK != (hr = pIEnroll2->put_RenewalCertificate(pCert1)) ) {
        SetLastError(hr);
        goto ErrorPut_RenewalCertificate;
    }

    memset(&blobPKCS102, 0, sizeof(blobPKCS102));
    if( S_OK != (hr = pIEnroll2->createPKCS10WStr(NULL, NULL, &blobPKCS102)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
        }

    // get the pkcs10 from the pkcs7  
    if( NULL == (pBlobPKCS102 = GetPKCS10FromPKCS7(&blobPKCS102)) )
        goto ErrorGetPKCS10FromPKCS7;

    // make the response
    if( NULL == (pBlobPKCS72 = MakePKCS7Response(pBlobPKCS102, &hash2)) )
        goto ErrorMakePKCS7Response;

    // accept the new cert
    if( S_OK != (hr = pIEnroll2->acceptPKCS7Blob(pBlobPKCS72)) ) {
        SetLastError(hr);
        goto ErrorAcceptPKCS7;
        }
        
    if( !RemoveCertFromStore(&hash2, L"MY", CERT_SYSTEM_STORE_CURRENT_USER) )
        goto ErrorRemoveCertFromStore;
    if( !RemoveCertFromStore(&hash, L"MY", CERT_SYSTEM_STORE_CURRENT_USER) )
        goto ErrorRemoveCertFromStore;
        
CommonReturn:

    if(pCert1 != NULL)
        CertFreeCertificateContext(pCert1);
    
    if(pBlobPKCS7 != NULL)
        free(pBlobPKCS7);

    if(pBlobPKCS72 != NULL)
        free(pBlobPKCS72);

    if(pBlobPKCS102 != NULL)
        free(pBlobPKCS102);

    if(pIEnroll != NULL)
	    pIEnroll->Release();

    if(pIEnroll2 != NULL)
	    pIEnroll2->Release();

    if(blobPKCS10.pbData != NULL)
        LocalFree(blobPKCS10.pbData);
        
    if(blobPKCS102.pbData != NULL)
        LocalFree(blobPKCS102.pbData);

    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorCreatePkCS10);
PRINT_ERROR(ErrorAcceptPKCS7);
PRINT_ERROR(ErrorMakePKCS7Response);
PRINT_ERROR(ErrorRemoveCertFromStore);
PRINT_ERROR(ErrorGetCertContextFromPKCS7);
PRINT_ERROR(ErrorGetPKCS10FromPKCS7);
PRINT_ERROR(ErrorPut_RenewalCertificate);
}


// Basic operation, create keys, gen request, accept cert, but put the certs in HKLM
BOOL Test4() {

    IEnroll *	        pIEnroll            = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS7          = NULL;

    CRYPT_DATA_BLOB     blobPKCS10;
    BYTE                arSha1Hash[20];
    CRYPT_HASH_BLOB     hash =  {sizeof(arSha1Hash), arSha1Hash};
    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;

    // TEST 1 Normal usage
    if( NULL == (pIEnroll = PIEnrollGetNoCOM()))
        goto ErrorPIEnrollGetNoCOM;

    // say I want the result in HKLM
    pIEnroll->put_MyStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE);

    // enroll for a new cert
    memset(&blobPKCS10, 0, sizeof(blobPKCS10));
    if( S_OK != (hr = pIEnroll->createPKCS10WStr(L"CN=XEnroll Test", L"1.2.3.4", &blobPKCS10)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
        }
        
    pIEnroll->Release();
    if( NULL == (pIEnroll = PIEnrollGetNoCOM()))
        goto ErrorPIEnrollGetNoCOM;

    if( NULL == (pBlobPKCS7 = MakePKCS7ResponseMachine(&blobPKCS10, &hash)) )
        goto ErrorMakePKCS7Response;

    //this is new xenroll instance, set to machine store
    pIEnroll->put_MyStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE);

    // accept the new cert
    if( S_OK != (hr = pIEnroll->acceptPKCS7Blob(pBlobPKCS7)) ) {
        SetLastError(hr);
        goto ErrorAcceptPKCS7;
        }
        
    if( !RemoveCertFromStore(&hash, L"MY", CERT_SYSTEM_STORE_LOCAL_MACHINE) )
        goto ErrorRemoveCertFromStore;
        
CommonReturn:

    if(pBlobPKCS7 != NULL)
        free(pBlobPKCS7);

    if(pIEnroll != NULL)
	    pIEnroll->Release();

    if(blobPKCS10.pbData != NULL)
        LocalFree(blobPKCS10.pbData);

    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorPIEnrollGetNoCOM);
PRINT_ERROR(ErrorCreatePkCS10);
PRINT_ERROR(ErrorAcceptPKCS7);
PRINT_ERROR(ErrorMakePKCS7Response);
PRINT_ERROR(ErrorRemoveCertFromStore);
}

BOOL Test5() {

    #define DNNAME  L"CN=Test"

    DWORD               Err             = GetLastError();
    BOOL                fRet            = TRUE;
    HCRYPTPROV          hProv           = NULL;
    HCRYPTKEY           hKey            = NULL;
    PCCERT_CONTEXT      pCertContext    = NULL;
    DWORD               dwFlagsT        = 0;
    CERT_NAME_BLOB      nameBlob;
    CRYPT_KEY_PROV_INFO	keyProvInfo;
    GUID		guidContainerName;

    SYSTEMTIME		startTime;
    SYSTEMTIME		endTime;

    memset(&keyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));
    memset(&nameBlob, 0, sizeof(CERT_NAME_BLOB));
    memset(&guidContainerName, 0, sizeof(GUID));

    // get a container based on a guid
    UuidCreate(&guidContainerName);
    UuidToStringW(&guidContainerName, &keyProvInfo.pwszContainerName);

    keyProvInfo.pwszProvName        = L"";
    keyProvInfo.dwProvType          = PROV_RSA_FULL;
    keyProvInfo.dwFlags             = 0;
    keyProvInfo.cProvParam          = 0;
    keyProvInfo.rgProvParam         = NULL;
    keyProvInfo.dwKeySpec           = AT_SIGNATURE;

    if( !CryptAcquireContextW(&hProv,
         keyProvInfo.pwszContainerName,
         keyProvInfo.pwszProvName,
         keyProvInfo.dwProvType,
         CRYPT_NEWKEYSET) ) {
        hProv = NULL;
        goto ErrorCryptAcquireContext;
    }

    // we better not have a key here, so gen it
    if(!CryptGenKey(    hProv, 
                        keyProvInfo.dwKeySpec, 
                        0,
                        &hKey) ) 
        goto ErrorCryptGenKey;

    // get the Subject DN only if one is specified
    if( !CertStrToNameW(
            CRYPT_ASN_ENCODING,
            DNNAME,
            0,
            NULL,
            NULL,
            &nameBlob.cbData,
            NULL)                                               ||
        (nameBlob.pbData = (BYTE *) _alloca(nameBlob.cbData)) == NULL   ||
        !CertStrToNameW(
            CRYPT_ASN_ENCODING,
            DNNAME,
            0,
            NULL,
            nameBlob.pbData,
            &nameBlob.cbData,
            NULL) ) {
        goto ErrorCertStrToNameW;
    }

    // check that predefine dates work
    memset(&startTime, 0, sizeof(startTime));
    startTime.wYear = 1998;
    startTime.wMonth = 6;
    startTime.wDay = 20;
    startTime.wHour = 12;

    memset(&endTime, 0, sizeof(endTime));
    endTime.wYear = 1998;
    endTime.wMonth = 7;
    endTime.wDay = 10;
    endTime.wHour = 4;

    if ( NULL == (pCertContext = CertCreateSelfSignCertificate(
        hProv,          
        &nameBlob,
        0,
        NULL,
        NULL,
	&startTime,
	&endTime,
        NULL
        ) ) )
        goto ErrorCertCreateSelfSignCertificate;

    dwFlagsT = CERT_STORE_SIGNATURE_FLAG | CERT_STORE_TIME_VALIDITY_FLAG;
    if( !CertVerifySubjectCertificateContext(
        pCertContext,
        pCertContext,
        &dwFlagsT
        ) )
	goto ErrorCertVerifySubjectCertificateContext;

    // check the time to see if it is correct
    if( pCertContext->pCertInfo->NotBefore.dwLowDateTime != 0xF34E2000 ||
	pCertContext->pCertInfo->NotBefore.dwHighDateTime != 0x1BD9C42 ||
	pCertContext->pCertInfo->NotAfter.dwLowDateTime != 0x356DE000 ||
	pCertContext->pCertInfo->NotAfter.dwHighDateTime != 0x1BDABB7 ) {
	SetLastError(ERROR_INVALID_TIME);
	goto ErrorDateTime;
    }


CommonReturn:
    if (hProv != NULL) {
        HCRYPTPROV hDeleteProv;

        CryptAcquireContextW(&hDeleteProv,
             keyProvInfo.pwszContainerName,
             keyProvInfo.pwszProvName,
             keyProvInfo.dwProvType,
             CRYPT_DELETEKEYSET);
    }

    if(pCertContext !=NULL)
        CertFreeCertificateContext(pCertContext);
        
    if(hKey != NULL)
        CryptDestroyKey(hKey);
    
    if(keyProvInfo.pwszContainerName != NULL)
        RpcStringFreeW(&keyProvInfo.pwszContainerName);

    if(hProv != NULL)
        CryptReleaseContext(hProv, 0);
 
    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorCryptAcquireContext);
PRINT_ERROR(ErrorCertStrToNameW);
PRINT_ERROR(ErrorCryptGenKey);
PRINT_ERROR(ErrorCertVerifySubjectCertificateContext);
PRINT_ERROR(ErrorCertCreateSelfSignCertificate);
PRINT_ERROR(ErrorDateTime);
}

// Basic operation, create keys, gen request, accept cert.
BOOL Test6() {

    ICEnroll *	        pEnroll             = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS7          = NULL;

    BSTR                bstrRequest         = NULL;
    CRYPT_DATA_BLOB     blobPKCS10;
    BYTE                arSha1Hash[20];
    CRYPT_HASH_BLOB     hash =  {sizeof(arSha1Hash), arSha1Hash};
    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;
    BSTR                bstrResponse        = NULL;

    if( S_OK != CoInitialize(NULL) )
        goto ErrorCoInitializeEx;

    // TEST 1 Normal usage
    if( S_OK != (hr = CoCreateInstance(CLSID_CEnroll, NULL, CLSCTX_INPROC_SERVER, IID_ICEnroll, (void **) &pEnroll)) ) {
        SetLastError(hr);
        goto ErrorCoCreateInstance;
    }

    // enroll for a new cert
    memset(&blobPKCS10, 0, sizeof(blobPKCS10));
    if( S_OK != (hr = pEnroll->createPKCS10(L"CN=XEnroll Test", L"1.2.3.4, 1.2.6.7", &bstrRequest)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
        }

    blobPKCS10.cbData = SysStringByteLen(bstrRequest);
    blobPKCS10.pbData = (PBYTE) bstrRequest;

    if( NULL == (pBlobPKCS7 = MakePKCS7Response(&blobPKCS10, &hash)) )
        goto ErrorMakePKCS7Response;

    if( NULL == (bstrResponse = SysAllocStringByteLen((LPCSTR) pBlobPKCS7->pbData, pBlobPKCS7->cbData)) )
        goto ErrorSysAllocStringByteLen;

    // accept the new cert
    if( S_OK != (hr = pEnroll->acceptPKCS7(bstrResponse)) ) {
        SetLastError(hr);
        goto ErrorAcceptPKCS7;
        }
        
    if( !RemoveCertFromStore(&hash, L"MY", CERT_SYSTEM_STORE_CURRENT_USER) )
        goto ErrorRemoveCertFromStore;
        
CommonReturn:

    if(pBlobPKCS7 != NULL)
        free(pBlobPKCS7);

    if(pEnroll != NULL)
	    pEnroll->Release();

	if(bstrResponse != NULL)
	    SysFreeString(bstrResponse);

    CoUninitialize();

    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorCoInitializeEx);
PRINT_ERROR(ErrorCoCreateInstance);
PRINT_ERROR(ErrorSysAllocStringByteLen);
PRINT_ERROR(ErrorCreatePkCS10);
PRINT_ERROR(ErrorAcceptPKCS7);
PRINT_ERROR(ErrorMakePKCS7Response);
PRINT_ERROR(ErrorRemoveCertFromStore);
}

// Basic operation, create keys, gen request, accept cert, but put the certs in HKLM
BOOL Test7() {

    IEnroll *	        pIEnroll            = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS7          = NULL;

    CRYPT_DATA_BLOB     blobPKCS10;
    BYTE                arSha1Hash[20];
    CRYPT_HASH_BLOB     hash =  {sizeof(arSha1Hash), arSha1Hash};
    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;

    // TEST 1 Normal usage
    if( NULL == (pIEnroll = PIEnrollGetNoCOM()))
        goto ErrorPIEnrollGetNoCOM;

    // say I want the result in HKLM
    pIEnroll->put_RequestStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE);

    // enroll for a new cert
    memset(&blobPKCS10, 0, sizeof(blobPKCS10));
    if( S_OK != (hr = pIEnroll->createPKCS10WStr(L"CN=XEnroll Test", L"1.2.3.4", &blobPKCS10)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
        }
        
    pIEnroll->Release();
    if( NULL == (pIEnroll = PIEnrollGetNoCOM()))
        goto ErrorPIEnrollGetNoCOM;

    if( NULL == (pBlobPKCS7 = MakePKCS7ResponseMachine(&blobPKCS10, &hash)) )
        goto ErrorMakePKCS7Response;

    // say I want the result in HKLM
    pIEnroll->put_MyStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE);

    // accept the new cert
    if( S_OK != (hr = pIEnroll->acceptPKCS7Blob(pBlobPKCS7)) ) {
        SetLastError(hr);
        goto ErrorAcceptPKCS7;
        }
        
    if( !RemoveCertFromStore(&hash, L"MY", CERT_SYSTEM_STORE_LOCAL_MACHINE) )
        goto ErrorRemoveCertFromStore;
        
CommonReturn:

    if(pBlobPKCS7 != NULL)
        free(pBlobPKCS7);

    if(pIEnroll != NULL)
	    pIEnroll->Release();

    if(blobPKCS10.pbData != NULL)
        LocalFree(blobPKCS10.pbData);

    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorPIEnrollGetNoCOM);
PRINT_ERROR(ErrorCreatePkCS10);
PRINT_ERROR(ErrorAcceptPKCS7);
PRINT_ERROR(ErrorMakePKCS7Response);
PRINT_ERROR(ErrorRemoveCertFromStore);
}

// Test some alg enum stuff
BOOL Test8() {

    IEnroll2 *	        pIEnroll            = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS7          = NULL;

    CRYPT_DATA_BLOB     blobPKCS10;
    BYTE                arSha1Hash[20];
    CRYPT_HASH_BLOB     hash =  {sizeof(arSha1Hash), arSha1Hash};
    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;
    LONG                lFlags  = 0;
    DWORD               i       = 0;
    LPWSTR              wsz     = NULL;

    // TEST 1 Normal usage
    if( NULL == (pIEnroll = PIEnroll2GetNoCOM()))
        goto ErrorPIEnrollGetNoCOM;

    // enum the default algids
    while( (S_OK == (hr = pIEnroll->EnumAlgs(i++, ALG_CLASS_HASH, &lFlags))) ) {
        if( (S_OK == (hr = pIEnroll->GetAlgNameWStr(lFlags, &wsz))) ) {
            LocalFree(wsz);
        }
        else {
            goto ErrorGetAlgName;
        }
    }
    
    if( i == 1 ) {
        SetLastError(hr);
        goto ErrorEnumAlgs;
    }

    if(S_OK != (hr = pIEnroll->GetSupportedKeySpec(&lFlags))) {
        SetLastError(hr);
        goto ErrorGetSupportedKeySpec;
    }

    if(S_OK != (hr = pIEnroll->GetKeyLen(FALSE, FALSE, &lFlags))) {
        SetLastError(hr);
        goto ErrorGetKeyLen;
    }

    if(S_OK != (hr = pIEnroll->GetKeyLen(FALSE, TRUE, &lFlags))) {
        SetLastError(hr);
        goto ErrorGetKeyLen;
    }

    if(S_OK != (hr = pIEnroll->GetKeyLen(TRUE, FALSE, &lFlags))) {
        SetLastError(hr);
        goto ErrorGetKeyLen;
    }

    if(S_OK != (hr = pIEnroll->GetKeyLen(TRUE, TRUE, &lFlags))) {
        SetLastError(hr);
        goto ErrorGetKeyLen;
    }

    // get the keyspec data
    // enroll for a new cert
    memset(&blobPKCS10, 0, sizeof(blobPKCS10));
    if( S_OK != (hr = pIEnroll->createPKCS10WStr(L"CN=XEnroll Test", L"1.2.3.4", &blobPKCS10)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
        }
        
    pIEnroll->Reset();
 
    if( NULL == (pBlobPKCS7 = MakePKCS7Response(&blobPKCS10, &hash)) )
        goto ErrorMakePKCS7Response;

    // accept the new cert
    if( S_OK != (hr = pIEnroll->acceptPKCS7Blob(pBlobPKCS7)) ) {
        SetLastError(hr);
        goto ErrorAcceptPKCS7;
        }
        
    if( !RemoveCertFromStore(&hash, L"MY", CERT_SYSTEM_STORE_CURRENT_USER) )
        goto ErrorRemoveCertFromStore;
        
CommonReturn:

    if(pBlobPKCS7 != NULL)
        free(pBlobPKCS7);

    if(pIEnroll != NULL)
	    pIEnroll->Release();

    if(blobPKCS10.pbData != NULL)
        LocalFree(blobPKCS10.pbData);

    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorPIEnrollGetNoCOM);
PRINT_ERROR(ErrorCreatePkCS10);
PRINT_ERROR(ErrorAcceptPKCS7);
PRINT_ERROR(ErrorMakePKCS7Response);
PRINT_ERROR(ErrorRemoveCertFromStore);
PRINT_ERROR(ErrorEnumAlgs);
PRINT_ERROR(ErrorGetKeyLen);
PRINT_ERROR(ErrorGetSupportedKeySpec);
PRINT_ERROR(ErrorGetAlgName);
}

// Test some alg enum stuff
BOOL Test9() {

    IEnroll2 *	        pIEnroll            = NULL;
    PCCERT_CONTEXT      pCertContext        = NULL;

    CRYPT_DATA_BLOB     blobPKCS10;
    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;
    DWORD               i       = 0;
 
    // TEST 1 Normal usage
    if( NULL == (pIEnroll = PIEnroll2GetNoCOM()))
        goto ErrorPIEnrollGetNoCOM;

    for(i=0; i<100; i++) {
    
        // get the keyspec data
        // enroll for a new cert
        memset(&blobPKCS10, 0, sizeof(blobPKCS10));
        if( S_OK != (hr = pIEnroll->createPKCS10WStr(L"CN=XEnroll Test", L"1.2.3.4", &blobPKCS10)) ) {
            SetLastError(hr);
            goto ErrorCreatePkCS10;
            }
    
        pIEnroll->Reset();

        // clean up after ourself
        if(NULL != (pCertContext =  GetCertOutOfRequestStore(&blobPKCS10)) ) {
            // delete the cert's private key
            DeleteCertPrivateKey(pCertContext);

            CertDeleteCertificateFromStore(pCertContext);
            pCertContext = NULL;
        }

        if(blobPKCS10.pbData != NULL)
            LocalFree(blobPKCS10.pbData);
    }
 
       
 CommonReturn:

    if(pIEnroll != NULL)
	    pIEnroll->Release();


    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorPIEnrollGetNoCOM);
PRINT_ERROR(ErrorCreatePkCS10);
}


// test to see if we can build PVK and SPC files
BOOL TestUI1() {

    IEnroll *	        pIEnroll            = NULL;
    PCRYPT_DATA_BLOB    pBlobPKCS7          = NULL;

    CRYPT_DATA_BLOB     blobPKCS10;
    BYTE                arSha1Hash[20];
    CRYPT_HASH_BLOB     hash =  {sizeof(arSha1Hash), arSha1Hash};
    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;

    // TEST 1 Normal usage
    pIEnroll = PIEnrollGetNoCOM();

    if( S_OK != pIEnroll->put_PVKFileNameWStr(L"c:\\temp\\foo.pvk") )
        goto ErrorPVKFileNameWStr;
    
    // enroll for a new cert
    memset(&blobPKCS10, 0, sizeof(blobPKCS10));
    if( S_OK != (hr = pIEnroll->createPKCS10WStr(NULL, NULL, &blobPKCS10)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
        }

    if( NULL == (pBlobPKCS7 = MakePKCS7Response(&blobPKCS10, &hash)) )
        goto ErrorMakePKCS7Response;

    // accept the new cert
    if( S_OK != (hr = pIEnroll->acceptPKCS7Blob(pBlobPKCS7)) ) {
        SetLastError(hr);
        goto ErrorAcceptPKCS7;
        }
        
    if( !RemoveCertFromStore(&hash, L"MY", CERT_SYSTEM_STORE_CURRENT_USER) )
        goto ErrorRemoveCertFromStore;
        
CommonReturn:

    if(pBlobPKCS7 != NULL)
        free(pBlobPKCS7);

    if(pIEnroll != NULL)
	    pIEnroll->Release();
	    
    if(blobPKCS10.pbData != NULL)
        LocalFree(blobPKCS10.pbData);

    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorCreatePkCS10);
PRINT_ERROR(ErrorAcceptPKCS7);
PRINT_ERROR(ErrorMakePKCS7Response);
PRINT_ERROR(ErrorRemoveCertFromStore);
PRINT_ERROR(ErrorPVKFileNameWStr);
}

// Test Renewal, Create original cert, create renewal request, create renewed cert
BOOL Test10() {

    BOOL                fRet    = TRUE;
    DWORD               Err     = GetLastError();
    HRESULT             hr      = S_OK;

    // GetUserNameExW is NOT a 2 pass call, so I have to guess at the MAX
    #define             MAXUSERNAME         256
    WCHAR               wszUserName[MAXUSERNAME];
    DWORD               cchUserName         = MAXUSERNAME;
    
    IEnroll *	        pIEnrollRenew       = NULL;
    IEnroll *	        pIEnrollRA1         = NULL;
    IEnroll *	        pIEnrollRA2         = NULL;

    CRYPT_DATA_BLOB     blobRenewRequest;
    CRYPT_DATA_BLOB     blobRA1Reqest;
    CRYPT_DATA_BLOB     blobRA2Reqest;
    CRYPT_DATA_BLOB     blobT;
    
    CERT_NAME_BLOB      blobNameRA1;
    CERT_NAME_BLOB      blobNameRA2;
    CERT_NAME_BLOB      blobNameOld;
    
    PCCERT_CONTEXT      pCertRA1            = NULL;
    PCCERT_CONTEXT      pCertRA2            = NULL;
    PCCERT_CONTEXT      pCertOld            = NULL;

    CERT_EXTENSION      rgExtension[]       = {
                                                {szOID_ENHANCED_KEY_USAGE, FALSE, {0, NULL}}
                                              };
    CERT_EXTENSIONS     Extensions          = {sizeof(rgExtension)/sizeof(CERT_EXTENSION), rgExtension};
    
    LPSTR               rgszOIDUsages[]     = {szOID_ENROLLMENT_AGENT};
    CERT_ENHKEY_USAGE   eku                 = {1 ,rgszOIDUsages};

    memset(&blobRenewRequest, 0, sizeof(blobRenewRequest));
    memset(&blobRA1Reqest, 0, sizeof(blobRA1Reqest));
    memset(&blobRA2Reqest, 0, sizeof(blobRA2Reqest));
    memset(&blobNameRA1, 0, sizeof(blobNameRA1));
    memset(&blobNameRA2, 0, sizeof(blobNameRA2));
    memset(&blobNameOld, 0, sizeof(blobNameOld));

    // encode the enhanced key usage
    if( !CryptEncodeObjectEx(
            CRYPT_ASN_ENCODING, 
            X509_ENHANCED_KEY_USAGE,
            &eku,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,
            &rgExtension[0].Value.pbData,           
            &rgExtension[0].Value.cbData
            ) )
        goto ErrorCryptEncodeObjectEx;
    
    // get the Subject DN only if one is specified
    if( !CertStrToNameW(
            CRYPT_ASN_ENCODING,
            L"CN=Test RA1",
            0,
            NULL,
            NULL,
            &blobNameRA1.cbData,
            NULL)                                               ||
        (blobNameRA1.pbData = (BYTE *) _alloca(blobNameRA1.cbData)) == NULL   ||
        !CertStrToNameW(
            CRYPT_ASN_ENCODING,
            L"CN=Test RA1",
            0,
            NULL,
            blobNameRA1.pbData,
            &blobNameRA1.cbData,
            NULL) ) {
        goto ErrorCertStrToNameW;
    }

    // get a Cert for the 1st RA
    if( NULL == (pCertRA1 = CertCreateSelfSignCertificate(
            NULL,          
            &blobNameRA1,
            0,
            NULL,
            NULL,
            NULL,
            NULL,
            &Extensions
        ) ) )
        goto ErrorCertCreateSelfSignCertificate;
        
    blobT.cbData = pCertRA1->cbCertEncoded;
    blobT.pbData = pCertRA1->pbCertEncoded;
    WriteBlobToFile(L"RA1.cer", 0, &blobT);
        
    // get the Subject DN only if one is specified
    if( !CertStrToNameW(
            CRYPT_ASN_ENCODING,
            L"CN=Test RA2",
            0,
            NULL,
            NULL,
            &blobNameRA2.cbData,
            NULL)                                               ||
        (blobNameRA2.pbData = (BYTE *) _alloca(blobNameRA2.cbData)) == NULL   ||
        !CertStrToNameW(
            CRYPT_ASN_ENCODING,
            L"CN=Test RA2",
            0,
            NULL,
            blobNameRA2.pbData,
            &blobNameRA2.cbData,
            NULL) ) {
        goto ErrorCertStrToNameW;
    }

    // get a Cert for the 2'nd RA
    if( NULL == (pCertRA2 = CertCreateSelfSignCertificate(
            NULL,          
            &blobNameRA2,
            0,
            NULL,
            NULL,
            NULL,
            NULL,
            &Extensions
        ) ) )
        goto ErrorCertCreateSelfSignCertificate;
        
    blobT.cbData = pCertRA2->cbCertEncoded;
    blobT.pbData = pCertRA2->pbCertEncoded;
    WriteBlobToFile(L"RA2.cer", 0, &blobT);

    // get the Subject DN only if one is specified
    if( !CertStrToNameW(
            CRYPT_ASN_ENCODING,
            L"CN=Test Cert Old",
            0,
            NULL,
            NULL,
            &blobNameOld.cbData,
            NULL)                                               ||
        (blobNameOld.pbData = (BYTE *) _alloca(blobNameOld.cbData)) == NULL   ||
        !CertStrToNameW(
            CRYPT_ASN_ENCODING,
            L"CN=Test Cert Old",
            0,
            NULL,
            blobNameOld.pbData,
            &blobNameOld.cbData,
            NULL) ) {
        goto ErrorCertStrToNameW;
    }

    // get a Cert for the Original cert
    if( NULL == (pCertOld = CertCreateSelfSignCertificate(
            NULL,          
            &blobNameOld,
            0,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL
        ) ) )
        goto ErrorCertCreateSelfSignCertificate;
    blobT.cbData = pCertOld->cbCertEncoded;
    blobT.pbData = pCertOld->pbCertEncoded;
    WriteBlobToFile(L"Original.cer", 0, &blobT);

    // Make an RA cert
    if(NULL == (pIEnrollRenew = PIEnrollGetNoCOM()) )
        goto ErrorPIEnrollGetNoCOM;
    
    // enroll for a new cert.
    if( S_OK != (hr = pIEnrollRenew->put_RenewalCertificate(pCertOld)) ) {
        SetLastError(hr);
        goto ErrorPut_RenewalCertificate;
    }

    // put in a certtype for laughs
    if( S_OK != (hr = pIEnrollRenew->AddCertTypeToRequestWStr(L"MY CERT TYPE")) ) {
        SetLastError(hr);
        goto ErrorAddCertTypeToRequest;
    }

    // get the renewal PKCS7 (in the 10 blob)
    if( S_OK != (hr = pIEnrollRenew->createPKCS10WStr(L"CN=XEnroll Test Renew", L"1.3.6.1.5.5.7.3.8", &blobRenewRequest)) ) {
        SetLastError(hr);
        goto ErrorCreatePkCS10;
    }
    WriteBlobToFile(L"Renewal.p7s", 0, &blobRenewRequest);

    // Make an RA cert
    if(NULL == (pIEnrollRA1 = PIEnrollGetNoCOM()) )
        goto ErrorPIEnrollGetNoCOM;


    if(S_OK != pIEnrollRA1->AddNameValuePairToSignatureWStr(L"CreateUserCertificate", L"stimpy.ntdev.microsoft.com"))
        goto ErrorAddNameValuePairToSignatureWStr;


    if( !GetUserNameExW(NameSamCompatible, wszUserName, &cchUserName) ) 
        goto ErrorGetUserName;

    if(S_OK != pIEnrollRA1->AddNameValuePairToSignatureWStr(L"UserName", wszUserName))
        goto ErrorAddNameValuePairToSignatureWStr;
    
    // get the 1st RA Request
    if( S_OK != (hr = pIEnrollRA1->CreatePKCS7RequestFromRequest(
		&blobRenewRequest,
		pCertRA1,
		&blobRA1Reqest) ) )
		goto ErrorCreatePKCS7RequestFromRequest;
    WriteBlobToFile(L"RA1.p7s", 0, &blobRA1Reqest);

    // Make an RA cert
    if(NULL == (pIEnrollRA2 = PIEnrollGetNoCOM()) )
        goto ErrorPIEnrollGetNoCOM;
    
    if(S_OK != pIEnrollRA2->AddNameValuePairToSignatureWStr(L"ChangeUserCertificate", L"stimpy.redmond.microsoft.com"))
        goto ErrorAddNameValuePairToSignatureWStr;
    
    // get the 2nd RA Request
    if( S_OK != (hr = pIEnrollRA2->CreatePKCS7RequestFromRequest(
		&blobRA1Reqest,
		pCertRA2,
		&blobRA2Reqest) ) )
		goto ErrorCreatePKCS7RequestFromRequest;

    // put this out to a file for Vic
    WriteBlobToFile(L"RA2.p7s", 0, &blobRA2Reqest);
        
CommonReturn:

    if(rgExtension[0].Value.pbData != NULL)
        LocalFree(rgExtension[0].Value.pbData);

    if(blobRenewRequest.pbData != NULL) {
        // clean up after ourself
        PCCERT_CONTEXT pCertRequest;
        if(NULL != (pCertRequest =  GetCertOutOfRequestStore2(
                &blobRenewRequest)) ) {
            // delete the cert's private key
            DeleteCertPrivateKey(pCertRequest);

            CertDeleteCertificateFromStore(pCertRequest);
        }

        LocalFree(blobRenewRequest.pbData);
    }
        
    if(pIEnrollRenew != NULL)
        pIEnrollRenew->freeRequestInfoBlob(blobRenewRequest);

    if(pCertRA1 != NULL) {
        DeleteCertPrivateKey(pCertRA1);
        CertFreeCertificateContext(pCertRA1);
    }
        
    if(pCertRA2 != NULL) {
        DeleteCertPrivateKey(pCertRA2);
        CertFreeCertificateContext(pCertRA2);
    }
        
    if(pCertOld != NULL) {
        DeleteCertPrivateKey(pCertOld);
        CertFreeCertificateContext(pCertOld);
    }

    if(blobRA1Reqest.pbData != NULL)
        LocalFree(blobRA1Reqest.pbData);

    if(blobRA2Reqest.pbData != NULL)
        LocalFree(blobRA2Reqest.pbData);

    if(pIEnrollRenew != NULL)
        pIEnrollRenew->Release();

    if(pIEnrollRA1 != NULL)
        pIEnrollRA1->Release();

    if(pIEnrollRA2 != NULL)
        pIEnrollRA2->Release();

    SetLastError(Err);

    return(fRet);

ErrorReturn:

    Err = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

PRINT_ERROR(ErrorGetUserName);
PRINT_ERROR(ErrorAddNameValuePairToSignatureWStr);
PRINT_ERROR(ErrorPIEnrollGetNoCOM);
PRINT_ERROR(ErrorCertStrToNameW);
PRINT_ERROR(ErrorCertCreateSelfSignCertificate);
PRINT_ERROR(ErrorCreatePKCS7RequestFromRequest);
PRINT_ERROR(ErrorCreatePkCS10);
PRINT_ERROR(ErrorPut_RenewalCertificate);
PRINT_ERROR(ErrorCryptEncodeObjectEx);
PRINT_ERROR(ErrorAddCertTypeToRequest);
}

HRESULT
myMultiByteToWideChar(
    IN  char  *psz,
    OUT WCHAR **ppwsz)
{
    HRESULT  hr;
    int cch = 0;
    WCHAR *pwsz = NULL;

    assert (NULL != psz);

    while (TRUE)
    {
        cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, cch);
        assert((cch - 1) == (int)strlen(psz));
        if (NULL != pwsz)
        {
             break; //done
        }
        pwsz = (WCHAR*)LocalAlloc(LMEM_FIXED, cch * sizeof(WCHAR));
        if (NULL == pwsz)
        {
            hr = E_OUTOFMEMORY;
            goto LocalAllocError;
        }
    }
    *ppwsz = pwsz;
    pwsz = NULL;

    hr = S_OK;
ErrorReturn:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    return hr;

PRINT_ERROR(LocalAllocError)
}


// test Enroll4 interface
BOOL Test11()
{

    BOOL  fRet = FALSE;
    HRESULT  hr;
    IEnroll4 *pIEnroll4 = NULL;
    HANDLE  hCAFile = NULL;
    CHAR    *pchCACert = NULL;
    BYTE    *pbCACert = NULL;
    DWORD   cchCACert;
    DWORD   cbCACert;
    DWORD   cbRead;
    PCCERT_CONTEXT  pCACert = NULL;
    WCHAR  *pwszDNName = NULL;
    WCHAR  *pwszCMCFileName = NULL;
    WCHAR  *pwszKeyContainer = NULL;
    CRYPT_DATA_BLOB  blobCMC;
    WCHAR  wszMyDNName[] = L"CN=Xenroll CMC Test";
    LONG   lKeySize;

    ZeroMemory(&blobCMC, sizeof(blobCMC));



    pIEnroll4 = PIEnroll4GetNoCOM();
    if(NULL == pIEnroll4)
    {
        goto PIEnroll4GetNoCOMError;
    }

    if (NULL != g_pszKeyContainer)
    {
        hr = myMultiByteToWideChar(g_pszKeyContainer, &pwszKeyContainer);
        if (S_OK != hr)
        {
            goto myMultiByteToWideCharError;
        }
    }

    if (NULL != pwszKeyContainer)
    {
        hr = pIEnroll4->put_ContainerNameWStr(pwszKeyContainer);
        if (S_OK != hr)
        {
            goto put_ContainerNameWStrError;
        }
    }

    hr = pIEnroll4->resetExtensions();
    if (S_OK != hr)
    {
        goto resetExtensionsError;
    }

    hr = pIEnroll4->resetAttributes();
    if (S_OK != hr)
    {
        goto resetAttributesError;
    }

    //add some extensions

    //add some attributes
    hr = pIEnroll4->addNameValuePairToRequestWStr(
                    0,
                    L"NameValue name",
                    L"NameValue value");
    if (S_OK != hr)
    {
        goto addNameValuePairToRequestWStrError;
    }

    if (NULL != g_pszCAXchgFileName)
    {
        //get a ca cert
        hCAFile = CreateFileA(
                    g_pszCAXchgFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);
        if (NULL != hCAFile)
        {
            cchCACert = GetFileSize(hCAFile, NULL);
            assert(0 < cchCACert);
            pchCACert = (CHAR*)LocalAlloc(LMEM_FIXED, cchCACert);
            if (NULL == pchCACert)
            {
                goto LocalAllocError;
            }
            if (!ReadFile(hCAFile, pchCACert, cchCACert, &cbRead, NULL))
            {
                goto ReadFileError;
            }
            assert(cbRead <= cchCACert);
    
            pbCACert = NULL;
            while (TRUE)
            {
                if (!CryptStringToBinaryA(
                            pchCACert,
                            cchCACert,
                            CRYPT_STRING_ANY,
                            pbCACert,
                            &cbCACert,
                            NULL,
                            NULL))
                {
                    goto CryptStringToBinaryAError;
                }
                if (NULL != pbCACert)
                {
                    break;
                }
                pbCACert = (BYTE*)LocalAlloc(LMEM_FIXED, cbCACert);
                if (NULL == pbCACert)
                {
                    goto LocalAllocError;
                }
            }
            pCACert = CertCreateCertificateContext(
                            X509_ASN_ENCODING,
                            pbCACert,
                            cbCACert);
            if (NULL == pCACert)
            {
                goto CertCreateCertificateContextError;
            }

            hr = pIEnroll4->SetPrivateKeyArchiveCertificate(
                        pCACert);
            if (S_OK != hr)
            {
                goto SetPrivateKeyArchiveCertificateError;
            }
        }

#if 0
        hr = pIEnroll4->put_GenKeyFlags(CRYPT_EXPORTABLE);
        if (S_OK != hr)
        {
            goto put_GenKeyFlagsError;
        }
#endif
    }

    pwszDNName = wszMyDNName;
    if (NULL != g_pszDNName)
    {
        hr = myMultiByteToWideChar(g_pszDNName, &pwszDNName);
        if (S_OK != hr)
        {
            goto myMultiByteToWideCharError;
        }
    }

    if (NULL != g_pszCMCFileName)
    {
        hr = myMultiByteToWideChar(g_pszCMCFileName, &pwszCMCFileName);
        if (S_OK != hr)
        {
            goto myMultiByteToWideCharError;
        }
    }

    // enroll for a new cert
    if (NULL != pwszCMCFileName)
    {
        hr = pIEnroll4->createFileRequestWStr(
                    XECR_CMC,
                    pwszDNName,
                    NULL,
                    pwszCMCFileName);
    }
    else
    {
        hr = pIEnroll4->createRequestWStr(
                    XECR_CMC,
                    pwszDNName,
                    NULL,
                    &blobCMC);
    }
    if (S_OK != hr)
    {
        goto createRequestWStrError;
    }


    fRet = TRUE;
ErrorReturn:
    if (NULL != pwszKeyContainer)
    {
        LocalFree(pwszKeyContainer);
    }
    if (NULL != pchCACert)
    {
        LocalFree(pchCACert);
    }
    if (NULL != pbCACert)
    {
        LocalFree(pbCACert);
    }
    if (NULL != pwszCMCFileName)
    {
        LocalFree(pwszCMCFileName);
    }
    if (NULL != pwszDNName && pwszDNName != wszMyDNName)
    {
        LocalFree(pwszDNName);
    }
    if(NULL != pIEnroll4)
    {
        pIEnroll4->Release();
    }
    if (NULL != hCAFile)
    {
        CloseHandle(hCAFile);
    }
    if (NULL != pCACert)
    {
        CertFreeCertificateContext(pCACert);
    }
    if (NULL != blobCMC.pbData)
    {
        LocalFree(blobCMC.pbData);
    }

   return fRet;


PRINT_ERROR(CryptStringToBinaryAError)
#if 0
PRINT_ERROR2(put_GenKeyFlagsError, hr)
#endif
PRINT_ERROR2(SetPrivateKeyArchiveCertificateError, hr)
PRINT_ERROR(CertCreateCertificateContextError)
PRINT_ERROR(ReadFileError)
PRINT_ERROR2(createRequestWStrError, hr)
PRINT_ERROR2(addNameValuePairToRequestWStrError, hr)
PRINT_ERROR2(resetExtensionsError, hr)
PRINT_ERROR2(resetAttributesError, hr)
PRINT_ERROR(PIEnroll4GetNoCOMError)
PRINT_ERROR2(put_ContainerNameWStrError, hr)
PRINT_ERROR2(LocalAllocError, E_OUTOFMEMORY)
PRINT_ERROR2(myMultiByteToWideCharError, hr)
}

// test Enroll4 interface, accept CMC response
BOOL Test12()
{
    HRESULT  hr;
    BOOL  fRet = FALSE;
    IEnroll4 *pIEnroll4 = NULL;
    int cch;
    WCHAR  *pwszResponseFile = NULL;

    if (NULL == g_pszCMCResponseFileName)
    {
        //skip the test
        printf("Test12 is skipped\n");
        fRet = TRUE;
        goto ErrorReturn;
    }

    pIEnroll4 = PIEnroll4GetNoCOM();
    if(NULL == pIEnroll4)
    {
        goto PIEnroll4GetNoCOMError;
    }


    hr = myMultiByteToWideChar(g_pszCMCResponseFileName, &pwszResponseFile);
    if (S_OK != hr)
    {
        goto myMultiByteToWideCharError;
    }

    hr = pIEnroll4->acceptFileResponseWStr(pwszResponseFile);
    if (S_OK != hr)
    {
        goto acceptFileResponseWStrError;
    }

    fRet = TRUE;
ErrorReturn:
    if (NULL != pwszResponseFile)
    {
        LocalFree(pwszResponseFile);
    }
    if(NULL != pIEnroll4)
    {
        pIEnroll4->Release();
    }
   return fRet;

PRINT_ERROR(PIEnroll4GetNoCOMError)
PRINT_ERROR(acceptFileResponseWStrError)
PRINT_ERROR(myMultiByteToWideCharError)
}

// Test pending API
BOOL Test13()
{
    BOOL                        fRet; 
    CRYPT_DATA_BLOB             pkcs10Blob; 
    DWORD                       dwIndex; 
    DWORD                       dwNumTests; 
    HRESULT                     hr; 
    IEnroll4                   *pIEnroll4    = NULL; 
    PCCERT_CONTEXT              pCertContext = NULL; 
    TXEnrollPendingAPITester   *pTester      = NULL; 
    WCHAR                       wszDNName[]  = L"CN=Xenroll PendingAPI Test";


    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //
    // TEST CASES
    //
    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    PENDING_INFO rgPendingTests[] = { 
	// 0) Normal inputs
	{ 
	    100, 
	    L"duncanb1.ntdev.microsoft.com", 
	    L"setPendingInfoWStr Test 1", 
	    L"SPI Test 1", 
	    0,                              
	    NULL,
	    S_OK 
	},       
	
	// 1) Negative Req ID
	{
	    -1, 
	    L"duncanb1.ntdev.microsoft.com", 
	    L"setPendingInfoWStr Test 1", 
	    L"SPI Test 1", 
	    0,   
	    NULL,                            
	    E_INVALIDARG
	}, 

	// 2) NULL CA location. 
	{
	    100, 
	    NULL,                           
	    L"setPendingInfoWStr Test 1", 
	    L"SPI Test 1", 
	    0,   
	    NULL,                            
	    E_INVALIDARG 
	},

	// 3) NULL CA name. 
	{
	    100,
	    L"duncanb1.ntdev.microsoft.com", 
	    NULL,                        
	    L"SPI Test 1", 
	    0,   
	    NULL,                            
	    E_INVALIDARG 
	},

	// 4) NULL friendly name. 
	{
	    100, 
	    L"duncanb1.ntdev.microsoft.com", 
	    L"setPendingInfoWStr Test 1",
	    NULL,         
	    0,   
	    NULL,                            
	    S_OK
	},         

	// 5) Specify USER store flags. 
	{
	    100, 
	    L"duncanb1.ntdev.microsoft.com", 
	    L"setPendingInfoWStr Test 1", 
	    L"SPI Test 1", 
	    CERT_SYSTEM_STORE_CURRENT_USER,  
	    NULL,
	    S_OK 
	},        

	// 6) Specify LM store flags. 
	{
	    100, 
	    L"duncanb1.ntdev.microsoft.com", 
	    L"setPendingInfoWStr Test 1", 
	    L"SPI Test 1", 
	    CERT_SYSTEM_STORE_LOCAL_MACHINE, 
	    NULL,
	    S_OK 
	}, 
	// 7) Long names: 
	{ 
	    100, 
	    L"duncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.com"
            L"duncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comcom"
            L"duncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comcom"
            L"duncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comcom"
            L"duncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comcom"
            L"duncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comcom"
            L"duncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comcom"
            L"duncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.comduncanb1.ntdev.microsoft.com", 

	    L"setPendingInfoWStr Test 1setPendingInfoWStr Test 1setPendingInfoWStr Test 1"
            L"setPendingInfoWStr Test 1setPendingInfoWStr Test 1setPendingInfoWStr Test 1"
            L"setPendingInfoWStr Test 1Test 1setPendingInfoWStr Test 1setPendingInfoWStr Test 1"
            L"setPendingInfoWStr Test 1setPendingInfoWStr Test 1Test 1setPendingInfoWStr Test 1"
            L"setPendingInfoWStr Test 1setPendingInfoWStr Test 1setPendingInfoWStr Test 1Test 1"
            L"setPendingInfoWStr Test 1setPendingInfoWStr Test 1setPendingInfoWStr Test 1"
            L"setPendingInfoWStr Test 1Test 1setPendingInfoWStr Test 1setPendingInfoWStr Test 1"
            L"setPendingInfoWStr Test 1setPendingInfoWStr Test 1Test 1setPendingInfoWStr Test 1"
            L"setPendingInfoWStr Test 1setPendingInfoWStr Test 1setPendingInfoWStr Test 1Test 1"
            L"setPendingInfoWStr Test 1setPendingInfoWStr Test 1setPendingInfoWStr Test 1"
            L"setPendingInfoWStr Test 1", 

	    L"SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1"
            L"SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1"
            L"Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1"
            L"SPITest 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1"
            L"SPITest 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1"
            L"SPITest 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1"
            L"SPITest 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1"
            L"SPITest 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1"
            L"SPITest 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1"
            L"SPITest 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI Test 1SPI", 
	    0, 
	    NULL,
	    S_OK 
	}
    };

    ZeroMemory(&pkcs10Blob, sizeof(pkcs10Blob)); 
    
    pIEnroll4 = PIEnroll4GetNoCOM();
    if(NULL == pIEnroll4)
        goto PIEnroll4GetNoCOMError;
    
    pTester = new TXEnrollPendingAPITester; 
    if (NULL == pTester)
	goto MemoryError; 

    // Test the ThumbPrintWStr property. 
    if (!pTester->TestProperty_ThumbPrintWStr(pIEnroll4))
	goto TestProperty_ThumbPrintWStrError; 

    pIEnroll4 = PIEnroll4GetNoCOM();
    if(NULL == pIEnroll4)
        goto PIEnroll4GetNoCOMError;
    
    // Test the removePendingRequestWStr method. 
    if (!pTester->TestMethod_removePendingRequestWStr(pIEnroll4))
	goto TestMethod_removePendingRequestWStrError; 

    // Test all enumPending / setPendingInfo cases:
    dwNumTests = sizeof(rgPendingTests) / sizeof(PENDING_INFO); 
    for (dwIndex = 0; dwIndex < dwNumTests; dwIndex++)
    {
	pIEnroll4 = PIEnroll4GetNoCOM();
	if(NULL == pIEnroll4)
	    goto PIEnroll4GetNoCOMError;

	if (S_OK != (hr = pIEnroll4->resetExtensions()))
	    goto resetExtensionsError;
	
	if (S_OK != (hr = pIEnroll4->resetAttributes()))
	    goto resetAttributesError;

	// Small key size so the test runs faster. 
	if (S_OK != (hr = pIEnroll4->put_GenKeyFlags(384 << 16)))
	    goto put_GenKeyFlagsError; 

	// Default to CURRENT_USER.  
	if (0 == rgPendingTests[dwIndex].dwStoreFlags)
	    rgPendingTests[dwIndex].dwStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;
	
	// Default to REQUEST store. 
	if (NULL == rgPendingTests[dwIndex].pwszStoreName)
	    rgPendingTests[dwIndex].pwszStoreName = L"REQUEST"; 

	if (S_OK != (hr = pIEnroll4->put_RequestStoreFlags(rgPendingTests[dwIndex].dwStoreFlags)))
	    goto put_RequestStoreFlagsError;
	    
	if (S_OK != (hr = pIEnroll4->put_RequestStoreNameWStr(rgPendingTests[dwIndex].pwszStoreName)))
	    goto put_RequestStoreNameWStrError; 

	// Create a request to test on. 
	if (S_OK != (hr = pIEnroll4->createRequestWStr
		     (XECR_PKCS10_V2_0,
		      wszDNName,
              NULL,
		      &pkcs10Blob)))
	    goto createRequestWStrError;

	if (!pTester->TestMethod_setPendingInfoWStr(pIEnroll4, pkcs10Blob, &rgPendingTests[dwIndex]))
	    goto TestMethod_setPendingInfoWStrError; 

	// only continue if we are not testing a failure case. 
	// Eventually this should be extended to test the failure cases for enumPendingRequestWStr. 
	if (S_OK == rgPendingTests[dwIndex].hrExpectedResult)
	{
	    if (!pTester->TestMethod_enumPendingRequestWStr(pIEnroll4, pkcs10Blob, &rgPendingTests[dwIndex]))
		goto TestMethod_enumPendingRequestWStrError; 

	}

	pCertContext = GetCertOutOfStore(&pkcs10Blob, rgPendingTests[dwIndex].dwStoreFlags, rgPendingTests[dwIndex].pwszStoreName); 
	if (NULL == pCertContext)
	    goto GetCertOutOfStoreError; 
	
	CertDeleteCertificateFromStore(pCertContext); 
	LocalFree(pkcs10Blob.pbData); 
	ZeroMemory(&pkcs10Blob, sizeof(pkcs10Blob)); 
	pCertContext = NULL; 
        pIEnroll4->Release(); 
    }
    
    fRet = TRUE; 

 CommonReturn:
    if (NULL != pkcs10Blob.pbData) 
    { 
	pCertContext = GetCertOutOfStore(&pkcs10Blob, rgPendingTests[dwIndex].dwStoreFlags, rgPendingTests[dwIndex].pwszStoreName); 
	if (NULL != pCertContext) { CertDeleteCertificateFromStore(pCertContext); }
	LocalFree(pkcs10Blob.pbData); 
    } 
    return fRet;
    
 ErrorReturn: 
    fRet = FALSE; 
    SetLastError(hr); 
    goto CommonReturn; 

PRINT_ERROR2(createRequestWStrError,                   hr); 
PRINT_ERROR2(GetCertOutOfStoreError,                   hr = GetLastError()); 
PRINT_ERROR2(MemoryError,                              hr = E_OUTOFMEMORY); 
PRINT_ERROR2(PIEnroll4GetNoCOMError,                   hr = GetLastError()); 
PRINT_ERROR2(put_GenKeyFlagsError,                     hr); 
PRINT_ERROR2(put_RequestStoreFlagsError,               hr); 
PRINT_ERROR2(put_RequestStoreNameWStrError,            hr); 
PRINT_ERROR2(resetAttributesError,                     hr);
PRINT_ERROR2(resetExtensionsError,                     hr);
PRINT_ERROR2(TestMethod_enumPendingRequestWStrError,   hr = GetLastError()); 
PRINT_ERROR2(TestMethod_removePendingRequestWStrError, hr = GetLastError()); 
PRINT_ERROR2(TestMethod_setPendingInfoWStrError,       hr = GetLastError()); 
PRINT_ERROR2(TestProperty_ThumbPrintWStrError,         hr = GetLastError()); 
}


// test Enroll4 misc. methods
BOOL Test14()
{
    BOOL  fRet = FALSE;
    HRESULT  hr;
    ICEnroll4  *pICEnroll = NULL;
    ICEnroll4  *pICEnroll2 = NULL;
    ICEnroll4  *pICEnroll3 = NULL;
    ICEnroll4  *pICEnroll4 = NULL;
    IEnroll4 *pIEnroll = NULL;
    IEnroll4 *pIEnroll2 = NULL;
    IEnroll4 *pIEnroll4 = NULL;
    LONG   lKeySize;
    BOOL        fCoInit = FALSE;

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        goto CoInitializeError;
    }
    fCoInit = TRUE;

    hr = CoCreateInstance(
                CLSID_CEnroll,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_ICEnroll,
                (void **) &pICEnroll);
    if( S_OK != hr || NULL == pICEnroll)
    {
        goto CoCreateInstanceError;
    }
    if (g_fVerb)
    {
        printf("CoCreateInstance(ICEnroll) test passed\n");
    }

    hr = CoCreateInstance(
                CLSID_CEnroll,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_ICEnroll2,
                (void **) &pICEnroll2);
    if( S_OK != hr || NULL == pICEnroll2)
    {
        goto CoCreateInstanceError;
    }
    if (g_fVerb)
    {
        printf("CoCreateInstance(ICEnroll2) test passed\n");
    }

    hr = CoCreateInstance(
                CLSID_CEnroll,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_ICEnroll3,
                (void **) &pICEnroll3);
    if( S_OK != hr || NULL == pICEnroll3)
    {
        goto CoCreateInstanceError;
    }
    if (g_fVerb)
    {
        printf("CoCreateInstance(ICEnroll3) test passed\n");
    }

    hr = CoCreateInstance(
                CLSID_CEnroll,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_ICEnroll4,
                (void **) &pICEnroll4);
    if( S_OK != hr || NULL == pICEnroll4)
    {
        goto CoCreateInstanceError;
    }
    if (g_fVerb)
    {
        printf("CoCreateInstance(ICEnroll4) test passed\n");
    }


    hr = CoCreateInstance(
                CLSID_CEnroll,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IEnroll,
                (void **) &pIEnroll);
    if( S_OK != hr || NULL == pIEnroll)
    {
        goto CoCreateInstanceError;
    }
    if (g_fVerb)
    {
        printf("CoCreateInstance(IEnroll) test passed\n");
    }

    hr = CoCreateInstance(
                CLSID_CEnroll,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IEnroll4,
                (void **) &pIEnroll2);
    if( S_OK != hr || NULL == pIEnroll2)
    {
        goto CoCreateInstanceError;
    }
    if (g_fVerb)
    {
        printf("CoCreateInstance(IEnroll2) test passed\n");
    }

    hr = CoCreateInstance(
                CLSID_CEnroll,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IEnroll4,
                (void **) &pIEnroll4);
    if( S_OK != hr || NULL == pIEnroll4)
    {
        goto CoCreateInstanceError;
    }
    if (g_fVerb)
    {
        printf("CoCreateInstance(IEnroll4) test passed\n");
    }


    hr = pIEnroll4->GetKeyLenEx(XEKL_KEYSIZE_MIN, XEKL_KEYSPEC_KEYX, &lKeySize);
    if (S_OK != hr)
    {
        goto GetKeyLenExError;
    }
    if (g_fVerb)
    {
        printf("Minimun exchange key size is %d\n", lKeySize);
    }

    hr = pIEnroll4->GetKeyLenEx(XEKL_KEYSIZE_MAX, XEKL_KEYSPEC_KEYX, &lKeySize);
    if (S_OK != hr)
    {
        goto GetKeyLenExError;
    }
    if (g_fVerb)
    {
        printf("Maximun exchange key size is %d\n", lKeySize);
    }

    hr = pIEnroll4->GetKeyLenEx(XEKL_KEYSIZE_DEFAULT, XEKL_KEYSPEC_KEYX, &lKeySize);
    if (S_OK != hr)
    {
        goto GetKeyLenExError;
    }
    if (g_fVerb)
    {
        printf("Default exchange key size is %d\n", lKeySize);
    }

    hr = pIEnroll4->GetKeyLenEx(XEKL_KEYSIZE_INC, XEKL_KEYSPEC_KEYX, &lKeySize);
    if (S_OK != hr)
    {
        goto GetKeyLenExError;
    }
    if (g_fVerb)
    {
        printf("Exchange key increment size is %d\n", lKeySize);
    }

    //signature key
    hr = pIEnroll4->GetKeyLenEx(XEKL_KEYSIZE_MIN, XEKL_KEYSPEC_SIG, &lKeySize);
    if (S_OK != hr)
    {
        goto GetKeyLenExError;
    }
    if (g_fVerb)
    {
        printf("Minimun signature key size is %d\n", lKeySize);
    }

    hr = pIEnroll4->GetKeyLenEx(XEKL_KEYSIZE_MAX, XEKL_KEYSPEC_SIG, &lKeySize);
    if (S_OK != hr)
    {
        goto GetKeyLenExError;
    }
    if (g_fVerb)
    {
        printf("Maximun signature key size is %d\n", lKeySize);
    }

    hr = pIEnroll4->GetKeyLenEx(XEKL_KEYSIZE_DEFAULT, XEKL_KEYSPEC_SIG, &lKeySize);
    if (S_OK != hr)
    {
        goto GetKeyLenExError;
    }
    if (g_fVerb)
    {
        printf("Default signature key size is %d\n", lKeySize);
    }

    hr = pIEnroll4->GetKeyLenEx(XEKL_KEYSIZE_INC, XEKL_KEYSPEC_SIG, &lKeySize);
    if (S_OK != hr)
    {
        goto GetKeyLenExError;
    }
    if (g_fVerb)
    {
        printf("Signature key increment size is %d\n", lKeySize);
    }

    fRet = TRUE;
ErrorReturn:
    if(NULL != pICEnroll)
    {
        pICEnroll->Release();
    }
    if(NULL != pICEnroll2)
    {
        pICEnroll2->Release();
    }
    if(NULL != pICEnroll3)
    {
        pICEnroll3->Release();
    }
    if(NULL != pICEnroll4)
    {
        pICEnroll4->Release();
    }
    if(NULL != pIEnroll)
    {
        pIEnroll->Release();
    }
    if(NULL != pIEnroll2)
    {
        pIEnroll2->Release();
    }
    if(NULL != pIEnroll4)
    {
        pIEnroll4->Release();
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    return fRet;

PRINT_ERROR2(CoCreateInstanceError, hr)
PRINT_ERROR2(CoInitializeError, hr)
PRINT_ERROR2(GetKeyLenExError, hr)
}

// test acceptPKCS7 and PFX
BOOL Test15()
{
    BOOL  fRet = FALSE;
    HRESULT  hr;
    IEnroll4 *pIEnroll4 = NULL;
    BOOL        fCoInit = FALSE;
    WCHAR    *pwszPKCS7FileName = NULL;
    WCHAR    *pwszPFXFileName = NULL;
    WCHAR    *pwszPFXPassword = NULL;
    WCHAR    wszEmptyPassword[] = L"";

    if (MAXDWORD == g_dwTestID &&
        NULL == g_pszPKCS7FileName)
    {
        printf("Test15 is skipped.\n");
        goto done;
    }

    if (NULL == g_pszPKCS7FileName)
    {
        printf("You must provide a PKCS7 file\n");
        goto MissedPKCS7FileError;
    }

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        goto CoInitializeError;
    }
    fCoInit = TRUE;

    hr = CoCreateInstance(
                CLSID_CEnroll,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IEnroll4,
                (void **) &pIEnroll4);
    if( S_OK != hr || NULL == pIEnroll4)
    {
        goto CoCreateInstanceError;
    }

    hr = myMultiByteToWideChar(g_pszPKCS7FileName, &pwszPKCS7FileName);
    if (S_OK != hr)
    {
        goto myMultiByteToWideCharError;
    }

    hr = pIEnroll4->acceptFilePKCS7WStr(pwszPKCS7FileName);
    if (S_OK != hr)
    {
        goto acceptFilePKCS7WStrError;
    }

    if (NULL != g_pszPFXFileName)
    {
        if (NULL == g_pszPFXPassword)
        {
            pwszPFXPassword = wszEmptyPassword;
            if (g_fVerb)
            {
                printf("Empty PFX password is used.\n");
            }
        }
        hr = myMultiByteToWideChar(g_pszPFXFileName, &pwszPFXFileName);
        if (S_OK != hr)
        {
            goto myMultiByteToWideCharError;
        }
        if (NULL != g_pszPFXPassword)
        {
            hr = myMultiByteToWideChar(g_pszPFXPassword, &pwszPFXPassword);
            if (S_OK != hr)
            {
                goto myMultiByteToWideCharError;
            }
        }

        //create pfx file
        hr = pIEnroll4->createFilePFXWStr(pwszPFXPassword, pwszPFXFileName);
        if (S_OK != hr)
        {
            goto createFilePFXWStrError;
        }
    }

done:
    fRet = TRUE;
ErrorReturn:

    if(NULL != pIEnroll4)
    {
        pIEnroll4->Release();
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    if (NULL != pwszPKCS7FileName)
    {
        LocalFree(pwszPKCS7FileName);
    }
    if (NULL != pwszPFXFileName)
    {
        LocalFree(pwszPFXFileName);
    }
    if (NULL != pwszPFXPassword && pwszPFXPassword != wszEmptyPassword)
    {
        LocalFree(pwszPFXPassword);
    }
    return fRet;

PRINT_ERROR2(CoCreateInstanceError, hr)
PRINT_ERROR2(myMultiByteToWideCharError, hr)
PRINT_ERROR2(acceptFilePKCS7WStrError, hr)
PRINT_ERROR2(createFilePFXWStrError, hr)
PRINT_ERROR2(CoInitializeError, hr)
PRINT_ERROR2(MissedPKCS7FileError, E_INVALIDARG)
}

//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   prints the usage statement
//
//----------------------------------------------------------------------------
static void Usage(DWORD cTest)
{
    printf("Usage: txenrol [options]\n");
    printf(" options:\n");
    printf(" -h this help\n");
    printf(" -k [KeyContainerName]\n");
    printf(" -n [DNName]\n");
    printf(" -x [CAExchangeCertFileName]\n");
    printf(" -o [CMCRequestFileName]\n");
    printf(" -s [#] stress test count\n");
    printf(" -t [TestID] run single test. There are %d tests.\n", cTest);
    printf(" -r [CMCResponseFile]\n");
    printf(" -a [PKCS7FileName]\n");
    printf(" -f [PFXFileName], -a is required\n");
    printf(" -w [PFXPassword], -a is required. If no -p, empty password is used.\n");
    printf(" -p pause before each test\n");
    printf(" -v verbose\n");

    printf("\n");
    printf(" Test1:  basic operation, gen keys, gen request, accept cert.\n");
    printf(" Test2:  basic operation but with no EKU or no DN name.\n");
    printf(" Test3:  test renewal cert.\n");
    printf(" Test4:  basic operation but put the certs in HKLM\n");
    printf(" Test5:  test self signed certificate creation\n");
    printf(" Test6:  basic operation with attributes\n");
    printf(" Test7:  basic operation but put the certs in HKLM\n");
    printf(" Test8:  test some alg enum stuff\n");
    printf(" Test9:  test some alg enum stuff\n");
    printf(" Test10: test renewal\n");
    printf(" Test11: test CMC request generation\n");
    printf(" Test12: test CMC response. skipped except -r is passed\n");
    printf(" Test13: test pending API\n");   
    printf(" Test14: test Enroll4 misc. methods\n");   
    printf(" Test15: test acceptPKCS7 and PFX\n");   
}

BOOL
ParseOptions(int argc, char *argv[])
{
    int i;

    for (i = 1; i < argc; ++i)
    {
        if ('-' == argv[i][0])
        {
            switch (argv[i][1])
            {
                case 'n':
                case 'N':
                ++i;
                if (i < argc)
                {
                    g_pszDNName = argv[i];
                }
                else
                {
                    printf("missed DNName\n");
                    return FALSE;
                }
                break;

                case 'x':
                case 'X':
                ++i;
                if (i < argc)
                {
                    g_pszCAXchgFileName = argv[i];
                }
                else
                {
                    printf("missed CAExchangeFileName\n");
                    return FALSE;
                }
                break;

                case 'o':
                case 'O':
                ++i;
                if (i < argc)
                {
                    g_pszCMCFileName = argv[i];
                }
                else
                {
                    printf("missed CMCRequestFileName\n");
                    return FALSE;
                }
                break;

                case 'w':
                case 'W':
                ++i;
                if (i < argc)
                {
                    g_pszPFXPassword = argv[i];
                }
                else
                {
                    printf("missed PFXPassword\n");
                    return FALSE;
                }
                break;

                case 'f':
                case 'F':
                ++i;
                if (i < argc)
                {
                    g_pszPFXFileName = argv[i];
                }
                else
                {
                    printf("missed PFXFileName\n");
                    return FALSE;
                }
                break;

                case 'a':
                case 'A':
                ++i;
                if (i < argc)
                {
                    g_pszPKCS7FileName = argv[i];
                }
                else
                {
                    printf("missed PKCS7FileName\n");
                    return FALSE;
                }
                break;

                case 'r':
                case 'R':
                ++i;
                if (i < argc)
                {
                    g_pszCMCResponseFileName = argv[i];
                }
                else
                {
                    printf("missed CMCResponseFileName\n");
                    return FALSE;
                }
                break;

                case 'k':
                case 'K':
                ++i;
                if (i < argc)
                {
                    g_pszKeyContainer = argv[i];
                }
                else
                {
                    printf("missed KeyContainerName\n");
                    return FALSE;
                }
                break;

                case 's':
                case 'S':
                ++i;
                if (i < argc)
                {
                    g_cStress = atoi(argv[i]);
                }
                break;

                case 't':
                case 'T':
                ++i;
                if (i < argc)
                {
                    g_dwTestID = atoi(argv[i]);
                }
                break;

                case 'p':
                case 'P':
                    g_fPause = TRUE;
                break;

                case 'v':
                case 'V':
                    g_fVerb = TRUE;
                break;

                case 'h':
                case 'H':
                    return FALSE;

                default:
                    printf("Unrecognized options -%c\n", argv[i][1]);
                    return FALSE;
                break;
            }
        }
        else
        {
            printf("Unrecognized options %s\n", argv[i]);
            return FALSE;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   main program entry point
//
//----------------------------------------------------------------------------
typedef BOOL (* PFNTest)(void);
PFNTest arPfnTest[] = {Test1, Test2, Test3, Test4, Test5, Test6, Test7, Test8, Test9, Test10, Test11, Test12, Test13, Test14, Test15};
#define COUNT_TEST   sizeof(arPfnTest)/sizeof(arPfnTest[0])

int _cdecl main(int argc, char * argv[])
{
    int                 ErrReturn           = 0;
    DWORD               i;
    DWORD               n;
    DWORD               NBRTests            = sizeof(arPfnTest) / sizeof(PFNTest);
    BOOL                fPassed = TRUE;

    if (1 > argc)
    {
        Usage(COUNT_TEST);
        return( 1 );
    }

    //parse options
    if (!ParseOptions(argc, argv))
    {
        Usage(COUNT_TEST);
        return (1);
    }
    
    for (DWORD n = 0; n < g_cStress; ++n)
    {
        if (g_fPause)
        {
            char wszgets[3];
            if (MAXDWORD == g_dwTestID)
            {
                printf("press enter key to start the tests ...");
            }
            else
            {
                printf("press enter key to run Test%d ...", g_dwTestID);
            }
            gets(wszgets);
        }
        if (MAXDWORD != g_dwTestID &&
                 COUNT_TEST >= g_dwTestID)
        {
            //only do one test
            if (!arPfnTest[g_dwTestID - 1]())
            {
                printf("Test%d failed.\n", g_dwTestID);
                fPassed = FALSE;
            }
            else
            {
                printf("Test%d finished.\n", g_dwTestID);
            }
        }
        else
        {
            for(i=0; i<NBRTests; i++)
            {
                if( !arPfnTest[i]() )
                {
                    printf("Test%d failed.\n", i+1);
                    fPassed = FALSE;
                }
                else
                {
                    printf("Test%d finished.\n", i+1);
                }
            }
        }
        if (1 < g_cStress)
        {
            printf("test round %d finished\n", n+1);
        }
    }

    if (fPassed)
    {
        printf("All XEnroll tests passed.\n");
    }
    else
    {
        printf("One or more XEnroll tests didn't pass.\n");
    }
    
    return(ErrReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptext\cryptpko.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cryptpko.h
//
//--------------------------------------------------------------------------

// CryptPKO.h : Declaration of the CCryptPKO

#ifndef __CRYPTPKO_H_
#define __CRYPTPKO_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CCryptPKO
class ATL_NO_VTABLE CCryptPKO :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCryptPKO, &CLSID_CryptPKO>,
	public ICryptPKO,
    public IContextMenu,
    public IShellPropSheetExt,
    public IShellExtInit
{
protected:
	LPDATAOBJECT    m_pDataObj;

public:

DECLARE_REGISTRY_RESOURCEID(IDR_CRYPTPKO)
DECLARE_NOT_AGGREGATABLE(CCryptPKO)

BEGIN_COM_MAP(CCryptPKO)
	COM_INTERFACE_ENTRY(ICryptPKO)
    COM_INTERFACE_ENTRY(IContextMenu)
    COM_INTERFACE_ENTRY(IShellPropSheetExt)
    COM_INTERFACE_ENTRY(IShellExtInit)
END_COM_MAP()

// ICryptPKO
public:

    CCryptPKO();
    ~CCryptPKO();

	//IShell members
	STDMETHODIMP			QueryContextMenu(HMENU hMenu,
	                                         UINT indexMenu,
	                                         UINT idCmdFirst,
                                             UINT idCmdLast,
                                             UINT uFlags);

	STDMETHODIMP			InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi);

	STDMETHODIMP			GetCommandString(UINT_PTR idCmd,
	                                         UINT uFlags,
	                                         UINT FAR *reserved,
                                             LPSTR pszName,
                                             UINT cchMax);

    //IShellPropSheetExt methods
    STDMETHODIMP            AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    STDMETHODIMP            ReplacePage(UINT uPageID,
                                        LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                                        LPARAM lParam);


	//IShellExtInit methods
	STDMETHODIMP		    Initialize(LPCITEMIDLIST pIDFolder,
	                                   LPDATAOBJECT pDataObj,
	                                   HKEY hKeyID);

};

#endif //__CRYPTPKO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptext\cryptsig.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cryptsig.h
//
//--------------------------------------------------------------------------

// CryptSig.h : Declaration of the CCryptSig

#ifndef __CRYPTSIG_H_
#define __CRYPTSIG_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CCryptSig
class ATL_NO_VTABLE CCryptSig : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCryptSig, &CLSID_CryptSig>,
	public ICryptSig,
    public IShellPropSheetExt,
    public IShellExtInit
{
protected:
	LPDATAOBJECT    m_pDataObj;

public:

DECLARE_REGISTRY_RESOURCEID(IDR_CRYPTSIG)
DECLARE_NOT_AGGREGATABLE(CCryptSig)

BEGIN_COM_MAP(CCryptSig)
	COM_INTERFACE_ENTRY(ICryptSig)
    COM_INTERFACE_ENTRY(IShellPropSheetExt)
    COM_INTERFACE_ENTRY(IShellExtInit)
END_COM_MAP()

// ICryptSig
public:

    CCryptSig();
	~CCryptSig();


     //IShellPropSheetExt methods
    STDMETHODIMP            AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    
    STDMETHODIMP            ReplacePage(UINT uPageID, 
                                        LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
                                        LPARAM lParam);

	//IShellExtInit methods
	STDMETHODIMP		    Initialize(LPCITEMIDLIST pIDFolder, 
	                                   LPDATAOBJECT pDataObj, 
	                                   HKEY hKeyID);    


};

#endif //__CRYPTSIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptext\cryptsig.cpp ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:      CryptSig.cpp
//
//  content:   Implements the IContextMenu member functions necessary to support
//             the context menu portioins of this shell extension.  Context menu
//             shell extensions are called when the user right clicks on a file

//  History:    16-09-1997 xiaohs   created
//
// CryptSig.cpp : Implementation of CCryptSig
//--------------------------------------------------------------
#include "stdafx.h"
#include "cryptext.h"
#include "private.h"
#include "CryptSig.h"

//--------------------------------------------------------------
// CCryptSig
//--------------------------------------------------------------
//
//  FUNCTION: GAKPageCallback(HWND, UINT, LPPROPSHEETPAGE)
//
//  PURPOSE: Callback  procedure for the property page
//
//  PARAMETERS:
//    hWnd      - Reserved (will always be NULL)
//    uMessage  - Action flag: Are we being created or released
//    ppsp      - The page that is being created or destroyed
//
//  RETURN VALUE:
//
//    Depends on message. 
//
//    For PSPCB_CREATE it's TRUE to let the page be created
//    or false to prevent it from being created.  
//    For PSPCB_RELEASE the return value is ignored.
//
//  COMMENTS:
//
BOOL CALLBACK
SignPageCallBack(HWND hWnd,
                UINT uMessage,
                void  *pvCallBack)
{
    switch(uMessage)
    {
        case PSPCB_CREATE:
            return TRUE;

        case PSPCB_RELEASE:
            if (pvCallBack) 
            {
               ((IShellPropSheetExt *)(pvCallBack))->Release();
            }
            return TRUE; 
    }
    return TRUE;
}

//--------------------------------------------------------------
//
//  Constructor
//
//--------------------------------------------------------------
CCryptSig::CCryptSig()
{
    m_pDataObj=NULL;
}


//--------------------------------------------------------------
//
//  Destructor
//
//--------------------------------------------------------------
CCryptSig::~CCryptSig()
{
    if (m_pDataObj)
        m_pDataObj->Release();

}

//--------------------------------------------------------------
//  FUNCTION: CCryptSig::AddPages(LPFNADDPROPSHEETPAGE, LPARAM)
//
//  PURPOSE: Called by the shell just before the property sheet is displayed.
//
//  PARAMETERS:
//    lpfnAddPage -  Pointer to the Shell's AddPage function
//    lParam      -  Passed as second parameter to lpfnAddPage
//
//  RETURN VALUE:
//
//    NOERROR in all cases.  If for some reason our pages don't get added,
//    the Shell still needs to bring up the Properties... sheet.
//
//  COMMENTS:
//--------------------------------------------------------------


STDMETHODIMP CCryptSig::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    HPROPSHEETPAGE  hpage;
    PROPSHEETPAGEW  *pPage=NULL;
    DWORD           dwPage=0;
    DWORD           dwIndex=0;
	DWORD			dwSignerCount=0;  
	DWORD			cbSize=0;

    FORMATETC       fmte = {CF_HDROP,
        	            (DVTARGETDEVICE FAR *)NULL,
        	            DVASPECT_CONTENT,
        	            -1,
        	            TYMED_HGLOBAL 
        	            };
    STGMEDIUM       stgm;
    UINT            ucFiles=0;
    WCHAR           wszFileName[_MAX_PATH];
    HCRYPTMSG       hMsg=NULL;
    HRESULT         hr=E_FAIL;
    DWORD           dwExceptionCode=0;
	DWORD			dwAttr=0;

    CRYPTUI_VIEWSIGNATURES_STRUCTW  sigView;

    //get the file name that user clicked on.  We do not add context menu
    //if user has selected more than one file

    if (m_pDataObj)
       hr = m_pDataObj->GetData(&fmte, &stgm);

    if (!SUCCEEDED(hr))
        return  NOERROR;    

    ucFiles = stgm.hGlobal ?
        DragQueryFileU((HDROP) stgm.hGlobal, 0xFFFFFFFFL , 0, 0) : 0;

    if  ((!ucFiles) || (ucFiles >= 2))
    {
        ReleaseStgMedium(&stgm);

        return  NOERROR;    //  Shouldn't happen, but it's not important
    }


    if(0==DragQueryFileU((HDROP) stgm.hGlobal, 0, wszFileName,
            sizeof wszFileName/ sizeof wszFileName[0]))
    {
        ReleaseStgMedium(&stgm);

        return NOERROR;
    }

	//we ignore the case when the file is off-line
	if(0xFFFFFFFF == (dwAttr=GetFileAttributesU(wszFileName)))
	{
		ReleaseStgMedium(&stgm);
		return NOERROR;
	}

	if(FILE_ATTRIBUTE_OFFLINE & dwAttr)
	{
		ReleaseStgMedium(&stgm);
		return NOERROR;
	}

    //get the content type of the file.  We only cares about
    //the signed document in binary format
    if(!CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       wszFileName,
                       CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED,
                       CERT_QUERY_FORMAT_FLAG_BINARY,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       &hMsg,
                       NULL))
    {
        //can not recognize the object.  Fine
        goto CLEANUP;
    }

	//make sure that we have at least on signer
	cbSize = sizeof(dwSignerCount);
	if(!CryptMsgGetParam(hMsg,
						CMSG_SIGNER_COUNT_PARAM,
						0,
						&dwSignerCount,
						&cbSize))
		goto CLEANUP;

	if(0==dwSignerCount)
		goto CLEANUP;

    
    //Call Reid's function to add the property sheet page
    memset(&sigView, 0, sizeof(CRYPTUI_VIEWSIGNATURES_STRUCTW));
    sigView.dwSize=sizeof(CRYPTUI_VIEWSIGNATURES_STRUCTW);
    sigView.choice=hMsg_Chosen;
    sigView.u.hMsg=hMsg;
    sigView.szFileName=wszFileName;
    sigView.pPropPageCallback=SignPageCallBack;  
    sigView.pvCallbackData=this;    


    if(!CryptUIGetViewSignaturesPagesW(
            &sigView,
            &pPage,
            &dwPage))
        goto CLEANUP;

    __try {
        for(dwIndex=0; dwIndex<dwPage; dwIndex++)
        {
           // pPage[dwIndex].dwFlags |= PSP_USECALLBACK;

            //add the callback functions to release the refcount
            //pPage[dwIndex].pfnCallback=SignPageCallBack;
            //pPage[dwIndex].pcRefParent=(UINT *)this;

            hpage = CreatePropertySheetPageU(&(pPage[dwIndex]));
        
            ((IShellPropSheetExt *)this)->AddRef();

            if (hpage) 
            {
                if (!lpfnAddPage(hpage, lParam)) 
                {
                    DestroyPropertySheetPage(hpage);
                    ((IShellPropSheetExt *)this)->Release();
                }
            }
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto CLEANUP;
    }




CLEANUP:

    ReleaseStgMedium(&stgm);


    if(pPage)
        CryptUIFreeViewSignaturesPagesW(pPage, dwPage);
    
    if(hMsg)
        CryptMsgClose(hMsg);


    return NOERROR;
}

//--------------------------------------------------------------

//  FUNCTION: CCryptSig::ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM)
//
//  PURPOSE: Called by the shell only for Control Panel property sheet 
//           extensions
//
//  PARAMETERS:
//    uPageID         -  ID of page to be replaced
//    lpfnReplaceWith -  Pointer to the Shell's Replace function
//    lParam          -  Passed as second parameter to lpfnReplaceWith
//
//  RETURN VALUE:
//
//    E_FAIL, since we don't support this function.  It should never be
//    called.

//  COMMENTS:
//--------------------------------------------------------------


STDMETHODIMP CCryptSig::ReplacePage(UINT uPageID, 
                                    LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
                                    LPARAM lParam)
{
    return E_FAIL;
}

//--------------------------------------------------------------
//  FUNCTION: CCryptSig::Initialize(LPCITEMIDLIST, LPDATAOBJECT, HKEY)
//
//  PURPOSE: Called by the shell when initializing a context menu or property
//           sheet extension.
//
//  PARAMETERS:
//    pIDFolder - Specifies the parent folder
//    pDataObj  - Spefifies the set of items selected in that folder.
//    hRegKey   - Specifies the type of the focused item in the selection.
//
//  RETURN VALUE:
//
//    NOERROR in all cases.
//--------------------------------------------------------------
STDMETHODIMP CCryptSig::Initialize(LPCITEMIDLIST pIDFolder,
                                   LPDATAOBJECT pDataObj,
                                   HKEY hRegKey)
{
    // Initialize can be called more than once

  if (m_pDataObj)
    	m_pDataObj->Release();

    // duplicate the object pointer and registry handle
    if (pDataObj)
    {
    	m_pDataObj = pDataObj;
    	pDataObj->AddRef();
    }          

    return NOERROR;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptext\cryptpko.cpp ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:      CryptPKO.cpp
//
//  content:   Implements the IContextMenu member functions necessary to support
//             the context menu portioins of this shell extension.  Context menu
//             shell extensions are called when the user right clicks on a file

//  History:    16-09-1997 xiaohs   created
//
//--------------------------------------------------------------
#include "stdafx.h"
#include "cryptext.h"
#include "private.h"
#include "CryptPKO.h"

//QueryContextMenu is called twice by the Shell.
//we have to set the flag.
BOOL            g_fDefaultCalled=FALSE;


HRESULT I_InvokeCommand(LPWSTR  pwszFileName, UINT    idCmd, BOOL    fDefault)
{

    DWORD           dwContentType=0;
    DWORD           dwFormatType=0;
    HCERTSTORE      hCertStore=NULL;
    HCRYPTMSG       hMsg=NULL;
    const void      *pvContext=NULL;
    UINT            idsFileName=0;


	HRESULT         hr = E_FAIL;

    CRYPTUI_VIEWCERTIFICATE_STRUCT  CertViewStruct;
    CRYPTUI_VIEWCRL_STRUCT          CRLViewStruct;
    CRYPTUI_WIZ_IMPORT_SRC_INFO             importSubject;

    //get the content type of the file
     //we care about every file type except for the signed doc
   if(!CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_ALL,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       &dwContentType,
                       &dwFormatType,
                       &hCertStore,
                       &hMsg,
                       &pvContext))
    {

        I_NoticeBox(
			GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_PKO_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);

       goto CLEANUP;
    }

    //make sure idCmd is the correct valud for different types
    //we are guaranteed that idCmd is 1 or 0
    if(CERT_QUERY_CONTENT_CERT != dwContentType &&
       CERT_QUERY_CONTENT_CTL  != dwContentType &&
       CERT_QUERY_CONTENT_CRL  != dwContentType && 
       CERT_QUERY_CONTENT_PKCS7_SIGNED != dwContentType)
    {
        if(1==idCmd)
        {
            hr=E_INVALIDARG;
            goto CLEANUP;
        }
    }


    switch (dwContentType)
    {
        case CERT_QUERY_CONTENT_CERT:
                if(idCmd==0)
                {
                    //call the Certificate Common Dialogue
                    memset(&CertViewStruct, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));

                    CertViewStruct.dwSize=sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT);
                    CertViewStruct.pCertContext=(PCCERT_CONTEXT)pvContext;

                    CryptUIDlgViewCertificate(&CertViewStruct, NULL);
                }
                else
                {
                    memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
                    importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
                    importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT;
                    importSubject.pCertContext=(PCCERT_CONTEXT)pvContext;

                    CryptUIWizImport(0,
                        NULL,
                        NULL,
                        &importSubject,
                        NULL);
                }
            break;

        case CERT_QUERY_CONTENT_CTL:
                if(idCmd==0)
                    I_ViewCTL((PCCTL_CONTEXT)pvContext);
                else
                {
                    //we do not need to install a catalog file
                    if(!IsCatalog((PCCTL_CONTEXT)pvContext))
                    {
                        memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
                        importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
                        importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_CTL_CONTEXT;
                        importSubject.pCTLContext=(PCCTL_CONTEXT)pvContext;

                        CryptUIWizImport(0,
                            NULL,
                            NULL,
                            &importSubject,
                            NULL);
                    }
                }

            break;
        case CERT_QUERY_CONTENT_CRL:
                if(idCmd==0)
                {
                    //call the CRL view dialogue
                    memset(&CRLViewStruct, 0, sizeof(CRYPTUI_VIEWCRL_STRUCT));

                    CRLViewStruct.dwSize=sizeof(CRYPTUI_VIEWCRL_STRUCT);
                    CRLViewStruct.pCRLContext=(PCCRL_CONTEXT)pvContext;

                    CryptUIDlgViewCRL(&CRLViewStruct);
                }
                else
                {
                    memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
                    importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
                    importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_CRL_CONTEXT;
                    importSubject.pCRLContext=(PCCRL_CONTEXT)pvContext;

                    CryptUIWizImport(0,
                        NULL,
                        NULL,
                        &importSubject,
                        NULL);
                }
            break;

        case CERT_QUERY_CONTENT_SERIALIZED_STORE:
                    idsFileName=IDS_SERIALIZED_STORE;

        case CERT_QUERY_CONTENT_SERIALIZED_CERT:
                    if(0 == idsFileName)
                        idsFileName=IDS_SERIALIZED_CERT;

        case CERT_QUERY_CONTENT_SERIALIZED_CTL:
                     if(0 == idsFileName)
                        idsFileName=IDS_SERIALIZED_STL;

       case CERT_QUERY_CONTENT_SERIALIZED_CRL:
                    if(0 == idsFileName)
                        idsFileName=IDS_SERIALIZED_CRL;

                if(!FIsWinNT5())
                {
                    I_NoticeBox(
						0,
                        0,
                        NULL, 
                        IDS_MSG_VALID_TITLE,
                        idsFileName,
                        IDS_MSG_VALID_SIGN_FILE,  
                        MB_OK|MB_ICONINFORMATION);
                }
                else
                {
                    LauchCertMgr(pwszFileName);
                }
            break;

        case CERT_QUERY_CONTENT_PKCS7_SIGNED:
                if(idCmd==0)
                {
                    if(!FIsWinNT5())
                    {
                        I_NoticeBox(
							0,
                            0,
                            NULL, 
                            IDS_MSG_VALID_TITLE,
                            IDS_PKCS7_NAME,
                            IDS_MSG_VALID_SIGN_FILE,  
                            MB_OK|MB_ICONINFORMATION);
                    }
                    else
                    {
                        LauchCertMgr(pwszFileName);
                    }
                }
                else
                {
                    //we are doing the import
                    memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
                    importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
					importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_FILE;
					importSubject.pwszFileName=pwszFileName;

                    CryptUIWizImport(0,
                                    NULL,
                                    NULL,
                                    &importSubject, 
                                    NULL);

                }
            break;


        case CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED:

                    I_NoticeBox(
						0,
                        0,
                        NULL, 
                        IDS_MSG_VALID_TITLE,
                        IDS_SIGN_NAME,
                        IDS_MSG_VALID_SIGN_FILE,  
                        MB_OK|MB_ICONINFORMATION);

            break;

        case CERT_QUERY_CONTENT_PFX:
                memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
                importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
                importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_FILE;
                importSubject.pwszFileName=pwszFileName;

                CryptUIWizImport(0,
                                NULL,
                                NULL,
                                &importSubject,
                                NULL);


            break;

        case CERT_QUERY_CONTENT_PKCS7_UNSIGNED:

                I_NoticeBox(
					0,
                    0,
                    NULL, 
                    IDS_MSG_VALID_TITLE,
                    IDS_PKCS7_UNSIGNED_NAME,
                    IDS_MSG_VALID_FILE,  
                    MB_OK|MB_ICONINFORMATION);

            break;

        case CERT_QUERY_CONTENT_PKCS10:
                I_NoticeBox(
					0,
                    0,
                    NULL, 
                    IDS_MSG_VALID_TITLE,
                    IDS_P10_NAME,
                    IDS_MSG_VALID_FILE,  
                    MB_OK|MB_ICONINFORMATION);

            break;
        default:

            break;
    }


    hr=S_OK;

CLEANUP:


    //relaset the stores and reset the local parameters
    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    if(hMsg)
        CryptMsgClose(hMsg);


    if(pvContext)
    {

        if(dwContentType == CERT_QUERY_CONTENT_CERT ||
            dwContentType == CERT_QUERY_CONTENT_SERIALIZED_CERT)
                CertFreeCertificateContext((PCCERT_CONTEXT)pvContext);
        else
        {
            if(dwContentType == CERT_QUERY_CONTENT_CTL ||
                dwContentType == CERT_QUERY_CONTENT_SERIALIZED_CTL)
                    CertFreeCTLContext((PCCTL_CONTEXT)pvContext);
            else
            {
                if(dwContentType == CERT_QUERY_CONTENT_CRL ||
                        dwContentType == CERT_QUERY_CONTENT_SERIALIZED_CRL)
                            CertFreeCRLContext((PCCRL_CONTEXT)pvContext);
            }
        }
    }

   return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCryptPKO

//--------------------------------------------------------------
//
//  FUNCTION: GAKPageCallback(HWND, UINT, LPPROPSHEETPAGE)
//
//  PURPOSE: Callback  procedure for the property page
//
//  PARAMETERS:
//    hWnd      - Reserved (will always be NULL)
//    uMessage  - Action flag: Are we being created or released
//    ppsp      - The page that is being created or destroyed
//
//  RETURN VALUE:
//
//    Depends on message.
//
//    For PSPCB_CREATE it's TRUE to let the page be created
//    or false to prevent it from being created.
//    For PSPCB_RELEASE the return value is ignored.
//
//  COMMENTS:
//
BOOL CALLBACK
SignPKOPageCallBack(HWND hWnd,
                UINT uMessage,
                void  *pvCallBack)
{
    switch(uMessage)
    {
        case PSPCB_CREATE:
            return TRUE;

        case PSPCB_RELEASE:
            if (pvCallBack)
            {
               ((IShellPropSheetExt *)(pvCallBack))->Release();
            }
            return TRUE;
    }
    return TRUE;
}

//--------------------------------------------------------------
//
//  Constructor
//
//--------------------------------------------------------------
CCryptPKO::CCryptPKO()
{
     m_pDataObj=NULL;
}


//--------------------------------------------------------------
//
//  Destructor
//
//--------------------------------------------------------------
CCryptPKO::~CCryptPKO()
{
    if (m_pDataObj)
        m_pDataObj->Release();
}


//--------------------------------------------------------------
//  FUNCTION: CCryptSig::AddPages(LPFNADDPROPSHEETPAGE, LPARAM)
//
//  PURPOSE: Called by the shell just before the property sheet is displayed.
//
//  PARAMETERS:
//    lpfnAddPage -  Pointer to the Shell's AddPage function
//    lParam      -  Passed as second parameter to lpfnAddPage
//
//  RETURN VALUE:
//
//    NOERROR in all cases.  If for some reason our pages don't get added,
//    the Shell still needs to bring up the Properties... sheet.
//
//  COMMENTS:
//--------------------------------------------------------------


STDMETHODIMP CCryptPKO::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    HPROPSHEETPAGE  hpage;
    PROPSHEETPAGEW  *pPage=NULL;
    DWORD           dwPage=0;
    DWORD           dwIndex=0;

    FORMATETC       fmte = {CF_HDROP,
        	            (DVTARGETDEVICE FAR *)NULL,
        	            DVASPECT_CONTENT,
        	            -1,
        	            TYMED_HGLOBAL
        	            };
    STGMEDIUM       stgm;
    UINT            ucFiles=0;
    WCHAR           wszFileName[_MAX_PATH];
    HCRYPTMSG       hMsg=NULL;
    HRESULT         hr=E_FAIL;
    DWORD           dwExceptionCode=0;

    CRYPTUI_VIEWSIGNATURES_STRUCTW  sigView;

    //get the file name that user clicked on.  We do not add context menu
    //if user has selected more than one file

    if (m_pDataObj)
       hr = m_pDataObj->GetData(&fmte, &stgm);

    if (!SUCCEEDED(hr))
        return  NOERROR;

    ucFiles = stgm.hGlobal ?
        DragQueryFileU((HDROP) stgm.hGlobal, 0xFFFFFFFFL , 0, 0) : 0;

    if  ((!ucFiles) || (ucFiles >= 2))
    {
        ReleaseStgMedium(&stgm);
        return  NOERROR;    //  Shouldn't happen, but it's not important
    }


    if(0==DragQueryFileU((HDROP) stgm.hGlobal, 0, wszFileName,
            sizeof wszFileName/ sizeof wszFileName[0]))
    {
        ReleaseStgMedium(&stgm);
        return NOERROR;
    }


    //get the content type of the file.  We only cares about
    //the signed document in binary format
    if(!CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       wszFileName,
                       CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED,
                       CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       &hMsg,
                       NULL))
    {
        //can not recognize the object.  Fine
        goto CLEANUP;
    }


    //add the property sheet page
    memset(&sigView, 0, sizeof(CRYPTUI_VIEWSIGNATURES_STRUCTW));
    sigView.dwSize=sizeof(CRYPTUI_VIEWSIGNATURES_STRUCTW);
    sigView.choice=hMsg_Chosen;
    sigView.u.hMsg=hMsg;
    sigView.szFileName=wszFileName;
    sigView.pPropPageCallback=SignPKOPageCallBack;
    sigView.pvCallbackData=this;

    if(!CryptUIGetViewSignaturesPagesW(
            &sigView,
            &pPage,
            &dwPage))
        goto CLEANUP;

    __try {
        for(dwIndex=0; dwIndex<dwPage; dwIndex++)
        {

            //add the callback functions to release the refcount
            //pPage[dwIndex].dwFlags |= PSP_USECALLBACK;

            //pPage[dwIndex].pfnCallback=SignPKOPageCallBack;
            //pPage[dwIndex].pcRefParent=(UINT *)this;

            hpage = CreatePropertySheetPageU(&(pPage[dwIndex]));

            ((IShellPropSheetExt *)this)->AddRef();

            if (hpage)
            {
                if (!lpfnAddPage(hpage, lParam))
                {
                    DestroyPropertySheetPage(hpage);
                    ((IShellPropSheetExt *)this)->Release();
                }
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto CLEANUP;
    }




CLEANUP:

    ReleaseStgMedium(&stgm);

    if(pPage)
        CryptUIFreeViewSignaturesPagesW(pPage, dwPage);

    if(hMsg)
        CryptMsgClose(hMsg);


    return NOERROR;
}

//--------------------------------------------------------------

//  FUNCTION: CCryptSig::ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM)
//
//  PURPOSE: Called by the shell only for Control Panel property sheet
//           extensions
//
//  PARAMETERS:
//    uPageID         -  ID of page to be replaced
//    lpfnReplaceWith -  Pointer to the Shell's Replace function
//    lParam          -  Passed as second parameter to lpfnReplaceWith
//
//  RETURN VALUE:
//
//    E_FAIL, since we don't support this function.  It should never be
//    called.

//  COMMENTS:
//--------------------------------------------------------------


STDMETHODIMP CCryptPKO::ReplacePage(UINT uPageID,
                                    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                                    LPARAM lParam)
{
    return E_FAIL;
}

//--------------------------------------------------------------
//  FUNCTION: CCryptPKO::QueryContextMenu(HMENU, UINT, UINT, UINT, UINT)
//
//  PURPOSE: Called by the shell just before the context menu is displayed.
//
//  PARAMETERS:
//    hMenu      - Handle to the context menu
//    indexMenu  - Index of where to begin inserting menu items
//    idCmdFirst - Lowest value for new menu ID's
//    idCmtLast  - Highest value for new menu ID's
//    uFlags     - Specifies the context of the menu event
//
//  RETURN VALUE:
//     We always return NOERROR unless when we succeeded, when
//     we have to return  HRESULT structure in which, if the method
//     is successful, the code member contains the menu identifier
//     offset of the last menu item added plus one.
//--------------------------------------------------------------
STDMETHODIMP CCryptPKO::QueryContextMenu(HMENU hMenu,
                                         UINT indexMenu,
                                         UINT idCmdFirst,
                                         UINT idCmdLast,
                                         UINT uFlags)
{
    DWORD           dwContentType=0;
    DWORD           dwFormatType=0;
    FORMATETC       fmte = {CF_HDROP,
        	            (DVTARGETDEVICE FAR *)NULL,
        	            DVASPECT_CONTENT,
        	            -1,
        	            TYMED_HGLOBAL
        	            };
    STGMEDIUM       stgm;
	HRESULT         hr = E_FAIL;
    UINT            ucFiles=0;
    WCHAR           wszFileName[_MAX_PATH];
    WCHAR           wszOpen[MAX_COMMAND_LENGTH];
    WCHAR           wszAdd[MAX_COMMAND_LENGTH];
    WCHAR           wszViewSig[MAX_COMMAND_LENGTH];
    UINT            idCmd = idCmdFirst;
    UINT            idCmdDefault=idCmdFirst;
    MENUITEMINFOA   MenuItemInfo;
    void            *pContext=NULL;

    //init the menuInfo for setting the default menu
    memset(&MenuItemInfo, 0, sizeof(MENUITEMINFOA));
    MenuItemInfo.cbSize=sizeof(MENUITEMINFOA);
    MenuItemInfo.fMask=MIIM_STATE;
    MenuItemInfo.fState=MFS_DEFAULT;

    //get the file name that user clicked on.  We do not add context menu
    //if user has selected more than one file

    if (m_pDataObj)
       hr = m_pDataObj->GetData(&fmte, &stgm);

    if (!SUCCEEDED(hr))
        return  NOERROR;

    ucFiles = stgm.hGlobal ?
        DragQueryFileU((HDROP) stgm.hGlobal, 0xFFFFFFFFL , 0, 0) : 0;

    if  ((!ucFiles) || (ucFiles >= 2))
        return  NOERROR;    //  Shouldn't happen, but it's not important


    if(0==DragQueryFileU((HDROP) stgm.hGlobal, 0, wszFileName,
            sizeof wszFileName/ sizeof wszFileName[0]))
        return NOERROR;

    //if user double click on a file, we need the take the
    //default action
   /* if(uFlags & CMF_DEFAULTONLY)
    {
        //QueryContextMenu is called twice by the Shell.
        //we have to set the flag.
        if(FALSE==g_fDefaultCalled)
        {

            hr=I_InvokeCommand(pwszFileName, 0, TRUE);
            g_fDefaultCalled=TRUE;
        }
        else
            g_fDefaultCalled=FALSE;

        idCmd=idCmdFirst;

        goto CLEANUP;
    }       */

    //decide if we need to add the context menu
    if (!(
           ((uFlags & 0x000F) == CMF_NORMAL)||
           (uFlags & CMF_VERBSONLY) ||
           (uFlags & CMF_EXPLORE) ||
           (uFlags & CMF_DEFAULTONLY)
         ))
        goto CLEANUP;

    //load the string
    if(!LoadStringU(g_hmodThisDll, IDS_MENU_OPEN, wszOpen, sizeof(wszOpen)/sizeof(wszOpen[0]))||
       !LoadStringU(g_hmodThisDll, IDS_MENU_VIEWSIG, wszViewSig, sizeof(wszViewSig)/sizeof(wszViewSig[0]))
       )
        goto CLEANUP;

    //get the content type of the file
    //we care about every file type and every format type
    if(!CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       wszFileName,
                       CERT_QUERY_CONTENT_FLAG_ALL,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       &dwContentType,
                       &dwFormatType,
                       NULL,
                       NULL,
                       (const void **)&pContext))
    {
                //add the open menu
                if(0==InsertMenuU(hMenu,
                   indexMenu++,
                   MF_STRING|MF_BYPOSITION,
                   idCmd++,
                   wszOpen))
                    goto CLEANUP;

                //  if there is no default verb, set open as default
                if (GetMenuDefaultItem(hMenu, MF_BYPOSITION, 0) == -1)            
                {
                     //  use indexMenu - 1 since we incremented indexMenu in the InsertMenu
                     SetMenuDefaultItem(hMenu, indexMenu -1, MF_BYPOSITION);
                }

                //set the open to be the default menu item
                idCmdDefault=idCmd-1;

                //no need for error checking
               /* SetMenuItemInfoA(hMenu,
                                idCmdDefault,
                                FALSE,
                                &MenuItemInfo);   */

                goto CLEANUP;
    }

    switch (dwContentType)
    {
        case CERT_QUERY_CONTENT_CERT:
        case CERT_QUERY_CONTENT_PKCS7_SIGNED:
                //get the correct wording for the second menu item based
                // on the content
                if(!LoadStringU(g_hmodThisDll, IDS_MENU_INSTALL_CERT, wszAdd, sizeof(wszAdd)/sizeof(wszAdd[0])))
                    goto CLEANUP;

        case CERT_QUERY_CONTENT_CTL:

                if(CERT_QUERY_CONTENT_CTL == dwContentType)
                {
                    if(!LoadStringU(g_hmodThisDll, IDS_MENU_INSTALL_STL, wszAdd, sizeof(wszAdd)/sizeof(wszAdd[0])))
                        goto CLEANUP;
                }

        case CERT_QUERY_CONTENT_CRL:

                if(CERT_QUERY_CONTENT_CRL == dwContentType)
                {
                    if(!LoadStringU(g_hmodThisDll, IDS_MENU_INSTALL_CRL, wszAdd, sizeof(wszAdd)/sizeof(wszAdd[0])))
                        goto CLEANUP;
                }

                //make sure we can add at least two items
                if(2 > (idCmdLast-idCmdFirst))
                    goto CLEANUP;

                //add the open menu
                if(0==InsertMenuU(hMenu,
                   indexMenu++,
                   MF_STRING|MF_BYPOSITION,
                   idCmd++,
                   wszOpen))
                    goto CLEANUP;

                //set the open to be the default menu item
                idCmdDefault=idCmd-1;

                //no need for error checking
                //set the default menu item
                SetMenuItemInfoA(hMenu,
                                idCmdDefault,
                                FALSE,
                                &MenuItemInfo);


                //add the add menu
                //do not put "install" for the catalog files
                if( !((CERT_QUERY_CONTENT_CTL == dwContentType)
                    && IsCatalog((PCCTL_CONTEXT)pContext))
                  )
                {
                    if(0==InsertMenuU(hMenu,
                       indexMenu++,
                       MF_STRING|MF_BYPOSITION,
                       idCmd++,
                       wszAdd))
                        goto CLEANUP;
                }

            break;


        case CERT_QUERY_CONTENT_SERIALIZED_STORE:
        case CERT_QUERY_CONTENT_SERIALIZED_CERT:
        case CERT_QUERY_CONTENT_SERIALIZED_CTL:
        case CERT_QUERY_CONTENT_SERIALIZED_CRL:
                //add the open menu
                if(0==InsertMenuU(hMenu,
                   indexMenu++,
                   MF_STRING|MF_BYPOSITION,
                   idCmd++,
                   wszOpen))
                    goto CLEANUP;

                //set the open to be the default menu item
                idCmdDefault=idCmd-1;

                //no need for error checking
                SetMenuItemInfoA(hMenu,
                                idCmdDefault,
                                FALSE,
                                &MenuItemInfo);

           break;

        case  CERT_QUERY_CONTENT_PFX:
               if(!LoadStringU(g_hmodThisDll, IDS_MENU_INSTALL_PFX, wszAdd, sizeof(wszAdd)/sizeof(wszAdd[0])))
                        goto CLEANUP;

                //add the install menu
                if(0==InsertMenuU(hMenu,
                   indexMenu++,
                   MF_STRING|MF_BYPOSITION,
                   idCmd++,
                   wszAdd))
                    goto CLEANUP;

                //set the add to be the default menu item
                idCmdDefault=idCmd-1;

                //no need for error checking
                SetMenuItemInfoA(hMenu,
                                idCmdDefault,
                                FALSE,
                                &MenuItemInfo);


            break;


        case CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED:
                //signed data case is handled by the property sheet extension
        default:
            //we do not worry about CERT_QUERY_CONTENT_PKCS7_UNSIGNED or
            //CERT_QUERY_CONTENT_PKCS10 or CERT_QUERY_CONTENT_PFX for now
            //add the open menu
                if(0==InsertMenuU(hMenu,
                   indexMenu++,
                   MF_STRING|MF_BYPOSITION,
                   idCmd++,
                   wszOpen))
                    goto CLEANUP;

                //set the open to be the default menu item
                idCmdDefault=idCmd-1;

                //  if there is no default verb, set open as default
                if (GetMenuDefaultItem(hMenu, MF_BYPOSITION, 0) == -1)            
                {
                     //  use indexMenu - 1 since we incremented indexMenu in the InsertMenu
                     SetMenuDefaultItem(hMenu, indexMenu -1, MF_BYPOSITION);
                }

            break;
    }


CLEANUP:

    if(idCmd-idCmdFirst)
    {
        //Must return number of menu items we added.
        hr=ResultFromShort(idCmd-idCmdFirst);
    }
    else
        //do not care if error happens.  No menu items have been added
        hr=NOERROR;

    if(pContext)
    {

        if(dwContentType == CERT_QUERY_CONTENT_CERT ||
            dwContentType == CERT_QUERY_CONTENT_SERIALIZED_CERT)
                CertFreeCertificateContext((PCCERT_CONTEXT)pContext);
        else
        {
            if(dwContentType == CERT_QUERY_CONTENT_CTL ||
                dwContentType == CERT_QUERY_CONTENT_SERIALIZED_CTL)
                    CertFreeCTLContext((PCCTL_CONTEXT)pContext);
            else
            {
                if(dwContentType == CERT_QUERY_CONTENT_CRL ||
                        dwContentType == CERT_QUERY_CONTENT_SERIALIZED_CRL)
                            CertFreeCRLContext((PCCRL_CONTEXT)pContext);
            }
        }
    }


   return hr;
}

//--------------------------------------------------------------
//  FUNCTION: CCryptPKO::InvokeCommand(LPCMINVOKECOMMANDINFO)
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//    lpcmi - Pointer to an CMINVOKECOMMANDINFO structure
//
//  RETURN VALUE:
//
//--------------------------------------------------------------
STDMETHODIMP CCryptPKO::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi)
{


    FORMATETC       fmte = {CF_HDROP,
        	            (DVTARGETDEVICE FAR *)NULL,
        	            DVASPECT_CONTENT,
        	            -1,
        	            TYMED_HGLOBAL
        	            };
    STGMEDIUM       stgm;
	HRESULT         hr = E_FAIL;
    UINT            ucFiles=0;
    WCHAR           wszFileName[_MAX_PATH];
    UINT            idCmd=0;


    //get the file name that user clicked on.  We do not add context menu
    //if user has selected more than one file

    if (m_pDataObj)
       hr = m_pDataObj->GetData(&fmte, &stgm);

    if (!SUCCEEDED(hr))
        return  hr;

    //get the number of files that user clicked on
    ucFiles = stgm.hGlobal ?
        DragQueryFileU((HDROP) stgm.hGlobal, 0xFFFFFFFFL , 0, 0) : 0;

    if  ((!ucFiles) || (ucFiles >= 2))
        return  E_INVALIDARG;    //  Shouldn't happen, but it's not important


    if(0==DragQueryFileU((HDROP) stgm.hGlobal, 0, wszFileName,
            sizeof wszFileName/ sizeof wszFileName[0]))
        return E_FAIL;

    //get the offset of the command item that was selected by the user
    //If HIWORD(lpcmi->lpVerb) then we have been called programmatically
    //and lpVerb is a command that should be invoked.  Otherwise, the shell
    //has called us, and LOWORD(lpcmi->lpVerb) is the menu ID the user has
    //selected.  Actually, it's (menu ID - idCmdFirst) from QueryContextMenu().
    if (HIWORD((DWORD_PTR)lpcmi->lpVerb))
    {
        hr=E_INVALIDARG;
        goto CLEANUP;
    }
    else
        idCmd = LOWORD(lpcmi->lpVerb);

    //exit if idCmd is not 0 or 1
    if(idCmd >= 2)
    {
        hr=E_INVALIDARG;
        goto CLEANUP;
    }

    hr=I_InvokeCommand(wszFileName, idCmd, FALSE);

CLEANUP:

   return hr;
}


//--------------------------------------------------------------
//  FUNCTION: CCryptPKO::GetCommandString
//
//--------------------------------------------------------------
void    CopyBuffer(UINT uFlags, LPSTR   pszName, UINT   cchMax, LPWSTR  wszString)
{
    UINT    cbSize=0;
    LPSTR   szString=NULL;
    LPWSTR  pwszName=NULL;

    if(uFlags == GCS_HELPTEXTW)
    {
        pwszName=(LPWSTR)pszName;

        cbSize=wcslen(wszString)+1;

        if(cbSize <= cchMax)
            wcsncpy(pwszName, wszString,cbSize);
        else
        {
            wcsncpy(pwszName, wszString, cchMax-1);
            *(pwszName+cchMax-1)=L'\0';
        } 

    }
    else
    {
       if((wszString!=NULL) && MkMBStr(NULL, 0, wszString, &szString))
       {

            cbSize=strlen(szString)+1;

            if(cbSize <= cchMax)
                strncpy(pszName, szString,cbSize);
            else
            {
                strncpy(pszName, szString, cchMax-1);
                *(pszName+cchMax-1)='\0';
            } 
       }

       if(szString)
            FreeMBStr(NULL, szString);

    }
}


//--------------------------------------------------------------
//  FUNCTION: CCryptPKO::GetCommandString
//
//--------------------------------------------------------------
STDMETHODIMP CCryptPKO::GetCommandString(UINT_PTR idCmd,
                                         UINT uFlags,
                                         UINT FAR *reserved,
                                         LPSTR pszName,
                                         UINT cchMax)
{
    DWORD           dwContentType=0;
    DWORD           dwFormatType=0;
    FORMATETC       fmte = {CF_HDROP,
        	            (DVTARGETDEVICE FAR *)NULL,
        	            DVASPECT_CONTENT,
        	            -1,
        	            TYMED_HGLOBAL
        	            };
    STGMEDIUM       stgm;
	HRESULT         hr = E_FAIL;
    UINT            ucFiles=0;

    WCHAR           wszFileName[_MAX_PATH];

    WCHAR           wszOpenString[MAX_COMMAND_LENGTH];
    WCHAR           wszAddString[MAX_COMMAND_LENGTH];


    if(uFlags!=GCS_HELPTEXTA && uFlags != GCS_HELPTEXTW)
        return E_INVALIDARG;
                                
    if( 0 == cchMax)
        return E_INVALIDARG;

    //init
    if(uFlags==GCS_HELPTEXTA)
        *pszName='\0';
    else
        *((LPWSTR)pszName)=L'\0';

    //get the file name that user clicked on.  We do not add context menu
    //if user has selected more than one file

    if (m_pDataObj)
       hr = m_pDataObj->GetData(&fmte, &stgm);

    if (!SUCCEEDED(hr))
        return  hr;

    //get the number of files that user clicked on
    ucFiles = stgm.hGlobal ?
        DragQueryFileU((HDROP) stgm.hGlobal, 0xFFFFFFFFL , 0, 0) : 0;

    if  ((!ucFiles) || (ucFiles >= 2))
        return  E_INVALIDARG;    //  Shouldn't happen, but it's not important


    if(0==DragQueryFileU((HDROP) stgm.hGlobal, 0, wszFileName,
            sizeof wszFileName/ sizeof wszFileName[0]))
        return E_FAIL;

    //exit if idCmd is not 0 or 1
    if(idCmd >= 2)
    {
        hr=E_INVALIDARG;
        goto CLEANUP;
    }

    //load the string
    if(!LoadStringU(g_hmodThisDll, IDS_HELP_OPEN, wszOpenString, sizeof(wszOpenString)/sizeof(wszOpenString[0])))
    {
        hr=E_FAIL;
        goto CLEANUP;
    }


    //get the content type of the file
    //we care about every file type except for the signed doc
    if(!CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       wszFileName,
                       CERT_QUERY_CONTENT_FLAG_ALL,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       &dwContentType,
                       &dwFormatType,
                       NULL,
                       NULL,
                       NULL))
    {
        //can not recognize the object.  Fine
        hr=E_FAIL;
        goto CLEANUP;
    }

        //make sure idCmd is the correct valud for different types
    //we are guaranteed that idCmd is 1 or 0
    if(CERT_QUERY_CONTENT_CERT != dwContentType &&
       CERT_QUERY_CONTENT_CTL  != dwContentType &&
       CERT_QUERY_CONTENT_CRL  != dwContentType &&
       CERT_QUERY_CONTENT_PKCS7_SIGNED != dwContentType)
    {
        if(1==idCmd)
        {
            hr=E_INVALIDARG;
            goto CLEANUP;
        }
    }


    switch (dwContentType)
    {
        case CERT_QUERY_CONTENT_CERT:
        case CERT_QUERY_CONTENT_PKCS7_SIGNED:
               if(!LoadStringU(g_hmodThisDll, IDS_HELP_INSTALL_CERT, wszAddString, sizeof(wszAddString)/sizeof(wszAddString[0])))
               {
                   hr=E_FAIL;
                   goto CLEANUP;
               }


        case CERT_QUERY_CONTENT_CTL:

                if(CERT_QUERY_CONTENT_CTL == dwContentType)
                {
                    if(!LoadStringU(g_hmodThisDll, IDS_HELP_INSTALL_STL, wszAddString, sizeof(wszAddString)/sizeof(wszAddString[0])))
                    {
                        hr=E_FAIL;
                        goto CLEANUP;
                    }
                }


        case CERT_QUERY_CONTENT_CRL:

                if(CERT_QUERY_CONTENT_CRL == dwContentType)
                {
                    if(!LoadStringU(g_hmodThisDll, IDS_HELP_INSTALL_CRL, wszAddString, sizeof(wszAddString)/sizeof(wszAddString[0])))
                    {
                        hr=E_FAIL;
                        goto CLEANUP;
                    }
                }


                //helper string for Open
                if(idCmd==0)
                {
                    CopyBuffer(uFlags, pszName, cchMax, wszOpenString);
                }

                //helper string for add
                if(idCmd==1)
                {
                    CopyBuffer(uFlags, pszName, cchMax, wszAddString);
                }

            break;

        case CERT_QUERY_CONTENT_SERIALIZED_STORE:
        case CERT_QUERY_CONTENT_SERIALIZED_CERT:
        case CERT_QUERY_CONTENT_SERIALIZED_CTL:
        case CERT_QUERY_CONTENT_SERIALIZED_CRL:
                //helper string for Open   

                CopyBuffer(uFlags, pszName, cchMax, wszOpenString);


           break;


        case CERT_QUERY_CONTENT_PFX:
                if(!LoadStringU(g_hmodThisDll, IDS_HELP_INSTALL_PFX, wszAddString, sizeof(wszAddString)/sizeof(wszAddString[0])))
                {
                    hr=E_FAIL;
                    goto CLEANUP;
                }

                CopyBuffer(uFlags, pszName, cchMax, wszAddString);


            break;
        case CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED:
        default:
                CopyBuffer(uFlags, pszName, cchMax, wszOpenString);

            break;
    }

    hr=NOERROR;

CLEANUP:

   return hr;
}

//--------------------------------------------------------------
//  FUNCTION: CCryptPKO::Initialize(LPCITEMIDLIST, LPDATAOBJECT, HKEY)
//
//  PURPOSE: Called by the shell when initializing a context menu or property
//           sheet extension.
//
//  PARAMETERS:
//    pIDFolder - Specifies the parent folder
//    pDataObj  - Spefifies the set of items selected in that folder.
//    hRegKey   - Specifies the type of the focused item in the selection.
//
//  RETURN VALUE:
//
//    NOERROR in all cases.
//--------------------------------------------------------------
STDMETHODIMP CCryptPKO::Initialize(LPCITEMIDLIST pIDFolder,
                                   LPDATAOBJECT pDataObj,
                                   HKEY hRegKey)
{
    // Initialize can be called more than once

  if (m_pDataObj)
    	m_pDataObj->Release();

    // duplicate the object pointer and registry handle
    if (pDataObj)
    {
    	m_pDataObj = pDataObj;
    	pDataObj->AddRef();
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptext\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptext\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cryptext.rc
//
#define IDS_PROJNAME                    100
#define IDR_CRYPTPKO                    101
#define IDR_CRYPTSIG                    102


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif

//The strings 
//
#define         IDS_MENU_OPEN                   6100
#define         IDS_HELP_OPEN                   6101
#define         IDS_MENU_VIEWSIG                6104
#define         IDS_HELP_VIEWSIG                6105
#define         IDS_MSG_TITLE                   6106
#define         IDS_MSG_INVALID_FILE            6107
#define         IDS_CER_NAME                    6108
#define         IDS_STL_NAME                    6109
#define         IDS_CRL_NAME                    6110
#define         IDS_SPC_NAME                    6111
#define         IDS_SST_NAME                    6112
#define         IDS_P7S_NAME                    6113
#define         IDS_P7B_NAME                    6114
#define         IDS_P7M_NAME                    6115
#define         IDS_P10_NAME                    6116
#define         IDS_PKCS7_NAME                  6117
#define         IDS_PKO_NAME                    6118
#define         IDS_ADD                         6119
#define         IDS_PKO_EXT                     6120
#define         IDS_MMC_PARAM                   6121
#define         IDS_PKCS7_UNSIGNED_NAME         6122
#define         IDS_MSG_VALID_TITLE             6123
#define         IDS_MSG_VALID_FILE              6124
#define         IDS_SIGN_EXT                    6125
#define         IDS_MENU_INSTALL_CERT           6126
#define         IDS_HELP_INSTALL_CERT           6127
#define         IDS_MENU_INSTALL_CRL            6128
#define         IDS_HELP_INSTALL_CRL            6129
#define         IDS_MENU_INSTALL_STL            6130
#define         IDS_HELP_INSTALL_STL            6131 
#define         IDS_INSTALL_CERT                6132
#define         IDS_INSTALL_STL                 6133
#define         IDS_INSTALL_CRL                 6134
#define         IDS_INVALID_INFO_FOR_PKCS10     6135
#define         IDS_INVALID_PVK_FOR_PKCS10      6136     
#define         IDS_P7R_NAME                    6140
#define         IDS_NO_XENROLL                  6141
#define         IDS_INVALID_P7R_FILE            6142
#define         IDS_INSTALL_CERT_SUCCEEDED      6143
#define         IDS_FAIL_TO_INSTALL             6144
#define         IDS_CAT_NAME                    6145
#define         IDS_MSG_VALID_SIGN_FILE         6146
#define         IDS_MENU_INSTALL_PFX            6147
#define         IDS_PFX_NAME                    6148
#define         IDS_SIGN_NAME                   6149
#define         IDS_HELP_INSTALL_PFX            6150
#define         IDS_SERIALIZED_STORE            6151
#define         IDS_SERIALIZED_CERT             6152
#define         IDS_SERIALIZED_STL              6153
#define         IDS_SERIALIZED_CRL              6154
#define         IDS_OLD_P7C_NAME                6155
#define         IDS_OLD_CTL_NAME                6156 
#define         IDS_OLD_STR_NAME                6166
#define         IDS_ACCESS_DENIED               6167
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptext\private.h ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       private.h
//
//  Contents:   The private include file for cryptext.dll.
//
//  History:    16-09-1997 xiaohs   created
//
//--------------------------------------------------------------
#ifndef PRIVATE_H
#define PRIVATE_H

#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#include <string.h>
#include <winreg.h>
#include <objbase.h>
#include "stdio.h"


#include "wincrypt.h"
#include "wintrust.h"
#include "sipbase.h"
#include "mssip.h"
#include "unicode.h" 
#include "crtem.h"
#include "cryptui.h"
#include "mscat.h"


#include "resource.h"


//Macro to convert a short to a HRESULT
#define ResultFromShort(i)  ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, 0, (USHORT)(i)))

//global data
extern HINSTANCE g_hmodThisDll;

#define MAX_STRING_SIZE             256
#define MAX_COMMAND_LENGTH          40
#define MAX_TITLE_LENGTH            60
#define MAX_FILE_NAME_LENGTH        60


#define MMC_NAME                    L"mmc.exe"
#define CERTMGR_MSC                 L"\\certmgr.msc"



//function prototypes
HRESULT UnregisterMimeHandler();
HRESULT RegisterMimeHandler();
BOOL    PKCS7WithSignature(HCRYPTMSG    hMsg);
void    I_ViewCTL(PCCTL_CONTEXT pCTLContext);
//void    I_ViewSignerInfo(HCRYPTMSG  hMsg);
HRESULT RetrieveBLOBFromFile(LPWSTR	pwszFileName,DWORD *pcb,BYTE **ppb);  
int     I_MessageBox(
            HWND        hWnd, 
            UINT        idsText,
            UINT        idsCaption,
            LPCWSTR     pwszCaption,  
            UINT        uType);

int     I_NoticeBox(
			DWORD		dwError,
            DWORD       dwFlags,
            HWND        hWnd, 
            UINT        idsTitle,
            UINT        idsFileName,
            UINT        idsMsgFormat,  
            UINT        uType);


BOOL    IsCatalog(PCCTL_CONTEXT pCTLContext);

void    LauchCertMgr(LPWSTR pwszFileName);


//typpe define
typedef  struct _MIME_REG_ENTRY{
    LPWSTR  wszKey;
    LPWSTR  wszName;
    UINT    idsName;
}MIME_REG_ENTRY;

typedef  struct _WIN95_REG_ENTRY{
    LPSTR  szKey;
    LPSTR  szName;
}WIN95_REG_ENTRY;



typedef struct _MIME_GUID_ENTRY{
    const CLSID   *pGuid;
    LPWSTR  wszKey1;
    LPWSTR  wszKey2;
    LPWSTR  wszKey3;
    UINT    idsName;
}MIME_GUID_ENTRY;


#endif  //PRIVATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\catalog.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       catalog.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_CATALOG_ENTRY_LIST,        IDH_CATALOG_ENTRY_LIST},
    {IDC_CATALOG_ENTRY_DETAIL_LIST, IDH_CATALOG_ENTRY_DETAILS},
    {IDC_CATALOG_ENTRY_DETAIL_EDIT, IDH_CATALOG_ENTRY_DETAIL_DISPLAY}
};


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
#define INDENT_STRING       L"     "
#define TERMINATING_CHAR    L""

static void DisplayCatalogEntryValues(HWND hWndListView, PCTL_ENTRY pctlEntry)
{
    LPWSTR                      pwszText;
    WCHAR                       szFieldText[_MAX_PATH];  // only used for calls to LoadString only
    WCHAR                       szValueText[CRYPTUI_MAX_STRING_SIZE];
    LV_ITEMW                    lvI;
    int                         index = 0;
    BYTE                        hash[20];
    DWORD                       hashSize = ARRAYSIZE(hash);
    BOOL                        fAddRows;
    DWORD                       i;
    SPC_INDIRECT_DATA_CONTENT   *pIndirectData;
    DWORD                       cbIndirectData;
    CAT_NAMEVALUE               *pNameValue;
    DWORD                       cbNameValue;

#if (1) //DSIE: Bug 477237.
     ListView_DeleteAllItems(hWndListView);
#endif

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    memset(&lvI, 0, sizeof(lvI));
    lvI.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
    lvI.lParam = NULL;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.iSubItem = 0;

    //
    // if the rows have already been added, then don't add them again, just
    // set the text in the subitem
    //
    fAddRows = ListView_GetItemCount(hWndListView) == 0;

    //
    // tag
    //
    if (NULL != (pwszText = (LPWSTR) malloc(pctlEntry->SubjectIdentifier.cbData)))
    {
#if (0) // DSIE: Bug 331214.
        wcscpy(pwszText, (LPWSTR) pctlEntry->SubjectIdentifier.pbData);
#else
        memcpy(pwszText, pctlEntry->SubjectIdentifier.pbData, pctlEntry->SubjectIdentifier.cbData);
#endif
        LoadStringU(HinstDll, IDS_TAG, szFieldText, ARRAYSIZE(szFieldText));
        lvI.iItem = index++;
        lvI.pszText = szFieldText;
        lvI.cchTextMax = wcslen(szFieldText);

        ModifyOrInsertRow(
                    hWndListView,
                    &lvI,
                    pwszText,
                    pwszText,
                    fAddRows,
                    FALSE);
    }

    //
    // indirect data attribute
    //
    for (i=0; i<pctlEntry->cAttribute; i++)
    {
        if (strcmp(pctlEntry->rgAttribute[i].pszObjId, SPC_INDIRECT_DATA_OBJID) != 0)
        {
            continue;
        }

        pIndirectData = NULL;
        cbIndirectData = 0;

        //
        // decode the indirect data
        //
        if (!CryptDecodeObject(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    SPC_INDIRECT_DATA_CONTENT_STRUCT,
                    pctlEntry->rgAttribute[i].rgValue[0].pbData,
                    pctlEntry->rgAttribute[i].rgValue[0].cbData,
                    0,
                    NULL,
                    &cbIndirectData))
        {
            continue;
        }

        if (NULL == (pIndirectData = (SPC_INDIRECT_DATA_CONTENT *) malloc(cbIndirectData)))
        {
            continue;
        }

        if (!CryptDecodeObject(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    SPC_INDIRECT_DATA_CONTENT_STRUCT,
                    pctlEntry->rgAttribute[i].rgValue[0].pbData,
                    pctlEntry->rgAttribute[i].rgValue[0].cbData,
                    0,
                    pIndirectData,
                    &cbIndirectData))
        {
            free(pIndirectData);
            continue;
        }

        //
        // thumbprint algorithm
        //
        if (MyGetOIDInfo(szValueText, ARRAYSIZE(szValueText), pIndirectData->DigestAlgorithm.pszObjId) &&
            (NULL != (pwszText = AllocAndCopyWStr(szValueText))))
        {
            LoadStringU(HinstDll, IDS_THUMBPRINT_ALGORITHM, szFieldText, ARRAYSIZE(szFieldText));
            lvI.pszText = szFieldText;
            lvI.cchTextMax = wcslen(szFieldText);
            lvI.iItem = index++;

            ModifyOrInsertRow(
                    hWndListView,
                    &lvI,
                    pwszText,
                    pwszText,
                    fAddRows,
                    FALSE);
        }

        //
        // thumbprint
        //
        if (FormatMemBufToString(
                        &pwszText,
                        pIndirectData->Digest.pbData,
                        pIndirectData->Digest.cbData))
        {
            LoadStringU(HinstDll, IDS_THUMBPRINT, szFieldText, ARRAYSIZE(szFieldText));
            lvI.iItem = index++;
            lvI.pszText = szFieldText;
            lvI.cchTextMax = wcslen(szFieldText);

            ModifyOrInsertRow(
                        hWndListView,
                        &lvI,
                        pwszText,
                        pwszText,
                        fAddRows,
                        TRUE);
        }

        free(pIndirectData);
    }

    //
    // name/value pair attributes
    //
    for (i=0; i<pctlEntry->cAttribute; i++)
    {
        if (strcmp(pctlEntry->rgAttribute[i].pszObjId, CAT_NAMEVALUE_OBJID) != 0)
        {
            continue;
        }

        pNameValue = NULL;
        cbNameValue = 0;

        //
        // decode the name/value
        //
        if (!CryptDecodeObject(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    CAT_NAMEVALUE_STRUCT,
                    pctlEntry->rgAttribute[i].rgValue[0].pbData,
                    pctlEntry->rgAttribute[i].rgValue[0].cbData,
                    0,
                    NULL,
                    &cbNameValue))
        {
            continue;
        }

        if (NULL == (pNameValue = (CAT_NAMEVALUE *) malloc(cbNameValue)))
        {
            continue;
        }

        if (!CryptDecodeObject(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    CAT_NAMEVALUE_STRUCT,
                    pctlEntry->rgAttribute[i].rgValue[0].pbData,
                    pctlEntry->rgAttribute[i].rgValue[0].cbData,
                    0,
                    pNameValue,
                    &cbNameValue))
        {
            free(pNameValue);
            continue;
        }

        if (NULL != (pwszText = (LPWSTR) malloc(pNameValue->Value.cbData)))
        {
#if (0) // DSIE: Bug 331214.
            wcscpy(pwszText, (LPWSTR) pNameValue->Value.pbData);
#else
            memcpy(pwszText, pNameValue->Value.pbData, pNameValue->Value.cbData);
#endif
            lvI.pszText = pNameValue->pwszTag;
            lvI.cchTextMax = wcslen(lvI.pszText);
            lvI.iItem = index++;

            ModifyOrInsertRow(
                    hWndListView,
                    &lvI,
                    pwszText,
                    pwszText,
                    fAddRows,
                    FALSE);
        }

        free(pNameValue);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void AddEntriesToList(HWND hWndListView, CTL_VIEW_HELPER *pviewhelp)
{
    LV_ITEMW        lvI;
    DWORD           i;
    int             index = 0;
    PCCTL_CONTEXT   pctl;

    pctl = pviewhelp->pcvctl->pCTLContext;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.iSubItem = 0;
    lvI.lParam = (LPARAM)NULL;

    //
    // loop for each entry and add it to the list
    //
    for (i=0; i<pctl->pCtlInfo->cCTLEntry; i++)
    {
        lvI.iItem = index++;
#if (0) // DSIE: Bug 331214.
        lvI.pszText = (LPWSTR) pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.pbData;
        lvI.cchTextMax = pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.cbData - sizeof(WCHAR);
        ListView_InsertItemU(hWndListView, &lvI);
#else
        // Need to align data because this can generate alignment fault under ia64.
        WCHAR * pwszText = (WCHAR *) malloc(pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.cbData);
        if (pwszText)
        {
            memcpy(pwszText, 
                   pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.pbData,
                   pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.cbData);
            lvI.pszText = pwszText;
            lvI.cchTextMax = pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.cbData - sizeof(WCHAR);
            ListView_InsertItemU(hWndListView, &lvI);
            free(pwszText);
        }
#endif
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageCatalogEntries(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD               i;
    PROPSHEETPAGE       *ps;
    PCCTL_CONTEXT       pctl;
    CTL_VIEW_HELPER     *pviewhelp;
    HWND                hWndListView;
    HWND                hwnd;
    LV_COLUMNW          lvC;
    WCHAR               szText[1024];
    WCHAR               szCompareText[CRYPTUI_MAX_STRING_SIZE];
    PCTL_INFO           pCtlInfo;
    PCCERT_CONTEXT      pCertContext;
    LPWSTR              pwszText;
    int                 listIndex;
    LVITEMW             lvI;
    LPNMLISTVIEW        pnmv;
    NMLISTVIEW          nmv;


    switch ( msg ) {
    case WM_INITDIALOG:
        //
        // save the pviewhelp struct in DWL_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (CTL_VIEW_HELPER *) (ps->lParam);
        pctl = pviewhelp->pcvctl->pCTLContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);

        pviewhelp->previousSelection = -1;
        pviewhelp->currentSelection = -1;

        //
        // clear the text in the detail edit box
        //
        CryptUISetRicheditTextW(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_EDIT, L"");

        //
        // initialize the columns in the list view
        //
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.pszText = szText;   // The text for the column.

        //
		// Add the columns. They are loaded from a string table.
		//
        lvC.iSubItem = 0;
        lvC.cx = 345;
        LoadStringU(HinstDll, IDS_TAG, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_LIST), 0, &lvC) == -1)
        {
            return FALSE;
        }

        lvC.iSubItem = 0;
        lvC.cx = 121;
        LoadStringU(HinstDll, IDS_FIELD, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST), 0, &lvC) == -1)
        {
            return FALSE;
        }

        lvC.cx = 200;
        LoadStringU(HinstDll, IDS_VALUE, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST), 1, &lvC) == -1)
        {
            return FALSE;
        }

        //
        // set the styles in the list views so that they highlight an entire line and
        // so they alway show their selection
        //
        SendDlgItemMessageA(
                hwndDlg,
                IDC_CATALOG_ENTRY_LIST,
                LVM_SETEXTENDEDLISTVIEWSTYLE,
                0,
                LVS_EX_FULLROWSELECT);
        SendDlgItemMessageA(
                hwndDlg,
                IDC_CATALOG_ENTRY_DETAIL_LIST,
                LVM_SETEXTENDEDLISTVIEWSTYLE,
                0,
                LVS_EX_FULLROWSELECT);

        //
        // add all the certificates to the certificate list box
        //
        AddEntriesToList(GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_LIST), pviewhelp);

        return TRUE;

    case WM_NOTIFY:

        pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pctl = pviewhelp->pcvctl->pCTLContext;
        pCtlInfo = pctl->pCtlInfo;

        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_HELP:

            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvctl->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvctl->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvctl->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvctl->dwHelpId);
            }
            return TRUE;

        case LVN_ITEMCHANGING:

            pnmv = (LPNMLISTVIEW) lParam;

            switch(((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_CATALOG_ENTRY_DETAIL_LIST:

                hWndListView = GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST);

                if (pnmv->uNewState & LVIS_SELECTED)
                {
                    pviewhelp->currentSelection = pnmv->iItem;

                    DisplayHelperTextInEdit(
                            GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST),
                            hwndDlg,
                            IDC_CATALOG_ENTRY_DETAIL_EDIT,
                            pnmv->iItem);
                }

                break;

            case IDC_CATALOG_ENTRY_LIST:
                if (pnmv->uNewState & LVIS_SELECTED)
                {
                    hWndListView = GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_LIST);

                    DisplayCatalogEntryValues(
                            GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST),
                            &(pctl->pCtlInfo->rgCTLEntry[pnmv->iItem]));
                    //
                    // clear the text in the detail edit box
                    //
                    CryptUISetRicheditTextW(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_EDIT, L"");

                    DisplayHelperTextInEdit(
                            GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST),
                            hwndDlg,
                            IDC_CATALOG_ENTRY_DETAIL_EDIT,
                            pviewhelp->currentSelection);
                }

                break;
            }

            return TRUE;

        case NM_CLICK:

            pnmv = (LPNMLISTVIEW) lParam;

            switch (((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_CATALOG_ENTRY_LIST:

                // FALL THROUGH!! - do this so everything gets updated
                // break;

            case IDC_CATALOG_ENTRY_DETAIL_LIST:

                ListView_SetItemState(
                            GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST),
                            pviewhelp->currentSelection,
                            LVIS_SELECTED | LVIS_FOCUSED,
                            LVIS_SELECTED | LVIS_FOCUSED);

                DisplayHelperTextInEdit(
                        GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST),
                        hwndDlg,
                        IDC_CATALOG_ENTRY_DETAIL_EDIT,
                        pviewhelp->currentSelection);

                break;
            }

            break;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_CATALOG_ENTRY_LIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_LIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED;
                    lvI.stateMask = LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;

            case IDC_CATALOG_ENTRY_DETAIL_LIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE;
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED;
                    lvI.stateMask = LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;

            }
            
            break;


        }

        break;

    case WM_DESTROY:
            //
            // get all the items in the list view and free the lParam
            // associated with each of them (lParam is the helper sruct)
            //
            hWndListView = GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST);

            memset(&lvI, 0, sizeof(lvI));
            lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
            lvI.mask = LVIF_PARAM;
            while (lvI.iItem >= 0)
            {
                if (ListView_GetItemU(hWndListView, &lvI))
                {
                    FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvI.lParam);
                }
                lvI.iItem--;
            }
            break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_LIST))           &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_LIST))    &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CATALOG_ENTRY_DETAIL_EDIT)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\ccertbmp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ccertbmp.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#define SELPALMODE  TRUE


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
CCertificateBmp::CCertificateBmp()
{
	m_fInitialized = FALSE;
	m_hpal = NULL;
    m_hbmpMiniCertOK = NULL;
    m_hbmpMiniCertNotOK = NULL;
    m_hbmbMiniCertExclamation = NULL;
    m_hbmbPKey = NULL;
    m_hWnd = NULL;
    m_hInst = NULL;
    m_pCertContext = NULL;
    m_dwChainError = 0;
    m_hWindowTextColorBrush = NULL;
    m_hWindowColorBrush = NULL;
    m_h3DLight = NULL;
    m_h3DHighLight = NULL;
    m_h3DLightShadow = NULL;
    m_h3DDarkShadow = NULL;
    m_fNoUsages = FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
CCertificateBmp::~CCertificateBmp()
{
	if (m_hpal != NULL)
	{
		::DeleteObject(m_hpal);
	}

    if (m_hbmpMiniCertOK != NULL)
    {
        ::DeleteObject(m_hbmpMiniCertOK);
    }

    if (m_hbmpMiniCertNotOK != NULL)
    {
        ::DeleteObject(m_hbmpMiniCertNotOK);
    }

    if (m_hbmbMiniCertExclamation != NULL)
    {
        ::DeleteObject(m_hbmbMiniCertExclamation);
    }

    if (m_hbmbPKey != NULL)
    {
        ::DeleteObject(m_hbmbPKey);
    }
}   


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
/*BOOL CCertificateBmp::IsTrueErrorString(DWORD dwError)
{
    BOOL fRet;

    switch (dwError)
    {
    case CERT_E_CHAINING:
    case TRUST_E_BASIC_CONSTRAINTS:
    case CERT_E_PURPOSE:
    case CERT_E_WRONG_USAGE:
        fRet = FALSE;
        break;

    default:
        fRet = TRUE;
        break;
    }
    
    return fRet;
}*/


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::SetChainError(DWORD dwError, BOOL fTrueError, BOOL fNoUsages)
{
    m_dwChainError = dwError;
    m_fTrueError = fTrueError; //IsTrueErrorString(dwError);
    m_fNoUsages = fNoUsages;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::SetHinst(HINSTANCE hInst)
{
    m_hInst = hInst;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
HINSTANCE CCertificateBmp::Hinst()
{
    return m_hInst;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::SetWindow(HWND hWnd)
{
    m_hWnd = hWnd;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
HWND CCertificateBmp::GetMyWindow()
{
    return m_hWnd;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
LRESULT APIENTRY CCertificateBmpProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{ 
    CCertificateBmp* This = (CCertificateBmp*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_PAINT:
        CallWindowProc((WNDPROC)(This->m_prevProc), hwnd, uMsg, wParam, lParam);
        This->OnPaint();
        break;

    default:
        return CallWindowProc((WNDPROC)(This->m_prevProc), hwnd, uMsg, wParam, lParam); 
    }
    
    return 0;
} 


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::DoSubclass()
{
    SetWindowLongPtr(GetMyWindow(), GWLP_USERDATA, (LONG_PTR)this);

    //
    // hook the window proc so we can get first stab at the messages
    //
    m_prevProc = (WNDPROC)SetWindowLongPtr(GetMyWindow(), GWLP_WNDPROC, (LONG_PTR)CCertificateBmpProc);
    
    //
    // Set 'no class cursor' so that SetCursor will work.
    //
    m_hPrevCursor = (HCURSOR)SetClassLongPtr(GetMyWindow(), GCLP_HCURSOR, NULL);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::DoUnSubclass()
{
    if (m_prevProc)
    {
        SetWindowLongPtr(GetMyWindow(), GWLP_WNDPROC, (LONG_PTR)m_prevProc);
        SetWindowLongPtr(GetMyWindow(), GCLP_HCURSOR, (LONG_PTR)m_hPrevCursor);
        m_prevProc = NULL;
    }
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::SetRevoked(BOOL fRevoked)
{
    m_fRevoked = fRevoked;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////    
BOOL CCertificateBmp::GetRevoked()
{
    return m_fRevoked;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::SetCertContext(PCCERT_CONTEXT pCertContext, BOOL fHasPrivateKey)
{
    m_pCertContext = pCertContext;
    m_fHasPrivateKey = fHasPrivateKey;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
PCCERT_CONTEXT CCertificateBmp::GetCertContext()
{
    return m_pCertContext;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::InitializeBmp()
{
    m_hbmpMiniCertNotOK = LoadResourceBitmap(Hinst(), MAKEINTRESOURCE(IDB_REVOKED_MINICERT), NULL);
    m_hbmpMiniCertOK = LoadResourceBitmap(Hinst(), MAKEINTRESOURCE(IDB_MINICERT), NULL);
    m_hbmbMiniCertExclamation = LoadResourceBitmap(Hinst(), MAKEINTRESOURCE(IDB_EXCLAMATION_MINICERT), NULL);
    m_hbmbPKey = LoadResourceBitmap(Hinst(), MAKEINTRESOURCE(IDB_PRIVATEKEY), NULL);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::Initialize()
{
	if (!m_fInitialized)
	{
        WCHAR szDisplayText[CRYPTUI_MAX_STRING_SIZE];
        WCHAR szURLText[CRYPTUI_MAX_STRING_SIZE];

        InitCommonControls();
		InitializeBmp();
        
        m_fInitialized = TRUE;

        m_hWindowTextColorBrush = GetSysColorBrush(COLOR_WINDOWTEXT);
        m_hWindowColorBrush = GetSysColorBrush(COLOR_WINDOW);
        m_h3DLight= GetSysColorBrush(COLOR_3DLIGHT);
        m_h3DHighLight = GetSysColorBrush(COLOR_3DHILIGHT);
        m_h3DLightShadow = GetSysColorBrush(COLOR_3DSHADOW);
        m_h3DDarkShadow = GetSysColorBrush(COLOR_3DDKSHADOW); 
	}
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
/*
int CCertificateBmp::OnQueryNewPalette()
{
    HDC hDC          = GetDC(GetMyWindow());

    HPALETTE hOldPal = SelectPalette(hDC, m_hpal, SELPALMODE);
    int iTemp = RealizePalette(hDC);         // Realize drawing palette.

    SelectPalette(hDC, hOldPal, TRUE);
    RealizePalette(hDC);

    ReleaseDC(GetMyWindow(), hDC);

    //
    // Did the realization change?
    //
    if (iTemp)
    {
        InvalidateRect(GetMyWindow(), NULL, FALSE);
    }
    return(iTemp);
}
*/

//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CCertificateBmp::OnPaint() 
{
    Initialize();

    BITMAP      bmMiniCert;
	BITMAP      bmPKey;
	
    LONG        miniCertXY;
    RECT        rect;
    RECT        disclaimerButtonRect;
    RECT        frameRect;
    RECT        mainWindowRect;
    RECT        borderRect;
    RECT        goodForRect;
    LONG        borderSpacing;

    //PAINTSTRUCT ps;
    HDC         hdc         = GetDC(GetMyWindow());//BeginPaint(GetMyWindow(), &ps);
    if (hdc == NULL)
    {
        return;
    }

    //
    // get the mini bitmap first thing so it can be used to do sizing
    //
    memset(&bmMiniCert, 0, sizeof(bmMiniCert));
    if ((m_dwChainError != 0) && m_fTrueError)
    {
        ::GetObject(m_hbmpMiniCertNotOK, sizeof(BITMAP), (LPSTR)&bmMiniCert);
    }
    else if ((m_dwChainError != 0) || m_fNoUsages)
    {
        ::GetObject(m_hbmbMiniCertExclamation, sizeof(BITMAP), (LPSTR)&bmMiniCert);
    }
    else
    {
        ::GetObject(m_hbmpMiniCertOK, sizeof(BITMAP), (LPSTR)&bmMiniCert);
    }


    //
    // calculate where the minicert bmp should be and where the lines should
    // be based on where other controls are
    //
    GetWindowRect(GetDlgItem(m_hWnd, IDC_CERT_GENERAL_HEADER), &rect);
    MapWindowPoints(HWND_DESKTOP, m_hWnd, (LPPOINT) &rect, 2);
    miniCertXY = rect.bottom - bmMiniCert.bmHeight;

    GetWindowRect(m_hWnd, &mainWindowRect);
    MapWindowPoints(HWND_DESKTOP, m_hWnd, (LPPOINT) &mainWindowRect, 2);

    GetWindowRect(GetDlgItem(m_hWnd, IDC_DISCLAIMER_BUTTON), &disclaimerButtonRect);
    MapWindowPoints(HWND_DESKTOP, m_hWnd, (LPPOINT) &disclaimerButtonRect, 2);

    //borderSpacing = mainWindowRect.right - disclaimerButtonRect.right;
    
    if ((mainWindowRect.right - disclaimerButtonRect.right) < (miniCertXY - 7))
    {
        borderSpacing = mainWindowRect.right - disclaimerButtonRect.right;
    }
    else
    {
        borderSpacing = miniCertXY - 7;
    }

    //
    // draw the background by drawing four rectangels.  these rectangels
    // border the "what this cert is good for" edit control or the error edit
    // control if there is an error.
    // we have to do this due to a bug in richedit where if you
    // invalidate the entire rect of the control sometimes the scroll
    // bars do not get redrawn.
    //
    if ((m_dwChainError != 0) || m_fNoUsages)
    {
        GetWindowRect(GetDlgItem(m_hWnd, IDC_CERT_GENERAL_ERROR_EDIT), &goodForRect);
    }
    else
    {
        GetWindowRect(GetDlgItem(m_hWnd, IDC_GOODFOR_EDIT), &goodForRect);
    }
    MapWindowPoints(HWND_DESKTOP, m_hWnd, (LPPOINT) &goodForRect, 2);
    rect.left = mainWindowRect.left + borderSpacing;
    rect.right = mainWindowRect.right - borderSpacing;
    rect.bottom = goodForRect.top;  
    rect.top = mainWindowRect.top + borderSpacing;
    ::FillRect(hdc, &rect, m_hWindowColorBrush);
    
    rect.bottom = disclaimerButtonRect.top - borderSpacing;  
    rect.top = goodForRect.bottom;
    ::FillRect(hdc, &rect, m_hWindowColorBrush);
    
    rect.top = goodForRect.top; 
    rect.bottom = goodForRect.bottom; 
    rect.left = mainWindowRect.left + borderSpacing;
    rect.right = goodForRect.left;
    ::FillRect(hdc, &rect, m_hWindowColorBrush);

    rect.left = goodForRect.right;
    rect.right = mainWindowRect.right - borderSpacing;
    ::FillRect(hdc, &rect, m_hWindowColorBrush);
    
    //
    // draw the frame
    //
    frameRect.left = mainWindowRect.left + borderSpacing;
    frameRect.right = mainWindowRect.right - borderSpacing;
    frameRect.bottom = disclaimerButtonRect.top - borderSpacing;  
    frameRect.top = mainWindowRect.top + borderSpacing;
    
    borderRect.left = frameRect.left;
    borderRect.right = frameRect.right - 1;
    borderRect.top = frameRect.top;
    borderRect.bottom = frameRect.top + 1;
    ::FillRect(hdc, &borderRect, m_h3DLightShadow);
    borderRect.left = frameRect.left;
    borderRect.right = frameRect.left + 1;
    borderRect.top = frameRect.top;
    borderRect.bottom = frameRect.bottom - 1;
    ::FillRect(hdc, &borderRect, m_h3DLightShadow);

    borderRect.left = frameRect.left + 1;
    borderRect.right = frameRect.right - 2;
    borderRect.top = frameRect.top + 1;
    borderRect.bottom = frameRect.top + 2;
    ::FillRect(hdc, &borderRect, m_h3DDarkShadow);
    borderRect.left = frameRect.left + 1;
    borderRect.right = frameRect.left + 2;
    borderRect.top = frameRect.top + 1;
    borderRect.bottom = frameRect.bottom - 2;
    ::FillRect(hdc, &borderRect, m_h3DDarkShadow);

    borderRect.left = frameRect.left;
    borderRect.right = frameRect.right;
    borderRect.top = frameRect.bottom - 1;
    borderRect.bottom = frameRect.bottom;
    ::FillRect(hdc, &borderRect, m_h3DHighLight);
    borderRect.left = frameRect.right - 1;
    borderRect.right = frameRect.right;
    borderRect.top = frameRect.top;
    borderRect.bottom = frameRect.bottom;
    ::FillRect(hdc, &borderRect, m_h3DHighLight);

    borderRect.left = frameRect.left + 1;
    borderRect.right = frameRect.right - 1;
    borderRect.top = frameRect.bottom - 2;
    borderRect.bottom = frameRect.bottom - 1;
    ::FillRect(hdc, &borderRect, m_h3DLight);
    borderRect.left = frameRect.right - 2;
    borderRect.right = frameRect.right - 1;
    borderRect.top = frameRect.top + 1;
    borderRect.bottom = frameRect.bottom - 1;
    ::FillRect(hdc, &borderRect, m_h3DLight);
    
    //
    // draw the lines with the proper foreground color
    //
    GetWindowRect(GetDlgItem(m_hWnd, IDC_CERT_GENERAL_HEADER), &rect);
    MapWindowPoints(HWND_DESKTOP, m_hWnd, (LPPOINT) &rect, 2);
    rect.left = mainWindowRect.left + miniCertXY;
    rect.right = mainWindowRect.right - miniCertXY;
    rect.top = rect.bottom + 6;
    rect.bottom = rect.top + 1;
    ::FillRect(hdc, &rect, m_hWindowTextColorBrush);

    GetWindowRect(GetDlgItem(m_hWnd, IDC_SUBJECT_EDIT), &rect);
    MapWindowPoints(HWND_DESKTOP, m_hWnd, (LPPOINT) &rect, 2);
    rect.left = mainWindowRect.left + miniCertXY;
    rect.right = mainWindowRect.right - miniCertXY;
    rect.top -= 10;
    rect.bottom = rect.top + 1;
    ::FillRect(hdc, &rect, m_hWindowTextColorBrush);
	
    //   
	// Draw the mini cert bitmap
    //
    if ((m_dwChainError != 0) && m_fTrueError)
    {
        MaskBlt(m_hbmpMiniCertNotOK, 
                m_hpal, 
                hdc, 
                miniCertXY,
                miniCertXY,
                bmMiniCert.bmWidth, 
                bmMiniCert.bmHeight);
    }
    else if ((m_dwChainError != 0) || m_fNoUsages)
    {
        MaskBlt(m_hbmbMiniCertExclamation, 
                m_hpal, 
                hdc, 
                miniCertXY,
                miniCertXY,
                bmMiniCert.bmWidth, 
                bmMiniCert.bmHeight);
    }
    else
    {
        MaskBlt(m_hbmpMiniCertOK, 
                m_hpal, 
                hdc, 
                miniCertXY,
                miniCertXY,
                bmMiniCert.bmWidth, 
                bmMiniCert.bmHeight);
    }

    //
    // if there is a private key then draw the bitmap
    //
    if (m_fHasPrivateKey)
    {
        GetWindowRect(GetDlgItem(m_hWnd, IDC_CERT_PRIVATE_KEY_EDIT), &rect);
        MapWindowPoints(HWND_DESKTOP, m_hWnd, (LPPOINT) &rect, 2);

        memset(&bmPKey, 0, sizeof(bmPKey));
        ::GetObject(m_hbmbPKey, sizeof(BITMAP), (LPSTR)&bmPKey);
        MaskBlt(m_hbmbPKey, 
                m_hpal, 
                hdc, 
                rect.left - bmPKey.bmWidth - 4, 
                rect.top - 2, 
                bmPKey.bmWidth, 
                bmPKey.bmHeight);
    }

    ReleaseDC(GetMyWindow(), hdc);//::EndPaint(GetMyWindow(), &ps);
    
    InvalidateRect(GetDlgItem(m_hWnd, IDC_SUBJECT_EDIT), NULL, TRUE);
    InvalidateRect(GetDlgItem(m_hWnd, IDC_ISSUER_EDIT), NULL, TRUE);
    InvalidateRect(GetDlgItem(m_hWnd, IDC_CERT_GENERAL_HEADER), NULL, TRUE);
    InvalidateRect(GetDlgItem(m_hWnd, IDC_CERT_GENERAL_GOODFOR_HEADER), NULL, TRUE);
    InvalidateRect(GetDlgItem(m_hWnd, IDC_CERT_GENERAL_ISSUEDTO_HEADER), NULL, TRUE);
    InvalidateRect(GetDlgItem(m_hWnd, IDC_CERT_GENERAL_ISSUEDBY_HEADER), NULL, TRUE);
    InvalidateRect(GetDlgItem(m_hWnd, IDC_CERT_GENERAL_VALID_EDIT), NULL, TRUE);
    InvalidateRect(GetDlgItem(m_hWnd, IDC_CERT_GENERAL_ERROR_EDIT), NULL, TRUE);
    InvalidateRect(GetDlgItem(m_hWnd, IDC_CERT_ISSUER_WARNING_EDIT), NULL, TRUE);
    InvalidateRect(GetDlgItem(m_hWnd, IDC_CERT_PRIVATE_KEY_EDIT), NULL, TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\ccertbmp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ccertbmp.h
//
//--------------------------------------------------------------------------

#ifndef _CCERTBMP_H
#define _CCERTBMP_H

#include        "global.hxx"
#include        <dbgdef.h>

/////////////////////////////////////////////////////////////////////////////
// CCertificateBmp window


class CCertificateBmp
	{
    HWND                m_hWnd;
    HINSTANCE           m_hInst;
	BOOL				m_fInitialized;

    BOOL                m_fRevoked;
	
    HPALETTE			m_hpal;		        // palette of the license background
	HBITMAP				m_hbmpMiniCertOK;	        // the logo bitmap
    HBITMAP				m_hbmpMiniCertNotOK;	    // the logo bitmap
    HBITMAP             m_hbmbMiniCertExclamation;
    HBITMAP             m_hbmbPKey;
    
    POINT               m_ptCoordinates;

    PCCERT_CONTEXT      m_pCertContext;
    BOOL                m_fHasPrivateKey;

    HCURSOR             m_hPrevCursor;
    
    DWORD               m_dwChainError;
    BOOL                m_fTrueError;
    BOOL                m_fNoUsages;

    HBRUSH              m_hWindowTextColorBrush;
    HBRUSH              m_hWindowColorBrush;
    HBRUSH              m_h3DLight;
    HBRUSH              m_h3DHighLight;
    HBRUSH              m_h3DLightShadow;
    HBRUSH              m_h3DDarkShadow;

public:
	                    CCertificateBmp();
	virtual             ~CCertificateBmp();

    void                SetWindow(HWND hWnd);
    HWND                GetMyWindow();
    void                SetRevoked(BOOL);
    BOOL                GetRevoked();
    HINSTANCE           Hinst();
	void                SetHinst(HINSTANCE);
    void                SetCertContext(PCCERT_CONTEXT, BOOL);
    PCCERT_CONTEXT      GetCertContext();
    void                DoSubclass();
    void                DoUnSubclass();  
    void                SetChainError(DWORD dwError, BOOL fTrueError, BOOL fNoUsages);


public:
	void OnPaint();
    int  OnQueryNewPalette();
    WNDPROC m_prevProc;
private:
	void Initialize();
	void InitializeBmp();
    void InitializeToolTip();
//    BOOL IsTrueErrorString(DWORD dwError);
public:
    
};


/////////////////////////////////////////////////////////////////////////////
#endif //_CCERTBMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptext\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7444C70D_39BF_11D1_8CD9_00C04FC29D45__INCLUDED_)
#define AFX_STDAFX_H__7444C70D_39BF_11D1_8CD9_00C04FC29D45__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7444C70D_39BF_11D1_8CD9_00C04FC29D45__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptext\exthlpr.cpp ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       exthlpr.cpp
//
//  Contents:   Helper functions for cryptext.dll
//              1. Registry Functions
//              2. String Formatting Functions
//              3. Exports for RunDll
//
//  History:    16-09-1997 xiaohs   created
//
//--------------------------------------------------------------

#include "cryptext.h"
#include "private.h"

#include    <ole2.h>
#include    "xenroll.h"
#include    "xenroll_i.c"
#include    "initguid.h"


//*************************************************************************************
//global data for registry entries
//************************************************************************************

    MIME_REG_ENTRY     rgRegEntry[]={
L".cer",                            L"CERFile",                                      0,
L"CERFile\\shell\\open\\command",   L"\"%SystemRoot%\\system32\\rundll32.exe\" cryptext.dll,CryptExtOpenCER %1", 0,
L"CERFile\\shell\\add\\command",    L"\"%SystemRoot%\\system32\\rundll32.exe\" cryptext.dll,CryptExtAddCER %1", 0,
L"CERFile\\shell\\add",             (LPWSTR) 1,                                      IDS_INSTALL_CERT,
L"CERFile",                         NULL,                                            IDS_CER_NAME,
L".pfx",                            L"PFXFile",                                      0,
L"PFXFile\\shell\\add\\command",    L"\"%SystemRoot%\\system32\\rundll32.exe\" cryptext.dll,CryptExtAddPFX %1", 0,
L"PFXFile\\shell\\add",             (LPWSTR) 1,                                      IDS_MENU_INSTALL_PFX,
L"PFXFile",                         NULL,                                            IDS_PFX_NAME,
L".p12",                            L"PFXFile",                                      0,
L".cat",                            L"CATFile",                                      0,
L"CATFile\\shell\\open\\command",   L"\"%SystemRoot%\\system32\\rundll32.exe\" cryptext.dll,CryptExtOpenCAT %1", 0,
L"CATFile",                         NULL,                                            IDS_CAT_NAME,
L".crt",                            L"CERFile",                                      0,
L".der",                            L"CERFile",                                      0,
L".stl",                            L"STLFile",                                      0,
L"STLFile\\shell\\open\\command",   L"\"%SystemRoot%\\system32\\rundll32.exe\" cryptext.dll,CryptExtOpenCTL %1", 0,
L"STLFile\\shell\\add\\command",    L"\"%SystemRoot%\\system32\\rundll32.exe\" cryptext.dll,CryptExtAddCTL %1",  0,
L"STLFile\\shell\\add",             (LPWSTR) 1,                                      IDS_INSTALL_STL,
L"STLFile",                         NULL,                                            IDS_STL_NAME,
L".crl",                            L"CRLFile",                                      0,
L"CRLFile\\shell\\open\\command",   L"\"%SystemRoot%\\system32\\rundll32.exe\" cryptext.dll,CryptExtOpenCRL %1", 0,
L"CRLFile\\shell\\add\\command",    L"\"%SystemRoot%\\system32\\rundll32.exe\" cryptext.dll,CryptExtAddCRL %1", 0,
L"CRLFile\\shell\\add",             (LPWSTR) 1,                                      IDS_INSTALL_CRL,
L"CRLFile",                         NULL,                                            IDS_CRL_NAME,
L".spc",                            L"SPCFile",                                      0,
L"SPCFile\\shell\\add\\command",    L"\"%SystemRoot%\\system32\\rundll32.exe\" cryptext.dll,CryptExtAddSPC %1", 0,
L"SPCFile\\shell\\add",             (LPWSTR) 1,                                      IDS_INSTALL_CERT,
L"SPCFile",                         NULL,                                            IDS_SPC_NAME,
L".p7s",                            L"P7SFile",                                      0,
L"P7SFile",                         NULL,                                            IDS_P7S_NAME,
L".p7b",                            L"SPCFile",                                      0,
L".p7m",                            L"P7MFile",                                      0,
L"P7MFile",                         NULL,                                            IDS_P7M_NAME,
L".p7r",                            L"SPCFile",                                      0,
L"P7RFile\\shell\\open\\command",   L"\"%SystemRoot%\\system32\\rundll32.exe\" cryptext.dll,CryptExtOpenP7R %1", 0,
L"P7RFile\\shell\\add\\command",    L"\"%SystemRoot%\\system32\\rundll32.exe\" cryptext.dll,CryptExtAddP7R %1", 0,
L"P7RFile\\shell\\add",             (LPWSTR) 1,                                      IDS_INSTALL_CERT,
L"P7RFile",                         NULL,                                            IDS_P7R_NAME,
L".sst",                            L"CertificateStoreFile",                                0,
L"CertificateStoreFile",            NULL,                                            IDS_SST_NAME,
L".p10",                            L"P10File",                                      0,
L"P10File",                         NULL,                                            IDS_P10_NAME,
L".pko",                            L"PKOFile",                                      0,
L"PKOFile\\shellex\\ContextMenuHandlers",   L"CryptoMenu",                           0,
L"PKOFile\\shellex\\PropertySheetHandlers", L"CryptoMenu",                           0,
L"PKOFile",                         NULL,                                            IDS_PKO_NAME,
    };


    //the following registry entries.
    //it uses MMC.exe to display PKCS7 and Store files.  MMC.exe
    //is only available on NT5 enviroment
    MIME_REG_ENTRY     rgWINNT5RegEntry[]={
L"SPCFile\\shell\\open\\command",   L"\"%SystemRoot%\\system32\\rundll32.exe\" cryptext.dll,CryptExtOpenPKCS7 %1", 0,
L"P7SFile\\shell\\open\\command",   L"\"%SystemRoot%\\system32\\rundll32.exe\" cryptext.dll,CryptExtOpenPKCS7 %1", 0,
L"CertificateStoreFile\\shell\\open\\command", L"\"%SystemRoot%\\system32\\rundll32.exe\" cryptext.dll,CryptExtOpenSTR %1", 0,
    };


WIN95_REG_ENTRY    rgWin95IconEntry[]={ 
"CERFile\\DefaultIcon",            "\\cryptui.dll,-3410", 
"PFXFile\\DefaultIcon",            "\\cryptui.dll,-3425",                                                       
"CATFile\\DefaultIcon",            "\\cryptui.dll,-3418",                              
"STLFile\\DefaultIcon",            "\\cryptui.dll,-3413",                            
"CRLFile\\DefaultIcon",            "\\cryptui.dll,-3417",                           
"P7RFile\\DefaultIcon",            "\\cryptui.dll,-3410",  
"SPCFile\\DefaultIcon",            "\\cryptui.dll,-3410",
    };

    MIME_REG_ENTRY     rgIconEntry[]={ 
L"CERFile\\DefaultIcon",            L"%SystemRoot%\\System32\\cryptui.dll,-3410",                               0,
L"PFXFile\\DefaultIcon",            L"%SystemRoot%\\System32\\cryptui.dll,-3425",                               0,
L"CATFile\\DefaultIcon",            L"%SystemRoot%\\System32\\cryptui.dll,-3418",                               0,
L"STLFile\\DefaultIcon",            L"%SystemRoot%\\System32\\cryptui.dll,-3413",                               0,
L"CRLFile\\DefaultIcon",            L"%SystemRoot%\\System32\\cryptui.dll,-3417",                               0,
L"P7RFile\\DefaultIcon",            L"%SystemRoot%\\System32\\cryptui.dll,-3410",                               0,
L"SPCFile\\DefaultIcon",            L"%SystemRoot%\\System32\\cryptui.dll,-3410",                               0,
};

    

 MIME_GUID_ENTRY     rgGuidEntry[]={
&CLSID_CryptPKO,  
L"PKOFile\\shellex\\ContextMenuHandlers\\CryptoMenu",
L"PKOFile\\shellex\\PropertySheetHandlers\\CrytoMenu", 
L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved", 
IDS_PKO_EXT,
&CLSID_CryptSig,  
NULL,
L"*\\shellex\\PropertySheetHandlers\\CryptoSignMenu",
L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved", 
IDS_SIGN_EXT,
    };



    LPWSTR      rgwszDelete[] = {
L".cer", 
L"CERFile\\DefaultIcon",                           
L"CERFile\\shell\\open\\command",   
L"CERFile\\shell\\add\\command",    
L"CERFile\\shell\\open",  
L"CERFile\\shell\\add",
L"CERFile\\shell",           
L"CERFile", 
L".pfx", 
L".p12", 
L"PFXFile\\DefaultIcon",                           
L"PFXFile\\shell\\add\\command",    
L"PFXFile\\shell\\add",
L"PFXFile\\shell",           
L"PFXFile",                         
L".cat",   
L"CATFile\\DefaultIcon",                                                    
L"CATFile\\shell\\open\\command",   
L"CATFile\\shell\\open",  
L"CATFile\\shell",           
L"CATFile",                         
L".crt",  
L".der",                          
L".stl",
L"STLFile\\DefaultIcon",                                                       
L"STLFile\\shell\\open\\command",   
L"STLFile\\shell\\add\\command",    
L"STLFile\\shell\\open",             
L"STLFile\\shell\\add",             
L"STLFile\\shell",             
L"STLFile",                         
L".crl",     
L"CRLFile\\DefaultIcon",                           
L"CRLFile\\shell\\open\\command",   
L"CRLFile\\shell\\add\\command",    
L"CRLFile\\shell\\open",   
L"CRLFile\\shell\\add",             
L"CRLFile\\shell",   
L"CRLFile",                         
L".spc", 
L"SPCFile\\DefaultIcon",                                                                               
L"SPCFile\\shell\\open\\command",   
L"SPCFile\\shell\\open",
L"SPCFile\\shell\\add\\command",   
L"SPCFile\\shell\\add",   
L"SPCFile\\shell",
L"SPCFile",                         
L".p7s",                            
L"P7SFile\\shell\\open\\command",   
L"P7SFile\\shell\\open",   
L"P7SFile\\shell",   
L"P7SFile",                         
L".p7b", 
L".p7m",                            
L"P7MFile",                         
L".p7r",   
L"P7RFile\\DefaultIcon",                                                    
L"P7RFile\\shell\\open\\command",   
L"P7RFile\\shell\\add\\command",    
L"P7RFile\\shell\\open",  
L"P7RFile\\shell\\add",
L"P7RFile\\shell",           
L"P7RFile",                         
L".sst",                            
L"CertificateStoreFile\\shell\\open\\command", 
L"CertificateStoreFile\\shell\\open", 
L"CertificateStoreFile\\shell", 
L"CertificateStoreFile",                   
L".p10",                           
L"P10File",                       
L".pko",                           
L"PKOFile\\shellex\\ContextMenuHandlers",
L"PKOFile\\shellex\\PropertySheetHandlers", 
L"PKOFile\\shellex", 
L"PKOFile",                        
};

    LPWSTR  g_CLSIDDefault[]={
L"\\shellex\\MayChangeDefaultMenu",
L"\\shellex",
};


    //the following is the entries for the content type
    // For any extension, say ".foo", we need to do the following:

	//1. Under  the HEKY_CLASSES_ROOT, under ".foo" key, add an entry of name "Content Type" and value "application/xxxxxxxx".
	//2. Under HKEY_CLASSES_ROOT\MIME\Database\Content Type, add a key of "application/xxxxxxxx", under which add an entry of name "Extension" and value ".foo".

    MIME_REG_ENTRY      rgContentTypeEntry[]={
L".der",            L"application/pkix-cert",                   0,
L".der",            L"application/x-x509-ca-cert",              0,
L".crt",            L"application/pkix-cert",                   0,
L".crt",            L"application/x-x509-ca-cert",              0,
L".cer",            L"application/pkix-cert",                   0,
L".cer",            L"application/x-x509-ca-cert",              0,
L".spc",            L"application/x-pkcs7-certificates",        0,
L".p7b",            L"application/x-pkcs7-certificates",        0,
L".pfx",            L"application/x-pkcs12",                    0,
L".p12",            L"application/x-pkcs12",                    0,
L".stl",            L"application/vnd.ms-pki.stl",              0,
L".crl",            L"application/pkix-crl",                    0,
L".p7r",            L"application/x-pkcs7-certreqresp",         0,
L".p10",            L"application/pkcs10",                      0,
L".sst",            L"application/vnd.ms-pki.certstore",        0,
L".cat",            L"application/vnd.ms-pki.seccat",           0,
L".p7m",            L"application/pkcs7-mime",                  0,
L".p7s",            L"application/pkcs7-signature",             0,
L".pko",            L"application/vnd.ms-pki.pko",              0,
    };

    //The following entries need to be deleted at Regsvr32 time
    //due to the following changes from NT5 B2 to B3:
    //.ctl  -> .stl
    //.str  -> .sst
    //.p7b  -> .p7c


    MIME_REG_ENTRY      rgRemoveRelatedEntry[]={
L"P7CFile\\shell\\open\\command",   L"rundll32.exe cryptext.dll,CryptExtOpenPKCS7 %1",  0,
L"P7CFile\\shell\\open",            NULL,                                               0,
L"CERTSTOREFile\\shell\\open\\command",   L"rundll32.exe cryptext.dll,CryptExtOpenSTR %1",  0,
L"CERTSTOREFile\\shell\\open",      NULL,                                               0,
L"CTLFile\\shell\\open\\command",   L"rundll32.exe cryptext.dll,CryptExtOpenCTL %1",    0,
L"CTLFile\\shell\\open",            NULL,                                               0,
L"CTLFile\\shell\\add\\command",    L"rundll32.exe cryptext.dll,CryptExtAddCTL %1",     0,
L"CTLFile\\shell\\add",             NULL,                                               0,
    };

    MIME_REG_ENTRY      rgRemoveEmptyEntry[]={
L"P7CFile\\shell",                  NULL,                                               0,
L"CTLFile\\shell",                  NULL,                                               0,
L"P7CFile",                         NULL,                                               0,
L"CTLFile",                         NULL,                                               0,
L"CERTSTOREFile\\shell",            NULL,                                               0,
L"CERTSTOREFile",                   NULL,                                               0,
};


    MIME_REG_ENTRY      rgResetChangedEntry[]={
L"P7CFile",                         NULL,                                            IDS_OLD_P7C_NAME,
L"CTLFile",                         NULL,                                            IDS_OLD_CTL_NAME,
L"CERTSTOREFile",                   NULL,                                            IDS_OLD_STR_NAME,
};


    MIME_REG_ENTRY      rgRemoveChangedEntry[]={
L".str",                            L"CERTSTOREFile",                                   0,
L".p7c",                            L"P7CFile",                                         0,
L".ctl",                            L"CTLFile",                                         0,
L"CTLFile\\DefaultIcon",            L"cryptui.dll,-3413",                               0,
L"P7CFile\\DefaultIcon",            L"cryptui.dll,-3410",                               0,
};

//
// DSIE: Starting with Whistler, the MUI system requires a new registry value named
//       "FirendlyTypeName" where the data will be loaded from a specified DLL.
//
    MIME_REG_ENTRY      rgFriendlyTypeNameEntry[]={
L"CERFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_CER_NAME,
L"STLFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_STL_NAME,
L"CRLFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_CRL_NAME,
L"SPCFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_SPC_NAME,
L"CertificateStoreFile",            L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_SST_NAME,
L"P7SFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_P7S_NAME,
L"P7MFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_P7M_NAME,
L"P10File",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_P10_NAME,
L"PKOFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_PKO_NAME,
L"P7RFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_P7R_NAME,
L"CATFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_CAT_NAME,
L"PFXFile",                         L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",  IDS_PFX_NAME,
};

#include <dbgdef.h>


//--------------------------------------------------------------------------
//
//  before anything else, we need to remove the .ctl, .str, and .p7c
//  entries.  No need to check the return values
//
//--------------------------------------------------------------------------

void    RemoveOldExtensions()
{
    DWORD               dwRegEntry=0;
    DWORD               dwRegIndex=0;
    HKEY                hKey=NULL;
    BOOL                fCorrectValue=FALSE; 
    BOOL                fPreviousValue=FALSE;
    WCHAR               wszValue[MAX_STRING_SIZE];
    DWORD               dwLastStringSize=0;
    DWORD               dwType=0;
    DWORD               cbSize=0;
    BOOL                fCTLOpen=FALSE;
    BOOL                fP7COpen=FALSE;
    FILETIME            fileTime;


    WCHAR               wszLoadString[MAX_STRING_SIZE];

    //1st, delete the rgRemoveChangedEntry about Icons
    dwRegEntry=sizeof(rgRemoveChangedEntry)/sizeof(rgRemoveChangedEntry[0]);

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {

        fCorrectValue=FALSE;

        if (ERROR_SUCCESS == RegOpenKeyExU(
                        HKEY_CLASSES_ROOT,
                        rgRemoveChangedEntry[dwRegIndex].wszKey,
                        0, 
                        KEY_READ, 
                        &hKey))
        {

            //get the value
            wszValue[0]=L'\0';
            cbSize=sizeof(wszValue)/sizeof(wszValue[0]);

            if(ERROR_SUCCESS == RegQueryValueExU(
                        hKey,
                        NULL,
                        NULL,
                        &dwType,
                        (BYTE *)wszValue,
                        &cbSize))
            {
                if(REG_SZ == dwType|| REG_EXPAND_SZ == dwType)
                {
                    dwLastStringSize=wcslen(rgRemoveChangedEntry[dwRegIndex].wszName);

                    if(((DWORD)wcslen(wszValue)) >= dwLastStringSize)
                    {
                        if(0 == _wcsicmp(
                            (LPWSTR)(wszValue+wcslen(wszValue)-dwLastStringSize),
                            rgRemoveChangedEntry[dwRegIndex].wszName))
                            fCorrectValue=TRUE;
                    }
                }
            }

            if(hKey)
            {
              RegCloseKey(hKey);
              hKey=NULL;
            }

        }


        if(fCorrectValue)
        {
            RegDeleteKeyU(HKEY_CLASSES_ROOT,rgRemoveChangedEntry[dwRegIndex].wszKey);
        }
    }


    //2nd, reset the values to NULL of rgResetChangedEntry
    dwRegEntry=sizeof(rgResetChangedEntry)/sizeof(rgResetChangedEntry[0]);
    hKey=NULL;

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {
        fCorrectValue=FALSE; 

        if(0!=LoadStringU(g_hmodThisDll,rgResetChangedEntry[dwRegIndex].idsName,
                        wszLoadString,MAX_STRING_SIZE))
        {

            if (ERROR_SUCCESS == RegOpenKeyExU(
                            HKEY_CLASSES_ROOT,
                            rgResetChangedEntry[dwRegIndex].wszKey,
                            0, 
                            KEY_WRITE | KEY_READ, 
                            &hKey))
            {

                //get the value
                wszValue[0]=L'\0';
                cbSize=sizeof(wszValue)/sizeof(wszValue[0]);

                //use try{}except here since not sure what WIN95 will behave
                //when the value is NULL
                __try{

                    if(ERROR_SUCCESS == RegQueryValueExU(
                                hKey,
                                NULL,
                                NULL,
                                &dwType,
                                (BYTE *)wszValue,
                                &cbSize))
                    {
                        if(REG_SZ == dwType || REG_EXPAND_SZ == dwType)
                        {
                            if(0 == _wcsicmp(
                                wszValue,
                                wszLoadString))
                                fCorrectValue=TRUE;
                        }
                    } 
                } __except(EXCEPTION_EXECUTE_HANDLER) {
                }
            }
        }

        if(fCorrectValue)
        {

            //set the value to NULL
            //use try{}except here since not sure what WIN95 will behave
            //when the value is NULL
             __try{

            RegSetValueExU(
                        hKey, 
                        NULL,
                        0,
                        REG_SZ,
                        NULL,
                        0);
            } __except(EXCEPTION_EXECUTE_HANDLER) {
            }
        }

        if(hKey)
        {
          RegCloseKey(hKey);
          hKey=NULL;
        }
    }

    //3rd, delete the related keys in rgRemoveRelatedEntry
    dwRegEntry=sizeof(rgRemoveRelatedEntry)/sizeof(rgRemoveRelatedEntry[0]);

    hKey=NULL;

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex+=2)
    {

        fCorrectValue=FALSE;

        if (ERROR_SUCCESS == RegOpenKeyExU(
                        HKEY_CLASSES_ROOT,
                        rgRemoveRelatedEntry[dwRegIndex].wszKey,
                        0, 
                        KEY_READ, 
                        &hKey))
        {

            //get the value
            wszValue[0]=L'\0';
            cbSize=sizeof(wszValue)/sizeof(wszValue[0]);

            if(ERROR_SUCCESS == RegQueryValueExU(
                        hKey,
                        NULL,
                        NULL,
                        &dwType,
                        (BYTE *)wszValue,
                        &cbSize))
            {
                if(REG_SZ == dwType|| REG_EXPAND_SZ == dwType)
                {
                   if(0 == _wcsicmp(
                        wszValue,
                        rgRemoveRelatedEntry[dwRegIndex].wszName))
                        fCorrectValue=TRUE;
                }
            }

            if(hKey)
            {
              RegCloseKey(hKey);
              hKey=NULL;
            }

        }


        if(fCorrectValue)
        {
            //mark if the CTLAdd and CTLOpen were the correct values
            if(dwRegIndex == 0)
                fP7COpen=TRUE;

            if(dwRegIndex == 2)
                fCTLOpen=TRUE;

            RegDeleteKeyU(HKEY_CLASSES_ROOT,rgRemoveRelatedEntry[dwRegIndex].wszKey);
            RegDeleteKeyU(HKEY_CLASSES_ROOT,rgRemoveRelatedEntry[dwRegIndex+1].wszKey);
       }
    }

    //fourth, if the shell subkey is empty, we need to remove the subkeys
    dwRegEntry=sizeof(rgRemoveEmptyEntry)/sizeof(rgRemoveEmptyEntry[0]);

    hKey=NULL;

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {

        fCorrectValue=FALSE;

        if (ERROR_SUCCESS == RegOpenKeyExU(
                        HKEY_CLASSES_ROOT,
                        rgRemoveEmptyEntry[dwRegIndex].wszKey,
                        0, 
                        KEY_READ, 
                        &hKey))
        {

            //enum the subkey
            cbSize=0;

            if(ERROR_SUCCESS != RegEnumKeyExU(
                        hKey,
                        0,
                        NULL,
                        &cbSize,
                        NULL,
                        NULL,
                        NULL,
                        &fileTime))
            {
                fCorrectValue=TRUE;
            }

            if(hKey)
            {
              RegCloseKey(hKey);
              hKey=NULL;
            }

        }


        if(fCorrectValue)
        {
            //mark if the CTLAdd and CTLOpen were the correct values
           // if((0 == dwRegIndex && TRUE == fP7COpen) ||
           //     (1 == dwRegIndex && TRUE == fCTLOpen)
           //    )
           // {
                RegDeleteKeyU(HKEY_CLASSES_ROOT,rgRemoveEmptyEntry[dwRegIndex].wszKey);
           // }
       }
    }
}


//--------------------------------------------------------------------------
//
//	  RegisterMimeHandler
//
//    This function adds the following registry entries:
//
//[HKEY_CLASSES_ROOT\.cer]
//   @="CERFile"
//[HKEY_CLASSES_ROOT\CERFile]
//   @="Security Certificate"
//[HKEY_CLASSES_ROOT\CERFile\shell\open\command]
//   @="rundll32.exe cryptext.dll,CryptExtOpenCER %1"
//[HKEY_CLASSES_ROOT\CERFile\shell\add]
//   @="&Add"
//[HKEY_CLASSES_ROOT\CERFile\shell\add\command]
//   @="rundll32.exe cryptext.dll,CryptExtAddCER %1"
//
//[HKEY_CLASSES_ROOT\.crt]
//   @="CERFile"
//
//[HKEY_CLASSES_ROOT\.stl]
//   @="sTLFile"
//[HKEY_CLASSES_ROOT\sTLFile]
//   @="Trust List"
//[HKEY_sLASSES_ROOT\sTLFile\shell\open\command]
//   @="rundll32.exe cryptext.dll,CryptExtOpenCTL %1"
//[HKEY_CLASSES_ROOT\sTLFile\shell\add]
//   @="&Add"
//[HKEY_CLASSES_ROOT\sTLFile\shell\add\command]
//   @="rundll32.exe cryptext.dll,CryptExtAddCTL %1"
// 
//[HKEY_CLASSES_ROOT\.crl]
//   @="CRLFile"
//[HKEY_CLASSES_ROOT\CRLFile]
//   @="Certificate Revocation List"
//[HKEY_CLASSES_ROOT\CRLFile\shell\open\command]
//   @="rundll32.exe cryptext.dll,CryptExtOpenCRL %1"
//[HKEY_CLASSES_ROOT\CRLFile\shell\add]
//   @="&Add"
//[HKEY_CLASSES_ROOT\CRLFile\shell\add\command]
//   @="rundll32.exe cryptext.dll,CryptExtAddCRL %1"
//
//[HKEY_CLASSES_ROOT\.spc]
//   @="SPCFile"
//[HKEY_CLASSES_ROOT\SPCFile]
//   @="Software Publishing Credentials"
//[HKEY_CLASSES_ROOT\SPCFile\shell\open\command]
//   @="rundll32.exe cryptext.dll,CryptExtOpenPKCS7 %1"
//
//[HKEY_CLASSES_ROOT\.p7s]
//   @="P7SFile"
//[HKEY_CLASSES_ROOT\P7SFile]
//   @="PKCS7 Signature"
//[HKEY_CLASSES_ROOT\P7SFile\shell\open\command]
//   @="rundll32.exe cryptext.dll,CryptExtOpenPKCS7 %1"
//
//[HKEY_CLASSES_ROOT\.p7b]
//   @="P7BFile"
//[HKEY_CLASSES_ROOT\P7BFile]
//   @="PKCS7 Certificates"
//[HKEY_CLASSES_ROOT\P7BFile\shell\open\command]
//   @="rundll32.exe cryptext.dll,CryptExtOpenPKCS7 %1"
//
//[HKEY_CLASSES_ROOT\.p7m]
//   @="P7MFile"
//[HKEY_CLASSES_ROOT\P7MFile]
//   @="PKCS7 MIME"
//
//[HKEY_CLASSES_ROOT\.sst]
//   @="CertificateStoreFile"
//[HKEY_CLASSES_ROOT\CertificateStoreFile]
//   @="Certificate Store"
//[HKEY_CLASSES_ROOT\CertificateStoreFile\shell\open\command]
//   @="rundll32.exe cryptext.dll,CryptExtOpenSTR %1"
//
//[HKEY_CLASSES_ROOT\.p10]
//   @="P10File"
//[HKEY_CLASSES_ROOT\P10File]
//   @="Certificate Request"
//
//[HKEY_CLASSES_ROOT\.pko]
//   @="PKOFile"
//[HKEY_CLASSES_ROOT\PKOFile]
//   @="Public Key Object"
//[HKEY_CLASSES_ROOT\PKOFile\shellex\ContextMenuHandlers]
//   @="CryptoMenu"
//[HKEY_CLASSES_ROOT\PKOFile\shellex\ContextMenuHandlers\CryptoMenu]
//   @="{7444C717-39BF-11D1-8CD9-00C04FC29D45}"
//
//[HKEY_CLASSES_ROOT\*\shellex\ContextMenuHandlers\CryptoSignMenu]
//   @="{7444C719-39BF-11D1-8CD9-00C04FC29D45}"
//
//
//[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved]
//   "{7444C717-39BF-11D1-8CD9-00C04FC29D45}"="Crypto PKO Extension"
//
//[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved]
//   "{7444C719-39BF-11D1-8CD9-00C04FC29D45}"="Crypto Sign Extension"
//
//--------------------------------------------------------------------------
HRESULT RegisterMimeHandler()
{
    HRESULT             hr=E_FAIL;
    DWORD               dwRegEntry=0;
    DWORD               dwRegIndex=0;
    WCHAR               wszName[MAX_STRING_SIZE];
    HKEY                hKey=NULL;
    DWORD               dwDisposition=0;  
    WCHAR               wszGUID[MAX_STRING_SIZE];
    WCHAR               wszDefault[MAX_STRING_SIZE*2];
    CHAR                szValue[2 * MAX_PATH + 1];
    CHAR                szSystem[MAX_PATH + 1];
    WCHAR               wszContentType[MAX_STRING_SIZE];
    LPWSTR              pwszCommandName = NULL;
    LPWSTR              pwszFriendlyTypeName = NULL;

    //before anything else, we need to remove the .ctl, .str, and .p7c
    //entries.  No need to check the return values
    RemoveOldExtensions();

    //1st, do the registry based context menu
    //get the count of the reg entries
    dwRegEntry=sizeof(rgRegEntry)/sizeof(rgRegEntry[0]);

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {
        //open a registry entry under HKEY_CLASSES_ROOT
        if (ERROR_SUCCESS != RegCreateKeyExU(
                        HKEY_CLASSES_ROOT,
                        rgRegEntry[dwRegIndex].wszKey,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
            goto RegCreateKeyErr;

        //set the value
        if (NULL == rgRegEntry[dwRegIndex].wszName)
        {
            //load the string
            if(0==LoadStringU(g_hmodThisDll,rgRegEntry[dwRegIndex].idsName,
                            wszName,MAX_STRING_SIZE))
                  goto LoadStringErr;

            if(ERROR_SUCCESS !=  RegSetValueExU(
                        hKey, 
                        NULL,
                        0,
                        REG_SZ,
                        (BYTE *)wszName,
                        (wcslen(wszName) + 1) * sizeof(WCHAR)))
                  goto RegSetValueErr;
        }
        else if ((LPWSTR) 1 == rgRegEntry[dwRegIndex].wszName)
        {
            //Redirect to load the string from the DLL.
            //format the data by inserting the IDS value.
            if (0 == FormatMessageU(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        L"@%%SystemRoot%%\\System32\\cryptext.dll,-%1!u!",
                        0,                  // dwMessageId
                        0,                  // dwLanguageId
                        (LPWSTR) (&pwszCommandName),
                        0,                  // minimum size to allocate
                        (va_list *) &rgRegEntry[dwRegIndex].idsName))
                goto FormatMsgError;

            if(ERROR_SUCCESS !=  RegSetValueExU(
                        hKey, 
                        NULL,
                        0,
                        REG_SZ,
                        (BYTE *) pwszCommandName,
                        (wcslen(pwszCommandName) + 1) * sizeof(WCHAR)))
                  goto RegSetValueErr;
        }
        else
        {
            if(ERROR_SUCCESS !=  RegSetValueExU(
                        hKey, 
                        NULL,
                        0,
                        REG_EXPAND_SZ,
                        (BYTE *)(rgRegEntry[dwRegIndex].wszName),
                        (wcslen(rgRegEntry[dwRegIndex].wszName) + 1) * sizeof(WCHAR)))
                  goto RegSetValueErr;
        }

        //close the registry key
        if(ERROR_SUCCESS  != RegCloseKey(hKey))
            goto RegCloseKeyErr;

        hKey=NULL;

        // free command name string.
        LocalFree((HLOCAL) pwszCommandName);
        pwszCommandName = NULL;
    }

    //some of the registry based context menu is specific for NT5
    if(FIsWinNT5())
    {
        //get the count of the reg entries
        dwRegEntry=sizeof(rgWINNT5RegEntry)/sizeof(rgWINNT5RegEntry[0]);

        for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
        {
            //open a registry entry under HKEY_CLASSES_ROOT
            if (ERROR_SUCCESS != RegCreateKeyExU(
                            HKEY_CLASSES_ROOT,
                            rgWINNT5RegEntry[dwRegIndex].wszKey,
                            0, 
                            NULL, 
                            REG_OPTION_NON_VOLATILE, 
                            KEY_WRITE, 
                            NULL,
                            &hKey, 
                            &dwDisposition))
                goto RegCreateKeyErr;


            //set the value
            if(NULL==rgWINNT5RegEntry[dwRegIndex].wszName)
            {
                //load the string
                if(0==LoadStringU(g_hmodThisDll,rgWINNT5RegEntry[dwRegIndex].idsName,
                                wszName,MAX_STRING_SIZE))
                      goto LoadStringErr;

                if(ERROR_SUCCESS !=  RegSetValueExU(
                            hKey, 
                            NULL,
                            0,
                            REG_SZ,
                            (BYTE *)wszName,
                            (wcslen(wszName) + 1) * sizeof(WCHAR)))
                      goto RegSetValueErr;
            }
            else
            {
                if(ERROR_SUCCESS !=  RegSetValueExU(
                            hKey, 
                            NULL,
                            0,
                            REG_EXPAND_SZ,
                            (BYTE *)(rgWINNT5RegEntry[dwRegIndex].wszName),
                            (wcslen(rgWINNT5RegEntry[dwRegIndex].wszName) + 1) * sizeof(WCHAR)))
                      goto RegSetValueErr;
            }

            //close the registry key
            if(ERROR_SUCCESS  != RegCloseKey(hKey))
                goto RegCloseKeyErr;

            hKey=NULL;

        }
    }

    //now, we need to register for the content type
    //1. Under  the HEKY_CLASSES_ROOT, under ".foo" key, add an entry of name 
    //   "Content Type" and value "application/xxxxxxxx".
    //2. Under HKEY_CLASSES_ROOT\MIME\Database\Content Type, add a key of "application/xxxxxxxx", 
    //   under which add an entry of name "Extension" and value ".foo".
    dwRegEntry=sizeof(rgContentTypeEntry)/sizeof(rgContentTypeEntry[0]);

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {
        //open a registry entry under HKEY_CLASSES_ROOT
        if (ERROR_SUCCESS != RegCreateKeyExU(
                        HKEY_CLASSES_ROOT,
                        rgContentTypeEntry[dwRegIndex].wszKey,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
            goto RegCreateKeyErr;


        //set the value
        if(ERROR_SUCCESS !=  RegSetValueExU(
                    hKey, 
                    L"Content Type",
                    0,
                    REG_SZ,
                    (BYTE *)(rgContentTypeEntry[dwRegIndex].wszName),
                    (wcslen(rgContentTypeEntry[dwRegIndex].wszName) + 1) * sizeof(WCHAR)))
              goto RegSetValueErr;

        //close the registry key
        if(ERROR_SUCCESS  != RegCloseKey(hKey))
            goto RegCloseKeyErr;

        hKey=NULL;
    }

    //2. Under HKEY_CLASSES_ROOT\MIME\Database\Content Type, add a key of "application/xxxxxxxx", 
    //   under which add an entry of name "Extension" and value ".foo".
    dwRegEntry=sizeof(rgContentTypeEntry)/sizeof(rgContentTypeEntry[0]);

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {
        //concatenate the key L"MIME\\Database\\Content Type\\application/XXXXXXXXXX
        wszContentType[0]=L'\0';

        wcscpy(wszContentType, L"MIME\\Database\\Content Type\\");
        wcscat(wszContentType, rgContentTypeEntry[dwRegIndex].wszName);

        //open a registry entry under HKEY_CLASSES_ROOT
        if (ERROR_SUCCESS != RegCreateKeyExU(
                        HKEY_CLASSES_ROOT,
                        wszContentType,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
            goto RegCreateKeyErr;


        //set the value
        if(ERROR_SUCCESS !=  RegSetValueExU(
                    hKey, 
                    L"Extension",
                    0,
                    REG_SZ,
                    (BYTE *)(rgContentTypeEntry[dwRegIndex].wszKey),
                    (wcslen(rgContentTypeEntry[dwRegIndex].wszKey) + 1) * sizeof(WCHAR)))
              goto RegSetValueErr;

        //close the registry key
        if(ERROR_SUCCESS  != RegCloseKey(hKey))
            goto RegCloseKeyErr;

        hKey=NULL;
    }

    //2nd, do the registry based DefaultIcon
    //we do things differently based on Win95 or WinNT
    if(FIsWinNT())
    {
        dwRegEntry=sizeof(rgIconEntry)/sizeof(rgIconEntry[0]);

        for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
        {
            //open a registry entry under HKEY_CLASSES_ROOT
            if (ERROR_SUCCESS != RegCreateKeyExU(
                            HKEY_CLASSES_ROOT,
                            rgIconEntry[dwRegIndex].wszKey,
                            0, 
                            NULL, 
                            REG_OPTION_NON_VOLATILE, 
                            KEY_WRITE, 
                            NULL,
                            &hKey, 
                            &dwDisposition))
                goto RegCreateKeyErr;


                if(ERROR_SUCCESS !=  RegSetValueExU(
                            hKey, 
                            NULL,
                            0,
                            REG_EXPAND_SZ,
                            (BYTE *)(rgIconEntry[dwRegIndex].wszName),
                            (wcslen(rgIconEntry[dwRegIndex].wszName) + 1) * sizeof(WCHAR)))
                      goto RegSetValueErr;

            //close the registry key
            if(ERROR_SUCCESS  != RegCloseKey(hKey))
                goto RegCloseKeyErr;

            hKey=NULL;

        }    
    }
    else
    {
        //get the system directory
        if(!GetSystemDirectory(szSystem, MAX_PATH))
            goto GetSystemErr;

        dwRegEntry=sizeof(rgWin95IconEntry)/sizeof(rgWin95IconEntry[0]);

        for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
        {
            //open a registry entry under HKEY_CLASSES_ROOT
            if (ERROR_SUCCESS != RegCreateKeyEx(
                            HKEY_CLASSES_ROOT,
                            rgWin95IconEntry[dwRegIndex].szKey,
                            0, 
                            NULL, 
                            REG_OPTION_NON_VOLATILE, 
                            KEY_WRITE, 
                            NULL,
                            &hKey, 
                            &dwDisposition))
                goto RegCreateKeyErr;


            //concantenate the values
            strcpy(szValue, szSystem);
            strcat(szValue, (rgWin95IconEntry[dwRegIndex].szName));
                
            if(ERROR_SUCCESS !=  RegSetValueEx(
                            hKey, 
                            NULL,
                            0,
                            REG_SZ,
                            (BYTE *)szValue,
                            (strlen(szValue) + 1) * sizeof(CHAR)))
                      goto RegSetValueErr;

            //close the registry key
            if(ERROR_SUCCESS  != RegCloseKey(hKey))
                goto RegCloseKeyErr;

            hKey=NULL;

        }    
    }


    //3rd, set the .PKO context menu handler and property sheet handler
    //set the values related to the GUIDs
    dwRegEntry=sizeof(rgGuidEntry)/sizeof(rgGuidEntry[0]);

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {

        //load the string
        if(0==LoadStringU(g_hmodThisDll,rgGuidEntry[dwRegIndex].idsName,
                            wszName,MAX_STRING_SIZE))
            goto LoadStringErr;

        //get the string presentation of the CLSID 
        if(0==StringFromGUID2(*(rgGuidEntry[dwRegIndex].pGuid), wszGUID, MAX_STRING_SIZE))
            goto StringFromGUIDErr;

        //open a registry entry under HKEY_CLASSES_ROOT for the context menu handler
        if(NULL!=rgGuidEntry[dwRegIndex].wszKey1)
        {
            if (ERROR_SUCCESS != RegCreateKeyExU(
                            HKEY_CLASSES_ROOT,
                            rgGuidEntry[dwRegIndex].wszKey1,
                            0, 
                            NULL, 
                            REG_OPTION_NON_VOLATILE, 
                            KEY_WRITE, 
                            NULL,
                            &hKey, 
                            &dwDisposition))
                goto RegCreateKeyErr;

            if(ERROR_SUCCESS !=  RegSetValueExU(
                            hKey, 
                            NULL,
                            0,
                            REG_SZ,
                            (BYTE *)wszGUID,
                            (wcslen(wszGUID) + 1) * sizeof(WCHAR)))
                      goto RegSetValueErr;

            //close the registry key
            if(ERROR_SUCCESS  != RegCloseKey(hKey))
                goto RegCloseKeyErr;

            hKey=NULL;

        }
        //open a registry entry under HKEY_CLASSES_ROOT for the property sheet hander
        if (ERROR_SUCCESS != RegCreateKeyExU(
                        HKEY_CLASSES_ROOT,
                        rgGuidEntry[dwRegIndex].wszKey2,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
            goto RegCreateKeyErr;

        if(ERROR_SUCCESS !=  RegSetValueExU(
                        hKey, 
                        NULL,
                        0,
                        REG_SZ,
                        (BYTE *)wszGUID,
                        (wcslen(wszGUID) + 1) * sizeof(WCHAR)))
                  goto RegSetValueErr;

        //close the registry key
        if(ERROR_SUCCESS  != RegCloseKey(hKey))
            goto RegCloseKeyErr;

        hKey=NULL;


        //open a registry entry under HKEY_LOCAL_MACHINE
        if (ERROR_SUCCESS != RegCreateKeyExU(
                        HKEY_LOCAL_MACHINE,
                        rgGuidEntry[dwRegIndex].wszKey3,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
            goto RegCreateKeyErr;

        if(ERROR_SUCCESS !=  RegSetValueExU(
                        hKey, 
                        wszGUID,
                        0,
                        REG_SZ,
                        (BYTE *)wszName,
                        (wcslen(wszName) + 1) * sizeof(WCHAR)))
                  goto RegSetValueErr;

        //close the registry key
        if(ERROR_SUCCESS  != RegCloseKey(hKey))
            goto RegCloseKeyErr;

        hKey=NULL;
    }

    //now, under the classID of &CLSID_CryptPKO, we need to add 
    //the registry shellex\MayChangeDefaultMenu
    dwRegEntry=sizeof(g_CLSIDDefault)/sizeof(g_CLSIDDefault[0]);

   //get the string presentation of the CLSID 
   if(0==StringFromGUID2(CLSID_CryptPKO, wszGUID, MAX_STRING_SIZE))
        goto StringFromGUIDErr;

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {
        wcscpy(wszDefault, L"CLSID\\");

        wcscat(wszDefault, wszGUID);

        wcscat(wszDefault, g_CLSIDDefault[dwRegIndex]);

        if (ERROR_SUCCESS != RegCreateKeyExU(
                        HKEY_CLASSES_ROOT,
                        wszDefault,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
            goto RegCreateKeyErr;

        if(ERROR_SUCCESS  != RegCloseKey(hKey))
            goto RegCloseKeyErr;

        hKey=NULL;

    }

    // Set the FriendlyTypeName value for the new MUI requirement of Whistler.
    dwRegEntry=sizeof(rgFriendlyTypeNameEntry)/sizeof(rgFriendlyTypeNameEntry[0]);

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {
        //format the data by inserting the IDS value.
        if (0 == FormatMessageU(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    rgFriendlyTypeNameEntry[dwRegIndex].wszName,
                    0,                  // dwMessageId
                    0,                  // dwLanguageId
                    (LPWSTR) (&pwszFriendlyTypeName),
                    0,                  // minimum size to allocate
                    (va_list *) &rgFriendlyTypeNameEntry[dwRegIndex].idsName))
            goto FormatMsgError;

        //open a registry entry under HKEY_CLASSES_ROOT
        if (ERROR_SUCCESS != RegCreateKeyExU(
                        HKEY_CLASSES_ROOT,
                        rgFriendlyTypeNameEntry[dwRegIndex].wszKey,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
            goto RegCreateKeyErr;

        //set the value
        if(ERROR_SUCCESS != RegSetValueExU(
                    hKey, 
                    L"FriendlyTypeName",
                    0,
                    REG_EXPAND_SZ,
                    (BYTE *) pwszFriendlyTypeName,
                    (wcslen(pwszFriendlyTypeName) + 1) * sizeof(WCHAR)))
              goto RegSetValueErr;

        //close the registry key
        if(ERROR_SUCCESS  != RegCloseKey(hKey))
            goto RegCloseKeyErr;

        hKey=NULL;

        // free friendly name type string.
        LocalFree((HLOCAL) pwszFriendlyTypeName);
        pwszFriendlyTypeName = NULL;
    }

	hr=S_OK;

CommonReturn:
	
    if(hKey)
        RegCloseKey(hKey);

    if(pwszCommandName)
        LocalFree((HLOCAL) pwszCommandName);

    if(pwszFriendlyTypeName)
        LocalFree((HLOCAL) pwszFriendlyTypeName);

	return hr;

ErrorReturn:
	hr=GetLastError();

	goto CommonReturn;


TRACE_ERROR(RegCloseKeyErr);
TRACE_ERROR(RegCreateKeyErr);
TRACE_ERROR(LoadStringErr);
TRACE_ERROR(RegSetValueErr);
TRACE_ERROR(StringFromGUIDErr);
TRACE_ERROR(GetSystemErr);
TRACE_ERROR(FormatMsgError);
}


//--------------------------------------------------------------------------
//
//	  UnregisterMimeHandler
//
//--------------------------------------------------------------------------
HRESULT UnregisterMimeHandler()
{
                                    
    HKEY        hKey=NULL;
    DWORD       dwRegEntry=0;
    DWORD       dwRegIndex=0;
    WCHAR       wszGUID[MAX_STRING_SIZE];
    DWORD       dwDisposition=0;
    WCHAR       wszDefault[MAX_STRING_SIZE*2];
    WCHAR       wszContentType[MAX_STRING_SIZE];

    //1st, delete the entries related to the GUID
    //that is, the .PKO context menu handler and property sheet handler
    dwRegEntry=sizeof(rgGuidEntry)/sizeof(rgGuidEntry[0]);

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {
        //get the string presentation of the CLSID
        if(0==StringFromGUID2(*(rgGuidEntry[dwRegIndex].pGuid), wszGUID, MAX_STRING_SIZE))
            continue;

        //open a registry entry under HKEY_LOCAL_MACHINE
        if (ERROR_SUCCESS == RegCreateKeyExU(
                        HKEY_LOCAL_MACHINE,
                        rgGuidEntry[dwRegIndex].wszKey3,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
        {

            RegDeleteValueU(hKey,wszGUID);

            //close the registry key
            RegCloseKey(hKey);

            hKey=NULL;
        }

        //delete a registry entry under HKEY_CLASSES_ROOT for property sheet
        RegDeleteKeyU(HKEY_CLASSES_ROOT,
                      rgGuidEntry[dwRegIndex].wszKey2);

        //delete a registry entry under HKEY_CLASSES_ROOT for context menu
        if(NULL !=rgGuidEntry[dwRegIndex].wszKey1)
        {
            RegDeleteKeyU(HKEY_CLASSES_ROOT,
                      rgGuidEntry[dwRegIndex].wszKey1);
        }
    }
  
    //2nd, detelet all the registry based context menu and Icon
    //get the count of the reg entries
    dwRegEntry=sizeof(rgwszDelete)/sizeof(rgwszDelete[0]);

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
        //delete the registry entries
        RegDeleteKeyU(HKEY_CLASSES_ROOT,rgwszDelete[dwRegIndex]);

    //now, delete anything related to the content type
    dwRegEntry=sizeof(rgContentTypeEntry)/sizeof(rgContentTypeEntry[0]);

    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {
        wszContentType[0]=L'\0';

        wcscpy(wszContentType, L"MIME\\Database\\Content Type\\");
        wcscat(wszContentType, rgContentTypeEntry[dwRegIndex].wszName);

        RegDeleteKeyU(HKEY_CLASSES_ROOT,wszContentType);
    }
    


    //3nd, under the classID of &CLSID_CryptPKO, we need to delete 
    //the registry shellex\MayChangeDefaultMenu
    dwRegEntry=sizeof(g_CLSIDDefault)/sizeof(g_CLSIDDefault[0]);

   //get the string presentation of the CLSID 
   if(0==StringFromGUID2(CLSID_CryptPKO, wszGUID, MAX_STRING_SIZE))
        return S_OK;


    for(dwRegIndex=0; dwRegIndex<dwRegEntry; dwRegIndex++)
    {
        wcscpy(wszDefault, L"CLSID\\");

        wcscat(wszDefault, wszGUID);

        wcscat(wszDefault, g_CLSIDDefault[dwRegIndex]);

        RegDeleteKeyU(HKEY_CLASSES_ROOT,wszDefault);

    }


	return S_OK;
}

//--------------------------------------------------------------------------
//
//	  View a CTL context
//
//--------------------------------------------------------------------------
void    I_ViewCTL(PCCTL_CONTEXT pCTLContext)
{

    CRYPTUI_VIEWCTL_STRUCT     ViewCTLStruct;

    if(NULL==pCTLContext)
        return;

    //memset
    memset(&ViewCTLStruct, 0, sizeof(ViewCTLStruct));
    ViewCTLStruct.dwSize=sizeof(ViewCTLStruct);
    ViewCTLStruct.pCTLContext=pCTLContext;

    CryptUIDlgViewCTL(&ViewCTLStruct);
}

//--------------------------------------------------------------------------
//
//	  View a signer Info
//
//--------------------------------------------------------------------------
/*void    I_ViewSignerInfo(HCRYPTMSG  hMsg)
{

    CERT_VIEWSIGNERINFO_STRUCT_W    ViewSignerInfoStruct;
    PCMSG_SIGNER_INFO               pSignerInfo=NULL;
    HCERTSTORE                      hCertStore=NULL;
    DWORD                           cbData=0;

    //get the cert store from the hMsg
    hCertStore=CertOpenStore(CERT_STORE_PROV_MSG,
                              X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                              NULL,
                              0,
                              hMsg);

    if(NULL==hCertStore)
        goto CLEANUP;

    //get the signer info struct
    if(!CryptMsgGetParam(hMsg, 
                         CMSG_SIGNER_INFO_PARAM,
                         0,
                         NULL,
                         &cbData))
        goto CLEANUP;

    pSignerInfo=(PCMSG_SIGNER_INFO)malloc(cbData);
    if(NULL==pSignerInfo)
        goto CLEANUP;

    if(!CryptMsgGetParam(hMsg, 
                         CMSG_SIGNER_INFO_PARAM,
                         0,
                         pSignerInfo,
                         &cbData))
        goto CLEANUP;

   //Init
    memset(&ViewSignerInfoStruct, 0, sizeof(ViewSignerInfoStruct));
    ViewSignerInfoStruct.dwSize=sizeof(ViewSignerInfoStruct);
    ViewSignerInfoStruct.pSignerInfo=pSignerInfo;
    ViewSignerInfoStruct.cStores=1;
    ViewSignerInfoStruct.rghStores=&hCertStore;

    CertViewSignerInfo_W(&ViewSignerInfoStruct);

CLEANUP:
    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    if(pSignerInfo)
        free(pSignerInfo);
    
}    */




//---------------------------------------------------------------------------------
//
//  Check is the PKCS signed MSG has a signerInfo attached
//
//---------------------------------------------------------------------------------
BOOL    PKCS7WithSignature(HCRYPTMSG    hMsg)
{
    DWORD   dwSignerCount=0;
    DWORD   cbSignerCount=0;

    if(NULL==hMsg)
        return FALSE;

    cbSignerCount=sizeof(dwSignerCount);

    //get the Param CMSG_SIGNER_COUNT_PARAM on the message handle
    //if 0==CMSG_SIGNER_COUNT_PARAM, there is no signerInfo
    //on the message handle
    if(!CryptMsgGetParam(hMsg,
                        CMSG_SIGNER_COUNT_PARAM,
                        0,
                        &dwSignerCount,
                        &cbSignerCount))
        return FALSE;

    if(0==dwSignerCount)
        return FALSE;

    return TRUE;

}

//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for CER and CRT file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenCERW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    PCCERT_CONTEXT      pCertContext=NULL;
    CRYPTUI_VIEWCERTIFICATE_STRUCT CertViewStruct;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;

    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_CERT,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       (const void **)&pCertContext))
    {
        //call the Certificate Common Dialogue
       memset(&CertViewStruct, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));

       CertViewStruct.dwSize=sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT);
       CertViewStruct.pCertContext=pCertContext;
       
       CryptUIDlgViewCertificate(&CertViewStruct,NULL);

    }
    else
    {
       I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_CER_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }

    if(pCertContext)
        CertFreeCertificateContext(pCertContext);

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for CER and CRT file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenCER(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    HRESULT             hr=S_OK;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    hr=CryptExtOpenCERW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return hr;
}

BOOL    IsCatalog(PCCTL_CONTEXT pCTLContext)
{
    BOOL    fRet=FALSE;

    if (pCTLContext)
    {
        if (pCTLContext->pCtlInfo)
        {
            if(pCTLContext->pCtlInfo->SubjectUsage.cUsageIdentifier)
            {
                if (pCTLContext->pCtlInfo->SubjectUsage.rgpszUsageIdentifier)
                {
                    if (strcmp(pCTLContext->pCtlInfo->SubjectUsage.rgpszUsageIdentifier[0],
                                szOID_CATALOG_LIST) == 0)
                    {
                        fRet = TRUE;
                   }
                }
            }
        }
    }

    return fRet;

}
//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .CTL file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenCATW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    PCCTL_CONTEXT       pCTLContext=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;


    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_CTL,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       (const void **)&pCTLContext) &&
                       IsCatalog(pCTLContext))
    {
        I_ViewCTL(pCTLContext);    
    }
    else
    {

        
       I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_CAT_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }

    if(pCTLContext)
        CertFreeCTLContext(pCTLContext);

    return S_OK;
}


//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .CTL file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenCAT(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtOpenCATW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for .PFX File
//---------------------------------------------------------------------------------
STDAPI CryptExtAddPFXW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    CRYPTUI_WIZ_IMPORT_SRC_INFO importSubject;   
        
    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;


    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_PFX,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL))
    {

        memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
        importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
        importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_FILE;
        importSubject.pwszFileName=pwszFileName;

        CryptUIWizImport(0,
                        NULL,
                        NULL,
                        &importSubject, 
                        NULL);
    }
    else
    {

       I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_PFX_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for .PFX File
//---------------------------------------------------------------------------------
STDAPI CryptExtAddPFX(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
        
    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtAddPFXW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}
//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for CER and CRT file
//---------------------------------------------------------------------------------
STDAPI CryptExtAddCERW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    PCCERT_CONTEXT      pCertContext=NULL;
    CRYPTUI_WIZ_IMPORT_SRC_INFO importSubject;   
        
    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;



    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_CERT,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       (const void **)&pCertContext))
    {
        memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
        importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
        importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT;
        importSubject.pCertContext=pCertContext;

        CryptUIWizImport(0,
                        NULL,
                        NULL,
                        &importSubject, 
                        NULL);
    }
    else
    {

        I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_CER_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }

    if(pCertContext)
        CertFreeCertificateContext(pCertContext);

    return S_OK;
}


//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for CER and CRT file
//---------------------------------------------------------------------------------
STDAPI CryptExtAddCER(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
        
    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);



    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtAddCERW(hinst, hPrevInstance,pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}
//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .CTL file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenCTLW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    PCCTL_CONTEXT       pCTLContext=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;

    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_CTL,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       (const void **)&pCTLContext))
    {
        I_ViewCTL(pCTLContext);    
    }
    else
    {
        I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_STL_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);


    }

    if(pCTLContext)
        CertFreeCTLContext(pCTLContext);

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .CTL file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenCTL(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtOpenCTLW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}
//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for .CTL file
//---------------------------------------------------------------------------------
STDAPI CryptExtAddCTLW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    PCCTL_CONTEXT       pCTLContext=NULL;
    CRYPTUI_WIZ_IMPORT_SRC_INFO importSubject;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;

    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_CTL,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       (const void **)&pCTLContext))
    {
         memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
        importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
        importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_CTL_CONTEXT;
        importSubject.pCTLContext=pCTLContext;

        CryptUIWizImport(0,
                        NULL,
                        NULL,
                        &importSubject, 
                        NULL);
    }
    else
    {
        I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_STL_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }

    if(pCTLContext)
        CertFreeCTLContext(pCTLContext);

    return S_OK;
}


//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for .CTL file
//---------------------------------------------------------------------------------
STDAPI CryptExtAddCTL(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtAddCTLW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);


    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .CRL file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenCRLW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR                  pwszFileName=NULL;
    PCCRL_CONTEXT           pCRLContext=NULL;
    CRYPTUI_VIEWCRL_STRUCT  CRLViewStruct;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;

    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_CRL,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       (const void **)&pCRLContext))
    {
        //call the CRL view dialogue
        memset(&CRLViewStruct, 0, sizeof(CRYPTUI_VIEWCRL_STRUCT));

        CRLViewStruct.dwSize=sizeof(CRYPTUI_VIEWCRL_STRUCT);
        CRLViewStruct.pCRLContext=pCRLContext;

        CryptUIDlgViewCRL(&CRLViewStruct);
    }
    else
    {
       
        I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_CRL_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
        
    }

    if(pCRLContext)
        CertFreeCRLContext(pCRLContext);

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .CRL file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenCRL(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR                  pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtOpenCRLW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}
//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for .CRL file
//---------------------------------------------------------------------------------
STDAPI CryptExtAddCRLW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    PCCRL_CONTEXT       pCRLContext=NULL;
    CRYPTUI_WIZ_IMPORT_SRC_INFO importSubject;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;


    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_CRL,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       (const void **)&pCRLContext))
    {
        memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
        importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
        importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_CRL_CONTEXT;
        importSubject.pCRLContext=pCRLContext;

        CryptUIWizImport(0,
                        NULL,
                        NULL,
                        &importSubject, 
                        NULL);
    }
    else
    {

        I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_CRL_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }

    if(pCRLContext)
        CertFreeCRLContext(pCRLContext);

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for .CRL file
//---------------------------------------------------------------------------------
STDAPI CryptExtAddCRL(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtAddCRLW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}
//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .SPC, .P7S, .P7B, .P7M file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenPKCS7W(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    HCERTSTORE          hCertStore=NULL;
    HCRYPTMSG           hMsg=NULL;

    DWORD               dwContentType=0;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;

    //check the object type.  Make sure the PKCS7 is not embedded
    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       &dwContentType,
                       NULL,
                       &hCertStore,
                       &hMsg,
                       NULL) )
    {
        LauchCertMgr(pwszFileName);    
    }
    else
    {

        I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_PKCS7_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);

    }

    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    if(hMsg)
        CryptMsgClose(hMsg);

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .SPC, .P7S, .P7B, .P7M file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenPKCS7(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtOpenPKCS7W(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}
//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for .SPC file
//---------------------------------------------------------------------------------
STDAPI CryptExtAddSPCW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    HCERTSTORE          hCertStore=NULL;

    CRYPTUI_WIZ_IMPORT_SRC_INFO importSubject;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;

    //check the object type.  Make sure the PKCS7 is not embedded
    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       &hCertStore,
                       NULL,
                       NULL) )
    {
        memset(&importSubject, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
        importSubject.dwSize=sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
        importSubject.dwSubjectChoice=CRYPTUI_WIZ_IMPORT_SUBJECT_FILE;
        importSubject.pwszFileName=pwszFileName;

        CryptUIWizImport(0,
                        NULL,
                        NULL,
                        &importSubject, 
                        NULL);
    }
    else
    {
        I_NoticeBox(
 		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_SPC_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }

    return S_OK;
}


//---------------------------------------------------------------------------------
//
//  Handler the command line "Add" for .SPC file
//---------------------------------------------------------------------------------
STDAPI CryptExtAddSPC(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtAddSPCW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .p7r file.  This file is returned by
//  certificate authority
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenP7RW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    CRYPT_DATA_BLOB         PKCS7Blob;
    IEnroll                 *pIEnroll=NULL;
    LPWSTR                  pwszFileName=NULL;
    PCCERT_CONTEXT          pCertContext=NULL;
 
    CRYPTUI_VIEWCERTIFICATE_STRUCT  ViewCertStruct;
    UINT                            ids=IDS_INSTALL_CERT_SUCCEEDED;

    //init
    memset(&PKCS7Blob, 0, sizeof(CRYPT_DATA_BLOB));

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;

    
 	if(FAILED(CoInitialize(NULL)))
    {
        ids=IDS_NO_XENROLL;
        goto CLEANUP;
    }

    //initialize information for xEnroll
	if(FAILED(CoCreateInstance(CLSID_CEnroll,
		NULL,CLSCTX_INPROC_SERVER,IID_IEnroll,
		(LPVOID *)&pIEnroll)))
    {
        ids=IDS_NO_XENROLL;
        goto CLEANUP;
    }

    //get the BLOB from the file
    if(S_OK != RetrieveBLOBFromFile(pwszFileName,&(PKCS7Blob.cbData),
                                    &(PKCS7Blob.pbData)))
    {
        ids=IDS_INVALID_P7R_FILE;
        goto CLEANUP;
    }

    //get the certifcate context
    if(NULL==(pCertContext=pIEnroll->getCertContextFromPKCS7(&PKCS7Blob)))
    {
        ids=IDS_INVALID_P7R_FILE;
        goto CLEANUP;
    }

    memset(&ViewCertStruct, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));
    ViewCertStruct.dwSize=sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT);         
    ViewCertStruct.hwndParent=NULL;     
    ViewCertStruct.dwFlags=CRYPTUI_ACCEPT_DECLINE_STYLE;        
    ViewCertStruct.pCertContext=pCertContext;   
    ViewCertStruct.cStores=0;        
    ViewCertStruct.rghStores=NULL;      

    if(!CryptUIDlgViewCertificate(&ViewCertStruct,NULL))
        goto CLEANUP;

    if(S_OK !=(pIEnroll->acceptPKCS7Blob(&PKCS7Blob)))
    {
        ids=IDS_FAIL_TO_INSTALL;
        goto CLEANUP;
    }


CLEANUP:

    I_MessageBox(
            NULL, 
            ids,
            IDS_P7R_NAME,
            NULL,  
            MB_OK|MB_APPLMODAL);


    if(PKCS7Blob.pbData)
        UnmapViewOfFile(PKCS7Blob.pbData);

    if(pCertContext)
        CertFreeCertificateContext(pCertContext);

    if(pIEnroll)
        pIEnroll->Release();

    CoUninitialize( );

    return S_OK;
}


//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .p7r file.  This file is returned by
//  certificate authority
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenP7R(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR                  pwszFileName=NULL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtOpenP7RW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .p7r file.  This file is returned by
//  certificate authority
//---------------------------------------------------------------------------------
STDAPI CryptExtAddP7RW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    CRYPT_DATA_BLOB         PKCS7Blob;
    IEnroll                 *pIEnroll=NULL;
    LPWSTR                  pwszFileName=NULL;
    UINT                    ids=IDS_INSTALL_CERT_SUCCEEDED;

    //init
    memset(&PKCS7Blob, 0, sizeof(CRYPT_DATA_BLOB));

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;

 	if(FAILED(CoInitialize(NULL)))
    {
        ids=IDS_NO_XENROLL;
        goto CLEANUP;
    }

    //initialize information for xEnroll
	if(FAILED(CoCreateInstance(CLSID_CEnroll,
		NULL,CLSCTX_INPROC_SERVER,IID_IEnroll,
		(LPVOID *)&pIEnroll)))
    {
        ids=IDS_NO_XENROLL;
        goto CLEANUP;
    }

    //get the BLOB from the file
    if(S_OK != RetrieveBLOBFromFile(pwszFileName,&(PKCS7Blob.cbData),
                                    &(PKCS7Blob.pbData)))
    {
        ids=IDS_INVALID_P7R_FILE;
        goto CLEANUP;
    }

    if(S_OK !=(pIEnroll->acceptPKCS7Blob(&PKCS7Blob)))
    {
        ids=IDS_FAIL_TO_INSTALL;
        goto CLEANUP;
    }


CLEANUP:

    I_MessageBox(
            NULL, 
            ids,
            IDS_P7R_NAME,
            NULL,  
            MB_OK|MB_APPLMODAL);


    if(PKCS7Blob.pbData)
        UnmapViewOfFile(PKCS7Blob.pbData);

    if(pIEnroll)
        pIEnroll->Release();

    
    CoUninitialize( );

    return S_OK;
}

//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .p7r file.  This file is returned by
//  certificate authority
//---------------------------------------------------------------------------------
STDAPI CryptExtAddP7R(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR                  pwszFileName=NULL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtAddP7RW(hinst, hPrevInstance, pwszFileName, nCmdShow);

   if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}
//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .sst file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenSTRW(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;
    HCERTSTORE          hCertStore=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;

    //check the object type.  
    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |
                       CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT |
                       CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL |
                       CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       &hCertStore,
                       NULL,
                       NULL))
    {
        LauchCertMgr(pwszFileName);
    }
    else
    {

        I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_SST_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }

    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    return S_OK;
}


//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .sst file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenSTR(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtOpenSTRW(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}


//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .p10 file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenP10W(HINSTANCE hinst, HINSTANCE hPrevInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=lpszCmdLine;


    //check the object type.  
    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pwszFileName,
                       CERT_QUERY_CONTENT_FLAG_PKCS10,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL))
    {
        I_NoticeBox(
        	0,
			0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_P10_NAME,
            IDS_MSG_VALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }
    else
    {
        I_NoticeBox(
		    GetLastError(),
            0,
            NULL, 
            IDS_MSG_TITLE,
            IDS_P10_NAME,
            IDS_MSG_INVALID_FILE,  
            MB_OK|MB_ICONINFORMATION);
    }

    return S_OK;
}
//---------------------------------------------------------------------------------
//
//  Mime Handler the command line "Open" for .p10 file
//---------------------------------------------------------------------------------
STDAPI CryptExtOpenP10(HINSTANCE hinst, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    LPWSTR              pwszFileName=NULL;

    if (!lpszCmdLine)
       return E_FAIL;

    //get the WCHAR file name
    pwszFileName=MkWStr(lpszCmdLine);

    if(NULL==pwszFileName)
        return HRESULT_FROM_WIN32(GetLastError());

    CryptExtOpenP10W(hinst, hPrevInstance, pwszFileName, nCmdShow);

    if(pwszFileName)
        FreeWStr(pwszFileName);

    return S_OK;
}


//--------------------------------------------------------------------------------
//
//get the bytes from the file name
//
//---------------------------------------------------------------------------------
HRESULT RetrieveBLOBFromFile(LPWSTR	pwszFileName,DWORD *pcb,BYTE **ppb)
{



	HRESULT	hr=E_FAIL;
	HANDLE	hFile=NULL;  
    HANDLE  hFileMapping=NULL;

    DWORD   cbData=0;
    BYTE    *pbData=0;
	DWORD	cbHighSize=0;

	if(!pcb || !ppb || !pwszFileName)
		return E_INVALIDARG;

	*ppb=NULL;
	*pcb=0;

    if ((hFile = CreateFileU(pwszFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,                   // lpsa
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL)) == INVALID_HANDLE_VALUE)
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }
        
    if((cbData = GetFileSize(hFile, &cbHighSize)) == 0xffffffff)
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

	//we do not handle file more than 4G bytes
	if(cbHighSize != 0)
	{
			hr=E_FAIL;
			goto CLEANUP;
	}
    
    //create a file mapping object
    if(NULL == (hFileMapping=CreateFileMapping(
                hFile,             
                NULL,
                PAGE_READONLY,
                0,
                0,
                NULL)))
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }
 
    //create a view of the file
	if(NULL == (pbData=(BYTE *)MapViewOfFile(
		hFileMapping,  
		FILE_MAP_READ,     
		0,
		0,
		cbData)))
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

	hr=S_OK;

	*pcb=cbData;
	*ppb=pbData;

CLEANUP:

	if(hFile)
		CloseHandle(hFile);

	if(hFileMapping)
		CloseHandle(hFileMapping);

	return hr;


}

//-----------------------------------------------------------------------
// Private implementation of the message box
//------------------------------------------------------------------------
int     I_NoticeBox(
			DWORD		dwError,
            DWORD       dwFlags,
            HWND        hWnd, 
            UINT        idsTitle,
            UINT        idsFileName,
            UINT        idsMsgFormat,  
            UINT        uType)
{
    WCHAR   wszTitle[MAX_STRING_SIZE];
    WCHAR   wszFileName[MAX_STRING_SIZE];
    WCHAR   wszMsg[MAX_STRING_SIZE];
    WCHAR   wszMsgFormat[MAX_STRING_SIZE];

	if(!LoadStringU(g_hmodThisDll, idsTitle, wszTitle, sizeof(wszTitle) / sizeof(wszTitle[0])))
		return 0;

    if(!LoadStringU(g_hmodThisDll, idsFileName, wszFileName, sizeof(wszFileName) / sizeof(wszFileName[0])))
        return 0;

	if(E_ACCESSDENIED == dwError)
	{
		if(!LoadStringU(g_hmodThisDll, IDS_ACCESS_DENIED, wszMsgFormat, sizeof(wszMsgFormat) / sizeof(wszMsgFormat[0])))
			return 0;
	}
	else
	{
		if(!LoadStringU(g_hmodThisDll, idsMsgFormat, wszMsgFormat, sizeof(wszMsgFormat) / sizeof(wszMsgFormat[0])))
			return 0;
	}

    //make the string
#if (0) // DSIE: Security code reviewed 02/19/2002.
        //       This can overflow anytime.
    if(0 == swprintf(wszMsg, wszMsgFormat, wszFileName))
#else
    if(0 == _snwprintf(wszMsg, sizeof(wszMsg) / sizeof(wszMsg[0]), wszMsgFormat, wszFileName))
#endif
        return 0;

    return MessageBoxU(hWnd, wszMsg, wszTitle, uType);
}

//-----------------------------------------------------------------------
// Private implementation of the message box 
//------------------------------------------------------------------------
int I_MessageBox(
    HWND        hWnd, 
    UINT        idsText,
    UINT        idsCaption,
    LPCWSTR     pwszCaption,  
    UINT        uType  
)
{
    WCHAR   wszText[MAX_STRING_SIZE];
    WCHAR   wszCaption[MAX_STRING_SIZE];
    UINT    intReturn=0;

    //get the caption string
    if(NULL == pwszCaption)
    {
        if(!LoadStringU(g_hmodThisDll, idsCaption, wszCaption, sizeof(wszCaption) / sizeof(wszCaption[0])))
             return 0;
    }

    //get the text string
    if(!LoadStringU(g_hmodThisDll, idsText, wszText, sizeof(wszText) / sizeof(wszText[0])))
    {
        return 0;
    }

    //message box
    if( pwszCaption)
    {
        intReturn=MessageBoxU(hWnd, wszText, pwszCaption, uType);
    }
    else
        intReturn=MessageBoxU(hWnd, wszText, wszCaption, uType);

    return intReturn;

}


//--------------------------------------------------------------------------
//
//	  FormatMessageUnicode
//
//--------------------------------------------------------------------------
BOOL	FormatMessageUnicode(LPWSTR	*ppwszFormat,UINT ids,...)
{
    // get format string from resources
    WCHAR		wszFormat[1000];
	va_list		argList;
	DWORD		cbMsg=0;
	BOOL		fResult=FALSE;
	HRESULT		hr=S_OK;

    if(NULL == ppwszFormat)
        goto InvalidArgErr;

    if(!LoadStringU(g_hmodThisDll, ids, wszFormat, sizeof(wszFormat) / sizeof(wszFormat[0])))
        goto LoadStringError;

    // format message into requested buffer
    va_start(argList, ids);

    cbMsg = FormatMessageU(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        wszFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPWSTR) (ppwszFormat),
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);

	if(!cbMsg)
		goto FormatMessageError;

	fResult=TRUE;

CommonReturn:
	
	return fResult;

ErrorReturn:
	fResult=FALSE;

	goto CommonReturn;


TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//--------------------------------------------------------------------------
//
//	  LauchCertMgr()
//
//      We use W version of APIs since this call is only made on WinNT5
//
//--------------------------------------------------------------------------
void    LauchCertMgr(LPWSTR pwszFileName)
{
    LPWSTR              pwszCommandParam=NULL;
	LPWSTR				pwszRealFileName=NULL;

    WCHAR               wszMSCFileName[_MAX_PATH * 2];
    WCHAR               wszSystemDirectory[_MAX_PATH];


	if(NULL == pwszFileName)
		return;


	pwszRealFileName=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(pwszFileName)+10));

	if(NULL == pwszRealFileName)
		return;

	//add the " around the file name
	wcscpy(pwszRealFileName, L"\"");

	wcscat(pwszRealFileName, pwszFileName);

	wcscat(pwszRealFileName, L"\"");
    
     //Open the MMC via "MMC.exe CertMgr.msc /certmgr:FileName=MyFoo.Exe"

    //get the system path
    if(GetSystemDirectoryW(wszSystemDirectory, sizeof(wszSystemDirectory)/sizeof(wszSystemDirectory[0])))
    {
        //copy the system directory
        wcscpy(wszMSCFileName, wszSystemDirectory);

        //cancatecate the string \certmgr.msc
        wcscat(wszMSCFileName, CERTMGR_MSC);

        //make the string "MMC.exe c:\winnt\system32\CertMgr.msc /certmgr:FileName=MyFoo.Exe"
        if(FormatMessageUnicode(&pwszCommandParam, IDS_MMC_PARAM,
                            wszMSCFileName, pwszRealFileName))
        {

            ShellExecuteW(NULL,
                          L"Open",
                          MMC_NAME,
                          pwszCommandParam, 
                          wszSystemDirectory,
                          SW_SHOWNORMAL);
        }

    }

    if(pwszCommandParam)
        LocalFree((HLOCAL)pwszCommandParam);

	if(pwszRealFileName)
		LocalFree((HLOCAL)pwszRealFileName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\convutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       convutil.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
LPSTR CertUIMkMBStr(LPCWSTR pwsz)
{
    int     cb;
    LPSTR   psz;

    if (pwsz == NULL)
    {
        return NULL;
    }
    
    cb = WideCharToMultiByte(
                    0,
                    0,
                    pwsz,
                    -1,
                    NULL,
                    0,
                    NULL,
                    NULL);
            
    if (NULL == (psz = (LPSTR) malloc(cb)))
    {
        SetLastError(E_OUTOFMEMORY);
        return NULL;
    }

    WideCharToMultiByte(
                0,
                0,
                pwsz,
                -1,
                psz,
                cb,
                NULL,
                NULL);

    return(psz);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
LPWSTR CertUIMkWStr(LPCSTR psz)
{
    int     cWChars;
    LPWSTR   pwsz;

    if (psz == NULL)
    {
        return NULL;
    }

    cWChars = MultiByteToWideChar(
                    0,
                    0,
                    psz,
                    -1,
                    NULL,
                    0);
            
    if (NULL == (pwsz = (LPWSTR) malloc(cWChars * sizeof(WCHAR))))
    {
        SetLastError(E_OUTOFMEMORY);
        return NULL;
    }

    MultiByteToWideChar(
                    0,
                    0,
                    psz,
                    -1,
                    pwsz,
                    cWChars);

    return(pwsz);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
LPSTR AllocAndCopyMBStr(LPCSTR psz)
{
    LPSTR   pszReturn;

    if (NULL == (pszReturn = (LPSTR) malloc(strlen(psz)+1)))
    {
        SetLastError(E_OUTOFMEMORY);
        return NULL;
    }
    strcpy(pszReturn, psz);

    return(pszReturn);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
LPWSTR AllocAndCopyWStr(LPCWSTR pwsz)
{
    LPWSTR   pwszReturn;

    if (NULL == (pwszReturn = (LPWSTR) malloc((wcslen(pwsz)+1) * sizeof(WCHAR))))
    {
        SetLastError(E_OUTOFMEMORY);
        return NULL;
    }
    wcscpy(pwszReturn, pwsz);

    return(pwszReturn);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
LPPROPSHEETPAGEA ConvertToPropPageA(LPCPROPSHEETPAGEW ppage, DWORD cPages)
{
    PROPSHEETPAGEA *ppageA;
    DWORD i;
    DWORD dwSize;
    
    if (NULL == (ppageA = (PROPSHEETPAGEA *) malloc(sizeof(PROPSHEETPAGEA) * cPages)))
    {
        SetLastError(E_OUTOFMEMORY);
        return NULL;
    };

    // DSIE: Bug 590638.
    memset(ppageA, 0, sizeof(PROPSHEETPAGEA) * cPages);
    dwSize = sizeof(PROPSHEETPAGEA) < ppage->dwSize ? sizeof(PROPSHEETPAGEA) : ppage->dwSize;

    for (i = 0; i < cPages; i++)
    {
        memcpy(&ppageA[i], ppage, dwSize);
        ppageA[i].dwSize = sizeof(PROPSHEETPAGEA);

        // In the future we may need to handle the pszTemplate and pszIcon fields
        if (ppage->pszTitle != NULL)
        {
            ppageA[i].pszTitle = CertUIMkMBStr(ppage->pszTitle);
        }

        ppage = (LPCPROPSHEETPAGEW) (((LPBYTE) ppage) + ppage->dwSize);
    }

    return(ppageA);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void FreePropSheetPagesA(LPPROPSHEETPAGEA ppage, DWORD cPages)
{
    DWORD i;

    for (i=0; i<cPages; i++)
    {
        // In the future we may need to handle the pszTemplate and pszIcon fields
        if (ppage[i].pszTitle != NULL)
        {
            free((void *)ppage[i].pszTitle);
        }
    }

    free(ppage);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL ConvertToPropPageW(LPCPROPSHEETPAGEA ppage, DWORD cPages, LPCPROPSHEETPAGEW *pppageW)
{
    PROPSHEETPAGEW * ppageW;
    DWORD i;
    DWORD dwSize;

    if (cPages == 0)
    {
        *pppageW = NULL;
        return TRUE;
    }
    
    if (NULL == (ppageW = (PROPSHEETPAGEW *) malloc(sizeof(PROPSHEETPAGEW) * cPages)))
    {
        SetLastError(E_OUTOFMEMORY);
        return FALSE;
    }

    // DSIE: Bug 590638.
    memset(ppageW, 0, sizeof(PROPSHEETPAGEW) * cPages);
    dwSize = sizeof(PROPSHEETPAGEW) < ppage->dwSize ? sizeof(PROPSHEETPAGEW) : ppage->dwSize;

    for (i = 0; i < cPages; i++)
    {
        memcpy(&ppageW[i], ppage, dwSize);
        ppageW[i].dwSize = sizeof(PROPSHEETPAGEW);

        // In the future we may need to handle the pszTemplate and pszIcon fields
        if (ppage->pszTitle != NULL)
        {
            ppageW[i].pszTitle = CertUIMkWStr(ppage->pszTitle);
        }

        ppage = (LPCPROPSHEETPAGEA) (((LPBYTE) ppage) + ppage->dwSize);
    }

    *pppageW = ppageW;
    
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void FreePropSheetPagesW(LPPROPSHEETPAGEW ppage, DWORD cPages)
{
    DWORD i;

    for (i=0; i<cPages; i++)
    {
        // In the future we may need to handle the pszTemplate and pszIcon fields
        if (ppage[i].pszTitle != NULL)
        {
            free((void *)ppage[i].pszTitle);
        }
    }

    free(ppage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\cps.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cps.cpp
//
//--------------------------------------------------------------------------

//
//  File:       select.cpp
//
//  Description: This file contains the implmentation code for the
//      "Certificate Select" dialog.
//

#pragma warning (disable: 4201)         // nameless struct/union
#pragma warning (disable: 4514)         // remove inline functions
#pragma warning (disable: 4127)         // conditional expression is constant

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE       HinstDll;
extern HMODULE         HmodRichEdit;

typedef struct _CPS_STATE_STRUCT {
    LPWSTR  pwszURL;
    LPWSTR  pwszDisplayText;
    DWORD   dwChainError;
    BOOL    fNoCOM;
} CPS_STATE_STRUCT, *PCPS_STATE_STRUCT;


INT_PTR CALLBACK CPSDlgProc(HWND hwndDlg, UINT msg,
                               WPARAM wParam, LPARAM lParam)
{

    BOOL                f;
    CPS_STATE_STRUCT    *pcpsStateStruct;

    switch (msg) {
    case WM_INITDIALOG:

        pcpsStateStruct = (CPS_STATE_STRUCT *) lParam;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pcpsStateStruct);

        // set the text for the CPS
        CryptUISetRicheditTextW(hwndDlg, IDC_CPS_TEXT, pcpsStateStruct->pwszDisplayText);

        // if there is no URL then hide the more info button,
        //
        // DSIE: Bug 364742, also hide if the URL is not safe to be execute.
        if (!pcpsStateStruct->pwszURL || 
            !IsOKToFormatAsLinkW(pcpsStateStruct->pwszURL, pcpsStateStruct->dwChainError))
        {
            EnableWindow(GetDlgItem(hwndDlg, ID_MORE_INFO), FALSE);
        }
        break;

    case WM_NOTIFY:
        //if (((NMHDR FAR *) lParam)->code == EN_LINK)

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case ID_MORE_INFO:

            if (HIWORD(wParam) == BN_CLICKED)
            {
                DWORD   numBytes = 0;
                LPSTR   pszURL = NULL;

                pcpsStateStruct = (CPS_STATE_STRUCT *) GetWindowLongPtr(hwndDlg, DWLP_USER);

                pszURL = CertUIMkMBStr(pcpsStateStruct->pwszURL);

                if (pszURL == NULL)
                {
                    return TRUE;
                }

                CryptuiGoLink(hwndDlg, pszURL, pcpsStateStruct->fNoCOM);
                free(pszURL);
                return TRUE;
            }
            break;

        case IDOK:
        case IDCANCEL:
        case IDOK_CPS:
        case IDCANCEL_CPS:
            EndDialog(hwndDlg, IDOK);
            return TRUE;
        }
        break;

        //
        //  Use the default handler -- we don't do anything for it
        //

    default:
        return FALSE;
    }

    return FALSE;
}


DWORD GetCPSInfo(PCCERT_CONTEXT pCertContext, LPWSTR * ppwszUrlString, LPWSTR * ppwszDisplayText)
{
    DWORD                               dwRetCode = 0;
    PCERT_EXTENSION                     pExt = NULL;
    DWORD                               i,j,k;
    DWORD                               cbCertPolicyInfo = 0;
    CERT_POLICIES_INFO                * pCertPolicyInfo = NULL;
    CERT_NAME_VALUE                   * pCertName = NULL;
    DWORD                               cbCertName = 0;
    CERT_POLICY_QUALIFIER_USER_NOTICE * pUserNotice = NULL;
    DWORD                               cbUserNotice = 0;
    PSPC_SP_AGENCY_INFO                 pInfo = NULL;
    DWORD                               cbInfo = 0;
    CERT_POLICY95_QUALIFIER1          * pCertPolicy95Qualifier = NULL;
    DWORD                               cbCertPolicy95Qualifier = 0;

    //
    // Check parameters and intialize return values.
    //
    if (NULL == pCertContext || NULL == ppwszUrlString || NULL == ppwszDisplayText)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *ppwszUrlString = *ppwszDisplayText = NULL;

    //
    // first look for the PKIX policy extension and see if it has an URL
    //
    if ((pExt = CertFindExtension(szOID_CERT_POLICIES, 
                                  pCertContext->pCertInfo->cExtension,
                                  pCertContext->pCertInfo->rgExtension)))
    {
        //
        // decode the policy extension
        //
        CryptDecodeObject(X509_ASN_ENCODING, 
                          szOID_CERT_POLICIES,
                          pExt->Value.pbData, 
                          pExt->Value.cbData, 
                          0, 
                          NULL,
                          &cbCertPolicyInfo);

        if (!(pCertPolicyInfo = (CERT_POLICIES_INFO *) malloc(cbCertPolicyInfo)))
        {
            dwRetCode = ERROR_OUTOFMEMORY;
            goto ErrorExit;
        }

        if (!(CryptDecodeObject(X509_ASN_ENCODING, 
                                szOID_CERT_POLICIES,
                                pExt->Value.pbData, 
                                pExt->Value.cbData, 
                                0, 
                                pCertPolicyInfo,
                                &cbCertPolicyInfo)))
        {
            dwRetCode = GetLastError();
            goto ErrorExit;
        }

        //
        // look for display text and/or and URL in the extension
        //
        for (i = 0; i < pCertPolicyInfo->cPolicyInfo ; i++)
        {
            for (j = 0; j < pCertPolicyInfo->rgPolicyInfo[i].cPolicyQualifier; j++)
            {
                // check to see what type of qualifier it is
                if (0 == strcmp(szOID_PKIX_POLICY_QUALIFIER_CPS,
                                pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].pszPolicyQualifierId))
                {
                    // decode as an anystring
                    CryptDecodeObject(X509_ASN_ENCODING,
                                      X509_UNICODE_ANY_STRING,
                                      pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.pbData,
                                      pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.cbData,
                                      0,
                                      NULL,
                                      &cbCertName);

                    if (!(pCertName = (CERT_NAME_VALUE *) malloc(cbCertName)))
                    {
                        dwRetCode = ERROR_OUTOFMEMORY;
                        goto ErrorExit;
                    }

                    if (!(CryptDecodeObject(X509_ASN_ENCODING,
                                            X509_UNICODE_ANY_STRING,
                                            pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.pbData,
                                            pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.cbData,
                                            0,
                                            pCertName,
                                            &cbCertName)))
                    {
                        dwRetCode = GetLastError();
                        goto ErrorExit;
                    }

                    if (pCertName->Value.cbData && NULL == *ppwszUrlString)
                    {
                        if (!(*ppwszUrlString = (LPWSTR) malloc(pCertName->Value.cbData + sizeof(WCHAR))))
                        {
                            dwRetCode = ERROR_OUTOFMEMORY;
                            goto ErrorExit;
                        }

                        wcscpy(*ppwszUrlString, (LPWSTR) pCertName->Value.pbData);
                    }

                    free(pCertName);
                    pCertName = NULL;
                }
                else if (0 == strcmp(szOID_PKIX_POLICY_QUALIFIER_USERNOTICE,
                                     pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].pszPolicyQualifierId))
                {
                    // decode as user notice
                    CryptDecodeObject(X509_ASN_ENCODING,
                                      szOID_PKIX_POLICY_QUALIFIER_USERNOTICE,
                                      pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.pbData,
                                      pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.cbData,
                                      0,
                                      NULL,
                                      &cbUserNotice);

                    if (!(pUserNotice = (CERT_POLICY_QUALIFIER_USER_NOTICE *) malloc(cbUserNotice)))
                    {
                        dwRetCode = ERROR_OUTOFMEMORY;
                        goto ErrorExit;
                    }

                    if (!(CryptDecodeObject(X509_ASN_ENCODING,
                                            szOID_PKIX_POLICY_QUALIFIER_USERNOTICE,
                                            pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.pbData,
                                            pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.cbData,
                                            0,
                                            pUserNotice,
                                            &cbUserNotice)))
                    {
                        dwRetCode = GetLastError();
                        goto ErrorExit;
                    }

                    // NOTE: pUserNotice->pszDisplayText may be NULL
                    if (pUserNotice->pszDisplayText && NULL == *ppwszDisplayText)
                    {
                        if (!(*ppwszDisplayText = (LPWSTR) malloc((wcslen(pUserNotice->pszDisplayText) + 1) * sizeof(WCHAR))))
                        {
                            dwRetCode = ERROR_OUTOFMEMORY;
                            goto ErrorExit;
                        }

                        wcscpy(*ppwszDisplayText, pUserNotice->pszDisplayText);
                    }

                    free(pUserNotice);
                    pUserNotice = NULL;
                }
            }
        }
    }
    //
    // next look for display information in the SPC Agency Info
    //

    else if ((pExt = CertFindExtension(SPC_SP_AGENCY_INFO_OBJID, 
                                       pCertContext->pCertInfo->cExtension,
                                       pCertContext->pCertInfo->rgExtension)))
    {
        CryptDecodeObject(X509_ASN_ENCODING, 
                          SPC_SP_AGENCY_INFO_STRUCT,
                          pExt->Value.pbData, 
                          pExt->Value.cbData, 
                          0, 
                          NULL,
                          &cbInfo);

        if (!(pInfo = (PSPC_SP_AGENCY_INFO) malloc(cbInfo)))
        {
            dwRetCode = ERROR_OUTOFMEMORY;
            goto ErrorExit;
        }

        if (!(CryptDecodeObject(X509_ASN_ENCODING, 
                                SPC_SP_AGENCY_INFO_STRUCT,
                                pExt->Value.pbData, 
                                pExt->Value.cbData, 
                                0, 
                                pInfo,
                                &cbInfo)))
        {
            dwRetCode = GetLastError();
            goto ErrorExit;
        }

        if (!(pInfo->pPolicyInformation))
        {
            dwRetCode = CRYPT_E_NOT_FOUND;
            goto ErrorExit;
        }

        if (pInfo->pwszPolicyDisplayText)
        {
            if (!(*ppwszDisplayText = (LPWSTR) malloc((wcslen(pInfo->pwszPolicyDisplayText) + 1) * sizeof(WCHAR))))
            {
                dwRetCode = ERROR_OUTOFMEMORY;
                goto ErrorExit;
            }

            wcscpy(*ppwszDisplayText, pInfo->pwszPolicyDisplayText);
        }

        switch (pInfo->pPolicyInformation->dwLinkChoice)
        {
            case SPC_URL_LINK_CHOICE:
            {
                if (pInfo->pPolicyInformation->pwszUrl)
                {
                    if (!(*ppwszUrlString = (LPWSTR) malloc((wcslen(pInfo->pPolicyInformation->pwszUrl) + 1) * sizeof(WCHAR))))
                    {
                        dwRetCode = ERROR_OUTOFMEMORY;
                        goto ErrorExit;
                    }

                    wcscpy(*ppwszUrlString, pInfo->pPolicyInformation->pwszUrl);
                }

                break;
            }

            case SPC_FILE_LINK_CHOICE:
            {
                if (pInfo->pPolicyInformation->pwszFile)
                {
                    if (!(*ppwszUrlString = (LPWSTR) malloc((wcslen(pInfo->pPolicyInformation->pwszFile) + 1) * sizeof(WCHAR))))
                    {
                        dwRetCode = ERROR_OUTOFMEMORY;
                        goto ErrorExit;
                    }

                    wcscpy(*ppwszUrlString, pInfo->pPolicyInformation->pwszFile);
                }

                break;
            }
        }
    }

    //
    // finally, look for info in the 2.5.29.3 extension
    //

    else if ((pExt = CertFindExtension(szOID_CERT_POLICIES_95, 
                                       pCertContext->pCertInfo->cExtension,
                                       pCertContext->pCertInfo->rgExtension)))
    {
        CryptDecodeObject(X509_ASN_ENCODING, 
                          szOID_CERT_POLICIES_95,
                          pExt->Value.pbData, 
                          pExt->Value.cbData, 
                          0, 
                          NULL,
                          &cbCertPolicyInfo);

        if (!(pCertPolicyInfo = (CERT_POLICIES_INFO *) malloc(cbCertPolicyInfo)))
        {
            dwRetCode = ERROR_OUTOFMEMORY;
            goto ErrorExit;
        }

        if (!(CryptDecodeObject(X509_ASN_ENCODING, 
                                szOID_CERT_POLICIES_95,
                                pExt->Value.pbData, 
                                pExt->Value.cbData, 
                                0, 
                                pCertPolicyInfo,
                                &cbCertPolicyInfo)))
        {
            dwRetCode = GetLastError();
            goto ErrorExit;
        }

        // now decode the qualifiers
        for (i = 0; i < pCertPolicyInfo->cPolicyInfo; i++)
        {
            for (j = 0; j < pCertPolicyInfo->rgPolicyInfo[i].cPolicyQualifier; j++)
            {
                if (0 == strcmp(szOID_CERT_POLICIES_95_QUALIFIER1,
                                pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].pszPolicyQualifierId))
                {
                    CryptDecodeObject(X509_ASN_ENCODING,
                                      szOID_CERT_POLICIES_95_QUALIFIER1,
                                      pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.pbData,
                                      pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.cbData,
                                      0,
                                      NULL,
                                      &cbCertPolicy95Qualifier);

                    if (!(pCertPolicy95Qualifier = (CERT_POLICY95_QUALIFIER1 *) malloc(cbCertPolicy95Qualifier)))
                    {
                        dwRetCode = ERROR_OUTOFMEMORY;
                        goto ErrorExit;
                    }

                    if (!(CryptDecodeObject(X509_ASN_ENCODING,
                                            szOID_CERT_POLICIES_95_QUALIFIER1,
                                            pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.pbData,
                                            pCertPolicyInfo->rgPolicyInfo[i].rgPolicyQualifier[j].Qualifier.cbData,
                                            0,
                                            pCertPolicy95Qualifier,
                                            &cbCertPolicy95Qualifier)))
                    {
                        dwRetCode = GetLastError();
                        goto ErrorExit;
                    }

                    // check to see what is available
                    if ((NULL != pCertPolicy95Qualifier->pszPracticesReference) && (NULL == *ppwszDisplayText))
                    {
                        if (!(*ppwszDisplayText = (LPWSTR) malloc((wcslen(pCertPolicy95Qualifier->pszPracticesReference) + 1) * sizeof(WCHAR))))
                        {
                            dwRetCode = ERROR_OUTOFMEMORY;
                            goto ErrorExit;
                        }

                        wcscpy(*ppwszDisplayText, pCertPolicy95Qualifier->pszPracticesReference);
                    }

                    for (k = 0; k < pCertPolicy95Qualifier->cCPSURLs; k++)
                    {
                        if ((NULL != pCertPolicy95Qualifier->rgCPSURLs[k].pszURL) && (NULL == *ppwszUrlString))
                        {
                            if (!(*ppwszUrlString = (LPWSTR) malloc((wcslen(pCertPolicy95Qualifier->rgCPSURLs[k].pszURL) + 1) * sizeof(WCHAR))))
                            {
                                dwRetCode = ERROR_OUTOFMEMORY;
                                goto ErrorExit;
                            }

                            wcscpy(*ppwszUrlString, pCertPolicy95Qualifier->rgCPSURLs[k].pszURL);
                        }
                    }

                    free(pCertPolicy95Qualifier);
                    pCertPolicy95Qualifier = NULL;
                }
            }
        }
    }

    //
    // If there is neither display text nor an URL, then return CRYPT_E_NOT_FOUND.
    //
    if ((NULL == *ppwszUrlString) && (NULL == *ppwszDisplayText))
    {
        dwRetCode = CRYPT_E_NOT_FOUND;
    }

CommonExit:

    if (pInfo)
        free(pInfo);

    if (pCertPolicyInfo)
        free(pCertPolicyInfo);

    if (pUserNotice)
        free(pUserNotice);

    if (pCertName)
        free(pCertName);

    if (pCertPolicy95Qualifier)
        free(pCertPolicy95Qualifier);

    return dwRetCode;

ErrorExit:
    if (*ppwszUrlString)
    {
        free(*ppwszUrlString);
        *ppwszUrlString = NULL;
    }

    if (*ppwszDisplayText)
    {
        free(*ppwszDisplayText);
        *ppwszDisplayText = NULL;
    }

    goto CommonExit;
}


BOOL IsOKToDisplayCPS(PCCERT_CONTEXT pCertContext, DWORD dwChainError)
{
    BOOL   fResult = FALSE;
    LPWSTR pwszUrlString = NULL;
    LPWSTR pwszDisplayText = NULL;

    //
    // Check parameters and initialize.
    //
    if (NULL == pCertContext)
    {
        goto CommonExit;
    }

    //
    // Get CPS info.
    //
    if ((0 == GetCPSInfo(pCertContext, &pwszUrlString, &pwszDisplayText)) &&
        (pwszDisplayText || IsOKToFormatAsLinkW(pwszUrlString, dwChainError)))
    {
        fResult = TRUE;
    }

CommonExit:

    if (pwszUrlString)
    {
        free(pwszUrlString);
    }

    if (pwszDisplayText)
    {
        free(pwszDisplayText);
    }

    return fResult;
}


BOOL DisplayCPS(HWND hwnd, PCCERT_CONTEXT pCertContext, DWORD dwChainError, BOOL fNoCOM)
{
    BOOL              fRet = FALSE;
    DWORD             dwRetCode = 0;
    CPS_STATE_STRUCT  cpsStateStruct;

    //
    // Initialize and check parameters.
    //
    memset(&cpsStateStruct, 0, sizeof(cpsStateStruct));

    if (NULL == pCertContext)
    {
        goto Return;
    }

    //
    // Get CPS info.
    //
    if (0 != (dwRetCode = GetCPSInfo(pCertContext, &cpsStateStruct.pwszURL, &cpsStateStruct.pwszDisplayText)))
    {
        goto Return;
    }

    // NOW, set up for, and launch that dialog
    if ((HmodRichEdit == NULL) && (NULL == (HmodRichEdit = LoadLibraryA("RichEd20.dll"))))
    {
        goto Return;
    }

    //
    // If there is an URL but no text then just invoke the browser and don't bring
    // up the dialog
    //
    if ((cpsStateStruct.pwszDisplayText == NULL) && (cpsStateStruct.pwszURL != NULL))
    {
        DWORD   numBytes = 0;
        LPSTR   pszURL = NULL;

        pszURL = CertUIMkMBStr(cpsStateStruct.pwszURL);
        if (pszURL == NULL)
        {
            goto Return;
        }

        CryptuiGoLink(hwnd, pszURL, fNoCOM);
        free(pszURL);
    }
    else
    {
        cpsStateStruct.fNoCOM = fNoCOM;
        cpsStateStruct.dwChainError = dwChainError;
        DialogBoxParamU(HinstDll, (LPWSTR) MAKEINTRESOURCE(IDD_CPS_DIALOG), hwnd, CPSDlgProc, (LPARAM) &cpsStateStruct);
    }

    fRet = TRUE;

Return:

    if (cpsStateStruct.pwszURL)
        free(cpsStateStruct.pwszURL);

    if (cpsStateStruct.pwszDisplayText)
        free(cpsStateStruct.pwszDisplayText);

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\crlrlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       crlrlist.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES,   IDH_CRLVIEW_REVOCATIONLIST_REVOCATION_LIST},
    {IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST,   IDH_CRLVIEW_REVOCATIONLIST_LIST_ENTRY},
    {IDC_CRL_REVOCATIONLIST_DETAIL_EDIT,            IDH_CRLVIEW_REVOCATIONLIST_LIST_ENTRY_DETAIL}
};


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void DisplayCRLEntryValues(HWND hWndListView, PCCRL_CONTEXT pcrl, int entryIndex)
{
    LPWSTR      pwszText;
    WCHAR       szText[CRYPTUI_MAX_STRING_SIZE];
    LV_ITEMW    lvI;
    DWORD       index = 0;

    ShowWindow(hWndListView, SW_HIDE);

    //
    memset(&lvI, 0, sizeof(lvI));
    lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
    lvI.mask = LVIF_PARAM;
    while (lvI.iItem >= 0)
    {
        if (ListView_GetItemU(hWndListView, &lvI))
        {
            FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvI.lParam);
        }
        lvI.iItem--;
    }

    ListView_DeleteAllItems(hWndListView);

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    memset(&lvI, 0, sizeof(lvI));
    lvI.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szText;
    lvI.iSubItem = 0;

    //
    // serial number
    //
    if (FormatSerialNoString(&pwszText, &(pcrl->pCrlInfo->rgCRLEntry[entryIndex].SerialNumber)))
    {
        LoadStringU(HinstDll, IDS_ADV_SER_NUM, szText, ARRAYSIZE(szText));
        lvI.iItem = index;
        lvI.cchTextMax = wcslen(szText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(TRUE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, index, 1, pwszText);
        index++;
    }

    //
    // revocation date
    //
    if (FormatDateString(&pwszText, pcrl->pCrlInfo->rgCRLEntry[entryIndex].RevocationDate, TRUE, TRUE, hWndListView))
    {
        LoadStringU(HinstDll, IDS_REVOCATION_DATE, szText, ARRAYSIZE(szText));
        lvI.iItem = index;
        lvI.cchTextMax = wcslen(szText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, index, 1, pwszText);
        index++;
    }

    //
    // add all the extensions
    //
    DisplayExtensions(
            hWndListView,
            pcrl->pCrlInfo->rgCRLEntry[entryIndex].cExtension,
            pcrl->pCrlInfo->rgCRLEntry[entryIndex].rgExtension,
            FALSE,
            &index);
    DisplayExtensions(
            hWndListView,
            pcrl->pCrlInfo->rgCRLEntry[entryIndex].cExtension,
            pcrl->pCrlInfo->rgCRLEntry[entryIndex].rgExtension,
            TRUE,
            &index);

    ShowWindow(hWndListView, SW_SHOW);
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void AddCertificatesToList(HWND hWndListView, CRL_VIEW_HELPER *pviewhelp)
{
    LPWSTR          pwszText;
    LV_ITEMW        lvI;
    DWORD           i;
    PCCRL_CONTEXT   pcrl;
    int             index = 0;

    pcrl = pviewhelp->pcvcrl->pCRLContext;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.iSubItem = 0;

    //
    // loop for each cert
    //
    for (i=0; i<pcrl->pCrlInfo->cCRLEntry; i++)
    {
        if (FormatSerialNoString(&(lvI.pszText), &(pcrl->pCrlInfo->rgCRLEntry[i].SerialNumber)))
        {
            lvI.cchTextMax = wcslen(lvI.pszText);
            lvI.iItem = index++;
            ListView_InsertItemU(hWndListView, &lvI);
            free(lvI.pszText);
            lvI.pszText = NULL;

            FormatDateString(&pwszText, pcrl->pCrlInfo->rgCRLEntry[i].RevocationDate, TRUE, TRUE, hWndListView);
            ListView_SetItemTextU(hWndListView, index-1 , 1, pwszText);
            free(pwszText);
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageCRLRevocationList(HWND hwndDlg, UINT msg, WPARAM wParam,
                                    LPARAM lParam)
{
    PROPSHEETPAGE       *ps;
    PCCRL_CONTEXT       pcrl;
    CRL_VIEW_HELPER     *pviewhelp;
    HWND                hWndListView;
    HWND                hwnd;
    LV_COLUMNW          lvC;
    WCHAR               szText[CRYPTUI_MAX_STRING_SIZE];
    PCRL_INFO           pCrlInfo;
    int                 listIndex;
    LVITEMW             lvI;
    LPNMLISTVIEW        pnmv;
    NMLISTVIEW          nmv;

    switch ( msg ) {
    case WM_INITDIALOG:
        //
        // save the pviewhelp struct in DWLP_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (CRL_VIEW_HELPER *) (ps->lParam);
        pcrl = pviewhelp->pcvcrl->pCRLContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);

        //
        // clear the text in the detail edit box
        //
        CryptUISetRicheditTextW(hwndDlg, IDC_CRL_REVOCATIONLIST_DETAIL_EDIT, L"");

        //
        // initialize the columns in the list view
        //
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.pszText = szText;   // The text for the column.

        // Add the columns. They are loaded from a string table.
        lvC.iSubItem = 0;
        lvC.cx = 200;
        LoadStringU(HinstDll, IDS_ADV_SER_NUM, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES), 0, &lvC) == -1)
        {
            // error
        }

        lvC.cx = 140;
        LoadStringU(HinstDll, IDS_REVOCATION_DATE, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES), 1, &lvC) == -1)
        {
            // error
        }

        // Add the columns. They are loaded from a string table.
        lvC.iSubItem = 0;
        lvC.cx = 121;
        LoadStringU(HinstDll, IDS_FIELD, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST), 0, &lvC) == -1)
        {
            // error
        }

        lvC.cx = 200;
        LoadStringU(HinstDll, IDS_VALUE, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST), 1, &lvC) == -1)
        {
            // error
        }

        //
        // add all the certificates to the certificate list box
        //
        AddCertificatesToList(GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES), pviewhelp);

        //
        // set the styles in the list views so that they highlight an entire line and
        // so they alway show their selection
        //
        SendDlgItemMessageA(
                hwndDlg,
                IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES,
                LVM_SETEXTENDEDLISTVIEWSTYLE,
                0,
                LVS_EX_FULLROWSELECT);
        SendDlgItemMessageA(
                hwndDlg,
                IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST,
                LVM_SETEXTENDEDLISTVIEWSTYLE,
                0,
                LVS_EX_FULLROWSELECT);

        //
        // initialize the current selection
        //
        pviewhelp->currentSelection = -1;

        return TRUE;

    case WM_NOTIFY:

        pviewhelp = (CRL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcrl = pviewhelp->pcvcrl->pCRLContext;
        pCrlInfo = pcrl->pCrlInfo;

        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case PSN_HELP:
            pviewhelp = (CRL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvcrl->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvcrl->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvcrl->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvcrl->dwHelpId);
            }
            return TRUE;

        case LVN_ITEMCHANGING:

            pnmv = (LPNMLISTVIEW) lParam;

            switch(((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST:

                if (pnmv->uNewState & LVIS_SELECTED)
                {
                    DisplayHelperTextInEdit(
                            GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST),
                            hwndDlg,
                            IDC_CRL_REVOCATIONLIST_DETAIL_EDIT,
                            pnmv->iItem);
                }

                break;

            case IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES:
                if (pnmv->uNewState & LVIS_SELECTED)
                {
                    memcpy(&nmv, pnmv, sizeof(nmv));
                    nmv.hdr.code = NM_CLICK;
                    SendMessage(hwndDlg, WM_NOTIFY, 0, (LPARAM) &nmv);
                }

                break;
            }

            return TRUE;

        case NM_CLICK:

            pnmv = (LPNMLISTVIEW) lParam;

            switch (((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES:

                hWndListView = GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES);

                if ((pnmv->iItem == -1) || (pviewhelp->currentSelection == pnmv->iItem))
                {
                    break;
                }

                //
                // clear the text in the detail edit box
                //
                CryptUISetRicheditTextW(hwndDlg, IDC_CRL_REVOCATIONLIST_DETAIL_EDIT, L"");

                DisplayCRLEntryValues(
                        GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST),
                        pcrl,
                        pnmv->iItem);

                pviewhelp->currentSelection = pnmv->iItem;

                break;
                // do the fall through when the update code is written properly
                // FALL THROUGH!! - do this so everything gets updated
                // break;

            case IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST:

                DisplayHelperTextInEdit(
                    GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST),
                    hwndDlg,
                    IDC_CRL_REVOCATIONLIST_DETAIL_EDIT,
                    pnmv->iItem);

                break;
            }

            break;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES:
                hWndListView = GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED;
                    lvI.stateMask = LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;

            case IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_SELECTED | LVIS_FOCUSED;
                    lvI.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;
            }
            
            break;
        }

        break;

    case WM_COMMAND:
        pviewhelp = (CRL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcrl = pviewhelp->pcvcrl->pCRLContext;
        pCrlInfo = pcrl->pCrlInfo;

        switch (LOWORD(wParam))
        {
        case IDHELP:
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvcrl->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvcrl->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvcrl->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvcrl->dwHelpId);
            }
            return TRUE;
        }
        break;

    case WM_DESTROY:
            pviewhelp = (CRL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

            //
            // get all the items in the list view and free the lParam
            // associated with each of them (lParam is the helper sruct)
            //
            hWndListView = GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST);

            memset(&lvI, 0, sizeof(lvI));
            lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
            lvI.mask = LVIF_PARAM;
            while (lvI.iItem >= 0)
            {
                if (ListView_GetItemU(hWndListView, &lvI))
                {
                    FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvI.lParam);
                }
                lvI.iItem--;
            }

            break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES)) &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST)) &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CRL_REVOCATIONLIST_DETAIL_EDIT)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\cryptuiapi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cryptuiapi.cpp
//
//  Contents:   Public Cryptographic UI APIs
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#include <cryptuiapi.h>


//+-------------------------------------------------------------------------
//  Dialog viewer of a certificate, CTL or CRL context.
//
//  dwContextType and associated pvContext's
//      CERT_STORE_CERTIFICATE_CONTEXT  PCCERT_CONTEXT
//      CERT_STORE_CRL_CONTEXT          PCCRL_CONTEXT
//      CERT_STORE_CTL_CONTEXT          PCCTL_CONTEXT
//
//  dwFlags currently isn't used and should be set to 0.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptUIDlgViewContext(
    IN DWORD dwContextType,
    IN const void *pvContext,
    IN OPTIONAL HWND hwnd,              // Defaults to the desktop window
    IN OPTIONAL LPCWSTR pwszTitle,      // Defaults to the context type title
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    BOOL fResult;

    switch (dwContextType) {
        case CERT_STORE_CERTIFICATE_CONTEXT:
            {
                CRYPTUI_VIEWCERTIFICATE_STRUCTW ViewInfo;
                memset(&ViewInfo, 0, sizeof(ViewInfo));
                ViewInfo.dwSize = sizeof(ViewInfo);
                ViewInfo.hwndParent = hwnd;
                ViewInfo.szTitle = pwszTitle;
                ViewInfo.pCertContext = (PCCERT_CONTEXT) pvContext;

                fResult = CryptUIDlgViewCertificateW(
                    &ViewInfo,
                    NULL            // pfPropertiesChanged
                    );
            }
            break;

        case CERT_STORE_CRL_CONTEXT:
            {
                CRYPTUI_VIEWCRL_STRUCTW ViewInfo;
                memset(&ViewInfo, 0, sizeof(ViewInfo));
                ViewInfo.dwSize = sizeof(ViewInfo);
                ViewInfo.hwndParent = hwnd;
                ViewInfo.szTitle = pwszTitle;
                ViewInfo.pCRLContext = (PCCRL_CONTEXT) pvContext;

                fResult = CryptUIDlgViewCRLW(
                    &ViewInfo
                    );
            }
            break;

        case CERT_STORE_CTL_CONTEXT:
            {
                CRYPTUI_VIEWCTL_STRUCTW ViewInfo;
                memset(&ViewInfo, 0, sizeof(ViewInfo));
                ViewInfo.dwSize = sizeof(ViewInfo);
                ViewInfo.hwndParent = hwnd;
                ViewInfo.szTitle = pwszTitle;
                ViewInfo.pCTLContext = (PCCTL_CONTEXT) pvContext;

                fResult = CryptUIDlgViewCTLW(
                    &ViewInfo
                    );
            }
            break;

        default:
            fResult = FALSE;
            SetLastError(E_INVALIDARG);
    }

    return fResult;
}


//+-------------------------------------------------------------------------
//  Dialog to select a certificate from the specified store.
//
//  Returns the selected certificate context. If no certificate was
//  selected, NULL is returned.
//
//  pwszTitle is either NULL or the title to be used for the dialog.
//  If NULL, the default title is used.  The default title is
//  "Select Certificate".
//
//  pwszDisplayString is either NULL or the text statement in the selection
//  dialog.  If NULL, the default phrase
//  "Select a certificate you wish to use" is used in the dialog.
//
//  dwDontUseColumn can be set to exclude columns from the selection
//  dialog. See the CRYPTDLG_SELECTCERT_*_COLUMN definitions below.
//
//  dwFlags currently isn't used and should be set to 0.
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CryptUIDlgSelectCertificateFromStore(
    IN HCERTSTORE hCertStore,
    IN OPTIONAL HWND hwnd,              // Defaults to the desktop window
    IN OPTIONAL LPCWSTR pwszTitle,
    IN OPTIONAL LPCWSTR pwszDisplayString,
    IN DWORD dwDontUseColumn,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    CRYPTUI_SELECTCERTIFICATE_STRUCTW SelectInfo;

    if (NULL == hCertStore) {
        SetLastError(E_INVALIDARG);
        return FALSE;
    }

    memset(&SelectInfo, 0, sizeof(SelectInfo));
    SelectInfo.dwSize = sizeof(SelectInfo);

    SelectInfo.hwndParent = hwnd;
    SelectInfo.szTitle = pwszTitle;
    SelectInfo.szDisplayString = pwszDisplayString;
    SelectInfo.dwDontUseColumn = dwDontUseColumn;
    SelectInfo.cDisplayStores = 1;
    SelectInfo.rghDisplayStores = &hCertStore;

    return CryptUIDlgSelectCertificateW(&SelectInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\crlgen.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       crlgen.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_CRL_GENERAL_ITEM_LIST,     IDH_CRLVIEW_GENERAL_ITEM_LIST},
    {IDC_CRL_GENERAL_DETAIL_EDIT,   IDH_CRLVIEW_GENERAL_ITEM_EDIT}
};


//////////////////////////////////////////////////////////////////////////////////////
// This function will take a HWND for a list view and a certinfo struct and display
// all the V1 fields of the cert in the list view
//////////////////////////////////////////////////////////////////////////////////////
static void DisplayV1Fields(HWND hWndListView, PCRL_INFO pCrlInfo, DWORD *index)
{
    LPWSTR      pwszText;
    WCHAR       szFieldText[_MAX_PATH];  // used for calls to LoadString only
    LV_ITEMW    lvI;
    char        szVersion[32];
    LPWSTR      pszVersion;
    FILETIME    tempFileTime;

     //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szFieldText;
    lvI.iSubItem = 0;
    lvI.iImage = IMAGE_V1;
    lvI.lParam = (LPARAM)NULL;

    //
    // version
    //
    lvI.iItem = (*index)++;
    LoadStringU(HinstDll, IDS_ADV_VERSION, szFieldText, ARRAYSIZE(szFieldText));
    lvI.cchTextMax = wcslen(szFieldText);
    wsprintfA(szVersion, "V%d", pCrlInfo->dwVersion+1);
    if (NULL != (pszVersion = CertUIMkWStr(szVersion)))
    {
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pszVersion, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pszVersion);
    }

    //
    // issuer
    //
    LoadStringU(HinstDll, IDS_ADV_ISSUER, szFieldText, ARRAYSIZE(szFieldText));
    lvI.cchTextMax = wcslen(szFieldText);
    if (FormatDNNameString(&pwszText, pCrlInfo->Issuer.pbData, pCrlInfo->Issuer.cbData, TRUE))
    {
        lvI.iItem = (*index)++;
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        if (FormatDNNameString(&pwszText, pCrlInfo->Issuer.pbData, pCrlInfo->Issuer.cbData, FALSE))
        {
            ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
            free(pwszText);
        }
    }

    //
    // Effective Data
    //
    if (FormatDateString(&pwszText, pCrlInfo->ThisUpdate, TRUE, TRUE, hWndListView))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ADV_THISUPDATE, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    // Next Update
    //
    memset(&tempFileTime, 0, sizeof(FILETIME));
    if (memcmp(&tempFileTime, &(pCrlInfo->NextUpdate), sizeof(FILETIME)) != 0)
    {
        if (FormatDateString(&pwszText, pCrlInfo->NextUpdate, TRUE, TRUE, hWndListView))
        {
            lvI.iItem = (*index)++;
            LoadStringU(HinstDll, IDS_ADV_NEXTUPDATE, szFieldText, ARRAYSIZE(szFieldText));
            lvI.cchTextMax = wcslen(szFieldText);
            lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
            ListView_InsertItemU(hWndListView, &lvI);
            ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
        }
    }

    //
    // signature algorithm
    //
    if (FormatAlgorithmString(&pwszText, &(pCrlInfo->SignatureAlgorithm)))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ADV_SIG_ALG, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }
}


INT_PTR APIENTRY ViewPageCRLGeneral(HWND hwndDlg, UINT msg, WPARAM wParam,
                                LPARAM lParam)
{
    DWORD               i;
    PROPSHEETPAGE       *ps;
    PCCRL_CONTEXT       pcrl;
    CRL_VIEW_HELPER     *pviewhelp;
    HIMAGELIST          hIml;
    HWND                hWndListView;
    HWND                hwnd;
    LV_COLUMNW          lvC;
    WCHAR               szText[CRYPTUI_MAX_STRING_SIZE];
    WCHAR               szCompareText[CRYPTUI_MAX_STRING_SIZE];
    PCRL_INFO           pCrlInfo;
    LVITEMW             lvI;
    LPNMLISTVIEW        pnmv;
    CHARFORMAT          chFormat;

    switch ( msg ) {
    case WM_INITDIALOG:
        //
        // save the pviewhelp struct in DWLP_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (CRL_VIEW_HELPER *) (ps->lParam);
        pcrl = pviewhelp->pcvcrl->pCRLContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);

        //
        // clear the text in the detail edit box
        //
        CryptUISetRicheditTextW(hwndDlg, IDC_CRL_GENERAL_DETAIL_EDIT, L"");

        //
        // get the handle of the list view control
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_CRL_GENERAL_ITEM_LIST);

        //
        // initialize the image list for the list view, load the icons,
        // then add the image list to the list view
        //
        hIml = ImageList_LoadImage(HinstDll, MAKEINTRESOURCE(IDB_PROPLIST), 0, 4, RGB(0,128,128), IMAGE_BITMAP, 0);
        if (hIml != NULL)
        {
            ListView_SetImageList(hWndListView, hIml, LVSIL_SMALL);  
        }
        
        //
        // initialize the columns in the list view
        //
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.pszText = szText;   // The text for the column.

        // Add the columns. They are loaded from a string table.
        lvC.iSubItem = 0;
        lvC.cx = 130;
        LoadStringU(HinstDll, IDS_FIELD, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(hWndListView, 0, &lvC) == -1)
        {
            // error
        }

        lvC.cx = 190;
        LoadStringU(HinstDll, IDS_VALUE, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(hWndListView, 1, &lvC) == -1)
        {
            // error
        }

        //
        // add all the certificate fields to the list box
        //
        i = 0;
        DisplayV1Fields(hWndListView, pcrl->pCrlInfo, &i);
        DisplayExtensions(hWndListView, pcrl->pCrlInfo->cExtension, pcrl->pCrlInfo->rgExtension, FALSE, &i);
        DisplayExtensions(hWndListView, pcrl->pCrlInfo->cExtension, pcrl->pCrlInfo->rgExtension, TRUE, &i);

        //
        // set the style in the list view so that it highlights an entire line
        //
        SendMessageA(hWndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

        //
        // load the header icon and fill in the header text and set styles for the header edit control
        //
        pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOCATIONLIST));

        LoadStringU(HinstDll, IDS_CRL_INFORMATION, (LPWSTR)szText, ARRAYSIZE(szText));
        CryptUISetRicheditTextW(hwndDlg, IDC_CRL_GENERAL_HEADER_EDIT, szText);

        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CRL_GENERAL_HEADER_EDIT));

        memset(&chFormat, 0, sizeof(chFormat));
        chFormat.cbSize = sizeof(chFormat);
        chFormat.dwMask = CFM_BOLD;
        chFormat.dwEffects = CFE_BOLD;
        SendMessageA(GetDlgItem(hwndDlg, IDC_CRL_GENERAL_HEADER_EDIT), EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);


        return TRUE;

    case WM_NOTIFY:

        pviewhelp = (CRL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcrl = pviewhelp->pcvcrl->pCRLContext;
        pCrlInfo = pcrl->pCrlInfo;

        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case PSN_HELP:
            pviewhelp = (CRL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvcrl->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvcrl->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvcrl->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvcrl->dwHelpId);
            }
            return TRUE;

        case LVN_ITEMCHANGING:
            if ((((NMHDR FAR *) lParam)->idFrom) != IDC_CRL_GENERAL_ITEM_LIST)
            {
                break;
            }

            pnmv = (LPNMLISTVIEW) lParam;

            if (pnmv->uNewState & LVIS_SELECTED)
            {
                DisplayHelperTextInEdit(
                    GetDlgItem(hwndDlg, IDC_CRL_GENERAL_ITEM_LIST),
                    hwndDlg,
                    IDC_CRL_GENERAL_DETAIL_EDIT,
                    pnmv->iItem);
            }

            return TRUE;


        case NM_CLICK:

            break;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_CRL_GENERAL_ITEM_LIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_CRL_GENERAL_ITEM_LIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED;
                    lvI.stateMask = LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;
            }
            
            break;
        }

        break;

    case WM_COMMAND:
        pviewhelp = (CRL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcrl = pviewhelp->pcvcrl->pCRLContext;
        pCrlInfo = pcrl->pCrlInfo;

        switch (LOWORD(wParam))
        {
        case IDHELP:
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvcrl->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvcrl->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvcrl->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvcrl->dwHelpId);
            }
            return TRUE;
        }
        break;

    case WM_PAINT:
        RECT        rect;
        PAINTSTRUCT paintstruct;
        HDC         hdc;
        COLORREF    colorRef;

        pviewhelp = (CRL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        if (GetUpdateRect(hwndDlg, &rect, FALSE))
        {
            hdc = BeginPaint(hwndDlg, &paintstruct);
            if (hdc == NULL)
            {
                EndPaint(hwndDlg, &paintstruct);
                break;
            }

            colorRef = GetBkColor(hdc);

            SendMessageA(GetDlgItem(hwndDlg, IDC_CRL_GENERAL_HEADER_EDIT), EM_SETBKGNDCOLOR, 0, (LPARAM) colorRef);

            if (pviewhelp->hIcon != NULL)
            {
                DrawIcon(
                    hdc,
                    ICON_X_POS,
                    ICON_Y_POS,
                    pviewhelp->hIcon);
            }

            EndPaint(hwndDlg, &paintstruct);
        }
        break;

    case WM_DESTROY:
        pviewhelp = (CRL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        //
        // get all the items in the list view and free the lParam
        // associated with each of them (lParam is the helper sruct)
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_CRL_GENERAL_ITEM_LIST);

        memset(&lvI, 0, sizeof(lvI));
        lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
        lvI.mask = LVIF_PARAM;
        while (lvI.iItem >= 0)
        {
            if (ListView_GetItemU(hWndListView, &lvI))
            {
                FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvI.lParam);
            }
            lvI.iItem--;
        }

        if (pviewhelp->hIcon != NULL)
        {
            DeleteObject(pviewhelp->hIcon);
            pviewhelp->hIcon = NULL;
        }

        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_CRL_GENERAL_ITEM_LIST)) &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CRL_GENERAL_DETAIL_EDIT)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\ctltlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctltlist.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_CTL_TRUSTLIST_CERTIFICATE_LIST,    IDH_CTLVIEW_TRUSTLIST_CERTIFICATE_LIST},
    {IDC_CTL_TRUSTLIST_CERTVALUE_LIST,      IDH_CTLVIEW_TRUSTLIST_CERTVALUE_LIST},
    {IDC_CTL_TRUSTLIST_DETAIL_EDIT,         IDH_CTLVIEW_TRUSTLIST_VALUE_DETAIL_EDIT},
    {IDC_CTL_TRUSTLIST_VIEW_BUTTON,         IDH_CTLVIEW_TRUSTLIST_VIEWCERT_BUTTON}
};


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
#define INDENT_STRING       L"     "
#define TERMINATING_CHAR    L""

static void DisplayCertificateValues(HWND hWndListView, PCCERT_CONTEXT pCertContext, PCTL_ENTRY pctlEntry)
{
    LPWSTR      pwszText;
    WCHAR       szFieldText[_MAX_PATH];  // used for calls to LoadString only
    WCHAR       szValueText[CRYPTUI_MAX_STRING_SIZE];
    LV_ITEMW    lvI;
    LV_ITEMW    lvIDelete;
    int         index = 0;
    PCERT_INFO  pCertInfo;
    BYTE        hash[20];
    DWORD       hashSize = ARRAYSIZE(hash);
    BOOL        fAddRows;
    DWORD       cChars;
    DWORD       cbFormatedAttribute;
    BYTE        *pbFormatedAttribute;
    DWORD       i;


    if (pCertContext == NULL)
    {
        while(ListView_DeleteItem(hWndListView, 0));
        return;
    }

    pCertInfo = pCertContext->pCertInfo;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    memset(&lvI, 0, sizeof(lvI));
    lvI.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
    lvI.lParam = NULL;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szFieldText;
    lvI.iSubItem = 0;

    //
    // if the rows have already been added, then don't add them again, just
    // set the text in the subitem
    //
    fAddRows = ListView_GetItemCount(hWndListView) == 0;

    //
    // subject
    //
    cChars = CertGetNameStringW(
                pCertContext,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                0,//CERT_NAME_ISSUER_FLAG,
                NULL,
                NULL,
                0);
    if ((cChars != 1) && (NULL != (pwszText = (LPWSTR) malloc(cChars * sizeof(WCHAR)))))
    {
        CertGetNameStringW(
                pCertContext,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                0,//CERT_NAME_ISSUER_FLAG,
                NULL,
                pwszText,
                cChars);

        LoadStringU(HinstDll, IDS_ADV_ISSUEDTO, szFieldText, ARRAYSIZE(szFieldText));
        lvI.iItem = index++;
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.iImage = IMAGE_V1;

        ModifyOrInsertRow(
                    hWndListView,
                    &lvI,
                    pwszText,
                    pwszText,
                    fAddRows,
                    FALSE);
    }

    //
    // issuer
    //
    cChars = CertGetNameStringW(
                pCertContext,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                CERT_NAME_ISSUER_FLAG,
                NULL,
                NULL,
                0);
    if ((cChars != 1) && (NULL != (pwszText = (LPWSTR) malloc(cChars * sizeof(WCHAR)))))
    {
        CertGetNameStringW(
                pCertContext,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                CERT_NAME_ISSUER_FLAG,
                NULL,
                pwszText,
                cChars);

        LoadStringU(HinstDll, IDS_ADV_ISSUEDFROM, szFieldText, ARRAYSIZE(szFieldText));
        lvI.iItem = index++;
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.iImage = IMAGE_V1;

        ModifyOrInsertRow(
                    hWndListView,
                    &lvI,
                    pwszText,
                    pwszText,
                    fAddRows,
                    FALSE);
    }

    //
    // serial number
    //
    if (FormatSerialNoString(&pwszText, &(pCertInfo->SerialNumber)))
    {
        LoadStringU(HinstDll, IDS_ADV_SER_NUM, szFieldText, ARRAYSIZE(szFieldText));
        lvI.iItem = index++;
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.iImage = IMAGE_V1;

        ModifyOrInsertRow(
                    hWndListView,
                    &lvI,
                    pwszText,
                    pwszText,
                    fAddRows,
                    TRUE);
    }

    //
    // not after
    //
    if (FormatDateString(&pwszText, pCertInfo->NotAfter, TRUE, TRUE, hWndListView))
    {
        LoadStringU(HinstDll, IDS_ADV_NOTAFTER, szFieldText, ARRAYSIZE(szFieldText));
        lvI.iItem = index++;
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.iImage = IMAGE_V1;

        ModifyOrInsertRow(
                    hWndListView,
                    &lvI,
                    pwszText,
                    pwszText,
                    fAddRows,
                    FALSE);
    }

    //
    // thumbprint
    //
    if (FormatMemBufToString(
                    &pwszText,
                    pctlEntry->SubjectIdentifier.pbData,
                    pctlEntry->SubjectIdentifier.cbData))
    {
        LoadStringU(HinstDll, IDS_THUMBPRINT, szFieldText, ARRAYSIZE(szFieldText));
        lvI.iItem = index++;
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.iImage = IMAGE_PROPERTY;

        ModifyOrInsertRow(
                    hWndListView,
                    &lvI,
                    pwszText,
                    pwszText,
                    fAddRows,
                    TRUE);
    }

    //
    // Attributes
    //

    //
    // delete any existing attributes
    //
    memset(&lvIDelete, 0, sizeof(lvIDelete));
    lvIDelete.iItem = ListView_GetItemCount(hWndListView) - 1;	
    lvIDelete.mask = LVIF_PARAM;
    while (lvIDelete.iItem >= index)
    {
        if (ListView_GetItemU(hWndListView, &lvIDelete))
        {
            FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvIDelete.lParam);
        }
        ListView_DeleteItem(hWndListView, lvIDelete.iItem);
        lvIDelete.iItem--;
    }

    if (pctlEntry->cAttribute > 0)
    {
        //
        // display the header
        //
        LoadStringU(HinstDll, IDS_ADDITIONAL_ATTRIBUTES, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.iItem = index++;
        ListView_InsertItemU(hWndListView, &lvI);

        //
        // display each attribute
        //
        for (i=0; i<pctlEntry->cAttribute; i++)
        {
            //
            // get the field column string
            //
            wcscpy(szFieldText, INDENT_STRING);
            if (!MyGetOIDInfo(
                        &szFieldText[0] + ((sizeof(INDENT_STRING) - sizeof(TERMINATING_CHAR)) / sizeof(WCHAR)),
                        ARRAYSIZE(szFieldText) - ((sizeof(INDENT_STRING) - sizeof(TERMINATING_CHAR)) / sizeof(WCHAR)),
                        pctlEntry->rgAttribute[i].pszObjId))
            {
                return;
            }

            //
            // get the value column string
            //
            cbFormatedAttribute = 0;
            pbFormatedAttribute = NULL;
            CryptFormatObject(
                        X509_ASN_ENCODING,
                        0,
	                    0,
	                    NULL,
                        pctlEntry->rgAttribute[i].pszObjId,
                        pctlEntry->rgAttribute[i].rgValue[0].pbData,
                        pctlEntry->rgAttribute[i].rgValue[0].cbData,
	                    NULL,
                        &cbFormatedAttribute
                        );

            if (NULL == (pbFormatedAttribute = (BYTE *) malloc(cbFormatedAttribute)))
            {
                return;
            }

            if (CryptFormatObject(
                        X509_ASN_ENCODING,
                        0,
	                    0,
	                    NULL,
                        pctlEntry->rgAttribute[i].pszObjId,
                        pctlEntry->rgAttribute[i].rgValue[0].pbData,
                        pctlEntry->rgAttribute[i].rgValue[0].cbData,
	                    pbFormatedAttribute,
                        &cbFormatedAttribute
                        ))
            {
                lvI.iItem = index++;
                lvI.cchTextMax = wcslen(szFieldText);
                lvI.lParam = (LPARAM)  MakeListDisplayHelperForExtension(
                                                        pctlEntry->rgAttribute[i].pszObjId,
                                                        pctlEntry->rgAttribute[i].rgValue[0].pbData,
                                                        pctlEntry->rgAttribute[i].rgValue[0].cbData);
                ListView_InsertItemU(hWndListView, &lvI);
                ListView_SetItemTextU(
                        hWndListView,
                        index-1,
                        1,
                        (LPWSTR)pbFormatedAttribute);
            }

            free (pbFormatedAttribute);
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static PCCERT_CONTEXT FindCertContextInStores(
                                PCTL_ENTRY  pCtlEntry,
                                DWORD       chStores1,
                                HCERTSTORE  *rghStores1,
                                DWORD       chStores2,
                                HCERTSTORE  *rghStores2,
                                HCERTSTORE  hExtraStore,
                                DWORD       dwFindType)
{
    DWORD           i;
    PCCERT_CONTEXT  pCertContext = NULL;

    if (dwFindType == 0)
    {
        return NULL;
    }

    i = 0;
    while ((i<chStores1) && (pCertContext == NULL))
    {
        pCertContext = CertFindCertificateInStore(
                                rghStores1[i++],
                                X509_ASN_ENCODING,
                                0,
                                dwFindType,
                                (void *)&(pCtlEntry->SubjectIdentifier),
                                NULL);
    }

    i = 0;
    while ((i<chStores2) && (pCertContext == NULL))
    {
        pCertContext = CertFindCertificateInStore(
                                rghStores2[i++],
                                X509_ASN_ENCODING,
                                0,
                                dwFindType,
                                (void *)&(pCtlEntry->SubjectIdentifier),
                                NULL);
    }

    if (pCertContext == NULL)
    {
        pCertContext = CertFindCertificateInStore(
                                hExtraStore,
                                X509_ASN_ENCODING,
                                0,
                                dwFindType,
                                (void *)&(pCtlEntry->SubjectIdentifier),
                                NULL);
    }

    return pCertContext;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void AddCertificatesToList(HWND hWndListView, CTL_VIEW_HELPER *pviewhelp)
{
    LPWSTR          pwszText;
    WCHAR           szText[CRYPTUI_MAX_STRING_SIZE];
    LV_ITEMW        lvI;
    DWORD           i;
    PCCTL_CONTEXT   pctl;
    DWORD           dwFindType;
    ALG_ID          algID;
    PCCRYPT_OID_INFO pOIDInfo;
    PCCERT_CONTEXT  pCertContext;
    int             index = 0;
    BOOL            fDisplayed;
    HCERTSTORE      hExtraStore;

    pctl = pviewhelp->pcvctl->pCTLContext;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szText;
    lvI.iSubItem = 0;
    lvI.lParam = (LPARAM)NULL;

    //
    // determine what type of hash the CTL uses, if it isn't anything
    // we know about then dont try to find any certs
    //
    pOIDInfo = CryptFindOIDInfo(
                    CRYPT_OID_INFO_OID_KEY,
                    pctl->pCtlInfo->SubjectAlgorithm.pszObjId,
                    CRYPT_HASH_ALG_OID_GROUP_ID);

    if ((pOIDInfo != NULL) && (pOIDInfo->Algid == CALG_SHA1))
    {
        dwFindType = CERT_FIND_SHA1_HASH;
    }
    else if ((pOIDInfo != NULL) && (pOIDInfo->Algid == CALG_MD5))
    {
        dwFindType = CERT_FIND_MD5_HASH;
    }
    else
    {
        dwFindType = 0;
    }

    //
    // loop for each cert and try to find it
    //
    for (i=0; i<pctl->pCtlInfo->cCTLEntry; i++)
    {
        fDisplayed = FALSE;

        if (dwFindType != 0)
        {
            pCertContext = FindCertContextInStores(
                                &(pctl->pCtlInfo->rgCTLEntry[i]),
                                pviewhelp->chStores,
                                pviewhelp->phStores,
                                pviewhelp->pcvctl->cCertSearchStores,
                                pviewhelp->pcvctl->rghCertSearchStores,
                                pviewhelp->hExtraStore,
                                dwFindType);
        }
        else
        {
            pCertContext = NULL;
        }

        //
        // if we found a cert to go with the hash, then get a display name for it
        // and display that along with the hash
        //
        if (pCertContext != NULL)
        {
            //
            // subject algorithm
            //
            if (CertGetNameStringW(
                pCertContext,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                0,//CERT_NAME_ISSUER_FLAG,
                NULL,
                szText,
                ARRAYSIZE(szText)))
            {
                if (FormatMemBufToString(
                            &pwszText,
                            pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.pbData,
                            pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.cbData))
                {
                    lvI.lParam = (LPARAM) pCertContext;
                    lvI.iItem = index++;
                    lvI.cchTextMax = wcslen(szText);
                    ListView_InsertItemU(hWndListView, &lvI);
                    ListView_SetItemTextU(hWndListView, index-1 , 1, pwszText);
                    free(pwszText);
                    fDisplayed = TRUE;
                }
            }
        }

        //
        // if the cert hasn't been displayed, that means no cert could be found based
        // on the hash, or a simple name could not be acquired, in any case, just
        // display the hash without a name
        //
        if (!fDisplayed)
        {
            if (FormatMemBufToString(
                        &pwszText,
                        pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.pbData,
                        pctl->pCtlInfo->rgCTLEntry[i].SubjectIdentifier.cbData))
            {
                lvI.lParam = (LPARAM) pCertContext;
                lvI.iItem = index++;
                LoadStringU(HinstDll, IDS_NOTAVAILABLE, szText, ARRAYSIZE(szText));
                lvI.cchTextMax = wcslen(szText);
                ListView_InsertItemU(hWndListView, &lvI);
                ListView_SetItemTextU(hWndListView, index-1 , 1, pwszText);
                free(pwszText);
                fDisplayed = TRUE;
            }
        }

        //
        // if for some strange reason we have not displayed the cert and we have
        // a context for it, then free it so there is no memory leak
        //
        if ((fDisplayed == FALSE) && (pCertContext != NULL))
        {
            CertFreeCertificateContext(pCertContext);
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageCTLTrustList(HWND hwndDlg, UINT msg, WPARAM wParam,
                                    LPARAM lParam)
{
    DWORD               i;
    PROPSHEETPAGE       *ps;
    PCCTL_CONTEXT       pctl;
    CTL_VIEW_HELPER     *pviewhelp;
    HWND                hWndListView;
    HWND                hwnd;
    LV_COLUMNW          lvC;
    WCHAR               szText[CRYPTUI_MAX_STRING_SIZE];
    WCHAR               szCompareText[CRYPTUI_MAX_STRING_SIZE];
    PCTL_INFO           pCtlInfo;
    PCCERT_CONTEXT      pCertContext;
    LPWSTR              pwszText;
    int                 listIndex;
    LVITEMW             lvI;
    LPNMLISTVIEW        pnmv;
    NMLISTVIEW          nmv;


    switch ( msg ) {
    case WM_INITDIALOG:
        //
        // save the pviewhelp struct in DWL_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (CTL_VIEW_HELPER *) (ps->lParam);
        pctl = pviewhelp->pcvctl->pCTLContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);

        pviewhelp->previousSelection = -1;
        pviewhelp->currentSelection = -1;

        //
        // open the know stores that we will be extracting the cert contexts from
        //
        if (!AllocAndOpenKnownStores(&(pviewhelp->chStores), &(pviewhelp->phStores)))
        {
            pviewhelp->chStores = 0;
            pviewhelp->phStores = NULL;
        }

        //
        // clear the text in the detail edit box
        //
        CryptUISetRicheditTextW(hwndDlg, IDC_CTL_TRUSTLIST_DETAIL_EDIT, L"");

        //
        // since there is no cert selected initially disable the "view cert button"
        //
        EnableWindow(GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_VIEW_BUTTON), FALSE);

        //
        // initialize the columns in the list view
        //
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.pszText = szText;   // The text for the column.

        // Add the columns. They are loaded from a string table.
        lvC.iSubItem = 0;
        lvC.cx = 115;
        LoadStringU(HinstDll, IDS_ISSUEDTO2, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTIFICATE_LIST), 0, &lvC) == -1)
        {
            // error
        }

        lvC.cx = 230;
        LoadStringU(HinstDll, IDS_THUMBPRINT, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTIFICATE_LIST), 1, &lvC) == -1)
        {
            // error
        }

        // Add the columns. They are loaded from a string table.
        lvC.iSubItem = 0;
        lvC.cx = 121;
        LoadStringU(HinstDll, IDS_FIELD, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST), 0, &lvC) == -1)
        {
            // error
        }

        lvC.cx = 200;
        LoadStringU(HinstDll, IDS_VALUE, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST), 1, &lvC) == -1)
        {
            // error
        }

        //
        // set the styles in the list views so that they highlight an entire line and
        // so they alway show their selection
        //
        SendDlgItemMessageA(
                hwndDlg,
                IDC_CTL_TRUSTLIST_CERTIFICATE_LIST,
                LVM_SETEXTENDEDLISTVIEWSTYLE,
                0,
                LVS_EX_FULLROWSELECT);
        SendDlgItemMessageA(
                hwndDlg,
                IDC_CTL_TRUSTLIST_CERTVALUE_LIST,
                LVM_SETEXTENDEDLISTVIEWSTYLE,
                0,
                LVS_EX_FULLROWSELECT);

        //
        // add all the certificates to the certificate list box
        //
        AddCertificatesToList(GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTIFICATE_LIST), pviewhelp);

        return TRUE;

    case WM_NOTIFY:

        pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pctl = pviewhelp->pcvctl->pCTLContext;
        pCtlInfo = pctl->pCtlInfo;

        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case PSN_HELP:

            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvctl->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvctl->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvctl->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvctl->dwHelpId);
            }
            return TRUE;

        case LVN_ITEMCHANGING:

            pnmv = (LPNMLISTVIEW) lParam;

            switch(((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_CTL_TRUSTLIST_CERTVALUE_LIST:

                hWndListView = GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST);

                //
                // if this item is being de-selected, then save it's index incase we need to
                // re-select it
                if ((pnmv->uOldState & LVIS_SELECTED) || (pnmv->uOldState & LVIS_FOCUSED))
                {
                    pviewhelp->previousSelection = pnmv->iItem;
                }

                //
                //
                // if the new item selected is the "Additional Attributes" header, then
                // don't allow it to be selected
                //
                if (pnmv->uNewState & LVIS_SELECTED)
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.iItem = pnmv->iItem;
                    lvI.mask = LVIF_TEXT;
                    lvI.pszText = szText;
                    lvI.cchTextMax = ARRAYSIZE(szText);
                    if (!ListView_GetItemU(hWndListView, &lvI))
                    {
                        return FALSE;
                    }

                    LoadStringU(HinstDll, IDS_ADDITIONAL_ATTRIBUTES, szCompareText, ARRAYSIZE(szCompareText));
                    if (wcscmp(szCompareText, szText) == 0)
                    {
                        if (pnmv->iItem == pviewhelp->previousSelection-1)
                        {
                            pviewhelp->currentSelection = pviewhelp->previousSelection-2;
                        }
                        else if (pnmv->iItem == pviewhelp->previousSelection+1)
                        {
                            pviewhelp->currentSelection = pviewhelp->previousSelection+2;
                        }
                        else
                        {
                            pviewhelp->currentSelection = pviewhelp->previousSelection;
                        }

                        ListView_SetItemState(
                            GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST),
                            pviewhelp->currentSelection,
                            LVIS_SELECTED | LVIS_FOCUSED,
                            LVIS_SELECTED | LVIS_FOCUSED);

                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
                    }
                    else
                    {
                        pviewhelp->currentSelection = pnmv->iItem;
                    }

                    DisplayHelperTextInEdit(
                            GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST),
                            hwndDlg,
                            IDC_CTL_TRUSTLIST_DETAIL_EDIT,
                            pviewhelp->currentSelection);
                }

                break;

            case IDC_CTL_TRUSTLIST_CERTIFICATE_LIST:
                if (pnmv->uNewState & LVIS_SELECTED)
                {
                    //memcpy(&nmv, pnmv, sizeof(nmv));
                    //nmv.hdr.code = NM_CLICK;
                    //SendMessage(hwndDlg, WM_NOTIFY, 0, (LPARAM) &nmv);

                    hWndListView = GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTIFICATE_LIST);

                    //
                    // get the selected item and its corresponding cert context
                    //
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.iItem = pnmv->iItem;
                    lvI.mask = LVIF_PARAM;
                    if (!ListView_GetItemU(hWndListView, &lvI))
                    {
                        return FALSE;
                    }
                    DisplayCertificateValues(
                            GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST),
                            (PCCERT_CONTEXT) lvI.lParam,
                            &(pctl->pCtlInfo->rgCTLEntry[pnmv->iItem]));
                    //
                    // clear the text in the detail edit box
                    //
                    CryptUISetRicheditTextW(hwndDlg, IDC_CTL_TRUSTLIST_DETAIL_EDIT, L"");

                    //
                    // enable the "view cert button" based on whether the cert is available or not
                    //
                    if (((PCCERT_CONTEXT) lvI.lParam) == NULL)
                    {
                        EnableWindow(GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_VIEW_BUTTON), FALSE);
                    }
                    else
                    {
                        EnableWindow(GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_VIEW_BUTTON), TRUE);
                    }

                    DisplayHelperTextInEdit(
                            GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST),
                            hwndDlg,
                            IDC_CTL_TRUSTLIST_DETAIL_EDIT,
                            pviewhelp->currentSelection);
                }

                break;
            }

            return TRUE;

        case NM_DBLCLK:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_CTL_TRUSTLIST_CERTIFICATE_LIST:

                if (IsWindowEnabled(GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_VIEW_BUTTON)))
                {
                    SendMessage(
                            hwndDlg,
                            WM_COMMAND,
                            MAKELONG(IDC_CTL_GENERAL_VIEW_BUTTON, BN_CLICKED),
                            (LPARAM) GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_VIEW_BUTTON));
                }
                break;
            }

            break;

        case NM_CLICK:

            pnmv = (LPNMLISTVIEW) lParam;

            switch (((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_CTL_TRUSTLIST_CERTIFICATE_LIST:

                // FALL THROUGH!! - do this so everything gets updated
                // break;

            case IDC_CTL_TRUSTLIST_CERTVALUE_LIST:

                ListView_SetItemState(
                            GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST),
                            pviewhelp->currentSelection,
                            LVIS_SELECTED | LVIS_FOCUSED,
                            LVIS_SELECTED | LVIS_FOCUSED);

                DisplayHelperTextInEdit(
                        GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST),
                        hwndDlg,
                        IDC_CTL_TRUSTLIST_DETAIL_EDIT,
                        pviewhelp->currentSelection);

                break;
            }

            break;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_CTL_TRUSTLIST_CERTIFICATE_LIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTIFICATE_LIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED;
                    lvI.stateMask = LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;

            case IDC_CTL_TRUSTLIST_CERTVALUE_LIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE;
                    lvI.iItem = 0;
                    lvI.state = LVIS_SELECTED | LVIS_FOCUSED;
                    lvI.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;

            }
            
            break;

        }

        break;

    case WM_COMMAND:
        pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pctl = pviewhelp->pcvctl->pCTLContext;
        pCtlInfo = pctl->pCtlInfo;

        switch (LOWORD(wParam))
        {
        case IDC_CTL_GENERAL_VIEW_BUTTON:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                CRYPTUI_VIEWCERTIFICATE_STRUCTW cvps;

                hWndListView = GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTIFICATE_LIST);

                //
                // get the selected item and its corresponding cert context
                //
                listIndex = ListView_GetNextItem(
                                hWndListView, 		
                                -1, 		
                                LVNI_SELECTED		
                                );	

                memset(&lvI, 0, sizeof(lvI));
                lvI.iItem = listIndex;
                lvI.mask = LVIF_PARAM;
                if (!ListView_GetItemU(hWndListView, &lvI))
                {
                    return FALSE;
                }

                memset(&cvps, 0, sizeof(cvps));
                cvps.dwSize = sizeof(cvps);
                cvps.hwndParent = hwndDlg;
                cvps.pCertContext = (PCCERT_CONTEXT) lvI.lParam;
                cvps.cStores = pviewhelp->pcvctl->cStores;
                cvps.rghStores = pviewhelp->pcvctl->rghStores;
                //cvps.dwFlags = CRYPTUI_IGNORE_UNTRUSTED_ROOT;
                CryptUIDlgViewCertificateW(&cvps, NULL);
            }
            break;
        case IDHELP:
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvctl->szHelpFileName,
                 //        HELP_CONTEXT, pviewhelp->pcvctl->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvctl->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvctl->dwHelpId);
            }
            return TRUE;
        }
        break;

    case WM_DESTROY:
            pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

            if (pviewhelp->chStores != 0)
            {
                FreeAndCloseKnownStores(pviewhelp->chStores, pviewhelp->phStores);
            }

            //
            // get all the items in the list view and free the lParam
            // associated with each of them (lParam is the helper sruct)
            //
            hWndListView = GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST);

            memset(&lvI, 0, sizeof(lvI));
            lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
            lvI.mask = LVIF_PARAM;
            while (lvI.iItem >= 0)
            {
                if (ListView_GetItemU(hWndListView, &lvI))
                {
                    FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvI.lParam);
                }
                lvI.iItem--;
            }
            break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTIFICATE_LIST))   &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_CERTVALUE_LIST))     &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_DETAIL_EDIT))        &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CTL_TRUSTLIST_VIEW_BUTTON)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\cvgen.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cvgen.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_SUBJECT_EDIT,                  IDH_CERTVIEW_GENERAL_SUBJECT_EDIT},
    {IDC_CERT_GENERAL_ISSUEDTO_HEADER,  IDH_CERTVIEW_GENERAL_SUBJECT_EDIT},
    {IDC_ISSUER_EDIT,                   IDH_CERTVIEW_GENERAL_ISSUER_EDIT},
    {IDC_CERT_GENERAL_ISSUEDBY_HEADER,  IDH_CERTVIEW_GENERAL_ISSUER_EDIT},
    {IDC_ADD_TO_STORE_BUTTON,           IDH_CERTVIEW_GENERAL_INSTALLCERT_BUTTON},
    {IDC_DISCLAIMER_BUTTON,             IDH_CERTVIEW_GENERAL_DISCLAIMER_BUTTON},
    {IDC_ACCEPT_BUTTON,                 IDH_CERTVIEW_GENERAL_ACCEPT_BUTTON},
    {IDC_DECLINE_BUTTON,                IDH_CERTVIEW_GENERAL_DECLINE_BUTTON},
    {IDC_GOODFOR_EDIT,                  IDH_CERTVIEW_GENERAL_GOODFOR_EDIT},
    {IDC_CERT_GENERAL_GOODFOR_HEADER,   IDH_CERTVIEW_GENERAL_GOODFOR_EDIT},
    {IDC_CERT_GENERAL_VALID_EDIT,       IDH_CERTVIEW_GENERAL_VALID_EDIT},
    {IDC_CERT_PRIVATE_KEY_EDIT,         IDH_CERTVIEW_GENERAL_PRIVATE_KEY_INFO}
};

typedef struct {
    void *  pszString;
    int     offset;
    BOOL    fUnicode;
} STREAMIN_HELP_STRUCT;


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
DWORD CALLBACK MyEditStreamCallback(
    DWORD_PTR dwCookie, // application-defined value
    LPBYTE  pbBuff,     // pointer to a buffer
    LONG    cb,         // number of bytes to read or write
    LONG    *pcb        // pointer to number of bytes transferred
)
{
    BYTE                    *pByte;
    DWORD                   cbResource;
    STREAMIN_HELP_STRUCT    *pHelpStruct;

    pHelpStruct = (STREAMIN_HELP_STRUCT *) dwCookie;

    pByte = (BYTE *)pHelpStruct->pszString;
    if (pHelpStruct->fUnicode)
    {
        cbResource = wcslen((LPWSTR) pHelpStruct->pszString) * sizeof(WCHAR);
    }
    else
    {
        cbResource = strlen((LPSTR) pHelpStruct->pszString);
    }

    if (pHelpStruct->offset == (int) cbResource)
    {
        *pcb = 0;
    }
    else if ((cb >= (int) cbResource) && (pHelpStruct->offset == 0))
    {
        memcpy(pbBuff, pByte, cbResource);
        *pcb = cbResource;
        pHelpStruct->offset = cbResource;
    }
    else if (cb >= (((int)cbResource) - pHelpStruct->offset))
    {
        memcpy(pbBuff, pByte + pHelpStruct->offset, cbResource - pHelpStruct->offset);
        *pcb = cbResource - pHelpStruct->offset;
    }
    else
    {
        memcpy(pbBuff, pByte  + pHelpStruct->offset, cb);
        *pcb = cb;
        pHelpStruct->offset += cb;
    }

    return 0;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static LRESULT StreamInWrapper(HWND hwndEdit, void * pszString, BOOL fUnicode)
{
    EDITSTREAM              editStream;
    char                    szBuffer[2048];
    STREAMIN_HELP_STRUCT    helpStruct;
    LRESULT                 ret;
    BOOL                    fOKToUseRichEdit20 = fRichedit20Usable(hwndEdit);

    memset(&editStream, 0, sizeof(EDITSTREAM));
    editStream.pfnCallback = MyEditStreamCallback;
    editStream.dwCookie = (DWORD_PTR) &helpStruct;

    SendMessageA(hwndEdit, EM_SETSEL, 0, -1);
    SendMessageA(hwndEdit, EM_SETSEL, -1, 0);

    if (fUnicode && fRichedit20Exists && fOKToUseRichEdit20)
    {
        helpStruct.pszString = pszString;
        helpStruct.offset = 0;
        helpStruct.fUnicode = TRUE;
        
        return (SendMessage(hwndEdit, EM_STREAMIN, SF_TEXT | SFF_SELECTION | SF_UNICODE, (LPARAM) &editStream));
    }
    else if (fUnicode)
    {
        LPSTR psz = CertUIMkMBStr((LPWSTR) pszString);

        helpStruct.pszString = psz;
        helpStruct.offset = 0;
        helpStruct.fUnicode = FALSE;

        ret = (SendMessage(hwndEdit, EM_STREAMIN, SF_TEXT | SFF_SELECTION, (LPARAM) &editStream));
        free(psz);

        return (ret);
    }
    else
    {
        helpStruct.pszString = pszString;
        helpStruct.offset = 0;
        helpStruct.fUnicode = FALSE;

        return (SendMessage(hwndEdit, EM_STREAMIN, SF_TEXT | SFF_SELECTION, (LPARAM) &editStream));
    }
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void LoadAndDisplayString(HWND hWndEditGoodFor, UINT nId, BOOL *pfFirst)
{
    WCHAR   rgwch[CRYPTUI_MAX_STRING_SIZE];
    
    LoadStringU(HinstDll, nId, rgwch, ARRAYSIZE(rgwch));
    
    if (*pfFirst)
    {
        *pfFirst = FALSE;
    }
    else
    {
        StreamInWrapper(hWndEditGoodFor, "\n", FALSE);
    }
    StreamInWrapper(hWndEditGoodFor, rgwch, TRUE);
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void AddUsagesToEditBox(HWND hWndEditGoodFor, CERT_VIEW_HELPER *pviewhelp)
{
    BOOL                fIndividualCodeSigning = FALSE;
    BOOL                fCommercialCodeSigning = FALSE;
    BOOL                fVirusString = FALSE;
    BOOL                fTimeStamping = FALSE;
    BOOL                fSGC = FALSE;
    BOOL                fIPSec = FALSE;
    int                 goodForIndex = 0;
    DWORD               i;
    BOOL                *rgfOIDProcessed;
    PARAFORMAT          paraFormat;
    PCCRYPT_OID_INFO    pOIDInfo;
    BOOL                fFirst = TRUE;

    if (NULL == (rgfOIDProcessed = (BOOL *) malloc(pviewhelp->cUsages * sizeof(BOOL))))
    {
        return;
    }

    for (i=0; i<pviewhelp->cUsages; i++)
    {
        rgfOIDProcessed[i] = FALSE;
    }

    //
    // clear the window
    //
    SetWindowTextU(hWndEditGoodFor, NULL);

    //
    // go through all the oids that this certificate was validated for and
    // add usage bullets to the list boxes, OR, if it was not validated for any
    // usages then put up the nousages string
    //
    for (i=0; i<pviewhelp->cUsages; i++)
    {
        if ((strcmp(szOID_PKIX_KP_TIMESTAMP_SIGNING, pviewhelp->rgUsages[i]) == 0) ||
            (strcmp(szOID_KP_TIME_STAMP_SIGNING, pviewhelp->rgUsages[i]) == 0))
        {
            if (!fTimeStamping)
            {
                LoadAndDisplayString(hWndEditGoodFor, ID_RTF_TIMESTAMP, &fFirst);
                fTimeStamping = TRUE;
            }
            rgfOIDProcessed[i] = TRUE;
        }
        else if (strcmp(szOID_KP_CTL_USAGE_SIGNING, pviewhelp->rgUsages[i]) == 0)
        {
            LoadAndDisplayString(hWndEditGoodFor, ID_RTF_CTLSIGN, &fFirst);
            rgfOIDProcessed[i] = TRUE;
        }
        else if (strcmp("1.3.6.1.4.1.311.10.3.4", pviewhelp->rgUsages[i]) == 0) // EFS
        {
            LoadAndDisplayString(hWndEditGoodFor, ID_RTF_EFS, &fFirst);
            rgfOIDProcessed[i] = TRUE;
        }
        else if (strcmp(szOID_PKIX_KP_SERVER_AUTH, pviewhelp->rgUsages[i]) == 0)
        {
            LoadAndDisplayString(hWndEditGoodFor, ID_RTF_SERVERAUTH, &fFirst);
            rgfOIDProcessed[i] = TRUE;
        }
        else if (strcmp(szOID_PKIX_KP_CLIENT_AUTH, pviewhelp->rgUsages[i]) == 0)
        {
            LoadAndDisplayString(hWndEditGoodFor, ID_RTF_CLIENTAUTH, &fFirst);
            rgfOIDProcessed[i] = TRUE;
        }
        else if (strcmp(szOID_PKIX_KP_EMAIL_PROTECTION, pviewhelp->rgUsages[i]) == 0)
        {
            //LoadAndDisplayString(hWndEditGoodFor, ID_RTF_EMAIL3, &fFirst);
            //LoadAndDisplayString(hWndEditGoodFor, ID_RTF_EMAIL2, &fFirst);
            LoadAndDisplayString(hWndEditGoodFor, ID_RTF_EMAIL1, &fFirst);
            rgfOIDProcessed[i] = TRUE;
        }
        else if (strcmp(szOID_PKIX_KP_CODE_SIGNING, pviewhelp->rgUsages[i]) == 0)
        {
            if (!fCommercialCodeSigning)
            {
                if (strcmp(szOID_PKIX_KP_CODE_SIGNING, pviewhelp->rgUsages[i]) == 0)
                {
                    LoadAndDisplayString(hWndEditGoodFor, ID_RTF_CODESIGN_COMMERCIAL_PKIX, &fFirst);
                }
                else
                {
                    LoadAndDisplayString(hWndEditGoodFor, ID_RTF_CODESIGN_COMMERCIAL, &fFirst);
                }

                if (!fIndividualCodeSigning)
                {
                    LoadAndDisplayString(hWndEditGoodFor, ID_RTF_CODESIGN_GENERAL, &fFirst);
                }
                fCommercialCodeSigning = TRUE;
            }
            rgfOIDProcessed[i] = TRUE;
        }
        else if ((strcmp(szOID_PKIX_KP_IPSEC_END_SYSTEM, pviewhelp->rgUsages[i]) == 0)  ||
                 (strcmp(szOID_PKIX_KP_IPSEC_TUNNEL, pviewhelp->rgUsages[i]) == 0)      ||
                 (strcmp(szOID_PKIX_KP_IPSEC_USER, pviewhelp->rgUsages[i]) == 0)        ||
                 (strcmp("1.3.6.1.5.5.8.2.2", pviewhelp->rgUsages[i]) == 0))
        {
            if (!fIPSec)
            {
                LoadAndDisplayString(hWndEditGoodFor, ID_RTF_IPSEC, &fFirst);
                fIPSec = TRUE;
            }
            rgfOIDProcessed[i] = TRUE;
        }
    }


    //
    // re walk the oids to add the ones that were not processed,
    // if they weren't processed that means we don't have a pre-defined
    // string for them, so just add the oid
    //
    for (i=0; i<pviewhelp->cUsages; i++)
    {
        if (!rgfOIDProcessed[i])
        {
            pOIDInfo = CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY, pviewhelp->rgUsages[i], 0);

            if (pOIDInfo != NULL)
            {
                if (fFirst)
                {
                    fFirst = FALSE;
                }
                else
                {
                    StreamInWrapper(hWndEditGoodFor, "\n", FALSE);
                }
                StreamInWrapper(hWndEditGoodFor, (void *) pOIDInfo->pwszName, TRUE);
            }
            else
            {
                if (fFirst)
                {
                    fFirst = FALSE;
                }
                else
                {
                    StreamInWrapper(hWndEditGoodFor, "\n", FALSE);
                }
                StreamInWrapper(hWndEditGoodFor, pviewhelp->rgUsages[i], FALSE);
            }
        }
    }

    free(rgfOIDProcessed);

    memset(&paraFormat, 0, sizeof(paraFormat));
    paraFormat.cbSize= sizeof(paraFormat);
    paraFormat.dwMask = PFM_NUMBERING;
    paraFormat.wNumbering = PFN_BULLET;
    SendMessage(hWndEditGoodFor, EM_SETSEL, 0, -1);
    SendMessage(hWndEditGoodFor, EM_SETPARAFORMAT, 0, (LPARAM) &paraFormat);
    SendMessage(hWndEditGoodFor, EM_SETSEL, -1, 0);
    SendMessage(hWndEditGoodFor, EM_HIDESELECTION, (WPARAM) TRUE, (LPARAM) FALSE);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static int GetEditControlMaxLineWidth (HWND hwndEdit, HDC hdc, int cline)
{
    int        index;
    int        line;
    int        charwidth;
    int        maxwidth = 0;
    CHAR       szMaxBuffer[1024];
    WCHAR      wsz[1024];
    TEXTRANGEA tr;
    SIZE       size;

    tr.lpstrText = szMaxBuffer;

    for ( line = 0; line < cline; line++ )
    {
        index = (int)SendMessageA(hwndEdit, EM_LINEINDEX, (WPARAM)line, 0);
        charwidth = (int)SendMessageA(hwndEdit, EM_LINELENGTH, (WPARAM)index, 0);

        tr.chrg.cpMin = index;
        tr.chrg.cpMax = index + charwidth;
        SendMessageA(hwndEdit, EM_GETTEXTRANGE, 0, (LPARAM)&tr);

        wsz[0] = NULL;

        MultiByteToWideChar(0, 0, (const char *)tr.lpstrText, -1, &wsz[0], 1024);

        if (wsz[0])
        {
            GetTextExtentPoint32W(hdc, &wsz[0], charwidth, &size);

            if ( (size.cx+2) > maxwidth )
            {
                maxwidth = size.cx+2;
            }
        }
    }

    return( maxwidth );
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void ResizeEditControl(HWND  hwndDlg, HWND  hwnd, BOOL fResizeHeight, BOOL fResizeWidth, RECT originalRect)
{
    RECT        rect;
    TEXTMETRIC  tm;
    HDC         hdc;
    int         cline;
    int         currentHeight;
    int         newHeight;
    int         newWidth;
    int         totalRowHeight;
    POINT       pointInFirstRow;
    POINT       pointInSecondRow;
    int         secondLineCharIndex;
    int         i;

    SetWindowPos(hwnd,
                    NULL,
                    0,
                    0,
                    originalRect.right-originalRect.left,
                    originalRect.bottom-originalRect.top,
                    SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);

    hdc = GetDC(hwnd);
    if ((hdc == NULL) && fResizeWidth)
    {
        return;
    }

    //
    // HACK ALERT, believe it or not there is no way to get the height of the current
    // font in the edit control, so get the position a character in the first row and the position
    // of a character in the second row, and do the subtraction to get the
    // height of the font
    //
    SendMessageA(hwnd, EM_POSFROMCHAR, (WPARAM) &pointInFirstRow, (LPARAM) 0);

    //
    // HACK ON TOP OF HACK ALERT,
    // since there may not be a second row in the edit box, keep reducing the width
    // by half until the first row falls over into the second row, then get the position
    // of the first char in the second row and finally reset the edit box size back to
    // it's original size
    //
    secondLineCharIndex = (int)SendMessageA(hwnd, EM_LINEINDEX, (WPARAM) 1, (LPARAM) 0);
    if (secondLineCharIndex == -1)
    {
        for (i=0; i<20; i++)
        {
            GetWindowRect(hwnd, &rect);
            SetWindowPos(   hwnd,
                            NULL,
                            0,
                            0,
                            (rect.right-rect.left)/2,
                            rect.bottom-rect.top,
                            SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
            secondLineCharIndex = (int)SendMessageA(hwnd, EM_LINEINDEX, (WPARAM) 1, (LPARAM) 0);
            if (secondLineCharIndex != -1)
            {
                break;
            }
        }

        if (secondLineCharIndex == -1)
        {
            // if we failed after twenty tries just reset the control to its original size
            // and get the heck outa here!!
            SetWindowPos(hwnd,
                    NULL,
                    0,
                    0,
                    originalRect.right-originalRect.left,
                    originalRect.bottom-originalRect.top,
                    SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);

            if (hdc != NULL)
            {
                ReleaseDC(hwnd, hdc);
            }

            return;
        }

        SendMessageA(hwnd, EM_POSFROMCHAR, (WPARAM) &pointInSecondRow, (LPARAM) secondLineCharIndex);

        SetWindowPos(hwnd,
                    NULL,
                    0,
                    0,
                    originalRect.right-originalRect.left,
                    originalRect.bottom-originalRect.top,
                    SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
    }
    else
    {
        SendMessageA(hwnd, EM_POSFROMCHAR, (WPARAM) &pointInSecondRow, (LPARAM) secondLineCharIndex);
    }

    //
    // if we need to resize the height then do it
    //
    if (fResizeHeight)
    {
        //
        // Calculate the new height needed
        //
        totalRowHeight = pointInSecondRow.y - pointInFirstRow.y;
        cline = (int)SendMessageA(hwnd, EM_GETLINECOUNT, 0, 0);
        currentHeight = originalRect.bottom - originalRect.top;

        // if the height required is greater than the previous height
        // then resize to an integral line height less than current height
        if ((cline * totalRowHeight) > currentHeight)
        {
            newHeight = (currentHeight / totalRowHeight) * totalRowHeight;
        }
        else
        {
            newHeight = cline * totalRowHeight;
        }
    }
    else
    {
        newHeight = rect.bottom - rect.top;
    }

    if (fResizeWidth)
    {
        newWidth = GetEditControlMaxLineWidth(hwnd, hdc, cline);
        if (newWidth > (originalRect.right - originalRect.left))
        {
            newWidth = originalRect.right - originalRect.left;
        }
    }
    else
    {
        newWidth = originalRect.right - originalRect.left;
    }

    SetWindowPos(hwnd, NULL, 0, 0, newWidth, newHeight, SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
    
    if (hdc != NULL)
    {
        ReleaseDC(hwnd, hdc);
    }
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL CertificateHasPrivateKey(PCCERT_CONTEXT pccert)
{
    DWORD cb = 0;

    return (CertGetCertificateContextProperty(pccert, CERT_KEY_PROV_INFO_PROP_ID, NULL, &cb));
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageGeneral(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD               i;
    PCCERT_CONTEXT      pccert;
    ENLINK *            penlink;
    PROPSHEETPAGE *     ps;
    CERT_VIEW_HELPER *  pviewhelp;
    WCHAR               rgwch[CRYPTUI_MAX_STRING_SIZE];
    DWORD               cb;
    HWND                hWndListView;
    HWND                hwnd;
    HWND                hWndEdit;
    LPNMLISTVIEW        pnmv;
    LPSTR               pszSubjectURL=NULL;
    LPSTR               pszIssuerURL=NULL;
    CHARFORMAT          chFormat;
    HWND                hWndIssuerEdit;
    HWND                hWndSubjectEdit;
    HWND                hWndGoodForEdit;
    PLINK_SUBCLASS_DATA plsd;
    HANDLE              hIcon;
    RECT                tempRect;
    DWORD               dwCertAccessProperty;
    int                 buttonPos = 1;
    LPWSTR              pwszDateString;
    WCHAR               szFindText[CRYPTUI_MAX_STRING_SIZE];
    FINDTEXTEX          findText;
    WCHAR               errorString[CRYPTUI_MAX_STRING_SIZE];
    WCHAR               errorTitle[CRYPTUI_MAX_STRING_SIZE];
    BOOL                fPrivateKeyExists;
    LPHELPINFO          lpHelpInfo;
    HELPINFO            helpInfo;

    LPWSTR              pwszIssuerNameString = NULL;
    LPWSTR              pwszSubjectNameString = NULL;

    
    switch ( msg ) {
    case WM_INITDIALOG:
        //
        // save the pviewhelp struct in DWL_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (CERT_VIEW_HELPER *) (ps->lParam);
        pccert = pviewhelp->pcvp->pCertContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);
        pviewhelp->hwndGeneralPage = hwndDlg;

        //
        // check to see if this certificate has a private key with it
        //
        if (CertificateHasPrivateKey(pccert))
        {
            LoadStringU(HinstDll, IDS_PRIVATE_KEY_EXISTS, rgwch, ARRAYSIZE(rgwch));
            CryptUISetRicheditTextW(hwndDlg, IDC_CERT_PRIVATE_KEY_EDIT, rgwch);

            if (NULL != (plsd = (PLINK_SUBCLASS_DATA) malloc(sizeof(LINK_SUBCLASS_DATA))))
            {
                memset(plsd, 0, sizeof(LINK_SUBCLASS_DATA));
                plsd->hwndParent = hwndDlg;
                plsd->uId = IDC_CERT_PRIVATE_KEY_EDIT;

                LoadStringU(HinstDll, IDS_PRIVATE_KEY_EXISTS_TOOLTIP, rgwch, ARRAYSIZE(rgwch));
                plsd->pszURL = CertUIMkMBStr(rgwch);
                plsd->fNoCOM = pviewhelp->fNoCOM;
                plsd->fUseArrowInsteadOfHand = TRUE;

                CertSubclassEditControlForLink(hwndDlg, GetDlgItem(hwndDlg, IDC_CERT_PRIVATE_KEY_EDIT), plsd);
            }
            fPrivateKeyExists = TRUE;
        }
        else
        {
            ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_PRIVATE_KEY_EDIT), SW_HIDE);
            fPrivateKeyExists = FALSE;
        }

        //
        // Initialize the CCertificateBmp
        //
        pviewhelp->pCCertBmp->SetWindow(hwndDlg);
        pviewhelp->pCCertBmp->SetHinst(HinstDll);
        pviewhelp->pCCertBmp->SetRevoked(pviewhelp->cUsages == 0);
        pviewhelp->pCCertBmp->SetCertContext(pccert, fPrivateKeyExists);
        pviewhelp->pCCertBmp->DoSubclass();

        //
        // deal with button states and placements
        //
        if (!(CRYPTUI_ACCEPT_DECLINE_STYLE & pviewhelp->pcvp->dwFlags))
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_ACCEPT_BUTTON), FALSE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_ACCEPT_BUTTON), SW_HIDE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_DECLINE_BUTTON), FALSE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_DECLINE_BUTTON), SW_HIDE);

            //
            // check to see if there is a disclaimer in the cert
            //
            // DSIE: Bug 364742
            if (!IsOKToDisplayCPS(pccert, pviewhelp->dwChainError))
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_DISCLAIMER_BUTTON), FALSE);
                pviewhelp->fCPSDisplayed = FALSE;
            }
            else
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_DISCLAIMER_BUTTON), TRUE);
                pviewhelp->fCPSDisplayed = TRUE;
            }

            //
            // for the "Install Certificate" button, get the CERT_ACCESS_STATE_PROP_ID
            // and check it
            //
            cb = sizeof(DWORD);
            CertGetCertificateContextProperty(
                    pccert,
                    CERT_ACCESS_STATE_PROP_ID,
                    (void *) &dwCertAccessProperty,
                    &cb);

            if (pviewhelp->pcvp->dwFlags & CRYPTUI_ENABLE_ADDTOSTORE)
            {
                ShowWindow(GetDlgItem(hwndDlg, IDC_ADD_TO_STORE_BUTTON), SW_SHOW);
            }
            else if(pviewhelp->pcvp->dwFlags & CRYPTUI_DISABLE_ADDTOSTORE)
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_ADD_TO_STORE_BUTTON), FALSE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_ADD_TO_STORE_BUTTON), SW_HIDE);
            }
            else
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_ADD_TO_STORE_BUTTON),
                    (dwCertAccessProperty & CERT_ACCESS_STATE_SYSTEM_STORE_FLAG) ? FALSE : TRUE);
                ShowWindow(
                    GetDlgItem(hwndDlg, IDC_ADD_TO_STORE_BUTTON),
                    (dwCertAccessProperty & CERT_ACCESS_STATE_SYSTEM_STORE_FLAG) ? SW_HIDE : SW_SHOW);
            }
        }
        else
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_DISCLAIMER_BUTTON), FALSE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_DISCLAIMER_BUTTON), SW_HIDE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_ADD_TO_STORE_BUTTON), FALSE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_ADD_TO_STORE_BUTTON), SW_HIDE);

            pviewhelp->fAccept = FALSE;
        }

        hWndGoodForEdit = GetDlgItem(hwndDlg, IDC_GOODFOR_EDIT);

        //
        // set the original rect fields of the usage edits in the viewhelp struct
        // so that they can be used any time a resize is needed
        //
        GetWindowRect(hWndGoodForEdit, &pviewhelp->goodForOriginalRect);

        //
        // fill in the "This certificate is intended to" bullet list
        //

        AddUsagesToEditBox(
                hWndGoodForEdit,
                pviewhelp);

        //
        // resize the edit controls so that they are an integral number of lines
        //
        ResizeEditControl(hwndDlg, hWndGoodForEdit, TRUE, FALSE, pviewhelp->goodForOriginalRect);

        //
        // do the arrow subclass on the usage edit boxes
        //
       // CertSubclassEditControlForArrowCursor(hWndGoodForEdit);

        //
        // if there are no valid usages or we couldn't validate because there wasn't
        // enough information, then hide the usage edit controls so we can
        // display more text, and tell the CCertBmp
        //
        if (pviewhelp->pwszErrorString != NULL)
        {
            EnableWindow(hWndGoodForEdit, FALSE);
            ShowWindow(hWndGoodForEdit, SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_GOODFOR_HEADER), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT), SW_SHOW);
            ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT), SW_HIDE);
            pviewhelp->pCCertBmp->SetChainError(pviewhelp->dwChainError, IsTrueErrorString(pviewhelp),
                                                (pviewhelp->dwChainError == 0) && (pviewhelp->cUsages == NULL));
            CryptUISetRicheditTextW(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT, pviewhelp->pwszErrorString);
        }
        else
        {
            ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT), SW_HIDE);
            if (pviewhelp->fCPSDisplayed)
            {
                ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT), SW_SHOW);
            }
            else
            {
                ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT), SW_HIDE);
            }
        }

        hWndIssuerEdit = GetDlgItem(hwndDlg, IDC_ISSUER_EDIT);
        hWndSubjectEdit = GetDlgItem(hwndDlg, IDC_SUBJECT_EDIT);

#if (0) //DISE: Bug 383855
        //
        // set the subject and issuer name
        //
        CertGetNameStringW(
                pccert,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                0,//CERT_NAME_ISSUER_FLAG,
                NULL,
                rgwch,
                ARRAYSIZE(rgwch));

        CryptUISetRicheditTextW(hwndDlg, IDC_SUBJECT_EDIT, rgwch);
#else
        pwszSubjectNameString = GetDisplayNameString(pccert, 0);

        CryptUISetRicheditTextW(hwndDlg, IDC_SUBJECT_EDIT, pwszSubjectNameString);

        if (NULL != pwszSubjectNameString)
        {
            free(pwszSubjectNameString);
        }
#endif

#if (0) //DISE: Bug 383855
        CertGetNameStringW(
                pccert,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                CERT_NAME_ISSUER_FLAG,
                NULL,
                rgwch,
                ARRAYSIZE(rgwch));

        CryptUISetRicheditTextW(hwndDlg, IDC_ISSUER_EDIT, rgwch);
#else
        pwszIssuerNameString = GetDisplayNameString(pccert, CERT_NAME_ISSUER_FLAG);

        CryptUISetRicheditTextW(hwndDlg, IDC_ISSUER_EDIT, pwszIssuerNameString);

        if (NULL != pwszIssuerNameString)
        {
            free(pwszIssuerNameString);
        }
#endif

        //
        // resize the name edit controls so that they just encapsulate the names
        //
        GetWindowRect(hWndSubjectEdit, &tempRect);
        ResizeEditControl(hwndDlg, hWndSubjectEdit, TRUE, FALSE, tempRect);
        GetWindowRect(hWndIssuerEdit, &tempRect);
        ResizeEditControl(hwndDlg, hWndIssuerEdit, TRUE, FALSE, tempRect);

        //
        // check if this should look like a link or not, if so, then set color and underline
        //
        // DSIE: Bug 367720.
        if (AllocAndGetSubjectURL(&pszSubjectURL, pccert) &&
            IsOKToFormatAsLinkA(pszSubjectURL, pviewhelp->dwChainError))
        {
            memset(&chFormat, 0, sizeof(chFormat));
            chFormat.cbSize = sizeof(chFormat);
            chFormat.dwMask = CFM_UNDERLINE | CFM_COLOR;
            chFormat.dwEffects = CFE_UNDERLINE;
            chFormat.crTextColor = RGB(0,0,255);
            SendMessageA(hWndSubjectEdit, EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);

            if (NULL != (plsd = (PLINK_SUBCLASS_DATA) malloc(sizeof(LINK_SUBCLASS_DATA))))
            {
                memset(plsd, 0, sizeof(LINK_SUBCLASS_DATA));
                plsd->hwndParent = hwndDlg;
                plsd->uId = IDC_SUBJECT_EDIT;
                plsd->pszURL = pszSubjectURL;
                plsd->fNoCOM = pviewhelp->fNoCOM;
                plsd->fUseArrowInsteadOfHand = FALSE;

                CertSubclassEditControlForLink(hwndDlg, hWndSubjectEdit, plsd);

                pviewhelp->fSubjectDisplayedAsLink = TRUE;
            }
            else
            {
                free(pszSubjectURL);
                
                CertSubclassEditControlForArrowCursor(hWndSubjectEdit);
            }
        }
        else
        {
            if (pszSubjectURL)
            {
                free(pszSubjectURL);
            }

            CertSubclassEditControlForArrowCursor(hWndSubjectEdit);
        }

        //
        // check if this should look like a link or not, if so, then set color and underline
        //
        // DSIE: Bug 367720.
        if (AllocAndGetIssuerURL(&pszIssuerURL, pccert) &&
            IsOKToFormatAsLinkA(pszIssuerURL, pviewhelp->dwChainError))
        {
            memset(&chFormat, 0, sizeof(chFormat));
            chFormat.cbSize = sizeof(chFormat);
            chFormat.dwMask = CFM_UNDERLINE | CFM_COLOR;
            chFormat.dwEffects = CFE_UNDERLINE;
            chFormat.crTextColor = RGB(0,0,255);
            SendMessageA(hWndIssuerEdit, EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);

            if (NULL != (plsd = (PLINK_SUBCLASS_DATA) malloc(sizeof(LINK_SUBCLASS_DATA))))
            {
                memset(plsd, 0, sizeof(LINK_SUBCLASS_DATA));
                plsd->hwndParent = hwndDlg;
                plsd->uId = IDC_ISSUER_EDIT;
                plsd->pszURL = pszIssuerURL;
                plsd->fNoCOM = pviewhelp->fNoCOM;
                plsd->fUseArrowInsteadOfHand = FALSE;

                CertSubclassEditControlForLink(hwndDlg, hWndIssuerEdit, plsd);

                pviewhelp->fIssuerDisplayedAsLink = TRUE;
            }
            else
            {
                free(pszIssuerURL);
            
                CertSubclassEditControlForArrowCursor(hWndIssuerEdit);
            }
        }
        else
        {
            if (pszIssuerURL)
            {
                free(pszIssuerURL);
            }
            
            CertSubclassEditControlForArrowCursor(hWndIssuerEdit);
        }

        //
        // set the text in all the header edit boxes
        //
        LoadStringU(HinstDll, IDS_CERTIFICATEINFORMATION, rgwch, ARRAYSIZE(rgwch));
        CryptUISetRicheditTextW(hwndDlg, IDC_CERT_GENERAL_HEADER, rgwch);

        LoadStringU(HinstDll, IDS_FORUSEWITH, rgwch, ARRAYSIZE(rgwch));
        CryptUISetRicheditTextW(hwndDlg, IDC_CERT_GENERAL_GOODFOR_HEADER, rgwch);

        LoadStringU(HinstDll, IDS_ISSUEDTO, rgwch, ARRAYSIZE(rgwch));
        CryptUISetRicheditTextW(hwndDlg, IDC_CERT_GENERAL_ISSUEDTO_HEADER, rgwch);

        LoadStringU(HinstDll, IDS_ISSUEDBY, rgwch, ARRAYSIZE(rgwch));
        CryptUISetRicheditTextW(hwndDlg, IDC_CERT_GENERAL_ISSUEDBY_HEADER, rgwch);

        LoadStringU(HinstDll, IDS_ISSUER_WARNING, rgwch, ARRAYSIZE(rgwch));
        CryptUISetRicheditTextW(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT, rgwch);

        //
        // set the font for all the header edit boxes
        //
        memset(&chFormat, 0, sizeof(chFormat));
        chFormat.cbSize = sizeof(chFormat);
        chFormat.dwMask = CFM_BOLD;
        chFormat.dwEffects = CFE_BOLD;
        SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_HEADER), EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);
        SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_GOODFOR_HEADER), EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);
        SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ISSUEDTO_HEADER), EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);
        SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ISSUEDBY_HEADER), EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);
        SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT), EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);

        //
        // subclass the header edit controls so they display an arrow cursor in their window
        //
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_HEADER));
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_GOODFOR_HEADER));
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ISSUEDTO_HEADER));
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ISSUEDBY_HEADER));
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT));
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT));

        //
        // set the validty string
        //
        if (FormatValidityString(&pwszDateString, pccert, GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT)))
        {
            //
            // insert the string and the the font style/color
            //
            CryptUISetRicheditTextW(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT, pwszDateString);
            free(pwszDateString);

            //
            // set the header parts of the validity string to bold
            //
            memset(&chFormat, 0, sizeof(chFormat));
            chFormat.cbSize = sizeof(chFormat);
            chFormat.dwMask = CFM_BOLD;
            chFormat.dwEffects = CFE_BOLD;

            findText.chrg.cpMin = findText.chrgText.cpMin = 0;
            findText.chrg.cpMax = findText.chrgText.cpMax = -1;

            LoadStringU(HinstDll, IDS_VALIDFROM, szFindText, ARRAYSIZE(szFindText));
            findText.lpstrText = CertUIMkMBStr(szFindText);
            SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT),
                        EM_FINDTEXTEX,
                        FR_DOWN,
                        (LPARAM) &findText);
            SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT),
                        EM_SETSEL,
                        findText.chrgText.cpMin,
                        (LPARAM) findText.chrgText.cpMax);
            SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT),
                        EM_SETCHARFORMAT,
                        SCF_SELECTION,
                        (LPARAM) &chFormat);
            free((void *)findText.lpstrText);

            LoadStringU(HinstDll, IDS_VALIDTO, szFindText, ARRAYSIZE(szFindText));
            findText.lpstrText = CertUIMkMBStr(szFindText);
            SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT),
                        EM_FINDTEXTEX,
                        FR_DOWN,
                        (LPARAM) &findText);
            SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT),
                        EM_SETSEL,
                        findText.chrgText.cpMin,
                        (LPARAM) findText.chrgText.cpMax);
            SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT),
                        EM_SETCHARFORMAT,
                        SCF_SELECTION,
                        (LPARAM) &chFormat);
            free((void *)findText.lpstrText);

            SendMessageA(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT),
                        EM_SETSEL,
                        -1,
                        0);
        }
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT));

        return TRUE;

    case WM_MY_REINITIALIZE:
            pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

            hWndGoodForEdit = GetDlgItem(hwndDlg, IDC_GOODFOR_EDIT);

            ShowWindow(hWndGoodForEdit, SW_HIDE);

            //
            // re-add the usages
            //
            AddUsagesToEditBox(
                hWndGoodForEdit,
                pviewhelp);

            //
            // resize the edit controls so that they are an integral number of lines
            //
            ResizeEditControl(hwndDlg, hWndGoodForEdit, TRUE, FALSE, pviewhelp->goodForOriginalRect);

            //
            // if there are no valid usages or we couldn't validate because there wasn't
            // enough information, then keep the usage edit windows hidden so we can
            // display more text,
            //
            if (pviewhelp->pwszErrorString == NULL)
            {
                EnableWindow(hWndGoodForEdit, TRUE);
                ShowWindow(hWndGoodForEdit, SW_SHOW);
                EnableWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_GOODFOR_HEADER), TRUE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_GOODFOR_HEADER), SW_SHOW);
                if (pviewhelp->fCPSDisplayed)
                {
                    ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT), SW_SHOW);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT), TRUE);
                }
                else
                {
                    EnableWindow(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT), FALSE);
                    ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT), SW_HIDE);
                }
                EnableWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT), FALSE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT), SW_HIDE);
            }
            else
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_GOODFOR_HEADER), FALSE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_GOODFOR_HEADER), SW_HIDE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT), FALSE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_ISSUER_WARNING_EDIT), SW_HIDE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT), TRUE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT), SW_SHOW);
            }

            //
            // if there is an untrusted root error, and we are ignoring untrusted root,
            // then set the error to 0
            //
            if (((pviewhelp->dwChainError == CERT_E_UNTRUSTEDROOT) || (pviewhelp->dwChainError == CERT_E_UNTRUSTEDTESTROOT)) &&
                (pviewhelp->fIgnoreUntrustedRoot))
            {
                pviewhelp->pCCertBmp->SetChainError(0, TRUE, (pviewhelp->dwChainError == 0) && (pviewhelp->cUsages == NULL));
            }
            else
            {
                pviewhelp->pCCertBmp->SetChainError(pviewhelp->dwChainError,  IsTrueErrorString(pviewhelp),
                                                    (pviewhelp->dwChainError == 0) && (pviewhelp->cUsages == NULL));
            }
            CryptUISetRicheditTextW(hwndDlg, IDC_CERT_GENERAL_ERROR_EDIT, pviewhelp->pwszErrorString);

            return TRUE;

    case WM_NOTIFY:
        pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        switch (((NMHDR FAR *) lParam)->code) {
        case EN_LINK:
            penlink = (ENLINK *) lParam;
            if (penlink->msg == WM_LBUTTONUP) {
                break;
            }
            break;

        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:

            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case PSN_HELP:
            pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //nHelpA(hwndDlg, (LPSTR) pviewhelp->pcvp->szHelpFileName,
                  //     HELP_CONTEXT, pviewhelp->pcvp->dwHelpId);
            }
            else {
                //nHelpW(hwndDlg, pviewhelp->pcvp->szHelpFileName, HELP_CONTEXT,
                  //     pviewhelp->pcvp->dwHelpId);
            }
            return TRUE;

        case LVN_ITEMCHANGING:

            pnmv = (LPNMLISTVIEW) lParam;

            if (pnmv->uNewState & LVIS_SELECTED)
            {
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            }

            return TRUE;

        case NM_DBLCLK:

            return TRUE;

        }
        break;

    case WM_COMMAND:
        pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        switch (LOWORD(wParam))
        {

        case IDHELP:
            pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95)
            {
                //nHelpA(hwndDlg, (LPSTR) pviewhelp->pcvp->szHelpFileName,
                  //     HELP_CONTEXT, pviewhelp->pcvp->dwHelpId);
            }
            else
            {
                //nHelpW(hwndDlg, pviewhelp->pcvp->szHelpFileName, HELP_CONTEXT,
                  //     pviewhelp->pcvp->dwHelpId);
            }
            return TRUE;

        case IDC_ACCEPT_BUTTON:
            pviewhelp->fAccept = TRUE;
            SendMessage(GetParent(hwndDlg), PSM_PRESSBUTTON, PSBTN_OK, (LPARAM) 0);
            break;

        case IDC_DECLINE_BUTTON:
            pviewhelp->fAccept = FALSE;
            SendMessage(GetParent(hwndDlg), PSM_PRESSBUTTON, PSBTN_OK, (LPARAM) 0);
            break;

        case IDC_DISCLAIMER_BUTTON:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                pccert = pviewhelp->pcvp->pCertContext;
                DisplayCPS(hwndDlg, pccert, pviewhelp->dwChainError, pviewhelp->fNoCOM);
                return TRUE;
            }
            break;

        case IDC_ADD_TO_STORE_BUTTON:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                CRYPTUI_WIZ_IMPORT_SRC_INFO importInfo;

                memset(&importInfo, 0, sizeof(importInfo));
                importInfo.dwSize = sizeof(importInfo);
                importInfo.dwSubjectChoice = CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT;
                importInfo.pCertContext = pviewhelp->pcvp->pCertContext;

                CryptUIWizImport(0, hwndDlg, NULL, &importInfo, NULL);
                return TRUE;
            }
            break;
        }
        break;

    case WM_DESTROY:
        pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        //
        // if DWL_USER is NULL then we weren't initialized, so don't cleanup
        //
        if (pviewhelp == NULL)
        {
            return FALSE;
        }

        pccert = pviewhelp->pcvp->pCertContext;

        SetWindowLongPtr(
                GetDlgItem(hwndDlg, IDC_GOODFOR_EDIT),
                GWLP_WNDPROC,
                GetWindowLongPtr(GetDlgItem(hwndDlg, IDC_GOODFOR_EDIT), GWLP_USERDATA));

        //
        // cleanup the private key edit box subclass
        //
        if (CertificateHasPrivateKey(pccert))
        {
            if (plsd = (PLINK_SUBCLASS_DATA) GetWindowLongPtr(GetDlgItem(hwndDlg, IDC_CERT_PRIVATE_KEY_EDIT), GWLP_USERDATA))
            {
                SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_CERT_PRIVATE_KEY_EDIT), GWLP_WNDPROC, (LONG_PTR)plsd->wpPrev);
                free(plsd->pszURL);
                free(plsd);
            }
        }

        //
        // use this call to AllocAndGetIssuerURL to see if the issuer has an active link, and then
        // do the proper unsubclass and/or free
        //
        if (pviewhelp->fIssuerDisplayedAsLink)
        {
            if (plsd = (PLINK_SUBCLASS_DATA) GetWindowLongPtr(GetDlgItem(hwndDlg, IDC_ISSUER_EDIT), GWLP_USERDATA))
            {
                SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_ISSUER_EDIT), GWLP_WNDPROC, (LONG_PTR)plsd->wpPrev);
                free(plsd->pszURL);
                free(plsd);
            }
        }
        else
        {
            SetWindowLongPtr(
                GetDlgItem(hwndDlg, IDC_ISSUER_EDIT),
                GWLP_WNDPROC,
                GetWindowLongPtr(GetDlgItem(hwndDlg, IDC_ISSUER_EDIT), GWLP_USERDATA));
        }

        //
        // use this call to AllocAndGetSubjectURL to see if the subject has an active link, and then
        // do the proper unsubclass and/or free
        //
        if (pviewhelp->fSubjectDisplayedAsLink)
        {
            if (plsd = (PLINK_SUBCLASS_DATA) GetWindowLongPtr(GetDlgItem(hwndDlg, IDC_SUBJECT_EDIT), GWLP_USERDATA))
            {
                SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_SUBJECT_EDIT), GWLP_WNDPROC, (LONG_PTR)plsd->wpPrev);
                free(plsd->pszURL);
                free(plsd);
            }
        }
        else
        {
            SetWindowLongPtr(
                GetDlgItem(hwndDlg, IDC_SUBJECT_EDIT),
                GWLP_WNDPROC,
                GetWindowLongPtr(GetDlgItem(hwndDlg, IDC_SUBJECT_EDIT), GWLP_USERDATA));
        }

        /*DeleteObject((HGDIOBJ)SendMessage(GetDlgItem(hwndDlg, IDC_INFO_BUTTON),
                                    BM_GETIMAGE,
                                    (WPARAM) IMAGE_ICON,
                                    (LPARAM) 0));*/

        return FALSE;

    case WM_HELP:
    case WM_CONTEXTMENU:
        lpHelpInfo = (LPHELPINFO)lParam;
        
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, lpHelpInfo->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_SUBJECT_EDIT))                     &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ISSUEDTO_HEADER))     &&
            (hwnd != GetDlgItem(hwndDlg, IDC_ISSUER_EDIT))                      &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CERT_GENERAL_ISSUEDBY_HEADER))     &&
            (hwnd != GetDlgItem(hwndDlg, IDC_ADD_TO_STORE_BUTTON))              &&
            (hwnd != GetDlgItem(hwndDlg, IDC_DISCLAIMER_BUTTON))                &&
            (hwnd != GetDlgItem(hwndDlg, IDC_ACCEPT_BUTTON))                    &&
            (hwnd != GetDlgItem(hwndDlg, IDC_DECLINE_BUTTON))                   &&
            (hwnd != GetDlgItem(hwndDlg, IDC_GOODFOR_EDIT))                     &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CERT_GENERAL_GOODFOR_HEADER))      &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CERT_PRIVATE_KEY_EDIT))            &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CERT_GENERAL_VALID_EDIT)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, (WPARAM) hwnd, lParam, helpmap);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\ctlgen.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctlgen.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP CTLHelpmap[] = {
    {IDC_CTL_GENERAL_ITEM_LIST,     IDH_CTLVIEW_GENERAL_ITEM_LIST},
    {IDC_CTL_GENERAL_DETAIL_EDIT,   IDH_CTLVIEW_GENERAL_ITEM_EDIT},
    {IDC_CTL_GENERAL_VIEW_BUTTON,   IDH_CTLVIEW_GENERAL_VIEWSIGNATURE_BUTTON}
};

static const HELPMAP CatHelpmap[] = {
    {IDC_CTL_GENERAL_ITEM_LIST,     IDH_CATALOGVIEW_GENERAL_ITEM_LIST},
    {IDC_CTL_GENERAL_DETAIL_EDIT,   IDH_CATALOGVIEW_GENERAL_ITEM_EDIT},
    {IDC_CTL_GENERAL_VIEW_BUTTON,   IDH_CATALOGVIEW_GENERAL_VIEWSIGNATURE_BUTTON}
};

const WCHAR     RgwchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

#define SELPALMODE  TRUE

//////////////////////////////////////////////////////////////////////////////////////
// This function will take a HWND for a list view and a certinfo struct and display
// all the V1 fields of the cert in the list view
//////////////////////////////////////////////////////////////////////////////////////
static void DisplayV1Fields(HWND hWndListView, PCTL_INFO pCtlInfo, DWORD *index)
{
    LPWSTR      pwszText;
    WCHAR       szFieldText[_MAX_PATH];  // used for calls to LoadString only
    LV_ITEMW    lvI;
    DWORD       i;
    int         sequenceNumIndex;
    FILETIME    tempFileTime;
    char        szVersion[32];
	DWORD		dwNumSpaces;
	DWORD		dwNumCharsInserted;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szFieldText;
    lvI.iSubItem = 0;
    lvI.iImage = IMAGE_V1;
    lvI.lParam = (LPARAM)NULL;

    //
    // version
    //
    lvI.iItem = (*index)++;
    LoadStringU(HinstDll, IDS_ADV_VERSION, szFieldText, ARRAYSIZE(szFieldText));
    lvI.cchTextMax = wcslen(szFieldText);
    wsprintfA(szVersion, "V%d", pCtlInfo->dwVersion+1);
    if (NULL != (pwszText = CertUIMkWStr(szVersion)))
    {
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    // Subject Usage
    //
    lvI.iItem = (*index)++;
    LoadStringU(HinstDll, IDS_ADV_SUBJECTUSAGE, szFieldText, ARRAYSIZE(szFieldText));
    lvI.cchTextMax = wcslen(szFieldText);
    if (NULL != (pwszText = FormatCTLSubjectUsage(&(pCtlInfo->SubjectUsage), TRUE)))
    {
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        if (NULL != (pwszText = FormatCTLSubjectUsage(&(pCtlInfo->SubjectUsage), FALSE)))
        {
            ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
            free(pwszText);
        }
    }

    //
    // list identifier
    //
    if (pCtlInfo->ListIdentifier.cbData != 0)
    {
        if(FormatMemBufToString(&pwszText, pCtlInfo->ListIdentifier.pbData, pCtlInfo->ListIdentifier.cbData))
        {
            lvI.iItem = (*index)++;
            LoadStringU(HinstDll, IDS_ADV_LISTIDENTIFIER, szFieldText, ARRAYSIZE(szFieldText));
            lvI.cchTextMax = wcslen(szFieldText);
            lvI.lParam = (LPARAM) MakeListDisplayHelper(TRUE, pwszText, NULL, 0);
            ListView_InsertItemU(hWndListView, &lvI);
            ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
        }
    }

    //
    // sequence number
    //
    if (pCtlInfo->SequenceNumber.cbData != 0)
    {
        dwNumSpaces = (pCtlInfo->SequenceNumber.cbData * 2) / 4;
		pwszText = (LPWSTR) malloc(((pCtlInfo->SequenceNumber.cbData * 2) + dwNumSpaces + 1) * sizeof(WCHAR));
        if (pwszText != NULL)
        {
            lvI.iItem = (*index)++;
            LoadStringU(HinstDll, IDS_ADV_SEQUENCENUMBER, szFieldText, ARRAYSIZE(szFieldText));
            lvI.cchTextMax = wcslen(szFieldText);

            sequenceNumIndex = pCtlInfo->SequenceNumber.cbData - 1;
            i = 0;
			dwNumCharsInserted = 0;
            while (sequenceNumIndex >= 0)
            {
                //
				// insert a space if needed
				//
				if (dwNumCharsInserted == 4)
				{
					pwszText[i++] = L' ';
					dwNumCharsInserted = 0;
				}

				pwszText[i++] = RgwchHex[(pCtlInfo->SequenceNumber.pbData[sequenceNumIndex] & 0xf0) >> 4];
                pwszText[i++] = RgwchHex[pCtlInfo->SequenceNumber.pbData[sequenceNumIndex] & 0x0f];
                sequenceNumIndex--;
				dwNumCharsInserted += 2;
            }
            pwszText[i] = 0;
            lvI.lParam = (LPARAM) MakeListDisplayHelper(TRUE, pwszText, NULL, 0);
            ListView_InsertItemU(hWndListView, &lvI);
            ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
        }
    }

    //
    // Effective Data
    //
    if (FormatDateString(&pwszText, pCtlInfo->ThisUpdate, TRUE, TRUE, hWndListView))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ADV_THISUPDATE, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    // Next Update
    //
    memset(&tempFileTime, 0, sizeof(FILETIME));
    if (memcmp(&tempFileTime, &(pCtlInfo->NextUpdate), sizeof(FILETIME)) != 0)
    {
        if (FormatDateString(&pwszText, pCtlInfo->NextUpdate, TRUE, TRUE, hWndListView))
        {
            lvI.iItem = (*index)++;
            LoadStringU(HinstDll, IDS_ADV_NEXTUPDATE, szFieldText, ARRAYSIZE(szFieldText));
            lvI.cchTextMax = wcslen(szFieldText);
            lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
            ListView_InsertItemU(hWndListView, &lvI);
            ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
        }
    }

    //
    // subject algorithm
    //
    if (FormatAlgorithmString(&pwszText, &(pCtlInfo->SubjectAlgorithm)))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ADV_SUBJECTALGORITHM, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
// This function will take a HWND for a list view and a pointer to a cert contexxt and
// display all the properties tagged to the cert in the list view
//////////////////////////////////////////////////////////////////////////////////////
static void DisplayProperties(HWND hWndListView, PCCTL_CONTEXT pctl, DWORD *index)
{
    DWORD               i;
    WCHAR               szFieldText[_MAX_PATH];  // used for calls to LoadString only
    LPWSTR              pwszText;
    LV_ITEMW            lvI;
    BYTE                hash[20];
    DWORD               hashSize = ARRAYSIZE(hash);
    DWORD               cbText;
    PCCRYPT_OID_INFO    pThumbprintAlgorithm;
    DWORD               dwAlgID = CALG_SHA1;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szFieldText;
    lvI.iSubItem = 0;
    lvI.iImage = IMAGE_PROPERTY;

    //
    // thumbprint algorithm
    //
    if (NULL != (pThumbprintAlgorithm = CryptFindOIDInfo(
                                            CRYPT_OID_INFO_ALGID_KEY,
                                            &dwAlgID,
                                            CRYPT_HASH_ALG_OID_GROUP_ID)) &&
        (NULL != (pwszText = AllocAndCopyWStr(pThumbprintAlgorithm->pwszName))))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_THUMBPRINT_ALGORITHM, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    // thumbprint
    //
    CertGetCTLContextProperty(
            pctl,
            CERT_SHA1_HASH_PROP_ID,
            hash,
            &hashSize);
    if (FormatMemBufToString(&pwszText, hash, ARRAYSIZE(hash)))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_THUMBPRINT, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(TRUE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    //  friendly name
    //
    cbText = 0;
    if (CertGetCTLContextProperty(  pctl,
                                    CERT_FRIENDLY_NAME_PROP_ID,
                                    NULL,
                                    &cbText)                    &&
       (NULL != (pwszText = (LPWSTR) malloc(cbText))))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_CTL_NAME, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        CertGetCTLContextProperty(  pctl,
                                    CERT_FRIENDLY_NAME_PROP_ID,
                                    pwszText,
                                    &cbText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    //  description
    //
    cbText = 0;
    if (CertGetCTLContextProperty(  pctl,
                                    CERT_DESCRIPTION_PROP_ID,
                                    NULL,
                                    &cbText)                    &&
       (NULL != (pwszText = (LPWSTR) malloc(cbText))))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_DESCRIPTION, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        CertGetCTLContextProperty(  pctl,
                                    CERT_DESCRIPTION_PROP_ID,
                                    pwszText,
                                    &cbText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void GetSignerInfo(CTL_VIEW_HELPER *pviewhelp)
{
    HCRYPTMSG           hMsg;
    DWORD               cbEncodedSigner = 0;
    BYTE                *pbEncodedSigner = NULL;
    DWORD               cbCertInfo = 0;
    CERT_INFO           *pCertInfo = NULL;
    DWORD               chStores = 0;
    HCERTSTORE          *rghStores = NULL;
    CRYPT_PROVIDER_SGNR *pProvSigner = NULL;
    CRYPT_PROVIDER_CERT *pProvCert = NULL;

    
    if (!(pviewhelp->hMsg = CryptMsgOpenToDecode(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                      0,
                                      0,
                                      0,
                                      NULL,
                                      NULL)))
    {
        return;
    }

    if (!CryptMsgUpdate(pviewhelp->hMsg,
                        pviewhelp->pcvctl->pCTLContext->pbCtlEncoded,
                        pviewhelp->pcvctl->pCTLContext->cbCtlEncoded,
                        TRUE))                    // fFinal
    {
        CryptMsgClose(pviewhelp->hMsg);
        pviewhelp->hMsg = NULL;
        return;
    }

    //
    // get the encoded signer BLOB
    //
    CryptMsgGetParam(pviewhelp->hMsg,
                     CMSG_ENCODED_SIGNER,
                     0,
                     NULL,
                     &cbEncodedSigner);

    if (cbEncodedSigner == 0)
    {
        pviewhelp->fNoSignature = TRUE;
        return;
    }

    if (NULL == (pbEncodedSigner = (PBYTE) malloc(cbEncodedSigner)))
    {
        return;
    }

    if (!CryptMsgGetParam(pviewhelp->hMsg,
                          CMSG_ENCODED_SIGNER,
                          0,
                          pbEncodedSigner,
                          &cbEncodedSigner))
    {
        free(pbEncodedSigner);
        return;
    }

    pviewhelp->fNoSignature = FALSE;

    //
    // decode the EncodedSigner info
    //
    pviewhelp->cbSignerInfo = 0;
    if(!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
					    PKCS7_SIGNER_INFO,
					    pbEncodedSigner,
					    cbEncodedSigner,
					    0,
					    NULL,
					    &pviewhelp->cbSignerInfo))
    {
        free(pbEncodedSigner);
        return;
    }
	

    if (NULL == (pviewhelp->pbSignerInfo = (PCMSG_SIGNER_INFO) malloc(pviewhelp->cbSignerInfo)))
    {
        free(pbEncodedSigner);
        return;
    }

    if (!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
					    PKCS7_SIGNER_INFO,
					    pbEncodedSigner,
					    cbEncodedSigner,
					    0,
					    pviewhelp->pbSignerInfo,
					    &pviewhelp->cbSignerInfo))
    {
        free(pbEncodedSigner);
        free(pviewhelp->pbSignerInfo);
        pviewhelp->pbSignerInfo = NULL;
        return;
    }

    free(pbEncodedSigner);

    //
    // get the signers cert
    //
    pviewhelp->pSignerCert = GetSignersCert(
                                pviewhelp->pbSignerInfo,
                                pviewhelp->hExtraStore,
                                pviewhelp->pcvctl->cStores,
                                pviewhelp->pcvctl->rghStores);

}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL VerifyCounterSignature(CTL_VIEW_HELPER *pviewhelp, FILETIME *pft, BOOL *pfCertValid, BOOL *pfCounterSignerCertFound)
{
    CRYPT_ATTRIBUTE     *pAttr = NULL;
    PCMSG_ATTR          pMsgAttr = NULL;
    DWORD               cbMsgAttr = 0;
    HCRYPTMSG           hMsg = NULL;
    BOOL                fRet = TRUE;
    PCMSG_SIGNER_INFO   pbCounterSignerInfo = NULL;
    DWORD               cbCounterSignerInfo = 0;
    BYTE                *pbEncodedSigner = NULL;
    DWORD               cbEncodedSigner = 0;
    CERT_INFO           CertInfo;
    PCCERT_CONTEXT      pCertContext=NULL;

    *pfCounterSignerCertFound = FALSE;
    *pfCertValid = FALSE;

    //
    // get the unauthenticated attributes because that is where the counter signer is
    //
    CryptMsgGetParam(pviewhelp->hMsg,
                     CMSG_SIGNER_UNAUTH_ATTR_PARAM,
                     0,
                     NULL,
                     &cbMsgAttr);

    if (cbMsgAttr == 0)
    {
        return TRUE;
    }

    if (NULL == (pMsgAttr = (CMSG_ATTR *) malloc(cbMsgAttr)))
    {
        goto ErrorCleanup;
    }

    if (!CryptMsgGetParam(pviewhelp->hMsg,
                          CMSG_SIGNER_UNAUTH_ATTR_PARAM,
                          0,
                          (void *) pMsgAttr,
                          &cbMsgAttr))
    {
        goto ErrorCleanup;
    }

    //
    // search for the counter signer in the unauthenticated attributes
    //
    if ((pAttr = CertFindAttribute(szOID_RSA_counterSign,
                                   pMsgAttr->cAttr,
                                   pMsgAttr->rgAttr)) == NULL)
    {
        //
        //  no counter signature
        //
        goto Cleanup;
    }

    //
    // decode the encoded counter signer info
    //
    if(!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
					    PKCS7_SIGNER_INFO,
					    pAttr->rgValue[0].pbData,
					    pAttr->rgValue[0].cbData,
					    0,
					    NULL,
					    &cbCounterSignerInfo))
    {
        goto ErrorCleanup;
    }
	

    if (NULL == (pbCounterSignerInfo = (PCMSG_SIGNER_INFO) malloc(cbCounterSignerInfo)))
    {
        goto ErrorCleanup;
    }

    if (!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
					    PKCS7_SIGNER_INFO,
					    pAttr->rgValue[0].pbData,
					    pAttr->rgValue[0].cbData,
					    0,
					    pbCounterSignerInfo,
					    &cbCounterSignerInfo))
    {
        goto ErrorCleanup;
    }

    pCertContext = GetSignersCert(
                        pbCounterSignerInfo,
                        pviewhelp->hExtraStore,
                        pviewhelp->pcvctl->cStores,
                        pviewhelp->pcvctl->rghStores);

    //
    // if the cert was not found, then set the boolean and return FALSE
    // for verifying the signature
    //
    if (pCertContext == NULL)
    {
        *pfCounterSignerCertFound = FALSE;
        goto ErrorCleanup;
    }
    else
    {
        *pfCounterSignerCertFound = TRUE;
    }

    //
    // validate the cert for usage
    //
    *pfCertValid = ValidateCertForUsage(
                        pCertContext,
                        pft,
                        pviewhelp->pcvctl->cStores,
                        pviewhelp->pcvctl->rghStores,
                        pviewhelp->hExtraStore,
                        szOID_PKIX_KP_TIMESTAMP_SIGNING); // currently the only type of counter signing permitted

    if (!(*pfCertValid))
    {
        goto ErrorCleanup;
    }

    //
    // get the encoded signer BLOB
    //
    CryptMsgGetParam(pviewhelp->hMsg,
                     CMSG_ENCODED_SIGNER,
                     0,
                     NULL,
                     &cbEncodedSigner);

    if (cbEncodedSigner == 0)
    {
        goto ErrorCleanup;
    }

    if (NULL == (pbEncodedSigner = (PBYTE) malloc(cbEncodedSigner)))
    {
        goto ErrorCleanup;
    }

    if (!CryptMsgGetParam(pviewhelp->hMsg,
                          CMSG_ENCODED_SIGNER,
                          0,
                          pbEncodedSigner,
                          &cbEncodedSigner))
    {
        goto ErrorCleanup;
    }

    //
    // verify the counter signature
    //
    fRet = CryptMsgVerifyCountersignatureEncoded(
                            NULL,   //HCRYPTPROV
                            PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING,
                            pbEncodedSigner,
                            cbEncodedSigner,
                            pAttr->rgValue[0].pbData,
                            pAttr->rgValue[0].cbData,
                            pCertContext->pCertInfo
                            );

Cleanup:
    if (pMsgAttr)
        free(pMsgAttr);

    if (pbCounterSignerInfo)
        free(pbCounterSignerInfo);

    if (pbEncodedSigner)
        free(pbEncodedSigner);

    if (pCertContext)
        CertFreeCertificateContext(pCertContext);

    return fRet;

ErrorCleanup:
    fRet = FALSE;
    goto Cleanup;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageCTLGeneral(HWND hwndDlg, UINT msg, WPARAM wParam,
                                LPARAM lParam)
{
    DWORD               i;
    PROPSHEETPAGE       *ps;
    PCCTL_CONTEXT       pctl;
    CTL_VIEW_HELPER     *pviewhelp;
    HIMAGELIST          hIml;
    HWND                hWndListView;
    HWND                hwnd;
    LV_COLUMNW          lvC;
    WCHAR               szText[CRYPTUI_MAX_STRING_SIZE];
    PCTL_INFO           pCtlInfo;
    LVITEMW             lvI;
    LPNMLISTVIEW        pnmv;
    CHARFORMAT          chFormat;
    FILETIME            *pft;
    BOOL                fCatFile;
    BOOL                fCounterSignerCertFound;
    BOOL                fCertValid;

#ifdef CMS_PKCS7
    CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA CtrlPara;
#endif  // CMS_PKCS7


    switch ( msg ) {
    case WM_INITDIALOG:
        //
        // save the pviewhelp struct in DWL_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (CTL_VIEW_HELPER *) (ps->lParam);
        pctl = pviewhelp->pcvctl->pCTLContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);

        //
        // clear the text in the detail edit box
        //
        CryptUISetRicheditTextW(hwndDlg, IDC_CTL_GENERAL_DETAIL_EDIT, L"");

        //
        // check to see if this is a CAT file or CTL file
        //
        pviewhelp->fCatFile = fCatFile = fIsCatalogFile(&(pctl->pCtlInfo->SubjectUsage));

        //
        // Get the CTL signer info
        //
        pviewhelp->hMsg = NULL;
        GetSignerInfo(pviewhelp);

        //
        // enable/disable the "View CTL Signature" button based on whether the signing
        // cert was passed in or not
        //
        EnableWindow(GetDlgItem(hwndDlg, IDC_CTL_GENERAL_VIEW_BUTTON),
                     (pviewhelp->pbSignerInfo != NULL));

        //
        // if there is a signer info, then get the sign time
        //
        if (pviewhelp->pbSignerInfo != NULL)
        {
            AllocAndReturnTimeStampersTimes(pviewhelp->pbSignerInfo, &pft);
        }

#ifdef CMS_PKCS7

        memset(&CtrlPara, 0, sizeof(CtrlPara));
        CtrlPara.cbSize = sizeof(CtrlPara);
        // CtrlPara.hCryptProv =

        // Assume the CTL only has 1 signer
        CtrlPara.dwSignerIndex = 0;
        CtrlPara.dwSignerType = CMSG_VERIFY_SIGNER_CERT;
        CtrlPara.pvSigner = (void *) pviewhelp->pSignerCert;
#endif  // CMS_PKCS7

        //
        // set the valid/invalid bitmap and the validity text based on whether the signature of
        // CTL verifies or not
        //
        if (pviewhelp->fNoSignature == TRUE)
        {
            if (fCatFile)
            {
                LoadStringU(HinstDll, IDS_CAT_NO_SIGNATURE, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_EXCLAMATION_CATLIST));
            }
            else
            {
                LoadStringU(HinstDll, IDS_CTL_NO_SIGNATURE, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_EXCLAMATION_TRUSTLIST));
            }
            pviewhelp->dwInheritableError = CRYPT_E_NO_SIGNER;
        }
        else if (pviewhelp->pSignerCert == NULL)
        {
            if (fCatFile)
            {
                LoadStringU(HinstDll, IDS_CAT_UNAVAILABLE_CERT, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_EXCLAMATION_CATLIST));
            }
            else
            {
                LoadStringU(HinstDll, IDS_CTL_UNAVAILABLE_CERT, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_EXCLAMATION_TRUSTLIST));
            }
            pviewhelp->dwInheritableError = TRUST_E_NO_SIGNER_CERT;
        }
        else if (!ValidateCertForUsage(
                        pviewhelp->pSignerCert,
                        pft,
                        pviewhelp->pcvctl->cStores,
                        pviewhelp->pcvctl->rghStores,
                        pviewhelp->hExtraStore,
                        fCatFile ? szOID_PKIX_KP_CODE_SIGNING : szOID_KP_CTL_USAGE_SIGNING))
        {
            if (fCatFile)
            {
                LoadStringU(HinstDll, IDS_CAT_INVALID_CERT, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_CATLIST));
            }
            else
            {
                LoadStringU(HinstDll, IDS_CTL_INVALID_CERT, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_TRUSTLIST));
            }
        }
#ifdef CMS_PKCS7
        // NOTE!!! the above ValidateCertForUsage() calls WinVerifyTrust().
        // As a result, for a DSS signer it would have inherited its public key
        // algorithm parameters.
        //
        // NOTE!!! also assumes dwSignerIndex == 0.
        else if (!CryptMsgControl(
                     pviewhelp->pcvctl->pCTLContext->hCryptMsg,
                     0,                                     // dwFlags
                     CMSG_CTRL_VERIFY_SIGNATURE_EX,
                     &CtrlPara
                     ))
#else
        else if (!CryptMsgControl(
                     pviewhelp->pcvctl->pCTLContext->hCryptMsg,
                     0,
                     CMSG_CTRL_VERIFY_SIGNATURE,
                     pviewhelp->pSignerCert->pCertInfo
                     ))
#endif  // CMS_PKCS7
        {
            if (fCatFile)
            {
                LoadStringU(HinstDll, IDS_CAT_INVALID_SIGNATURE, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_CATLIST));
            }
            else
            {
                LoadStringU(HinstDll, IDS_CTL_INVALID_SIGNATURE, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_TRUSTLIST));
            }
            pviewhelp->dwInheritableError = TRUST_E_BAD_DIGEST;
        }
        else if (!VerifyCounterSignature(pviewhelp, pft, &fCertValid, &fCounterSignerCertFound))
        {
            if (fCatFile)
            {
                if (!fCounterSignerCertFound)
                {
                    LoadStringU(HinstDll, IDS_CAT_COUNTER_SIGNER_CERT_UNAVAILABLE, (LPWSTR)szText, ARRAYSIZE(szText));
                    pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_EXCLAMATION_CATLIST));
                }
                else if (!fCertValid)
                {
                    LoadStringU(HinstDll, IDS_CAT_INVALID_COUNTER_SIGNER_CERT, (LPWSTR)szText, ARRAYSIZE(szText));
                    pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_CATLIST));
                }
                else
                {
                    LoadStringU(HinstDll, IDS_CAT_INVALID_COUNTER_SIGNATURE, (LPWSTR)szText, ARRAYSIZE(szText));
                    pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_CATLIST));
                }
            }
            else
            {
                if (!fCounterSignerCertFound)
                {
                    LoadStringU(HinstDll, IDS_CTL_COUNTER_SIGNER_CERT_UNAVAILABLE, (LPWSTR)szText, ARRAYSIZE(szText));
                    pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_EXCLAMATION_TRUSTLIST));
                }
                else if (!fCertValid)
                {
                    LoadStringU(HinstDll, IDS_CTL_INVALID_COUNTER_SIGNER_CERT, (LPWSTR)szText, ARRAYSIZE(szText));
                    pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_TRUSTLIST));
                }
                else
                {
                    LoadStringU(HinstDll, IDS_CTL_INVALID_COUNTER_SIGNATURE, (LPWSTR)szText, ARRAYSIZE(szText));
                    pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_TRUSTLIST));
                }
            }
            pviewhelp->dwInheritableError = TRUST_E_COUNTER_SIGNER;
        }
        else
        {
            if (fCatFile)
            {
                LoadStringU(HinstDll, IDS_CAT_VALID, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_CATLIST));
            }
            else
            {
                LoadStringU(HinstDll, IDS_CTL_VALID, (LPWSTR)szText, ARRAYSIZE(szText));
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_TRUSTLIST));
            }
        }
        CryptUISetRicheditTextW(hwndDlg, IDC_CTL_GENERAL_VALIDITY_EDIT, szText);

        if (pviewhelp->pbSignerInfo != NULL)
        {
            free(pft);
        }

        //
        // set the header text and subclass the edit controls so they display an
        // arrow cursor in their window
        //
        if (fCatFile)
        {
            LoadStringU(HinstDll, IDS_CAT_INFORMATION, (LPWSTR)szText, ARRAYSIZE(szText));
        }
        else
        {
            LoadStringU(HinstDll, IDS_CTL_INFORMATION, (LPWSTR)szText, ARRAYSIZE(szText));
        }
        CryptUISetRicheditTextW(hwndDlg, IDC_CTL_GENERAL_HEADER_EDIT, szText);
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CTL_GENERAL_VALIDITY_EDIT));
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_CTL_GENERAL_HEADER_EDIT));

        //
        // set the font for the CTL header information
        //
        memset(&chFormat, 0, sizeof(chFormat));
        chFormat.cbSize = sizeof(chFormat);
        chFormat.dwMask = CFM_BOLD;
        chFormat.dwEffects = CFE_BOLD;
        SendMessageA(GetDlgItem(hwndDlg, IDC_CTL_GENERAL_HEADER_EDIT), EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);

        //
        // get the handle of the list view control
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_CTL_GENERAL_ITEM_LIST);

        //
        // initialize the image list for the list view, load the icons,
        // then add the image list to the list view
        //
        hIml = ImageList_LoadImage(HinstDll, MAKEINTRESOURCE(IDB_PROPLIST), 0, 4, RGB(0,128,128), IMAGE_BITMAP, 0);
        ListView_SetImageList(hWndListView, hIml, LVSIL_SMALL);

        //
        // initialize the columns in the list view
        //
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.pszText = szText;   // The text for the column.

        // Add the columns. They are loaded from a string table.
        lvC.iSubItem = 0;
        lvC.cx = 130;
        LoadStringU(HinstDll, IDS_FIELD, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(hWndListView, 0, &lvC) == -1)
        {
            // error
        }

        lvC.cx = 200;
        LoadStringU(HinstDll, IDS_VALUE, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(hWndListView, 1, &lvC) == -1)
        {
            // error
        }


        //
        // add all the certificate fields to the list box
        //
        i = 0;
        DisplayV1Fields(hWndListView, pctl->pCtlInfo, &i);
        DisplayExtensions(hWndListView, pctl->pCtlInfo->cExtension, pctl->pCtlInfo->rgExtension, FALSE, &i);
        DisplayExtensions(hWndListView, pctl->pCtlInfo->cExtension, pctl->pCtlInfo->rgExtension, TRUE, &i);
        DisplayProperties(hWndListView, pctl, &i);

        //
        // set the style in the list view so that it highlights an entire line
        //
        SendMessageA(hWndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

        return TRUE;

    case WM_NOTIFY:

        pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pctl = pviewhelp->pcvctl->pCTLContext;
        pCtlInfo = pctl->pCtlInfo;

        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case PSN_HELP:
            pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvctl->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvctl->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvctl->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvctl->dwHelpId);
            }
            return TRUE;

        case LVN_ITEMCHANGING:
            if ((((NMHDR FAR *) lParam)->idFrom) != IDC_CTL_GENERAL_ITEM_LIST)
            {
                break;
            }

            pnmv = (LPNMLISTVIEW) lParam;

            if (pnmv->uNewState & LVIS_SELECTED)
            {
                DisplayHelperTextInEdit(
                    GetDlgItem(hwndDlg, IDC_CTL_GENERAL_ITEM_LIST),
                    hwndDlg,
                    IDC_CTL_GENERAL_DETAIL_EDIT,
                    pnmv->iItem);
            }

            return TRUE;

        case NM_CLICK:
            if ((((NMHDR FAR *) lParam)->idFrom) != IDC_CTL_GENERAL_ITEM_LIST)
            {
                break;
            }

            DisplayHelperTextInEdit(
                    GetDlgItem(hwndDlg, IDC_CTL_GENERAL_ITEM_LIST),
                    hwndDlg,
                    IDC_CTL_GENERAL_DETAIL_EDIT,
                    -1);

            return TRUE;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_CTL_GENERAL_ITEM_LIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_CTL_GENERAL_ITEM_LIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED;
                    lvI.stateMask = LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;
            }
            
            break;
        }

        break;

    case WM_COMMAND:
        pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pctl = pviewhelp->pcvctl->pCTLContext;
        pCtlInfo = pctl->pCtlInfo;

        switch (LOWORD(wParam))
        {
        case IDC_CTL_GENERAL_VIEW_BUTTON:
            {
                CRYPTUI_VIEWSIGNERINFO_STRUCTW cvsi;

                memset(&cvsi, 0, sizeof(cvsi));
                cvsi.dwSize = sizeof(cvsi);
                cvsi.hwndParent = hwndDlg;
                cvsi.pSignerInfo = pviewhelp->pbSignerInfo;
                cvsi.hMsg = pviewhelp->hMsg;
                cvsi.pszOID = fIsCatalogFile(&(pCtlInfo->SubjectUsage)) ? szOID_PKIX_KP_CODE_SIGNING : szOID_KP_CTL_USAGE_SIGNING;
                cvsi.cStores = 1;
                cvsi.rghStores = &(pviewhelp->hExtraStore);

                if (pviewhelp->dwInheritableError != 0)
                {
                    cvsi.dwReserved = pviewhelp->dwInheritableError;
                    cvsi.dwFlags |= CRYPTUI_VIEWSIGNERINFO_RESERVED_FIELD_IS_ERROR_CODE;
                }

                CryptUIDlgViewSignerInfoW(&cvsi);

            }
            break;
        case IDHELP:
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvctl->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvctl->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvctl->szHelpFileName, HELP_CONTEXT,
                 //        pviewhelp->pcvctl->dwHelpId);
            }
            return TRUE;
        }
        break;

    case WM_PAINT:
        RECT        rect;
        PAINTSTRUCT paintstruct;
        HDC         hdc;
        COLORREF    colorRef;

        pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        if (GetUpdateRect(hwndDlg, &rect, FALSE))
        {
            hdc = BeginPaint(hwndDlg, &paintstruct);
            if (hdc == NULL)
            {
                EndPaint(hwndDlg, &paintstruct);
                break;
            }

            colorRef = GetBkColor(hdc);

            SendMessageA(GetDlgItem(hwndDlg, IDC_CTL_GENERAL_VALIDITY_EDIT), EM_SETBKGNDCOLOR , 0, (LPARAM) colorRef);
            SendMessageA(GetDlgItem(hwndDlg, IDC_CTL_GENERAL_HEADER_EDIT), EM_SETBKGNDCOLOR, 0, (LPARAM) colorRef);

            if (pviewhelp->hIcon != NULL)
            {
                DrawIcon(
                    hdc,
                    ICON_X_POS,
                    ICON_Y_POS,
                    pviewhelp->hIcon);
            }

            EndPaint(hwndDlg, &paintstruct);
        }
        break;

    case WM_DESTROY:
        pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        if (pviewhelp->hIcon != NULL)
        {
            DeleteObject(pviewhelp->hIcon);
            pviewhelp->hIcon = NULL;
        }
        if (pviewhelp->pSignerCert != NULL)
        {
            CertFreeCertificateContext(pviewhelp->pSignerCert);
            pviewhelp->pSignerCert = NULL;
        }
        if (pviewhelp->pbSignerInfo)
        {
            free(pviewhelp->pbSignerInfo);
            pviewhelp->pbSignerInfo = NULL;
        }

        if (pviewhelp->hMsg != NULL)
        {
            CryptMsgClose(pviewhelp->hMsg);
            
        }
        pviewhelp->hMsg = NULL;

        //
        // get all the items in the list view and free the lParam
        // associated with each of them (lParam is the helper sruct)
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_CTL_GENERAL_ITEM_LIST);

        memset(&lvI, 0, sizeof(lvI));
        lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
        lvI.mask = LVIF_PARAM;
        while (lvI.iItem >= 0)
        {
            if (ListView_GetItemU(hWndListView, &lvI))
            {
                FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvI.lParam);
            }
            lvI.iItem--;
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        pviewhelp = (CTL_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_CTL_GENERAL_ITEM_LIST))    &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CTL_GENERAL_DETAIL_EDIT))  &&
            (hwnd != GetDlgItem(hwndDlg, IDC_CTL_GENERAL_VIEW_BUTTON)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            if (pviewhelp->fCatFile)
            {
                return OnContextHelp(hwndDlg, msg, wParam, lParam, CatHelpmap);
            }
            else
            {
                return OnContextHelp(hwndDlg, msg, wParam, lParam, CTLHelpmap);
            }
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\cvdetail.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cvdetail.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_SHOW_DETAILS_COMBO,        IDH_CERTVIEW_DETAILS_SHOW_COMBO},
    {IDC_SAVE_CERTIFICATE_BUTTON,   IDH_CERTVIEW_DETAILS_SAVECERT_BUTTON},
    {IDC_ITEM_LIST,                 IDH_CERTVIEW_DETAILS_ITEM_LIST},
    {IDC_EDIT_PROPERTIES_BUTTON,    IDH_CERTVIEW_GENERAL_EDITPROPERTIES_BUTTON},
    {IDC_DETAIL_EDIT,               IDH_CERTVIEW_DETAILS_ITEM_EDIT}
};


//////////////////////////////////////////////////////////////////////////////////////
// This function will take a HWND for a list view and a certinfo struct and display
// all the V1 fields of the cert in the list view
//////////////////////////////////////////////////////////////////////////////////////
static void DisplayV1Fields(HWND hWndListView, PCERT_INFO pCertInfo, DWORD *index)
{
    LPWSTR      pwszText;
    LPWSTR      pwszPubKey;
    WCHAR       szFieldText[_MAX_PATH];  // used for calls to LoadString only
    WCHAR       szKeySize[32];
    LV_ITEMW    lvI;
    DWORD       dwKeySize;
    char        szVersion[32];
    void        *pTemp;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szFieldText;
    lvI.iSubItem = 0;
    lvI.iImage = IMAGE_V1;
    lvI.lParam = (LPARAM)NULL;

    //
    // version
    //
    lvI.iItem = (*index)++;
    LoadStringU(HinstDll, IDS_ADV_VERSION, szFieldText, ARRAYSIZE(szFieldText));
    lvI.cchTextMax = wcslen(szFieldText);
    wsprintfA(szVersion, "V%d", pCertInfo->dwVersion+1);
    if (NULL != (pwszText = CertUIMkWStr(szVersion)))
    {
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    // serial number
    //
    if (FormatSerialNoString(&pwszText, &(pCertInfo->SerialNumber)))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ADV_SER_NUM, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(TRUE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    // signature algorithm
    //
    if (FormatAlgorithmString(&pwszText, &(pCertInfo->SignatureAlgorithm)))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ADV_SIG_ALG, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    // issuer
    //
    LoadStringU(HinstDll, IDS_ADV_ISSUER, szFieldText, ARRAYSIZE(szFieldText));
    lvI.cchTextMax = wcslen(szFieldText);
    if (FormatDNNameString(&pwszText, pCertInfo->Issuer.pbData, pCertInfo->Issuer.cbData, TRUE))
    {
        lvI.iItem = (*index)++;
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        if (FormatDNNameString(&pwszText, pCertInfo->Issuer.pbData, pCertInfo->Issuer.cbData, FALSE))
        {
            ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
            free(pwszText);
        }
    }

    //
    // not before
    //
    if (FormatDateString(&pwszText, pCertInfo->NotBefore, TRUE, TRUE, hWndListView))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ADV_NOTBEFORE, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }


    //
    // not after
    //
    if (FormatDateString(&pwszText, pCertInfo->NotAfter, TRUE, TRUE, hWndListView))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ADV_NOTAFTER, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }


    //
    // subject
    //
    LoadStringU(HinstDll, IDS_ADV_SUBJECT, szFieldText, ARRAYSIZE(szFieldText));
    lvI.cchTextMax = wcslen(szFieldText);
    if (FormatDNNameString(&pwszText, pCertInfo->Subject.pbData, pCertInfo->Subject.cbData, TRUE))
    {
        lvI.iItem = (*index)++;
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        if (FormatDNNameString(&pwszText, pCertInfo->Subject.pbData, pCertInfo->Subject.cbData, FALSE))
        {
            ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
            free(pwszText);
        }
    }

    //
    // public key
    //
    if (FormatAlgorithmString(&pwszText, &(pCertInfo->SubjectPublicKeyInfo.Algorithm)))
    {
        WCHAR temp[32];

        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ADV_PUBKEY, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);

        dwKeySize = CertGetPublicKeyLength(X509_ASN_ENCODING, &(pCertInfo->SubjectPublicKeyInfo));
        _itow(dwKeySize, szKeySize, 10);
        wcscpy(temp, L" (");
        wcscat(temp, szKeySize);
        wcscat(temp, L" Bits)");
        pTemp = realloc(pwszText, ((wcslen(pwszText) + wcslen(temp) + 1 ) * sizeof(WCHAR)));
        if (pTemp == NULL)
        {
            free(pwszText);
            return;
        }
        pwszText = (LPWSTR) pTemp;
        wcscat(pwszText, temp);

        FormatMemBufToString(
                &pwszPubKey,
                pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData);

        lvI.lParam = (LPARAM) MakeListDisplayHelper(TRUE, pwszPubKey, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
        free(pwszText);
    }
}



//////////////////////////////////////////////////////////////////////////////////////
// This function will take a HWND for a list view and a pointer to a cert contexxt and
// display all the properties tagged to the cert in the list view
//////////////////////////////////////////////////////////////////////////////////////
static void DisplayProperties(HWND hWndListView, PCCERT_CONTEXT pCertContext, DWORD *index)
{
    DWORD               i;
    WCHAR               szFieldText[_MAX_PATH];  // used for calls to LoadString only
    LPWSTR              pwszText;
    LV_ITEMW            lvI;
    BYTE                hash[20];
    DWORD               hashSize = ARRAYSIZE(hash);
    DWORD               cbText;
    CRYPT_KEY_PROV_INFO *pKeyInfo = NULL;
    DWORD               cbKeyInfo = 0;
    HCRYPTPROV          hCryptProv;
    HCRYPTKEY           hCryptKey;
    DWORD               dwTemp;
    PCCRYPT_OID_INFO    pThumbprintAlgorithm;
    DWORD               dwAlgID = CALG_SHA1;


    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szFieldText;
    lvI.iSubItem = 0;
    lvI.iImage = IMAGE_PROPERTY;

    //
    // thumbprint algorithm
    //
    if (NULL != (pThumbprintAlgorithm = CryptFindOIDInfo(
                                            CRYPT_OID_INFO_ALGID_KEY,
                                            &dwAlgID,
                                            CRYPT_HASH_ALG_OID_GROUP_ID)) &&
        (NULL != (pwszText = AllocAndCopyWStr(pThumbprintAlgorithm->pwszName))))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_THUMBPRINT_ALGORITHM, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    // thumbprint
    //
    CertGetCertificateContextProperty(
            pCertContext,
            CERT_SHA1_HASH_PROP_ID,
            hash,
            &hashSize);
    if (FormatMemBufToString(&pwszText, hash, ARRAYSIZE(hash)))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_THUMBPRINT, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(TRUE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    //  friendly name
    //
    cbText = 0;
    if (CertGetCertificateContextProperty(  pCertContext,
                                            CERT_FRIENDLY_NAME_PROP_ID,
                                            NULL,
                                            &cbText)                    &&
       (NULL != (pwszText = (LPWSTR) malloc(cbText))))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_CERTIFICATE_NAME, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        CertGetCertificateContextProperty(  pCertContext,
                                            CERT_FRIENDLY_NAME_PROP_ID,
                                            pwszText,
                                            &cbText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    //  description
    //
    cbText = 0;
    if (CertGetCertificateContextProperty(  pCertContext,
                                            CERT_DESCRIPTION_PROP_ID,
                                            NULL,
                                            &cbText)                    &&
       (NULL != (pwszText = (LPWSTR) malloc(cbText))))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_DESCRIPTION, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        CertGetCertificateContextProperty(  pCertContext,
                                            CERT_DESCRIPTION_PROP_ID,
                                            pwszText,
                                            &cbText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
    }

    //
    //  enhanced key usage
    //
    if (FormatEnhancedKeyUsageString(&pwszText, pCertContext, TRUE, TRUE))
    {
        lvI.iItem = (*index)++;
        LoadStringU(HinstDll, IDS_ENHANCED_KEY_USAGE, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        ListView_InsertItemU(hWndListView, &lvI);
        FormatEnhancedKeyUsageString(&pwszText, pCertContext, TRUE, FALSE);
        ListView_SetItemTextU(hWndListView, (*index)-1 , 1, pwszText);
        free(pwszText);
    }

    //
    //  extended error information
    //
    cbText = 0;
    if (CertGetCertificateContextProperty(  pCertContext,
                                            CERT_EXTENDED_ERROR_INFO_PROP_ID,
                                            NULL,
                                            &cbText)                    &&
       (cbText / sizeof(WCHAR) > 1)                                     &&
       (NULL != (pwszText = (LPWSTR) malloc(cbText * 2))))
    {
        DWORD cchText = cbText / sizeof(WCHAR);

        if (!CertGetCertificateContextProperty(  pCertContext,
                                            CERT_EXTENDED_ERROR_INFO_PROP_ID,
                                            pwszText,
                                            &cbText)                    ||
            (cchText != cbText / sizeof(WCHAR))                         ||
            (pwszText[cchText - 1] != L'\0'))
        {
            free(pwszText);
        }
        else
        {
            // Force an extra L'\n' between lines by converting L'\r' to L'\n'
            //
            // Create a duplicate version of the error information where L'\r'
            // is converted to L' ' and L'\n' is converted to L','.

            LPWSTR pwszSingleLineText = pwszText + cchText;

            for (i = 0; i < cchText; i++)
            {
                if (pwszText[i] == L'\r')
                {
                    pwszText[i] = L'\n';
                    pwszSingleLineText[i] = L' ';
                }
                else if (pwszText[i] == L'\n')
                {
                    if (pwszText[i+1] == L'\0')
                    {
                        pwszSingleLineText[i] = L'\0';
                        break;
                    }
                    else
                    {
                        pwszSingleLineText[i] = L',';
                    }
                }
                else
                {
                    pwszSingleLineText[i] = pwszText[i];
                }
            }

            lvI.iItem = (*index)++;
            LoadStringU(HinstDll, IDS_EXTENDED_ERROR_INFO, szFieldText, ARRAYSIZE(szFieldText));
            lvI.cchTextMax = wcslen(szFieldText);
            lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
            ListView_InsertItemU(hWndListView, &lvI);
            ListView_SetItemTextU(hWndListView, (*index)-1 , 1,
                pwszSingleLineText);
        }
    }

    //
    // private key
    //
    /*if (CertGetCertificateContextProperty(  pCertContext,
                                            CERT_KEY_PROV_INFO_PROP_ID,
                                            NULL,
                                            &cbKeyInfo))
    {
        if (NULL == (pKeyInfo = (CRYPT_KEY_PROV_INFO *) malloc(cbKeyInfo)))
        {
            return;
        }
        if (!CertGetCertificateContextProperty( pCertContext,
                                                CERT_KEY_PROV_INFO_PROP_ID,
                                                pKeyInfo,
                                                &cbKeyInfo))
        {
            return;
        }

        if (CryptAcquireContextU(
                    &hCryptProv,
                    pKeyInfo->pwszContainerName,
                    pKeyInfo->pwszProvName,
                    pKeyInfo->dwProvType,
                    pKeyInfo->dwFlags))
        {
            if (CryptGetUserKey(hCryptProv, pKeyInfo->dwKeySpec, &hCryptKey))
            {

            }
        }

        free(pKeyInfo);
    }*/

}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageDetails(HWND hwndDlg, UINT msg, WPARAM wParam,
                               LPARAM lParam)
{
    DWORD                   i;
    PROPSHEETPAGE           *ps;
    PCCERT_CONTEXT          pccert;
    CERT_VIEW_HELPER        *pviewhelp;
    WCHAR                   rgwch[CRYPTUI_MAX_STRING_SIZE];
    HIMAGELIST              hIml;
    HWND                    hWndListView;
    HWND                    hwnd;
    LV_COLUMNW              lvC;
    WCHAR                   szText[CRYPTUI_MAX_STRING_SIZE];
    LV_ITEMW                lvI;
    LPNMLISTVIEW            pnmv;
    CRYPTUI_WIZ_EXPORT_INFO ExportInfo;
    DWORD                   dwCertAccessProperty;
    DWORD                   cb;
    WCHAR                   errorString[CRYPTUI_MAX_STRING_SIZE];
    WCHAR                   errorTitle[CRYPTUI_MAX_STRING_SIZE];

    switch ( msg ) {
    case WM_INITDIALOG:
        //
        // save the pviewhelp struct in DWL_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (CERT_VIEW_HELPER *) (ps->lParam);
        pccert = pviewhelp->pcvp->pCertContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);
        pviewhelp->hwndDetailPage = hwndDlg;

        //
        // clear the text in the detail edit box
        //
        CryptUISetRicheditTextW(hwndDlg, IDC_DETAIL_EDIT, L"");
        
        //
        // initialize the combo box with it's strings
        //

        LoadStringU(HinstDll, IDS_ALL_FIELDS, szText, ARRAYSIZE(szText));
        SendDlgItemMessageU(hwndDlg, IDC_SHOW_DETAILS_COMBO, CB_INSERTSTRING, 0, (LPARAM) szText);
        LoadStringU(HinstDll, IDS_V1_FIELDS_ONLY, szText, ARRAYSIZE(szText));
        SendDlgItemMessageU(hwndDlg, IDC_SHOW_DETAILS_COMBO, CB_INSERTSTRING, 1, (LPARAM) szText);
        LoadStringU(HinstDll, IDS_EXTENSIONS_ONLY, szText, ARRAYSIZE(szText));
        SendDlgItemMessageU(hwndDlg, IDC_SHOW_DETAILS_COMBO, CB_INSERTSTRING, 2, (LPARAM) szText);
        LoadStringU(HinstDll, IDS_CRITICAL_EXTENSIONS_ONLY, szText, ARRAYSIZE(szText));
        SendDlgItemMessageU(hwndDlg, IDC_SHOW_DETAILS_COMBO, CB_INSERTSTRING, 3, (LPARAM) szText);
        LoadStringU(HinstDll, IDS_PROPERTIES_ONLY, szText, ARRAYSIZE(szText));
        SendDlgItemMessageU(hwndDlg, IDC_SHOW_DETAILS_COMBO, CB_INSERTSTRING, 4, (LPARAM) szText);
        SendDlgItemMessageU(hwndDlg, IDC_SHOW_DETAILS_COMBO, CB_SETCURSEL, 0, (LPARAM) NULL);

        //
        // get the handle of the list view control
        //

        hWndListView = GetDlgItem(hwndDlg, IDC_ITEM_LIST);

        //
        // initialize the image list for the list view, load the icons,
        // then add the image list to the list view
        //
        hIml = ImageList_LoadImage(HinstDll, MAKEINTRESOURCE(IDB_PROPLIST), 0, 4, RGB(0,128,128), IMAGE_BITMAP, 0);
        if (hIml != NULL)
        {
            ListView_SetImageList(hWndListView, hIml, LVSIL_SMALL);
        }

        //
        // initialize the columns in the list view
        //

        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.cx = 171;            // Width of the column, in pixels.
        lvC.pszText = szText;   // The text for the column.

        // Add the columns. They are loaded from a string table.
        for (i = 0; i <= 1; i++)
        {
            lvC.iSubItem = i;
            LoadStringU(HinstDll, IDS_FIELD + i, szText, ARRAYSIZE(szText));

            if (ListView_InsertColumnU(hWndListView, i, &lvC) == -1)
            {
                // error
            }
        }

        //
        // add all the certificate fields to the list box
        //
        i = 0;
        DisplayV1Fields(hWndListView, pccert->pCertInfo, &i);
        DisplayExtensions(hWndListView, pccert->pCertInfo->cExtension, pccert->pCertInfo->rgExtension, FALSE, &i);
        DisplayExtensions(hWndListView, pccert->pCertInfo->cExtension, pccert->pCertInfo->rgExtension, TRUE, &i);
        DisplayProperties(hWndListView, pccert, &i);

        //
        // set the style in the list view so that it highlights an entire line
        //
        SendMessageA(hWndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

        //
        // for the "Edit Properties" button, get the CERT_ACCESS_STATE_PROP_ID
        // and check it
        //
        cb = sizeof(DWORD);
        CertGetCertificateContextProperty(
                pccert,
                CERT_ACCESS_STATE_PROP_ID,
                (void *) &dwCertAccessProperty,
                &cb);

        if (pviewhelp->pcvp->dwFlags & CRYPTUI_ENABLE_EDITPROPERTIES)
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_EDIT_PROPERTIES_BUTTON), TRUE);
        }
        else if (pviewhelp->pcvp->dwFlags & CRYPTUI_DISABLE_EDITPROPERTIES)
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_EDIT_PROPERTIES_BUTTON), FALSE);
        }
        else
        {
            EnableWindow(
                GetDlgItem(hwndDlg, IDC_EDIT_PROPERTIES_BUTTON),
                (dwCertAccessProperty & CERT_ACCESS_STATE_WRITE_PERSIST_FLAG));
        }
        
#if (1) //DSIE: Bug 538804.
        if (pviewhelp->pcvp->dwFlags & CRYPTUI_DISABLE_EXPORT)
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_SAVE_CERTIFICATE_BUTTON), FALSE);
        }
#endif

        return TRUE;

    case WM_MY_REINITIALIZE:

        //
        // send a message to the combo box that selection has chaged, it will then
        // update everything for us
        //
        SendMessage(
                hwndDlg,
                WM_COMMAND,
                (WPARAM) MAKELONG(IDC_SHOW_DETAILS_COMBO, LBN_SELCHANGE),
                (LPARAM) GetDlgItem(hwndDlg, IDC_SHOW_DETAILS_COMBO));

        return TRUE;

    case WM_NOTIFY:

        pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pccert = pviewhelp->pcvp->pCertContext;

        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case PSN_HELP:
            pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvp->szHelpFileName,
                    //     HELP_CONTEXT, pviewhelp->pcvp->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvp->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvp->dwHelpId);
            }
            return TRUE;

        case LVN_ITEMCHANGING:
            if ((((NMHDR FAR *) lParam)->idFrom) != IDC_ITEM_LIST)
            {
                break;
            }

            pnmv = (LPNMLISTVIEW) lParam;

            if (pnmv->uNewState & LVIS_SELECTED)
            {
                DisplayHelperTextInEdit(
                    GetDlgItem(hwndDlg, IDC_ITEM_LIST),
                    hwndDlg,
                    IDC_DETAIL_EDIT,
                    pnmv->iItem);
            }

            return TRUE;

        case NM_CLICK:
            if ((((NMHDR FAR *) lParam)->idFrom) != IDC_ITEM_LIST)
            {
                break;
            }

            DisplayHelperTextInEdit(
                    GetDlgItem(hwndDlg, IDC_ITEM_LIST),
                    hwndDlg,
                    IDC_DETAIL_EDIT,
                    -1);

            return TRUE;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_ITEM_LIST:
                if (NULL == (hWndListView = GetDlgItem(hwndDlg, IDC_ITEM_LIST)))
                    break;

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED | LVIS_SELECTED;
                    lvI.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;
            }
            
            break;
        }

        break;

    case WM_COMMAND:

        pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pccert = pviewhelp->pcvp->pCertContext;

        switch (LOWORD(wParam))
        {
        case IDC_SAVE_CERTIFICATE_BUTTON:

            memset(&ExportInfo, 0, sizeof(ExportInfo));
            ExportInfo.dwSize = sizeof(ExportInfo);
            ExportInfo.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CERT_CONTEXT;
            ExportInfo.pCertContext = pviewhelp->pcvp->pCertContext;
            CryptUIWizExport(0, hwndDlg, NULL, &ExportInfo, NULL);

            break;

        case IDC_EDIT_PROPERTIES_BUTTON:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT csp;
                BOOL                                     fPropertiesChanged;

                memset(&csp, 0, sizeof(csp));
                csp.dwSize = sizeof(csp);
                csp.hwndParent = hwndDlg;
                csp.dwFlags = 0;
                csp.pCertContext = pviewhelp->pcvp->pCertContext;
                csp.cStores = pviewhelp->pcvp->cStores;
                csp.rghStores = pviewhelp->pcvp->rghStores;
                csp.cPropSheetPages = 0;
                csp.rgPropSheetPages = NULL;

                CryptUIDlgViewCertificateProperties(&csp, &fPropertiesChanged);

                //
                // if properties were actually changed, then set the flag
                // to our caller, and refresh our state
                //
                if (fPropertiesChanged)
                {
                    //
                    // if the WinVerifyTrust state was passed in, then the view
                    // cannot be refreshed, so alert the user
                    //
                    if (pviewhelp->pcvp->pCryptProviderData != NULL)
                    {
                        LoadStringU(HinstDll, IDS_NO_REFRESH, errorString, ARRAYSIZE(errorString));
                        if (pviewhelp->pcvp->szTitle != NULL)
                        {
                            MessageBoxU(hwndDlg, errorString, pviewhelp->pcvp->szTitle, MB_OK | MB_ICONWARNING);
                        }
                        else
                        {
                            LoadStringU(HinstDll, IDS_VIEW_TITLE, errorTitle, ARRAYSIZE(errorTitle));
                            MessageBoxU(hwndDlg, errorString, errorTitle, MB_OK | MB_ICONWARNING);
                        }
                    }

                    if (pviewhelp->pfPropertiesChanged != NULL)
                    {
                        *(pviewhelp->pfPropertiesChanged) = TRUE;
                    }

                    //
                    // since the editing of properties changed major stuff, we need
                    // to redo the trust work and then reset the display
                    //
                    BuildChain(pviewhelp, NULL);

                    SendMessage(hwndDlg, WM_MY_REINITIALIZE, (WPARAM) 0, (LPARAM) 0);
                    if (pviewhelp->hwndGeneralPage != NULL)
                    {
                        SendMessage(pviewhelp->hwndGeneralPage, WM_MY_REINITIALIZE, (WPARAM) 0, (LPARAM) 0);
                    }
                    if (pviewhelp->hwndHierarchyPage != NULL)
                    {
                        SendMessage(pviewhelp->hwndHierarchyPage, WM_MY_REINITIALIZE, (WPARAM) 0, (LPARAM) 0);
                    }
                }
                return TRUE;
            }
            break;

        case IDC_SHOW_DETAILS_COMBO:
            if (HIWORD(wParam) == LBN_SELCHANGE)
            {
                DWORD curSel = (DWORD)SendDlgItemMessageA(hwndDlg, IDC_SHOW_DETAILS_COMBO, CB_GETCURSEL, 0, (LPARAM) NULL);
                hWndListView = GetDlgItem(hwndDlg, IDC_ITEM_LIST);

                //
                // get all the items in the list view and free the lParam
                // associated with each of them (lParam is the helper sruct)
                //
                memset(&lvI, 0, sizeof(lvI));
                lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
                lvI.mask = LVIF_PARAM;
                while (lvI.iItem >= 0)
                {
                    if (ListView_GetItemU(hWndListView, &lvI))
                    {
                        FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvI.lParam);
                    }
                    lvI.iItem--;
                }
                ListView_DeleteAllItems(hWndListView);

                CryptUISetRicheditTextW(hwndDlg, IDC_DETAIL_EDIT, L"");

                i = 0;

                switch (curSel)
                {
                case 0:
                    DisplayV1Fields(hWndListView, pccert->pCertInfo, &i);
                    DisplayExtensions(hWndListView, pccert->pCertInfo->cExtension, pccert->pCertInfo->rgExtension, FALSE, &i);
                    DisplayExtensions(hWndListView, pccert->pCertInfo->cExtension, pccert->pCertInfo->rgExtension, TRUE, &i);
                    DisplayProperties(hWndListView, pccert, &i);
                    break;
                case 1:
                    DisplayV1Fields(hWndListView, pccert->pCertInfo, &i);
                    break;
                case 2:
                    DisplayExtensions(hWndListView, pccert->pCertInfo->cExtension, pccert->pCertInfo->rgExtension, FALSE, &i);
                    DisplayExtensions(hWndListView, pccert->pCertInfo->cExtension, pccert->pCertInfo->rgExtension, TRUE, &i);
                    break;
                case 3:
                    DisplayExtensions(hWndListView, pccert->pCertInfo->cExtension, pccert->pCertInfo->rgExtension, TRUE, &i);
                    break;
                case 4:
                    DisplayProperties(hWndListView, pccert, &i);
                    break;
                }

                return TRUE;
            }
            break;

        case IDHELP:
            pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvp->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvp->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvp->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvp->dwHelpId);
            }
            return TRUE;
        }
        break;

    case WM_DESTROY:

        //
        // get all the items in the list view and free the lParam
        // associated with each of them (lParam is the helper sruct)
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_ITEM_LIST);

        memset(&lvI, 0, sizeof(lvI));
        lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
        lvI.mask = LVIF_PARAM;
        while (lvI.iItem >= 0)
        {
            if (ListView_GetItemU(hWndListView, &lvI))
            {
                FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvI.lParam);
            }
            lvI.iItem--;
        }

        break;
    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_SHOW_DETAILS_COMBO))       &&
            (hwnd != GetDlgItem(hwndDlg, IDC_SAVE_CERTIFICATE_BUTTON))  &&
            (hwnd != GetDlgItem(hwndDlg, IDC_ITEM_LIST))                &&
            (hwnd != GetDlgItem(hwndDlg, IDC_EDIT_PROPERTIES_BUTTON))   &&
            (hwnd != GetDlgItem(hwndDlg, IDC_DETAIL_EDIT)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\cvhrchy.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cvhrchy.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

//  Fix a Win95 problem
/*#undef TVM_SETITEM
#define TVM_SETITEM TVM_SETITEMA
#undef TVM_GETITEM
#define TVM_GETITEM TVM_GETITEMA*/

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

#define MY_TREE_IMAGE_STATE_VALIDCERT           0
#define MY_TREE_IMAGE_STATE_INVALIDCERT         1
#define MY_TREE_IMAGE_STATE_VALIDCTL            2
#define MY_TREE_IMAGE_STATE_INVALIDCTL          3
#define MY_TREE_IMAGE_STATE_EXCLAMATION_CERT    4

static const HELPMAP helpmap[] = {
    {IDC_TRUST_TREE,        IDH_CERTVIEW_HIERARCHY_TRUST_TREE},
    {IDC_TRUST_VIEW,        IDH_CERTVIEW_HIERARCHY_SHOW_DETAILS_BUTTON},
    {IDC_HIERARCHY_EDIT,    IDH_CERTVIEW_HIERARCHY_ERROR_EDIT}
};

typedef struct {
    PCCERT_CONTEXT  pCert;
    PCCTL_CONTEXT   pCTL;
    LPWSTR          pwszErrorString;
} TREEVIEW_HELPER, *PTREEVIEW_HELPER;


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static PTREEVIEW_HELPER MakeHelperStruct(void *pVoid, LPWSTR pwszErrorString, BOOL fCTL)
{
    PTREEVIEW_HELPER pHelper;

    if (NULL == (pHelper = (PTREEVIEW_HELPER) malloc(sizeof(TREEVIEW_HELPER))))
    {
        return NULL;
    }
    memset(pHelper, 0, sizeof(TREEVIEW_HELPER));

    if (fCTL)
    {
        pHelper->pCTL = (PCCTL_CONTEXT) pVoid;
    }
    else
    {
        pHelper->pCert = (PCCERT_CONTEXT) pVoid;
    }
    pHelper->pwszErrorString = pwszErrorString;

    return(pHelper);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void FreeHelperStruct(PTREEVIEW_HELPER pHelper)
{
    free(pHelper->pwszErrorString);
    free(pHelper);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL GetTreeCTLErrorString(
                    DWORD   dwError,
                    LPWSTR  *ppwszErrorString)
{
    WCHAR   szErrorString[CRYPTUI_MAX_STRING_SIZE];
    BOOL    fRet = FALSE;

    *ppwszErrorString = NULL;

    if (dwError == TRUST_E_CERT_SIGNATURE)
    {
        LoadStringU(HinstDll, IDS_SIGNATURE_ERROR_CTL, szErrorString, ARRAYSIZE(szErrorString));
        if (NULL != (*ppwszErrorString = AllocAndCopyWStr(szErrorString)))
        {
            fRet = TRUE;
        }
    }
    else if (dwError == CERT_E_EXPIRED)
    {
        LoadStringU(HinstDll, IDS_EXPIRED_ERROR_CTL, szErrorString, ARRAYSIZE(szErrorString));
        if (NULL != (*ppwszErrorString = AllocAndCopyWStr(szErrorString)))
        {
            fRet = TRUE;
        }
    }
    else if (dwError == CERT_E_WRONG_USAGE)
    {
        LoadStringU(HinstDll, IDS_WRONG_USAGE_ERROR_CTL, szErrorString, ARRAYSIZE(szErrorString));
        if (NULL != (*ppwszErrorString = AllocAndCopyWStr(szErrorString)))
        {
            fRet = TRUE;
        }
    }

    //
    // if there wasn't an error string set, then hand back the "CTL is OK" string
    //
    if (*ppwszErrorString == NULL)
    {
        LoadStringU(HinstDll, IDS_CTLOK, szErrorString, ARRAYSIZE(szErrorString));
        *ppwszErrorString = AllocAndCopyWStr(szErrorString);
    }

    return fRet;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static int GetErrorIcon(PCRYPT_PROVIDER_CERT pCryptProviderCert)
{
    int iRet;

    switch (pCryptProviderCert->dwError)
    {
    case CERT_E_CHAINING:
    case TRUST_E_BASIC_CONSTRAINTS:
    case CERT_E_PURPOSE:
    case CERT_E_WRONG_USAGE:
    case CERT_E_REVOCATION_FAILURE:
    case CERT_E_INVALID_NAME:

        iRet =  MY_TREE_IMAGE_STATE_EXCLAMATION_CERT;
        break;

    default:

        if ((pCryptProviderCert->dwError == 0) && CertHasEmptyEKUProp(pCryptProviderCert->pCert))
        {
            iRet = MY_TREE_IMAGE_STATE_EXCLAMATION_CERT;
        }
        else
        {
            iRet = MY_TREE_IMAGE_STATE_INVALIDCERT;
        }
        break;
    }

    return iRet;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL GetTreeCertErrorStringAndImage(
                    PCRYPT_PROVIDER_CERT    pCryptProviderCert,
                    LPWSTR                  *ppwszErrorString,
                    int                     *piImage,
                    BOOL                    fWarnUntrustedRoot,
                    BOOL                    fRootInRemoteStore,
                    BOOL                    fLeafCert,
                    BOOL                    fAllUsagesFailed)
{
    WCHAR   szErrorString[CRYPTUI_MAX_STRING_SIZE];
    BOOL    fRet = FALSE;
    BOOL    fAllUsagesFailedAndLeafCert = fAllUsagesFailed && fLeafCert;

    *ppwszErrorString = NULL;

    //
    // if this is a self signed cert
    //
    if ((pCryptProviderCert->fSelfSigned))
    {
        //
        // if it is in a trust list, AND there is no error, then it is OK
        //
        if ((pCryptProviderCert->pCtlContext != NULL) && (pCryptProviderCert->dwError == 0) && !CertHasEmptyEKUProp(pCryptProviderCert->pCert))
        {
            *ppwszErrorString = NULL;
        }
        //
        // else, if is not marked as a trusted root, and we in fWarnUntrustedRoot mode and
        // the root cert is in the root store of the remote machine, then give warning
        //
        else if (((pCryptProviderCert->dwError == CERT_E_UNTRUSTEDROOT) ||
                        (pCryptProviderCert->dwError == CERT_E_UNTRUSTEDTESTROOT))  &&
                 fWarnUntrustedRoot                                                 &&
                 fRootInRemoteStore)
        {
            //
            // this is a special case where there is an error, but it is the untrusted
            // root error and we were told to by the caller to just warn the user
            //
            LoadStringU(HinstDll, IDS_WARNUNTRUSTEDROOT_ERROR_ROOTCERT, szErrorString, ARRAYSIZE(szErrorString));
            if (NULL != (*ppwszErrorString = AllocAndCopyWStr(szErrorString)))
            {
                fRet = TRUE;
                *piImage = MY_TREE_IMAGE_STATE_EXCLAMATION_CERT;
            }
        }
        //
        // else, if it is not marked as a trusted root it is an untrusted root error
        //
        else if ((pCryptProviderCert->dwError == CERT_E_UNTRUSTEDROOT)
                    || (pCryptProviderCert->dwError == CERT_E_UNTRUSTEDTESTROOT))
        {
            LoadStringU(HinstDll, IDS_UNTRUSTEDROOT_ERROR, szErrorString, ARRAYSIZE(szErrorString));
            if (NULL != (*ppwszErrorString = AllocAndCopyWStr(szErrorString)))
            {
                fRet = TRUE;
                *piImage = MY_TREE_IMAGE_STATE_INVALIDCERT;
            }
        }
        else if (GetCertErrorString(ppwszErrorString, pCryptProviderCert))
        {
            fRet = TRUE;
            *piImage = GetErrorIcon(pCryptProviderCert);
        }
    }
    else
    {
        if (GetCertErrorString(ppwszErrorString, pCryptProviderCert))
        {
            fRet = TRUE;
            *piImage = GetErrorIcon(pCryptProviderCert);
        }
    }

    //
    // if there wasn't an error string set, then hand back the "cert is OK" string
    //
    if (*ppwszErrorString == NULL)
    {
        LoadStringU(HinstDll, IDS_CERTIFICATEOK_TREE, szErrorString, ARRAYSIZE(szErrorString));
        *ppwszErrorString = AllocAndCopyWStr(szErrorString);
        *piImage = MY_TREE_IMAGE_STATE_VALIDCERT;
    }

    return fRet;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void DeleteChainViewItems(HWND hwndDlg,  PCERT_VIEW_HELPER pviewhelp)
{
    HTREEITEM   hItem;
    TV_ITEM     tvi;
    HWND        hWndTreeView = GetDlgItem(hwndDlg, IDC_TRUST_TREE);

    hItem = TreeView_GetNextItem(
                    hWndTreeView,
                    NULL,
                    TVGN_ROOT);

    tvi.mask = TVIF_HANDLE | TVIF_PARAM;

    while (hItem != NULL)
    {
        tvi.hItem = hItem;
        TreeView_GetItem(hWndTreeView, &tvi);
        FreeHelperStruct((PTREEVIEW_HELPER) tvi.lParam);

        hItem =  TreeView_GetNextItem(
                    hWndTreeView,
                    hItem,
                    TVGN_CHILD);
    }

    pviewhelp->fDeletingChain = TRUE;
    TreeView_DeleteAllItems(hWndTreeView);
    pviewhelp->fDeletingChain = FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void PopulateChainView(HWND hwndDlg, PCERT_VIEW_HELPER pviewhelp)
{
    HTREEITEM           hItem;
    int                 i;
    TV_ITEM             tvi;
    TVINSERTSTRUCTW     tvins;
    LPSTR               psz;
    LPWSTR              pwszErrorString;
    WCHAR               rgwch[CRYPTUI_MAX_STRING_SIZE];

    //
    // if there is an old tree in the view then clean it up
    //
    DeleteChainViewItems(hwndDlg, pviewhelp);

    //
    //  loop for each cert and add it to the chain view
    //
    tvins.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    hItem = TVI_ROOT;
    pviewhelp->fAddingToChain = TRUE;

    for (i=pviewhelp->cpCryptProviderCerts-1; i>= 0; i--) {

        tvins.hParent = hItem;
        tvins.hInsertAfter = TVI_FIRST;

        //
        // if this cert has a CTL context on it, then display that as the
        // parent of this cert
        //
        if (pviewhelp->rgpCryptProviderCerts[i]->pCtlContext != NULL)
        {
            LoadStringU(HinstDll, IDS_CTLVIEW_TITLE, rgwch, ARRAYSIZE(rgwch));
            psz = CertUIMkMBStr(rgwch);
            tvins.item.pszText = rgwch;
            tvins.item.cchTextMax = wcslen(rgwch);

            //
            // display the proper image based on whether there is a CTL error or not
            //
            if (GetTreeCTLErrorString(
                    pviewhelp->rgpCryptProviderCerts[i]->dwCtlError,
                    &pwszErrorString))
            {
                tvins.item.iImage = MY_TREE_IMAGE_STATE_INVALIDCTL;
            }
            else
            {
                tvins.item.iImage = MY_TREE_IMAGE_STATE_VALIDCTL;
            }

            tvins.item.iSelectedImage = tvins.item.iImage;
            tvins.item.lParam = (LPARAM) MakeHelperStruct(
                                            (void *)pviewhelp->rgpCryptProviderCerts[i]->pCtlContext,
                                            pwszErrorString,
                                            TRUE);

            hItem = (HTREEITEM) SendMessage(GetDlgItem(hwndDlg, IDC_TRUST_TREE), TVM_INSERTITEMW, 0, (LPARAM) &tvins);

            if (i != (int) (pviewhelp->cpCryptProviderCerts-1))
            {
                TreeView_Expand(GetDlgItem(hwndDlg, IDC_TRUST_TREE),
                                tvins.hParent, TVE_EXPAND);
            }

            //
            // set up the parent to insert the cert
            //
            tvins.hParent = hItem;

            free(psz);
        }

        //
        // get the display string for the tree view item
        //
        tvins.item.pszText = PrettySubject(pviewhelp->rgpCryptProviderCerts[i]->pCert);
        if (tvins.item.pszText == NULL)
        {
            LPWSTR pwszNone = NULL;

            if (NULL == (pwszNone = (LPWSTR) malloc((MAX_TITLE_LENGTH + 1) * sizeof(WCHAR))))
            {
                break;
            }

            // load the string for NONE
            if(!LoadStringU(g_hmodThisDll, IDS_NONE, pwszNone, MAX_TITLE_LENGTH))
            {
                free(pwszNone);
                break;
            }
            
            tvins.item.pszText = pwszNone;
        }
        tvins.item.cchTextMax = wcslen(tvins.item.pszText);
        
        //
        // check if the cert is trusted by trying to get an error string for the cert,
        // set the the tree view image for the cert based on that
        //
        GetTreeCertErrorStringAndImage(
                    pviewhelp->rgpCryptProviderCerts[i],
                    &pwszErrorString,
                    &(tvins.item.iImage),
                    pviewhelp->fWarnUntrustedRoot,
                    pviewhelp->fRootInRemoteStore,
                    (i == 0),
                    (pviewhelp->cUsages == 0));

        tvins.item.iSelectedImage = tvins.item.iImage;
        tvins.item.lParam = (LPARAM) MakeHelperStruct(
                                        (void *)pviewhelp->rgpCryptProviderCerts[i]->pCert,
                                        pwszErrorString,
                                        FALSE);
        
        hItem = (HTREEITEM) SendMessage(GetDlgItem(hwndDlg, IDC_TRUST_TREE), TVM_INSERTITEMW, 0, (LPARAM) &tvins);
        
        if ((i != (int) (pviewhelp->cpCryptProviderCerts-1)) ||
            (pviewhelp->rgpCryptProviderCerts[i]->pCtlContext != NULL))
        {
            TreeView_Expand(GetDlgItem(hwndDlg, IDC_TRUST_TREE),
                            tvins.hParent, TVE_EXPAND);
        }

        TreeView_SelectItem(GetDlgItem(hwndDlg, IDC_TRUST_TREE), hItem);

        free(tvins.item.pszText);
        tvins.item.pszText = NULL;
    }

    pviewhelp->fAddingToChain = FALSE;
    pviewhelp->hItem = hItem;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageHierarchy(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD               cb;
    HIMAGELIST          hIml;
    HTREEITEM           hItem;
    int                 i;
    PCCERT_CONTEXT      pccert;
    PROPSHEETPAGE *     ps;
    CERT_VIEW_HELPER    *pviewhelp;
    LPWSTR              pwsz;
    TV_ITEM             tvi;
    LPNMTREEVIEW        pnmtv;
    LPWSTR              pwszErrorString;
    HWND                hwnd;
    WCHAR               szViewButton[CRYPTUI_MAX_STRING_SIZE];
    LPNMHDR             pnm;

    switch ( msg ) {
    case WM_INITDIALOG:
        //  Pick up the parameter so we have all of the data
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (CERT_VIEW_HELPER *) (ps->lParam);
        pccert = pviewhelp->pcvp->pCertContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);
        pviewhelp->hwndHierarchyPage = hwndDlg;

        //
        //  Build up the image list for the control
        //
        hIml = ImageList_LoadImage(HinstDll, MAKEINTRESOURCE(IDB_TRUSTTREE_BITMAP), 16, 5, RGB(255,0,255), IMAGE_BITMAP, 0);
        if (hIml != NULL)
        {
            TreeView_SetImageList(GetDlgItem(hwndDlg, IDC_TRUST_TREE), hIml, TVSIL_NORMAL);
        }

        //
        //  Populate the tree control
        //
        PopulateChainView(hwndDlg, pviewhelp);
        EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_VIEW), FALSE);

        // Init of state var
        pviewhelp->fDblClk = FALSE;

        return TRUE;

    case WM_MY_REINITIALIZE:
        pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        //
        //  Re-Populate the tree control
        //
        PopulateChainView(hwndDlg, pviewhelp);

        TreeView_SelectItem(GetDlgItem(hwndDlg, IDC_TRUST_TREE), NULL);
        EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_VIEW), FALSE);

        //
        // clear out the error detail edit box
        //
        CryptUISetRicheditTextW(hwndDlg, IDC_HIERARCHY_EDIT, L"");

        return TRUE;

    case WM_NOTIFY:
        pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        switch (((NMHDR FAR *) lParam)->code) {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:

            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case TVN_SELCHANGEDA:
        case TVN_SELCHANGEDW:
            pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

            if ((!pviewhelp->fDeletingChain)    &&
                (((NM_TREEVIEW *) lParam)->itemNew.hItem != NULL))
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_VIEW),
                           ((NM_TREEVIEW *) lParam)->itemNew.hItem != pviewhelp->hItem);

                tvi.mask = TVIF_HANDLE | TVIF_PARAM;
                tvi.hItem = ((NM_TREEVIEW *) lParam)->itemNew.hItem;
                TreeView_GetItem(GetDlgItem(hwndDlg, IDC_TRUST_TREE), &tvi);
                CryptUISetRicheditTextW(hwndDlg, IDC_HIERARCHY_EDIT, ((PTREEVIEW_HELPER) tvi.lParam)->pwszErrorString);

                //
                // set the text on the button based on whether a cert or CTL is selected
                //
                if (((PTREEVIEW_HELPER) tvi.lParam)->pCTL == NULL)
                {
                    LoadStringU(HinstDll, IDS_VIEW_CERTIFICATE, szViewButton, ARRAYSIZE(szViewButton));
                }
                else
                {
                    LoadStringU(HinstDll, IDS_VIEW_CTL, szViewButton, ARRAYSIZE(szViewButton));
                }
                SetDlgItemTextU(hwndDlg, IDC_TRUST_VIEW, szViewButton);

            }
            break;

        case PSN_HELP:
            pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvp->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvp->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvp->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvp->dwHelpId);
            }
            return TRUE;

        case TVN_ITEMEXPANDINGA:
        case TVN_ITEMEXPANDINGW:

            pnmtv = (LPNMTREEVIEW) lParam;

            if (!pviewhelp->fAddingToChain)
            {
                if (pnmtv->action == TVE_COLLAPSE)
                {
                    HTREEITEM hParentItem = TreeView_GetParent(GetDlgItem(hwndDlg, IDC_TRUST_TREE), pnmtv->itemNew.hItem);
                    if ((hParentItem != NULL) && (!pviewhelp->fDblClk))
                    {
                        TreeView_SelectItem(GetDlgItem(hwndDlg, IDC_TRUST_TREE), hParentItem);
                    }
                    else
                    {
                        pviewhelp->fDblClk = FALSE;
                    }
                }
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            }
            return TRUE;

        case NM_DBLCLK:

            pnm = (LPNMHDR) lParam;
            hItem = TreeView_GetSelection(GetDlgItem(hwndDlg, IDC_TRUST_TREE));

            if (TreeView_GetChild(GetDlgItem(hwndDlg, IDC_TRUST_TREE), hItem) != NULL)
            {
                SendMessage(hwndDlg, WM_COMMAND, MAKELONG(IDC_TRUST_VIEW, BN_CLICKED), (LPARAM) GetDlgItem(hwndDlg, IDC_TRUST_VIEW));
            }

            if (hItem != pviewhelp->hItem)
            {
                pviewhelp->fDblClk = TRUE;
            }
            break;
        }

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case IDC_TRUST_VIEW:

            if (HIWORD(wParam) == BN_CLICKED)
            {
                CRYPTUI_VIEWCERTIFICATE_STRUCTW  cvps;
                CRYPTUI_VIEWCTL_STRUCTW          cvctl;
                BOOL                             fPropertiesChanged;
                PTREEVIEW_HELPER                 pTreeViewHelper;

                pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

                hItem = TreeView_GetSelection(GetDlgItem(hwndDlg, IDC_TRUST_TREE));
                tvi.mask = TVIF_HANDLE | TVIF_PARAM | TVIF_CHILDREN;
                tvi.hItem = hItem;
                TreeView_GetItem(GetDlgItem(hwndDlg, IDC_TRUST_TREE), &tvi);
                pTreeViewHelper = (PTREEVIEW_HELPER) tvi.lParam;

                //
                // check to see if we are viewing a cert or a ctl
                //
                if (pTreeViewHelper->pCTL != NULL)
                {
                    memset(&cvctl, 0, sizeof(CRYPTUI_VIEWCTL_STRUCTW));
                    cvctl.dwSize = sizeof(CRYPTUI_VIEWCTL_STRUCTW);
                    cvctl.hwndParent = hwndDlg;
                    cvctl.pCTLContext = pTreeViewHelper->pCTL;
                    cvctl.cCertSearchStores = pviewhelp->pcvp->cStores;
                    cvctl.rghCertSearchStores = pviewhelp->pcvp->rghStores;
                    cvctl.cStores = pviewhelp->pcvp->cStores;
                    cvctl.rghStores = pviewhelp->pcvp->rghStores;

                    CryptUIDlgViewCTLW(&cvctl);
                }
                else
                {

                    memcpy(&cvps, pviewhelp->pcvp, sizeof(cvps));
                    cvps.hwndParent = hwndDlg;
                    cvps.pCertContext = pTreeViewHelper->pCert;

                    // Set this flag to inhibit the deletion of the
                    // CERT_EXTENDED_ERROR_INFO_PROP_ID property which is
                    // set on the CA certs when building the original chain
                    // for the end certificate.
                    //
                    cvps.dwFlags |= CRYPTUI_TREEVIEW_PAGE_FLAG;

#if (0) // DSIE: Do not carry the state over. People get so confused when the state is carried
        //       over. So, always rebuild the state, and treat it as new context. Beside, by
        //       carrying the state over, it will have problem showing when there is more
        //       than one policy OID, as WinVerifyTrust can only handle one policy OID to be 
        //       passed in.
                    //
                    // Use the proper WinVerifyTrust state... either the one passed
                    // in or the one built internally if one was not passed in
                    //
                    if (pviewhelp->pcvp->hWVTStateData == NULL)
                    {
                        cvps.hWVTStateData = pviewhelp->sWTD.hWVTStateData;
                    }
#endif
                    //
                    // see where this item is in the chain
                    //
                    while (NULL != (hItem = TreeView_GetChild(GetDlgItem(hwndDlg, IDC_TRUST_TREE), hItem)))
                    {
                        //
                        // get the TreeViewHelper and make sure this item is a cert,
                        // if it is, then increase the count, otherwise if it is a CTL
                        // don't count it because CTL's hang off the CryptProviderCert 
                        // structure, so they don't take up an index themselves
                        //
                        tvi.mask = TVIF_HANDLE | TVIF_PARAM | TVIF_CHILDREN;
                        tvi.hItem = hItem;
                        TreeView_GetItem(GetDlgItem(hwndDlg, IDC_TRUST_TREE), &tvi);
                        pTreeViewHelper = (PTREEVIEW_HELPER) tvi.lParam;
                        if (pTreeViewHelper->pCert != NULL)
                        {
                            cvps.idxCert++;
                        }
                    }

                    //cvps.pCryptProviderData = NULL;

                    i = CryptUIDlgViewCertificateW(&cvps, &fPropertiesChanged);

                    //
                    // if properties changed whiled editing the parent, then
                    // we need to let our caller know, and we need to refresh
                    //
                    if (fPropertiesChanged)
                    {
                        if (pviewhelp->pfPropertiesChanged != NULL)
                        {
                            *(pviewhelp->pfPropertiesChanged) = TRUE;
                        }

                        //
                        // since the properties of one of our parents changed, we need
                        // to redo the trust work and then reset the display
                        //
                        BuildChain(pviewhelp, NULL);

                        if (pviewhelp->hwndGeneralPage != NULL)
                        {
                            SendMessage(pviewhelp->hwndGeneralPage, WM_MY_REINITIALIZE, (WPARAM) 0, (LPARAM) 0);
                        }

                        SendMessage(hwndDlg, WM_MY_REINITIALIZE, (WPARAM) 0, (LPARAM) 0);
                    }
                }
            }

            return TRUE;

        case IDHELP:
            pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvp->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvp->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvp->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvp->dwHelpId);
            }
            return TRUE;
        }
        break;

    case WM_DESTROY:
        pviewhelp = (CERT_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        DeleteChainViewItems(hwndDlg, pviewhelp);

        ImageList_Destroy(TreeView_GetImageList(GetDlgItem(hwndDlg, IDC_TRUST_TREE), TVSIL_NORMAL));

        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_TRUST_TREE))       &&
            (hwnd != GetDlgItem(hwndDlg, IDC_TRUST_VIEW))       &&
            (hwnd != GetDlgItem(hwndDlg, IDC_HIERARCHY_EDIT)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\disputil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       disputil.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;


//////////////////////////////////////////////////////////////////////////////////////
// This function will take a HWND for a list view, OID, and an extension in a bufffer,
// it will then format and display the extension in the list view
//////////////////////////////////////////////////////////////////////////////////////
static void DisplayExtension(HWND hWndListView, LPSTR pszObjId, LPBYTE pbData, DWORD cbData, DWORD index)
{
    BYTE    *pbFormatedExtension = NULL;
    DWORD   cbFormatedExtension = 0;

    //
    // format the extension using the installable formatting function
    //
    CryptFormatObject(
                X509_ASN_ENCODING,
                0,
	            0,
	            NULL,
                pszObjId,
                pbData,
                cbData,
	            NULL,
                &cbFormatedExtension
                );

    if (NULL == (pbFormatedExtension = (BYTE *) malloc(cbFormatedExtension)))
    {
        return;
    }

    if (CryptFormatObject(
            X509_ASN_ENCODING,
            0,
	        0,
	        NULL,
            pszObjId,
            pbData,
            cbData,
	        pbFormatedExtension,
            &cbFormatedExtension
            ))
    {
        ListView_SetItemTextU(
                hWndListView,
                index ,
                1,
                (LPWSTR)pbFormatedExtension);
    }

    free (pbFormatedExtension);
}


//////////////////////////////////////////////////////////////////////////////////////
// This function will take a HWND for a list view, an array of extensions and display
// all the extensions  in the list view.  It will either display the extensions that
// are critical or non-critical (based on the parameter fCritical)
//////////////////////////////////////////////////////////////////////////////////////
void DisplayExtensions(HWND hWndListView, DWORD cExtension, PCERT_EXTENSION rgExtension, BOOL fCritical, DWORD *index)
{
    DWORD       i;
    WCHAR       szText[CRYPTUI_MAX_STRING_SIZE];
    LV_ITEMW    lvI;
    WCHAR       pwszText;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szText;
    lvI.iSubItem = 0;
    if (fCritical)
        lvI.iImage = IMAGE_CRITICAL_EXTENSION;
    else
        lvI.iImage = IMAGE_EXTENSION;
    lvI.lParam = (LPARAM)NULL;

    //
    //  loop for each extension
    //
    for (i=0; i<cExtension; i++)
    {
        // display only critical or non-critical extensions based on fCritical
        if (rgExtension[i].fCritical != fCritical)
        {
            continue;
        }

        // add the field to the field column of the list view
        if (!MyGetOIDInfo(szText, ARRAYSIZE(szText), rgExtension[i].pszObjId))
        {
            return;
        }

        pwszText =
        lvI.iItem = (*index)++;
        lvI.cchTextMax = wcslen(szText);
        lvI.lParam = (LPARAM) MakeListDisplayHelperForExtension(
                                        rgExtension[i].pszObjId,
                                        rgExtension[i].Value.pbData,
                                        rgExtension[i].Value.cbData);
        ListView_InsertItemU(hWndListView, &lvI);

        DisplayExtension(
                hWndListView,
                rgExtension[i].pszObjId,
                rgExtension[i].Value.pbData,
                rgExtension[i].Value.cbData,
                (*index)-1);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
PLIST_DISPLAY_HELPER MakeListDisplayHelper(BOOL fHexText, LPWSTR pwszDisplayText, BYTE *pbData, DWORD cbData)
{
    PLIST_DISPLAY_HELPER pDisplayHelper;

    if (NULL == (pDisplayHelper = (PLIST_DISPLAY_HELPER) malloc(sizeof(LIST_DISPLAY_HELPER))))
    {
        return NULL;
    }

    pDisplayHelper->fHexText = fHexText;
    pDisplayHelper->pwszDisplayText = pwszDisplayText;
    pDisplayHelper->pbData = pbData;
    pDisplayHelper->cbData = cbData;

    return pDisplayHelper;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
void FreeListDisplayHelper(PLIST_DISPLAY_HELPER pDisplayHelper)
{
    if (pDisplayHelper == NULL)
    {
        return;
    }

    if (pDisplayHelper->pwszDisplayText)
        free(pDisplayHelper->pwszDisplayText);
    if (pDisplayHelper->pbData)
        free(pDisplayHelper->pbData);

    free(pDisplayHelper);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
PLIST_DISPLAY_HELPER MakeListDisplayHelperForExtension(LPSTR pszObjId, BYTE *pbData, DWORD cbData)
{
    BYTE    *pbFormatedExtension = NULL;
    DWORD   cbFormatedExtension = 0;

    //
    // format the extension using the installable formatting function if possible,
    // otherwise set up the helper with a pointer to plain old bytes
    //
    if (CryptFormatObject(
                X509_ASN_ENCODING,
                0,
	            CRYPT_FORMAT_STR_MULTI_LINE | CRYPT_FORMAT_STR_NO_HEX,
	            NULL,
                pszObjId,
                pbData,
                cbData,
	            NULL,
                &cbFormatedExtension
                ))
    {

        if (NULL == (pbFormatedExtension = (BYTE *) malloc(cbFormatedExtension)))
        {
            return NULL;
        }

        if (CryptFormatObject(
                X509_ASN_ENCODING,
                0,
	            CRYPT_FORMAT_STR_MULTI_LINE | CRYPT_FORMAT_STR_NO_HEX,
	            NULL,
                pszObjId,
                pbData,
                cbData,
	            pbFormatedExtension,
                &cbFormatedExtension
                ))
        {
            return MakeListDisplayHelper(FALSE, (LPWSTR) pbFormatedExtension, NULL, 0);
        }
    }
    else
    {
        if (NULL != (pbFormatedExtension = (BYTE *) malloc(cbData)))
        {
            memcpy(pbFormatedExtension, pbData, cbData);
        }
        return MakeListDisplayHelper(TRUE, NULL, pbFormatedExtension, cbData);
    }

    return NULL;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
void DisplayHelperTextInEdit(HWND hWndListView, HWND hwndDlg, int nIDEdit, int index)
{
    int                 listIndex;
    LVITEMW             lvI;
    LIST_DISPLAY_HELPER *pDisplayHelper;
    HWND                hWndEdit;

    hWndEdit = GetDlgItem(hwndDlg, nIDEdit);

    //
    // get the selected item if the index was not passed in
    //
    if (index == -1)
    {
        listIndex = ListView_GetNextItem(
                        hWndListView, 		
                        -1, 		
                        LVNI_SELECTED		
                        );	
    }
    else
    {
        listIndex = index;
    }

    memset(&lvI, 0, sizeof(lvI));
    lvI.iItem = listIndex;
    lvI.mask = LVIF_PARAM;
    if ((lvI.iItem == -1) || !ListView_GetItemU(hWndListView, &lvI))
    {
        return;
    }

    pDisplayHelper = (PLIST_DISPLAY_HELPER) lvI.lParam;

    if (pDisplayHelper == NULL)
    {
        return;
    }

    if (pDisplayHelper->fHexText)
    {
        SetTextFormatHex(hWndEdit);
    }
    else
    {
        SetTextFormatInitial(hWndEdit);
    }

    if ((pDisplayHelper->fHexText) && (pDisplayHelper->pbData != NULL))
    {
        FormatMemBufToWindow(
                hWndEdit,
                pDisplayHelper->pbData,
                pDisplayHelper->cbData);
    }
    else if (pDisplayHelper->pwszDisplayText != NULL)
    {
        //SetDlgItemTextU(hwndDlg, nIDEdit, pDisplayHelper->pwszDisplayText);
        CryptUISetRicheditTextW(hwndDlg, nIDEdit, pDisplayHelper->pwszDisplayText);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
//
// these two functions handle modifying the text font in the field view text box
// on the details tab.
//
static BOOL gfInitialFaceNameSet = FALSE;
static char g_szInitialFaceName[LF_FACESIZE];
static char g_szMonoSpaceFaceName[LF_FACESIZE];

void SetTextFormatInitial(HWND hWnd)
{
    CHARFORMAT  chFormat;

    //
    // initialize the global string variables that hold the face name for the details text box
    //
    if (!gfInitialFaceNameSet)
    {
        memset(&chFormat, 0, sizeof(chFormat));
        chFormat.cbSize = sizeof(chFormat);
        chFormat.dwMask = CFM_FACE;

        SendMessageA(hWnd, EM_GETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);
        strcpy(g_szInitialFaceName, chFormat.szFaceName);

        LoadStringA(HinstDll, IDS_FIELD_TEXT_BOX_FONT, g_szMonoSpaceFaceName, ARRAYSIZE(g_szMonoSpaceFaceName));
        gfInitialFaceNameSet = TRUE;
    }

    memset(&chFormat, 0, sizeof(chFormat));
    chFormat.cbSize = sizeof(chFormat);
    chFormat.dwMask = CFM_FACE;
    strcpy(chFormat.szFaceName, g_szInitialFaceName);

    SendMessageA(hWnd, EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);
}

void SetTextFormatHex(HWND hWnd)
{
    CHARFORMAT  chFormat;

    //
    // initialize the global string variables that hold the face name for the details text box
    //
    if (!gfInitialFaceNameSet)
    {
        memset(&chFormat, 0, sizeof(chFormat));
        chFormat.cbSize = sizeof(chFormat);
        chFormat.dwMask = CFM_FACE;

        SendMessageA(hWnd, EM_GETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);
        strcpy(g_szInitialFaceName, chFormat.szFaceName);

        LoadStringA(HinstDll, IDS_FIELD_TEXT_BOX_FONT, g_szMonoSpaceFaceName, ARRAYSIZE(g_szMonoSpaceFaceName));
        gfInitialFaceNameSet = TRUE;
    }

    memset(&chFormat, 0, sizeof(chFormat));
    chFormat.cbSize = sizeof(chFormat);
    chFormat.dwMask = CFM_FACE;
    strcpy(chFormat.szFaceName, g_szMonoSpaceFaceName);

    SendMessageA(hWnd, EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL GetUnknownErrorString(LPWSTR *ppwszErrorString, DWORD dwError)
{
    LPVOID  pwsz;
    DWORD   ret = 0;
    WCHAR   szText[CRYPTUI_MAX_STRING_SIZE];

    ret = FormatMessageU (
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
			NULL,
			dwError,
			MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			(LPWSTR) &pwsz,
            0,
            NULL);

    if (ret != 0)
    {
        *ppwszErrorString = AllocAndCopyWStr((LPWSTR) pwsz);
        LocalFree(pwsz);
    }
    else
    {
        LoadStringU(HinstDll, IDS_UNKNOWN_ERROR, szText, ARRAYSIZE(szText));
        *ppwszErrorString = AllocAndCopyWStr(szText);
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL GetCertErrorString(LPWSTR *ppwszErrorString, PCRYPT_PROVIDER_CERT pCryptProviderCert)
{
    WCHAR   szErrorString[CRYPTUI_MAX_STRING_SIZE];

    //
    // if this is true then the cert is OK
    //
    if ((pCryptProviderCert->dwError == 0)                              &&
        (pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_SIG)        &&
        (pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_TIME)       &&
        (pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_TIMENEST)   &&
        (!pCryptProviderCert->fIsCyclic)                                &&
        !CertHasEmptyEKUProp(pCryptProviderCert->pCert))
    {
        return FALSE;
    }

    *ppwszErrorString = NULL;

    if ((pCryptProviderCert->dwError == CERT_E_UNTRUSTEDROOT) ||
        (pCryptProviderCert->dwError == CERT_E_UNTRUSTEDTESTROOT))
    {
        LoadStringU(HinstDll, IDS_UNTRUSTEDROOT_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pCryptProviderCert->dwError == CERT_E_REVOKED)
    {
        LoadStringU(HinstDll, IDS_CERTREVOKED_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (!(pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_SIG) ||
             (pCryptProviderCert->dwError == TRUST_E_CERT_SIGNATURE))
    {
        LoadStringU(HinstDll, IDS_CERTBADSIGNATURE_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (!(pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_TIME) ||
             (pCryptProviderCert->dwError == CERT_E_EXPIRED))
    {
        LoadStringU(HinstDll, IDS_CERTEXPIRED_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (!(pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_TIMENEST) ||
             (pCryptProviderCert->dwError == CERT_E_VALIDITYPERIODNESTING))
    {
        LoadStringU(HinstDll, IDS_TIMENESTING_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pCryptProviderCert->dwError == CERT_E_WRONG_USAGE)
    {
        //
        // if state was passed in, then the usage should be there
        //
       /* if (pviewhelp->pcvp->pCryptProviderData != NULL)
        {
            pviewhelp->pcvp->pCryptProviderData->pszUsageOID;
        }
        else
        {
            //
            // otherwise get the usage out of the built up state
            //
            pviewhelp->sWTD.pPolicyCallbackData = pszUsage;
        }*/



        LoadStringU(HinstDll, IDS_WRONG_USAGE_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pCryptProviderCert->dwError == TRUST_E_BASIC_CONSTRAINTS)
    {
        LoadStringU(HinstDll, IDS_BASIC_CONSTRAINTS_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pCryptProviderCert->dwError == CERT_E_PURPOSE)
    {
        LoadStringU(HinstDll, IDS_PURPOSE_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pCryptProviderCert->dwError == CERT_E_REVOCATION_FAILURE)
    {
        LoadStringU(HinstDll, IDS_REVOCATION_FAILURE_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pCryptProviderCert->dwError == CERT_E_CHAINING)
    {
        LoadStringU(HinstDll, IDS_CANTBUILDCHAIN_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pCryptProviderCert->dwError == TRUST_E_EXPLICIT_DISTRUST)
    {
        LoadStringU(HinstDll, IDS_EXPLICITDISTRUST_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if ((pCryptProviderCert->dwError == 0) && CertHasEmptyEKUProp(pCryptProviderCert->pCert))
    {
        LoadStringU(HinstDll, IDS_NO_USAGES_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pCryptProviderCert->fIsCyclic)
    {
        LoadStringU(HinstDll, IDS_CYCLE_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else
    {
        //
        // this is not an error we know about, so call the general
        // error string function
        //
        GetUnknownErrorString(ppwszErrorString, pCryptProviderCert->dwError);
    }

    if (*ppwszErrorString == NULL)
    {
        if (NULL == (*ppwszErrorString = AllocAndCopyWStr(szErrorString)))
        {
            return FALSE;
        }
    }

    return TRUE;
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void DrawFocusRectangle (HWND hwnd, HDC hdc)
{
    RECT        rect;
    PAINTSTRUCT ps;
    BOOL        fReleaseDC = FALSE;

    if (hdc == NULL)
    {
        hdc = GetDC(hwnd);
        if (hdc == NULL)
        {
            return;
        }

        fReleaseDC = TRUE;
    }

    GetClientRect(hwnd, &rect);
    DrawFocusRect(hdc, &rect);

    if ( fReleaseDC == TRUE )
    {
        ReleaseDC(hwnd, hdc);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK ArrowCursorSubclassProc (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    HDC         hdc;
    WNDPROC     wndproc;
    PAINTSTRUCT ps;
    HWND        hWndSubject;
    HWND        hWndIssuer;
    HWND        hWndNext;

    wndproc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch ( uMsg )
    {
    case WM_SETCURSOR:

        SetCursor(LoadCursor(NULL, IDC_ARROW));
        return( TRUE );

        break;

    case WM_CHAR:

        if ( wParam != (WPARAM)' ' )
        {
            break;
        }

    case WM_LBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    //case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    //case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:

        return( TRUE );

        break;

    case EM_SETSEL:

        return( TRUE );

        break;

    case WM_PAINT:

        CallWindowProc(wndproc, hwnd, uMsg, wParam, lParam);
        if ( hwnd == GetFocus() )
        {
            DrawFocusRectangle(hwnd, NULL);
        }
        return( TRUE );

        break;

    case WM_SETFOCUS:

        hWndSubject = GetDlgItem(GetParent(hwnd), IDC_SUBJECT_EDIT);
        hWndIssuer = GetDlgItem(GetParent(hwnd), IDC_ISSUER_EDIT);

        //if ((hwnd == hWndSubject) || (hwnd == hWndIssuer))
        {
            hWndNext = GetNextDlgTabItem(GetParent(hwnd), hwnd, FALSE);

            if ((hWndNext == hWndSubject) && (hwnd == hWndIssuer))
            {
                SetFocus(GetDlgItem(GetParent(GetParent(hwnd)), IDOK));
            }
            else
            {
                SetFocus(hWndNext);
            }
            return( TRUE );
        }
        /*else
        {
            InvalidateRect(hwnd, NULL, FALSE);
            UpdateWindow(hwnd);
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            return( TRUE );
        }
*/
        break;

    case WM_KILLFOCUS:

        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
        return( TRUE );

    }

    return(CallWindowProc(wndproc, hwnd, uMsg, wParam, lParam));
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK LinkSubclassProc (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    DWORD               cpszURLString = 0;
    LPSTR               pszURLString = NULL;
    PLINK_SUBCLASS_DATA plsd;

    plsd = (PLINK_SUBCLASS_DATA)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch ( uMsg )
    {
    case WM_SETCURSOR:

        // if the mouse hasn't been captured yet, then capture it and set the flag
        if (!plsd->fMouseCaptured)
        {
            SetCapture(hwnd);
            plsd->fMouseCaptured = TRUE;
        }

        if (plsd->fUseArrowInsteadOfHand)
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
        }
        else
        {
            SetCursor(LoadCursor((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),
                                MAKEINTRESOURCE(IDC_MYHAND)));
        }
        return( TRUE );

        break;

    case WM_CHAR:

        if ( wParam != (WPARAM)' ')
        {
            if ( wParam == 0x1b )
            {
                SendMessage(GetParent(GetParent(hwnd)), WM_CLOSE, 0, 0);
                return TRUE;
            }
            break;
        }

        // fall through to wm_lbuttondown....

    case WM_LBUTTONDOWN:

        if (plsd->fUseArrowInsteadOfHand)
        {
            return TRUE;
        }

        SetFocus(hwnd);

        switch(plsd->uId)
        {
            case IDC_SUBJECT_EDIT:
            case IDC_ISSUER_EDIT:
                CryptuiGoLink(GetParent(plsd->hwndParent), plsd->pszURL, plsd->fNoCOM);
                break;
        }

        return( TRUE );

    case WM_LBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    //case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    //case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:

        return( TRUE );

    case EM_SETSEL:

        return( TRUE );

    case WM_PAINT:

        CallWindowProc(plsd->wpPrev, hwnd, uMsg, wParam, lParam);
        if ( hwnd == GetFocus() )
        {
            DrawFocusRectangle(hwnd, NULL);
        }
        return( TRUE );

    case WM_SETFOCUS:

        if ((hwnd == GetDlgItem(GetParent(hwnd), IDC_CERT_PRIVATE_KEY_EDIT)) &&
            (plsd->fUseArrowInsteadOfHand))
        {
            SetFocus(GetNextDlgTabItem(GetParent(hwnd), hwnd, FALSE));
            return( TRUE );
        }

        if ( hwnd == GetFocus() )
        {
            InvalidateRect(GetParent(hwnd), NULL, FALSE);
            UpdateWindow(hwnd);
            SetCursor(LoadCursor((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),
                                MAKEINTRESOURCE(IDC_MYHAND)));
            return( TRUE );
        }
        break;

    case WM_KILLFOCUS:

        InvalidateRect(GetParent(hwnd), NULL, FALSE);
        UpdateWindow(hwnd);
        SetCursor(LoadCursor(NULL, IDC_ARROW));

        return( TRUE );

    case WM_MOUSEMOVE:

        MSG                 msg;
        DWORD               dwCharLine;
        RECT                rect;
        int                 xPos, yPos;

        memset(&msg, 0, sizeof(MSG));
        msg.hwnd    = hwnd;
        msg.message = uMsg;
        msg.wParam  = wParam;
        msg.lParam  = lParam;

        SendMessage(plsd->hwndTip, TTM_RELAYEVENT, 0, (LPARAM)&msg);

        // check to see if the mouse is in this windows rect, if not, then reset
        // the cursor to an arrow and release the mouse
        GetClientRect(hwnd, &rect);
        xPos = LOWORD(lParam);
        yPos = HIWORD(lParam);
        if ((xPos < 0) ||
            (yPos < 0) ||
            (xPos > (rect.right - rect.left)) ||
            (yPos > (rect.bottom - rect.top)))
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            ReleaseCapture();
            plsd->fMouseCaptured = FALSE;
        }

        return( TRUE );
    }

    return(CallWindowProc(plsd->wpPrev, hwnd, uMsg, wParam, lParam));
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
void CertSubclassEditControlForArrowCursor (HWND hwndEdit)
{
    LONG_PTR PrevWndProc;

    PrevWndProc = GetWindowLongPtr(hwndEdit, GWLP_WNDPROC);
    SetWindowLongPtr(hwndEdit, GWLP_USERDATA, PrevWndProc);
    SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)ArrowCursorSubclassProc);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
void CertSubclassEditControlForLink (
                 HWND                hwndDlg,
                 HWND                hwndEdit,
                 PLINK_SUBCLASS_DATA plsd
                 )
{
    HWND hwndTip;

    plsd->hwndTip = CreateWindowA(
                          TOOLTIPS_CLASSA,
                          (LPSTR)NULL,
                          WS_POPUP | TTS_ALWAYSTIP,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          hwndDlg,
                          (HMENU)NULL,
                          HinstDll,
                          NULL
                          );

    if ( plsd->hwndTip != NULL )
    {
        TOOLINFOA tia;

        memset(&tia, 0, sizeof(TOOLINFOA));
        tia.cbSize = sizeof(TOOLINFOA);
        tia.hwnd = hwndEdit;
        tia.uId = 1;
        tia.hinst = HinstDll;
        //GetClientRect(hwndEdit, &tia.rect);
        SendMessageA(hwndEdit, EM_GETRECT, 0, (LPARAM)&tia.rect);
        tia.lpszText = plsd->pszURL;

        SendMessageA(plsd->hwndTip, TTM_ADDTOOL, 0, (LPARAM)&tia);
    }

    plsd->fMouseCaptured = FALSE;
    plsd->wpPrev = (WNDPROC)GetWindowLongPtr(hwndEdit, GWLP_WNDPROC);
    SetWindowLongPtr(hwndEdit, GWLP_USERDATA, (LONG_PTR)plsd);
    SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)LinkSubclassProc);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
void * GetStoreName(HCERTSTORE hCertStore, BOOL fWideChar)
{
    DWORD    cbName = 0;
    LPWSTR   pwszName = NULL;
    LPSTR    pszName = NULL;

    if (!CertGetStoreProperty(
                hCertStore,
                CERT_STORE_LOCALIZED_NAME_PROP_ID,
                NULL,
                &cbName))
    {
        return NULL;
    }

    if (NULL == (pwszName = (LPWSTR) malloc(cbName)))
    {
        return NULL;
    }

    if (!CertGetStoreProperty(
                hCertStore,
                CERT_STORE_LOCALIZED_NAME_PROP_ID,
                pwszName,
                &cbName))
    {
        free(pwszName);
        return NULL;
    }

    if (fWideChar)
    {
        return pwszName;
    }
    else
    {
        pszName = CertUIMkMBStr(pwszName);
        free(pwszName);
        return pszName;
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL ValidateItemText(HWND hWndListView, LPWSTR pszText, int index)
{
    LVITEMW lvItem;
    WCHAR   szText[CRYPTUI_MAX_STRING_SIZE];

    memset(&lvItem, 0, sizeof(lvItem));
    lvItem.iItem = index;
    lvItem.mask = LVIF_TEXT;
    lvItem.pszText = szText;
    lvItem.cchTextMax = ARRAYSIZE(szText);
    if (!ListView_GetItemU(hWndListView, &lvItem))
    {
        return FALSE;
    }

    return (wcscmp(szText, pszText) == 0);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
void ModifyOrInsertRow(
                    HWND        hWndListView,
                    LV_ITEMW    *plvI,
                    LPWSTR      pwszValueText,
                    LPWSTR      pwszText,
                    BOOL        fAddRows,
                    BOOL        fHex)
{
    LV_ITEMW    lvIParam;

    memset(&lvIParam, 0, sizeof(lvIParam));
    lvIParam.mask = LVIF_PARAM;
    lvIParam.iItem = plvI->iItem;	

    if (fAddRows)
    {
        ListView_InsertItemU(hWndListView, plvI);
    }
    else
    {
        //
        // delete the helper that is already there
        //
        ListView_GetItemU(hWndListView, &lvIParam);
        FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvIParam.lParam);

        if (!ValidateItemText(hWndListView, plvI->pszText, plvI->iItem))
        {
            ListView_DeleteItem(hWndListView, plvI->iItem);
            ListView_InsertItemU(hWndListView, plvI);
        }
    }

    ListView_SetItemTextU(hWndListView, plvI->iItem, 1, pwszValueText);

    lvIParam.lParam = (LPARAM) MakeListDisplayHelper(fHex, pwszText, NULL, 0);
    ListView_SetItem(hWndListView, &lvIParam);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
int CALLBACK HidePropSheetCancelButtonCallback(
                HWND    hwndDlg,
                UINT    uMsg,
                LPARAM  lParam)
{
    RECT rc, parentRect;
    int  xExtra, yExtra;

    if (uMsg == PSCB_INITIALIZED)
    {
        HWND hwndOk = GetDlgItem(hwndDlg, IDOK);
        HWND hwndCancel = GetDlgItem(hwndDlg, IDCANCEL);

        GetWindowRect(hwndCancel, &rc);
        MapWindowPoints(HWND_DESKTOP, hwndDlg, (LPPOINT) &rc, 2);
        ShowWindow(hwndCancel, SW_HIDE);
        MoveWindow(
                hwndOk,
                rc.left,
                rc.top,
                rc.right - rc.left,
                rc.bottom - rc.top,
                FALSE);
    }

    return 0;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR WINAPI CryptUIPropertySheetA(LPCPROPSHEETHEADERA pHdr)
{
    PROPSHEETHEADERA    hdr;
    PROPSHEETPAGEA      *pPropSheetPage;
    INT_PTR             ret;
    UINT                i;

    memcpy(&hdr, pHdr, sizeof(PROPSHEETHEADERA));
    hdr.dwSize = PROPSHEETHEADERA_V1_SIZE;

    hdr.ppsp = (PROPSHEETPAGEA *) malloc(pHdr->nPages * PROPSHEETPAGEA_V1_SIZE);
    if (hdr.ppsp == NULL)
    {
        SetLastError(E_OUTOFMEMORY);
        return -1;
    }

    pPropSheetPage = (PROPSHEETPAGEA *) hdr.ppsp;
    for (i=0; i<pHdr->nPages; i++)
    {
        memcpy(pPropSheetPage, &(pHdr->ppsp[i]), PROPSHEETPAGEA_V1_SIZE);
        pPropSheetPage->dwSize = PROPSHEETPAGEA_V1_SIZE;
        pPropSheetPage = (PROPSHEETPAGEA *) (((LPBYTE) pPropSheetPage) + PROPSHEETPAGEA_V1_SIZE);
    }

    ret = PropertySheetA(&hdr);
    free((void *)hdr.ppsp);
    return ret;
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR WINAPI CryptUIPropertySheetW(LPCPROPSHEETHEADERW pHdr)
{
    PROPSHEETHEADERW    hdr;
    PROPSHEETPAGEW      *pPropSheetPage;
    INT_PTR             ret;
    UINT                i;

    memcpy(&hdr, pHdr, sizeof(PROPSHEETHEADERW));
    hdr.dwSize = PROPSHEETHEADERW_V1_SIZE;

    hdr.ppsp = (PROPSHEETPAGEW *) malloc(pHdr->nPages * PROPSHEETPAGEW_V1_SIZE);
    if (hdr.ppsp == NULL)
    {
        SetLastError(E_OUTOFMEMORY);
        return -1;
    }

    pPropSheetPage = (PROPSHEETPAGEW *) hdr.ppsp;
    for (i=0; i<pHdr->nPages; i++)
    {
        memcpy(pPropSheetPage, &(pHdr->ppsp[i]), PROPSHEETPAGEW_V1_SIZE);
        pPropSheetPage->dwSize = PROPSHEETPAGEW_V1_SIZE;
        pPropSheetPage = (PROPSHEETPAGEW *) (((LPBYTE) pPropSheetPage) + PROPSHEETPAGEW_V1_SIZE);
    }

    ret = PropertySheetW(&hdr);
    free((void *)hdr.ppsp);
    return ret;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL IsTrueErrorString(CERT_VIEW_HELPER *pviewhelp)
{
    BOOL fRet;

    if ( ( ((pviewhelp->dwChainError == CERT_E_UNTRUSTEDROOT) ||
            (pviewhelp->dwChainError == CERT_E_UNTRUSTEDTESTROOT))  &&
         (pviewhelp->fWarnUntrustedRoot)                             &&
         (pviewhelp->fRootInRemoteStore)) ||
          pviewhelp->fWarnRemoteTrust )
    {
        return FALSE;
    }

    switch (pviewhelp->dwChainError)
    {
    case CERT_E_CHAINING:
    case TRUST_E_BASIC_CONSTRAINTS:
    case CERT_E_PURPOSE:
    case CERT_E_WRONG_USAGE:
        fRet = FALSE;
        break;

    case CERT_E_INVALID_NAME:
        if (pviewhelp->pcvp->idxCert == 0)
        {
            fRet = TRUE;
        }
        else
        {
            fRet = FALSE;
        }

        break;

    default:
        fRet = TRUE;
        break;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\demand.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       demand.h
//
//--------------------------------------------------------------------------

/*
**	d e m a n d . h
**	
**	Purpose: create an intelligent method of defer loading functions
**
**  Creators: jimsch, brimo, t-erikne
**  Created: 5/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __DEMAND_H
#define __DEMAND_H

#ifndef MAC
//
// IF YOU #INCLUDE A FILE HERE YOU PROBABLY ARE MAKING A MISTAKE.
// THIS FILE IS INCLUDED BY LOTS OF PEOPLE.  THINK THRICE
// BEFORE #INCLUDING *ANYTHING* HERE.  MAKE GOOD USE
// OF FORWARD REFS INSTEAD.
//

#ifdef IMPLEMENT_LOADER_FUNCTIONS

#define USE_CRITSEC

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           if (!DemandLoad##dll()) return err;          \
           return VAR_##name args2;                     \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           if (!DemandLoad##dll()) return;              \
           VAR_##name args2;                            \
           return;                                      \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;
#if 0
// my 1st attempt
#define DemandLoadDLL_GENERATOR(fnsuffix, dllname, handle, procaddrlist) \
    BOOL DemandLoad##fnsuffix()                     \
    {                                               \
        BOOL                fRet = TRUE;            \
                                                    \
        Assert(fInit);                              \
        EnterCriticalSection(&cs);                  \
                                                    \
        if (0 == handle)                            \
            {                                       \
            handle = LoadLibrary(#dllname);         \
                                                    \
            if (0 == handle)                        \
                fRet = FALSE;                       \
            else                                    \
                {                                   \
                procaddrlist                        \
                }                                   \
            }                                       \
                                                    \
        LeaveCriticalSection(&cs);                  \
        return fRet;                                \
    }
#endif

#else  // !IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;
#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;

#if 0
#define DemandLoadDLL_GENERATOR(fnsuffix, dllname, handle, procaddrlist) \
        BOOL DemandLoad##fnsuffix(void);
#endif

#endif // IMPLEMENT_LOADER_FUNCTIONS

void InitDemandLoadedLibs();
void FreeDemandLoadedLibs();

/////////////////////////////////////
// CRYPT32.DLL

BOOL DemandLoadCrypt32(void);

LOADER_FUNCTION( BOOL, CertFreeCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext),
    FALSE, Crypt32)
#define CertFreeCertificateContext VAR_CertFreeCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertDuplicateCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext), NULL, Crypt32)
#define CertDuplicateCertificateContext VAR_CertDuplicateCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertFindCertificateInStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext),
    NULL, Crypt32)
#define CertFindCertificateInStore VAR_CertFindCertificateInStore

LOADER_FUNCTION( BOOL, CertCloseStore,
    (HCERTSTORE hCertStore, DWORD dwFlags),
    (hCertStore, dwFlags),
    FALSE, Crypt32)
#define CertCloseStore VAR_CertCloseStore

LOADER_FUNCTION( HCERTSTORE, CertOpenStore,
    (LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV hCryptProv,
     DWORD dwFlags, const void *pvPara),
    (lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara),
    NULL, Crypt32)
#define CertOpenStore VAR_CertOpenStore

LOADER_FUNCTION( BOOL, CertGetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData),
    (pCertContext, dwPropId, pvData, pcbData),
    FALSE, Crypt32)
#define CertGetCertificateContextProperty VAR_CertGetCertificateContextProperty

LOADER_FUNCTION( BOOL, CertCompareCertificate,
    (DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2),
    (dwCertEncodingType, pCertId1, pCertId2),
    FALSE, Crypt32)
#define CertCompareCertificate VAR_CertCompareCertificate

LOADER_FUNCTION( PCCERT_CONTEXT, CertEnumCertificatesInStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, pPrevCertContext),
    NULL, Crypt32)
#define CertEnumCertificatesInStore VAR_CertEnumCertificatesInStore

LOADER_FUNCTION( BOOL, CryptDecodeObject,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE * pbEncoded,
     DWORD cbEncoded, DWORD dwFlags, void * pvStructInfo, DWORD * pcbStructInfo),
    (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags,
     pvStructInfo, pcbStructInfo),
    FALSE, Crypt32)
#define CryptDecodeObject VAR_CryptDecodeObject

LOADER_FUNCTION( PCERT_EXTENSION, CertFindExtension,
    (LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION rgExtensions[]),
    (pszObjId, cExtensions, rgExtensions),
    NULL, Crypt32)
#define CertFindExtension VAR_CertFindExtension

LOADER_FUNCTION( BOOL, CryptFormatObject,
    (DWORD dwCertEncodingType, DWORD dwFormatType, DWORD dwFormatStrType,
     void * pFormatStruct, LPCSTR lpszStructType, const BYTE * pbEncoded,
     DWORD cbEncoded, void * pbFormat, DWORD * pcbFormat),
    (dwCertEncodingType, dwFormatType, dwFormatStrType, pFormatStruct,
     lpszStructType, pbEncoded, cbEncoded, pbFormat, pcbFormat),
    FALSE, Crypt32)
#define CryptFormatObject VAR_CryptFormatObject

LOADER_FUNCTION( DWORD, CertNameToStrW,
    (DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType,
     LPWSTR psz, DWORD csz),
    (dwCertEncodingType, pName, dwStrType, psz, csz),
    0, Crypt32)
#define CertNameToStrW VAR_CertNameToStrW

LOADER_FUNCTION( DWORD, CertNameToStrA,
    (DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType,
     LPSTR psz, DWORD csz),
    (dwCertEncodingType, pName, dwStrType, psz, csz),
    0, Crypt32)
#define CertNameToStrA VAR_CertNameToStrA

LOADER_FUNCTION( BOOL, CertStrToNameA,
    (DWORD dwCertEncodingType, LPCSTR pszX500, DWORD dwStrType, void *pvReserved,
     BYTE *pbEncoded, DWORD *pcbEncoded, LPCSTR *ppszError),
    (dwCertEncodingType, pszX500, dwStrType, pvReserved,
     pbEncoded, pcbEncoded, ppszError),
     FALSE, Crypt32)
#define CertStrToNameA VAR_CertStrToNameA

LOADER_FUNCTION( DWORD, CertRDNValueToStrW,
    (DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz),
    (dwValueType, pValue, psz, csz),
    0, Crypt32)
#define CertRDNValueToStrW VAR_CertRDNValueToStrW

LOADER_FUNCTION( PCERT_RDN_ATTR, CertFindRDNAttr,
    (LPCSTR pszObjId, PCERT_NAME_INFO pName),
    (pszObjId, pName),
    NULL, Crypt32)
#define CertFindRDNAttr VAR_CertFindRDNAttr

LOADER_FUNCTION( BOOL, CryptRegisterOIDFunction,
    (DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszDll,
     LPCSTR pszOverrideFuncName),
    (dwEncodingType, pszFuncName, pszOID, pwszDll, pszOverrideFuncName),
    FALSE, Crypt32)
#define CryptRegisterOIDFunction VAR_CryptRegisterOIDFunction

LOADER_FUNCTION( BOOL, CryptUnregisterOIDFunction,
    (DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID),
    (dwEncodingType, pszFuncName, pszOID),
    FALSE, Crypt32)
#define CryptUnregisterOIDFunction VAR_CryptUnregisterOIDFunction

LOADER_FUNCTION( BOOL, CertSetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void * pvData),
    (pCertContext, dwPropId, dwFlags, pvData),
    FALSE, Crypt32)
#define CertSetCertificateContextProperty VAR_CertSetCertificateContextProperty

LOADER_FUNCTION( BOOL, CertVerifyCTLUsage,
    (DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject,
     PCTL_USAGE pSubjectUsage, DWORD dwFlags,
     PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
     PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus),
    (dwEncodingType, dwSubjectType, pvSubject, pSubjectUsage, dwFlags,
     pVerifyUsagePara, pVerifyUsageStatus),
    0, Crypt32)
#define CertVerifyCTLUsage VAR_CertVerifyCTLUsage

LOADER_FUNCTION( PCCERT_CONTEXT, CertGetIssuerCertificateFromStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext,
     PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags),
    (hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags),
    NULL, Crypt32)
#define CertGetIssuerCertificateFromStore VAR_CertGetIssuerCertificateFromStore

LOADER_FUNCTION( BOOL, CertFreeCTLContext,
    (PCCTL_CONTEXT pCtlContext),
    (pCtlContext),
    FALSE, Crypt32)
#define CertFreeCTLContext VAR_CertFreeCTLContext

LOADER_FUNCTION( BOOL, CertAddEncodedCTLToStore,
    (HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded,
     DWORD cbCtlEncoded, DWORD dwAddDisposition, PCCTL_CONTEXT *ppCtlContext),
    (hCertStore, dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded,
     dwAddDisposition, ppCtlContext),
    FALSE, Crypt32)
#define CertAddEncodedCTLToStore VAR_CertAddEncodedCTLToStore

LOADER_FUNCTION( BOOL, CryptMsgEncodeAndSignCTL,
    (DWORD dwMsgEncodingType, PCTL_INFO pCtlInfo, PCMSG_SIGNED_ENCODE_INFO pSignInfo,
     DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded),
    (dwMsgEncodingType, pCtlInfo, pSignInfo, dwFlags, pbEncoded, pcbEncoded),
    FALSE, Crypt32)
#define CryptMsgEncodeAndSignCTL VAR_CryptMsgEncodeAndSignCTL

LOADER_FUNCTION( PCCTL_CONTEXT, CertFindCTLInStore,
    (HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, DWORD dwFindFlags,
     DWORD dwFindType, const void *pvFindPara, PCCTL_CONTEXT pPrevCtlContext),
    (hCertStore, dwMsgAndCertEncodingType, dwFindFlags,
     dwFindType, pvFindPara, pPrevCtlContext),
    NULL, Crypt32)
#define CertFindCTLInStore VAR_CertFindCTLInStore

LOADER_FUNCTION( PCCTL_CONTEXT, CryptSignAndEncodeCertificate,
    (HCRYPTPROV hCryptProv, DWORD dwKeySpec, DWORD dwCertEncodingType,
     LPCSTR lpszStructType, const void *pvStructInfo,
     PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
     const void *pvHashAuxInfo, PBYTE pbEncoded, DWORD *pcbEncoded),
    (hCryptProv, dwKeySpec, dwCertEncodingType, lpszStructType,
     pvStructInfo, pSignatureAlgorithm, pvHashAuxInfo, pbEncoded,
     pcbEncoded),
    NULL, Crypt32)
#define CryptSignAndEncodeCertificate VAR_CryptSignAndEncodeCertificate

LOADER_FUNCTION( BOOL, CryptEncodeObject,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo,
     BYTE *pbEncoded, DWORD *pcbEncoded),
    (dwCertEncodingType, lpszStructType, pvStructInfo, pbEncoded,pcbEncoded),
    FALSE, Crypt32)
#define CryptEncodeObject VAR_CryptEncodeObject

LOADER_FUNCTION( BOOL, CryptExportPublicKeyInfo,
    (HCRYPTPROV hCryptProv, DWORD dwKeySpec, DWORD dwCertEncodingType,
     PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo),
    (hCryptProv, dwKeySpec, dwCertEncodingType, pInfo, pcbInfo),
    FALSE, Crypt32)
#define CryptExportPublicKeyInfo VAR_CryptExportPublicKeyInfo

LOADER_FUNCTION( HCERTSTORE, CertDuplicateStore,
    (HCERTSTORE hCertStore),
    (hCertStore),
    NULL, Crypt32)
#define CertDuplicateStore VAR_CertDuplicateStore

LOADER_FUNCTION( BOOL, CertAddEncodedCertificateToStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded,
     DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext),
    (hCertStore, dwCertEncodingType, pbCertEncoded,
     cbCertEncoded, dwAddDisposition, ppCertContext),
    FALSE, Crypt32)
#define CertAddEncodedCertificateToStore VAR_CertAddEncodedCertificateToStore

LOADER_FUNCTION( LONG, CertVerifyTimeValidity,
    (LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo),
    (pTimeToVerify, pCertInfo),
    +1, Crypt32)                // Return AFTER by default
#define CertVerifyTimeValidity VAR_CertVerifyTimeValidity

LOADER_FUNCTION( PCTL_ENTRY, CertFindSubjectInCTL,
    (DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject,
     PCCTL_CONTEXT pCtlContext, DWORD dwFlags),
    (dwEncodingType, dwSubjectType, pvSubject, pCtlContext, dwFlags),
    NULL, Crypt32)
#define CertFindSubjectInCTL VAR_CertFindSubjectInCTL

LOADER_FUNCTION( BOOL, CertVerifySubjectCertificateContext,
    (PCCERT_CONTEXT pSubject, PCCERT_CONTEXT pIssuer, DWORD *pdwFlags),
    (pSubject, pIssuer, pdwFlags),
    FALSE, Crypt32)
#define CertVerifySubjectCertificateContext VAR_CertVerifySubjectCertificateContext

LOADER_FUNCTION( BOOL, CertGetEnhancedKeyUsage,
    (PCCERT_CONTEXT pCertContext, DWORD dwFlags, PCERT_ENHKEY_USAGE pUsage,
     DWORD *pcbUsage),
    (pCertContext, dwFlags, pUsage, pcbUsage),
    FALSE, Crypt32)
#define CertGetEnhancedKeyUsage VAR_CertGetEnhancedKeyUsage

#if 0
LOADER_FUNCTION( BOOL, ,
    (),
    (),
    FALSE, Crypt32)
#define X VAR_
#endif // 0

/////////////////////////////////////
// ADVAPI32.DLL

#ifndef ALGIDDEF
    #define ALGIDDEF
    typedef unsigned int ALG_ID;
#endif

BOOL DemandLoadAdvApi32(void);

LOADER_FUNCTION( BOOL, CryptAcquireContextW,
    (HCRYPTPROV *phProv, LPCWSTR pszContainer, LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags),
    (phProv, pszContainer, pszProvider, dwProvType, dwFlags),
    FALSE, AdvApi32)
#define CryptAcquireContextW VAR_CryptAcquireContextW

#if 0
LOADER_FUNCTION( BOOL, CryptGetProvParam,
    (HCRYPTPROV hProv, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags),
    (hProv, dwParam, pbData, pdwDataLen, dwFlags),
    FALSE, AdvApi32)
#define CryptGetProvParam VAR_CryptGetProvParam

LOADER_FUNCTION( BOOL, CryptReleaseContext,
    (HCRYPTPROV hProv, DWORD dwFlags),
    (hProv, dwFlags),
    FALSE, AdvApi32)
#define CryptReleaseContext VAR_CryptReleaseContext

LOADER_FUNCTION( BOOL, CryptGenKey,
    (HCRYPTPROV hProv, ALG_ID Algid, DWORD dwFlags, HCRYPTKEY *phKey),
    (hProv, Algid, dwFlags, phKey),
    FALSE, AdvApi32)
#define CryptGenKey VAR_CryptGenKey

LOADER_FUNCTION( BOOL, CryptDestroyKey,
    (HCRYPTKEY hKey),
    (hKey),
    FALSE, AdvApi32)
#define CryptDestroyKey VAR_CryptDestroyKey
#endif // 0


#ifndef WIN16

/////////////////////////////////////
// USER32.DLL

BOOL DemandLoadUser32();

LOADER_FUNCTION( LRESULT, SendDlgItemMessageW,
    (HWND hwnd, int idCtl, UINT msg, WPARAM wparam, LPARAM lparam),
    (hwnd, idCtl, msg, wparam, lparam),
    -1, User32)
#define SendDlgItemMessageW VAR_SendDlgItemMessageW

LOADER_FUNCTION( BOOL, SetDlgItemTextW,
    (HWND hwnd, int idCtl, LPCWSTR psz),
    (hwnd, idCtl, psz),
    FALSE, User32)
#define SetDlgItemTextW VAR_SetDlgItemTextW

LOADER_FUNCTION( UINT, GetDlgItemTextW,
    (HWND hwnd, int idCtl, LPWSTR psz, int nMax),
    (hwnd, idCtl, psz, nMax),
    FALSE, User32)
#define GetDlgItemTextW VAR_GetDlgItemTextW

LOADER_FUNCTION( int, LoadStringW,
    (HINSTANCE hinst, UINT idStr, LPWSTR rgwch, int cwch),
    (hinst, idStr, rgwch, cwch),
    0, User32)
#define LoadStringW VAR_LoadStringW

LOADER_FUNCTION( DWORD, FormatMessageW,
    (DWORD dwFlags, LPCVOID pbSource, DWORD dwMessageId,
     DWORD dwLangId, LPWSTR lpBuffer, DWORD nSize, va_list * args),
    (dwFlags, pbSource, dwMessageId, dwLangId, lpBuffer, nSize, args),
    0, User32)
#define FormatMessageW VAR_FormatMessageW

LOADER_FUNCTION( BOOL, WinHelpW,
    (HWND hWndMain, LPCWSTR szHelp, UINT uCommand, ULONG_PTR dwData),
    (hWndMain, szHelp, uCommand, dwData),
    FALSE, User32)
#define WinHelpW VAR_WinHelpW

#endif // !WIN16

#else   // MAC
#define SendDlgItemMessageW MySendDlgItemMessageW
#define SetDlgItemTextW     MySetDlgItemTextW
#define GetDlgItemTextW     MyGetDlgItemTextW
#define LoadStringW         MyLoadStringW
#define FormatMessageW      MyFormatMessageW
#define WinHelpW            MyWinHelpW
#define SendMessageW        SendMessageA
#undef CertOpenStore
EXTERN_C WINCRYPT32API HCERTSTORE WINAPI MacCertOpenStore(LPCSTR lpszStoreProvider,
                                                 DWORD dwEncodingType,
                                                 HCRYPTPROV hCryptProv,
                                                 DWORD dwFlags,
                                                 const void *pvPara);
#define CertOpenStore   MacCertOpenStore
#endif  // !MAC
#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\gettrst.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       gettrst.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#include "wintrustp.h"
#include "crypthlp.h"

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
static BOOL IsUntrustedRootProblem(WINTRUST_DATA *pWTD)
{
    CRYPT_PROVIDER_DATA     *pProvData = NULL;
    CRYPT_PROVIDER_SGNR     *pProvSigner = NULL;
    CRYPT_PROVIDER_CERT     *pCryptProviderCert;
    DWORD                   i;
    
    pProvData = WTHelperProvDataFromStateData(pWTD->hWVTStateData);
    pProvSigner = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0);
        
    if (pProvSigner)
    {
        // get all certs in the chain
        for (i=0; i<pProvSigner->csCertChain; i++)
        {
            pCryptProviderCert = WTHelperGetProvCertFromChain(pProvSigner, i);
            if (pCryptProviderCert != NULL)
            {
                if (pCryptProviderCert->dwError != ERROR_SUCCESS)
                {
                    return FALSE;
                }
            }
            else
            {
                return FALSE;
            }
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
static DWORD GetFinalErrorFromChain(PCERT_VIEW_HELPER pviewhelp)
{
    int   i;
    DWORD   dwErr = 0;

    for (i=((int)pviewhelp->cpCryptProviderCerts)-1; i>= 0; i--) 
    {
        dwErr = pviewhelp->rgpCryptProviderCerts[i]->dwError;
        
        if (((dwErr == CERT_E_UNTRUSTEDROOT) || (dwErr == CERT_E_UNTRUSTEDTESTROOT)) && 
            (pviewhelp->fIgnoreUntrustedRoot))
        {
            dwErr = 0;
        }
        else if (dwErr != 0)
        {
            break;
        }
    }

    return dwErr;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
static void GetCertChainErrorString(PCERT_VIEW_HELPER pviewhelp)
{
    WCHAR   szErrorString[CRYPTUI_MAX_STRING_SIZE];
    DWORD   i;
    DWORD   dwChainError;
    
    //
    // free the error string if one already exists
    //
    if (pviewhelp->pwszErrorString != NULL)
    {
        free(pviewhelp->pwszErrorString);
        pviewhelp->pwszErrorString = NULL;
    }


    // If they ask to be warned about local/remote differences, 
    // always display this warning
    if (pviewhelp->fWarnRemoteTrust)
    {
        LoadStringU(HinstDll, IDS_WARNREMOTETRUST_ERROR, szErrorString, ARRAYSIZE(szErrorString));
        goto StringLoaded;
    } 
    
    //
    // if there was no over all chain error, then the only problem,
    // is if there are no usages
    //
    if (pviewhelp->dwChainError == 0)
    {
        if (pviewhelp->cUsages == NULL)
        {
            LoadStringU(HinstDll, IDS_NOVALIDUSAGES_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
        }
        else
        {
            return;
        }
    }

    if ((pviewhelp->dwChainError == CERT_E_UNTRUSTEDROOT) ||
        (pviewhelp->dwChainError == CERT_E_UNTRUSTEDTESTROOT))
    {
        //
        // if we are ignoring untrusted roots, then just return
        //
        if (pviewhelp->fIgnoreUntrustedRoot)
        {
            return;
        }

        //
        // if we are just warning the user about untrusted root AND the root
        // cert is in the remote root store then load that string
        //
        if (pviewhelp->fWarnUntrustedRoot && pviewhelp->fRootInRemoteStore)
        {
            //
            // if this is a root cert then show the error for a root
            //
            if (pviewhelp->cpCryptProviderCerts == 1 && (pviewhelp->rgpCryptProviderCerts[0])->fSelfSigned)
            {
                LoadStringU(HinstDll, IDS_WARNUNTRUSTEDROOT_ERROR_ROOTCERT, szErrorString, ARRAYSIZE(szErrorString));
            }
            else
            {
                LoadStringU(HinstDll, IDS_WARNUNTRUSTEDROOT_ERROR, szErrorString, ARRAYSIZE(szErrorString));
            }
        }
        else
        {
            //
            // if this is a root cert then show the error for a root
            //
            if (pviewhelp->cpCryptProviderCerts == 1 && (pviewhelp->rgpCryptProviderCerts[0])->fSelfSigned)
            {
                LoadStringU(HinstDll, IDS_UNTRUSTEDROOT_ROOTCERT_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
            }
            else
            {
                LoadStringU(HinstDll, IDS_UNTRUSTEDROOT_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
            }
        }
    }
    else if (pviewhelp->dwChainError == CERT_E_REVOKED)
    {
        LoadStringU(HinstDll, IDS_CERTREVOKED_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError == TRUST_E_CERT_SIGNATURE)
    {
        LoadStringU(HinstDll, IDS_CERTBADSIGNATURE_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError == CERT_E_EXPIRED)
    {
        LoadStringU(HinstDll, IDS_CERTEXPIRED_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError == CERT_E_VALIDITYPERIODNESTING)
    {
        LoadStringU(HinstDll, IDS_TIMENESTING_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError == CERT_E_WRONG_USAGE)
    {
        LoadStringU(HinstDll, IDS_WRONG_USAGE_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError == TRUST_E_BASIC_CONSTRAINTS)
    {
        LoadStringU(HinstDll, IDS_BASIC_CONSTRAINTS_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError == CERT_E_PURPOSE)
    {
        LoadStringU(HinstDll, IDS_PURPOSE_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError == CERT_E_REVOCATION_FAILURE)
    {
        LoadStringU(HinstDll, IDS_REVOCATION_FAILURE_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError == CERT_E_CHAINING)
    {
        LoadStringU(HinstDll, IDS_CANTBUILDCHAIN_ERROR_TREE, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError == TRUST_E_EXPLICIT_DISTRUST)
    {
        LoadStringU(HinstDll, IDS_EXPLICITDISTRUST_ERROR, szErrorString, ARRAYSIZE(szErrorString));
    }
    else if (pviewhelp->dwChainError != 0)
    {
        //
        // this is not an error we know about, so call the general
        // error string function
        //
        GetUnknownErrorString(&(pviewhelp->pwszErrorString), pviewhelp->dwChainError);
    }

StringLoaded:
    
    if (pviewhelp->pwszErrorString == NULL)
    {
        pviewhelp->pwszErrorString = AllocAndCopyWStr(szErrorString);
    }
}

// Returned string must be freed via LocalFree()
LPWSTR
FormatRevocationStatus(
    IN PCERT_CHAIN_ELEMENT pElement
    )
{
    LPWSTR pwszRevStatus = NULL;
    UINT ids = IDS_REV_STATUS_UNKNOWN_ERROR;
    static const WCHAR wszNoTime[] = L"...";
    LPWSTR pwszArg1 = (LPWSTR) wszNoTime;
    LPWSTR pwszArg2 = (LPWSTR) wszNoTime;
    LPWSTR pwszTime1 = NULL;
    LPWSTR pwszTime2 = NULL;
    LPWSTR pwszErrStr = NULL;
    DWORD dwRevResult;
    PCERT_REVOCATION_INFO pRevInfo;
    PCERT_REVOCATION_CRL_INFO pCrlInfo;

    pRevInfo = pElement->pRevocationInfo;
    if (NULL == pRevInfo)
        return NULL;

    dwRevResult = pRevInfo->dwRevocationResult;
    pCrlInfo = pRevInfo->pCrlInfo;

    switch (dwRevResult) {
        case ERROR_SUCCESS:
            ids = IDS_REV_STATUS_OK;
            // Fall through
        case CRYPT_E_REVOCATION_OFFLINE:
            if (pCrlInfo) {
                PCCRL_CONTEXT pCrl;

                pCrl = pCrlInfo->pDeltaCrlContext;
                if (NULL == pCrl)
                    pCrl = pCrlInfo->pBaseCrlContext;
                if (pCrl) {
                    BOOL fFormatDate;

                    fFormatDate = FormatDateString(
                        &pwszTime1, 
                        pCrl->pCrlInfo->ThisUpdate,
                        TRUE,               // fIncludeTime
                        TRUE,               // fLongFormat
                        NULL                // hwnd
                        );
                    if (fFormatDate) {
                        pwszArg1 = pwszTime1;

                        if (I_CryptIsZeroFileTime(&pCrl->pCrlInfo->NextUpdate))
                            pwszArg2 = (LPWSTR) wszNoTime;
                        else {
                            fFormatDate = FormatDateString(
                                &pwszTime2, 
                                pCrl->pCrlInfo->NextUpdate,
                                TRUE,               // fIncludeTime
                                TRUE,               // fLongFormat
                                NULL                // hwnd
                                );
                            if (fFormatDate)
                                pwszArg2 = pwszTime2;
                        }
                    }

                    if (fFormatDate) {
                        switch (dwRevResult) {
                            case ERROR_SUCCESS:
                                ids = IDS_REV_STATUS_OK_WITH_CRL;
                                break;
                            case CRYPT_E_REVOCATION_OFFLINE:
                                ids = IDS_REV_STATUS_OFFLINE_WITH_CRL;
                                break;
                        }
                    }
                }
            }
            break;

        case CRYPT_E_REVOKED:
            if (pCrlInfo && pCrlInfo->pCrlEntry) {
                if (FormatDateString(
                        &pwszTime1, 
                        pCrlInfo->pCrlEntry->RevocationDate,
                        TRUE,               // fIncludeTime
                        TRUE,               // fLongFormat
                        NULL                // hwnd
                        )) {
                    ids = IDS_REV_STATUS_REVOKED_ON;
                    pwszArg1 = pwszTime1;
                }
            }
            break;

        default:
            break;
    }

    if (IDS_REV_STATUS_UNKNOWN_ERROR == ids) {
        GetUnknownErrorString(&pwszErrStr, dwRevResult);
        if (NULL == pwszErrStr)
            goto CommonReturn;
        pwszArg1 = pwszErrStr;
    }

    pwszRevStatus = FormatMessageUnicodeIds(ids, pwszArg1, pwszArg2);
CommonReturn:
    if (pwszTime1)
        free(pwszTime1);
    if (pwszTime2)
        free(pwszTime2);
    if (pwszErrStr)
        free(pwszErrStr);

    return pwszRevStatus;
}



//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL BuildChain(
        PCERT_VIEW_HELPER   pviewhelp, 
        LPSTR               pszUsage)
{
    CRYPT_PROVIDER_DATA const *         pProvData = NULL;
    CRYPT_PROVIDER_SGNR       *         pProvSigner = NULL;
    DWORD                               i;
    GUID                                defaultProviderGUID = WINTRUST_ACTION_GENERIC_CERT_VERIFY;
    HRESULT                             hr = ERROR_SUCCESS;
    BOOL                                fInternalError = FALSE;
    DWORD                               dwStartIndex;
    BOOL                                fRet = TRUE;
    PCCRYPTUI_VIEWCERTIFICATE_STRUCTW   pcvp = pviewhelp->pcvp;
    WCHAR                               szErrorString[CRYPTUI_MAX_STRING_SIZE];

    //
    // if there was previous chain state then free that before building
    // the new chain
    //
    if (pviewhelp->fFreeWTD)
    {
        pviewhelp->sWTD.dwStateAction = WTD_STATEACTION_CLOSE;
        WinVerifyTrustEx(NULL, &defaultProviderGUID, &(pviewhelp->sWTD));
    }

    pviewhelp->cpCryptProviderCerts = 0;
    pviewhelp->fFreeWTD = FALSE;

    //
    // initialize structs that are used with WinVerifyTrust()
    //
    memset(&(pviewhelp->sWTD), 0x00, sizeof(WINTRUST_DATA));
    pviewhelp->sWTD.cbStruct       = sizeof(WINTRUST_DATA);
    pviewhelp->sWTD.dwUIChoice     = WTD_UI_NONE;
    pviewhelp->sWTD.dwUnionChoice  = WTD_CHOICE_CERT;
    pviewhelp->sWTD.pCert          = &(pviewhelp->sWTCI);
    pviewhelp->sWTD.dwProvFlags    = (pszUsage == NULL) ? WTD_NO_POLICY_USAGE_FLAG : 0;
    if (pcvp->dwFlags & CRYPTUI_ENABLE_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT)
    {
        pviewhelp->sWTD.dwProvFlags |= WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    }
    else if (pcvp->dwFlags & CRYPTUI_ENABLE_REVOCATION_CHECK_END_CERT)
    {
        pviewhelp->sWTD.dwProvFlags |= WTD_REVOCATION_CHECK_END_CERT;
    }
    else if (pcvp->dwFlags & CRYPTUI_ENABLE_REVOCATION_CHECK_CHAIN)
    {
        pviewhelp->sWTD.dwProvFlags |= WTD_REVOCATION_CHECK_CHAIN;
    }
    else
    {
        pviewhelp->sWTD.dwProvFlags |= WTD_REVOCATION_CHECK_NONE;
    }

    memset(&(pviewhelp->sWTCI), 0x00, sizeof(WINTRUST_CERT_INFO));
    pviewhelp->sWTCI.cbStruct          = sizeof(WINTRUST_CERT_INFO);
    pviewhelp->sWTCI.pcwszDisplayName  = L"CryptUI";
    pviewhelp->sWTCI.psCertContext     = (CERT_CONTEXT *)pcvp->pCertContext;  
    pviewhelp->sWTCI.chStores          = pcvp->cStores;
    pviewhelp->sWTCI.pahStores         = pcvp->rghStores;
    pviewhelp->sWTCI.dwFlags           |= (pcvp->dwFlags & CRYPTUI_DONT_OPEN_STORES) ? WTCI_DONT_OPEN_STORES : 0;
    pviewhelp->sWTCI.dwFlags           |= (pcvp->dwFlags & CRYPTUI_ONLY_OPEN_ROOT_STORE) ? WTCI_OPEN_ONLY_ROOT : 0;

    //
    // if a provider was passed in, then use it to build the chain,
    // otherwise use the default provider to build the chain
    //
    if (pcvp->pCryptProviderData != NULL)
    {
        pProvData = pcvp->pCryptProviderData; 
        
    }
    else
    {
        pviewhelp->sWTD.dwStateAction = WTD_STATEACTION_VERIFY;
        
        //
        // the default default provider requires the policycallback data to point
        // to the usage oid you are validating for, so set it to the usage passed in
        //
        pviewhelp->sWTD.pPolicyCallbackData = pszUsage;
        pviewhelp->sWTD.pSIPClientData = NULL;
        hr = WinVerifyTrustEx(NULL, &defaultProviderGUID, &(pviewhelp->sWTD));

        pProvData = WTHelperProvDataFromStateData(pviewhelp->sWTD.hWVTStateData);
        if (WTHelperGetProvSignerFromChain((PCRYPT_PROVIDER_DATA) pProvData, 0, FALSE, 0) != NULL)
        {
            pviewhelp->fFreeWTD = TRUE;
            fInternalError = FALSE;
        }
        else
        {
            pviewhelp->fFreeWTD = FALSE;
            pviewhelp->sWTD.dwStateAction = WTD_STATEACTION_CLOSE;
            WinVerifyTrustEx(NULL, &defaultProviderGUID, &(pviewhelp->sWTD));
            fInternalError = TRUE;
        }
    }

    if (pProvData && !fInternalError)
    {
        //
        // set the chain error in the helper struct
        //
        pviewhelp->dwChainError = pProvData->dwFinalError;
        
        //
        // This is to catch internal WinVerifyTrust errors 
        //
        if ((pviewhelp->dwChainError == 0) && (FAILED(hr)))
        {
            pviewhelp->dwChainError = (DWORD) hr;
        }

        //
        // if the WinTrust state was passed into the certUI then use that for 
        // the chain, else, get it from the state that was just built
        //
        if (pcvp->pCryptProviderData != NULL)
        {
            pProvSigner = WTHelperGetProvSignerFromChain(
                                    (PCRYPT_PROVIDER_DATA) pProvData, 
                                    pcvp->idxSigner, 
                                    pcvp->fCounterSigner, 
                                    pcvp->idxCounterSigner);
            
            dwStartIndex = pcvp->idxCert;
        }
        else
        {
            pProvSigner = WTHelperGetProvSignerFromChain((PCRYPT_PROVIDER_DATA) pProvData, 0, FALSE, 0);
            dwStartIndex = 0;
        }
    
        if (pProvSigner)
        {
            //
            // get all certs in the chain
            //
            for (i=dwStartIndex; i<pProvSigner->csCertChain && (i<dwStartIndex+MAX_CERT_CHAIN_LENGTH); i++)
            {
                pviewhelp->rgpCryptProviderCerts[pviewhelp->cpCryptProviderCerts] = WTHelperGetProvCertFromChain(pProvSigner, i);
                if (pviewhelp->rgpCryptProviderCerts[pviewhelp->cpCryptProviderCerts] != NULL)
                {
                    // Note, only modify this property when creating the
                    // chain for the original end cert. Subsequent CA
                    // chains won't have the ExtendedErrorInfo.

                    if ((pcvp->dwFlags & CRYPTUI_TREEVIEW_PAGE_FLAG) == 0)
                    {
                        // Either delete or set the
                        // CERT_EXTENDED_ERROR_INFO_PROP_ID

                        // This is used in cvdetail.cpp when displaying
                        // property details

                        PCRYPT_PROVIDER_CERT pProvCert =
                            pviewhelp->rgpCryptProviderCerts[
                                pviewhelp->cpCryptProviderCerts];

                        LPWSTR pwszExtErrorInfo = NULL; // not allocated
                        LPWSTR pwszRevStatus = NULL;    // LocalAlloc()'ed

                        if (pProvCert->cbStruct >
                                offsetof(CRYPT_PROVIDER_CERT, pChainElement)
                                        &&
                                NULL != pProvCert->pChainElement)
                        {
                            pwszExtErrorInfo = (LPWSTR)
                                pProvCert->pChainElement->pwszExtendedErrorInfo;
                            pwszRevStatus = FormatRevocationStatus(
                                pProvCert->pChainElement);

                            if (NULL == pwszExtErrorInfo)
                            {
                                pwszExtErrorInfo = pwszRevStatus;
                            }
                            else if (pwszRevStatus)
                            {
                                LPWSTR pwszReAlloc;
                                DWORD cchRevStatus;
                                DWORD cchExtErrorInfo;

                                cchRevStatus = wcslen(pwszRevStatus);
                                cchExtErrorInfo = wcslen(pwszExtErrorInfo);
                                pwszReAlloc = (LPWSTR) LocalReAlloc(
                                    pwszRevStatus,
                                    (cchRevStatus + cchExtErrorInfo + 1) *
                                        sizeof(WCHAR),
                                    LMEM_MOVEABLE);
                                if (pwszReAlloc)
                                {
                                    memcpy(&pwszReAlloc[cchRevStatus],
                                        pwszExtErrorInfo,
                                        (cchExtErrorInfo + 1) * sizeof(WCHAR));
                                    pwszExtErrorInfo = pwszRevStatus =
                                        pwszReAlloc;
                                }
                            }
                        }
                
                        if (pwszExtErrorInfo)
                        {
                            CRYPT_DATA_BLOB ExtErrorInfoBlob;

                            ExtErrorInfoBlob.pbData = (BYTE *) pwszExtErrorInfo;
                            ExtErrorInfoBlob.cbData =
                                (wcslen(pwszExtErrorInfo) + 1) * sizeof(WCHAR);

                            CertSetCertificateContextProperty(
                                pProvCert->pCert,
                                CERT_EXTENDED_ERROR_INFO_PROP_ID,
                                CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG,
                                &ExtErrorInfoBlob
                                );
                        }
                        else
                        {
                            CertSetCertificateContextProperty(
                                pProvCert->pCert,
                                CERT_EXTENDED_ERROR_INFO_PROP_ID,
                                CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG,
                                NULL            // pvData, NULL implies delete
                                );
                        }

                        if (pwszRevStatus)
                            LocalFree(pwszRevStatus);
                    }


                    pviewhelp->cpCryptProviderCerts++;
                }
            }
        }
    }
    
    CalculateUsages(pviewhelp);

    //
    // if the cert we are looking at is not the leaf cert, then we can't just take the
    // dwFinalError as the overall chain error, so find the over all chain error by
    // walking the chain and looking at the errors
    //
    if ((pcvp->pCryptProviderData != NULL) && (pcvp->idxCert != 0))
    {
        pviewhelp->dwChainError = GetFinalErrorFromChain(pviewhelp);  
    }

    //
    // if we are in the fWarnUntrustedRoot then check to see if the root cert is in the
    // remote machine's root store
    //
    if (pviewhelp->fWarnUntrustedRoot)
    {
        PCCERT_CONTEXT  pCertContext = NULL;
        CRYPT_HASH_BLOB cryptHashBlob;
        BYTE            hash[20];
        DWORD           cb = 20;

        pviewhelp->fRootInRemoteStore = FALSE;

        cryptHashBlob.cbData = 20;
        cryptHashBlob.pbData = &(hash[0]);

        if (CertGetCertificateContextProperty(
                pviewhelp->rgpCryptProviderCerts[pviewhelp->cpCryptProviderCerts-1]->pCert,
                CERT_SHA1_HASH_PROP_ID,
                &(hash[0]),
                &cb))
        {

        
            pCertContext = CertFindCertificateInStore(
                                pviewhelp->pcvp->rghStores[0],
                                X509_ASN_ENCODING || PKCS_7_ASN_ENCODING,
                                0,
                                CERT_FIND_SHA1_HASH,
                                &cryptHashBlob,
                                NULL);

            if (pCertContext != NULL)
            {
                CertFreeCertificateContext(pCertContext);
                pviewhelp->fRootInRemoteStore = TRUE;
            }
        }
    }

    //
    // get the error string for the whole cert chain
    //
    if (!fInternalError)
    {
        GetCertChainErrorString(pviewhelp);
    }
    else
    {
        LoadStringU(HinstDll, IDS_INTERNAL_ERROR, szErrorString, ARRAYSIZE(szErrorString));
        pviewhelp->pwszErrorString = AllocAndCopyWStr(szErrorString);
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL CalculateUsages(PCERT_VIEW_HELPER pviewhelp)
{
    DWORD                               cLocalArrayOfUsages = 0;
    LPSTR                     *         localArrayOfUsages = NULL;
    BOOL                                fLocalUsagesAllocated = FALSE;
    DWORD                               i;
    HRESULT                             hr;
    BOOL                                fRet = TRUE;
    PCCRYPTUI_VIEWCERTIFICATE_STRUCTW   pcvp = pviewhelp->pcvp;
    void                                *pTemp;

    //
    // if there are already usages, then clean them up before recalculating them, 
    // or just return if state was passed into CertUI
    //
    if (pviewhelp->cUsages != 0)
    {
        //
        // state was passed into the CertUI, so just return
        //
        if (pcvp->pCryptProviderData != NULL)
        {
            return TRUE;
        }

        //
        // cleanup usages that were generated prior to this call
        //
        for (i=0; i<pviewhelp->cUsages; i++)
        {
            free(pviewhelp->rgUsages[i]);
        }

        free(pviewhelp->rgUsages);   
    }

    //
    // initialize usage variables
    //
    pviewhelp->cUsages = 0;
    pviewhelp->rgUsages = NULL;
    
    //
    // if a provider was passed in, then we just look at it for the usage and structure
    // passed in for the trust of that usage,
    // otherwise we need to look at each usage and validate trust for all of them
    //
    if (pcvp->pCryptProviderData != NULL)
    {
        //
        // allocate an array of 1 LPSTR
        //
        if (NULL == (pviewhelp->rgUsages = (LPSTR *) malloc(sizeof(LPSTR))))
        {
            SetLastError(E_OUTOFMEMORY);
            return FALSE;
        }

        //
        // copy either the 1 purpose that was passed in, or the purpose out of WinTrust state
        //
        if (pcvp->cPurposes == 1)
        {
            if (NULL == (pviewhelp->rgUsages[0] = (LPSTR) malloc(strlen(pcvp->rgszPurposes[0])+1)))
            {
                SetLastError(E_OUTOFMEMORY);
                return FALSE;
            }
            strcpy(pviewhelp->rgUsages[0], pcvp->rgszPurposes[0]);
        }
        else
        {
            if (NULL == (pviewhelp->rgUsages[0] = (LPSTR) malloc(strlen(pcvp->pCryptProviderData->pszUsageOID)+1)))
            {
                SetLastError(E_OUTOFMEMORY);
                return FALSE;
            }
            strcpy(pviewhelp->rgUsages[0], pcvp->pCryptProviderData->pszUsageOID);
        }

        pviewhelp->cUsages = 1;
    }
    else
    {
        //
        // check to see if usages where passed in, if so, then intersect those with 
        // available usages in the cert, otherwise, get the available usages in the cert
        // and use them as is 
        //
        if (pcvp->cPurposes != 0)
        {
            //
            // get the array of possible usages for the cert chain
            //

            // DSIE: Switch over to using pChainElement from philh's new chain building code.
            AllocAndReturnKeyUsageList(pviewhelp->rgpCryptProviderCerts[0], &localArrayOfUsages, &cLocalArrayOfUsages);  

            if (cLocalArrayOfUsages != 0)
                fLocalUsagesAllocated = TRUE;

            //
            // for each usage that was passed in check to see if it is in the list of possible usages
            //
            for (i=0; i<pcvp->cPurposes; i++)
            {   
                if (OIDinArray(pcvp->rgszPurposes[i], localArrayOfUsages, cLocalArrayOfUsages))
                {
                    //
                    // if an array hasn't yet been allocated, then allocate space for an array of
                    // 1 LPSTR, otherwise use realloc to add one more element
                    //
                    if (pviewhelp->rgUsages == NULL)
                    {
                        pviewhelp->rgUsages = (LPSTR *) malloc(sizeof(LPSTR));
                    }
                    else
                    {
                        pTemp = realloc(pviewhelp->rgUsages, sizeof(LPSTR) * (pviewhelp->cUsages+1));
                        if (pTemp == NULL)
                        {
                            free(pviewhelp->rgUsages);
                            pviewhelp->rgUsages = NULL;
                        }
                        else
                        {
                            pviewhelp->rgUsages = (LPSTR *) pTemp;
                        }
                    }

                    if (pviewhelp->rgUsages == NULL)
                    {
                        goto ErrorCleanUp;
                    }

                    //
                    // allocate space for the usage string, then copy it, and increment number of usages
                    //
                    if (NULL == (pviewhelp->rgUsages[pviewhelp->cUsages] = (LPSTR) malloc(strlen(pcvp->rgszPurposes[i])+1)))
                    {       
                        SetLastError(E_OUTOFMEMORY);
                        goto ErrorCleanUp;
                    }       
                    strcpy(pviewhelp->rgUsages[pviewhelp->cUsages], pcvp->rgszPurposes[i]);
                    pviewhelp->cUsages++;
                }
            }
        }
        else
        {
            AllocAndReturnKeyUsageList(pviewhelp->rgpCryptProviderCerts[0], &(pviewhelp->rgUsages), &(pviewhelp->cUsages));  
        }
    }

CleanUp:

    
    if (fLocalUsagesAllocated)
    {
        i = 0;
        while ((i < cLocalArrayOfUsages) && (localArrayOfUsages[i] != NULL))
        {
            free(localArrayOfUsages[i]);
            i++;
        }

        free(localArrayOfUsages);
    }

    return fRet;

ErrorCleanUp:

    if (pviewhelp->rgUsages != NULL)
    {
        i = 0;
        while ((i < pviewhelp->cUsages) && (pviewhelp->rgUsages[i] != NULL))
        {
            free(pviewhelp->rgUsages[i]);
            i++;
        }

        free(pviewhelp->rgUsages); 
    }

    fRet = FALSE;
    goto CleanUp;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL BuildWinVTrustState(
                    LPCWSTR                         szFileName, 
                    CMSG_SIGNER_INFO const          *pSignerInfo,
                    DWORD                           cStores, 
                    HCERTSTORE                      *rghStores, 
                    LPCSTR                          pszOID,
                    PCERT_VIEWSIGNERINFO_PRIVATE    pcvsiPrivate, 
                    CRYPT_PROVIDER_DEFUSAGE         *pCryptProviderDefUsage,
                    WINTRUST_DATA                   *pWTD)
{
    WINTRUST_FILE_INFO      WTFI;
    WINTRUST_SGNR_INFO      WTSI;
    HRESULT                 hr;
    GUID                    defaultProviderGUID = WINTRUST_ACTION_GENERIC_CERT_VERIFY;

    //
    // initialize structs that are used locally with WinVerifyTrust()
    //
    memset(pWTD, 0x00, sizeof(WINTRUST_DATA));
    pWTD->cbStruct       = sizeof(WINTRUST_DATA);
    pWTD->dwUIChoice     = WTD_UI_NONE;

    //
    // if the szFileName parameter is non NULL then this for a file,
    // otherwise it is for a signer info
    //
    if (szFileName != NULL)
    {
        pWTD->dwUnionChoice         = WTD_CHOICE_FILE;
        pWTD->pFile                 = &WTFI;
        pWTD->pPolicyCallbackData   = (void *) pszOID;

        memset(&WTFI, 0x00, sizeof(WINTRUST_FILE_INFO));
        WTFI.cbStruct          = sizeof(WINTRUST_FILE_INFO);
        WTFI.pcwszFilePath     = szFileName;
    }
    else
    {
        pWTD->dwUnionChoice         = WTD_CHOICE_SIGNER;
        pWTD->pSgnr                 = &WTSI;
        pWTD->pPolicyCallbackData   = (void *) pszOID;
        
        memset(&WTSI, 0x00, sizeof(WINTRUST_SGNR_INFO));
        WTSI.cbStruct          = sizeof(WINTRUST_SGNR_INFO);
        WTSI.pcwszDisplayName  = L"CryptUI";
        WTSI.psSignerInfo      = (CMSG_SIGNER_INFO *) pSignerInfo;  
        WTSI.chStores          = cStores;
        WTSI.pahStores         = rghStores;
        //WTSI.pszOID            = pszOID;
    }
    
    pWTD->pSIPClientData = NULL;
    pWTD->dwStateAction = WTD_STATEACTION_VERIFY;
    hr = WinVerifyTrustEx(NULL, &defaultProviderGUID, pWTD);
    if (hr == ERROR_SUCCESS)
    {
        pcvsiPrivate->fpCryptProviderDataTrustedUsage = TRUE;   
    }
    else
    {
        pcvsiPrivate->fpCryptProviderDataTrustedUsage = FALSE;   
    }
    
    pcvsiPrivate->pCryptProviderData = WTHelperProvDataFromStateData(pWTD->hWVTStateData);

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL FreeWinVTrustState(
                    LPCWSTR                         szFileName, 
                    CMSG_SIGNER_INFO const          *pSignerInfo,
                    DWORD                           cStores, 
                    HCERTSTORE                      *rghStores, 
                    LPCSTR                          pszOID,
                    CRYPT_PROVIDER_DEFUSAGE         *pCryptProviderDefUsage,
                    WINTRUST_DATA                   *pWTD)//,
                    //BOOL                            *pfUseDefaultProvider)
{
    WINTRUST_FILE_INFO      WTFI;
    WINTRUST_SGNR_INFO      WTSI;
    HRESULT                 hr;
    GUID                    defaultProviderGUID = WINTRUST_ACTION_GENERIC_CERT_VERIFY;

    // initialize structs that are used locally with WinVerifyTrust()
    memset(pWTD, 0x00, sizeof(WINTRUST_DATA));
    pWTD->cbStruct       = sizeof(WINTRUST_DATA);
    pWTD->dwUIChoice     = WTD_UI_NONE;
    
    //
    // if the szFileName parameter is non NULL then this for a file,
    // otherwise it is for a signer info
    //
    if (szFileName != NULL)
    {
        pWTD->dwUnionChoice  = WTD_CHOICE_FILE;
        pWTD->pFile          = &WTFI;

        memset(&WTFI, 0x00, sizeof(WINTRUST_FILE_INFO));
        WTFI.cbStruct          = sizeof(WINTRUST_FILE_INFO);
        WTFI.pcwszFilePath     = szFileName;
    }
    else
    {
        pWTD->dwUnionChoice  = WTD_CHOICE_SIGNER;
        pWTD->pSgnr          = &WTSI;

        memset(&WTSI, 0x00, sizeof(WINTRUST_SGNR_INFO));
        WTSI.cbStruct          = sizeof(WINTRUST_SGNR_INFO);
        WTSI.psSignerInfo      = (CMSG_SIGNER_INFO *) pSignerInfo;
        WTSI.chStores          = cStores;
        WTSI.pahStores         = rghStores;
    }

    /*if (*pfUseDefaultProvider)
    {
        pWTD->dwStateAction = WTD_STATEACTION_CLOSE;
        WinVerifyTrustEx(NULL, &defaultProviderGUID, pWTD);
    }
    else
    {*/
        pWTD->dwStateAction = WTD_STATEACTION_CLOSE;
        WinVerifyTrustEx(NULL, &(pCryptProviderDefUsage->gActionID), pWTD);
        WintrustGetDefaultForUsage(DWACTION_FREE, pszOID, pCryptProviderDefUsage);
    //}

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\frmtutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       frmtutil.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;

///////////////////////////////////////////////////////

const WCHAR     RgwchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

const CHAR      RgchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                             '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL FormatAlgorithmString(LPWSTR *ppString, CRYPT_ALGORITHM_IDENTIFIER const *pAlgorithm)
{
    PCCRYPT_OID_INFO pOIDInfo;
    
    pOIDInfo = CryptFindOIDInfo(
                    CRYPT_OID_INFO_OID_KEY,
                    pAlgorithm->pszObjId,
                    0);

    if (pOIDInfo != NULL)
    {
        if (NULL == (*ppString = AllocAndCopyWStr((LPWSTR) pOIDInfo->pwszName)))
        {
            return FALSE;

        }
    }
    else
    {
        if (NULL == (*ppString = CertUIMkWStr(pAlgorithm->pszObjId)))
        {
            return FALSE;

        }
    }
        
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL FormatDateString(LPWSTR *ppString, FILETIME ft, BOOL fIncludeTime, BOOL fLongFormat, HWND hwnd)
{
    int                 cch;
    int                 cch2;
    LPWSTR              psz;
    SYSTEMTIME          st;
    FILETIME            localTime;
    DWORD               locale;
    BOOL                bRTLLocale;
    DWORD               dwFlags = fLongFormat ? DATE_LONGDATE : 0;

    //  See if the user locale id is RTL (Arabic, Urdu, Farsi or Hebrew).
    locale     = GetUserDefaultLCID();
    bRTLLocale = (	(PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC) ||
   			        (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_URDU)   ||
   			        (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_FARSI)  ||
                	(PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW)
		         );
    locale = MAKELCID( MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), SORT_DEFAULT) ;

    if (bRTLLocale && (hwnd != NULL))
    {
       //Get the date format that matches the edit control reading direction.
       if (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_RTLREADING) {
           dwFlags |= DATE_RTLREADING;
       } else {
           dwFlags |= DATE_LTRREADING;
       }
    }

    if (!FileTimeToLocalFileTime(&ft, &localTime))
    {
        return FALSE;
    }
    
    if (!FileTimeToSystemTime(&localTime, &st)) 
    {
        //
        // if the conversion to local time failed, then just use the original time
        //
        if (!FileTimeToSystemTime(&ft, &st)) 
        {
            return FALSE;
        }
        
    }

    cch = (GetTimeFormatU(LOCALE_USER_DEFAULT, 0, &st, NULL, NULL, 0) +
           GetDateFormatU(locale, dwFlags, &st, NULL, NULL, 0) + 5);

    if (NULL == (psz = (LPWSTR) malloc((cch+5) * sizeof(WCHAR))))
    {
        return FALSE;
    }
    
    cch2 = GetDateFormatU(locale, dwFlags, &st, NULL, psz, cch);

    if (fIncludeTime)
    {
        psz[cch2-1] = ' ';
        GetTimeFormatU(LOCALE_USER_DEFAULT, 0, &st, NULL, 
                       &psz[cch2], cch-cch2);
    }
    
    *ppString = psz;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL FormatValidityString(LPWSTR *ppString, PCCERT_CONTEXT pCertContext, HWND hwnd)
{
    WCHAR   szText[256];
    LPWSTR  pwszReturnText;
    LPWSTR  pwszText;
    void    *pTemp;

    *ppString = NULL;
    
    LoadStringU(HinstDll, IDS_VALIDFROM, szText, ARRAYSIZE(szText));

    if (NULL == (pwszReturnText = AllocAndCopyWStr(szText)))
    {
        return FALSE;
    }
    
    if (!FormatDateString(&pwszText, pCertContext->pCertInfo->NotBefore, FALSE, FALSE, hwnd))
    {
        free(pwszReturnText);
        return FALSE;
    }

    if (NULL == (pTemp = realloc(pwszReturnText, (wcslen(pwszReturnText)+wcslen(pwszText)+3) * sizeof(WCHAR))))
    {
        free(pwszText);
        free(pwszReturnText);
        return FALSE;
    }
    pwszReturnText = (LPWSTR) pTemp;
    wcscat(pwszReturnText, L"  ");
    wcscat(pwszReturnText, pwszText);
    free(pwszText);
    pwszText = NULL;

    LoadStringU(HinstDll, IDS_VALIDTO, szText, ARRAYSIZE(szText));

    if (NULL == (pTemp = realloc(pwszReturnText, (wcslen(pwszReturnText)+wcslen(szText)+3) * sizeof(WCHAR))))
    {
        free(pwszReturnText);
        return FALSE;
    }
    pwszReturnText = (LPWSTR) pTemp;
    wcscat(pwszReturnText, L"  ");
    wcscat(pwszReturnText, szText);

    if (!FormatDateString(&pwszText, pCertContext->pCertInfo->NotAfter, FALSE, FALSE, hwnd))
    {
        free(pwszReturnText);
        return FALSE;
    }

    if (NULL == (pTemp = realloc(pwszReturnText, (wcslen(pwszReturnText)+wcslen(pwszText)+3) * sizeof(WCHAR))))
    {
        free(pwszText);
        free(pwszReturnText);
        return FALSE;
    }
    pwszReturnText = (LPWSTR) pTemp;
    wcscat(pwszReturnText, L"  ");
    wcscat(pwszReturnText, pwszText);
    free(pwszText);

    *ppString = pwszReturnText;
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL FormatSerialNoString(LPWSTR *ppString, CRYPT_INTEGER_BLOB const *pblob)
{
    DWORD                 i = 0;
    LPBYTE                pb;

    //DSIE: Bug 54159.
    //      To solve the problem, we need to put the Left-To-Right marker (0x200e),
    //      if complex script is supported, at the beginning of the Unicode string, 
    //      so that it will always be displayed as US string (left-to-right).
#if (0)
    if (NULL == (*ppString = (LPWSTR) malloc((pblob->cbData * 3) * sizeof(WCHAR))))
    {
        return FALSE;
    }

    // fill the buffer
    pb = &pblob->pbData[pblob->cbData-1];
    while (pb >= &pblob->pbData[0]) 
    {
        (*ppString)[i++] = RgwchHex[(*pb & 0xf0) >> 4];
        (*ppString)[i++] = RgwchHex[*pb & 0x0f];
        (*ppString)[i++] = L' ';
        pb--;                    
    }
    (*ppString)[--i] = 0;
#else
    HMODULE hModule  = NULL;
    DWORD   dwLength = pblob->cbData * 3;

    // See if complex script is supported.
    if (hModule = GetModuleHandle("LPK.DLL"))
    {
        dwLength++;
    }

    if (NULL == (*ppString = (LPWSTR) malloc(dwLength * sizeof(WCHAR))))
    {
        return FALSE;
    }

    // The marker will be changed back to NULL if no data to format.
    if (hModule)
    {
        (*ppString)[i++] = (WCHAR) 0x200e;
    }

    // fill the buffer
    pb = &pblob->pbData[pblob->cbData-1];
    while (pb >= &pblob->pbData[0]) 
    {
        (*ppString)[i++] = RgwchHex[(*pb & 0xf0) >> 4];
        (*ppString)[i++] = RgwchHex[*pb & 0x0f];
        (*ppString)[i++] = L' ';
        pb--;                    
    }
    (*ppString)[--i] = 0;
#endif
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
#define NUM_HEXBYTES_PERLINE    8
#define NUM_CHARS_PERLINE       ((NUM_HEXBYTES_PERLINE*2) + (NUM_HEXBYTES_PERLINE-1) + 3 + NUM_HEXBYTES_PERLINE + 2)
//                              (two hex digits per byte) + (space between each byte)+ (3 spaces) + (an ascci char per byte) + \n

BOOL FormatMemBufToWindow(HWND hWnd, LPBYTE pbData, DWORD cbData)
{   
    DWORD   i = 0;
    LPBYTE  pb;
    LPSTR   pszBuffer;
    DWORD   cbBuffer;
    char    szHexText[(NUM_HEXBYTES_PERLINE*2) + NUM_HEXBYTES_PERLINE];
    DWORD   dwHexTextIndex = 0;
    char    szASCIIText[NUM_HEXBYTES_PERLINE+1];
    DWORD   dwASCIITextIndex = 0;
    BYTE    *pbBuffer;

    cbBuffer = ((cbData+NUM_HEXBYTES_PERLINE-1) / NUM_HEXBYTES_PERLINE) * NUM_CHARS_PERLINE + 1;
    if (NULL == (pszBuffer = (LPSTR) malloc(cbBuffer)))
    {
        return FALSE;
    }

    pszBuffer[0] = 0;
    pbBuffer = (BYTE *) &pszBuffer[0];

    szHexText[(NUM_HEXBYTES_PERLINE*2) + NUM_HEXBYTES_PERLINE-1] = 0;
    szASCIIText[NUM_HEXBYTES_PERLINE] = 0;

#if (1) //DSIE: bug 262252
	if (cbData && pbData)
	{
	    pb = pbData;
	    while (pb <= &(pbData[cbData-1]))
	    {   
	        // if we have a full line, then add the ascii characters
	        if (((pb - pbData) % NUM_HEXBYTES_PERLINE == 0) && (pb != pbData))
	        {
	            szHexText[(NUM_HEXBYTES_PERLINE*2) + NUM_HEXBYTES_PERLINE-1] = 0;
	            
	            //
	            // for some reason strcat is dying when the string gets REALLY long, so just do
	            // the string cat stuff manually with memcpy.
	            //
	            memcpy(pbBuffer, (BYTE *) szHexText, strlen(szHexText));        pbBuffer += strlen(szHexText);//strcat(pszBuffer, szHexText);
	            memcpy(pbBuffer, (BYTE *) "   ", strlen("   "));                pbBuffer += strlen("   ");//strcat(pszBuffer, "   ");
	            memcpy(pbBuffer, (BYTE *) szASCIIText, strlen(szASCIIText));    pbBuffer += strlen(szASCIIText);//strcat(pszBuffer, szASCIIText);
	            memcpy(pbBuffer, (BYTE *) "\n", strlen("\n"));                  pbBuffer += strlen("\n");//strcat(pszBuffer, "\n");
	            dwHexTextIndex = 0;
	            dwASCIITextIndex = 0;
	        }

	        szHexText[dwHexTextIndex++] = RgchHex[(*pb & 0xf0) >> 4];
	        szHexText[dwHexTextIndex++] = RgchHex[*pb & 0x0f];
	        // this will overwrite the null character when it is the last iteration,
	        // so just reset the null characert before doing the strcat
	        szHexText[dwHexTextIndex++] = ' ';  
	        szASCIIText[dwASCIITextIndex++] = (*pb >= 0x20 && *pb <= 0x7f) ? (char)*pb : '.';
	        pb++;
	    }

	    //
	    // print out the last line
	    //

	    // fill in with spaces if needed
	    for (i=dwHexTextIndex; i<((NUM_HEXBYTES_PERLINE*2) + NUM_HEXBYTES_PERLINE-1); i++)
	    {
	        szHexText[i] = ' ';
	    }
	    szHexText[(NUM_HEXBYTES_PERLINE*2) + NUM_HEXBYTES_PERLINE-1] = 0;
	    
	    // add the null character to the proper place in the ascii buffer
	    szASCIIText[dwASCIITextIndex] = 0;

	    //
	    // for some reason strcat is dying when the string gets REALLY long, so just do
	    // the string cat stuff manually with memcpy.
	    //
	    memcpy(pbBuffer, (BYTE *) szHexText, strlen(szHexText));        pbBuffer += strlen(szHexText);//strcat(pszBuffer, szHexText);
	    memcpy(pbBuffer, (BYTE *) "   ", strlen("   "));                pbBuffer += strlen("   ");//strcat(pszBuffer, "   ");
	    memcpy(pbBuffer, (BYTE *) szASCIIText, strlen(szASCIIText));    pbBuffer += strlen(szASCIIText);//strcat(pszBuffer, szASCIIText);
	    *pbBuffer = 0; 
	}
#endif
    SendMessageA(hWnd, WM_SETTEXT, 0, (LPARAM) pszBuffer);
    free(pszBuffer);
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL FormatMemBufToString(LPWSTR *ppString, LPBYTE pbData, DWORD cbData)
{   
    DWORD   i = 0;
    LPBYTE  pb;
    
    if (NULL == (*ppString = (LPWSTR) malloc((cbData * 3) * sizeof(WCHAR))))
    {
        return FALSE;
    }

    //
    // copy to the buffer
    //
    pb = pbData;
    while (pb <= &(pbData[cbData-1]))
    {   
        (*ppString)[i++] = RgwchHex[(*pb & 0xf0) >> 4];
        (*ppString)[i++] = RgwchHex[*pb & 0x0f];
        (*ppString)[i++] = L' ';
        pb++;         
    }
    (*ppString)[--i] = 0;
    
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
#define STRING_ALLOCATION_SIZE 128
BOOL FormatDNNameString(LPWSTR *ppString, LPBYTE pbData, DWORD cbData, BOOL fMultiline)
{
    CERT_NAME_INFO  *pNameInfo;
    DWORD           cbNameInfo;
    WCHAR           szText[256];
    LPWSTR          pwszText;
    int             i,j;
    DWORD           numChars = 1; // 1 for the terminating 0
    DWORD           numAllocations = 1;
    void            *pTemp;

    //
    // decode the dnname into a CERT_NAME_INFO struct
    //
    if (!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_UNICODE_NAME,
                pbData,
                cbData,
                0,
                NULL,
                &cbNameInfo))
    {
        return FALSE;
    }
    if (NULL == (pNameInfo = (CERT_NAME_INFO *) malloc(cbNameInfo)))
    {
        return FALSE;
    }
    if (!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_UNICODE_NAME,
                pbData,
                cbData,
                0,
                pNameInfo,
                &cbNameInfo))
    {
        free (pNameInfo);
        return FALSE;
    }

    //
    // allocate an initial buffer for the DN name string, then if it grows larger
    // than the initial amount just grow as needed
    //
    *ppString = (LPWSTR) malloc(STRING_ALLOCATION_SIZE * sizeof(WCHAR));
    if (*ppString == NULL)
    {
        free (pNameInfo);
        return FALSE;
    }

    (*ppString)[0] = 0;


    //
    // loop for each rdn and add it to the string
    //
    for (i=pNameInfo->cRDN-1; i>=0; i--)
    {
        // if this is not the first iteration, then add a eol or a ", "
        if (i != (int)pNameInfo->cRDN-1)
        {
            if (numChars+2 >= (numAllocations * STRING_ALLOCATION_SIZE))
            {
                pTemp = realloc(*ppString, ++numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                if (pTemp == NULL)
                {
                    free (pNameInfo);
                    free (*ppString);
                    return FALSE;
                }
                *ppString = (LPWSTR) pTemp;
            }
            
            if (fMultiline)
                wcscat(*ppString, L"\n");
            else
                wcscat(*ppString, L", ");

            numChars += 2;
        }

        for (j=pNameInfo->rgRDN[i].cRDNAttr-1; j>=0; j--)
        {
            // if this is not the first iteration, then add a eol or a ", "
            if (j != (int)pNameInfo->rgRDN[i].cRDNAttr-1)
            {
                if (numChars+2 >= (numAllocations * STRING_ALLOCATION_SIZE))
                {
                    pTemp = realloc(*ppString, ++numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                    if (pTemp == NULL)
                    {
                        free (pNameInfo);
                        free (*ppString);
                        return FALSE;
                    }
                    *ppString = (LPWSTR) pTemp;
                }
                
                if (fMultiline)
                    wcscat(*ppString, L"\n");
                else
                    wcscat(*ppString, L", ");

                numChars += 2;  
            }
            
            //
            // add the field name to the string if it is Multiline display
            //

            if (fMultiline)
            {
                if (!MyGetOIDInfo(szText, ARRAYSIZE(szText), pNameInfo->rgRDN[i].rgRDNAttr[j].pszObjId))
                {
                    free (pNameInfo);
                    return FALSE;
                }

                if ((numChars + wcslen(szText) + 3) >= (numAllocations * STRING_ALLOCATION_SIZE))
                {
                    // increment the number of allocation blocks until it is large enough
                    while ((numChars + wcslen(szText) + 3) >= (++numAllocations * STRING_ALLOCATION_SIZE));

                    pTemp = realloc(*ppString, numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                    if (pTemp == NULL)
                    {
                        free (pNameInfo);
                        free (*ppString);
                        return FALSE;
                    }
                    *ppString = (LPWSTR) pTemp;
                }

                numChars += wcslen(szText) + 3;
                wcscat(*ppString, szText);
                wcscat(*ppString, L" = ");  // delimiter
            }

            //
            // add the value to the string
            //
            if (CERT_RDN_ENCODED_BLOB == pNameInfo->rgRDN[i].rgRDNAttr[j].dwValueType ||
                        CERT_RDN_OCTET_STRING == pNameInfo->rgRDN[i].rgRDNAttr[j].dwValueType)
            {
                // translate the buffer to a text string and display it that way
                if (FormatMemBufToString(
                        &pwszText, 
                        pNameInfo->rgRDN[i].rgRDNAttr[j].Value.pbData,
                        pNameInfo->rgRDN[i].rgRDNAttr[j].Value.cbData))
                {
                    if ((numChars + wcslen(pwszText)) >= (numAllocations * STRING_ALLOCATION_SIZE))
                    {
                        // increment the number of allocation blocks until it is large enough
                        while ((numChars + wcslen(pwszText)) >= (++numAllocations * STRING_ALLOCATION_SIZE));

                        pTemp = realloc(*ppString, numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                        if (pTemp == NULL)
                        {
                            free (pwszText);
                            free (pNameInfo);
                            free (*ppString);
                            return FALSE;
                        }
                        *ppString = (LPWSTR) pTemp;
                    }
                    
                    wcscat(*ppString, pwszText);
                    numChars += wcslen(pwszText);
                    
                    free (pwszText);
                }
            }
            else 
            {
                // buffer is already a string so just copy it
                
                if ((numChars + (pNameInfo->rgRDN[i].rgRDNAttr[j].Value.cbData/sizeof(WCHAR))) 
                        >= (numAllocations * STRING_ALLOCATION_SIZE))
                {
                    // increment the number of allocation blocks until it is large enough
                    while ((numChars + (pNameInfo->rgRDN[i].rgRDNAttr[j].Value.cbData/sizeof(WCHAR))) 
                            >= (++numAllocations * STRING_ALLOCATION_SIZE));

                    pTemp = realloc(*ppString, numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                    if (pTemp == NULL)
                    {
                        free (pNameInfo);
                        free (*ppString);
                        return FALSE;
                    }
                    *ppString = (LPWSTR) pTemp;
                }

                wcscat(*ppString, (LPWSTR) pNameInfo->rgRDN[i].rgRDNAttr[j].Value.pbData);
                numChars += (pNameInfo->rgRDN[i].rgRDNAttr[j].Value.cbData/sizeof(WCHAR));
            }
        }
    }
    free (pNameInfo);
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL FormatEnhancedKeyUsageString(LPWSTR *ppString, PCCERT_CONTEXT pCertContext, BOOL fPropertiesOnly, BOOL fMultiline)
{
    CERT_ENHKEY_USAGE   *pKeyUsage = NULL;
    DWORD               cbKeyUsage = 0;
    DWORD               numChars = 1;
    WCHAR               szText[CRYPTUI_MAX_STRING_SIZE];
    DWORD               i;

    //
    // Try to get the enhanced key usage property
    //

    if (!CertGetEnhancedKeyUsage (  pCertContext,
                                    fPropertiesOnly ? CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG : 0,
                                    NULL,
                                    &cbKeyUsage))
    {
        return FALSE;
    }

    if (NULL == (pKeyUsage = (CERT_ENHKEY_USAGE *) malloc(cbKeyUsage)))
    {
        return FALSE;
    }

    if (!CertGetEnhancedKeyUsage (  pCertContext,
                                    fPropertiesOnly ? CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG : 0,
                                    pKeyUsage,
                                    &cbKeyUsage))
    {
        free(pKeyUsage);
        return FALSE;
    }

    if (pKeyUsage->cUsageIdentifier == 0)
    {
        free (pKeyUsage);
        if (GetLastError() == CRYPT_E_NOT_FOUND)
        {
            LoadStringU(HinstDll, IDS_ALL_FIELDS, szText, ARRAYSIZE(szText));
            if (NULL == (*ppString = AllocAndCopyWStr(szText)))
            {
                return FALSE; 
            }
            else
            {
                return TRUE;   
            }
        }
        else
        {
            LoadStringU(HinstDll, IDS_NO_USAGES, szText, ARRAYSIZE(szText));
            if (NULL == (*ppString = AllocAndCopyWStr(szText)))
            {
                return FALSE; 
            }
            else
            {
                return TRUE;   
            }
        }
    }

    //
    // calculate size
    //

    // loop for each usage and add it to the display string
    for (i=0; i<pKeyUsage->cUsageIdentifier; i++)
    {
        if (MyGetOIDInfo(szText, ARRAYSIZE(szText), pKeyUsage->rgpszUsageIdentifier[i]))
        {
            // add delimeter if not first iteration
            if (i != 0)
            {
                numChars += 2;
            }

            numChars += wcslen(szText);
        }
        else
        {
            free (pKeyUsage);
            return FALSE;   
        }
    }

    if (NULL == (*ppString = (LPWSTR) malloc((numChars+1) * sizeof(WCHAR))))
    {
        free (pKeyUsage);
        return FALSE; 
    }

    //
    // copy to buffer
    //
    (*ppString)[0] = 0;
    // loop for each usage and add it to the display string
    for (i=0; i<pKeyUsage->cUsageIdentifier; i++)
    {
        if (MyGetOIDInfo(szText, ARRAYSIZE(szText), pKeyUsage->rgpszUsageIdentifier[i]))
        {
            // add delimeter if not first iteration
            if (i != 0)
            {
                if (fMultiline)
                    wcscat(*ppString, L"\n");
                else
                    wcscat(*ppString, L", ");
                    
                numChars += 2;
            }

            //  add the enhanced key usage string
            wcscat(*ppString, szText);
            numChars += wcslen(szText);
        }
        else
        {
            free (pKeyUsage);
            return FALSE;   
        }
    }

    free (pKeyUsage);
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
LPWSTR AllocAndReturnSignTime(CMSG_SIGNER_INFO const *pSignerInfo, FILETIME **ppSignTime, HWND hwnd)
{
    DWORD       i;
    BOOL        fFound = FALSE;
    FILETIME    *pFileTime = NULL;
    DWORD       cbFileTime = 0;
    LPWSTR      pszReturn = NULL;

    if (ppSignTime != NULL)
    {
        *ppSignTime = NULL;
    }

    //
    // loop for each authenticated attribute
    //
    i=0;
    while ((!fFound) && (i<pSignerInfo->AuthAttrs.cAttr))
    {
        if (!(strcmp(pSignerInfo->AuthAttrs.rgAttr[i].pszObjId, szOID_RSA_signingTime) == 0))
        {
            i++;
            continue;
        }

        assert(pSignerInfo->AuthAttrs.rgAttr[i].cValue == 1);
        
        fFound = TRUE;

        //decode the EncodedSigner info
		if(!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
							PKCS_UTC_TIME,
							pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
							pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData,
							0,
							NULL,
							&cbFileTime))
        {
            return NULL;
        }

        if (NULL == (pFileTime = (FILETIME *) malloc(cbFileTime)))
        {
            return NULL;
        }

		if(!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
							PKCS_UTC_TIME,
							pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
							pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData,
							0,
							pFileTime,
							&cbFileTime))
        {
            return NULL;
        }

        //
        // return the sign time if the caller wants it, otherwise format the string and return it
        //
        if (ppSignTime)
        {
            if (NULL != (*ppSignTime = (FILETIME *) malloc(sizeof(FILETIME))))
            {
                memcpy(*ppSignTime, pFileTime, sizeof(FILETIME));
            }
        }
        else if (!FormatDateString(&pszReturn, *pFileTime, TRUE, TRUE, hwnd))
        {
            free(pFileTime);
            return NULL;
        }
    }

    if (pFileTime != NULL)
    {
        free(pFileTime);
    }

    return(pszReturn);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
LPWSTR AllocAndReturnTimeStampersTimes(CMSG_SIGNER_INFO const *pSignerInfo, FILETIME **ppSignTime, HWND hwnd)
{
    PCMSG_SIGNER_INFO   pCounterSignerInfo;
    DWORD               cbCounterSignerInfo;
    DWORD               i;
    LPWSTR              pszReturnText = NULL;
    LPWSTR              pszTimeText = NULL;
    void                *pTemp;

    if (ppSignTime != NULL)
    {
        *ppSignTime = NULL;
    }

    for (i=0; i<pSignerInfo->UnauthAttrs.cAttr; i++)
    {
        if (!(strcmp(pSignerInfo->UnauthAttrs.rgAttr[i].pszObjId, szOID_RSA_counterSign) == 0))
        {
            continue;
        }

        assert(pSignerInfo->UnauthAttrs.rgAttr[i].cValue == 1);

        //decode the EncodedSigner info
		if(!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
							PKCS7_SIGNER_INFO,
							pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].pbData,
							pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].cbData,
							0,
							NULL,
							&cbCounterSignerInfo))
        {
			return NULL;
        }

        if (NULL == (pCounterSignerInfo = (PCMSG_SIGNER_INFO)malloc(cbCounterSignerInfo)))
        {
            return NULL;
        }

		if(!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
							PKCS7_SIGNER_INFO,
							pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].pbData,
							pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].cbData,
							0,
							pCounterSignerInfo,
							&cbCounterSignerInfo))
        {
            free(pCounterSignerInfo);
            return NULL;
        }

        if (ppSignTime != NULL)
        {
            //
            // break after this which means we just get the first time stamp time,
            // but reallistically there should only be one anyway.
            //
            AllocAndReturnSignTime(pCounterSignerInfo, ppSignTime, hwnd);
            free(pCounterSignerInfo);
            break;
        }
        else
        {
            pszTimeText = AllocAndReturnSignTime(pCounterSignerInfo, NULL, hwnd);
            
            if (pszReturnText == NULL)
            {
                pszReturnText = pszTimeText;
            }
            else if (pszTimeText != NULL)
            {
                pTemp = realloc(pszReturnText, 
                                (wcslen(pszReturnText) + wcslen(pszTimeText) + wcslen(L", ") + 1) * sizeof(WCHAR));
                if (pTemp == NULL)
                {
                    free(pszTimeText);
                    free(pszReturnText);
                    return NULL;
                }
                pszReturnText = (LPWSTR) pTemp;
                wcscat(pszReturnText, L", ");
                wcscat(pszReturnText, pszTimeText);
                free(pszTimeText);
            }
        }

        free(pCounterSignerInfo);
    }

    //
    // if there were no counter signers, then use the time in the original signer info
    // 
    if ((pszReturnText == NULL) && (ppSignTime == NULL))
    {
        pszReturnText = AllocAndReturnSignTime(pSignerInfo, NULL, hwnd);
    }

    return(pszReturnText);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
LPWSTR FormatCTLSubjectUsage(CTL_USAGE *pSubjectUsage, BOOL fMultiline)
{
    DWORD   i;
    WCHAR   szText[CRYPTUI_MAX_STRING_SIZE];
    LPWSTR  pwszText = NULL;
    void    *pTemp;

    for (i=0; i<pSubjectUsage->cUsageIdentifier; i++)
    {
        if (!MyGetOIDInfo(szText, ARRAYSIZE(szText), pSubjectUsage->rgpszUsageIdentifier[i]))
        {
            continue;
        }

        if (pwszText == NULL)
        {
            pwszText = AllocAndCopyWStr(szText);
        }
        else
        {
            pTemp = realloc(pwszText, (wcslen(szText) + wcslen(pwszText) + 3) * sizeof(WCHAR));
            if (pTemp != NULL)
            {
                pwszText = (LPWSTR) pTemp;

                if (fMultiline)
                {
                    wcscat(pwszText, L"\n"); 
                }
                else
                {
                    wcscat(pwszText, L", "); 
                }
                wcscat(pwszText, szText); 
            }
            else
            {
                free(pwszText);
                return NULL;
            }
        }
    }
    return pwszText;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\demand.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       demand.cpp
//
//--------------------------------------------------------------------------

/*
**	d e m a n d . c p p
**	
**	Purpose: implement the loader functions for defer/demand -loaded libraries
**
**  Creators: jimsch, brimo, t-erikne
**  Created: 5/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/

#include        "global.hxx"
#include        <dbgdef.h>

// W4 stuff
#pragma warning(disable: 4201)  // nameless struct/union
#pragma warning(disable: 4514)  // unreferenced inline function removed

#define IMPLEMENT_LOADER_FUNCTIONS
#include "demand.h"

#ifndef MAC
////////////////////////////////////////////////////////////////////////////
//
//  Macros

#define CRIT_GET_PROC_ADDR(h, fn, temp)             \
        temp = (TYP_##fn) GetProcAddress(h, #fn);   \
        if (temp)                                   \
            VAR_##fn = temp;                        \
        else                                        \
            {                                       \
            AssertSz(VAR_##fn" failed to load");    \
            goto error;                             \
            }

#define RESET(fn)                                   \
        VAR_##fn = LOADER_##fn;

#define GET_PROC_ADDR(h, fn) \
        VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
        //        Assert(VAR_##fn != NULL);

#define GET_PROC_ADDR3(h, fn, varname) \
        VAR_##varname = (TYP_##varname) GetProcAddress(h, #fn);  \
        //        Assert(VAR_##varname != NULL);

////////////////////////////////////////////////////////////////////////////
//
//  Variables

static HMODULE          s_hCrypt = 0;
static HMODULE          s_hAdvApi = 0;
static HMODULE          s_hShell32 = 0;
#if 0 // JLS
static HMODULE          s_hShLWAPI = 0;
static HMODULE          s_hURLMon = 0;
static HMODULE          s_hVersion = 0;
static HMODULE          s_hWinINET = 0;
static HMODULE          s_hComctl32 = 0;
static HMODULE          s_hPstoreC = 0;
static HMODULE          s_hMAPI = 0;
static HMODULE          s_hWSOCK = 0;
static HMODULE          s_hOLEAUT = 0;
static HMODULE          s_hKernel = 0;
#endif // 0 // JLS

#ifdef USE_CRITSEC
static CRITICAL_SECTION cs = {0};
#endif

#ifdef DEBUG
static BOOL             s_fInit = FALSE;
#endif

////////////////////////////////////////////////////////////////////////////
//
//  Management functions

void InitDemandLoadedLibs()
{
#ifdef USE_CRITSEC
    InitializeCriticalSection(&cs);
#endif
#ifdef DEBUG
    s_fInit = TRUE;
#endif
}

void FreeDemandLoadedLibs()
{
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif
    if (s_hCrypt)
        FreeLibrary(s_hCrypt);
    if (s_hAdvApi)
        FreeLibrary(s_hAdvApi);
    if (s_hShell32)
        FreeLibrary(s_hShell32);
#if 0 //JLS
    if (s_hShLWAPI)
        FreeLibrary(s_hShLWAPI);
    if (s_hURLMon)
        FreeLibrary(s_hURLMon);
    if (s_hOLEAUT)
        FreeLibrary(s_hOLEAUT);
    if (s_hMAPI)
        FreeLibrary(s_hMAPI);
    if (s_hWSOCK)
        FreeLibrary(s_hWSOCK);
    if (s_hPstoreC)
        FreeLibrary(s_hPstoreC);
    if (s_hKernel)
        FreeLibrary(s_hKernel);
#endif // JLS
#ifdef DEBUG
    s_fInit = FALSE;
#endif
#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
    DeleteCriticalSection(&cs);
#endif
}

#if 0 // JLS
////////////////////////////////////////////////////////////////////////////
//
//  Loader functions

/* sample loader with critical proc addrs
** but not thread-safe
BOOL DemandLoadFoo()
{
    FARPROC fp;

    if (0 == g_hFoo)
        {
        g_hFoo = LoadLibrary("FOO.DLL");

        if (0 == g_hFoo)
            return FALSE;

        CRIT_GET_PROC_ADDR(NeededFunction1, fp);
        CRIT_GET_PROC_ADDR(NeededFunction2, fp);
        GET_PROC_ADDR(OptionalFunction);
        }
    return TRUE;

error:
    FreeLibrary(g_hFoo);
    g_hFoo = NULL;
    RESET(NeededFunction1)
    RESET(NeededFunction2)
    RESET(OptionalFunction)
    return FALSE;
}
*/
#endif // 0

BOOL DemandLoadCrypt32()
{
    BOOL                fRet = TRUE;

    //    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hCrypt) {
        s_hCrypt = LoadLibraryA("CRYPT32.DLL");
        // AssertSz((BOOL)s_hCrypt, TEXT("LoadLibrary failed on CRYPT32.DLL"));

        if (0 == s_hCrypt)
            fRet = FALSE;
        else {
            GET_PROC_ADDR(s_hCrypt, CertFreeCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertDuplicateCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertFindCertificateInStore)
            GET_PROC_ADDR(s_hCrypt, CertCloseStore)
            GET_PROC_ADDR(s_hCrypt, CertGetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt, CertOpenStore)
            GET_PROC_ADDR(s_hCrypt, CertGetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt, CertCompareCertificate)
            GET_PROC_ADDR(s_hCrypt, CertEnumCertificatesInStore)
            GET_PROC_ADDR(s_hCrypt, CryptDecodeObject)
            GET_PROC_ADDR(s_hCrypt, CertFindExtension)
            GET_PROC_ADDR(s_hCrypt, CryptFormatObject)
            GET_PROC_ADDR(s_hCrypt, CertNameToStrW)
            GET_PROC_ADDR(s_hCrypt, CertNameToStrA)
            GET_PROC_ADDR(s_hCrypt, CertStrToNameA)
            GET_PROC_ADDR(s_hCrypt, CertRDNValueToStrW)
            GET_PROC_ADDR(s_hCrypt, CertFindRDNAttr)
            GET_PROC_ADDR(s_hCrypt, CryptRegisterOIDFunction)
            GET_PROC_ADDR(s_hCrypt, CryptUnregisterOIDFunction)
            GET_PROC_ADDR(s_hCrypt, CertSetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt, CertVerifyCTLUsage)
            GET_PROC_ADDR(s_hCrypt, CertGetIssuerCertificateFromStore)
            GET_PROC_ADDR(s_hCrypt, CertFreeCTLContext)
            GET_PROC_ADDR(s_hCrypt, CertAddEncodedCTLToStore)
            GET_PROC_ADDR(s_hCrypt, CryptMsgEncodeAndSignCTL)
            GET_PROC_ADDR(s_hCrypt, CertFindCTLInStore)
            GET_PROC_ADDR(s_hCrypt, CryptSignAndEncodeCertificate)
            GET_PROC_ADDR(s_hCrypt, CryptEncodeObject)
            GET_PROC_ADDR(s_hCrypt, CryptExportPublicKeyInfo)
            GET_PROC_ADDR(s_hCrypt, CertDuplicateStore)
            GET_PROC_ADDR(s_hCrypt, CertAddEncodedCertificateToStore);
            GET_PROC_ADDR(s_hCrypt, CertVerifyTimeValidity);
            GET_PROC_ADDR(s_hCrypt, CertFindSubjectInCTL);
            GET_PROC_ADDR(s_hCrypt, CertVerifySubjectCertificateContext);
            GET_PROC_ADDR(s_hCrypt, CertGetEnhancedKeyUsage);
        }
    }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

BOOL DemandLoadAdvApi32()
{
    BOOL                fRet = TRUE;

    //    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hAdvApi) {
        s_hAdvApi = LoadLibraryA("ADVAPI32.DLL");
        //  AssertSz((BOOL)s_hAdvApi, TEXT("LoadLibrary failed on ADVAPI32.DLL"));

        if (0 == s_hAdvApi)
            fRet = FALSE;
        else {
            if (FIsWin95) {
                VAR_CryptAcquireContextW = MyCryptAcquireContextW;
            }
            else {
                GET_PROC_ADDR(s_hAdvApi, CryptAcquireContextW);
            }
#if 0
            GET_PROC_ADDR(s_hAdvApi, CryptGetProvParam)
            GET_PROC_ADDR(s_hAdvApi, CryptReleaseContext)
            GET_PROC_ADDR(s_hAdvApi, CryptGenKey)
            GET_PROC_ADDR(s_hAdvApi, CryptDestroyKey)
#endif // 0
        }
    }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

#ifndef WIN16

BOOL DemandLoadUser32()
{
    BOOL                fRet = TRUE;

    //    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif
#undef SendDlgitemMessageW
#undef SetDlgItemTextW
#undef GetDlgItemTextW
#undef LoadStringW
#undef FormatMessageW

    if (0 == s_hShell32) {
        if (FIsWin95) {
            VAR_SendDlgItemMessageW = MySendDlgItemMessageW;
            VAR_SetDlgItemTextW = MySetDlgItemTextW;
            VAR_GetDlgItemTextW = MyGetDlgItemTextW;
            VAR_LoadStringW = MyLoadStringW;
            VAR_FormatMessageW = MyFormatMessageW;
            VAR_WinHelpW = MyWinHelpW;
        }
        else {
            s_hShell32 = LoadLibraryA("kernel32.dll");
            GET_PROC_ADDR(s_hShell32, FormatMessageW);
            FreeLibrary(s_hShell32);
            
            s_hShell32 = LoadLibraryA("USER32.DLL");
            GET_PROC_ADDR(s_hShell32, SendDlgItemMessageW);
            GET_PROC_ADDR(s_hShell32, SetDlgItemTextW);
            GET_PROC_ADDR(s_hShell32, GetDlgItemTextW);
            GET_PROC_ADDR(s_hShell32, LoadStringW);
            GET_PROC_ADDR(s_hShell32, WinHelpW);
        }
    }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

#endif // !WIN16

#endif  // !MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\main.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       main.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#pragma warning (disable: 4201)         // nameless struct/union
#pragma warning (disable: 4514)         // remove inline functions
#pragma warning (disable: 4127)         // conditional expression is constant

//#include <wchar.h>


HMODULE         HmodRichEdit = NULL;
HINSTANCE       HinstDll;
BOOL            FIsWin95 = TRUE;
BOOL            fRichedit20Exists = FALSE;


//
//  Generic DLL Main function,  we need to get our own hinstance handle.
//
//  We don't need to get thread attaches however.

extern "C" BOOL WINAPI TrustUIDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved);

extern "C" BOOL WINAPI Wizard_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/);

BOOL WINAPI DllMain(HANDLE hInst, ULONG ulReason, LPVOID)
{
    BOOL    fResult=FALSE;

    switch( ulReason ) {
    case DLL_PROCESS_ATTACH:
        HinstDll = (HINSTANCE) hInst;
        
        //  Kill all thread attach and detach messages
        DisableThreadLibraryCalls(HinstDll);

        //  Are we running in Win95 or something equally bad
        FIsWin95 = IsWin95();

        // check for richedit 2.0's existence
        fRichedit20Exists =  CheckRichedit20Exists();

        break;

    case DLL_PROCESS_DETACH:
        
        //  If the rich edit dll was loaded, then unload it now
        if (HmodRichEdit != NULL) {
            FreeLibrary(HmodRichEdit);
        }
        break;
    }

    fResult=TrustUIDllMain((HINSTANCE)hInst, ulReason, NULL);

    fResult=fResult && (Wizard_DllMain((HINSTANCE)hInst, ulReason, NULL));

    fResult=fResult && (ProtectUI_DllMain((HINSTANCE)hInst, ulReason, NULL));

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\internal.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       internal.h
//
//--------------------------------------------------------------------------

#ifndef _INTERNAL_H
#define _INTERNAL_H

#include "richedit.h"
#include "ccertbmp.h"


#define CRYPTUI_MAX_STRING_SIZE 768

///////////////////////////////////////////////////////////////////////////////
// macro for getting the number of bytes in an array
///////////////////////////////////////////////////////////////////////////////
#define  ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))

#define ICON_X_POS 21
#define ICON_Y_POS 10

#define IMAGE_PROPERTY           0
#define IMAGE_EXTENSION          1
#define IMAGE_CRITICAL_EXTENSION 2
#define IMAGE_V1                 3

///////////////////////////////////////////////////////////////////////////////
// this structure is used to subclass an edit control and give it a link look
// and feel
///////////////////////////////////////////////////////////////////////////////
typedef struct _LIST_DISPLAY_HELPER {
    BOOL    fHexText;
    LPWSTR  pwszDisplayText;
    BYTE    *pbData;
    DWORD   cbData;
} LIST_DISPLAY_HELPER, *PLIST_DISPLAY_HELPER;

///////////////////////////////////////////////////////////////////////////////
// this structure is used to subclass an edit control and give it a link look
// and feel
///////////////////////////////////////////////////////////////////////////////
typedef struct _LINK_SUBCLASS_DATA {

    HWND    hwndParent;
    WNDPROC wpPrev;
    DWORD   uId;
    HWND    hwndTip;
    LPSTR   pszURL;
    BOOL    fMouseCaptured;
    BOOL    fNoCOM;
    BOOL    fUseArrowInsteadOfHand;
} LINK_SUBCLASS_DATA, *PLINK_SUBCLASS_DATA;


///////////////////////////////////////////////////////////////////////////////
// this structure is used to for the CertViewCert api and it's supporting
// property sheet dialog procs
///////////////////////////////////////////////////////////////////////////////
#define MAX_CERT_CHAIN_LENGTH 40
typedef struct {
    PCCRYPTUI_VIEWCERTIFICATE_STRUCTW   pcvp;
    DWORD                               cpCryptProviderCerts;
    PCRYPT_PROVIDER_CERT                rgpCryptProviderCerts[MAX_CERT_CHAIN_LENGTH];
    DWORD                               dwChainError;
    DWORD                               cUsages;
    LPSTR                               *rgUsages;
    HTREEITEM                           hItem;      // Leaf item in trust view
    BOOL                                fDblClk;
    CCertificateBmp                     *pCCertBmp;
    HWND                                hwndGeneralPage;
    HWND                                hwndDetailPage;
    HWND                                hwndHierarchyPage;
    RECT                                goodForOriginalRect;
    WINTRUST_DATA                       sWTD;
    WINTRUST_CERT_INFO                  sWTCI;
    BOOL                                fFreeWTD;
    BOOL                                fAddingToChain;
    BOOL                                fDeletingChain;
    LPWSTR                              pwszErrorString;
    BOOL                                fAccept;
    BOOL                                fNoCOM;
    BOOL                                *pfPropertiesChanged;
    BOOL                                fCPSDisplayed;
    BOOL                                fIgnoreUntrustedRoot;
    BOOL                                fWarnUntrustedRoot;
    BOOL                                fRootInRemoteStore;
    HICON                               hIcon;
    BOOL                                fCancelled;
    BOOL				fIssuerDisplayedAsLink;
    BOOL                                fSubjectDisplayedAsLink;
    BOOL                                fWarnRemoteTrust;
} CERT_VIEW_HELPER, *PCERT_VIEW_HELPER;

#define WM_MY_REINITIALIZE  (WM_USER+20)

///////////////////////////////////////////////////////////////////////////////
// this structure is used to for the CertViewCTL api and it's supporting
// property sheet dialog procs
///////////////////////////////////////////////////////////////////////////////
typedef struct {
    PCCRYPTUI_VIEWCTL_STRUCTW       pcvctl;
    DWORD                           chStores;
    HCERTSTORE                      *phStores;
    HCERTSTORE                      hExtraStore;
    PCCERT_CONTEXT                  pSignerCert;
    PCMSG_SIGNER_INFO               pbSignerInfo;
    DWORD                           cbSignerInfo;
    HICON                           hIcon;
    HCRYPTMSG                       hMsg;
    int                             previousSelection;
    int                             currentSelection;
    BOOL                            fNoSignature;
    BOOL                            fCancelled;
    DWORD                           dwInheritableError;
    BOOL                            fCatFile;
} CTL_VIEW_HELPER, *PCTL_VIEW_HELPER;


///////////////////////////////////////////////////////////////////////////////
// this structure is used to for the CertViewCRL api and it's supporting
// property sheet dialog procs
///////////////////////////////////////////////////////////////////////////////
typedef struct {
    PCCRYPTUI_VIEWCRL_STRUCTW   pcvcrl;
    int                         currentSelection;
    HICON                       hIcon;
    BOOL                        fCancelled;
} CRL_VIEW_HELPER, *PCRL_VIEW_HELPER;


///////////////////////////////////////////////////////////////////////////////
// this structure is used to for the CertSetProperties api and it's supporting
// property sheet dialog procs
///////////////////////////////////////////////////////////////////////////////
typedef struct {
    PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp;
    LPWSTR                                      pwszInitialCertName;
    LPWSTR                                      pwszInitialDescription;
    BOOL                                        fSelfCleanup;
    BOOL                                        fInserting;
    BOOL                                        *pfPropertiesChanged;
    BOOL                                        fPropertiesChanged;
    BOOL                                        fGetPagesCalled;
    LPSTR                                       *rgszValidChainUsages;
    int                                         cszValidUsages;
    DWORD                                       EKUPropertyState;
	BOOL										fAddPurposeCanBeEnabled;
    BOOL                                        fCancelled;
    DWORD                                       dwRadioButtonState;
    BOOL                                        fMMCCallbackMade;
    BOOL                                        InWMInit;
} CERT_SETPROPERTIES_HELPER, *PCERT_SETPROPERTIES_HELPER;


///////////////////////////////////////////////////////////////////////////////
// this structure is used to for the CertViewSignerInfo api 
///////////////////////////////////////////////////////////////////////////////
#define CRYPTUI_VIEWSIGNERINFO_RESERVED_FIELD_IS_SIGNERINFO_PRIVATE 0x80000000
#define CRYPTUI_VIEWSIGNERINFO_RESERVED_FIELD_IS_ERROR_CODE         0x40000000
typedef struct {
    PCRYPT_PROVIDER_DATA    pCryptProviderData;
    BOOL                    fpCryptProviderDataTrustedUsage;
    DWORD                   idxSigner;
    BOOL                    fCounterSigner;
    DWORD                   idxCounterSigner;
    DWORD                   dwInheritedError;
} CERT_VIEWSIGNERINFO_PRIVATE, *PCERT_VIEWSIGNERINFO_PRIVATE;

///////////////////////////////////////////////////////////////////////////////
// this structure is used to for the CertViewSignerInfo api and it's supporting
// property sheet dialog procs
///////////////////////////////////////////////////////////////////////////////
typedef struct {
    PCCRYPTUI_VIEWSIGNERINFO_STRUCTW    pcvsi;
    PCCERT_CONTEXT                      pSignersCert;
    int                                 previousSelection;
    int                                 currentSelection;
    HICON                               hIcon;
    HCERTSTORE                          hExtraStore;
    PCERT_VIEWSIGNERINFO_PRIVATE        pPrivate;
    BOOL                                fPrivateAllocated;
    CRYPT_PROVIDER_DEFUSAGE             CryptProviderDefUsage;
    WINTRUST_DATA                       WTD;
    BOOL                                fUseDefaultProvider;
    BOOL                                fCancelled;
    DWORD                               dwInheritedError;
} SIGNER_VIEW_HELPER, *PSIGNER_VIEW_HELPER;


///////////////////////////////////////////////////////////////////////////////
// this structure is used to for the CertViewSignatures api and it's supporting
// property sheet dialog procs
///////////////////////////////////////////////////////////////////////////////
typedef struct {
    PCRYPTUI_VIEWSIGNATURES_STRUCTW     pcvs;
    BOOL                                fSelfCleanup;
    HCERTSTORE                          hExtraStore;
} CERT_VIEWSIGNATURES_HELPER, *PCERT_VIEWSIGNATURES_HELPER;


///////////////////////////////////////////////////////////////////////////////
// these functions are the property pages procs for the CertViewCert API
///////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageDetails(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY ViewPageGeneral(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY ViewPageHierarchy(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);

///////////////////////////////////////////////////////////////////////////////
// these functions are the property pages procs for the CertViewCTL API
///////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageCTLGeneral(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY ViewPageCTLTrustList(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY ViewPageCatalogEntries(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);

///////////////////////////////////////////////////////////////////////////////
// these functions are the property pages procs for the CertViewCRL API
///////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageCRLGeneral(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY ViewPageCRLRevocationList(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);

///////////////////////////////////////////////////////////////////////////////
// these functions are the property pages procs for the CertViewSignerInfo API
///////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageSignerGeneral(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY ViewPageSignerAdvanced(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);


///////////////////////////////////////////////////////////////////////////////
// used for obvious purposes
///////////////////////////////////////////////////////////////////////////////
BOOL IsWin95(void);
extern BOOL FIsWin95;
BOOL CheckRichedit20Exists(void);
extern BOOL fRichedit20Exists;
BOOL fRichedit20Usable(HWND hwndEdit);


#undef SetWindowLong
#define SetWindowLong SetWindowLongA
#undef GetWindowLong
#define GetWindowLong GetWindowLongA
#undef SendMessage
#define SendMessage SendMessageA


//
//  frmtutil.cpp
//
BOOL FormatAlgorithmString(LPWSTR *ppString, CRYPT_ALGORITHM_IDENTIFIER const *pAlgorithm);
BOOL FormatSerialNoString(LPWSTR *ppString, CRYPT_INTEGER_BLOB const *pblob);
BOOL FormatMemBufToString(LPWSTR *ppString, LPBYTE pbData, DWORD cbData);
BOOL FormatDateString(LPWSTR *ppString, FILETIME ft, BOOL fIncludeTime, BOOL fLongFormat, HWND hwnd = NULL);
BOOL FormatValidityString(LPWSTR *ppString, PCCERT_CONTEXT pCertContext, HWND hwnd = NULL);
BOOL FormatDNNameString(LPWSTR *ppString, LPBYTE pbData, DWORD cbData, BOOL fMultiline);
BOOL FormatEnhancedKeyUsageString(LPWSTR *ppString, PCCERT_CONTEXT pCertContext, BOOL fPropertiesOnly, BOOL fMultiline);
BOOL FormatMemBufToWindow(HWND hWnd, LPBYTE pbData, DWORD cbData);
LPWSTR AllocAndReturnSignTime(CMSG_SIGNER_INFO const *pSignerInfo, FILETIME **ppSignTime, HWND hwnd = NULL);
LPWSTR AllocAndReturnTimeStampersTimes(CMSG_SIGNER_INFO const *pSignerInfo, FILETIME **ppSignTime, HWND hwnd = NULL);
LPWSTR FormatCTLSubjectUsage(CTL_USAGE *pSubjectUsage, BOOL fMultiline);

//
// usagutil.cpp
//
BOOL OIDinArray(LPCSTR pszOID, LPSTR *rgszOIDArray, DWORD cOIDs);
BOOL AllocAndReturnKeyUsageList(PCRYPT_PROVIDER_CERT pCryptProviderCert, LPSTR **pKeyUsageOIDs, DWORD *numOIDs);
BOOL AllocAndReturnEKUList(PCCERT_CONTEXT pCert, LPSTR **pKeyUsageOIDs, DWORD *numOIDs);
void FreeEKUList(LPSTR *pKeyUsageOIDs, DWORD numOIDs);
BOOL MyGetOIDInfo(LPWSTR string, DWORD stringSize, LPSTR pszObjId);
BOOL OIDInUsages(PCERT_ENHKEY_USAGE pUsage, LPCSTR pszOID);
BOOL fPropertiesDisabled(PCERT_ENHKEY_USAGE pPropertyUsage);
BOOL CertHasEmptyEKUProp(PCCERT_CONTEXT pCertContext);
BOOL ValidateCertForUsage(
                    PCCERT_CONTEXT  pCertContext,
                    FILETIME        *psftVerifyAsOf,
                    DWORD           cStores,
                    HCERTSTORE *    rghStores,
                    HCERTSTORE      hExtraStore,
                    LPCSTR          pszOID);

//
// linkutil.cpp
//
void CryptuiGoLink(HWND hwndParent, char *pszWhere, BOOL fNoCOM);
BOOL AllocAndGetIssuerURL(LPSTR *ppURLString, PCCERT_CONTEXT pCertContext);
BOOL AllocAndGetSubjectURL(LPSTR *ppURLString, PCCERT_CONTEXT pCertContext);

//
// cps.cpp
//
DWORD GetCPSInfo(PCCERT_CONTEXT pCertContext, LPWSTR * ppwszUrlString, LPWSTR * ppwszDisplayText);
BOOL IsOKToDisplayCPS(PCCERT_CONTEXT pCertContext, DWORD dwChainError);
BOOL DisplayCPS(HWND hwnd, PCCERT_CONTEXT pCertContext, DWORD dwChainError, BOOL fNoCOM);

//
// disputil.cpp
//
void DisplayExtensions(HWND hWndListView, DWORD cExtension, PCERT_EXTENSION rgExtension, BOOL fCritical, DWORD *index);
PLIST_DISPLAY_HELPER MakeListDisplayHelper(BOOL fHexText, LPWSTR pwszDisplayText, BYTE *pbData, DWORD cbData);
PLIST_DISPLAY_HELPER MakeListDisplayHelperForExtension(LPSTR pszObjId, BYTE *pbData, DWORD cbData);
void FreeListDisplayHelper(PLIST_DISPLAY_HELPER pDisplayHelper);
void DisplayHelperTextInEdit(HWND hWndListView, HWND hwndDlg, int nIDEdit, int index);
void SetTextFormatInitial(HWND hWnd);
void SetTextFormatHex(HWND hWnd);

BOOL GetUnknownErrorString(LPWSTR *ppwszErrorString, DWORD dwError);
BOOL GetCertErrorString(LPWSTR *ppwszErrorString, PCRYPT_PROVIDER_CERT pCryptProviderCert);
void CertSubclassEditControlForArrowCursor (HWND hwndEdit);
void CertSubclassEditControlForLink (HWND hwndDlg, HWND hwndEdit, PLINK_SUBCLASS_DATA plsd);
void * GetStoreName(HCERTSTORE hCertStore, BOOL fWideChar);
void ModifyOrInsertRow(
                    HWND        hWndListView,
                    LV_ITEMW    *plvI,
                    LPWSTR      pwszValueText,
                    LPWSTR      pwszText,
                    BOOL        fAddRows,
                    BOOL        fHex);
int CALLBACK HidePropSheetCancelButtonCallback(
                    HWND    hwndDlg,
                    UINT    uMsg,
                    LPARAM  lParam);

INT_PTR WINAPI CryptUIPropertySheetA(LPCPROPSHEETHEADERA pHdr);
INT_PTR WINAPI CryptUIPropertySheetW(LPCPROPSHEETHEADERW pHdr);

BOOL IsTrueErrorString(CERT_VIEW_HELPER *pviewhelp);

//
// convutil.cpp
//
LPSTR CertUIMkMBStr(LPCWSTR pwsz);
LPWSTR CertUIMkWStr(LPCSTR psz);
LPSTR AllocAndCopyMBStr(LPCSTR psz);
LPWSTR AllocAndCopyWStr(LPCWSTR pwsz);
LPPROPSHEETPAGEA ConvertToPropPageA(LPCPROPSHEETPAGEW ppage, DWORD cPages);
void FreePropSheetPagesA(LPPROPSHEETPAGEA ppage, DWORD cPages);
BOOL ConvertToPropPageW(LPCPROPSHEETPAGEA ppage, DWORD cPages, LPCPROPSHEETPAGEW *pppageW);
void FreePropSheetPagesW(LPPROPSHEETPAGEW ppage, DWORD cPages);



//
// gettrst.cpp
//
BOOL CalculateUsages(PCERT_VIEW_HELPER pviewhelp);

BOOL BuildChain(PCERT_VIEW_HELPER pviewhelp, LPSTR pszUsage);

BOOL BuildWinVTrustState(
            LPCWSTR                         szFileName,
            CMSG_SIGNER_INFO const          *pSignerInfo,
            DWORD                           cStores,
            HCERTSTORE                      *rghStores,
            LPCSTR                          pszOID,
            PCERT_VIEWSIGNERINFO_PRIVATE    pcvsiPrivate,
            CRYPT_PROVIDER_DEFUSAGE         *pCryptProviderDefUsage,
            WINTRUST_DATA                   *pWTD);

BOOL FreeWinVTrustState(
            LPCWSTR                         szFileName,
            CMSG_SIGNER_INFO const          *pSignerInfo,
            DWORD                           cStores,
            HCERTSTORE                      *rghStores,
            LPCSTR                          pszOID,
            CRYPT_PROVIDER_DEFUSAGE         *pCryptProviderDefUsage,
            WINTRUST_DATA                   *pWTD);

//
// other stuff (util.cpp)
//
BOOL CommonInit();
BOOL FreeAndCloseKnownStores(DWORD chStores, HCERTSTORE *phStores);
BOOL AllocAndOpenKnownStores(DWORD *chStores, HCERTSTORE  **pphStores);
HBITMAP LoadResourceBitmap(HINSTANCE hInstance, LPSTR lpString, HPALETTE* lphPalette);
void MaskBlt
(
    HBITMAP& hbmImage,
    HPALETTE hpal,
    HDC& hdc, int xDst, int yDst, int dx, int dy
);
PCCERT_CONTEXT GetSignersCert(CMSG_SIGNER_INFO const *pSignerInfo, HCERTSTORE hExtraStore, DWORD cStores, HCERTSTORE *rghStores);
BOOL fIsCatalogFile(CTL_USAGE *pSubjectUsage);
DWORD CryptUISetRicheditTextW(HWND hwndDlg, UINT id, LPCWSTR pwsz);
void SetRicheditIMFOption(HWND hWndRichEdit);

/*BOOL CryptUISetupFonts(HFONT *pBoldFont);
void CryptUIDestroyFonts(HFONT hBoldFont);
void CryptUISetControlFont(HFONT hFont, HWND hwnd, INT nId);
*/

//
//  These routines extract and pretty print fields in the certs.  The
//      routines use crt to allocate and return a buffer
//

LPWSTR PrettySubject(PCCERT_CONTEXT pccert);

typedef struct {
    DWORD       dw1;
    DWORD       dw2;
} HELPMAP;

BOOL OnContextHelp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
                   HELPMAP const * rgCtxMap);

//--------------------------------------------------------------------------
//
//	 IsValidURL
//
//--------------------------------------------------------------------------
BOOL IsValidURL (LPWSTR pwszURL);

//--------------------------------------------------------------------------
//
//	  FormatMessageUnicodeIds
//
//--------------------------------------------------------------------------
LPWSTR FormatMessageUnicodeIds (UINT ids, ...);

//--------------------------------------------------------------------------
//
//	  FormatMessageUnicodeString
//
//--------------------------------------------------------------------------
LPWSTR FormatMessageUnicodeString (LPWSTR pwszFormat, ...);

//--------------------------------------------------------------------------
//
//	  FormatMessageUnicode
//
//--------------------------------------------------------------------------
LPWSTR FormatMessageUnicode (LPWSTR pwszFormat, va_list * pArgList);

#endif //_INTERNAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\linkutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       linkutil.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void CryptuiGoLink(HWND hwndParent, char *pszWhere, BOOL fNoCOM)
{
    HCURSOR hcursPrev = NULL;
    HMODULE hURLMon = NULL;
    BOOL    fCallCoUnInit = FALSE;
    
    //
    //  since we're a model dialog box, we want to go behind IE once it comes up!!!
    //
    SetWindowPos(hwndParent, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);

    hcursPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    __try
    {

    hURLMon = (HMODULE)LoadLibraryU(L"urlmon.dll");

    if (!(hURLMon) || fNoCOM)
    {
        //
        // The hyperlink module is unavailable, go to fallback plan
        //
        //
        // This works in test cases, but causes deadlock problems when used from withing
        // the Internet Explorer itself. The dialog box is up (that is, IE is in a modal
        // dialog loop) and in comes this DDE request...).
        //
        ShellExecute(hwndParent, "open", pszWhere, NULL, NULL, SW_SHOWNORMAL);
    } 
    else 
    {
        //
        // The hyperlink module is there. Use it
        //
        if (SUCCEEDED(CoInitialize(NULL)))       // Init OLE if no one else has
        {
            fCallCoUnInit = TRUE;

            //
            //  allow com to fully init...
            //
            MSG     msg;

            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE); // peek but not remove

            typedef void (WINAPI *pfnHlinkSimpleNavigateToString)(LPCWSTR, LPCWSTR, LPCWSTR, IUnknown *,
                                                                  IBindCtx *, IBindStatusCallback *,
                                                                  DWORD, DWORD);

            pfnHlinkSimpleNavigateToString      pProcAddr;

            pProcAddr = (pfnHlinkSimpleNavigateToString)GetProcAddress(hURLMon, TEXT("HlinkSimpleNavigateToString"));

            if (pProcAddr)
            {
                WCHAR       *pwszWhere;
                IBindCtx    *pbc;  

                pwszWhere = new WCHAR[strlen(pszWhere) + 1];
                if (pwszWhere == NULL)
                {
                    return;
                }

                MultiByteToWideChar(0, 0, (const char *)pszWhere, -1, pwszWhere, strlen(pszWhere) + 1);

                pbc = NULL;

                CreateBindCtx( 0, &pbc ); 
                
                (*pProcAddr)(pwszWhere, NULL, NULL, NULL, pbc, NULL, HLNF_OPENINNEWWINDOW, NULL);

                if (pbc)
                {
                    pbc->Release();
                }

                delete [] pwszWhere;
            }
        
            CoUninitialize();
        }

        FreeLibrary(hURLMon);
    }

    SetCursor(hcursPrev);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        if (hURLMon != NULL)
        {
            FreeLibrary(hURLMon);   
        }

        if (fCallCoUnInit)
        {
            CoUninitialize();
        }

        if (hcursPrev != NULL)
        {
            SetCursor(hcursPrev);
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL AllocAndGetIssuerURL(LPSTR *ppURLString, PCCERT_CONTEXT pCertContext)
{
    PCERT_EXTENSION     pExt = NULL;
    PSPC_SP_AGENCY_INFO pInfo = NULL;
    DWORD               cbInfo = 0;
    PCERT_ALT_NAME_ENTRY pAltName = NULL;
    DWORD               cbAltName = 0;

    *ppURLString = NULL;

    //
    // first look for the Agency Info extension and see if it has an URL 
    //
    if ((pExt = CertFindExtension(SPC_SP_AGENCY_INFO_OBJID, pCertContext->pCertInfo->cExtension,
                                   pCertContext->pCertInfo->rgExtension)))
    {
        CryptDecodeObject(X509_ASN_ENCODING, SPC_SP_AGENCY_INFO_STRUCT,
                         pExt->Value.pbData, pExt->Value.cbData, 0, NULL,
                         &cbInfo);

        if (!(pInfo = (PSPC_SP_AGENCY_INFO) malloc(cbInfo)))
        {
            return FALSE;
        }

        if (!(CryptDecodeObject(X509_ASN_ENCODING, SPC_SP_AGENCY_INFO_STRUCT,
                                pExt->Value.pbData, pExt->Value.cbData, 0, pInfo,
                                &cbInfo)))
        {
            free(pInfo);
            return FALSE;
        } 

        if (!(pInfo->pPolicyInformation))
        {
            free(pInfo);
            return FALSE;
        }

        switch (pInfo->pPolicyInformation->dwLinkChoice)
        {
            case SPC_URL_LINK_CHOICE:
                if (NULL != (*ppURLString = 
                    (LPSTR) malloc(wcslen(pInfo->pPolicyInformation->pwszUrl)+1)))
                {
                    WideCharToMultiByte(
                            0,
                            0,
                            pInfo->pPolicyInformation->pwszUrl,
                            -1,
                            *ppURLString,
                            wcslen(pInfo->pPolicyInformation->pwszUrl)+1,
                            NULL,
                            NULL);
                    
                    free(pInfo);
                    return TRUE;
                }
                else
                {
                    free(pInfo);
                    return FALSE;   
                }
                break;
            case SPC_FILE_LINK_CHOICE:
                if (NULL != (*ppURLString = 
                    (LPSTR) malloc(wcslen(pInfo->pPolicyInformation->pwszFile)+1)))
                {
                    WideCharToMultiByte(
                            0,
                            0,
                            pInfo->pPolicyInformation->pwszFile,
                            -1,
                            *ppURLString,
                            wcslen(pInfo->pPolicyInformation->pwszFile)+1,
                            NULL,
                            NULL);

                    return TRUE;
                }
                else
                {
                    free(pInfo);
                    return FALSE;
                }
                break;
        }
        free(pInfo);
    }

    //
    // if there was no Agency Info extension or it didn't contain an URL,
    // look for the Authority Info Access Syntax extension
    //
    /*if ((pExt = CertFindExtension(SPC_SP_AGENCY_INFO_OBJID, pCertContext->pCertInfo->cExtension,
                                   pCertContext->pCertInfo->rgExtension)))
    {
        FIX FIX
    }*/

    //
    // finally, if there was no Agency Info and no Authority Info Access Syntax
    // check to see if there is an Alternate Name extension
    //
    if ((pExt = CertFindExtension(szOID_ISSUER_ALT_NAME, pCertContext->pCertInfo->cExtension,
                                   pCertContext->pCertInfo->rgExtension)))
    {
        CryptDecodeObject(X509_ASN_ENCODING, szOID_ISSUER_ALT_NAME,
                         pExt->Value.pbData, pExt->Value.cbData, 0, NULL,
                         &cbAltName);

        if (!(pAltName = (PCERT_ALT_NAME_ENTRY) malloc(cbAltName)))
        {
            return FALSE;
        }

        if (!(CryptDecodeObject(X509_ASN_ENCODING, szOID_ISSUER_ALT_NAME,
                                pExt->Value.pbData, pExt->Value.cbData, 0, pAltName,
                                &cbAltName)))
        {
            free(pAltName);
            return FALSE;
        }   
        
        if (pAltName->dwAltNameChoice == CERT_ALT_NAME_URL)
        {
            if (NULL != (*ppURLString = (LPSTR) malloc(wcslen(pAltName->pwszURL)+1)))
            {
                WideCharToMultiByte(
                            0,
                            0,
                            pAltName->pwszURL,
                            -1,
                            *ppURLString,
                            wcslen(pAltName->pwszURL)+1,
                            NULL,
                            NULL);

                free(pAltName);
                return TRUE;
            }
        }
        free(pAltName);
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL AllocAndGetSubjectURL(LPSTR *ppURLString, PCCERT_CONTEXT pCertContext)
{
    PCERT_EXTENSION     pExt = NULL;
    PCERT_ALT_NAME_ENTRY pAltName = NULL;
    DWORD               cbAltName = 0;
    
    *ppURLString = NULL;
    
    //
    // check to see if there is an Alternate Name extension
    //
    if ((pExt = CertFindExtension(szOID_SUBJECT_ALT_NAME, pCertContext->pCertInfo->cExtension,
                                   pCertContext->pCertInfo->rgExtension)))
    {
        CryptDecodeObject(X509_ASN_ENCODING, szOID_SUBJECT_ALT_NAME,
                         pExt->Value.pbData, pExt->Value.cbData, 0, NULL,
                         &cbAltName);

        if (!(pAltName = (PCERT_ALT_NAME_ENTRY) malloc(cbAltName)))
        {
            return FALSE;
        }

        if (!(CryptDecodeObject(X509_ASN_ENCODING, szOID_SUBJECT_ALT_NAME,
                                pExt->Value.pbData, pExt->Value.cbData, 0, pAltName,
                                &cbAltName)))
        {
            free(pAltName);
            return FALSE;
        }   
        
        if (pAltName->dwAltNameChoice == CERT_ALT_NAME_URL)
        {
            if (NULL != (*ppURLString = (LPSTR) malloc(wcslen(pAltName->pwszURL)+1)))
            {
                WideCharToMultiByte(
                            0,
                            0,
                            pAltName->pwszURL,
                            -1,
                            *ppURLString,
                            wcslen(pAltName->pwszURL)+1,
                            NULL,
                            NULL);

                free(pAltName);
                return TRUE;
            }
        }
        free(pAltName);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\property.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       property.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include <wininet.h>
#include <crypthlp.h>           //DSIE:  For XCERT_MIN_SYNC_DELTA_TIME and 
                                //       XCERT_MIN_SYNC_DELTA_TIME

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmapGeneral[] = {
    {IDC_CERTIFICATE_NAME,		IDH_CERTPROPERTIES_CERTIFICATENAME},
    {IDC_DESCRIPTION,			IDH_CERTPROPERTIES_DESCRIPTION},
    {IDC_KEY_USAGE_LIST,		IDH_CERTPROPERTIES_USAGE_LIST},
    {IDC_PROPERTY_NEWOID,		IDH_CERTPROPERTIES_ADDPURPOSE_BUTTON},
	{IDC_ENABLE_ALL_RADIO,		IDH_CERTPROPERTIES_ENABLE_ALL_RADIO},
	{IDC_DISABLE_ALL_RADIO,		IDH_CERTPROPERTIES_DISABLE_ALL_RADIO},
	{IDC_ENABLE_SELECT_RADIO,	IDH_CERTPROPERTIES_ENABLE_CUSTOM_RADIO}
};

static const HELPMAP helpmapCrossCert[] = {
    {IDC_CHECKFORNEWCERTS_CHECK, IDH_CHECKFORNEWCERTS_CHECK},
    {IDC_NUMBEROFUNITS_EDIT,	 IDH_NUMBEROFUNITS_EDIT},
    {IDC_UNITS_COMBO,		     IDH_UNITS_COMBO},
    {IDC_USE_DEFAULT_BUTTON,	 IDH_USE_DEFAULT_BUTTON},
    {IDC_ADDURL_BUTTON,		     IDH_ADDURL_BUTTON},
    {IDC_NEWURL_EDIT,		     IDH_NEWURL_EDIT},
    {IDC_URL_LIST,               IDH_URL_LIST},
	{IDC_REMOVEURL_BUTTON,	     IDH_REMOVEURL_BUTTON}
};

#define MY_CHECK_STATE_CHECKED            (INDEXTOSTATEIMAGEMASK(1))
#define MY_CHECK_STATE_UNCHECKED          (INDEXTOSTATEIMAGEMASK(2))
#define MY_CHECK_STATE_CHECKED_GRAYED     (INDEXTOSTATEIMAGEMASK(3))
#define MY_CHECK_STATE_UNCHECKED_GRAYED   (INDEXTOSTATEIMAGEMASK(4))

#define PROPERTY_STATE_ALL_ENABLED      1
#define PROPERTY_STATE_ALL_DISABLED     2
#define PROPERTY_STATE_SELECT           3

typedef struct {
    LPSTR   pszOID;
    DWORD   initialState;
} SETPROPERTIES_HELPER_STRUCT, *PSETPROPERTIES_HELPER_STRUCT;

//DSIE: Bug 154609
#define XCERT_DEFAULT_DELTA_HOURS     (XCERT_DEFAULT_SYNC_DELTA_TIME / (60 * 60)) // Default interval is 8 hours.

//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY NewOIDDialogProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD   i;
    char    szText[256];
    WCHAR   errorString[CRYPTUI_MAX_STRING_SIZE];
    WCHAR   errorTitle[CRYPTUI_MAX_STRING_SIZE];
    LPSTR   pszText = NULL;

    switch ( msg ) {

    case WM_INITDIALOG:

        SendDlgItemMessage(hwndDlg, IDC_EDIT1, EM_EXLIMITTEXT, 0, (LPARAM) 255);
        SetDlgItemTextU(hwndDlg, IDC_EDIT1, L"");
        SetFocus(GetDlgItem(hwndDlg, IDC_EDIT1));
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {

        case IDOK:
            if (GetDlgItemTextA(
                        hwndDlg,
                        IDC_EDIT1,
                        szText,
                        ARRAYSIZE(szText)))
            {
                BOOL                fError = FALSE;
                CERT_ENHKEY_USAGE   KeyUsage;
                DWORD               cbData = 0;
                LPSTR               pszCheckOID;

                //
                // make sure there are not weird characters
                //
                for (i=0; i<(DWORD)strlen(szText); i++)
                {
                    if (((szText[i] < '0') || (szText[i] > '9')) && (szText[i] != '.'))
                    {
                        fError = TRUE;
                        break;
                    }
                }

                //
                // check the first and last chars, and for the empty string
                //
                if (!fError)
                {
                    if ((szText[0] == '.') || (szText[strlen(szText)-1] == '.') || (strcmp(szText, "") == 0))
                    {
                        fError = TRUE;
                    }
                }

                //
                // finally, make sure that it encodes properly
                //
                if (!fError)
                {
                    pszCheckOID = szText;
                    KeyUsage.rgpszUsageIdentifier = &pszCheckOID;
                    KeyUsage.cUsageIdentifier = 1;

                    if (!CryptEncodeObject(
                              X509_ASN_ENCODING,
                              szOID_ENHANCED_KEY_USAGE,
                              &KeyUsage,
                              NULL,
                              &cbData))
                    {
                        fError = TRUE;
                    }
                }


                //
                // if an error has occurred then display error
                //
                if (fError)
                {
                    LoadStringU(HinstDll, IDS_ERRORINOID, errorString, ARRAYSIZE(errorString));
                    LoadStringU(HinstDll, IDS_CERTIFICATE_PROPERTIES, errorTitle, ARRAYSIZE(errorTitle));
                    MessageBoxU(hwndDlg, errorString, errorTitle, MB_OK | MB_ICONERROR);
                    SendDlgItemMessage(hwndDlg, IDC_EDIT1, EM_SETSEL, 0, -1);
                    SetFocus(GetDlgItem(hwndDlg, IDC_EDIT1));
                    return FALSE;
                }

                //
                // allocate space for the string and pass the string back
                //
                pszText = (LPSTR) malloc(strlen(szText)+1);
                if (pszText != NULL)
                {
                    strcpy(pszText, szText);
                }
            }

            EndDialog(hwndDlg, (INT_PTR)pszText);
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, 0);
            break;
        }

        break;
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
DWORD MyGetCheckState(HWND hWndListView, int listIndex)
{
    LVITEMW lvI;

    memset(&lvI, 0, sizeof(lvI));
    lvI.mask = LVIF_STATE;
    lvI.iItem = listIndex;
    lvI.state = 0;
    lvI.stateMask = LVIS_STATEIMAGEMASK;

    ListView_GetItem(hWndListView, &lvI);

    return (lvI.state);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
void MySetCheckState(HWND hWndListView, int listIndex, DWORD dwImage)
{
    LVITEMW lvI;

    memset(&lvI, 0, sizeof(lvI));
    lvI.mask = LVIF_STATE;
    lvI.stateMask = LVIS_STATEIMAGEMASK;
    lvI.iItem = listIndex;
    lvI.state = dwImage;

    SendMessage(hWndListView, LVM_SETITEM, (WPARAM) 0, (LPARAM) &lvI);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void SetEnableStateForChecks(PCERT_SETPROPERTIES_HELPER pviewhelp, HWND hWndListView, BOOL fEnabled)
{
	int		i;
	DWORD	dwState;

	pviewhelp->fInserting = TRUE;

	for (i=0; i<ListView_GetItemCount(hWndListView); i++)
	{
		dwState = MyGetCheckState(hWndListView, i);

		if ((dwState == MY_CHECK_STATE_CHECKED_GRAYED) ||
			(dwState == MY_CHECK_STATE_UNCHECKED_GRAYED))
		{
			if (fEnabled)
			{
				MySetCheckState(
						hWndListView,
						i,
						(dwState == MY_CHECK_STATE_CHECKED_GRAYED) ? MY_CHECK_STATE_CHECKED : MY_CHECK_STATE_UNCHECKED);
			}
		}
		else
		{
			if (!fEnabled)
			{
				MySetCheckState(
						hWndListView,
						i,
						(dwState == MY_CHECK_STATE_CHECKED) ? MY_CHECK_STATE_CHECKED_GRAYED : MY_CHECK_STATE_UNCHECKED_GRAYED);
			}
		}
	}

	pviewhelp->fInserting = FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void AddUsageToList(
                    HWND            hWndListView,
                    LPSTR           pszOID,
                    DWORD           dwImage,
                    BOOL            fDirty)
{
    WCHAR                       szText[CRYPTUI_MAX_STRING_SIZE];
    LV_ITEMW                    lvI;
    SETPROPERTIES_HELPER_STRUCT *pHelperStruct;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    memset(&lvI, 0, sizeof(lvI));
    lvI.mask = LVIF_TEXT | LVIF_PARAM;
    lvI.pszText = szText;
    lvI.iSubItem = 0;
    lvI.lParam = (LPARAM)NULL;
    lvI.iItem = ListView_GetItemCount(hWndListView);

    // get the display string for the usage
    if (!MyGetOIDInfo(szText, ARRAYSIZE(szText), pszOID))
    {
        return;
    }
    lvI.cchTextMax = wcslen(szText);

    // set the lParam field the helper struct so that we always have access the oid and
    // the initial check state
    pHelperStruct = NULL;
    pHelperStruct =
        (SETPROPERTIES_HELPER_STRUCT *) malloc(sizeof(SETPROPERTIES_HELPER_STRUCT) + (strlen(pszOID)+1));

    if (pHelperStruct != NULL)
    {
        pHelperStruct->pszOID = (LPSTR) (((LPBYTE)pHelperStruct) + sizeof(SETPROPERTIES_HELPER_STRUCT));
        lvI.lParam = (LPARAM) pHelperStruct;
        strcpy(pHelperStruct->pszOID, pszOID);

        //
        // if the dirty flag was passed in, then set the initial image to iImage+1
        // so that when we are checking to see if anything has changed on shutdown
        // we know this is a usage that was added after the dialog was brought up.
        //
        if (fDirty)
        {
            pHelperStruct->initialState = dwImage+1;
        }
        else
        {
            pHelperStruct->initialState = dwImage;
        }
    }
    else
    {
        return;
    }

    ListView_InsertItemU(hWndListView, &lvI);

    //
    // for some reason you can't set the state image when inserting the
    // item, so set the state image after it has been inserted
    //
    MySetCheckState(hWndListView, lvI.iItem, dwImage);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void DisplayKeyUsages(
                    HWND                        hWndListView,
                    PCERT_SETPROPERTIES_HELPER  pviewhelp)
{
    DWORD               i;
    LPSTR               *pszOIDs = NULL;
    DWORD               numOIDs = 0;
    DWORD               cbPropertyUsage = 0;
    PCERT_ENHKEY_USAGE  pPropertyUsage = NULL;
    DWORD               cbEKUExtensionUsage = 0;
    PCERT_ENHKEY_USAGE  pEKUExtensionUsage = NULL;
    DWORD               dwImage;
    DWORD               displayState;
    int                 j;
    PCCERT_CONTEXT      pCertContext = pviewhelp->pcsp->pCertContext;
    LVITEMW             lvI;

    //
    // get the property usages that are currently tagged to this cert
    //
    if(!CertGetEnhancedKeyUsage (
                pCertContext,
                CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
                NULL,
                &cbPropertyUsage
                )                                                               ||
        (pPropertyUsage = (PCERT_ENHKEY_USAGE) malloc(cbPropertyUsage)) == NULL ||
        !CertGetEnhancedKeyUsage (
                pCertContext,
                CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
                pPropertyUsage,
                &cbPropertyUsage
                ) )
    {

        if (GetLastError() == CRYPT_E_NOT_FOUND)
        {
            if (pPropertyUsage != NULL)
                free(pPropertyUsage);
            pPropertyUsage = NULL;
        }
        else
        {
            goto CleanUp;
        }
    }

    //
    // get the EKU usages that are in the cert
    //
    if(!CertGetEnhancedKeyUsage (
                pCertContext,
                CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                NULL,
                &cbEKUExtensionUsage
                )                                                               ||
        (pEKUExtensionUsage = (PCERT_ENHKEY_USAGE) malloc(cbEKUExtensionUsage)) == NULL ||
        !CertGetEnhancedKeyUsage (
                pCertContext,
                CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                pEKUExtensionUsage,
                &cbEKUExtensionUsage
                ) )
    {

        if (GetLastError() == CRYPT_E_NOT_FOUND)
        {
            if (pEKUExtensionUsage != NULL)
                free(pEKUExtensionUsage);
            pEKUExtensionUsage = NULL;
        }
        else
        {
            goto CleanUp;
        }
    }

    //
    // set the property state so the INIT_DIALOG can set the correct state
    //
    if (pPropertyUsage == NULL)
    {
         pviewhelp->EKUPropertyState = PROPERTY_STATE_ALL_ENABLED;
    }
    else if (fPropertiesDisabled(pPropertyUsage))
    {
        pviewhelp->EKUPropertyState = PROPERTY_STATE_ALL_DISABLED;
    }
    else
    {
        pviewhelp->EKUPropertyState = PROPERTY_STATE_SELECT;
    }

    //
    // there are four different cases that the cert can be in
    // 1) cert has property EKU only
    // 2) cert has neither
    // 3) cert has extension EKU only
    // 4) cert has both property EKU and extension EKU
    //

    if (pEKUExtensionUsage == NULL)
    {
        //
        // if we are in case 1 or 2, then all the usage that are valid
        // for the chain are entered into the list view, unless the chain
        // is good for everything, in which case the current certs valid
        // usages are entered
        //
        if (pviewhelp->cszValidUsages != -1)
        {
            for (i=0; i<(DWORD)pviewhelp->cszValidUsages; i++)
            {
                if ((pPropertyUsage == NULL) || OIDInUsages(pPropertyUsage, pviewhelp->rgszValidChainUsages[i]))
                {
                    dwImage = MY_CHECK_STATE_CHECKED;
                }
                else
                {
                    dwImage = MY_CHECK_STATE_UNCHECKED;
                }
                AddUsageToList(hWndListView, pviewhelp->rgszValidChainUsages[i], dwImage, FALSE);
            }
        }
        else
        {
            AllocAndReturnEKUList(pCertContext, &pszOIDs, &numOIDs);

            for (i=0; i<numOIDs; i++)
            {
                //
                // if there are no property usages, or if this usage is in the list of
                // property usages, then set the state to checked
                //
                if ((pPropertyUsage == NULL) || OIDInUsages(pPropertyUsage, pszOIDs[i]))
                {
                    dwImage = MY_CHECK_STATE_CHECKED;

                }
                else
                {
                    dwImage = MY_CHECK_STATE_UNCHECKED;
                }

                AddUsageToList(hWndListView, pszOIDs[i], dwImage, FALSE);
            }

            FreeEKUList(pszOIDs, numOIDs);
        }
    }
    else
    {
        //
        // for cases 3 and 4, the list view is populated with only the EKU extension,
        // and is further restricted that the EKU must be in the chain valid usages
        //
        for (i=0; i<pEKUExtensionUsage->cUsageIdentifier; i++)
        {
            //
            // if the EKU is not valid up the chain then skip the display
            //
            if ((pviewhelp->cszValidUsages != -1)   &&
                !OIDinArray(pEKUExtensionUsage->rgpszUsageIdentifier[i],
                            pviewhelp->rgszValidChainUsages,
                            pviewhelp->cszValidUsages))
            {
                continue;
            }

            //
            // if there are no properties or the usage is in the properties then
            // the usage should be checked
            //
            if ((pPropertyUsage == NULL) || OIDInUsages(pPropertyUsage, pEKUExtensionUsage->rgpszUsageIdentifier[i]))
            {
                dwImage = MY_CHECK_STATE_CHECKED;
            }
            else
            {
                dwImage = MY_CHECK_STATE_UNCHECKED;
            }
            AddUsageToList(hWndListView, pEKUExtensionUsage->rgpszUsageIdentifier[i], dwImage, FALSE);
        }
    }

CleanUp:

    if (pPropertyUsage != NULL)
        free(pPropertyUsage);

    if (pEKUExtensionUsage != NULL)
        free(pEKUExtensionUsage);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL StateChanged(HWND hWndListView)
{
    int     listIndex;
    LVITEMW lvI;

    memset(&lvI, 0, sizeof(lvI));
    lvI.mask = LVIF_STATE | LVIF_PARAM;
    lvI.stateMask = LVIS_STATEIMAGEMASK;

    listIndex = ListView_GetItemCount(hWndListView) - 1;	

    while (listIndex >= 0)
    {
        lvI.iItem = listIndex--;
        lvI.state = 0;
        lvI.lParam = 0;

        ListView_GetItem(hWndListView, &lvI);

        if (lvI.state != ((PSETPROPERTIES_HELPER_STRUCT)lvI.lParam)->initialState)
        {
            return TRUE;
        }
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static
PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW
AllocAndCopySetPropertiesStruct(PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp)
{
    PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pStruct;
    DWORD i;

    if (NULL == (pStruct = (PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW)
                            malloc(sizeof(CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW))))
    {
        return NULL;
    }
    memcpy(pStruct, pcsp, sizeof(CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW));

    if (NULL == (pStruct->rghStores = (HCERTSTORE *) malloc(sizeof(HCERTSTORE)*pcsp->cStores)))
    {
        free(pStruct);
        return NULL;
    }

    pStruct->cPropSheetPages = 0;
    pStruct->rgPropSheetPages = NULL;
    pStruct->pCertContext = CertDuplicateCertificateContext(pcsp->pCertContext);

    for (i=0; i<pcsp->cStores; i++)
    {
        pStruct->rghStores[i] = CertDuplicateStore(pcsp->rghStores[i]);
    }

    return pStruct;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void FreeSetPropertiesStruct(PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp)
{
    DWORD i;

    CertFreeCertificateContext(pcsp->pCertContext);

    for (i=0; i<pcsp->cStores; i++)
    {
        CertCloseStore(pcsp->rghStores[i], 0);
    }

    free(pcsp->rghStores);
    free(pcsp);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL OIDAlreadyExist(LPSTR pszNewOID, HWND hWndListView)
{
    LVITEMW                         lvI;
    PSETPROPERTIES_HELPER_STRUCT    pHelperStruct;

    memset(&lvI, 0, sizeof(lvI));
    lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
    lvI.mask = LVIF_PARAM;
    while (lvI.iItem >= 0)
    {
        if (ListView_GetItemU(hWndListView, &lvI))
        {
            pHelperStruct = (PSETPROPERTIES_HELPER_STRUCT) lvI.lParam;
            if (strcmp(pHelperStruct->pszOID, pszNewOID) == 0)
            {
                return TRUE;
            }
        }
        lvI.iItem--;
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL CertHasEKU(PCCERT_CONTEXT pccert)
{
    DWORD i;

    i = 0;
    while (i < pccert->pCertInfo->cExtension)
    {
        if (strcmp(pccert->pCertInfo->rgExtension[i].pszObjId, szOID_ENHANCED_KEY_USAGE) == 0)
        {
            return TRUE;
        }
        i++;
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL BuildChainEKUList(PCERT_SETPROPERTIES_HELPER pviewhelp)
{
    WINTRUST_DATA                       WTD;
    WINTRUST_CERT_INFO                  WTCI;
    CRYPT_PROVIDER_DATA const *         pProvData = NULL;
    CRYPT_PROVIDER_SGNR       *         pProvSigner = NULL;
    PCRYPT_PROVIDER_CERT                pProvCert = NULL;
    PCCERT_CONTEXT                      *rgpCertContext = NULL;
    DWORD                               i;
    BOOL                                fRet = TRUE;
    DWORD                               cbOIDs = 0;
    DWORD                               dwCertsForUsageCheck = 0;
    GUID                                defaultProviderGUID = WINTRUST_ACTION_GENERIC_CERT_VERIFY;

    pviewhelp->cszValidUsages = 0;

    //
    // initialize structs that are used with WinVerifyTrust()
    //
    memset(&WTD, 0x00, sizeof(WINTRUST_DATA));
    WTD.cbStruct       = sizeof(WINTRUST_DATA);
    WTD.dwUIChoice     = WTD_UI_NONE;
    WTD.dwUnionChoice  = WTD_CHOICE_CERT;
    WTD.pCert          = &WTCI;
    WTD.dwProvFlags    = WTD_NO_POLICY_USAGE_FLAG | WTD_REVOCATION_CHECK_NONE;

    memset(&WTCI, 0x00, sizeof(WINTRUST_CERT_INFO));
    WTCI.cbStruct          = sizeof(WINTRUST_CERT_INFO);
    WTCI.pcwszDisplayName  = L"CryptUI";
    WTCI.psCertContext     = (CERT_CONTEXT *)pviewhelp->pcsp->pCertContext;
    WTCI.chStores          = pviewhelp->pcsp->cStores;
    WTCI.pahStores         = pviewhelp->pcsp->rghStores;
    WTCI.dwFlags           = 0;

    WTD.dwStateAction = WTD_STATEACTION_VERIFY;

    //
    // the default default provider requires the policycallback data to point
    // to the usage oid you are validating for, so set it to the usage passed in
    //
    WinVerifyTrustEx(NULL, &defaultProviderGUID, &WTD);

    pProvData = WTHelperProvDataFromStateData(WTD.hWVTStateData);
    pProvSigner = WTHelperGetProvSignerFromChain((PCRYPT_PROVIDER_DATA) pProvData, 0, FALSE, 0);
    if (pProvSigner == NULL)
    {
        goto Error;
    }

    //
    // build up the array of PCCERT_CONTEXTs
    //
    rgpCertContext = (PCCERT_CONTEXT *) malloc((pProvSigner->csCertChain-1) * sizeof(PCCERT_CONTEXT));
    if (rgpCertContext == NULL)
    {
        goto Error;
    }

    for (i=1; i<pProvSigner->csCertChain; i++)
    {
        pProvCert = WTHelperGetProvCertFromChain(pProvSigner, i);
        rgpCertContext[i-1] = pProvCert->pCert;
        dwCertsForUsageCheck++;

        //
        // if there is a CTL context that contains this cert, then the usage
        // changes for certs above the CTL in the chain, so stop with this         
        // cert when calculating valid usages
        //
        if (pProvCert->pCtlContext != NULL)
        {
            break;
        }
    }

    //
    // now, get the usages array
    //
    if (!CertGetValidUsages(dwCertsForUsageCheck, rgpCertContext, &(pviewhelp->cszValidUsages), NULL, &cbOIDs))
    {
        goto Error;
    }

    if (NULL == (pviewhelp->rgszValidChainUsages = (LPSTR *) malloc(cbOIDs)))
    {
        goto Error;
    }

    if (!CertGetValidUsages(dwCertsForUsageCheck, rgpCertContext, &(pviewhelp->cszValidUsages), pviewhelp->rgszValidChainUsages, &cbOIDs))
    {
        free(pviewhelp->rgszValidChainUsages);
        pviewhelp->rgszValidChainUsages = NULL;
        goto Error;
    }

CleanUp:

    WTD.dwStateAction = WTD_STATEACTION_CLOSE;
    WinVerifyTrustEx(NULL, &defaultProviderGUID, &WTD);
    if (rgpCertContext != NULL)
    {
        free(rgpCertContext);
    }

    return fRet;

Error:
    fRet = FALSE;
    goto CleanUp;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void AddExistingPropertiesToUsage(
                                            PCCERT_CONTEXT pccert,
                                            PCERT_ENHKEY_USAGE pPropertyUsage,
                                            HWND hWndListView)
{
    PCERT_ENHKEY_USAGE  pExistingPropUsage = NULL;
    DWORD               cbExistingPropUsage = 0;
    DWORD               i;
    BOOL                fSkip = FALSE;
    LVITEMW             lvI;
    DWORD               state;
    void                *pTemp;

    //
    // get the property usages that are currently tagged to this cert
    //
    if(!CertGetEnhancedKeyUsage (
                pccert,
                CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
                NULL,
                &cbExistingPropUsage
                )                                                               ||
        (pExistingPropUsage = (PCERT_ENHKEY_USAGE) malloc(cbExistingPropUsage)) == NULL ||
        !CertGetEnhancedKeyUsage (
                pccert,
                CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
                pExistingPropUsage,
                &cbExistingPropUsage
                ) )
    {
        if (pExistingPropUsage != NULL)
        {
            free(pExistingPropUsage);
        }

        return;
    }

    //
    // loop for each usage, and add it if it does not already exist in the list,
    // AND it is not already in the list view unchecked
    //
    for (i=0; i<pExistingPropUsage->cUsageIdentifier; i++)
    {
        if (!OIDInUsages(pPropertyUsage, pExistingPropUsage->rgpszUsageIdentifier[i]))
        {
            fSkip = FALSE;

            //
            // if the property is unchecked in the list view then skip it
            //
            memset(&lvI, 0, sizeof(lvI));
            lvI.mask = LVIF_PARAM;
            lvI.lParam = (LPARAM)NULL;
            lvI.iItem = ListView_GetItemCount(hWndListView) - 1;
            lvI.iSubItem = 0;

            while (lvI.iItem >= 0)
            {
                if (ListView_GetItemU(hWndListView, &lvI))
                {
                    if (strcmp(((PSETPROPERTIES_HELPER_STRUCT)lvI.lParam)->pszOID,
                        pExistingPropUsage->rgpszUsageIdentifier[i]) == 0)
                    {
                        state = MyGetCheckState(hWndListView, lvI.iItem);

                        if ((state == MY_CHECK_STATE_UNCHECKED) || (state == MY_CHECK_STATE_UNCHECKED_GRAYED))
                        {
                            fSkip = TRUE;
                            break;
                        }
                    }
                }
                lvI.iItem--;
            }

            if (fSkip)
            {
                continue;
            }

            //
            // allocate space for a pointer to the usage OID string
            //
            if (pPropertyUsage->cUsageIdentifier++ == 0)
            {
                pPropertyUsage->rgpszUsageIdentifier = (LPSTR *) malloc (sizeof(LPSTR));
            }
            else
            {
                pTemp = realloc (pPropertyUsage->rgpszUsageIdentifier,
                                       sizeof(LPSTR) * pPropertyUsage->cUsageIdentifier);
                if (pTemp == NULL)
                {
                    free(pPropertyUsage->rgpszUsageIdentifier);
                    pPropertyUsage->rgpszUsageIdentifier = NULL;
                }
                else
                {
                    pPropertyUsage->rgpszUsageIdentifier = (LPSTR *) pTemp;
                }
            }

            if (pPropertyUsage->rgpszUsageIdentifier == NULL)
            {
                pPropertyUsage->cUsageIdentifier = 0;
                return;
            }

            pPropertyUsage->rgpszUsageIdentifier[pPropertyUsage->cUsageIdentifier-1] =
                AllocAndCopyMBStr(pExistingPropUsage->rgpszUsageIdentifier[i]);
        }
    }

    if (pExistingPropUsage != NULL)
    {
        free(pExistingPropUsage);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageSetPropertiesGeneral(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL                f;
    DWORD               cch;
    PCCERT_CONTEXT      pccert;
    PROPSHEETPAGE *     ps;
    LPWSTR              pwsz;
    WCHAR               rgwch[CRYPTUI_MAX_STRING_SIZE];
    CRYPT_DATA_BLOB     CryptDataBlob;
    DWORD               cbpwsz;
    HIMAGELIST          hIml;
    HWND                hWndListView;
    HWND                hwnd;
    LV_COLUMNW          lvC;
    LVITEMW             lvI;
    LPNMLISTVIEW        pnmv;
    DWORD               state;
    LPSTR               pszNewOID;
    WCHAR               errorString[CRYPTUI_MAX_STRING_SIZE];
    WCHAR               errorTitle[CRYPTUI_MAX_STRING_SIZE];
    int                 j;
    DWORD               i;
    void                *pTemp;
    PCERT_SETPROPERTIES_HELPER pviewhelp;
    PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp = NULL;

    switch ( msg ) {
    case WM_INITDIALOG:

        //
        // save the pviewhelp struct in DWL_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (PCERT_SETPROPERTIES_HELPER) ps->lParam;
        pcsp = (PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW) pviewhelp->pcsp;
        pccert = pcsp->pCertContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pviewhelp);

        fRichedit20Usable(GetDlgItem(hwndDlg, IDC_HIDDEN_RICHEDIT));
        ShowWindow(GetDlgItem(hwndDlg, IDC_HIDDEN_RICHEDIT), SW_HIDE);
        
        //
        // Set the Certificate Name (friendly name) and Description fields in the dialog box
        //
        cbpwsz = 0;
        if (CertGetCertificateContextProperty(  pccert,
                                                CERT_FRIENDLY_NAME_PROP_ID,
                                                NULL,
                                                &cbpwsz))
        {
            //
            // The Certificate Name (friendly name) property exists, so display it
            //
            pviewhelp->pwszInitialCertName = (LPWSTR) malloc(cbpwsz);
            if (pviewhelp->pwszInitialCertName != NULL)
            {
                CertGetCertificateContextProperty(  pccert,
                                                    CERT_FRIENDLY_NAME_PROP_ID,
                                                    pviewhelp->pwszInitialCertName,
                                                    &cbpwsz);
                CryptUISetRicheditTextW(hwndDlg, IDC_CERTIFICATE_NAME, pviewhelp->pwszInitialCertName);
            }
        }
        else
        {
            //
            // The Certificate Name (friendly name) property did not exist, so display the default
            //
            //LoadStringU(HinstDll, IDS_DEFAULT_CERTIFICATE_NAME, rgwch, ARRAYSIZE(rgwch));
            CryptUISetRicheditTextW(hwndDlg, IDC_CERTIFICATE_NAME, L"");
            pviewhelp->pwszInitialCertName = AllocAndCopyWStr(L"");
        }

        // DSIE: IE 6 bug #13676.
        SendDlgItemMessage(hwndDlg, IDC_CERTIFICATE_NAME, EM_EXLIMITTEXT, 0, (LPARAM) 40);

        cbpwsz = 0;
        if (CertGetCertificateContextProperty(  pccert,
                                                CERT_DESCRIPTION_PROP_ID,
                                                NULL,
                                                &cbpwsz))
        {
            //
            // The Description property exists, so display it
            //
            pviewhelp->pwszInitialDescription = (LPWSTR) malloc(cbpwsz);
            if (pviewhelp->pwszInitialDescription != NULL)
            {
                CertGetCertificateContextProperty(  pccert,
                                                    CERT_DESCRIPTION_PROP_ID,
                                                    pviewhelp->pwszInitialDescription,
                                                    &cbpwsz);
                CryptUISetRicheditTextW(hwndDlg, IDC_DESCRIPTION, pviewhelp->pwszInitialDescription);
            }
        }
        else
        {
            //
            // The Description property did not exist, so display the default
            //
            //LoadStringU(HinstDll, IDS_DEFAULT_DESCRIPTION, rgwch, ARRAYSIZE(rgwch));
            CryptUISetRicheditTextW(hwndDlg, IDC_DESCRIPTION, L"");
            pviewhelp->pwszInitialDescription = AllocAndCopyWStr(L"");
        }

        // DSIE: IE 6 bug #13676.
        SendDlgItemMessage(hwndDlg, IDC_DESCRIPTION, EM_EXLIMITTEXT, 0, (LPARAM) 255);

        //
        // get the handle of the list view control
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST);

        //
        // initialize the image list for the list view, load the icons,
        // then add the image list to the list view
        //
        ListView_SetExtendedListViewStyle(hWndListView, LVS_EX_CHECKBOXES);
        hIml = ImageList_LoadImage(HinstDll, MAKEINTRESOURCE(IDB_CHECKLIST), 0, 4, RGB(255,0,255), IMAGE_BITMAP, 0);
        if (hIml != NULL)
        {
            ListView_SetImageList(hWndListView, hIml, LVSIL_STATE);
        }        

        //
        // initialize the columns in the list view
        //
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.cx = 330;            // Width of the column, in pixels.
        lvC.pszText = L"";   // The text for the column.
        if (ListView_InsertColumnU(hWndListView, 0, &lvC) == -1)
        {
                // error
        }

        BuildChainEKUList(pviewhelp);

        pviewhelp->fInserting = TRUE;
        DisplayKeyUsages(hWndListView, pviewhelp);
        pviewhelp->fInserting = FALSE;

        //
        // set the flag noting whether the add purposes button can be
		// enabled based on wether there are EKU's in the cert, and if
		// the chain is NOT valid for all usages
        //
        if (CertHasEKU(pccert) || (pviewhelp->cszValidUsages != -1))
        {
            pviewhelp->fAddPurposeCanBeEnabled = FALSE;
		}
        else
        {
            pviewhelp->fAddPurposeCanBeEnabled = TRUE;
		}

        //
        // set the state of the property editing controls based on the
        // state of the eku PROPERTY
        //
        if (pviewhelp->EKUPropertyState == PROPERTY_STATE_ALL_ENABLED)
        {
            SendDlgItemMessage(hwndDlg, IDC_ENABLE_ALL_RADIO, BM_SETCHECK, BST_CHECKED, (LPARAM) 0);
            SetEnableStateForChecks(pviewhelp, GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), FALSE);
			EnableWindow(GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), FALSE);
			EnableWindow(GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID), FALSE);
            pviewhelp->dwRadioButtonState = IDC_ENABLE_ALL_RADIO;
		}
        else if (pviewhelp->EKUPropertyState == PROPERTY_STATE_ALL_DISABLED)
        {
            SendDlgItemMessage(hwndDlg, IDC_DISABLE_ALL_RADIO, BM_SETCHECK, BST_CHECKED, (LPARAM) 0);
            SetEnableStateForChecks(pviewhelp, GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), FALSE);
			EnableWindow(GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), FALSE);
			EnableWindow(GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID), FALSE);
            pviewhelp->dwRadioButtonState = IDC_DISABLE_ALL_RADIO;
		}
        else if (pviewhelp->EKUPropertyState == PROPERTY_STATE_SELECT)
        {
            SendDlgItemMessage(hwndDlg, IDC_ENABLE_SELECT_RADIO, BM_SETCHECK, BST_CHECKED, (LPARAM) 0);
            EnableWindow(GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), TRUE);
			SetEnableStateForChecks(pviewhelp, GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), TRUE);
			if (pviewhelp->fAddPurposeCanBeEnabled)
			{
				EnableWindow(GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID), TRUE);
			}
			else
			{
				EnableWindow(GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID), FALSE);
			}
            pviewhelp->dwRadioButtonState = IDC_ENABLE_SELECT_RADIO;
        }

        //
        // make sure we get change notifications from the richedit controls
        //
        SendDlgItemMessageA(hwndDlg, IDC_CERTIFICATE_NAME, EM_SETEVENTMASK, 0, (LPARAM) ENM_CHANGE);
        SendDlgItemMessageA(hwndDlg, IDC_DESCRIPTION, EM_SETEVENTMASK, 0, (LPARAM) ENM_CHANGE);

        //DSIE: Bug 465438.
        if (pcsp->dwFlags & CRYPTUI_DISABLE_EDITPROPERTIES)
        {
            SendMessage(GetDlgItem(hwndDlg, IDC_CERTIFICATE_NAME), EM_SETREADONLY, (WPARAM) TRUE, (LPARAM) 0);
            SendMessage(GetDlgItem(hwndDlg, IDC_DESCRIPTION), EM_SETREADONLY, (WPARAM) TRUE, (LPARAM) 0);
            EnableWindow(GetDlgItem(hwndDlg, IDC_ENABLE_ALL_RADIO), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_DISABLE_ALL_RADIO), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_ENABLE_SELECT_RADIO), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID), FALSE);
        }

        return TRUE;

    case WM_NOTIFY:
        pviewhelp = (PCERT_SETPROPERTIES_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcsp = (PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW) pviewhelp->pcsp;
        pccert = pcsp->pCertContext;

        switch (((NMHDR FAR *) lParam)->code) {

        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            {
            BOOL                fAllItemsChecked = TRUE;
            DWORD               cbPropertyUsage = 0;
            PCERT_ENHKEY_USAGE  pPropertyUsage = NULL;
            GETTEXTEX           GetTextStruct;

            memset(&GetTextStruct, 0, sizeof(GetTextStruct));
            GetTextStruct.flags = GT_DEFAULT;
            GetTextStruct.codepage = 1200; //UNICODE

            //
            //  Write back the Friendly name
            //  and description if they have changed
            //

            //
            // Friendly Name
            //

            cch = (DWORD)SendDlgItemMessage(hwndDlg, IDC_CERTIFICATE_NAME,
                                     WM_GETTEXTLENGTH, 0, 0);
            pwsz = (LPWSTR) malloc((cch+1)*sizeof(WCHAR));
            if (pwsz != NULL)
            {
                memset(pwsz, 0, (cch+1)*sizeof(WCHAR));
                if (fRichedit20Exists && fRichedit20Usable(GetDlgItem(hwndDlg, IDC_HIDDEN_RICHEDIT)))
                {
                    GetTextStruct.cb = (cch+1)*sizeof(WCHAR);
                    SendDlgItemMessageA(
                            hwndDlg, 
                            IDC_CERTIFICATE_NAME, 
                            EM_GETTEXTEX, 
                            (WPARAM) &GetTextStruct,
                            (LPARAM) pwsz);
                }
                else
                {
                    GetDlgItemTextU(hwndDlg, IDC_CERTIFICATE_NAME, pwsz, cch+1);
                }

                //
                // check for change
                //
                if (wcscmp(pviewhelp->pwszInitialCertName, pwsz) != 0)
                {
                    if (wcscmp(pwsz, L"") == 0)
                    {
                        f = CertSetCertificateContextProperty(pccert,
                                                              CERT_FRIENDLY_NAME_PROP_ID, 0,
                                                              NULL);
                    }
                    else
                    {
                        CryptDataBlob.pbData = (LPBYTE) pwsz;
                        CryptDataBlob.cbData = (cch+1)*sizeof(WCHAR);
                        f = CertSetCertificateContextProperty(pccert,
                                                              CERT_FRIENDLY_NAME_PROP_ID, 0,
                                                              &CryptDataBlob);
                    }

                    if (pviewhelp->pfPropertiesChanged != NULL)
                    {
                        *(pviewhelp->pfPropertiesChanged) = TRUE;
                    }
                    pviewhelp->fPropertiesChanged = TRUE;
                }
                free(pwsz);
            }

            //
            // Description
            //

            cch = (DWORD)SendDlgItemMessage(hwndDlg, IDC_DESCRIPTION,
                                     WM_GETTEXTLENGTH, 0, 0);
            pwsz = (LPWSTR) malloc((cch+1)*sizeof(WCHAR));
            if (pwsz != NULL)
            {
                memset(pwsz, 0, (cch+1)*sizeof(WCHAR));
                if (fRichedit20Exists && fRichedit20Usable(GetDlgItem(hwndDlg, IDC_HIDDEN_RICHEDIT)))
                {
                    GetTextStruct.cb = (cch+1)*sizeof(WCHAR);
                    SendDlgItemMessageA(
                            hwndDlg, 
                            IDC_DESCRIPTION, 
                            EM_GETTEXTEX, 
                            (WPARAM) &GetTextStruct,
                            (LPARAM) pwsz);
                }
                else
                {
                    GetDlgItemTextU(hwndDlg, IDC_DESCRIPTION, pwsz, cch+1);
                }

                //
                // check for change
                //
                if (wcscmp(pviewhelp->pwszInitialDescription, pwsz) != 0)
                {
                    if (wcscmp(pwsz, L"") == 0)
                    {
                        f = CertSetCertificateContextProperty(pccert,
                                                              CERT_DESCRIPTION_PROP_ID, 0,
                                                              NULL);
                    }
                    else
                    {
                        CryptDataBlob.pbData = (LPBYTE) pwsz;
                        CryptDataBlob.cbData = (cch+1)*sizeof(WCHAR);
                        f = CertSetCertificateContextProperty(pccert,
                                                              CERT_DESCRIPTION_PROP_ID, 0,
                                                              &CryptDataBlob);
                    }

                    if (pviewhelp->pfPropertiesChanged != NULL)
                    {
                        *(pviewhelp->pfPropertiesChanged) = TRUE;
                    }
                    pviewhelp->fPropertiesChanged = TRUE;
                }
                free(pwsz);
            }

            hWndListView = GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST);

            //
            // check the radio buttons and the  usages to see if any have changed,
            // if so, then set the fPropertiesFlag in the CERT_VIEWCERT_STRUCT so the
            // caller knows that something has changed
            //
            if ((pviewhelp->EKUPropertyState == PROPERTY_STATE_ALL_ENABLED) &&
                (SendDlgItemMessage(hwndDlg, IDC_ENABLE_ALL_RADIO, BM_GETCHECK, 0, (LPARAM) 0) == BST_CHECKED))
            {
                //pviewhelp->fPropertiesChanged = FALSE;
            }
            else if ((pviewhelp->EKUPropertyState == PROPERTY_STATE_ALL_DISABLED) &&
                (SendDlgItemMessage(hwndDlg, IDC_DISABLE_ALL_RADIO, BM_GETCHECK, 0, (LPARAM) 0) == BST_CHECKED))
            {
                //pviewhelp->fPropertiesChanged = FALSE;
            }
            else if ((pviewhelp->EKUPropertyState == PROPERTY_STATE_SELECT) &&
                     (SendDlgItemMessage(hwndDlg, IDC_ENABLE_SELECT_RADIO, BM_GETCHECK, 0, (LPARAM) 0) == BST_CHECKED) &&
                     (!StateChanged(hWndListView)))
            {
                //pviewhelp->fPropertiesChanged = FALSE;
            }
            else
            {
                pviewhelp->fPropertiesChanged = TRUE;
            }

            if (pviewhelp->pfPropertiesChanged != NULL)
            {
                *(pviewhelp->pfPropertiesChanged) |= pviewhelp->fPropertiesChanged;
            }

            if ((SendDlgItemMessage(hwndDlg, IDC_ENABLE_ALL_RADIO, BM_GETCHECK, 0, (LPARAM) 0) == BST_CHECKED) &&
                pviewhelp->fPropertiesChanged)
            {
                CertSetEnhancedKeyUsage(pccert, NULL);
            }
            else if ((SendDlgItemMessage(hwndDlg, IDC_DISABLE_ALL_RADIO, BM_GETCHECK, 0, (LPARAM) 0) == BST_CHECKED) &&
                     pviewhelp->fPropertiesChanged)
            {
                CERT_ENHKEY_USAGE eku;

                eku.cUsageIdentifier = 0;
                eku.rgpszUsageIdentifier = NULL;

                CertSetEnhancedKeyUsage(pccert, &eku);
            }
            else if ((SendDlgItemMessage(hwndDlg, IDC_ENABLE_SELECT_RADIO, BM_GETCHECK, 0, (LPARAM) 0) == BST_CHECKED) &&
                     pviewhelp->fPropertiesChanged)
            {
                if (NULL == (pPropertyUsage = (PCERT_ENHKEY_USAGE) malloc(sizeof(CERT_ENHKEY_USAGE))))
                {
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
                    return FALSE;
                }
                pPropertyUsage->cUsageIdentifier = 0;
                pPropertyUsage->rgpszUsageIdentifier = NULL;

                //
                // enumerate through all the items and add to the properties
                // if checked
                //
                memset(&lvI, 0, sizeof(lvI));
                lvI.mask = LVIF_PARAM;
                lvI.lParam = (LPARAM)NULL;
                lvI.iItem = ListView_GetItemCount(hWndListView) - 1;
                lvI.iSubItem = 0;

                while (lvI.iItem >= 0)
                {
                    if (!ListView_GetItemU(hWndListView, &lvI))
                    {
                        lvI.iItem--;
                        continue;
                    }

                    state = MyGetCheckState(hWndListView, lvI.iItem);

                    if ((state == MY_CHECK_STATE_CHECKED) || (state == MY_CHECK_STATE_CHECKED_GRAYED))
                    {
                        //
                        // allocate space for a pointer to the usage OID string
                        //
                        if (pPropertyUsage->cUsageIdentifier++ == 0)
                        {
                            pPropertyUsage->rgpszUsageIdentifier = (LPSTR *) malloc (sizeof(LPSTR));
                        }
                        else
                        {
                            pTemp = realloc (pPropertyUsage->rgpszUsageIdentifier,
                                                   sizeof(LPSTR) * pPropertyUsage->cUsageIdentifier);
                            if (pTemp == NULL)
                            {
                                free(pPropertyUsage->rgpszUsageIdentifier);
                                pPropertyUsage->rgpszUsageIdentifier = NULL;
                            }
                            else
                            {
                                pPropertyUsage->rgpszUsageIdentifier = (LPSTR *) pTemp;
                            }
                        }

                        if (pPropertyUsage->rgpszUsageIdentifier == NULL)
                        {
                            free(pPropertyUsage);
                            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
                            return FALSE;
                        }

                        pPropertyUsage->rgpszUsageIdentifier[pPropertyUsage->cUsageIdentifier-1] =
                            AllocAndCopyMBStr(((PSETPROPERTIES_HELPER_STRUCT)lvI.lParam)->pszOID);
                    }

                    lvI.iItem--;
                }

                AddExistingPropertiesToUsage(pccert, pPropertyUsage, hWndListView);

                CertSetEnhancedKeyUsage(pccert, pPropertyUsage);

                for (i=0; i<pPropertyUsage->cUsageIdentifier; i++)
                {
                    free(pPropertyUsage->rgpszUsageIdentifier[i]);
                }
                if (pPropertyUsage->rgpszUsageIdentifier)
                    free(pPropertyUsage->rgpszUsageIdentifier);
            }

            if (pPropertyUsage != NULL)
                free(pPropertyUsage);

            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;
            }
        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case PSN_HELP:
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pcsp->szHelpFileName,
                  //       HELP_CONTEXT, pcsp->dwHelpId);
            }
            else {
               // WinHelpW(hwndDlg, pcsp->szHelpFileName, HELP_CONTEXT,
                 //        pcsp->dwHelpId);
            }
            return TRUE;
        case LVN_ITEMCHANGING:

            if (pviewhelp->fInserting)
            {
                return TRUE;
            }

            pnmv = (LPNMLISTVIEW) lParam;
            hWndListView = GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST);

            state = LVIS_STATEIMAGEMASK & pnmv->uOldState;

            if ((state == MY_CHECK_STATE_CHECKED_GRAYED) || (state == MY_CHECK_STATE_UNCHECKED_GRAYED))
            {
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            }
            else if ((state == MY_CHECK_STATE_CHECKED) || (state == MY_CHECK_STATE_UNCHECKED))
            {
                pviewhelp->fInserting = TRUE;
                if (state == MY_CHECK_STATE_CHECKED)
                {
                    MySetCheckState(hWndListView, pnmv->iItem, MY_CHECK_STATE_UNCHECKED);
                }
                else
                {
                    MySetCheckState(hWndListView, pnmv->iItem, MY_CHECK_STATE_CHECKED);
                }
                pviewhelp->fInserting = FALSE;
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            }

            return TRUE;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_KEY_USAGE_LIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED | LVIS_SELECTED;
                    lvI.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;
            }
            
            break;
        }

        break;

    case WM_COMMAND:

        pviewhelp = (PCERT_SETPROPERTIES_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcsp = (PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW) pviewhelp->pcsp;
        pccert = pcsp->pCertContext;

        switch (LOWORD(wParam))
        {
        case IDHELP:
            if (FIsWin95)
            {
                //WinHelpA(hwndDlg, (LPSTR) pcsp->szHelpFileName,
                  //       HELP_CONTEXT, pcsp->dwHelpId);
            }
            else
            {
                //WinHelpW(hwndDlg, pcsp->szHelpFileName, HELP_CONTEXT,
                  //     pcsp->dwHelpId);
            }
            return TRUE;

        case IDC_CERTIFICATE_NAME:
            if (HIWORD(wParam) == EN_SETFOCUS)
            {
                SendDlgItemMessageA(hwndDlg, IDC_CERTIFICATE_NAME, EM_SETSEL, 0, -1);
                return TRUE;
            }
            else if (HIWORD(wParam) == EN_CHANGE)
            {
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            }
            break;

        case IDC_DESCRIPTION:
            if (HIWORD(wParam) == EN_SETFOCUS)
            {
                SendDlgItemMessageA(hwndDlg, IDC_DESCRIPTION, EM_SETSEL, 0, -1);
                return TRUE;
            }
            else if (HIWORD(wParam) == EN_CHANGE)
            {
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            }
            break;

        case IDC_ENABLE_ALL_RADIO:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                SetEnableStateForChecks(pviewhelp, GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), FALSE);
				EnableWindow(GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), FALSE);
				EnableWindow(GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID), FALSE);
                if (pviewhelp->dwRadioButtonState != IDC_ENABLE_ALL_RADIO)
                {
                    PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
                    pviewhelp->dwRadioButtonState = IDC_ENABLE_ALL_RADIO;
                }
            }
            break;

        case IDC_DISABLE_ALL_RADIO:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                SetEnableStateForChecks(pviewhelp, GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), FALSE);
				EnableWindow(GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), FALSE);
				EnableWindow(GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID), FALSE);
                if (pviewhelp->dwRadioButtonState != IDC_DISABLE_ALL_RADIO)
                {
                    PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
                    pviewhelp->dwRadioButtonState = IDC_DISABLE_ALL_RADIO;
                }
            }
            break;

        case IDC_ENABLE_SELECT_RADIO:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), TRUE);
				SetEnableStateForChecks(pviewhelp, GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), TRUE);
				if (pviewhelp->fAddPurposeCanBeEnabled)
				{
					EnableWindow(GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID), TRUE);
				}
				else
				{
					EnableWindow(GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID), FALSE);
				}

                if (pviewhelp->dwRadioButtonState != IDC_ENABLE_SELECT_RADIO)
                {
                    PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
                    pviewhelp->dwRadioButtonState = IDC_ENABLE_SELECT_RADIO;
                }
            }
            break;

        case IDC_PROPERTY_NEWOID:
            pszNewOID = (LPSTR) DialogBoxU(
                                    HinstDll,
                                    (LPWSTR) MAKEINTRESOURCE(IDD_USER_PURPOSE),
                                    hwndDlg,
                                    NewOIDDialogProc);

            if (pszNewOID != NULL)
            {
                DWORD       chStores = 0;
                HCERTSTORE  *phStores = NULL;

                //
                // if the OID already existis then put up a message box and return
                //
                if (OIDAlreadyExist(pszNewOID, GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST)))
                {
                    WCHAR   errorString2[CRYPTUI_MAX_STRING_SIZE];
                    WCHAR   errorTitle2[CRYPTUI_MAX_STRING_SIZE];

                    LoadStringU(HinstDll, IDS_OID_ALREADY_EXISTS_MESSAGE, errorString2, ARRAYSIZE(errorString2));
                    LoadStringU(HinstDll, IDS_CERTIFICATE_PROPERTIES, errorTitle2, ARRAYSIZE(errorTitle2));
                    MessageBoxU(hwndDlg, errorString2, errorTitle2, MB_OK | MB_ICONWARNING);
                    return FALSE;
                }

                //
                // if the usage doesn't exist in the chain usages, then put up an error
                //
                /*if ((pviewhelp->cszValidUsages != -1)   && //pviewhelp->cszValidUsages == -1 means all usages are ok
                    !OIDinArray(pszNewOID, pviewhelp->rgszValidChainUsages, pviewhelp->cszValidUsages))
                {
                    LoadStringU(HinstDll, IDS_ERROR_INVALIDOID_CERT, errorString2, ARRAYSIZE(errorString2));
                    LoadStringU(HinstDll, IDS_CERTIFICATE_PROPERTIES, errorTitle2, ARRAYSIZE(errorTitle2));
                    MessageBoxU(hwndDlg, errorString2, errorTitle2, MB_OK | MB_ICONERROR);
                    return FALSE;
                } */

                pviewhelp->fInserting = TRUE;
                AddUsageToList(GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST), pszNewOID, MY_CHECK_STATE_CHECKED, TRUE);
                pviewhelp->fInserting = FALSE;

                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

                free(pszNewOID);
            }
            break;
        }
        break;

    case WM_DESTROY:

        pviewhelp = (PCERT_SETPROPERTIES_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);

        //
        // get all the items in the list view and free the lParam
        // associated with each of them (lParam is the helper sruct)
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST);

        memset(&lvI, 0, sizeof(lvI));
        lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
        lvI.mask = LVIF_PARAM;
        while (lvI.iItem >= 0)
        {
            if (ListView_GetItemU(hWndListView, &lvI))
            {
                free((void *) lvI.lParam);
            }
            lvI.iItem--;
        }

        //
        // free the name and description if they exist
        //
        if (pviewhelp->pwszInitialCertName)
        {
            free (pviewhelp->pwszInitialCertName);
        }
        if (pviewhelp->pwszInitialDescription)
        {
            free (pviewhelp->pwszInitialDescription);
        }

        //
        // free the usage array
        //
        if (pviewhelp->rgszValidChainUsages)
        {
            free(pviewhelp->rgszValidChainUsages);
        }

        //
        // if the properties have changed, and there is a pMMCCallback
        // then make the callback to MMC
        //
        if (pviewhelp->fPropertiesChanged               &&
            pviewhelp->fGetPagesCalled                  &&
            (pviewhelp->pcsp->pMMCCallback != NULL)     &&
            (pviewhelp->fMMCCallbackMade != TRUE))
        {
            pviewhelp->fMMCCallbackMade = TRUE;

            (*(pviewhelp->pcsp->pMMCCallback->pfnCallback))(
                        pviewhelp->pcsp->pMMCCallback->lNotifyHandle,
                        pviewhelp->pcsp->pMMCCallback->param);
        }

        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_CERTIFICATE_NAME))		&&
            (hwnd != GetDlgItem(hwndDlg, IDC_DESCRIPTION))			&&
            (hwnd != GetDlgItem(hwndDlg, IDC_KEY_USAGE_LIST))		&&
			(hwnd != GetDlgItem(hwndDlg, IDC_ENABLE_ALL_RADIO))		&&
			(hwnd != GetDlgItem(hwndDlg, IDC_DISABLE_ALL_RADIO))	&&
			(hwnd != GetDlgItem(hwndDlg, IDC_ENABLE_SELECT_RADIO))  &&
            (hwnd != GetDlgItem(hwndDlg, IDC_PROPERTY_NEWOID)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmapGeneral);
        }

        break;
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
#define MAX_DWORD_SIZE  ((DWORD) 0xffffffff)


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageSetPropertiesCrossCerts(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL                        f;
    DWORD                       cch;
    PCCERT_CONTEXT              pccert;
    PROPSHEETPAGE *             ps;
    LPWSTR                      pwsz;
    WCHAR                       rgwch[CRYPTUI_MAX_STRING_SIZE];
    CRYPT_DATA_BLOB             CryptDataBlob;
    HWND                        hWndListView;
    HWND                        hwnd;
    LVITEMW                     lvI;
    LV_COLUMNW                  lvC;
    LPNMLISTVIEW                pnmv;
    WCHAR                       errorString[CRYPTUI_MAX_STRING_SIZE];
    WCHAR                       errorTitle[CRYPTUI_MAX_STRING_SIZE];
    DWORD                       dw;
    int                         i;
    void                        *pTemp;
    PCERT_SETPROPERTIES_HELPER pviewhelp;
    PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp = NULL;
    DWORD                       cb = 0;
    BYTE                        *pb = NULL;
    CROSS_CERT_DIST_POINTS_INFO *pCrossCertInfo = NULL;
    CROSS_CERT_DIST_POINTS_INFO CrossCertInfo;
    DWORD                       cbCrossCertInfo = 0;
    LPWSTR                      pwszStringToAdd = NULL;
    PCERT_ALT_NAME_INFO         pAltNameInfo = NULL;
    BOOL                        fChecked;
    WCHAR                       wszText[CRYPTUI_MAX_STRING_SIZE];
    DWORD                       dwNumUnits = 0;
    LPWSTR                      pwszURL = NULL;
    DWORD                       dwLength;
    BOOL                        fTranslated;                      
    PCERT_ALT_NAME_ENTRY        rgAltEntry;
    LONG_PTR                    PrevWndProc;
    DWORD                       dwSecsPerUnit    = 1;
    HWND                        hwndControl=NULL;
    int                         listIndex=0;

    switch ( msg ) {
    case WM_INITDIALOG:

        //
        // save the pviewhelp struct in DWL_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (PCERT_SETPROPERTIES_HELPER) ps->lParam;
        pcsp = (PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW) pviewhelp->pcsp;
        pccert = pcsp->pCertContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pviewhelp);

        pviewhelp->InWMInit = TRUE;

        hWndListView = GetDlgItem(hwndDlg, IDC_URL_LIST);

        SendDlgItemMessage(hwndDlg, IDC_NUMBEROFUNITS_EDIT, EM_LIMITTEXT, (WPARAM) 7, (LPARAM) 0);
        SendDlgItemMessage(hwndDlg, IDC_NEWURL_EDIT, EM_LIMITTEXT, (WPARAM) 512, (LPARAM) 0);

        //
        // Initialize the combo box fields
        //
        LoadStringU(HinstDll, IDS_HOURS, wszText, ARRAYSIZE(wszText));
        SendDlgItemMessageU(hwndDlg, IDC_UNITS_COMBO, CB_INSERTSTRING, 0, (LPARAM) wszText);

        LoadStringU(HinstDll, IDS_DAYS, wszText, ARRAYSIZE(wszText));
        SendDlgItemMessageU(hwndDlg, IDC_UNITS_COMBO, CB_INSERTSTRING, 1, (LPARAM) wszText);

        SendDlgItemMessageU(hwndDlg, IDC_UNITS_COMBO, CB_SETCURSEL, 0, (LPARAM) NULL);
        SetDlgItemTextU(hwndDlg, IDC_NUMBEROFUNITS_EDIT, L"0");

        //
        // Initialize the list view control
        //
        memset(&lvC, 0, sizeof(LV_COLUMNW));
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;
        lvC.cx = 150;
        lvC.pszText = L"";
        lvC.iSubItem=0;
        if (ListView_InsertColumnU(GetDlgItem(hwndDlg, IDC_URL_LIST), 0, &lvC) == -1)
        {
            return FALSE;
        }

        //DSIE: Bug 465438.
        if (pcsp->dwFlags & CRYPTUI_DISABLE_EDITPROPERTIES)
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_CHECKFORNEWCERTS_CHECK), FALSE);
            SendMessage(GetDlgItem(hwndDlg, IDC_NUMBEROFUNITS_EDIT), EM_SETREADONLY, (WPARAM) TRUE, (LPARAM) 0);
            EnableWindow(GetDlgItem(hwndDlg, IDC_UNITS_COMBO), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_USE_DEFAULT_BUTTON), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_ADDURL_BUTTON), FALSE);
            SendMessage(GetDlgItem(hwndDlg, IDC_NEWURL_EDIT), EM_SETREADONLY, (WPARAM) TRUE, (LPARAM) 0);
            EnableWindow(GetDlgItem(hwndDlg, IDC_URL_LIST), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_REMOVEURL_BUTTON), FALSE);
        }
        else
        {
            //
            // try to get the CERT_CROSS_CERT_DIST_POINTS_PROP_ID property for this cert
            //
            if (!CertGetCertificateContextProperty(
                        pccert, 
                        CERT_CROSS_CERT_DIST_POINTS_PROP_ID, 
                        NULL, 
                        &cb))
            {
                //
                // The property doesn't exist
                //
                SendDlgItemMessage(hwndDlg, IDC_CHECKFORNEWCERTS_CHECK, BM_SETCHECK, BST_UNCHECKED, 0);
                EnableWindow(GetDlgItem(hwndDlg, IDC_NUMBEROFUNITS_EDIT), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_UNITS_COMBO), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_USE_DEFAULT_BUTTON), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_ADDURL_BUTTON), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_NEWURL_EDIT), FALSE);
                EnableWindow(hWndListView, FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_REMOVEURL_BUTTON), FALSE);

                pviewhelp->InWMInit = FALSE;
                return TRUE;
            }
            else
            {
                SendDlgItemMessage(hwndDlg, IDC_CHECKFORNEWCERTS_CHECK, BM_SETCHECK, BST_CHECKED, 0);
                EnableWindow(GetDlgItem(hwndDlg, IDC_NUMBEROFUNITS_EDIT), TRUE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_UNITS_COMBO), TRUE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_USE_DEFAULT_BUTTON), TRUE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_ADDURL_BUTTON), TRUE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_NEWURL_EDIT), TRUE);
                EnableWindow(hWndListView, TRUE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_REMOVEURL_BUTTON), FALSE);
            }
        }

        if (NULL == (pb = (BYTE *) malloc(cb)))
        {
            return FALSE;
        }

        if (!CertGetCertificateContextProperty(
                pccert, 
                CERT_CROSS_CERT_DIST_POINTS_PROP_ID, 
                pb, 
                &cb))
        {
            free(pb);
            return FALSE;
        }

        if (!CryptDecodeObject(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                X509_CROSS_CERT_DIST_POINTS,
                pb,
                cb,
                0,
                NULL,
                &cbCrossCertInfo))
        {
            free(pb);
            return FALSE;
        }

        if (NULL == (pCrossCertInfo = 
                        (CROSS_CERT_DIST_POINTS_INFO *) malloc(cbCrossCertInfo)))
        {
            free(pb);
            return FALSE;
        }

        if (!CryptDecodeObject(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                X509_CROSS_CERT_DIST_POINTS,
                pb,
                cb,
                0,
                pCrossCertInfo,
                &cbCrossCertInfo))
        {
            free(pb);
            return FALSE;
        }

        free(pb);

        //
        // Initialize the sync time controls
        //
        if (pCrossCertInfo->dwSyncDeltaTime == 0)
        {
            pCrossCertInfo->dwSyncDeltaTime = XCERT_DEFAULT_SYNC_DELTA_TIME;    
        }
        
        if ((pCrossCertInfo->dwSyncDeltaTime % 86400) == 0)   
        {
            //
            // Days
            //
            dwNumUnits = pCrossCertInfo->dwSyncDeltaTime / 86400;
            SendDlgItemMessageU(
                    hwndDlg, 
                    IDC_UNITS_COMBO, 
                    CB_SETCURSEL, 
                    1, 
                    (LPARAM) NULL);
        }
        else
        {
            //
            // Hours
            //
            dwNumUnits = pCrossCertInfo->dwSyncDeltaTime / 3600;

            //
            // Force to 1 if exisiting value is less than 1 hour.
            //
            if (0 == dwNumUnits)
            {
                dwNumUnits = 1;
            }

            SendDlgItemMessageU(
                    hwndDlg, 
                    IDC_UNITS_COMBO, 
                    CB_SETCURSEL, 
                    0, 
                    (LPARAM) NULL);
        }   

        SetDlgItemInt(
                hwndDlg,
                IDC_NUMBEROFUNITS_EDIT,
                dwNumUnits,
                FALSE);

        //
        // Add each dist point to the list view
        //
        memset(&lvI, 0, sizeof(lvI));
        lvI.mask = LVIF_TEXT | LVIF_PARAM;

        for (lvI.iItem=0; lvI.iItem< (int)pCrossCertInfo->cDistPoint; lvI.iItem++)
        {
            pAltNameInfo = &(pCrossCertInfo->rgDistPoint[lvI.iItem]);

            if ((pAltNameInfo->cAltEntry == 0) ||
                (pAltNameInfo->rgAltEntry[0].dwAltNameChoice != 7))
            {
                continue;
            }

            pwszURL = (LPWSTR) 
                malloc( (wcslen(pAltNameInfo->rgAltEntry[0].pwszURL) + 1) * 
                        sizeof(WCHAR));
            if (pwszURL == NULL)
            {
                continue;
            }
            wcscpy(pwszURL, pAltNameInfo->rgAltEntry[0].pwszURL);
    
            lvI.pszText = pwszURL;
            lvI.lParam = (LPARAM) pwszURL;

            ListView_InsertItemU(hWndListView, &lvI);        
        }

        ListView_SetColumnWidth(hWndListView, 0, LVSCW_AUTOSIZE);
        ListView_SetColumnWidth(hWndListView, 1, LVSCW_AUTOSIZE);

        free(pCrossCertInfo);
        
        pviewhelp->InWMInit = FALSE;
    
        return TRUE;

    case WM_NOTIFY:
        pviewhelp = (PCERT_SETPROPERTIES_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcsp = (PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW) pviewhelp->pcsp;
        pccert = pcsp->pCertContext;

        switch (((NMHDR FAR *) lParam)->code) {

        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            hWndListView = GetDlgItem(hwndDlg, IDC_URL_LIST);
               
            if (BST_CHECKED != SendDlgItemMessage(
                                                hwndDlg, 
                                                IDC_CHECKFORNEWCERTS_CHECK, 
                                                BM_GETCHECK, 
                                                0, 
                                                0))
            {
                CertSetCertificateContextProperty(
                        pccert,
                        CERT_CROSS_CERT_DIST_POINTS_PROP_ID, 
                        0,
                        NULL);
            }
            else
            {
                //
                // Set the sync time
                //
                memset(&CrossCertInfo, 0, sizeof(CrossCertInfo));

                dwNumUnits = GetDlgItemInt(
                                    hwndDlg,
                                    IDC_NUMBEROFUNITS_EDIT,
                                    &fTranslated,
                                    FALSE);

                if (0 == SendDlgItemMessage(hwndDlg, IDC_UNITS_COMBO, CB_GETCURSEL, 0, NULL))
                {
                    dwSecsPerUnit = 3600;
                }
                else
                {
                    dwSecsPerUnit = 86400;
                }
                
                CrossCertInfo.dwSyncDeltaTime = dwNumUnits * dwSecsPerUnit;

                //
                // Set the dist points
                //
                CrossCertInfo.cDistPoint = ListView_GetItemCount(hWndListView);
                CrossCertInfo.rgDistPoint = (CERT_ALT_NAME_INFO *)
                                malloc( CrossCertInfo.cDistPoint * 
                                        sizeof(CERT_ALT_NAME_INFO));
                if (CrossCertInfo.rgDistPoint == NULL)
                {
                    break;
                }

                // one AltEntry per DistPoint
                rgAltEntry = (CERT_ALT_NAME_ENTRY *) 
                    malloc(CrossCertInfo.cDistPoint * sizeof(CERT_ALT_NAME_ENTRY));
                if (rgAltEntry == NULL)
                {
                    free(CrossCertInfo.rgDistPoint);
                    break;
                }

                memset(&lvI, 0, sizeof(lvI));
                lvI.mask = LVIF_PARAM;
                for (dw=0; dw<CrossCertInfo.cDistPoint; dw++)
                {
                    lvI.iItem = dw;
                    if (ListView_GetItemU(hWndListView, &lvI))
                    {
                        CrossCertInfo.rgDistPoint[dw].cAltEntry = 1;
                        CrossCertInfo.rgDistPoint[dw].rgAltEntry = &(rgAltEntry[dw]);
                        rgAltEntry[dw].dwAltNameChoice = 7;
                        rgAltEntry[dw].pwszURL = (LPWSTR) lvI.lParam;
                    }
                } 
                
                //
                // Now encode 
                //
                CryptDataBlob.cbData = 0;
                CryptDataBlob.pbData = NULL;
                if (CryptEncodeObject(
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        X509_CROSS_CERT_DIST_POINTS,
                        &CrossCertInfo,
                        NULL,
                        &CryptDataBlob.cbData))
                {
                    if (NULL != (CryptDataBlob.pbData = (BYTE *) 
                                        malloc(CryptDataBlob.cbData)))
                    {
                        if (CryptEncodeObject(
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                X509_CROSS_CERT_DIST_POINTS,
                                &CrossCertInfo,
                                CryptDataBlob.pbData,
                                &CryptDataBlob.cbData))
                        {
                            CertSetCertificateContextProperty(
                                pccert,
                                CERT_CROSS_CERT_DIST_POINTS_PROP_ID, 
                                0,
                                &CryptDataBlob);
                        }

                        free(CryptDataBlob.pbData);
                    }
                }

                free(rgAltEntry);
                free(CrossCertInfo.rgDistPoint);
            } 

            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;

        case PSN_KILLACTIVE:
            //
            // DSIE: Bug 124468. Per PM JohnLa, we don't make any check until user applies.
            //
            if (BST_CHECKED == SendDlgItemMessage(hwndDlg, 
                                                  IDC_CHECKFORNEWCERTS_CHECK, 
                                                  BM_GETCHECK, 
                                                  0, 
                                                  0))
            {
                //
                // Check the sync time
                //
                dwNumUnits = GetDlgItemInt(
                                    hwndDlg,
                                    IDC_NUMBEROFUNITS_EDIT,
                                    &fTranslated,
                                    FALSE);

                if (0 == SendDlgItemMessage(hwndDlg, IDC_UNITS_COMBO, CB_GETCURSEL, 0, NULL))
                {
                    dwSecsPerUnit = 3600;
                }
                else
                {
                    dwSecsPerUnit = 86400;
                }

                if (!fTranslated || 0 == dwNumUnits || dwNumUnits > (MAX_DWORD_SIZE / dwSecsPerUnit))
                {
                    WCHAR * pwszMessage = NULL;
                    DWORD dwMaxInterval = MAX_DWORD_SIZE / dwSecsPerUnit;
 
                    if (pwszMessage = FormatMessageUnicodeIds(IDS_INVALID_XCERT_INTERVAL, dwMaxInterval))
                    {
                        WCHAR wszTitle[CRYPTUI_MAX_STRING_SIZE] = L"";

                        LoadStringU(HinstDll, IDS_CERTIFICATE_PROPERTIES, wszTitle, ARRAYSIZE(wszTitle));

                        MessageBoxU(hwndDlg, pwszMessage, wszTitle, MB_OK | MB_ICONWARNING);
                        LocalFree((HLOCAL) pwszMessage);
                    }

                    SetFocus(GetDlgItem(hwndDlg, IDC_NUMBEROFUNITS_EDIT));

                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT) TRUE);
                    return TRUE;
                }
            }

            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case PSN_HELP:
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pcsp->szHelpFileName,
                  //       HELP_CONTEXT, pcsp->dwHelpId);
            }
            else {
               // WinHelpW(hwndDlg, pcsp->szHelpFileName, HELP_CONTEXT,
                 //        pcsp->dwHelpId);
            }
            return TRUE;

        case LVN_ITEMCHANGED:
            EnableWindow(
                GetDlgItem(hwndDlg, IDC_REMOVEURL_BUTTON), 
                (ListView_GetSelectedCount(
                    GetDlgItem(hwndDlg,IDC_URL_LIST)) == 0) ? FALSE : TRUE);
            return TRUE;

        case NM_SETFOCUS:
            //get the window handle of the url list view
            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_URL_LIST)))
                   break;

            //get the selected cert
            listIndex = ListView_GetNextItem(
                            hwndControl, 		
                            -1, 		
                            LVNI_FOCUSED		
                            );

           //select first item to show hilite.
           if (listIndex == -1)
                ListView_SetItemState(hwndControl,
                                      0,
                                      LVIS_SELECTED | LVIS_FOCUSED,
                                      LVIS_SELECTED | LVIS_FOCUSED);
            return TRUE;
        }

        break;

    case WM_COMMAND:

        pviewhelp = (PCERT_SETPROPERTIES_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcsp = (PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW) pviewhelp->pcsp;
        pccert = pcsp->pCertContext;

        switch (LOWORD(wParam))
        {
        case IDHELP:
            
            return TRUE;

        case IDC_CHECKFORNEWCERTS_CHECK:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                //
                // Get current state of check, then enable/disable all 
                // controls accordingly
                //
                fChecked = (BST_CHECKED == SendDlgItemMessage(
                                                hwndDlg, 
                                                IDC_CHECKFORNEWCERTS_CHECK, 
                                                BM_GETCHECK, 
                                                0, 
                                                0));

                EnableWindow(GetDlgItem(hwndDlg, IDC_NUMBEROFUNITS_EDIT), fChecked);
                EnableWindow(GetDlgItem(hwndDlg, IDC_UNITS_COMBO), fChecked);
                EnableWindow(GetDlgItem(hwndDlg, IDC_USE_DEFAULT_BUTTON), fChecked);
                EnableWindow(GetDlgItem(hwndDlg, IDC_ADDURL_BUTTON), fChecked);
                EnableWindow(GetDlgItem(hwndDlg, IDC_NEWURL_EDIT), fChecked);
                EnableWindow(GetDlgItem(hwndDlg, IDC_URL_LIST), fChecked);
                if (fChecked)
                {
                    //
                    // DSIE: Bug 124669.
                    //
                    dwNumUnits = GetDlgItemInt(
                                        hwndDlg,
                                        IDC_NUMBEROFUNITS_EDIT,
                                        &fTranslated,
                                        FALSE);
                    if (0 == dwNumUnits)
                    {
                        SendDlgItemMessageU(
                                hwndDlg, 
                                IDC_UNITS_COMBO, 
                                CB_SETCURSEL, 
                                0, 
                                (LPARAM) NULL);

                        SetDlgItemInt(
                                hwndDlg,
                                IDC_NUMBEROFUNITS_EDIT,
                                XCERT_DEFAULT_DELTA_HOURS,
                                FALSE);
                    }

                    EnableWindow(
                        GetDlgItem(hwndDlg, IDC_REMOVEURL_BUTTON), 
                        (ListView_GetSelectedCount(
                            GetDlgItem(hwndDlg,IDC_URL_LIST)) == 0) ? FALSE : TRUE);
                }
                else
                {
                    EnableWindow(GetDlgItem(hwndDlg, IDC_REMOVEURL_BUTTON), FALSE);
                }

                if (pviewhelp->pfPropertiesChanged != NULL)
                {
                    *(pviewhelp->pfPropertiesChanged) = TRUE;
                }
                pviewhelp->fPropertiesChanged = TRUE;
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            }

            break;

        case IDC_USE_DEFAULT_BUTTON:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                //
                // Reset to default interval.
                //
                SendDlgItemMessageU(
                        hwndDlg, 
                        IDC_UNITS_COMBO, 
                        CB_SETCURSEL, 
                        0, 
                        (LPARAM) NULL);

                SetDlgItemInt(
                        hwndDlg,
                        IDC_NUMBEROFUNITS_EDIT,
                        XCERT_DEFAULT_DELTA_HOURS,
                        FALSE);
            }
            break;

        case IDC_ADDURL_BUTTON:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                hWndListView = GetDlgItem(hwndDlg, IDC_URL_LIST);

                dwLength = (DWORD) SendDlgItemMessage(
                                        hwndDlg, 
                                        IDC_NEWURL_EDIT, 
                                        WM_GETTEXTLENGTH, 
                                        0, 
                                        NULL);

                if (dwLength == 0)
                {
                    break;
                }

                pwszURL = (LPWSTR) malloc((dwLength + 1) * sizeof(WCHAR));
                if (pwszURL == NULL)
                {
                    break;
                }
                GetDlgItemTextU(
                                hwndDlg, 
                                IDC_NEWURL_EDIT, 
                                pwszURL,
                                dwLength + 1);
                pwszURL[dwLength] = '\0';

                if (!IsValidURL(pwszURL))
                {
                    free(pwszURL);
                    LoadStringU(HinstDll, IDS_INVALID_URL_ERROR, errorString, ARRAYSIZE(errorString));
                    LoadStringU(HinstDll, IDS_CERTIFICATE_PROPERTIES, errorTitle, ARRAYSIZE(errorTitle));
                    MessageBoxU(hwndDlg, errorString, errorTitle, MB_OK | MB_ICONWARNING);
                    break;
                }

                memset(&lvI, 0, sizeof(lvI));
                lvI.mask = LVIF_TEXT | LVIF_PARAM;
                lvI.iItem = ListView_GetItemCount(hWndListView);
                lvI.pszText = pwszURL;
                lvI.lParam = (LPARAM) pwszURL;

                ListView_InsertItemU(hWndListView, &lvI); 
                ListView_SetColumnWidth(hWndListView, 0, LVSCW_AUTOSIZE);
#if (0) //DSIE: Bug 434091
                ListView_SetColumnWidth(hWndListView, 1, LVSCW_AUTOSIZE);
#endif

                SetDlgItemTextU(hwndDlg, IDC_NEWURL_EDIT, L""); 

                if (pviewhelp->pfPropertiesChanged != NULL)
                {
                    *(pviewhelp->pfPropertiesChanged) = TRUE;
                }
                pviewhelp->fPropertiesChanged = TRUE;
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            }
            break;

        case IDC_REMOVEURL_BUTTON:

            hWndListView = GetDlgItem(hwndDlg, IDC_URL_LIST);

            memset(&lvI, 0, sizeof(lvI));
            lvI.mask = LVIF_STATE | LVIF_PARAM;
            lvI.stateMask = LVIS_SELECTED;

            for (i=(ListView_GetItemCount(hWndListView) - 1); i >=0; i--)
            {
                lvI.iItem = i;
                
                if (ListView_GetItemU(hWndListView, &lvI) &&
                    (lvI.state & LVIS_SELECTED))
                {
                    free((void *) lvI.lParam);
                    ListView_DeleteItem(hWndListView, i);
                }
            }

            ListView_SetColumnWidth(hWndListView, 0, LVSCW_AUTOSIZE);
#if (0) //DSIE: Bug 434091
            ListView_SetColumnWidth(hWndListView, 1, LVSCW_AUTOSIZE);
#endif

            if (pviewhelp->pfPropertiesChanged != NULL)
            {
                *(pviewhelp->pfPropertiesChanged) = TRUE;
            }
            pviewhelp->fPropertiesChanged = TRUE;
            PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

            if (0 == ListView_GetItemCount(hWndListView))
            {
                SetFocus(GetDlgItem(GetParent(hwndDlg), IDOK));
            }
            else
            {
                //get the selected cert
                listIndex = ListView_GetNextItem(
                                hWndListView, 		
                                -1, 		
                                LVNI_FOCUSED		
                                );

                //select first item to show hilite.
                if (listIndex == -1)
                    listIndex = 0;

                ListView_SetItemState(hWndListView,
                                      listIndex,
                                      LVIS_SELECTED | LVIS_FOCUSED,
                                      LVIS_SELECTED | LVIS_FOCUSED);

                SetFocus(GetDlgItem(hwndDlg,IDC_REMOVEURL_BUTTON));
                SendMessage(GetDlgItem(hwndDlg,IDC_REMOVEURL_BUTTON), BM_SETSTYLE, BS_DEFPUSHBUTTON, 0);
            }
            break;

        case IDC_UNITS_COMBO:
            if (HIWORD(wParam) == CBN_SELCHANGE)
            {
                if (!pviewhelp->InWMInit)
                {
                    dwNumUnits = GetDlgItemInt(
                                    hwndDlg,
                                    IDC_NUMBEROFUNITS_EDIT,
                                    &fTranslated,
                                    FALSE);

                    if (0 == SendDlgItemMessage(hwndDlg, IDC_UNITS_COMBO, CB_GETCURSEL, 0, NULL))
                    {
                        dwSecsPerUnit = 3600;
                    }
                    else
                    {
                        dwSecsPerUnit = 86400;                
                    }

                    if (dwNumUnits > (MAX_DWORD_SIZE / dwSecsPerUnit))
                    {
                        SetDlgItemInt(
                                hwndDlg,
                                IDC_NUMBEROFUNITS_EDIT,
                                (DWORD) (MAX_DWORD_SIZE / dwSecsPerUnit),
                                FALSE);  
                    }

                    PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
                }
                
            }
            
            break;

        case IDC_NUMBEROFUNITS_EDIT:
            if (HIWORD(wParam) == EN_CHANGE)
            {
                if (!pviewhelp->InWMInit)
                {
                    PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
                }                
            }

            break;
        }
        break;
        
    case WM_DESTROY:

        pviewhelp = (PCERT_SETPROPERTIES_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcsp = (PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW) pviewhelp->pcsp;
        pccert = pcsp->pCertContext;

        hWndListView = GetDlgItem(hwndDlg, IDC_URL_LIST);

        memset(&lvI, 0, sizeof(lvI));
        lvI.mask = LVIF_PARAM;
        
        for (i=(ListView_GetItemCount(hWndListView) - 1); i >=0; i--)
        {
            lvI.iItem = i;
            if (ListView_GetItemU(hWndListView, &lvI))
            {
                free((void *) lvI.lParam);            
            }
        }

        //
        // if the properties have changed, and there is a pMMCCallback
        // then make the callback to MMC
        //
        if (pviewhelp->fPropertiesChanged               &&
            pviewhelp->fGetPagesCalled                  &&
            (pviewhelp->pcsp->pMMCCallback != NULL)     &&
            (pviewhelp->fMMCCallbackMade != TRUE))
        {
            pviewhelp->fMMCCallbackMade = TRUE;

            (*(pviewhelp->pcsp->pMMCCallback->pfnCallback))(
                        pviewhelp->pcsp->pMMCCallback->lNotifyHandle,
                        pviewhelp->pcsp->pMMCCallback->param);
        }
        

        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_CHECKFORNEWCERTS_CHECK))	&&
            (hwnd != GetDlgItem(hwndDlg, IDC_NUMBEROFUNITS_EDIT))	    &&
            (hwnd != GetDlgItem(hwndDlg, IDC_UNITS_COMBO))		   	    &&
			(hwnd != GetDlgItem(hwndDlg, IDC_USE_DEFAULT_BUTTON))	    &&
			(hwnd != GetDlgItem(hwndDlg, IDC_ADDURL_BUTTON))		   	&&
			(hwnd != GetDlgItem(hwndDlg, IDC_NEWURL_EDIT))		        &&
			(hwnd != GetDlgItem(hwndDlg, IDC_URL_LIST))		            &&
            (hwnd != GetDlgItem(hwndDlg, IDC_REMOVEURL_BUTTON)))	   
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmapCrossCert);
        }

        break;
    }

    return FALSE;
}



//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL GetRegisteredClientPages(PROPSHEETPAGEW **ppClientPages, DWORD *pcClientPages, PCCERT_CONTEXT pCertContext)
{
    HCRYPTOIDFUNCSET    hCertPropPagesFuncSet;
    void *              pvFuncAddr = NULL;
    HCRYPTOIDFUNCADDR   hFuncAddr = NULL;
    PROPSHEETPAGEW      callbackPages[MAX_CLIENT_PAGES];
    DWORD               cCallbackPages = MAX_CLIENT_PAGES;
    DWORD               cChars = 0;
    LPWSTR              pwszDllNames = NULL;
    BOOL                fRet = TRUE;
    LPWSTR              pwszCurrentDll;
    DWORD               i;
    void                *pTemp;

    //
    // initialize incoming variables
    //
    *ppClientPages = NULL;
    *pcClientPages = 0;

    //
    // get a handle to the function table
    //
    if (NULL == (hCertPropPagesFuncSet = CryptInitOIDFunctionSet(
            CRYPTUILDLG_CERTPROP_PAGES_CALLBACK, 0)))
    {
        goto ErrorReturn;
    }

    //
    // get the list of dlls that contain the callback functions
    //
    if (!CryptGetDefaultOIDDllList(
                hCertPropPagesFuncSet,
                0,
                NULL,
                &cChars))
    {
        goto ErrorReturn;
    }

    if (NULL == (pwszDllNames = (LPWSTR) malloc(cChars * sizeof(WCHAR))))
    {
        SetLastError(E_OUTOFMEMORY);
        goto ErrorReturn;
    }

    if (!CryptGetDefaultOIDDllList(
                hCertPropPagesFuncSet,
                0,
                pwszDllNames,
                &cChars))
    {
        goto ErrorReturn;
    }

    //
    // loop for each dll and call it to see if it has property pages for this cert
    //
    pwszCurrentDll = pwszDllNames;
    while (pwszCurrentDll[0] != L'\0')
    {
        //
        // try to get the function pointer
        //
        if (!CryptGetDefaultOIDFunctionAddress(
                    hCertPropPagesFuncSet,
                    0,
                    pwszCurrentDll,
                    0,
                    &pvFuncAddr,
                    &hFuncAddr))
        {
            DWORD dwErr = GetLastError();
            pwszCurrentDll += wcslen(pwszCurrentDll) + 1;
            continue;
        }

        //
        // call the client to get the their pages
        //
        cCallbackPages = MAX_CLIENT_PAGES;
        memset(callbackPages, 0, sizeof(callbackPages));
        if (((PFN_CRYPTUIDLG_CERTPROP_PAGES_CALLBACK) pvFuncAddr)(pCertContext, callbackPages, &cCallbackPages))
        {
            //
            // if they handed back pages then add them to the array
            //
            if (cCallbackPages >= 1)
            {
                if (*ppClientPages == NULL)
                {
                    if (NULL == (*ppClientPages = (PROPSHEETPAGEW *) malloc(cCallbackPages * sizeof(PROPSHEETPAGEW))))
                    {
                        SetLastError(E_OUTOFMEMORY);
                        goto ErrorReturn;
                    }
                }
                else
                {
                    if (NULL == (pTemp = realloc(*ppClientPages, (cCallbackPages + (*pcClientPages)) * sizeof(PROPSHEETPAGEW))))
                    {
                        SetLastError(E_OUTOFMEMORY);
                        goto ErrorReturn;
                    }
                    *ppClientPages = (PROPSHEETPAGEW *) pTemp;
                }

                memcpy(&((*ppClientPages)[(*pcClientPages)]), &(callbackPages[0]), cCallbackPages * sizeof(PROPSHEETPAGEW));
                *pcClientPages += cCallbackPages;
            }
        }

        //
        // free the function that was just called, and move on to the next one in the string
        //
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        hFuncAddr = NULL;
        pwszCurrentDll += wcslen(pwszCurrentDll) + 1;
    }

CleanUp:
    if (pwszDllNames != NULL)
    {
        free(pwszDllNames);
    }

    if (hFuncAddr != NULL)
    {
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    }
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CleanUp;
}


//////////////////////////////////////////////////////////////////////////////////////
//  CertSetCertificateProperties
//
//  Description:
//      This routine will display and allow the user to edit certain properties of
//		a certificate
//
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI CryptUIDlgViewCertificatePropertiesW(PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp,
                                                 BOOL                                        *pfPropertiesChanged)
{
    int                         cPages = 2;
    BOOL                        fRetValue = FALSE;
    HRESULT                     hr;
    PROPSHEETPAGEW *            ppage = NULL;
    PROPSHEETPAGEW *            pClientPages = NULL;
    DWORD                       cClientPages = 0;
    INT_PTR                     ret;
    WCHAR                       rgwch[256];
    char                        rgch[256];
    CERT_SETPROPERTIES_HELPER   viewhelper;

    if (pcsp->dwSize != sizeof(CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW)) {
        SetLastError(E_INVALIDARG);
        return FALSE;
    }

    if (!CommonInit())
    {
        return FALSE;
    }

    //
    // initialize the helper struct
    //
    memset (&viewhelper, 0, sizeof(viewhelper));
    viewhelper.pcsp = pcsp;
    viewhelper.fSelfCleanup = FALSE;
    viewhelper.pfPropertiesChanged = pfPropertiesChanged;
    viewhelper.fGetPagesCalled = FALSE;
    viewhelper.fMMCCallbackMade = FALSE;

    //
    // set the properties changed flag to FALSE initially, it will be set
    // to TRUE if when the dialog exits anything has been changed
    //
    viewhelper.fPropertiesChanged = FALSE;
    if (viewhelper.pfPropertiesChanged != NULL)
    {
        *(viewhelper.pfPropertiesChanged) = FALSE;
    }

    //
    // get all the pages from registered clients
    //
    if (!GetRegisteredClientPages(&pClientPages, &cClientPages, pcsp->pCertContext))
    {
        return FALSE;
    }

    //
    //  Build up the list of pages we are going to use in the dialog
    //
    ppage = (PROPSHEETPAGEW *) malloc((cPages + pcsp->cPropSheetPages + cClientPages) * sizeof(PROPSHEETPAGEW));
    if (ppage == NULL) {
        goto Exit;
    }

    memset(ppage, 0, (cPages + pcsp->cPropSheetPages + cClientPages) * sizeof(PROPSHEETPAGEW));

    ppage[0].dwSize = sizeof(ppage[0]);
    ppage[0].dwFlags = 0;
    ppage[0].hInstance = HinstDll;
    ppage[0].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_CERTIFICATE_PROPERTIES_DIALOG);
    ppage[0].hIcon = 0;
    ppage[0].pszTitle = NULL;
    ppage[0].pfnDlgProc = ViewPageSetPropertiesGeneral;
    ppage[0].lParam = (LPARAM) &viewhelper;
    ppage[0].pfnCallback = 0;
    ppage[0].pcRefParent = NULL;
    
    ppage[1].dwSize = sizeof(ppage[0]);
    ppage[1].dwFlags = 0;
    ppage[1].hInstance = HinstDll;
    ppage[1].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_CERTIFICATE_PROPERTIES_CROSSCERTS_DIALOG);
    ppage[1].hIcon = 0;
    ppage[1].pszTitle = NULL;
    ppage[1].pfnDlgProc = ViewPageSetPropertiesCrossCerts;
    ppage[1].lParam = (LPARAM) &viewhelper;
    ppage[1].pfnCallback = 0;
    ppage[1].pcRefParent = NULL;

    //
    //  copy over the users pages
    //
    memcpy(&ppage[cPages], pcsp->rgPropSheetPages, pcsp->cPropSheetPages * sizeof(PROPSHEETPAGEW));
    cPages += pcsp->cPropSheetPages;

    //
    // copy over the registered client's pages
    //
    memcpy(&ppage[cPages], pClientPages, cClientPages * sizeof(PROPSHEETPAGEW));
    cPages += cClientPages;

    if (FIsWin95) {

        PROPSHEETHEADERA     hdr;

        memset(&hdr, 0, sizeof(hdr));
        hdr.dwSize = sizeof(hdr);
        hdr.dwFlags = PSH_PROPSHEETPAGE;// | PSH_NOAPPLYNOW;
        hdr.hwndParent = (pcsp->hwndParent != NULL) ? pcsp->hwndParent : GetDesktopWindow();
        hdr.hInstance = HinstDll;
        hdr.hIcon = NULL;
        if (pcsp->szTitle != NULL)
        {
            hdr.pszCaption = CertUIMkMBStr(pcsp->szTitle);
        }
        else
        {
            LoadStringA(HinstDll, IDS_CERTIFICATE_PROPERTIES, (LPSTR) rgch, sizeof(rgch));
            hdr.pszCaption = (LPSTR) rgch;
        }
        hdr.nPages = cPages;
        hdr.nStartPage = 0;
        hdr.ppsp = ConvertToPropPageA(ppage, cPages);
        if (hdr.ppsp == NULL)
        {
            if ((pcsp->szTitle != NULL) && (hdr.pszCaption != NULL))
            {
                free((void *)hdr.pszCaption);
            }            
            goto Exit;
        }

        hdr.pfnCallback = NULL;

        ret = CryptUIPropertySheetA(&hdr);

        if ((pcsp->szTitle != NULL) && (hdr.pszCaption != NULL))
        {
            free((void *)hdr.pszCaption);
        }

        FreePropSheetPagesA((PROPSHEETPAGEA *)hdr.ppsp, cPages);
   }
   else {
        PROPSHEETHEADERW     hdr;

        memset(&hdr, 0, sizeof(hdr));
        hdr.dwSize = sizeof(hdr);
        hdr.dwFlags = PSH_PROPSHEETPAGE;// | PSH_NOAPPLYNOW;
        hdr.hwndParent = (pcsp->hwndParent != NULL) ? pcsp->hwndParent : GetDesktopWindow();
        hdr.hInstance = HinstDll;
        hdr.hIcon = NULL;
        if (pcsp->szTitle)
        {
            hdr.pszCaption = pcsp->szTitle;
        }
        else
        {
            LoadStringW(HinstDll, IDS_CERTIFICATE_PROPERTIES, rgwch, ARRAYSIZE(rgwch));
            hdr.pszCaption = rgwch;
        }

        hdr.nPages = cPages;
        hdr.nStartPage = 0;
        hdr.ppsp = (PROPSHEETPAGEW *) ppage;
        hdr.pfnCallback = NULL;

        ret = CryptUIPropertySheetW(&hdr);
    }

    if (viewhelper.fCancelled)
    {
        SetLastError(ERROR_CANCELLED);
    }

    fRetValue = (ret >= 1);

Exit:
    if (pClientPages)
        free(pClientPages);

    if (ppage)
        free(ppage);
    return fRetValue;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI CryptUIDlgViewCertificatePropertiesA(PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA    pcsp,
                                                 BOOL                                           *pfPropertiesChanged)
{
    BOOL                                        fRet;
    CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW   cspW;

    memcpy(&cspW, pcsp, sizeof(cspW));    
    if (!ConvertToPropPageW(
                    pcsp->rgPropSheetPages,
                    pcsp->cPropSheetPages,
                    &(cspW.rgPropSheetPages)))
    {
        return FALSE;
    }

    cspW.szTitle = CertUIMkWStr(pcsp->szTitle);

    fRet = CryptUIDlgViewCertificatePropertiesW(&cspW, pfPropertiesChanged);

    if (cspW.szTitle)
        free((void *)cspW.szTitle);

    //DSIE: Prefix bug 428038.
    if (cspW.rgPropSheetPages)
    {
        FreePropSheetPagesW((LPPROPSHEETPAGEW) cspW.rgPropSheetPages, cspW.cPropSheetPages);
    }

    return fRet;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
UINT
CALLBACK
GetCertificatePropertiesPagesPropPageCallback(
                HWND                hWnd,
                UINT                uMsg,
                LPPROPSHEETPAGEW    ppsp)
{
    CERT_SETPROPERTIES_HELPER *pviewhelp = (CERT_SETPROPERTIES_HELPER *) ppsp->lParam;

    if (pviewhelp->pcsp->pPropPageCallback != NULL)
    {
        (*(pviewhelp->pcsp->pPropPageCallback))(hWnd, uMsg, pviewhelp->pcsp->pvCallbackData);
    }

    if (uMsg == PSPCB_RELEASE)
    {
        if (pviewhelp->fSelfCleanup)
        {
            FreeSetPropertiesStruct((PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW) pviewhelp->pcsp);
            free(pviewhelp);
        }
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI CryptUIGetCertificatePropertiesPagesW(
                    PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW     pcsp,
                    BOOL                                            *pfPropertiesChanged,
                    PROPSHEETPAGEW                                  **prghPropPages,
                    DWORD                                           *pcPropPages
                    )
{
    BOOL                                        fRetValue = TRUE;
    HRESULT                                     hr;
    WCHAR                                       rgwch[CRYPTUI_MAX_STRING_SIZE];
    char                                        rgch[CRYPTUI_MAX_STRING_SIZE];
    CERT_SETPROPERTIES_HELPER                   *pviewhelp = NULL;
    PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW  pNewcsp;
    PROPSHEETPAGEW *                            pClientPages = NULL;
    DWORD                                       cClientPages = 0;

    *prghPropPages = NULL;
    *pcPropPages = 0;

    if (NULL == (pNewcsp = AllocAndCopySetPropertiesStruct(pcsp)))
    {
        goto ErrorReturn;
    }

    if (NULL == (pviewhelp = (CERT_SETPROPERTIES_HELPER *) malloc(sizeof(CERT_SETPROPERTIES_HELPER))))
    {
        goto ErrorReturn;
    }

    *pcPropPages = 2;

    if (!CommonInit())
    {
        goto ErrorReturn;
    }

    //
    // initialize the helper struct
    //
    memset (pviewhelp, 0, sizeof(CERT_SETPROPERTIES_HELPER));
    pviewhelp->pcsp = pNewcsp;
    pviewhelp->fSelfCleanup = TRUE;
    pviewhelp->pfPropertiesChanged = pfPropertiesChanged;
    pviewhelp->fGetPagesCalled = TRUE;
    pviewhelp->fMMCCallbackMade = FALSE;

    //
    // set the properties changed flag to FALSE initially, it will be set
    // to TRUE if when the dialog exits anything has been changed
    //
    pviewhelp->fPropertiesChanged = FALSE;
    if (pviewhelp->pfPropertiesChanged != NULL)
    {
        *(pviewhelp->pfPropertiesChanged) = FALSE;
    }

    //
    // get all the pages from registered clients
    //
    if (!GetRegisteredClientPages(&pClientPages, &cClientPages, pcsp->pCertContext))
    {
        goto ErrorReturn;
    }

    //
    //  Build up the list of pages we are going to use in the dialog
    //
    *prghPropPages = (PROPSHEETPAGEW *) malloc(((*pcPropPages) + cClientPages) * sizeof(PROPSHEETPAGEW));
    if (*prghPropPages == NULL) {
        goto ErrorReturn;
    }

    memset(*prghPropPages, 0, ((*pcPropPages) + cClientPages) * sizeof(PROPSHEETPAGEW));

    (*prghPropPages)[0].dwSize = sizeof((*prghPropPages)[0]);
    (*prghPropPages)[0].dwFlags = PSP_USECALLBACK;
    (*prghPropPages)[0].hInstance = HinstDll;
    (*prghPropPages)[0].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_CERTIFICATE_PROPERTIES_DIALOG);
    (*prghPropPages)[0].hIcon = 0;
    (*prghPropPages)[0].pszTitle = NULL;
    (*prghPropPages)[0].pfnDlgProc = ViewPageSetPropertiesGeneral;
    (*prghPropPages)[0].lParam = (LPARAM) pviewhelp;
    (*prghPropPages)[0].pfnCallback = GetCertificatePropertiesPagesPropPageCallback;
    (*prghPropPages)[0].pcRefParent = NULL;
    
    (*prghPropPages)[1].dwSize = sizeof((*prghPropPages)[0]);
    (*prghPropPages)[1].dwFlags = PSP_USECALLBACK;
    (*prghPropPages)[1].hInstance = HinstDll;
    (*prghPropPages)[1].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_CERTIFICATE_PROPERTIES_CROSSCERTS_DIALOG);
    (*prghPropPages)[1].hIcon = 0;
    (*prghPropPages)[1].pszTitle = NULL;
    (*prghPropPages)[1].pfnDlgProc = ViewPageSetPropertiesCrossCerts;
    (*prghPropPages)[1].lParam = (LPARAM) pviewhelp;
    (*prghPropPages)[1].pfnCallback = NULL;
    (*prghPropPages)[1].pcRefParent = NULL;

    //
    // copy over the registered client's pages
    //
    memcpy(&((*prghPropPages)[*pcPropPages]), pClientPages, cClientPages * sizeof(PROPSHEETPAGEW));
    (*pcPropPages) += cClientPages;

CommonReturn:

    if (pClientPages != NULL)
    {
        free(pClientPages);
    }

    return fRetValue;

ErrorReturn:

    if (pNewcsp != NULL)
    {
        free(pNewcsp);
    }

    if (pviewhelp != NULL)
    {
        free(pviewhelp);
    }

    if (*prghPropPages != NULL)
    {
        free(*prghPropPages);
        *prghPropPages = NULL;
    }

    fRetValue = FALSE;
    goto CommonReturn;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI CryptUIGetCertificatePropertiesPagesA(
                    PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA     pcsp,
                    BOOL                                            *pfPropertiesChanged,
                    PROPSHEETPAGEA                                  **prghPropPages,
                    DWORD                                           *pcPropPages
                    )
{
    return (CryptUIGetCertificatePropertiesPagesW(
                    (PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW) pcsp,
                    pfPropertiesChanged,
                    (PROPSHEETPAGEW**) prghPropPages,
                    pcPropPages));
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI CryptUIFreeCertificatePropertiesPagesW(
                PROPSHEETPAGEW                  *rghPropPages,
                DWORD                           cPropPages
                )
{
    free(rghPropPages);

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI CryptUIFreeCertificatePropertiesPagesA(
                PROPSHEETPAGEA                  *rghPropPages,
                DWORD                           cPropPages
                )
{
    return (CryptUIFreeCertificatePropertiesPagesW((PROPSHEETPAGEW *) rghPropPages, cPropPages));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\pwdui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       pwdui.h
//
//--------------------------------------------------------------------------


#ifndef _PWDUI_H_
#define _PWDUI_H_

#ifdef __cplusplus
extern "C" {
#endif


BOOL
WINAPI
ProtectUI_DllMain(
    HINSTANCE hinstDLL, // handle to DLL module
    DWORD fdwReason,    // reason for calling function
    LPVOID lpvReserved  // reserved
    );



#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // _PWDUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\pwdui.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    pwdui.c

Abstract:

    This module contains routines for displaying Data Protection API
    related UI, originating from client process address space.

    For the future, there is support planned for causing UI to originate
    from the secure desktop, via Secure Authentication Sequence (SAS).

Author:

    Scott Field (sfield)    12-May-99

--*/

#define UNICODE
#define _UNICODE


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <wincrypt.h>
#include <sha.h>
#include <unicode5.h>

#include "resource.h"

#include "pwdui.h"


typedef struct {
    DATA_BLOB *pDataIn;                         // input DATA_BLOB* to CryptProtect or CryptUnprotect
    CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct;   // PromptStruct describing UI operations to perform
    LPWSTR szDataDescription;                   // Application supplied data descr
    PBYTE rgbPasswordHash;                      // resultant passwordhash for strong security
    BOOL fCachedPassword;                       // did we find password in cache?
    BOOL fProtect;                              // protect or unprotect?
    BOOL fValidPassword;                        // does rgbPasswordHash contain a valid value?
} DIALOGARGS, *PDIALOGARGS, *LPDIALOGARGS;


typedef struct {
    LIST_ENTRY Next;
    LUID LogonId;
    FILETIME ftLastAccess;
    BYTE rgbDataInHash[A_SHA_DIGEST_LEN];
    BYTE rgbPasswordHash[A_SHA_DIGEST_LEN];
} PASSWORD_CACHE_ENTRY, *PPASSWORD_CACHE_ENTRY, *LPPASSWORD_CACHE_ENTRY;



DWORD
ProtectUIConfirm(
    IN      DIALOGARGS *pDialogArgs
    );

DWORD
UnprotectUIConfirm(
    IN      DIALOGARGS *pDialogArgs
    );

BOOL
ChooseSecurityLevel(
    IN      HWND hWndParent,
    IN      DIALOGARGS *pDialogArgs
    );

VOID
AdvancedSecurityDetails(
    IN      HWND hWndParent,
    IN      DIALOGARGS *pDialogArgs
    );

//
// dialog box handling routines.
//

INT_PTR
CALLBACK
DialogConfirmProtect(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    );

INT_PTR
CALLBACK
DialogConfirmAccess(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    );

INT_PTR
CALLBACK
DialogChooseSecurityLevel(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    );

INT_PTR
CALLBACK
DialogChooseSecurityLevelMedium(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    );

INT_PTR
CALLBACK
DialogChooseSecurityLevelHigh(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    );

INT_PTR
CALLBACK
DialogAdvancedSecurityDetails(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    );


//
// helper routines.
//

#ifndef SSAlloc
#define SSAlloc(x) LocalAlloc(LMEM_FIXED, x)
#endif

#ifndef SSFree
#define SSFree(x) LocalFree(x)
#endif

VOID
ComputePasswordHash(
    IN      PVOID pvPassword,
    IN      DWORD cbPassword,
    IN OUT  BYTE rgbPasswordHash[A_SHA_DIGEST_LEN]
    );

BOOL
GetEffectiveLogonId(
    IN OUT  LUID *pLogonId
    );

BOOL
InitializeDetailGlobals(
    VOID
    );


//
// password cache related routines.
//

BOOL
InitializeProtectPasswordCache(
    VOID
    );

VOID
DeleteProtectPasswordCache(
    VOID
    );

BOOL
AddProtectPasswordCache(
    IN      DATA_BLOB* pDataIn,
    IN      BYTE rgbPassword[A_SHA_DIGEST_LEN]
    );

BOOL
SearchProtectPasswordCache(
    IN      DATA_BLOB* pDataIn,
    IN OUT  BYTE rgbPassword[A_SHA_DIGEST_LEN],
    IN      BOOL fDeleteFoundEntry
    );

VOID
PurgeProtectPasswordCache(
    VOID
    );

BOOL
IsCachePWAllowed(
    VOID
    );



//
// global variables.
//

HINSTANCE g_hInstProtectUI;
CRITICAL_SECTION g_csProtectPasswordCache;
LIST_ENTRY g_ProtectPasswordCache;

#define ALLOW_CACHE_UNKNOWN 0
#define ALLOW_CACHE_NO 1
#define ALLOW_CACHE_YES 2

DWORD g_dwAllowCachePW = 0;
WCHAR g_szGooPassword[] = L"(*&#$(^(#%^))(*&(^(*{}_SAF^^%";

BOOL g_fDetailGlobalsInitialized = FALSE;
LPWSTR g_szDetailApplicationName = NULL;
LPWSTR g_szDetailApplicationPath = NULL;


BOOL
WINAPI
ProtectUI_DllMain(
    HINSTANCE hinstDLL, // handle to DLL module
    DWORD fdwReason,    // reason for calling function
    LPVOID lpvReserved  // reserved
    )
{
    BOOL fRet = TRUE;

    if( fdwReason == DLL_PROCESS_ATTACH ) {
        g_hInstProtectUI = hinstDLL;
        fRet = InitializeProtectPasswordCache();
    } else if ( fdwReason == DLL_PROCESS_DETACH ) {
        DeleteProtectPasswordCache();
    }

    return fRet;
}

DWORD
WINAPI
I_CryptUIProtect(
    IN      PVOID               pvReserved1,
    IN      PVOID               pvReserved2,
    IN      DWORD               dwReserved3,
    IN      PVOID               *pvReserved4,
    IN      BOOL                fReserved5,
    IN      PVOID               pvReserved6
    )
{
    DIALOGARGS DialogArgs;
    DWORD dwLastError = ERROR_SUCCESS;

    DATA_BLOB* pDataIn = (DATA_BLOB*)pvReserved1;
    CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct = (CRYPTPROTECT_PROMPTSTRUCT*)pvReserved2;
    DWORD dwFlags = (DWORD)dwReserved3;
    LPCWSTR szDescription = (LPCWSTR)*pvReserved4;
    BOOL fProtectOperation = (BOOL)fReserved5;
    PBYTE rgbPasswordHash = (PBYTE)pvReserved6;
    BOOL fEmptyDescription;


    //
    // for protect:
    // szDescription, if NULL or empty, get from user
    // if PROMPT_STRONG is set, grey out medium security.
    //
    // for unprotect:
    // szDescription, get from datablob.
    // pPromptStruct->dwPromptFlags from datablob.
    // if PROMPT_STRONG is set, enable password field and
    //

    if( pPromptStruct == NULL )
        return ERROR_INVALID_PARAMETER;

    if( pPromptStruct->cbSize != sizeof( CRYPTPROTECT_PROMPTSTRUCT) )
        return ERROR_INVALID_PARAMETER;

    if( fProtectOperation ) {

        //
        // if unprotect was specified, protect is implicitly specified.
        // vice-versa is true, too.
        //

        if ( ((pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_ON_PROTECT) == 0) &&
             ((pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_ON_UNPROTECT) == 0)
             )
        {
            //
            // nothing to do, bail out.
            //

            return ERROR_SUCCESS;
        }

        pPromptStruct->dwPromptFlags |= CRYPTPROTECT_PROMPT_ON_PROTECT;
        pPromptStruct->dwPromptFlags |= CRYPTPROTECT_PROMPT_ON_UNPROTECT;

    }


    if ( dwFlags & CRYPTPROTECT_UI_FORBIDDEN ) {
        return ERROR_PASSWORD_RESTRICTION;
    }



    //
    // build dialog box arguments block.
    //

    DialogArgs.pDataIn = pDataIn;

    DialogArgs.pPromptStruct = pPromptStruct;

    if( szDescription != NULL && szDescription[0] != L'\0' ) {
        DialogArgs.szDataDescription = (LPWSTR)szDescription;
        fEmptyDescription = FALSE;
    } else {
        DialogArgs.szDataDescription = NULL;
        fEmptyDescription = TRUE;
    }


    DialogArgs.rgbPasswordHash = rgbPasswordHash;
    DialogArgs.fCachedPassword = FALSE;
    DialogArgs.fProtect = fProtectOperation;
    DialogArgs.fValidPassword = FALSE;


    if( fProtectOperation ) {

        //
        // now, throw the UI for the protect operation.
        //

        dwLastError = ProtectUIConfirm( &DialogArgs );

        if( dwLastError == ERROR_SUCCESS && fEmptyDescription &&
            DialogArgs.szDataDescription ) {

            //
            // output modified data description to caller.
            //

            *pvReserved4 = DialogArgs.szDataDescription;
        }
    } else {

        //
        // now, throw the UI for the unprotect operation.
        //
        dwLastError = UnprotectUIConfirm( &DialogArgs );
    }

    if( fEmptyDescription && dwLastError != ERROR_SUCCESS &&
        DialogArgs.szDataDescription ) {

        SSFree( DialogArgs.szDataDescription );
    }

    return dwLastError;
}


DWORD
WINAPI
I_CryptUIProtectFailure(
    IN      PVOID               pvReserved1,
    IN      DWORD               dwReserved2,
    IN      PVOID               *pvReserved3)
{
    CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct = (CRYPTPROTECT_PROMPTSTRUCT*)pvReserved1;
    DWORD dwFlags = (DWORD)dwReserved2;
    LPCWSTR szDescription = (LPCWSTR)*pvReserved3;
    WCHAR szTitle[512];
    WCHAR szText[512];

    if((pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_ON_UNPROTECT) == 0)
    {
        return ERROR_SUCCESS;
    }

    if(dwFlags & CRYPTPROTECT_UI_FORBIDDEN)
    {
        return ERROR_PASSWORD_RESTRICTION;
    }

    LoadStringU(g_hInstProtectUI, IDS_PROTECT_DECRYPTION_ERROR, szTitle, sizeof(szTitle)/sizeof(WCHAR));
    LoadStringU(g_hInstProtectUI, IDS_PROTECT_CANNOT_DECRYPT, szText, sizeof(szText)/sizeof(WCHAR));
    MessageBoxU(pPromptStruct->hwndApp, szText, szTitle, MB_OK | MB_ICONWARNING);

    return ERROR_SUCCESS;
}


DWORD
ProtectUIConfirm(
    IN      DIALOGARGS *pDialogArgs
    )
{
    INT_PTR iRet;

    iRet = DialogBoxParamU(
                    g_hInstProtectUI,
                    MAKEINTRESOURCE(IDD_PROTECT_CONFIRM_PROTECT),
                    pDialogArgs->pPromptStruct->hwndApp,
                    DialogConfirmProtect,
                    (LPARAM)pDialogArgs
                    );



    return (DWORD)iRet;

}


DWORD
UnprotectUIConfirm(
    IN      DIALOGARGS *pDialogArgs
    )
{
    INT_PTR iRet;

    iRet = DialogBoxParamU(
                    g_hInstProtectUI,
                    MAKEINTRESOURCE(IDD_PROTECT_CONFIRM_SECURITY),
                    pDialogArgs->pPromptStruct->hwndApp,
                    DialogConfirmAccess,
                    (LPARAM)pDialogArgs
                    );

    return (DWORD)iRet;
}

INT_PTR
CALLBACK
DialogConfirmProtect(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{
    DIALOGARGS *pDialogArgs;
    CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct;

    switch (message)
    {
        case WM_INITDIALOG:
        {

            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, GetLastError());
                    return FALSE;
                }
            }

            // lParam is DIALOGARGS *
            pDialogArgs = (DIALOGARGS*)lParam;
            pPromptStruct = pDialogArgs->pPromptStruct;

            //
            // set the dialog title
            //
            if (pPromptStruct->szPrompt)
                SetWindowTextU(hDlg, pPromptStruct->szPrompt);

            //
            // display dynamic stuff.
            //

            SendMessage( hDlg, WM_COMMAND, IDC_PROTECT_UPDATE_DYNAMIC, 0 );

            return FALSE; // don't default the Focus..
        } // WM_INITDIALOG

        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case IDOK:
                {
                    EndDialog(hDlg, ERROR_SUCCESS);
                    return TRUE;
                }

                case IDCANCEL:
                {
                    EndDialog(hDlg, ERROR_CANCELLED);
                    return TRUE;
                }

                case IDC_PROTECT_ADVANCED:
                {

                    pDialogArgs = (DIALOGARGS*)GetWindowLongPtr(
                                                    hDlg,
                                                    GWLP_USERDATA
                                                    );
                    if(pDialogArgs == NULL)
                        break; // TODO:   bail out

                    //
                    // show details dialog.
                    //

                    AdvancedSecurityDetails(
                            hDlg,
                            pDialogArgs
                            );

                    return FALSE;
                }

                case IDC_PROTECT_UPDATE_DYNAMIC:
                {
                    WCHAR szResource[ 256 ] = L"";
                    int cchResource = sizeof(szResource) / sizeof(WCHAR);
                    UINT ResourceId;

                    pDialogArgs = (DIALOGARGS*)GetWindowLongPtr(
                                                    hDlg,
                                                    GWLP_USERDATA
                                                    );
                    if(pDialogArgs == NULL)
                        break; // TODO:   bail out


                    pPromptStruct = pDialogArgs->pPromptStruct;

                    //
                    // description.
                    //
                    if (pDialogArgs->szDataDescription)
                        SetWindowTextU(GetDlgItem(hDlg, IDC_PROTECT_LABEL_EDIT1), pDialogArgs->szDataDescription);

                    // Disable the OK button if we're defaulting to strong protection,
                    // unless a password has already been set.
                    if((pPromptStruct->dwPromptFlags & (CRYPTPROTECT_PROMPT_STRONG |
                                                        CRYPTPROTECT_PROMPT_REQUIRE_STRONG)) &&
                       (pDialogArgs->fValidPassword == FALSE))
                    {
                        EnableWindow( GetDlgItem(hDlg, IDOK), FALSE );
                        SendMessage(hDlg, DM_SETDEFID, IDC_PROTECT_CHANGE_SECURITY, 0);
                        SetFocus(GetDlgItem(hDlg, IDC_PROTECT_CHANGE_SECURITY));
                    }
                    else
                    {
                        EnableWindow( GetDlgItem(hDlg, IDOK), TRUE );
                        SendMessage(hDlg, DM_SETDEFID, IDOK,0);
                        SetFocus(GetDlgItem(hDlg, IDOK));
                    }

                    //
                    // security level.
                    //

                    if( pPromptStruct->dwPromptFlags & (CRYPTPROTECT_PROMPT_STRONG | 
                                                        CRYPTPROTECT_PROMPT_REQUIRE_STRONG))
                    {
                        ResourceId = IDS_PROTECT_SECURITY_LEVEL_SET_HIGH;
                    } else {
                        ResourceId = IDS_PROTECT_SECURITY_LEVEL_SET_MEDIUM;
                    }

                    cchResource = LoadStringU(g_hInstProtectUI,
                                            ResourceId,
                                            szResource,
                                            cchResource
                                            );
                    SetWindowTextU( GetDlgItem(hDlg,IDC_PROTECT_SECURITY_LEVEL),
                                    szResource
                                  );

                    return FALSE;
                }

                case IDC_PROTECT_CHANGE_SECURITY:
                {
                    pDialogArgs = (DIALOGARGS*)GetWindowLongPtr(
                                                    hDlg,
                                                    GWLP_USERDATA
                                                    );
                    if(pDialogArgs == NULL)
                        break; // TODO:   bail out


                    //
                    // spawn child dialog to handle prompting for security level.
                    //

                    if(!ChooseSecurityLevel( hDlg, pDialogArgs )) {
                        EndDialog(hDlg, ERROR_CANCELLED);
                        return TRUE;
                    }

                    //
                    // display dynamic stuff that may have changed.
                    //

                    SendMessage( hDlg, WM_COMMAND, IDC_PROTECT_UPDATE_DYNAMIC, 0 );
                    break;
                }

                default:
                {
                    return FALSE;
                }
            }

        } // WM_COMMAND

        default:
        {
            return FALSE;
        }
    } // message
}

INT_PTR
CALLBACK
DialogConfirmAccess(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{
    DIALOGARGS *pDialogArgs;
    CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct;

    switch (message)
    {
        case WM_INITDIALOG:
        {

            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, GetLastError());
                    return FALSE;
                }
            }

            // lParam is DIALOGARGS *
            pDialogArgs = (DIALOGARGS*)lParam;
            pPromptStruct = pDialogArgs->pPromptStruct;

            //
            // set the dialog title
            //
            if (pPromptStruct->szPrompt)
                SetWindowTextU(hDlg, pPromptStruct->szPrompt);

            //
            // description.
            //
            if (pDialogArgs->szDataDescription)
                SetWindowTextU(GetDlgItem(hDlg, IDC_PROTECT_LABEL_EDIT1), pDialogArgs->szDataDescription);

            if( pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG ) {

                //
                // If policy doesn't allow, disable caching of password.
                //
                // Otherwise, search password cache to see if user cached password
                // for this item.
                //

                if( g_dwAllowCachePW == ALLOW_CACHE_UNKNOWN )
                {
                    if(!IsCachePWAllowed()) {
                        g_dwAllowCachePW = ALLOW_CACHE_NO;
                    } else {
                        g_dwAllowCachePW = ALLOW_CACHE_YES;
                    }
                }

                if((g_dwAllowCachePW == ALLOW_CACHE_NO) || 
                   (pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_REQUIRE_STRONG))
                {
                    ShowWindow( GetDlgItem(hDlg, IDC_PROTECT_CACHEPW), SW_HIDE );
                    EnableWindow( GetDlgItem(hDlg, IDC_PROTECT_CACHEPW), FALSE );

                } else if(SearchProtectPasswordCache( pDialogArgs->pDataIn, pDialogArgs->rgbPasswordHash, FALSE ))
                {
                    //
                    // enable checkbox for cached password, fill edit control
                    // with password.
                    //

                    SetWindowTextU(GetDlgItem(hDlg,IDC_PROTECT_PASSWORD1),
                                   g_szGooPassword
                                   );

                    SendMessage(GetDlgItem(hDlg, IDC_PROTECT_CACHEPW), BM_SETCHECK, BST_CHECKED, 0);
                    pDialogArgs->fCachedPassword = TRUE;
                    pDialogArgs->fValidPassword = TRUE;

                }
            } else {

                //
                // disable irrelevant fields in dialog.
                //

                ShowWindow( GetDlgItem(hDlg, IDC_PROTECT_CACHEPW), SW_HIDE );
                EnableWindow( GetDlgItem(hDlg, IDC_PROTECT_CACHEPW), FALSE );

                ShowWindow( GetDlgItem(hDlg, IDC_PROTECT_PASSWORD1), SW_HIDE );
                EnableWindow( GetDlgItem(hDlg, IDC_PROTECT_PASSWORD1), FALSE );
            }

            return TRUE;
        } // WM_INITDIALOG

        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case IDOK:
                {
                    pDialogArgs = (DIALOGARGS*)GetWindowLongPtr(
                                                    hDlg,
                                                    GWLP_USERDATA
                                                    );
                    if(pDialogArgs == NULL)
                        break; // TODO:   bail out

                    pPromptStruct = pDialogArgs->pPromptStruct;

                    if( pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG )
                    {
                        WCHAR szPassword[ 256 ];
                        int cchPassword = sizeof(szPassword) / sizeof(WCHAR);

                        BOOL fCachePassword;

                        //
                        // check if remember password is checked.
                        // if so, check if password is untypable goo.
                        //

                        if( g_dwAllowCachePW != ALLOW_CACHE_NO &&
                            (BST_CHECKED == SendMessage(GetDlgItem(hDlg, IDC_PROTECT_CACHEPW), BM_GETCHECK, 0, 0))
                            )
                        {
                            fCachePassword = TRUE;
                        } else {
                            fCachePassword = FALSE;
                        }


                        cchPassword = GetWindowTextU(
                                        GetDlgItem(hDlg,IDC_PROTECT_PASSWORD1),
                                        szPassword,
                                        cchPassword
                                        );

                        if( !fCachePassword && pDialogArgs->fCachedPassword ) {

                            //
                            // user un-checked cachePW button, and item was cached.
                            // remove it from cache.
                            //

                            SearchProtectPasswordCache(
                                            pDialogArgs->pDataIn,
                                            pDialogArgs->rgbPasswordHash,
                                            TRUE
                                            );
                        }

                        if(
                            pDialogArgs->fCachedPassword &&
                            (cchPassword*sizeof(WCHAR) == sizeof(g_szGooPassword)-sizeof(WCHAR)) &&
                            (memcmp(szPassword, g_szGooPassword, cchPassword*sizeof(WCHAR)) == 0)
                            )
                        {
                            //
                            // nothing to do, rgbPasswordHash was updated by
                            // cache search...
                            //


                        } else {

                            ComputePasswordHash(
                                        szPassword,
                                        (DWORD)(cchPassword * sizeof(WCHAR)),
                                        pDialogArgs->rgbPasswordHash
                                        );
                            pDialogArgs->fValidPassword = TRUE;

                            //
                            // if user chose to cache password, add it.
                            //

                            if( fCachePassword )
                            {
                                AddProtectPasswordCache(
                                            pDialogArgs->pDataIn,
                                            pDialogArgs->rgbPasswordHash
                                            );
                            }
                        }

                        SecureZeroMemory(szPassword, sizeof(szPassword));
                    }

                    EndDialog(hDlg, ERROR_SUCCESS);
                    return TRUE;
                }

                case IDCANCEL:
                {
                    EndDialog(hDlg, ERROR_CANCELLED);
                    return TRUE;
                }

                case IDC_PROTECT_ADVANCED:
                {

                    pDialogArgs = (DIALOGARGS*)GetWindowLongPtr(
                                                    hDlg,
                                                    GWLP_USERDATA
                                                    );
                    if(pDialogArgs == NULL)
                        break; // TODO:   bail out

                    //
                    // show details dialog.
                    //

                    AdvancedSecurityDetails(
                            hDlg,
                            pDialogArgs
                            );

                    return FALSE;
                }

                default:
                {
                    return FALSE;
                }
            }

        } // WM_COMMAND

        default:
        {
            return FALSE;
        }
    } // message
}


//
// security level chooser routines.
//

BOOL
ChooseSecurityLevel(
    IN      HWND hWndParent,
    IN      DIALOGARGS *pDialogArgs
    )
{
    CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct;
    DWORD dwOriginalPromptFlags;
    BOOL fEmptyDescription;
    INT_PTR iRet;


    pPromptStruct = pDialogArgs->pPromptStruct;
    dwOriginalPromptFlags = pPromptStruct->dwPromptFlags;
    fEmptyDescription = (pDialogArgs->szDataDescription == NULL);


Step1:

    if(pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_REQUIRE_STRONG)
    {
        //
        // Force strong protection.
        //

        pPromptStruct->dwPromptFlags |= CRYPTPROTECT_PROMPT_STRONG;
    }
    else
    {
        // 
        // The "require strong" flag is not set, so allow the user to select
        // between medium and strong protection.
        //

        iRet = DialogBoxParamU(
                        g_hInstProtectUI,
                        MAKEINTRESOURCE(IDD_PROTECT_CHOOSE_SECURITY),
                        hWndParent,
                        DialogChooseSecurityLevel,
                        (LPARAM)pDialogArgs
                        );
    
        // if user decides not to choose, bail
    
        if( iRet == IDCANCEL )
            return TRUE;
    
        if( iRet != IDOK )
            return FALSE;
    }

    if( pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG ) {

        //
        // display dialog 'page' confirming high security.
        //

        iRet = DialogBoxParamU(
                        g_hInstProtectUI,
                        MAKEINTRESOURCE(IDD_PROTECT_CHOOSE_SECURITY_H),
                        hWndParent,
                        DialogChooseSecurityLevelHigh,
                        (LPARAM)pDialogArgs
                        );

    } else {

        //
        // display dialog 'page' confirming medium security.
        //

        iRet = DialogBoxParamU(
                        g_hInstProtectUI,
                        MAKEINTRESOURCE(IDD_PROTECT_CHOOSE_SECURITY_M),
                        hWndParent,
                        DialogChooseSecurityLevelMedium,
                        (LPARAM)pDialogArgs
                        );
    }

    if( iRet == IDC_PROTECT_BACK ) {

        //
        // put original prompt flags back so we don't end up with undefined
        // pwd at high-security level.
        // free allocated description if that happened, too.
        //

        pPromptStruct->dwPromptFlags = dwOriginalPromptFlags;
        if( fEmptyDescription && pDialogArgs->szDataDescription ) {
            SSFree( pDialogArgs->szDataDescription );
            pDialogArgs->szDataDescription = NULL;
        }

        goto Step1;
    }

    if( iRet != IDOK )
        return FALSE;

    return TRUE;
}




INT_PTR
CALLBACK
DialogChooseSecurityLevel(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{

    switch (message)
    {
        CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct;
        DIALOGARGS *pDialogArgs;

        case WM_INITDIALOG:
        {
            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, IDCANCEL);
                    return FALSE;
                }
            }

            // lParam is DIALOGARGS*

            pDialogArgs = (DIALOGARGS*)lParam;
            pPromptStruct = pDialogArgs->pPromptStruct;

            // set the dialog title
            if (pPromptStruct->szPrompt)
                SetWindowTextU(hDlg, pPromptStruct->szPrompt);

            if( pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG ) {
                SendDlgItemMessage(hDlg, IDC_PROTECT_RADIO_HIGH, BM_SETCHECK, BST_CHECKED, 0);
                SendMessage(hDlg, WM_COMMAND, (WORD)IDC_PROTECT_RADIO_HIGH, 0);
            } else {
                SendDlgItemMessage(hDlg, IDC_PROTECT_RADIO_MEDIUM, BM_SETCHECK, BST_CHECKED, 0);
                SendMessage(hDlg, WM_COMMAND, (WORD)IDC_PROTECT_RADIO_MEDIUM, 0);
            }

            return TRUE;
        } // WM_INITDIALOG

        case WM_COMMAND:
        {

            switch (LOWORD(wParam))
            {
                case IDC_PROTECT_NEXT:
                case IDOK:
                {
                    pDialogArgs = (DIALOGARGS*)GetWindowLongPtr(
                                                    hDlg,
                                                    GWLP_USERDATA
                                                    );
                    if(pDialogArgs == NULL)
                        break; // TODO:   bail out

                    pPromptStruct = pDialogArgs->pPromptStruct;

                    if (BST_CHECKED == SendDlgItemMessageW(
                                                    hDlg,
                                                    IDC_PROTECT_RADIO_HIGH,
                                                    BM_GETCHECK,
                                                    0,
                                                    0
                                                    ))
                    {
                        pPromptStruct->dwPromptFlags |= CRYPTPROTECT_PROMPT_STRONG;
                    } else {
                        pPromptStruct->dwPromptFlags &= ~(CRYPTPROTECT_PROMPT_STRONG);
                    }

                    break;
                }

                default:
                {
                    break;
                }
            }

            if (
               (LOWORD(wParam) == IDOK) ||
               (LOWORD(wParam) == IDCANCEL) ||
               (LOWORD(wParam) == IDC_PROTECT_NEXT)
               )
            {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }
        } // WM_COMMAND

        default:
        {
            return FALSE;
        }
    } // message
}

INT_PTR
CALLBACK
DialogChooseSecurityLevelMedium(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{

    switch (message)
    {
        case WM_INITDIALOG:
        {
            DIALOGARGS *pDialogArgs;
            CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct;

            // lParam is DIALOGARGS*
            pDialogArgs = (DIALOGARGS*)lParam;
            pPromptStruct = pDialogArgs->pPromptStruct;

            // set the dialog title
            if (pPromptStruct->szPrompt)
                SetWindowTextU(hDlg, pPromptStruct->szPrompt);

            return TRUE;
        } // WM_INITDIALOG

        case WM_COMMAND:
        {
            if (
               (LOWORD(wParam) == IDOK) ||
               (LOWORD(wParam) == IDCANCEL) ||
               (LOWORD(wParam) == IDC_PROTECT_BACK)
               )
            {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }
        } // WM_COMMAND

        default:
        {
            return FALSE;
        }
    } // message
}

INT_PTR
CALLBACK
DialogChooseSecurityLevelHigh(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{

    switch (message)
    {
        DIALOGARGS *pDialogArgs;
        CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct;

        case WM_INITDIALOG:
        {

            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, IDCANCEL);
                    return FALSE;
                }
            }

            // lParam is DIALOGARGS*
            pDialogArgs = (DIALOGARGS*)lParam;
            pPromptStruct = pDialogArgs->pPromptStruct;

            // set the dialog title
            if (pPromptStruct->szPrompt)
                SetWindowTextU(hDlg, pPromptStruct->szPrompt);

            // Disable <Back and Finished buttons
            if(pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_REQUIRE_STRONG)
            {
                EnableWindow( GetDlgItem(hDlg, IDC_PROTECT_BACK), FALSE );
                EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
            }

            //
            // description.
            //

            if( pDialogArgs->szDataDescription ) {

                HWND hwndProtectEdit1 = GetDlgItem( hDlg, IDC_PROTECT_PASSWORD1 );

                SetWindowTextU(GetDlgItem(hDlg, IDC_PROTECT_PW_NEWNAME), pDialogArgs->szDataDescription);

                //
                // set focus to Password entry box.
                //

                EnableWindow(hwndProtectEdit1, TRUE);
                SetFocus(hwndProtectEdit1);

                //
                // default dialog template disabled input.
                //

            } else {

                HWND hwndProtectPWNew = GetDlgItem( hDlg, IDC_PROTECT_PW_NEWNAME );

                //
                // enable edit box entry.
                //

                EnableWindow(hwndProtectPWNew, TRUE);

                //
                // set focus to description box
                //

                SetFocus(hwndProtectPWNew);
            }

            return FALSE;
        } // WM_INITDIALOG

        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case IDOK:
                {
                    WCHAR szPassword[ 256 ];
                    int cchPassword;
                    BYTE rgbPasswordHashConfirm[A_SHA_DIGEST_LEN];
                    BOOL fPasswordsMatch = TRUE; // assume passwords match.

                    pDialogArgs = (DIALOGARGS*)GetWindowLongPtr(
                                                    hDlg,
                                                    GWLP_USERDATA
                                                    );
                    if(pDialogArgs == NULL)
                        break; // TODO:   bail out

                    pPromptStruct = pDialogArgs->pPromptStruct;

                    //
                    // nothing more to do if not STRONG
                    //

                    if( (pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG) == 0 ) {
                        EndDialog( hDlg, IDOK );
                    }


                    cchPassword = sizeof(szPassword) / sizeof(WCHAR);
                    cchPassword = GetWindowTextU(
                                    GetDlgItem(hDlg,IDC_PROTECT_PASSWORD1),
                                    szPassword,
                                    cchPassword
                                    );

                    ComputePasswordHash(
                                    szPassword,
                                    cchPassword * sizeof(WCHAR),
                                    pDialogArgs->rgbPasswordHash
                                    );

                    SecureZeroMemory( szPassword, cchPassword*sizeof(WCHAR) );

                    cchPassword = sizeof(szPassword) / sizeof(WCHAR);
                    cchPassword = GetWindowTextU(
                                    GetDlgItem(hDlg,IDC_PROTECT_EDIT2),
                                    szPassword,
                                    cchPassword
                                    );

                    ComputePasswordHash(
                                    szPassword,
                                    cchPassword * sizeof(WCHAR),
                                    rgbPasswordHashConfirm
                                    );

                    SecureZeroMemory( szPassword, cchPassword*sizeof(WCHAR) );


                    //
                    // check if both passwords entered by user match.
                    //

                    if( memcmp(rgbPasswordHashConfirm, pDialogArgs->rgbPasswordHash, sizeof(rgbPasswordHashConfirm)) != 0 )
                    {
                        fPasswordsMatch = FALSE;
                    }

                    SecureZeroMemory( rgbPasswordHashConfirm, sizeof(rgbPasswordHashConfirm) );

                    if( !fPasswordsMatch )
                    {
                        WCHAR szText[256];
                        WCHAR szCaption[256];

                        //
                        // passwords must match: tell user.
                        //

                        LoadStringU(g_hInstProtectUI,
                                    IDS_PROTECT_PASSWORD_NOMATCH,
                                    szText,
                                    sizeof(szText) / sizeof(WCHAR)
                                    );

                        LoadStringU(g_hInstProtectUI,
                                    IDS_PROTECT_PASSWORD_ERROR_DLGTITLE,
                                    szCaption,
                                    sizeof(szCaption) / sizeof(WCHAR)
                                    );

                        MessageBoxW(hDlg,
                                    szText,
                                    szCaption,
                                    MB_OK | MB_ICONEXCLAMATION
                                    );

                        return FALSE;
                    }

                    //
                    // if no description provided, make sure user entered one,
                    // and grab it..
                    //

                    if( pDialogArgs->szDataDescription == NULL ) {
                        cchPassword = sizeof(szPassword) / sizeof(WCHAR);
                        cchPassword = GetWindowTextU(
                                        GetDlgItem(hDlg,IDC_PROTECT_PW_NEWNAME),
                                        szPassword,
                                        cchPassword
                                        );

                        if( cchPassword == 0 ) {

                            WCHAR szText[256];
                            WCHAR szCaption[256];

                            //
                            // password must be named: tell user.
                            //

                            LoadStringU(g_hInstProtectUI,
                                        IDS_PROTECT_PASSWORD_MUSTNAME,
                                        szText,
                                        sizeof(szText) / sizeof(WCHAR)
                                        );

                            LoadStringU(g_hInstProtectUI,
                                        IDS_PROTECT_PASSWORD_ERROR_DLGTITLE,
                                        szCaption,
                                        sizeof(szCaption) / sizeof(WCHAR)
                                        );

                            MessageBoxW(hDlg,
                                        szText,
                                        szCaption,
                                        MB_OK | MB_ICONEXCLAMATION
                                        );

                            return FALSE;
                        }

                        pDialogArgs->szDataDescription = (LPWSTR)SSAlloc( (cchPassword+1) * sizeof(WCHAR) );
                        if( pDialogArgs->szDataDescription == NULL )
                            return FALSE;

                        CopyMemory( pDialogArgs->szDataDescription, szPassword, cchPassword*sizeof(WCHAR) );
                        (pDialogArgs->szDataDescription)[cchPassword] = L'\0';
                    }

                    pDialogArgs->fValidPassword = TRUE;

                    EndDialog(hDlg, IDOK);
                    return TRUE;
                }

                case IDC_PROTECT_PASSWORD1:
                {
                    pDialogArgs = (DIALOGARGS*)GetWindowLongPtr(
                                                    hDlg,
                                                    GWLP_USERDATA
                                                    );
                    if(pDialogArgs == NULL)
                        break; // TODO:   bail out

                    pPromptStruct = pDialogArgs->pPromptStruct;

                    if(pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_REQUIRE_STRONG) 
                    {
                        WCHAR szPassword[ 256 ];
                        int cchPassword;

                        //
                        // Disable the Finish button until a password has been entered.
                        //

                        cchPassword = sizeof(szPassword) / sizeof(WCHAR);
                        cchPassword = GetWindowTextU(
                                        GetDlgItem(hDlg,IDC_PROTECT_PASSWORD1),
                                        szPassword,
                                        cchPassword
                                        );
                        if(cchPassword)
                        {
                            RtlSecureZeroMemory(szPassword, cchPassword * sizeof(WCHAR));
                            EnableWindow(GetDlgItem(hDlg, IDOK), TRUE);
                        }
                        else
                        {
                            EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
                        }
                    }
                    break;
                }


                case IDC_PROTECT_BACK:
                case IDCANCEL:
                {
                    EndDialog(hDlg, LOWORD(wParam));
                    return TRUE;
                }

                default:
                {
                    break;
                }
            }

        } // WM_COMMAND

        default:
        {
            return FALSE;
        }
    } // message
}



VOID
AdvancedSecurityDetails(
    IN      HWND hWndParent,
    IN      DIALOGARGS *pDialogArgs
    )
{
    DialogBoxParamU(
                    g_hInstProtectUI,
                    MAKEINTRESOURCE(IDD_PROTECT_SECURITY_DETAILS),
                    hWndParent,
                    DialogAdvancedSecurityDetails,
                    (LPARAM)pDialogArgs
                    );
}


INT_PTR
CALLBACK
DialogAdvancedSecurityDetails(
    HWND hDlg,      // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{
   switch (message) {

        DIALOGARGS *pDialogArgs;
        CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct;

        case WM_INITDIALOG:
        {
            WCHAR szResource[ 256 ] = L"";
            UINT ResourceId;

            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, IDCANCEL);
                    return FALSE;
                }
            }

            // lParam is DIALOGARGS*
            pDialogArgs = (DIALOGARGS*)lParam;
            pPromptStruct = pDialogArgs->pPromptStruct;

            // set the dialog title
            if (pPromptStruct->szPrompt)
                SetWindowTextU(hDlg, pPromptStruct->szPrompt);

            InitializeDetailGlobals();

            if(g_szDetailApplicationPath)
            {
                SetWindowTextU(GetDlgItem(hDlg, IDC_PROTECT_APP_PATH), g_szDetailApplicationPath);
            }

            if( pDialogArgs->fProtect ) {
                ResourceId = IDS_PROTECT_OPERATION_PROTECT;
            } else {
                ResourceId = IDS_PROTECT_OPERATION_UNPROTECT;
            }

            LoadStringU(g_hInstProtectUI,
                        ResourceId,
                        szResource,
                        sizeof(szResource) / sizeof(WCHAR)
                        );

            SetWindowTextU(GetDlgItem(hDlg, IDC_PROTECT_OPERATION_TYPE), szResource);



            if( pDialogArgs->szDataDescription ) {
                SetWindowTextU(GetDlgItem(hDlg, IDC_PROTECT_APP_DESCRIPTION), pDialogArgs->szDataDescription);
            }
            return FALSE;
        } // WM_INITDIALOG

        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
                {
                    EndDialog(hDlg, LOWORD(wParam));
                    return TRUE;
                }

                default:
                {
                    break;
                }
            }

        } // WM_COMMAND

        default:
        {
            return FALSE;
        }

    } // switch

    return FALSE;
}

VOID
ComputePasswordHash(
    IN      PVOID pvPassword,
    IN      DWORD cbPassword,
    IN OUT  BYTE rgbPasswordHash[A_SHA_DIGEST_LEN]
    )
/*++

    Compute SHA-1 hash of supplied pvPassword of size cbPassword, returning
    resultant hash in rgbPasswordHash buffer.

--*/
{
    A_SHA_CTX shaCtx;

    if( pvPassword == NULL )
        return;

    A_SHAInit( &shaCtx );
    A_SHAUpdate( &shaCtx, (unsigned char*)pvPassword, (unsigned int)cbPassword );
    A_SHAFinal( &shaCtx, rgbPasswordHash );

    SecureZeroMemory( &shaCtx, sizeof(shaCtx) );

    return;
}

BOOL
GetEffectiveLogonId(
    IN OUT  LUID *pLogonId
    )
{
    HANDLE hToken;
    TOKEN_STATISTICS TokenInformation;
    DWORD cbTokenInformation;
    BOOL fSuccess;

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken)) {
        if(GetLastError() != ERROR_NO_TOKEN)
            return FALSE;

        if(!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
            return FALSE;
    }


    fSuccess = GetTokenInformation(
                    hToken,
                    TokenStatistics,
                    &TokenInformation,
                    sizeof(TokenInformation),
                    &cbTokenInformation
                    );

    CloseHandle( hToken );

    if( fSuccess ) {
        CopyMemory( pLogonId, &TokenInformation.AuthenticationId, sizeof(*pLogonId) );
    }

    return fSuccess;
}


BOOL
InitializeDetailGlobals(
    VOID
    )
{
    WCHAR szStackBuffer[ 256 ];
    DWORD cchStackBuffer;

    LPWSTR szDetailApplicationName = NULL;
    LPWSTR szDetailApplicationPath = NULL;

    if( g_fDetailGlobalsInitialized )
        return TRUE;

    cchStackBuffer = sizeof(szStackBuffer) / sizeof(WCHAR);
    cchStackBuffer = GetModuleFileNameU( NULL, szStackBuffer, cchStackBuffer );

    if( cchStackBuffer ) {

        cchStackBuffer++; // include terminal NULL.

        szDetailApplicationPath = (LPWSTR)SSAlloc( cchStackBuffer * sizeof(WCHAR) );

        if( szDetailApplicationPath ) {
            CopyMemory( szDetailApplicationPath, szStackBuffer, cchStackBuffer*sizeof(WCHAR) );
        }
    }

    EnterCriticalSection( &g_csProtectPasswordCache );

    if( !g_fDetailGlobalsInitialized ) {

        g_szDetailApplicationName = szDetailApplicationName;
        g_szDetailApplicationPath = szDetailApplicationPath;
        g_fDetailGlobalsInitialized = TRUE;

        szDetailApplicationName = NULL;
        szDetailApplicationPath = NULL;
    }

    LeaveCriticalSection( &g_csProtectPasswordCache );

    if( szDetailApplicationName )
        SSFree( szDetailApplicationName );

    if( szDetailApplicationPath )
        SSFree( szDetailApplicationPath );

    return TRUE;
}


BOOL
InitializeProtectPasswordCache(
    VOID
    )
{
    __try
    {
        InitializeCriticalSection( &g_csProtectPasswordCache );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SecureZeroMemory(&g_csProtectPasswordCache, sizeof(g_csProtectPasswordCache));
        SetLastError(GetExceptionCode());
        return FALSE;
    }

    InitializeListHead( &g_ProtectPasswordCache );

    g_fDetailGlobalsInitialized = FALSE;
    g_szDetailApplicationName = NULL;
    g_szDetailApplicationPath = NULL;

    return TRUE;
}

VOID
DeleteProtectPasswordCache(
    VOID
    )
{

    if( g_szDetailApplicationName )
    {
        SSFree(g_szDetailApplicationName);
        g_szDetailApplicationName = NULL;
    }

    if( g_szDetailApplicationPath )
    {
        SSFree(g_szDetailApplicationPath);
        g_szDetailApplicationPath = NULL;
    }

    g_fDetailGlobalsInitialized = FALSE;

    EnterCriticalSection( &g_csProtectPasswordCache );

    while ( !IsListEmpty( &g_ProtectPasswordCache ) ) {

        PPASSWORD_CACHE_ENTRY pCacheEntry;

        pCacheEntry = CONTAINING_RECORD(
                                g_ProtectPasswordCache.Flink,
                                PASSWORD_CACHE_ENTRY,
                                Next
                                );

        RemoveEntryList( &pCacheEntry->Next );

        SecureZeroMemory( pCacheEntry, sizeof(*pCacheEntry) );
        SSFree( pCacheEntry );
    }

    LeaveCriticalSection( &g_csProtectPasswordCache );

    DeleteCriticalSection( &g_csProtectPasswordCache );
}

BOOL
AddProtectPasswordCache(
    IN      DATA_BLOB* pDataIn,
    IN      BYTE rgbPassword[A_SHA_DIGEST_LEN]
    )
{
    PPASSWORD_CACHE_ENTRY pCacheEntry = NULL;
    A_SHA_CTX shaCtx;


    pCacheEntry = (PPASSWORD_CACHE_ENTRY)SSAlloc( sizeof(PASSWORD_CACHE_ENTRY) );
    if( pCacheEntry == NULL )
        return FALSE;

    GetEffectiveLogonId( &pCacheEntry->LogonId );
    GetSystemTimeAsFileTime( &pCacheEntry->ftLastAccess );

    A_SHAInit( &shaCtx );
    A_SHAUpdate( &shaCtx, (unsigned char*)pDataIn->pbData, pDataIn->cbData );
    A_SHAFinal( &shaCtx, pCacheEntry->rgbDataInHash );
    SecureZeroMemory( &shaCtx, sizeof(shaCtx) );

    CopyMemory( pCacheEntry->rgbPasswordHash, rgbPassword, A_SHA_DIGEST_LEN );


    EnterCriticalSection( &g_csProtectPasswordCache );

    InsertHeadList( &g_ProtectPasswordCache, &pCacheEntry->Next );

    LeaveCriticalSection( &g_csProtectPasswordCache );

    return TRUE;
}

BOOL
SearchProtectPasswordCache(
    IN      DATA_BLOB* pDataIn,
    IN OUT  BYTE rgbPassword[A_SHA_DIGEST_LEN],
    IN      BOOL fDeleteFoundEntry
    )
{

    A_SHA_CTX shaCtx;
    BYTE rgbDataInHashCandidate[A_SHA_DIGEST_LEN];
    LUID LogonIdCandidate;

    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;

    BOOL fFoundMatch = FALSE;

    if(!GetEffectiveLogonId( &LogonIdCandidate ))
        return FALSE;


    A_SHAInit( &shaCtx );
    A_SHAUpdate( &shaCtx, (unsigned char*)pDataIn->pbData, pDataIn->cbData );
    A_SHAFinal( &shaCtx, rgbDataInHashCandidate );


    EnterCriticalSection( &g_csProtectPasswordCache );

    ListHead = &g_ProtectPasswordCache;

    for( ListEntry = ListHead->Flink;
         ListEntry != ListHead;
         ListEntry = ListEntry->Flink ) {

        PPASSWORD_CACHE_ENTRY pCacheEntry;
        signed int comparator;

        pCacheEntry = CONTAINING_RECORD( ListEntry, PASSWORD_CACHE_ENTRY, Next );

        //
        // search by hash, then LogonId
        // note that most usage scenarios, all cache entries will correspond
        // to same LogonId.
        //

        comparator = memcmp( rgbDataInHashCandidate, pCacheEntry->rgbDataInHash, sizeof(rgbDataInHashCandidate) );

        if( comparator != 0 )
            continue;


        comparator = memcmp(&LogonIdCandidate, &pCacheEntry->LogonId, sizeof(LUID));

        if( comparator != 0 )
            continue;


        //
        // match found.
        //

        fFoundMatch = TRUE;

        if( fDeleteFoundEntry ) {
            RemoveEntryList( &pCacheEntry->Next );
            SecureZeroMemory( pCacheEntry, sizeof(*pCacheEntry) );
            SSFree( pCacheEntry );
        } else {


            CopyMemory( rgbPassword, pCacheEntry->rgbPasswordHash, A_SHA_DIGEST_LEN );

            //
            // update last access time.
            //

            GetSystemTimeAsFileTime( &pCacheEntry->ftLastAccess );
        }

        break;
    }

    LeaveCriticalSection( &g_csProtectPasswordCache );

    PurgeProtectPasswordCache();

    return fFoundMatch;
}

VOID
PurgeProtectPasswordCache(
    VOID
    )
/*++

    This routine purges entries in the password cache that are greater than
    1 hour in age, via the ftLastAccess time.

--*/
{
//    static FILETIME ftLastPurge = {0xffffffff,0xffffffff};
    static FILETIME ftLastPurge;
    FILETIME ftStaleEntry;

    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;

    unsigned __int64 ui64;

    //
    // get current time, and subtract an hour off it.
    //

    GetSystemTimeAsFileTime( &ftStaleEntry );


    ui64 = ftStaleEntry.dwHighDateTime;
    ui64 <<= 32;
    ui64 |= ftStaleEntry.dwLowDateTime;

//    ui64 -= (600000000*60);
    ui64 -= 0x861c46800;

    ftStaleEntry.dwLowDateTime = (DWORD)(ui64 & 0xffffffff);
    ftStaleEntry.dwHighDateTime = (DWORD)(ui64 >> 32);



    //
    // only purge list once per hour.
    //

    if( CompareFileTime( &ftStaleEntry, &ftLastPurge ) < 0 ) {
        return;
    }


    //
    // update last purge time.
    //

    GetSystemTimeAsFileTime( &ftLastPurge );

    EnterCriticalSection( &g_csProtectPasswordCache );

    ListHead = &g_ProtectPasswordCache;

    for( ListEntry = ListHead->Flink;
         ListEntry != ListHead;
         ListEntry = ListEntry->Flink ) {

        PPASSWORD_CACHE_ENTRY pCacheEntry;
        signed int comparator;

        pCacheEntry = CONTAINING_RECORD( ListEntry, PASSWORD_CACHE_ENTRY, Next );

        if( CompareFileTime( &ftStaleEntry, &pCacheEntry->ftLastAccess ) > 0 )
        {
            ListEntry = ListEntry->Blink;

            RemoveEntryList( &pCacheEntry->Next );
            SecureZeroMemory( pCacheEntry, sizeof(*pCacheEntry) );
            SSFree( pCacheEntry );
        }
    }

    LeaveCriticalSection( &g_csProtectPasswordCache );

    return;
}

BOOL
IsCachePWAllowed(
    VOID
    )
{
    HKEY hKeyProtect;
    DWORD dwType;
    DWORD dwValue;
    DWORD cbValue;
    LONG lRet;

    lRet = RegOpenKeyExU(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Policies\\Microsoft\\Cryptography\\Protect",
            0,
            KEY_QUERY_VALUE,
            &hKeyProtect
            );

    if( lRet != ERROR_SUCCESS )
        return TRUE;

    cbValue = sizeof(dwValue);

    lRet = RegQueryValueExU(
                    hKeyProtect,
                    L"AllowCachePW",
                    NULL,
                    &dwType,
                    (PBYTE)&dwValue,
                    &cbValue
                    );


    RegCloseKey( hKeyProtect );

    if( lRet == ERROR_SUCCESS && dwType == REG_DWORD && dwValue == 0 ) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\selcert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       selcert.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

#define MAX_SIZE_OF_COLUMNS 400

static const HELPMAP helpmap[] = {
    {IDC_SELECTCERT_VIEWCERT_BUTTON,IDH_SELECTCERTIFICATE_VIEWCERT_BUTTON},
    {IDC_SELECTCERT_CERTLIST,       IDH_SELECTCERTIFICATE_CERTIFICATE_LIST}
};


class CertContextList { 
public: 
    CertContextList() : m_head(NULL) { }
    ~CertContextList(); 

    HRESULT Add(IN  PCCERT_CONTEXT pCertContext, 
		OUT BOOL           *pfReplacedExisting) ;

    HRESULT SyncWithStore(HCERTSTORE hStore, DWORD dwFlags); 

private:
    typedef struct _CertContextListEle { 
	PCCERT_CONTEXT               pCertContext; 
	struct _CertContextListEle * pNext; 
    } CertContextListEle; 

    CertContextListEle * m_head; 
};

typedef struct _CERT_SELECT_HELPER
{
    PCCRYPTUI_SELECTCERTIFICATE_STRUCTW pcsc;
    PCCERT_CONTEXT                      pSelectedCert;
    DWORD                               rgdwSortParam[6];
    BOOL                                fCertListDblClick;
    CertContextList                    *pCertsFromDS; 
} CERT_SELECT_HELPER, *PCERT_SELECT_HELPER;


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////

static void AddCertToList(HWND hWndListView, PCERT_SELECT_HELPER pviewhelp, PCCERT_CONTEXT pCertContext, int itemIndex)
{
    LPWSTR                                  pwszText;
    DWORD                                   cbText;
    WCHAR                                   szText[CRYPTUI_MAX_STRING_SIZE];
    int                                     subItemIndex;
    LV_ITEMW                                lvI;
    PCCRYPTUI_SELECTCERTIFICATE_STRUCTW     pcsc;

    pcsc = pviewhelp->pcsc;

    //
    // set up the fields in the list view item
    //
    lvI.mask = LVIF_PARAM | LVIF_STATE | LVIF_IMAGE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.iSubItem = 0;
    lvI.iImage = 0;
    lvI.lParam = (LPARAM) CertDuplicateCertificateContext(pCertContext);
    lvI.iItem = itemIndex;
    ListView_InsertItemU(hWndListView, &lvI);

    subItemIndex = 0;

    //
    // issued to
    //
    if (!(pcsc->dwDontUseColumn & CRYPTUI_SELECT_ISSUEDTO_COLUMN))
    {
        CertGetNameStringW(
                pCertContext,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                0,//CERT_NAME_ISSUER_FLAG,
                NULL,
                szText,
                ARRAYSIZE(szText));
        ListView_SetItemTextU(hWndListView, itemIndex , subItemIndex++, szText);
    }

    //
    // issued by
    //
    if (!(pcsc->dwDontUseColumn & CRYPTUI_SELECT_ISSUEDBY_COLUMN))
    {
        CertGetNameStringW(
                pCertContext,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                CERT_NAME_ISSUER_FLAG,
                NULL,
                szText,
                ARRAYSIZE(szText));
        ListView_SetItemTextU(hWndListView, itemIndex , subItemIndex++, szText);
    }

    //
    // intended use
    //
    if (!(pcsc->dwDontUseColumn & CRYPTUI_SELECT_INTENDEDUSE_COLUMN))
    {
        if (FormatEnhancedKeyUsageString(&pwszText, pCertContext, FALSE, FALSE))
        {
            ListView_SetItemTextU(hWndListView, itemIndex , subItemIndex, pwszText);
            free(pwszText);
        }
        subItemIndex++;
    }

    //
    // friendly name
    //
    if (!(pcsc->dwDontUseColumn & CRYPTUI_SELECT_FRIENDLYNAME_COLUMN))
    {
        cbText = 0;
        if (CertGetCertificateContextProperty(  pCertContext,
                                                CERT_FRIENDLY_NAME_PROP_ID,
                                                NULL,
                                                &cbText)                    &&
           (NULL != (pwszText = (LPWSTR) malloc(cbText))))
        {
            CertGetCertificateContextProperty(  pCertContext,
                                                CERT_FRIENDLY_NAME_PROP_ID,
                                                pwszText,
                                                &cbText);
            ListView_SetItemTextU(hWndListView, itemIndex , subItemIndex++, pwszText);
            free(pwszText);
        }
        else
        {
            LoadStringU(HinstDll, IDS_FRIENDLYNAME_NONE, szText, ARRAYSIZE(szText));
            ListView_SetItemTextU(hWndListView, itemIndex , subItemIndex++, szText);
        }
    }

    //
    // expiration
    //
    if (!(pcsc->dwDontUseColumn & CRYPTUI_SELECT_EXPIRATION_COLUMN))
    {
        if (!FormatDateString(&pwszText, pCertContext->pCertInfo->NotAfter, FALSE, FALSE, hWndListView))
        {
            LoadStringU(HinstDll, IDS_NOTAVAILABLE, szText, ARRAYSIZE(szText));
            ListView_SetItemTextU(hWndListView, itemIndex , subItemIndex++, szText);
        }
        else
        {
            ListView_SetItemTextU(hWndListView, itemIndex , subItemIndex++, pwszText);
            free(pwszText);
        }
    }

    //
    // location
    //
    if (!(pcsc->dwDontUseColumn & CRYPTUI_SELECT_LOCATION_COLUMN))
    {
        pwszText = (LPWSTR) GetStoreName(pCertContext->hCertStore, TRUE);
        if (pwszText == NULL)
        {
            LoadStringU(HinstDll, IDS_NOTAVAILABLE, szText, ARRAYSIZE(szText));
            ListView_SetItemTextU(hWndListView, itemIndex , subItemIndex++, szText);
        }
        else
        {
            ListView_SetItemTextU(hWndListView, itemIndex , subItemIndex++, pwszText);
            free(pwszText);
        }
    }
}


static int ReplaceCertInList(HWND hWndListView, PCERT_SELECT_HELPER pviewhelp, PCCERT_CONTEXT pCertContext)
{
    int     nIndex = -1; 
    LV_ITEM lvitem; 

    while (-1 != (nIndex = ListView_GetNextItem(hWndListView, nIndex, LVNI_ALL)))
    {
        //DSIE: Bug 420717
        memset(&lvitem, 0, sizeof(lvitem));

        lvitem.iItem = nIndex; 
        lvitem.mask  = LVIF_PARAM; 
        if (ListView_GetItem(hWndListView, &lvitem))
        {
            PCCERT_CONTEXT pCurrent = (PCCERT_CONTEXT)lvitem.lParam; 
            if (pCurrent->dwCertEncodingType == pCertContext->dwCertEncodingType)
            {
                if (CertCompareCertificate(pCertContext->dwCertEncodingType, 
                                           pCertContext->pCertInfo, 
                                           pCurrent->pCertInfo))
                {
                    // Found a match, replace the certificate. 
                    CertFreeCertificateContext(pCurrent); 
                    ListView_DeleteItem(hWndListView, nIndex); 
                    // Now, add our new certificate at this index. 
                    AddCertToList(hWndListView, pviewhelp, pCertContext, nIndex);
                    goto CommonReturn; 
                }
            }
        }
    }
		    
    // No match, nothing to replace, just append to the list. 
    AddCertToList(hWndListView, pviewhelp, pCertContext, ListView_GetItemCount(hWndListView)); 
    
CommonReturn: 
    return nIndex; 
}


BOOL SupportEncryptedFileSystem(PCCERT_CONTEXT pCertContext)
{
    BOOL                fSuccess = FALSE;
    DWORD               cbUsage  = 0;
    PCERT_ENHKEY_USAGE  pUsage   = NULL;

    if (!pCertContext)
        return FALSE;

    if (!CertGetEnhancedKeyUsage(pCertContext, 0, NULL, &cbUsage))
        goto CleanUp;

    if (NULL == (pUsage = (PCERT_ENHKEY_USAGE) malloc(cbUsage)))
        goto CleanUp;

    if (!CertGetEnhancedKeyUsage(pCertContext, 0, pUsage, &cbUsage))
        goto CleanUp;

    if (0 == pUsage->cUsageIdentifier)
    {
        if (CRYPT_E_NOT_FOUND == GetLastError())
        {
            fSuccess = TRUE;
        }
    }
    else
    {
        for (DWORD i = 0; i < pUsage->cUsageIdentifier; i++)
        {
            if (0 == strcmp(szOID_KP_EFS, pUsage->rgpszUsageIdentifier[i]))
            {
                fSuccess = TRUE;
                goto CleanUp;
            }
        }
    }

CleanUp:
    if (pUsage)
        free(pUsage);

    return fSuccess;
}


HRESULT AddFromDS(HWND hwndDlg, PCERT_SELECT_HELPER pviewhelp)
{
    static const int     SCOPE_INIT_COUNT = 1;
    IDsObjectPicker    * pDsObjectPicker  = NULL;
    IDataObject        * pdo              = NULL;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];
    DSOP_INIT_INFO       InitInfo;
    UINT                 cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);
    HWND                 hWndListView     = NULL; 

    BOOL                 fGotStgMedium    = FALSE;
    PDS_SELECTION_LIST   pDsSelList       = NULL;
    STGMEDIUM            stgmedium        = {TYMED_HGLOBAL, NULL, NULL};
    FORMATETC            formatetc        = {(CLIPFORMAT) cfDsObjectPicker, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    HRESULT              hr;
    HCERTSTORE           hDSCertStore     = NULL; 

    PCCERT_CONTEXT       pCertContext     = NULL; 
    PCCERT_CONTEXT       pCertContextPrev = NULL;     
    CertContextList    * pCertContextList = NULL; 

    WCHAR                errorString[512]; 
    WCHAR                errorTitle[512]; 
    BOOL                 fInitialSelectedCert = FALSE;
    PCCRYPTUI_SELECTCERTIFICATE_STRUCTW  pcsc = NULL;

    // Input validation: 
    if (NULL == hwndDlg         || 
	    NULL == pviewhelp       || 
	    NULL == pviewhelp->pcsc || 
	    NULL == pviewhelp->pCertsFromDS)
	return E_INVALIDARG; 

    // Init: 
    pcsc             = pviewhelp->pcsc; 
    pCertContextList = pviewhelp->pCertsFromDS; 
    hWndListView = GetDlgItem(hwndDlg, IDC_SELECTCERT_CERTLIST);

    CoInitialize(NULL);
    hr = CoCreateInstance(CLSID_DsObjectPicker,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDsObjectPicker,
                          (void **) &pDsObjectPicker);
    if (FAILED(hr) || NULL == pDsObjectPicker)
	    goto ComError; 
 
    // Initialize the DSOP_SCOPE_INIT_INFO array.
    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);
 
    // Combine multiple scope types in a single array entry.
    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                         | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
 
    // Set uplevel and downlevel filters to include only computer objects.
    // Uplevel filters apply to both mixed and native modes.
    // Notice that the uplevel and downlevel flags are different.
    aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
 
    // Initialize the DSOP_INIT_INFO structure.
    ZeroMemory(&InitInfo, sizeof(InitInfo));
    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // Target is the local computer.
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;
    //InitInfo.flOptions = DSOP_FLAG_MULTISELECT;
 
    // You can call Initialize multiple times; last call wins.
    // Note that object picker makes its own copy of InitInfo.
    hr = pDsObjectPicker->Initialize(&InitInfo);
    if (FAILED(hr))
        goto ComError;

    // Invoke the modal dialog.
    hr = pDsObjectPicker->InvokeDialog(hwndDlg, &pdo);
    if (FAILED(hr)) 
        goto ComError;

    // User pressed Cancel.
    if (hr == S_FALSE)
    {
        hr = E_ABORT;
        goto cleanup;
    }
 
    // Get the global memory block containing the user's selections.
    hr = pdo->GetData(&formatetc, &stgmedium);
    if (FAILED(hr)) 
        goto ComError;
    
    fGotStgMedium = TRUE;
 
    // Retrieve pointer to DS_SELECTION_LIST structure.
    pDsSelList = (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);
    if (!pDsSelList) 
        goto ComError;
 
    // Loop through DS_SELECTION array of selected objects.
    for (ULONG i = 0; i < pDsSelList->cItems; i++) 
    {
	    WCHAR  pwszLdapUrl[2048]; 
        LPWSTR pTemp = pDsSelList->aDsSelection[i].pwzADsPath;
	    
	    BOOL   fReplacedExisting; 
	    BOOL   fHasEFSCerts = FALSE; 

        // Now is the time to get the certificate
	    LPCWSTR szCertAttr = L"?userCertificate"; 
	    
	    // Check if our buffer is too small to hold the query.  
	    if (wcslen(pTemp) + wcslen(szCertAttr) + 1 > (sizeof(pwszLdapUrl) / sizeof(pwszLdapUrl[0])))
		    goto UnexpectedErr; 

	    wcscpy(pwszLdapUrl, pTemp);
	    wcscat(pwszLdapUrl, szCertAttr);
	    
        // Now open the DS store using LDAP provider.
	    hDSCertStore = CertOpenStore(sz_CERT_STORE_PROV_LDAP,
		                             X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
		                             NULL,
		                             CERT_STORE_READONLY_FLAG,
		                             (void*) pwszLdapUrl);
	    if (NULL == hDSCertStore)
		    goto CertCliError; 
    
	    // We get the certificate store
	    pCertContext     = NULL; 
	    pCertContextPrev = NULL; 
	    int            nItemIndex;

	    while (NULL != (pCertContext = CertEnumCertificatesInStore(hDSCertStore, pCertContextPrev)))
	    {
		    // Apply our filter callback function to see if we should display this certificate. 
	        BOOL fAllowCert = FALSE;
            
            if (pcsc->pFilterCallback)
                fAllowCert = (*(pcsc->pFilterCallback))(pCertContext, &fInitialSelectedCert, pcsc->pvCallbackData);

            if (!fAllowCert)
                fAllowCert = SupportEncryptedFileSystem(pCertContext); 

		    if (fAllowCert) 
            {
		        fHasEFSCerts = TRUE; 

		        if (S_OK != (hr = pCertContextList->Add(pCertContext, &fReplacedExisting)))
			        goto ErrorReturn; 

		        nItemIndex = ReplaceCertInList(hWndListView, pviewhelp, pCertContext); 

		        // if the select cert dialog caller said that this should be the initially
		        // selected cert then make it so.
		        if (fInitialSelectedCert)
			        ListView_SetItemState(hWndListView, nItemIndex, LVIS_SELECTED, LVIS_SELECTED);
		    }
		    
		    pCertContextPrev = pCertContext; 
	    }

	    // We didn't reach the end of the enumeration.  This is an error. 
	    if (GetLastError() != CRYPT_E_NOT_FOUND)
		    goto CertCliError; 

	    // We didn't find any EFS certs: display an error message and pop up the window again. 
	    if (!fHasEFSCerts)
		    goto NoEfsError; 
    }
 
    hr = S_OK;

 cleanup: 
    if (hDSCertStore)        
    { 
        CertCloseStore(hDSCertStore, 0); 
    } 

    if (NULL != pCertContext)        
    { 
        CertFreeCertificateContext(pCertContext); 
    } 

    if (pDsSelList)
    {
        GlobalUnlock(stgmedium.hGlobal);
    }

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium); 
    }

    if (pdo)
    {
        pdo->Release();
    }

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }

    CoUninitialize();

    return hr;

 ErrorReturn: 
    { 
        WCHAR wszText[MAX_STRING_SIZE]; 
        WCHAR errorTitle2[MAX_STRING_SIZE]; 
        LPWSTR pwszErrorMsg = NULL; 

        //get the text string
        if(LoadStringU(HinstDll, IDS_INTERNAL_ERROR, wszText, sizeof(wszText) / sizeof(wszText[0])))
        {
            if (FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                               FORMAT_MESSAGE_FROM_SYSTEM |
                               FORMAT_MESSAGE_IGNORE_INSERTS,
                               NULL,
                               hr,
                               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                               (LPWSTR) &pwszErrorMsg,
                               0,
                               NULL))
            {
                if (LoadStringU(HinstDll, IDS_SELECT_CERTIFICATE_TITLE, errorTitle2, ARRAYSIZE(errorTitle2))) { 
                        MessageBoxU(hwndDlg, pwszErrorMsg, errorTitle2, MB_ICONERROR|MB_OK|MB_APPLMODAL);
                }
            }
        }
        
        if (NULL != pwszErrorMsg) { LocalFree(pwszErrorMsg); } 
    }
    goto cleanup; 

 CertCliError: 
    hr = HRESULT_FROM_WIN32(GetLastError()); 
    goto ErrorReturn; 

 ComError:
    goto ErrorReturn; 

 NoEfsError:
    LoadStringU(HinstDll, IDS_SELECT_CERT_NO_CERT_ERROR, errorString, ARRAYSIZE(errorString));
    if (pcsc->szTitle != NULL)
    {
	    MessageBoxU(hwndDlg, errorString, pcsc->szTitle, MB_OK | MB_ICONWARNING);
    }
    else
    {
	    LoadStringU(HinstDll, IDS_SELECT_CERTIFICATE_TITLE, errorTitle, ARRAYSIZE(errorTitle));
	    MessageBoxU(hwndDlg, errorString, errorTitle, MB_OK | MB_ICONWARNING);
    }
    hr = AddFromDS(hwndDlg, pviewhelp); 
    goto cleanup; 

 UnexpectedErr:
    hr = E_UNEXPECTED; 
    goto ErrorReturn; 
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void AddCertsToList(HWND hWndListView, PCERT_SELECT_HELPER pviewhelp)
{
    DWORD                               i;
    PCCERT_CONTEXT                      pCertContext;
    int                                 itemIndex = 0;
    PCCRYPTUI_SELECTCERTIFICATE_STRUCTW pcsc;
    BOOL                                fInitialSelectedCert = FALSE;

    pcsc = pviewhelp->pcsc;

    //
    // loop for each store and display the certs in each store
    //
    for (i=0; i<pcsc->cDisplayStores; i++)
    {
        //
        // loop for each cert in the store
        //
        pCertContext = NULL;
        while (NULL != (pCertContext = CertEnumCertificatesInStore(pcsc->rghDisplayStores[i], pCertContext)))
        {
            fInitialSelectedCert = FALSE;

            if ((pcsc->pFilterCallback == NULL) ||
                ((*(pcsc->pFilterCallback))(pCertContext, &fInitialSelectedCert, pcsc->pvCallbackData) == TRUE))
            {
                AddCertToList(hWndListView, pviewhelp, pCertContext, itemIndex);

                //
                // if the select cert dialog caller said that this should be the initially
                // selected cert then make it so.
                //
                if (fInitialSelectedCert)
                {
                    ListView_SetItemState(hWndListView, itemIndex, LVIS_SELECTED, LVIS_SELECTED);
                }

                itemIndex++;
            }
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static int CalculateColumnWidth(DWORD dwDontUseColumn)
{
    int numColumns = 0;

    if (!(dwDontUseColumn & CRYPTUI_SELECT_ISSUEDTO_COLUMN))
    {
        numColumns++;
    }

    if (!(dwDontUseColumn & CRYPTUI_SELECT_ISSUEDBY_COLUMN))
    {
        numColumns++;
    }

    if (!(dwDontUseColumn & CRYPTUI_SELECT_INTENDEDUSE_COLUMN))
    {
        numColumns++;
    }

    if (!(dwDontUseColumn & CRYPTUI_SELECT_FRIENDLYNAME_COLUMN))
    {
        numColumns++;
    }

    if (!(dwDontUseColumn & CRYPTUI_SELECT_EXPIRATION_COLUMN))
    {
        numColumns++;
    }

    if (!(dwDontUseColumn & CRYPTUI_SELECT_LOCATION_COLUMN))
    {
        numColumns++;
    }

    if (numColumns >= 2)
    {
        return (MAX_SIZE_OF_COLUMNS / numColumns);
    }
    else
    {
        return MAX_SIZE_OF_COLUMNS;
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY SelectCertDialogProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    WCHAR                               szText[CRYPTUI_MAX_STRING_SIZE];
    HWND                                hWndListView;
    LV_COLUMNW                          lvC;
    int                                 iCol = 0;
    LV_ITEMW                            lvI;
    int                                 listIndex;
    LPNMLISTVIEW                        pnmv;
    PCERT_SELECT_HELPER                 pviewhelp;
    PCCRYPTUI_SELECTCERTIFICATE_STRUCTW pcsc;
    WCHAR                               errorString[CRYPTUI_MAX_STRING_SIZE];
    WCHAR                               errorTitle[CRYPTUI_MAX_STRING_SIZE];
    HWND                                hwnd;
    HIMAGELIST                          hIml;
    DWORD                               dwSortParam;
    int                                 SortParamIndex;

    switch ( msg ) {

    case WM_INITDIALOG:
        pviewhelp = (PCERT_SELECT_HELPER) lParam;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);
        pcsc = pviewhelp->pcsc;

        //
        // set the dialog title and the display string
        //
        if (pcsc->szTitle != NULL)
        {
            SetWindowTextU(hwndDlg, pcsc->szTitle);
        }

        if (pcsc->szDisplayString != NULL)
        {
            SetDlgItemTextU(hwndDlg, IDC_SELECTCERT_DISPLAYSTRING, pcsc->szDisplayString);
        }
        else
        {
            if (pcsc->dwFlags & CRYPTUI_SELECTCERT_MULTISELECT)
            {
                LoadStringU(HinstDll, IDS_SELECT_MULTIPLE_CERT_DEFAULT, szText, ARRAYSIZE(szText));
            }
            else
            {
                LoadStringU(HinstDll, IDS_SELECT_CERT_DEFAULT, szText, ARRAYSIZE(szText));
            }
            SetDlgItemTextU(hwndDlg, IDC_SELECTCERT_DISPLAYSTRING, szText);
        }

        hWndListView = GetDlgItem(hwndDlg, IDC_SELECTCERT_CERTLIST);

        //
        // initialize the image list for the list view
        //
        hIml = ImageList_LoadImage(HinstDll, MAKEINTRESOURCE(IDB_CERT), 0, 1, RGB(255,0,255), IMAGE_BITMAP, 0);
        ListView_SetImageList(hWndListView, hIml, LVSIL_SMALL);

        //
        // add the colums to the list view
        //

        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;// | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.pszText = szText;   // The text for the column.
        lvC.cx = CalculateColumnWidth(pviewhelp->pcsc->dwDontUseColumn);

        memset(&(pviewhelp->rgdwSortParam[0]), 0, ARRAYSIZE(pviewhelp->rgdwSortParam));
        SortParamIndex = 0;

        if (!(pviewhelp->pcsc->dwDontUseColumn & CRYPTUI_SELECT_ISSUEDTO_COLUMN))
        {
            LoadStringU(HinstDll, IDS_ISSUEDTO2, szText, ARRAYSIZE(szText));
            if (ListView_InsertColumnU(hWndListView, iCol++, &lvC) == -1)
            {
                // error
            }

            pviewhelp->rgdwSortParam[SortParamIndex++] = SORT_COLUMN_SUBJECT | SORT_COLUMN_ASCEND;
        }

        if (!(pviewhelp->pcsc->dwDontUseColumn & CRYPTUI_SELECT_ISSUEDBY_COLUMN))
        {
            LoadStringU(HinstDll, IDS_ISSUEDBY2, szText, ARRAYSIZE(szText));
            if (ListView_InsertColumnU(hWndListView, iCol++, &lvC) == -1)
            {
                // error
            }

            pviewhelp->rgdwSortParam[SortParamIndex++] = SORT_COLUMN_ISSUER | SORT_COLUMN_DESCEND;
        }

        if (!(pviewhelp->pcsc->dwDontUseColumn & CRYPTUI_SELECT_INTENDEDUSE_COLUMN))
        {
            LoadStringU(HinstDll, IDS_INTENDED_PURPOSE, szText, ARRAYSIZE(szText));
            if (ListView_InsertColumnU(hWndListView, iCol++, &lvC) == -1)
            {
                // error
            }

            pviewhelp->rgdwSortParam[SortParamIndex++] =SORT_COLUMN_PURPOSE | SORT_COLUMN_DESCEND;
        }

        if (!(pviewhelp->pcsc->dwDontUseColumn & CRYPTUI_SELECT_FRIENDLYNAME_COLUMN))
        {
            LoadStringU(HinstDll, IDS_CERTIFICATE_NAME, szText, ARRAYSIZE(szText));
            if (ListView_InsertColumnU(hWndListView, iCol++, &lvC) == -1)
            {
                // error
            }

            pviewhelp->rgdwSortParam[SortParamIndex++] = SORT_COLUMN_NAME | SORT_COLUMN_DESCEND;
        }

        if (!(pviewhelp->pcsc->dwDontUseColumn & CRYPTUI_SELECT_EXPIRATION_COLUMN))
        {
            LoadStringU(HinstDll, IDS_EXPIRATION_DATE, szText, ARRAYSIZE(szText));
            if (ListView_InsertColumnU(hWndListView, iCol++, &lvC) == -1)
            {
                // error
            }

            pviewhelp->rgdwSortParam[SortParamIndex++] = SORT_COLUMN_EXPIRATION | SORT_COLUMN_DESCEND;
        }

        if (!(pviewhelp->pcsc->dwDontUseColumn & CRYPTUI_SELECT_LOCATION_COLUMN))
        {
            LoadStringU(HinstDll, IDS_LOCATION, szText, ARRAYSIZE(szText));
            if (ListView_InsertColumnU(hWndListView, iCol++, &lvC) == -1)
            {
                // error
            }

            pviewhelp->rgdwSortParam[SortParamIndex++] = SORT_COLUMN_LOCATION | SORT_COLUMN_DESCEND; 
        }

        AddCertsToList(hWndListView, pviewhelp);

        //
        // if there is no cert selected initially disable the "view cert button"
        //
        if (ListView_GetSelectedCount(hWndListView) == 0)
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_SELECTCERT_VIEWCERT_BUTTON), FALSE);
        }

        //
        // set the style in the list view so that it highlights an entire line
        //
        SendMessageA(hWndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

#if (1) // DSIE: bug 338852.
        HWND hwndFindUser;

        if (hwndFindUser = GetDlgItem(hwndDlg, IDC_SELECTCERT_ADDFROMDS_BUTTON))
        {
            LPBYTE pDCName = NULL;

            DWORD dwError = NetGetDCName(NULL, NULL, &pDCName);

            if (NERR_Success == dwError)
            {
                NetApiBufferFree(pDCName);
            }
            else
            {
                EnableWindow(hwndFindUser, FALSE);
            }
        }
#endif
        
        ListView_SetItemState(hWndListView,
                              0,
                              LVIS_FOCUSED | LVIS_SELECTED,
                              LVIS_FOCUSED | LVIS_SELECTED);
        SetFocus(hWndListView); 

        break;

    case WM_NOTIFY:
        pviewhelp = (PCERT_SELECT_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcsc = pviewhelp->pcsc;

        hWndListView = GetDlgItem(hwndDlg, IDC_SELECTCERT_CERTLIST);

        switch (((NMHDR FAR *) lParam)->code)
        {

        case NM_DBLCLK:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_SELECTCERT_CERTLIST:

                if (IsWindowEnabled(GetDlgItem(hwndDlg, IDC_SELECTCERT_VIEWCERT_BUTTON)))
                {
                    pviewhelp->fCertListDblClick = TRUE;

                    SendMessage(
                            hwndDlg,
                            WM_COMMAND,
                            MAKELONG(IDC_SELECTCERT_VIEWCERT_BUTTON, BN_CLICKED),
                            (LPARAM) GetDlgItem(hwndDlg, IDC_SELECTCERT_VIEWCERT_BUTTON));
                }
                break;
            }

            break;

        case LVN_ITEMCHANGING:

            pnmv = (LPNMLISTVIEW) lParam;

            switch (((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_SELECTCERT_CERTLIST:

                if (!(pcsc->dwFlags & CRYPTUI_SELECTCERT_MULTISELECT))
                {
                    if (pnmv->uNewState & LVIS_SELECTED)
                    {
                        ListView_SetItemState(
                            hWndListView,
                            ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED),
                            ~LVIS_SELECTED,
                            LVIS_SELECTED);
                    
                        EnableWindow(GetDlgItem(hwndDlg, IDC_SELECTCERT_VIEWCERT_BUTTON), TRUE);
                    }
                }

                break;
            }

            break;

        case LVN_ITEMCHANGED:
    
            pnmv = (LPNMLISTVIEW) lParam;

            switch (((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_SELECTCERT_CERTLIST:

                if (ListView_GetSelectedCount(hWndListView) == 1)
                {
                    EnableWindow(GetDlgItem(hwndDlg, IDC_SELECTCERT_VIEWCERT_BUTTON), TRUE);
                }
                else
                {
                    EnableWindow(GetDlgItem(hwndDlg, IDC_SELECTCERT_VIEWCERT_BUTTON), FALSE);
                }                
            }
                
            break;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_SELECTCERT_CERTLIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_SELECTCERT_CERTLIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED;
                    lvI.stateMask = LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;
            }
            
            break;

        case LVN_COLUMNCLICK:

            pnmv = (NM_LISTVIEW FAR *) lParam;

            //
            // get the column number
            //
            dwSortParam = 0;

            switch (pnmv->iSubItem)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                        dwSortParam = pviewhelp->rgdwSortParam[pnmv->iSubItem];
                    break;
                default:
                        dwSortParam = 0;
                    break;
            }

            if (0 != dwSortParam)
            {
                //
                // flip the ascend ording
                //
                if (dwSortParam & SORT_COLUMN_ASCEND)
                {
                    dwSortParam &= 0x0000FFFF;
                    dwSortParam |= SORT_COLUMN_DESCEND;
                }
                else
                {
                    if (dwSortParam & SORT_COLUMN_DESCEND)
                    {
                        dwSortParam &= 0x0000FFFF;
                        dwSortParam |= SORT_COLUMN_ASCEND;
                    }
                }

                //
                // sort the column
                //
                SendDlgItemMessage(hwndDlg,
                    IDC_SELECTCERT_CERTLIST,
                    LVM_SORTITEMS,
                    (WPARAM) (LPARAM) dwSortParam,
                    (LPARAM) (PFNLVCOMPARE)CompareCertificate);

                pviewhelp->rgdwSortParam[pnmv->iSubItem] = dwSortParam;
            }

            break;

        }

        break;

    case WM_COMMAND:
        pviewhelp = (PCERT_SELECT_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcsc = pviewhelp->pcsc;

        hWndListView = GetDlgItem(hwndDlg, IDC_SELECTCERT_CERTLIST);

        switch (LOWORD(wParam))
        {

	case IDC_SELECTCERT_ADDFROMDS_BUTTON:
	    { 
		HRESULT hr = AddFromDS(hwndDlg, pviewhelp); 
		if (FAILED(hr))
		{
		    // Error
		}
		break; 
	    }

        case IDC_SELECTCERT_VIEWCERT_BUTTON:
            CRYPTUI_VIEWCERTIFICATE_STRUCTW cvps;
            BOOL                            fPropertiesChanged;

            listIndex = ListView_GetNextItem(
                                hWndListView, 		
                                -1, 		
                                LVNI_SELECTED		
                                );	

            if (listIndex != -1)
            {
                memset(&lvI, 0, sizeof(lvI));
                lvI.iItem = listIndex;
                lvI.mask = LVIF_PARAM;
                if (ListView_GetItemU(hWndListView, &lvI))
                {
                    //
                    // if the caller handed in a callback call them to see if they
                    // want to handle the display of the cert, otherwise display the cert
                    //
                    if ((pcsc->pDisplayCallback != NULL) &&
                        ((*(pcsc->pDisplayCallback))((PCCERT_CONTEXT) lvI.lParam, hwndDlg, pcsc->pvCallbackData) == TRUE))
                    {
                        //
                        // set the fPropertiesChanged bool to true so that the cert will
                        // get refreshed in the display.  this doesn't hurt anything even
                        // if the cert didn't change
                        //
                        fPropertiesChanged = TRUE;
                    }
                    else
                    {
                        memset(&cvps, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCTW));
                        cvps.dwSize = sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCTW);
                        cvps.hwndParent = hwndDlg;
                        cvps.pCertContext = (PCCERT_CONTEXT) lvI.lParam;
                        cvps.cStores = pviewhelp->pcsc->cStores;
                        cvps.rghStores = pviewhelp->pcsc->rghStores;
                        cvps.cPropSheetPages = pviewhelp->pcsc->cPropSheetPages;
                        cvps.rgPropSheetPages = pviewhelp->pcsc->rgPropSheetPages;
                        CryptUIDlgViewCertificateW(&cvps, &fPropertiesChanged);
                    }

                    //
                    // if the properties changed then refresh the cert in the list
                    //
                    if (fPropertiesChanged)
                    {
                        ListView_DeleteItem(hWndListView, listIndex);
                        AddCertToList(hWndListView, pviewhelp, (PCCERT_CONTEXT) lvI.lParam, listIndex);
                        ListView_SetItemState(hWndListView, listIndex, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                    }

                    if (!pviewhelp->fCertListDblClick)
                    {
                        SetFocus(GetDlgItem(hwndDlg, IDC_SELECTCERT_VIEWCERT_BUTTON));
                    }

                    pviewhelp->fCertListDblClick = FALSE;
                }
            }

            break;

        case IDOK:
            listIndex = ListView_GetNextItem(
                                hWndListView, 		
                                -1, 		
                                LVNI_SELECTED		
                                );	

            if (listIndex != -1)
            {
                memset(&lvI, 0, sizeof(lvI));
                lvI.iItem = listIndex;
                lvI.mask = LVIF_PARAM;
                
                if (!(pcsc->dwFlags & CRYPTUI_SELECTCERT_MULTISELECT))
		{
                    if (ListView_GetItemU(hWndListView, &lvI))
                    {
                        pviewhelp->pSelectedCert = CertDuplicateCertificateContext((PCCERT_CONTEXT) lvI.lParam);
                    }
                }
                else 
                {
                    if (ListView_GetItemU(hWndListView, &lvI))
                    {
                        CertAddCertificateContextToStore(
                                pcsc->hSelectedCertStore,
                                (PCCERT_CONTEXT) lvI.lParam,
                                CERT_STORE_ADD_ALWAYS,
                                NULL);
                    }

                    while (-1 != (listIndex = ListView_GetNextItem(
                                                    hWndListView, 		
                                                    listIndex, 		
                                                    LVNI_SELECTED		
                                                    )))
                    {
                        lvI.iItem = listIndex;
                        if (ListView_GetItemU(hWndListView, &lvI))
                        {
                            CertAddCertificateContextToStore(
                                    pcsc->hSelectedCertStore,
                                    (PCCERT_CONTEXT) lvI.lParam,
                                    CERT_STORE_ADD_ALWAYS,
                                    NULL);
                        }
                    }
                }
            }
            else
            {
                LoadStringU(HinstDll, IDS_SELECT_CERT_ERROR, errorString, ARRAYSIZE(errorString));
                if (pcsc->szTitle != NULL)
                {
                    MessageBoxU(hwndDlg, errorString, pcsc->szTitle, MB_OK | MB_ICONWARNING);
                }
                else
                {
                    LoadStringU(HinstDll, IDS_SELECT_CERTIFICATE_TITLE, errorTitle, ARRAYSIZE(errorTitle));
                    MessageBoxU(hwndDlg, errorString, errorTitle, MB_OK | MB_ICONWARNING);
                }
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
                return TRUE;
            }

            EndDialog(hwndDlg, NULL);
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, NULL);
            break;
        }

        break;

    case WM_DESTROY:
        pviewhelp = (PCERT_SELECT_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        hWndListView = GetDlgItem(hwndDlg, IDC_SELECTCERT_CERTLIST);

        memset(&lvI, 0, sizeof(lvI));
        lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
        lvI.mask = LVIF_PARAM;
        while (lvI.iItem >= 0)
        {
            if (ListView_GetItemU(hWndListView, &lvI))
            {
                CertFreeCertificateContext((PCCERT_CONTEXT) lvI.lParam);
            }
            lvI.iItem--;
        }
        
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDOK))                             &&
            (hwnd != GetDlgItem(hwndDlg, IDCANCEL))                         &&
            (hwnd != GetDlgItem(hwndDlg, IDC_SELECTCERT_VIEWCERT_BUTTON))   &&
            (hwnd != GetDlgItem(hwndDlg, IDC_SELECTCERT_CERTLIST)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
PCCERT_CONTEXT
WINAPI
CryptUIDlgSelectCertificateW(
            PCCRYPTUI_SELECTCERTIFICATE_STRUCTW pcsc
            )
{
    CERT_SELECT_HELPER viewhelper;
    WORD               wDialogID; 

    if (CommonInit() == FALSE)
    {
        return NULL;
    }

    if ((pcsc->dwSize != sizeof(CRYPTUI_SELECTCERTIFICATE_STRUCTW)) &&
        (pcsc->dwSize != offsetof(CRYPTUI_SELECTCERTIFICATE_STRUCTW, hSelectedCertStore))) {
        SetLastError(E_INVALIDARG);
        return FALSE;
    }
    
    wDialogID = 
      pcsc->dwFlags & CRYPTUI_SELECTCERT_ADDFROMDS ? 
      IDD_SELECTCERT_DIALOG_WITH_DSPICKER          : 
      IDD_SELECTCERT_DIALOG; 

    viewhelper.pcsc              = pcsc;
    viewhelper.pSelectedCert     = NULL;
    viewhelper.fCertListDblClick = FALSE;
    viewhelper.pCertsFromDS      = new CertContextList; 
    if (NULL == viewhelper.pCertsFromDS)
    {
	SetLastError(E_OUTOFMEMORY); 
	return FALSE;
    }

    if (DialogBoxParamU(
                HinstDll,
                (LPWSTR) MAKEINTRESOURCE(wDialogID),
                (pcsc->hwndParent != NULL) ? pcsc->hwndParent : GetDesktopWindow(),
                SelectCertDialogProc,
                (LPARAM) &viewhelper) != -1)
    {
        SetLastError(0);
    }

    delete viewhelper.pCertsFromDS; 

    if (pcsc->dwFlags & CRYPTUI_SELECTCERT_MULTISELECT)
    {
        return NULL;
    }
    else
    {
        return(viewhelper.pSelectedCert);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
PCCERT_CONTEXT
WINAPI
CryptUIDlgSelectCertificateA(
            PCCRYPTUI_SELECTCERTIFICATE_STRUCTA pcsc
            )
{
    CRYPTUI_SELECTCERTIFICATE_STRUCTW   cscW;
    PCCERT_CONTEXT                      pReturnCert = NULL;

    memcpy(&cscW, pcsc, sizeof(cscW));
    
    if (!ConvertToPropPageW(
                pcsc->rgPropSheetPages,
                pcsc->cPropSheetPages,
                &(cscW.rgPropSheetPages)))
    {
        return NULL;
    }

    if (pcsc->szTitle)
    {
        cscW.szTitle = CertUIMkWStr(pcsc->szTitle);
    }

    if (pcsc->szDisplayString)
    {
        cscW.szDisplayString = CertUIMkWStr(pcsc->szDisplayString);
    }

    pReturnCert = CryptUIDlgSelectCertificateW(&cscW);

    FreePropSheetPagesW((LPPROPSHEETPAGEW) cscW.rgPropSheetPages, cscW.cPropSheetPages);

    if (cscW.szTitle)
    {
        free((void *) cscW.szTitle);
    }

    if (cscW.szDisplayString)
    {
        free((void *) cscW.szDisplayString);
    }

    return(pReturnCert);
}

////////////////////////////////////////////////////////////
//
// Implementation of utility class:  CertContextList
//
////////////////////////////////////////////////////////////

CertContextList::~CertContextList()
{
    CertContextListEle  *pListEle;
    CertContextListEle  *pListEleNext;

    for (pListEle = m_head; pListEle != NULL; pListEle = pListEleNext)
    {
	pListEleNext = pListEle->pNext; 
	if (pListEle->pCertContext != NULL) { CertFreeCertificateContext(pListEle->pCertContext); } 
	delete pListEle; 
    }
}
    
HRESULT CertContextList::Add(IN  PCCERT_CONTEXT pCertContext, 
			     OUT BOOL           *pfReplacedExisting) 
{ 
    HRESULT               hr = S_OK; 
    CertContextListEle   *pListEle = NULL; 
    CertContextListEle   *pListElePrev = NULL; 

    if (pCertContext == NULL || pfReplacedExisting == NULL) 
	return E_INVALIDARG; 
    
    for (pListEle = m_head; pListEle != NULL; pListEle = pListEle->pNext)
    {
	PCCERT_CONTEXT pCurrent = pListEle->pCertContext; 

	if (pCurrent->dwCertEncodingType == pCertContext->dwCertEncodingType)
	{
	    if (CertCompareCertificate
		(pCertContext->dwCertEncodingType, 
		 pCertContext->pCertInfo,
		 pCurrent->pCertInfo))
	    {
		// We're replacing an existing element.  
		*pfReplacedExisting = TRUE; 
		CertFreeCertificateContext(pListEle->pCertContext); 
		pListEle->pCertContext = CertDuplicateCertificateContext(pCertContext); 
		goto CommonReturn; 
	    }
	}

	pListElePrev = pListEle;
    }
    
    // Didn't find the cert in the list, append it.
    if (pListElePrev == NULL)
    {
	// Special case: this is the first cert we've added.  
	pListElePrev = new CertContextListEle; 
	if (pListElePrev == NULL)
	    goto MemoryErr; 
	pListEle = pListElePrev; 
	m_head = pListEle; 
    }
    else
    {
	pListElePrev->pNext = new CertContextListEle; 
	if (pListElePrev->pNext == NULL)
	    goto MemoryErr; 
	pListEle = pListElePrev->pNext; 
    }

    pListEle->pCertContext = CertDuplicateCertificateContext(pCertContext); 
    pListEle->pNext        = NULL; 

 CommonReturn: 
    return hr; 

 MemoryErr: 
    hr = E_OUTOFMEMORY; 
    goto CommonReturn;
}

HRESULT CertContextList::SyncWithStore(HCERTSTORE hStore, DWORD dwFlags)
{
    CertContextListEle * pListEle; 

    for (pListEle = m_head; pListEle != NULL; pListEle = pListEle->pNext)
    {
	if (!CertAddCertificateContextToStore
	    (hStore, 
	     pListEle->pCertContext, 
	     dwFlags, 
	     NULL))
	    return HRESULT_FROM_WIN32(GetLastError()); 
    }

    return S_OK; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cryptui.rc
//

// For dialogs, the range of numbers you should use
// are from 130 through 149.
#define IDD_CERTPROP_GENERAL            130
#define IDD_CERTPROP_DETAILS            131
#define IDD_CERTPROP_HIERARCHY          132
#define IDD_TRUST                       135
#define IDD_CPS_DIALOG                  136
#define IDD_CERTIFICATE_PROPERTIES_DIALOG 137
#define IDD_CTL_GENERAL                 138
#define IDD_CTL_TRUSTLIST               139
#define IDD_USER_PURPOSE                140
#define IDD_SIGNER_GENERAL_DIALOG       141
#define IDD_SIGNER_ADVANCED_DIALOG      142
#define IDD_CRL_GENERAL                 143
#define IDD_CRL_REVOCATIONLIST          144
#define IDD_SIGNATURES_GENERAL_DIALOG   145
#define IDD_SELECT_STORE_DIALOG         146
#define IDD_SELECTCERT_DIALOG           147
#define IDD_SELECTCERT_DIALOG_WITH_DSPICKER  148
#define IDD_CATALOGFILE                 149

#define IDD_PROTECT_CHOOSE_SECURITY     150
#define IDD_PROTECT_CONFIRM_PROTECT     151
#define IDD_PROTECT_CONFIRM_SECURITY    152
#define IDD_PROTECT_CHOOSE_SECURITY_H   153
#define IDD_PROTECT_CHOOSE_SECURITY_M   154
#define IDD_PROTECT_SECURITY_DETAILS    155

#define IDD_CERTIFICATE_PROPERTIES_CROSSCERTS_DIALOG 156

//NOTE: cryptwzr.lib reserve the range from 180 to 230 for IDD_  resources
// NOTE: pki\activex\xaddroot\resource reserve the range from 270 to 279
// for IDD_  dialogs


// For bitmaps, the range of numbers you should use
// are from 300 through 319.
#define IDB_MINICERT                    302
#define IDB_REVOKED_MINICERT            303
#define IDB_EXCLAMATION_MINICERT        304
#define IDB_TRUSTTREE_BITMAP            305
#define IDB_FOLDER                      306
#define IDB_CERT                        307
#define IDB_PROPLIST                    308
#define IDB_CHECKLIST                   309
#define IDB_PRIVATEKEY                  310
#define IDB_CA                          311
#define IDB_WIZARD_CERT_HEADER          312
#define IDB_WIZARD_SIGN_HEADER          313
#define IDB_WIZARD_CTL_HEADER           314
#define IDB_PROTECT_USER                315
#define IDB_PROTECT_LOCKKEY             316

// For strings, the range of numbers you should use
// are from 3184 through 3503.
#define IDS_TRUST_DESC                  3213
#define IDS_GENERAL_DESC                3214
#define IDS_VIEW_TITLE                  3215
#define IDS_DEFAULT_DESCRIPTION         3216
#define IDS_DEFAULT_CERTIFICATE_NAME    3217
#define IDS_FIELD                       3218
#define IDS_VALUE                       3219
#define IDS_ALL_FIELDS                  3220
#define IDS_V1_FIELDS_ONLY              3221
#define IDS_EXTENSIONS_ONLY             3222
#define IDS_CRITICAL_EXTENSIONS_ONLY    3223
#define IDS_PROPERTIES_ONLY             3224
#define IDS_THUMBPRINT_ALGORITHM        3225
#define IDS_THUMBPRINT                  3226
#define IDS_CERTIFICATE_NAME            3227
#define IDS_DESCRIPTION                 3228
#define IDS_ENHANCED_KEY_USAGE          3229
#define IDS_CERTIFICATEINFORMATION      3230
#define IDS_FORUSEWITH                  3231
#define IDS_ISSUEDBY                    3232
#define IDS_ISSUEDTO                    3234
#define IDS_VALIDFROM                   3235
#define IDS_VALIDTO                     3236
#define IDS_FIELD_TEXT_BOX_FONT         3237
#define IDS_LISTUSAGE_CODESIGN1         3238
#define IDS_LISTUSAGE_CODESIGN2         3239
#define IDS_LISTUSAGE_VIRUS             3240
#define IDS_LISTUSAGE_ERRORFREE         3241
#define IDS_LISTUSAGE_SRVRAUTHGOOD      3242
#define IDS_LISTUSAGE_SRVRAUTHNOTGOOD   3243
#define IDS_LISTUSAGE_SGC               3244
#define IDS_LISTUSAGE_EMAIL1            3245
#define IDS_LISTUSAGE_EMAIL2            3246
#define IDS_LISTUSAGE_EMAIL3            3247
#define IDS_LISTUSAGE_TIMESTAMP         3248
#define IDS_LISTUSAGE_CTLSIGN           3249
#define IDS_LISTUSAGE_EFS               3250
#define IDS_CTLVIEW_TITLE               3251
#define IDS_ADV_VERSION                 3252
#define IDS_ADV_SER_NUM                 3253
#define IDS_ADV_SIG_ALG                 3254
#define IDS_ADV_ISSUER                  3255
#define IDS_ADV_NOTBEFORE               3256
#define IDS_ADV_NOTAFTER                3257
#define IDS_ADV_SUBJECT                 3258
#define IDS_ADV_PUBKEY                  3259
#define IDS_ADV_SUBJECTUSAGE            3260
#define IDS_ADV_LISTIDENTIFIER          3261
#define IDS_ADV_SEQUENCENUMBER          3262
#define IDS_ADV_THISUPDATE              3263
#define IDS_ADV_NEXTUPDATE              3264
#define IDS_ADV_SUBJECTALGORITHM        3265
#define IDS_CTL_NAME                    3266    
#define IDS_ADV_ISSUEDTO                3267
#define IDS_ADV_ISSUEDFROM              3268
#define IDS_NOTAVAILABLE                3269
#define IDS_HASHVALUE                   3270
#define IDS_CTL_INVALID_SIGNATURE       3271
#define IDS_CTL_VALID                   3272
#define IDS_ERRORINOID                  3273
#define IDS_ERROR_INVALIDOID_CERT       3274
#define IDS_SIGNERVIEW_TITLE            3275
#define IDS_NAME                        3276
#define IDS_EMAIL                       3277
#define IDS_SIGNING_TIME                3278
#define IDS_DIGEST_ALGORITHM            3279
#define IDS_DIGEST_ENCRYPTION_ALGORITHM 3280
#define IDS_AUTHENTICATED_ATTRIBUTES    3281
#define IDS_UNAUTHENTICATED_ATTRIBUTES  3282
#define IDS_TIMESTAMP_TIME              3283
#define IDS_CRL_VALID                   3284
#define IDS_CRL_INVALID                 3285
#define IDS_CRLVIEW_TITLE               3286
#define IDS_REVOCATION_DATE             3287
#define IDS_ADDITIONAL_ATTRIBUTES       3288
#define IDS_OID_ALREADY_EXISTS_MESSAGE  3289
#define IDS_CERTIFICATE_PROPERTIES      3290
#define IDS_CERTREVOKED_ERROR           3291
#define IDS_CERTEXPIRED_ERROR           3292
#define IDS_CERTBADSIGNATURE_ERROR      3293
#define IDS_CANTBUILDCHAIN_ERROR        3294
#define IDS_TIMENESTING_ERROR           3295
#define IDS_UNTRUSTEDROOT_ERROR         3296
#define IDS_NOVALIDUSAGES_ERROR_TREE    3297   
#define IDS_UNTRUSTEDROOT_ERROR_TREE    3298
#define IDS_CERTIFICATEOK_TREE          3299
#define IDS_CERTREVOKED_ERROR_TREE      3300
#define IDS_CERTEXPIRED_ERROR_TREE      3301
#define IDS_CERTBADSIGNATURE_ERROR_TREE 3302
#define IDS_TIMENESTING_ERROR_TREE      3303
#define IDS_CTLOK                       3304
#define IDS_INTERNAL_ERROR              3305
#define IDS_ISSUEDTO2                   3306
#define IDS_CTL_INFORMATION             3307
#define IDS_CTL_INVALID_CERT            3308
#define IDS_CTL_UNAVAILABLE_CERT        3309
#define IDS_CRL_INFORMATION             3310
#define IDS_SELECT_STORE_DEFAULT        3311
#define IDS_SELECT_CERT_DEFAULT         3312
#define IDS_ISSUEDBY2                   3313
#define IDS_INTENDED_PURPOSE            3314
#define IDS_LOCATION                    3315
#define IDS_FRIENDLYNAME_NONE           3316
#define IDS_SIGNER_INFORMATION          3317
#define IDS_SIGNER_VALID                3318
#define IDS_SIGNER_INVALID_SIGNATURE    3319
#define IDS_SIGNER_UNAVAILABLE_CERT     3320
#define IDS_SELECT_CERT_ERROR           3321
#define IDS_SELECT_CERTIFICATE_TITLE    3322
#define IDS_NO_REFRESH                  3323
#define IDS_TAG                         3324
#define IDS_CATALOG_TITLE               3325
#define IDS_CAT_INVALID_SIGNATURE       3326
#define IDS_CAT_INVALID_CERT            3327
#define IDS_CAT_UNAVAILABLE_CERT        3328
#define IDS_CAT_VALID                   3329
#define IDS_CAT_INFORMATION             3330
#define IDS_UNTRUSTEDROOT_ROOTCERT_ERROR_TREE 3331
#define IDS_SELECT_STORE_TITLE          3332
#define IDS_SELECT_STORE_ERROR          3333
#define IDS_ISSUER_WARNING              3334
#define IDS_PRIVATE_KEY_EXISTS          3335
#define IDS_CAT_NO_SIGNATURE            3336
#define IDS_CTL_NO_SIGNATURE            3337
#define IDS_WRONG_USAGE_ERROR           3338
#define IDS_BASIC_CONSTRAINTS_ERROR     3339
#define IDS_PURPOSE_ERROR               3340
#define IDS_REVOCATION_FAILURE_ERROR    3341
#define IDS_WRONG_USAGE_ERROR_TREE      3342
#define IDS_BASIC_CONSTRAINTS_ERROR_TREE 3343
#define IDS_PURPOSE_ERROR_TREE          3344
#define IDS_REVOCATION_FAILURE_ERROR_TREE 3345
#define IDS_SIGNATURE_ERROR_CTL         3346
#define IDS_EXPIRED_ERROR_CTL           3347
#define IDS_WRONG_USAGE_ERROR_CTL       3348
#define IDS_VIEW_CERTIFICATE            3349
#define IDS_VIEW_CTL                    3350
#define IDS_EXPIRATION_DATE             3352
#define IDS_CANTBUILDCHAIN_ERROR_TREE   3353
#define IDS_CYCLE_ERROR                 3354
#define IDS_PRIVATE_KEY_EXISTS_TOOLTIP  3355
#define IDS_CAT_INVALID_COUNTER_SIGNATURE 3356
#define IDS_CTL_INVALID_COUNTER_SIGNATURE 3357
#define IDS_CAT_COUNTER_SIGNER_CERT_UNAVAILABLE 3358
#define IDS_CTL_COUNTER_SIGNER_CERT_UNAVAILABLE 3359
#define IDS_CAT_INVALID_COUNTER_SIGNER_CERT 3360
#define IDS_CTL_INVALID_COUNTER_SIGNER_CERT 3361
#define IDS_COUNTER_SIGNER_INVALID      3362
#define IDS_BAD_SIGNER_CERT_SIGNATURE   3363
#define IDS_SIGNER_INVALID              3364
#define IDS_NOSGCOID                    3365
#define IDS_UKNOWN_ERROR                3366
#define IDS_NO_USAGES_ERROR             3367
#define IDS_SIGNER_CERT_NO_VERIFY       3368
#define ID_RTF_CODESIGN_GENERAL         3369
#define ID_RTF_CODESIGN_COMMERCIAL      3370
#define ID_RTF_CODESIGN_INDIVIDUAL      3371
#define ID_RTF_SERVERAUTH               3372
#define ID_RTF_CLIENTAUTH               3373
#define ID_RTF_SGC                      3374
#define ID_RTF_EMAIL1                   3375
#define ID_RTF_EMAIL2                   3376
#define ID_RTF_EMAIL3                   3377
#define ID_RTF_TIMESTAMP                3378
#define ID_RTF_CTLSIGN                  3379
#define ID_RTF_EFS                      3380
#define ID_RTF_IPSEC                    3381
#define IDS_EXPLICITDISTRUST_ERROR      3382
#define IDS_UNKNOWN_ERROR               3383
#define IDS_WARNUNTRUSTEDROOT_ERROR     3384
#define IDS_WARNUNTRUSTEDROOT_ERROR_ROOTCERT 3385
#define ID_RTF_CODESIGN_COMMERCIAL_PKIX 3386
#define IDS_UNABLE_TO_OPEN_STORE        3387
#define IDS_SELECT_MULTIPLE_CERT_DEFAULT 3388
#define IDS_NO_USAGES                   3389

#define IDS_PROTECT_SECURITY_LEVEL_SET_HIGH 3390
#define IDS_PROTECT_SECURITY_LEVEL_SET_MEDIUM 3391
#define IDS_PROTECT_PASSWORD_MUSTNAME   3392
#define IDS_PROTECT_PASSWORD_ERROR_DLGTITLE 3393
#define IDS_PROTECT_PASSWORD_NOMATCH    3394
#define IDS_PROTECT_OPERATION_PROTECT   3395
#define IDS_PROTECT_OPERATION_UNPROTECT 3396
#define IDS_SELECT_CERT_NO_CERT_ERROR   3397
#define IDS_SECONDS                     3398
#define IDS_MINUTES                     3399
#define IDS_HOURS                       3400
#define IDS_DAYS                        3401
#define IDS_INVALID_URL_ERROR           3402
#define IDS_INVALID_XCERT_INTERVAL      3403
#define IDS_EXTENDED_ERROR_INFO         3404
#define IDS_PROTECT_DECRYPTION_ERROR    3405
#define IDS_PROTECT_CANNOT_DECRYPT      3406

// Following resources are used to "Revocation Status" Extended Error Info
#define IDS_REV_STATUS_OK               3407
#define IDS_REV_STATUS_REVOKED_ON       3408
#define IDS_REV_STATUS_OK_WITH_CRL      3409
#define IDS_REV_STATUS_OFFLINE_WITH_CRL 3410
#define IDS_REV_STATUS_UNKNOWN_ERROR    3411

// New strings 5/15/2001.
#define IDS_WARNREMOTETRUST_ERROR       3412


// NOTE: pki\activex\xaddroot\resource reserve the range from 7000 to 7099
// for strings


// icons
#define IDI_INFO                        3409  
#define IDI_OK_CERT                     3410
#define IDI_REVOKED_CERT                3411
#define IDI_EXCLAMATION_CERT            3412
#define IDI_TRUSTLIST                   3413
#define IDI_REVOKED_TRUSTLIST           3414
#define IDI_EXCLAMATION_TRUSTLIST       3416
#define IDI_REVOCATIONLIST              3417
#define IDI_CATLIST                     3418
#define IDI_REVOKED_CATLIST             3419
#define IDI_EXCLAMATION_CATLIST         3420
#define IDI_SIGN                        3421
#define IDI_REVOKED_SIGN                3422
#define IDI_EXCLAMATION_SIGN            3423
#define IDI_CA                          3424
#define IDI_PFX                         3425
#define IDI_CERTMGR                     3426


// NOTE: pki\activex\xaddroot\cactl2.h reserve the range from 3490 to 3499
// for icons

// for dacui resources                  4000-6000  


//NOTE:  cryptwzr.lib reserve 6000-8000 range for resources      


//  Select Certificate control ids
#define IDC_CS_PROPERTIES               100
#define IDC_CS_FINEPRINT                101
#define IDC_CS_CERTLIST                 102

#define IDC_CS_INFO                     103
#define IDC_CS_VALIDITY                 104
#define IDC_CS_ALGORITHM                105
#define IDC_CS_SERIAL_NUMBER            106
#define IDC_CS_THUMBPRINT               107
 


//  Certificate View General Page
#define IDC_ADD_TO_STORE_BUTTON         101
#define IDC_DISCLAIMER_BUTTON           102
#define IDC_GOODFOR_EDIT                103
#define IDC_SUBJECT_EDIT                105
#define IDC_ISSUER_EDIT                 106
#define IDC_ACCEPT_BUTTON               108
#define IDC_DECLINE_BUTTON              109
#define IDC_CERT_GENERAL_HEADER         110
#define IDC_CERT_GENERAL_GOODFOR_HEADER 111
#define IDC_CERT_GENERAL_ISSUEDTO_HEADER 113
#define IDC_CERT_GENERAL_ISSUEDBY_HEADER 114
#define IDC_CERT_GENERAL_VALID_EDIT     115
#define IDC_CERT_GENERAL_ERROR_EDIT     116
#define IDC_CERT_ISSUER_WARNING_EDIT    117
#define IDC_CERT_PRIVATE_KEY_EDIT       118

// Certificate view details page
#define IDC_SHOW_DETAILS_COMBO          100
#define IDC_ITEM_LIST                   101
#define IDC_DETAIL_EDIT                 102
#define IDC_SAVE_CERTIFICATE_BUTTON     103  
#define IDC_MYHAND                      104 
#define IDC_EDIT_PROPERTIES_BUTTON      105

//  Certificate View Hierarchy Page
#define IDC_TRUST_VIEW                  100
#define IDC_TRUST_TREE                  101
#define IDC_HIERARCHY_EDIT              102
#define IDC_USAGE_COMBO                 103
#define IDC_CERTIFICATE_PURPOSE_STATIC  104
#define IDC_NOTE2_STATIC                 105


// CTL General Page
#define IDC_CTL_GENERAL_ITEM_LIST       100
#define IDC_CTL_GENERAL_DETAIL_EDIT     101
#define IDC_CTL_GENERAL_VIEW_BUTTON     102
#define IDC_CTL_GENERAL_VALIDITY_EDIT   103
#define IDC_CTL_GENERAL_HEADER_EDIT     104

// CTL Trust List Page
#define IDC_CTL_TRUSTLIST_CERTIFICATE_LIST  100
#define IDC_CTL_TRUSTLIST_DETAIL_EDIT       101
#define IDC_CTL_TRUSTLIST_VIEW_BUTTON       102
#define IDC_CTL_TRUSTLIST_CERTVALUE_LIST    103

// Catalog File Page
#define IDC_CATALOG_ENTRY_LIST          100
#define IDC_CATALOG_ENTRY_DETAIL_LIST   101
#define IDC_CATALOG_ENTRY_DETAIL_EDIT   102

// CRL General Page
#define IDC_CRL_GENERAL_ITEM_LIST       100
#define IDC_CRL_GENERAL_DETAIL_EDIT     101
#define IDC_CRL_GENERAL_HEADER_EDIT     102

// CRL Revocation List Page
#define IDC_CRL_REVOCATIONLIST_REVOKED_CERTIFICATES 100
#define IDC_CRL_REVOCATIONLIST_REVOCATIONENTRY_LIST 101
#define IDC_CRL_REVOCATIONLIST_DETAIL_EDIT          102

// for CPS dialog
#define IDOK_CPS                        100
#define IDCANCEL_CPS                    101
#define IDC_CPS_TEXT                    102
#define ID_MORE_INFO                    103

// properties dialog
#define IDC_KEY_USAGE_LIST              100
#define IDC_DESCRIPTION                 101
#define IDC_CERTIFICATE_NAME            102
#define IDC_PROPERTY_NEWOID             103
#define IDC_ENABLE_ALL_RADIO            104
#define IDC_DISABLE_ALL_RADIO           105
#define IDC_ENABLE_SELECT_RADIO         106
#define IDC_HIDDEN_RICHEDIT             107

// cross cert properties dialog
#define IDC_CHECKFORNEWCERTS_CHECK      100
#define IDC_NUMBEROFUNITS_EDIT          101
#define IDC_UNITS_COMBO                 102
#define IDC_ADDURL_BUTTON               103
#define IDC_USE_DEFAULT_BUTTON          104
#define IDC_NEWURL_EDIT                 105
#define IDC_URL_LIST                    106
#define IDC_REMOVEURL_BUTTON            107

// signer info general page
#define IDC_SIGNER_GENERAL_SIGNER_NAME  100
#define IDC_SIGNER_GENERAL_EMAIL        101
#define IDC_SIGNER_GENERAL_SIGNING_TIME 102
#define IDC_SIGNER_GENERAL_VIEW_CERTIFICATE 103
#define IDC_SIGNER_GENERAL_COUNTER_SIGS 104
#define IDC_SIGNER_GENERAL_DETAILS      105
#define IDC_SIGNER_GENERAL_HEADER_EDIT  106
#define IDC_SIGNER_GENERAL_VALIDITY_EDIT 107

// signer info advanced page
#define IDC_SIGNER_ADVANCED_DETAILS     100
#define IDC_SIGNER_ADVANCED_VALUE       101

// signatures dialog
#define IDC_SIGNATURES_DETAILS_BUTTON   100
#define IDC_SIGNATURES_SIG_LIST         101

// select store
#define IDC_SHOWPHYSICALSTORES_CHECK    100
#define IDC_SELECTSTORE_TREE            101
#define IDC_SELECTSTORE_DISPLAYSTRING   102

// select cert
#define IDC_SELECTCERT_CERTLIST         100
#define IDC_SELECTCERT_DISPLAYSTRING    101
#define IDC_SELECTCERT_VIEWCERT_BUTTON  102
#define IDC_SELECTCERT_ADDFROMDS_BUTTON 103



#define IDC_LIST1                       1014
#define IDC_EDIT1                       1016

#define IDC_STATIC                      -1


//
// Data Protection API control values.
//


#define IDC_PROTECT_PASSWORD1                   1020
#define IDC_PROTECT_EDIT2                       1021
#define IDC_PROTECT_BUTTON3                     1022
#define IDC_PROTECT_MESSAGE                     1023
#define IDC_PROTECT_APP_MSG                     1024
#define IDC_PROTECT_DEFINENEW                   1025
#define IDC_PROTECT_RADIO_LOW                   1026
#define IDC_PROTECT_RADIO_MEDIUM                1027
#define IDC_PROTECT_RADIO_HIGH                  1028
#define IDC_PROTECT_ADVANCED                    1029

#define IDC_PROTECT_CACHEPW                     1030
#define IDC_PROTECT_CHANGE_SECURITY             1031
#define IDC_PROTECT_BACK                        1032
#define IDC_PROTECT_NEXT                        1033
#define IDC_PROTECT_PW_NEWNAME                  1034
#define IDC_PROTECT_LABEL_EDIT1                 1035
#define IDC_PROTECT_MAIN_CAPTION                1036
#define IDC_PROTECT_STATIC1                     1037
#define IDC_PROTECT_STATIC2                     1038
#define IDC_PROTECT_STATIC3                     1039

#define IDC_PROTECT_STATIC4                     1040
#define IDC_PROTECT_STATIC5                     1041
#define IDC_PROTECT_STATIC6                     1042
#define IDC_PROTECT_STATIC7                     1043
#define IDC_PROTECT_STATIC8                     1044
#define IDC_PROTECT_SECURITY_LEVEL              1045
#define IDC_PROTECT_UPDATE_DYNAMIC              1046

#define IDC_PROTECT_DESCRIPTION                 1047
#define IDC_PROTECT_PATH                        1048
#define IDC_PROTECT_ACCESSTYPE                  1049

#define IDC_PROTECT_APP_DESCRIPTION             1050
#define IDC_PROTECT_APP_PATH                    1051
#define IDC_PROTECT_OPERATION_TYPE              1052
     
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        3217
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1090
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

#define IDH_CS_CERTLIST                 (1000+IDC_CS_CERTLIST)
#define IDH_CS_PROPERTIES               (1000+IDC_CS_CERTLIST)
#define IDH_CS_ALGORITHM                (1000+IDC_CS_CERTLIST)
#define IDH_VSG_STATUS                (1000+IDC_CS_CERTLIST)
#define IDH_VSG_FINEPRINT                (1000+IDC_CS_CERTLIST)
#define IDH_VSG_TEXT                (1000+IDC_CS_CERTLIST)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\selstore.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       selstore.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_SELECTSTORE_TREE,          IDH_SELECTSTORE_STORE_TREE},
    {IDC_SHOWPHYSICALSTORES_CHECK,  IDH_SELECTSTORE_SHOWPHYSICAL_CHECK}
};

typedef struct _STORE_SELECT_HELPER
{
    PCCRYPTUI_SELECTSTORE_STRUCTW   pcss;
    HCERTSTORE                      hSelectedStore;
    HWND                            hwndTreeView;
    DWORD                           dwExtraOpenStoreFlag;
    HTREEITEM                       hParentItem;
    BOOL                            fCollapseMode;
    int                             CurrentSysEnumIndex;
    int                             CurrentPhysEnumIndex;
} STORE_SELECT_HELPER, *PSTORE_SELECT_HELPER;

typedef struct _OPEN_STORE_STRUCT
{
    BOOL                        fStoreHandle;
    HCERTSTORE                  hCertStore;
    DWORD                       dwFlags;
    LPCSTR                      ProviderType;
    LPWSTR                      pwszStoreName;
    PCERT_PHYSICAL_STORE_INFO   pStoreInfo;
    int                         EnumerationStructIndex;
} OPEN_STORE_STRUCT, *POPEN_STORE_STRUCT;


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static POPEN_STORE_STRUCT AllocAndReturnOpenStoreStruct(
                                        BOOL                        fStoreHandle,
                                        HCERTSTORE                  hCertStore,
                                        DWORD                       dwFlags,
                                        LPCSTR                      ProviderType,
                                        LPWSTR                      pwszStoreName,
                                        PCERT_PHYSICAL_STORE_INFO   pStoreInfo,
                                        int                         EnumerationStructIndex)
{
    POPEN_STORE_STRUCT pOpenStoreStruct;

    if (NULL == (pOpenStoreStruct = (POPEN_STORE_STRUCT) malloc(sizeof(OPEN_STORE_STRUCT))))
    {
        return FALSE;
    }

    pOpenStoreStruct->fStoreHandle = fStoreHandle;

    if (fStoreHandle)
    {
        pOpenStoreStruct->hCertStore = hCertStore;
    }
    else
    {
        if (NULL == (pOpenStoreStruct->pwszStoreName = AllocAndCopyWStr(pwszStoreName)))
        {
            free(pOpenStoreStruct);
            return NULL;
        }

        pOpenStoreStruct->dwFlags = dwFlags;
        pOpenStoreStruct->ProviderType = ProviderType;
        pOpenStoreStruct->pStoreInfo = NULL;
    }

    pOpenStoreStruct->EnumerationStructIndex = EnumerationStructIndex;

    return pOpenStoreStruct;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void FreeOpenStoreStruct(POPEN_STORE_STRUCT pOpenStoreStruct)
{
    if (!(pOpenStoreStruct->fStoreHandle))
    {
        free(pOpenStoreStruct->pwszStoreName);
    }

    free(pOpenStoreStruct);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL WINAPI EnumPhyCallback(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved,
    IN OPTIONAL void *pvArg
    )
{
    PSTORE_SELECT_HELPER    pviewhelp = (PSTORE_SELECT_HELPER) pvArg;
    TVINSERTSTRUCTW         tvins;
    LPWSTR                  pwszFullStoreName;
    HCERTSTORE              hTestStore = NULL;
    DWORD                   dwAccess;
    DWORD                   cbdwAccess = sizeof(DWORD);
    LPCWSTR                 pszLocalizedName;


    //
    // if the store that is passed back cannot be opened, OR,
    // if the caller specified to display writable stores only, and
    // the current store being enumerated is read only, then that store
    // will not be displayed
    //
    if ((pStoreInfo->dwFlags & (CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG | CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG)) ||
        ((pviewhelp->pcss->dwFlags & CRYPTUI_DISPLAY_WRITE_ONLY_STORES) &&
        (pStoreInfo->dwOpenFlags & CERT_STORE_READONLY_FLAG)))
    {
        return TRUE;
    }

    if (NULL == (pwszFullStoreName = (LPWSTR) malloc((wcslen((LPWSTR)pvSystemStore)+wcslen(L"\\")+wcslen(pwszStoreName)+1) * sizeof(WCHAR))))
    {
        return FALSE;
    }
    wcscpy(pwszFullStoreName, (LPWSTR)pvSystemStore);
    wcscat(pwszFullStoreName, L"\\");
    wcscat(pwszFullStoreName, pwszStoreName);

    //
    // now, if the caller passed in the CRYPTUI_VALIDATE_STORES_AS_WRITABLE flag,
    // we need to verify that the store can actually be opened with writable rights
    //
    if (pviewhelp->pcss->dwFlags & CRYPTUI_VALIDATE_STORES_AS_WRITABLE)
    {
         hTestStore = CertOpenStore(
                                    CERT_STORE_PROV_PHYSICAL,
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    NULL,
                                    (dwFlags & CERT_SYSTEM_STORE_MASK)      |
                                        pviewhelp->dwExtraOpenStoreFlag     |
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG  |
                                        (pviewhelp->pcss->pStoresForSelection->rgEnumerationStructs[pviewhelp->CurrentPhysEnumIndex].dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG),
                                    pwszFullStoreName);

         if (hTestStore == NULL)
         {
            free(pwszFullStoreName);
            return TRUE;
         }

         //
         // make call to get the store property to see if it is writable
         //
         CertGetStoreProperty(hTestStore, CERT_ACCESS_STATE_PROP_ID, &dwAccess, &cbdwAccess);

         CertCloseStore(hTestStore, 0);

         //
         // if the store can't be written to, then simply return
         //
         if (!(dwAccess & CERT_ACCESS_STATE_WRITE_PERSIST_FLAG))
         {
            return TRUE;
         }
    }

    pszLocalizedName = CryptFindLocalizedName(pwszStoreName);

    tvins.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvins.hParent = pviewhelp->hParentItem;
    tvins.hInsertAfter = TVI_LAST;
    tvins.item.pszText = (pszLocalizedName != NULL) ?   (LPWSTR) pszLocalizedName : (LPWSTR) pwszStoreName;
    tvins.item.cchTextMax = wcslen(tvins.item.pszText);
    tvins.item.iImage = 0;
    tvins.item.iSelectedImage = tvins.item.iImage;
    tvins.item.lParam = (LPARAM) AllocAndReturnOpenStoreStruct(
                                            FALSE,
                                            0,
                                            (dwFlags & CERT_SYSTEM_STORE_MASK) |
                                                (pviewhelp->pcss->pStoresForSelection->rgEnumerationStructs[pviewhelp->CurrentPhysEnumIndex].dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG),
                                            CERT_STORE_PROV_PHYSICAL,
                                            (LPWSTR) pwszFullStoreName,
                                            pStoreInfo,
                                            -1);

    SendMessage(pviewhelp->hwndTreeView, TVM_INSERTITEMW, 0, (LPARAM) &tvins);
    free(pwszFullStoreName);

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL WINAPI EnumSysCallback(
    IN const void* pwszSystemStore,
    IN DWORD dwFlags,
    IN PCERT_SYSTEM_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved,
    IN OPTIONAL void *pvArg
    )
{
    PSTORE_SELECT_HELPER    pviewhelp = (PSTORE_SELECT_HELPER) pvArg;
    TVINSERTSTRUCTW         tvins;
    HTREEITEM               hItem;
    LPCWSTR                 pszLocalizedName;
    HCERTSTORE              hTestStore = NULL;
    DWORD                   dwAccess;
    DWORD                   cbdwAccess = sizeof(DWORD);

    if ((_wcsicmp((LPWSTR)pwszSystemStore, L"acrs") == 0) ||
        (_wcsicmp((LPWSTR)pwszSystemStore, L"request") == 0))
    {
        return TRUE;
    }

    //
    // now, if the caller passed in the CRYPTUI_VALIDATE_STORES_AS_WRITABLE flag,
    // we need to verify that the store can actually be opened with writable rights
    //
    if (pviewhelp->pcss->dwFlags & CRYPTUI_VALIDATE_STORES_AS_WRITABLE)
    {
         hTestStore = CertOpenStore(
                                    CERT_STORE_PROV_SYSTEM,
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    NULL,
                                    (dwFlags & CERT_SYSTEM_STORE_MASK)      |
                                        pviewhelp->dwExtraOpenStoreFlag     |
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG  |
                                        (pviewhelp->pcss->pStoresForSelection->rgEnumerationStructs[pviewhelp->CurrentSysEnumIndex].dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG),
                                    pwszSystemStore);

         if (hTestStore == NULL)
         {
            return TRUE;
         }

         //
         // make call to get the store property to see if it is writable
         //
         CertGetStoreProperty(hTestStore, CERT_ACCESS_STATE_PROP_ID, &dwAccess, &cbdwAccess);

         CertCloseStore(hTestStore, 0);

         //
         // if the store can't be written to, then simply return
         //
         if (!(dwAccess & CERT_ACCESS_STATE_WRITE_PERSIST_FLAG))
         {
            return TRUE;
         }
    }

    pszLocalizedName = CryptFindLocalizedName((LPWSTR)pwszSystemStore);

    tvins.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvins.hParent = TVI_ROOT;
    tvins.hInsertAfter = TVI_LAST;
    tvins.item.pszText = (pszLocalizedName != NULL) ?   (LPWSTR) pszLocalizedName : (LPWSTR) pwszSystemStore;
    tvins.item.cchTextMax = wcslen(tvins.item.pszText);
    tvins.item.iImage = 0;
    tvins.item.iSelectedImage = tvins.item.iImage;
    tvins.item.lParam = (LPARAM) AllocAndReturnOpenStoreStruct(
                                            FALSE,
                                            0,
                                            dwFlags & CERT_SYSTEM_STORE_MASK |
                                                (pviewhelp->pcss->pStoresForSelection->rgEnumerationStructs[pviewhelp->CurrentSysEnumIndex].dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG),
                                            CERT_STORE_PROV_SYSTEM,
                                            (LPWSTR) pwszSystemStore,
                                            NULL,
                                            pviewhelp->CurrentSysEnumIndex);
    pviewhelp->hParentItem = (HTREEITEM) SendMessage(pviewhelp->hwndTreeView, TVM_INSERTITEMW, 0, (LPARAM) &tvins);
    
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY SelectStoreDialogProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PSTORE_SELECT_HELPER            pviewhelp;
    HIMAGELIST                      hIml;
    PCCRYPTUI_SELECTSTORE_STRUCTW   pcss;
    TV_ITEM                         tvi;
    TVINSERTSTRUCTW                 tvins;
    DWORD                           i;
    LPNMTREEVIEW                    pnmtv;
    HTREEITEM                       hParentItem, hChildItem;
    HWND                            hwndTreeView;
    POPEN_STORE_STRUCT              pOpenStoreStruct;
    WCHAR                           szText[CRYPTUI_MAX_STRING_SIZE];
    HWND                            hwnd;
    WCHAR                           errorString[CRYPTUI_MAX_STRING_SIZE];
    WCHAR                           errorTitle[CRYPTUI_MAX_STRING_SIZE];

    switch ( msg ) {

    case WM_INITDIALOG:
        pviewhelp = (PSTORE_SELECT_HELPER) lParam;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);
        pcss = pviewhelp->pcss;

        pviewhelp->hwndTreeView = GetDlgItem(hwndDlg, IDC_SELECTSTORE_TREE);
        pviewhelp->fCollapseMode = FALSE;

        //
        // set the dialog title and the display string
        //
        if (pcss->szTitle != NULL)
        {
            SetWindowTextU(hwndDlg, pcss->szTitle);
        }

        if (pcss->szDisplayString != NULL)
        {
            SetDlgItemTextU(hwndDlg, IDC_SELECTSTORE_DISPLAYSTRING, pcss->szDisplayString);
        }
        else
        {
            LoadStringU(HinstDll, IDS_SELECT_STORE_DEFAULT, szText, ARRAYSIZE(szText));
            SetDlgItemTextU(hwndDlg, IDC_SELECTSTORE_DISPLAYSTRING, szText);
        }

        //
        // enable/disable the show physical stores check box
        //
        if (pcss->dwFlags & CRYPTUI_ALLOW_PHYSICAL_STORE_VIEW)
        {
            ShowWindow(GetDlgItem(hwndDlg, IDC_SHOWPHYSICALSTORES_CHECK), SW_SHOW);
        }
        else
        {
            ShowWindow(GetDlgItem(hwndDlg, IDC_SHOWPHYSICALSTORES_CHECK), SW_HIDE);
        }

        //
        //  Build up the image list for the control
        //
        hIml = ImageList_LoadImage(HinstDll, MAKEINTRESOURCE(IDB_FOLDER), 0, 1, RGB(255,0,255), IMAGE_BITMAP, 0);
        if (hIml != NULL)
        {
            TreeView_SetImageList(GetDlgItem(hwndDlg, IDC_SELECTSTORE_TREE), hIml, TVSIL_NORMAL);
        }

        //
        // add all of the stores from the enumeration to the tree view
        //
        i = 0;
        while (i < pcss->pStoresForSelection->cEnumerationStructs)
        {
            pviewhelp->CurrentSysEnumIndex = (int) i;
            if (!CertEnumSystemStore(
                        pcss->pStoresForSelection->rgEnumerationStructs[i].dwFlags,
                        pcss->pStoresForSelection->rgEnumerationStructs[i].pvSystemStoreLocationPara,
                        pviewhelp,
                        EnumSysCallback))
            {
                // ERROR
            }
            i++;
        }


        //
        // add all of the stores from the enumeration to the tree view
        //
        i = 0;
        while (i < pcss->pStoresForSelection->cStores)
        {
            memset(&tvins, 0, sizeof(tvins));
            tvins.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
            tvins.hParent = TVI_ROOT;
            tvins.hInsertAfter = TVI_LAST;
            tvins.item.pszText = (LPWSTR) GetStoreName(pcss->pStoresForSelection->rghStores[i], TRUE);

            //
            // if we didn't get a name then just continue on to the next store
            //
            if (tvins.item.pszText == NULL)
            {
                i++;
                continue;
            }
            tvins.item.cchTextMax = wcslen(tvins.item.pszText);
            tvins.item.iImage = 0;
            tvins.item.iSelectedImage = tvins.item.iImage;
            tvins.item.lParam =
                (LPARAM) AllocAndReturnOpenStoreStruct(TRUE, pcss->pStoresForSelection->rghStores[i], 0, NULL, NULL, NULL, -1);
            SendMessage(pviewhelp->hwndTreeView, TVM_INSERTITEMW, 0, (LPARAM) &tvins);
            free(tvins.item.pszText);
            i++;
        }

        break;

    case WM_NOTIFY:
        pviewhelp = (PSTORE_SELECT_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        if (pviewhelp == NULL)
        {
            break;
        }

        pcss = pviewhelp->pcss;

        switch (((NMHDR FAR *) lParam)->code) {

        case TVN_ITEMEXPANDINGA:
        case TVN_ITEMEXPANDINGW:

            pnmtv = (LPNMTREEVIEW) lParam;

            //
            // if in collapse mode the just return
            //
            if (pviewhelp->fCollapseMode)
            {
                return TRUE;
            }

            //
            // don't allow expansion if physical stores are not allowed to be viewed
            //
            if (!((pcss->dwFlags & CRYPTUI_ALLOW_PHYSICAL_STORE_VIEW) &&
                 ((SendMessage(GetDlgItem(hwndDlg, IDC_SHOWPHYSICALSTORES_CHECK), BM_GETSTATE, 0, 0) & BST_CHECKED) == BST_CHECKED)))
            {
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            }
            return TRUE;
        }

        break;

    case WM_COMMAND:
        pviewhelp = (PSTORE_SELECT_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        if (pviewhelp == NULL)
        {
            break;
        }

        pcss = pviewhelp->pcss;

        switch (LOWORD(wParam))
        {

        case IDC_SHOWPHYSICALSTORES_CHECK:

            LRESULT checkState;

            if (HIWORD(wParam) != BN_CLICKED)
            {
                return TRUE;
            }

            hwndTreeView = GetDlgItem(hwndDlg, IDC_SELECTSTORE_TREE);

            memset(&tvi, 0, sizeof(tvi));
            tvi.mask = TVIF_PARAM | TVIF_HANDLE;

            checkState = SendMessage(GetDlgItem(hwndDlg, IDC_SHOWPHYSICALSTORES_CHECK), BM_GETSTATE, 0, 0);
            if ((checkState & BST_CHECKED) == BST_CHECKED)
            {
                ShowWindow(hwndTreeView, SW_HIDE);
                //
                // add all the physical stores under each system store
                //
                pviewhelp->hParentItem = TreeView_GetRoot(hwndTreeView);
                while (NULL != pviewhelp->hParentItem)
                {
                    tvi.hItem = pviewhelp->hParentItem;
                    TreeView_GetItem(hwndTreeView, &tvi);
                    pOpenStoreStruct = (POPEN_STORE_STRUCT) tvi.lParam;

                    if (!(pOpenStoreStruct->fStoreHandle))
                    {
                        pviewhelp->CurrentPhysEnumIndex = (int) pOpenStoreStruct->EnumerationStructIndex;
                        CertEnumPhysicalStore(
                                (LPWSTR) pOpenStoreStruct->pwszStoreName, //pwszSystemStore,
                                pcss->pStoresForSelection->rgEnumerationStructs[pOpenStoreStruct->EnumerationStructIndex].dwFlags,
                                pviewhelp,
                                EnumPhyCallback);

                        TreeView_Expand(hwndTreeView, pviewhelp->hParentItem, TVE_EXPAND);
                        TreeView_Expand(hwndTreeView, pviewhelp->hParentItem, TVE_COLLAPSE);
                    }

                    pviewhelp->hParentItem = TreeView_GetNextItem(hwndTreeView, pviewhelp->hParentItem, TVGN_NEXT);
                }

                ShowWindow(hwndTreeView, SW_SHOW);
            }
            else
            {
                //
                // delete all of the physical stores under each system store
                //
                pviewhelp->fCollapseMode = TRUE;
                hParentItem = TreeView_GetRoot(hwndTreeView);
                while (NULL != hParentItem)
                {
                    while (NULL != (hChildItem = TreeView_GetNextItem(hwndTreeView, hParentItem, TVGN_CHILD)))
                    {
                        tvi.hItem = hChildItem;
                        TreeView_GetItem(hwndTreeView, &tvi);

                        FreeOpenStoreStruct((POPEN_STORE_STRUCT) tvi.lParam);
                        TreeView_DeleteItem(hwndTreeView, hChildItem);
                    }
                    hParentItem = TreeView_GetNextItem(hwndTreeView, hParentItem, TVGN_NEXT);
                }
                pviewhelp->fCollapseMode = FALSE;
            }
            break;

        case IDOK:
            hwndTreeView = GetDlgItem(hwndDlg, IDC_SELECTSTORE_TREE);

            hParentItem = TreeView_GetSelection(hwndTreeView);
            if (hParentItem != NULL)
            {
                memset(&tvi, 0, sizeof(tvi));
                tvi.mask = TVIF_PARAM | TVIF_HANDLE;
                tvi.hItem = hParentItem;
                TreeView_GetItem(hwndTreeView, &tvi);

                pOpenStoreStruct = (POPEN_STORE_STRUCT) tvi.lParam;

                if (pOpenStoreStruct->fStoreHandle)
                {
                    pviewhelp->hSelectedStore = CertDuplicateStore(pOpenStoreStruct->hCertStore);
                }
                else
                {
                    pviewhelp->hSelectedStore = CertOpenStore(
                                                    pOpenStoreStruct->ProviderType,
                                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                    NULL,
                                                    pOpenStoreStruct->dwFlags               |
                                                        pviewhelp->dwExtraOpenStoreFlag     |
                                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG,
                                                    pOpenStoreStruct->pwszStoreName);

                    //
                    // check to make sure the store got opened correctly,
                    // if not, then notify the user
                    //
                    if (pviewhelp->hSelectedStore == NULL)
                    {
                        LoadStringU(HinstDll, IDS_UNABLE_TO_OPEN_STORE, errorString, ARRAYSIZE(errorString));
                        if (pcss->szTitle != NULL)
                        {
                            MessageBoxU(hwndDlg, errorString, pcss->szTitle, MB_OK | MB_ICONWARNING);
                        }
                        else
                        {
                            LoadStringU(HinstDll, IDS_SELECT_STORE_TITLE, errorTitle, ARRAYSIZE(errorTitle));
                            MessageBoxU(hwndDlg, errorString, errorTitle, MB_OK | MB_ICONWARNING);
                        }
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
                        return TRUE;
                    }
                }

                //
                // if a validation callback was passed in then do the validation
                //
                if ((pcss->pValidateStoreCallback) &&
                    ((*(pcss->pValidateStoreCallback))(pviewhelp->hSelectedStore, hwndDlg, pcss->pvCallbackData) != TRUE))
                {
                    CertCloseStore(pviewhelp->hSelectedStore, 0);

                    pviewhelp->hSelectedStore = NULL;
                    return TRUE;
                }
            }
            else
            {
                LoadStringU(HinstDll, IDS_SELECT_STORE_ERROR, errorString, ARRAYSIZE(errorString));
                if (pcss->szTitle != NULL)
                {
                    MessageBoxU(hwndDlg, errorString, pcss->szTitle, MB_OK | MB_ICONWARNING);
                }
                else
                {
                    LoadStringU(HinstDll, IDS_SELECT_STORE_TITLE, errorTitle, ARRAYSIZE(errorTitle));
                    MessageBoxU(hwndDlg, errorString, errorTitle, MB_OK | MB_ICONWARNING);
                }
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
                return TRUE;
            }

            EndDialog(hwndDlg, NULL);
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, NULL);
            break;
        }

        break;

    case WM_DESTROY:
        pviewhelp = (PSTORE_SELECT_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        if (pviewhelp == NULL)
        {
            break;
        }

        hwndTreeView = GetDlgItem(hwndDlg, IDC_SELECTSTORE_TREE);

        //
        // free up all the store open helper structs if we are in enum mode
        //
        memset(&tvi, 0, sizeof(tvi));
        tvi.mask = TVIF_PARAM | TVIF_HANDLE;

        while (NULL != (hParentItem = TreeView_GetRoot(hwndTreeView)))
        {
            while (NULL != (hChildItem = TreeView_GetNextItem(hwndTreeView, hParentItem, TVGN_CHILD)))
            {
                tvi.hItem = hChildItem;
                TreeView_GetItem(hwndTreeView, &tvi);

                FreeOpenStoreStruct((POPEN_STORE_STRUCT) tvi.lParam);
                TreeView_DeleteItem(hwndTreeView, hChildItem);
            }

            tvi.hItem = hParentItem;
            TreeView_GetItem(hwndTreeView, &tvi);

            FreeOpenStoreStruct((POPEN_STORE_STRUCT) tvi.lParam);
            TreeView_DeleteItem(hwndTreeView, hParentItem);
        }

        ImageList_Destroy(TreeView_GetImageList(GetDlgItem(hwndDlg, IDC_SELECTSTORE_TREE), TVSIL_NORMAL));

        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDOK))                         &&
            (hwnd != GetDlgItem(hwndDlg, IDCANCEL))                     &&
            (hwnd != GetDlgItem(hwndDlg, IDC_SELECTSTORE_TREE))         &&
            (hwnd != GetDlgItem(hwndDlg, IDC_SHOWPHYSICALSTORES_CHECK)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
HCERTSTORE
WINAPI
CryptUIDlgSelectStoreW(
            PCCRYPTUI_SELECTSTORE_STRUCTW pcss
            )
{
    STORE_SELECT_HELPER viewhelper;

    if (CommonInit() == FALSE)
    {
        return NULL;
    }

    if (pcss->dwSize != sizeof(CRYPTUI_SELECTSTORE_STRUCTW)) {
        SetLastError(E_INVALIDARG);
        return FALSE;
    }

    viewhelper.pcss = pcss;
    viewhelper.hSelectedStore = NULL;
    viewhelper.dwExtraOpenStoreFlag = (pcss->dwFlags & CRYPTUI_RETURN_READ_ONLY_STORE) ? CERT_STORE_READONLY_FLAG : 0;

    DialogBoxParamU(
            HinstDll,
            (LPWSTR) MAKEINTRESOURCE(IDD_SELECT_STORE_DIALOG),
            (pcss->hwndParent != NULL) ? pcss->hwndParent : GetDesktopWindow(),
            SelectStoreDialogProc,
            (LPARAM) &viewhelper);

    return(viewhelper.hSelectedStore);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
HCERTSTORE
WINAPI
CryptUIDlgSelectStoreA(
            PCCRYPTUI_SELECTSTORE_STRUCTA pcss
            )
{
    CRYPTUI_SELECTSTORE_STRUCTW cssW;
    HCERTSTORE                  hReturnStore = NULL;

    memcpy(&cssW, pcss, sizeof(cssW));

    if (pcss->szTitle)
    {
        cssW.szTitle = CertUIMkWStr(pcss->szTitle);
    }

    if (pcss->szDisplayString)
    {
        cssW.szDisplayString = CertUIMkWStr(pcss->szDisplayString);
    }

    hReturnStore = CryptUIDlgSelectStoreW(&cssW);

    if (cssW.szTitle)
    {
        free((void *) cssW.szTitle);
    }

    if (cssW.szDisplayString)
    {
        free((void *) cssW.szDisplayString);
    }

    return(hReturnStore);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\signgen.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       signgen.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_SIGNER_GENERAL_SIGNER_NAME,        IDH_SIGNERINFO_GENERAL_SIGNERNAME},
    {IDC_SIGNER_GENERAL_EMAIL,              IDH_SIGNERINFO_GENERAL_SIGNEREMAIL},
    {IDC_SIGNER_GENERAL_SIGNING_TIME,       IDH_SIGNERINFO_GENERAL_SIGNETIME},
    {IDC_SIGNER_GENERAL_VIEW_CERTIFICATE,   IDH_SIGNERINFO_GENERAL_VIEW_CERTIFICATE},
    {IDC_SIGNER_GENERAL_COUNTER_SIGS,       IDH_SIGNERINFO_GENERAL_COUNTERSIG_LIST},
    {IDC_SIGNER_GENERAL_DETAILS,            IDH_SIGNERINFO_GENERAL_COUNTERSIG_DETAILS}
};


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void AddCounterSignersToList(HWND hWndListView, SIGNER_VIEW_HELPER *pviewhelp)
{
    CMSG_SIGNER_INFO const *pSignerInfo;
    PCMSG_SIGNER_INFO       pCounterSignerInfo;
    DWORD                   cbCounterSignerInfo;
    PCCERT_CONTEXT          pCertContext = NULL;
    DWORD                   i;
    WCHAR                   szNameText[CRYPTUI_MAX_STRING_SIZE];
    WCHAR                   szEmailText[CRYPTUI_MAX_STRING_SIZE];
    LV_ITEMW                lvI;
    int                     itemIndex = 0;
    LPWSTR                  pszTimeText;

    pSignerInfo = pviewhelp->pcvsi->pSignerInfo;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    memset(&lvI, 0, sizeof(lvI));
    lvI.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;

    //
    // loop for each unauthenticated attribute and see if it is a counter sig
    //
    for (i=0; i<pSignerInfo->UnauthAttrs.cAttr; i++)
    {
        if (!(strcmp(pSignerInfo->UnauthAttrs.rgAttr[i].pszObjId, szOID_RSA_counterSign) == 0))
        {
            continue;
        }

        assert(pSignerInfo->UnauthAttrs.rgAttr[i].cValue == 1);

        //
        // decode the EncodedSigner info
        //
        cbCounterSignerInfo = 0;
        pCounterSignerInfo  = NULL;
		if(!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
							PKCS7_SIGNER_INFO,
							pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].pbData,
							pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].cbData,
							0,
							NULL,
							&cbCounterSignerInfo))
        {
			return;
        }

        if (NULL == (pCounterSignerInfo = (PCMSG_SIGNER_INFO)malloc(cbCounterSignerInfo)))
        {
            return;
        }

		if(!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
							PKCS7_SIGNER_INFO,
							pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].pbData,
							pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].cbData,
							0,
							pCounterSignerInfo,
							&cbCounterSignerInfo))
        {
            free(pCounterSignerInfo);
            return;
        }

        //
        // find the signers cert
        //
        pCertContext = GetSignersCert(
                                pCounterSignerInfo,
                                pviewhelp->hExtraStore,
                                pviewhelp->pcvsi->cStores,
                                pviewhelp->pcvsi->rghStores);

        //
        // get the signers name
        //
        if (!(pCertContext && CertGetNameStringW(
                                        pCertContext,
                                        CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                        0,//CERT_NAME_ISSUER_FLAG,
                                        NULL,
                                        szNameText,
                                        ARRAYSIZE(szNameText))))
        {
            LoadStringU(HinstDll, IDS_NOTAVAILABLE, szNameText, ARRAYSIZE(szNameText));
        }

        //
        // get the signers email
        //
        if (!(pCertContext && (CertGetNameStringW(
                                        pCertContext,
                                        CERT_NAME_EMAIL_TYPE,
                                        0,//CERT_NAME_ISSUER_FLAG,
                                        NULL,
                                        szEmailText,
                                        ARRAYSIZE(szEmailText)) != 1)))
        {
            LoadStringU(HinstDll, IDS_NOTAVAILABLE, szEmailText, ARRAYSIZE(szEmailText));
        }

        pszTimeText = AllocAndReturnSignTime(pCounterSignerInfo, NULL, hWndListView);

        //
        // add the item to the list view
        //
        lvI.iSubItem = 0;
        lvI.pszText = szNameText;
        lvI.cchTextMax = wcslen(szNameText);
        lvI.lParam = (LPARAM) pCounterSignerInfo;
        lvI.iItem = itemIndex++;
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, itemIndex-1 , 1, szEmailText);

        if (pszTimeText != NULL)
        {
            ListView_SetItemTextU(hWndListView, itemIndex-1 , 2, pszTimeText);
            free(pszTimeText);
        }
        else
        {
            LoadStringU(HinstDll, IDS_NOTAVAILABLE, szEmailText, ARRAYSIZE(szEmailText));
            ListView_SetItemTextU(hWndListView, itemIndex-1 , 2, szEmailText);
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL ValidateCertForUsageWrapper(
                    PCCERT_CONTEXT  pCertContext,
                    DWORD           cStores,
                    HCERTSTORE *    rghStores,
                    HCERTSTORE      hExtraStore,
                    LPCSTR          pszOID)
{
    if ((pszOID == NULL) ||
        (!((strcmp(pszOID, szOID_PKIX_KP_TIMESTAMP_SIGNING) == 0)  ||
           (strcmp(pszOID, szOID_KP_TIME_STAMP_SIGNING) == 0))))
    {
        return (ValidateCertForUsage(
                    pCertContext,
                    NULL,
                    cStores,
                    rghStores,
                    hExtraStore,
                    pszOID));
    }
    else
    {
        return (ValidateCertForUsage(
                    pCertContext,
                    NULL,
                    cStores,
                    rghStores,
                    hExtraStore,
                    szOID_PKIX_KP_TIMESTAMP_SIGNING) ||
                ValidateCertForUsage(
                    pCertContext,
                    NULL,
                    cStores,
                    rghStores,
                    hExtraStore,
                    szOID_KP_TIME_STAMP_SIGNING));
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL GetWinVTrustState(SIGNER_VIEW_HELPER  *pviewhelp)
{
    HCERTSTORE          *rghLocalStoreArray;
    DWORD               i;

    //
    // if the private data was passed in that means WinVerifyTrust has already
    // been called so just use that state to see if the cert is OK, otherwise
    // call BuildWinVTrustState to build up the state
    //
    if (pviewhelp->pPrivate == NULL)
    {
        //
        // make one array out of the array of hCertStores plus the extra hCertStore
        //
        if (NULL == (rghLocalStoreArray = (HCERTSTORE *) malloc(sizeof(HCERTSTORE) * (pviewhelp->pcvsi->cStores+1))))
        {
            return FALSE;
        }
        i=0;
        while (i<pviewhelp->pcvsi->cStores)
        {
            rghLocalStoreArray[i] = pviewhelp->pcvsi->rghStores[i];
            i++;
        }
        rghLocalStoreArray[i] = pviewhelp->hExtraStore;

        if (NULL == (pviewhelp->pPrivate = (CERT_VIEWSIGNERINFO_PRIVATE *) malloc(sizeof(CERT_VIEWSIGNERINFO_PRIVATE))))
        {
            free(rghLocalStoreArray);
            return FALSE;
        }

        if (BuildWinVTrustState(
                    NULL,
                    pviewhelp->pcvsi->pSignerInfo,
                    pviewhelp->pcvsi->cStores+1,
                    rghLocalStoreArray,
                    pviewhelp->pcvsi->pszOID,
                    pviewhelp->pPrivate,
                    &(pviewhelp->CryptProviderDefUsage),
                    &(pviewhelp->WTD)))
        {
            pviewhelp->fPrivateAllocated = TRUE;
            pviewhelp->pPrivate->idxSigner = 0;
            pviewhelp->pPrivate->fCounterSigner = FALSE;
            pviewhelp->pPrivate->idxCounterSigner = 0;
            pviewhelp->pPrivate->dwInheritedError = 0;
        }
        else
        {
            free(pviewhelp->pPrivate);
            pviewhelp->pPrivate = NULL;
        }

        free(rghLocalStoreArray);
    }

    if (pviewhelp->pPrivate != NULL)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageSignerGeneral(HWND hwndDlg, UINT msg, WPARAM wParam,
                                LPARAM lParam)
{
    DWORD                       i;
    PROPSHEETPAGE               *ps;
    SIGNER_VIEW_HELPER          *pviewhelp;
    HWND                        hWndListView;
    LV_COLUMNW                  lvC;
    WCHAR                       szText[CRYPTUI_MAX_STRING_SIZE];
    HANDLE                      hGraphic;
    DWORD                       cbText;
    LPWSTR                      pwszText;
    CMSG_SIGNER_INFO const      *pSignerInfo;
    LPWSTR                      pszTimeText;
    LVITEMW                     lvI;
    int                         listIndex;
    CHARFORMAT                  chFormat;
    HWND                        hwnd;
    CRYPT_PROVIDER_DATA const   *pProvData = NULL;
    LPWSTR                      pwszErrorString;
    LPNMLISTVIEW                pnmv;

    switch ( msg ) {
    case WM_INITDIALOG:
        //
        // save the pviewhelp struct in DWL_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (SIGNER_VIEW_HELPER *) (ps->lParam);
        pSignerInfo = pviewhelp->pcvsi->pSignerInfo;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);

        //
        // extract the signers cert from the list of stores
        //
        pviewhelp->pSignersCert = GetSignersCert(
                                            pviewhelp->pcvsi->pSignerInfo,
                                            pviewhelp->hExtraStore,
                                            pviewhelp->pcvsi->cStores,
                                            pviewhelp->pcvsi->rghStores);

        if (!GetWinVTrustState(pviewhelp))
        {
            return FALSE;
        }

        switch (pviewhelp->pPrivate->pCryptProviderData->dwFinalError)
        {
        case TRUST_E_NO_SIGNER_CERT:
            pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_EXCLAMATION_SIGN));
            LoadStringU(HinstDll, IDS_SIGNER_UNAVAILABLE_CERT, (LPWSTR)szText, ARRAYSIZE(szText));
            break;

        case TRUST_E_CERT_SIGNATURE:
            pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_SIGN));
            LoadStringU(HinstDll, IDS_BAD_SIGNER_CERT_SIGNATURE, (LPWSTR)szText, ARRAYSIZE(szText));
            break;

        case TRUST_E_BAD_DIGEST:
            pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_SIGN));
            LoadStringU(HinstDll, IDS_SIGNER_INVALID_SIGNATURE, (LPWSTR)szText, ARRAYSIZE(szText));
            break;

        case CERT_E_CHAINING:
            pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_SIGN));
            LoadStringU(HinstDll, IDS_SIGNER_CERT_NO_VERIFY, (LPWSTR)szText, ARRAYSIZE(szText));
            break;

        case TRUST_E_COUNTER_SIGNER:
        case TRUST_E_TIME_STAMP:
            pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_SIGN));

            //
            // if the over-all error is a counter signer signer error, then we need to check
            // whether we are currently viewing the counter signer of the original signer
            //
            if (pviewhelp->pPrivate->fCounterSigner)
            {
                PCRYPT_PROVIDER_SGNR pSigner;

                //
                // if we are looking at the counter signer, then get the specific error
                // out of the signer structure
                //
                pSigner = WTHelperGetProvSignerFromChain(
                                    pviewhelp->pPrivate->pCryptProviderData,
                                    pviewhelp->pPrivate->idxSigner,
                                    pviewhelp->pPrivate->fCounterSigner,
                                    pviewhelp->pPrivate->idxCounterSigner);
                
                if (pSigner == NULL)
                {
                    LoadStringU(HinstDll, IDS_UKNOWN_ERROR, (LPWSTR)szText, ARRAYSIZE(szText));
                }
                else
                {
                    switch (pSigner->dwError)
                    {
                    case TRUST_E_NO_SIGNER_CERT:
                        pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_EXCLAMATION_SIGN));
                        LoadStringU(HinstDll, IDS_SIGNER_UNAVAILABLE_CERT, (LPWSTR)szText, ARRAYSIZE(szText));
                        break;

                    case TRUST_E_CERT_SIGNATURE:
                        LoadStringU(HinstDll, IDS_BAD_SIGNER_CERT_SIGNATURE, (LPWSTR)szText, ARRAYSIZE(szText));
                        break;

                    case TRUST_E_BAD_DIGEST:
                    case NTE_BAD_SIGNATURE:
                        LoadStringU(HinstDll, IDS_SIGNER_INVALID_SIGNATURE, (LPWSTR)szText, ARRAYSIZE(szText));
                        break;

                    default:
                        GetUnknownErrorString(&pwszErrorString, pSigner->dwError);
                        if ((pwszErrorString != NULL) && (wcslen(pwszErrorString)+1 < ARRAYSIZE(szText)))
                        {
                            wcscpy(szText, pwszErrorString);
                        }
                        else
                        {
                            LoadStringU(HinstDll, IDS_UKNOWN_ERROR, (LPWSTR)szText, ARRAYSIZE(szText));
                        }
                        free(pwszErrorString);
                        break;
                    }
                }
            }
            else
            {
                //
                // since we are viewing the original signer, just set the generic counter signer
                // error problem
                //
                LoadStringU(HinstDll, IDS_COUNTER_SIGNER_INVALID, (LPWSTR)szText, ARRAYSIZE(szText));
            }
            break;

        case 0:

            //
            // even if there is no error from the wintrust call, there may be ar
            // inherited error, if that is that case then fall through to the default
            // error processing
            //
            if ((pviewhelp->dwInheritedError == 0) && (pviewhelp->pPrivate->dwInheritedError == 0))
            {
                pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_SIGN));
                LoadStringU(HinstDll, IDS_SIGNER_VALID, (LPWSTR)szText, ARRAYSIZE(szText));
                break;
            }

            // fall through if dwInheritedError is not 0

        default:

            if (pviewhelp->pPrivate->pCryptProviderData->dwFinalError != 0)
            {
                GetUnknownErrorString(&pwszErrorString, pviewhelp->pPrivate->pCryptProviderData->dwFinalError);
            }
            else
            {
                if (pviewhelp->dwInheritedError != 0)
                {
                    GetUnknownErrorString(&pwszErrorString, pviewhelp->dwInheritedError);
                }
                else
                {
                    GetUnknownErrorString(&pwszErrorString, pviewhelp->pPrivate->dwInheritedError);
                }
            }
            pviewhelp->hIcon = LoadIcon(HinstDll, MAKEINTRESOURCE(IDI_REVOKED_SIGN));
            if ((pwszErrorString != NULL) && (wcslen(pwszErrorString)+1 < ARRAYSIZE(szText)))
            {
                wcscpy(szText, pwszErrorString);
            }
            else
            {
                LoadStringU(HinstDll, IDS_UKNOWN_ERROR, (LPWSTR)szText, ARRAYSIZE(szText));
            }
            free(pwszErrorString);
            break;
        }

        CryptUISetRicheditTextW(hwndDlg, IDC_SIGNER_GENERAL_VALIDITY_EDIT, szText);
        LoadStringU(HinstDll, IDS_SIGNER_INFORMATION, (LPWSTR)szText, ARRAYSIZE(szText));

        //
        // set the header text and subclass the edit controls so they display an
        // arrow cursor in their window
        //
        CryptUISetRicheditTextW(hwndDlg, IDC_SIGNER_GENERAL_HEADER_EDIT, szText);
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_VALIDITY_EDIT));
        CertSubclassEditControlForArrowCursor(GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_HEADER_EDIT));

        //
        // disable the "View Certificate" button if the cert was not found
        //
        if (pviewhelp->pSignersCert == NULL)
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_VIEW_CERTIFICATE), FALSE);
        }

        //
        // get the signers name and display it
        //
        if (!((pviewhelp->pSignersCert) && (CertGetNameStringW(
                                                pviewhelp->pSignersCert,
                                                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                                0,//CERT_NAME_ISSUER_FLAG,
                                                NULL,
                                                szText,
                                                ARRAYSIZE(szText)))))
        {
            LoadStringU(HinstDll, IDS_NOTAVAILABLE, szText, ARRAYSIZE(szText));
        }
        CryptUISetRicheditTextW(hwndDlg, IDC_SIGNER_GENERAL_SIGNER_NAME, szText);

        //
        // get the signers email and display it
        //
        if (!((pviewhelp->pSignersCert) && (CertGetNameStringW(
                                                pviewhelp->pSignersCert,
                                                CERT_NAME_EMAIL_TYPE,
                                                0,//CERT_NAME_ISSUER_FLAG,
                                                NULL,
                                                szText,
                                                ARRAYSIZE(szText)) != 1)))
        {
            LoadStringU(HinstDll, IDS_NOTAVAILABLE, szText, ARRAYSIZE(szText));
        }
        CryptUISetRicheditTextW(hwndDlg, IDC_SIGNER_GENERAL_EMAIL, szText);

        //
        // get the signing time and display it
        //
        pszTimeText = AllocAndReturnTimeStampersTimes(
                            pviewhelp->pcvsi->pSignerInfo, 
                            NULL, 
                            GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_SIGNING_TIME));
        if (pszTimeText != NULL)
        {
            CryptUISetRicheditTextW(hwndDlg, IDC_SIGNER_GENERAL_SIGNING_TIME, pszTimeText);
            free(pszTimeText);
        }
        else
        {
            LoadStringU(HinstDll, IDS_NOTAVAILABLE, szText, ARRAYSIZE(szText));
            CryptUISetRicheditTextW(hwndDlg, IDC_SIGNER_GENERAL_SIGNING_TIME, szText);
        }

        //
        // disable the view details button since nothing is currently selected
        //
        EnableWindow(GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_DETAILS), FALSE);

        //
        // create and set the font for the signer info header information
        //
        memset(&chFormat, 0, sizeof(chFormat));
        chFormat.cbSize = sizeof(chFormat);
        chFormat.dwMask = CFM_BOLD;
        chFormat.dwEffects = CFE_BOLD;
        SendMessageA(GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_HEADER_EDIT), EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &chFormat);

        //
        // get the handle of the list view control
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_COUNTER_SIGS);

        //
        // initialize the columns in the list view
        //
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.pszText = szText;   // The text for the column.

        // Add the columns. They are loaded from a string table.
        lvC.iSubItem = 0;
        lvC.cx = 100;
        LoadStringU(HinstDll, IDS_NAME, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(hWndListView, 0, &lvC) == -1)
        {
            // error
        }

        lvC.cx = 100;
        LoadStringU(HinstDll, IDS_EMAIL, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(hWndListView, 1, &lvC) == -1)
        {
            // error
        }

        lvC.cx = 125;
        LoadStringU(HinstDll, IDS_TIMESTAMP_TIME, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(hWndListView, 2, &lvC) == -1)
        {
            // error
        }

        //
        // set the style in the list view so that it highlights an entire line
        //
        SendMessageA(hWndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

        //
        // add all of the counter signers to the list box
        //
        AddCounterSignersToList(GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_COUNTER_SIGS), pviewhelp);

        return TRUE;

    case WM_NOTIFY:

        pviewhelp = (SIGNER_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pSignerInfo = pviewhelp->pcvsi->pSignerInfo;

        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_QUERYCANCEL:
            pviewhelp->fCancelled = TRUE;
            return FALSE;

        case PSN_HELP:
            pviewhelp = (SIGNER_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvsi->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvsi->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvsi->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvsi->dwHelpId);
            }
            return TRUE;

        case NM_DBLCLK:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_SIGNER_GENERAL_COUNTER_SIGS:

                if (IsWindowEnabled(GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_DETAILS)))
                {
                    SendMessage(
                            hwndDlg,
                            WM_COMMAND,
                            MAKELONG(IDC_SIGNER_GENERAL_DETAILS, BN_CLICKED),
                            (LPARAM) GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_DETAILS));
                }
                break;
            }

            break;
        case LVN_ITEMCHANGED:

            if ((((NMHDR FAR *) lParam)->idFrom) != IDC_SIGNER_GENERAL_COUNTER_SIGS)
            {
                break;
            }

            //
            // if an item is selected, then enable the details button, otherwise
            // disable it
            //
            EnableWindow(
                GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_DETAILS), 
                (ListView_GetSelectedCount(
                    GetDlgItem(hwndDlg,IDC_SIGNER_GENERAL_COUNTER_SIGS)) == 0) ? FALSE : TRUE);

            break;

        case NM_CLICK:

            if ((((NMHDR FAR *) lParam)->idFrom) != IDC_SIGNER_GENERAL_COUNTER_SIGS)
            {
                break;
            }

            hWndListView = GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_COUNTER_SIGS);

            //
            // make sure something is selected by getting the current selection
            //
            listIndex = ListView_GetNextItem(
                                hWndListView, 		
                                -1, 		
                                LVNI_SELECTED		
                                );	           
            break;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_SIGNER_GENERAL_COUNTER_SIGS:
                hWndListView = GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_COUNTER_SIGS);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED;
                    lvI.stateMask = LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;
            }
            
            break;

        }
        break;

    case WM_COMMAND:
        pviewhelp = (SIGNER_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pSignerInfo = pviewhelp->pcvsi->pSignerInfo;

        switch (LOWORD(wParam))
        {
        case IDC_SIGNER_GENERAL_VIEW_CERTIFICATE:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                CRYPTUI_VIEWCERTIFICATE_STRUCTW cvps;

                memset(&cvps,0, sizeof(cvps));
                cvps.dwSize = sizeof(cvps);
                cvps.pCryptProviderData = NULL;
                cvps.hwndParent = hwndDlg;
                cvps.pCertContext = pviewhelp->pSignersCert;
                cvps.cPurposes = 1;
                cvps.rgszPurposes = (LPCSTR *) &(pviewhelp->pcvsi->pszOID);
                cvps.cStores = pviewhelp->pcvsi->cStores;
                cvps.rghStores = pviewhelp->pcvsi->rghStores;

                if (pviewhelp->pPrivate != NULL)
                {
                    cvps.pCryptProviderData = pviewhelp->pPrivate->pCryptProviderData;
                    cvps.fpCryptProviderDataTrustedUsage =
                            pviewhelp->pPrivate->fpCryptProviderDataTrustedUsage;
                    cvps.idxSigner = pviewhelp->pPrivate->idxSigner;
                    cvps.fCounterSigner = pviewhelp->pPrivate->fCounterSigner;
                    cvps.idxCounterSigner = pviewhelp->pPrivate->idxCounterSigner;
                }

                CryptUIDlgViewCertificateW(&cvps, NULL);
            }
            break;

        case IDC_SIGNER_GENERAL_DETAILS:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                hWndListView = GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_COUNTER_SIGS);

                //
                // get the selected item and its lParam which is a signer info
                //
                listIndex = ListView_GetNextItem(
                                hWndListView, 		
                                -1, 		
                                LVNI_SELECTED		
                                );	

                memset(&lvI, 0, sizeof(lvI));
                lvI.iItem = listIndex;
                lvI.mask = LVIF_PARAM;
                if (!ListView_GetItemU(hWndListView, &lvI))
                {
                    return FALSE;
                }

                CRYPTUI_VIEWSIGNERINFO_STRUCTW  cvsi;
                CERT_VIEWSIGNERINFO_PRIVATE     cvsiPrivate;

                memcpy(&cvsi, pviewhelp->pcvsi, sizeof(cvsi));
                cvsi.pSignerInfo = (PCMSG_SIGNER_INFO) lvI.lParam;
                cvsi.pszOID = szOID_KP_TIME_STAMP_SIGNING;
                cvsi.hwndParent = hwndDlg;

                if (pviewhelp->pPrivate != NULL)
                {
                    cvsiPrivate.pCryptProviderData = pviewhelp->pPrivate->pCryptProviderData;
                    cvsiPrivate.fpCryptProviderDataTrustedUsage =
                            pviewhelp->pPrivate->fpCryptProviderDataTrustedUsage;
                    cvsiPrivate.idxSigner = pviewhelp->pPrivate->idxSigner;
                    cvsiPrivate.fCounterSigner = TRUE;
                    cvsiPrivate.idxCounterSigner = listIndex;
                    cvsi.dwFlags |= CRYPTUI_VIEWSIGNERINFO_RESERVED_FIELD_IS_SIGNERINFO_PRIVATE;
                    cvsi.dwFlags &= ~CRYPTUI_VIEWSIGNERINFO_RESERVED_FIELD_IS_ERROR_CODE;
                    cvsi.dwReserved = (DWORD_PTR) &cvsiPrivate;

                    //
                    // it is possible that there is no error when validating the original
                    // signer info and that an error was inherited, so to allow the counter
                    // signer dialog to again inherit the error it must be filled in in the
                    // private struct
                    //
                    if (pviewhelp->pcvsi->dwFlags & CRYPTUI_VIEWSIGNERINFO_RESERVED_FIELD_IS_ERROR_CODE)
                    {
                        cvsiPrivate.dwInheritedError = (DWORD) pviewhelp->pcvsi->dwReserved;                 
                    }
                    else
                    {
                        cvsiPrivate.dwInheritedError = 0;
                    }
                }
                else if (pviewhelp->pcvsi->dwFlags & CRYPTUI_VIEWSIGNERINFO_RESERVED_FIELD_IS_ERROR_CODE)
                {
                    cvsi.dwFlags |= CRYPTUI_VIEWSIGNERINFO_RESERVED_FIELD_IS_ERROR_CODE;
                    cvsi.dwFlags &= ~CRYPTUI_VIEWSIGNERINFO_RESERVED_FIELD_IS_SIGNERINFO_PRIVATE;
                    cvsi.dwReserved = pviewhelp->pcvsi->dwReserved;   
                }

                CryptUIDlgViewSignerInfoW(&cvsi);
            }
            break;

        case IDHELP:
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvsi->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvsi->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvsi->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvsi->dwHelpId);
            }
            return TRUE;
        }
        break;

    case WM_PAINT:
        RECT        rect;
        PAINTSTRUCT paintstruct;
        HDC         hdc;
        COLORREF    colorRef;

        pviewhelp = (SIGNER_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        if (GetUpdateRect(hwndDlg, &rect, FALSE))
        {
            hdc = BeginPaint(hwndDlg, &paintstruct);
            if (hdc == NULL)
            {
                EndPaint(hwndDlg, &paintstruct);
                break;
            }

            colorRef = GetBkColor(hdc);

            SendMessageA(GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_VALIDITY_EDIT), EM_SETBKGNDCOLOR , 0, (LPARAM) colorRef);
            SendMessageA(GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_HEADER_EDIT), EM_SETBKGNDCOLOR, 0, (LPARAM) colorRef);

            if (pviewhelp->hIcon != NULL)
            {
                DrawIcon(
                    hdc,
                    ICON_X_POS,
                    ICON_Y_POS,
                    pviewhelp->hIcon);
            }

            EndPaint(hwndDlg, &paintstruct);
        }
        break;

    case WM_DESTROY:
        pviewhelp = (SIGNER_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        if (pviewhelp->pSignersCert)
        {
            CertFreeCertificateContext(pviewhelp->pSignersCert);
            pviewhelp->pSignersCert = NULL;
        }

        if (pviewhelp->hIcon != NULL)
        {
            DeleteObject(pviewhelp->hIcon);
            pviewhelp->hIcon = NULL;
        }

        if (pviewhelp->fPrivateAllocated)
        {
            FreeWinVTrustState(
                    NULL,
                    pviewhelp->pcvsi->pSignerInfo,
                    0,
                    NULL,
                    pviewhelp->pcvsi->pszOID,
                    &(pviewhelp->CryptProviderDefUsage),
                    &(pviewhelp->WTD));//,
                    //&(pviewhelp->fUseDefaultProvider));

            free(pviewhelp->pPrivate);
        }

        //
        // get all the items in the list view and free the lParam
        // associated with each of them (lParam is the helper sruct)
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_COUNTER_SIGS);

        memset(&lvI, 0, sizeof(lvI));
        lvI.iItem = ListView_GetItemCount(hWndListView) - 1;
        lvI.mask = LVIF_PARAM;
        while (lvI.iItem >= 0)
        {
            if (ListView_GetItemU(hWndListView, &lvI))
            {
                if (((void *) lvI.lParam) != NULL)
                {
                    free((void *) lvI.lParam);
                }
            }
            lvI.iItem--;
        }

        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_SIGNER_NAME))       &&
            (hwnd != GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_EMAIL))             &&
            (hwnd != GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_SIGNING_TIME))      &&
            (hwnd != GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_VIEW_CERTIFICATE))  &&
            (hwnd != GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_COUNTER_SIGS))      &&
            (hwnd != GetDlgItem(hwndDlg, IDC_SIGNER_GENERAL_DETAILS)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\trust.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       trust.cpp
//
//--------------------------------------------------------------------------

#include        "global.hxx"
#include        <dbgdef.h>

BOOL CertConfigureTrustA(void)
{
    return FALSE;
}

BOOL CertConfigureTrustW(void)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\signadv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       signadv.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_SIGNER_ADVANCED_DETAILS,   IDH_SIGNERINFO_ADVANCED_DETAIL_LIST},
    {IDC_SIGNER_ADVANCED_VALUE,     IDH_SIGNERINFO_ADVANCED_DETAIL_EDIT}
};


#define INDENT_STRING       L"     "
#define TERMINATING_CHAR    L""

static void AddSignerInfoToList(HWND hWndListView, SIGNER_VIEW_HELPER *pviewhelp)
{
    CMSG_SIGNER_INFO const *pSignerInfo;
    PCMSG_SIGNER_INFO       pCounterSignerInfo;
    DWORD                   cbCounterSignerInfo;
    PCCERT_CONTEXT          pCertContext = NULL;
    DWORD                   i;
    WCHAR                   szFieldText[_MAX_PATH];  // used for calls to LoadString only
    LV_ITEMW                lvI;
    int                     itemIndex = 0;
    LPWSTR                  pwszText;
    DWORD                   cbFormatedAttribute;
    BYTE                   *pbFormatedAttribute;
    char                    szVersion[32];

    pSignerInfo = pviewhelp->pcvsi->pSignerInfo;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    memset(&lvI, 0, sizeof(lvI));
    lvI.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.iSubItem = 0;
    lvI.pszText = szFieldText;

    //
    // version
    //
    LoadStringU(HinstDll, IDS_ADV_VERSION, szFieldText, ARRAYSIZE(szFieldText));
    wsprintfA(szVersion, "V%d", pSignerInfo->dwVersion+1);
    if (NULL != (pwszText = CertUIMkWStr(szVersion)))
    {
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        lvI.iItem = itemIndex++;
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, itemIndex-1 , 1, pwszText);
    }

    //
    // issuer
    //
    LoadStringU(HinstDll, IDS_ADV_ISSUER, szFieldText, ARRAYSIZE(szFieldText));
    lvI.cchTextMax = wcslen(szFieldText);

    if (FormatDNNameString(&pwszText, pSignerInfo->Issuer.pbData, pSignerInfo->Issuer.cbData, TRUE))
    {
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        lvI.iItem = itemIndex++;
        ListView_InsertItemU(hWndListView, &lvI);
        if (FormatDNNameString(&pwszText, pSignerInfo->Issuer.pbData, pSignerInfo->Issuer.cbData, FALSE))
        {
            ListView_SetItemTextU(hWndListView, itemIndex-1 , 1, pwszText);
            free(pwszText);
        }
    }

    //
    // serial number
    //
    if (FormatSerialNoString(&pwszText, &(pSignerInfo->SerialNumber)))
    {
        LoadStringU(HinstDll, IDS_ADV_SER_NUM, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(TRUE, pwszText, NULL, 0);
        lvI.iItem = itemIndex++;
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, itemIndex-1 , 1, pwszText);
    }

    //
    // hash algorithm
    //
    if (FormatAlgorithmString(&pwszText, &(pSignerInfo->HashAlgorithm)))
    {
        LoadStringU(HinstDll, IDS_DIGEST_ALGORITHM, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        lvI.iItem = itemIndex++;
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, itemIndex-1 , 1, pwszText);
    }

    //
    // hash encryption algorithm
    //
    if (FormatAlgorithmString(&pwszText, &(pSignerInfo->HashEncryptionAlgorithm)))
    {
        LoadStringU(HinstDll, IDS_DIGEST_ENCRYPTION_ALGORITHM, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) MakeListDisplayHelper(FALSE, pwszText, NULL, 0);
        lvI.iItem = itemIndex++;
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, itemIndex-1 , 1, pwszText);
    }

    //
    // Authenticated Attributes
    //
    if (pSignerInfo->AuthAttrs.cAttr > 0)
    {
        //
        // display the header
        //
        LoadStringU(HinstDll, IDS_AUTHENTICATED_ATTRIBUTES, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) NULL;
        lvI.iItem = itemIndex++;
        lvI.iIndent = 0;
        ListView_InsertItemU(hWndListView, &lvI);

        lvI.iIndent = 2;

        //
        // display each unauthenticated attribute
        //
        for (i=0; i<pSignerInfo->AuthAttrs.cAttr; i++)
        {
            //
            // get the field column string
            //
            wcscpy(szFieldText, INDENT_STRING);
            if (!MyGetOIDInfo(
                        &szFieldText[0] + ((sizeof(INDENT_STRING) - sizeof(TERMINATING_CHAR)) / sizeof(WCHAR)),
                        ARRAYSIZE(szFieldText) - ((sizeof(INDENT_STRING) - sizeof(TERMINATING_CHAR)) / sizeof(WCHAR)),
                        pSignerInfo->AuthAttrs.rgAttr[i].pszObjId))
            {
                return;
            }

            //
            // get the value column string
            //
            cbFormatedAttribute = 0;
            pbFormatedAttribute = NULL;
            CryptFormatObject(
                        X509_ASN_ENCODING,
                        0,
	                    0,
	                    NULL,
                        pSignerInfo->AuthAttrs.rgAttr[i].pszObjId,
                        pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
                        pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData,
	                    NULL,
                        &cbFormatedAttribute
                        );

            if (NULL == (pbFormatedAttribute = (BYTE *) malloc(cbFormatedAttribute)))
            {
                return;
            }

            if (CryptFormatObject(
                        X509_ASN_ENCODING,
                        0,
	                    0,
	                    NULL,
                        pSignerInfo->AuthAttrs.rgAttr[i].pszObjId,
                        pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
                        pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData,
	                    pbFormatedAttribute,
                        &cbFormatedAttribute
                        ))
            {
                lvI.iItem = itemIndex++;
                lvI.cchTextMax = wcslen(szFieldText);
                lvI.lParam = (LPARAM)  MakeListDisplayHelperForExtension(
                                                        pSignerInfo->AuthAttrs.rgAttr[i].pszObjId,
                                                        pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
                                                        pSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData);
                ListView_InsertItemU(hWndListView, &lvI);
                ListView_SetItemTextU(
                        hWndListView,
                        itemIndex-1,
                        1,
                        (LPWSTR)pbFormatedAttribute);
            }

            free (pbFormatedAttribute);
        }
    }

    //
    // Unauthenticated Attributes
    //
    if (pSignerInfo->UnauthAttrs.cAttr > 0)
    {
        //
        // display the header
        //
        LoadStringU(HinstDll, IDS_UNAUTHENTICATED_ATTRIBUTES, szFieldText, ARRAYSIZE(szFieldText));
        lvI.cchTextMax = wcslen(szFieldText);
        lvI.lParam = (LPARAM) NULL;
        lvI.iItem = itemIndex++;
        lvI.iIndent = 0;
        ListView_InsertItemU(hWndListView, &lvI);

        lvI.iIndent = 2;

        //
        // display each unauthenticated attribute
        //
        for (i=0; i<pSignerInfo->UnauthAttrs.cAttr; i++)
        {
            //
            // get the field column string
            //
            wcscpy(szFieldText, INDENT_STRING);
            if (!MyGetOIDInfo(
                        &szFieldText[0] + ((sizeof(INDENT_STRING) - sizeof(TERMINATING_CHAR)) / sizeof(WCHAR)),
                        ARRAYSIZE(szFieldText) - ((sizeof(INDENT_STRING) - sizeof(TERMINATING_CHAR)) / sizeof(WCHAR)),
                        pSignerInfo->UnauthAttrs.rgAttr[i].pszObjId))
            {
                return;
            }

            //
            // get the value column string
            //
            cbFormatedAttribute = 0;
            pbFormatedAttribute = NULL;
            CryptFormatObject(
                        X509_ASN_ENCODING,
                        0,
	                    0,
	                    NULL,
                        pSignerInfo->UnauthAttrs.rgAttr[i].pszObjId,
                        pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].pbData,
                        pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].cbData,
	                    NULL,
                        &cbFormatedAttribute
                        );

            if (NULL == (pbFormatedAttribute = (BYTE *) malloc(cbFormatedAttribute)))
            {
                return;
            }

            if (CryptFormatObject(
                        X509_ASN_ENCODING,
                        0,
	                    0,
	                    NULL,
                        pSignerInfo->UnauthAttrs.rgAttr[i].pszObjId,
                        pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].pbData,
                        pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].cbData,
	                    pbFormatedAttribute,
                        &cbFormatedAttribute
                        ))
            {
                lvI.iItem = itemIndex++;
                lvI.cchTextMax = wcslen(szFieldText);
                lvI.lParam = (LPARAM) MakeListDisplayHelperForExtension(
                                                        pSignerInfo->UnauthAttrs.rgAttr[i].pszObjId,
                                                        pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].pbData,
                                                        pSignerInfo->UnauthAttrs.rgAttr[i].rgValue[0].cbData);
                ListView_InsertItemU(hWndListView, &lvI);
                ListView_SetItemTextU(
                        hWndListView,
                        itemIndex-1,
                        1,
                        (LPWSTR)pbFormatedAttribute);
            }

            free (pbFormatedAttribute);
        }
    }
}


INT_PTR APIENTRY ViewPageSignerAdvanced(HWND hwndDlg, UINT msg, WPARAM wParam,
                                LPARAM lParam)
{
    DWORD                   i;
    PROPSHEETPAGE          *ps;
    SIGNER_VIEW_HELPER     *pviewhelp;
    HWND                    hWndListView;
    LV_COLUMNW              lvC;
    WCHAR                   szText[CRYPTUI_MAX_STRING_SIZE];
    CMSG_SIGNER_INFO const *pSignerInfo;
    LVITEMW                 lvI;
    LPNMLISTVIEW            pnmv;
    WCHAR                   szCompareText[CRYPTUI_MAX_STRING_SIZE];
    HWND                    hwnd;
    BOOL                    fCallSetWindowLong;

    switch ( msg ) {
    case WM_INITDIALOG:
        //
        // save the pviewhelp struct in DWLP_USER so it can always be accessed
        //
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (SIGNER_VIEW_HELPER *) (ps->lParam);
        pSignerInfo = pviewhelp->pcvsi->pSignerInfo;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);

        pviewhelp->previousSelection = -1;
        pviewhelp->currentSelection = -1;

        //
        // clear the text in the detail edit box
        //
        CryptUISetRicheditTextW(hwndDlg, IDC_SIGNER_ADVANCED_VALUE, L"");

        //
        // get the handle of the list view control
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS);

        //
        // initialize the columns in the list view
        //
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.pszText = szText;   // The text for the column.

        // Add the columns. They are loaded from a string table.
        lvC.iSubItem = 0;
        lvC.cx = 140;
        LoadStringU(HinstDll, IDS_FIELD, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(hWndListView, 0, &lvC) == -1)
        {
            // error
        }

        lvC.cx = 218;
        LoadStringU(HinstDll, IDS_VALUE, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(hWndListView, 1, &lvC) == -1)
        {
            // error
        }

        //
        // set the style in the list view so that it highlights an entire line
        //
        SendMessageA(hWndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

        //
        // add all of the signer information to the list box
        //
        AddSignerInfoToList(hWndListView, pviewhelp);

        return TRUE;

    case WM_NOTIFY:

        pviewhelp = (SIGNER_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pSignerInfo = pviewhelp->pcvsi->pSignerInfo;

        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_HELP:
            pviewhelp = (SIGNER_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvsi->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvsi->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvsi->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvsi->dwHelpId);
            }
            return TRUE;

        case LVN_ITEMCHANGING:

            pnmv = (LPNMLISTVIEW) lParam;
            fCallSetWindowLong = FALSE;

            hWndListView = GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS);

            //
            // if this item is being de-selected, then save it's index incase we need to
            // re-select it
            if ((pnmv->uOldState & LVIS_SELECTED) || (pnmv->uOldState & LVIS_FOCUSED))
            {
                pviewhelp->previousSelection = pnmv->iItem;
            }

            //
            // if the new item selected is the "Authenticated Attributes" header, or
            // the "Unauthenticated Attributes" header then don't allow it to be
            // selected
            //
            if ((pnmv->uNewState & LVIS_SELECTED) || (pnmv->uNewState & LVIS_FOCUSED))
            {
                memset(&lvI, 0, sizeof(lvI));
                lvI.iItem = pnmv->iItem;
                lvI.mask = LVIF_TEXT;
                lvI.pszText = szText;
                lvI.cchTextMax = ARRAYSIZE(szText);
                if (!ListView_GetItemU(hWndListView, &lvI))
                {
                    return FALSE;
                }

                LoadStringU(HinstDll, IDS_AUTHENTICATED_ATTRIBUTES, szCompareText, ARRAYSIZE(szCompareText));
                if (wcscmp(szCompareText, szText) == 0)
                {
                    if (pnmv->iItem == pviewhelp->previousSelection-1)
                    {
                        pviewhelp->currentSelection = pviewhelp->previousSelection-2;
                    }
                    else if (pnmv->iItem == pviewhelp->previousSelection+1)
                    {
                        pviewhelp->currentSelection = pviewhelp->previousSelection+2;
                    }
                    else
                    {
                        pviewhelp->currentSelection = pviewhelp->previousSelection;
                    }

                    ListView_SetItemState(
                            GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS),
                            pviewhelp->currentSelection,
                            LVIS_SELECTED | LVIS_FOCUSED,
                            LVIS_SELECTED | LVIS_FOCUSED);

                    fCallSetWindowLong = TRUE;
                }
                else
                {
                    LoadStringU(HinstDll, IDS_UNAUTHENTICATED_ATTRIBUTES, szCompareText, ARRAYSIZE(szCompareText));
                    if (wcscmp(szCompareText, szText) == 0)
                    {
                        if (pnmv->iItem == pviewhelp->previousSelection-1)
                        {
                            pviewhelp->currentSelection = pviewhelp->previousSelection-2;
                        }
                        else if (pnmv->iItem == pviewhelp->previousSelection+1)
                        {
                            pviewhelp->currentSelection = pviewhelp->previousSelection+2;
                        }
                        else
                        {
                            pviewhelp->currentSelection = pviewhelp->previousSelection;
                        }

                        ListView_SetItemState(
                            GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS),
                            pviewhelp->currentSelection,
                            LVIS_SELECTED | LVIS_FOCUSED,
                            LVIS_SELECTED | LVIS_FOCUSED);

                        fCallSetWindowLong = TRUE;
                    }
                    else
                    {
                        pviewhelp->currentSelection = pnmv->iItem;
                    }
                }

                DisplayHelperTextInEdit(
                    GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS),
                    hwndDlg,
                    IDC_SIGNER_ADVANCED_VALUE,
                    pviewhelp->currentSelection);

                if (fCallSetWindowLong)
                {
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
                }
            }

            return TRUE;

        case NM_CLICK:
            if ((((NMHDR FAR *) lParam)->idFrom) != IDC_SIGNER_ADVANCED_DETAILS)
            {
                break;
            }

            ListView_SetItemState(
                            GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS),
                            pviewhelp->currentSelection,
                            LVIS_SELECTED | LVIS_FOCUSED,
                            LVIS_SELECTED | LVIS_FOCUSED);

            DisplayHelperTextInEdit(
                    GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS),
                    hwndDlg,
                    IDC_SIGNER_ADVANCED_VALUE,
                    -1);
            break;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_SIGNER_ADVANCED_DETAILS:
                hWndListView = GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED;
                    lvI.stateMask = LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;
            }
            
            break;

        }
        break;

    case WM_COMMAND:
        pviewhelp = (SIGNER_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pSignerInfo = pviewhelp->pcvsi->pSignerInfo;

        switch (LOWORD(wParam))
        {
        case IDHELP:
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pviewhelp->pcvsi->szHelpFileName,
                  //       HELP_CONTEXT, pviewhelp->pcvsi->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pviewhelp->pcvsi->szHelpFileName, HELP_CONTEXT,
                  //       pviewhelp->pcvsi->dwHelpId);
            }
            return TRUE;
        }
        break;

    case WM_DESTROY:
        pviewhelp = (SIGNER_VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

        //
        // get all the items in the list view and free the lParam
        // associated with each of them (lParam is the helper sruct)
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS);

        memset(&lvI, 0, sizeof(lvI));
        lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
        lvI.mask = LVIF_PARAM;
        while (lvI.iItem >= 0)
        {
            if (ListView_GetItemU(hWndListView, &lvI))
            {
                FreeListDisplayHelper((PLIST_DISPLAY_HELPER) lvI.lParam);
            }
            lvI.iItem--;
        }


        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_DETAILS)) &&
            (hwnd != GetDlgItem(hwndDlg, IDC_SIGNER_ADVANCED_VALUE)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\usagutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       usagutil.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;

//BOOL CertifiateValidForEnhancedKeyUsage(LPCSTR szEku, PCCERT_CONTEXT pCert);
//BOOL CertifiateValidForEnhancedKeyUsageWithChain(LPCSTR szEku, PCCERT_CONTEXT pCert); 


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL OIDinArray(LPCSTR pszOID, LPSTR *rgszOIDArray, DWORD cOIDs)
{
    DWORD i;

    for (i=0; i<cOIDs; i++)
    {
        if (strcmp(pszOID, rgszOIDArray[i]) == 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL OIDInUsages(PCERT_ENHKEY_USAGE pUsage, LPCSTR pszOID)
{
    DWORD i; 

    // check every extension
    for(i=0; i<pUsage->cUsageIdentifier; i++) 
    {
        if(!strcmp(pUsage->rgpszUsageIdentifier[i], pszOID))
            break;
    }
    
    return (i < pUsage->cUsageIdentifier);
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
static BOOL UsageExists(PCCRYPT_OID_INFO *pCryptOIDInfo, LPSTR pszOID)
{
    int i = 0;
    
    while (pCryptOIDInfo[i] != NULL)
    {
        if (strcmp(pCryptOIDInfo[i]->pszOID, pszOID) == 0)
        {
            return TRUE;
        }
        i++;
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
static BOOL WINAPI AddNewOIDToArray(IN LPTSTR pNewOID, IN LPTSTR ** pppOIDs, IN DWORD * pdwOIDs)
{
    LPTSTR * ppNewOIDs;
    DWORD    cNumOIDs = *pdwOIDs;

    for (DWORD i = 0; i < cNumOIDs; i++)
    {
        if (0 == strcmp(pNewOID, (*pppOIDs)[i]))
        {
            return TRUE;
        }
    }

    if (0 == cNumOIDs)
        ppNewOIDs = (LPTSTR *) malloc(sizeof(LPSTR));
    else
        ppNewOIDs = (LPTSTR *) realloc(*pppOIDs, (cNumOIDs + 1) * sizeof(LPSTR));
  
    if (ppNewOIDs)
    {
        if (NULL == (ppNewOIDs[cNumOIDs] = (LPSTR) malloc(strlen(pNewOID) + 1)))
        {
            free(ppNewOIDs);
            return FALSE;
        }
        strcpy(ppNewOIDs[cNumOIDs], pNewOID);
        
        *pppOIDs = ppNewOIDs;
        *pdwOIDs = cNumOIDs + 1;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL AllocAndReturnKeyUsageList(PCRYPT_PROVIDER_CERT pCryptProviderCert, LPSTR **pKeyUsageOIDs, DWORD *numOIDs)
{
    BOOL  fRet = TRUE;
    DWORD i, j = 0;
    PCERT_CHAIN_ELEMENT pChainElement = pCryptProviderCert->pChainElement;
    
    *numOIDs = 0;
    *pKeyUsageOIDs = NULL;

    if (!pChainElement)
    {
        goto ErrorCleanUp;
    }

    //
    // For NULL usages, use
    //
    //  szOID_ANY_CERT_POLICY        = good for all issuance usages (maps to "All issuance purposes")
    //  szOID_ANY_APPLICATION_POLICY = good for all application usages (maps to "All application purposes")
    //
    if (!pChainElement->pIssuanceUsage)
    {
        //
        // Good for all issuance usages.
        //
        if (!AddNewOIDToArray(szOID_ANY_CERT_POLICY, pKeyUsageOIDs, numOIDs))
        {
            goto ErrorCleanUp;
        }
    }
    else
    {
        for (i = 0; i < pChainElement->pIssuanceUsage->cUsageIdentifier; i++)
        {
            if (!AddNewOIDToArray(pChainElement->pIssuanceUsage->rgpszUsageIdentifier[i], pKeyUsageOIDs, numOIDs))
            {
                goto ErrorCleanUp;
            }
        }
    }

    if (!pChainElement->pApplicationUsage)
    {
        //
        // Good for all application usages.
        //
        if (!AddNewOIDToArray(szOID_ANY_APPLICATION_POLICY, pKeyUsageOIDs, numOIDs))
        {
            goto ErrorCleanUp;
        }
    }
    else
    {
        for (i = 0; i < pChainElement->pApplicationUsage->cUsageIdentifier; i++)
        {
            if (!AddNewOIDToArray(pChainElement->pApplicationUsage->rgpszUsageIdentifier[i], pKeyUsageOIDs, numOIDs))
            {
                goto ErrorCleanUp;
            }
        }
    }
   
CleanUp:
    
    return(fRet);
 
ErrorCleanUp:

    if (*pKeyUsageOIDs != NULL)
    {
        for (i = 0; i < *numOIDs; i++)
        {
            if ((*pKeyUsageOIDs)[i])
                free((*pKeyUsageOIDs)[i]); 
        }

        *numOIDs = 0;

        free(*pKeyUsageOIDs);
        *pKeyUsageOIDs = NULL;
    }
    fRet = FALSE;
    goto CleanUp;
}

//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL AllocAndReturnEKUList(PCCERT_CONTEXT pCert, LPSTR **pKeyUsageOIDs, DWORD *numOIDs)
{
    BOOL                fRet               = TRUE;
    DWORD               cbExtensionUsage   = 0;
    PCERT_ENHKEY_USAGE  pExtensionUsage    = NULL;
    DWORD               cbPropertyUsage    = 0;
    PCERT_ENHKEY_USAGE  pPropertyUsage     = NULL;
    DWORD               i;
    DWORD               numPropUsages = 0;
    
    //
    // get all of the usages from extensions
    //
    if(!CertGetEnhancedKeyUsage (
                pCert,
                CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                NULL,
                &cbExtensionUsage
                )                                                                   ||
        (pExtensionUsage = (PCERT_ENHKEY_USAGE) malloc(cbExtensionUsage)) == NULL   ||
        !CertGetEnhancedKeyUsage (
                pCert,
                CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                pExtensionUsage,
                &cbExtensionUsage
                ) ) {

        // if not found, then we mean everything is OK                
        if( GetLastError() == CRYPT_E_NOT_FOUND) {
            if(pExtensionUsage != NULL)
                free(pExtensionUsage);
            pExtensionUsage = NULL;
        }
        else
            goto ErrorCleanUp;
    }

    //
    // get all of the usages from properties
    //
    if(!CertGetEnhancedKeyUsage (
                pCert,
                CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
                NULL,
                &cbPropertyUsage
                )                                                                   ||
        (pPropertyUsage = (PCERT_ENHKEY_USAGE) malloc(cbPropertyUsage)) == NULL   ||
        !CertGetEnhancedKeyUsage (
                pCert,
                CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
                pPropertyUsage,
                &cbPropertyUsage
                ) ) {

        // if not found, then we mean everything is OK                
        if( GetLastError() == CRYPT_E_NOT_FOUND) {
            if(pPropertyUsage != NULL)
                free(pPropertyUsage);
            pPropertyUsage = NULL;
        }
        else
            goto ErrorCleanUp;
    }

    *numOIDs = 0;
    
    //
    // if there are usages in the extensions, then that is the
    // available list, otherwise get the global list and add the properties
    //
    if (pExtensionUsage != NULL)
    {
        *pKeyUsageOIDs = (LPSTR *) malloc(pExtensionUsage->cUsageIdentifier * sizeof(LPSTR));
        if (*pKeyUsageOIDs == NULL)
        {
            goto ErrorCleanUp;
        }

        for(i=0; i<pExtensionUsage->cUsageIdentifier; i++) 
        {
            (*pKeyUsageOIDs)[*numOIDs] = 
                    (LPSTR) malloc(strlen(pExtensionUsage->rgpszUsageIdentifier[i])+1);
            if ((*pKeyUsageOIDs)[*numOIDs] == NULL)
            {
                goto ErrorCleanUp;
            }
            strcpy((*pKeyUsageOIDs)[(*numOIDs)++], pExtensionUsage->rgpszUsageIdentifier[i]);
        }
    }
    else
    {
        PCCRYPT_OID_INFO *pCryptOIDInfo;
        DWORD numUsages = 0;

        //
        // use WTHelperGetKnownUsages to get the default list 
        //
        if (!WTHelperGetKnownUsages(WTH_ALLOC, &pCryptOIDInfo))
        {
            goto ErrorCleanUp;
        }
    
        //
        // count the number of oids
        //
        i = 0;
        while (pCryptOIDInfo[i] != NULL)
        {
            numUsages++;
            i++;
        }

        //
        // if there are properties, then count how many there are that
        // are not already in the global list
        //
        if (pPropertyUsage)
        {
            for(i=0; i<pPropertyUsage->cUsageIdentifier; i++) 
            {
                if (!UsageExists(pCryptOIDInfo, pPropertyUsage->rgpszUsageIdentifier[i]))
                {
                    numPropUsages++;
                }
            }
        }

        *pKeyUsageOIDs = (LPSTR *) malloc((numUsages + numPropUsages) * sizeof(LPSTR));
        if (*pKeyUsageOIDs == NULL)
        {
            goto ErrorCleanUp;
        }

        i = 0;
        while (pCryptOIDInfo[i] != NULL)
        {
            (*pKeyUsageOIDs)[*numOIDs] = 
                    (LPSTR) malloc(strlen(pCryptOIDInfo[i]->pszOID)+1);
            if ((*pKeyUsageOIDs)[*numOIDs] == NULL)
            {
                WTHelperGetKnownUsages(WTH_FREE, &pCryptOIDInfo);
                goto ErrorCleanUp;
            }
            strcpy((*pKeyUsageOIDs)[(*numOIDs)++], pCryptOIDInfo[i]->pszOID);
            i++;
        }
        
        //
        // add the property usages
        //
        if (pPropertyUsage)
        {
            for(i=0; i<pPropertyUsage->cUsageIdentifier; i++) 
            {
                if (!UsageExists(pCryptOIDInfo, pPropertyUsage->rgpszUsageIdentifier[i]))
                {
                    (*pKeyUsageOIDs)[*numOIDs] = 
                            (LPSTR) malloc(strlen(pPropertyUsage->rgpszUsageIdentifier[i])+1);
                    if ((*pKeyUsageOIDs)[*numOIDs] == NULL)
                    {
                        WTHelperGetKnownUsages(WTH_FREE, &pCryptOIDInfo);
                        goto ErrorCleanUp;
                    }
                    strcpy((*pKeyUsageOIDs)[(*numOIDs)++], pPropertyUsage->rgpszUsageIdentifier[i]);
                }
            }   
        }

        WTHelperGetKnownUsages(WTH_FREE, &pCryptOIDInfo);
    }
   
CleanUp:

    if(pExtensionUsage != NULL)
        free(pExtensionUsage);

    if(pPropertyUsage != NULL)
        free(pPropertyUsage);

    if ((*numOIDs == 0) && (*pKeyUsageOIDs != NULL))
    {
        free(*pKeyUsageOIDs);
    }

    return(fRet);
 
ErrorCleanUp:

    if (*pKeyUsageOIDs != NULL)
    {
        for(i=0; i<*numOIDs; i++) 
        {
            free(*pKeyUsageOIDs[i]);  
        }
        *numOIDs = 0;
    }
    fRet = FALSE;
    goto CleanUp;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
void FreeEKUList(LPSTR *pKeyUsageOIDs, DWORD numOIDs)
{
    DWORD i;

    if (*pKeyUsageOIDs != NULL)
    {
        for(i=0; i<numOIDs; i++) 
        {
            free(pKeyUsageOIDs[i]);  
        }
        free(pKeyUsageOIDs);
    }
}



//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL MyGetOIDInfo(LPWSTR string, DWORD stringSize, LPSTR pszObjId)
{   
    PCCRYPT_OID_INFO pOIDInfo;
            
    pOIDInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_OID_KEY, 
                pszObjId, 
                0);

    if (pOIDInfo != NULL)
    {
        if ((DWORD)wcslen(pOIDInfo->pwszName)+1 <= stringSize)
        {
            wcscpy(string, pOIDInfo->pwszName);
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return (MultiByteToWideChar(CP_ACP, 0, pszObjId, -1, string, stringSize) != 0);
    }
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL fPropertiesDisabled(PCERT_ENHKEY_USAGE pPropertyUsage)
{
    if (pPropertyUsage == NULL)
    {
        return FALSE;
    }
    else if (pPropertyUsage->cUsageIdentifier == 0)
    {
        return TRUE;
    }
    else
    {
        return ((pPropertyUsage->cUsageIdentifier == 1) && 
                (strcmp(szOID_YESNO_TRUST_ATTR, pPropertyUsage->rgpszUsageIdentifier[0]) == 0));
    }
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL CertHasEmptyEKUProp(PCCERT_CONTEXT pCertContext)
{
    DWORD               cbPropertyUsage = 0;
    PCERT_ENHKEY_USAGE  pPropertyUsage = NULL;
    BOOL                fRet = FALSE;

    // get the extension usages that are in the cert
    if(!CertGetEnhancedKeyUsage (
                pCertContext,
                CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
                NULL,
                &cbPropertyUsage
                )                                                                   ||
        (pPropertyUsage = (PCERT_ENHKEY_USAGE) malloc(cbPropertyUsage)) == NULL   ||
        !CertGetEnhancedKeyUsage (
                pCertContext,
                CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
                pPropertyUsage,
                &cbPropertyUsage
                ) ) 
    {
        if(GetLastError() == CRYPT_E_NOT_FOUND)
        {
            return FALSE;
        }
    }

    if (pPropertyUsage == NULL)
    {
        return FALSE;
    }

    if ((pPropertyUsage->cUsageIdentifier == 0) ||
        ((pPropertyUsage->cUsageIdentifier == 1) && (strcmp(szOID_YESNO_TRUST_ATTR, pPropertyUsage->rgpszUsageIdentifier[0]) == 0)))
    {
        fRet = TRUE;
    }

    if (pPropertyUsage != NULL)
    {
        free(pPropertyUsage);
    }

    return fRet;
}


//////////////////////////////////////////////////////////////////////////////////////
// This function will validate the cert for the given oid
//////////////////////////////////////////////////////////////////////////////////////
BOOL ValidateCertForUsage(
                    PCCERT_CONTEXT  pCertContext, 
                    FILETIME        *psftVerifyAsOf,
                    DWORD           cStores,
                    HCERTSTORE *    rghStores,
                    HCERTSTORE      hExtraStore,
                    LPCSTR          pszOID)
{
    WINTRUST_DATA               WTD;
    WINTRUST_CERT_INFO          WTCI;
    CRYPT_PROVIDER_DEFUSAGE     cryptProviderDefUsage;
    GUID                        defaultProviderGUID = WINTRUST_ACTION_GENERIC_CERT_VERIFY;
    BOOL                        fUseDefaultProvider;
    BOOL                        fRet = FALSE;
    HCERTSTORE                  *rghLocalStoreArray;
    DWORD                       i;

    //
    // make one array out of the array of hCertStores plus the extra hCertStore
    //
    if (NULL == (rghLocalStoreArray = (HCERTSTORE *) malloc(sizeof(HCERTSTORE) * (cStores+1))))
    {
        return FALSE;
    }
    i=0;
    while (i<cStores)
    {
        rghLocalStoreArray[i] = rghStores[i];
        i++;
    }
    rghLocalStoreArray[i] = hExtraStore;
    
    //
    // initialize structs that are used with WinVerifyTrust()
    //
    memset(&WTD, 0x00, sizeof(WINTRUST_DATA));
    WTD.cbStruct       = sizeof(WINTRUST_DATA);
    WTD.dwUIChoice     = WTD_UI_NONE;
    WTD.dwUnionChoice  = WTD_CHOICE_CERT;
    WTD.pCert          = &WTCI;

    memset(&WTCI, 0x00, sizeof(WINTRUST_CERT_INFO));
    WTCI.cbStruct          = sizeof(WINTRUST_CERT_INFO);
    WTCI.pcwszDisplayName  = L"CryptUI";
    WTCI.psCertContext     = (CERT_CONTEXT *)pCertContext;  
    WTCI.chStores          = cStores+1;
    WTCI.pahStores         = rghLocalStoreArray;
    WTCI.psftVerifyAsOf    = psftVerifyAsOf;

    fUseDefaultProvider = FALSE;

    if (pszOID != NULL)
    {
        memset(&cryptProviderDefUsage, 0, sizeof(cryptProviderDefUsage));
        cryptProviderDefUsage.cbStruct = sizeof(cryptProviderDefUsage);
        if (!(WintrustGetDefaultForUsage(DWACTION_ALLOCANDFILL, pszOID, &cryptProviderDefUsage)))
        {
            // if we can't get a provider to check trust for this usage, then use the default
            // provider to check usage
            fUseDefaultProvider = TRUE;
        } 
    }
    
    //
    //  this call to WVT will verify the chain and return the data in sWTD.hWVTStateData
    //
    if (fUseDefaultProvider)
    {
        // the default default provider requires the policycallback data to point
        // to the usage oid you are validating for, if usage is "all" then wintrust ignores
        // usage checks
        WTD.pPolicyCallbackData = (pszOID != NULL) ? (void *) pszOID : "all";
        WTD.pSIPClientData = NULL;
        if (SUCCEEDED(WinVerifyTrustEx(NULL, &defaultProviderGUID, &WTD)))
        {
            fRet = TRUE;
        }     
    }
    else
    {
        WTD.pPolicyCallbackData = cryptProviderDefUsage.pDefPolicyCallbackData;
        WTD.pSIPClientData = cryptProviderDefUsage.pDefSIPClientData;
        if (SUCCEEDED(WinVerifyTrustEx(NULL, &cryptProviderDefUsage.gActionID, &WTD)))
        {
            fRet = TRUE;
        }
        WintrustGetDefaultForUsage(DWACTION_FREE, szOID_KP_CTL_USAGE_SIGNING, &cryptProviderDefUsage);
    }

    free(rghLocalStoreArray);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\uihlpr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:     uihlpr.cpp
//
//  History:  Created - DSIE April 9, 2001
//
//--------------------------------------------------------------------------

#include "global.hxx"


//+-------------------------------------------------------------------------
// Check to see if a specified URL is http scheme.
//--------------------------------------------------------------------------
BOOL
WINAPI
IsHttpUrlA(
    IN LPCTSTR  pszUrlString
)
{
    BOOL bResult = FALSE;

    if (pszUrlString)
    {
        LPWSTR pwszUrlString = NULL;

        if (pwszUrlString = new WCHAR[strlen(pszUrlString) + 1])
        {
            MultiByteToWideChar(0, 0, (const char *) pszUrlString, -1, pwszUrlString, strlen(pszUrlString) + 1);

            bResult = IsHttpUrlW(pwszUrlString) ;

            delete [] pwszUrlString;
        }
    }

    return bResult;
}

BOOL
WINAPI
IsHttpUrlW(
    IN LPCWSTR  pwszUrlString
)
{
    BOOL bResult = FALSE;

    if (pwszUrlString)
    {
        URL_COMPONENTSW urlComponents;

        ZeroMemory(&urlComponents, sizeof(urlComponents));
        urlComponents.dwStructSize = sizeof(urlComponents);

        if (InternetCrackUrlW(pwszUrlString, lstrlenW(pwszUrlString), 0, &urlComponents))
        {
            if (INTERNET_SCHEME_HTTP == urlComponents.nScheme || INTERNET_SCHEME_HTTPS == urlComponents.nScheme)
            {
                bResult = TRUE;
            }
        }
   }
        
    return bResult;
}


//+-------------------------------------------------------------------------
// Check to see if a specified string should be formatted as link based on
// severity of error code, and internet scheme of the string.
//--------------------------------------------------------------------------
BOOL
WINAPI
IsOKToFormatAsLinkA(
    IN LPSTR    pszUrlString,
    IN DWORD    dwErrorCode
)
{
    BOOL bResult = FALSE;

    if (pszUrlString)
    {
        LPWSTR pwszUrlString = NULL;

        if (pwszUrlString = new WCHAR[strlen(pszUrlString) + 1])
        {
            MultiByteToWideChar(0, 0, (const char *) pszUrlString, -1, pwszUrlString, strlen(pszUrlString) + 1);

            bResult = IsOKToFormatAsLinkW(pwszUrlString, dwErrorCode) ;

            delete [] pwszUrlString;
        }
    }

    return bResult;
}


BOOL
WINAPI
IsOKToFormatAsLinkW(
    IN LPWSTR   pwszUrlString,
    IN DWORD    dwErrorCode
)
{
    BOOL bResult = FALSE;

    switch (dwErrorCode)
    {
        case 0:
        case CERT_E_EXPIRED:
        case CERT_E_PURPOSE:
        case CERT_E_WRONG_USAGE:
        case CERT_E_CN_NO_MATCH:
        case CERT_E_INVALID_NAME:
        case CERT_E_INVALID_POLICY:
        case CERT_E_REVOCATION_FAILURE:
        case CRYPT_E_NO_REVOCATION_CHECK:
        case CRYPT_E_REVOCATION_OFFLINE:
        {
#if (0)
            bResult = IsHttpUrlW(pwszUrlString);
#else
            bResult = TRUE;
#endif
            break;
        }
    }

    return bResult;
}


//+-------------------------------------------------------------------------
// Return the display name for a cert. Caller must free the string by
// free().
//--------------------------------------------------------------------------
LPWSTR
WINAPI
GetDisplayNameString(
    IN  PCCERT_CONTEXT   pCertContext,
	IN  DWORD            dwFlags
)
{
	DWORD	cchNameString  = 0;
	LPWSTR	pwszNameString = NULL;
	DWORD   DisplayTypes[] = {CERT_NAME_SIMPLE_DISPLAY_TYPE,
                              CERT_NAME_FRIENDLY_DISPLAY_TYPE,
							  CERT_NAME_EMAIL_TYPE,
		                      CERT_NAME_DNS_TYPE,
							  CERT_NAME_UPN_TYPE};

    if (NULL == pCertContext)
	{
        goto InvalidArgError;
	}

	for (int i = 0; i < (sizeof(DisplayTypes) / sizeof(DisplayTypes[0])); i++)
	{
		cchNameString   = 0;
		pwszNameString = NULL;

		cchNameString = CertGetNameStringW(pCertContext,
                                          DisplayTypes[i],
                                          dwFlags,
                                          NULL,
                                          pwszNameString,
                                          0);

        if (1 < cchNameString)
        {
            if (NULL == (pwszNameString = (LPWSTR) malloc(cchNameString * sizeof(WCHAR))))
            {
                goto OutOfMemoryError;
            }
            ZeroMemory(pwszNameString, cchNameString * sizeof(WCHAR));

		    CertGetNameStringW(pCertContext,
                               DisplayTypes[i],
                               dwFlags,
                               NULL,
                               pwszNameString,
                               cchNameString);
            break;
        }
    }

CommonReturn:

	return pwszNameString;

ErrorReturn:

	if (NULL != pwszNameString)
    {
        free(pwszNameString);
        pwszNameString = NULL;
    }

	goto CommonReturn;

SET_ERROR(InvalidArgError, E_INVALIDARG);
SET_ERROR(OutOfMemoryError, E_OUTOFMEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\util.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       util.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <wininet.h>
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL CommonInit()
{
    if (HmodRichEdit == NULL)
    {
        HmodRichEdit = LoadLibraryA("RichEd32.dll");
        if (HmodRichEdit == NULL) {
            return FALSE;
        }
    }

    INITCOMMONCONTROLSEX        initcomm = {
        sizeof(initcomm), ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES | ICC_TREEVIEW_CLASSES
    };

    InitCommonControlsEx(&initcomm);

    return TRUE;
}

/////////////////////////////////////////////////////////

BOOL IsWin95()
{
    BOOL        f;
    OSVERSIONINFOA       ver;
    ver.dwOSVersionInfoSize = sizeof(ver);
    f = GetVersionExA(&ver);
    return !f || (ver.dwPlatformId == 1);
}

BOOL CheckRichedit20Exists()
{
    HMODULE hModRichedit20;

    hModRichedit20 = LoadLibraryA("RichEd20.dll");

    if (hModRichedit20 != NULL)
    {
        FreeLibrary(hModRichedit20);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
LPWSTR PrettySubject(PCCERT_CONTEXT pccert)
{
    DWORD       cb;
    DWORD       cch;
    BOOL        f;
    LPWSTR      pwsz;

    //
    //  If the user has put a friendly name onto a certificate, then we
    //  should display that as the pretty name for the certificate.
    //

    f = CertGetCertificateContextProperty(pccert, CERT_FRIENDLY_NAME_PROP_ID,
                                          NULL, &cb);
    if (f && (cb > 0)) {
        pwsz = (LPWSTR) malloc(cb);
        if (pwsz == NULL)
        {
            return NULL;
        }
        CertGetCertificateContextProperty(pccert, CERT_FRIENDLY_NAME_PROP_ID,
                                          pwsz, &cb);
#if (0) //DSIE: Bug 477933
        return pwsz;
#else
        if (0 < wcslen(pwsz))
        {
            return pwsz;
        }

        free(pwsz);
#endif
    }

    pwsz = GetDisplayNameString(pccert, 0);

    return pwsz;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL OnContextHelp(HWND /*hwnd*/, UINT uMsg, WPARAM wParam, LPARAM lParam,
                   HELPMAP const * rgCtxMap)
{
    if (uMsg == WM_HELP)
    {
        LPHELPINFO lphi = (LPHELPINFO) lParam;
        if (lphi->iContextType == HELPINFO_WINDOW)
        {   // must be for a control
            if (lphi->iCtrlId != IDC_STATIC)
            {
                WinHelpU((HWND)lphi->hItemHandle, L"secauth.hlp", HELP_WM_HELP,
                        (ULONG_PTR)(LPVOID)rgCtxMap);
            }
        }
        return (TRUE);
    }
    else if (uMsg == WM_CONTEXTMENU) {
        WinHelpU ((HWND) wParam, L"secauth.hlp", HELP_CONTEXTMENU,
                 (ULONG_PTR)(LPVOID)rgCtxMap);
        return (TRUE);
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer(void)
{
    HRESULT     hr = S_OK;


    return hr;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer(void)
{
    HRESULT     hr = S_OK;


    return hr;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL FreeAndCloseKnownStores(DWORD chStores, HCERTSTORE *phStores)
{
    DWORD i;

    for (i=0; i<chStores; i++)
    {
        CertCloseStore(phStores[i], 0);
    }
    free(phStores);

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
#define NUM_KNOWN_STORES 5
BOOL AllocAndOpenKnownStores(DWORD *chStores, HCERTSTORE  **pphStores)
{
    HCERTSTORE hStore;

    if (NULL == (*pphStores = (HCERTSTORE *) malloc(NUM_KNOWN_STORES * sizeof(HCERTSTORE))))
    {
        return FALSE;
    }

    *chStores = 0;

    //
    //  ROOT store - ALWAYS #0 !!!!
    //
    if (hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                0,
                                0,
                                CERT_SYSTEM_STORE_CURRENT_USER |
                                CERT_STORE_READONLY_FLAG |
                                CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                "ROOT"))
    {
        (*pphStores)[(*chStores)++] = hStore;
    }
    else
    {
        return(FALSE);  // if we can't find the root, FAIL!
    }

    //
    //  open the Trust List store
    //
    if (hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                0,
                                0,
                                CERT_SYSTEM_STORE_CURRENT_USER |
                                CERT_STORE_READONLY_FLAG |
                                CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                "TRUST"))
    {
        (*pphStores)[(*chStores)++] = hStore;
    }

    //
    //  CA Store
    //
    if (hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                0,
                                0,
                                CERT_SYSTEM_STORE_CURRENT_USER |
                                CERT_STORE_READONLY_FLAG |
                                CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                "CA"))
    {
        (*pphStores)[(*chStores)++] = hStore;
    }

    //
    //  MY Store
    //
    if (hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                0,
                                0,
                                CERT_SYSTEM_STORE_CURRENT_USER |
                                CERT_STORE_READONLY_FLAG |
                                CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                "MY"))
    {
        (*pphStores)[(*chStores)++] = hStore;
    }

    //
    //  SPC Store (historic reasons!)
    //
    if (hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                0,
                                0,
                                CERT_SYSTEM_STORE_LOCAL_MACHINE |
                                CERT_STORE_READONLY_FLAG |
                                CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                "SPC"))
    {
        (*pphStores)[(*chStores)++] = hStore;
    }

    return(TRUE);
}


//////////////////////////////////////////////////////////////////////////////////////
// Create and return a palette from the info in a DIB bitmap.
// To free the returned palette, use DeleteObject.
//////////////////////////////////////////////////////////////////////////////////////
#define SELPALMODE  TRUE

static HPALETTE CreateDIBPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors)
{
	LPBITMAPINFOHEADER  lpbi;
	LPLOGPALETTE     lpPal;
	HANDLE           hLogPal;
	HPALETTE         hPal = NULL;
	int              i;

	lpbi = (LPBITMAPINFOHEADER)lpbmi;
	if (lpbi->biBitCount <= 8)
		{
		if (lpbi->biClrUsed == 0)
			*lpiNumColors = (1 << lpbi->biBitCount);
		else
			*lpiNumColors = lpbi->biClrUsed;
		}
	else
	   *lpiNumColors = 0;  // No palette needed for 24 BPP DIB

	if (*lpiNumColors)
		{
		hLogPal = GlobalAlloc (GHND, sizeof (LOGPALETTE) + sizeof (PALETTEENTRY) * (*lpiNumColors));
        if (hLogPal == NULL)
        {
            return NULL;
        }
		lpPal = (LPLOGPALETTE) GlobalLock (hLogPal);
		lpPal->palVersion    = 0x300;
		lpPal->palNumEntries = (WORD)*lpiNumColors;

		for (i = 0;  i < *lpiNumColors;  i++)
			{
			lpPal->palPalEntry[i].peRed   = lpbmi->bmiColors[i].rgbRed;
			lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
			lpPal->palPalEntry[i].peBlue  = lpbmi->bmiColors[i].rgbBlue;
			lpPal->palPalEntry[i].peFlags = 0;
			}
		hPal = CreatePalette(lpPal);
		GlobalUnlock (hLogPal);
		GlobalFree   (hLogPal);
		}
	return hPal;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
HBITMAP LoadResourceBitmap(HINSTANCE hInstance, LPSTR lpString, HPALETTE* lphPalette)
// Load the indicated bitmap resource and its palette. To free the
//		bitmap, use DeleteObject
//		palette, use DeleteObject
{
	HRSRC  hRsrc;
	HGLOBAL hGlobal;
	HBITMAP hBitmapFinal = NULL;
	LPBITMAPINFOHEADER  lpbi;
	HDC hdc;
	int iNumColors;

	if (hRsrc = ::FindResource(hInstance, lpString, RT_BITMAP))
	{
		hGlobal = ::LoadResource(hInstance, hRsrc);
        if (hGlobal == NULL)
        {
            return NULL;
        }
		lpbi = (LPBITMAPINFOHEADER)::LockResource(hGlobal);

		hdc = GetDC(NULL);
        if (hdc == NULL)
        {
            return NULL;
        }

        HDC     hdcMem  = CreateCompatibleDC(hdc);
        if (hdcMem == NULL)
        {
            ReleaseDC(NULL,hdc);
            return NULL;
        }

        HBITMAP hbmMem  = CreateCompatibleBitmap(hdc, 10, 10); assert(hbmMem);
        if (hbmMem == NULL)
        {
            ReleaseDC(NULL,hdc);
            DeleteDC(hdcMem);
            return NULL;
        }

        HBITMAP hbmPrev	= (HBITMAP)SelectObject(hdcMem, hbmMem);

        HPALETTE hpal = CreateDIBPalette((LPBITMAPINFO)lpbi, &iNumColors);
        HPALETTE hpalPrev = NULL;
	    if (hpal)
	    {
		    hpalPrev = SelectPalette(hdcMem,hpal,FALSE);
		    RealizePalette(hdcMem);
	    }

		hBitmapFinal = ::CreateDIBitmap(hdcMem,
			(LPBITMAPINFOHEADER)lpbi,
			(LONG)CBM_INIT,
			(LPSTR)lpbi + lpbi->biSize + iNumColors * sizeof(RGBQUAD),
			(LPBITMAPINFO)lpbi,
			DIB_RGB_COLORS );

        if (hpalPrev)
        {
            SelectPalette(hdcMem, hpalPrev, FALSE);
            RealizePalette(hdcMem);
        }

        if (lphPalette)
        {
            // Let the caller own this if he asked for it
		    *lphPalette = hpal;
        }
        else
        {
            // We don't need it any more
            ::DeleteObject(hpal);
        }

        // Tidy up
        SelectObject(hdcMem, hbmPrev);
        DeleteObject(hbmMem);
        DeleteDC(hdcMem);

		ReleaseDC(NULL,hdc);
		UnlockResource(hGlobal);
		FreeResource(hGlobal);
    }
	return (hBitmapFinal);
}


//////////////////////////////////////////////////////////////////////////////////////
// Implement our own mask blt to deal with devices that don't support it natively
//////////////////////////////////////////////////////////////////////////////////////
void MaskBlt
(
    HBITMAP& hbmImage,
    HPALETTE hpal,
    HDC& hdc, int xDst, int yDst, int dx, int dy
)
{
	int xSrc = 0, ySrc = 0;
	int xMsk = 0, yMsk = 0;
	// Either
	//		a) I'm not testing for MaskBlt correctly, or
	//		b) some Win95 cards lie about its support
	// For now, we just turn it off and roll our own
	if (FALSE) //  && (GetDeviceCaps(hdc, RASTERCAPS) & RC_BITBLT))
	{
		// Device can handle it; let it do it
		// Raster opcode 0x00AA0029 == leave destination untouched
		//
/*		CDC hdcImage;
		hdc.CreateCompatibleDC(&hdcImage);
		CBitmap* pbmpPrev = hdcImage.SelectObject(&hbmImage);
//		We need to create the mask ourselves in any case
//		hdc.MaskBlt(xDst,yDst,dx,dy, &hdcImage,xSrc,ySrc, hbmMaskIn,xMsk,yMsk, MAKEROP4(0x00AA0029,SRCCOPY));
		hdcImage.SelectObject(pbmpPrev);
*/	}
	else
	{
		HDC     hdcMask;
		HDC     hdcMaskInv;
		HDC     hdcCache;
		HDC     hdcImage;
		HDC     hdcImageCrop;
        HBITMAP hbmCache;
		HBITMAP hbmImageCrop;
		HBITMAP hbmMaskInvert;
		HBITMAP hbmMask;
        HBITMAP hbmPrevImage;
		HBITMAP hbmPrevImageCrop;
		HBITMAP hbmPrevCache;
		HBITMAP hbmPrevMask;
		HBITMAP hbmPrevMaskInv;
        COLORREF rgbTransparent;
		COLORREF rgbPrev;

        //
        // Device can't handle it; we roll our own
		//
		hdcMask			= CreateCompatibleDC(hdc);	assert(hdcMask);
		hdcMaskInv		= CreateCompatibleDC(hdc);	assert(hdcMaskInv);
		hdcCache		= CreateCompatibleDC(hdc);	assert(hdcCache);
		hdcImage		= CreateCompatibleDC(hdc);	assert(hdcImage);
		hdcImageCrop	= CreateCompatibleDC(hdc);	assert(hdcImageCrop);

        if ((hdcMask == NULL)       ||
            (hdcMaskInv == NULL)    ||
            (hdcCache == NULL)      ||
            (hdcImage == NULL)      ||
            (hdcImageCrop == NULL))
        {
            goto DCCleanUp;
        }
		
		// Create bitmaps
		hbmCache		= CreateCompatibleBitmap(hdc, dx, dy);			assert(hbmCache);
		hbmImageCrop	= CreateCompatibleBitmap(hdc, dx, dy);			assert(hbmImageCrop);
		hbmMaskInvert	= CreateCompatibleBitmap(hdcMaskInv, dx, dy);	assert(hbmMaskInvert);
		hbmMask			= CreateBitmap(dx, dy, 1, 1, NULL);				assert(hbmMask); // B&W bitmap

        if ((hbmCache == NULL)      ||
            (hbmImageCrop == NULL)  ||
            (hbmMaskInvert == NULL) ||
            (hbmMask == NULL))
        {
            goto BMCleanUp;
        }

		// Select bitmaps
		hbmPrevImage	= (HBITMAP)SelectObject(hdcImage,		hbmImage);		
		hbmPrevImageCrop= (HBITMAP)SelectObject(hdcImageCrop,	hbmImageCrop);	
		hbmPrevCache	= (HBITMAP)SelectObject(hdcCache,		hbmCache);		
		hbmPrevMask		= (HBITMAP)SelectObject(hdcMask,		hbmMask);		
		hbmPrevMaskInv	= (HBITMAP)SelectObject(hdcMaskInv,		hbmMaskInvert);	

		assert(hbmPrevMaskInv);			
		assert(hbmPrevMask);			
		assert(hbmPrevCache);			
		assert(hbmPrevImageCrop);		
		assert(hbmPrevImage);			

        // Select the palette into each bitmap
        /*HPALETTE hpalCache     = SelectPalette(hdcCache,         hpal, SELPALMODE);
        HPALETTE hpalImage     = SelectPalette(hdcImage,         hpal, SELPALMODE);
        HPALETTE hpalImageCrop = SelectPalette(hdcImageCrop,     hpal, SELPALMODE);
        HPALETTE hpalMaskInv   = SelectPalette(hdcMaskInv,       hpal, SELPALMODE);
        HPALETTE hpalMask      = SelectPalette(hdcMask,          hpal, SELPALMODE);
*/
		// Create the mask. We want a bitmap which is white (1) where the image is
		// rgbTransparent and black (0) where it is another color.
		//
		//	When using BitBlt() to convert a color bitmap to a monochrome bitmap, GDI
		//	sets to white (1) all pixels that match the background color of the source
		//	DC. All other bits are set to black (0).
		//
		rgbTransparent = RGB(255,0,255);									// this color becomes transparent
		rgbPrev        = SetBkColor(hdcImage, rgbTransparent);
		BitBlt(hdcMask,     0,0,dx,dy, hdcImage,  0,   0,    SRCCOPY);
		SetBkColor(hdcImage, rgbPrev);

		// Create the inverted mask
		BitBlt(hdcMaskInv,  0,0,dx,dy, hdcMask,   xMsk,yMsk, NOTSRCCOPY);	// Sn: Create inverted mask

		// Carry out the surgery
		BitBlt(hdcCache,    0,0,dx,dy, hdc,       xDst,yDst, SRCCOPY);		// S: Get copy of screen
		BitBlt(hdcCache,    0,0,dx,dy, hdcMask,	 0,   0,    SRCAND);		// DSa: zero where new image goes
		BitBlt(hdcImageCrop,0,0,dx,dy, hdcImage,  xSrc,ySrc, SRCCOPY);		// S: Get copy of image
		BitBlt(hdcImageCrop,0,0,dx,dy, hdcMaskInv,0,   0,    SRCAND);		// DSa: zero out outside of image
		BitBlt(hdcCache,    0,0,dx,dy, hdcImageCrop,0, 0,    SRCPAINT);		// DSo: Combine image into cache
		BitBlt(hdc,   xDst,yDst,dx,dy, hdcCache,  0,   0,    SRCCOPY);		// S: Put results back on screen

//      VERIFY(BitBlt(hdc,   xDst,yDst,dx,dy,    hdcCache,  0,   0,    SRCCOPY));
//      VERIFY(BitBlt(hdc,   xDst+dx,yDst,dx,dy, hdcMask,   0,   0,    SRCCOPY));


        /*if (hpalCache)      SelectPalette(hdcCache,         hpalCache,      SELPALMODE);
        if (hpalImage)      SelectPalette(hdcImage,         hpalImage,      SELPALMODE);
        if (hpalImageCrop)  SelectPalette(hdcImageCrop,     hpalImageCrop,  SELPALMODE);
        if (hpalMaskInv)    SelectPalette(hdcMaskInv,       hpalMaskInv,    SELPALMODE);
        if (hpalMask)       SelectPalette(hdcMask,          hpalMask,       SELPALMODE);
*/

		// Tidy up
		SelectObject(hdcImage,		hbmPrevImage);
		SelectObject(hdcImageCrop,	hbmPrevImageCrop);
		SelectObject(hdcCache,		hbmPrevCache);
		SelectObject(hdcMask,		hbmPrevMask);
		SelectObject(hdcMaskInv,	hbmPrevMaskInv);

		// Free resources
BMCleanUp:
        if (hbmMaskInvert != NULL)
		    DeleteObject(hbmMaskInvert);

        if (hbmMask != NULL)
		    DeleteObject(hbmMask);

        if (hbmImageCrop != NULL)
		    DeleteObject(hbmImageCrop);

        if (hbmCache != NULL)
		    DeleteObject(hbmCache);

		// Delete DCs
DCCleanUp:
		if (hdcMask != NULL)
            DeleteDC(hdcMask);
		
        if (hdcMaskInv != NULL)
            DeleteDC(hdcMaskInv);
		
        if (hdcCache != NULL)
            DeleteDC(hdcCache);
		
        if (hdcImage != NULL)
            DeleteDC(hdcImage);
		
        if (hdcImageCrop != NULL)
            DeleteDC(hdcImageCrop);
	}
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
PCCERT_CONTEXT GetSignersCert(CMSG_SIGNER_INFO const *pSignerInfo, HCERTSTORE hExtraStore, DWORD cStores, HCERTSTORE *rghStores)

{
    DWORD           i;
    PCCERT_CONTEXT  pCertContext = NULL;
    CERT_INFO       certInfo;
    DWORD           chLocalStores = 0;
    HCERTSTORE      *rghLocalStores = NULL;

    memset(&certInfo, 0, sizeof(CERT_INFO));
    certInfo.SerialNumber = pSignerInfo->SerialNumber;
    certInfo.Issuer = pSignerInfo->Issuer;

    pCertContext = CertGetSubjectCertificateFromStore(
                                    hExtraStore,
                                    X509_ASN_ENCODING,
                                    &certInfo);
    i = 0;
    while ((i<cStores) && (pCertContext == NULL))
    {
        pCertContext = CertGetSubjectCertificateFromStore(
                                    rghStores[i],
                                    X509_ASN_ENCODING,
                                    &certInfo);
        i++;
    }

    //
    // search the known stores if it was not found and caller wants to search them
    //
    if (pCertContext == NULL)
    {
        AllocAndOpenKnownStores(&chLocalStores, &rghLocalStores);

        i = 0;
        while ((pCertContext == NULL) && (i < chLocalStores))
        {
            pCertContext = CertGetSubjectCertificateFromStore(
                                            rghLocalStores[i++],
                                            X509_ASN_ENCODING,
                                            &certInfo);
        }

        FreeAndCloseKnownStores(chLocalStores, rghLocalStores);
    }

    return(pCertContext);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL fIsCatalogFile(CTL_USAGE *pSubjectUsage)
{
    if (pSubjectUsage->cUsageIdentifier != 1)
    {
        return FALSE;
    }

    return (strcmp(pSubjectUsage->rgpszUsageIdentifier[0], szOID_CATALOG_LIST) == 0);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
typedef struct {
    LPSTR   psz;
    LPCWSTR pwsz;
    LONG    byteoffset;
    BOOL    fStreamIn;
} STREAMIN_HELPER_STRUCT;


DWORD CALLBACK SetRicheditTextWCallback(
    DWORD_PTR dwCookie, // application-defined value
    LPBYTE  pbBuff,     // pointer to a buffer
    LONG    cb,         // number of bytes to read or write
    LONG    *pcb        // pointer to number of bytes transferred
)
{
    STREAMIN_HELPER_STRUCT *pHelpStruct = (STREAMIN_HELPER_STRUCT *) dwCookie;
    LONG  lRemain = ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset);

    if (pHelpStruct->fStreamIn)
    {
        //
        // The whole string can be copied first time
        //
        if ((cb >= (LONG) (wcslen(pHelpStruct->pwsz) * sizeof(WCHAR))) && (pHelpStruct->byteoffset == 0))
        {
            memcpy(pbBuff, pHelpStruct->pwsz, wcslen(pHelpStruct->pwsz) * sizeof(WCHAR));
            *pcb = wcslen(pHelpStruct->pwsz) * sizeof(WCHAR);
            pHelpStruct->byteoffset = *pcb;
        }
        //
        // The whole string has been copied, so terminate the streamin callbacks
        // by setting the num bytes copied to 0
        //
        else if (((LONG)(wcslen(pHelpStruct->pwsz) * sizeof(WCHAR))) <= pHelpStruct->byteoffset)
        {
            *pcb = 0;
        }
        //
        // The rest of the string will fit in this buffer
        //
        else if (cb >= (LONG) ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset))
        {
            memcpy(
                pbBuff,
                ((BYTE *)pHelpStruct->pwsz) + pHelpStruct->byteoffset,
                ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset));
            *pcb = ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset);
            pHelpStruct->byteoffset += ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset);
        }
        //
        // copy as much as possible
        //
        else
        {
            memcpy(
                pbBuff,
                ((BYTE *)pHelpStruct->pwsz) + pHelpStruct->byteoffset,
                cb);
            *pcb = cb;
            pHelpStruct->byteoffset += cb;
        }
    }
    else
    {
        //
        // This is the EM_STREAMOUT which is only used during the testing of
        // the richedit2.0 functionality.  (we know our buffer is 32 bytes)
        //
        if (cb <= 32)
        {
            memcpy(pHelpStruct->psz, pbBuff, cb);
        }
        *pcb = cb;
    }

    return 0;
}


DWORD CryptUISetRicheditTextW(HWND hwndDlg, UINT id, LPCWSTR pwsz)
{
    EDITSTREAM              editStream;
    STREAMIN_HELPER_STRUCT  helpStruct;

    SetRicheditIMFOption(GetDlgItem(hwndDlg, id));

    //
    // setup the edit stream struct since it is the same no matter what
    //
    editStream.dwCookie = (DWORD_PTR) &helpStruct;
    editStream.dwError = 0;
    editStream.pfnCallback = SetRicheditTextWCallback;

    if (!fRichedit20Exists || !fRichedit20Usable(GetDlgItem(hwndDlg, id)))
    {
        SetDlgItemTextU(hwndDlg, id, pwsz);
        return 0;
    }

    helpStruct.pwsz = pwsz;
    helpStruct.byteoffset = 0;
    helpStruct.fStreamIn = TRUE;

    SendDlgItemMessageA(hwndDlg, id, EM_STREAMIN, SF_TEXT | SF_UNICODE, (LPARAM) &editStream);


    return editStream.dwError;
}


void SetRicheditIMFOption(HWND hWndRichEdit)
{
    DWORD dwOptions;

    if (fRichedit20Exists && fRichedit20Usable(hWndRichEdit))
    {
        dwOptions = (DWORD)SendMessageA(hWndRichEdit, EM_GETLANGOPTIONS, 0, 0);
        dwOptions |= IMF_UIFONTS;
        SendMessageA(hWndRichEdit, EM_SETLANGOPTIONS, 0, dwOptions);
    }
}


BOOL fRichedit20UsableCheckMade = FALSE;
BOOL fRichedit20UsableVar = FALSE;

BOOL fRichedit20Usable(HWND hwndEdit)
{
    EDITSTREAM              editStream;
    STREAMIN_HELPER_STRUCT  helpStruct;
    LPWSTR                  pwsz = L"Test String";
    LPSTR                   pwszCompare = "Test String";
    char                    compareBuf[32];

    if (fRichedit20UsableCheckMade)
    {
        return (fRichedit20UsableVar);
    }

    //
    // setup the edit stream struct since it is the same no matter what
    //
    editStream.dwCookie = (DWORD_PTR) &helpStruct;
    editStream.dwError = 0;
    editStream.pfnCallback = SetRicheditTextWCallback;

    helpStruct.pwsz = pwsz;
    helpStruct.byteoffset = 0;
    helpStruct.fStreamIn = TRUE;

    SendMessageA(hwndEdit, EM_SETSEL, 0, -1);
    SendMessageA(hwndEdit, EM_STREAMIN, SF_TEXT | SF_UNICODE | SFF_SELECTION, (LPARAM) &editStream);

    memset(&(compareBuf[0]), 0, 32 * sizeof(char));
    helpStruct.psz = compareBuf;
    helpStruct.fStreamIn = FALSE;
    SendMessageA(hwndEdit, EM_STREAMOUT, SF_TEXT, (LPARAM) &editStream);

    fRichedit20UsableVar = (strcmp(pwszCompare, compareBuf) == 0);

    fRichedit20UsableCheckMade = TRUE;
    SetWindowTextA(hwndEdit, "");

    return (fRichedit20UsableVar);
}

/*
//--------------------------------------------------------------------------
//
//	  CryptUISetupFonts
//
//--------------------------------------------------------------------------
BOOL
CryptUISetupFonts(HFONT *pBoldFont)
{
    //
	// Create the fonts we need based on the dialog font
    //
	NONCLIENTMETRICS ncm = {0};
	ncm.cbSize = sizeof(ncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

	LOGFONT BoldLogFont     = ncm.lfMessageFont;

	BoldLogFont.lfWeight      = FW_BOLD;
	*pBoldFont    = CreateFontIndirect(&BoldLogFont);

    if(*pBoldFont)
        return TRUE;
    else
        return FALSE;
}


//--------------------------------------------------------------------------
//
//	  CryptUIDestroyFonts
//
//--------------------------------------------------------------------------
void
CryptUIDestroyFonts(HFONT hBoldFont)
{
    if( hBoldFont )
    {
        DeleteObject( hBoldFont );
    }
}


//--------------------------------------------------------------------------
//
//	 CryptUISetControlFont
//
//--------------------------------------------------------------------------
void
CryptUISetControlFont(HFONT hFont, HWND hwnd, INT nId)
{
	if( hFont )
    {
    	HWND hwndControl = GetDlgItem(hwnd, nId);

    	if( hwndControl )
        {
        	SendMessage(hwndControl, WM_SETFONT, (WPARAM) hFont, (LPARAM) TRUE);
        }
    }
}*/

//--------------------------------------------------------------------------
//
//	 IsValidURL
//
//--------------------------------------------------------------------------
BOOL 
IsValidURL (LPWSTR pwszURL)
{
    URL_COMPONENTSW     UrlComponents;
    WCHAR               pwszScheme[MAX_PATH+1];
    WCHAR               pwszCanonicalUrl[INTERNET_MAX_PATH_LENGTH];
    DWORD               dwNumChars   = INTERNET_MAX_PATH_LENGTH;
    CERT_ALT_NAME_INFO  NameInfo     = {0, NULL};
    CRYPT_DATA_BLOB     NameInfoBlob = {0, NULL};
    BOOL                bResult = FALSE;

    if (NULL == pwszURL || 0 == wcslen(pwszURL))
    {
        goto ErrorExit;
    }

    if (!InternetCanonicalizeUrlW(pwszURL,
                                  pwszCanonicalUrl,
                                  &dwNumChars,
                                  ICU_BROWSER_MODE))
    {
        goto ErrorExit;
    }

    memset(&UrlComponents, 0, sizeof(URL_COMPONENTSW));
    UrlComponents.dwStructSize = sizeof(URL_COMPONENTSW);
    UrlComponents.lpszScheme = pwszScheme;
    UrlComponents.dwSchemeLength = MAX_PATH;

    if (!InternetCrackUrlW(pwszCanonicalUrl,
                           0,
                           0,
                           &UrlComponents))
    {
        goto ErrorExit;
    }

    NameInfo.cAltEntry = 1;
    NameInfo.rgAltEntry = (PCERT_ALT_NAME_ENTRY) malloc(sizeof(CERT_ALT_NAME_ENTRY));
    if (NULL == NameInfo.rgAltEntry)
    {
        goto ErrorExit;
    }

    NameInfo.rgAltEntry[0].dwAltNameChoice = 7;
    NameInfo.rgAltEntry[0].pwszURL = pwszURL;

    if (!CryptEncodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                           X509_ALTERNATE_NAME,
                           &NameInfo,
                           NULL,
                           &NameInfoBlob.cbData))
    {
        goto ErrorExit;
    }

    NameInfoBlob.pbData = (BYTE *) malloc(NameInfoBlob.cbData);
    if (NULL == NameInfoBlob.pbData)
    {
        goto ErrorExit;
    }

    if (!CryptEncodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                           X509_ALTERNATE_NAME,
                           &NameInfo,
                           NameInfoBlob.pbData,
                           &NameInfoBlob.cbData))
    {
        goto ErrorExit;
    }

    bResult = TRUE;

CommonExit:

    if (NameInfo.rgAltEntry)
    {
        free(NameInfo.rgAltEntry);
    }

    if (NameInfoBlob.pbData)
    {
        free(NameInfoBlob.pbData);
    }

    return bResult;

ErrorExit:

    bResult = FALSE;

    goto CommonExit;
}

//--------------------------------------------------------------------------
//
//	  FormatMessageUnicodeIds
//
//--------------------------------------------------------------------------
LPWSTR FormatMessageUnicodeIds (UINT ids, ...)
{
    va_list argList;
    LPWSTR  pwszMessage = NULL;
    WCHAR   wszFormat[CRYPTUI_MAX_STRING_SIZE] = L"";

    if (!LoadStringU(HinstDll, ids, wszFormat, CRYPTUI_MAX_STRING_SIZE - 1))
    {
        goto LoadStringError;
    }

    va_start(argList, ids);

    pwszMessage = FormatMessageUnicode(wszFormat, &argList);

    va_end(argList);

CommonReturn:

    return pwszMessage;

ErrorReturn:

    if (pwszMessage)
    {
        LocalFree(pwszMessage);
    }

    pwszMessage = NULL;

    goto CommonReturn;

TRACE_ERROR(LoadStringError);
}

//--------------------------------------------------------------------------
//
//	  FormatMessageUnicodeString
//
//--------------------------------------------------------------------------
LPWSTR FormatMessageUnicodeString (LPWSTR pwszFormat, ...)
{
    va_list argList;
    LPWSTR  pwszMessage = NULL;

    va_start(argList, pwszFormat);

    pwszMessage = FormatMessageUnicode(pwszFormat, &argList);

    va_end(argList);

    return pwszMessage;
}

//--------------------------------------------------------------------------
//
//	  FormatMessageUnicode
//
//--------------------------------------------------------------------------
LPWSTR FormatMessageUnicode (LPWSTR pwszFormat, va_list * pArgList)
{
    DWORD  cbMsg       = 0;
    LPWSTR pwszMessage = NULL;

    if (NULL == pwszFormat || NULL == pArgList)
    {
        goto InvalidArgErr;
    }

    if (!(cbMsg = FormatMessageU(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                                 pwszFormat,
                                 0,                  // dwMessageId
                                 0,                  // dwLanguageId
                                 (LPWSTR) &pwszMessage,
                                 0,                  // minimum size to allocate
                                 pArgList)))
    {
	//
	// FormatMessageU() will return 0, if data to be formatted is empty. 
        // In this case, we return pointer to an empty string, instead of NULL
        // pointer which actually is used for error case.
	//
	if (0 == GetLastError())
	{
	    if (NULL == (pwszMessage = (LPWSTR) LocalAlloc(LPTR, sizeof(WCHAR))))
            {
		goto MemoryError;
            }
	}
	else
        {
	    goto FormatMessageError;
        }
    }

    assert(NULL != pwszMessage);

CommonReturn:

    return pwszMessage;

ErrorReturn:

    if (pwszMessage)
    {
        LocalFree(pwszMessage);
    }

    pwszMessage = NULL;

    goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatMessageError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\view.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       view.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

#define SPECIAL_NO_COM_FLAG 0x8000


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
CryptUIDlgViewCertificateW(PCCRYPTUI_VIEWCERTIFICATE_STRUCTW pcvp, BOOL *pfPropertiesChanged)
{
    int                         cPages = 3;
	UINT						cDefaultPages = 0;
    BOOL                        fRetValue = FALSE;
    HRESULT                     hr;
    PROPSHEETPAGEW *            ppage = NULL;
    INT_PTR                     ret;
    WCHAR                       rgwch[CRYPTUI_MAX_STRING_SIZE];
    char                        rgch[CRYPTUI_MAX_STRING_SIZE];
    CERT_VIEW_HELPER            viewhelp;
    DWORD                       i;
    CRYPTUI_INITDIALOG_STRUCT   *pInitDlgStruct;

    //
    // it doesn't matter what this action is as long as it is a valid action, it is just used for 
    // freeing the WinVerifyTrust state
    //
    GUID                gAction = WINTRUST_ACTION_GENERIC_CERT_VERIFY;

    //
    //  We use the common controls -- so make sure they have been loaded
    //
    if (CommonInit() == FALSE)
    {
        return FALSE;
    }

    if (pcvp->dwSize != sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCTW)) {
        SetLastError(E_INVALIDARG);
        return FALSE;
    }

    memset(&viewhelp, 0, sizeof(CERT_VIEW_HELPER));
    viewhelp.pcvp = pcvp;
    viewhelp.hwndGeneralPage = NULL;
    viewhelp.hwndDetailPage = NULL;
    viewhelp.hwndHierarchyPage = NULL;
    viewhelp.pfPropertiesChanged = pfPropertiesChanged;
    viewhelp.fIgnoreUntrustedRoot = (pcvp->dwFlags & CRYPTUI_ACCEPT_DECLINE_STYLE) || 
                                    (pcvp->dwFlags & CRYPTUI_IGNORE_UNTRUSTED_ROOT);
    viewhelp.fWarnUntrustedRoot = (pcvp->dwFlags & CRYPTUI_WARN_UNTRUSTED_ROOT);
    viewhelp.fWarnRemoteTrust = (pcvp->dwFlags & CRYPTUI_WARN_REMOTE_TRUST);
    
    //
    // set the properties changed flag to FALSE initially, it will be set
    // to TRUE if the user edits properties and actually changes them
    //
    if (viewhelp.pfPropertiesChanged != NULL)
    {
        *(viewhelp.pfPropertiesChanged) = FALSE;
    }
        
    // 
    // Initialize the CCertifcateBitmap class that is used in the general page
    //
    viewhelp.pCCertBmp = new (CCertificateBmp);
    if (viewhelp.pCCertBmp == NULL)
    {
        SetLastError(E_OUTOFMEMORY);
        return FALSE;
    }

    //
    // this will calculate the initial usages that the cert in question is allowed
    //
    BuildChain(&viewhelp, NULL);

    //
    // set the BOOL that turns COM off if the special flag is set
    //
    viewhelp.fNoCOM = (pcvp->dwFlags & SPECIAL_NO_COM_FLAG);
        
    //
    //  Build up the list of pages we are going to use in the dialog
    //
    ppage = (PROPSHEETPAGEW *) malloc((cPages+pcvp->cPropSheetPages) * sizeof(PROPSHEETPAGEW));
    if (ppage == NULL) {
        SetLastError(E_OUTOFMEMORY);
        goto Exit;
    }
    
    memset(ppage, 0, (cPages+pcvp->cPropSheetPages) * sizeof(PROPSHEETPAGEW));

    ppage[0].dwSize = sizeof(ppage[0]);
    ppage[0].dwFlags = 0;
    ppage[0].hInstance = HinstDll;
    ppage[0].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_CERTPROP_GENERAL);
    ppage[0].hIcon = 0;
    ppage[0].pszTitle = NULL;
    ppage[0].pfnDlgProc = ViewPageGeneral;
    ppage[0].lParam = (LPARAM) &viewhelp;
    ppage[0].pfnCallback = 0;
    ppage[0].pcRefParent = NULL;
    cPages = 1;

    if (!(pcvp->dwFlags & CRYPTUI_HIDE_DETAILPAGE)) {
        ppage[cPages].dwSize = sizeof(ppage[0]);
        ppage[cPages].dwFlags = 0;
        ppage[cPages].hInstance = HinstDll;
        ppage[cPages].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_CERTPROP_DETAILS);
        ppage[cPages].hIcon = 0;
        ppage[cPages].pszTitle = NULL;
        ppage[cPages].pfnDlgProc = ViewPageDetails;
        ppage[cPages].lParam = (LPARAM) &viewhelp;
        ppage[cPages].pfnCallback = 0;
        ppage[cPages].pcRefParent = NULL;
        cPages += 1;
    }
    
    if (!(pcvp->dwFlags & CRYPTUI_HIDE_HIERARCHYPAGE) &&
        !(pcvp->dwFlags & CRYPTUI_ACCEPT_DECLINE_STYLE)) {
        ppage[cPages].dwSize = sizeof(ppage[0]);
        ppage[cPages].dwFlags = 0;
        ppage[cPages].hInstance = HinstDll;
        ppage[cPages].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_CERTPROP_HIERARCHY);
        ppage[cPages].hIcon = 0;
        ppage[cPages].pszTitle = NULL;
        ppage[cPages].pfnDlgProc = ViewPageHierarchy;
        ppage[cPages].lParam = (LPARAM) &viewhelp;
        ppage[cPages].pfnCallback = 0;
        ppage[cPages].pcRefParent = NULL;
        cPages += 1;
    }

	cDefaultPages = (UINT) cPages;

    //
    //  Copy over the users pages
    //
    memcpy(&ppage[cPages], pcvp->rgPropSheetPages,
           pcvp->cPropSheetPages * sizeof(PROPSHEETPAGEW));

    //
    // set the lParam for each of the callers property pages to 
    // be a pointer to a CRYPTUI_INITDIALOG_STRUCT structure
    //
    for (i=0; i<pcvp->cPropSheetPages; i++)
    {
        pInitDlgStruct = (CRYPTUI_INITDIALOG_STRUCT *) malloc(sizeof(CRYPTUI_INITDIALOG_STRUCT));
        if (pInitDlgStruct == NULL)
        {   
            SetLastError(E_OUTOFMEMORY);
            return FALSE;
        }
        pInitDlgStruct->lParam = pcvp->rgPropSheetPages[i].lParam;
        pInitDlgStruct->pCertContext = pcvp->pCertContext;
        ppage[cPages].lParam = (LPARAM) pInitDlgStruct;
        cPages++;
    }

    if (FIsWin95) {

        PROPSHEETHEADERA    hdr;
        
        memset(&hdr, 0, sizeof(hdr));
        hdr.dwSize = sizeof(hdr);
        hdr.dwFlags = PSH_USECALLBACK | PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
        hdr.hwndParent = (pcvp->hwndParent != NULL) ? pcvp->hwndParent : GetDesktopWindow();
        hdr.hInstance = HinstDll;
        hdr.hIcon = NULL;
        if (pcvp->szTitle != NULL) {
            hdr.pszCaption = CertUIMkMBStr(pcvp->szTitle);
        }
        else {
            LoadStringA(HinstDll, IDS_VIEW_TITLE, rgch, sizeof(rgch));
            hdr.pszCaption = (LPSTR) rgch;
        }
        hdr.nPages = cPages;
        hdr.nStartPage = (pcvp->nStartPage & 0x8000) ? ((UINT)(pcvp->nStartPage & ~0x8000)) + cDefaultPages : pcvp->nStartPage;
        hdr.ppsp = ConvertToPropPageA(ppage, cPages);
        if (hdr.ppsp == NULL)
        {
            if ((pcvp->szTitle != NULL) && (hdr.pszCaption != NULL))
            {
                free((void *)hdr.pszCaption);
            }            
            goto Exit;
        }
        hdr.pfnCallback = HidePropSheetCancelButtonCallback;

        ret = CryptUIPropertySheetA(&hdr);

        if ((pcvp->szTitle != NULL) && (hdr.pszCaption != NULL))
        {
            free((void *)hdr.pszCaption);
        }

        FreePropSheetPagesA((PROPSHEETPAGEA *) hdr.ppsp, cPages);

   }
   else 
   {
        PROPSHEETHEADERW     hdr;

        memset(&hdr, 0, sizeof(hdr));
        hdr.dwSize = sizeof(hdr);
        hdr.dwFlags = PSH_USECALLBACK | PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
        hdr.hwndParent = (pcvp->hwndParent != NULL) ? pcvp->hwndParent : GetDesktopWindow();
        hdr.hInstance = HinstDll;
        hdr.hIcon = NULL;
        if (pcvp->szTitle != NULL) {
            hdr.pszCaption = pcvp->szTitle;
        }
        else {
            LoadStringW(HinstDll, IDS_VIEW_TITLE, rgwch, ARRAYSIZE(rgwch));
            hdr.pszCaption = rgwch;
        }
        hdr.nPages = cPages;
        hdr.nStartPage = (pcvp->nStartPage & 0x8000) ? ((UINT)(pcvp->nStartPage & ~0x8000)) + cDefaultPages : pcvp->nStartPage;
        hdr.ppsp = (PROPSHEETPAGEW *) ppage;
        hdr.pfnCallback = HidePropSheetCancelButtonCallback;

        ret = CryptUIPropertySheetW(&hdr);
    }

    //
    // free the CRYPTUI_INITDIALOG_STRUCT structures
    //
    for (i=0; i<pcvp->cPropSheetPages; i++)
    {
        free((void *) ppage[i+cPages-1].lParam);
    }
    
    //
    // free the WinVerifyTrust state if we need to
    //
    if (viewhelp.fFreeWTD)
    {
        viewhelp.sWTD.dwStateAction = WTD_STATEACTION_CLOSE;
        WinVerifyTrustEx(NULL, &gAction, &viewhelp.sWTD);
    }

    //
    // free all the usages that were allocated by
    //
    for (i=0; i<viewhelp.cUsages; i++)
    {
        free(viewhelp.rgUsages[i]);
    }

    if (viewhelp.rgUsages != NULL)
    {
        free(viewhelp.rgUsages);
    }   

    if (viewhelp.pwszErrorString != NULL)
    {
        free(viewhelp.pwszErrorString);
    }

    if (viewhelp.fCancelled)
    {
        SetLastError(ERROR_CANCELLED);
    }

    fRetValue = (ret >= 1);
    
Exit:
    if (viewhelp.pCCertBmp)
        delete(viewhelp.pCCertBmp);
    if (ppage)
        free(ppage);

    if (pcvp->dwFlags & CRYPTUI_ACCEPT_DECLINE_STYLE)
        return (viewhelp.fAccept);
    else
        return fRetValue;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
CryptUIDlgViewCertificateA(PCCRYPTUI_VIEWCERTIFICATE_STRUCTA pcvp, BOOL *pfPropertiesChanged)
{
    BOOL                            fRet;
    CRYPTUI_VIEWCERTIFICATE_STRUCTW cvpW;
    
    memcpy(&cvpW, pcvp, sizeof(cvpW));
    
    if (!ConvertToPropPageW(
                pcvp->rgPropSheetPages, 
                pcvp->cPropSheetPages,
                &(cvpW.rgPropSheetPages)))
    {
        return FALSE;
    }

    cvpW.szTitle = CertUIMkWStr(pcvp->szTitle);
    
    fRet = CryptUIDlgViewCertificateW(&cvpW, pfPropertiesChanged);

    if (cvpW.szTitle != NULL)
        free((void *)cvpW.szTitle);
    FreePropSheetPagesW((LPPROPSHEETPAGEW) cvpW.rgPropSheetPages, cvpW.cPropSheetPages);

    return fRet;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI 
CryptUIDlgViewCTLW(PCCRYPTUI_VIEWCTL_STRUCTW pcvctl)
{
    int                             cPages = 2;
    BOOL                            fRetValue = FALSE;
    HRESULT                         hr;
    PROPSHEETPAGEW *                ppage = NULL;
    INT_PTR                         ret;
    WCHAR                           rgwch[100];
    CTL_VIEW_HELPER                 viewhelp;
    DWORD                           i;
    CRYPTUI_VIEWSIGNATURES_STRUCTW  cvs;
    PROPSHEETPAGEW *                prghExtraPages;
    DWORD                           cExtraPages;
    
    //  We use the common controls -- so make sure they have been loaded
    if (CommonInit() == FALSE)
    {
        return FALSE;
    }

    if (pcvctl->dwSize != sizeof(CRYPTUI_VIEWCTL_STRUCTW)) {
        SetLastError(E_INVALIDARG);
        return FALSE;
    }

    //
    memset(&viewhelp, 0, sizeof(CTL_VIEW_HELPER));
    viewhelp.pcvctl = pcvctl;
    viewhelp.hExtraStore = CertOpenStore(
                                    CERT_STORE_PROV_MSG, 
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
                                    NULL, 
                                    NULL,
                                    (const void *) pcvctl->pCTLContext->hCryptMsg);
    
    //
    //  Build up the list of pages we are going to use in the dialog
    //
    ppage = (PROPSHEETPAGEW *) malloc((cPages+pcvctl->cPropSheetPages) * sizeof(PROPSHEETPAGEW));
    if (ppage == NULL) {
        goto Exit;
    }
    
    memset(ppage, 0, (cPages+pcvctl->cPropSheetPages) * sizeof(PROPSHEETPAGEW));

    ppage[0].dwSize = sizeof(ppage[0]);
    ppage[0].dwFlags = 0;
    ppage[0].hInstance = HinstDll;
    ppage[0].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_CTL_GENERAL);
    ppage[0].hIcon = 0;
    ppage[0].pszTitle = NULL;
    ppage[0].pfnDlgProc = ViewPageCTLGeneral;
    ppage[0].lParam = (LPARAM) &viewhelp;
    ppage[0].pfnCallback = 0;
    ppage[0].pcRefParent = NULL;
    cPages = 1;

    //
    // if the subject usage is for a catalog file, then display that page instead of CTL page
    //
    if (fIsCatalogFile(&(pcvctl->pCTLContext->pCtlInfo->SubjectUsage)))
    {
        ppage[cPages].dwSize = sizeof(ppage[0]);
        ppage[cPages].dwFlags = 0;
        ppage[cPages].hInstance = HinstDll;
        ppage[cPages].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_CATALOGFILE);
        ppage[cPages].hIcon = 0;
        ppage[cPages].pszTitle = NULL;
        ppage[cPages].pfnDlgProc = ViewPageCatalogEntries;
        ppage[cPages].lParam = (LPARAM) &viewhelp;
        ppage[cPages].pfnCallback = 0;
        ppage[cPages].pcRefParent = NULL;
        cPages += 1;
    }
    else
    {
        if (!(pcvctl->dwFlags & CRYPTUI_HIDE_TRUSTLIST_PAGE)) 
        {
            ppage[cPages].dwSize = sizeof(ppage[0]);
            ppage[cPages].dwFlags = 0;
            ppage[cPages].hInstance = HinstDll;
            ppage[cPages].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_CTL_TRUSTLIST);
            ppage[cPages].hIcon = 0;
            ppage[cPages].pszTitle = NULL;
            ppage[cPages].pfnDlgProc = ViewPageCTLTrustList;
            ppage[cPages].lParam = (LPARAM) &viewhelp;
            ppage[cPages].pfnCallback = 0;
            ppage[cPages].pcRefParent = NULL;
            cPages += 1;
        }
    }

    //
    //  Copy over the users pages
    //
    memcpy(&ppage[cPages], pcvctl->rgPropSheetPages,
           pcvctl->cPropSheetPages * sizeof(PROPSHEETPAGEW));
    cPages += pcvctl->cPropSheetPages;

    if (FIsWin95) 
    {

        PROPSHEETHEADERA     hdr;

        memset(&hdr, 0, sizeof(hdr));
        hdr.dwSize = sizeof(hdr);
        hdr.dwFlags = PSH_USECALLBACK | PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
        hdr.hwndParent = (pcvctl->hwndParent != NULL) ? pcvctl->hwndParent : GetDesktopWindow();
        hdr.hInstance = HinstDll;
        hdr.hIcon = NULL;
        if (pcvctl->szTitle != NULL) 
        {
            hdr.pszCaption = CertUIMkMBStr(pcvctl->szTitle);
        }
        else if (fIsCatalogFile(&(pcvctl->pCTLContext->pCtlInfo->SubjectUsage)))
        {   
            LoadStringA(HinstDll, IDS_CATALOG_TITLE, (LPSTR) rgwch, ARRAYSIZE(rgwch));
            hdr.pszCaption = (LPSTR) rgwch;
        }
        else
        {
            LoadStringA(HinstDll, IDS_CTLVIEW_TITLE, (LPSTR) rgwch, ARRAYSIZE(rgwch));
            hdr.pszCaption = (LPSTR) rgwch;
        }
        hdr.nPages = cPages;
        hdr.nStartPage = 0;
        hdr.ppsp = ConvertToPropPageA(ppage, cPages);
        if (hdr.ppsp == NULL)
        {
            if ((pcvctl->szTitle != NULL) && (hdr.pszCaption != NULL))
            {
                free((void *)hdr.pszCaption);
            }            
            goto Exit;
        }
        hdr.pfnCallback = HidePropSheetCancelButtonCallback;

        ret = CryptUIPropertySheetA(&hdr);

        if ((pcvctl->szTitle != NULL) && (hdr.pszCaption != NULL))
        {
            free((void *)hdr.pszCaption);
        }

        FreePropSheetPagesA((PROPSHEETPAGEA *) hdr.ppsp, cPages);

   }
   else {
        PROPSHEETHEADERW     hdr;

        memset(&hdr, 0, sizeof(hdr));
        hdr.dwSize = sizeof(hdr);
        hdr.dwFlags = PSH_USECALLBACK | PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
        hdr.hwndParent = (pcvctl->hwndParent != NULL) ? pcvctl->hwndParent : GetDesktopWindow();
        hdr.hInstance = HinstDll;
        hdr.hIcon = NULL;
        if (pcvctl->szTitle != NULL) 
        {
            hdr.pszCaption = pcvctl->szTitle;
        }
        else if (fIsCatalogFile(&(pcvctl->pCTLContext->pCtlInfo->SubjectUsage)))
        {
            LoadStringW(HinstDll, IDS_CATALOG_TITLE, rgwch, ARRAYSIZE(rgwch));
            hdr.pszCaption = rgwch;
        }
        else 
        {
            LoadStringW(HinstDll, IDS_CTLVIEW_TITLE, rgwch, ARRAYSIZE(rgwch));
            hdr.pszCaption = rgwch;
        }
        hdr.nPages = cPages;
        hdr.nStartPage = 0;
        hdr.ppsp = (PROPSHEETPAGEW *) ppage;
        hdr.pfnCallback = HidePropSheetCancelButtonCallback;

        ret = CryptUIPropertySheetW(&hdr);
    }

    CertCloseStore(viewhelp.hExtraStore, 0);

    if (viewhelp.fCancelled)
    {
        SetLastError(ERROR_CANCELLED);
    }

    fRetValue = (ret >= 1);
    
Exit:
    if (ppage)
        free(ppage);
    return fRetValue;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI 
CryptUIDlgViewCTLA(PCCRYPTUI_VIEWCTL_STRUCTA pcvctl)
{
    BOOL                    fRet;
    CRYPTUI_VIEWCTL_STRUCTW cvctlW;
    
    memcpy(&cvctlW, pcvctl, sizeof(cvctlW));
    
    if (!ConvertToPropPageW(
                pcvctl->rgPropSheetPages, 
                pcvctl->cPropSheetPages,
                &(cvctlW.rgPropSheetPages)))
    {
        return FALSE;
    }

    cvctlW.szTitle = CertUIMkWStr(pcvctl->szTitle);
    
    fRet = CryptUIDlgViewCTLW(&cvctlW);

    if (cvctlW.szTitle != NULL)
        free((void *)cvctlW.szTitle);
    FreePropSheetPagesW((LPPROPSHEETPAGEW) cvctlW.rgPropSheetPages, cvctlW.cPropSheetPages);
    
    return fRet;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI 
CryptUIDlgViewCRLW(PCCRYPTUI_VIEWCRL_STRUCTW pcvcrl)
{
    int                 cPages = 2;
    BOOL                fRetValue = FALSE;
    HRESULT             hr;
    PROPSHEETPAGEW *    ppage = NULL;
    INT_PTR             ret;
    WCHAR               rgwch[CRYPTUI_MAX_STRING_SIZE];
    CRL_VIEW_HELPER     viewhelp;
    DWORD               i;
    
    //  We use the common controls -- so make sure they have been loaded
    if (CommonInit() == FALSE)
    {
        return FALSE;
    }

    if (pcvcrl->dwSize != sizeof(CRYPTUI_VIEWCRL_STRUCTW)) {
        SetLastError(E_INVALIDARG);
        return FALSE;
    }

    //
    memset(&viewhelp, 0, sizeof(CRL_VIEW_HELPER));
    viewhelp.pcvcrl = pcvcrl;

    //
    //  Build up the list of pages we are going to use in the dialog
    //

    ppage = (PROPSHEETPAGEW *) malloc((cPages+pcvcrl->cPropSheetPages) * sizeof(PROPSHEETPAGEW));
    if (ppage == NULL) {
        goto Exit;
    }
    
    memset(ppage, 0, (cPages+pcvcrl->cPropSheetPages) * sizeof(PROPSHEETPAGEW));

    ppage[0].dwSize = sizeof(ppage[0]);
    ppage[0].dwFlags = 0;
    ppage[0].hInstance = HinstDll;
    ppage[0].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_CRL_GENERAL);
    ppage[0].hIcon = 0;
    ppage[0].pszTitle = NULL;
    ppage[0].pfnDlgProc = ViewPageCRLGeneral;
    ppage[0].lParam = (LPARAM) &viewhelp;
    ppage[0].pfnCallback = 0;
    ppage[0].pcRefParent = NULL;
    cPages = 1;

    if (!(pcvcrl->dwFlags & CRYPTUI_HIDE_REVOCATIONLIST_PAGE)) {
        ppage[cPages].dwSize = sizeof(ppage[0]);
        ppage[cPages].dwFlags = 0;
        ppage[cPages].hInstance = HinstDll;
        ppage[cPages].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_CRL_REVOCATIONLIST);
        ppage[cPages].hIcon = 0;
        ppage[cPages].pszTitle = NULL;
        ppage[cPages].pfnDlgProc = ViewPageCRLRevocationList;
        ppage[cPages].lParam = (LPARAM) &viewhelp;
        ppage[cPages].pfnCallback = 0;
        ppage[cPages].pcRefParent = NULL;
        cPages += 1;
    }
    
    //
    //  Copy over the users pages
    //

    memcpy(&ppage[cPages], pcvcrl->rgPropSheetPages,
           pcvcrl->cPropSheetPages * sizeof(PROPSHEETPAGEW));
    cPages += pcvcrl->cPropSheetPages;

    if (FIsWin95) {

        PROPSHEETHEADERA     hdr;

        memset(&hdr, 0, sizeof(hdr));
        hdr.dwSize = sizeof(hdr);
        hdr.dwFlags = PSH_USECALLBACK | PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
        hdr.hwndParent = (pcvcrl->hwndParent != NULL) ? pcvcrl->hwndParent : GetDesktopWindow();
        hdr.hInstance = HinstDll;
        hdr.hIcon = NULL;
        if (pcvcrl->szTitle != NULL) {
            hdr.pszCaption = CertUIMkMBStr(pcvcrl->szTitle);
        }
        else {
            LoadStringA(HinstDll, IDS_CRLVIEW_TITLE, (LPSTR) rgwch, ARRAYSIZE(rgwch));
            hdr.pszCaption = (LPSTR) rgwch;
        }
        hdr.nPages = cPages;
        hdr.nStartPage = 0;
        hdr.ppsp = ConvertToPropPageA(ppage, cPages);
        if (hdr.ppsp == NULL)
        {
            if ((pcvcrl->szTitle != NULL) && (hdr.pszCaption != NULL))
            {
                free((void *)hdr.pszCaption);
            }            
            goto Exit;
        }
        hdr.pfnCallback = HidePropSheetCancelButtonCallback;

        ret = CryptUIPropertySheetA(&hdr);

        if ((pcvcrl->szTitle != NULL) && (hdr.pszCaption != NULL))
        {
            free((void *)hdr.pszCaption);
        }

        FreePropSheetPagesA((PROPSHEETPAGEA *) hdr.ppsp, cPages);

   }
   else {
        PROPSHEETHEADERW     hdr;

        memset(&hdr, 0, sizeof(hdr));
        hdr.dwSize = sizeof(hdr);
        hdr.dwFlags = PSH_USECALLBACK | PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
        hdr.hwndParent = (pcvcrl->hwndParent != NULL) ? pcvcrl->hwndParent : GetDesktopWindow();
        hdr.hInstance = HinstDll;
        hdr.hIcon = NULL;
        if (pcvcrl->szTitle != NULL) {
            hdr.pszCaption = pcvcrl->szTitle;
        }
        else {
            LoadStringW(HinstDll, IDS_CRLVIEW_TITLE, rgwch, ARRAYSIZE(rgwch));
            hdr.pszCaption = rgwch;
        }
        hdr.nPages = cPages;
        hdr.nStartPage = 0;
        hdr.ppsp = (PROPSHEETPAGEW *) ppage;
        hdr.pfnCallback = HidePropSheetCancelButtonCallback;

        ret = CryptUIPropertySheetW(&hdr);
    }

    if (viewhelp.fCancelled)
    {
        SetLastError(ERROR_CANCELLED);
    }

    fRetValue = (ret >= 1);
    
Exit:
    if (ppage)
        free(ppage);
    return fRetValue;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI 
CryptUIDlgViewCRLA(PCCRYPTUI_VIEWCRL_STRUCTA pcvcrl)
{
    BOOL                    fRet;
    CRYPTUI_VIEWCRL_STRUCTW cvcrlW;
    
    memcpy(&cvcrlW, pcvcrl, sizeof(cvcrlW));
    
    if (!ConvertToPropPageW(
                pcvcrl->rgPropSheetPages, 
                pcvcrl->cPropSheetPages,
                &(cvcrlW.rgPropSheetPages)))
    {
        return FALSE;
    }

    cvcrlW.szTitle = CertUIMkWStr(pcvcrl->szTitle);
    
    fRet = CryptUIDlgViewCRLW(&cvcrlW);

    if (cvcrlW.szTitle != NULL)
        free((void *)cvcrlW.szTitle);
    FreePropSheetPagesW((LPPROPSHEETPAGEW) cvcrlW.rgPropSheetPages, cvcrlW.cPropSheetPages);
    
    return fRet;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI 
CryptUIDlgViewSignerInfoW(PCCRYPTUI_VIEWSIGNERINFO_STRUCTW pcvsi)
{
    int                 cPages = 2;
    BOOL                fRetValue = FALSE;
    HRESULT             hr;
    PROPSHEETPAGEW *    ppage = NULL;
    INT_PTR             ret;
    WCHAR               rgwch[CRYPTUI_MAX_STRING_SIZE];
    SIGNER_VIEW_HELPER  viewhelp;
    DWORD               i;
    
    //  We use the common controls -- so make sure they have been loaded
    if (CommonInit() == FALSE)
    {
        return FALSE;
    }

    if (pcvsi->dwSize != sizeof(CRYPTUI_VIEWSIGNERINFO_STRUCTW)) {
        SetLastError(E_INVALIDARG);
        return FALSE;
    }

    //
    memset(&viewhelp, 0, sizeof(SIGNER_VIEW_HELPER));
    viewhelp.pcvsi = pcvsi;
    if (pcvsi->dwFlags & CRYPTUI_VIEWSIGNERINFO_RESERVED_FIELD_IS_SIGNERINFO_PRIVATE)
    {
        viewhelp.pPrivate = (PCERT_VIEWSIGNERINFO_PRIVATE) pcvsi->dwReserved;
    }
    else if (pcvsi->dwFlags & CRYPTUI_VIEWSIGNERINFO_RESERVED_FIELD_IS_ERROR_CODE)
    {
        viewhelp.dwInheritedError = (DWORD) pcvsi->dwReserved;
    }
    viewhelp.fPrivateAllocated = FALSE;
    viewhelp.hExtraStore = CertOpenStore(
                                    CERT_STORE_PROV_MSG, 
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
                                    NULL, 
                                    NULL,
                                    (const void *) pcvsi->hMsg);
    if (NULL == viewhelp.hExtraStore) 
    {
        return FALSE;
    }
    
    //
    //  Build up the list of pages we are going to use in the dialog
    //

    ppage = (PROPSHEETPAGEW *) malloc((cPages+pcvsi->cPropSheetPages) * sizeof(PROPSHEETPAGEW));
    if (ppage == NULL) {
        goto Exit;
    }
    
    memset(ppage, 0, (cPages+pcvsi->cPropSheetPages) * sizeof(PROPSHEETPAGEW));

    ppage[0].dwSize = sizeof(ppage[0]);
    ppage[0].dwFlags = 0;
    ppage[0].hInstance = HinstDll;
    ppage[0].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_SIGNER_GENERAL_DIALOG);
    ppage[0].hIcon = 0;
    ppage[0].pszTitle = NULL;
    ppage[0].pfnDlgProc = ViewPageSignerGeneral;
    ppage[0].lParam = (LPARAM) &viewhelp;
    ppage[0].pfnCallback = 0;
    ppage[0].pcRefParent = NULL;
    cPages = 1;

    if (!(pcvsi->dwFlags & CRYPTUI_HIDE_TRUSTLIST_PAGE)) {
        ppage[cPages].dwSize = sizeof(ppage[0]);
        ppage[cPages].dwFlags = 0;
        ppage[cPages].hInstance = HinstDll;
        ppage[cPages].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_SIGNER_ADVANCED_DIALOG);
        ppage[cPages].hIcon = 0;
        ppage[cPages].pszTitle = NULL;
        ppage[cPages].pfnDlgProc = ViewPageSignerAdvanced;
        ppage[cPages].lParam = (LPARAM) &viewhelp;
        ppage[cPages].pfnCallback = 0;
        ppage[cPages].pcRefParent = NULL;
        cPages += 1;
    }
    
    //
    //  Copy over the users pages
    //

    memcpy(&ppage[cPages], pcvsi->rgPropSheetPages,
           pcvsi->cPropSheetPages * sizeof(PROPSHEETPAGEW));
    cPages += pcvsi->cPropSheetPages;

    if (FIsWin95) {

        PROPSHEETHEADERA     hdr;

        memset(&hdr, 0, sizeof(hdr));
        hdr.dwSize = sizeof(hdr);
        hdr.dwFlags = PSH_USECALLBACK | PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
        hdr.hwndParent = (pcvsi->hwndParent != NULL) ? pcvsi->hwndParent : GetDesktopWindow();
        hdr.hInstance = HinstDll;
        hdr.hIcon = NULL;
        if (pcvsi->szTitle != NULL) {
            hdr.pszCaption = CertUIMkMBStr(pcvsi->szTitle);
        }
        else {
            LoadStringA(HinstDll, IDS_SIGNERVIEW_TITLE, (LPSTR) rgwch, ARRAYSIZE(rgwch));
            hdr.pszCaption = (LPSTR) rgwch;
        }
        hdr.nPages = cPages;
        hdr.nStartPage = 0;
        hdr.ppsp = ConvertToPropPageA(ppage, cPages);
        if (hdr.ppsp == NULL)
        {
            if ((pcvsi->szTitle != NULL) && (hdr.pszCaption != NULL))
            {
                free((void *)hdr.pszCaption);
            }            
            goto Exit;
        }
        hdr.pfnCallback = HidePropSheetCancelButtonCallback;

        ret = CryptUIPropertySheetA(&hdr);

        if ((pcvsi->szTitle != NULL) && (hdr.pszCaption != NULL))
        {
            free((void *)hdr.pszCaption);
        }

        FreePropSheetPagesA((PROPSHEETPAGEA *) hdr.ppsp, cPages);

   }
   else {
        PROPSHEETHEADERW     hdr;

        memset(&hdr, 0, sizeof(hdr));
        hdr.dwSize = sizeof(hdr);
        hdr.dwFlags = PSH_USECALLBACK | PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
        hdr.hwndParent = (pcvsi->hwndParent != NULL) ? pcvsi->hwndParent : GetDesktopWindow();
        hdr.hInstance = HinstDll;
        hdr.hIcon = NULL;
        if (pcvsi->szTitle != NULL) {
            hdr.pszCaption = pcvsi->szTitle;
        }
        else {
            LoadStringW(HinstDll, IDS_SIGNERVIEW_TITLE, rgwch, ARRAYSIZE(rgwch));
            hdr.pszCaption = rgwch;
        }
        hdr.nPages = cPages;
        hdr.nStartPage = 0;
        hdr.ppsp = (PROPSHEETPAGEW *) ppage;
        hdr.pfnCallback = HidePropSheetCancelButtonCallback;

        ret = CryptUIPropertySheetW(&hdr);
    }
   
    CertCloseStore(viewhelp.hExtraStore, 0);

    if (viewhelp.fCancelled)
    {
        SetLastError(ERROR_CANCELLED);
    }

    fRetValue = (ret >= 1);
    
Exit:
    
    if (ppage)
        free(ppage);
    return fRetValue;
}


//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI 
CryptUIDlgViewSignerInfoA(PCCRYPTUI_VIEWSIGNERINFO_STRUCTA pcvsi)
{
    BOOL                            fRet;
    CRYPTUI_VIEWSIGNERINFO_STRUCTW  cvsiW;
    
    memcpy(&cvsiW, pcvsi, sizeof(cvsiW));
    
    if (!ConvertToPropPageW(
                pcvsi->rgPropSheetPages, 
                pcvsi->cPropSheetPages,
                &(cvsiW.rgPropSheetPages)))
    {
        return FALSE;
    }

    cvsiW.szTitle = CertUIMkWStr(pcvsi->szTitle);
    
    fRet = CryptUIDlgViewSignerInfoW(&cvsiW);

    if (cvsiW.szTitle)
        free((void *)cvsiW.szTitle);
    FreePropSheetPagesW((LPPROPSHEETPAGEW) cvsiW.rgPropSheetPages, cvsiW.cPropSheetPages);
    
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\cryptui\viewsigs.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       viewsigs.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>


extern HINSTANCE        HinstDll;
extern HMODULE          HmodRichEdit;

static const HELPMAP helpmap[] = {
    {IDC_SIGNATURES_SIG_LIST,		IDH_DIGSIG_PROPSHEET_LIST},
	{IDC_SIGNATURES_DETAILS_BUTTON, IDH_DIGSIG_PROPSHEET_DETAIL}
};

//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static PCRYPTUI_VIEWSIGNATURES_STRUCTW AllocAndCopyViewSignaturesStruct(PCCRYPTUI_VIEWSIGNATURES_STRUCTW pcvs)
{
    PCRYPTUI_VIEWSIGNATURES_STRUCTW pStruct;
    DWORD i;

    if (NULL == (pStruct = (PCRYPTUI_VIEWSIGNATURES_STRUCTW) malloc(sizeof(CRYPTUI_VIEWSIGNATURES_STRUCTW))))
    {
        return NULL;
    }
    memcpy(pStruct, pcvs, sizeof(CRYPTUI_VIEWSIGNATURES_STRUCTW));

    if (pcvs->szFileName != NULL)
    {
        if (NULL == (pStruct->szFileName = AllocAndCopyWStr((LPWSTR) pcvs->szFileName)))
        {
            free(pStruct);
            return NULL;
        }
    }

    if (NULL == (pStruct->rghStores = (HCERTSTORE *) malloc(sizeof(HCERTSTORE)*pcvs->cStores)))
    {
        if (pStruct->szFileName)
        {
            free((void *) pStruct->szFileName);
        }
        free(pStruct);
        return NULL;
    }

    if (pcvs->choice == EncodedMessage_Chosen)
    {
        if (NULL == (pStruct->u.EncodedMessage.pbData = (BYTE *) malloc(pcvs->u.EncodedMessage.cbData)))
        {
            free(pStruct->rghStores);
            if (pStruct->szFileName)
            {
                free((void *) pStruct->szFileName);
            }
            free(pStruct);
            return NULL;
        }
        memcpy(
            pStruct->u.EncodedMessage.pbData,
            pcvs->u.EncodedMessage.pbData,
            pcvs->u.EncodedMessage.cbData);
    }
    else
    {
        pStruct->u.hMsg = CryptMsgDuplicate(pcvs->u.hMsg);
    }

    pStruct->cPropSheetPages = 0;
    pStruct->rgPropSheetPages = NULL;

    for (i=0; i<pcvs->cStores; i++)
    {
        pStruct->rghStores[i] = CertDuplicateStore(pcvs->rghStores[i]);
    }

    return pStruct;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void FreeViewSignaturesStruct(PCRYPTUI_VIEWSIGNATURES_STRUCTW pcvs)
{
    DWORD i;

    if (pcvs->choice == EncodedMessage_Chosen)
    {
        free(pcvs->u.EncodedMessage.pbData);
    }
    else
    {
        CryptMsgClose(pcvs->u.hMsg);
    }

    if (pcvs->szFileName)
    {
        free((void *) pcvs->szFileName);
    }

    for (i=0; i<pcvs->cStores; i++)
    {
        CertCloseStore(pcvs->rghStores[i], 0);
    }

    free(pcvs->rghStores);
    free(pcvs);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static PCMSG_SIGNER_INFO GetSignerInfo(HCRYPTMSG hMsg, DWORD index)
{

    DWORD               cbEncodedSigner = 0;
    BYTE                *pbEncodedSigner = NULL;
    PCMSG_SIGNER_INFO   pSignerInfo = NULL;
    DWORD               cbSignerInfo = 0;

    //
    // get the encoded signer BLOB
    //
    CryptMsgGetParam(hMsg,
                     CMSG_ENCODED_SIGNER,
                     index,
                     NULL,
                     &cbEncodedSigner);

    if (cbEncodedSigner == 0)
    {
        return NULL;
    }

    if (NULL == (pbEncodedSigner = (PBYTE) malloc(cbEncodedSigner)))
    {
        return NULL;
    }

    if (!CryptMsgGetParam(hMsg,
                          CMSG_ENCODED_SIGNER,
                          index,
                          pbEncodedSigner,
                          &cbEncodedSigner))
    {
        free(pbEncodedSigner);
        return NULL;
    }

    //
    // decode the EncodedSigner info
    //
    if(!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
					    PKCS7_SIGNER_INFO,
					    pbEncodedSigner,
					    cbEncodedSigner,
					    0,
					    NULL,
					    &cbSignerInfo))
    {
        free(pbEncodedSigner);
        return NULL;
    }
	

    if (NULL == (pSignerInfo = (PCMSG_SIGNER_INFO) malloc(cbSignerInfo)))
    {
        free(pbEncodedSigner);
        return NULL;
    }

    if (!CryptDecodeObject(PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
					    PKCS7_SIGNER_INFO,
					    pbEncodedSigner,
					    cbEncodedSigner,
					    0,
					    pSignerInfo,
					    &cbSignerInfo))
    {
        free(pbEncodedSigner);
        free(pSignerInfo);
        return NULL;
    }

    free(pbEncodedSigner);
    return(pSignerInfo);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void DisplaySignatures(HWND hWndListView, PCERT_VIEWSIGNATURES_HELPER pviewhelp)
{
    PCMSG_SIGNER_INFO   pSignerInfo;
    DWORD               cbCounterSignerInfo;
    PCCERT_CONTEXT      pCertContext = NULL;
    DWORD               i;
    WCHAR               szNameText[CRYPTUI_MAX_STRING_SIZE];
    WCHAR               szEmailText[CRYPTUI_MAX_STRING_SIZE];
    LV_ITEMW            lvI;
    int                 itemIndex = 0;
    LPWSTR              pszTimeText;
    HCRYPTMSG           hMsg;

    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    memset(&lvI, 0, sizeof(lvI));
    lvI.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.pszText = szNameText;

    //
    // If the encoded message was passed in the use CryptMsg to crack the encoded PKCS7 Signed Message
    //
    if (pviewhelp->pcvs->choice == EncodedMessage_Chosen)
    {
        if (!(hMsg = CryptMsgOpenToDecode(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                          0,
                                          0,
                                          0,
                                          NULL,
                                          NULL)))
        {
            return;
        }

        if (!CryptMsgUpdate(hMsg,
                            pviewhelp->pcvs->u.EncodedMessage.pbData,
                            pviewhelp->pcvs->u.EncodedMessage.cbData,
                            TRUE))                    // fFinal
        {
            CryptMsgClose(hMsg);
            return;
        }
    }
    else
    {
        hMsg = pviewhelp->pcvs->u.hMsg;
    }

    //
    // get the signer info struct for each signer
    //
    i = 0;
    while (NULL != (pSignerInfo = GetSignerInfo(hMsg, i++)))
    {
        //
        // find the signers cert
        //
        pCertContext = GetSignersCert(
                            pSignerInfo,
                            pviewhelp->hExtraStore,
                            pviewhelp->pcvs->cStores,
                            pviewhelp->pcvs->rghStores);

        //
        // get the signers name
        //
        if (!(pCertContext && CertGetNameStringW(
                                        pCertContext,
                                        CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                        0,//CERT_NAME_ISSUER_FLAG,
                                        NULL,
                                        szNameText,
                                        ARRAYSIZE(szNameText))))
        {
            LoadStringU(HinstDll, IDS_NOTAVAILABLE, szNameText, ARRAYSIZE(szNameText));
        }

        //
        // get the signers email
        //
        if (!(pCertContext && (CertGetNameStringW(
                                        pCertContext,
                                        CERT_NAME_EMAIL_TYPE,
                                        0,//CERT_NAME_ISSUER_FLAG,
                                        NULL,
                                        szEmailText,
                                        ARRAYSIZE(szEmailText)) != 1)))
        {
            LoadStringU(HinstDll, IDS_NOTAVAILABLE, szEmailText, ARRAYSIZE(szEmailText));
        }

        pszTimeText = AllocAndReturnTimeStampersTimes(pSignerInfo, NULL, hWndListView);

        //
        // add the item to the list view
        //
        lvI.iSubItem = 0;
        lvI.cchTextMax = wcslen(szNameText);
        lvI.lParam = (LPARAM) pSignerInfo;
        lvI.iItem = itemIndex++;
        ListView_InsertItemU(hWndListView, &lvI);
        ListView_SetItemTextU(hWndListView, itemIndex-1 , 1, szEmailText);

        if (pszTimeText != NULL)
        {
            ListView_SetItemTextU(hWndListView, itemIndex-1 , 2, pszTimeText);
            free(pszTimeText);
        }
        else
        {
            LoadStringU(HinstDll, IDS_NOTAVAILABLE, szEmailText, ARRAYSIZE(szEmailText));
            ListView_SetItemTextU(hWndListView, itemIndex-1 , 2, szEmailText);
        }
    }

    if (pviewhelp->pcvs->choice == EncodedMessage_Chosen)
    {
        CryptMsgClose(hMsg);
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL fUseCTLSigning(PCERT_VIEWSIGNATURES_HELPER pviewhelp)
{
    BOOL            fCTL = FALSE;
    CERT_BLOB       blob;
    PCCTL_CONTEXT   pCTLContext=NULL;
    
    if (pviewhelp->pcvs->choice == EncodedMessage_Chosen)
    {
        blob.cbData = pviewhelp->pcvs->u.EncodedMessage.cbData;
        blob.pbData = pviewhelp->pcvs->u.EncodedMessage.pbData;

        if (CryptQueryObject(
                CERT_QUERY_OBJECT_BLOB,
                &blob,
                CERT_QUERY_CONTENT_FLAG_CTL,
                CERT_QUERY_FORMAT_FLAG_ALL,
                0,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                (const void **)&pCTLContext) &&
            !fIsCatalogFile(&(pCTLContext->pCtlInfo->SubjectUsage)))
        {
            fCTL = TRUE;
        }
    }
    else
    {
        if (CryptQueryObject(
                CERT_QUERY_OBJECT_FILE,
                pviewhelp->pcvs->szFileName,
                CERT_QUERY_CONTENT_FLAG_CTL,
                CERT_QUERY_FORMAT_FLAG_ALL,
                0,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                (const void **)&pCTLContext) &&
            !fIsCatalogFile(&(pCTLContext->pCtlInfo->SubjectUsage)))
        {
            fCTL = TRUE;
        }
    }

    if(pCTLContext)
    {
        CertFreeCTLContext(pCTLContext);
    }

    return fCTL;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY ViewPageViewSignatures(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PROPSHEETPAGE *                 ps;
    PCRYPTUI_VIEWSIGNATURES_STRUCTW pcvs = NULL;
    HWND                            hWndListView;
    LV_COLUMNW                      lvC;
    LPNMLISTVIEW                    pnmv;
    PCERT_VIEWSIGNATURES_HELPER     pviewhelp;
    WCHAR                           szText[CRYPTUI_MAX_STRING_SIZE];
    int                             listIndex;
    LV_ITEMW                        lvI;
    DWORD                           i;
	HWND							hwnd;

    switch ( msg ) {
    case WM_INITDIALOG:
        //
        // save the pviewhelp struct in DWLP_USER so it can always be accessed
        //

        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = (PCERT_VIEWSIGNATURES_HELPER) ps->lParam;
        pcvs = (PCRYPTUI_VIEWSIGNATURES_STRUCTW) pviewhelp->pcvs;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (DWORD_PTR) pviewhelp);

        //
        // initially nothing is selected, so disable the details button
        //
        EnableWindow(GetDlgItem(hwndDlg, IDC_SIGNATURES_DETAILS_BUTTON), FALSE);

        //
        // get the handle of the list view control
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_SIGNATURES_SIG_LIST);

        //
        // initialize the columns in the list view
        //
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
        lvC.pszText = szText;   // The text for the column.
        lvC.iSubItem = 0;

        // Add the columns. They are loaded from a string table.
        lvC.cx = 100;
        LoadStringU(HinstDll, IDS_NAME, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(hWndListView, 0, &lvC) == -1)
        {
            // error
        }

        lvC.cx = 100;
        LoadStringU(HinstDll, IDS_EMAIL, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(hWndListView, 1, &lvC) == -1)
        {
            // error
        }

        lvC.cx = 125;
        LoadStringU(HinstDll, IDS_TIMESTAMP_TIME, szText, ARRAYSIZE(szText));
        if (ListView_InsertColumnU(hWndListView, 2, &lvC) == -1)
        {
            // error
        }

        //
        // set the style in the list view so that it highlights an entire line
        //
        SendMessageA(hWndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

        DisplaySignatures(hWndListView, pviewhelp);

        return TRUE;

    case WM_NOTIFY:

        pviewhelp = (PCERT_VIEWSIGNATURES_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcvs = (PCRYPTUI_VIEWSIGNATURES_STRUCTW) pviewhelp->pcvs;

        switch (((NMHDR FAR *) lParam)->code)
        {

        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:

            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)FALSE);
            break;

        case PSN_HELP:
            if (FIsWin95) {
                //WinHelpA(hwndDlg, (LPSTR) pcvs->szHelpFileName,
                  //       HELP_CONTEXT, pcvs->dwHelpId);
            }
            else {
                //WinHelpW(hwndDlg, pcvs->szHelpFileName, HELP_CONTEXT,
                  //       pcvs->dwHelpId);
            }
            return TRUE;

        case NM_DBLCLK:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {
            case IDC_SIGNATURES_SIG_LIST:

                if (IsWindowEnabled(GetDlgItem(hwndDlg, IDC_SIGNATURES_DETAILS_BUTTON)))
                {
                    SendMessage(
                            hwndDlg,
                            WM_COMMAND,
                            MAKELONG(IDC_SIGNATURES_DETAILS_BUTTON, BN_CLICKED),
                            (LPARAM) GetDlgItem(hwndDlg, IDC_SIGNATURES_DETAILS_BUTTON));
                }
                break;
            }

            break;

        case LVN_ITEMCHANGED:
            
            if ((((NMHDR FAR *) lParam)->idFrom) != IDC_SIGNATURES_SIG_LIST)
            {
                break;
            }

            //
            // if an item is selected, then enable the details button, otherwise
            // disable it
            //
            EnableWindow(
                GetDlgItem(hwndDlg, IDC_SIGNATURES_DETAILS_BUTTON), 
                (ListView_GetSelectedCount(
                    GetDlgItem(hwndDlg,IDC_SIGNATURES_SIG_LIST)) == 0) ? FALSE : TRUE);

            break;

        case NM_CLICK:

            if ((((NMHDR FAR *) lParam)->idFrom) != IDC_SIGNATURES_SIG_LIST)
            {
                break;
            }

            hWndListView = GetDlgItem(hwndDlg, IDC_SIGNATURES_SIG_LIST);

            //
            // make sure something is selected by getting the current selection
            //
            listIndex = ListView_GetNextItem(
                                hWndListView, 		
                                -1, 		
                                LVNI_SELECTED		
                                );	
            break;

        case  NM_SETFOCUS:

            switch (((NMHDR FAR *) lParam)->idFrom)
            {

            case IDC_SIGNATURES_SIG_LIST:
                hWndListView = GetDlgItem(hwndDlg, IDC_SIGNATURES_SIG_LIST);

                if ((ListView_GetItemCount(hWndListView) != 0) && 
                    (ListView_GetNextItem(hWndListView, -1, LVNI_SELECTED) == -1))
                {
                    memset(&lvI, 0, sizeof(lvI));
                    lvI.mask = LVIF_STATE; 
                    lvI.iItem = 0;
                    lvI.state = LVIS_FOCUSED;
                    lvI.stateMask = LVIS_FOCUSED;
                    ListView_SetItem(hWndListView, &lvI);
                }

                break;
            }
            
            break;
        }

        break;

    case WM_COMMAND:

        pviewhelp = (PCERT_VIEWSIGNATURES_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);
        pcvs = (PCRYPTUI_VIEWSIGNATURES_STRUCTW) pviewhelp->pcvs;

        switch (LOWORD(wParam))
        {

        case IDHELP:
            if (FIsWin95)
            {
                //WinHelpA(hwndDlg, (LPSTR) pcvs->szHelpFileName,
                  //       HELP_CONTEXT, pcvs->dwHelpId);
            }
            else
            {
                //WinHelpW(hwndDlg, pcvs->szHelpFileName, HELP_CONTEXT,
                  //       pcvs->dwHelpId);
            }
            return TRUE;

        case IDC_SIGNATURES_DETAILS_BUTTON:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                CRYPTUI_VIEWSIGNERINFO_STRUCTW  cvsi;
                CERT_VIEWSIGNERINFO_PRIVATE     cvsiPrivate;
                CRYPT_PROVIDER_DEFUSAGE         cryptProviderDefUsage;
                WINTRUST_DATA                   WTD;
                //BOOL                            fDefault;
                HCRYPTMSG                       hMsg;

                hWndListView = GetDlgItem(hwndDlg, IDC_SIGNATURES_SIG_LIST);

                //
                // get the selected item and its lParam which is a signer info
                //
                listIndex = ListView_GetNextItem(
                                hWndListView, 		
                                -1, 		
                                LVNI_SELECTED		
                                );	

                memset(&lvI, 0, sizeof(lvI));
                lvI.iItem = listIndex;
                lvI.mask = LVIF_PARAM;
                if (!ListView_GetItemU(hWndListView, &lvI))
                {
                    return FALSE;
                }

                //
                // If the encoded message was passed in the use CryptMsg to crack the encoded PKCS7 Signed Message
                //
                if (pviewhelp->pcvs->choice == EncodedMessage_Chosen)
                {
                    if (!(hMsg = CryptMsgOpenToDecode(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                      0,
                                                      0,
                                                      0,
                                                      NULL,
                                                      NULL)))
                    {
                        return TRUE;
                    }

                    if (!CryptMsgUpdate(hMsg,
                                        pviewhelp->pcvs->u.EncodedMessage.pbData,
                                        pviewhelp->pcvs->u.EncodedMessage.cbData,
                                        TRUE))                    // fFinal
                    {
                        CryptMsgClose(hMsg);
                        return TRUE;
                    }
                }
                else
                {
                    hMsg = pviewhelp->pcvs->u.hMsg;
                }

                memset(&cvsi, 0, sizeof(cvsi));
                cvsi.dwSize = sizeof(cvsi);
                cvsi.pSignerInfo = (PCMSG_SIGNER_INFO) lvI.lParam;
                cvsi.hwndParent = hwndDlg;
                cvsi.hMsg = hMsg;
                cvsi.pszOID = fUseCTLSigning(pviewhelp) ? szOID_KP_CTL_USAGE_SIGNING : szOID_PKIX_KP_CODE_SIGNING;
                cvsi.cStores = pcvs->cStores;
                cvsi.rghStores = pcvs->rghStores;

                //
                // if there was a file name passed in then fill out the
                // information in the private struct about which signer to display
                //
                if (pcvs->szFileName != NULL)
                {
                    BuildWinVTrustState(
                            pcvs->szFileName,
                            NULL,
                            0,
                            NULL,
                            fUseCTLSigning(pviewhelp) ? szOID_KP_CTL_USAGE_SIGNING : szOID_PKIX_KP_CODE_SIGNING,
                            &cvsiPrivate,
                            &cryptProviderDefUsage,
                            &WTD);//,
                            //&fDefault);
                    cvsiPrivate.idxSigner = listIndex;
                    cvsiPrivate.fCounterSigner = FALSE;
                    cvsiPrivate.idxCounterSigner = 0;
                    cvsiPrivate.dwInheritedError = 0;
                    cvsi.dwFlags |= CRYPTUI_VIEWSIGNERINFO_RESERVED_FIELD_IS_SIGNERINFO_PRIVATE;
                    cvsi.dwReserved = (DWORD_PTR) &cvsiPrivate;
                }

                CryptUIDlgViewSignerInfoW(&cvsi);

                if (pcvs->szFileName != NULL)
                {
                    FreeWinVTrustState(
                            pcvs->szFileName,
                            NULL,
                            0,
                            NULL,
                            szOID_PKIX_KP_CODE_SIGNING,
                            &cryptProviderDefUsage,
                            &WTD);//,
                            //&fDefault);
                }

                if (pviewhelp->pcvs->choice == EncodedMessage_Chosen)
                {
                    CryptMsgClose(hMsg);
                }
            }
            break;

        }
        break;

    case WM_DESTROY:
        LVITEMW lvItem;

        pviewhelp = (PCERT_VIEWSIGNATURES_HELPER) GetWindowLongPtr(hwndDlg, DWLP_USER);

        //
        // get all the items in the list view and free the lParam
        // associated with each of them (lParam is the helper sruct)
        //
        hWndListView = GetDlgItem(hwndDlg, IDC_SIGNATURES_SIG_LIST);

        memset(&lvI, 0, sizeof(lvI));
        lvI.iItem = ListView_GetItemCount(hWndListView) - 1;	
        lvI.mask = LVIF_PARAM;
        while (lvI.iItem >= 0)
        {
            if (ListView_GetItemU(hWndListView, &lvI))
            {
                free((void *) lvI.lParam);
            }
            lvI.iItem--;
        }

        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

		if (msg == WM_HELP)
        {
            hwnd = GetDlgItem(hwndDlg, ((LPHELPINFO)lParam)->iCtrlId);
        }
        else
        {
            hwnd = (HWND) wParam;
        }

        if ((hwnd != GetDlgItem(hwndDlg, IDC_SIGNATURES_SIG_LIST))		&&
			(hwnd != GetDlgItem(hwndDlg, IDC_SIGNATURES_DETAILS_BUTTON)))
        {
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LRESULT)TRUE);
            return TRUE;
        }
        else
        {
            return OnContextHelp(hwndDlg, msg, wParam, lParam, helpmap);
        }
        break;
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
UINT
CALLBACK
ViewSigsPropPageCallback(
                HWND                hWnd,
                UINT                uMsg,
                LPPROPSHEETPAGEW    ppsp)
{
    CERT_VIEWSIGNATURES_HELPER *pviewhelp = (CERT_VIEWSIGNATURES_HELPER *) ppsp->lParam;

    if (pviewhelp->pcvs->pPropPageCallback != NULL)
    {
        (*(pviewhelp->pcvs->pPropPageCallback))(hWnd, uMsg, pviewhelp->pcvs->pvCallbackData);
    }

    if (uMsg == PSPCB_RELEASE)
    {
        if (pviewhelp->fSelfCleanup)
        {
            if (pviewhelp->hExtraStore)
                CertCloseStore(pviewhelp->hExtraStore, 0);
            FreeViewSignaturesStruct(pviewhelp->pcvs);
            free(pviewhelp);
        }
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
CryptUIGetViewSignaturesPagesW(
            PCCRYPTUI_VIEWSIGNATURES_STRUCTW    pcvs,
            PROPSHEETPAGEW                      **prghPropPages,
            DWORD                               *pcPropPages
            )
{
    BOOL                            fRetValue = TRUE;
    HRESULT                         hr;
    WCHAR                           rgwch[CRYPTUI_MAX_STRING_SIZE];
    char                            rgch[CRYPTUI_MAX_STRING_SIZE];
    CERT_VIEWSIGNATURES_HELPER      *pviewhelp;
    PCRYPTUI_VIEWSIGNATURES_STRUCTW pNewcvs;
    CRYPT_DATA_BLOB                 EncodedMsg;

    if (pcvs->dwSize != sizeof(CRYPTUI_VIEWSIGNATURES_STRUCTW)) {
        SetLastError(E_INVALIDARG);
        return FALSE;
    }

    if (!CommonInit())
    {
        return FALSE;
    }

    if (NULL == (pNewcvs = AllocAndCopyViewSignaturesStruct(pcvs)))
    {
        return FALSE;
    }

    if (NULL == (pviewhelp = (CERT_VIEWSIGNATURES_HELPER *) malloc(sizeof(CERT_VIEWSIGNATURES_HELPER))))
    {
        FreeViewSignaturesStruct(pNewcvs);
        return FALSE;
    }

    *pcPropPages = 1;

    //
    // initialize the helper struct
    //
    memset (pviewhelp, 0, sizeof(CERT_VIEWSIGNATURES_HELPER));
    pviewhelp->pcvs = pNewcvs;
    pviewhelp->fSelfCleanup = TRUE;
    if (pcvs->choice == EncodedMessage_Chosen)
    {
        EncodedMsg.pbData = pcvs->u.EncodedMessage.pbData;
        EncodedMsg.cbData = pcvs->u.EncodedMessage.cbData;
        pviewhelp->hExtraStore = CertOpenStore(
                                        CERT_STORE_PROV_PKCS7,
                                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        NULL,
                                        NULL,
                                        (const void *) &EncodedMsg);
    }
    else
    {
        pviewhelp->hExtraStore = CertOpenStore(
                                        CERT_STORE_PROV_MSG,
                                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        NULL,
                                        NULL,
                                        (const void *) pcvs->u.hMsg);
    }

    //
    //  Build up the list of pages we are going to use in the dialog
    //

    *prghPropPages = (PROPSHEETPAGEW *) malloc((*pcPropPages) * sizeof(PROPSHEETPAGEW));
    if (*prghPropPages == NULL)
    {
        FreeViewSignaturesStruct(pNewcvs);
        return FALSE;
    }

    memset(*prghPropPages, 0, (*pcPropPages) * sizeof(PROPSHEETPAGEW));

    (*prghPropPages)[0].dwSize = sizeof((*prghPropPages)[0]);
    (*prghPropPages)[0].dwFlags = PSP_USECALLBACK;
    (*prghPropPages)[0].hInstance = HinstDll;
    (*prghPropPages)[0].pszTemplate = (LPWSTR) MAKEINTRESOURCE(IDD_SIGNATURES_GENERAL_DIALOG);
    (*prghPropPages)[0].hIcon = 0;
    (*prghPropPages)[0].pszTitle = NULL;
    (*prghPropPages)[0].pfnDlgProc = ViewPageViewSignatures;
    (*prghPropPages)[0].lParam = (LPARAM) pviewhelp;
    (*prghPropPages)[0].pfnCallback = ViewSigsPropPageCallback;
    (*prghPropPages)[0].pcRefParent = NULL;
    *pcPropPages = 1;

    return fRetValue;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
CryptUIGetViewSignaturesPagesA(
                    PCCRYPTUI_VIEWSIGNATURES_STRUCTA    pcvs,
                    PROPSHEETPAGEA                      **prghPropPages,
                    DWORD                               *pcPropPages
                    )
{
    CRYPTUI_VIEWSIGNATURES_STRUCTW  cvsW;
    BOOL                            fRet;

    memcpy(&cvsW, pcvs, sizeof(cvsW));

    if (pcvs->szFileName != NULL)
    {
        cvsW.szFileName = CertUIMkWStr(pcvs->szFileName);
    }

    fRet = (CryptUIGetViewSignaturesPagesW(
                    &cvsW,
                    (PROPSHEETPAGEW**) prghPropPages,
                    pcPropPages));

    if (cvsW.szFileName != NULL)
    {
        free((void *) cvsW.szFileName);
    }

    return(fRet);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
CryptUIFreeViewSignaturesPagesW(
                    PROPSHEETPAGEW                *rghPropPages,
                    DWORD                         cPropPages
                    )
{
    free(rghPropPages);

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI CryptUIFreeViewSignaturesPagesA(
                    PROPSHEETPAGEA                *rghPropPages,
                    DWORD                         cPropPages
                    )
{
    return (CryptUIFreeViewSignaturesPagesW((PROPSHEETPAGEW *) rghPropPages, cPropPages));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\buildctl.h ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       buildctl.h
//
//  Contents:   The private include file buildCTL wizard
//
//  History:    10-11-1997 xiaohs   created
//
//--------------------------------------------------------------
#ifndef BUILDCTL_H
#define BUILDCTL_H


#ifdef __cplusplus
extern "C" {
#endif

#include    "sipguids.h"

#define     BUILDCTL_DURATION_SIZE  33

//-----------------------------------------------------------------------
//  CERT_BUILDCTL_INFO
//
//
//  This struct contains everything you will ever need to the make CTL
//  wizard
//------------------------------------------------------------------------
typedef struct _CERT_BUILDCTL_INFO
{
    HWND                hwndParent;
    DWORD               dwFlag;
    HFONT               hBigBold;
    HFONT               hBold;
    PCCTL_CONTEXT       pSrcCTL;
    BOOL                fKnownDes;
    LPWSTR              pwszFileName;
    BOOL                fFreeFileName;
    BOOL                fSelectedFileName;
    HCERTSTORE          hDesStore;
    BOOL                fFreeDesStore;
    BOOL                fSelectedDesStore;
    BOOL                fCompleteInit;
    DWORD               dwPurposeCount;
    ENROLL_PURPOSE_INFO **prgPurpose;
    DWORD               dwCertCount;
    PCCERT_CONTEXT      *prgCertContext;
    LPWSTR              pwszFriendlyName;
    LPWSTR              pwszDescription;
    LPWSTR              pwszListID;
    FILETIME             *pNextUpdate;
    DWORD               dwValidMonths;
    DWORD               dwValidDays;
    BOOL                fClearCerts;
    DWORD               dwHashPropID;
    LPSTR               pszSubjectAlgorithm;
    CRYPTUI_WIZ_GET_SIGN_PAGE_INFO  *pGetSignInfo;
    DWORD               rgdwSortParam[4];               //keep the sorting param for the columns
}CERT_BUILDCTL_INFO;

typedef struct _CERT_STORE_LIST
{
    DWORD               dwStoreCount;
    HCERTSTORE          *prgStore;
}CERT_STORE_LIST;


typedef struct _CERT_SEL_LIST
{
    HWND                hwndDlg;
    CERT_BUILDCTL_INFO  *pCertBuildCTLInfo;
}CERT_SEL_LIST;


BOOL    I_BuildCTL(CERT_BUILDCTL_INFO   *pCertBuildCTLInfo, 
                   UINT                 *pIDS, 
                   BYTE                 **ppbEncodedCTL,
                   DWORD                *pcbEncodedCTL);


LPWSTR WizardAllocAndCopyWStr(LPWSTR pwsz);

BOOL    ValidString(CRYPT_DATA_BLOB *pDataBlob);


void AddDurationToFileTime(DWORD dwValidMonths, 
                      DWORD dwValidDays,
                      FILETIME  *pCurrentFileTime,
                      FILETIME  *pNextFileTime);

void    SubstractDurationFromFileTime(
        FILETIME    *pNextUpdateTime,
        FILETIME    *pCurrentTime, 
        DWORD       *pdwValidMonths, 
        DWORD       *pdwValidDays);

 BOOL    ValidZero(LPWSTR    pwszInput);


#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif  //BUILDCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\ui\wizards\buildctl.cpp ===
//-------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       buildctl.cpp
//
//  Contents:   The cpp file to implement the makectl wizard
//
//  History:    10-11-1997 xiaohs   created
//
//--------------------------------------------------------------
#include    "wzrdpvk.h"
#include    "buildctl.h"

#include    "wintrustp.h"




//***********************************************************************
//
//  WinProc helper functions
//**********************************************************************


//--------------------------------------------------------------------------
//
//	CheckReplace 
//
//--------------------------------------------------------------------------
BOOL    CheckReplace(HWND   hwndDlg, LPWSTR pwszFileName)
{
    BOOL    fReplace=FALSE;
    WCHAR   wszTitle[MAX_STRING_SIZE]; 
    WCHAR   wszText[MAX_STRING_SIZE];
    WCHAR   wszFileText[MAX_STRING_SIZE];


    if(NULL == pwszFileName || NULL == hwndDlg)
        goto CLEANUP;
   
    //title
#if (0) //DSIE: Bug 160615
    if(!LoadStringU(g_hmodThisDll, IDS_BUILDCTL_WIZARD_TITLE, wszTitle, sizeof(wszTitle)))
#else
    if(!LoadStringU(g_hmodThisDll, IDS_BUILDCTL_WIZARD_TITLE, wszTitle, sizeof(wszTitle) / sizeof(wszTitle[0])))
#endif
        goto CLEANUP;

    //text
#if (0) //DSIE: Bug 160616
    if(!LoadStringU(g_hmodThisDll, IDS_REPLACE_FILE, wszText, sizeof(wszText)))
#else
    if(!LoadStringU(g_hmodThisDll, IDS_REPLACE_FILE, wszText, sizeof(wszText) / sizeof(wszText[0])))
#endif
       goto CLEANUP;

    if(0 == swprintf(wszFileText, wszText, pwszFileName))
        goto CLEANUP;

    if(IDNO==MessageBoxExW(hwndDlg, wszFileText, wszTitle, 
                        MB_YESNO|MB_ICONWARNING|MB_DEFBUTTON2|MB_APPLMODAL, 0))
        fReplace=FALSE;
    else
        fReplace=TRUE;


CLEANUP:

    return fReplace;

}

//--------------------------------------------------------------------------
//
//	  DuratioinWithinLimit: We limit the CTL to 99 months.
//
//--------------------------------------------------------------------------
BOOL    DurationWithinLimit(DWORD   dwMonths,    DWORD   dwDays)
{
    BOOL        fResult=FALSE;
    FILETIME    ThisUpdate;
    FILETIME    NextUpdate;
    DWORD       dwNewMonth=0;
    DWORD       dwNewDay=0;

    if((0==dwMonths) && (0==dwDays))
        return TRUE;

    //This update field
	GetSystemTimeAsFileTime(&ThisUpdate);

    AddDurationToFileTime(dwMonths,
                          dwDays,
                          &ThisUpdate,
                          &NextUpdate);

    SubstractDurationFromFileTime(
        &NextUpdate,
        &ThisUpdate,
        &dwNewMonth,
        &dwNewDay);

    if((dwNewMonth > 99) ||
        (dwNewMonth == 99 && dwNewDay !=0))
        return FALSE;

    return TRUE;

}



//--------------------------------------------------------------------------
//
//	  FormatMessageIDSU
//
//--------------------------------------------------------------------------
BOOL	FormatMessageIDSU(LPWSTR	*ppwszFormat,UINT ids, ...)
{
    WCHAR       wszFormat[MAX_STRING_SIZE];
	LPWSTR		pwszMsg=NULL;
	BOOL		fResult=FALSE;
    va_list     argList;

    va_start(argList, ids);

#if (0) //DSIE: Bug 160614
    if(!LoadStringU(g_hmodThisDll, ids, wszFormat, sizeof(wszFormat)))
#else
    if(!LoadStringU(g_hmodThisDll, ids, wszFormat, sizeof(wszFormat) / sizeof(wszFormat[0])))
#endif
		goto LoadStringError;


    if(!FormatMessageU(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                        wszFormat,
                        0,
                        0,
                        (LPWSTR)&pwszMsg,
                        0,
                        &argList))
        goto FormatMessageError;


    if(!(*ppwszFormat=WizardAllocAndCopyWStr(pwszMsg)))
		goto SZtoWSZError;


	fResult=TRUE;
                    
CommonReturn:
	
    va_end(argList);


	if(pwszMsg)
		LocalFree((HLOCAL)pwszMsg);

	return fResult;

ErrorReturn:
	fResult=FALSE;

	goto CommonReturn;


TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMessageError);
TRACE_ERROR(SZtoWSZError);
}


/*    // get format string from resources
    CHAR		szFormat[256];
	va_list		argList;
	LPSTR		pszMsg=NULL;
	DWORD		cbMsg=0;
	BOOL		fResult=FALSE;
	HRESULT		hr=S_OK;

    if(!LoadStringA(g_hmodThisDll, ids, szFormat, sizeof(szFormat)))
		goto LoadStringError;

    // format message into requested buffer
    va_start(argList, ids);

    cbMsg = FormatMessageA(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        szFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPSTR) &pszMsg,
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);

	if(!cbMsg)
		goto FormatMessageError;

	//copy the sz to wsz
	if(!(*ppwszFormat=MkWStr(pszMsg)))
		goto SZtoWSZError;

	fResult=TRUE;

CommonReturn:
	
	if(pszMsg)
		LocalFree((HLOCAL)pszMsg);

	return fResult;

ErrorReturn:
	fResult=FALSE;

	goto CommonReturn;


TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMessageError);
TRACE_ERROR(SZtoWSZError);
}  */


//----------------------------------------------------------------------------
// GetValidityString
//
//----------------------------------------------------------------------------
BOOL    GetValidityString(DWORD     dwValidMonths,
                          DWORD     dwValidDays,
                          LPWSTR    *ppwszString)
{
    BOOL    fResult=FALSE;

    if(!ppwszString)
        return FALSE;

    *ppwszString=NULL;

    if((0==dwValidMonths) && (0==dwValidDays))
        return FALSE;

    if(dwValidMonths && dwValidDays)
       fResult=FormatMessageIDSU(ppwszString, IDS_CTL_VALID_MONTH_DAY,
                            dwValidMonths, dwValidDays);
    else
    {
        if(dwValidMonths)
            fResult=FormatMessageIDSU(ppwszString, IDS_CTL_VALID_MONTH, dwValidMonths);
        else
            fResult=FormatMessageIDSU(ppwszString, IDS_CTL_VALID_DAY, dwValidDays);
    }

    return fResult;
}



//----------------------------------------------------------------------------
//  Make sure that user has typed
//
//----------------------------------------------------------------------------
BOOL    ValidDuration(LPWSTR    pwszDuration)
{
    DWORD   i=0;

    if(NULL==pwszDuration)
        return FALSE;

    //only numerical numbers should be allowed
    for (i=0; i< (DWORD)(wcslen(pwszDuration)); i++)
    {
        if ((pwszDuration[i] < L'0') || (pwszDuration[i] > L'9'))
            return FALSE;
    }

    return TRUE;
}

//----------------------------------------------------------------------------
//  SetStoreName
//
//----------------------------------------------------------------------------
void    SetStoreName(HWND       hwndControl,
                     HCERTSTORE hDesStore)
{

    LPWSTR                  pwszStoreName=NULL;
//   LV_COLUMNW              lvC;
//    LV_ITEMW                lvItem;
    DWORD                   dwSize=0;

     //get the store name
     if(!CertGetStoreProperty(
            hDesStore,
            CERT_STORE_LOCALIZED_NAME_PROP_ID,
            NULL,
            &dwSize) || (0==dwSize))
    {
        //DSIE: Prefix bug 427201.
        //Get the  <Unknown> string
        pwszStoreName=(LPWSTR)WizardAlloc(MAX_TITLE_LENGTH * sizeof(WCHAR));

        if(pwszStoreName)
        {
            *pwszStoreName=L'\0';

            LoadStringU(g_hmodThisDll, IDS_UNKNOWN, pwszStoreName, MAX_TITLE_LENGTH);
        }
    }
    else
    {
        pwszStoreName=(LPWSTR)WizardAlloc(dwSize);

        if(pwszStoreName)
        {
            *pwszStoreName=L'\0';

            CertGetStoreProperty(
                hDesStore,
                CERT_STORE_LOCALIZED_NAME_PROP_ID,
                pwszStoreName,
                &dwSize);
        }
    }

    if(pwszStoreName)
        SetWindowTextU(hwndControl,pwszStoreName);


    if(pwszStoreName)
        WizardFree(pwszStoreName);


  /* //clear the ListView
    ListView_DeleteAllItems(hwndControl);

    //set the store name
    //only one column is needed
    memset(&lvC, 0, sizeof(LV_COLUMNW));

    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
    lvC.cx =10;    //(wcslen(pwszStoreName)+2)*7;          // Width of the column, in pixels.
    lvC.pszText = L"";   // The text for the column.
    lvC.iSubItem=0;

    if (ListView_InsertColumnU(hwndControl, 0, &lvC) == -1)
    {
        if(pwszStoreName)
        WizardFree(pwszStoreName);

        return;
    }

    //insert the store name
    memset(&lvItem, 0, sizeof(LV_ITEMW));

    // set up the fields in the list view item struct that don't change from item to item
    lvItem.mask = LVIF_TEXT | LVIF_STATE ;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.iItem=0;
    lvItem.iSubItem=0;
    lvItem.pszText=pwszStoreName;


    ListView_InsertItemU(hwndControl, &lvItem);

    //automatically resize the column
    ListView_SetColumnWidth(hwndControl, 0, LVSCW_AUTOSIZE);      */
}


BOOL    SameCert(PCCERT_CONTEXT pCertOne, PCCERT_CONTEXT    pCertTwo)
{
    if(!pCertOne || !pCertTwo)
        return FALSE;

    if(pCertOne->cbCertEncoded != pCertTwo->cbCertEncoded)
        return FALSE;

    if(0 == memcmp(pCertOne->pbCertEncoded, pCertTwo->pbCertEncoded, pCertTwo->cbCertEncoded))
        return TRUE;

    return FALSE;
}

//----------------------------------------------------------------------------
//  Delete a certificate from the pCertBuildCTLInfo
//
//----------------------------------------------------------------------------
BOOL    DeleteCertFromBuildCTL(CERT_BUILDCTL_INFO    *pCertBuildCTLInfo,
                               PCCERT_CONTEXT         pCertContext)
{
    //we need to remove the cert from our array
    PCCERT_CONTEXT  *prgCertContext=NULL;
    DWORD           dwIndex=0;
    DWORD           dwNewIndex=0;
    int             iIndex=-1;

    if(!pCertBuildCTLInfo || !pCertContext)
        return FALSE;

     //consider the case of only one cert left
    if(pCertBuildCTLInfo->dwCertCount == 1)
    {
        pCertBuildCTLInfo->dwCertCount=0;

        //free the certificate context
        CertFreeCertificateContext(pCertBuildCTLInfo->prgCertContext[0]);

        WizardFree(pCertBuildCTLInfo->prgCertContext);

        pCertBuildCTLInfo->prgCertContext=NULL;
    }
    else
    {
        prgCertContext=pCertBuildCTLInfo->prgCertContext;

        //re-allocate the memory
        pCertBuildCTLInfo->prgCertContext=(PCCERT_CONTEXT *)WizardAlloc(sizeof(PCCERT_CONTEXT) *
                                            (pCertBuildCTLInfo->dwCertCount-1));
        //if we are out of memory
        if(NULL==pCertBuildCTLInfo->prgCertContext)
        {
            //reset
            pCertBuildCTLInfo->prgCertContext=prgCertContext;
            return FALSE;
        }

        //copy the certificate context over
        dwNewIndex=0;

        for(dwIndex=0; dwIndex<pCertBuildCTLInfo->dwCertCount; dwIndex++)
        {

            //find the cert to delete, and do not copy it to the new array
            if(SameCert(prgCertContext[dwIndex], pCertContext))
            {
                iIndex=dwIndex;
                continue;
            }

            pCertBuildCTLInfo->prgCertContext[dwNewIndex]=prgCertContext[dwIndex];

            dwNewIndex++;
        }

        //remember that we are one cert less
        pCertBuildCTLInfo->dwCertCount=dwNewIndex;

        if(prgCertContext)
        {
            //free the certificate context
            if(-1 != iIndex)
                CertFreeCertificateContext(prgCertContext[iIndex]);

            WizardFree(prgCertContext);
        }

    }

    return TRUE;
}


//----------------------------------------------------------------------------
//  Add certificate to the pCertBuildCTLInfo
//
//----------------------------------------------------------------------------
BOOL    AddCertToBuildCTL(PCCERT_CONTEXT        pCertContext,
                          CERT_BUILDCTL_INFO    *pCertBuildCTLInfo)
{
    DWORD   dwIndex=0;

    //check to see if the certificate is alreayd in the CTL
    for(dwIndex=0; dwIndex < pCertBuildCTLInfo->dwCertCount; dwIndex++)
    {
        if(pCertContext->cbCertEncoded ==
            (pCertBuildCTLInfo->prgCertContext[dwIndex])->cbCertEncoded)
        {
            if(0==memcmp(pCertContext->pbCertEncoded,
               (pCertBuildCTLInfo->prgCertContext[dwIndex])->pbCertEncoded,
               pCertContext->cbCertEncoded))
               //return FALSE if a duplicate exists
               return FALSE;

        }
    }

    pCertBuildCTLInfo->prgCertContext=(PCCERT_CONTEXT *)WizardRealloc(
        pCertBuildCTLInfo->prgCertContext,
        sizeof(PCCERT_CONTEXT *)*(pCertBuildCTLInfo->dwCertCount +1));

    if(NULL==pCertBuildCTLInfo->prgCertContext)
    {
        pCertBuildCTLInfo->dwCertCount=0;
        return FALSE;
    }


    pCertBuildCTLInfo->prgCertContext[pCertBuildCTLInfo->dwCertCount]=pCertContext;

    pCertBuildCTLInfo->dwCertCount++;

    return TRUE;
}
//----------------------------------------------------------------------------
//  Add certificate to the ListView
//
//----------------------------------------------------------------------------
BOOL    AddCertToList(HWND              hwndControl,
                      PCCERT_CONTEXT    pCertContext,
                      int               iItem)
{
    BOOL            fResult=FALSE;
    LV_ITEMW        lvItem;
    DWORD           dwChar=0;
    WCHAR           wszNone[MAX_TITLE_LENGTH];

    LPWSTR          pwszName=NULL;

    if(!hwndControl || !pCertContext)
        return FALSE;

     // set up the fields in the list view item struct that don't change from item to item
    lvItem.mask = LVIF_TEXT | LVIF_STATE |LVIF_PARAM;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.iItem=iItem;
    lvItem.iSubItem=0;
    lvItem.lParam = (LPARAM)(pCertContext);

    //load the string for NONE
    if(!LoadStringU(g_hmodThisDll, IDS_NONE, wszNone, MAX_TITLE_LENGTH))
        wszNone[0]=L'\0';


    //Subject
    dwChar=CertGetNameStringW(
        pCertContext,
        CERT_NAME_SIMPLE_DISPLAY_TYPE,
        0,
        NULL,
        NULL,
        0);

    if ((dwChar != 0) && (NULL != (pwszName = (LPWSTR)WizardAlloc(dwChar * sizeof(WCHAR)))))
    {

        CertGetNameStringW(
            pCertContext,
            CERT_NAME_SIMPLE_DISPLAY_TYPE,
            0,
            NULL,
            pwszName,
            dwChar);

        lvItem.pszText=pwszName;

        ListView_InsertItemU(hwndControl, &lvItem);

    }
    else
    {
        lvItem.pszText=wszNone;

        ListView_InsertItemU(hwndControl, &lvItem);
    }


    //WizardFree the memory
    if(pwszName)
    {
        WizardFree(pwszName);
        pwszName=NULL;
    }

    //Issuer
    lvItem.iSubItem++;

    dwChar=CertGetNameStringW(
        pCertContext,
        CERT_NAME_SIMPLE_DISPLAY_TYPE,
        CERT_NAME_ISSUER_FLAG,
        NULL,
        NULL,
        0);

    if ((dwChar != 0) && (NULL != (pwszName = (LPWSTR)WizardAlloc(dwChar * sizeof(WCHAR)))))
    {

        CertGetNameStringW(
            pCertContext,
            CERT_NAME_SIMPLE_DISPLAY_TYPE,
            CERT_NAME_ISSUER_FLAG,
            NULL,
            pwszName,
            dwChar);

        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                       pwszName);

    }
    else
        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                       wszNone);


    //free the memory
    if(pwszName)
    {
        WizardFree(pwszName);
        pwszName=NULL;
    }


    //purpose
    lvItem.iSubItem++;

    if(MyFormatEnhancedKeyUsageString(&pwszName,pCertContext, FALSE, FALSE))
    {

       ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                      pwszName);

    }
    
    //free the memory
    if(pwszName)
    {
        WizardFree(pwszName);
        pwszName=NULL;
    }


    //Expiration
    lvItem.iSubItem++;

    if(WizardFormatDateString(&pwszName,pCertContext->pCertInfo->NotAfter, FALSE))
    {

       ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                      pwszName);

    }
    else
        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                       wszNone);

    //free the memory
    if(pwszName)
    {
        WizardFree(pwszName);
        pwszName=NULL;
    }

    return TRUE;
}
//----------------------------------------------------------------------------
//  Make sure the cert has the same usage as the ones defined in CTL.
//
//----------------------------------------------------------------------------
BOOL    CertMatchCTL(CERT_BUILDCTL_INFO *pCertBuildCTLInfo,
                     PCCERT_CONTEXT     pCertContext)
{
    BOOL        fResult=FALSE;
    int         cNumOID=0;
    LPSTR       *rgOID=NULL;
    DWORD       cbOID=0;
    DWORD       dwIndex=0;
    DWORD       dwOIDIndex=0;

    if(!pCertBuildCTLInfo || !pCertContext)
        return FALSE;

    //we have to have some oids in the list
    if(0==pCertBuildCTLInfo->dwPurposeCount || NULL==pCertBuildCTLInfo->prgPurpose)
        return FALSE;

    //get the OIDs from the cert
    if(!CertGetValidUsages(
        1,
        &pCertContext,
        &cNumOID,
        NULL,
        &cbOID))
        return FALSE;

    rgOID=(LPSTR *)WizardAlloc(cbOID);

    if(NULL==rgOID)
        return FALSE;

    if(!CertGetValidUsages(
        1,
        &pCertContext,
        &cNumOID,
        rgOID,
        &cbOID))
        goto CLEANUP;

    if(-1==cNumOID)
    {
        fResult=TRUE;
        goto CLEANUP;
    }

    //make sure the array of OIDs match the ones in the CTL

    for(dwIndex=0; dwIndex<pCertBuildCTLInfo->dwPurposeCount; dwIndex++)
    {
        if(NULL==pCertBuildCTLInfo->prgPurpose[dwIndex])
            continue;

        if(FALSE==pCertBuildCTLInfo->prgPurpose[dwIndex]->fSelected)
            continue;

        if(NULL==pCertBuildCTLInfo->prgPurpose[dwIndex]->pszOID)
            continue;

        //we need to find at least one match from the oids supported by the cert
        for(dwOIDIndex=0; dwOIDIndex<(DWORD)cNumOID; dwOIDIndex++)
        {
            if(0==strcmp(pCertBuildCTLInfo->prgPurpose[dwIndex]->pszOID,
                        rgOID[dwOIDIndex]))
            {
                fResult=TRUE;
                goto CLEANUP;
            }
        }
    }


    //we are hopeless at this point
    fResult=FALSE;

CLEANUP:

    if(rgOID)
        WizardFree(rgOID);

    return fResult;
}

//----------------------------------------------------------------------------
//  Find a cert from stores .
//
//----------------------------------------------------------------------------
static PCCERT_CONTEXT FindCertContextInStores(
                                PCTL_ENTRY  pCtlEntry,
                                DWORD       chStores1,
                                HCERTSTORE  *rghStores1,
                                DWORD       chStores2,
                                HCERTSTORE  *rghStores2,
                                HCERTSTORE  hExtraStore,
                                DWORD       dwFindType)
{
    DWORD           i;
    PCCERT_CONTEXT  pCertContext = NULL;

    if (dwFindType == 0)
    {
        return NULL;
    }

    i = 0;
    while ((i<chStores1) && (pCertContext == NULL))
    {
        pCertContext = CertFindCertificateInStore(
                                rghStores1[i++],
                                X509_ASN_ENCODING,
                                0,
                                dwFindType,
                                (void *)&(pCtlEntry->SubjectIdentifier),
                                NULL);
    }

    i = 0;
    while ((i<chStores2) && (pCertContext == NULL))
    {
        pCertContext = CertFindCertificateInStore(
                                rghStores2[i++],
                                X509_ASN_ENCODING,
                                0,
                                dwFindType,
                                (void *)&(pCtlEntry->SubjectIdentifier),
                                NULL);
    }

    if (pCertContext == NULL)
    {
        pCertContext = CertFindCertificateInStore(
                                hExtraStore,
                                X509_ASN_ENCODING,
                                0,
                                dwFindType,
                                (void *)&(pCtlEntry->SubjectIdentifier),
                                NULL);
    }

    return pCertContext;
}


//----------------------------------------------------------------------------
//  See if the certificate is valid
//
//----------------------------------------------------------------------------
BOOL    IsValidCert(HWND                hwndDlg,
                    PCCERT_CONTEXT      pCertContext,
                    CERT_BUILDCTL_INFO  *pCertBuildCTLInfo,
                    BOOL                fMsg,
                    BOOL                fFromCTL)
{
         //make sure the pCertContext is a self-signed certificate
         if(!TrustIsCertificateSelfSigned(pCertContext,
             pCertContext->dwCertEncodingType,
             0))
         {
            if(fMsg)
            {
                if(fFromCTL)
                    I_MessageBox(hwndDlg, IDS_NOT_SELF_SIGNED_FROM_CTL,
                         IDS_BUILDCTL_WIZARD_TITLE,
                         NULL,
                         MB_ICONEXCLAMATION|MB_OK|MB_APPLMODAL);
                else
                    I_MessageBox(hwndDlg, IDS_NOT_SELF_SIGNED,
                         IDS_BUILDCTL_WIZARD_TITLE,
                         NULL,
                         MB_ICONERROR|MB_OK|MB_APPLMODAL);
            }
            return FALSE;

         }


         //make sure the certifcate match what is defined on the CTL list
         if(!CertMatchCTL(pCertBuildCTLInfo, pCertContext))
         {
            if(fMsg)
            {
               if(fFromCTL)
                    I_MessageBox(hwndDlg, IDS_NO_MATCH_USAGE_FROM_CTL,
                         IDS_BUILDCTL_WIZARD_TITLE,
                         NULL,
                         MB_ICONEXCLAMATION|MB_OK|MB_APPLMODAL);
               else
                    I_MessageBox(hwndDlg, IDS_NO_MATCH_USAGE,
                         IDS_BUILDCTL_WIZARD_TITLE,
                         NULL,
                         MB_ICONERROR|MB_OK|MB_APPLMODAL);


            }

            return FALSE;
         }

         return TRUE;
}

//----------------------------------------------------------------------------
//  Cert a ceritifcate from the file
//
//----------------------------------------------------------------------------
static HCERTSTORE GetCertStoreFromFile(HWND                  hwndDlg,
                                      CERT_BUILDCTL_INFO    *pCertBuildCTLInfo)
{
    OPENFILENAMEW       OpenFileName;
    WCHAR               szFileName[_MAX_PATH];
    WCHAR               szFilter[MAX_STRING_SIZE];  //"Certificate File (*.cer)\0*.cer\0Certificate File (*.crt)\0*.crt\0All Files\0*.*\0"
    BOOL                fResult=FALSE;

    HCERTSTORE          hCertStore=NULL;
    DWORD               dwSize=0;
    DWORD               dwContentType=0;


    if(!hwndDlg || !pCertBuildCTLInfo)
        return NULL;

    memset(&OpenFileName, 0, sizeof(OpenFileName));

    *szFileName=L'\0';

    OpenFileName.lStructSize = sizeof(OpenFileName);
    OpenFileName.hwndOwner = hwndDlg;
    OpenFileName.hInstance = NULL;
    //load the fileter string
    if(LoadFilterString(g_hmodThisDll, IDS_ALL_CER_FILTER, szFilter, MAX_STRING_SIZE))
    {
        OpenFileName.lpstrFilter = szFilter;
    }
    OpenFileName.lpstrCustomFilter = NULL;
    OpenFileName.nMaxCustFilter = 0;
    OpenFileName.nFilterIndex = 1;
    OpenFileName.lpstrFile = szFileName;
    OpenFileName.nMaxFile = _MAX_PATH;
    OpenFileName.lpstrFileTitle = NULL;
    OpenFileName.nMaxFileTitle = 0;
    OpenFileName.lpstrInitialDir = NULL;
    OpenFileName.lpstrTitle = NULL;
    OpenFileName.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;
    OpenFileName.nFileOffset = 0;
    OpenFileName.nFileExtension = 0;
    OpenFileName.lpstrDefExt = L"cer";
    OpenFileName.lCustData = NULL;
    OpenFileName.lpfnHook = NULL;
    OpenFileName.lpTemplateName = NULL;

    if (!WizGetOpenFileName(&OpenFileName))
        return NULL;

    if(!ExpandAndCryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       szFileName,
                       CERT_QUERY_CONTENT_FLAG_CERT |
                       CERT_QUERY_CONTENT_FLAG_CTL  |
                       CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT |
                       CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |
                       CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       &dwContentType,
                       NULL,
                       &hCertStore,
                       NULL,
                       NULL) || (NULL==hCertStore))
    {
        I_MessageBox(hwndDlg, IDS_INVALID_CERT_FILE,
                         IDS_BUILDCTL_WIZARD_TITLE,
                         NULL,
                         MB_ICONERROR|MB_OK|MB_APPLMODAL);

        goto CLEANUP;

    }

    if(dwContentType & CERT_QUERY_CONTENT_CTL)
    {
        I_MessageBox(hwndDlg, IDS_INVALID_CERT_FILE,
                         IDS_BUILDCTL_WIZARD_TITLE,
                         NULL,
                         MB_ICONERROR|MB_OK|MB_APPLMODAL);

        goto CLEANUP;

    }



    fResult=TRUE;

CLEANUP:

    if(TRUE==fResult)
        return hCertStore;

    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    return NULL;

}
//----------------------------------------------------------------------------
//  CallBack fro cert selection call back
//
//----------------------------------------------------------------------------
static BOOL WINAPI SelCertCallBack(
        PCCERT_CONTEXT  pCertContext,
        BOOL            *pfInitialSelectedCert,
        void            *pvCallbackData)
{
    if(!pvCallbackData || !pCertContext)
        return FALSE;

    //make sure that this is a valid certificate
    return IsValidCert(((CERT_SEL_LIST *)pvCallbackData)->hwndDlg,
                       pCertContext,
                       ((CERT_SEL_LIST *)pvCallbackData)->pCertBuildCTLInfo,
                       FALSE,
                       FALSE);
}
 //////////////////////////////////////////////////////////////////////////////////////
//  The call back function for enum system stores for the signing certificate
//////////////////////////////////////////////////////////////////////////////////////
static BOOL WINAPI EnumSysStoreSignCertCallBack(
    const void* pwszSystemStore,
    DWORD dwFlags,
    PCERT_SYSTEM_STORE_INFO pStoreInfo,
    void *pvReserved,
    void *pvArg
    )
{
    CERT_STORE_LIST     *pCertStoreList=NULL;
    HCERTSTORE          hCertStore=NULL;

    if(NULL==pvArg)
        return FALSE;

    pCertStoreList=(CERT_STORE_LIST *)pvArg;

    //open the store
    hCertStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							g_dwMsgAndCertEncodingType,
							NULL,
							CERT_SYSTEM_STORE_CURRENT_USER |CERT_STORE_SET_LOCALIZED_NAME_FLAG,
                            (LPWSTR)pwszSystemStore);

    if(!hCertStore)
       return FALSE;


    pCertStoreList->prgStore=(HCERTSTORE *)WizardRealloc(
        pCertStoreList->prgStore,
        sizeof(HCERTSTORE) *(pCertStoreList->dwStoreCount +1));

    if(NULL==pCertStoreList->prgStore)
    {
        CertCloseStore(hCertStore, 0);
        pCertStoreList->dwStoreCount=0;
    }

    pCertStoreList->prgStore[pCertStoreList->dwStoreCount]=hCertStore;
    pCertStoreList->dwStoreCount++;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
//  The call back function for enum system stores
//////////////////////////////////////////////////////////////////////////////////////
static BOOL WINAPI EnumSysStoreCallBack(
    const void* pwszSystemStore,
    DWORD dwFlags,
    PCERT_SYSTEM_STORE_INFO pStoreInfo,
    void *pvReserved,
    void *pvArg
    )
{
    CERT_STORE_LIST     *pCertStoreList=NULL;
    HCERTSTORE          hCertStore=NULL;

    if(NULL==pvArg)
        return FALSE;

    pCertStoreList=(CERT_STORE_LIST *)pvArg;

    //open the store as read-only
    hCertStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							g_dwMsgAndCertEncodingType,
							NULL,
							CERT_SYSTEM_STORE_CURRENT_USER |CERT_STORE_SET_LOCALIZED_NAME_FLAG|CERT_STORE_READONLY_FLAG,
                            (LPWSTR)pwszSystemStore);

    //we can not open the store.
    if(!hCertStore)
       return TRUE;

    pCertStoreList->prgStore=(HCERTSTORE *)WizardRealloc(
        pCertStoreList->prgStore,
        sizeof(HCERTSTORE) *(pCertStoreList->dwStoreCount +1));

    if(NULL==pCertStoreList->prgStore)
    {
        CertCloseStore(hCertStore, 0);
        pCertStoreList->dwStoreCount=0;
    }
    else // DSIE: Bug 227267
    {
        pCertStoreList->prgStore[pCertStoreList->dwStoreCount]=hCertStore;
        pCertStoreList->dwStoreCount++;
    }    

    return TRUE;
}

//----------------------------------------------------------------------------
//  Cert a ceritifcate from the store
//
//----------------------------------------------------------------------------
static HCERTSTORE GetCertsFromStore(HWND                  hwndDlg,
                                    CERT_BUILDCTL_INFO    *pCertBuildCTLInfo)
{
    PCCERT_CONTEXT                      pCertContext=NULL;
    CRYPTUI_SELECTCERTIFICATE_STRUCT    SelCert;
    CERT_SEL_LIST                       CertSelList;
    DWORD                               dwIndex=0;
    HCERTSTORE                          hCertStore;
    CERT_STORE_LIST                     CertStoreList;

    if(!hwndDlg || !pCertBuildCTLInfo)
        return NULL;

    //init
    memset(&CertStoreList, 0, sizeof(CertStoreList));
    memset(&SelCert, 0, sizeof(CRYPTUI_SELECTCERTIFICATE_STRUCT));
    memset(&CertSelList, 0, sizeof(CERT_SEL_LIST));

    //set up the parameter for call back for cert selection dialogue
    CertSelList.hwndDlg=hwndDlg;
    CertSelList.pCertBuildCTLInfo=pCertBuildCTLInfo;

    if (NULL == (hCertStore = CertOpenStore(
                                    CERT_STORE_PROV_MEMORY,
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    NULL,
                                    0,
                                    NULL)))
    {
        goto CLEANUP;
    }

    //set up the parameter to get a list of certificate
    if (!CertEnumSystemStore(
            CERT_SYSTEM_STORE_CURRENT_USER,
            NULL,
            &CertStoreList,
            EnumSysStoreCallBack))
        goto CLEANUP;

    //set up the parameter for cert selection dialogue
    SelCert.dwSize=sizeof(CRYPTUI_SELECTCERTIFICATE_STRUCT);
    SelCert.hwndParent=hwndDlg;
    SelCert.dwFlags = CRYPTUI_SELECTCERT_MULTISELECT;
    SelCert.pFilterCallback=SelCertCallBack;
    SelCert.pvCallbackData=&CertSelList;
    SelCert.cDisplayStores=CertStoreList.dwStoreCount;
    SelCert.rghDisplayStores=CertStoreList.prgStore;
    SelCert.hSelectedCertStore = hCertStore;

    CryptUIDlgSelectCertificate(&SelCert);

CLEANUP:

    for(dwIndex=0; dwIndex<CertStoreList.dwStoreCount; dwIndex++)
        CertCloseStore(CertStoreList.prgStore[dwIndex], 0);

    if(CertStoreList.prgStore)
        WizardFree(CertStoreList.prgStore);

    return hCertStore;

}


//---------------------------------------------------------------------
//  Get the certificate list for the CTL
//
//---------------------------------------------------------------------
void    GetCertForCTL(HWND                hwndParent,
                      BOOL                fMsg,
                      CERT_BUILDCTL_INFO  *pCertBuildCTLInfo,
                      HCERTSTORE          hCertStore)
{
    DWORD           dwIndex=0;
    DWORD           dwCertIndex=0;
    DWORD           dwFindType=0;
    CTL_INFO        *pCTLInfo=NULL;

    PCCERT_CONTEXT  pCertContext=NULL;
    PCCERT_CONTEXT  pPreCertContext=NULL;
    HCERTSTORE      rgHCertStore[4]={NULL, NULL, NULL, NULL};
    HCERTSTORE      hExtraStore=NULL;

    BOOL            fInvalidCertMsg=fMsg;
    BOOL            fFoundInCTLMsg=fMsg;

    if(!pCertBuildCTLInfo)
        return;

    //add the certificate from the old CTL
    if(pCertBuildCTLInfo->pSrcCTL)
    {

        //open my, ca, trust, and root store
        if(rgHCertStore[dwIndex]=CertOpenStore(
                                CERT_STORE_PROV_SYSTEM_W,
							    g_dwMsgAndCertEncodingType,
							    NULL,
							    CERT_SYSTEM_STORE_CURRENT_USER,
							    L"my"))
            dwIndex++;

        if(rgHCertStore[dwIndex]=CertOpenStore(
                                CERT_STORE_PROV_SYSTEM_W,
							    g_dwMsgAndCertEncodingType,
							    NULL,
							    CERT_SYSTEM_STORE_CURRENT_USER,
							    L"trust"))
            dwIndex++;


        if(rgHCertStore[dwIndex]=CertOpenStore(
                                CERT_STORE_PROV_SYSTEM_W,
							    g_dwMsgAndCertEncodingType,
							    NULL,
							    CERT_SYSTEM_STORE_CURRENT_USER,
							    L"ca"))
            dwIndex++;

         if(rgHCertStore[dwIndex]=CertOpenStore(
                                CERT_STORE_PROV_SYSTEM_W,
							    g_dwMsgAndCertEncodingType,
							    NULL,
							    CERT_SYSTEM_STORE_CURRENT_USER,
							    L"root"))
            dwIndex++;

         //open the cert store
         hExtraStore = CertOpenStore(
                                    CERT_STORE_PROV_MSG,
                                    g_dwMsgAndCertEncodingType,
                                    NULL,
                                    0,
                                    (const void *) (pCertBuildCTLInfo->pSrcCTL->hCryptMsg));


        //find the certificate hash
        pCTLInfo=pCertBuildCTLInfo->pSrcCTL->pCtlInfo;

        if(pCertBuildCTLInfo->dwHashPropID==CERT_SHA1_HASH_PROP_ID)
            dwFindType=CERT_FIND_SHA1_HASH;
        else
            dwFindType=CERT_FIND_MD5_HASH;

        //look through each entry in the CTL list
        for(dwCertIndex=0; dwCertIndex<pCTLInfo->cCTLEntry; dwCertIndex++)
        {

             pCertContext=FindCertContextInStores(
                                    &(pCTLInfo->rgCTLEntry[dwCertIndex]),
                                    dwIndex,
                                    rgHCertStore,
                                    0,
                                    NULL,
                                    hExtraStore,
                                    dwFindType);

             
             if(NULL==pCertContext && TRUE==fFoundInCTLMsg)
             {
                I_MessageBox(hwndParent, IDS_NO_MATCH_IN_CTL,
                             IDS_BUILDCTL_WIZARD_TITLE,
                             NULL,
                             MB_ICONEXCLAMATION|MB_OK|MB_APPLMODAL);

                //no need to give the message again
                fFoundInCTLMsg=FALSE;

                continue;
             }
             else if (NULL==pCertContext)
             {
                continue;
             }

             if(!IsValidCert(hwndParent,
                            pCertContext,
                            pCertBuildCTLInfo,
                            fInvalidCertMsg,
                            TRUE))
             {

                CertFreeCertificateContext(pCertContext);
                pCertContext=0;

                //no need to give message again
                fInvalidCertMsg=FALSE;

                continue;
             }

             if(!AddCertToBuildCTL(pCertContext, pCertBuildCTLInfo))
             {
                CertFreeCertificateContext(pCertContext);
                pCertContext=NULL;

                continue;
             }

        }
    }
    else
    {
        //add the certificate from the hCertStore to the CTL
        if(NULL != hCertStore)
        {
	        while(pCertContext=CertEnumCertificatesInStore(hCertStore, pPreCertContext))
	        {

                if(!IsValidCert(hwndParent,
                                pCertContext,
                                pCertBuildCTLInfo,
                                FALSE,     //do not want a message
                                FALSE))    //not build from a CTL
                {
                    pPreCertContext=pCertContext;
                    continue;
                }

                //get a duplicate of the certificate context
                pPreCertContext=CertDuplicateCertificateContext(pCertContext);

                if(NULL==pPreCertContext)
                {
                    pPreCertContext=pCertContext;
                    continue;
                }

                //add the duplicate to the list
                if(!AddCertToBuildCTL(pPreCertContext, pCertBuildCTLInfo))
                    CertFreeCertificateContext(pPreCertContext);

                //continue for the next iteration
                pPreCertContext=pCertContext;
            }

        }
    }


    //free the certificate store
    if(hExtraStore)
        CertCloseStore(hExtraStore, 0);

    for(dwIndex=0; dwIndex < 4; dwIndex++)
    {
        if(rgHCertStore[dwIndex])
            CertCloseStore(rgHCertStore[dwIndex], 0);

    }
}


//---------------------------------------------------------------------
//  Init the certifcate list from the old CTL
//
//---------------------------------------------------------------------
void    InitCertList(HWND                hwndControl,
                     CERT_BUILDCTL_INFO  *pCertBuildCTLInfo)
{
    DWORD           dwIndex=0;

    if(!hwndControl || !pCertBuildCTLInfo)
        return;

    for(dwIndex=0; dwIndex<pCertBuildCTLInfo->dwCertCount; dwIndex++)
    {
        //add the certificat to the window
        AddCertToList(hwndControl,(pCertBuildCTLInfo->prgCertContext)[dwIndex],
            dwIndex);
    }
}


//-----------------------------------------------------------------------
//   The winProc for the new oid dialogue
//-----------------------------------------------------------------------
void    FreeCerts(CERT_BUILDCTL_INFO *pCertBuildCTLInfo)
{
    DWORD   dwIndex=0;

    if(!pCertBuildCTLInfo)
        return;

    if(pCertBuildCTLInfo->prgCertContext)
    {
        for(dwIndex=0; dwIndex<pCertBuildCTLInfo->dwCertCount; dwIndex++)
        {
            if(pCertBuildCTLInfo->prgCertContext[dwIndex])
                CertFreeCertificateContext(pCertBuildCTLInfo->prgCertContext[dwIndex]);
        }

        WizardFree(pCertBuildCTLInfo->prgCertContext);
    }

    pCertBuildCTLInfo->dwCertCount=0;

    pCertBuildCTLInfo->prgCertContext=NULL;
}


//////////////////////////////////////////////////////////////////////////////////////
//   The winProc for the new oid dialogue
//////////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY CTLOIDDialogProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD   i;
    char    szText[MAX_STRING_SIZE];
    LPSTR   pszText=NULL;
    int     intMsg=0;

    CERT_ENHKEY_USAGE   KeyUsage;
    DWORD               cbData = 0;
    LPSTR               pszCheckOID=NULL;



    switch ( msg ) {

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {

        case IDOK:
            if (GetDlgItemTextA(
                        hwndDlg,
                        IDC_WIZARD_EDIT1,
                        szText,
                        MAX_STRING_SIZE-1))
            {
                //
                // make sure there are not weird characters
                //
                for (i=0; i<(DWORD)strlen(szText); i++)
                {
                    if (((szText[i] < '0') || (szText[i] > '9')) && (szText[i] != '.'))
                    {
                       intMsg=I_MessageBox(hwndDlg, IDS_WIZARD_ERROR_OID,
                                                IDS_BUILDCTL_WIZARD_TITLE,
                                                NULL,
                                                MB_OK | MB_ICONERROR|MB_APPLMODAL);
                        return FALSE;
                    }
                }

                //
                // check the last char, and for the empty string
                //
                if ((szText[0] == '.') || (szText[strlen(szText)-1] == '.') || (strcmp(szText, "") == 0))
                {
                       intMsg=I_MessageBox(hwndDlg, IDS_WIZARD_ERROR_OID,
                                                IDS_BUILDCTL_WIZARD_TITLE,
                                                NULL,
                                                MB_OK | MB_ICONERROR|MB_APPLMODAL);
                        return FALSE;
                }

                //encode the OID to make sure the format of the OID is correct
                pszCheckOID = szText;
                KeyUsage.rgpszUsageIdentifier = &pszCheckOID;
                KeyUsage.cUsageIdentifier = 1;

                if (!CryptEncodeObject(
                          X509_ASN_ENCODING,
                          szOID_ENHANCED_KEY_USAGE,
                          &KeyUsage,
                          NULL,
                          &cbData))
                {
                       intMsg=I_MessageBox(hwndDlg, IDS_WIZARD_ERROR_OID,
                                                IDS_BUILDCTL_WIZARD_TITLE,
                                                NULL,
                                                MB_OK | MB_ICONERROR|MB_APPLMODAL);
                        return FALSE;
                }


                //
                // allocate space for the string and pass the string back
                //
                pszText = (LPSTR) WizardAlloc(strlen(szText)+1);
                if (pszText != NULL)
                {
                    strcpy(pszText, szText);
                }
            }

            EndDialog(hwndDlg, (INT_PTR)pszText);
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, 0);
            break;
        }

        break;
    }

    return FALSE;
}


//-----------------------------------------------------------------------
//Free the purpose array
//-----------------------------------------------------------------------
void FreePurposeInfo(ENROLL_PURPOSE_INFO    **prgPurposeInfo,
                     DWORD                  dwOIDCount)
{
    DWORD   dwIndex=0;

    if(dwOIDCount==0 || NULL==prgPurposeInfo)
        return;

    for(dwIndex=0; dwIndex<dwOIDCount; dwIndex++)
    {
        if(prgPurposeInfo[dwIndex])
        {
            if(TRUE==prgPurposeInfo[dwIndex]->fFreeOID)
            {
                if((prgPurposeInfo[dwIndex])->pszOID)
                    WizardFree((prgPurposeInfo[dwIndex])->pszOID);
            }

            if(TRUE==prgPurposeInfo[dwIndex]->fFreeName)
            {
                //the name was obtained viz MkWstr
                if((prgPurposeInfo[dwIndex])->pwszName)
                    FreeWStr((prgPurposeInfo[dwIndex])->pwszName);
            }

            WizardFree(prgPurposeInfo[dwIndex]);
        }
    }

    WizardFree(prgPurposeInfo);
}

//-----------------------------------------------------------------------
//Search for the OID in the array
//-----------------------------------------------------------------------
BOOL    SearchAndAddOID(LPSTR                   pszOID,
                        DWORD                   *pdwCount,
                        ENROLL_PURPOSE_INFO     ***pprgPurposeInfo,
                        BOOL                    *pfFound,
                        BOOL                    fAllocateOID,
                        BOOL                    fMarkAsSelectedNew,
                        BOOL                    fMarkAsSelectedFound
                        )
{
    DWORD   dwIndex=0;

    if(NULL==pszOID || NULL==pdwCount || NULL==pprgPurposeInfo)
        return FALSE;

    for(dwIndex=0; dwIndex< *pdwCount; dwIndex++)
    {
        //no need to go on if we find a match
        if(0==strcmp(pszOID, (*pprgPurposeInfo)[dwIndex]->pszOID))
        {
            if(pfFound)
                *pfFound=TRUE;

            //mark the selected option
            if(TRUE==fMarkAsSelectedFound)
                (*pprgPurposeInfo)[dwIndex]->fSelected=TRUE;

            return TRUE;
        }
    }

    //we did not find a match
    if(pfFound)
       *pfFound=FALSE;

    //now, we need to add the OID to the list
    (*pdwCount)++;

    //get more memory for the pointer list
    *pprgPurposeInfo=(ENROLL_PURPOSE_INFO **)WizardRealloc(*pprgPurposeInfo,
                                      (*pdwCount) * sizeof(ENROLL_PURPOSE_INFO *));

    if(NULL==*pprgPurposeInfo)
        return FALSE;

    //wizardAlloc for each pointer
    (*pprgPurposeInfo)[*pdwCount-1]=(ENROLL_PURPOSE_INFO *)WizardAlloc(sizeof(ENROLL_PURPOSE_INFO));

    if(NULL==(*pprgPurposeInfo)[*pdwCount-1])
        return FALSE;

    memset((*pprgPurposeInfo)[*pdwCount-1], 0, sizeof(ENROLL_PURPOSE_INFO));

    if(TRUE==fAllocateOID)
    {
        (*pprgPurposeInfo)[*pdwCount-1]->pszOID=(LPSTR)WizardAlloc(strlen(pszOID)+1);

        if(NULL!=(*pprgPurposeInfo)[*pdwCount-1]->pszOID)
        {
            strcpy((*pprgPurposeInfo)[*pdwCount-1]->pszOID, pszOID);

            (*pprgPurposeInfo)[*pdwCount-1]->fFreeOID=TRUE;
        }
    }
    else
    {
        (*pprgPurposeInfo)[*pdwCount-1]->pszOID=pszOID;
        (*pprgPurposeInfo)[*pdwCount-1]->fFreeOID=FALSE;
    }

    //get the name for the OID based on the oid string
    if((*pprgPurposeInfo)[*pdwCount-1]->pszOID)
    {
        (*pprgPurposeInfo)[*pdwCount-1]->pwszName=MkWStr(pszOID);

        (*pprgPurposeInfo)[*pdwCount-1]->fFreeName=TRUE;
    }

    //mark the OID as selected if specified
    if(TRUE==fMarkAsSelectedNew)
        (*pprgPurposeInfo)[*pdwCount-1]->fSelected=TRUE;
    else
        (*pprgPurposeInfo)[*pdwCount-1]->fSelected=FALSE;

    return TRUE;

}


//-----------------------------------------------------------------------
//The call back function for enum
//-----------------------------------------------------------------------
static BOOL WINAPI EnumInfoCallback(
    IN PCCRYPT_OID_INFO pInfo,
    IN void *pvArg
    )
{

    PURPOSE_INFO_CALL_BACK     *pCallBackInfo=NULL;
    DWORD                       dwError=0;

    pCallBackInfo=(PURPOSE_INFO_CALL_BACK     *)pvArg;
    if(NULL==pvArg || NULL==pInfo)
        return FALSE;

    //increment the oid list
    (*(pCallBackInfo->pdwCount))++;

    //get more memory for the pointer list
    *(pCallBackInfo->pprgPurpose)=(ENROLL_PURPOSE_INFO **)WizardRealloc(*(pCallBackInfo->pprgPurpose),
                                      (*(pCallBackInfo->pdwCount)) * sizeof(ENROLL_PURPOSE_INFO *));

    if(NULL==*(pCallBackInfo->pprgPurpose))
    {
        dwError=GetLastError();
        return FALSE;
    }

    //wizardAlloc for each pointer
    (*(pCallBackInfo->pprgPurpose))[*(pCallBackInfo->pdwCount)-1]=(ENROLL_PURPOSE_INFO *)WizardAlloc(sizeof(ENROLL_PURPOSE_INFO));

    if(NULL==(*(pCallBackInfo->pprgPurpose))[*(pCallBackInfo->pdwCount)-1])
        return FALSE;

    memset((*(pCallBackInfo->pprgPurpose))[*(pCallBackInfo->pdwCount)-1], 0, sizeof(ENROLL_PURPOSE_INFO));

    (*(pCallBackInfo->pprgPurpose))[*(pCallBackInfo->pdwCount)-1]->pszOID=(LPSTR)(pInfo->pszOID);
    (*(pCallBackInfo->pprgPurpose))[*(pCallBackInfo->pdwCount)-1]->pwszName=(LPWSTR)(pInfo->pwszName);

    return TRUE;
}

//-----------------------------------------------------------------------
//Initialize usage OID to display
//-----------------------------------------------------------------------
BOOL    GetOIDForCTL(CERT_BUILDCTL_INFO     *pCertBuildCTLInfo,
                    DWORD                   cUsageID,
                    LPSTR                   *rgpszUsageID)
{

    BOOL                    fResult=FALSE;
    PURPOSE_INFO_CALL_BACK  PurposeCallBack;
    PCTL_INFO               pCTLInfo=NULL;
    DWORD                   dwIndex=0;

    DWORD                   dwCount=0;
    ENROLL_PURPOSE_INFO     **prgPurposeInfo=NULL;

    //init
    memset(&PurposeCallBack, 0, sizeof(PURPOSE_INFO_CALL_BACK));

    if(NULL==pCertBuildCTLInfo)
        return FALSE;

    //init
    PurposeCallBack.pdwCount=&dwCount;
    PurposeCallBack.pprgPurpose=&prgPurposeInfo;

    //enum all the enhanced key usages
    if(!CryptEnumOIDInfo(
               CRYPT_ENHKEY_USAGE_OID_GROUP_ID,
                0,
                &PurposeCallBack,
                EnumInfoCallback))
        goto CLEANUP;

    //add the existing ones in the old CTL if they do not exist
    //from the enum list
    if(pCertBuildCTLInfo->pSrcCTL)
    {
        if(pCertBuildCTLInfo->pSrcCTL->pCtlInfo)
        {
            pCTLInfo=pCertBuildCTLInfo->pSrcCTL->pCtlInfo;

            for(dwIndex=0; dwIndex<pCTLInfo->SubjectUsage.cUsageIdentifier; dwIndex++)
            {
                if(!SearchAndAddOID(pCTLInfo->SubjectUsage.rgpszUsageIdentifier[dwIndex],
                                &dwCount,
                                &prgPurposeInfo,
                                NULL,
                                FALSE,
                                TRUE,    //mark as selected if new oid
                                TRUE))   //mark as selected if existing oid
                    goto CLEANUP;
            }

        }
    }
    else
    {
        //add the pre-defined OIDs
        if((0!=cUsageID)  && (NULL!=rgpszUsageID))
        {
            for(dwIndex=0; dwIndex<cUsageID; dwIndex++)
            {
                if(!SearchAndAddOID(rgpszUsageID[dwIndex],
                                &dwCount,
                                &prgPurposeInfo,
                                NULL,
                                FALSE,   //do not allocate for the OID
                                TRUE,    //mark as selected if new oid
                                TRUE))   //mark as selected if existing oid
                    goto CLEANUP;

            }

        }

    }

   fResult=TRUE;

CLEANUP:

   if(FALSE==fResult)
   {
       if(prgPurposeInfo)
           FreePurposeInfo(prgPurposeInfo, dwCount);
   }
   else
   {
        pCertBuildCTLInfo->dwPurposeCount=dwCount;
        pCertBuildCTLInfo->prgPurpose=prgPurposeInfo;
   }

   return fResult;


}

//-----------------------------------------------------------------------
//Initialize the usage OID list
//-----------------------------------------------------------------------
BOOL    InitBuildCTLOID(HWND                       hwndList,
                        CERT_BUILDCTL_INFO         *pCertBuildCTLInfo)
{
    DWORD                       dwCount=0;
    ENROLL_PURPOSE_INFO         **prgPurposeInfo=NULL;
    DWORD                       dwIndex=0;
    LV_ITEMW                    lvItem;
    LV_COLUMNW                  lvC;
    int                         dwMaxSize=0;

    if(!hwndList || !pCertBuildCTLInfo)
        return FALSE;

    //get the list of OIDs from the old CTL and all possibilities
    dwCount=pCertBuildCTLInfo->dwPurposeCount;

    prgPurposeInfo=pCertBuildCTLInfo->prgPurpose;

    //mark the list is selected by a check box
    ListView_SetExtendedListViewStyle(hwndList, LVS_EX_CHECKBOXES);

    //get the max length of the column
    for(dwIndex=0; dwIndex<dwCount; dwIndex++)
    {
        if(dwMaxSize < wcslen((prgPurposeInfo[dwIndex])->pwszName))
            dwMaxSize=wcslen((prgPurposeInfo[dwIndex])->pwszName);
    }


    //insert a column into the list view
    memset(&lvC, 0, sizeof(LV_COLUMNW));

    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
    lvC.cx =10;       // (dwMaxSize+2)*7;            // Width of the column, in pixels.
    lvC.pszText = L"";   // The text for the column.
    lvC.iSubItem=0;

    if (ListView_InsertColumnU(hwndList, 0, &lvC) == -1)
        return FALSE;

    //populate the list
    memset(&lvItem, 0, sizeof(LV_ITEMW));
    lvItem.mask=LVIF_TEXT | LVIF_STATE;

    for(dwIndex=0; dwIndex<dwCount; dwIndex++)
    {
        lvItem.iItem=dwIndex;

        lvItem.pszText=(prgPurposeInfo[dwIndex])->pwszName;
        lvItem.cchTextMax=sizeof(WCHAR)*(1+wcslen((prgPurposeInfo[dwIndex])->pwszName));
        lvItem.stateMask  = LVIS_STATEIMAGEMASK;
        lvItem.state      = (prgPurposeInfo[dwIndex])->fSelected ? 0x00002000 : 0x00001000;

        //insert the list
           // insert and set state
        ListView_SetItemState(hwndList,
                                  ListView_InsertItemU(hwndList, &lvItem),
                                  (prgPurposeInfo[dwIndex])->fSelected ? 0x00002000 : 0x00001000,
                                  LVIS_STATEIMAGEMASK);
    }

    //autosize the column
    ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE);

    return TRUE;
}


//-----------------------------------------------------------------------
//populate the list box in the order of
//Purpose, FileName, StoreName,  FriendlyName,
//and any other things signing wizard display
//-----------------------------------------------------------------------
void    DisplayBuildCTLConfirmation(HWND                hwndControl,
                                   CERT_BUILDCTL_INFO  *pCertBuildCTLInfo)
{

    DWORD           dwIndex=0;
    LPWSTR          pwszStoreName=NULL;
    WCHAR           wszNone[MAX_TITLE_LENGTH];
    BOOL            fNewItem=FALSE;
    DWORD           dwSize=0;
    LPWSTR          pwszValidityString=NULL;

    LV_COLUMNW       lvC;
    LV_ITEMW         lvItem;

    //pCertBuildCTLInfo has to be valid
    if(!pCertBuildCTLInfo)
        return;

    //delete all the old items in the listView
    ListView_DeleteAllItems(hwndControl);

    //load the string <none>
    if(!LoadStringU(g_hmodThisDll, IDS_NONE, wszNone, MAX_TITLE_LENGTH))
        *wszNone=L'\0';

    //get the storename
    if(pCertBuildCTLInfo->hDesStore)
    {
        if(!CertGetStoreProperty(
            pCertBuildCTLInfo->hDesStore,
            CERT_STORE_LOCALIZED_NAME_PROP_ID,
            NULL,
            &dwSize) || (0==dwSize))
        {

            //Get the  <Unknown> string
            pwszStoreName=(LPWSTR)WizardAlloc(MAX_TITLE_LENGTH * sizeof(WCHAR));

            if(pwszStoreName)
            {
                *pwszStoreName=L'\0';

                LoadStringU(g_hmodThisDll, IDS_UNKNOWN, pwszStoreName, MAX_TITLE_LENGTH);
            }
        }
        else
        {
            pwszStoreName=(LPWSTR)WizardAlloc(dwSize);

            if(pwszStoreName)
            {
                *pwszStoreName=L'\0';

                CertGetStoreProperty(
                    pCertBuildCTLInfo->hDesStore,
                    CERT_STORE_LOCALIZED_NAME_PROP_ID,
                    pwszStoreName,
                    &dwSize);
            }
        }
    }

    //insert row by row
    memset(&lvItem, 0, sizeof(LV_ITEMW));

    // set up the fields in the list view item struct that don't change from item to item
    lvItem.mask = LVIF_TEXT | LVIF_STATE ;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.iItem=0;
    lvItem.iSubItem=0;

    //Purpose.  We are guaranteed to have at least one item in the purpose list
    ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_CTL_PURPOSE, NULL);

    for(dwIndex=0; dwIndex<pCertBuildCTLInfo->dwPurposeCount; dwIndex++)
    {
        if(TRUE==((pCertBuildCTLInfo->prgPurpose)[dwIndex]->fSelected))
        {
            if(TRUE==fNewItem)
            {
                //increase the row
                lvItem.iItem++;
                lvItem.pszText=L"";
                lvItem.iSubItem=0;
                ListView_InsertItemU(hwndControl, &lvItem);

            }
            else
                fNewItem=TRUE;

            lvItem.iSubItem++;

            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                       (pCertBuildCTLInfo->prgPurpose)[dwIndex]->pwszName);

        }
    }

    //list ID
    lvItem.iItem++;
    lvItem.iSubItem=0;

    ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_CTL_ID, NULL);

    //content
    lvItem.iSubItem++;

    if(pCertBuildCTLInfo->pwszListID)
        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,pCertBuildCTLInfo->pwszListID);
    else
       ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,wszNone);


    //validity
    lvItem.iItem++;
    lvItem.iSubItem=0;

    ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_CTL_VALIDITY, NULL);

    //content
    lvItem.iSubItem++;

    if(pCertBuildCTLInfo->dwValidMonths || pCertBuildCTLInfo->dwValidDays)
    {
        GetValidityString(pCertBuildCTLInfo->dwValidMonths, pCertBuildCTLInfo->dwValidDays,
                        &pwszValidityString);

        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,pwszValidityString);
    }
    else
       ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,wszNone);


    //only show the file name or store name if the destination page
    //is not skipped
    if(0 == (pCertBuildCTLInfo->dwFlag & CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION))
    {

        //file name
        if(pCertBuildCTLInfo->pwszFileName && (TRUE==(pCertBuildCTLInfo->fSelectedFileName)))
        {
            lvItem.iItem++;
            lvItem.iSubItem=0;

            ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_FILE_NAME, NULL);

            //content
            lvItem.iSubItem++;

            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                pCertBuildCTLInfo->pwszFileName);
        }


         //StoreName
        if(pCertBuildCTLInfo->hDesStore && (TRUE==pCertBuildCTLInfo->fSelectedDesStore))
        {
            if(pwszStoreName)
            {
                lvItem.iItem++;
                lvItem.iSubItem=0;

                ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_STORE_NAME, NULL);

                //content
                lvItem.iSubItem++;

                ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
                    pwszStoreName);
            }
        }
    }


    //FriendlyName and descripton will be displayed if the hDesStore is not NULL
 //   if(pCertBuildCTLInfo->hDesStore && (TRUE==pCertBuildCTLInfo->fSelectedDesStore))
   // {
        //friendlyName
        lvItem.iItem++;
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_FRIENDLY_NAME, NULL);

        //content
        lvItem.iSubItem++;

        if(pCertBuildCTLInfo->pwszFriendlyName)
            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,pCertBuildCTLInfo->pwszFriendlyName);
        else
           ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,wszNone);


        //description
        lvItem.iItem++;
        lvItem.iSubItem=0;

        ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_DESCRIPTION, NULL);

        //content
        lvItem.iSubItem++;

        if(pCertBuildCTLInfo->pwszDescription)
            ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,pCertBuildCTLInfo->pwszDescription);
        else
           ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,wszNone);

    //}

    //autosize the columns
    ListView_SetColumnWidth(hwndControl, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(hwndControl, 1, LVSCW_AUTOSIZE);


    //free the memory
    if(pwszStoreName)
        WizardFree(pwszStoreName);

    if(pwszValidityString)
        WizardFree(pwszValidityString);

    return;
}

//**************************************************************************
//
//    The winProcs for the buildCtl wizard
//**************************************************************************
//-----------------------------------------------------------------------
//BuildCTL_Welcome
//-----------------------------------------------------------------------
INT_PTR APIENTRY BuildCTL_Welcome(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CERT_BUILDCTL_INFO       *pCertBuildCTLInfo=NULL;
    PROPSHEETPAGEW           *pPropSheet=NULL;


	switch (msg)
	{
		case WM_INITDIALOG:
            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGEW *) lParam;
            pCertBuildCTLInfo = (CERT_BUILDCTL_INFO *) (pPropSheet->lParam);
            //make sure pCertBuildCTLInfo is a valid pointer
            if(NULL==pCertBuildCTLInfo)
               break;
            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertBuildCTLInfo);

            SetControlFont(pCertBuildCTLInfo->hBigBold, hwndDlg,IDC_WIZARD_STATIC_BIG_BOLD1);
            SetControlFont(pCertBuildCTLInfo->hBold,    hwndDlg,IDC_WIZARD_STATIC_BOLD1);

			break;

		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:

                            if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //check if we need to skip the 1st page
                            if(CRYPTUI_WIZ_BUILDCTL_SKIP_PURPOSE & pCertBuildCTLInfo->dwFlag)
                            {
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_BUILDCTL_CERTS);
                            }


                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}
//-----------------------------------------------------------------------
//BuildCTL_Purpose
//-----------------------------------------------------------------------
INT_PTR APIENTRY BuildCTL_Purpose(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CERT_BUILDCTL_INFO       *pCertBuildCTLInfo=NULL;
    PROPSHEETPAGEW           *pPropSheet=NULL;

    HWND                    hwndControl=NULL;
    DWORD                   dwCount=0;
    DWORD                   dwIndex=0;
    NM_LISTVIEW FAR *       pnmv=NULL;
    int                     intMsg=0;
    LPSTR                   pszNewOID;
    BOOL                    fFound=FALSE;
    LV_ITEMW                lvItem;
    DWORD                   dwChar=0;
    WCHAR                   wszMonth[BUILDCTL_DURATION_SIZE];
    WCHAR                   wszDay[BUILDCTL_DURATION_SIZE];
    BOOL                    fUserTypeDuration=FALSE;

    LPWSTR                  pwszDuration=NULL;


	switch (msg)
	{
		case WM_INITDIALOG:
            HWND hwndFocus;

            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGEW *) lParam;
            pCertBuildCTLInfo = (CERT_BUILDCTL_INFO *) (pPropSheet->lParam);
            //make sure pCertBuildCTLInfo is a valid pointer
            if(NULL==pCertBuildCTLInfo)
                break;

            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertBuildCTLInfo);

            SetControlFont(pCertBuildCTLInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

            //initizialize the OID list
            InitBuildCTLOID(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1),
                pCertBuildCTLInfo);

            //initialize the ListID
            if(pCertBuildCTLInfo->pwszListID)
                SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1, pCertBuildCTLInfo->pwszListID);

            //mark that we are done with the init OID ListView
            //if user de-select OIDs from now on, they will be prompted for the
            //warning
            pCertBuildCTLInfo->fCompleteInit=TRUE;

            //init the dwValidMonth and dwValidDays
            if(pCertBuildCTLInfo->dwValidMonths != 0)
            {
                _ltow(pCertBuildCTLInfo->dwValidMonths, wszMonth, 10);
                SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT_MONTH,  wszMonth);
            }

            if(pCertBuildCTLInfo->dwValidDays != 0)
            {
                _ltow(pCertBuildCTLInfo->dwValidDays,   wszDay, 10);

                SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT_DAY,    wszDay);
            }

#if (1) //DSIE: Bug 483644.
            ListView_SetItemState(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), 
                                  0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
#endif

			break;

		case WM_COMMAND:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    switch (LOWORD(wParam))
                    {
                        case    IDC_WIZARD_BUTTON1:
                                if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                {
                                    break;
                                }

                                //get the window handle of the cert list view
                                if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                                    break;

                                //prompt user to enter the user OID
                                pszNewOID = (LPSTR) DialogBoxU(
                                    g_hmodThisDll,
                                    (LPCWSTR)MAKEINTRESOURCE(IDD_BUILDCTL_USER_PURPOSE),
                                    hwndDlg,
                                    CTLOIDDialogProc);

                                //add the OID to the list
                                if(NULL != pszNewOID)
                                {
                                    SearchAndAddOID(
                                        pszNewOID,
                                        &(pCertBuildCTLInfo->dwPurposeCount),
                                        &(pCertBuildCTLInfo->prgPurpose),
                                        &fFound,
                                        TRUE,
                                        TRUE,      //mark as selected if new oid
                                        FALSE);    //do not mark as selected if existing oid

                                    if(fFound==TRUE)
                                    {
                                        I_MessageBox(hwndDlg, IDS_EXISTING_OID,
                                                    IDS_BUILDCTL_WIZARD_TITLE,
                                                    NULL,
                                                    MB_ICONINFORMATION|MB_OK|MB_APPLMODAL);

                                                }
                                    else
                                    {
                                        //add the item to the list view

                                        //populate the list
                                        memset(&lvItem, 0, sizeof(LV_ITEMW));
                                        lvItem.mask=LVIF_TEXT | LVIF_STATE;

                                        lvItem.iItem=pCertBuildCTLInfo->dwPurposeCount-1;

                                        lvItem.pszText=(pCertBuildCTLInfo->prgPurpose[pCertBuildCTLInfo->dwPurposeCount-1])->pwszName;
                                        lvItem.cchTextMax=sizeof(WCHAR)*(1+wcslen
                                            ((pCertBuildCTLInfo->prgPurpose[pCertBuildCTLInfo->dwPurposeCount-1])->pwszName));

                                        lvItem.stateMask  = LVIS_STATEIMAGEMASK;
                                        lvItem.state      = (pCertBuildCTLInfo->prgPurpose[pCertBuildCTLInfo->dwPurposeCount-1])->fSelected ? 0x00002000 : 0x00001000;


                                        // insert and set state
                                        //mark no warning for the user
                                        pCertBuildCTLInfo->fCompleteInit=FALSE;

                                        ListView_SetItemState(hwndControl,
                                                    ListView_InsertItemU(hwndControl, &lvItem),
                                                    (pCertBuildCTLInfo->prgPurpose[pCertBuildCTLInfo->dwPurposeCount-1])->fSelected ? 0x00002000 : 0x00001000,
                                                    LVIS_STATEIMAGEMASK);

                                        //mark the end of setting
                                        pCertBuildCTLInfo->fCompleteInit=TRUE;

                                        //autosize the column
                                        ListView_SetColumnWidth(hwndControl, 0, LVSCW_AUTOSIZE);

                                    }
                                }

                                //free the pszNewOID
                                if(pszNewOID)
                                        WizardFree(pszNewOID);
                            break;
                    }
                }

			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);

					    break;

                    case PSN_WIZBACK:


                        break;

                    case LVN_ITEMCHANGING:

                            if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                            {
                                break;
                            }

                            //the item has been chagned.
                            pnmv = (NM_LISTVIEW FAR *) lParam;

                            if(NULL==pnmv)
                                break;

                            //ingore if we have not complete the init yet
                            if(NULL == pCertBuildCTLInfo->prgPurpose)
                                 //we allow change
                                 return FALSE;

                            //ignore if we are not complete with the
                            //init yet
                            if(FALSE==pCertBuildCTLInfo->fCompleteInit)
                                return FALSE;

                            //see if the new item is de-selected
                            if(pnmv->uChanged & LVIF_STATE)
                            {
                                if(FALSE==(((pnmv->uNewState & LVIS_STATEIMAGEMASK)>> 12) -1))
                                {
                                    if(TRUE==(pCertBuildCTLInfo->prgPurpose[pnmv->iItem])->fSelected)
                                    {
                                        //check to see if the user has selected any certs
                                        if(0!=pCertBuildCTLInfo->dwCertCount)
                                        {
                                            //ask user if they are sure to change the subject
                                            //of the CTL, thus the whole cert list will be gone
                                            intMsg=I_MessageBox(hwndDlg, IDS_SURE_CERT_GONE,
                                                    IDS_BUILDCTL_WIZARD_TITLE,
                                                    NULL,
                                                    MB_ICONEXCLAMATION|MB_YESNO|MB_APPLMODAL);

                                            if(IDYES==intMsg)
                                            {

                                                //free all the certificate context and
                                                //clear the listView of the ceritificate
                                                pCertBuildCTLInfo->fClearCerts=TRUE;

                                                //we allow change
                                                return FALSE;
                                            }

                                            //we disallow the change
                                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, TRUE);

                                            return TRUE;
                                        }

                                    }

                                }
                            }

                            //we allow the chagne
                            return FALSE;

                            break;
                    case PSN_WIZNEXT:

                            if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //get the window handle of the purpose list view
                            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                                break;

                            //get the count of selected OIDs and mark them
                            dwCount=0;

                            for(dwIndex=0; dwIndex<pCertBuildCTLInfo->dwPurposeCount; dwIndex++)
                            {
                                //mark the selected OIDS.  Keep track of
                                //if the OID selections have been changed
                                if(ListView_GetCheckState(hwndControl, dwIndex))
                                {
                                    ((pCertBuildCTLInfo->prgPurpose)[dwIndex])->fSelected=TRUE;
                                    dwCount++;
                                }
                                else
                                {
                                    ((pCertBuildCTLInfo->prgPurpose)[dwIndex])->fSelected=FALSE;
                                }

                            }

                            if(0==dwCount)
                            {
                                I_MessageBox(hwndDlg, IDS_NO_SELECTED_CTL_PURPOSE,
                                                IDS_BUILDCTL_WIZARD_TITLE,
                                                NULL,
                                                MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                //the page should stay
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                break;

                            }

                            //get the list ID if user has specified it.
                            if(pCertBuildCTLInfo->pwszListID)
                            {
                                WizardFree(pCertBuildCTLInfo->pwszListID);
                                pCertBuildCTLInfo->pwszListID=NULL;
                            }

                            if(0!=(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
                                                   IDC_WIZARD_EDIT1,
                                                   WM_GETTEXTLENGTH, 0, 0)))
                            {


                                pCertBuildCTLInfo->pwszListID=(LPWSTR)WizardAlloc(sizeof(WCHAR)*(dwChar+1));

                                if(NULL!=pCertBuildCTLInfo->pwszListID)
                                {
                                    GetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,
                                                    pCertBuildCTLInfo->pwszListID,
                                                    dwChar+1);

                                }
                                else
                                    //we are out of memory and out of hope
                                    break;
                            }

                            //get the valid month and valid days that user specified
                             if(0!=(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
                                                   IDC_WIZARD_EDIT_MONTH,
                                                   WM_GETTEXTLENGTH, 0, 0)))
                             {

                                fUserTypeDuration=TRUE;

                                pwszDuration=(LPWSTR)WizardAlloc(sizeof(WCHAR)*(dwChar+1));

                                if(NULL!=pwszDuration)
                                {
                                    GetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT_MONTH,
                                                    pwszDuration,
                                                    dwChar+1);

                                }
                                else
                                    //we are out of memory and out of hope
                                    break;

                                //make sure the character are valid
                                /*if(!ValidDuration(pwszDuration))
                                {
                                    I_MessageBox(hwndDlg, IDS_INVALID_MONTHS,
                                            IDS_BUILDCTL_WIZARD_TITLE,
                                            NULL,
                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                    WizardFree(pwszDuration);

                                    pwszDuration=NULL;

                                    //the page should stay
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                    break;
                                }*/

                                pCertBuildCTLInfo->dwValidMonths=_wtol(pwszDuration);

                                /*if( (0 == pCertBuildCTLInfo->dwValidMonths && !ValidZero(pwszDuration)) ||
                                     (0 > _wtol(pwszDuration))
                                 )
                                {
                                    if(!ValidZero(pwszDuration))
                                    {
                                        I_MessageBox(hwndDlg, IDS_INVALID_MONTHS,
                                                IDS_BUILDCTL_WIZARD_TITLE,
                                                NULL,
                                                MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                        WizardFree(pwszDuration);

                                        pwszDuration=NULL;

                                        //the page should stay
                                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                        break;
                                    }
                                } */
                             }
                             else
                                 pCertBuildCTLInfo->dwValidMonths=0;

                             //Free the memory
                             if(pwszDuration)
                             {
                                 WizardFree(pwszDuration);
                                 pwszDuration=NULL;
                             }

                             //valid days
                             if(0!=(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
                                                  IDC_WIZARD_EDIT_DAY,
                                                  WM_GETTEXTLENGTH, 0, 0)))
                             {
                                fUserTypeDuration=TRUE;

                                pwszDuration=(LPWSTR)WizardAlloc(sizeof(WCHAR)*(dwChar+1));

                                if(NULL!=pwszDuration)
                                {
                                    GetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT_DAY,
                                                    pwszDuration,
                                                    dwChar+1);
                                }
                                else
                                    //we are out of memory and out of hope
                                    break;

                                //make sure the character are valid
                                /*if(!ValidDuration(pwszDuration))
                                {
                                    I_MessageBox(hwndDlg, IDS_INVALID_DAYS,
                                            IDS_BUILDCTL_WIZARD_TITLE,
                                            NULL,
                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                    WizardFree(pwszDuration);

                                    pwszDuration=NULL;

                                    //the page should stay
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                    break;
                                }*/

                                pCertBuildCTLInfo->dwValidDays=_wtol(pwszDuration);

                                /*if( (0 == pCertBuildCTLInfo->dwValidDays && !ValidZero(pwszDuration)) ||
                                     (0 > _wtol(pwszDuration))
                                 )
                                {
                                    I_MessageBox(hwndDlg, IDS_INVALID_DAYS,
                                            IDS_BUILDCTL_WIZARD_TITLE,
                                            NULL,
                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                    WizardFree(pwszDuration);

                                    pwszDuration=NULL;

                                    //the page should stay
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                    break;
                                }*/
                             }
                             else
                                 pCertBuildCTLInfo->dwValidDays=0;


                             //Free the memory
                             if(pwszDuration)
                             {
                                 WizardFree(pwszDuration);
                                 pwszDuration=NULL;
                             }

                             //make sure that user did type in some valid duration
                             if(0 == pCertBuildCTLInfo->dwValidDays &&
                                 0 == pCertBuildCTLInfo->dwValidMonths &&
                                 TRUE== fUserTypeDuration)
                             {

                                    I_MessageBox(hwndDlg, IDS_INVALID_DURATION,
                                            IDS_BUILDCTL_WIZARD_TITLE,
                                            NULL,
                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                    //the page should stay
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                    break;
                             }


                             //make sure that the dwValidMonth + dwValidDays
                             //will not exceed 99 month + some extra days
                             if(pCertBuildCTLInfo->dwValidDays ||
                                 pCertBuildCTLInfo->dwValidMonths)
                             {
                                if(!DurationWithinLimit(pCertBuildCTLInfo->dwValidMonths,
                                                       pCertBuildCTLInfo->dwValidDays))
                                {
                                    I_MessageBox(hwndDlg, IDS_EXCEED_LIMIT,
                                            IDS_BUILDCTL_WIZARD_TITLE,
                                            NULL,
                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                    //the page should stay
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                    break;
                                }
                             }

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------
//BuildCTL_Certs
//-----------------------------------------------------------------------
INT_PTR APIENTRY BuildCTL_Certs(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CERT_BUILDCTL_INFO       *pCertBuildCTLInfo=NULL;
    PROPSHEETPAGEW           *pPropSheet=NULL;
    HCERTSTORE              hCertStore=NULL;
    PCCERT_CONTEXT          pCertContext=NULL;
    PCCERT_CONTEXT          pPreCertContext=NULL;

    BOOL                    fSelfSigned=TRUE;
    BOOL                    fCTLUsage=TRUE;
    BOOL                    fEmptyStore=TRUE;
    BOOL                    fDuplicateCert=TRUE;

    HWND                    hwndControl=NULL;
    DWORD                   dwCount=0;
    DWORD                   dwIndex=0;
    int                     listIndex=0;
    WCHAR                   wszText[MAX_STRING_SIZE];
    UINT                    rgIDS[]={IDS_COLUMN_SUBJECT,
                                     IDS_COLUMN_ISSUER,
                                     IDS_COLUMN_PURPOSE,
                                     IDS_COLUMN_EXPIRE};

    LV_COLUMNW              lvC;
    CRYPTUI_VIEWCERTIFICATE_STRUCT    CertViewStruct;
    DWORD                   dwSortParam=0;
    LV_ITEM                 lvItem;
    NM_LISTVIEW FAR *       pnmv=NULL;
    BOOL                    fErrorDisplayed=FALSE;
    int                     i;


	switch (msg)
	{
		case WM_INITDIALOG:
            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGEW *) lParam;
            pCertBuildCTLInfo = (CERT_BUILDCTL_INFO *) (pPropSheet->lParam);
            //make sure pCertBuildCTLInfo is a valid pointer
            if(NULL==pCertBuildCTLInfo)
            {
                break;
            }

            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertBuildCTLInfo);

            SetControlFont(pCertBuildCTLInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

            // set the style in the list view so that it highlights an entire line
            SendMessageA(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

            //insert columns with headers into the listView control
            dwCount=sizeof(rgIDS)/sizeof(rgIDS[0]);

            //get the window handle of the cert list view
            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                break;

            //set up the common info for the column
            memset(&lvC, 0, sizeof(LV_COLUMNW));

            lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
            lvC.cx = 145;          // Width of the column, in pixels.
            lvC.iSubItem=0;
            lvC.pszText = wszText;   // The text for the column.


            //inser the column one at a time
            for(dwIndex=0; dwIndex<dwCount; dwIndex++)
            {
                //get the column header
                wszText[0]=L'\0';

                LoadStringU(g_hmodThisDll, rgIDS[dwIndex], wszText, MAX_STRING_SIZE);

                ListView_InsertColumnU(hwndControl, dwIndex, &lvC);
            }

            //initlize the ListView by populate the original certs
            //from the existing CTL
            InitCertList(
                hwndControl,
                pCertBuildCTLInfo);

            //get the item count
            if(ListView_GetItemCount(hwndControl))
            {

                //sort the certificates by the 1st column
                dwSortParam=pCertBuildCTLInfo->rgdwSortParam[0];

                if(0!=dwSortParam)
                {
                    //sort the 1st column
                    SendDlgItemMessage(hwndDlg,
                        IDC_WIZARD_LIST1,
                        LVM_SORTITEMS,
                        (WPARAM) (LPARAM) dwSortParam,
                        (LPARAM) (PFNLVCOMPARE)CompareCertificate);
                }
            }
            else
            {
                //we reset the ordering order
                pCertBuildCTLInfo->rgdwSortParam[0]=SORT_COLUMN_SUBJECT | SORT_COLUMN_DESCEND;

            }

            //Disable the Buttons for View or Delete if no selection
            //has been made
            //get the window handle of the cert list view
            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                                    break;

            //get the selected item
            listIndex = ListView_GetNextItem(
                                    hwndControl, 		
                                    -1, 		
                                    LVNI_SELECTED		
                                    );

            if(-1 == listIndex)
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON3), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON4), FALSE);
            }
            
            break;

		case WM_COMMAND:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    switch (LOWORD(wParam))
                    {
                        //add a certificate from a store
                        case    IDC_WIZARD_BUTTON1:
                                if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                    break;

                                //get the window handle of the cert list view
                                if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                                    break;

                                //get the certificate from the stores
                                if(hCertStore=GetCertsFromStore(hwndDlg, pCertBuildCTLInfo))
                                {
                                    pCertContext = NULL;
                                    while (NULL != (pCertContext = CertEnumCertificatesInStore(
                                                                        hCertStore,
                                                                        pCertContext)))
                                    {
                                        if(AddCertToBuildCTL(
                                                CertDuplicateCertificateContext(pCertContext), 
                                                pCertBuildCTLInfo))
                                        {
                                            //add the certificat to the window
                                            AddCertToList(hwndControl,pCertContext,
                                                pCertBuildCTLInfo->dwCertCount-1);
                                        }
                                        else if (!fErrorDisplayed)
                                        {
                                            fErrorDisplayed = TRUE;

                                            //warn the user that the certificate already exists
                                             I_MessageBox(hwndDlg, IDS_EXIT_CERT_IN_CTL,
                                                         IDS_BUILDCTL_WIZARD_TITLE,
                                                         NULL,
                                                         MB_ICONINFORMATION|MB_OK|MB_APPLMODAL);

                                        }
                                    }

                                    CertCloseStore(hCertStore, 0);
                                }

                            break;
                          //add a certificate from a file
                         case   IDC_WIZARD_BUTTON2:

                                if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                    break;

                                //get the window handle of the cert list view
                                if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                                    break;

                                //get the file name.  Make sure the cert is correct
                                if(hCertStore=GetCertStoreFromFile(hwndDlg, pCertBuildCTLInfo))
                                {
                                    while(pCertContext=CertEnumCertificatesInStore(
                                                       hCertStore,
                                                       pPreCertContext))
                                    {
                                        fEmptyStore=FALSE;

                                        //make sure this is a valid certificate
                                         //make sure the pCertContext is a self-signed certificate
                                         if(!TrustIsCertificateSelfSigned(pCertContext, pCertContext->dwCertEncodingType, 0))
                                         {
                                             if(fSelfSigned)
                                             {
                                                I_MessageBox(hwndDlg, IDS_SOME_NOT_SELF_SIGNED,
                                                     IDS_BUILDCTL_WIZARD_TITLE,
                                                     NULL,
                                                     MB_ICONEXCLAMATION|MB_OK|MB_APPLMODAL);

                                                //no need to pop up the information anymore
                                                fSelfSigned=FALSE;
                                             }

                                             pPreCertContext=pCertContext;
                                             continue;
                                         }


                                         //make sure the certifcate match what is defined on the CTL list
                                         if(!CertMatchCTL(pCertBuildCTLInfo, pCertContext))
                                         {
                                             if(fCTLUsage)
                                             {
                                                I_MessageBox(hwndDlg, IDS_SOME_NO_MATCH_USAGE,
                                                     IDS_BUILDCTL_WIZARD_TITLE,
                                                     NULL,
                                                     MB_ICONEXCLAMATION|MB_OK|MB_APPLMODAL);

                                                //no need to pop up the information anymore
                                                fCTLUsage=FALSE;
                                             }

                                             pPreCertContext=pCertContext;
                                             continue;
                                         }

                                        //get a duplicate copy
                                        pPreCertContext=CertDuplicateCertificateContext(pCertContext);

                                        if(NULL==pPreCertContext)
                                        {
                                            pPreCertContext=pCertContext;
                                            continue;
                                        }

                                        if(AddCertToBuildCTL(pPreCertContext, pCertBuildCTLInfo))
                                        {
                                            //add the certificat to the window
                                            AddCertToList(hwndControl,pPreCertContext,
                                                pCertBuildCTLInfo->dwCertCount-1);
                                        }
                                        else
                                        {
                                            if(fDuplicateCert)
                                            {
                                                //warn the user that the certificate already exists
                                                 I_MessageBox(hwndDlg, IDS_EXIT_CERT_IN_CTL,
                                                             IDS_BUILDCTL_WIZARD_TITLE,
                                                             NULL,
                                                             MB_ICONINFORMATION|MB_OK|MB_APPLMODAL);

                                                 fDuplicateCert=FALSE;
                                            }

                                            CertFreeCertificateContext(pPreCertContext);
                                        }

                                        pPreCertContext=pCertContext;
                                    }


                                    //warn the user that the store is empty
                                    if(TRUE == fEmptyStore)
                                    {
                                         I_MessageBox(hwndDlg, IDS_EMPTY_CERT_IN_FILE,
                                                     IDS_BUILDCTL_WIZARD_TITLE,
                                                     NULL,
                                                     MB_ICONEXCLAMATION|MB_OK|MB_APPLMODAL);
                                    }
                                }

                                pPreCertContext=NULL;
                                pCertContext=NULL;

                                if(hCertStore)
                                    CertCloseStore(hCertStore, 0);

                                hCertStore=NULL;
                           break;

                          //remove a certificate from the store
                         case   IDC_WIZARD_BUTTON3:
                                if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                    break;

                                //get the window handle of the cert list view
                                if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                                    break;

                                memset(&lvItem, 0, sizeof(lvItem));
                                lvItem.mask = LVIF_STATE | LVIF_PARAM;
                                lvItem.stateMask = LVIS_SELECTED;

                                for (i=(ListView_GetItemCount(hwndControl) - 1); i >=0; i--)
                                {
                                    lvItem.iItem = i;
                
                                    if (ListView_GetItem(hwndControl, &lvItem) &&
                                        (lvItem.state & LVIS_SELECTED))
                                    {
                                       if(DeleteCertFromBuildCTL(pCertBuildCTLInfo, (PCCERT_CONTEXT)(lvItem.lParam)))
                                       {
                                            //delete the item from the list
                                            ListView_DeleteItem(hwndControl, lvItem.iItem);
                                       }
                                    }
                                }
#if (1) //DSIE: Bug 483667.
                                if (ListView_GetItemCount(hwndControl) == 0)
                                {
                                    SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON1), BM_SETSTYLE, BS_DEFPUSHBUTTON, 0);
                                    SetFocus(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON1));
                                }
                                else
                                {
                                    ListView_SetItemState(hwndControl, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                                    SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON3), BM_SETSTYLE, BS_DEFPUSHBUTTON, 0);
                                    SetFocus(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON3));
                                }
#endif
                                break;

                            //view a certificate
                        case    IDC_WIZARD_BUTTON4:
                                if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                {
                                    break;
                                }

                                //get the window handle of the cert list view
                                if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                                    break;

                                //get the selected cert
                                listIndex = ListView_GetNextItem(
                                    hwndControl, 		
                                    -1, 		
                                    LVNI_SELECTED		
                                    );

                                if (listIndex != -1)
                                {

                                  //get the selected certificate
                                    memset(&lvItem, 0, sizeof(LV_ITEM));
                                    lvItem.mask=LVIF_PARAM;
                                    lvItem.iItem=listIndex;

                                    if(ListView_GetItem(hwndControl, &lvItem))
                                    {
                                        //view certiificate
                                       if(pCertBuildCTLInfo->dwCertCount > (DWORD)listIndex)
                                       {
                                            memset(&CertViewStruct, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));
                                            CertViewStruct.dwSize=sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT);
                                            CertViewStruct.pCertContext=(PCCERT_CONTEXT)(lvItem.lParam);
                                            CertViewStruct.hwndParent=hwndDlg;
                                            CertViewStruct.dwFlags=CRYPTUI_DISABLE_EDITPROPERTIES;
                                            CryptUIDlgViewCertificate(&CertViewStruct, NULL);
                                       }
                                   }
                                }
                                else
                                    //output the message
                                    I_MessageBox(hwndDlg, IDS_HAS_TO_SELECT_CERT,
                                            IDS_BUILDCTL_WIZARD_TITLE,
                                            NULL,
                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);

                            break;
                        default:
                            break;
                    }
                }

			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {
                    //the column has been clicked
                    case LVN_COLUMNCLICK:

                            if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                 break;

                            //get the window handle of the purpose list view
                            if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                                break;

                            pnmv = (NM_LISTVIEW FAR *) lParam;

                            //get the column number
                            dwSortParam=0;

                            switch(pnmv->iSubItem)
                            {
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                        dwSortParam=pCertBuildCTLInfo->rgdwSortParam[pnmv->iSubItem];
                                    break;
                                default:
                                        dwSortParam=0;
                                    break;
                            }

                            if(0!=dwSortParam)
                            {
                                //remember to flip the ascend ording

                                if(dwSortParam & SORT_COLUMN_ASCEND)
                                {
                                    dwSortParam &= 0x0000FFFF;
                                    dwSortParam |= SORT_COLUMN_DESCEND;
                                }
                                else
                                {
                                    if(dwSortParam & SORT_COLUMN_DESCEND)
                                    {
                                        dwSortParam &= 0x0000FFFF;
                                        dwSortParam |= SORT_COLUMN_ASCEND;
                                    }
                                }

                                //sort the column
                                SendDlgItemMessage(hwndDlg,
                                    IDC_WIZARD_LIST1,
                                    LVM_SORTITEMS,
                                    (WPARAM) (LPARAM) dwSortParam,
                                    (LPARAM) (PFNLVCOMPARE)CompareCertificate);

                                pCertBuildCTLInfo->rgdwSortParam[pnmv->iSubItem]=dwSortParam;

                            }

                        break;

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);

                        if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                        {
                            break;
                        }

                        //get the window handle of the purpose list view
                        if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                            break;

                        //see if we need to clear the certs
                        if(TRUE==pCertBuildCTLInfo->fClearCerts)
                        {
                            pCertBuildCTLInfo->fClearCerts=FALSE;

                            //clear the list view
                            ListView_DeleteAllItems(hwndControl);

                            //free all the certificate context
                            FreeCerts(pCertBuildCTLInfo);
                        }

					    break;

                    case PSN_WIZBACK:
                            if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //check if we need to skip the 1st page
                            if(CRYPTUI_WIZ_BUILDCTL_SKIP_PURPOSE & pCertBuildCTLInfo->dwFlag)
                            {
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_BUILDCTL_WELCOME);
                            }


                        break;

                    case PSN_WIZNEXT:


                            if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                            {
                                break;
                            }

                            if(0==pCertBuildCTLInfo->dwCertCount)
                            {
                                I_MessageBox(hwndDlg, IDS_HAS_TO_SELECT_CERT,
                                                IDS_BUILDCTL_WIZARD_TITLE,
                                                NULL,
                                                MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                //the page should stay
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                            }
                        break;
                    case NM_DBLCLK:

                        switch (((NMHDR FAR *) lParam)->idFrom)
                        {
                            case IDC_WIZARD_LIST1:

                                    if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                        break;

                                    //get the window handle of the cert list view
                                    if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                                        break;

                                    //get the selected cert
                                    listIndex = ListView_GetNextItem(
                                        hwndControl, 		
                                        -1, 		
                                        LVNI_SELECTED		
                                        );

                                    if (listIndex != -1)
                                    {
                                        //get the selected certificate
                                        memset(&lvItem, 0, sizeof(LV_ITEM));
                                        lvItem.mask=LVIF_PARAM;
                                        lvItem.iItem=listIndex;

                                        if(ListView_GetItem(hwndControl, &lvItem))
                                        {
                                            //view certiificate
                                           if(pCertBuildCTLInfo->dwCertCount > (DWORD)listIndex)
                                           {
                                                memset(&CertViewStruct, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));
                                                CertViewStruct.dwSize=sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT);
                                                CertViewStruct.pCertContext=(PCCERT_CONTEXT)(lvItem.lParam);
                                                CertViewStruct.hwndParent=hwndDlg;
                                                CertViewStruct.dwFlags=CRYPTUI_DISABLE_EDITPROPERTIES;

                                                CryptUIDlgViewCertificate(&CertViewStruct, NULL);
                                           }
                                        }
                                    }
                                    else
                                        //output the message
                                        I_MessageBox(hwndDlg, IDS_HAS_TO_SELECT_CERT,
                                                IDS_BUILDCTL_WIZARD_TITLE,
                                                NULL,
                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);
                                break;

                            default:
                                break;
                        }

                        break;
                   /* case  NM_CLICK:
                        {

                            switch (((NMHDR FAR *) lParam)->idFrom)
                            {
                                case IDC_WIZARD_LIST1:
                                    //get the window handle of the cert list view
                                    if(NULL==(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)))
                                                            break;

                                    //get the selected item
                                    listIndex = ListView_GetNextItem(
                                                            hwndControl, 		
                                                            -1, 		
                                                            LVNI_SELECTED		
                                                            );

                                    if(-1 != listIndex)
                                    {

                                        EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON3), TRUE);
                                        EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON4), TRUE);
                                    }
                                    break;
                            }
                        }
                        break; */

#if (1) //DSIE: 483656.
                    case LVN_INSERTITEM:
                        pnmv = (LPNMLISTVIEW) lParam;

                        if (pnmv->iItem == 0)
                        {
                            ListView_SetItemState(pnmv->hdr.hwndFrom, 
                                0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                        }

                        break;
#endif
                    //the item has been selected
                    case LVN_ITEMCHANGED:
                        //
                        // if an item is selected, then enable the remove button, otherwise
                        // disable it
                        if (ListView_GetSelectedCount(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1)) == 0)
                        {
                            EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON3), FALSE);
                            EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON4), FALSE);
                        }
                        else
                        {
                            EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON3), TRUE);
                            EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON4), TRUE);
                        }

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}
//-----------------------------------------------------------------------
// BuildCTL_Destination
//-----------------------------------------------------------------------
INT_PTR APIENTRY BuildCTL_Destination(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CERT_BUILDCTL_INFO      *pCertBuildCTLInfo=NULL;
    PROPSHEETPAGEW           *pPropSheet=NULL;
    HWND                    hwndControl=NULL;
    OPENFILENAMEW           OpenFileName;
    WCHAR                   szFileName[_MAX_PATH];
    static WCHAR            wszFileName[_MAX_PATH];
    WCHAR                   szFilter[MAX_STRING_SIZE]; //"Certificate Trust List (*.ctl)\0*.ctl\0All Files\0*.*\0"
    DWORD                   dwSize=0;

    LPWSTR                  pwszStoreName=NULL;
    
    CRYPTUI_SELECTSTORE_STRUCT CertStoreSelect;
    STORENUMERATION_STRUCT     StoreEnumerationStruct;
    STORESFORSELCTION_STRUCT   StoresForSelectionStruct;

    DWORD                   dwChar=0;
    HCERTSTORE              hCertStore=NULL;
    LV_COLUMNW              lvC;
    LV_ITEMW                lvItem;
    HDC                     hdc=NULL;
    COLORREF                colorRef;
    BOOL                    fAppendExt=FALSE;


	switch (msg)
	{
		case WM_INITDIALOG:
                //set the wizard information so that it can be shared
                pPropSheet = (PROPSHEETPAGEW *) lParam;
                pCertBuildCTLInfo = (CERT_BUILDCTL_INFO *) (pPropSheet->lParam);
                //make sure pCertBuildCTLInfo is a valid pointer
                if(NULL==pCertBuildCTLInfo)
                   break;
                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertBuildCTLInfo);


                SetControlFont(pCertBuildCTLInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

                //getthe background color of the parent window
                //the background of the list view for store name is grayed
                /*
               if(hdc=GetWindowDC(hwndDlg))
               {
                    if(CLR_INVALID!=(colorRef=GetBkColor(hdc)))
                    {
                        ListView_SetBkColor(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), CLR_NONE);
                        ListView_SetTextBkColor(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), CLR_NONE);
                    }
               }   */

               //pre-set the selections for the destinations
               //set the store name if pre-selected
               if(pCertBuildCTLInfo->hDesStore)
               {
                    //select the 1st radio button
                    SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1), BM_SETCHECK, 1, 0);
                    SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO2), BM_SETCHECK, 0, 0);

                    //disable the windows for select a file
                    EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_EDIT1), FALSE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON2), FALSE);

                    //set the store name if pre-selected
                    //get the hwndControl for the list view
                    hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1);

                    if(hwndControl)
                        SetStoreName(hwndControl,pCertBuildCTLInfo->hDesStore);
               }
               else
               {
                    //select the 2nd radio button
                    SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1), BM_SETCHECK, 0, 0);
                    SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO2), BM_SETCHECK, 1, 0);

                    //disable the controls to select a store
                    EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON1), FALSE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), FALSE);

                   if(pCertBuildCTLInfo->pwszFileName)
                   {
                        //pre-initialize the file name
                        SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1, pCertBuildCTLInfo->pwszFileName);
                   }
               }
                                
                //init
                memset(&wszFileName, 0, sizeof(wszFileName));

                *wszFileName='\0';
			break;

		case WM_COMMAND:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    switch (LOWORD(wParam))
                    {
                        case    IDC_WIZARD_RADIO1:
                                 //select the 1st radio button
                                SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1), BM_SETCHECK, 1, 0);

                                //enable the controls to select a store
                                EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON1), TRUE);
                                EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), TRUE);

                                 //disable raio2
                                SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO2), BM_SETCHECK, 0, 0);

                                //disable controls to select a file
                                EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON2), FALSE);
                                EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_EDIT1), FALSE);
                            break;
                        case    IDC_WIZARD_RADIO2:
                               //disable the 1st radio button
                                SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1), BM_SETCHECK, 0, 0);

                                //disable the controls to select a store
                                EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON1), FALSE);
                                EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), FALSE);

                                 //enable raio2
                                SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO2), BM_SETCHECK, 1, 0);

                                //enable controls to select a file
                                EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_BUTTON2), TRUE);
                                EnableWindow(GetDlgItem(hwndDlg, IDC_WIZARD_EDIT1), TRUE);
                            break;
                        case    IDC_WIZARD_BUTTON1:

                                //the browse for store button is selected
                                if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                {
                                    break;
                                }

                                //get the hwndControl for the list view
                                hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1);

                                 //call the store selection dialogue
                                memset(&CertStoreSelect, 0, sizeof(CertStoreSelect));
                                memset(&StoresForSelectionStruct, 0, sizeof(StoresForSelectionStruct));
                                memset(&StoreEnumerationStruct, 0, sizeof(StoreEnumerationStruct));

                                StoreEnumerationStruct.dwFlags=CERT_STORE_MAXIMUM_ALLOWED_FLAG | CERT_SYSTEM_STORE_CURRENT_USER;
                                StoreEnumerationStruct.pvSystemStoreLocationPara=NULL;
                                StoresForSelectionStruct.cEnumerationStructs = 1;
                                StoresForSelectionStruct.rgEnumerationStructs = &StoreEnumerationStruct;

                                CertStoreSelect.dwSize=sizeof(CRYPTUI_SELECTSTORE_STRUCT);
                                CertStoreSelect.hwndParent=hwndDlg;
                                CertStoreSelect.dwFlags=CRYPTUI_VALIDATE_STORES_AS_WRITABLE | CRYPTUI_ALLOW_PHYSICAL_STORE_VIEW | CRYPTUI_DISPLAY_WRITE_ONLY_STORES;
                                CertStoreSelect.pStoresForSelection = &StoresForSelectionStruct;

                                hCertStore=CryptUIDlgSelectStore(&CertStoreSelect);

                                if(hCertStore)
                                {
                                     //delete the old destination certificate store
                                    if(pCertBuildCTLInfo->hDesStore && (TRUE==pCertBuildCTLInfo->fFreeDesStore))
                                    {
                                        CertCloseStore(pCertBuildCTLInfo->hDesStore, 0);
                                        pCertBuildCTLInfo->hDesStore=NULL;
                                    }

                                    pCertBuildCTLInfo->hDesStore=hCertStore;
                                    pCertBuildCTLInfo->fFreeDesStore=TRUE;

                                     //get the store name
                                    SetStoreName(hwndControl,
                                                 pCertBuildCTLInfo->hDesStore);
                                }

                            break;
                        case   IDC_WIZARD_BUTTON2:
                                //the browse file button is clicked.  Open the FileOpen dialogue
                                memset(&OpenFileName, 0, sizeof(OpenFileName));

                                *szFileName=L'\0';

                                OpenFileName.lStructSize = sizeof(OpenFileName);
                                OpenFileName.hwndOwner = hwndDlg;
                                OpenFileName.hInstance = NULL;
                                //load the fileter string
                                if(LoadFilterString(g_hmodThisDll, IDS_CTL_FILTER, szFilter, MAX_STRING_SIZE))
                                {
                                    OpenFileName.lpstrFilter = szFilter;
                                }
                                OpenFileName.lpstrCustomFilter = NULL;
                                OpenFileName.nMaxCustFilter = 0;
                                OpenFileName.nFilterIndex = 1;
                                OpenFileName.lpstrFile = szFileName;
                                OpenFileName.nMaxFile = _MAX_PATH;
                                OpenFileName.lpstrFileTitle = NULL;
                                OpenFileName.nMaxFileTitle = 0;
                                OpenFileName.lpstrInitialDir = NULL;
                                OpenFileName.lpstrTitle = NULL;
                                OpenFileName.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
                                OpenFileName.nFileOffset = 0;
                                OpenFileName.nFileExtension = 0;
                                OpenFileName.lpstrDefExt = L"ctl";
                                OpenFileName.lCustData = NULL;
                                OpenFileName.lpfnHook = NULL;
                                OpenFileName.lpTemplateName = NULL;

                                if (WizGetSaveFileName(&OpenFileName))
                                {
                                   //set the edit box
                                    SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1, szFileName);

                                    //copy the selected file name
                                    wcscpy(wszFileName, szFileName);                                                                   
                                }

                            break;
                        default:

                           break;
                    }
                }
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);

                            if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(pCertBuildCTLInfo->pwszFileName)
                            {
                                //pre-initialize the file name since extension might have been added
                                SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1, pCertBuildCTLInfo->pwszFileName);
                            }

					    break;

                    case PSN_WIZBACK:

                        break;

                    case PSN_WIZNEXT:
                            if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                            {
                                break;
                            }

                            //make sure that we have select some store
                            if(TRUE==SendMessage(GetDlgItem(hwndDlg, IDC_WIZARD_RADIO1), BM_GETCHECK, 0, 0))
                            {
                                if(NULL==pCertBuildCTLInfo->hDesStore)
                                {

                                    //output the message
                                    I_MessageBox(hwndDlg, IDS_HAS_TO_SELECT_STORE,
                                            IDS_BUILDCTL_WIZARD_TITLE,
                                            NULL,
                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                     //make the file page stay
                                     SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                     break;
                                }
                                else
                                {
                                    //mark the hDesStore should be used
                                    pCertBuildCTLInfo->fSelectedDesStore=TRUE;
                                    pCertBuildCTLInfo->fSelectedFileName=FALSE;
                                }
                            }
                            else
                            {
                                //make sure a file is selected
                                if(0==(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
                                                       IDC_WIZARD_EDIT1,
                                                       WM_GETTEXTLENGTH, 0, 0)))
                                {
                                    I_MessageBox(hwndDlg, IDS_HAS_TO_SELECT_FILE,
                                            IDS_BUILDCTL_WIZARD_TITLE,
                                            NULL,
                                            MB_ICONERROR|MB_OK|MB_APPLMODAL);

                                     //make the file page stay
                                     SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                     break;
                                }
                                else
                                {
                                    //mark the file name should be used
                                    pCertBuildCTLInfo->fSelectedDesStore=FALSE;
                                    pCertBuildCTLInfo->fSelectedFileName=TRUE;

                                   //get the file name
                                    if(pCertBuildCTLInfo->pwszFileName)
                                    {
                                        //delete the old file name
                                        if(TRUE==pCertBuildCTLInfo->fFreeFileName)
                                        {
                                            WizardFree(pCertBuildCTLInfo->pwszFileName);
                                            pCertBuildCTLInfo->pwszFileName=NULL;
                                        }
                                    }

                                    pCertBuildCTLInfo->pwszFileName=(LPWSTR)WizardAlloc((dwChar+1)*sizeof(WCHAR));

                                    if(NULL==pCertBuildCTLInfo->pwszFileName)
                                        break;

                                    pCertBuildCTLInfo->fFreeFileName=TRUE;

                                    GetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,
                                                    pCertBuildCTLInfo->pwszFileName,
                                                    dwChar+1);

                                    //we append .ctl file extension if user has not specify it
                                    fAppendExt=FALSE;

                                    if(wcslen(pCertBuildCTLInfo->pwszFileName) < 4)
                                        fAppendExt=TRUE;
                                    else
                                    {
                                        if (_wcsicmp(L".stl", &(pCertBuildCTLInfo->pwszFileName[wcslen(pCertBuildCTLInfo->pwszFileName)-4])) != 0)
                                            fAppendExt=TRUE;
                                        else
                                            fAppendExt=FALSE;
                                    }

                                    if(TRUE == fAppendExt)
                                    {
                                        pCertBuildCTLInfo->pwszFileName = (LPWSTR)WizardRealloc(pCertBuildCTLInfo->pwszFileName,
                                                    (wcslen(pCertBuildCTLInfo->pwszFileName) + 4 + 1) * sizeof(WCHAR));

                                        if(NULL==pCertBuildCTLInfo->pwszFileName)
                                            break;

                                        wcscat(pCertBuildCTLInfo->pwszFileName, L".stl");

                                    }

                                    //confirm to over write
                                    if(0 != _wcsicmp(wszFileName, pCertBuildCTLInfo->pwszFileName))
                                    {
                                        if(FileExist(pCertBuildCTLInfo->pwszFileName))
                                        {
                                            if(FALSE == CheckReplace(hwndDlg, pCertBuildCTLInfo->pwszFileName))
                                            {
                                                 //make the file page stay
                                                 SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

                                                 break;
                                            }
                                        }
                                    }
                                }
                            }

                            //decide if we need to skip to the friendly name page
                            if(pCertBuildCTLInfo->hDesStore && (TRUE==pCertBuildCTLInfo->fSelectedDesStore))
                            {
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_BUILDCTL_NAME);
                            }
                            else
                            {
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_BUILDCTL_COMPLETION);
                            }

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}
//-----------------------------------------------------------------------
// BuildCTL_Name
//-----------------------------------------------------------------------
INT_PTR APIENTRY BuildCTL_Name(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CERT_BUILDCTL_INFO      *pCertBuildCTLInfo=NULL;
    PROPSHEETPAGEW           *pPropSheet=NULL;
    HWND                    hwndControl=NULL;
    DWORD                   dwChar;

	switch (msg)
	{
		case WM_INITDIALOG:
            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGEW *) lParam;
            pCertBuildCTLInfo = (CERT_BUILDCTL_INFO *) (pPropSheet->lParam);
            //make sure pCertBuildCTLInfo is a valid pointer
            if(NULL==pCertBuildCTLInfo)
               break;
            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertBuildCTLInfo);


            SetControlFont(pCertBuildCTLInfo->hBold, hwndDlg,IDC_WIZARD_STATIC_BOLD1);

            //set the FriedlyName and description field
            //if pwszFriendlyName is NULL, use the list ID
            if(pCertBuildCTLInfo->pwszFriendlyName)
                SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1, pCertBuildCTLInfo->pwszFriendlyName);
            else
            {
                if(pCertBuildCTLInfo->pwszListID)
                    SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1, pCertBuildCTLInfo->pwszListID);
            }

            if(pCertBuildCTLInfo->pwszDescription)
                SetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT2, pCertBuildCTLInfo->pwszDescription);

			break;

		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);


					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:
                            if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                            {
                                break;
                            }

                            //free the friendly name and description
                            if(pCertBuildCTLInfo->pwszFriendlyName)
                            {
                                WizardFree(pCertBuildCTLInfo->pwszFriendlyName);
                                pCertBuildCTLInfo->pwszFriendlyName=NULL;
                            }

                            if(pCertBuildCTLInfo->pwszDescription)
                            {
                                WizardFree(pCertBuildCTLInfo->pwszDescription);
                                pCertBuildCTLInfo->pwszDescription=NULL;
                            }


                            //get the friendly name
                            if(0!=(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
                                                   IDC_WIZARD_EDIT1,
                                                   WM_GETTEXTLENGTH, 0, 0)))
                            {
                                pCertBuildCTLInfo->pwszFriendlyName=(LPWSTR)WizardAlloc(sizeof(WCHAR)*(dwChar+1));

                                if(NULL!=pCertBuildCTLInfo->pwszFriendlyName)
                                {
                                    GetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT1,
                                                    pCertBuildCTLInfo->pwszFriendlyName,
                                                    dwChar+1);

                                }
                                else
                                    //we are out of memory and out of hope
                                    break;
                            }

                            //get the description
                            if(0!=(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
                                                  IDC_WIZARD_EDIT2,
                                                  WM_GETTEXTLENGTH, 0, 0)))
                            {
                                pCertBuildCTLInfo->pwszDescription=(LPWSTR)WizardAlloc(sizeof(WCHAR)*(dwChar+1));

                                if(NULL!=pCertBuildCTLInfo->pwszDescription)
                                {
                                    GetDlgItemTextU(hwndDlg, IDC_WIZARD_EDIT2,
                                                    pCertBuildCTLInfo->pwszDescription,
                                                    dwChar+1);

                                }
                                else
                                    //we are out of memory and out of hope
                                    break;
                            }

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}


//-----------------------------------------------------------------------
// BuildCTL_Completion
//-----------------------------------------------------------------------
INT_PTR APIENTRY BuildCTL_Completion(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CERT_BUILDCTL_INFO      *pCertBuildCTLInfo=NULL;
    PROPSHEETPAGEW           *pPropSheet=NULL;
    HWND                    hwndControl=NULL;
    LV_COLUMNW              lvC;
    LPNMLISTVIEW            pnmv;

    HDC                     hdc=NULL;
    COLORREF                colorRef;

    DWORD                   dwEncodedCTL=0;
    BYTE                    *pbEncodedCTL=NULL;
    DWORD                   cbEncodedCTL=0;
    UINT                    ids=0;

	switch (msg)
	{
		case WM_INITDIALOG:
                //set the wizard information so that it can be shared
                pPropSheet = (PROPSHEETPAGEW *) lParam;
                pCertBuildCTLInfo = (CERT_BUILDCTL_INFO *) (pPropSheet->lParam);
                //make sure pCertBuildCTLInfo is a valid pointer
                if(NULL==pCertBuildCTLInfo)
                   break;
                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCertBuildCTLInfo);

                SetControlFont(pCertBuildCTLInfo->hBigBold, hwndDlg,IDC_WIZARD_STATIC_BIG_BOLD1);

               //getthe background color of the parent window
                /*
               if(hdc=GetWindowDC(hwndDlg))
               {
                    if(CLR_INVALID!=(colorRef=GetBkColor(hdc)))
                    {
                        ListView_SetBkColor(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), CLR_NONE);
                        ListView_SetTextBkColor(GetDlgItem(hwndDlg, IDC_WIZARD_LIST1), CLR_NONE);
                    }
               }     */

                //insert two columns
                hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1);

                if(NULL==hwndControl)
                    break;

                //1st one is the label for the confirmation
                memset(&lvC, 0, sizeof(LV_COLUMNW));

                lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
                lvC.cx = 20;          // Width of the column, in pixels.We will autosize later
                lvC.pszText = L"";   // The text for the column.
                lvC.iSubItem=0;

                if (ListView_InsertColumnU(hwndControl, 0, &lvC) == -1)
                    break;

                //2nd column is the content
                memset(&lvC, 0, sizeof(LV_COLUMNW));

                lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
                lvC.cx = 10; //(dwMaxSize+2)*7;  // Width of the column, in pixels.
                                                 //the width will be autosized later
                lvC.pszText = L"";   // The text for the column.
                lvC.iSubItem= 1;

                if (ListView_InsertColumnU(hwndControl, 1, &lvC) == -1)
                    break;

#if (1) //DSIE: Bug ???.
                ListView_SetExtendedListViewStyle(hwndControl, 
                    ListView_GetExtendedListViewStyle(hwndControl) | LVS_EX_FULLROWSELECT);
#endif

            break;
		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK|PSWIZB_FINISH);

                            if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                            {
                                break;
                            }

                            //populate the list box in the order of
                            //FileName, StoreName, Purpose, FriendlyName, Description
                            //and any other things signing wizard display
                            if(hwndControl=GetDlgItem(hwndDlg, IDC_WIZARD_LIST1))
                            {
                                DisplayBuildCTLConfirmation(hwndControl, pCertBuildCTLInfo);
#if (1) //DSIE: Bug ???
                                ListView_SetItemState(hwndControl, 0, 
                                    LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
#endif
                            }

					    break;

                    case PSN_WIZBACK:
                            if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                            {
                                break;
                            }

                            //no need to worry if the pages are not included in the wizards
                            if(0==(pCertBuildCTLInfo->dwFlag & CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION))
                            {
                                //skip the friendly name page if the desination does no include
                                //a store
                                if(pCertBuildCTLInfo->hDesStore && (TRUE==pCertBuildCTLInfo->fSelectedDesStore))
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_BUILDCTL_NAME);
                                else
                                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_BUILDCTL_DESTINATION);
                            }

                        break;

                    case PSN_WIZFINISH:
                            if(NULL==(pCertBuildCTLInfo=(CERT_BUILDCTL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;


                            //we need to build the CTL and return the pbEncoded and cbEncoded
                            if(!I_BuildCTL(pCertBuildCTLInfo,
                                           &ids,
                                           &pbEncodedCTL,
                                           &cbEncodedCTL))
                            {
                                if(ids!=0)
                                    I_MessageBox(hwndDlg, ids, IDS_BUILDCTL_WIZARD_TITLE,
                                                NULL, MB_OK|MB_ICONINFORMATION);
                            }
                            else
                            {
                                if(0!=cbEncodedCTL && NULL!=pbEncodedCTL)
                                {
                                    //set up the signing information
                                    ((CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO *)(pCertBuildCTLInfo->pGetSignInfo->pDigitalSignInfo->pSignBlobInfo))->cbBlob=cbEncodedCTL;
                                    ((CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO *)(pCertBuildCTLInfo->pGetSignInfo->pDigitalSignInfo->pSignBlobInfo))->pbBlob=pbEncodedCTL;
                                }
                            }

                        break;

                    default:
                        return FALSE;
    	        }
		    break;

		default:

			    return FALSE;
	}

	return TRUE;
}

//**************************************************************************
//
//    The entry point for buildCTL wizard
//**************************************************************************
//----------------------------------------------------------------------------
//  Check to see if the certificate is a valid signing CTL cert
//
//----------------------------------------------------------------------------
BOOL    IsValidSigningCTLCert(PCCERT_CONTEXT      pCertContext)
{
    BOOL        fResult=FALSE;

    int         cNumOID=0;
    LPSTR       *rgOID=NULL;
    DWORD       cbOID=0;

    DWORD       dwIndex=0;
    DWORD       cbData=0;


    if(!pCertContext)
        return FALSE;

    //the certificate has to have the CERT_KEY_PROV_INFO_PROP_ID
    if(!CertGetCertificateContextProperty(pCertContext,
                                CERT_KEY_PROV_INFO_PROP_ID,
                                NULL,
                                &cbData))
        return FALSE;

    if(0==cbData)
        return FALSE;



    //get the OIDs from the cert
    if(!CertGetValidUsages(
        1,
        &pCertContext,
        &cNumOID,
        NULL,
        &cbOID))
        return FALSE;

    rgOID=(LPSTR *)WizardAlloc(cbOID);

    if(NULL==rgOID)
        return FALSE;

    if(!CertGetValidUsages(
        1,
        &pCertContext,
        &cNumOID,
        rgOID,
        &cbOID))
        goto CLEANUP;

    //-1 means the certiifcate is food for everything
    if(-1==cNumOID)
    {
        fResult=TRUE;
        goto CLEANUP;
    }

    for(dwIndex=0; dwIndex<(DWORD)cNumOID; dwIndex++)
    {
        //the only good cert is the one with CTL signing OID
        if(0==strcmp(szOID_KP_CTL_USAGE_SIGNING,
                    rgOID[dwIndex]))
        {
            fResult=TRUE;
            goto CLEANUP;
        }
    }

    //we are hopeless at this point
    fResult=FALSE;

CLEANUP:

    if(rgOID)
        WizardFree(rgOID);

    return fResult;

}
//----------------------------------------------------------------------------
//  CallBack fro cert selection call back
//
//----------------------------------------------------------------------------
static BOOL WINAPI SelectCTLSignCertCallBack(
        PCCERT_CONTEXT  pCertContext,
        BOOL            *pfInitialSelectedCert,
        void            *pvCallbackData)
{
    if(!pCertContext)
        return FALSE;

    //make sure that this is a valid certificate
    return IsValidSigningCTLCert(pCertContext);
}
//-----------------------------------------------------------------------
//
// CryptUIWizBuildCTL
//
//  Build a new CTL or modify an existing CTL.   The UI for wizard will
//  always show in this case
//
//
//  dwFlags:            IN  Reserved:   flags.  Must be set 0
//  hwndParnet:         IN  Optional:   The parent window handle
//  pwszWizardTitle:    IN  Optional:   The title of the wizard
//  pBuildCTLSrc:       IN  Optional:   The source from which the CTL will be built
//  pBuildCTLDest:      IN  Optional:   The desination where the newly
//                                      built CTL will be stored
//  ppCTLContext:       OUT Optaionl:   The newly build CTL
//
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizBuildCTL(
    DWORD                                   dwFlags,
    HWND                                    hwndParent,
    LPCWSTR                                 pwszWizardTitle,
    PCCRYPTUI_WIZ_BUILDCTL_SRC_INFO         pBuildCTLSrc,
    PCCRYPTUI_WIZ_BUILDCTL_DEST_INFO        pBuildCTLDest,
    PCCTL_CONTEXT                           *ppCTLContext
)
{
    BOOL                    fResult=FALSE;
    HRESULT                 hr=E_FAIL;
    DWORD                   dwError=0;

    CERT_BUILDCTL_INFO      CertBuildCTLInfo;
    UINT                    ids=IDS_INVALID_WIZARD_INPUT;
    FILETIME            	CurrentFileTime;


    PROPSHEETPAGEW           *prgBuildCTLSheet=NULL;
    PROPSHEETHEADERW         buildCTLHeader;
    ENROLL_PAGE_INFO        rgBuildCTLPageInfo[]=
        {(LPCWSTR)MAKEINTRESOURCE(IDD_BUILDCTL_WELCOME),    BuildCTL_Welcome,
        (LPCWSTR)MAKEINTRESOURCE(IDD_BUILDCTL_PURPOSE),     BuildCTL_Purpose,
        (LPCWSTR)MAKEINTRESOURCE(IDD_BUILDCTL_CERTS),       BuildCTL_Certs,
        (LPCWSTR)MAKEINTRESOURCE(IDD_BUILDCTL_DESTINATION), BuildCTL_Destination,
        (LPCWSTR)MAKEINTRESOURCE(IDD_BUILDCTL_NAME),        BuildCTL_Name,
        (LPCWSTR)MAKEINTRESOURCE(IDD_BUILDCTL_COMPLETION),  BuildCTL_Completion,
    };

    DWORD                   dwIndex=0;
    DWORD                   dwPropCount=0;
    WCHAR                   wszTitle[MAX_TITLE_LENGTH];
    PCCRYPT_OID_INFO        pOIDInfo;
    PCCTL_CONTEXT           pCTLContext=NULL;
    PCCTL_CONTEXT           pBldCTL=NULL;
    PCCRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO  pNewCTLInfo=NULL;
    LPWSTR                  pwszListID=NULL;
    PCERT_ENHKEY_USAGE      pSubjectUsage=NULL;
    DWORD                   cbData=0;

    CRYPTUI_WIZ_GET_SIGN_PAGE_INFO  GetSignInfo;
    DWORD                           dwPages=0;
    CRYPTUI_WIZ_DIGITAL_SIGN_INFO   DigitalSignInfo;
    PROPSHEETPAGEW                  *pwPages=NULL;
    CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO SignBlob;
    CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO SignStoreInfo;
    GUID                            CTLGuid=CRYPT_SUBJTYPE_CTL_IMAGE;
    CRYPT_DATA_BLOB                 PropertyBlob;
    HCERTSTORE                      hMyStore=NULL;
    INT_PTR                         iReturn=-1;
   // CERT_STORE_LIST                 CertStoreList;


    //init
    memset(&CertBuildCTLInfo, 0, sizeof(CERT_BUILDCTL_INFO));
    memset(&buildCTLHeader, 0, sizeof(PROPSHEETHEADERW));

    memset(&GetSignInfo, 0, sizeof(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO));
    memset(&DigitalSignInfo, 0, sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO));
    memset(&SignBlob, 0, sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO));
    memset(&SignStoreInfo, 0, sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO));

    memset(&PropertyBlob, 0, sizeof(CRYPT_DATA_BLOB));
    //open all the system store system store
    //memset(&CertStoreList, 0, sizeof(CertStoreList));


    //input checking

    if(ppCTLContext)
        *ppCTLContext=NULL;

    //get the basic information from the src info struct
    if(pBuildCTLSrc)
    {
        if(pBuildCTLSrc->dwSize != sizeof(CRYPTUI_WIZ_BUILDCTL_SRC_INFO))
            goto InvalidArgErr;

        if(CRYPTUI_WIZ_BUILDCTL_SRC_EXISTING_CTL==pBuildCTLSrc->dwSourceChoice)
        {
            if(NULL==pBuildCTLSrc->pCTLContext)
                goto InvalidArgErr;

            pCTLContext=pBuildCTLSrc->pCTLContext;

            CertBuildCTLInfo.pSrcCTL=pCTLContext;

        }
        else
        {
            if(CRYPTUI_WIZ_BUILDCTL_SRC_NEW_CTL==pBuildCTLSrc->dwSourceChoice)
            {
                if(NULL==pBuildCTLSrc->pNewCTLInfo)
                    goto InvalidArgErr;

                pNewCTLInfo=pBuildCTLSrc->pNewCTLInfo;
            }
            else
                goto InvalidArgErr;
        }
    }


    //init the private structure based on input parameters
    CertBuildCTLInfo.hwndParent=hwndParent;
    CertBuildCTLInfo.dwFlag=dwFlags;
    CertBuildCTLInfo.rgdwSortParam[0]=SORT_COLUMN_SUBJECT | SORT_COLUMN_ASCEND;
    CertBuildCTLInfo.rgdwSortParam[1]=SORT_COLUMN_ISSUER | SORT_COLUMN_DESCEND;
    CertBuildCTLInfo.rgdwSortParam[2]=SORT_COLUMN_PURPOSE | SORT_COLUMN_DESCEND;
    CertBuildCTLInfo.rgdwSortParam[3]=SORT_COLUMN_EXPIRATION | SORT_COLUMN_DESCEND;

    //get the listIdentifier
    if(pCTLContext)
    {
        //copy the listID if it is the wchar format
        if(0!=(pCTLContext->pCtlInfo->ListIdentifier.cbData))
        {
            //get the string presentation of the listID
            if(ValidString(&(pCTLContext->pCtlInfo->ListIdentifier)))
            {
                CertBuildCTLInfo.pwszListID=WizardAllocAndCopyWStr((LPWSTR)(pCTLContext->pCtlInfo->ListIdentifier.pbData));

                if(NULL==CertBuildCTLInfo.pwszListID)
                    goto MemoryErr;
            }
            else
            {
                //get the hex presentation of the listID
                cbData=0;
                if(CryptFormatObject(
                        X509_ASN_ENCODING,
                        0,
                        0,
                        NULL,
                        0,
                        pCTLContext->pCtlInfo->ListIdentifier.pbData,
                        pCTLContext->pCtlInfo->ListIdentifier.cbData,
                        NULL,
                        &cbData) && (0!= cbData))
                {
                    CertBuildCTLInfo.pwszListID=(LPWSTR)WizardAlloc(cbData);

                    if(NULL==CertBuildCTLInfo.pwszListID)
                        goto MemoryErr;

                    if(!CryptFormatObject(
                        X509_ASN_ENCODING,
                        0,
                        0,
                        NULL,
                        0,
                        pCTLContext->pCtlInfo->ListIdentifier.pbData,
                        pCTLContext->pCtlInfo->ListIdentifier.cbData,
                        CertBuildCTLInfo.pwszListID,
                        &cbData))
                        goto Win32Err;
                }
            }
        }

    }
    else
    {
       if(pNewCTLInfo)
       {
            if(pNewCTLInfo->pwszListIdentifier)
            {
                CertBuildCTLInfo.pwszListID=WizardAllocAndCopyWStr(pNewCTLInfo->pwszListIdentifier);
                if(NULL==CertBuildCTLInfo.pwszListID)
                    goto MemoryErr;
            }
       }

    }



    //get the hash algorithm and dwHashPropID from the source CTL
    if(pCTLContext)
    {
        //make sure we have the correct algorithm
        if(NULL==pCTLContext->pCtlInfo->SubjectAlgorithm.pszObjId)
        {
             ids=IDS_INVALID_ALGORITHM_IN_CTL;
             goto InvalidArgErr;
        }

        CertBuildCTLInfo.pszSubjectAlgorithm=(LPSTR)(pCTLContext->pCtlInfo->SubjectAlgorithm.pszObjId);
    }
    else
    {
        if(pNewCTLInfo)
            CertBuildCTLInfo.pszSubjectAlgorithm=(LPSTR)(pNewCTLInfo->pszSubjectAlgorithm);
    }

    if(CertBuildCTLInfo.pszSubjectAlgorithm)
    {

        pOIDInfo = CryptFindOIDInfo(
                    CRYPT_OID_INFO_OID_KEY,
                    CertBuildCTLInfo.pszSubjectAlgorithm,
                    CRYPT_HASH_ALG_OID_GROUP_ID);

        if(NULL==pOIDInfo)
        {
             ids=IDS_INVALID_ALGORITHM_IN_CTL;
             goto Crypt32Err;
        }


        if (pOIDInfo->Algid == CALG_MD5)
        {
           CertBuildCTLInfo.dwHashPropID=CERT_MD5_HASH_PROP_ID;
        }
        else
        {
            if (pOIDInfo->Algid == CALG_SHA1)
            {
                CertBuildCTLInfo.dwHashPropID=CERT_SHA1_HASH_PROP_ID;
            }
            else
            {
                 ids=IDS_INVALID_ALGORITHM_IN_CTL;
                 goto InvalidArgErr;
            }
        }

    }
    else
        CertBuildCTLInfo.dwHashPropID=CERT_SHA1_HASH_PROP_ID;

    //get the pSubjectUsage
    if(pNewCTLInfo)
    {
        if(pNewCTLInfo->pSubjectUsage)
            pSubjectUsage=pNewCTLInfo->pSubjectUsage;
    }

    //add the subject Usage and pre-select them from either
    //the exising CTL or the user defined ones
    if(!GetOIDForCTL(&CertBuildCTLInfo,
        (pSubjectUsage) ? pSubjectUsage->cUsageIdentifier : 0,
        (pSubjectUsage) ? pSubjectUsage->rgpszUsageIdentifier : NULL))
        goto InvalidArgErr;

    //get the Certficate contexts from either the existing CTL
    //of the user defined one
    GetCertForCTL(hwndParent,
                  TRUE,         //always UI mode for now
                  &CertBuildCTLInfo,
                  (pNewCTLInfo)? pNewCTLInfo->hCertStore : NULL);

    //get the dwValidMonths and dwValidDays
    if(pCTLContext)
        CertBuildCTLInfo.pNextUpdate=&(pCTLContext->pCtlInfo->NextUpdate);
    else
    {
        if(pNewCTLInfo)
            CertBuildCTLInfo.pNextUpdate=(FILETIME *)(&(pNewCTLInfo->NextUpdate));
    }


    //get the current FileTime
    GetSystemTimeAsFileTime(&CurrentFileTime);

    //get the difference
    if(CertBuildCTLInfo.pNextUpdate)
    {
        SubstractDurationFromFileTime(
                CertBuildCTLInfo.pNextUpdate,
                &CurrentFileTime,
                &(CertBuildCTLInfo.dwValidMonths),
                &(CertBuildCTLInfo.dwValidDays));

        //we limit to 99 month
        if((CertBuildCTLInfo.dwValidMonths > 99) ||
            (CertBuildCTLInfo.dwValidMonths == 99 && CertBuildCTLInfo.dwValidDays !=0))
        {
            CertBuildCTLInfo.dwValidMonths=0;
            CertBuildCTLInfo.dwValidDays=0;
        }
    }

    //get the FriendlyName and Description
    if(pCTLContext)
    {
        //friendly Name
        cbData=0;

        if(CertGetCTLContextProperty(
                 pCTLContext,
                 CERT_FRIENDLY_NAME_PROP_ID,
                 NULL,
                 &cbData) && (0!=cbData))
        {
            CertBuildCTLInfo.pwszFriendlyName=(LPWSTR)WizardAlloc(cbData);

            if(NULL==CertBuildCTLInfo.pwszFriendlyName)
                goto MemoryErr;

            if(!CertGetCTLContextProperty(
                 pCTLContext,
                 CERT_FRIENDLY_NAME_PROP_ID,
                 CertBuildCTLInfo.pwszFriendlyName,
                 &cbData))
                goto Win32Err;

        }

        //Description
        cbData=0;

        if(CertGetCTLContextProperty(
                 pCTLContext,
                 CERT_DESCRIPTION_PROP_ID,
                 NULL,
                 &cbData) && (0!=cbData))
        {
            CertBuildCTLInfo.pwszDescription=(LPWSTR)WizardAlloc(cbData);

            if(NULL==CertBuildCTLInfo.pwszDescription)
                goto MemoryErr;

            if(!CertGetCTLContextProperty(
                 pCTLContext,
                 CERT_DESCRIPTION_PROP_ID,
                 CertBuildCTLInfo.pwszDescription,
                 &cbData))
                goto Win32Err;

        }
    }
    else
    {
        if(pNewCTLInfo)
        {
            if(pNewCTLInfo->pwszFriendlyName)
            {
                CertBuildCTLInfo.pwszFriendlyName=WizardAllocAndCopyWStr(pNewCTLInfo->pwszFriendlyName);

                if(NULL==CertBuildCTLInfo.pwszFriendlyName)
                    goto MemoryErr;
            }

            if(pNewCTLInfo->pwszDescription)
            {
                CertBuildCTLInfo.pwszDescription=WizardAllocAndCopyWStr(pNewCTLInfo->pwszDescription);

                if(NULL==CertBuildCTLInfo.pwszDescription)
                    goto MemoryErr;
            }
        }

    }


    //get the destination
    if(pBuildCTLDest)
    {
        CertBuildCTLInfo.fKnownDes=TRUE;

        if(pBuildCTLDest->dwSize != sizeof(CRYPTUI_WIZ_BUILDCTL_DEST_INFO))
                 goto InvalidArgErr;

        switch(pBuildCTLDest->dwDestinationChoice)
        {
            case CRYPTUI_WIZ_BUILDCTL_DEST_CERT_STORE:

                    if(NULL==pBuildCTLDest->hCertStore)
                        goto InvalidArgErr;

                    CertBuildCTLInfo.hDesStore=pBuildCTLDest->hCertStore;
                    CertBuildCTLInfo.fFreeDesStore=FALSE;
                    CertBuildCTLInfo.fSelectedDesStore=TRUE;
                break;

            case CRYPTUI_WIZ_BUILDCTL_DEST_FILE:
                    if(NULL==pBuildCTLDest->pwszFileName)
                        goto InvalidArgErr;

                    CertBuildCTLInfo.pwszFileName=(LPWSTR)(pBuildCTLDest->pwszFileName);
                    CertBuildCTLInfo.fFreeFileName=FALSE;
                    CertBuildCTLInfo.fSelectedFileName=TRUE;
                break;

            default:
                    goto InvalidArgErr;
                break;
        }


    }
    else
        CertBuildCTLInfo.fKnownDes=FALSE;


    //set up the fonts
    if(!SetupFonts(g_hmodThisDll,
               NULL,
               &(CertBuildCTLInfo.hBigBold),
               &(CertBuildCTLInfo.hBold)))
    {
        ids=IDS_FAIL_INIT_BUILDCTL;
        goto Win32Err;
    }


    //init the common control
    if(!WizardInit() ||
       (sizeof(rgBuildCTLPageInfo)/sizeof(rgBuildCTLPageInfo[0])!=BUILDCTL_PROP_SHEET)
      )
    {
        ids=IDS_FAIL_INIT_BUILDCTL;
        goto InvalidArgErr;
    }

    //set up the parameter to get a list of certificate
    //open the my store
    if(NULL == (hMyStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							g_dwMsgAndCertEncodingType,
							NULL,
							CERT_SYSTEM_STORE_CURRENT_USER |CERT_STORE_SET_LOCALIZED_NAME_FLAG,
                            L"my")))
        goto Win32Err;

   /* if (!CertEnumSystemStore(
            CERT_SYSTEM_STORE_CURRENT_USER,
            NULL,
            &CertStoreList,
            EnumSysStoreSignCertCallBack))
        goto Win32Err;   */


    //set up GetSignInfo
    GetSignInfo.dwSize=sizeof(CRYPTUI_WIZ_GET_SIGN_PAGE_INFO);
    GetSignInfo.dwPageChoice=CRYPTUI_WIZ_DIGITAL_SIGN_MINIMAL_SIGNING_OPTION_PAGES;


    if(pwszWizardTitle)
        GetSignInfo.pwszPageTitle=(LPWSTR)pwszWizardTitle;
    else
    {
        if(LoadStringU(g_hmodThisDll, IDS_BUILDCTL_WIZARD_TITLE, wszTitle, sizeof(wszTitle)/sizeof(wszTitle[0])))
            GetSignInfo.pwszPageTitle=wszTitle;
    }

    GetSignInfo.pDigitalSignInfo=&DigitalSignInfo;

    //set up DigitalSignInfo
    DigitalSignInfo.dwSize=sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO);
    //we are always signing a BLOB
    DigitalSignInfo.dwSubjectChoice=CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB;
    DigitalSignInfo.pSignBlobInfo=&SignBlob;
    DigitalSignInfo.dwSigningCertChoice=CRYPTUI_WIZ_DIGITAL_SIGN_STORE;
    DigitalSignInfo.pSigningCertStore=&SignStoreInfo;
    DigitalSignInfo.dwAdditionalCertChoice=CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN;

    //set up SignStoreInfo
    SignStoreInfo.dwSize=sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO);
    SignStoreInfo.cCertStore=1;             //CertStoreList.dwStoreCount;
    SignStoreInfo.rghCertStore=&hMyStore;    //CertStoreList.prgStore;
    SignStoreInfo.pFilterCallback=SelectCTLSignCertCallBack;

    //set up SignBlobInfo
    SignBlob.dwSize=sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO);
    SignBlob.pGuidSubject=&CTLGuid;

    //copy the GetSignInfo into the private data
    CertBuildCTLInfo.pGetSignInfo=&GetSignInfo;

    //we set up the wizard in two ways: with the signing page or without the
    //signing page
    if(dwFlags & CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING)
    {
       //set up the property sheet without signing
        prgBuildCTLSheet=(PROPSHEETPAGEW *)WizardAlloc(sizeof(PROPSHEETPAGEW) *
                                            BUILDCTL_PROP_SHEET);

        if(NULL==prgBuildCTLSheet)
            goto MemoryErr;

        memset(prgBuildCTLSheet, 0, sizeof(PROPSHEETPAGEW) * BUILDCTL_PROP_SHEET);


        dwPropCount=0;

        for(dwIndex=0; dwIndex<BUILDCTL_PROP_SHEET; dwIndex++)
        {

            //skip the destination page is required
            if(3 == dwIndex )
            {
                if(dwFlags & CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION)
                    continue;
            }

            //skip the friendly name page if the desination page is skipped and the destination
            //is a file name
            if(4== dwIndex)
            {
                if(dwFlags & CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION)
                {
                    if(NULL==ppCTLContext)
                    {
                        if(pBuildCTLDest)
                        {
                            if(CRYPTUI_WIZ_BUILDCTL_DEST_FILE == pBuildCTLDest->dwDestinationChoice)
                                continue;
                        }
                        else
                            continue;
                    }
                }
            }

            prgBuildCTLSheet[dwPropCount].dwSize=sizeof(prgBuildCTLSheet[dwPropCount]);

            if(pwszWizardTitle)
                prgBuildCTLSheet[dwPropCount].dwFlags=PSP_USETITLE;
            else
                prgBuildCTLSheet[dwPropCount].dwFlags=0;

            prgBuildCTLSheet[dwPropCount].hInstance=g_hmodThisDll;
            prgBuildCTLSheet[dwPropCount].pszTemplate=(LPCWSTR)(rgBuildCTLPageInfo[dwIndex].pszTemplate);

            if(pwszWizardTitle)
            {
                prgBuildCTLSheet[dwPropCount].pszTitle=pwszWizardTitle;
            }
            else
                prgBuildCTLSheet[dwPropCount].pszTitle=NULL;

            prgBuildCTLSheet[dwPropCount].pfnDlgProc=rgBuildCTLPageInfo[dwIndex].pfnDlgProc;

            prgBuildCTLSheet[dwPropCount].lParam=(LPARAM)&CertBuildCTLInfo;

            dwPropCount++;
        }

    }
    else
    {
        //get the pages
        if(!CryptUIWizGetDigitalSignPages(&GetSignInfo,
                                        &pwPages,
                                        &dwPages))
            goto Win32Err;

       //set up the property sheet and the property header
        prgBuildCTLSheet=(PROPSHEETPAGEW *)WizardAlloc(sizeof(PROPSHEETPAGEW) * (
                                            BUILDCTL_PROP_SHEET + dwPages));

        if(NULL==prgBuildCTLSheet)
            goto MemoryErr;

        memset(prgBuildCTLSheet, 0, sizeof(PROPSHEETPAGEW) * (BUILDCTL_PROP_SHEET + dwPages));


        dwPropCount=0;

        for(dwIndex=0; dwIndex<BUILDCTL_PROP_SHEET + dwPages; dwIndex++)
        {
            //copying the signing pages
            if(dwIndex>=3 && dwIndex < (3+dwPages))
            {
                memcpy(&(prgBuildCTLSheet[dwPropCount]), &(pwPages[dwPropCount-3]), sizeof(PROPSHEETPAGEW));
                dwPropCount++;
                continue;
            }

            //skip the destination page is required
            if((3+dwPages) == dwIndex )
            {
                if(dwFlags & CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION)
                    continue;
            }

            //skip the friendly name page if the desination page is skipped and the destination
            //is a file name
            if((4+dwPages) == dwIndex)
            {
                if(dwFlags & CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION)
                {
                    if(NULL==ppCTLContext)
                    {
                        if(pBuildCTLDest)
                        {
                            if(CRYPTUI_WIZ_BUILDCTL_DEST_FILE == pBuildCTLDest->dwDestinationChoice)
                                continue;
                        }
                        else
                            continue;
                    }
                }
            }

            prgBuildCTLSheet[dwPropCount].dwSize=sizeof(prgBuildCTLSheet[dwPropCount]);

            if(pwszWizardTitle)
                prgBuildCTLSheet[dwPropCount].dwFlags=PSP_USETITLE;
            else
                prgBuildCTLSheet[dwPropCount].dwFlags=0;

            prgBuildCTLSheet[dwPropCount].hInstance=g_hmodThisDll;
            prgBuildCTLSheet[dwPropCount].pszTemplate=(LPCWSTR)(rgBuildCTLPageInfo[dwIndex >= 3 ? dwIndex-dwPages : dwIndex].pszTemplate);

            if(pwszWizardTitle)
            {
                prgBuildCTLSheet[dwPropCount].pszTitle=pwszWizardTitle;
            }
            else
                prgBuildCTLSheet[dwPropCount].pszTitle=NULL;

            prgBuildCTLSheet[dwPropCount].pfnDlgProc=rgBuildCTLPageInfo[dwIndex >= 3 ? d