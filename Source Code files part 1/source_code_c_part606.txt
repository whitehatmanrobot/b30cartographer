 = System.Drawing.SystemColors.HighlightText;
                    this.songTitle.Location = new System.Drawing.Point(128, 392);
                    this.songTitle.Name = "songTitle";
                    this.songTitle.Size = new System.Drawing.Size(360, 23);
                    this.songTitle.TabIndex = 2;
                    this.songTitle.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
                    // 
                    // label2
                    // 
                    this.label2.Location = new System.Drawing.Point(24, 392);
                    this.label2.Name = "label2";
                    this.label2.TabIndex = 3;
                    this.label2.Text = "Current Track:";
                    this.label2.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
                    // 
                    // label3
                    // 
                    this.label3.Location = new System.Drawing.Point(24, 424);
                    this.label3.Name = "label3";
                    this.label3.TabIndex = 4;
                    this.label3.Text = "Player State";
                    this.label3.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
                    // 
                    // playState
                    // 
                    this.playState.BackColor = System.Drawing.SystemColors.HotTrack;
                    this.playState.ForeColor = System.Drawing.SystemColors.HighlightText;
                    this.playState.Location = new System.Drawing.Point(128, 424);
                    this.playState.Name = "playState";
                    this.playState.Size = new System.Drawing.Size(360, 23);
                    this.playState.TabIndex = 5;
                    this.playState.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
                    // 
                    // addMusic
                    // 
                    this.addMusic.Location = new System.Drawing.Point(368, 104);
                    this.addMusic.Name = "addMusic";
                    this.addMusic.TabIndex = 6;
                    this.addMusic.Text = "Add Music";
                    this.addMusic.Click += new System.EventHandler(this.addMusic_Click);
                    // 
                    // musicPath
                    // 
                    this.musicPath.Location = new System.Drawing.Point(184, 104);
                    this.musicPath.Name = "musicPath";
                    this.musicPath.Size = new System.Drawing.Size(160, 20);
                    this.musicPath.TabIndex = 7;
                    this.musicPath.Text = "textBox1";
                    // 
                    // fullScreen
                    // 
                    this.fullScreen.Location = new System.Drawing.Point(368, 360);
                    this.fullScreen.Name = "fullScreen";
                    this.fullScreen.TabIndex = 8;
                    this.fullScreen.Text = "FullScreen";
                    this.fullScreen.Click += new System.EventHandler(this.fullScreen_Click);
                    // 
                    // richTextBox1
                    // 
                    this.richTextBox1.Location = new System.Drawing.Point(16, 136);
                    this.richTextBox1.Name = "richTextBox1";
                    this.richTextBox1.Size = new System.Drawing.Size(472, 214);
                    this.richTextBox1.TabIndex = 8;
                    this.richTextBox1.Text = "richTextBox1";
                    // 
                    // Form1
                    // 
                    this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
                    this.ClientSize = new System.Drawing.Size(816, 486);
                    this.Controls.AddRange(new System.Windows.Forms.Control[] {
                                                                                                                    this.musicPath,
                                                                                                                    this.addMusic,
                                                                                                                    this.playState,
                                                                                                                    this.label3,
                                                                                                                    this.label2,
                                                                                                                    this.songTitle,
                                                                                                                    this.label1,
                                                                                                                    this.albumListbox,
                                                                                                                    this.fullScreen,
                                                                                                                    this.richTextBox1});
                this.Name = "Form1";
                this.Text = "WMP Test Bed";
                this.ResumeLayout(false);

            }
#endregion

            /// <summary>
            /// The main entry point for the application.
            /// </summary>
            [STAThread]
            static void Main() 
            {
                Application.Run(new Form1());
            }

            private void albumListbox_SelectedIndexChanged(object sender, System.EventArgs e)
            {
                // get the name of the item
                string strAlbumName = albumListbox.SelectedItem as string ;
                if ( strAlbumName != null && strAlbumName.Length > 0 )
                    {
                    IWMPPlaylist playlist = wmpplayer.mediaCollection.getByAlbum( strAlbumName ) ;
                    if ( playlist != null )
                    {
                        wmpplayer.currentPlaylist = playlist ;
                        wmpplayer.controls.play() ;
                    }
                }
            }

            ///<summary>
            ///Simply runs through all the directories in the given directory info
            ///   and adds them into your my music folder. Although adding an url
            ///   twice doesn't actually do anything, the performance is better if
            ///   I check first.
            ///</summary>
            private void AddDirectoryToLibrary( DirectoryInfo di ) 
            { 
                FileInfo[] rgfi = di.GetFiles( "*.wma" ) ;
                foreach ( FileInfo fi in rgfi )
                {
                    wmpplayer.mediaCollection.add( fi.FullName ) ;
                }
                rgfi = di.GetFiles( "*.mp3" ) ;
                foreach ( FileInfo fi in rgfi )
                {
                    wmpplayer.mediaCollection.add( fi.FullName ) ;
                }

                // Don't forget subdirectories
                DirectoryInfo[] rgdi = di.GetDirectories() ;
                foreach( DirectoryInfo childDi in rgdi )
                {
                    AddDirectoryToLibrary( childDi ) ;
                }
            }

            private void addMusic_Click(object sender, System.EventArgs e)
            {
                DirectoryInfo di = new DirectoryInfo( musicPath.Text ) ;
                if ( di != null )
                {
                    AddDirectoryToLibrary(di) ;
                }
            }

            private void fullScreen_Click(object sender, System.EventArgs e)
            {
                wmpplayer.fullScreen = true ;
            }

            private void ShowXML()
            {
                // Find out the name of the album selected, get the xml from windows media.com and
                //   drop it into the Rich Text Edit.
                string strAlbumName = albumListbox.SelectedItem as string ;
                if ( strAlbumName != null && strAlbumName.Length > 0 )
                    {
                    IWMPPlaylist playlist = wmpplayer.mediaCollection.getByAlbum( strAlbumName ) ;
                    if ( playlist != null && playlist.count > 0 )
                    {
                        IWMPMedia mediaItem = playlist.get_Item( 0 ) ;
                        string strTOC = mediaItem.getItemInfo( "TOC" ) ;
                        string strURL = "http://www.windowsmedia.com/redir/QueryToc.asp?cd=" 
                                            + strTOC 
                                            + "&version=8.0.0.4452"  ;

                        HttpWebRequest req = WebRequest.Create( strURL ) as HttpWebRequest ;
                        HttpWebResponse resp = req.GetResponse()  as HttpWebResponse ;
                        Stream respStream = resp.GetResponseStream() ;
                        richTextBox1.LoadFile( respStream, RichTextBoxStreamType.PlainText ) ;
                    }

                }
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\proctest\class1.cs ===
/********************************************************************
 * Project  : C:\DEPOT\multimedia\eHomeTest\UserXp\Proctest\Proctest.sln
 * File     : Class1.cs
 * Summary  : Test ability to get process ID and then kill a process cleanly
 * Classes  :
 * Notes    :
 * *****************************************************************/

using System;
using System.Diagnostics;

namespace Proctest
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class ProcTestApp
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
            Process[] procarray = Process.GetProcesses();
            foreach (Process p in procarray)
            {
                Console.WriteLine("{0} {1}", p.Id, p.ProcessName);
                if ( String.Compare(p.ProcessName,"wmplayer", true) == 0 )
                {
                    p.Kill();
                }
            }

            Console.WriteLine("Press ENTER to exit");
            Console.ReadLine();

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\mediamanager\mpcollection.cs ===
/********************************************************************
 * Project  : C:\DEPOT\multimedia\eHomeTest\UserXp\MediaManager\MediaManager.sln
 * File     : MPCollection.cs
 * Summary  : Provides access to and control of the Media Player library. 
 * Classes  :
 * Notes    :
 * *****************************************************************/

using System;
using WMPOCX;

namespace MediaManager
{
	/// <summary>
	/// Media Player MediaCollection object support
	/// </summary>
    /*C+C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C
    * public class MPCollection
    * 
    * Summary  :
    * ---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C*/
	public class MPCollection
	{
		/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
         * public MPCollection()
         * Args     :
         * Modifies :
         * Returns  :
         * M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M*/
        public MPCollection()
		{
			// Get access to media player object.
            _wmpocx     = new WMPOCX.WMPOCXClass() ;
            _wmpplayer  = (IWMPPlayer) _wmpocx ;
            _playList   = _wmpplayer.mediaCollection.getAll() ;
		} // public MPCollection()

 
        /*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
         * public int Count()
         * Summary  : Returns number of items in media library
         * Args     :
         * Modifies :
         * Returns  :
         * M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M*/
        public int Count()
        {
            if ( _playList == null )
            {
                return 0;
            }
            return _playList.count;
        }

        /*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
         * public void DisplayItem(int i)
         * Summary  : Returns ALL supported attributes for a single item in the media library.
         * Args     :
         * Modifies :
         * Returns  :
         * M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M*/
        public string GetSingleItem(int i, string delim)
        {
            string displayString;

            if ( _playList == null )
            {
                return "";
            }

            if ( i >= _playList.count) return "";
            
            displayString = "";
            for (int y = 0; y < _attributes.Length; y++)
            {
                //displayString += " " + _attributes[y] + "=" + _playList.get_Item(i).getItemInfo(_attributes[y]);
                displayString += _playList.get_Item(i).getItemInfo(_attributes[y]) + delim;
            } // y
            //Console.WriteLine("{0}", displayString);
            return displayString;
        }

        /*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
         * public string GetSingleItemAttribute(int i, string attrib)
         * Summary  : Returns requested attibute for an item.
         * Args     :
         * Modifies :
         * Returns  :
         * M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M*/
        public string GetSingleItemAttribute(int i, string attrib)
        {
            string displayString;

            if ( _playList == null )
            {
                return "";
            }

            if ( i >= _playList.count) return "";
            
            displayString = _playList.get_Item(i).getItemInfo(attrib);

            return displayString;
        }

        /*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
         * public string[] GetAllItemsAttribute(string attrib)
         * Summary  : returns an array containing the requested attribute for all entries in the media library.
         * Args     :
         * Modifies :
         * Returns  :
         * M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M*/
        public string[] GetAllItemsAttribute(string attrib)
        {
            string[] attribArray = new string[_playList.count];

            for (int x = 0; x < _playList.count; x++)
            {
                attribArray[x] = GetSingleItemAttribute(x, attrib);
            }

            return attribArray;
        }

        /*----------------------------------------
         * Member Data
         * ----------------------------------------*/
        private WMPOCX.WMPOCX       _wmpocx      = null ;
        private WMPOCX.IWMPPlayer   _wmpplayer   = null ;
        private IWMPPlaylist        _playList    = null ;
        private string[]            _attributes  = { "Name", "Genre", "Artist", "Author", "Album",  "MediaType", 
                                                    "MediaAttribute", "TOC", "OriginalIndex", "FileType", "Bitrate", 
                                                    "DigitallySecure","PlayCount","SourceURL", "Copyright", "CreationDate", 
                                                    "Composer", "Size", "TotalDuration", "Style", "BuyNow", "MoreInfo", 
                                                    "Rating", "Label", "Lyrics"};
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\stringcheck2\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\inc\ddraw\ddagp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddagp.h
 *  Content:	AGP memory header file
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03-Feb-98	DrewB   Split from ddrawpr.h for user/kernel portability.
 *
 ***************************************************************************/

#ifndef __DDAGP_INCLUDED__
#define __DDAGP_INCLUDED__

// This value controls how big a chunk of GART memory to commit each time
// we need to (rather than commiting just what we need to satisfy a surface
// request). This value is in bytes.  Currently 256KB.
#define DEFAULT_AGP_COMMIT_DELTA (256 * 1024)

extern DWORD dwAGPPolicyMaxBytes;
extern DWORD dwAGPPolicyCommitDelta;

//
// OS-specific functions for AGP manipulation.
//

#ifdef WIN95
#define OsGetAGPDeviceHandle(pHeap) GetDXVxdHandle()
#define OsCloseAGPDeviceHandle(h) CloseHandle(h)
#else
#define OsGetAGPDeviceHandle(pHeap) ((pHeap)->hdevAGP)
#define OsCloseAGPDeviceHandle(h)
#endif

BOOL OsAGPReserve( HANDLE hdev, DWORD dwNumPages, BOOL fIsUC, BOOL fIsWC,
                   FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                   LPVOID *ppvReservation );
BOOL OsAGPCommit( HANDLE hdev, LPVOID pvReservation,
                  DWORD dwPageOffset, DWORD dwNumPages );
BOOL OsAGPDecommitAll( HANDLE hdev, LPVOID pvReservation, DWORD dwNumPages );
BOOL OsAGPFree( HANDLE hdev, LPVOID pvReservation );

//
// Generic functions that use the OS-specific functions.
//

DWORD AGPReserve( HANDLE hdev, DWORD dwSize, BOOL fIsUC, BOOL fIsWC,
                  FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                  LPVOID *ppvReservation );
BOOL AGPCommit( HANDLE hdev, LPVOID pvReservation,
                DWORD dwOffset, DWORD dwSize );
BOOL AGPDecommitAll( HANDLE hdev, LPVOID pvReservation, DWORD dwSize );
BOOL AGPFree( HANDLE hdev, LPVOID pvReservation );

#ifndef __NTDDKCOMP__

#ifdef WIN95
BOOL vxdIsVMMAGPAware ( HANDLE hvxd );
#endif

BOOL OSIsAGPAware( HANDLE hdev );
#endif

#endif // __DDAGP_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\inc\ddraw\ddheap.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddheap.h
 *  Content:	Heap manager header file
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03-Feb-98	DrewB   Split from ddrawpr.h for user/kernel portability.
 *
 ***************************************************************************/

#ifndef __DDHEAP_INCLUDED__
#define __DDHEAP_INCLUDED__

#include "dmemmgr.h"

#ifndef VIDMEMONLY

BOOL linVidMemInit( LPVMEMHEAP pvmh, FLATPTR start, FLATPTR end );
void linVidMemFini( LPVMEMHEAP pvmh );
void linVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );
FLATPTR linVidMemAlloc( LPVMEMHEAP pvmh, DWORD xsize, DWORD ysize,
                        LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment,
                        LPLONG lpNewPitch );
DWORD linVidMemAmountAllocated( LPVMEMHEAP pvmh );
DWORD linVidMemAmountFree( LPVMEMHEAP pvmh );
DWORD linVidMemLargestFree( LPVMEMHEAP pvmh );
    
BOOL rectVidMemInit( LPVMEMHEAP pvmh, FLATPTR start, DWORD width, DWORD height,
                     DWORD stride );
void rectVidMemFini( LPVMEMHEAP pvmh );
FLATPTR rectVidMemAlloc( LPVMEMHEAP pvmh, DWORD cxThis, DWORD cyThis,
                         LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment );
void rectVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );
DWORD rectVidMemAmountAllocated( LPVMEMHEAP pvmh );
DWORD rectVidMemAmountFree( LPVMEMHEAP pvmh );

BOOL IsDifferentPixelFormat( LPDDPIXELFORMAT pdpf1, LPDDPIXELFORMAT pdpf2 );

#define DDHA_SKIPRECTANGULARHEAPS       0x0001
#define DDHA_ALLOWNONLOCALMEMORY        0x0002
#define DDHA_ALLOWNONLOCALTEXTURES      0x0004
#define DDHA_USEALTCAPS                 0x0008

FLATPTR DdHeapAlloc( DWORD dwNumHeaps,
                     LPVIDMEM pvmHeaps,
                     HANDLE hdev,
                     LPVIDMEMINFO lpVidMemInfo,
                     DWORD dwWidth,
                     DWORD dwHeight,
                     LPDDRAWI_DDRAWSURFACE_LCL lpSurfaceLcl,
                     DWORD dwFlags,
                     LPVIDMEM *ppvmHeap,
                     LPLONG plNewPitch,
                     LPDWORD pdwNewCaps,
                     LPDWORD pdwSize);

LPVMEMHEAP WINAPI HeapVidMemInit( LPVIDMEM lpVidMem, DWORD pitch, HANDLE hdev,
                                  LPHEAPALIGNMENT phad);
void WINAPI HeapVidMemFini( LPVIDMEM lpVidMem, HANDLE hdev );
FLATPTR WINAPI HeapVidMemAlloc( LPVIDMEM lpVidMem, DWORD x, DWORD y,
                                HANDLE hdev, LPSURFACEALIGNMENT lpAlignment,
                                LPLONG lpNewPitch, LPDWORD pdwSize );

#endif // VIDMEMONLY

LPVMEMHEAP WINAPI VidMemInit( DWORD flags, FLATPTR start, FLATPTR end_or_width,
                              DWORD height, DWORD pitch );
void WINAPI VidMemFini( LPVMEMHEAP pvmh );
DWORD WINAPI VidMemAmountFree( LPVMEMHEAP pvmh );
DWORD WINAPI VidMemAmountAllocated( LPVMEMHEAP pvmh );
DWORD WINAPI VidMemLargestFree( LPVMEMHEAP pvmh );

#endif // __DDHEAP_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\inc\ddraw\ddhelp.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddhelp.c
 *  Content: 	helper app to cleanup after dead processes
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   29-mar-95	craige	initial implementation
 *   09-may-95	craige	call fn in dll
 *   20-jul-95	craige	internal reorg to prevent thunking during modeset
 *   29-nov-95  angusm  added DDHELPREQ_CREATEDSFOCUSTHREAD
 *   18-jul-96	andyco	added dplayhelp_xxx functions to allow > 1 dplay app to
 *			host a game on a single machine.
 *   3-oct-96	andyco	made the winmain crit section "cs" a global so we can take
 *			it in dphelps receive thread before forwarding requests
 *   05-oct-96  colinmc fixed build breaker with CRITICAL SECTION stuff
 *   12-oct-96  colinmc new service to load the DirectX VXD into DDHELP
 *                      (necessary for the Win16 lock stuff)
 *   18-jan-97  colinmc vxd handling stuff is no longer win16 lock specific
 *
 ***************************************************************************/
#ifndef __DDHELP_INCLUDED__
#define __DDHELP_INCLUDED__

/*
 * globals
 */
#ifndef NO_D3D
extern CRITICAL_SECTION    	cs; 	// the crit section we take in winmain
					// this is a global so dphelp can take it before
					// forwarding enum requests that come in on its
					// receive thread (manbugs 3907)
#endif

/*
 * named objects
 */
#define DDHELP_EVENT_NAME		"__DDHelpEvent__"
#define DDHELP_ACK_EVENT_NAME		"__DDHelpAckEvent__"
#define DDHELP_STARTUP_EVENT_NAME	"__DDHelpStartupEvent__"
#define DDHELP_SHARED_NAME		"__DDHelpShared__"
#define DDHELP_MUTEX_NAME		"__DDHelpMutex__"
#define DDHELP_MODESET_EVENT_NAME	"__DDHelpModeSetEvent%d__"
#define DDHELP_DOSBOX_EVENT_NAME	"__DDHelpDOSBoxSetEvent%d__"
#define DDHELP_APMSUSPEND_EVENT_NAME    "__DDHelpApmSuspendEvent__"
#define DDHELP_APMRESUME_EVENT_NAME     "__DDHelpApmResumeEvent__"

/*
 * requests
 */
#define DDHELPREQ_NEWPID		1
#define DDHELPREQ_NEWDC			2
#define DDHELPREQ_FREEDCLIST		3
#define DDHELPREQ_RETURNHELPERPID	4
#define DDHELPREQ_LOADDLL		5
#define DDHELPREQ_FREEDLL		6
#define DDHELPREQ_SUICIDE		7
#define DDHELPREQ_KILLATTACHED		8
#define DDHELPREQ_WAVEOPEN		9
#define DDHELPREQ_WAVECLOSE		10
#define DDHELPREQ_CREATETIMER		11
#define DDHELPREQ_KILLTIMER		12
#define DDHELPREQ_CREATEHELPERTHREAD	13
#define DDHELPREQ_CREATEMODESETTHREAD	14
#define DDHELPREQ_KILLMODESETTHREAD	15
#define DDHELPREQ_CREATEDSMIXERTHREAD	16
#define DDHELPREQ_CALLDSCLEANUP         17
#define DDHELPREQ_CREATEDSFOCUSTHREAD	18
#define DDHELPREQ_DPLAYADDSERVER	19
#define DDHELPREQ_DPLAYDELETESERVER	20
#ifdef WIN95
    #define DDHELPREQ_GETDSVXDHANDLE        21
#endif /* WIN95 */
#define DDHELPREQ_NOTIFYONDISPLAYCHANGE	22
#ifdef WIN95
    #define DDHELPREQ_CREATEDOSBOXTHREAD    23
    #define DDHELPREQ_KILLDOSBOXTHREAD      24
#endif /* WIN95 */
#define DDHELPREQ_LOADLIBRARY           25
#define DDHELPREQ_FREELIBRARY           26
#define DDHELPREQ_STOPWATCHPID          27
#define DDHELPREQ_ADDDEVICECHANGENOTIFY 28
#define DDHELPREQ_DELDEVICECHANGENOTIFY 29
#ifdef WIN95
    #define DDHELPREQ_GETDDVXDHANDLE        30
#endif /* WIN95 */

/*
 * callback routine
 */
typedef BOOL	(FAR PASCAL *LPHELPNOTIFYPROC)(struct DDHELPDATA *);
typedef BOOL	(FAR PASCAL *LPHELPMODESETNOTIFYPROC)( LPVOID lpDD );
typedef void    (FAR PASCAL *LPDSCLEANUP)(LPVOID pds);
typedef BOOL    (FAR PASCAL *LPDEVICECHANGENOTIFYPROC)(UINT, DWORD);

/*
 * communication data
 */
typedef struct DDHELPDATA
{
    int			req;
    HANDLE		req_id;
    DWORD		pid;
    BOOL		isdisp;
    union
    {
	LPHELPNOTIFYPROC	lpNotify;
	LPHELPMODESETNOTIFYPROC	lpModeSetNotify;
    };
    DWORD		context;
    char		fname[260];
    char		func[64];
    ULONG_PTR	        dwData1;
    ULONG_PTR	        dwData2;
    LPVOID		pData1;
    LPVOID		pData2;
    ULONG_PTR	        dwReturn;
} DDHELPDATA, *LPDDHELPDATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\stringcheck\stringcheck.cs ===
/*+*******************************************************************************************
  Project				: StringCheck
  File					: StringCheck.cs
  Summary				: Entry point
  Classes / Fcns		: 
  Notes / Revisions		: 
*******************************************************************************************+*/
using System;

/*
Sample Command Line
	-d"d:\local\stringcheck" -o"D:\Local\SillyString\output.txt" -f"*.c" -s"\"*\""

*/


/*C+C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++
  
    Summary:
C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C-C*/
public class StringCheckApp
{
	public static int Main(string[] args)
	{
		// Parse out command line parameters
		if ( 0 == ProgramArgs.CommandLine(args) ) goto SillyStringAppMainEnd;

		Console.WriteLine("\nStringCheck - Scan source files for hard coded strings.");
		Console.WriteLine("Command Line Options:");
		
		Console.WriteLine("Directory     = {0}", ProgramArgs.Directory);
		Console.WriteLine("FileFilter    = {0}", ProgramArgs.FileFilter);
		Console.WriteLine("SearchString  = {0}", ProgramArgs.SearchString);
		Console.WriteLine("OutputFile    = {0}\n", ProgramArgs.OutputFile);

		// Let's get to it!
		ds = new DirScan(ProgramArgs.Directory, ProgramArgs.FileFilter, ProgramArgs.SearchString, ProgramArgs.OutputFile);
		ds.BeginScan();

		// Cleanup & Shutdown
SillyStringAppMainEnd:
		//Console.WriteLine("Press ENTER to exit.");
		//Console.ReadLine();

		return 0;
	} // Main

	/*---------------------------------------------------------
		Member vars
	----------------------------------------------------------*/
	static DirScan ds;
	
}  // StringCheckApp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\stringcheck\programargs.cs ===
/*+*******************************************************************************************
  Project				: StringCheck
  File					: ProgramArgs.c
  Summary				: Responsible for managing program configuration and command line parsing
  Classes / Fcns		: public class ProgramArgs
  Notes / Revisions		: 
*******************************************************************************************+*/

using System;


/*C+C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++C+++
  public class ProgramArgs
    Summary:
C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C---C-C*/
public class ProgramArgs
{
	/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++
	Method: 	public ProgramArgs(string[] args)
	Summary:
	Args:
	Modifies:
	Returns:
	M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
	static public int CommandLine(string[] args)
	{
		// call default constructor
		// ProgramArgs(); // this does not work, why?
		if (args == null)
		{
			return 0;
		}

		if ( args.GetLength(0) < 4)
		{
			ProgramArgs.ArgsHelp();
			return 0;
		}

		foreach(string s in args)
		{
			// directory
			if ( s.StartsWith("-d") && 2 < s.Length )
			{
				Directory = s.Substring(2);
			}
			// filter
			else if ( s.StartsWith("-f")  && 2 < s.Length )
			{
				FileFilter = s.Substring(2);
			}
			// search string
			else if ( s.StartsWith("-s")  && 2 < s.Length)
			{
				SearchString = s.Substring(2);
			}
			// output file
			else if ( s.StartsWith("-o")  && 2 < s.Length)
			{
				OutputFile = s.Substring(2);
			}
			else if ( s.StartsWith("-?") || s.StartsWith("/?") || s.StartsWith("-h") )
			{
				ArgsHelp();
				return 0;
			}
			else
			{
				Console.WriteLine("Invalid parameter!!");
				ArgsHelp();
			}
		} // foreach

		return 1;
	} // public int ProgramArgs(string[] args)


	/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++
	Method: 	public void ArgsHelp()
	Summary:
	Args:
	Modifies:
	Returns:
	M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
	static private void ArgsHelp()
	{
		Console.WriteLine("StringCheck -d<Directory> -f<File Filter> -s<Search String> -o<Output file>");
		Console.WriteLine("Directory      = Full path to directory that will be scanned.");	
		Console.WriteLine("File Filter    = *, *.cs, etc..");
		Console.WriteLine("Search String  = Regex expression describing text to search for.");
		Console.WriteLine("Output File    = Search results will be written to this file.");
	}

	/*---------------------------------------------------------
		Member Variables
	----------------------------------------------------------*/
	// Directory to scan.
	static public string Directory = "..";

	// Files to scan.
	static public string FileFilter = "*";

	// Search string using regex
	static public string SearchString = "*";

	// Write results to this file
	static public string OutputFile = "out.txt";

} // public class ProgramArgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\inc\ddraw\dwininfo.h ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	wndinfo.h
 *  Content:	Direct Draw window information structure
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   08-jul-95	craige	initial implementation
 *   18-jul-95	craige	keep track of dsound/ddraw hooks with flags
 *   13-aug-95  toddla  added WININFO_ACTIVELIE
 *   09-sep-95  toddla  added WININFO_INACTIVATEAPP
 *   17-may-96  colinmc Bug 23029: Removed WININFO_WASICONIC
 *
 ***************************************************************************/

#ifndef __WNDINFO_INCLUDED__
#define __WNDINFO_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _DDWINDOWINFO
{
    DWORD                       dwSmag;
    struct _DDWINDOWINFO	*lpLink;
    WNDPROC			lpDSoundCallback;
    HWND			hWnd;
    WNDPROC			lpWndProc;
    DWORD			dwPid;
    DWORD			dwFlags;
    struct
    {
	LPDDRAWI_DIRECTDRAW_LCL	lpDD_lcl;
	DWORD			dwDDFlags;
    } DDInfo;
} DDWINDOWINFO, *LPDDWINDOWINFO;

#define WININFO_MAGIC                   0x42954295l
#define WININFO_DDRAWHOOKED		0x00000001l
#define WININFO_DSOUNDHOOKED		0x00000002l
#define WININFO_ZOMBIE                  0x00000008l
#define WININFO_UNHOOK                  0x00000010l
#define WININFO_IGNORENEXTALTTAB	0x00000020l
#define WININFO_SELFSIZE                0x00000040l
#define WININFO_INACTIVATEAPP           0x00000080l

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\inc\ddraw\ddd3dapi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995,1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddd3dapi.h
 *  Content:	Interface between DirectDraw and Direct3D.
 *@@BEGIN_MSINTERNAL
 * 
 *  $Id$
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   02/17/96   colinmc Created this file from the obsolete d3dapi.h
 *   03/23/96   colinmc Added process termination cleanup code
 *   04/17/96   colinmc Bug 17008: DirectDraw/Direct3D deadlock
 *   04/25/96	stevela Bug 16803: Name of Direct3D DLL changed.
 *   04/29/96   colinmc Bug 19954: Must query for Direct3D before texture
 *                      or device
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef _DDD3DAPI_H_
#define _DDD3DAPI_H_

// Flags for D3DDEVICEDESC dwDeviceZBufferBitDepth
// copied from direct3d\rast\d3dif\d3dif.hpp, see note there for explanation

#define D3DSWRASTERIZER_ZBUFFERBITDEPTHFLAGS (DDBD_16)

/*
 * File name of the Direct3D DLL.
 */
#define D3D_DLLNAME               "D3DIM.DLL"
#define D3DDX7_DLLNAME            "D3DIM700.DLL"

/*
 * Entry points exported by the Direct3D DLL.
 */
#define D3DCREATE_PROCNAME        "Direct3DCreate"
#define D3DCREATEDEVICE_PROCNAME  "Direct3DCreateDevice"
#define D3DCREATETEXTURE_PROCNAME "Direct3DCreateTexture"
#define D3DHALCLEANUP_PROCNAME    "Direct3D_HALCleanUp"

#ifdef USE_D3D_CSECT
    typedef HRESULT (WINAPI * D3DCreateProc)(LPUNKNOWN*         lplpD3D,
					     IUnknown*          pUnkOuter);
#else  /* USE_D3D_CSECT */
    typedef HRESULT (WINAPI * D3DCreateProc)(LPCRITICAL_SECTION lpDDCSect,
					     LPUNKNOWN*         lplpD3D,
					     IUnknown*          pUnkOuter);
#endif /* USE_D3D_CSECT */

typedef HRESULT (WINAPI * D3DCreateTextProc)(REFCLSID            riid,
                                             LPDIRECTDRAWSURFACE lpDDS,
					     LPUNKNOWN*          lplpD3DText,
					     IUnknown*           pUnkOuter);
typedef HRESULT (WINAPI * D3DCreateDeviceProc)(REFCLSID            riid,
                                               LPUNKNOWN           lpDirect3D,
                                               LPDIRECTDRAWSURFACE lpDDS,
                                               LPUNKNOWN*          lplpD3DDevice,
                                               IUnknown*           pUnkOuter,
                                               DWORD               dwVersion);

typedef DWORD (WINAPI * D3DGetSWRastPixFmtsProc)(DDPIXELFORMAT **ppDDPF);

typedef HRESULT (WINAPI * D3DHALCleanUpProc)(LPD3DHAL_CALLBACKS lpHALTable, DWORD dwPID);

#endif /* _DDD3DAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\stringcheck2\stringcheck.cs ===
using System;
using System.IO;
using System.Text.RegularExpressions;

namespace StringCheck2
{

	/// <summary>
	/// StringCheck class. Responsible for scanning files for fixed strings.
	/// </summary>
	public class StringCheck
	{
		const string REGEX_QuotedString = "\"*\"";
		public StringCheck()
		{
		}

		/// <summary>
		/// Scans the files in a directory for fixed strings
		/// </summary>
		/// <param name="path">Directory to search</param>
		/// <param name="fileFilter">File filter to use (*.cs, etc)</param>
		/// <param name="exclusions">List of exclusions</param>
		/// <param name="rtb_output">TextBox to display output in. If null, no output displayed</param>
		/// <returns></returns>
		public string[] Scan( string path, string fileFilter, string[] exclusions, System.Windows.Forms.RichTextBox rtb_output, string ResultsFile, bool append )
		{
			DirectoryInfo	dir;
			String			FullName;
			long			FileSize;
			DateTime		CreationDate;

			// Get files in directory.
			dir		= new DirectoryInfo(path);
			foreach (FileInfo f in dir.GetFiles(fileFilter)) 
			{
				ScanFile(f.FullName, REGEX_QuotedString, exclusions, rtb_output, ResultsFile, append);
			} // foreach (FileInfo f in dir.GetFiles(fileFilter)) 

			string[] returnString = new string[1];
			return returnString;
		} // Scan

		/// <summary>
		/// Helper function for Scan. ScanFile scans an individual file, looking for hard coded strings.
		/// </summary>
		/// <param name="InputFile">File name of file to be scanned.</param>
		/// <param name="SearchString">Regular expression string.</param>
		/// <param name="exclusions">String array containing rules for exclusions.</param>
		/// <param name="rtb_output">Pointer to a rich text field used to display output. If set to null, no output will be displayed on-screen.</param>
		/// <param name="ResultsFile">File name of file to write results to.</param>
		/// <param name="append">Append flag. If set to true, results will be appended to ResultsFile. If false, ResultsFile will be overwritten.</param>
		/// <returns></returns>
		private int ScanFile(string InputFile, string SearchString, string[] exclusions, System.Windows.Forms.RichTextBox rtb_output, string ResultsFile, bool append )
		{
			/*---------------------------------------------------------
				To Do: Need error checking
			----------------------------------------------------------*/	
			StreamWriter	OutputStream = null;
			StreamReader	InputStream = null;
			String			line, OutputString;
			int				linenum, padding, i ;
			Match			m;
			Regex			r;
			bool            excludeLine;

			// Open log file and input file
			if ( null != ResultsFile )
			{
				if ( false == append ) File.Delete(ResultsFile);
				OutputStream = File.AppendText(ResultsFile);
			}
			InputStream  = File.OpenText(InputFile);

			// Build regex expression from passed search string
			// System.ArgumentException
			try
			{
				r = new Regex(SearchString);
			}
			catch ( System.ArgumentException )
			{
				if ( null != rtb_output) rtb_output.Text += "\n" + "FileScan:ScanFile() - ERROR - " + SearchString + " is not a valid regex expression";
				return 0;
			}

			// Read input file line by line - repeat until end of file
			//if ( null != rtb_output) rtb_output.Text += "\n" + "Scanning " + InputFile + " For " +  SearchString;
			linenum = 0;

			while ((line=InputStream.ReadLine())!=null)
			{
				linenum++;
				m = r.Match(line);
				if (m.Success)
				{
					// Remove leading spaces
					padding = 0;
					while ( line[padding] == ' ')
					{
						padding++;
					}
					line = line.Substring(padding);
            
					// check exclusions
					excludeLine = false;
					foreach (string s in exclusions)
					{
						if ( -1 != line.IndexOf(s) )
						{
							excludeLine = true;
							break;
						}
					}

					if ( excludeLine == false )
					{
						// Write to output file in CSV format
						if ( null != ResultsFile ) 
						{
							//OutputString = "\"" + InputFile + "\"," + linenum + ",\"" + line + "\"";
							OutputString = InputFile + "~" + linenum + "~" + line;
							OutputStream.WriteLine(OutputString);
						}
						if ( null != rtb_output) rtb_output.Text += "\n" + InputFile + "~" + linenum + "~" + line;
					}
				}
			}

			// cleanup and return
			if ( null != ResultsFile )
			{
				OutputStream.Flush();
				OutputStream.Close();
			}
			InputStream.Close();
			return 1;
		}

	} // class StringCheck
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\inc\ddraw\memalloc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.h
 *  Content:	header file for memory allocation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   22-may-95	craige	added MemAlloc16
 *   12-jun-95	craige	added MemReAlloc
 *   26-jun-95  craige  added GetPtr16
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *
 ***************************************************************************/
#ifndef __MEMALLOC_INCLUDED__
#define __MEMALLOC_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif
extern void MemFini( void );
extern void MemState( void );
extern BOOL MemInit( void );
extern void MemFree( LPVOID lptr );
extern UINT __cdecl MemSize( LPVOID lptr );
extern LPVOID __cdecl MemAlloc( UINT size );
extern LPVOID __cdecl MemReAlloc( LPVOID ptr, UINT size );
extern LPVOID __cdecl MemAlloc16( UINT size, DWORD FAR *p16 );
extern LPVOID GetPtr16( LPVOID ptr );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\inc\ddraw\w95help.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95help.h
 *  Content:	header file for Win95 helper interface
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96	andyco	added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *   22-jan-97  kipo	return an HRESULT from HelperAddDPlayServer()
 *
 ***************************************************************************/
#ifndef __W95HELP_INCLUDED__
#define __W95HELP_INCLUDED__
#include "ddhelp.h"

#ifdef __cplusplus
extern "C" {
#endif

extern void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc );

extern void StopWatchProcess( DWORD pid, LPHELPNOTIFYPROC proc );

extern void SignalNewDriver( LPSTR fname, BOOL isdisp );

extern BOOL CreateHelperProcess( LPDWORD ppid );

extern void DoneWithHelperProcess( void );

extern BOOL WaitForHelperStartup( void );

extern DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context );

extern void HelperCreateThread( void );

extern DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx );

extern DWORD HelperWaveClose( DWORD hwo );

extern DWORD HelperCreateTimer( DWORD dwResolution,LPVOID pTimerProc,DWORD dwInstanceData );

extern DWORD HelperKillTimer( DWORD dwTimerID );

#ifdef _WIN32
extern HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern void HelperCallDSEmulatorCleanup( LPVOID pCleanupFunc,
                                         LPVOID pDirectSound );

#endif

extern BOOL HelperCreateModeSetThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern BOOL HelperCreateDOSBoxThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern void HelperKillModeSetThread( DWORD hInstance );

extern void HelperKillDOSBoxThread( DWORD hInstance );

extern DWORD HelperAddDPlayServer(DWORD port);
extern BOOL HelperDeleteDPlayServer();

#ifdef WIN95
extern HANDLE HelperGetDSVxd( void );

extern HANDLE HelperGetDDVxd( void );

#endif

extern void HelperSetOnDisplayChangeNotify( void *pfn );
extern HINSTANCE HelperLoadLibrary(LPCSTR pszLibraryName);
extern BOOL HelperFreeLibrary(HINSTANCE hInst);
extern void HelperAddDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC);
extern void HelperDelDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\inc\ddraw\ddreg.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddreg.h
 *  Content:	DirectDraw registry entries
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   16-aug-96	craige	initial implementation
 *   06-jan-97  colinmc Initial AGP work
 *   01-feb-97  colinmc Bug 5457: Fixed Win16 lock problem causing hang
 *                      with mutliple AMovie instances on old cards
 *
 ***************************************************************************/

#ifndef __DDRAWREG_INCLUDED__
#define __DDRAWREG_INCLUDED__

#define REGSTR_PATH_DDRAW 		   "Software\\Microsoft\\DirectDraw"

#define	REGSTR_VAL_DDRAW_MODEXONLY	   "ModeXOnly"
#define	REGSTR_VAL_DDRAW_EMULATIONONLY	   "EmulationOnly"
#define REGSTR_VAL_DDRAW_SHOWFRAMERATE	   "ShowFrameRate"
#define REGSTR_VAL_DDRAW_ENABLEPRINTSCRN   "EnablePrintScreen"
#define REGSTR_VAL_DDRAW_DISABLEWIDERSURFACES "DisableWiderSurfaces"
/*
 * This one is checked in DirectDrawMsg
 */
#define REGSTR_VAL_DDRAW_DISABLEDIALOGS    "DisableDialogs"
#define REGSTR_VAL_DDRAW_NODDSCAPSINDDSD   "DisableDDSCAPSInDDSD"

#define REGSTR_VAL_DDRAW_FORCEAGPSUPPORT   "ForceAGPSupport"
#define REGSTR_VAL_DDRAW_AGPPOLICYMAXPAGES "AGPPolicyMaxPages"
#define REGSTR_VAL_DDRAW_AGPPOLICYMAXBYTES "AGPPolicyMaxBytes"
#define REGSTR_VAL_DDRAW_AGPPOLICYCOMMITDELTA "AGPPolicyCommitDelta"
#define REGSTR_VAL_DDRAW_DISABLEAGPSUPPORT "DisableAGPSupport"

#define REGSTR_VAL_DDRAW_DISABLEMMX	   "DisableMMX"

#define REGSTR_VAL_DDRAW_FORCEREFRESHRATE  "ForceRefreshRate"

#define REGSTR_VAL_DDRAW_LOADDEBUGRUNTIME  "LoadDebugRuntime"

#ifdef WIN95
#define REGSTR_KEY_RECENTMONITORS          "MostRecentMonitors"
#define REGSTR_VAL_DDRAW_MONITORSORDER     "Order"
#endif

#ifdef DEBUG
    #define REGSTR_VAL_DDRAW_DISABLENOSYSLOCK  "DisableNoSysLock"
    #define REGSTR_VAL_DDRAW_FORCENOSYSLOCK    "ForceNoSysLock"
#endif /* DEBUG */
#define REGSTR_VAL_DDRAW_DISABLEINACTIVATE "DisableInactivate"

#define REGSTR_KEY_GAMMA_CALIBRATOR        "GammaCalibrator"
#define REGSTR_VAL_GAMMA_CALIBRATOR        "Path"

#define REGSTR_KEY_APPCOMPAT		   "Compatibility"

#define REGSTR_KEY_LASTAPP		   "MostRecentApplication"

#define REGSTR_VAL_DDRAW_NAME		   "Name"
#define REGSTR_VAL_DDRAW_APPID		   "ID"
#define REGSTR_VAL_DDRAW_FLAGS		   "Flags"

#define REGSTR_VAL_D3D_USENONLOCALVIDMEM   "UseNonLocalVidMem"

#define REGSTR_VAL_DDRAW_ENUMSECONDARY     "EnumerateAttachedSecondaries"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\inc\ddraw\dibeng.inc ===
;/*
;----------------------------------------------------------------------------
; DIBENG.INC
; Copyright (c) 1992 Microsoft Corporation
;
; Dib Engine Interface Definitions
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; General Comments:
; The DIB Engine is non-palettized from GDI's perspective.  When an app
; selects a DIB into a memory DC, GDI will create a DIB Engine PDevice 
; (see definition below) and will stuff in a 'DI' in the deType field.
; Subsequent operations on this DC will result in calls to the DIB Engine
; with this PDevice.  
; Device drivers can also use the DIB Engine to handle most, if not all,
; of their rendering work.  A device driver exports the DIB Engine PDevice
; as it's own PDevice to GDI.  This PDevice contains a pointer to a 
; BitmapInfo header in the driver's data segment. Immediately following
; this is an optional color table for devices less than 16 bpp.
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
; E Q U A T E S
;----------------------------------------------------------------------------
BRUSHSIZE	equ	8		;height and width in pixels.
VER_DIBENG      equ     400h            ;version = 4.0
TYPE_DIBENG     equ     'RP'            ;deType
comment ~
*/
#define BRUSHSIZE       8
#define VER_DIBENG      0x400
#define TYPE_DIBENG     0x5250
/*
end comment ~
;----------------------------------------------------------------------------
; S T R U C T U R E S
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; PDevice Structure for the DIB Engine.  deType will contain 'DI' when GDI
; calls the DIB Engine to perform graphics operations on the dib.  deType 
; will contain a 0 or a Selector if a mini-driver is calling the DIB Engine 
; to do graphics operations. 
;----------------------------------------------------------------------------
deCursorExclude		equ deBeginAccess
deCursorUnexclude	equ deEndAccess
comment ~
*/
#define deCursorExclude	deBeginAccess
#define deCursorUnexclude deEndAccess
/*
end comment ~

DIBENGINE	    struc						      ;*/ typedef struct {                        /*
  deType            dw  ?               ; contains TYPE_DIBENG or 0           ;*/ WORD         deType;                    /*
  deWidth	    dw	?		; Width of dib in pixels	      ;*/ WORD         deWidth;                   /*
  deHeight	    dw	?		; Height of dib in pixels	      ;*/ WORD         deHeight;                  /*
  deWidthBytes	    dw	?		; #bytes per scan line		      ;*/ WORD         deWidthBytes;              /*
  dePlanes	    db	?		; # of planes in bitmap 	      ;*/ BYTE         dePlanes;                  /*
  deBitsPixel	    db	?		; # of bits per pixel		      ;*/ BYTE         deBitsPixel;               /*
  deReserved1	    dd	?		; cannot be used.		      ;*/ DWORD        deReserved1;               /*
  deDeltaScan       dd  ?               ; + or -. Displacement to next scan.  ;*/ DWORD        deDeltaScan;               /*
  delpPDevice	    dd	?		; Pointer to associated PDevice       ;*/ LPBYTE       delpPDevice;               /*
  deBits	    df	?		; fword offset to bits of dib	      ;*/ DWORD        deBitsOffset;              /*
                                        ;                                     ;*/ WORD         deBitsSelector;            /*
  deFlags	    dw	?		; additional flags		      ;*/ WORD         deFlags;                   /*
  deVersion	    dw  ?		; lsb=minor, msb=major (0400h = 4.0)  ;*/ WORD         deVersion;                 /*
  deBitmapInfo	    dd	?		; pointer to the bitmapinfo header    ;*/ LPBITMAPINFO deBitmapInfo;              /*
  deBeginAccess     dd	?		; Begin surface access call back      ;*/ void         (FAR *deBeginAccess)();    /*
  deEndAccess       dd	?		; End surface access call back	      ;*/ void         (FAR *deEndAccess)();      /*
  deDriverReserved  dd  ?		; Reserved for Minidriver use.        ;*/ DWORD        deDriverReserved;          /*
DIBENGINE	    ends		                                      ;*/ } DIBENGINE, FAR *LPDIBENGINE;          /*
;----------------------------------------------------------------------------
; Definitions for DIBEngine.deFlags
;----------------------------------------------------------------------------
MINIDRIVER      equ     0000000000000001b       ;display driver
PALETTIZED      equ     0000000000000010b       ;paletized device
SELECTEDDIB     equ     0000000000000100b       ;DIB Section
OFFSCREEN       equ     0000000000001000b       ;offscreen surface (use with VRAM)
DISABLED        equ     0000000000010000b	;going away -- please use BUSY instead [raypat]
BUSY            equ     0000000000010000b	;
NOT_FRAMEBUFFER	equ	0000000000100000b	;example: 8514/a
FIVE6FIVE	equ	0000000001000000b	;16 bpp, 565 color format.
NON64KBANK      equ     0000000010000000b       ;bank size is not 64K
VRAM            equ     1000000000000000b       ;physical surface (video memory)
BANKEDVRAM      equ     0100000000000000b       ;VFlatD simulated
BANKEDSCAN      equ     0010000000000000b       ;VFlatD simulated (broken rasters)
PALETTE_XLAT    equ     0001000000000000b       ;background palette xlat
VGADITHER       equ     0000100000000000b       ;dither to VGA colors (first 8, and last 8)
CTCHANGE        equ     0000010000000000b       ;color table has been changed
DITHER256       equ     0000001000000000b       ;dither to 256 fixed colors
FREE2           equ     0000000100000000b       ;free

BUSY_BIT        equ     4                       ;bit number to test for BUSY


comment ~
*/
#define MINIDRIVER      0x0001	  
#define PALETTIZED      0x0002	  
#define SELECTEDDIB     0x0004	  
#define OFFSCREEN       0x0008
#define DISABLED        0x0010
#define BUSY            0x0010		
#define NOT_FRAMEBUFFER 0x0020
#define FIVE6FIVE       0x0040
#define NON64KBANK      0x0080
#define VRAM            0x8000	  
#define BANKEDVRAM      0x4000	  
#define BANKEDSCAN      0x2000
#define PALETTE_XLAT    0x1000
#define VGADITHER       0x0800
#define CTCHANGE        0x0400
#define DITHER256       0x0200

#define BUSY_BIT        0x0004
/*
end comment ~

;----------------------------------------------------------------------------
; Definitions for DIBEngine.deBeginAccess flags
;----------------------------------------------------------------------------
FB_ACCESS   	equ     0000000000000001b
CURSOREXCLUDE  	equ     0000000000001000b

comment ~
*/
#define FB_ACCESS	0x0001
#define CURSOREXCLUDE	0x0008
/*
end comment ~


;----------------------------------------------------------------------------
; Definitions for most significant byte of a physical color.
;----------------------------------------------------------------------------
GREY_BIT        equ     01000000b       ;color is grey (r=g=b)
comment ~
*/
#define GREY_BIT        0x40	  
/*
end comment ~
;----------------------------------------------------------------------------
; DIB Engine Color Table entry structure. This structure is used by device
; drivers that are using DIB Engine services for rendering.  This structure
; is identical to the RGBQuad structure except for some bit definitions
; in the 4th byte.
;----------------------------------------------------------------------------
DIBColorEntry	struc							      ;*/ typedef struct {		  /*
  dceBlue	    db	?                                                     ;*/ BYTE dceBlue;	                  /*
  dceGreen	    db	?                                                     ;*/ BYTE dceGreen;                  /*
  dceRed	    db	?                                                     ;*/ BYTE dceRed;	                  /*
  dceFlags          db  ?                                                     ;*/ BYTE dceFlags;                  /*
DIBColorEntry	ends                                                          ;*/ } DIBColorEntry;                /*
;----------------------------------------------------------------------------
; Definitions for DIBColorEntry.dceFlags
;----------------------------------------------------------------------------
NONSTATIC	equ	10000000b      ;Inhibits color matching to this entry.
MAPTOWHITE	equ	00000001b      ;0=Black, 1=White
comment ~
*/
#define NONSTATIC       0x80	  
#define MAPTOWHITE      0x01	  
/*
end comment ~
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; DIB Engine Physical Object Definitions
;----------------------------------------------------------------------------

DIB_Pen	struc                                                                 ;*/ typedef struct {                /*  
dpPenStyle	dw	?                                                     ;*/ WORD  dpPenStyle;               /*  
dpPenFlags	db	?		;currently none undefined.            ;*/ BYTE  dpPenFlags;               /*
dpPenBpp	db	?	                                              ;*/ BYTE  dpPenBpp;                 /*
dpPenMono	dd	?                                                     ;*/ DWORD dpPenMono;                /*
dpPenColor	dd	?                                                     ;*/ DWORD dpPenColor;               /*
DIB_Pen	ends                                                                  ;*/ } DIB_Pen;                      /*

DIB_Brush1	struc                                                         ;*/ typedef struct {                /*  
dp1BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp1BrushFlags;            /*
dp1BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp1BrushBpp;              /*
dp1BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp1BrushStyle;            /*
dp1FgColor	dd	?		    ;Physical fg color                ;*/ DWORD dp1FgColor;               /*
dp1Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp1Hatch;                 /*
dp1BgColor	dd	?		    ;Physical bg color                ;*/ DWORD dp1BgColor;               /*
dp1BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp1BrushMono [BRUSHSIZE*4];/*
dp1BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp1BrushMask [BRUSHSIZE*4];/*
dp1BrushBits	db	BRUSHSIZE*4 dup (?) ;8 rows, 8 columns of 1 bit/pixel ;*/ BYTE dp1BrushBits [BRUSHSIZE*4];/* 
DIB_Brush1	ends                                                          ;*/ } DIB_Brush1;                   /*  

DIB_Brush4	struc                                                         ;*/ typedef struct {                /*  
dp4BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp4BrushFlags;            /*
dp4BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp4BrushBpp;              /*
dp4BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp4BrushStyle;            /*
dp4FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp4FgColor;               /*
dp4Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp4Hatch;                 /*
dp4BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp4BgColor;               /*
dp4BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp4BrushMono [BRUSHSIZE*4];/*
dp4BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp4BrushMask [BRUSHSIZE*4];/*
dp4BrushBits	db	BRUSHSIZE*4 dup (?) ;8 rows, 8 columns of 4 bit/pixel ;*/ BYTE dp4BrushBits [BRUSHSIZE*4];/* 
DIB_Brush4	ends                                                          ;*/ } DIB_Brush4;                   /*  

DIB_Brush8	struc                                                         ;*/ typedef struct {                /*  
dp8BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp8BrushFlags;            /*
dp8BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp8BrushBpp;              /*
dp8BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp8BrushStyle;            /*
dp8FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp8FgColor;               /*
dp8Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp8Hatch;                 /*
dp8BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp8BgColor;               /*
dp8BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp8BrushMono [BRUSHSIZE*4];/*
dp8BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp8BrushMask [BRUSHSIZE*4];/*
dp8BrushBits	db	BRUSHSIZE*8 dup (?) ;8 rows,8 columns of 8 bit/pixel  ;*/ BYTE dp8BrushBits [BRUSHSIZE*8];/* 
DIB_Brush8	ends                                                          ;*/ } DIB_Brush8;                   /*  

DIB_Brush16	struc                                                         ;*/ typedef struct {                /*  
dp16BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp16BrushFlags;            /*
dp16BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp16BrushBpp;              /*
dp16BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp16BrushStyle;            /*
dp16FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp16FgColor;               /*
dp16Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp16Hatch;                 /*
dp16BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp16BgColor;               /*
dp16BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp16BrushMono [BRUSHSIZE*4];/*
dp16BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp16BrushMask [BRUSHSIZE*4];/*
dp16BrushBits	db	BRUSHSIZE*16 dup (?);8 rows,8 columns of 16 bit/pixel;*/ BYTE dp16BrushBits [BRUSHSIZE*16];/* 
DIB_Brush16	ends                                                          ;*/ } DIB_Brush16;                   /*  

DIB_Brush24	struc                                                         ;*/ typedef struct {                /*  
dp24BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp24BrushFlags;            /*
dp24BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp24BrushBpp;              /*
dp24BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp24BrushStyle;            /*
dp24FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp24FgColor;               /*
dp24Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp24Hatch;                 /*
dp24BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp24BgColor;               /*
dp24BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp24BrushMono [BRUSHSIZE*4];/*
dp24BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp24BrushMask [BRUSHSIZE*4];/*
dp24BrushBits	db	BRUSHSIZE*24 dup (?);8 rows,8 columns of 24 bit/pixel ;*/ BYTE dp24BrushBits [BRUSHSIZE*24];/* 
DIB_Brush24	ends                                                          ;*/ } DIB_Brush24;                   /*  

DIB_Brush32	struc                                                         ;*/ typedef struct {                /*  
dp32BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp32BrushFlags;            /*
dp32BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp32BrushBpp;              /*
dp32BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp32BrushStyle;            /*
dp32FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp32FgColor;               /*
dp32Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp32Hatch;                 /*
dp32BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp32BgColor;               /*
dp32BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp32BrushMono [BRUSHSIZE*4];/*
dp32BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp32BrushMask [BRUSHSIZE*4];/*
dp32BrushBits	db	BRUSHSIZE*32 dup (?);8 rows,8 columns of 32 bit/pixel ;*/ BYTE dp32BrushBits [BRUSHSIZE*32];/* 
DIB_Brush32	ends                                                          ;*/ } DIB_Brush32;                   /*  

;----------------------------------------------------------------------------
; Definitions for DIB_Brushxx.dpxxBrushFlags
;----------------------------------------------------------------------------                                      
COLORSOLID     equ      00000001b ;Color part is solid.                        
MONOSOLID      equ      00000010b ;Mono part is solid.                         
PATTERNMONO    equ      00000100b ;Pattern brush came from a mono bitmap.      
MONOVALID      equ      00001000b ;Mono part is valid.                         
MASKVALID      equ      00010000b ;Transparency Mask part is valid.
PRIVATEDATA    equ      00100000b ;Vendor specific bit for Pens, Brushes
comment ~
*/
#define  COLORSOLID     0x01         
#define  MONOSOLID      0x02         
#define  PATTERNMONO    0x04         
#define  MONOVALID      0x08         
#define  MASKVALID      0x10
#define  PRIVATEDATA    0x20
/*
end comment ~
;----------------------------------------------------------------------------
; ColorToMono
; Entry: red, green, blue
; Exit:  blue = intensity.
;----------------------------------------------------------------------------
ColorToMono	macro	red, green, blue
	add	blue,red		;R+B
        rcr     blue,1                  ;(R+B)/2
	add	blue,green		;pitch in Green
        rcr     blue,1                  ;G/2 + (R+B)/4
endm	ColorToMono

;----------------------------------------------------------------------------
; ColorToMonoBit
; Entry: red, green, blue
; Exit:  blue = 0 if color maps to black
;        blue = 1 if color maps to white
;----------------------------------------------------------------------------
ColorToMonoBit	macro	red, green, blue
	ColorToMono red,green,blue    ; Call ColorToMono to derive intensity.
	cmp	blue,127
	setnc	blue
endm ColorToMonoBit

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\inc\ddraw\ids.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ids.h
 *  Content:    DirectDraw resource ids
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   10-sep-95  toddla  created
 *   20-sep-95	craige	add IDS_PRIMARYDISPLAY
 *
 ***************************************************************************/

// icon ids
#define ID_ICON             42

// string ids
#define IDS_TITLE           100     // dialog box title
#define IDS_DONTWORK_BPP    101     // you must be in 256 color mode or higher.
#define IDS_DONTWORK_DRV    102     // your driver is bad.
#define IDS_PRIMARYDISPLAY  103     // primary display ident. string
#define IDS_TIME_BOMB		104		// time bomb message string
#define IDS_TIME_BOMB_TITLE	105		// time bomb title string
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\inc\ddraw\dpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.h
 *  Content:    header file for debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-apr-95  craige  initial implementation
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96  kipo    added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
#include "newdpf.h"
#else

    #ifndef __DPF_INCLUDED__
    #define __DPF_INCLUDED__

    #ifdef __cplusplus
    extern "C" {
    #endif

    #ifdef WINNT
        #undef DEBUG
        #ifdef DBG
            #define DEBUG
        #endif
    #endif

    extern void cdecl DXdprintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DInfoPrintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DWarnPrintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DErrorPrintf( LPSTR szFormat, ...);

    extern void DPFInit( void );
    #ifdef DEBUG
        #define DPF_DECLARE(szName) char * __pszDpfName=#szName":"
        #define DPFINIT()   DPFInit()
        #define DPF         DXdprintf
        #define DPF_ERR(a)  DXdprintf( 0, DPF_MODNAME ": " a );
        extern HWND hWndListBox;
        #if defined( _WIN32 ) && !defined(WINNT)
            #define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
        #else
            #define DEBUG_BREAK()       DebugBreak()
        #endif
        #define USE_DDASSERT

        // New for D3D
        #define D3D_ERR       D3DErrorPrintf
        #define D3D_WARN      D3DWarnPrintf
        #define D3D_INFO      D3DInfoPrintf
    #else
        #pragma warning(disable:4002)
        #define DPF_DECLARE(szName)
        #define DPFINIT()
        #define DPF()
        #define DPF_ERR(a)
        #define DEBUG_BREAK()

        #define D3D_ERR(a)
        #define D3D_WARN()
        #define D3D_INFO()
    #endif

    #if defined(DEBUG) && defined(USE_DDASSERT)

    extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);

    #define DDASSERT(condition) if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)

    #else  /* DEBUG && USE_DDASSERT */

    #define DDASSERT(condition)

    #endif /* DEBUG && USE_DDASSERT */

    #ifdef _WIN32

    #ifdef DEBUG
        __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
        __inline DWORD perf_clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

        #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
        #define TIMEZERO(t)   t ## T = 0, t ## N = 0
        #define TIMESTART(t)  t ## T -= perf_clock(), t ## N ++
        #define TIMESTOP(t)   t ## T += perf_clock()
        #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
        #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
    #else
        #define TIMEVAR(t)
        #define TIMEZERO(t)
        #define TIMESTART(t)
        #define TIMESTOP(t)
        #define TIMEFMT(t)
        #define TIMEOUT(t)
    #endif

    #endif
    #ifdef __cplusplus
    }
    #endif

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\audiosrv\agfxs.h ===
/* agfxs.h
 * header for extern GFX functions
 * Copyright (c) 2000-2001 Microsoft Corporation
 */
BOOL GFX_DllProcessAttach(void);
void GFX_DllProcessDetach(void);

void GFX_AudioInterfaceArrival(PCTSTR DeviceInterface);
void GFX_AudioInterfaceRemove(PCTSTR DeviceInterface);

void GFX_RenderInterfaceArrival(PCTSTR DeviceInterface);
void GFX_RenderInterfaceRemove(PCTSTR DeviceInterface);

void GFX_CaptureInterfaceArrival(PCTSTR DeviceInterface);
void GFX_CaptureInterfaceRemove(PCTSTR DeviceInterface);

void GFX_DataTransformInterfaceArrival(PCTSTR DeviceInterface);
void GFX_DataTransformInterfaceRemove(PCTSTR DeviceInterface);

void GFX_SysaudioInterfaceArrival(PCTSTR DeviceInterface);
void GFX_SysaudioInterfaceRemove(PCTSTR DeviceInterface);

void GFX_SessionChange(DWORD EventType, LPVOID EventData);

void GFX_ServiceStop(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ehometest\userxp\stringcheck2\frm_main.cs ===
using System;
using System.IO;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;

namespace StringCheck2
{
	/// <summary>
	/// The PARAMETERS class holds all of the command line and default options for this application.
	/// </summary>
	class PARAMETERS
	{
		/// <summary>Controls display of results output. Set to true to display output on-screen. Default = false</summary>
		static public bool		displayOutput	= false;					// -d
		/// <summary>Points to the file which search results should be written to. Default = results.txt</summary>
		static public string	resultsFile		= "results.txt";			// -w "file"
		/// <summary>If set equal to true, results will be appended to the file specified in resultsFile. If false, the file will be overwriten. Default = false</summary>
		static public bool		append			= false;					// -a
		/// <summary>Directory containing files to scan. Default = .\</summary>
		static public string	path			= ".\\";					// -p "path"
		/// <summary>File filter to use when selecting documents to scan. Wildcards (*.cs, etc.) are ok. Default = "*.cs"</summary>
		static public string	file			= "*.cs";					// -f "filter"
		/// <summary>Set this parameter equal to a file name to write a file containing command line options
		/// that match the values entered in the GUI. By default the value is "" and no file will be written.</summary>
		static public string	cmdFile			= "";						// -c "cmd file"
		/// <summary>If the autorun flag is set to true then the program will process files and exit without displaying the GUI.
		/// Use for automating the string search tool. Default = false</summary>
		static public bool		autorun			= false;					// -r
		/// <summary>File containing exclusion strings. One per line. These strings are used to exclude
		/// lines of code that would otherwise be added to the results of the hard coded string search.</summary>
		static public string	exclusionFile	= "exclusions.txt";			// -e "exclusions file"
	}

	/// <summary>
	/// This is the main GUI form for the StringSearch tool.
	/// </summary>
	public class frm_main : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Button btn_run;
		private System.Windows.Forms.TabControl tabControl1;
		private System.Windows.Forms.TabPage tab_opts;
		private System.Windows.Forms.GroupBox groupBox1;
		private System.Windows.Forms.Label label5;
		private System.Windows.Forms.Label label4;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.CheckBox cb_append;
		private System.Windows.Forms.TextBox txt_cmdFile;
		private System.Windows.Forms.TextBox txt_fileFilter;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.TextBox txt_path;
		private System.Windows.Forms.TextBox txt_output;
		private System.Windows.Forms.TabPage tab_exclusions;
		private System.Windows.Forms.TabPage tab_output;
		private System.Windows.Forms.RichTextBox rtb_output;
		private System.Windows.Forms.RichTextBox rtb_exclusions;
		private System.Windows.Forms.TextBox txt_exclusion;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;
		private System.Windows.Forms.GroupBox groupBox2;
		private System.Windows.Forms.Button btn_saveExclusions;
		private System.Windows.Forms.Button btn_reloadExclusions;
		private System.Windows.Forms.CheckBox cb_autoRunFlag;
		private System.Windows.Forms.Button btn_saveCmdFile;
		private System.Windows.Forms.StatusBar statusBar1;
		private System.Windows.Forms.StatusBarPanel statusBarPanel1;

		StringCheck sc;

		/// <summary>
		/// Default Constructor for frm_main. This is the place to set all initial control values, etc.
		/// </summary>
		public frm_main()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			// Set all controls to parameters passed on command line.
			txt_output.Text				= PARAMETERS.resultsFile;
			cb_append.Checked			= PARAMETERS.append;
			txt_path.Text				= PARAMETERS.path;
			txt_fileFilter.Text			= PARAMETERS.file;
			txt_cmdFile.Text			= PARAMETERS.cmdFile;
			txt_exclusion.Text			= PARAMETERS.exclusionFile;

			// Load exclusions file
			try
			{
				rtb_exclusions.LoadFile(PARAMETERS.exclusionFile,RichTextBoxStreamType.PlainText);
			}
			catch
			{
				rtb_exclusions.Text = "";
			}

			// Create a stringcheck instance
			sc = new StringCheck();
		}

		/// <summary>
		/// Clean up any resources being used.
		/// /// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.btn_run = new System.Windows.Forms.Button();
			this.tabControl1 = new System.Windows.Forms.TabControl();
			this.tab_opts = new System.Windows.Forms.TabPage();
			this.groupBox1 = new System.Windows.Forms.GroupBox();
			this.txt_exclusion = new System.Windows.Forms.TextBox();
			this.label4 = new System.Windows.Forms.Label();
			this.label3 = new System.Windows.Forms.Label();
			this.cb_append = new System.Windows.Forms.CheckBox();
			this.txt_fileFilter = new System.Windows.Forms.TextBox();
			this.label2 = new System.Windows.Forms.Label();
			this.label1 = new System.Windows.Forms.Label();
			this.txt_path = new System.Windows.Forms.TextBox();
			this.txt_output = new System.Windows.Forms.TextBox();
			this.groupBox2 = new System.Windows.Forms.GroupBox();
			this.btn_saveCmdFile = new System.Windows.Forms.Button();
			this.cb_autoRunFlag = new System.Windows.Forms.CheckBox();
			this.txt_cmdFile = new System.Windows.Forms.TextBox();
			this.label5 = new System.Windows.Forms.Label();
			this.tab_exclusions = new System.Windows.Forms.TabPage();
			this.btn_reloadExclusions = new System.Windows.Forms.Button();
			this.btn_saveExclusions = new System.Windows.Forms.Button();
			this.rtb_exclusions = new System.Windows.Forms.RichTextBox();
			this.tab_output = new System.Windows.Forms.TabPage();
			this.rtb_output = new System.Windows.Forms.RichTextBox();
			this.statusBar1 = new System.Windows.Forms.StatusBar();
			this.statusBarPanel1 = new System.Windows.Forms.StatusBarPanel();
			this.tabControl1.SuspendLayout();
			this.tab_opts.SuspendLayout();
			this.groupBox1.SuspendLayout();
			this.groupBox2.SuspendLayout();
			this.tab_exclusions.SuspendLayout();
			this.tab_output.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.statusBarPanel1)).BeginInit();
			this.SuspendLayout();
			// 
			// btn_run
			// 
			this.btn_run.Location = new System.Drawing.Point(280, 16);
			this.btn_run.Name = "btn_run";
			this.btn_run.TabIndex = 7;
			this.btn_run.Text = "&Run";
			this.btn_run.Click += new System.EventHandler(this.btn_run_Click);
			// 
			// tabControl1
			// 
			this.tabControl1.Controls.AddRange(new System.Windows.Forms.Control[] {
																					  this.tab_opts,
																					  this.tab_exclusions,
																					  this.tab_output});
			this.tabControl1.Location = new System.Drawing.Point(8, 8);
			this.tabControl1.Name = "tabControl1";
			this.tabControl1.SelectedIndex = 0;
			this.tabControl1.Size = new System.Drawing.Size(400, 336);
			this.tabControl1.TabIndex = 2;
			// 
			// tab_opts
			// 
			this.tab_opts.Controls.AddRange(new System.Windows.Forms.Control[] {
																				   this.groupBox1,
																				   this.groupBox2});
			this.tab_opts.Location = new System.Drawing.Point(4, 22);
			this.tab_opts.Name = "tab_opts";
			this.tab_opts.Size = new System.Drawing.Size(392, 310);
			this.tab_opts.TabIndex = 0;
			this.tab_opts.Text = "Options";
			// 
			// groupBox1
			// 
			this.groupBox1.Controls.AddRange(new System.Windows.Forms.Control[] {
																					this.txt_exclusion,
																					this.label4,
																					this.label3,
																					this.cb_append,
																					this.txt_fileFilter,
																					this.label2,
																					this.label1,
																					this.txt_path,
																					this.txt_output,
																					this.btn_run});
			this.groupBox1.Location = new System.Drawing.Point(8, 16);
			this.groupBox1.Name = "groupBox1";
			this.groupBox1.Size = new System.Drawing.Size(376, 192);
			this.groupBox1.TabIndex = 3;
			this.groupBox1.TabStop = false;
			this.groupBox1.Text = "Run Options";
			// 
			// txt_exclusion
			// 
			this.txt_exclusion.Location = new System.Drawing.Point(96, 160);
			this.txt_exclusion.Name = "txt_exclusion";
			this.txt_exclusion.Size = new System.Drawing.Size(264, 20);
			this.txt_exclusion.TabIndex = 5;
			this.txt_exclusion.Text = "*.cs";
			this.txt_exclusion.TextChanged += new System.EventHandler(this.txt_exclusion_TextChanged);
			// 
			// label4
			// 
			this.label4.ImageAlign = System.Drawing.ContentAlignment.MiddleRight;
			this.label4.Location = new System.Drawing.Point(8, 160);
			this.label4.Name = "label4";
			this.label4.Size = new System.Drawing.Size(80, 23);
			this.label4.TabIndex = 10;
			this.label4.Text = "Exclusion File";
			this.label4.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// label3
			// 
			this.label3.ImageAlign = System.Drawing.ContentAlignment.MiddleRight;
			this.label3.Location = new System.Drawing.Point(24, 64);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(64, 23);
			this.label3.TabIndex = 9;
			this.label3.Text = "Results File";
			this.label3.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// cb_append
			// 
			this.cb_append.Location = new System.Drawing.Point(24, 24);
			this.cb_append.Name = "cb_append";
			this.cb_append.Size = new System.Drawing.Size(152, 24);
			this.cb_append.TabIndex = 1;
			this.cb_append.Text = "Append to Results File";
			this.cb_append.CheckedChanged += new System.EventHandler(this.cb_append_CheckedChanged);
			// 
			// txt_fileFilter
			// 
			this.txt_fileFilter.Location = new System.Drawing.Point(96, 128);
			this.txt_fileFilter.Name = "txt_fileFilter";
			this.txt_fileFilter.Size = new System.Drawing.Size(64, 20);
			this.txt_fileFilter.TabIndex = 4;
			this.txt_fileFilter.Text = "*.cs";
			this.txt_fileFilter.TextChanged += new System.EventHandler(this.txt_fileFilter_TextChanged);
			// 
			// label2
			// 
			this.label2.ImageAlign = System.Drawing.ContentAlignment.MiddleRight;
			this.label2.Location = new System.Drawing.Point(32, 128);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(56, 23);
			this.label2.TabIndex = 5;
			this.label2.Text = "File Filter";
			this.label2.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// label1
			// 
			this.label1.ImageAlign = System.Drawing.ContentAlignment.MiddleRight;
			this.label1.Location = new System.Drawing.Point(16, 96);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(72, 23);
			this.label1.TabIndex = 4;
			this.label1.Text = "Path to Scan";
			this.label1.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// txt_path
			// 
			this.txt_path.Location = new System.Drawing.Point(96, 96);
			this.txt_path.Name = "txt_path";
			this.txt_path.Size = new System.Drawing.Size(264, 20);
			this.txt_path.TabIndex = 3;
			this.txt_path.Text = ".\\";
			this.txt_path.TextChanged += new System.EventHandler(this.txt_path_TextChanged);
			// 
			// txt_output
			// 
			this.txt_output.Location = new System.Drawing.Point(96, 64);
			this.txt_output.Name = "txt_output";
			this.txt_output.Size = new System.Drawing.Size(264, 20);
			this.txt_output.TabIndex = 2;
			this.txt_output.Text = ".\\results.txt";
			this.txt_output.TextChanged += new System.EventHandler(this.txt_output_TextChanged);
			// 
			// groupBox2
			// 
			this.groupBox2.Controls.AddRange(new System.Windows.Forms.Control[] {
																					this.btn_saveCmdFile,
																					this.cb_autoRunFlag,
																					this.txt_cmdFile,
																					this.label5});
			this.groupBox2.Location = new System.Drawing.Point(8, 216);
			this.groupBox2.Name = "groupBox2";
			this.groupBox2.Size = new System.Drawing.Size(376, 88);
			this.groupBox2.TabIndex = 5;
			this.groupBox2.TabStop = false;
			this.groupBox2.Text = "Command File Options";
			// 
			// btn_saveCmdFile
			// 
			this.btn_saveCmdFile.Location = new System.Drawing.Point(272, 56);
			this.btn_saveCmdFile.Name = "btn_saveCmdFile";
			this.btn_saveCmdFile.TabIndex = 13;
			this.btn_saveCmdFile.Text = "&Save";
			this.btn_saveCmdFile.Click += new System.EventHandler(this.btn_saveCmdFile_Click);
			// 
			// cb_autoRunFlag
			// 
			this.cb_autoRunFlag.Location = new System.Drawing.Point(16, 56);
			this.cb_autoRunFlag.Name = "cb_autoRunFlag";
			this.cb_autoRunFlag.TabIndex = 12;
			this.cb_autoRunFlag.Text = "Auto run flag";
			this.cb_autoRunFlag.CheckedChanged += new System.EventHandler(this.cb_autoRunFlag_CheckedChanged);
			// 
			// txt_cmdFile
			// 
			this.txt_cmdFile.Location = new System.Drawing.Point(96, 24);
			this.txt_cmdFile.Name = "txt_cmdFile";
			this.txt_cmdFile.Size = new System.Drawing.Size(264, 20);
			this.txt_cmdFile.TabIndex = 6;
			this.txt_cmdFile.Text = ".\\check.cmd";
			this.txt_cmdFile.TextChanged += new System.EventHandler(this.txt_cmdFile_TextChanged);
			// 
			// label5
			// 
			this.label5.ImageAlign = System.Drawing.ContentAlignment.MiddleRight;
			this.label5.Location = new System.Drawing.Point(16, 24);
			this.label5.Name = "label5";
			this.label5.Size = new System.Drawing.Size(80, 23);
			this.label5.TabIndex = 11;
			this.label5.Text = "Command File";
			this.label5.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// tab_exclusions
			// 
			this.tab_exclusions.Controls.AddRange(new System.Windows.Forms.Control[] {
																						 this.btn_reloadExclusions,
																						 this.btn_saveExclusions,
																						 this.rtb_exclusions});
			this.tab_exclusions.Location = new System.Drawing.Point(4, 22);
			this.tab_exclusions.Name = "tab_exclusions";
			this.tab_exclusions.Size = new System.Drawing.Size(392, 310);
			this.tab_exclusions.TabIndex = 1;
			this.tab_exclusions.Text = "Exclusions";
			// 
			// btn_reloadExclusions
			// 
			this.btn_reloadExclusions.Location = new System.Drawing.Point(88, 8);
			this.btn_reloadExclusions.Name = "btn_reloadExclusions";
			this.btn_reloadExclusions.TabIndex = 2;
			this.btn_reloadExclusions.Text = "&Reload";
			this.btn_reloadExclusions.Click += new System.EventHandler(this.btn_reloadExclusions_Click);
			// 
			// btn_saveExclusions
			// 
			this.btn_saveExclusions.Location = new System.Drawing.Point(8, 8);
			this.btn_saveExclusions.Name = "btn_saveExclusions";
			this.btn_saveExclusions.TabIndex = 1;
			this.btn_saveExclusions.Text = "&Save";
			this.btn_saveExclusions.Click += new System.EventHandler(this.btn_saveExclusions_Click);
			// 
			// rtb_exclusions
			// 
			this.rtb_exclusions.Font = new System.Drawing.Font("Courier New", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.rtb_exclusions.Location = new System.Drawing.Point(8, 40);
			this.rtb_exclusions.Name = "rtb_exclusions";
			this.rtb_exclusions.Size = new System.Drawing.Size(112, 184);
			this.rtb_exclusions.TabIndex = 0;
			this.rtb_exclusions.Text = "";
			// 
			// tab_output
			// 
			this.tab_output.Controls.AddRange(new System.Windows.Forms.Control[] {
																					 this.rtb_output});
			this.tab_output.Location = new System.Drawing.Point(4, 22);
			this.tab_output.Name = "tab_output";
			this.tab_output.Size = new System.Drawing.Size(392, 310);
			this.tab_output.TabIndex = 2;
			this.tab_output.Text = "Output";
			// 
			// rtb_output
			// 
			this.rtb_output.Font = new System.Drawing.Font("Courier New", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.rtb_output.Location = new System.Drawing.Point(8, 8);
			this.rtb_output.Name = "rtb_output";
			this.rtb_output.Size = new System.Drawing.Size(136, 208);
			this.rtb_output.TabIndex = 0;
			this.rtb_output.Text = "";
			// 
			// statusBar1
			// 
			this.statusBar1.Location = new System.Drawing.Point(0, 368);
			this.statusBar1.Name = "statusBar1";
			this.statusBar1.Panels.AddRange(new System.Windows.Forms.StatusBarPanel[] {
																						  this.statusBarPanel1});
			this.statusBar1.Size = new System.Drawing.Size(416, 22);
			this.statusBar1.TabIndex = 5;
			this.statusBar1.Text = "Ready";
			// 
			// statusBarPanel1
			// 
			this.statusBarPanel1.Text = "statusBarPanel1";
			// 
			// frm_main
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(416, 390);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.statusBar1,
																		  this.tabControl1});
			this.Name = "frm_main";
			this.Text = "StringCheck";
			this.Layout += new System.Windows.Forms.LayoutEventHandler(this.frm_main_Layout);
			this.tabControl1.ResumeLayout(false);
			this.tab_opts.ResumeLayout(false);
			this.groupBox1.ResumeLayout(false);
			this.groupBox2.ResumeLayout(false);
			this.tab_exclusions.ResumeLayout(false);
			this.tab_output.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.statusBarPanel1)).EndInit();
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// StringCheck2 main entry point. Processes command line and displays GUI or runs scan depending on -r command line option.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			// Process command line
			if ( true == ProcessCommandLine(args) )
			{
				// Load gui
				Application.Run(new frm_main());
			}
			else
			{
				System.Windows.Forms.RichTextBox rtb_exclusions = new System.Windows.Forms.RichTextBox();
				StringCheck sc = new StringCheck();

				// Load exclusions file and process files
				try
				{
					rtb_exclusions.LoadFile(PARAMETERS.exclusionFile,RichTextBoxStreamType.PlainText);
				}
				catch
				{
					Console.WriteLine("ERROR - Could Not Load File {0}", PARAMETERS.exclusionFile);
					return;
				}
				sc.Scan(PARAMETERS.path, PARAMETERS.file, rtb_exclusions.Lines, null, PARAMETERS.resultsFile, PARAMETERS.append);
			} // if 
		} // main

		/// <summary>
		/// Process the command line arguments and fill the PARAMETERS structure.
		/// </summary>
		static private bool ProcessCommandLine(string[] args)
		{
			bool retval = true;
			// Lets get the command line options.
			foreach(string s in args)
			{
				// -d display output flag
				if ( s.StartsWith("-d") )
				{
					PARAMETERS.displayOutput = true;
				}
				// -w write results to file
				else if ( s.StartsWith("-w")  && 2 < s.Length )
				{
					PARAMETERS.resultsFile = s.Substring(2);
				}
				// -a append flag
				else if ( s.StartsWith("-a"))
				{
					PARAMETERS.append = true;
				}
				// -p path 
				else if ( s.StartsWith("-p")  && 2 < s.Length)
				{
					PARAMETERS.path = s.Substring(2);
				}
				// -f file filter
				else if ( s.StartsWith("-f")  && 2 < s.Length)
				{
					PARAMETERS.file = s.Substring(2);
				}
				// -c command file
				else if ( s.StartsWith("-c")  && 2 < s.Length)
				{
					PARAMETERS.cmdFile = s.Substring(2);
				}
				// -r auto run flag
				else if ( s.StartsWith("-r"))
				{
					PARAMETERS.autorun = true;
					retval = false;
				}
				// -e exclusions file
				else if ( s.StartsWith("-e")  && 2 < s.Length)
				{
					PARAMETERS.exclusionFile = s.Substring(2);
				}
			} // foreach
			return retval;
		} // ProcessCommandLine

		/// <summary>
		/// Append checkbox event handler. Updates PARAMETERS.append
		/// </summary>
		private void cb_append_CheckedChanged(object sender, System.EventArgs e)
		{
			PARAMETERS.append = cb_append.Checked;
		}

		/// <summary>
		/// Output file text changed event handler
		/// </summary>
		private void txt_output_TextChanged(object sender, System.EventArgs e)
		{
			PARAMETERS.resultsFile = txt_output.Text;
		}

		/// <summary>
		/// Search path text changed event handler
		/// </summary>
		private void txt_path_TextChanged(object sender, System.EventArgs e)
		{
			PARAMETERS.path = txt_path.Text;
		}

		/// <summary>
		/// File filter text changed event handler
		/// </summary>
		private void txt_fileFilter_TextChanged(object sender, System.EventArgs e)
		{
			PARAMETERS.file = txt_fileFilter.Text;
		}

		/// <summary>
		/// Exclusion file text changed event handler
		/// </summary>
		private void txt_exclusion_TextChanged(object sender, System.EventArgs e)
		{
			PARAMETERS.exclusionFile = txt_exclusion.Text;
			// Try to load exclusions file
			try
			{
				rtb_exclusions.LoadFile(PARAMETERS.exclusionFile,RichTextBoxStreamType.PlainText);
			}
			catch
			{
				rtb_exclusions.Text = "";
			}
		}

		/// <summary>
		/// Command file text changed event handler
		/// </summary>
		private void txt_cmdFile_TextChanged(object sender, System.EventArgs e)
		{
			PARAMETERS.cmdFile = txt_cmdFile.Text;
		}

		/// <summary>
		/// Run button clicked event handler
		/// </summary>
		private void btn_run_Click(object sender, System.EventArgs e)
		{
			string[] testexclusions = { "Assembly", "chris was here", "this is a test" };
			string results;

			if (PARAMETERS.resultsFile == "") results = null;
			else results = PARAMETERS.resultsFile;

			rtb_output.Text = "";
			statusBar1.Text = "RUNNING....";
			//sc.Scan(PARAMETERS.path, PARAMETERS.file, testexclusions, rtb_output, results, PARAMETERS.append);
			sc.Scan(PARAMETERS.path, PARAMETERS.file, rtb_exclusions.Lines, rtb_output, results, PARAMETERS.append);
			statusBar1.Text = "RUN Complete!";
		}

		/// <summary>
		/// Form layout change event handler. Called whenever user resizes main form.
		/// </summary>
		private void frm_main_Layout(object sender, System.Windows.Forms.LayoutEventArgs e)
		{
			tabControl1.Width = this.Width - (tabControl1.Left * 3);
			tabControl1.Height = this.Height - tabControl1.Top - statusBar1.Height - 40;

			rtb_exclusions.Width = tabControl1.Width - (rtb_exclusions.Left * 3);
			rtb_exclusions.Height = tabControl1.Height - rtb_exclusions.Top - 30;

			rtb_output.Width = tabControl1.Width - (rtb_exclusions.Left * 3);
			rtb_output.Height = tabControl1.Height - rtb_output.Top - 30;
		}


		/// <summary>
		/// Saves exclusions file.
		/// </summary>
		private void btn_saveExclusions_Click(object sender, System.EventArgs e)
		{
			rtb_exclusions.SaveFile(PARAMETERS.exclusionFile,RichTextBoxStreamType.PlainText);
		}

		/// <summary>
		/// Reloads exclusions file.
		/// </summary>
		private void btn_reloadExclusions_Click(object sender, System.EventArgs e)
		{
			try
			{
				rtb_exclusions.LoadFile(PARAMETERS.exclusionFile,RichTextBoxStreamType.PlainText);
			}
			catch
			{
				return;
			}
		}

		/// <summary>
		/// Saves a command (.CMD) file with the parameters set to the vales entered in the Options form.
		/// </summary>
		private void btn_saveCmdFile_Click(object sender, System.EventArgs e)
		{
			StreamWriter	OutputStream = null;
			string			cmdline;
		
			// create new cmd file
			if ( "" == PARAMETERS.cmdFile )
			{
				return;
			}
			try
			{
				OutputStream = File.CreateText(PARAMETERS.cmdFile);
			}
			catch
			{
				return;
			}

			// Build command line
			cmdline = "stringcheck2 ";

			// Set flags
			if (true == PARAMETERS.append)			cmdline += "-a ";
			if (true == PARAMETERS.autorun)			cmdline += "-r ";
			if (true == PARAMETERS.displayOutput)	cmdline += "-d ";

			// Set options
			cmdline += "-c\"" + PARAMETERS.cmdFile + "\"";
			cmdline += " -e\"" + PARAMETERS.exclusionFile + "\"";
			cmdline += " -f\"" + PARAMETERS.file + "\"";
			cmdline += " -p\"" + PARAMETERS.path + "\"";
			cmdline += " -w\"" + PARAMETERS.resultsFile + "\"";

			OutputStream.WriteLine("{0}", cmdline);
			OutputStream.Close();
		}

		/// <summary>
		/// Toggles the PARAMETERS.autorun flag.
		/// </summary>
		private void cb_autoRunFlag_CheckedChanged(object sender, System.EventArgs e)
		{
			PARAMETERS.autorun = cb_autoRunFlag.Checked;
		}

	} // Class
} // Namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\audiosrv\agfxsp.h ===
/* agfxsp.h
 * header for agfxs.cpp
 * Copyright (c) 2000-2001 Microsoft Corporation
 */


#define ZONETYPE_RENDER 1
#define ZONETYPE_CAPTURE 2
#define ZONETYPE_RENDERCAPTURE 3

typedef CList<class CGfxFactory*, class CGfxFactory*>   CListGfxFactories;
typedef CList<class CZoneFactory*, class CZoneFactory*> CListZoneFactories;
typedef CList<class CLmAutoLoad*, class CLmAutoLoad*>   CListLmAutoLoads;
typedef CList<class CCuUserLoad*, class CCuUserLoad*>   CListCuUserLoads;

//===   CUser   ===
class CUser {
public:
	CUser(void);
	~CUser(void);

	BOOL  operator==(const CUser &other);
	
	PSID  GetSid(void);
	LONG  Initialize(DWORD SessionId);
        LONG  RegOpen(IN REGSAM samDesired, OUT PHKEY phkResult);

private:
        void  CloseUserRegistry(void);
        BOOL  OpenUserRegistry(void);
        
        HANDLE           m_hUserToken;
	DWORD            m_SessionId;
	PSID             m_pSid;
	CRITICAL_SECTION m_csRegistry;
	BOOL             m_fcsRegistry;
	LONG             m_refRegistry;
	HKEY             m_hRegistry;
};

//===   CCuUserLoad   ===
class CCuUserLoad {
public:
	CCuUserLoad(CUser *pUser);
	~CCuUserLoad(void);

	LONG     AddToZoneGraph(CZoneFactory *pZoneFactory);
	LONG     CreateFromAutoLoad(ULONG CuAutoLoadId);
	LONG     CreateFromUser(PCTSTR GfxFactoryDi, PCTSTR ZoneFactoryDi, ULONG Type, ULONG Order);
	LONG     Erase(void);
	HANDLE   GetFilterHandle(void);
	PCTSTR   GetGfxFactoryDi(void);
	LONG     GetGfxFactoryClsid(CListGfxFactories &rlistGfxFactories, LPCLSID pClsid);
	DWORD    GetId(void);
	ULONG    GetOrder(void);
	ULONG    GetType(void);
	PCTSTR   GetZoneFactoryDi(void);
	LONG     Initialize(PCTSTR pstrCuAutoLoad);
	LONG     ModifyOrder(ULONG NewOrder);
        LONG     RegCreateFilterKey(IN PCTSTR SubKey, IN REGSAM samDesired, OUT PHKEY phkResult);
        LONG     RegOpenFilterKey(IN PCTSTR SubKey, IN REGSAM samDesired, OUT PHKEY phkResult);
        void     RemoveFromZoneGraph(void);
	LONG     Scan(CListZoneFactories &rlistZoneFactories, CListGfxFactories &rlistGfxFactories);
	LONG     Write(void);

	static void FillListFromReg(CUser *pUser, CListCuUserLoads& rlistCuUserLoads);
	static void ListRemoveGfxFactoryDi(IN CListCuUserLoads &rlistCuUserLoads, IN PCTSTR DeviceInterface);
        static void ListRemoveZoneFactoryDi(IN CListCuUserLoads &rlistCuUserLoads, IN PCTSTR DeviceInterface);
        static void ListRemoveZoneFactoryDiCapture(IN CListCuUserLoads &rlistCuUserLoads, IN PCTSTR DeviceInterface);
        static void ListRemoveZoneFactoryDiRender(IN CListCuUserLoads &rlistCuUserLoads, IN PCTSTR DeviceInterface);
	static void ScanList(CListCuUserLoads& rlistCuUsrLoads, CListZoneFactories& rlistZoneFactories, CListGfxFactories& rlistGfxFactories);

private:
        LONG     AddGfxToGraph(void);
        LONG     ChangeGfxOrderInGraph(IN ULONG NewOrder);
        LONG     RemoveFromGraph(void);
	BOOL     WinsConflictWith(CCuUserLoad *pOther);
        
	CUser   *m_User;
	
	ULONG    m_CuUserLoadId;
	ULONG    m_CuAutoLoadId;
	PTSTR    m_GfxFactoryDi;
	PTSTR    m_ZoneFactoryDi;
	ULONG    m_Type;
        ULONG    m_Order;
        

	HANDLE   m_FilterHandle;
	LONG     m_ErrorFilterCreate;

        CZoneFactory *m_pZoneFactory;
	POSITION      m_posZoneGfxList;
	
};

//===   CCuAutoLoad   ===
class CCuAutoLoad {
public:
	CCuAutoLoad(CUser *pUser);
	~CCuAutoLoad(void);

	LONG   Create(PCTSTR ZoneFactoryDi, ULONG LmAutoLoadId);
	LONG   Erase(void);
	PCTSTR GetGfxFactoryDi(void);
	ULONG  GetLmAutoLoadId(void);
	ULONG  GetType(void);
	PCTSTR GetZoneFactoryDi(void);
	LONG   Initialize(ULONG CuAutoLoadId);
	LONG   Write(void);

	static void ScanReg(IN CUser *pUser, IN PCTSTR ZoneFactoryDi, IN ULONG LmAutoLoadId, IN CListCuUserLoads &rlistCuUserLoads);

private:
	CUser *m_User;
	ULONG  m_CuAutoLoadId;
	ULONG  m_LmAutoLoadId;
	PTSTR  m_ZoneFactoryDi;
	PTSTR  m_GfxFactoryDi;
	ULONG  m_Type;
};

//===   CLmAutoLoad   ===
class CLmAutoLoad {
public:
	CLmAutoLoad(void);
	~CLmAutoLoad(void);

	LONG   Create(DWORD Id, PCTSTR GfxFactoryDi, PCTSTR HardwareId, PCTSTR ReferenceString, ULONG Type);
	LONG   Erase(void);
	PCTSTR GetGfxFactoryDi(void);
	ULONG  GetType(void);
	LONG   Initialize(DWORD Id);
	BOOL   IsCompatibleZoneFactory(CZoneFactory& rZoneFactory);
	LONG   Write(void);

	static CListLmAutoLoads* CreateListFromReg(void);
	static void DestroyList(CListLmAutoLoads* pListLmAutoLoads);
	static void ScanRegOnGfxFactory(CUser *pUser, CGfxFactory& rGfxFactory, CListZoneFactories &rlistZoneFactories, CListCuUserLoads &rlistCuUserLoads);
        static void ScanRegOnZoneFactory(CUser *pUser, CZoneFactory& rZoneFactory, CListGfxFactories &rlistGfxFactories, CListCuUserLoads &rlistCuUserLoads);

private:
	DWORD m_Id;
	PTSTR m_GfxFactoryDi;
	PTSTR m_HardwareId;
	PTSTR m_ReferenceString;
	ULONG m_Type;
};

//===   CInfAutoLoad   ===
class CInfAutoLoad {
public:
	CInfAutoLoad();
	~CInfAutoLoad();

	LONG Initialize(HKEY hkey, CGfxFactory *pGfxFactory);
	LONG Scan(void);
	
        static LONG ScanReg(HKEY hkey, CGfxFactory *pGfxFactory);

private:
	CGfxFactory *m_pGfxFactory;
	HKEY  m_hkey;
	DWORD m_Id;
	DWORD m_NewAutoLoad;

	PTSTR m_GfxFactoryDi;
	PTSTR m_HardwareId;
	PTSTR m_ReferenceString;
	ULONG m_Type;
};

//===   CGfxFactory   ===
class CGfxFactory {
public:
	CGfxFactory();
	~CGfxFactory();

	REFCLSID          GetClsid(void);
	PCTSTR            GetDeviceInterface(void);
        CListLmAutoLoads& GetListLmAutoLoads(void);
	LONG              Initialize(HKEY hkey, PCTSTR DeviceInterface);
	BOOL              IsCompatibleZoneFactory(IN ULONG Type, IN CZoneFactory& rZoneFactory);

        static void         ListRemoveGfxFactoryDi(IN CListGfxFactories &rlistGfxFactories, IN PCTSTR DeviceInterface);
        static CGfxFactory* ListSearchOnDi(IN CListGfxFactories& rlistGfxFactories, IN PCTSTR GfxFactoryDi);

private:
        CListLmAutoLoads *m_plistLmAutoLoads;
	PTSTR m_DeviceInterface;
	CLSID m_Clsid;
};

//===   CZoneFactory   ===
class CZoneFactory {
public:
	CZoneFactory(void);
	~CZoneFactory(void);

	LONG          AddType(IN ULONG Type);
	PCTSTR        GetDeviceInterface(void);
        PCTSTR        GetTargetHardwareId(void);
	BOOL          HasHardwareId(IN PCTSTR HardwareId);
	BOOL          HasReferenceString(IN PCTSTR ReferenceString);
	BOOL          HasCompatibleType(IN ULONG Type);
	LONG          Initialize(IN PCTSTR DeviceInterface, IN ULONG Type);
        LONG          RemoveType(IN ULONG Type);

        static void          ListRemoveZoneFactoryDi(IN CListZoneFactories &rlistZoneFactories, IN PCTSTR DeviceInterface);
        static void          ListRemoveZoneFactoryDiCapture(IN CListZoneFactories &rlistZoneFactories, IN PCTSTR DeviceInterface);
        static void          ListRemoveZoneFactoryDiRender(IN CListZoneFactories &rlistZoneFactories, IN PCTSTR DeviceInterface);
	static CZoneFactory* ListSearchOnDi(IN CListZoneFactories& rlistZoneFactories, IN PCTSTR ZoneFactoryDi);

	CListCuUserLoads m_listCaptureGfxs;
	CListCuUserLoads m_listRenderGfxs;
	
private:
	PTSTR            m_DeviceInterface;
	PTSTR            m_HardwareId;
	PTSTR            m_ReferenceString;
	ULONG            m_Type;
	
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\audiosrv\debug.h ===
/* debug.h
 * Copyright (c) 2000-2001 Microsoft Corporation
 */
 
//
// ISSUE-2000/09/29-FrankYe Try to use standard ntrtl debug
//    stuff.  Check winweb/wem for guidance perhaps.
//

#ifdef ASSERT
#undef ASSERT
#endif

#ifdef DBG
#define ASSERT( exp ) \
if (!(exp)) { \
    char msg[200]; \
    wsprintfA(msg, "Assert failure %s %d %s\n", __FILE__, __LINE__, #exp); \
    OutputDebugStringA(msg); \
    DebugBreak(); \
}
static int dprintf(PCTSTR pszFormat, ...)
{
    PTSTR pstrTemp;
    va_list marker;
    int result = 0;
    
    pstrTemp = (PTSTR)HeapAlloc(GetProcessHeap(), 0, 500 * sizeof(TCHAR));
    if (pstrTemp)
    {
        va_start(marker, pszFormat);
        result = wvsprintf(pstrTemp, pszFormat, marker);
        OutputDebugString(TEXT("AudioSrv: "));
        OutputDebugString(pstrTemp);
        HeapFree(GetProcessHeap(), 0, pstrTemp);
    }
    return result;
}


#else
#define ASSERT
#define dprintf
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\audiosrv\agfxs.cpp ===
/* agfxs.cpp
 * Server side code for agfx.
 * Created by FrankYe on 7/3/2000
 * Copyright (c) 2000-2001 Microsoft Corporation
 */
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <windows.h>
#include <sddl.h>
#include <winsta.h>
#include <wtsapi32.h>
#include <syslib.h>
#include <mmsystem.h>
#include <mmsysp.h>
#include <regstr.h>
#include <objbase.h>
#include <setupapi.h>
#include <wdmguid.h>
#include <ks.h>
#include <ksmedia.h>
}


#include "debug.h"
#include "list.h"
#include "service.h"
#include "audiosrv.h"
#include "reg.h"
#include "sad.h"
#include "ksi.h"
#include "agfxs.h"
#include "agfxsp.h"

/*===========================================================================//
  ===   ISSUE-2000/09/24-FrankYe TODO   Notes    ===
-
- Figure out correct way to pass handle through RPC to s_gfxOpenGfx
- Does RPC server unregister its endpoint when shutting down?
- Should turn on strick type checking
- Ensure there are no Order duplicates
- Handle NULL global lists.  Perhaps put lists in a context
- Need to listen to PnP queries and unload GFXs if PnP wishes
    to remove them.  Repro problem by Uninstalling a GFX via
    Device Manager.  Note it asks for reboot.
- Create client contexts at least to ensure input GFX IDs are
   valid for the current user.  Otherwise one user can manipulate
   the gfx settings of another user via gfxOpenGfx.
- Be consistent in whether s_* functions return LONG or RPC_STATUS
- Modify to handle Render and Capture device specs
- When loading all CuAutoLoad and CuUserLoad, confirm active
- Move all string constants to header
- Should AutoLoad HardwareId be MULTI_SZ

//===========================================================================*/


//=============================================================================
//===   Constants   ===
//=============================================================================
#define REGSTR_PATH_GFX REGSTR_PATH_MULTIMEDIA TEXT("\\Audio\\Gfx")

#define REGSTR_PATH_GFX_AUTOLOAD TEXT("AutoLoad")
#define REGSTR_PATH_GFX_USERLOAD TEXT("UserLoad")

#define REGSTR_PATH_DI_GFX TEXT("Gfx")

#define REGSTR_PATH_GFXAUTOLOAD                  REGSTR_PATH_GFX TEXT("\\") REGSTR_PATH_GFX_AUTOLOAD
#define REGSTR_PATH_GFXUSERLOAD                  REGSTR_PATH_GFX TEXT("\\") REGSTR_PATH_GFX_USERLOAD
#define REGSTR_PATH_GFXDI_USERINTERFACECLSID     TEXT("UserInterface\\CLSID")
#define REGSTR_PATH_GFXUSERLOADID_FILTERSETTINGS TEXT("FilterSettings")

#define REGSTR_VAL_GFX_IDGEN  TEXT("IdGeneration")
#define REGSTR_VAL_GFX_ZONEDI TEXT("ZoneDi")
#define REGSTR_VAL_GFX_GFXDI  TEXT("GfxDi")
#define REGSTR_VAL_GFX_TYPE   TEXT("Type")
#define REGSTR_VAL_GFX_ORDER  TEXT("Order")

#define REGSTR_VAL_GFX_ID           TEXT("Id")
#define REGSTR_VAL_GFX_CUAUTOLOADID TEXT("CuAutoLoadId")
#define REGSTR_VAL_GFX_LMAUTOLOADID TEXT("LmAutoLoadId")

#define REGSTR_VAL_GFX_HARDWAREID      TEXT("HardwareId")
#define REGSTR_VAL_GFX_REFERENCESTRING TEXT("ReferenceString")
#define REGSTR_VAL_GFX_NEWAUTOLOAD     TEXT("NewAutoLoad")





//=============================================================================
//===   Global data   ===
//=============================================================================

//
// resource object protecting GFX support initialization and termination. This
// is required since initialization/termination might happen either on RPC calls
// to s_gfxLogon/s_gfxLogoff or on SERVICE_CONTROL_STOP event to the service
// control handler.  Also, other RPC interface functions might be executing
// on one thread while s_gfxLogon, s_gfxLogoff, or SERVICE_CONTROL_STOP happens
// on another thread.
//
RTL_RESOURCE GfxResource;
BOOL gfGfxResource = FALSE;

//
// Are GFX functions initialized and functional
//
BOOL gfGfxInitialized = FALSE;

//
// The current console user
//
CUser* gpConsoleUser = NULL;

//
// The process global lists below are locked/unlocked together using
// the functions LockGlobalLists and UnlockGlobalLists.  We don't
// attempt to lock at finer granulatiry
//
CListGfxFactories  *gplistGfxFactories = NULL;
CListZoneFactories *gplistZoneFactories = NULL;
CListCuUserLoads   *gplistCuUserLoads = NULL;
                                                             
//
// The sysaudio data below is locked by a critical section accessed
// by calling LockSysaudio and UnlockSysaudio
//
PTSTR gpstrSysaudioDeviceInterface = NULL;
HANDLE ghSysaudio = INVALID_HANDLE_VALUE;
LONG gfCsSysaudio = FALSE;
CRITICAL_SECTION gcsSysaudio;

//
// If both the global lists lock and the sysaudio lock are required
// at the same time, then the global lists lock must be acquired first!
//

//=============================================================================
//===   debug helpers   ===
//=============================================================================
#ifdef DBG
#endif

//=============================================================================
//===   Heap helpers   ===
//=============================================================================
static BOOL HeapFreeIfNotNull(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
{
    return lpMem ? HeapFree(hHeap, dwFlags, lpMem) : TRUE;
}
void* __cdecl operator new(size_t cbBuffer)
{
    ASSERT(cbBuffer);
    return HeapAlloc(hHeap, 0, cbBuffer);
}

void __cdecl operator delete(void *p)
{
    ASSERT(p);
    HeapFree(hHeap, 0, p);
}

//=============================================================================
//===   String helpers   ===
//=============================================================================
int lstrcmpiMulti(PCTSTR pstrMulti, PCTSTR pstrKey)
{
    int iresult;
    do {
	iresult = lstrcmpi(pstrMulti, pstrKey);
	pstrMulti += lstrlen(pstrMulti)+1;
    } while (iresult && lstrlen(pstrMulti));
    return iresult;
}

PTSTR lstrDuplicate(PCTSTR pstr)
{
    PTSTR pstrDuplicate = (PTSTR)HeapAlloc(hHeap, 0, (lstrlen(pstr)+1)*sizeof(TCHAR));
    if (pstrDuplicate) lstrcpy(pstrDuplicate, pstr);
    return pstrDuplicate;
}

//=============================================================================
//===   Rtl resource helpers   ===
//=============================================================================

/*-----------------------------------------------------------------------------

    RtlInterlockedTestAcquireResourceShared

    Given a resource, and a BOOLEAN flag protected by the resource, this
    function acquires the resource shared and tests the flag.  If the flag is
    true, this function returns TREU with the resource acquired shared.  If the
    flag is false, this function releases the resource and returns FALSE.
    
-----------------------------------------------------------------------------*/
BOOL RtlInterlockedTestAcquireResourceShared(
    PRTL_RESOURCE Resource,
    PBOOL ResourceFlag
)
{
    RtlAcquireResourceShared(Resource, TRUE);
    if (*ResourceFlag) return TRUE;
    RtlReleaseResource(Resource);
    return FALSE;
}

//=============================================================================
//
//      Security helpers   
//
//  The semantics are similar to other security-related Win32 APIs.  That is
//  the return value is a BOOL where TRUE means success, FALSE means failure,
//  and GetLastError will return an error code after a failure.
//
//=============================================================================

/*-----------------------------------------------------------------------------

    GetCurrentUserTokenW

    Private function implemented in irnotif.lib.  Retrieves the token of the
    user logged onto the specified winstation.  I've been advised that the
    caller of this function is responsible for closing the returned handle.

    Returns NULL on failure.
    
-----------------------------------------------------------------------------*/
EXTERN_C HANDLE GetCurrentUserTokenW(IN WCHAR Winsta[], IN DWORD DesiredAccess);

/*-----------------------------------------------------------------------------

    CreateStringSidFromSid

    Same function as the Win32 API ConvertSidToStringSid but ensures the
    resulting string is allocated on the heap specified by the global
    variable hHeap.

-----------------------------------------------------------------------------*/
BOOL CreateStringSidFromSid(IN PSID pSid, OUT PTSTR *ppStringSid)
{
    PTSTR StringSid;
    LONG  LastError;

    ASSERT(pSid);
    
    if (ConvertSidToStringSid(pSid, &StringSid))
    {
	PTSTR outStringSid;
	    	
	// dprintf(TEXT("CreateStringSidFromSid: StringSid=%s\n"), StringSid);
	    	
	outStringSid = lstrDuplicate(StringSid);

	if (outStringSid) {
	    *ppStringSid = outStringSid;
	    LastError = NO_ERROR;
	} else {
	    LastError = ERROR_OUTOFMEMORY;
	}
	    	
        LocalFree(StringSid);
    } else {
	LastError = GetLastError();
	dprintf(TEXT("CreateStringSidFromSid: ConvertSidToStringSid LastError=%d\n"), GetLastError());
    }

    SetLastError(LastError);
    return (NO_ERROR == LastError);
}

/*-----------------------------------------------------------------------------

    CreateTokenSid

    Given a token handle, create a SID for the token user.
    
    The SID is allocated on the heap specified by the global variable hHeap.
    The caller is responsible for freeing the storage for ths SID.  The
    function returns TRUE if successful and FALSE otherwise.  LastError is
    set.
    
-----------------------------------------------------------------------------*/
BOOL CreateTokenSid(HANDLE TokenHandle, OUT PSID *ppSid)
{
    	DWORD cbTokenUserInformation;
    	LONG  LastError;

    	LastError = NO_ERROR;
    	
    	if (!GetTokenInformation(TokenHandle, TokenUser, NULL, 0, &cbTokenUserInformation)) LastError = GetLastError();
    	
    	if ((NO_ERROR == LastError) || (ERROR_INSUFFICIENT_BUFFER == LastError))
    	{
	    PTOKEN_USER TokenUserInformation;

            ASSERT(cbTokenUserInformation > 0);

	    TokenUserInformation = (PTOKEN_USER)HeapAlloc(hHeap, 0, cbTokenUserInformation);
	    if (TokenUserInformation)
	    {
    	        if (GetTokenInformation(TokenHandle, TokenUser, TokenUserInformation, cbTokenUserInformation, &cbTokenUserInformation))
    	        {
    	            DWORD cbSid = GetLengthSid(TokenUserInformation->User.Sid);
    	            PSID pSid = HeapAlloc(hHeap, 0, cbSid);
    	            if (pSid)
    	            {
    	            	if (CopySid(cbSid, pSid, TokenUserInformation->User.Sid))
    	            	{
    	            	    *ppSid = pSid;
    	            	    LastError = NO_ERROR;
    	            	} else {
    	            	    LastError = GetLastError();
                            dprintf(TEXT("CreateTokenSid: CopySid failed, LastError=%d\n"), LastError);
    	            	}
    	            } else {
    	                LastError = ERROR_OUTOFMEMORY;
    	            }
	    	} else {
	    	    LastError = GetLastError();
	    	    dprintf(TEXT("CreateTokenSid: GetTokenInformation (second) LastError=%d\n"), LastError);
	    	}
	    	HeapFree(hHeap, 0, TokenUserInformation);
	    } else {
	        LastError = ERROR_OUTOFMEMORY;
	    }
    	} else {
    	    LastError = GetLastError();
    	    dprintf(TEXT("CreateTokenSid: GetTokenInformation (first) LastError=%d\n"), LastError);
    	}

    	SetLastError(LastError);
    	return (NO_ERROR == LastError);
}

/*-----------------------------------------------------------------------------

    CreateSessionUserSid

    Given a session ID, create a SID for the session user.
    
    The SID is allocated on the heap specified by the global variable hHeap.
    The caller is responsible for freeing the storage for ths SID.  The
    function returns TRUE if successful and FALSE otherwise.  LastError is
    set.
    
-----------------------------------------------------------------------------*/
BOOL CreateSessionUserSid(IN DWORD dwSessionId, OUT PSID *ppSid)
{
    HANDLE hToken;
    LONG error;

    if (WTSQueryUserToken(dwSessionId, &hToken))
    {
        PSID pSid;
        if (CreateTokenSid(hToken, &pSid))
        {
            *ppSid = pSid;
       	    error = NO_ERROR;
        } else {
            error = GetLastError();
            dprintf(TEXT("CreateSessionUserSid: CreateTokenSid failed, LastError=%d\n"), error);
        }
        CloseHandle(hToken);
    } else {
        error = GetLastError();
        dprintf(TEXT("CreateSessionUserSid: WTSQueryUserToken failed, LastError=%d\n"), error);
    }

    SetLastError(error);
    return (NO_ERROR == error);
}

/*-----------------------------------------------------------------------------

    CreateThreadImpersonationSid

    Given a thread handle, create a SID for the user that the thread is
    impersonating.

    The SID is allocated on the heap specified by the global variable hHeap.
    The caller is responsible for freeing the storage for ths SID.  The
    function returns TRUE if successful and FALSE otherwise.  LastError is
    set.
    
-----------------------------------------------------------------------------*/
BOOL CreateThreadImpersonationSid(IN HANDLE ThreadHandle, OUT PSID *ppSid)
{
    HANDLE TokenHandle;
    LONG LastError;

    if (OpenThreadToken(ThreadHandle, TOKEN_QUERY, FALSE, &TokenHandle))
    {
    	if (CreateTokenSid(TokenHandle, ppSid))
    	{
    	    LastError = NO_ERROR;
    	} else {
    	    LastError = GetLastError();
    	    dprintf(TEXT("CreateThreadImpersonationSid: CreateTokenSid LastError=%d\n"), LastError);
    	}
    	CloseHandle(TokenHandle);
    } else {
        LastError = GetLastError();
        dprintf(TEXT("OpenThreadToken LastError=%d\n"), LastError);
    }

    SetLastError(LastError);
    return (NO_ERROR == LastError);
}

/*--------------------------------------------------------------------------

   IsUserProfileLoaded

   Silly way to determine whether the user's profile is loaded
  
   Arguments:
      IN HANDLE hUserToken : Token for user whose profile to check
  
   Return value:
      BOOL : Indicates whether user profile is loaded and available
        TRUE : User profile is available
        FALSE : User profie is not available or an error was encountered.
          Call GetLastError to get an error code describing what failure
          was encountered.
  
   Comments:
  
-------------------------------------------------------------------------*/
BOOL IsUserProfileLoaded(HANDLE hUserToken)
{
    PSID pSid;
    BOOL success;
    LONG error = NO_ERROR;

    success = CreateTokenSid(hUserToken, &pSid);
    if (success)
    {
    	PTSTR StringSid;
    	success = CreateStringSidFromSid(pSid, &StringSid);
    	if (success)
    	{
    	    HKEY hkUser;
    	    error = RegOpenKeyEx(HKEY_USERS, StringSid, 0, KEY_QUERY_VALUE, &hkUser);
    	    success = (NO_ERROR == error);
    	    if (success) RegCloseKey(hkUser);
    	    HeapFree(hHeap, 0, StringSid);
    	}
    	else
    	{
    	    error = GetLastError();
    	}
    	HeapFree(hHeap, 0, pSid);
    }
    else
    {
        error = GetLastError();
    }

    // if (error) dprintf(TEXT("IsUserProfileLoaded : warning: returning error %d\n"), error);

    ASSERT(success == (NO_ERROR == error));
    SetLastError(error);
    return success;
    
}

//=============================================================================
//===   Rpc helpers   ===
//=============================================================================

/*-----------------------------------------------------------------------------

    RpcClientHasUserSid

    Checks whether the current thread's RPC client's SID matches the given SID.
    It does this by impersonating the client using RpcImpersonateClient,
    calling the helper function CreateThreadImpersonationSid, and then
    RpcRevertToSelf.
    
    The function returns TRUE the SIDs are equal, or FALSE if there is an error
    or of the SIDs are not equal.  LastError is set.
    
-----------------------------------------------------------------------------*/
BOOL RpcClientHasUserSid(PSID Sid)
{
    LONG LastError;
    BOOL result = FALSE;

    LastError = RpcImpersonateClient(NULL);
    if (NO_ERROR == LastError)
    {
    	PSID ClientSid;
    	if (CreateThreadImpersonationSid(GetCurrentThread(), &ClientSid))
    	{
    	    LastError = NO_ERROR;
    	    if (EqualSid(ClientSid, Sid)) result = TRUE;
    	    HeapFree(hHeap, 0, ClientSid);
    	} else {
    	    LastError = GetLastError();
    	    dprintf(TEXT("RpcClientHasUserSid: CreateThreadImpersonationSid failed, LastError=%d\n"), LastError);
    	}
    	RpcRevertToSelf();
    }

    // We should never match the SID if there was a failure.
    ASSERT( ! ((TRUE == result) && (NO_ERROR != LastError))  );
    
    SetLastError(LastError);
    return result;
}

//=============================================================================
//===   SetupDi helpers   ===
//=============================================================================
BOOL SetupDiCreateDeviceInterfaceDetail(HDEVINFO hdi, PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData, PSP_DEVICE_INTERFACE_DETAIL_DATA *ppDeviceInterfaceDetailData, PSP_DEVINFO_DATA pDeviceInfoData)
{
    DWORD cbDeviceInterfaceDetailData;
    BOOL fresult;

    fresult = SetupDiGetDeviceInterfaceDetail(hdi, DeviceInterfaceData, NULL, 0, &cbDeviceInterfaceDetailData, NULL);

    if (fresult || ERROR_INSUFFICIENT_BUFFER == GetLastError())
    {
	PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetailData;

	DeviceInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)HeapAlloc(hHeap, 0, cbDeviceInterfaceDetailData);
	if (DeviceInterfaceDetailData) {
	    SP_DEVINFO_DATA DeviceInfoData;

	    DeviceInterfaceDetailData->cbSize = sizeof(*DeviceInterfaceDetailData);
	    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
	    fresult = SetupDiGetDeviceInterfaceDetail(hdi, DeviceInterfaceData, DeviceInterfaceDetailData, cbDeviceInterfaceDetailData, NULL, &DeviceInfoData);

	    if (fresult) {
		if (ppDeviceInterfaceDetailData) *ppDeviceInterfaceDetailData = DeviceInterfaceDetailData;
		if (pDeviceInfoData) *pDeviceInfoData = DeviceInfoData;
	    }
	    
	    if (!fresult || !ppDeviceInterfaceDetailData) {
		DWORD dw = GetLastError();
		HeapFree(hHeap, 0, DeviceInterfaceDetailData);
		SetLastError(dw);
	    }
	}
    } else {
	DWORD dw = GetLastError();
    }

    return fresult;
}

BOOL SetupDiGetDeviceInterfaceHardwareId(HDEVINFO hdi, PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData, PTSTR *ppstrHardwareId)
{
    SP_DEVINFO_DATA DeviceInfoData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA pDeviceInterfaceDetailData;
    BOOL fresult;
    
    DeviceInfoData.cbSize = sizeof(DeviceInfoData);

    fresult = SetupDiCreateDeviceInterfaceDetail(hdi, DeviceInterfaceData, &pDeviceInterfaceDetailData, &DeviceInfoData);
    if (fresult) {
        DWORD cbHardwareId;
        
        fresult = SetupDiGetDeviceRegistryProperty(hdi, &DeviceInfoData,
            SPDRP_HARDWAREID, NULL, NULL, 0, &cbHardwareId);
        
        if (fresult || ERROR_INSUFFICIENT_BUFFER == GetLastError()) {
            PTSTR HardwareId;
            
            HardwareId = (PTSTR)HeapAlloc(hHeap, 0, cbHardwareId);
            fresult = SetupDiGetDeviceRegistryProperty(hdi, &DeviceInfoData,
                SPDRP_HARDWAREID, NULL, (PBYTE)HardwareId, cbHardwareId, NULL);
                
            if (fresult) {
                *ppstrHardwareId = HardwareId;
            } else {
                HeapFree(hHeap, 0, HardwareId);
            }
        }
	HeapFree(hHeap, 0, pDeviceInterfaceDetailData);
    }
    
    return fresult;
}

BOOL SetupDiGetDeviceInterfaceBusId(HDEVINFO hdi, PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData, LPGUID pBusTypeGuid)
{
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD dwNeeded;
    BOOL fresult;

    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
    fresult = SetupDiGetDeviceInterfaceDetail(hdi, DeviceInterfaceData, NULL, 0, &dwNeeded, &DeviceInfoData);
    if (fresult || ERROR_INSUFFICIENT_BUFFER == GetLastError()) {
        GUID BusTypeGuid;
        ULONG cbBusTypeGuid;

        cbBusTypeGuid = sizeof(BusTypeGuid);
        fresult = SetupDiGetDeviceRegistryProperty(hdi, &DeviceInfoData, SPDRP_BUSTYPEGUID, NULL, (PBYTE)&BusTypeGuid, cbBusTypeGuid, &cbBusTypeGuid);
        if (fresult) *pBusTypeGuid = BusTypeGuid;
    }

    return fresult;
}

BOOL SetupDiCreateAliasDeviceInterfaceFromDeviceInterface(
    IN PCTSTR pDeviceInterface,
    IN LPCGUID  pAliasInterfaceClassGuid,
    OUT PTSTR *ppAliasDeviceInterface
)
{
    HDEVINFO hdi;
    PSP_DEVICE_INTERFACE_DETAIL_DATA pAudioDeviceInterfaceDetail;
    PTSTR pAliasDeviceInterface;
    BOOL fresult;
    LONG error;
    
    hdi = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (INVALID_HANDLE_VALUE != hdi)
    {
        SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
        
        DeviceInterfaceData.cbSize = sizeof(DeviceInterfaceData);
        fresult = SetupDiOpenDeviceInterface(hdi, pDeviceInterface, 0, &DeviceInterfaceData);
        if (fresult)
        {
            SP_DEVICE_INTERFACE_DATA AliasDeviceInterfaceData;
            PSP_DEVICE_INTERFACE_DETAIL_DATA pAliasDeviceInterfaceDetail;
            
            AliasDeviceInterfaceData.cbSize = sizeof(AliasDeviceInterfaceData);
            fresult = SetupDiGetDeviceInterfaceAlias(hdi, &DeviceInterfaceData, pAliasInterfaceClassGuid, &AliasDeviceInterfaceData);
            if (fresult)
            {
            	fresult = SetupDiCreateDeviceInterfaceDetail(hdi, &AliasDeviceInterfaceData, &pAliasDeviceInterfaceDetail, NULL);
            	if (fresult)
            	{
            	    pAliasDeviceInterface = lstrDuplicate(pAliasDeviceInterfaceDetail->DevicePath);
            	    error = pAliasDeviceInterface ? NO_ERROR : ERROR_OUTOFMEMORY;
            	    HeapFree(hHeap, 0, pAliasDeviceInterfaceDetail);
            	} else {
            	    error = GetLastError();
            	}
            } else {
                error = GetLastError();
            }
        } else {
            error = GetLastError();
        }
        SetupDiDestroyDeviceInfoList(hdi);
    } else {
        error = GetLastError();
    }

    if (NO_ERROR == error)
    {
    	*ppAliasDeviceInterface = pAliasDeviceInterface;
    }

    return (NO_ERROR == error);
}

//=============================================================================
//
//      Reg helpers
//
//  The semantics of these functions are designed to be as similar to the
//  Win32 API registry functions as reasonably possible.
//
//=============================================================================

LONG RegPrepareEnum(HKEY hkey, PDWORD pcSubkeys, PTSTR *ppstrSubkeyNameBuffer, PDWORD pcchSubkeyNameBuffer)
{
    DWORD cSubkeys;
    DWORD cchMaxSubkeyName;
    LONG lresult;

    lresult = RegQueryInfoKey(hkey, NULL, NULL, NULL, &cSubkeys, &cchMaxSubkeyName, NULL, NULL, NULL, NULL, NULL, NULL);
    if (NO_ERROR == lresult) {
        PTSTR SubkeyName;
        SubkeyName = (PTSTR)HeapAlloc(hHeap, 0, (cchMaxSubkeyName+1) * sizeof(TCHAR));
        if (SubkeyName) {
		*pcSubkeys = cSubkeys;
		*ppstrSubkeyNameBuffer = SubkeyName;
		*pcchSubkeyNameBuffer = cchMaxSubkeyName+1;
	} else {
	    lresult = ERROR_OUTOFMEMORY;
	}
    }
    return lresult;
}

LONG RegEnumOpenKey(HKEY hkey, DWORD dwIndex, PTSTR SubkeyName, DWORD cchSubkeyName, REGSAM samDesired, PHKEY phkeyResult)
{
    LONG lresult;

    lresult = RegEnumKeyEx(hkey, dwIndex, SubkeyName, &cchSubkeyName, NULL, NULL, NULL, NULL);
    if (NO_ERROR == lresult) {
	HKEY hkeyResult;
	lresult = RegOpenKeyEx(hkey, SubkeyName, 0, samDesired, &hkeyResult);
	if (NO_ERROR == lresult) *phkeyResult = hkeyResult;
    }
    return lresult;
}

LONG RegDeleteKeyRecursive(HKEY hkey, PCTSTR pstrSubkey)
{
    HKEY hkeySub;
    LONG lresult;

    lresult = RegOpenKeyEx(hkey, pstrSubkey, 0, KEY_READ | KEY_WRITE, &hkeySub);
    if (NO_ERROR == lresult)
    {
	DWORD cSubkeys;
	DWORD cchSubkeyNameBuffer;
	PTSTR pstrSubkeyNameBuffer;

	lresult = RegPrepareEnum(hkeySub, &cSubkeys, &pstrSubkeyNameBuffer, &cchSubkeyNameBuffer);
	if (NO_ERROR == lresult)
	{
	    DWORD iSubkey;

	    for (iSubkey = 0; iSubkey < cSubkeys; iSubkey++)
	    {
		DWORD cchSubkeyNameBufferT;

		cchSubkeyNameBufferT = cchSubkeyNameBuffer;
		lresult = RegEnumKeyEx(hkeySub, iSubkey, pstrSubkeyNameBuffer, &cchSubkeyNameBufferT, NULL, NULL, NULL, NULL);
		if (NO_ERROR != lresult) break;

		lresult = RegDeleteKeyRecursive(hkeySub, pstrSubkeyNameBuffer);
		if (NO_ERROR != lresult) break;
	    }
	    HeapFree(hHeap, 0, pstrSubkeyNameBuffer);
	}
	RegCloseKey(hkeySub);
    }

    if (NO_ERROR == lresult) lresult = RegDeleteKey(hkey, pstrSubkey);

    return lresult;
}

//=============================================================================
//===   Utilities   ===
//=============================================================================
LONG XxNextId(HKEY hkey, PDWORD pId)
{
    HKEY hkeyGfx;
    DWORD Id;
    LONG lresult;

    lresult = RegCreateKeyEx(hkey, REGSTR_PATH_GFX, 0, NULL, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hkeyGfx, NULL);
    if (NO_ERROR == lresult)
    {
	lresult = RegQueryDwordValue(hkeyGfx, REGSTR_VAL_GFX_IDGEN, &Id);
	if (ERROR_FILE_NOT_FOUND == lresult) {
	    Id = 0;
	    lresult = NO_ERROR;
	}
	if (NO_ERROR == lresult) {
	    Id++;
	    lresult = RegSetDwordValue(hkeyGfx, REGSTR_VAL_GFX_IDGEN, Id);
	}
	RegCloseKey(hkeyGfx);
    }

    if (NO_ERROR == lresult) *pId = Id;
    return lresult;
}

LONG LmNextId(PDWORD pId)
{
    return XxNextId(HKEY_LOCAL_MACHINE, pId);
}

LONG CuNextId(CUser *pUser, PDWORD pId)
{
    HKEY hkeyCu;
    LONG lresult;
    lresult = pUser->RegOpen(KEY_READ, &hkeyCu);
    if (!lresult)
    {
	lresult = XxNextId(hkeyCu, pId);
	RegCloseKey(hkeyCu);
    }
    return lresult;
}

BOOL ZoneTypeHasRender(IN ULONG Type)
{
   if (ZONETYPE_RENDERCAPTURE == Type) return TRUE;
   if (ZONETYPE_RENDER == Type) return TRUE;
   return FALSE;
}

BOOL ZoneTypeHasCapture(IN ULONG Type)
{
   if (ZONETYPE_RENDERCAPTURE == Type) return TRUE;
   if (ZONETYPE_CAPTURE == Type) return TRUE;
   return FALSE;
}
	
void LockGlobalLists(void)
{
    ASSERT(gplistZoneFactories);
    ASSERT(gplistGfxFactories);
    ASSERT(gplistCuUserLoads);

    gplistZoneFactories->Lock();
    gplistGfxFactories->Lock();
    gplistCuUserLoads->Lock();

    return;
}

void UnlockGlobalLists(void)
{
    ASSERT(gplistZoneFactories);
    ASSERT(gplistGfxFactories);
    ASSERT(gplistCuUserLoads);

    gplistCuUserLoads->Unlock();
    gplistGfxFactories->Unlock();
    gplistZoneFactories->Unlock();
    
    return;
}

void LockSysaudio(void)
{
    ASSERT(gfCsSysaudio);
    EnterCriticalSection(&gcsSysaudio);
    return;
}

void UnlockSysaudio(void)
{
    ASSERT(gfCsSysaudio);
    LeaveCriticalSection(&gcsSysaudio);
    return;
}

//=============================================================================
//===   CuUserLoad   ===
//=============================================================================
CCuUserLoad::CCuUserLoad(CUser *pUser)
{
    ASSERT(pUser);
    
    m_User = pUser;
    m_ZoneFactoryDi = NULL;
    m_GfxFactoryDi = NULL;
    m_FilterHandle = INVALID_HANDLE_VALUE;
    m_ErrorFilterCreate = NO_ERROR;
    m_pZoneFactory = NULL;
    m_posZoneGfxList = NULL;
}

CCuUserLoad::~CCuUserLoad(void)
{
    RemoveFromZoneGraph();
    HeapFreeIfNotNull(hHeap, 0, m_ZoneFactoryDi);
    HeapFreeIfNotNull(hHeap, 0, m_GfxFactoryDi);
}

/*--------------------------------------------------------------------------

   CCuUserLoad::AddGfxToGraph

   Adds an instantiated gfx to the sysaudio graph for a zone factory.
  
   Arguments:
      IN CCuUserLoad *pCuUserLoad : The gfx to add to the graph

      OUT POSITION *pZoneGfxListPosition : The resulting list position
          in the zone factory's list of gfxs.
  
   Return value:
      LONG : error code defined in winerror.h
  	ERROR_OUTOFMEMORY :
  
   Comments:
     The caller should have already instantiated the gfx.

     This function walks the zone factory's gfx list (either render or
     capture list depending on the type of gfx being added) to find an
     insertion point.  The gfx list is sorted by gfx order.  Finally, the
     resulting list position is returned to the caller so that it can be
     passed back to RemoveFromGraph or ChangeGfxOrderInGraph later.
  
-------------------------------------------------------------------------*/
LONG CCuUserLoad::AddGfxToGraph(void)
{
    CListCuUserLoads *plistGfxs;
    POSITION posNextGfx;
    CCuUserLoad *pNextGfx;
    LONG error;

    // dprintf(TEXT("CCuUserLoad::AddGfxToGraph\n"));

    ASSERT(INVALID_HANDLE_VALUE != m_FilterHandle);
    ASSERT(NULL == m_posZoneGfxList);
    
    error = NO_ERROR;

    if (GFXTYPE_CAPTURE == m_Type) plistGfxs = &m_pZoneFactory->m_listCaptureGfxs;
    else if (GFXTYPE_RENDER == m_Type) plistGfxs = &m_pZoneFactory->m_listRenderGfxs;
    else 
    {
        ASSERT(FALSE);
        return (ERROR_INVALID_DATA);
    }

    //
    // Find possible insertion point for the new gfx by scanning list up to
    // a point where all previous gfxs have lower order values.
    //
    for (posNextGfx = plistGfxs->GetHeadPosition(); posNextGfx; plistGfxs->GetNext(posNextGfx))
    {
        pNextGfx = plistGfxs->GetAt(posNextGfx);
        if (m_Order <= pNextGfx->m_Order) break;
    }

    //
    // If there is a conflict with an existing gfx at the insertion point
    // then either shift the conflicting gfx to a higher order or bump the
    // insertion point and the new gfx's order and try again, depending
    // on whether this gfx "wins the conflict" with the conflicting gfx.
    //
    while (!error && posNextGfx && (m_Order == pNextGfx->m_Order))
    {
        if (WinsConflictWith(pNextGfx))
        {
            error = pNextGfx->ModifyOrder(pNextGfx->m_Order + 1);
        }
        else
        {
            plistGfxs->GetNext(posNextGfx);
            if (posNextGfx) pNextGfx = plistGfxs->GetAt(posNextGfx);
            m_Order++;
        }
    }

    //
    // We've finally determined the proper insertion point and resolved any
    // conflicts.  Insert the gfx into the gfx list, add the gfx to the
    // sysaudio graph, and finally persist the gfx again if the final order
    // is different than original.
    //
    if (!error)
    {
        POSITION posGfx;
        
        posGfx = plistGfxs->InsertBefore(posNextGfx, this);
    	if (!posGfx) error = ERROR_OUTOFMEMORY;
    	
    	if (!error)
    	{
    	    // ISSUE-2000/09/21-FrankYe Need to pass friendly name
            error = SadAddGfxToZoneGraph(ghSysaudio, m_FilterHandle, TEXT("ISSUE-2000//09//21-FrankYe Need to pass friendly name"), m_ZoneFactoryDi, m_Type, m_Order);
            if (error) dprintf(TEXT("CCuUserLoad::AddGfxToZoneGraph : error: SadAddGfxToZoneGraph returned %d\n"), error);
    	    if (!error) m_posZoneGfxList = posGfx;
    	    else plistGfxs->RemoveAt(posGfx);
    	}
    }

    return error;
}

//--------------------------------------------------------------------------;
//
// CCuUserLoad::AddToZoneGraph
//
// Instantiates and adds a GFX filter to a zone graph.
//
// Arguments:
//    CZoneFactory *pZoneFactory : Identifies the zone to which the GFX
// is added.
//
// Return value:
//    LONG : error code defined in winerror.h
//
// Comments:
//    Instantiates the filter.
//    Advises filter of target device id.
//    Unserializes persistent properties to filter.
//    Calls AddToGraph on the ZoneFactory.
//
//--------------------------------------------------------------------------;
LONG CCuUserLoad::AddToZoneGraph(CZoneFactory *pZoneFactory)
{
    LONG error;

    dprintf(TEXT("CCuUserLoad::AddToZoneGraph : note: instantiating %s Gfx[%s] in Zone[%s]\n"), (GFXTYPE_RENDER == m_Type) ? TEXT("render") : TEXT("capture"), m_GfxFactoryDi, m_ZoneFactoryDi);

    ASSERT(NULL == m_pZoneFactory);
    ASSERT(NULL == m_posZoneGfxList);    
    ASSERT(INVALID_HANDLE_VALUE == m_FilterHandle);

    //
    // Instantiate the GFX filter
    //
    m_FilterHandle = CreateFile(m_GfxFactoryDi,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
			        NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                NULL);
    error = (INVALID_HANDLE_VALUE == m_FilterHandle) ? GetLastError() : NO_ERROR;


    //
    // Advise filter of the zone's target hardware IDs
    //
    if (!error)
    {
        switch(m_Type)
        {
            case GFXTYPE_RENDER:
                KsSetAudioGfxRenderTargetDeviceId(m_FilterHandle, pZoneFactory->GetTargetHardwareId());
                break;
            case GFXTYPE_CAPTURE:
                KsSetAudioGfxCaptureTargetDeviceId(m_FilterHandle, pZoneFactory->GetTargetHardwareId());
                break;
            case GFXTYPE_RENDERCAPTURE:
                // NTRAID#298244-2000/12/18-FrankYe Someday implement RENDERCAPTURE GFXs
                ASSERT(FALSE);
                break;
            default:
                ASSERT(FALSE);
        }
    }

    //
    // Restore filter settings from registry
    //
    if (!error)
    {
        HKEY hkFilterSettings;
        if (NO_ERROR == RegOpenFilterKey(REGSTR_PATH_GFXUSERLOADID_FILTERSETTINGS, KEY_READ, &hkFilterSettings)) {
            KsUnserializeFilterStateFromReg(m_FilterHandle, hkFilterSettings);
            RegCloseKey(hkFilterSettings);
        }
    }

    //
    // Save pointer to the zone factory to which we're adding this gfx
    //
    if (!error)
    {
    	m_pZoneFactory = pZoneFactory;
    }

    //
    // Tell zone factory to add this gfx to its graph
    //
    if (!error)
    {
    	error = AddGfxToGraph();
    }

    //
    // Unwind if error
    //
    if (error)
    {
        if (INVALID_HANDLE_VALUE != m_FilterHandle)
        {
            CloseHandle(m_FilterHandle);
            m_FilterHandle = INVALID_HANDLE_VALUE;
        }
    }

    m_ErrorFilterCreate = error;
    return error;
}

/*--------------------------------------------------------------------------

   CCuUserLoad::ChangeGfxOrderInGraph

   Changes the order of a gfx already in the zone graph.
  
   Arguments:
      IN ULONG NewGfxOrder : The new order value for the gfx.

   Return value:
      LONG : error code defined in winerror.h
        ERROR_INVALID_PARAMETER : A gfx already occupies the
          requested order.
  	ERROR_OUTOFMEMORY :
  
   Comments:
  
-------------------------------------------------------------------------*/
LONG CCuUserLoad::ChangeGfxOrderInGraph(IN ULONG NewGfxOrder)
{
    CListCuUserLoads *plistGfxs;
    CCuUserLoad *pNextGfx;
    POSITION posNextGfx;
    LONG error;

    // dprintf(TEXT("CCuUserLoad::ChangeGfxOrderInGraph\n"));

    error = NO_ERROR;
    
    if (GFXTYPE_CAPTURE == m_Type) plistGfxs = &m_pZoneFactory->m_listCaptureGfxs;
    else if (GFXTYPE_RENDER == m_Type) plistGfxs = &m_pZoneFactory->m_listRenderGfxs;
    else
    {
        ASSERT(FALSE);
        return (ERROR_INVALID_DATA);    
    }

    error = SadRemoveGfxFromZoneGraph(ghSysaudio, m_FilterHandle, TEXT("ISSUE-2000//09//21-FrankYe Need to pass friendly name"), m_ZoneFactoryDi, m_Type, m_Order);
    if (error) dprintf(TEXT("CCuUserLoad::ChangeGfxToZoneGraph : error: SadRemoveGfxFromZoneGraph returned %d\n"), error);

    if (!error)
    {
    	POSITION posOriginalNextGfx;

    	posOriginalNextGfx = m_posZoneGfxList;
    	plistGfxs->GetNext(posOriginalNextGfx);
    	
    	// Find insertion position
    	for (posNextGfx = plistGfxs->GetHeadPosition(); posNextGfx; plistGfxs->GetNext(posNextGfx))
    	{
    	    pNextGfx = plistGfxs->GetAt(posNextGfx);
    	    if (NewGfxOrder <= pNextGfx->m_Order) break;
    	}
    	// posNextGfx is now the list position after the insertion point

    	plistGfxs->MoveBefore(posNextGfx, m_posZoneGfxList);
    	
    	if (posNextGfx && (NewGfxOrder == pNextGfx->m_Order))
    	{
            dprintf(TEXT("CCuUserLoad::ChangeGfxOrderInGraph : note: attempting to move conflicting GFX ID %08X moving from %d to %d\n"),
            	pNextGfx->GetId(), pNextGfx->m_Order, pNextGfx->m_Order + 1);
            
    	    plistGfxs->SetAt(m_posZoneGfxList, NULL);
            error = pNextGfx->ModifyOrder(pNextGfx->m_Order + 1);
            plistGfxs->SetAt(m_posZoneGfxList, this);
    	}

        if (!error)
    	{
            // ISSUE-2000/09/21-FrankYe Need to pass friendly name
            error = SadAddGfxToZoneGraph(ghSysaudio, m_FilterHandle, TEXT("ISSUE-2000//09//21-FrankYe Need to pass friendly name"), m_ZoneFactoryDi, m_Type, NewGfxOrder);
            if (error) dprintf(TEXT("CCuUserLoadFactory::ChangeGfxOrderInGraph : error: SadAddGfxToZoneGraph returned %d\n"), error);

            if (!error)
            {
    	        m_Order = NewGfxOrder;
    	        if (!error) Write();
            }
    	}
    	else
    	{
    	    plistGfxs->MoveBefore(posOriginalNextGfx, m_posZoneGfxList);
    	}
    	
    }

    return error;
}

LONG CCuUserLoad::CreateFromAutoLoad(ULONG CuAutoLoadId)
{
    LONG lresult;
    CCuAutoLoad *pCuAutoLoad = new CCuAutoLoad(m_User);

    ASSERT(!m_GfxFactoryDi);
    ASSERT(!m_ZoneFactoryDi);

    if (pCuAutoLoad)
    {
	lresult = pCuAutoLoad->Initialize(CuAutoLoadId);
	if (!lresult)
	{
	    m_CuUserLoadId = CuAutoLoadId;
	    m_CuAutoLoadId = CuAutoLoadId;
	    m_Type = pCuAutoLoad->GetType();
            m_Order = 0;

	    m_GfxFactoryDi = lstrDuplicate(pCuAutoLoad->GetGfxFactoryDi());
	    if (m_GfxFactoryDi) m_ZoneFactoryDi = lstrDuplicate(pCuAutoLoad->GetZoneFactoryDi());
	    if (!m_ZoneFactoryDi) lresult = ERROR_OUTOFMEMORY;
	}
	delete pCuAutoLoad;
    } else {
	lresult = ERROR_OUTOFMEMORY;
    }

    return lresult;
}

LONG CCuUserLoad::CreateFromUser(PCTSTR GfxFactoryDi, PCTSTR ZoneFactoryDi, ULONG Type, ULONG Order)
{
    LONG lresult;

    ASSERT((GFXTYPE_RENDER == Type) || (GFXTYPE_CAPTURE == Type));
    ASSERT(GFX_MAXORDER >= Order);
    
    ASSERT(!m_GfxFactoryDi);
    ASSERT(!m_ZoneFactoryDi);

    lresult = CuNextId(m_User, &m_CuUserLoadId);
    if (!lresult)
    {
	m_CuAutoLoadId = 0;
	m_Type = Type;
        m_Order = Order;

	m_GfxFactoryDi = lstrDuplicate(GfxFactoryDi);
	m_ZoneFactoryDi = lstrDuplicate(ZoneFactoryDi);
	if (!m_GfxFactoryDi || !m_ZoneFactoryDi) lresult = ERROR_OUTOFMEMORY;
    }

    return lresult;
}

LONG CCuUserLoad::Erase(void)
{
    HKEY hkeyCu;
    HKEY hkeyCuUserLoadEnum;
    LONG lresult;

    lresult = m_User->RegOpen(KEY_READ, &hkeyCu);
    if (!lresult)
    {
	lresult = RegOpenKeyEx(hkeyCu, REGSTR_PATH_GFXUSERLOAD, 0, KEY_CREATE_SUB_KEY, &hkeyCuUserLoadEnum);
	if (!lresult)
	{
	    TCHAR szCuUserLoad[9];

	    wsprintf(szCuUserLoad, TEXT("%08X"), m_CuUserLoadId);
	    lresult = RegDeleteKeyRecursive(hkeyCuUserLoadEnum, szCuUserLoad);

	    RegCloseKey(hkeyCuUserLoadEnum);
	}
	RegCloseKey(hkeyCu);
    }

    return lresult;
}

/*-----------------------------------------------------------------------------
    CCuUserLoad::GetGfxFactoryClsid
    
    Uses the specified list of Gfx factories (CListGfxFactories) to find the
    user interface CLSID of the Gfx factory whose device interface matches the
    one associated with this CCuUserLoad object

    Caller must acquire locks on rlistGfxFactories
    
-----------------------------------------------------------------------------*/

LONG CCuUserLoad::GetGfxFactoryClsid(CListGfxFactories &rlistGfxFactories, LPCLSID pClsid)
{
    CGfxFactory *pGfxFactory;
    LONG lresult;

    ASSERT(m_GfxFactoryDi);

    pGfxFactory = CGfxFactory::ListSearchOnDi(rlistGfxFactories, m_GfxFactoryDi);
    if (pGfxFactory)
    {
	*pClsid = pGfxFactory->GetClsid();
	lresult = NO_ERROR;
    } else {
	// ISSUE-2000/09/15-FrankYe : Best error code?
	*pClsid = GUID_NULL;
	lresult = ERROR_DEVICE_NOT_AVAILABLE;
    }

    return lresult;
}

PCTSTR CCuUserLoad::GetGfxFactoryDi(void)
{
    return m_GfxFactoryDi;
}

HANDLE CCuUserLoad::GetFilterHandle(void)
{
    ASSERT((INVALID_HANDLE_VALUE != m_FilterHandle) || (NO_ERROR != m_ErrorFilterCreate));
    SetLastError(m_ErrorFilterCreate);
    return m_FilterHandle;
}

DWORD CCuUserLoad::GetId(void)
{
    return m_CuUserLoadId;
}

ULONG CCuUserLoad::GetOrder(void)
{
    return m_Order;
}

ULONG CCuUserLoad::GetType(void)
{
    return m_Type;
}

PCTSTR CCuUserLoad::GetZoneFactoryDi(void)
{
    return m_ZoneFactoryDi;
}

LONG CCuUserLoad::Initialize(PCTSTR pstrUserLoadId)
{
    HKEY hkeyCu;
    HKEY hkeyCuUserLoadEnum;
    PTSTR pstrEnd;
    LONG lresult;
    
    m_CuUserLoadId = _tcstoul((PTSTR)pstrUserLoadId, &pstrEnd, 16);

    // dprintf(TEXT("CCuUserLoad::Initialize : subkey [%s] CuUserLoadId=%08X\n"), pstrUserLoadId, m_CuUserLoadId);
    lresult = m_User->RegOpen(KEY_READ, &hkeyCu);
    if (!lresult)
    {
	lresult = RegOpenKeyEx(hkeyCu, REGSTR_PATH_GFXUSERLOAD, 0, KEY_ENUMERATE_SUB_KEYS, &hkeyCuUserLoadEnum);
	if (!lresult)
	{
	    HKEY hkeyCuUserLoad;

	    lresult = RegOpenKeyEx(hkeyCuUserLoadEnum, pstrUserLoadId, 0, KEY_QUERY_VALUE, &hkeyCuUserLoad);
	    if (!lresult)
	    {
		lresult = RegQuerySzValue(hkeyCuUserLoad, REGSTR_VAL_GFX_ZONEDI, &m_ZoneFactoryDi);
		if (!lresult) lresult = RegQuerySzValue(hkeyCuUserLoad, REGSTR_VAL_GFX_GFXDI, &m_GfxFactoryDi);
		if (!lresult) lresult = RegQueryDwordValue(hkeyCuUserLoad, REGSTR_VAL_GFX_TYPE, &m_Type);
                if (!lresult) lresult = RegQueryDwordValue(hkeyCuUserLoad, REGSTR_VAL_GFX_ORDER, &m_Order);
                if (!lresult && (m_Order > GFX_MAXORDER)) lresult = ERROR_BADDB;
		if (!lresult)
		{
		    lresult = RegQueryDwordValue(hkeyCuUserLoad, REGSTR_VAL_GFX_CUAUTOLOADID, &m_CuAutoLoadId);
		    if (!lresult && 0 != m_CuAutoLoadId)
		    {
			CCuAutoLoad *pCuAutoLoad = new CCuAutoLoad(m_User);
			if (pCuAutoLoad)
			{
			    lresult = pCuAutoLoad->Initialize(m_CuAutoLoadId);
			    delete pCuAutoLoad;
			} else {
			    lresult = ERROR_OUTOFMEMORY;
			}
		    } else if (ERROR_FILE_NOT_FOUND == lresult) {
			m_CuAutoLoadId = 0;
			lresult = NO_ERROR;
		    }
		}
		RegCloseKey(hkeyCuUserLoad);
	    }
	    RegCloseKey(hkeyCuUserLoadEnum);
	}
	RegCloseKey(hkeyCu);
    }
    return lresult;
}

/*--------------------------------------------------------------------------

   CCuUserLoad::WinsConflictWith

   Attempts to determine which gfx factory should be given priority (i.e.,
   be closer to the render or capture device).
  
   Arguments:
      IN CCuUserLoad pOther : Other gfx to compare against.
      
   Return value:
      BOOL : True if this gfx wins the conflict.
 
   Comments:
     If both gfxs have LmAutoLoadIds then we compare those.  The higher ID
     (more recently insalled) wins.  If only one has an LmAutoLoadId then it
     wins because we favor autoload GFXs over generic GFXs.  If neither have
     LmAutoLoadIds, then this CuUserLoad object wins, arbitrarily.
  
-------------------------------------------------------------------------*/
BOOL CCuUserLoad::WinsConflictWith(IN CCuUserLoad *that)
{
    ULONG thisId = 0;
    ULONG thatId = 0;;
    
    if (this->m_CuAutoLoadId)
    {
        CCuAutoLoad *pCuAutoLoad = new CCuAutoLoad(m_User);
        if (pCuAutoLoad)
        {
    	    if (NO_ERROR == pCuAutoLoad->Initialize(this->m_CuAutoLoadId))
    	    {
    	        thisId = pCuAutoLoad->GetLmAutoLoadId();
    	    }
    	    delete pCuAutoLoad;
        }
    }

    if (that->m_CuAutoLoadId)
    {
        CCuAutoLoad *pCuAutoLoad = new CCuAutoLoad(m_User);
        if (pCuAutoLoad)
        {
    	    if (NO_ERROR == pCuAutoLoad->Initialize(that->m_CuAutoLoadId))
    	    {
    	        thatId = pCuAutoLoad->GetLmAutoLoadId();
    	    }
    	    delete pCuAutoLoad;
        }
    }

    return (thisId >= thatId);
}

//--------------------------------------------------------------------------;
//
// CCuUserLoad::ModifyOrder
//
// Modfies the position of a gfx in a zone graph.
//
// Arguments:
//    IN ULONG NewOrder : The new position for the gfx.
//
// Return value:
//    LONG : error code defined in winerror.h
//	ERROR_INVALID_FUNCTION : gfx not yet in a zone graph
//
// Comments:
//    The gfx should already be in a zone graph before calling this
// function.  Otherwise, it returns an error.  This function calls
// ChangeGfxOrderInGraph on the ZoneFactory to do the buld of the work.
//
//--------------------------------------------------------------------------;
LONG CCuUserLoad::ModifyOrder(IN ULONG NewOrder)
{
    LONG error = NO_ERROR;

    if (NO_ERROR != m_ErrorFilterCreate) return m_ErrorFilterCreate;

    ASSERT(INVALID_HANDLE_VALUE != m_FilterHandle);
    ASSERT(m_pZoneFactory);
    ASSERT(m_posZoneGfxList);

    if (m_Order != NewOrder) error = ChangeGfxOrderInGraph(NewOrder);
    else dprintf(TEXT("CCuUserLoad::ModifyOrder : warning: new order same as old\n"));

    return error;
}

LONG CCuUserLoad::RegCreateFilterKey(IN PCTSTR SubKey, IN REGSAM samDesired, OUT PHKEY phkResult)
{
    HKEY hkCu;
    LONG result;

    result = m_User->RegOpen(KEY_READ, &hkCu);
    if (NO_ERROR == result)
    {
        HKEY hkCuUserLoad;
        TCHAR strRegPath[] = REGSTR_PATH_GFXUSERLOAD TEXT("\\00000000");

        wsprintf(strRegPath, TEXT("%s\\%08X"), REGSTR_PATH_GFXUSERLOAD, m_CuUserLoadId);

	result = RegOpenKeyEx(hkCu, strRegPath, 0, KEY_CREATE_SUB_KEY, &hkCuUserLoad);
	if (NO_ERROR == result)
	{
            result = RegCreateKeyEx(hkCuUserLoad, SubKey, 0, NULL, REG_OPTION_NON_VOLATILE, samDesired, NULL, phkResult, NULL);

            RegCloseKey(hkCuUserLoad);
        }

        RegCloseKey(hkCu);
    }

    return result;
}

LONG CCuUserLoad::RegOpenFilterKey(IN PCTSTR SubKey, IN REGSAM samDesired, OUT PHKEY phkResult)
{
    HKEY hkCu;
    LONG result;

    result = m_User->RegOpen(KEY_READ, &hkCu);
    if (NO_ERROR == result)
    {
        HKEY hkCuUserLoad;
        TCHAR strRegPath[] = REGSTR_PATH_GFXUSERLOAD TEXT("\\00000000");

        wsprintf(strRegPath, TEXT("%s\\%08X"), REGSTR_PATH_GFXUSERLOAD, m_CuUserLoadId);

	result = RegOpenKeyEx(hkCu, strRegPath, 0, KEY_ENUMERATE_SUB_KEYS, &hkCuUserLoad);
	if (NO_ERROR == result)
	{
            result = RegOpenKeyEx(hkCuUserLoad, SubKey, 0, samDesired, phkResult);

            RegCloseKey(hkCuUserLoad);
        }

        RegCloseKey(hkCu);
    }

    return result;
}

/*--------------------------------------------------------------------------

   CCuUserLoad::RemoveFromGraph

   Removes a gfx from the zone factory's sysaudio graph.
  
   Arguments:

   Return value:
      LONG : error code defined in winerror.h
 
   Comments:
  
-------------------------------------------------------------------------*/
LONG CCuUserLoad::RemoveFromGraph(void)
{
    CListCuUserLoads *plistGfxs = NULL;
    LONG error;
 
    ASSERT(INVALID_HANDLE_VALUE != m_FilterHandle);
    
    error = NO_ERROR;
    
    if (GFXTYPE_CAPTURE == m_Type) plistGfxs = &m_pZoneFactory->m_listCaptureGfxs;
    else if (GFXTYPE_RENDER == m_Type) plistGfxs = &m_pZoneFactory->m_listRenderGfxs;
    else ASSERT(FALSE);

    //
    // Command Sysaudio to disconnect the filter from the
    // zone's graph.
    //
    	    
    // ISSUE-2000/09/21-FrankYe Need to pass friendly name
    error = SadRemoveGfxFromZoneGraph(ghSysaudio, m_FilterHandle, TEXT("ISSUE-2000//09//21-FrankYe Need to pass friendly name"), m_ZoneFactoryDi, m_Type, m_Order);
    if (error) dprintf(TEXT("CCuUserLoad::RemoveFromGraph : error: SadRemoveGfxFromZoneGraph returned %d\n"), error);

    if (!error && plistGfxs) plistGfxs->RemoveAt(m_posZoneGfxList);

    return error;
}

//--------------------------------------------------------------------------;
//
// CCuUserLoad::RemoveFromZoneGraph
//
// Removes a gfx from its zone graph.
//
// Arguments:
//
// Return value:
//    void
//
// Comments:
//  If the GFX has been added to a zone graph, this function removes it from
//  the graph.  First it persists any settings on the GFX, then it calls
//  RemoveFromGraph on the ZoneFactory.  Finally it finally closes the GFX
//  handle.
//  
//  This method is called from this object's destructor, so it is important
//  that this function do its best to handle any errors.
//
//--------------------------------------------------------------------------;
void CCuUserLoad::RemoveFromZoneGraph(void)
{
    if (INVALID_HANDLE_VALUE != m_FilterHandle)
    {
        HKEY hkFilterSettings;
        LONG error;

        ASSERT(m_pZoneFactory);
        ASSERT(m_posZoneGfxList);
        ASSERT(INVALID_HANDLE_VALUE != ghSysaudio);
        
        //
        // Save filter settings to registry
        //
        if (NO_ERROR == RegCreateFilterKey(REGSTR_PATH_GFXUSERLOADID_FILTERSETTINGS, KEY_WRITE, &hkFilterSettings)) {
            KsSerializeFilterStateToReg(m_FilterHandle, hkFilterSettings);
            RegCloseKey(hkFilterSettings);
        }

        error = RemoveFromGraph();
        m_pZoneFactory = NULL;
        m_posZoneGfxList = NULL;

        m_ErrorFilterCreate = error;
        
	if (!error)
	{
	    CloseHandle(m_FilterHandle);
            m_FilterHandle = INVALID_HANDLE_VALUE;
	}
	
    }

    return;
}

LONG CCuUserLoad::Write(void)
{
    HKEY hkeyCu;
    HKEY hkeyCuUserLoadEnum;
    LONG lresult;

    lresult = m_User->RegOpen(KEY_READ, &hkeyCu);
    if (!lresult)
    {
	lresult = RegCreateKeyEx(hkeyCu, REGSTR_PATH_GFXUSERLOAD, 0, NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hkeyCuUserLoadEnum, NULL);
	if (NO_ERROR == lresult)
	{
	    TCHAR szUserLoad[9];
	    HKEY hkeyCuUserLoad;

	    wsprintf(szUserLoad, TEXT("%08X"), m_CuUserLoadId);
	    lresult = RegCreateKeyEx(hkeyCuUserLoadEnum, szUserLoad, 0, NULL, 0, KEY_SET_VALUE, NULL, &hkeyCuUserLoad, NULL);
	    if (!lresult)
	    {
		lresult = RegSetSzValue(hkeyCuUserLoad, REGSTR_VAL_GFX_GFXDI, m_GfxFactoryDi);
		if (!lresult) lresult = RegSetSzValue(hkeyCuUserLoad, REGSTR_VAL_GFX_ZONEDI, m_ZoneFactoryDi);
		if (!lresult) lresult = RegSetDwordValue(hkeyCuUserLoad, REGSTR_VAL_GFX_TYPE, m_Type);
		if (!lresult) lresult = RegSetDwordValue(hkeyCuUserLoad, REGSTR_VAL_GFX_ORDER, m_Order);
		if (!lresult && (0 != m_CuAutoLoadId)) lresult = RegSetDwordValue(hkeyCuUserLoad, REGSTR_VAL_GFX_CUAUTOLOADID, m_CuAutoLoadId);

		RegCloseKey(hkeyCuUserLoad);

		// Any errors writing the values would leave an invalid reg entry.  So delete if errors
		if (lresult) RegDeleteKey(hkeyCuUserLoadEnum, szUserLoad);
	    }

	    RegCloseKey(hkeyCuUserLoadEnum);
	}
	RegCloseKey(hkeyCu);
    }
    return lresult;
}

/*-----------------------------------------------------------------------------

    CCuUserLoad::FillListFromReg
    
    Adds elements to the specified list of user-loads (CListCuUserLoads) based
    on the contents of the REGSTR_PATH_GFXUSERLOAD registry information
    
    Caller must acquire any necessary locks on rlistCuUserLoads
    
-----------------------------------------------------------------------------*/
void CCuUserLoad::FillListFromReg(CUser *pUser, CListCuUserLoads &rlistCuUserLoads)
{
    HKEY hkeyCu;
    HKEY hkeyCuUserLoadEnum;
    LONG lresult;

    ASSERT(pUser);

    lresult = pUser->RegOpen(KEY_READ, &hkeyCu);
    if (!lresult)
    {
	lresult = RegOpenKeyEx(hkeyCu, REGSTR_PATH_GFXUSERLOAD, 0, KEY_READ, &hkeyCuUserLoadEnum);
	if (!lresult)
	{
	    DWORD cSubkeys;
	    DWORD cchSubkeyNameBuffer;
	    PTSTR pstrSubkeyNameBuffer;

	    lresult = RegPrepareEnum(hkeyCuUserLoadEnum, &cSubkeys, &pstrSubkeyNameBuffer, &cchSubkeyNameBuffer);
	    if (NO_ERROR == lresult)
	    {
		CListCuUserLoads listCuUserLoadsErase;

                lresult = listCuUserLoadsErase.Initialize();
                if (!lresult)
                {
                    POSITION pos;
                    DWORD dwIndex;

                    for (dwIndex = 0; dwIndex < cSubkeys; dwIndex++)
                    {
                        DWORD cchSubkeyNameBufferT;
    
                        cchSubkeyNameBufferT = cchSubkeyNameBuffer;
                        lresult = RegEnumKeyEx(hkeyCuUserLoadEnum, dwIndex, pstrSubkeyNameBuffer, &cchSubkeyNameBufferT, NULL, NULL, NULL, NULL);
                        if (!lresult)
                        {
                            CCuUserLoad *pCuUserLoad = new CCuUserLoad(pUser);
                            if (pCuUserLoad)
                            {
                                lresult = pCuUserLoad->Initialize(pstrSubkeyNameBuffer);
                                if (ERROR_FILE_NOT_FOUND == lresult) {
                                    if (!listCuUserLoadsErase.AddTail(pCuUserLoad))
                                    {
                                        lresult = ERROR_OUTOFMEMORY;
                                        delete pCuUserLoad;
                                    }
                                } else if (NO_ERROR == lresult) {
                                    if (!rlistCuUserLoads.AddTail(pCuUserLoad))
                                    {
                                        lresult = ERROR_OUTOFMEMORY;
                                        delete pCuUserLoad;
                                    }
                                } else {
                                    delete pCuUserLoad;
                                }
                            } else {
                                lresult = ERROR_OUTOFMEMORY;
                            }
                        }
                    }

                    pos = listCuUserLoadsErase.GetHeadPosition();
                    while (pos)
                    {
                        CCuUserLoad *pCuUserLoad = listCuUserLoadsErase.GetNext(pos);
                        pCuUserLoad->Erase();
                        delete pCuUserLoad;
                    }
		}

	    }

	    RegCloseKey(hkeyCuUserLoadEnum);
	}
        else
        {
    	    // dprintf(TEXT("CCuUserLoad::FillListFromReg : error: RegOpenKeyEx returned %d\n"), lresult);
        }
  
	RegCloseKey(hkeyCu);
    }
    else
    {
    	dprintf(TEXT("CCuUserLoad::FillListFromReg : error: pUser->RegOpen returned %d\n"), lresult);
    }
    
    return;
}

/*-----------------------------------------------------------------------------
    CCuUserLoad::Scan
    
    The caller must acquire any locks required for rlistZoneFactories and
    rlistGfxFactories
    
-----------------------------------------------------------------------------*/
LONG CCuUserLoad::Scan(CListZoneFactories &rlistZoneFactories, CListGfxFactories &rlistGfxFactories)
{
    LONG lresult;

    // dprintf(TEXT("CCuUserLoad::Scan\n"));

    if (m_CuAutoLoadId != 0)
    {
	// Confirm the CuAutoLoad is still valid
	CCuAutoLoad *pCuAutoLoad = new CCuAutoLoad(m_User);
	if (pCuAutoLoad)
	{
	    lresult = pCuAutoLoad->Initialize(m_CuAutoLoadId);
	    delete pCuAutoLoad;
	} else {
	    lresult = ERROR_OUTOFMEMORY;
	}
    } else {
	lresult = NO_ERROR;
    }

    LockSysaudio();

    if (!lresult && (INVALID_HANDLE_VALUE == m_FilterHandle) && (INVALID_HANDLE_VALUE != ghSysaudio))
    {
        // dprintf(TEXT("Checking Gfx[%s] and Zone[%s}\n"), m_GfxFactoryDi, m_ZoneFactoryDi);
	// See if this CuUserLoad needs loaded. It needs loaded if:
	//  a) The GfxFactory exists,
	//  b) The ZoneFactory exists
	//  c) The ZoneFactory is the proper type

	CZoneFactory *pZoneFactory = CZoneFactory::ListSearchOnDi(rlistZoneFactories, m_ZoneFactoryDi);
	if (pZoneFactory)
	{
	    CGfxFactory *pGfxFactory = CGfxFactory::ListSearchOnDi(rlistGfxFactories, m_GfxFactoryDi);
	    if (pGfxFactory)
	    {
	    	lresult = AddToZoneGraph(pZoneFactory);
	    }
	}

    }

    UnlockSysaudio();

    return lresult;
}

/*-----------------------------------------------------------------------------
    CCuUserLoad::ScanList
    
    This function walks all members of a user-load list (CListCuUserLoads)
    and invokes Scan on each of them.
    
    The caller must acquire any necessary lock on rlistCuUserLoads,
    rlistZoneFactories, and rlistGfxFactories.
    
-----------------------------------------------------------------------------*/
void CCuUserLoad::ScanList(CListCuUserLoads& rlistCuUserLoads, CListZoneFactories& rlistZoneFactories, CListGfxFactories& rlistGfxFactories)
{
    POSITION posNext;

    posNext = rlistCuUserLoads.GetHeadPosition();
    while (posNext)
    {
	POSITION posThis = posNext;
	CCuUserLoad& rCuUserLoad = *rlistCuUserLoads.GetNext(posNext);
	LONG lresult = rCuUserLoad.Scan(rlistZoneFactories, rlistGfxFactories);
	if (ERROR_FILE_NOT_FOUND == lresult)
	{
	    rCuUserLoad.Erase();
	    rlistCuUserLoads.RemoveAt(posThis);
	    delete &rCuUserLoad;
	}
    }

    return;
}

void CCuUserLoad::ListRemoveGfxFactoryDi(IN CListCuUserLoads &rlistCuUserLoads, IN PCTSTR DeviceInterface)
{
    POSITION pos;
    pos = rlistCuUserLoads.GetHeadPosition();
    while (pos) {
        CCuUserLoad& rCuUserLoad = *rlistCuUserLoads.GetNext(pos);
        if (!lstrcmpi(DeviceInterface, rCuUserLoad.GetGfxFactoryDi())) rCuUserLoad.RemoveFromZoneGraph();
    }
    return;
}

void CCuUserLoad::ListRemoveZoneFactoryDi(IN CListCuUserLoads &rlistCuUserLoads, IN PCTSTR DeviceInterface)
{
    POSITION pos;
    pos = rlistCuUserLoads.GetHeadPosition();
    while (pos) {
        CCuUserLoad& rCuUserLoad = *rlistCuUserLoads.GetNext(pos);
        if (!lstrcmpi(DeviceInterface, rCuUserLoad.GetZoneFactoryDi())) rCuUserLoad.RemoveFromZoneGraph();
    }
    return;
}

void CCuUserLoad::ListRemoveZoneFactoryDiRender(IN CListCuUserLoads &rlistCuUserLoads, IN PCTSTR DeviceInterface)
{
    POSITION pos;
    pos = rlistCuUserLoads.GetHeadPosition();
    while (pos) {
    	CCuUserLoad& rCuUserLoad = *rlistCuUserLoads.GetNext(pos);
        if (!lstrcmpi(DeviceInterface, rCuUserLoad.GetZoneFactoryDi()))
        {
            ULONG GfxType = rCuUserLoad.GetType();
            if ((GFXTYPE_RENDER == GfxType) || (GFXTYPE_RENDERCAPTURE == GfxType)) rCuUserLoad.RemoveFromZoneGraph();
        }
    }
}

void CCuUserLoad::ListRemoveZoneFactoryDiCapture(IN CListCuUserLoads &rlistCuUserLoads, IN PCTSTR DeviceInterface)
{
    POSITION pos;
    pos = rlistCuUserLoads.GetHeadPosition();
    while (pos) {
    	CCuUserLoad& rCuUserLoad = *rlistCuUserLoads.GetNext(pos);
        if (!lstrcmpi(DeviceInterface, rCuUserLoad.GetZoneFactoryDi()))
        {
            ULONG GfxType = rCuUserLoad.GetType();
            if ((GFXTYPE_CAPTURE == GfxType) || (GFXTYPE_RENDERCAPTURE == GfxType)) rCuUserLoad.RemoveFromZoneGraph();
        }
    }
}

//=============================================================================
//===   CuAutoLoad   ===
//=============================================================================
CCuAutoLoad::CCuAutoLoad(CUser *pUser)
{
    ASSERT(pUser);
    
    m_User = pUser;
    m_ZoneFactoryDi = NULL;
    m_GfxFactoryDi = NULL;
}

CCuAutoLoad::~CCuAutoLoad(void)
{
    HeapFreeIfNotNull(hHeap, 0, m_ZoneFactoryDi);
    HeapFreeIfNotNull(hHeap, 0, m_GfxFactoryDi);
}

LONG CCuAutoLoad::Create(PCTSTR ZoneFactoryDi, ULONG LmAutoLoadId)
{
	LONG lresult;
	CLmAutoLoad *pLmAutoLoad = new CLmAutoLoad;
	
	if (pLmAutoLoad)
	{
		lresult = pLmAutoLoad->Initialize(LmAutoLoadId);
		if (!lresult)
		{
			lresult = CuNextId(m_User, &m_CuAutoLoadId);
			if (!lresult)
			{
				m_LmAutoLoadId = LmAutoLoadId;
				m_Type = pLmAutoLoad->GetType();
				m_ZoneFactoryDi = lstrDuplicate(ZoneFactoryDi);
				if (m_ZoneFactoryDi) m_GfxFactoryDi = lstrDuplicate(pLmAutoLoad->GetGfxFactoryDi());
				if (!m_GfxFactoryDi) lresult = ERROR_OUTOFMEMORY;
			}
		}
		delete pLmAutoLoad;
	} else {
		lresult = ERROR_OUTOFMEMORY;
	}

	return lresult;
}

/*-----------------------------------------------------------------------------
    CCuAutoLoad::Erase
    
    This function erases the registry data representing this CCuAutoLoad object.
    
-----------------------------------------------------------------------------*/
LONG CCuAutoLoad::Erase(void)
{
    HKEY hkeyCu;
    LONG lresult;

    lresult = m_User->RegOpen(KEY_READ, &hkeyCu);
    if (!lresult)
    {
	HKEY hkeyCuAutoLoadEnum;

	lresult = RegOpenKeyEx(hkeyCu, REGSTR_PATH_GFXAUTOLOAD, 0, KEY_WRITE, &hkeyCuAutoLoadEnum);
	if (!lresult)
	{
	    TCHAR szCuAutoLoad[9];

	    wsprintf(szCuAutoLoad, TEXT("%08X"), m_CuAutoLoadId);
            lresult = RegDeleteKeyRecursive(hkeyCuAutoLoadEnum, szCuAutoLoad);

            RegCloseKey(hkeyCuAutoLoadEnum);
        }

        RegCloseKey(hkeyCu);
    }

    return lresult;
}

PCTSTR CCuAutoLoad::GetGfxFactoryDi(void)
{
	return m_GfxFactoryDi;
}

ULONG CCuAutoLoad::GetLmAutoLoadId(void)
{
	return m_LmAutoLoadId;
}

ULONG CCuAutoLoad::GetType(void)
{
	return m_Type;
}

PCTSTR CCuAutoLoad::GetZoneFactoryDi(void)
{
	return m_ZoneFactoryDi;
}

LONG CCuAutoLoad::Initialize(ULONG CuAutoLoadId)
{
    HKEY hkeyCu;
    LONG lresult;

    m_CuAutoLoadId = CuAutoLoadId;

    lresult = m_User->RegOpen(KEY_READ, &hkeyCu);
    if (!lresult)
    {
	HKEY hkeyCuAutoLoadEnum;

	lresult = RegOpenKeyEx(hkeyCu, REGSTR_PATH_GFXAUTOLOAD, 0, KEY_ENUMERATE_SUB_KEYS, &hkeyCuAutoLoadEnum);
	if (!lresult)
	{
	    HKEY hkeyCuAutoLoad;
	    TCHAR szCuAutoLoad[9];

	    wsprintf(szCuAutoLoad, TEXT("%08X"), m_CuAutoLoadId);
	    lresult = RegOpenKeyEx(hkeyCuAutoLoadEnum, szCuAutoLoad, 0, KEY_QUERY_VALUE, &hkeyCuAutoLoad);
	    if (!lresult)
	    {
		lresult = RegQuerySzValue(hkeyCuAutoLoad, REGSTR_VAL_GFX_ZONEDI, &m_ZoneFactoryDi);
		if (!lresult) lresult = RegQueryDwordValue(hkeyCuAutoLoad, REGSTR_VAL_GFX_LMAUTOLOADID, &m_LmAutoLoadId);

		if (!lresult)
		{
		    CLmAutoLoad *pLmAutoLoad = new CLmAutoLoad;

		    if (pLmAutoLoad)
		    {
			lresult = pLmAutoLoad->Initialize(m_LmAutoLoadId);
			if (!lresult)
			{
			    m_Type = pLmAutoLoad->GetType();
			    m_GfxFactoryDi = lstrDuplicate(pLmAutoLoad->GetGfxFactoryDi());
			    if (!m_GfxFactoryDi) lresult = ERROR_OUTOFMEMORY;
			}
			delete pLmAutoLoad;
		    } else {
			lresult = ERROR_OUTOFMEMORY;
		    }
		}
		// ISSUE-2000/09/25-FrankYe a FILE_NOT_FOUND error on any values would indicate a corrupt reg entry!
		RegCloseKey(hkeyCuAutoLoad);
	    }
	    RegCloseKey(hkeyCuAutoLoadEnum);
	}
	RegCloseKey(hkeyCu);
    }

    return lresult;
}

/*-----------------------------------------------------------------------------

    CCuAutoLoad::ScanReg
    
-----------------------------------------------------------------------------*/
void CCuAutoLoad::ScanReg(IN CUser *pUser, IN PCTSTR ZoneFactoryDi, IN ULONG LmAutoLoadId, IN CListCuUserLoads &rlistCuUserLoads)
{
    HKEY hkeyCu;
    LONG lresult;

    ASSERT(pUser);

    lresult = pUser->RegOpen(KEY_READ, &hkeyCu);
    if (!lresult)
    {
	HKEY hkeyCuAutoLoadEnum;

	lresult = RegOpenKeyEx(hkeyCu, REGSTR_PATH_GFXAUTOLOAD, 0, KEY_READ, &hkeyCuAutoLoadEnum);
	if (!lresult)
	{
	    DWORD cSubkeys;
	    PTSTR pstrSubkeyNameBuffer;
	    DWORD cchSubkeyNameBuffer;

	    lresult = RegPrepareEnum(hkeyCuAutoLoadEnum, &cSubkeys, &pstrSubkeyNameBuffer, &cchSubkeyNameBuffer);
	    if (!lresult)
	    {
		DWORD dwIndex;
		
		lresult = ERROR_FILE_NOT_FOUND;

		for (dwIndex = 0; (dwIndex < cSubkeys) && (ERROR_FILE_NOT_FOUND == lresult); dwIndex++)
		{
		    DWORD cchSubkeyNameBufferT = cchSubkeyNameBuffer;

		    lresult = RegEnumKeyEx(hkeyCuAutoLoadEnum, dwIndex, pstrSubkeyNameBuffer, &cchSubkeyNameBufferT, NULL, NULL, NULL, NULL);
		    if (!lresult)
		    {
                        CCuAutoLoad *pCuAutoLoad = new CCuAutoLoad(pUser);

                        if (pCuAutoLoad)
                        {
                            PTSTR pstrEnd;

                            ULONG CuAutoLoadId = _tcstoul(pstrSubkeyNameBuffer, &pstrEnd, 16);
			    
                            lresult = pCuAutoLoad->Initialize(CuAutoLoadId);
                            if (!lresult)
                            {
                                if (LmAutoLoadId != pCuAutoLoad->m_LmAutoLoadId ||
                                    lstrcmpi(ZoneFactoryDi, pCuAutoLoad->m_ZoneFactoryDi))
                                {
                                    lresult = ERROR_FILE_NOT_FOUND;
                                }
                            }
                            delete pCuAutoLoad;
                        } else {
                            lresult = ERROR_OUTOFMEMORY;
                        }
		    }
		}
		HeapFree(hHeap, 0, pstrSubkeyNameBuffer);
	    }
	    RegCloseKey(hkeyCuAutoLoadEnum);
	}

	if (ERROR_FILE_NOT_FOUND == lresult)
	{
            //
            // For this user, create and write a CuAutoLoad to the registry
            // and create and write a counterpart CuUserLoad  to the registry.
            // If writing the CuUserLoad to registry fails, we should erase
            // the CuAutoLoad from the registry.  Then, audiosrv will retry
            // creating the CuAutoLoad and CuUserLoad reg entries next time.
            //

	    CCuAutoLoad *pCuAutoLoad = new CCuAutoLoad(pUser);

	    if (pCuAutoLoad)
	    {
                CCuUserLoad *pCuUserLoad = new CCuUserLoad(pUser);

                if (pCuUserLoad)
                {
                    lresult = pCuAutoLoad->Create(ZoneFactoryDi, LmAutoLoadId);
                    if (!lresult) lresult = pCuAutoLoad->Write();
    
                    if (!lresult)
                    {
                        lresult = pCuUserLoad->CreateFromAutoLoad(pCuAutoLoad->m_CuAutoLoadId);
                        if (!lresult) lresult = pCuUserLoad->Write();
                        if (lresult) pCuAutoLoad->Erase();
                        if (!lresult) if (!rlistCuUserLoads.AddTail(pCuUserLoad))
                        if (lresult) delete pCuUserLoad;
                    }
                }
		delete pCuAutoLoad;
	    }
	}

	RegCloseKey(hkeyCu);
    }
}

/*-------------------------------------------------------------------

    CCuAutoLoad::Write
    
    Creates a registry entry in REGSTR_PATH_GFXAUTOLOAD representing
    this CCuAutoLoad object.    

-------------------------------------------------------------------*/

LONG CCuAutoLoad::Write(void)
{
    HKEY hkeyCu;
    LONG lresult;

    lresult = m_User->RegOpen(KEY_READ, &hkeyCu);
    if (!lresult)
    {
        HKEY hkeyCuAutoLoadEnum;

	lresult = RegCreateKeyEx(hkeyCu, REGSTR_PATH_GFXAUTOLOAD, 0, NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hkeyCuAutoLoadEnum, NULL);
	if (!lresult)
	{
	    HKEY hkeyCuAutoLoad;
	    TCHAR szCuAutoLoad[9];

	    wsprintf(szCuAutoLoad, TEXT("%08X"), m_CuAutoLoadId);
	    lresult = RegCreateKeyEx(hkeyCuAutoLoadEnum, szCuAutoLoad, 0, NULL, 0, KEY_SET_VALUE, NULL, &hkeyCuAutoLoad, NULL);
	    if (!lresult)
	    {
		lresult = RegSetSzValue(hkeyCuAutoLoad, REGSTR_VAL_GFX_ZONEDI, m_ZoneFactoryDi);
		if (!lresult) lresult = RegSetDwordValue(hkeyCuAutoLoad, REGSTR_VAL_GFX_LMAUTOLOADID, m_LmAutoLoadId);

		RegCloseKey(hkeyCuAutoLoad);

		// If any of the above failed, let's not leave this CuAutoLoad in the registry
		if (lresult) RegDeleteKeyRecursive(hkeyCuAutoLoadEnum, szCuAutoLoad);
	    }
	    RegCloseKey(hkeyCuAutoLoadEnum);
	}
	RegCloseKey(hkeyCu);
    }
    return lresult;
}


//=============================================================================
//===   LmAutoLoad   ===
//=============================================================================
CLmAutoLoad::CLmAutoLoad(void)
{
	m_GfxFactoryDi = NULL;
	m_HardwareId = NULL;
	m_ReferenceString = NULL;
}

CLmAutoLoad::~CLmAutoLoad(void)
{
	HeapFreeIfNotNull(hHeap, 0, m_GfxFactoryDi);
	HeapFreeIfNotNull(hHeap, 0, m_HardwareId);
	HeapFreeIfNotNull(hHeap, 0, m_ReferenceString);
}

LONG CLmAutoLoad::Create(DWORD Id, PCTSTR GfxFactoryDi, PCTSTR HardwareId, PCTSTR ReferenceString, ULONG Type)
{
	ASSERT(!m_GfxFactoryDi);
	ASSERT(!m_HardwareId);
	ASSERT(!m_ReferenceString);

	m_Id = Id;
	m_Type = Type;
	m_GfxFactoryDi = lstrDuplicate(GfxFactoryDi);
	if (m_GfxFactoryDi) m_HardwareId = lstrDuplicate(HardwareId);
	if (m_HardwareId) m_ReferenceString = lstrDuplicate(ReferenceString);
	return m_ReferenceString ? NO_ERROR : ERROR_OUTOFMEMORY;
}

LONG CLmAutoLoad::Erase(void)
{
    HKEY hkeyLmAutoLoadEnum;
    LONG lresult;

    lresult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_GFXAUTOLOAD, 0, KEY_CREATE_SUB_KEY, &hkeyLmAutoLoadEnum);
    if (!lresult)
    {
        TCHAR szLmAutoLoad[9];

        wsprintf(szLmAutoLoad, TEXT("%08x"), m_Id);
        lresult = RegDeleteKeyRecursive(hkeyLmAutoLoadEnum, szLmAutoLoad);
        RegCloseKey(hkeyLmAutoLoadEnum);
    }

    return lresult;
}

PCTSTR CLmAutoLoad::GetGfxFactoryDi(void)
{
    return m_GfxFactoryDi;
}

ULONG CLmAutoLoad::GetType(void)
{
    return m_Type;
}

LONG CLmAutoLoad::Initialize(DWORD Id)
{
    HKEY hkeyLmAutoLoadEnum;
    LONG lresult;

    m_Id = Id;

    lresult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_GFXAUTOLOAD, 0, KEY_ENUMERATE_SUB_KEYS, &hkeyLmAutoLoadEnum);
    if (!lresult)
    {
	TCHAR szLmAutoLoad[9];
	HKEY hkeyLmAutoLoad;

	wsprintf(szLmAutoLoad, TEXT("%08x"), m_Id);
	lresult = RegOpenKeyEx(hkeyLmAutoLoadEnum, szLmAutoLoad, 0, KEY_QUERY_VALUE, &hkeyLmAutoLoad);
	if (!lresult)
	{
	    lresult = RegQuerySzValue(hkeyLmAutoLoad, REGSTR_VAL_GFX_GFXDI, &m_GfxFactoryDi);
	    if (!lresult) lresult = RegQuerySzValue(hkeyLmAutoLoad, REGSTR_VAL_GFX_HARDWAREID, &m_HardwareId);
	    if (!lresult) lresult = RegQuerySzValue(hkeyLmAutoLoad, REGSTR_VAL_GFX_REFERENCESTRING, &m_ReferenceString);
	    if (!lresult) lresult = RegQueryDwordValue(hkeyLmAutoLoad, REGSTR_VAL_GFX_TYPE, &m_Type);

	    RegCloseKey(hkeyLmAutoLoad);

	    if (ERROR_FILE_NOT_FOUND == lresult)
	    {
		// If any of these values are missing, then this
		// registry data is corrupt
	    	lresult = ERROR_BADDB;
	    }
	}
	RegCloseKey(hkeyLmAutoLoadEnum);
    }

    return lresult;
}

BOOL CLmAutoLoad::IsCompatibleZoneFactory(CZoneFactory& rZoneFactory)
{
    if (!rZoneFactory.HasHardwareId(m_HardwareId)) return FALSE;
    if (!rZoneFactory.HasReferenceString(m_ReferenceString)) return FALSE;
    if (!rZoneFactory.HasCompatibleType(m_Type)) return FALSE;
    return TRUE;
}

LONG CLmAutoLoad::Write(void)
{
    HKEY hkeyLmAutoLoadEnum;
    LONG lresult;

    lresult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_GFXAUTOLOAD, 0, NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hkeyLmAutoLoadEnum, NULL);
    if (!lresult)
    {
        TCHAR szLmAutoLoad[9];
        HKEY hkeyLmAutoLoad;

        wsprintf(szLmAutoLoad, TEXT("%08x"), m_Id);
        lresult = RegCreateKeyEx(hkeyLmAutoLoadEnum, szLmAutoLoad, 0, NULL, 0, KEY_SET_VALUE, NULL, &hkeyLmAutoLoad, NULL);
        if (!lresult)
        {
            lresult = RegSetSzValue(hkeyLmAutoLoad, REGSTR_VAL_GFX_GFXDI, m_GfxFactoryDi);
            if (!lresult) lresult = RegSetSzValue(hkeyLmAutoLoad, REGSTR_VAL_GFX_HARDWAREID, m_HardwareId);
            if (!lresult) lresult = RegSetSzValue(hkeyLmAutoLoad, REGSTR_VAL_GFX_REFERENCESTRING, m_ReferenceString);
            if (!lresult) lresult = RegSetDwordValue(hkeyLmAutoLoad, REGSTR_VAL_GFX_TYPE, m_Type);

            RegCloseKey(hkeyLmAutoLoad);

            if (lresult) RegDeleteKeyRecursive(hkeyLmAutoLoadEnum, szLmAutoLoad);
        }
        RegCloseKey(hkeyLmAutoLoadEnum);
    }

    return lresult;
}

CListLmAutoLoads* CLmAutoLoad::CreateListFromReg(void)
{
    CListLmAutoLoads *pListLmAutoLoads = new CListLmAutoLoads;

    if (pListLmAutoLoads)
    {
	LONG lresult;

        lresult = pListLmAutoLoads->Initialize();
        if (!lresult) {
            HKEY hkeyLmAutoLoadEnum;
    
            lresult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_GFXAUTOLOAD, 0, KEY_READ, &hkeyLmAutoLoadEnum);
            if (!lresult)
            {
                DWORD cSubkeys;
                PTSTR pstrSubkeyNameBuffer;
                DWORD cchSubkeyNameBuffer;
    
                lresult = RegPrepareEnum(hkeyLmAutoLoadEnum, &cSubkeys, &pstrSubkeyNameBuffer, &cchSubkeyNameBuffer);
                if (!lresult)
                {
                    DWORD dwIndex = 0;
    
                    for (dwIndex = 0; dwIndex < cSubkeys; dwIndex++)
                    {
                        DWORD cchSubkeyNameBufferT = cchSubkeyNameBuffer;
                        lresult = RegEnumKeyEx(hkeyLmAutoLoadEnum, dwIndex, pstrSubkeyNameBuffer, &cchSubkeyNameBufferT, 0, NULL, 0, NULL);
                        if (!lresult) {
                            CLmAutoLoad *pLmAutoLoad = new CLmAutoLoad;
                            if (pLmAutoLoad)
                            {
                                PTSTR pstrEnd;
                                ULONG Id = _tcstoul(pstrSubkeyNameBuffer, &pstrEnd, 16);
                                if (pLmAutoLoad->Initialize(Id) || !pListLmAutoLoads->AddTail(pLmAutoLoad))
                                {
                                    delete pLmAutoLoad;
                                }
                            }
                        }
                    }
                    HeapFree(hHeap, 0, pstrSubkeyNameBuffer);
                }
    
                RegCloseKey(hkeyLmAutoLoadEnum);
            }
        } else {
            delete pListLmAutoLoads;
            pListLmAutoLoads = NULL;
        }
    }

    return pListLmAutoLoads;
}

void CLmAutoLoad::DestroyList(CListLmAutoLoads *pListLmAutoLoads)
{
    POSITION pos = pListLmAutoLoads->GetHeadPosition();
    while (pos) delete pListLmAutoLoads->GetNext(pos);
    delete pListLmAutoLoads;
}

/*-----------------------------------------------------------------------------
    CLmAutoLoad::ScanRegOnGfxFactory
    
    This function reads the local machine auto-load instructions from the
    registry.  Given a Gfx factory (CGfxFactory) and a list of Zone factories
    (CListZoneFactories) it finds any auto loads (CLmAutoLoad) that can
    be loaded and added to a specified CCuUserLoad list.  For such auto-loads
    that it finds, it notifies any corresonding auto load for the current user.
    
    The caller must acquire any necessary locks on the GfxFactory,
    listZoneFactories, and listCuUserLoads.
    
-----------------------------------------------------------------------------*/

void CLmAutoLoad::ScanRegOnGfxFactory(CUser *pUser, CGfxFactory& rGfxFactory, CListZoneFactories& rlistZoneFactories, CListCuUserLoads &rlistCuUserLoads)
{
    CListLmAutoLoads *pListLmAutoLoads = CLmAutoLoad::CreateListFromReg();

    ASSERT(pUser);

    if (pListLmAutoLoads)
    {
	POSITION posLmAutoLoads = pListLmAutoLoads->GetHeadPosition();
	while (posLmAutoLoads)
	{
	    CLmAutoLoad& rLmAutoLoad = *pListLmAutoLoads->GetNext(posLmAutoLoads);

	    if (lstrcmpi(rGfxFactory.GetDeviceInterface(), rLmAutoLoad.m_GfxFactoryDi)) continue;

	    POSITION posZoneFactories = rlistZoneFactories.GetHeadPosition();
	    while (posZoneFactories)
	    {
		CZoneFactory& rZoneFactory = *rlistZoneFactories.GetNext(posZoneFactories);
		if (!rLmAutoLoad.IsCompatibleZoneFactory(rZoneFactory)) continue;

		// This is more like a notification than a scan
		CCuAutoLoad::ScanReg(pUser, rZoneFactory.GetDeviceInterface(), rLmAutoLoad.m_Id, rlistCuUserLoads);
	    }
	}

        CLmAutoLoad::DestroyList(pListLmAutoLoads);
    }
}

/*-----------------------------------------------------------------------------
    CLmAutoLoad::ScanRegOnZoneFactory
    
    This function reads the local machine auto load instructions from the
    registry.  Given a Zone factory (CZoneFactory) and a list of Gfx factories
    (CListGfxFactories) it finds any auto loads (CLmAutoLoad) that can
    be loaded.  For such auto loads that it finds, it notifies any
    corresonding auto load for the current user.
    
    The caller must acquire any necessary locks on the ZoneFactory and the
    listGfxFactories.
    
-----------------------------------------------------------------------------*/

void CLmAutoLoad::ScanRegOnZoneFactory(CUser *pUser, CZoneFactory& rZoneFactory, CListGfxFactories& rlistGfxFactories, CListCuUserLoads& rlistCuUserLoads)
{
    CListLmAutoLoads *pListLmAutoLoads = CLmAutoLoad::CreateListFromReg();

    ASSERT(pUser);

    if (pListLmAutoLoads)
    {
	POSITION posLmAutoLoads = pListLmAutoLoads->GetHeadPosition();
	while (posLmAutoLoads)
	{
	    CLmAutoLoad& rLmAutoLoad = *pListLmAutoLoads->GetNext(posLmAutoLoads);
	    if (!rLmAutoLoad.IsCompatibleZoneFactory(rZoneFactory)) continue;

	    POSITION posGfxFactories = rlistGfxFactories.GetHeadPosition();
	    while (posGfxFactories)
	    {
		CGfxFactory& rGfxFactory = *rlistGfxFactories.GetNext(posGfxFactories);
		if (lstrcmpi(rGfxFactory.GetDeviceInterface(), rLmAutoLoad.m_GfxFactoryDi)) continue;

		// This is more like a notification than a scan
		CCuAutoLoad::ScanReg(pUser, rZoneFactory.GetDeviceInterface(), rLmAutoLoad.m_Id, rlistCuUserLoads);
	    }
	}

        CLmAutoLoad::DestroyList(pListLmAutoLoads);
    }
}


//=============================================================================
//===   InfAutoLoad   ===
//=============================================================================
CInfAutoLoad::CInfAutoLoad(void)
{
    m_hkey = NULL;
    m_GfxFactoryDi = NULL;
    m_HardwareId = NULL;
    m_ReferenceString = NULL;
}

CInfAutoLoad::~CInfAutoLoad(void)
{
    HeapFreeIfNotNull(hHeap, 0, m_GfxFactoryDi);
    HeapFreeIfNotNull(hHeap, 0, m_HardwareId);
    HeapFreeIfNotNull(hHeap, 0, m_ReferenceString);
    if (m_hkey) RegCloseKey(m_hkey);
}

LONG CInfAutoLoad::Initialize(HKEY hkey, CGfxFactory *pGfxFactory)
{
    LONG lresult;

    m_pGfxFactory = pGfxFactory;

    m_GfxFactoryDi = lstrDuplicate(pGfxFactory->GetDeviceInterface());
    if (m_GfxFactoryDi)
    {
	lresult = RegOpenKeyEx(hkey, NULL, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &m_hkey);
        if (lresult) m_hkey = NULL;

        if (!lresult) lresult = RegQuerySzValue(m_hkey, REGSTR_VAL_GFX_HARDWAREID, &m_HardwareId);
        if (!lresult) lresult = RegQuerySzValue(m_hkey, REGSTR_VAL_GFX_REFERENCESTRING, &m_ReferenceString);
        if (!lresult) lresult = RegQueryDwordValue(m_hkey , REGSTR_VAL_GFX_TYPE, &m_Type);
        if (!lresult) lresult = RegQueryDwordValue(m_hkey , REGSTR_VAL_GFX_NEWAUTOLOAD, &m_NewAutoLoad);
        if (!lresult)
        {
            lresult = RegQueryDwordValue(m_hkey , REGSTR_VAL_GFX_ID, &m_Id);
            if (ERROR_FILE_NOT_FOUND == lresult)
            {
                m_Id = 0;
                lresult = NO_ERROR;
            }
        }
    } else {
	lresult = ERROR_OUTOFMEMORY;
    }

    return (lresult);
}

LONG CInfAutoLoad::Scan(void)
{
    LONG lresult;
    DWORD LmId;

    CLmAutoLoad *pLmAutoLoad = new CLmAutoLoad;

    if (pLmAutoLoad)
    {
	    lresult = pLmAutoLoad->Initialize(m_Id);
	    if (lresult)
		{
			delete pLmAutoLoad;
			pLmAutoLoad = NULL;
		}

    } else {
	    lresult = ERROR_OUTOFMEMORY;
    }

    // a) new infautoload, found old lmautoload -> erase and free old lmautoload, create new lmautoload and add to list
    // b) new infautolaod, no old lmautoload -> create new lmautoload and add to list
    // c) new infautoload, error on old lmautoload -> abort
    // d) current infautoload, found lmautoload -> add to list
    // e) current infautoload, no lmautoload -> create new lmautoload and add to list
    // f) current infautoload, error on lmautoload -> abort

    if (m_NewAutoLoad && !lresult)
    {
	    lresult = pLmAutoLoad->Erase();
	    delete pLmAutoLoad;
		pLmAutoLoad = NULL;
	    if (!lresult) lresult = ERROR_FILE_NOT_FOUND;
    }

    if (ERROR_FILE_NOT_FOUND == lresult)
    {
		ASSERT( pLmAutoLoad == NULL );

		// create new
		lresult = LmNextId(&LmId);
		if (!lresult)
		{
			pLmAutoLoad = new CLmAutoLoad;

			if (pLmAutoLoad)
			{
				lresult = pLmAutoLoad->Create(LmId, m_GfxFactoryDi, m_HardwareId, m_ReferenceString, m_Type);
				if (!lresult) lresult = pLmAutoLoad->Write();
				if (!lresult)
				{
					lresult = RegSetDwordValue(m_hkey, REGSTR_VAL_GFX_ID, LmId);
					if (!lresult)
					{
						m_Id = LmId;
						lresult = RegSetDwordValue(m_hkey, REGSTR_VAL_GFX_NEWAUTOLOAD, 0);
						if (!lresult) m_NewAutoLoad = 0;
					}

					if (lresult) pLmAutoLoad->Erase();
				}

				if (lresult)
				{
					delete pLmAutoLoad;
					pLmAutoLoad = NULL;
				}

			} else {
				lresult = ERROR_OUTOFMEMORY;
			}
		}
    }

    if (NO_ERROR == lresult)
    {
		ASSERT( pLmAutoLoad != NULL );

	    // add to list
	    if (!m_pGfxFactory->GetListLmAutoLoads().AddTail(pLmAutoLoad))
		{
	        delete pLmAutoLoad;
			pLmAutoLoad = NULL;
	        lresult = ERROR_OUTOFMEMORY;
		}
    }

    return lresult;
}


LONG CInfAutoLoad::ScanReg(HKEY hkey, CGfxFactory *pGfxFactory)
{
    HKEY hkeyInfAutoLoadEnum;
    BOOL lresult;

    lresult = RegOpenKeyEx(hkey, REGSTR_PATH_GFX_AUTOLOAD, 0, KEY_READ, &hkeyInfAutoLoadEnum);
    if (NO_ERROR == lresult) {
        DWORD cSubkeys;
	PTSTR SubkeyName;
        DWORD cchSubkeyName;

	lresult = RegPrepareEnum(hkeyInfAutoLoadEnum, &cSubkeys, &SubkeyName, &cchSubkeyName);
	if (NO_ERROR == lresult)
	{
            DWORD i;

            for (i = 0; i < cSubkeys; i++) {
		HKEY hkeyInfAutoLoad;
		lresult = RegEnumOpenKey(hkeyInfAutoLoadEnum, i, SubkeyName, cchSubkeyName, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyInfAutoLoad);
                if (NO_ERROR == lresult)
		{
		    CInfAutoLoad *pInfAutoLoad = new CInfAutoLoad;

		    if (pInfAutoLoad)
		    {
		    	lresult = pInfAutoLoad->Initialize(hkeyInfAutoLoad, pGfxFactory);
			if (!lresult) lresult = pInfAutoLoad->Scan();
			delete pInfAutoLoad;
		    }
		    else
		    {
		    	lresult = ERROR_OUTOFMEMORY;
		    }
                    RegCloseKey(hkeyInfAutoLoad);
		}
	    }
	    HeapFree(hHeap, 0, SubkeyName);
	}
	RegCloseKey(hkeyInfAutoLoadEnum);
    }
    else
    {
    	// If there is no autoload information, then that's not really an error
        if (ERROR_FILE_NOT_FOUND == lresult) lresult = NO_ERROR;
    }
    return lresult;
}

//=============================================================================
//===   ZoneFactory   ===
//=============================================================================

CZoneFactory::CZoneFactory(void)
{
    m_DeviceInterface = NULL;
    m_HardwareId      = NULL;
    m_ReferenceString = NULL;
}

CZoneFactory::~CZoneFactory(void)
{
    ASSERT(m_listCaptureGfxs.IsEmpty());
    ASSERT(m_listRenderGfxs.IsEmpty());
    
    HeapFreeIfNotNull(hHeap, 0, m_DeviceInterface);
    HeapFreeIfNotNull(hHeap, 0, m_HardwareId);
    HeapFreeIfNotNull(hHeap, 0, m_ReferenceString);
}

LONG CZoneFactory::AddType(IN ULONG Type)
{
    BOOL fRender, fCapture;

    fRender = ZoneTypeHasRender(m_Type) || ZoneTypeHasRender(Type);
    fCapture = ZoneTypeHasCapture(m_Type) || ZoneTypeHasCapture(Type);
    
    ASSERT(fRender || fCapture);
    
    if (fRender && fCapture) m_Type = ZONETYPE_RENDERCAPTURE;
    else if (fRender) m_Type = ZONETYPE_RENDER;
    else if (fCapture) m_Type = ZONETYPE_CAPTURE;
    else m_Type = 0;

    ASSERT(0 != m_Type);
    return m_Type;
}

PCTSTR CZoneFactory::GetDeviceInterface(void)
{
    return m_DeviceInterface;
}

PCTSTR CZoneFactory::GetTargetHardwareId(void)
{
    return m_HardwareId;
}

BOOL CZoneFactory::HasHardwareId(IN PCTSTR HardwareId)
{
    return 0 == lstrcmpiMulti(m_HardwareId, HardwareId);
}

BOOL CZoneFactory::HasReferenceString(IN PCTSTR ReferenceString)
{
    return 0 == lstrcmpi(m_ReferenceString, ReferenceString);
}

BOOL CZoneFactory::HasCompatibleType(ULONG Type)
{
    if (ZoneTypeHasRender(Type) && !ZoneTypeHasRender(m_Type)) return FALSE;
    if (ZoneTypeHasCapture(Type) && !ZoneTypeHasCapture(m_Type)) return FALSE;
    return TRUE;
}

LONG CZoneFactory::Initialize(IN PCTSTR DeviceInterface, IN ULONG Type)
{
    HDEVINFO hdi;
    SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
    BOOL success;
    LONG error;

    hdi = NULL;

    m_Type = Type;

    error = m_listCaptureGfxs.Initialize();
    
    if (!error)
    {
    	error = m_listRenderGfxs.Initialize();
    }

    if (!error)
    {
        m_DeviceInterface = lstrDuplicate(DeviceInterface);
        if (!m_DeviceInterface) error = ERROR_OUTOFMEMORY;
    }

    if (!error)
    {
	hdi = SetupDiCreateDeviceInfoList(NULL, NULL);
	if (!hdi) error = GetLastError();
    }

    if (!error)
    {
	DeviceInterfaceData.cbSize = sizeof(DeviceInterfaceData);
	success = SetupDiOpenDeviceInterface(hdi, m_DeviceInterface, 0, &DeviceInterfaceData);
	if (!success) error = GetLastError();
    }

    if (!error)
    {
	success = SetupDiGetDeviceInterfaceHardwareId(hdi, &DeviceInterfaceData, &m_HardwareId);
	if (!success) error = GetLastError();
    }
    
    if (!error)
    {
	PTSTR pstr = m_DeviceInterface;

	pstr += 4;	// go past "\\?\"

	while ((TEXT('\\') != *pstr) && (TEXT('\0') != *pstr)) pstr++;
	if (*pstr == TEXT('\\'))
	{
	    pstr += 1;	// go past the '\' delimiter preceding the ref string
	    m_ReferenceString = lstrDuplicate(pstr);
	    if (!m_ReferenceString) error = ERROR_OUTOFMEMORY;
	}
    }

    if (hdi)
    {
    	SetupDiDestroyDeviceInfoList(hdi);
    }

    return error;
}

LONG CZoneFactory::RemoveType(IN ULONG Type)
{
    BOOL fRender, fCapture;

    fRender = ZoneTypeHasRender(m_Type) && !ZoneTypeHasRender(Type);
    fCapture = ZoneTypeHasCapture(m_Type) && !ZoneTypeHasCapture(Type);
    
    if (fRender && fCapture) m_Type = ZONETYPE_RENDERCAPTURE;
    else if (fRender) m_Type = ZONETYPE_RENDER;
    else if (fCapture) m_Type = ZONETYPE_CAPTURE;
    else m_Type = 0;
    
    return m_Type;
}

void CZoneFactory::ListRemoveZoneFactoryDi(IN CListZoneFactories &rlistZoneFactories, IN PCTSTR DeviceInterface)
{
    POSITION pos;
    
    // Scan all ZoneFactories and delete if matched
    pos = rlistZoneFactories.GetHeadPosition();
    while (pos) {
        POSITION posThis = pos;
        CZoneFactory& rZoneFactory = *rlistZoneFactories.GetNext(pos);
        if (!lstrcmpi(DeviceInterface, rZoneFactory.GetDeviceInterface())) {
            rlistZoneFactories.RemoveAt(posThis);
            delete &rZoneFactory;
        }
    }
    return;
}

void CZoneFactory::ListRemoveZoneFactoryDiRender(IN CListZoneFactories &rlistZoneFactories, IN PCTSTR DeviceInterface)
{
    POSITION pos;
    
    // Scan all ZoneFactories and delete if matched
    pos = rlistZoneFactories.GetHeadPosition();
    while (pos) {
        POSITION posThis = pos;
        CZoneFactory& rZoneFactory = *rlistZoneFactories.GetNext(pos);
        if (!lstrcmpi(DeviceInterface, rZoneFactory.GetDeviceInterface())) {
            if (0 == rZoneFactory.RemoveType(ZONETYPE_RENDER))
            {
                rlistZoneFactories.RemoveAt(posThis);
                delete &rZoneFactory;
            }
        }
    }
    return;
}

void CZoneFactory::ListRemoveZoneFactoryDiCapture(IN CListZoneFactories &rlistZoneFactories, IN PCTSTR DeviceInterface)
{
    POSITION pos;
    
    // Scan all ZoneFactories and delete if matched
    pos = rlistZoneFactories.GetHeadPosition();
    while (pos) {
        POSITION posThis = pos;
        CZoneFactory& rZoneFactory = *rlistZoneFactories.GetNext(pos);
        if (!lstrcmpi(DeviceInterface, rZoneFactory.GetDeviceInterface())) {
            if (0 == rZoneFactory.RemoveType(ZONETYPE_CAPTURE))
            {
                rlistZoneFactories.RemoveAt(posThis);
                delete &rZoneFactory;
            }
        }
    }
    return;
}

/*-----------------------------------------------------------------------------
    CZoneFactory::ListSearchOnDi
    
    Finds a zone factory (CZoneFactory) in a specified list (CListZoneFactories)
    having the specified device interface.
    
    The caller must acquire any necessary locks on rlist before calling
    this function
    
-----------------------------------------------------------------------------*/

CZoneFactory* CZoneFactory::ListSearchOnDi(CListZoneFactories& rlist, PCTSTR Di)
{
    POSITION pos = rlist.GetHeadPosition();
    while (pos)
    {
	CZoneFactory& rZoneFactory = *rlist.GetNext(pos);
	if (!lstrcmpi(rZoneFactory.GetDeviceInterface(), Di)) return &rZoneFactory;
    }
    return NULL;
}


//=============================================================================
//===   GfxFactory   ===
//=============================================================================

CGfxFactory::CGfxFactory(void)
{
    m_plistLmAutoLoads = NULL;;
    m_DeviceInterface = NULL;
}

CGfxFactory::~CGfxFactory(void)
{
    if (m_plistLmAutoLoads) CLmAutoLoad::DestroyList(m_plistLmAutoLoads);
    HeapFreeIfNotNull(hHeap, 0, m_DeviceInterface);
}

REFCLSID CGfxFactory::GetClsid(void)
{
    return m_Clsid;
}

PCTSTR CGfxFactory::GetDeviceInterface(void)
{
    return m_DeviceInterface;
}

CListLmAutoLoads& CGfxFactory::GetListLmAutoLoads(void)
{
    return *m_plistLmAutoLoads;
}

LONG CGfxFactory::Initialize(HKEY hkey, PCTSTR DeviceInterface)
{
    LONG lresult;

    m_plistLmAutoLoads = new CListLmAutoLoads;
    lresult = m_plistLmAutoLoads ? NO_ERROR : ERROR_OUTOFMEMORY;

    if (!lresult) {
        lresult = m_plistLmAutoLoads->Initialize();

        if (!lresult) {

            m_DeviceInterface = lstrDuplicate(DeviceInterface);
            lresult = m_DeviceInterface ? NO_ERROR : ERROR_OUTOFMEMORY;

            if (!lresult)
            {
                HKEY hkeyUi;
        
                m_Clsid = GUID_NULL;
        
                // Read UI CLSID from registry
                lresult = RegOpenKeyEx(hkey, REGSTR_PATH_GFXDI_USERINTERFACECLSID, 0, KEY_QUERY_VALUE, &hkeyUi);
                if (NO_ERROR == lresult)
                {
                    TCHAR strClsid[] = TEXT("{00000000-0000-0000-0000-000000000000}");
                    DWORD dwType;
                    DWORD cbstrClsid;
        
                    cbstrClsid = (lstrlen(strClsid) + 1) * sizeof(strClsid[0]);
                    dwType = REG_SZ;
        
                    lresult = RegQueryValueEx(hkeyUi, NULL, NULL, &dwType, (PBYTE)strClsid, &cbstrClsid);
                    if (NO_ERROR == lresult)
                    {
                        HRESULT hr;
                        CLSID clsid;
        
                        hr = CLSIDFromString(strClsid, &clsid);
                        if (SUCCEEDED(hr))
                        {
                            m_Clsid = clsid;
                        }
                    }
        
                    RegCloseKey(hkeyUi);
                }

                // Ignore errors reading CLSID
                lresult = NO_ERROR;
        
                // Note the following must have HKLM write priviledges
                lresult = CInfAutoLoad::ScanReg(hkey, this);
            }
        }

        // Assuming above logic leaves nothing in the list on error
        if (lresult) delete m_plistLmAutoLoads;
    }

    return lresult;
}

BOOL CGfxFactory::IsCompatibleZoneFactory(IN ULONG Type, IN CZoneFactory& rZoneFactory)
{
    // Fix 394279: Limit to one GFX per device
    if ((Type == GFXTYPE_RENDER) && (rZoneFactory.m_listRenderGfxs.GetCount() > 0))
    {
        return FALSE;
    }
    else if ((Type == GFXTYPE_CAPTURE) && (rZoneFactory.m_listCaptureGfxs.GetCount() > 0))
    {
        return FALSE;
    }
    else if ((Type == GFXTYPE_RENDERCAPTURE) && 
             ((rZoneFactory.m_listRenderGfxs.GetCount() > 0) || (rZoneFactory.m_listCaptureGfxs.GetCount() > 0)))
    {
        return FALSE;
    }

    POSITION pos;

    // dprintf(TEXT("CGfxFactory::IsCompatibleZoneFactory : checking Type compatibility: Requested Type=%d\n"), Type);
    if (!rZoneFactory.HasCompatibleType(Type)) return FALSE;
    // dprintf(TEXT("CGfxFactory::IsCompatibleZoneFactory : Type is compatible\n"));
    if (0 == m_plistLmAutoLoads->GetCount()) return FALSE; //Fix 394279: Only allow autoload GFX
    pos = m_plistLmAutoLoads->GetHeadPosition();
    while (pos) {
	CLmAutoLoad& rLmAutoLoad = *m_plistLmAutoLoads->GetNext(pos);
	if (rLmAutoLoad.IsCompatibleZoneFactory(rZoneFactory)) return TRUE;
    }
    return FALSE;
}

void CGfxFactory::ListRemoveGfxFactoryDi(IN CListGfxFactories &rlistGfxFactories, IN PCTSTR DeviceInterface)
{
    POSITION pos;
    
    // Scan all GfxFactories and delete if matched
    pos = rlistGfxFactories.GetHeadPosition();
    while (pos) {
        POSITION posThis = pos;
        CGfxFactory& rGfxFactory = *rlistGfxFactories.GetNext(pos);
        if (!lstrcmpi(DeviceInterface, rGfxFactory.GetDeviceInterface())) {
            rlistGfxFactories.RemoveAt(posThis);
            delete &rGfxFactory;
        }
    }
    return;
}

/*-----------------------------------------------------------------------------
    CGfxFactory::ListSearchOnDi
    
    The caller must acquire any necessary locks on rlist
    
-----------------------------------------------------------------------------*/
CGfxFactory* CGfxFactory::ListSearchOnDi(IN CListGfxFactories& rlist, IN PCTSTR Di)
{
    POSITION pos = rlist.GetHeadPosition();
    while (pos)	{
	CGfxFactory& rGfxFactory = *rlist.GetNext(pos);
	if (!lstrcmpi(rGfxFactory.GetDeviceInterface(), Di)) return &rGfxFactory;
    }
    return NULL;
}

//=============================================================================
//===   CUser   ===
//=============================================================================

LONG CreateUser(IN DWORD SessionId, OUT CUser **ppUser)
{
    CUser *pUser;
    LONG error;

    pUser = new CUser;
    if (pUser)
    {
    	error = pUser->Initialize(SessionId);
    	if (error) delete pUser;
    }
    else
    {
    	error = ERROR_OUTOFMEMORY;
    }

    if (!error) *ppUser = pUser;
    
    return error;
}

CUser::CUser(void)
{
    m_hUserToken = NULL;
    m_SessionId = LOGONID_NONE;
    m_pSid = NULL;
    m_fcsRegistry = FALSE;
    m_refRegistry = 0;
    m_hRegistry = NULL;
}

CUser::~CUser(void)
{
    if (m_hRegistry) RegCloseKey(m_hRegistry);

    HeapFreeIfNotNull(hHeap, 0, m_pSid);
    
    if (m_hUserToken) CloseHandle(m_hUserToken);
    
    if (m_fcsRegistry) DeleteCriticalSection(&m_csRegistry);
}

BOOL CUser::operator==(const CUser& other)
{
    if (m_SessionId != other.m_SessionId) return FALSE;
    if (!EqualSid(m_pSid, other.m_pSid)) return FALSE;
    return TRUE;
}

void CUser::CloseUserRegistry(void)
{
    ASSERT(m_pSid);
    ASSERT(m_hRegistry);
    ASSERT(m_fcsRegistry);
    
    EnterCriticalSection(&m_csRegistry);
    ASSERT(m_refRegistry > 0);
    if (0 == --m_refRegistry)
    {
        LONG result;
        result = RegCloseKey(m_hRegistry);
        ASSERT(NO_ERROR == result);
        m_hRegistry = NULL;
    }
    LeaveCriticalSection(&m_csRegistry);
    return;
}

PSID CUser::GetSid(void)
{
    ASSERT(m_pSid);
    return m_pSid;
}

LONG CUser::Initialize(DWORD SessionId)
{
    LONG error;
    
    m_SessionId = SessionId;

    // Initialize registry critical section
    __try {
	InitializeCriticalSection(&m_csRegistry);
	error = NO_ERROR;
	m_fcsRegistry = TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
	error = ERROR_OUTOFMEMORY;
	m_fcsRegistry = FALSE;
    }

    // Open a user token for the session's user
    if (!error)
    {
       	if (WTSQueryUserToken(m_SessionId, &m_hUserToken))
       	{
       	    if (!IsUserProfileLoaded(m_hUserToken))
       	    {
       	        error = GetLastError();
       	    	CloseHandle(m_hUserToken);
       	    	m_hUserToken = NULL;
       	    }
       	}
       	else
    	{
    	    error = GetLastError();
            dprintf(TEXT("CUser::Initialize : error: WTSQueryUserToken returned error=%d\n"), error);
    	}
    }

    // Create a SID for this user
    if (!error)
    {
        if (!CreateTokenSid(m_hUserToken, &m_pSid))
        {
            error = GetLastError();
            dprintf(TEXT("CUser::Initialize : error: CreateTokenSid failed, LastError=%d\n"), error);
        }
    }

    return error;
}

LONG CUser::RegOpen(IN REGSAM samDesired, OUT PHKEY phkResult)
{
    LONG error;
    
    if (OpenUserRegistry())
    {
        ASSERT(m_hRegistry);
    	error = RegOpenKeyEx(m_hRegistry, NULL, 0, samDesired, phkResult);
    	CloseUserRegistry();
    }
    else
    {
    	// Can't think of a better error code
    	error = ERROR_INVALID_FUNCTION;
    }

    return error;
}

BOOL CUser::OpenUserRegistry(void)
{
    BOOL success = FALSE;
    
    ASSERT(m_fcsRegistry);
    ASSERT(m_hUserToken);

    EnterCriticalSection(&m_csRegistry);
    ASSERT(m_refRegistry >= 0);
    if (0 == m_refRegistry++)
    {
    	ASSERT(NULL == m_hRegistry);
    	
        if (ImpersonateLoggedOnUser(m_hUserToken))
    	{
    	    NTSTATUS status;
    	    	
    	    status = RtlOpenCurrentUser(MAXIMUM_ALLOWED, (PHANDLE)&m_hRegistry);
    	    if (NT_SUCCESS(status))
    	    {
                success = TRUE;
            }
    	    else
    	    {
    	        dprintf(TEXT("CUser::OpenUserRegistry : error: RtlOpenCurrentUser returned status=%08Xh\n"), status);
    	    	m_hRegistry = NULL;
    	    }
    	    RevertToSelf();
    	}
    	else
    	{
    	    LONG error = GetLastError();
    	    dprintf(TEXT("CUser::OpenUserRegistry : error: ImpersonateLoggedOnUser failed, LastError=%d\n"), error);
    	}
    	
    	if (!success) m_refRegistry--;
    }
    else
    {
        // dprintf(TEXT("CUser::OpenUserRegistry : note: reusing registry handle\n"));
        success = TRUE;
    }

    LeaveCriticalSection(&m_csRegistry);

    return success;
}

//=============================================================================
//===   ===
//=============================================================================

/*-----------------------------------------------------------------------------

    OpenSysaudioForGfxs

    Attempts to open a handle on SysAudio if one hasn't already been opened.

	This function takes the sysaudio lock and thus must not be called while
	the global list lock is held.
    
-----------------------------------------------------------------------------*/
void OpenSysaudioForGfxs(void)
{
	LockSysaudio();
	
    if ((INVALID_HANDLE_VALUE == ghSysaudio) && gpstrSysaudioDeviceInterface)
    {
        ghSysaudio =  CreateFile(gpstrSysaudioDeviceInterface,
                                 GENERIC_READ | GENERIC_WRITE,
                                 0,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                 NULL);
    
        if (INVALID_HANDLE_VALUE == ghSysaudio)
        {
            dprintf(TEXT("OpenSysaudioForGfxs: error: CreateFile failure.\n"));
        }
    }
    
	UnlockSysaudio();
}

void
ZoneFactoryInterfaceCheck(
    IN CUser *pUser,
    IN HDEVINFO DevInfo,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN ULONG Type
)
{
    GUID BusTypeGuid;
    BOOL fresult;

    ASSERT(pUser);

    //
    // For now, we support GFXs only on USB bus because we want to limit
    // GFXs to only non-accelerated audio devices
    //
    fresult = SetupDiGetDeviceInterfaceBusId(DevInfo, DeviceInterfaceData, &BusTypeGuid);
    if (fresult && (GUID_BUS_TYPE_USB == BusTypeGuid))
    {
    	PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetail;
    	
    	fresult = SetupDiCreateDeviceInterfaceDetail(DevInfo, DeviceInterfaceData, &DeviceInterfaceDetail, NULL);
    	if (fresult)
    	{
            LockGlobalLists();
    
            CZoneFactory *pZoneFactory;
    
            // We scan AutoLoad and UserLoads only if we are enhancing the type
            // of an existing zone or we are adding a new zone
    
            pZoneFactory = CZoneFactory::ListSearchOnDi(*gplistZoneFactories, DeviceInterfaceDetail->DevicePath);
            if (pZoneFactory)
            {
    	        if (pZoneFactory->HasCompatibleType(Type))
    	        {
    	    	    pZoneFactory = NULL;
    	        }
                else
                {
                    pZoneFactory->AddType(Type);
                }
            }
            else
            {
                pZoneFactory = new CZoneFactory;
                if (pZoneFactory)
                {
                    if (pZoneFactory->Initialize(DeviceInterfaceDetail->DevicePath, Type) || !gplistZoneFactories->AddTail(pZoneFactory))
                    {
                        delete pZoneFactory;
                        pZoneFactory = NULL;
                    }
                }
            }
                
            if (pZoneFactory)
            {
                CLmAutoLoad::ScanRegOnZoneFactory(pUser, *pZoneFactory, *gplistGfxFactories, *gplistCuUserLoads);
                CCuUserLoad::ScanList(*gplistCuUserLoads, *gplistZoneFactories, *gplistGfxFactories);
            }
                
            UnlockGlobalLists();

            HeapFree(hHeap, 0, DeviceInterfaceDetail);
    	} else {
    	    dprintf(TEXT("ZoneFactoryInterfaceCheck: SetupDiCreateDeviceInterfaceDetail failed\n"));
    	}
    
    }
    else
    {
        if (fresult)
        {
            // dprintf(TEXT("ZoneFactoryInterfaceCheck found interface on non USB bus [%s]\n"), DeviceInterface);
        }
        else
        {
            // DWORD dw = GetLastError();
            // dprintf(TEXT("ZoneFactoryInterfaceCheck: error calling SetupDiGetDeviceInterfaceBusId\n")
            //         TEXT("  DeviceInterface=%s\n")
            //         TEXT("  LastError=%d\n"),
            //        DeviceInterface, dw);
        }
    }

    return;
}

void
GfxFactoryInterfaceCheck(
    IN CUser *pUser,
    IN HDEVINFO DevInfo,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
)
{
    HKEY hkeyDi;

    ASSERT(pUser);
            
    hkeyDi = SetupDiOpenDeviceInterfaceRegKey(DevInfo, DeviceInterfaceData, 0, KEY_ENUMERATE_SUB_KEYS);
    if (hkeyDi)
    {
        HKEY hkeyDiGfx;
        LONG lresult;
                    
        // If the KSCATEGORY_AUDIO device interface key has a GFX
        //    subkey then this is a GFX factory
                
        lresult = RegOpenKeyEx(hkeyDi, REGSTR_PATH_DI_GFX, 0, KEY_QUERY_VALUE, &hkeyDiGfx);
        if (NO_ERROR == lresult)
        {
            PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetail;
            BOOL fresult;
            
            fresult = SetupDiCreateDeviceInterfaceDetail(DevInfo, DeviceInterfaceData, &DeviceInterfaceDetail, NULL);
            if (fresult)
            {
            	OpenSysaudioForGfxs();
            	
                LockGlobalLists();
    
                // Ensure it's not already in the list
                if (!CGfxFactory::ListSearchOnDi(*gplistGfxFactories, DeviceInterfaceDetail->DevicePath))
                {
                    CGfxFactory *pGfxFactory = new CGfxFactory;
            
                    if (pGfxFactory)
                    {
                        if (!pGfxFactory->Initialize(hkeyDiGfx, DeviceInterfaceDetail->DevicePath) && gplistGfxFactories->AddTail(pGfxFactory))
                        {
                            CLmAutoLoad::ScanRegOnGfxFactory(pUser, *pGfxFactory, *gplistZoneFactories, *gplistCuUserLoads);
                            CCuUserLoad::ScanList(*gplistCuUserLoads, *gplistZoneFactories, *gplistGfxFactories);
                        }
                        else
                        {
                            delete pGfxFactory;
                        }
                    }
                }
    
                UnlockGlobalLists();

                HeapFree(hHeap, 0, DeviceInterfaceDetail);
            }

            RegCloseKey(hkeyDiGfx);
        }
        
        RegCloseKey(hkeyDi);
    }
    
    return;
}

/*-----------------------------------------------------------------------------
    GFX_InterfaceArrival

-----------------------------------------------------------------------------*/
void GFX_InterfaceArrival(PCTSTR ArrivalDeviceInterface)
{
    CUser *pUser;
    HDEVINFO hdi;
    SP_DEVICE_INTERFACE_DATA ArrivalDeviceInterfaceData;

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return;

    pUser = gpConsoleUser;
    ASSERT(pUser);

    hdi = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (INVALID_HANDLE_VALUE != hdi)
    {
        BOOL fresult;
        ArrivalDeviceInterfaceData.cbSize = sizeof(ArrivalDeviceInterfaceData);
        fresult = SetupDiOpenDeviceInterface(hdi, ArrivalDeviceInterface, 0, &ArrivalDeviceInterfaceData);
        if (fresult)
        {
            SP_DEVICE_INTERFACE_DATA AudioDeviceInterfaceData;
            SP_DEVICE_INTERFACE_DATA AliasDeviceInterfaceData;
	    BOOL fRender;
            BOOL fCapture;
            BOOL fDataTransform;
            BOOL fAudio;
    
            // dprintf(TEXT("GFX_InterfaceArrival: checking interface aliases on %s\n"), ArrivalDeviceInterface);
                    
            AudioDeviceInterfaceData.cbSize = sizeof(AudioDeviceInterfaceData);
            fAudio = SetupDiGetDeviceInterfaceAlias(hdi, &ArrivalDeviceInterfaceData, &KSCATEGORY_AUDIO, &AudioDeviceInterfaceData);
            fAudio = fAudio && (AudioDeviceInterfaceData.Flags & SPINT_ACTIVE);
        
            AliasDeviceInterfaceData.cbSize = sizeof(AliasDeviceInterfaceData);
            fRender = SetupDiGetDeviceInterfaceAlias(hdi, &ArrivalDeviceInterfaceData, &KSCATEGORY_RENDER, &AliasDeviceInterfaceData);
            fRender = fRender && (AliasDeviceInterfaceData.Flags & SPINT_ACTIVE);
        
            AliasDeviceInterfaceData.cbSize = sizeof(AliasDeviceInterfaceData);
            fCapture = SetupDiGetDeviceInterfaceAlias(hdi, &ArrivalDeviceInterfaceData, &KSCATEGORY_CAPTURE, &AliasDeviceInterfaceData);
            fCapture = fCapture && (AliasDeviceInterfaceData.Flags & SPINT_ACTIVE);
            
            AliasDeviceInterfaceData.cbSize = sizeof(AliasDeviceInterfaceData);
            fDataTransform = SetupDiGetDeviceInterfaceAlias(hdi, &ArrivalDeviceInterfaceData, &KSCATEGORY_DATATRANSFORM, &AliasDeviceInterfaceData);
            fDataTransform = fDataTransform && (AliasDeviceInterfaceData.Flags & SPINT_ACTIVE);

	    /*    
            if (fAudio) dprintf(TEXT("GFX_InterfaceArrival: interface has Audio alias\n"));
            if (fRender) dprintf(TEXT("GFX_InterfaceArrival: interface has Render alias\n"));
            if (fCapture) dprintf(TEXT("GFX_InterfaceArrival: interface has Capture alias\n"));
            if (fDataTransform) dprintf(TEXT("GFX_InterfaceArrival: interface has DataTransform alias\n"));
    	    */
    	    
            if (fAudio && fDataTransform) GfxFactoryInterfaceCheck(pUser, hdi, &AudioDeviceInterfaceData);
    
            if (fAudio && fRender && fCapture) ZoneFactoryInterfaceCheck(pUser, hdi, &AudioDeviceInterfaceData, ZONETYPE_RENDERCAPTURE);
            else if (fAudio && fRender) ZoneFactoryInterfaceCheck(pUser, hdi, &AudioDeviceInterfaceData, ZONETYPE_RENDER);
            else if (fAudio && fCapture) ZoneFactoryInterfaceCheck(pUser, hdi, &AudioDeviceInterfaceData, ZONETYPE_CAPTURE);
            
        }
    
        SetupDiDestroyDeviceInfoList(hdi);
    }
    
    RtlReleaseResource(&GfxResource);
    return;
}


void GFX_AudioInterfaceArrival(PCTSTR ArrivalDeviceInterface)
{
    // dprintf(TEXT("GFX_AudioInterfaceArrival: %s\n"), ArrivalDeviceInterface);
    GFX_InterfaceArrival(ArrivalDeviceInterface);
    return;
}

void GFX_DataTransformInterfaceArrival(PCTSTR ArrivalDeviceInterface)
{
    // dprintf(TEXT("GFX_DataTransformInterfaceArrival: %s\n"), ArrivalDeviceInterface);
    GFX_InterfaceArrival(ArrivalDeviceInterface);
    return;
}

void GFX_RenderInterfaceArrival(PCTSTR ArrivalDeviceInterface)
{
    // dprintf(TEXT("GFX_RenderInterfaceArrival: %s\n"), ArrivalDeviceInterface);
    GFX_InterfaceArrival(ArrivalDeviceInterface);
    return;
}

void GFX_CaptureInterfaceArrival(PCTSTR ArrivalDeviceInterface)
{
    // dprintf(TEXT("GFX_CaptureInterfaceArrival: %s\n"), ArrivalDeviceInterface);
    GFX_InterfaceArrival(ArrivalDeviceInterface);
    return;
}

/*-----------------------------------------------------------------------------
    GFX_AudioInterfaceRemove

-----------------------------------------------------------------------------*/
void GFX_AudioInterfaceRemove(PCTSTR DeviceInterface)
{
    POSITION pos;

    // dprintf(TEXT("GFX_AudioInterfaceRemove: %s\n"), DeviceInterface);

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return;
    
    LockGlobalLists();

    CCuUserLoad::ListRemoveZoneFactoryDi(*gplistCuUserLoads, DeviceInterface);
    CCuUserLoad::ListRemoveGfxFactoryDi(*gplistCuUserLoads, DeviceInterface);
    CZoneFactory::ListRemoveZoneFactoryDi(*gplistZoneFactories, DeviceInterface);
    CGfxFactory::ListRemoveGfxFactoryDi(*gplistGfxFactories, DeviceInterface);

    UnlockGlobalLists();

    RtlReleaseResource(&GfxResource);

    return;
}

void GFX_DataTransformInterfaceRemove(PCTSTR DataTransformDeviceInterface)
{
    PTSTR AudioDeviceInterface;
    BOOL fresult;
    
    // dprintf(TEXT("GFX_DataTransformInterfaceRemove: %s\n"), DataTransformDeviceInterface);

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return;

    fresult = SetupDiCreateAliasDeviceInterfaceFromDeviceInterface(DataTransformDeviceInterface, &KSCATEGORY_AUDIO, &AudioDeviceInterface);
    if (fresult)
    {
        LockGlobalLists();
        CCuUserLoad::ListRemoveGfxFactoryDi(*gplistCuUserLoads, AudioDeviceInterface);
        CGfxFactory::ListRemoveGfxFactoryDi(*gplistGfxFactories, AudioDeviceInterface);
        UnlockGlobalLists();
        HeapFree(hHeap, 0, AudioDeviceInterface);
    }
        
    RtlReleaseResource(&GfxResource);
    return;
}

void GFX_RenderInterfaceRemove(PCTSTR RemoveDeviceInterface)
{
    PTSTR AudioDeviceInterface;
    BOOL fresult;
    
    // dprintf(TEXT("GFX_RenderInterfaceRemove: %s\n"), RemoveDeviceInterface);

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return;

    fresult = SetupDiCreateAliasDeviceInterfaceFromDeviceInterface(RemoveDeviceInterface, &KSCATEGORY_AUDIO, &AudioDeviceInterface);
    if (fresult)
    {
	LockGlobalLists();
        CCuUserLoad::ListRemoveZoneFactoryDiRender(*gplistCuUserLoads, AudioDeviceInterface);
        CZoneFactory::ListRemoveZoneFactoryDiRender(*gplistZoneFactories, AudioDeviceInterface);
        UnlockGlobalLists();
        HeapFree(hHeap, 0, AudioDeviceInterface);
    }
    
    RtlReleaseResource(&GfxResource);
    return;
}

void GFX_CaptureInterfaceRemove(PCTSTR RemoveDeviceInterface)
{
    PTSTR AudioDeviceInterface;
    BOOL fresult;
    
    // dprintf(TEXT("GFX_CaptureInterfaceRemove: %s\n"), RemoveDeviceInterface);

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return;

    fresult = SetupDiCreateAliasDeviceInterfaceFromDeviceInterface(RemoveDeviceInterface, &KSCATEGORY_AUDIO, &AudioDeviceInterface);
    if (fresult)
    {
   	LockGlobalLists();
        CCuUserLoad::ListRemoveZoneFactoryDiCapture(*gplistCuUserLoads, AudioDeviceInterface);
        CZoneFactory::ListRemoveZoneFactoryDiCapture(*gplistZoneFactories, AudioDeviceInterface);
        UnlockGlobalLists();
        HeapFree(hHeap, 0, AudioDeviceInterface);
    }
    
    RtlReleaseResource(&GfxResource);
    return;
}

/*-----------------------------------------------------------------------------
    GFX_SysaudioInterfaceArrival
    
-----------------------------------------------------------------------------*/
void GFX_SysaudioInterfaceArrival(PCTSTR DeviceInterface)
{
    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return;
    
    LockSysaudio();

    if ((INVALID_HANDLE_VALUE == ghSysaudio) && !gpstrSysaudioDeviceInterface)
    {
        gpstrSysaudioDeviceInterface = lstrDuplicate(DeviceInterface);
    } else {

		// Sysaudio might already be open
        ASSERT(gpstrSysaudioDeviceInterface);
		if (lstrcmpi(DeviceInterface, gpstrSysaudioDeviceInterface))
		{
	    	// We have two Sysaudio devices in the system!!!  What to do???
            dprintf(TEXT("GFX_SysaudioInterfaceArrival: warning: received two arrivals!\n"));
		    ASSERT(FALSE);
		}
    }

    UnlockSysaudio();

    //
    // Even though we read the value of ghSysaudio here, we don't lock
    // sysaudio.  If some other thread is changing it from invalid to valid
    // then that thread will scan user-loads.  If some other thread changes
    // it from valid to invalid, it is okay that we do a wasteful scan of
    // user-loads.
    //
    if (INVALID_HANDLE_VALUE != ghSysaudio)
    {
        LockGlobalLists();
        CCuUserLoad::ScanList(*gplistCuUserLoads, *gplistZoneFactories, *gplistGfxFactories);
        UnlockGlobalLists();
    }

    RtlReleaseResource(&GfxResource);

    return;
}

/*-----------------------------------------------------------------------------
    GFX_SysaudioInterfaceRemove

    If this matches our sysaudio interface then scan all CuUserLoads and remove
    them from zones.  Then close our handle to Sysaudio.
    
-----------------------------------------------------------------------------*/
void GFX_SysaudioInterfaceRemove(PCTSTR DeviceInterface)
{
    POSITION pos;

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return;
    
    LockGlobalLists();
    LockSysaudio();

    //
    // Scan all CuUserLoads and remove them from zone
    //
    pos = gplistCuUserLoads->GetHeadPosition();
    while (pos) {
        CCuUserLoad& rCuUserLoad = *gplistCuUserLoads->GetNext(pos);
        rCuUserLoad.RemoveFromZoneGraph();
    }
    

    //
    // Close sysaudio
    //
    if (INVALID_HANDLE_VALUE != ghSysaudio) {
        CloseHandle(ghSysaudio);
        HeapFree(hHeap, 0, gpstrSysaudioDeviceInterface);
        ghSysaudio = INVALID_HANDLE_VALUE;
        gpstrSysaudioDeviceInterface = NULL;
    }


    UnlockSysaudio();
    UnlockGlobalLists();
    RtlReleaseResource(&GfxResource);
   return;
}

//=============================================================================
//===   RPC server interface   ===
//=============================================================================

LONG s_gfxRemoveGfx(ULONG CuUserLoadId)
{
    LONG lresult;
    
    dprintf(TEXT("gfxRemoveGfx: CuUserLoadId=%08Xh\n"), CuUserLoadId);

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return ERROR_INVALID_FUNCTION;

    lresult = RpcClientHasUserSid(gpConsoleUser->GetSid()) ? NO_ERROR : ERROR_INVALID_FUNCTION;
    if (!lresult)
    {
	POSITION pos;
	lresult = ERROR_BAD_DEVICE;   // Cannot find the device specified

        LockGlobalLists();

	pos = gplistCuUserLoads->GetHeadPosition();
	while (pos) {
	    CCuUserLoad *pCuUserLoad = gplistCuUserLoads->GetAt(pos);
	    if (pCuUserLoad->GetId() == CuUserLoadId) {
		lresult = pCuUserLoad->Erase();
		if (!lresult) {
		    gplistCuUserLoads->RemoveAt(pos);
		    delete pCuUserLoad;
		    lresult = NO_ERROR;
		}
		break;
	    }
	    gplistCuUserLoads->GetNext(pos);
	}

        UnlockGlobalLists();

    }

    RtlReleaseResource(&GfxResource);

    return lresult;
}

LONG s_gfxModifyGfx(ULONG CuUserLoadId, DWORD Order)
{
    LONG lresult;

    // Validate the Order parameter
    if (GFX_MAXORDER < Order)
    {
        dprintf(TEXT("gfxModifyGfx: error: Order=%d is invalid\n"), Order);
    	return ERROR_INVALID_PARAMETER;
    }

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return ERROR_INVALID_FUNCTION;

    lresult = RpcClientHasUserSid(gpConsoleUser->GetSid()) ? NO_ERROR : ERROR_INVALID_FUNCTION;
    if (!lresult)
    {
	POSITION pos;
	lresult = ERROR_BAD_DEVICE;    // Cannot find the device specified

        LockGlobalLists();

	pos = gplistCuUserLoads->GetHeadPosition();
	while (pos) {
	    CCuUserLoad *pCuUserLoad = gplistCuUserLoads->GetAt(pos);
	    if (pCuUserLoad->GetId() == CuUserLoadId) {
                dprintf(TEXT("gfxModify : note: Moving GFX ID %08X from %d to %d\n"), CuUserLoadId, pCuUserLoad->GetOrder(), Order);
    	    	lresult = pCuUserLoad->ModifyOrder(Order);
		break;
	    }
	    gplistCuUserLoads->GetNext(pos);
	}

        UnlockGlobalLists();

    }

    RtlReleaseResource(&GfxResource);
    
    return lresult;
}

RPC_STATUS s_gfxAddGfx(IN PWSTR ZoneFactoryDi, IN PWSTR GfxFactoryDi, IN ULONG Type, IN ULONG Order, OUT PDWORD pNewId)
{
    LONG lresult;
    
    dprintf(TEXT("gfxAddGfx: ZoneFactoryDi = %s\n"), ZoneFactoryDi);
    dprintf(TEXT("gfxAddGfx: GfxFactoryDi = %s\n"), GfxFactoryDi);
    dprintf(TEXT("gfxAddGfx: Type = %s\n"), GFXTYPE_RENDER == Type ? TEXT("Render") : TEXT("Capture"));
    dprintf(TEXT("gfxAddGfx: Order = %d\n"), Order);

    // Validate the Type parameter
    if (GFXTYPE_RENDER != Type &&
        GFXTYPE_CAPTURE != Type &&
        GFXTYPE_RENDERCAPTURE != Type)
    {
        dprintf(TEXT("gfxAddGfx: error: Type=%d is invalid\n"), Type);
        return ERROR_INVALID_PARAMETER;
    }

    // Validate the Order parameter
    if (GFX_MAXORDER < Order)
    {
        dprintf(TEXT("gfxAddGfx: error: Order=%d is invalid\n"), Order);
    	return ERROR_INVALID_PARAMETER;
    }

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return ERROR_INVALID_FUNCTION;

    lresult = RpcClientHasUserSid(gpConsoleUser->GetSid()) ? NO_ERROR : ERROR_INVALID_FUNCTION;
    if (!lresult)
    {
        LockGlobalLists();

	CGfxFactory *pGfxFactory = CGfxFactory::ListSearchOnDi(*gplistGfxFactories, GfxFactoryDi);
	CZoneFactory *pZoneFactory = CZoneFactory::ListSearchOnDi(*gplistZoneFactories, ZoneFactoryDi);

	if (pGfxFactory && pZoneFactory && pGfxFactory->IsCompatibleZoneFactory(Type, *pZoneFactory))
	{
	    CCuUserLoad *pCuUserLoad = new CCuUserLoad(gpConsoleUser);
	    if (pCuUserLoad) {
		lresult = pCuUserLoad->CreateFromUser(GfxFactoryDi, ZoneFactoryDi, Type, Order);
		if (!lresult)
		{
                    POSITION pos;

		    pos = gplistCuUserLoads->AddTail(pCuUserLoad);
		    if (pos)
		    {
                        lresult = pCuUserLoad->Scan(*gplistZoneFactories, *gplistGfxFactories);
                        if (!lresult)
                        {
                            pCuUserLoad->Write();	// Ignoring errors
                            *pNewId = pCuUserLoad->GetId();
			} else {
			    gplistCuUserLoads->RemoveAt(pos);
			}
		    } else {
			lresult = ERROR_OUTOFMEMORY;
		    }
		}
		if (lresult) delete pCuUserLoad;
	    } else {
		lresult = ERROR_OUTOFMEMORY;
	    }
	} else {
	    lresult = ERROR_INVALID_PARAMETER;
	}

        UnlockGlobalLists();

    }
    
    lresult ? dprintf(TEXT("gfxAddGfx: returning error=%lu\n"), lresult) :
              dprintf(TEXT("gfxAddGfx: returning NewId=%08Xh\n"), *pNewId);
              
    RtlReleaseResource(&GfxResource);
    
    return lresult;
}

RPC_STATUS s_gfxCreateGfxList(IN PWSTR ZoneFactoryDi, OUT UNIQUE_PGFXLIST *ppGfxList)
{
    UNIQUE_PGFXLIST pGfxList;
    int cGfx;
    LONG lresult;

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return ERROR_INVALID_FUNCTION;

    lresult = RpcClientHasUserSid(gpConsoleUser->GetSid()) ? NO_ERROR : ERROR_INVALID_FUNCTION;
    if (!lresult)
    {
        LockGlobalLists();

	if (!CZoneFactory::ListSearchOnDi(*gplistZoneFactories, ZoneFactoryDi)) lresult = ERROR_DEVICE_NOT_AVAILABLE;

	if (!lresult)
	{
	    pGfxList = NULL;
	    lresult = NO_ERROR;

	    cGfx = gplistCuUserLoads->GetCount();
	    if (cGfx > 0)
	    {
		SIZE_T cbGfxList;

		cbGfxList = sizeof(*pGfxList) - sizeof(pGfxList->Gfx[0]) + (cGfx * sizeof(pGfxList->Gfx[0]));
		pGfxList = (UNIQUE_PGFXLIST)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cbGfxList);
		if (pGfxList)
		{
		    POSITION pos = gplistCuUserLoads->GetHeadPosition();
		    PGFX pGfx = &pGfxList->Gfx[0];

		    cGfx = 0;

		    while (pos && !lresult)
		    {
			CCuUserLoad& rCuUserLoad = *gplistCuUserLoads->GetNext(pos);
			if (!lstrcmpi(ZoneFactoryDi, rCuUserLoad.GetZoneFactoryDi()))
			{
			    pGfx->Type = rCuUserLoad.GetType();
			    pGfx->Id = rCuUserLoad.GetId();
			    pGfx->Order = rCuUserLoad.GetOrder();
			    rCuUserLoad.GetGfxFactoryClsid(*gplistGfxFactories, (LPCLSID)&pGfx->Clsid);
			    ASSERT(rCuUserLoad.GetGfxFactoryDi());
			    pGfx->GfxFactoryDi = lstrDuplicate(rCuUserLoad.GetGfxFactoryDi());
			    if (!pGfx->GfxFactoryDi) lresult = ERROR_OUTOFMEMORY;
			    pGfx++;
			    cGfx++;
			}
		    }

		    if (lresult)
		    {
			pGfx = &pGfxList->Gfx[0];
			while (cGfx > 0)
			{
			    HeapFreeIfNotNull(hHeap, 0, pGfx->GfxFactoryDi);
			    pGfx++;
			    cGfx--;
			}
			HeapFree(hHeap, 0, pGfxList);
			pGfxList = NULL;
		    }
		} else {
		    lresult = ERROR_OUTOFMEMORY;
		}
	    }

	    if (!lresult)
	    {
		if (pGfxList) pGfxList->Count = cGfx;
		*ppGfxList = pGfxList;
	    }

	}

	UnlockGlobalLists();

    }

    RtlReleaseResource(&GfxResource);

    return lresult;
}

RPC_STATUS s_gfxCreateGfxFactoriesList(IN PWSTR ZoneFactoryDi, OUT UNIQUE_PDILIST *ppDiList)
{
    RPC_STATUS status;
    CZoneFactory *pZoneFactory;

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return ERROR_INVALID_FUNCTION;

    status = RpcClientHasUserSid(gpConsoleUser->GetSid()) ? NO_ERROR : ERROR_INVALID_FUNCTION;
    if (!status)
    {
	LockGlobalLists();

	pZoneFactory = CZoneFactory::ListSearchOnDi(*gplistZoneFactories, ZoneFactoryDi);
	if (!pZoneFactory) status = ERROR_DEVICE_NOT_AVAILABLE;

	if (!status)
	{
	    UNIQUE_PDILIST pDiList;
	    SIZE_T cbDiList;
	    int cElements;
            PWSTR *pDi;

	    cElements = gplistGfxFactories->GetCount();

	    cbDiList = (sizeof(*pDiList) - sizeof(pDiList->DeviceInterface[0])) + (cElements * sizeof(pDiList->DeviceInterface[0]));
	    pDiList = (UNIQUE_PDILIST)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cbDiList);

	    if (pDiList)
	    {
	        pDi = &pDiList->DeviceInterface[0];
	        POSITION pos = gplistGfxFactories->GetHeadPosition();

	        pDiList->Count = 0;

	        for (pos = gplistGfxFactories->GetHeadPosition(); pos; *gplistGfxFactories->GetNext(pos))
	        {
	            // If this gfx factory is an auto-load, then we need
	            // to check whether the zone factory is compatible before
	            // returning this gfx factory in the gfx factories list
	            CGfxFactory& rGfxFactory = *gplistGfxFactories->GetAt(pos);
	            if (rGfxFactory.GetListLmAutoLoads().GetCount())
	            {
	                // See if this ZoneFactoryDi works on any of the LmAutoLoads
	                POSITION posLmAutoLoad;
	            
	                for (posLmAutoLoad = rGfxFactory.GetListLmAutoLoads().GetHeadPosition();
	                     posLmAutoLoad;
	                     rGfxFactory.GetListLmAutoLoads().GetNext(posLmAutoLoad))
	                {
	                    CLmAutoLoad& rLmAutoLoad = *rGfxFactory.GetListLmAutoLoads().GetAt(posLmAutoLoad);
	                    if (rLmAutoLoad.IsCompatibleZoneFactory(*pZoneFactory)) break;
	                }
	                    
	                if (!posLmAutoLoad) continue;
	            } else continue; // Fix 394279: Only enumerate Auto-load GFX

	            ASSERT(rGfxFactory.GetDeviceInterface());
	            *pDi = lstrDuplicate(rGfxFactory.GetDeviceInterface());
	            if (NULL == *pDi) break;

	            pDi++;  // Next slot
	            pDiList->Count++;
	        }

	        if (pos)
	        {
	            pDi = &pDiList->DeviceInterface[0];
	            while (*pDi) HeapFree(hHeap, 0, *(pDi++));
	            HeapFree(hHeap, 0, pDiList);
	            pDiList = NULL;
	        }

	        if (pDiList) *ppDiList = pDiList;
	        status = pDiList ? NO_ERROR : ERROR_OUTOFMEMORY;

	    }
	}

	UnlockGlobalLists();

    }

    RtlReleaseResource(&GfxResource);

    return status;
}

RPC_STATUS s_gfxCreateZoneFactoriesList(OUT UNIQUE_PDILIST *ppDiList)
{
    UNIQUE_PDILIST pDiList;
    SIZE_T cbDiList;
    int cElements;
    RPC_STATUS status;


    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return ERROR_INVALID_FUNCTION;

    status = RpcClientHasUserSid(gpConsoleUser->GetSid()) ? NO_ERROR : ERROR_INVALID_FUNCTION;
    if (!status)
    {
        PWSTR *pDi;

	LockGlobalLists();

	cElements = gplistZoneFactories->GetCount();

	cbDiList = (sizeof(*pDiList) - sizeof(pDiList->DeviceInterface[0])) + (cElements * sizeof(pDiList->DeviceInterface[0]));
	pDiList = (UNIQUE_PDILIST) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cbDiList);

	if (pDiList)
	{
	    pDi = &pDiList->DeviceInterface[0];
	    POSITION pos = gplistZoneFactories->GetHeadPosition();

	    pDiList->Count = cElements;

	    while (pos)
	    {
	            
	        CZoneFactory& rZoneFactory = *gplistZoneFactories->GetAt(pos);
	        *pDi = lstrDuplicate(rZoneFactory.GetDeviceInterface());
	        if (NULL == *pDi) break;
	            
	        gplistZoneFactories->GetNext(pos);
	        pDi++;
	    }
	    
	    if (pos)
	    {
	        pDi = &pDiList->DeviceInterface[0];

	        while (*pDi) HeapFree(hHeap, 0, *(pDi++));

	        HeapFree(hHeap, 0, pDiList);
	        pDiList = NULL;
	    }
	        
	}

	UnlockGlobalLists();

	if (pDiList) *ppDiList = pDiList;
	status = pDiList ? NO_ERROR : ERROR_OUTOFMEMORY;

    }

    RtlReleaseResource(&GfxResource);

    return status;
}

LONG s_gfxOpenGfx(IN DWORD dwProcessId, IN DWORD dwGfxId, OUT RHANDLE *pFileHandle)
{
    HANDLE hClientProcess;
    RPC_STATUS status;
    HANDLE hGfxFilter;
    POSITION pos;

    if (!RtlInterlockedTestAcquireResourceShared(&GfxResource, &gfGfxInitialized)) return ERROR_INVALID_FUNCTION;

    status = RpcClientHasUserSid(gpConsoleUser->GetSid()) ? NO_ERROR : ERROR_INVALID_FUNCTION;
    if (!status)
    {
	LockGlobalLists();

	status = ERROR_BAD_DEVICE;    // Cannot find the device specified

	pos = gplistCuUserLoads->GetHeadPosition();
	while (pos) {
	    CCuUserLoad *pCuUserLoad = gplistCuUserLoads->GetAt(pos);
	    if (pCuUserLoad->GetId() == dwGfxId) {
	        hGfxFilter = pCuUserLoad->GetFilterHandle();
	        status = (INVALID_HANDLE_VALUE != hGfxFilter) ? NO_ERROR : GetLastError();
	        break;
	    }
	    gplistCuUserLoads->GetNext(pos);
	}

	if (!status)
	{
	    hClientProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwProcessId);
	    if (hClientProcess)
	    {
	        HANDLE hGfxFilterClient;

	        if (DuplicateHandle(GetCurrentProcess(), hGfxFilter, hClientProcess, &hGfxFilterClient, 0, FALSE, DUPLICATE_SAME_ACCESS))
	        {
	            dprintf(TEXT("hGfxFilter=%p, hGfxFilterClient=%p\n"), hGfxFilter, hGfxFilterClient);
	            *pFileHandle = (RHANDLE)hGfxFilterClient;
	        } else {
	            status = GetLastError();
	        }
	        CloseHandle(hClientProcess);
	    } else {
	        status = GetLastError();
	    }
	}

	UnlockGlobalLists();

    }

    RtlReleaseResource(&GfxResource);
    
    return status;
}

//=============================================================================
//===   Startup/shutdown   ===
//=============================================================================

void EnumeratedInterface(LPCGUID ClassGuid, PCTSTR DeviceInterface)
{
    if (IsEqualGUID(KSCATEGORY_AUDIO,         *ClassGuid)) GFX_AudioInterfaceArrival(DeviceInterface);
    if (IsEqualGUID(KSCATEGORY_RENDER,        *ClassGuid)) GFX_RenderInterfaceArrival(DeviceInterface);
    if (IsEqualGUID(KSCATEGORY_CAPTURE,       *ClassGuid)) GFX_CaptureInterfaceArrival(DeviceInterface);
    if (IsEqualGUID(KSCATEGORY_DATATRANSFORM, *ClassGuid)) GFX_DataTransformInterfaceArrival(DeviceInterface);
    if (IsEqualGUID(KSCATEGORY_SYSAUDIO,      *ClassGuid)) GFX_SysaudioInterfaceArrival(DeviceInterface);
    return;
}

void EnumerateInterfaces(LPCGUID ClassGuid)
{
    HDEVINFO hdi;

    hdi = SetupDiGetClassDevs(ClassGuid, NULL, NULL, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
    if (hdi) {
        DWORD i;
        BOOL fresult;

        i = (-1);
        do {
            SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;

            i += 1;
            DeviceInterfaceData.cbSize = sizeof(DeviceInterfaceData);
            fresult = SetupDiEnumDeviceInterfaces(hdi, NULL, ClassGuid, i, &DeviceInterfaceData);
            if (fresult) {
                DWORD cbDeviceInterfaceDetailData;

                if (   SetupDiGetDeviceInterfaceDetail(hdi, &DeviceInterfaceData, NULL, 0, &cbDeviceInterfaceDetailData, NULL)
                    || ERROR_INSUFFICIENT_BUFFER == GetLastError())
                {
                    PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetailData;

                    DeviceInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)HeapAlloc(hHeap, 0, cbDeviceInterfaceDetailData);
                    if (DeviceInterfaceDetailData) {
                        DeviceInterfaceDetailData->cbSize = sizeof(*DeviceInterfaceDetailData);
                        if (SetupDiGetDeviceInterfaceDetail(hdi, &DeviceInterfaceData, DeviceInterfaceDetailData, cbDeviceInterfaceDetailData, NULL, NULL)) {
			    EnumeratedInterface(ClassGuid, DeviceInterfaceDetailData->DevicePath);
                        }
                        HeapFree(hHeap, 0, DeviceInterfaceDetailData);
                    }
                }
            }
        } while (fresult);

        SetupDiDestroyDeviceInfoList(hdi);
    }
    return;
}


void Initialize(void)
{
    LONG result;

    ASSERT(FALSE == gfGfxInitialized);

    // dprintf(TEXT("GFX_Initialize\n"));
    
    //
    // Sysaudio critical section
    //
    ASSERT(!gfCsSysaudio);
    __try {
        InitializeCriticalSection(&gcsSysaudio);
        gfCsSysaudio = TRUE;
        result = NO_ERROR;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        result = ERROR_OUTOFMEMORY;
    }

    //
    // Create gobal lists
    //
    if (NO_ERROR == result)
    {
        gplistGfxFactories = new CListGfxFactories;
        gplistZoneFactories = new CListZoneFactories;
        gplistCuUserLoads = new CListCuUserLoads;
        
        if (gplistGfxFactories && gplistZoneFactories && gplistCuUserLoads)
        {
            result = gplistGfxFactories->Initialize();
            if (NO_ERROR == result) result = gplistZoneFactories->Initialize();
            if (NO_ERROR == result) result = gplistCuUserLoads->Initialize();
    
        } else {
            result = ERROR_OUTOFMEMORY;
        }
    }

    if (NO_ERROR == result) {

        gfGfxInitialized = TRUE;

        //
        // Fill global lists
        //
        // Note we do not acquire global lists lock.  We assume that this
        // function is called before any other functions that might access
        // the lists.
        //
        
        CCuUserLoad::FillListFromReg(gpConsoleUser, *gplistCuUserLoads);

        // Pnp notifications are already set up.  We need to enumerate any     |
        // existing interfaces.  We don't really need to enumerate render,
        // capture, and datatransform since we check for those aliases when we
        // check audio interfaces.  If a capture, render, or datatransform
        // interface is not yet enabled when we check an audio interface, then
        // we will get it via pnp notification.
        EnumerateInterfaces(&KSCATEGORY_SYSAUDIO);
        EnumerateInterfaces(&KSCATEGORY_AUDIO);
        // EnumerateInterfaces(&KSCATEGORY_RENDER);
        // EnumerateInterfaces(&KSCATEGORY_CAPTURE);
        // EnumerateInterfaces(&KSCATEGORY_DATATRANSFORM);
        

    } else {

        //
        // Unwind due to error
        //
        if (gplistGfxFactories) delete gplistGfxFactories;
        if (gplistZoneFactories) delete gplistZoneFactories;
        if (gplistCuUserLoads) delete gplistCuUserLoads;
        gplistGfxFactories = NULL;
        gplistZoneFactories = NULL;
        gplistCuUserLoads = NULL;
        
        if (gfCsSysaudio) DeleteCriticalSection(&gcsSysaudio);
        gfCsSysaudio = FALSE;
        
    }

    return;
}


void Terminate(void)
{
    POSITION pos;

    // dprintf(TEXT("GFX_Terminate\n"));

    gfGfxInitialized = FALSE;
    
    //
    // Clean up glistGfxFactories, glistZoneFactories, glistUserLoads
    //
    if (gplistCuUserLoads) {
        pos = gplistCuUserLoads->GetHeadPosition();
        while (pos) {
                CCuUserLoad *pCuUserLoad = gplistCuUserLoads->GetNext(pos);
                delete pCuUserLoad;
        }
        gplistCuUserLoads->RemoveAll();
        delete gplistCuUserLoads;
        gplistCuUserLoads = NULL;
    }

    if (gplistGfxFactories) {
        pos = gplistGfxFactories->GetHeadPosition();
        while (pos) {
                CGfxFactory *pGfxFactory = gplistGfxFactories->GetNext(pos);
                delete pGfxFactory;
        }
        gplistGfxFactories->RemoveAll();
        delete gplistGfxFactories;
        gplistGfxFactories = NULL;
    }

    if (gplistZoneFactories) {
        pos = gplistZoneFactories->GetHeadPosition();
        while (pos) {
                CZoneFactory *pZoneFactory = gplistZoneFactories->GetNext(pos);
                delete pZoneFactory;
        }
        gplistZoneFactories->RemoveAll();
        delete gplistZoneFactories;
        gplistZoneFactories = NULL;
    }

    //
    // Close sysaudio
    //
    if (INVALID_HANDLE_VALUE != ghSysaudio) {
        CloseHandle(ghSysaudio);
        HeapFree(hHeap, 0, gpstrSysaudioDeviceInterface);
        ghSysaudio = INVALID_HANDLE_VALUE;
        gpstrSysaudioDeviceInterface = NULL;
    }

    //
    // Sysaudio critical section
    //
    if (gfCsSysaudio) DeleteCriticalSection(&gcsSysaudio);
    gfCsSysaudio = FALSE;

    //
    // Console user
    //
    if (gpConsoleUser) delete gpConsoleUser;
    gpConsoleUser = NULL;

    return;
}

/*-----------------------------------------------------------------------------

    InitializeForNewConsoleUser

    Evaluates current console user.  If the user is different than before,
    then terminate and reinitialize the GFX objects and data structures.

    Assume GfxResource is acquired exclusive.
    
    Assumes gdwConsoleSessionId has been set properly.

    Might change gpConsoleUserSid.
    
-----------------------------------------------------------------------------*/
void InitializeForNewConsoleUser(DWORD ConsoleSessionId)
{
    CUser *pOldConsoleUser = gpConsoleUser;
    CUser *pNewConsoleUser = NULL;
    BOOL IsNewConsoleUser  = TRUE;

    CreateUser(ConsoleSessionId, &pNewConsoleUser);
    
    if ((!pNewConsoleUser && !pOldConsoleUser) ||
    	(pNewConsoleUser && pOldConsoleUser && (*pNewConsoleUser == *pOldConsoleUser)))
    {
    	IsNewConsoleUser = FALSE;
    }

    if (IsNewConsoleUser)
    {
    	Terminate();
    	gpConsoleUser = pNewConsoleUser;
    	if (gpConsoleUser)
    	{
   	    #ifdef DBG
    	    {
    	        PTSTR StringSid;
    	        if (CreateStringSidFromSid(gpConsoleUser->GetSid(), &StringSid))
    	        {
    	            dprintf(TEXT("note: new console user SID %s\n"), StringSid);
    	            HeapFree(hHeap, 0, StringSid);
    	        }
    	    }
    	    #endif
    	    Initialize();
    	}

    } else {
        delete pNewConsoleUser;
    }

    return;
}

void GFX_SessionChange(DWORD EventType, LPVOID EventData)
{
    PWTSSESSION_NOTIFICATION pWtsNotification = (PWTSSESSION_NOTIFICATION)EventData;
    static DWORD ConsoleSessionId = 0;	// Initial console session ID

    switch (EventType)
    {
    	case WTS_CONSOLE_CONNECT:
    	{
            RtlAcquireResourceExclusive(&GfxResource, TRUE);
            ConsoleSessionId = pWtsNotification->dwSessionId;
            InitializeForNewConsoleUser(ConsoleSessionId);
            RtlReleaseResource(&GfxResource);
    	    break;
    	}
        case WTS_CONSOLE_DISCONNECT:
        {
            RtlAcquireResourceExclusive(&GfxResource, TRUE);
            Terminate();
            ConsoleSessionId = LOGONID_NONE;
            RtlReleaseResource(&GfxResource);
            break;
        }
        case WTS_REMOTE_CONNECT:
       	{
       	    break;
       	}
       	case WTS_REMOTE_DISCONNECT:
       	{
       	    break;
       	}
    	case WTS_SESSION_LOGON:
    	{
            RtlAcquireResourceExclusive(&GfxResource, TRUE);
            if (ConsoleSessionId == pWtsNotification->dwSessionId) InitializeForNewConsoleUser(ConsoleSessionId);
            RtlReleaseResource(&GfxResource);
	    break;
    	}
	case WTS_SESSION_LOGOFF:
	{
            RtlAcquireResourceExclusive(&GfxResource, TRUE);
            if (ConsoleSessionId == pWtsNotification->dwSessionId) Terminate();
            RtlReleaseResource(&GfxResource);
	    break;
	}
        default:
        {
            dprintf(TEXT("GFX_SessionChange: Unhandled EventType=%d\n"), EventType);
            break;
        }
    }
    
    return;
}

void GFX_ServiceStop(void)
{
    RtlAcquireResourceExclusive(&GfxResource, TRUE);
    Terminate();
    RtlReleaseResource(&GfxResource);
    return;
}

void s_gfxLogon(IN handle_t hBinding, IN DWORD dwProcessId)
{
    // dprintf(TEXT("s_gfxLogon\n"));
    // ISSUE-2001/01/29-FrankYe I should be able to completely remove this and
    // s_gfxLogoff after Windows Bugs 296884 is fixed.
    return;
}

void s_gfxLogoff(void)
{
    // dprintf(TEXT("s_gfxLogoff\n"));
    return;
}

//=============================================================================
//===   GFX-specific DLL attach/detach   ===
//=============================================================================

BOOL GFX_DllProcessAttach(void)
{
   BOOL result;
   NTSTATUS ntstatus;

    __try {
        RtlInitializeResource(&GfxResource);
        ntstatus = STATUS_SUCCESS;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        ntstatus = GetExceptionCode();
    }
    gfGfxResource = (NT_SUCCESS(ntstatus));
    result = (NT_SUCCESS(ntstatus));

    return result;
}

void GFX_DllProcessDetach(void)
{
    if (gfGfxResource) {
    	RtlDeleteResource(&GfxResource);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\audiosrv\audiosrv.cpp ===
/* audiosrv.cpp
 * Copyright (c) 2000-2001 Microsoft Corporation
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT
#include <stdio.h>
#include <windows.h>
#include <setupapi.h>
#include <dbt.h>
#include <ks.h>
#include <ksmedia.h>
#include <svcs.h>
#include "debug.h"
#include "list.h"
#include "audiosrv.h"
#include "service.h"
#include "agfxs.h"
#include "mme.h"
#include "ts.h"

//
// Note in general don't rely on compiler init of global
// variables since service might be stopped and restarted
// without this DLL being freed and then reloaded.
//
PSVCHOST_GLOBAL_DATA gpSvchostSharedGlobals = NULL;
BOOL       fRpcStarted;
HANDLE     hHeap;
HDEVNOTIFY hdevNotifyAudio;
HDEVNOTIFY hdevNotifyRender;
HDEVNOTIFY hdevNotifyCapture;
HDEVNOTIFY hdevNotifyDataTransform;
HDEVNOTIFY hdevNotifySysaudio;

//
// Upon loading this DLL, svchost will find this exported function
// and pass a pointer to useful shared globals.
void SvchostPushServiceGlobals(IN PSVCHOST_GLOBAL_DATA pSvchostSharedGlobals)
{
    gpSvchostSharedGlobals = pSvchostSharedGlobals;
}

//--------------------------------------------------------------------------;
//
// AudioSrvRpcIfCallback
//
// Description:
//	RPC security callback function.  See MSDN for RpcServerRegisterIfEx
// IfCallback parameter.  This security callback function will fail any
// non local RPC calls.  It checks this by using the internal RPC
// function I_RpcBindingInqTransportType.
//
// Arguments:
//	See MSDN for RPC_IF_CALLBACK_FN.
//
// Return value:
//	See MSDN for RPC_IF_CALLBACK_FN.
//
// History:
//	05/02/2002		FrankYe		Created
//
//--------------------------------------------------------------------------;
RPC_STATUS RPC_ENTRY AudioSrvRpcIfCallback(IN RPC_IF_HANDLE Interface, IN void *Context)
{
	unsigned int type;
	RPC_STATUS status;

	status = I_RpcBindingInqTransportType(Context, &type);
	if (RPC_S_OK != status) return ERROR_ACCESS_DENIED;
	if (TRANSPORT_TYPE_LPC != type) return ERROR_ACCESS_DENIED;
	return RPC_S_OK;
}

// Stub initialization function. 
DWORD MyServiceInitialization(SERVICE_STATUS_HANDLE ssh, DWORD   argc, LPTSTR  *argv, DWORD *specificError)
{
    DEV_BROADCAST_DEVICEINTERFACE dbdi;
    LONG status;

    // dprintf(TEXT("MyServiceInitialization\n"));
    
    status = ERROR_SUCCESS;;

    fRpcStarted = FALSE;
    hdevNotifyAudio = NULL;
    hdevNotifyRender = NULL;
    hdevNotifyCapture = NULL;
    hdevNotifyDataTransform = NULL;
    hdevNotifySysaudio = NULL;

    gplistSessionNotifications = new CListSessionNotifications;
    if (!gplistSessionNotifications) status = ERROR_OUTOFMEMORY;
    if (!status) status = gplistSessionNotifications->Initialize();

    if (!status) {
        ZeroMemory(&dbdi, sizeof(dbdi));
        dbdi.dbcc_size = sizeof(dbdi);
        dbdi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        dbdi.dbcc_classguid = KSCATEGORY_AUDIO;
        hdevNotifyAudio = RegisterDeviceNotification(ssh, &dbdi, DEVICE_NOTIFY_SERVICE_HANDLE);
        if (!hdevNotifyAudio) status = GetLastError();
    }
    
    if (!status) {
        ZeroMemory(&dbdi, sizeof(dbdi));
        dbdi.dbcc_size = sizeof(dbdi);
        dbdi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        dbdi.dbcc_classguid = KSCATEGORY_RENDER;
        hdevNotifyRender = RegisterDeviceNotification(ssh, &dbdi, DEVICE_NOTIFY_SERVICE_HANDLE);
        if (!hdevNotifyRender) status = GetLastError();
    }
    
    if (!status) {
        ZeroMemory(&dbdi, sizeof(dbdi));
        dbdi.dbcc_size = sizeof(dbdi);
        dbdi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        dbdi.dbcc_classguid = KSCATEGORY_CAPTURE;
        hdevNotifyCapture = RegisterDeviceNotification(ssh, &dbdi, DEVICE_NOTIFY_SERVICE_HANDLE);
        if (!hdevNotifyCapture) status = GetLastError();
    }
    
    if (!status) {
        ZeroMemory(&dbdi, sizeof(dbdi));
        dbdi.dbcc_size = sizeof(dbdi);
        dbdi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        dbdi.dbcc_classguid = KSCATEGORY_DATATRANSFORM;
        hdevNotifyDataTransform = RegisterDeviceNotification(ssh, &dbdi, DEVICE_NOTIFY_SERVICE_HANDLE);
        if (!hdevNotifyDataTransform) status = GetLastError();
    }
    
    if (!status) {
        ZeroMemory(&dbdi, sizeof(dbdi));
        dbdi.dbcc_size = sizeof(dbdi);
        dbdi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        dbdi.dbcc_classguid = KSCATEGORY_SYSAUDIO;
        hdevNotifySysaudio = RegisterDeviceNotification(ssh, &dbdi, DEVICE_NOTIFY_SERVICE_HANDLE);
        if (!hdevNotifySysaudio) status = GetLastError();
    }
    
    if (!status) {
        NTSTATUS ntstatus;
        ntstatus = RpcServerUseAllProtseqsIf(RPC_C_PROTSEQ_MAX_REQS_DEFAULT, AudioSrv_v1_0_s_ifspec, NULL);
        if (!ntstatus) ntstatus = RpcServerRegisterIfEx(AudioSrv_v1_0_s_ifspec, NULL, NULL, RPC_IF_AUTOLISTEN, RPC_C_LISTEN_MAX_CALLS_DEFAULT, AudioSrvRpcIfCallback);
        if (!ntstatus) {
            fRpcStarted = TRUE;
        } else {
            // ISSUE-2000/10/10-FrankYe Try to convert to proper win32 error.
            status = RPC_S_SERVER_UNAVAILABLE;
        }
    }

    if (!status) {
    	status = MME_ServiceStart();
    }

    if (status) {
        // Rely on MyServiceTerminate to clean up anything
        // that is partially initialized.
    }

    return status;
}  // end MyServiceInitialization

void MyServiceTerminate(void)
{
    //
    // Stop the Rpc server
    //
    if (fRpcStarted) {
        NTSTATUS status;
        status = RpcServerUnregisterIf(AudioSrv_v1_0_s_ifspec, NULL, 1);
        if (status) dprintf(TEXT("ServiceStop: StopRpcServerEx returned NTSTATUS=%08Xh\n"), status);
        fRpcStarted = FALSE;
    }
    
    //
    // Unregister PnP notifications
    //
    if (hdevNotifySysaudio) UnregisterDeviceNotification(hdevNotifySysaudio);
    if (hdevNotifyDataTransform) UnregisterDeviceNotification(hdevNotifyDataTransform);
    if (hdevNotifyCapture) UnregisterDeviceNotification(hdevNotifyCapture);
    if (hdevNotifyRender) UnregisterDeviceNotification(hdevNotifyRender);
    if (hdevNotifyAudio) UnregisterDeviceNotification(hdevNotifyAudio);
    hdevNotifySysaudio = NULL;
    hdevNotifyDataTransform = NULL;
    hdevNotifyCapture = NULL;
    hdevNotifyRender = NULL;
    hdevNotifyAudio = NULL;

    //
    // Clean up any remaining session notifications and delete list
    //
    if (gplistSessionNotifications) {
        POSITION pos = gplistSessionNotifications->GetHeadPosition();
        while (pos)
        {
            PSESSIONNOTIFICATION pNotification;
            pNotification = gplistSessionNotifications->GetNext(pos);
            CloseHandle(pNotification->Event);
            delete pNotification;
        }
        delete gplistSessionNotifications;
    }
    gplistSessionNotifications = NULL;

    //
    // Clean up GFX support
    //
    GFX_ServiceStop();

    return;
}

DWORD ServiceDeviceEvent(DWORD EventType, LPVOID EventData)
{
    PDEV_BROADCAST_DEVICEINTERFACE dbdi = (PDEV_BROADCAST_DEVICEINTERFACE)EventData;

    switch (EventType)
    {
    case DBT_DEVICEARRIVAL:
        if (dbdi->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE) break;
        
	if (dbdi->dbcc_classguid == KSCATEGORY_AUDIO) MME_AudioInterfaceArrival(dbdi->dbcc_name);
	
	if (dbdi->dbcc_classguid == KSCATEGORY_SYSAUDIO) GFX_SysaudioInterfaceArrival(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_AUDIO) GFX_AudioInterfaceArrival(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_RENDER) GFX_RenderInterfaceArrival(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_CAPTURE) GFX_CaptureInterfaceArrival(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_DATATRANSFORM) GFX_DataTransformInterfaceArrival(dbdi->dbcc_name);
	
	return NO_ERROR;

    case DBT_DEVICEQUERYREMOVEFAILED:
        if (dbdi->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE) break;
        
	if (dbdi->dbcc_classguid == KSCATEGORY_SYSAUDIO) GFX_SysaudioInterfaceArrival(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_AUDIO) GFX_AudioInterfaceArrival(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_RENDER) GFX_RenderInterfaceArrival(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_CAPTURE) GFX_CaptureInterfaceArrival(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_DATATRANSFORM) GFX_DataTransformInterfaceArrival(dbdi->dbcc_name);
	
	return NO_ERROR;

    case DBT_DEVICEQUERYREMOVE:
        if (dbdi->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE) break;
        
	if (dbdi->dbcc_classguid == KSCATEGORY_SYSAUDIO) GFX_SysaudioInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_AUDIO) GFX_AudioInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_RENDER) GFX_RenderInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_CAPTURE) GFX_CaptureInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_DATATRANSFORM) GFX_DataTransformInterfaceRemove(dbdi->dbcc_name);
	
	return NO_ERROR;

    case DBT_DEVICEREMOVEPENDING:
        if (dbdi->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE) break;
        
	if (dbdi->dbcc_classguid == KSCATEGORY_AUDIO) MME_AudioInterfaceRemove(dbdi->dbcc_name);
	
	if (dbdi->dbcc_classguid == KSCATEGORY_SYSAUDIO) GFX_SysaudioInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_AUDIO) GFX_AudioInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_RENDER) GFX_RenderInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_CAPTURE) GFX_CaptureInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_DATATRANSFORM) GFX_DataTransformInterfaceRemove(dbdi->dbcc_name);
	
	return NO_ERROR;

    case DBT_DEVICEREMOVECOMPLETE:
        if (dbdi->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE) break;
        
	if (dbdi->dbcc_classguid == KSCATEGORY_AUDIO) MME_AudioInterfaceRemove(dbdi->dbcc_name);
	
	if (dbdi->dbcc_classguid == KSCATEGORY_SYSAUDIO) GFX_SysaudioInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_AUDIO) GFX_AudioInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_RENDER) GFX_RenderInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_CAPTURE) GFX_CaptureInterfaceRemove(dbdi->dbcc_name);
	if (dbdi->dbcc_classguid == KSCATEGORY_DATATRANSFORM) GFX_DataTransformInterfaceRemove(dbdi->dbcc_name);
	
	return NO_ERROR;

    default:
	return ERROR_CALL_NOT_IMPLEMENTED;
    }

    return ERROR_CALL_NOT_IMPLEMENTED;
}

void ServiceStop(void)
{
    dprintf(TEXT("ServiceStop\n"));
    
    ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 0);
    MyServiceTerminate();
    ReportStatusToSCMgr(SERVICE_STOPPED, NO_ERROR, 0);

    return;
}

VOID ServiceStart(SERVICE_STATUS_HANDLE ssh, DWORD dwArgc, LPTSTR *lpszArgv)
{ 
    DWORD status;
    DWORD specificError;

    // dprintf(TEXT("ServiceStart\n"));

    status = MyServiceInitialization(ssh, dwArgc, lpszArgv, &specificError); 

    if (!status) {
	// dprintf(TEXT("MyServiceInitialization succeeded\n"));
        ReportStatusToSCMgr(SERVICE_RUNNING, NO_ERROR, 0);
    } else {
	dprintf(TEXT("MyServiceInitialization returned status=%d\n"), status);
        ReportStatusToSCMgr(SERVICE_STOPPED, status, 0);
    }

    return; 
} 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t cb)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb);
}

void  __RPC_USER MIDL_user_free( void __RPC_FAR * pv)
{
    HeapFree(hHeap, 0, pv);
}

BOOL DllMain(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{
    BOOL result = TRUE;
    static BOOL fGfxResult = FALSE;
    static BOOL fMmeResult = FALSE;
    
    if (DLL_PROCESS_ATTACH == Reason)
    {
        hHeap = GetProcessHeap();
        result = fGfxResult = GFX_DllProcessAttach();
        if (result) result = fMmeResult = MME_DllProcessAttach();

        if (!result)
        {
            if (fMmeResult) MME_DllProcessDetach();
            if (fGfxResult) GFX_DllProcessDetach();

            fMmeResult = FALSE;
            fGfxResult = FALSE;
        }
            
    }
    else if (DLL_PROCESS_DETACH == Reason)
    {
        if (fMmeResult) MME_DllProcessDetach();
        if (fGfxResult) GFX_DllProcessDetach();

        fMmeResult = FALSE;
        fGfxResult = FALSE;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\audiosrv\ksi.h ===
EXTERN_C
LONG
KsSerializeFilterStateToReg(
    IN HANDLE hKsObject,
    IN HKEY hKey
);

EXTERN_C
LONG
KsUnserializeFilterStateFromReg(
    IN HANDLE hKsObject,
    IN HKEY hKey
);

EXTERN_C
LONG
KsSetAudioGfxRenderTargetDeviceId(
    IN HANDLE hGfx,
    IN PCTSTR DeviceId
);

EXTERN_C
LONG
KsSetAudioGfxCaptureTargetDeviceId(
    IN HANDLE hGfx,
    IN PCTSTR DeviceId
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\audiosrv\ksi.cpp ===
#include <windows.h>
#include <objbase.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
#include "debug.h"
#include "reg.h"
#include "ksi.h"

extern "C" HANDLE hHeap;

const int StrLenGuid = 38; // "{01234567-0123-0123-0123-012345678901}"
__inline void MyStringFromGuid(PTSTR pstr, LPCGUID Guid)
{
    wsprintf(pstr, TEXT("{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
                   Guid->Data1,
                   Guid->Data2,
                   Guid->Data3,
                   Guid->Data4[0], Guid->Data4[1],
                   Guid->Data4[2], Guid->Data4[3], Guid->Data4[4], Guid->Data4[5], Guid->Data4[6], Guid->Data4[7]);
}

LONG KsGetFilterStatePropertySets(IN HANDLE hKsObject, OUT GUID *ppaPropertySets[], OUT int *pcPropertySets)
{
    KSPROPERTY Property;
    ULONG cbData;
    LONG result;

    Property.Set = KSPROPSETID_Audio;
    Property.Id = KSPROPERTY_AUDIO_FILTER_STATE;
    Property.Flags = KSPROPERTY_TYPE_GET;

    if (DeviceIoControl(hKsObject, IOCTL_KS_PROPERTY,
                        &Property, sizeof(Property),
                        NULL, 0,
                        &cbData, NULL))
    {
        // dprintf(TEXT("KsGetFilterStatePropertySets: succeeded, cbData=%d\n"), cbData);
        result = NO_ERROR;
    } else {
        result = GetLastError();
        // dprintf(TEXT("KsGetFilterStatePropertySets: failed getting FilterState property size, LastError=%d\n"), result);
        if (ERROR_MORE_DATA == result) {
            // dprintf(TEXT("KsGetFilterStatePropertySets: note: %d bytes in FilterState\n"), cbData);
            result = NO_ERROR;
        }
    }

    if (NO_ERROR == result) {
        if (cbData > 0) {
            LPGUID paPropertySets;
            paPropertySets = (LPGUID)HeapAlloc(hHeap, 0, cbData);
            if (paPropertySets) {

                Property.Set = KSPROPSETID_Audio;
                Property.Id = KSPROPERTY_AUDIO_FILTER_STATE;
                Property.Flags = KSPROPERTY_TYPE_GET;

                if (DeviceIoControl(hKsObject, IOCTL_KS_PROPERTY,
                                    &Property, sizeof(Property),
                                    paPropertySets, cbData,
                                    &cbData, NULL))
                {
                    *ppaPropertySets = paPropertySets;
                    *pcPropertySets = cbData / sizeof(paPropertySets[0]);
                } else {
                    result = GetLastError();
                    // dprintf(TEXT("KsGetFilterStatePropertySets: failed getting FilterState property, LastError=%d\n"), result);
                }

                if (NO_ERROR != result) {
                    HeapFree(hHeap, 0, paPropertySets);
                }

            } else {
                result = ERROR_OUTOFMEMORY;
            }
        } else {
            *ppaPropertySets = NULL;
            *pcPropertySets = 0;
        }
    }

    return result;
}

LONG KsSerializePropertySetToReg(IN HANDLE hKsObject, IN LPCGUID PropertySet, IN HKEY hKey)
{
    TCHAR strGuid[StrLenGuid+1];
    KSPROPERTY Property;
    ULONG cbData;
    LONG result;

    MyStringFromGuid(strGuid, PropertySet);

    // dprintf(TEXT("KsSerializePropertySetToReg: note: serializing set %s\n"), strGuid);

    Property.Set = *PropertySet;
    Property.Id = 0;
    Property.Flags = KSPROPERTY_TYPE_SERIALIZESET;

    if (DeviceIoControl(hKsObject, IOCTL_KS_PROPERTY,
                        &Property, sizeof(Property),
                        NULL, 0,
                        &cbData, NULL))
    {
        // dprintf(TEXT("KsSerializePropertySetToReg: succeeded, cbData=%d\n"), cbData);
        result = NO_ERROR;
    } else {
        result = GetLastError();
        // dprintf(TEXT("KsSerializePropertySetToReg: failed getting serialized size, LastError=%d\n"), result);
        if (ERROR_MORE_DATA == result) {
            // dprintf(TEXT("KsSerializePropertySetToReg: note: %d bytes to serialize\n"), cbData);
            result = NO_ERROR;
        }
    }

    if (NO_ERROR == result && cbData > 0) {
        PVOID pvData = HeapAlloc(hHeap, 0, cbData);
        if (pvData) {
            Property.Set = *PropertySet;
            Property.Id = 0;
            Property.Flags = KSPROPERTY_TYPE_SERIALIZESET;

            if (DeviceIoControl(hKsObject, IOCTL_KS_PROPERTY,
                                &Property, sizeof(Property),
                                pvData, cbData,
                                &cbData, NULL))
            {
                result = RegSetBinaryValue(hKey, strGuid, (PBYTE)pvData, cbData);
            } else {
                result = GetLastError();
                // dprintf(TEXT("KsSerializePropertySetToReg: failed to serialize, LastError=%d\n"), result);
            }
            HeapFree(hHeap, 0, pvData);
        } else {
            result = ERROR_OUTOFMEMORY;
        }
    }

    return result;
}

LONG KsSerializeFilterStateToReg(IN HANDLE hKsObject, IN HKEY hKey)
{
    LPGUID paPropertySets;
    int cPropertySets;
    LONG result;
    
    result = KsGetFilterStatePropertySets(hKsObject, &paPropertySets, &cPropertySets);
    if (NO_ERROR == result && cPropertySets > 0) {
        int i;
        for (i = 0; i < cPropertySets; i++) {
            KsSerializePropertySetToReg(hKsObject, &paPropertySets[i], hKey);
        }
        HeapFree(hHeap, 0, paPropertySets);
    }

    return result;
}

LONG KsUnserializePropertySetFromReg(IN HANDLE hKsObject, IN LPCGUID PropertySet, IN HKEY hKey)
{
    TCHAR strGuid[StrLenGuid+1];
    KSPROPERTY Property;
    PBYTE pData;
    ULONG cbData;
    LONG result;

    MyStringFromGuid(strGuid, PropertySet);

    // dprintf(TEXT("KsUnserializePropertySetFromReg: note: serializing set %s\n"), strGuid);

    result = RegQueryBinaryValue(hKey, strGuid, (PBYTE*)&pData, &cbData);
    if (NO_ERROR == result) {
        Property.Set = *PropertySet;
        Property.Id = 0;
        Property.Flags = KSPROPERTY_TYPE_UNSERIALIZESET;
    
        if (DeviceIoControl(hKsObject, IOCTL_KS_PROPERTY,
                            &Property, sizeof(Property),
                            pData, cbData,
                            &cbData, NULL))
        {
            // dprintf(TEXT("KsUnserializePropertySetFromReg: succeeded\n"));
            result = NO_ERROR;
        } else {
            result = GetLastError();
            // dprintf(TEXT("KsUnserializePropertySetFromReg: failed to unserialize, LastError=%d\n"), result);
        }

        HeapFree(hHeap, 0, pData);
    }
    return result;
}

LONG KsUnserializeFilterStateFromReg(IN HANDLE hKsObject, IN HKEY hKey)
{
    LPGUID paPropertySets;
    int cPropertySets;
    LONG result;
    
    result = KsGetFilterStatePropertySets(hKsObject, &paPropertySets, &cPropertySets);
    if (NO_ERROR == result && cPropertySets > 0) {
        int i;
        for (i = 0; i < cPropertySets; i++) {
            KsUnserializePropertySetFromReg(hKsObject, &paPropertySets[i], hKey);
        }
        HeapFree(hHeap, 0, paPropertySets);
    }

    return result;
}

LONG KsSetAudioGfxXxxTargetDeviceId(IN HANDLE hGfx, IN ULONG PropertyId, IN PCTSTR DeviceId)
{
    KSPROPERTY Property;
    ULONG cbData;
    LONG result;

    ASSERT(hGfx);
    ASSERT(!IsBadStringPtr(DeviceId, (UINT_PTR)(-1)));
    ASSERT(lstrlen(DeviceId));

    Property.Set = KSPROPSETID_AudioGfx;
    Property.Id = PropertyId;
    Property.Flags = KSPROPERTY_TYPE_SET;

    cbData = (lstrlen(DeviceId) + 1) * sizeof(DeviceId[0]);

    if (DeviceIoControl(hGfx, IOCTL_KS_PROPERTY,
                        &Property, sizeof(Property),
                        (LPVOID)DeviceId, cbData,
                        &cbData, NULL))
    {
        result = NO_ERROR;
    } else {
        result = GetLastError();
        dprintf(TEXT("KsSetAudioGfxXxxTargetDeviceId: failed, LastError=%d\n"), result);
    }

    return result;
}

LONG KsSetAudioGfxRenderTargetDeviceId(IN HANDLE hGfx, IN PCTSTR DeviceId)
{
    return KsSetAudioGfxXxxTargetDeviceId(hGfx, KSPROPERTY_AUDIOGFX_RENDERTARGETDEVICEID, DeviceId);
}

LONG KsSetAudioGfxCaptureTargetDeviceId(IN HANDLE hGfx, IN PCTSTR DeviceId)
{
    return KsSetAudioGfxXxxTargetDeviceId(hGfx, KSPROPERTY_AUDIOGFX_CAPTURETARGETDEVICEID, DeviceId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\audiosrv\mme.h ===
/* mme.h
 * External scope definitions for mme.cpp
 * Created by FrankYe on 2/14/2001
 * Copyright (c) 2001-2001 Microsoft Corporation
 */

void MME_AudioInterfaceArrival(PCTSTR DeviceInterface);
void MME_AudioInterfaceRemove(PCTSTR DeviceInterface);
LONG MME_ServiceStart(void);
BOOL MME_DllProcessAttach(void);
void MME_DllProcessDetach(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\audiosrv\mme.cpp ===
/* mme.cpp
 * Handles pnp, etc. for MME APIs
 * Created by FrankYe on 2/14/2001
 * Copyright (c) 2001-2001 Microsoft Corporation
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <regstr.h>
#include <mmsystem.h>
#include <mmsysp.h>
#include <ks.h>
#include <ksmedia.h>
#include <setupapi.h>

#include "debug.h"
#include "reg.h"
#include "service.h"
#include "audiosrv.h"

//=============================================================================
//===   file scope constants   ===
//=============================================================================
#define REGSTR_VAL_SETUPPREFERREDAUDIODEVICES      TEXT("SetupPreferredAudioDevices")
#define REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT TEXT("SetupPreferredAudioDevicesCount")

#define PNPINFOSIZE     (256 * 1024)

//=============================================================================
//===   file scope globals   ===
//=============================================================================
RTL_RESOURCE PnpInfoResource;
BOOL         gfPnpInfoResource = FALSE;
HANDLE       hPnpInfo = NULL;
PMMPNPINFO   pPnpInfo = NULL;

//=============================================================================
//===   security helpers   ===
//=============================================================================

PSECURITY_DESCRIPTOR BuildSecurityDescriptor(DWORD AccessMask)
{
    PSECURITY_DESCRIPTOR pSd;
    PSID pSidSystem;
    PSID pSidEveryone;
    PACL pDacl;
    ULONG cbDacl;
    BOOL fSuccess;
    BOOL f;

    SID_IDENTIFIER_AUTHORITY AuthorityNt = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY AuthorityWorld = SECURITY_WORLD_SID_AUTHORITY;

    fSuccess = FALSE;

    pSd = HeapAlloc(hHeap, 0, SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (pSd)
    {
	if (InitializeSecurityDescriptor(pSd, SECURITY_DESCRIPTOR_REVISION))
	{
	    if (AllocateAndInitializeSid(&AuthorityNt, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &pSidSystem))
	    {
		ASSERT(IsValidSid(pSidSystem));
		if (AllocateAndInitializeSid(&AuthorityWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pSidEveryone))
		{
		    ASSERT(IsValidSid(pSidEveryone));
		    cbDacl = sizeof(ACL) +
			     2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
			     GetLengthSid(pSidSystem) +
			     GetLengthSid(pSidEveryone);

		    pDacl = (PACL)HeapAlloc(hHeap, 0, cbDacl);
		    if (pDacl) {
			if (InitializeAcl(pDacl, cbDacl, ACL_REVISION))
			{
			    if (AddAccessAllowedAce(pDacl, ACL_REVISION, GENERIC_ALL, pSidSystem))
			    {
				if (AddAccessAllowedAce(pDacl, ACL_REVISION, AccessMask, pSidEveryone))
				{
				    if (SetSecurityDescriptorDacl(pSd, TRUE, pDacl, FALSE))
				    {
					fSuccess = TRUE;
				    } else {
					dprintf(TEXT("BuildSD: SetSecurityDescriptorDacl failed\n"));
				    }
				} else {
				    dprintf(TEXT("BuildSD: AddAccessAlloweAce for Everyone failed\n"));
				}
			    } else {
				dprintf(TEXT("BuildSD: AddAccessAllowedAce for System failed\n"));
			    }
			} else {
			    dprintf(TEXT("BuildSD: InitializeAcl failed\n"));
			}

			if (!fSuccess) {
			    f = HeapFree(hHeap, 0, pDacl);
			    ASSERT(f);
			}
		    }
		    FreeSid(pSidEveryone);
		} else {
		    dprintf(TEXT("BuildSD: AllocateAndInitizeSid failed for Everyone\n"));
		}
		FreeSid(pSidSystem);
	    } else {
		dprintf(TEXT("BuildSD: AllocateAndInitizeSid failed for System\n"));
	    }
	} else {
	    dprintf(TEXT("BuildSD: InitializeSecurityDescriptor failed\n"));
	}

	if (!fSuccess) {
	    f = HeapFree(hHeap, 0, pSd);
	    ASSERT(f);
	}
    }

    return fSuccess ? pSd : NULL;
}

void DestroySecurityDescriptor(PSECURITY_DESCRIPTOR pSd)
{
    PACL pDacl;
    BOOL fDaclPresent;
    BOOL fDaclDefaulted;
    BOOL f;

    if (GetSecurityDescriptorDacl(pSd, &fDaclPresent, &pDacl, &fDaclDefaulted))
    {
	if (fDaclPresent)
	{
	    f = HeapFree(hHeap, 0, pDacl);
	    ASSERT(f);
	}
    } else {
	dprintf(TEXT("DestroySD: GetSecurityDescriptorDacl failed\n"));
    }

    f = HeapFree(hHeap, 0, pSd);
    ASSERT(f);

    return;
}

//=============================================================================
//===      ===
//=============================================================================



//--------------------------------------------------------------------------;
//
// PTSTR BroadcastWinmmDeviceChange
//
// Arguments:
//
// Return value:
//
// History:
//	11/9/98		FrankYe		Created
//      2/15/2001       FrankYe         Moved from winmm to audiosrv
//
//--------------------------------------------------------------------------;
void BroadcastWinmmDeviceChange(void)
{
    static UINT uWinmmDeviceChange = 0;

    if (!uWinmmDeviceChange) {
	uWinmmDeviceChange = RegisterWindowMessage(WINMMDEVICECHANGEMSGSTRING);
	// dprintf(TEXT("BroadcastWinmmDeviceChange: WINMMDEVICECHANGEMSG = %d\n"), uWinmmDeviceChange);
	if (!uWinmmDeviceChange) {
	    dprintf(TEXT("BroadcastWinmmDeviceChange: RegisterWindowMessage failed!\n"));
	}
    }

    if (uWinmmDeviceChange) {
	DWORD dwRecipients = BSM_APPLICATIONS | BSM_ALLDESKTOPS;
	long result;

	// dprintf(TEXT("BroadcastWinmmDeviceChange: BroadcastSystemMessage\n"));
	result = BroadcastSystemMessage(BSF_POSTMESSAGE, &dwRecipients,
					uWinmmDeviceChange, 0, 0);
	if (result < 0) {
	    dprintf(TEXT("BroadcastWinmmDeviceChange: BroadcastSystemMessage failed\n"));
	}
    }
    
    return;
}

//--------------------------------------------------------------------------;
//
// PTSTR MakeRendererDeviceInstanceIdFromDeviceInterface
//
// Arguments:
//
// Return value:
//
// History:
//	11/9/98		FrankYe		Created
//
//--------------------------------------------------------------------------;
PTSTR MakeRendererDeviceInstanceIdFromDeviceInterface(PWSTR DeviceInterface)
{
    PTSTR DeviceInstanceId;
    HDEVINFO hdi;
    DWORD dwLastError;

    // dprintf(TEXT("MRDIIFDI: DeviceInterface=%ls\n"), DeviceInterface);
    DeviceInstanceId = NULL;
    hdi = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (INVALID_HANDLE_VALUE != hdi)
    {
	SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;

	// dprintf(TEXT("MRDIIFDI: Created empty DeviceInfoList\n"));
	DeviceInterfaceData.cbSize = sizeof(DeviceInterfaceData);
	if (SetupDiOpenDeviceInterface(hdi, DeviceInterface, 0,
					  &DeviceInterfaceData))
	{
	    SP_DEVINFO_DATA DeviceInfoData;
	    DWORD cbDeviceInterfaceDetail;

	    // dprintf(TEXT("MRDIIFDI: Opened DeviceInterface\n"));
	    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
	    if (SetupDiGetDeviceInterfaceDetail(hdi, &DeviceInterfaceData, NULL, 0, &cbDeviceInterfaceDetail, &DeviceInfoData) ||
		(ERROR_INSUFFICIENT_BUFFER == GetLastError()))
	    {
		DWORD cchDeviceInstanceId;

	        // dprintf(TEXT("MRDIIFDI: Got DeviceInfoData\n"));
		if (SetupDiGetDeviceInstanceId(hdi, &DeviceInfoData, NULL, 0, &cchDeviceInstanceId) ||
		    ERROR_INSUFFICIENT_BUFFER == GetLastError())
		{
		    // dprintf(TEXT("MRDIIFDI: DeviceInstanceId is %d characters\n"), cchDeviceInstanceId);
		    DeviceInstanceId = (PTSTR)HeapAlloc(hHeap, 0, cchDeviceInstanceId * sizeof(DeviceInstanceId[0]));
		    if (DeviceInstanceId)
		    {
			// dprintf(TEXT("MRDIIFDI: Allocated storage for DeviceInstanceId\n"));
			if (SetupDiGetDeviceInstanceId(hdi, &DeviceInfoData,
			    DeviceInstanceId,
			    cchDeviceInstanceId, NULL))
			{
			    // dprintf(TEXT("MRDIIFDI: DeviceInstanceId=%ls\n"), DeviceInstanceId);
			} else {
			    BOOL f;
			    dwLastError = GetLastError();
			    dprintf(TEXT("MRDIIFDI: Couldn't query DeviceInstanceId, LastError=%d\n"), dwLastError);
			    f = HeapFree(hHeap, 0, DeviceInstanceId);
                DeviceInstanceId = NULL;
			    ASSERT(f);
			}
		    } else {
			dprintf(TEXT("MRDIIFDI: Could not allocate storage for DeviceInstanceId\n"));
		    }
		} else {
		    dwLastError = GetLastError();
		    dprintf(TEXT("MRDIIFDI: Couldn't query size of DeviceInstanceId, LastError=%d\n"), dwLastError);
		}
	    } else {
		dwLastError = GetLastError();
		dprintf(TEXT("MRDIIFDI: SetupDiGetDeviceInterfaceDetail failed LastError=%d\n"), dwLastError);
	    }
	} else {
	    dwLastError = GetLastError();
	    dprintf(TEXT("MRDIIFDI: SetupDiOpenDeviceInterface failed, LastError=%d\n"), dwLastError);
	}

	if (!SetupDiDestroyDeviceInfoList(hdi))
	{
	    dwLastError = GetLastError();
	    dprintf(TEXT("MRDIIFDI: SetupDiDestroyDeviceInfoList failed, LastError=%d\n"), dwLastError);
	}
    } else {
	dwLastError = GetLastError();
	dprintf(TEXT("MRDIIFDI: SetupDiCreateDeviceInfoList failed, LastError=%d\n"), dwLastError);
    }
    return DeviceInstanceId;
}




//--------------------------------------------------------------------------;
//
// MigrageNewDeviceInterfaceSetup
//
// Arguments:
//
// Return value:
//
// History:
//	1/19/99		FrankYe		Created
//
//--------------------------------------------------------------------------;
void MigrateNewDeviceInterfaceSetup(PMMDEVICEINTERFACEINFO pdii, DWORD CurrentSetupCount)
{
    HDEVINFO hdi;
    DWORD dwLastError;
    DWORD SetupCount;

    SetupCount = 0;

    hdi = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (INVALID_HANDLE_VALUE != hdi)
    {
	SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;

	DeviceInterfaceData.cbSize = sizeof(DeviceInterfaceData);
	if (SetupDiOpenDeviceInterface(hdi, pdii->szName, 0, &DeviceInterfaceData))
	{
	    HKEY hkeyDeviceInterface;

	    hkeyDeviceInterface = SetupDiCreateDeviceInterfaceRegKeyW(hdi, &DeviceInterfaceData, 0, KEY_SET_VALUE | KEY_QUERY_VALUE, NULL, NULL);
	    if (INVALID_HANDLE_VALUE != hkeyDeviceInterface)
	    {
		LONG result;

		result = RegQueryDwordValue(hkeyDeviceInterface, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, &SetupCount);
		if ((ERROR_SUCCESS != result) || (SetupCount < CurrentSetupCount))
		{
		    SetupCount = CurrentSetupCount;
		    if (ERROR_SUCCESS == RegSetDwordValue(hkeyDeviceInterface, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, SetupCount))
		    {
			// dprintf(TEXT("MNDIS: Success\n"));
		    } else {
			dwLastError = GetLastError();
			dprintf(TEXT("MNDIS: RegSetValueEx failed, LastError=%d\n"), dwLastError);
		    }
		}

		result = RegCloseKey(hkeyDeviceInterface);
		ASSERT(ERROR_SUCCESS == result);
	    } else {
		dwLastError = GetLastError();
		dprintf(TEXT("MNDIS: SetupDiCreateDeviceInterfaceRegKey failed, LastError=%d\n"), dwLastError);
	    }
	} else {
	    dwLastError = GetLastError();
	    dprintf(TEXT("MRDIIFDI: SetupDiOpenDeviceInterface failed, LastError=%d\n"), dwLastError);
	}

	if (!SetupDiDestroyDeviceInfoList(hdi))
	{
	    dwLastError = GetLastError();
	    dprintf(TEXT("MRDIIFDI: SetupDiDestroyDeviceInfoList failed, LastError=%d\n"), dwLastError);
	}
    } else {
	dwLastError = GetLastError();
	dprintf(TEXT("MRDIIFDI: SetupDiCreateDeviceInfoList failed, LastError=%d\n"), dwLastError);
    }

    pdii->SetupPreferredAudioCount = SetupCount;
    return;
}


//--------------------------------------------------------------------------;
//
// MigrateNewDeviceInstanceSetup
//
// Arguments:
//
// Return value:
//
// History:
//	11/9/98		FrankYe		Created
//
//--------------------------------------------------------------------------;
void MigrateNewDeviceInstanceSetup(PTSTR DeviceInstanceId, PDWORD pSetupCountOut)
{
    HDEVINFO hdi;
    DWORD dwLastError;

    *pSetupCountOut = 0;
    
    hdi = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (INVALID_HANDLE_VALUE != hdi)
    {
	SP_DEVINFO_DATA DeviceInfoData;

	// dprintf(TEXT("MNDS: Created empty DeviceInfoList\n"));
	DeviceInfoData.cbSize = sizeof(DeviceInfoData);
	if (SetupDiOpenDeviceInfoW(hdi, DeviceInstanceId, NULL, 0, &DeviceInfoData))
	{
	    HKEY hkeyDriver;

	    hkeyDriver = SetupDiOpenDevRegKey(hdi, &DeviceInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_QUERY_VALUE | KEY_SET_VALUE);
	    if (INVALID_HANDLE_VALUE != hkeyDriver) {
	    	HKEY hkeyMmeDrivers;
	    	
		dwLastError = RegOpenKeyEx(hkeyDriver, TEXT("Drivers"), 0, KEY_QUERY_VALUE, &hkeyMmeDrivers);
		if (ERROR_SUCCESS == dwLastError)
		{
		
	    	    DWORD fNewInstall;
		    BOOL  fSetupPreferredAudioDevices;
		    DWORD cbfSetupPreferredAudioDevices;
	            DWORD SetupCount;

	            // Read the driver's existing setup count.  If it doesn't exist
	            // then this is a new install.
		    dwLastError = RegQueryDwordValue(hkeyDriver, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, &SetupCount);
		    if (ERROR_SUCCESS == dwLastError) {
		        fNewInstall = FALSE;
		    } else if (ERROR_FILE_NOT_FOUND == dwLastError) {
		        fNewInstall = TRUE;
		        SetupCount = 0;
		        dwLastError = ERROR_SUCCESS;
		    } else {
		        fNewInstall = FALSE;
		        SetupCount = 0;
		    }

                    if (ERROR_SUCCESS == dwLastError)
                    {
		        // Read the driver's SetupPreferredAudioDevices flag.
		        cbfSetupPreferredAudioDevices = sizeof(fSetupPreferredAudioDevices);
		        dwLastError = RegQueryValueEx(hkeyDriver, REGSTR_VAL_SETUPPREFERREDAUDIODEVICES, NULL, NULL, (PBYTE)&fSetupPreferredAudioDevices, &cbfSetupPreferredAudioDevices);
		        if (ERROR_FILE_NOT_FOUND == dwLastError) {
		            fSetupPreferredAudioDevices = FALSE;
		            dwLastError = ERROR_SUCCESS;
		        }
		
        	        // If this is a new install AND the driver .inf set the
        	        // fSetupPreferredAudioDevices flag, then let's try to
        	        // increment the machine setupcount and write the driver
        	        // setupcount.
        	        if ((ERROR_SUCCESS == dwLastError) && fNewInstall && fSetupPreferredAudioDevices)
        	        {
        		    HKEY hkeySetupPreferredAudioDevices;
        
        		    dwLastError = RegCreateKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_MEDIARESOURCES TEXT("\\") REGSTR_VAL_SETUPPREFERREDAUDIODEVICES, &hkeySetupPreferredAudioDevices);
        		    if (ERROR_SUCCESS == dwLastError)
        		    {
        		        dwLastError = RegQueryDwordValue(hkeySetupPreferredAudioDevices, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, &SetupCount);
        		        if (ERROR_FILE_NOT_FOUND == dwLastError) {
        			    SetupCount = 0;
        			    dwLastError = ERROR_SUCCESS;
        		        }
        
        		        if (ERROR_SUCCESS == dwLastError)
        		        {
        			    SetupCount++;
        			    dwLastError = RegSetDwordValue(hkeySetupPreferredAudioDevices, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, SetupCount);
        			    if (ERROR_SUCCESS != dwLastError) dprintf(TEXT("MNDIS: Couldn't set count\n"));
        		        }
        		    
        		        RegCloseKey(hkeySetupPreferredAudioDevices);
        		    } else {
        		        dprintf(TEXT("MNDIS: Couldn't create hklm\\...\\SetupPreferredAudioDevices\n"));
        		    }
        	        }
        	    
    	                if (ERROR_SUCCESS == dwLastError) {
    		            // We've successfully read, incremented, and written the
    		            // setup version to HKLM, or we've done nothing because we
    		            // didn't have to.
    		            if (fNewInstall) RegSetDwordValue(hkeyDriver, REGSTR_VAL_SETUPPREFERREDAUDIODEVICESCOUNT, SetupCount);
    		            if (fSetupPreferredAudioDevices) RegDeleteValue(hkeyDriver, REGSTR_VAL_SETUPPREFERREDAUDIODEVICES);
    		        }
    	                
                    }

		    // Return the SetupCount for the driver
		    *pSetupCountOut = SetupCount;
		
    		    RegCloseKey(hkeyMmeDrivers);
    		    
                }
		
		RegCloseKey(hkeyDriver);
    
	    } else {
		dwLastError = GetLastError();
		dprintf(TEXT("MNDS: SetupDiCreateDevRegKey failed, LastError=%d\n"), dwLastError);
	    }
	} else {
	    dwLastError = GetLastError();
	    dprintf(TEXT("MNDS: SetupDiOpenDeviceInfo failed, LastError=%d\n"), dwLastError);
	}

	if (!SetupDiDestroyDeviceInfoList(hdi))
	{
	    dwLastError = GetLastError();
	    dprintf(TEXT("MNDS: SetupDiDestroyDeviceInfoList failed, LastError=%d\n"), dwLastError);
	}
    } else {
	dwLastError = GetLastError();
	dprintf(TEXT("MNDS: SetupDiCreateDeviceInfoList failed, LastError=%d\n"), dwLastError);
    }
    return;
}

//------------------------------------------------------------------------------
//
//
//	MigrateAutoSetupPreferredAudio
//
//
//------------------------------------------------------------------------------
void MigrateAutoSetupPreferredAudio(PMMDEVICEINTERFACEINFO pdii)
{
    PTSTR pstrRendererDeviceInstanceId;
    DWORD SetupCount;

    SetupCount = 0;
    pstrRendererDeviceInstanceId = MakeRendererDeviceInstanceIdFromDeviceInterface(pdii->szName);

    if (pstrRendererDeviceInstanceId) {
	BOOL f;
	MigrateNewDeviceInstanceSetup(pstrRendererDeviceInstanceId, &SetupCount);
	f = HeapFree(hHeap, 0, pstrRendererDeviceInstanceId);
	ASSERT(f);
    }

    MigrateNewDeviceInterfaceSetup(pdii, SetupCount);
    
    return;
}


PMMDEVICEINTERFACEINFO pnpServerInstallDevice
(
    PCTSTR  pszDeviceInterface,
    BOOL    fRemove
)
{
    PMMDEVICEINTERFACEINFO  pdii;
    PWSTR                   pszDev;
    UINT                    ii;

    if (NULL == pPnpInfo)
    {
        dprintf(TEXT("pnpServerInstallDevice called at bad time\n"));
        ASSERT(FALSE);

        return NULL;
    }

    pdii = (PMMDEVICEINTERFACEINFO)&(pPnpInfo[1]);

    pdii = (PMMDEVICEINTERFACEINFO)PAD_POINTER(pdii);

    for (ii = pPnpInfo->cDevInterfaces; ii; ii--)
    {
        //  Searching for the device interface...

        pszDev = (PWSTR)(&(pdii->szName[0]));

        if (0 == lstrcmpi(pszDev, pszDeviceInterface))
        {
            break;
        }

        pdii = (PMMDEVICEINTERFACEINFO)(pszDev + lstrlenW(pszDev) + 1);
        pdii = (PMMDEVICEINTERFACEINFO)PAD_POINTER(pdii);
    }

    //  Getting the current settings...

    if (0 == ii)
    {
	PMMDEVICEINTERFACEINFO pdiiNext;
	SIZE_T sizePnpInfo;

	//  Does not exist, create it, first ensuring there is enough room

	pdiiNext = (PMMDEVICEINTERFACEINFO)(pdii->szName + ((lstrlenW(pszDeviceInterface) + 1)));
	pdiiNext = (PMMDEVICEINTERFACEINFO)PAD_POINTER(pdiiNext);
	sizePnpInfo = ((PBYTE)pdiiNext) - ((PBYTE)pPnpInfo);
	if (sizePnpInfo < PNPINFOSIZE)
	{
	    // dprintf(TEXT("pnpServerInstallDevice: note: sizePnpInfo = %p\n", sizePnpInfo);

	    pdii->cPnpEvents = 0;
	    pdii->fdwInfo    = 0L;

	    pszDev = (PWSTR)(&(pdii->szName[0]));
	    lstrcpy(pszDev, pszDeviceInterface);

	    pPnpInfo->cDevInterfaces++;
            pPnpInfo->cbSize = (DWORD)sizePnpInfo;
	} else {
	    dprintf(TEXT("pnpServerInstallDevice RAN OUT OF PNPINO STORAGE!!!\n"));
	    pdii = NULL;
	}
    }
    else
    {
        //  Already exists, increment the event count.
        pdii->cPnpEvents++;
    }

    //  Set or clear the "removed" bit.
    if (pdii)
    {
	if (fRemove)
	{
	    pdii->fdwInfo |= MMDEVICEINFO_REMOVED;
	 // dprintf("pnpServerInstallDevice removed [%ls]\n", pszDeviceInterface);
	}
	else
	{
	    pdii->fdwInfo &= (~MMDEVICEINFO_REMOVED);
	 // dprintf("pnpServerInstallDevice added [%ls]\n", pszDeviceInterface);
	}

    }

    return pdii;
}


BOOL PnpInfoEnum
(
    void
)
{
    UINT                                cDevs = 0;
    HDEVINFO                            hDevInfo;
    BOOL                                fEnum;
    DWORD                               ii, dw;
    DWORD                               cbSize;
    GUID                                guidClass = KSCATEGORY_AUDIO;
    SP_DEVICE_INTERFACE_DATA            did;
    SP_DEVINFO_DATA                     DevInfoData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pdidd;

    cbSize = 300 * sizeof(TCHAR) + sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

    pdidd = (PSP_DEVICE_INTERFACE_DETAIL_DATA)HeapAlloc(hHeap, 0, cbSize);

    if (NULL == pdidd)
    {
        HeapFree(hHeap, 0, pdidd);
        return FALSE;
    }

    pdidd->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

    hDevInfo = SetupDiGetClassDevs(
                &guidClass,
                NULL,
                NULL,
                DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);

    if (INVALID_HANDLE_VALUE == hDevInfo)
    {
        dprintf(TEXT("SetupDiGetClasDevs failed [0x%08lx].\n"), GetLastError());
        HeapFree(hHeap, 0, pdidd);
        return FALSE;
    }

    ZeroMemory(&did, sizeof(did));

    did.cbSize = sizeof(did);

    ZeroMemory(&DevInfoData, sizeof(SP_DEVINFO_DATA));

    DevInfoData.cbSize    = sizeof(SP_DEVINFO_DATA);
    DevInfoData.ClassGuid = KSCATEGORY_AUDIO;

    for (ii = 0; ;ii++, cDevs++)
    {
	PMMDEVICEINTERFACEINFO pdii;
	
        fEnum = SetupDiEnumDeviceInterfaces(
                    hDevInfo,
                    NULL,
                    &guidClass,
                    ii,
                    &did);

        if (!fEnum)
        {
            break;
        }

        dw = 0;

        fEnum = SetupDiGetDeviceInterfaceDetail(
                    hDevInfo,
                    &did,
                    pdidd,
                    cbSize,
                    &dw,
                    &DevInfoData);

        if (!fEnum)
        {
            dprintf(TEXT("SetupDiGetDeviceInterfaceDetail failed (0x%08lx).\n"), GetLastError());
            break;
        }

        // dprintf(TEXT("PnpInfoEnum: Enumerated[%ls]\n"), pdidd->DevicePath);

	pdii = pnpServerInstallDevice(pdidd->DevicePath, FALSE);
	if (pdii) MigrateAutoSetupPreferredAudio(pdii);
    }

    if (!SetupDiDestroyDeviceInfoList(hDevInfo))
    {
	ASSERT(!"wdmEnumerateInstalledDevices: SetupDiDestroyDeviceInfoList failed.");
    }

    HeapFree(hHeap, 0, pdidd);
    SetLastError(ERROR_SUCCESS);

    return TRUE;

} // PnpInfoEnum()


BOOL InitializePnpInfo
(
    void
)
{
    SECURITY_ATTRIBUTES sa;
    PSECURITY_DESCRIPTOR pSd;
    BOOL result;

    ASSERT(!gfPnpInfoResource);
    ASSERT(!hPnpInfo);
    ASSERT(!pPnpInfo);

    result = FALSE;
    
    __try {
        RtlInitializeResource(&PnpInfoResource);
        gfPnpInfoResource = TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        gfPnpInfoResource = FALSE;;
    }
    
    if (!gfPnpInfoResource) return FALSE;
    
    pSd = BuildSecurityDescriptor(FILE_MAP_READ);
    if (pSd)
    {
        sa.nLength              = sizeof(SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = pSd;
        sa.bInheritHandle       = FALSE;

        hPnpInfo = CreateFileMapping(GetCurrentProcess(), &sa, PAGE_READWRITE, 0, PNPINFOSIZE, MMGLOBALPNPINFONAME);

        DestroySecurityDescriptor(pSd);

        if (hPnpInfo)
        {
            pPnpInfo = (PMMPNPINFO)MapViewOfFile(hPnpInfo, FILE_MAP_WRITE, 0, 0, 0);
            if (pPnpInfo)
            {
            	ZeroMemory(pPnpInfo, PNPINFOSIZE);
                pPnpInfo->cbSize = sizeof(MMPNPINFO);
                pPnpInfo->cPnpEvents = 0;

                result = TRUE;

            } else {
                dprintf(TEXT("InitializePnpInfo: MapViewOfFile failed!\n"));
            }
        } else {
            dprintf(TEXT("InitializePnpInfo: CreateFileMappingFailed!\n"));
        }
    } else {
        dprintf(TEXT("InitializePnpInfo: BuildSecurityDescriptor failed!\n"));
    }

    if (!result)
    {
    	if (pPnpInfo) UnmapViewOfFile(pPnpInfo);
    	if (hPnpInfo) CloseHandle(hPnpInfo);
    	if (gfPnpInfoResource) RtlDeleteResource(&PnpInfoResource);
    	pPnpInfo = NULL;
    	hPnpInfo = NULL;
    	gfPnpInfoResource = FALSE;
    }

    return result;
} // InitializePnpInfo()

void DeletePnpInfo(void)
{
    ASSERT(gfPnpInfoResource);
    ASSERT(hPnpInfo);
    ASSERT(pPnpInfo);

    UnmapViewOfFile(pPnpInfo);
    CloseHandle(hPnpInfo);
    RtlDeleteResource(&PnpInfoResource);
    
    pPnpInfo = NULL;
    hPnpInfo = NULL;
    gfPnpInfoResource = FALSE;
    
    return;
}

//=============================================================================
//===   rpc functions   ===
//=============================================================================

long s_wdmDriverOpenDrvRegKey(IN DWORD dwProcessId, IN LPCTSTR DeviceInterface, IN ULONG samDesired, OUT RHANDLE *phkeyClient)
{
    HDEVINFO hdi;
    HKEY hkey;
    RPC_STATUS status;

    // We impersonate the client while calling setupapi so that we are sure
    // the client actually has access to open the driver reg key

    status = RpcImpersonateClient(NULL);
    if (status) return status;
    
    hdi = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (INVALID_HANDLE_VALUE != hdi)
    {
	SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;

	DeviceInterfaceData.cbSize = sizeof(DeviceInterfaceData);
	if (SetupDiOpenDeviceInterface(hdi, DeviceInterface, 0,
					  &DeviceInterfaceData))
	{
	    SP_DEVINFO_DATA DeviceInfoData;
	    DWORD cbDeviceInterfaceDetail;

	    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
	    if (SetupDiGetDeviceInterfaceDetail(hdi, &DeviceInterfaceData, NULL, 0, &cbDeviceInterfaceDetail, &DeviceInfoData) ||
		(ERROR_INSUFFICIENT_BUFFER == GetLastError()))
	    {
                hkey = SetupDiOpenDevRegKey(hdi, &DeviceInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, samDesired);
                if (INVALID_HANDLE_VALUE != hkey) 
                {
                    status = ERROR_SUCCESS;
                } else {
                    status = GetLastError();
                    dprintf(TEXT("s_wdmDriverOpenDrvRegKey: SetupDiOpenDevRegKey failed, Error=%d\n"), status);
                }
            } else {
                status = GetLastError();
                dprintf(TEXT("s_wdmDriverOpenDrvRegKey: SetupDiGetDeviceInterfaceDetail failed, Error=%d\n"), status);
            }
        } else {
            status = GetLastError();
            dprintf(TEXT("s_wdmDriverOpenDrvRegKey: SetupDiOpenDeviceInterface failed, Error=%d\n"), status);
        }

        SetupDiDestroyDeviceInfoList(hdi);
    } else {
        status = GetLastError();
        dprintf(TEXT("s_wdmDriverOpenDrvRegKey: SetupDiCreateDeviceInfoList failed, Error=%d\n"), status);
    }

    // We stop impersonating here because the remaining operations
    // should not depend on the client's privileges.
    
    RpcRevertToSelf();

    if (ERROR_SUCCESS == status)
    {
        HANDLE hClientProcess;

        hClientProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwProcessId);
        if (hClientProcess)
        {
            HANDLE hkeyClient;

            if (DuplicateHandle(GetCurrentProcess(), hkey, hClientProcess, &hkeyClient, 0, FALSE, DUPLICATE_SAME_ACCESS))
            {
                // dprintf(TEXT("s_wdmDriverOpenDrvRegKey hkeyClient=%p\n"), hkeyClient);
                *phkeyClient = (RHANDLE)hkeyClient;
            } else {
                status = GetLastError();
                dprintf(TEXT("s_wdmDriverOpenDrvRegKey: DuplicateHandle failed, Error=%d\n"), status);
            }
            CloseHandle(hClientProcess);
        } else {
            status = GetLastError();
            dprintf(TEXT("s_wdmDriverOpenDrvRegKey: OpenProcess failed, Error=%d\n"), status);
        }

        RegCloseKey(hkey);
    }

    return status;
}



void s_winmmAdvisePreferredDeviceChange(void)
{
    // dprintf(TEXT("s_winmmAdvisePreferredDeviceChange\n"));
    ASSERT(pPnpInfo);
    InterlockedIncrement(&pPnpInfo->cPreferredDeviceChanges);
    BroadcastWinmmDeviceChange();
    return;
}

long s_winmmGetPnpInfo(OUT LONG *pcbPnpInfo, OUT BYTE **ppPnpInfoOut)
{
    static BOOL fEnumDone = FALSE;
    
    PBYTE pPnpInfoOut;
    LONG result;

    // dprintf(TEXT("s_winmmGetPnpInfo\n"));
    
    ASSERT(pPnpInfo);

    RtlAcquireResourceShared(&PnpInfoResource, TRUE);
    pPnpInfoOut = (PBYTE)HeapAlloc(hHeap, 0, pPnpInfo->cbSize);
    if (pPnpInfoOut)
    {
    	CopyMemory(pPnpInfoOut, pPnpInfo, pPnpInfo->cbSize);
        *pcbPnpInfo = pPnpInfo->cbSize;
        *ppPnpInfoOut = pPnpInfoOut;
    	result = NO_ERROR;
    } else {
        // ISSUE-2001/02/15-FrankYe Do we need to zero the out params?
        result = ERROR_OUTOFMEMORY;
    }
    RtlReleaseResource(&PnpInfoResource);
    return result;
}

//=============================================================================
//===   pnp interface handlers   ===
//=============================================================================
void MME_AudioInterfaceArrival(PCTSTR DeviceInterface)
{
    PMMDEVICEINTERFACEINFO pdii;
    // dprintf(TEXT("MME_AudioInterfaceArrival\n"));
    RtlAcquireResourceExclusive(&PnpInfoResource, TRUE);
    pdii = pnpServerInstallDevice(DeviceInterface, FALSE);
    if (pdii) MigrateAutoSetupPreferredAudio(pdii);
    InterlockedIncrement(&pPnpInfo->cPnpEvents);
    InterlockedIncrement(&pPnpInfo->cPreferredDeviceChanges);
    RtlReleaseResource(&PnpInfoResource);
    if (pdii) BroadcastWinmmDeviceChange();
    return;
}

void MME_AudioInterfaceRemove(PCTSTR DeviceInterface)
{
    PMMDEVICEINTERFACEINFO pdii;
    // dprintf(TEXT("MME_AudioInterfaceRemove\n"));
    RtlAcquireResourceExclusive(&PnpInfoResource, TRUE);
    pdii = pnpServerInstallDevice(DeviceInterface, TRUE);
    InterlockedIncrement(&pPnpInfo->cPnpEvents);
    InterlockedIncrement(&pPnpInfo->cPreferredDeviceChanges);
    RtlReleaseResource(&PnpInfoResource);
    if (pdii) BroadcastWinmmDeviceChange();
    return;
}

LONG MME_ServiceStart(void)
{
    ASSERT(pPnpInfo);
    // dprintf(TEXT("MME_ServiceStart\n"));
    RtlAcquireResourceExclusive(&PnpInfoResource, TRUE);
    if (!PnpInfoEnum()) dprintf(TEXT("MME_ServiceStart: PnpInfoEnum failed!\n"));
    InterlockedIncrement(&pPnpInfo->cPnpEvents);
    RtlReleaseResource(&PnpInfoResource);
    return NO_ERROR;
}

//=============================================================================
//===   DLL attach/detach   ===
//=============================================================================

BOOL MME_DllProcessAttach(void)
{
    return InitializePnpInfo();
}

void MME_DllProcessDetach(void)
{
    return DeletePnpInfo();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\audiosrv\list.h ===
//
// Lists have internal serialization so that most functions operate as atomic
// operations.  However, the results of some functions are transient (i.e.
// immediately out-of-date)  unless the caller explicitly locks the list using
// the Lock/Unlock methods.  These functions are GetCount, GetHeadPosition,
// GetNext.  Also, it is the caller's responsibility to serialize access to a
// POSITION.  The internal  serialization only ensures that two simultaneus
// AddTail calls will not make the list internally inconsistent, and nor will
// two simultaneous RemoveAt calls on _different_ POSITIONs.
//
// List elements with NULL object pointers are skipped by list iteration
// functions GetHeadPosition and GetNext.
//

typedef struct _CListElement {
	struct _CListElement *Next;
	struct _CListElement *Prev;
	const void *Object;
} CListElement, *POSITION;

template <class TYPE, class ARG_TYPE> class CList {
public:
	CList();
	~CList();

        POSITION AddHead(ARG_TYPE newElement);
	POSITION AddTail(ARG_TYPE newElement);
	TYPE     GetAt(POSITION position);
	int      GetCount(void) const;
	POSITION GetHeadPosition(void) const;
	TYPE     GetNext(POSITION& rPosition); // return *Position++
        LONG     Initialize(void);
	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);
	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
        BOOL     IsEmpty(void) const;
        void     Lock(void);
        void     MoveBefore(POSITION posTarget, POSITION posMove);
	void     RemoveAll(void);
	void     RemoveAt(POSITION position);
	void     SetAt(POSITION pos, ARG_TYPE newElement);
        void     Unlock(void);

private:
        BOOL m_Initialized;
        CRITICAL_SECTION m_CriticalSection;
	int m_Count;
	CListElement m_Sentinel;
};

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(void)
{
    m_Initialized = FALSE;
    m_Count = 0;
    m_Sentinel.Next = &m_Sentinel;
    m_Sentinel.Prev = &m_Sentinel;
    m_Sentinel.Object = &m_Sentinel;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList(void)
{
    if (m_Initialized) {
	RemoveAll();
	ASSERT(m_Sentinel.Next = &m_Sentinel);
	ASSERT(m_Sentinel.Prev = &m_Sentinel);
        DeleteCriticalSection(&m_CriticalSection);
        m_Initialized = FALSE;
    }
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
    POSITION pos;

    ASSERT(m_Initialized);

    pos = new CListElement;
    if (pos) {
        Lock();

        pos->Next = m_Sentinel.Next;
        pos->Prev = &m_Sentinel;

        pos->Prev->Next = pos;
        pos->Next->Prev = pos;

        pos->Object = newElement;

        m_Count++;

        Unlock();
    }
    return pos;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
    POSITION pos;

    ASSERT(m_Initialized);

    pos = new CListElement;
    if (pos) {
        Lock();

        pos->Next = &m_Sentinel;
        pos->Prev = m_Sentinel.Prev;

        pos->Prev->Next = pos;
        pos->Next->Prev = pos;

        pos->Object = newElement;

        m_Count++;

        Unlock();
    }
    return pos;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::GetAt(POSITION pos)
{
    ASSERT(m_Initialized);
    return (TYPE)pos->Object;
}

template<class TYPE, class ARG_TYPE>
int CList<TYPE, ARG_TYPE>::GetCount(void) const
{
    ASSERT(m_Initialized);
    return m_Count;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition(void) const
{
    POSITION pos;
    ASSERT(m_Initialized);
    pos = m_Sentinel.Next;
    // Skip NULL elements
    while (NULL == pos->Object) pos = pos->Next;
    if (pos == &m_Sentinel) return NULL;
    return pos;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPos)
{
    ASSERT(m_Initialized);
    
    TYPE Object = (TYPE)rPos->Object;
    
    rPos = rPos->Next;
    // Skip NULL elements.
    while (NULL == rPos->Object) rPos = rPos->Next;
    if (rPos == &m_Sentinel) rPos = NULL;

    return Object;
}

template<class TYPE, class ARG_TYPE>
LONG CList<TYPE, ARG_TYPE>::Initialize(void)
{
    LONG result;

    ASSERT(!m_Initialized);

    __try {
	InitializeCriticalSection(&m_CriticalSection);
	result = NO_ERROR;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
	result = ERROR_OUTOFMEMORY;
    }

    m_Initialized = (NO_ERROR == result);

    return result;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{
    ASSERT(m_Initialized);
    
    if (position == NULL)
    {
    	// insert after nothing -> head of the list
    	position = &m_Sentinel;
    }

    // Insert it after position
    CListElement* newPos = new CListElement;
    if (newPos)
    {
	Lock();
	    
	newPos->Next = position->Next;
	newPos->Prev = position;
	
	newPos->Next->Prev = newPos;
	newPos->Prev->Next = newPos;

        newPos->Object = newElement;

        m_Count++;

        Unlock();
    }
    return newPos;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{
    ASSERT(m_Initialized);
    
    if (position == NULL)
    {
        // insert before nothing -> tail of list
        position = &m_Sentinel;
    }

    // Insert it before position
    CListElement* newPos = new CListElement;
    if (newPos)
    {
	Lock();
	    
	newPos->Next = position;
	newPos->Prev = position->Prev;
	
	newPos->Next->Prev = newPos;
	newPos->Prev->Next = newPos;

        newPos->Object = newElement;

        m_Count++;

        Unlock();
    }
    return newPos;
}

template<class TYPE, class ARG_TYPE>
BOOL CList<TYPE, ARG_TYPE>::IsEmpty(void) const
{
    ASSERT(m_Initialized);
    return (0 == m_Count);
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::Lock(void)
{
    EnterCriticalSection(&m_CriticalSection);
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::MoveBefore(POSITION posTarget, POSITION posMove)
{
    ASSERT(m_Initialized);

    if (posTarget == posMove) return;

    if (posTarget == NULL)	
    {
        // Move before nothing -> tail of list
        posTarget = &m_Sentinel;
    }
    
    // first remove from list
    posMove->Prev->Next = posMove->Next;
    posMove->Next->Prev = posMove->Prev;

    // Move it before posTarget
    posMove->Next = posTarget;
    posMove->Prev = posTarget->Prev;
    
    posMove->Next->Prev = posMove;
    posMove->Prev->Next = posMove;
    
    return;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll(void)
{
    POSITION pos;
    ASSERT(m_Initialized);
    while (pos = GetHeadPosition()) RemoveAt(pos);
    return;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION pos)
{
    ASSERT(m_Initialized);
    ASSERT(m_Count > 0);
    Lock();
    pos->Prev->Next = pos->Next;
    pos->Next->Prev = pos->Prev;
    m_Count--;
    Unlock();
    delete pos;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
{
    ASSERT(m_Initialized);
    ASSERT(m_Count > 0);
    Lock();
    pos->Object = newElement;
    Unlock();
    return;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::Unlock(void)
{
    LeaveCriticalSection(&m_CriticalSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\audiosrv\reg.cpp ===
#include <windows.h>
#include "debug.h"
#include "reg.h"

extern "C" HANDLE hHeap;

//------------------------------------------------------------------------------
//
//
//	Registry helpers
//
//
//------------------------------------------------------------------------------

LONG RegQueryBinaryValue(IN HKEY hkey, IN PCTSTR pValueName, OUT PBYTE *ppValue, OUT ULONG *pcbValue)
{
    LONG result;
    DWORD typeValue;
    DWORD cbValue = 0;
    BOOL f;
    
    result = RegQueryValueEx(hkey, pValueName, 0, &typeValue, NULL, &cbValue);
    if (ERROR_SUCCESS == result)
    {
	if (REG_BINARY == typeValue)
	{
            PBYTE pValue;
	    pValue = (PBYTE)HeapAlloc(hHeap, 0, cbValue);
	    if (pValue)
	    {
		result = RegQueryValueEx(hkey, pValueName, 0, &typeValue, (PBYTE)pValue, &cbValue);
		if (ERROR_SUCCESS == result)
		{
                    if (REG_BINARY == typeValue)
                    {
                        *ppValue = pValue;
                        *pcbValue = cbValue;
                    } else {
                        result = ERROR_FILE_NOT_FOUND;
                        f = HeapFree(hHeap, 0, pValue);
                        ASSERT(f);
                    }
		} else {
		    f = HeapFree(hHeap, 0, pValue);
		    ASSERT(f);
		}
	    } else {
		result = ERROR_OUTOFMEMORY;
	    }
	} else {
	    result = ERROR_FILE_NOT_FOUND;
	}
    }
    return result;
}

LONG RegQuerySzValue(HKEY hkey, PCTSTR pValueName, PTSTR *ppstrValue)
{
    LONG result;
    DWORD typeValue;
    DWORD cbstrValue = 0;
    BOOL f;
    
    result = RegQueryValueEx(hkey, pValueName, 0, &typeValue, NULL, &cbstrValue);
    if (ERROR_SUCCESS == result)
    {
	if (REG_SZ == typeValue)
	{
	    PTSTR pstrValue;
	    pstrValue = (PTSTR)HeapAlloc(hHeap, 0, cbstrValue);
	    if (pstrValue)
	    {
		result = RegQueryValueEx(hkey, pValueName, 0, &typeValue, (PBYTE)pstrValue, &cbstrValue);
		if (ERROR_SUCCESS == result)
		{
                    if (REG_SZ == typeValue)
                    {
                        *ppstrValue = pstrValue;
                    } else {
                        result = ERROR_FILE_NOT_FOUND;
                        f = HeapFree(hHeap, 0, pstrValue);
                        ASSERT(f);
                    }
		} else {
		    f = HeapFree(hHeap, 0, pstrValue);
		    ASSERT(f);
		}
	    } else {
		result = ERROR_OUTOFMEMORY;
	    }
	} else {
	    result = ERROR_FILE_NOT_FOUND;
	}
    }
    return result;
}

LONG RegQueryMultiSzValue(HKEY hkey, PCTSTR pValueName, PTSTR *ppstrValue)
{
    LONG result;
    DWORD typeValue;
    DWORD cbstrValue = 0;
    BOOL f;
    
    result = RegQueryValueEx(hkey, pValueName, 0, &typeValue, NULL, &cbstrValue);
    if (ERROR_SUCCESS == result)
    {
	if (REG_MULTI_SZ == typeValue)
	{
	    PTSTR pstrValue;
	    pstrValue = (PTSTR)HeapAlloc(hHeap, 0, cbstrValue);
	    if (pstrValue)
	    {
		result = RegQueryValueEx(hkey, pValueName, 0, &typeValue, (PBYTE)pstrValue, &cbstrValue);
		if (ERROR_SUCCESS == result)
		{
                    if (REG_MULTI_SZ == typeValue)
                    {
                        *ppstrValue = pstrValue;
                    } else {
                        result = ERROR_FILE_NOT_FOUND;
                        f = HeapFree(hHeap, 0, pstrValue);
                        ASSERT(f);
                    }
		} else {
		    f = HeapFree(hHeap, 0, pstrValue);
		    ASSERT(f);
		}
	    } else {
		result = ERROR_OUTOFMEMORY;
	    }
	} else {
	    result = ERROR_FILE_NOT_FOUND;
	}
    }
    return result;
}

LONG RegQueryDwordValue(HKEY hkey, PCTSTR pValueName, PDWORD pdwValue)
{
    DWORD cbdwValue;
    LONG result;

    cbdwValue = sizeof(*pdwValue);
    result = RegQueryValueEx(hkey, pValueName, 0, NULL, (PBYTE)pdwValue, &cbdwValue);
    return result;
}

LONG RegSetSzValue(HKEY hkey, PCTSTR pValueName, PCTSTR pstrValue)
{
    DWORD cbstrValue = (lstrlen(pstrValue) + 1) * sizeof(pstrValue[0]);
    return RegSetValueEx(hkey, pValueName, 0, REG_SZ, (PBYTE)pstrValue, cbstrValue);
}

LONG RegSetMultiSzValue(HKEY hkey, PCTSTR pValueName, PCTSTR pstrValue)
{
	PCTSTR pstr;
	DWORD cch;
	DWORD cchValue;
	DWORD cbValue;

	pstr = pstrValue;
	cchValue = 0;

	do {
		cch = lstrlen(pstr);
		cchValue += cch+1;
		pstr +=  cch+1;
	} while (cch > 0);

	cbValue = cchValue * sizeof(TCHAR);

	return RegSetValueEx(hkey, pValueName, 0, REG_MULTI_SZ, (PBYTE)pstrValue, cbValue);
}

LONG RegSetBinaryValue(IN HKEY hkey, IN PCTSTR pValueName, IN PBYTE pValue, IN ULONG cbValue)
{
    return RegSetValueEx(hkey, pValueName, 0, REG_BINARY, (PBYTE)pValue, cbValue);
}

LONG RegSetDwordValue(HKEY hkey, PCTSTR pValueName, DWORD dwValue)
{
    return RegSetValueEx(hkey, pValueName, 0, REG_DWORD, (PBYTE)&dwValue, sizeof(dwValue));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\audiosrv\reg.h ===
LONG RegQueryBinaryValue(IN HKEY hkey, IN PCTSTR pValueName, OUT PBYTE *ppData, OUT ULONG *pcbData);
LONG RegQueryDwordValue(IN HKEY hkey, IN PCTSTR pValueName, OUT DWORD *pdwValue);
LONG RegQueryMultiSzValue(IN HKEY hkey, IN PCTSTR pValueName, OUT PTSTR *ppstrValue);
LONG RegQuerySzValue(IN HKEY hkey, IN PCTSTR pValueName, OUT PTSTR *ppstrValue);
LONG RegSetBinaryValue(IN HKEY hkey, IN PCTSTR pValueName, IN PBYTE pValue, IN ULONG cbValue);
LONG RegSetDwordValue(IN HKEY hkey, IN PCTSTR pValueName, IN DWORD dwValue);
LONG RegSetMultiSzValue(IN HKEY hkey, IN PCTSTR pValueName, IN PCTSTR pstrValue);
LONG RegSetSzValue(IN HKEY hkey, IN PCTSTR pValueName, IN PCTSTR pstrValue);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\audiosrv\sad.cpp ===
#include <windows.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmediap.h>
#include "debug.h"
#include "sad.h"

extern "C" HANDLE hHeap;

LONG SadAddGfxToZoneGraph(HANDLE hSad, HANDLE hGfx, PCTSTR GfxFriendlyName, PCTSTR ZoneFactoryDi, ULONG Type, ULONG Order)
{
    KSPROPERTY Property;
    PSYSAUDIO_GFX pSadGfx;
    ULONG cbSadGfx;
    PTSTR pZoneFactoryDi;
    ULONG cbZoneFactoryDi;
    PTSTR pGfxFriendlyName;
    ULONG cbGfxFriendlyName;
    DWORD cbBytesReturned;
    LONG lresult;
    
    ASSERT(!IsBadStringPtr(GfxFriendlyName, 5000));
    ASSERT(!IsBadStringPtr(ZoneFactoryDi, 5000));
    
    Property.Set = KSPROPSETID_Sysaudio;
    Property.Id = KSPROPERTY_SYSAUDIO_ADDREMOVE_GFX;
    Property.Flags = KSPROPERTY_TYPE_SET;
    
    cbGfxFriendlyName = (lstrlen(GfxFriendlyName)+1) * sizeof(GfxFriendlyName[0]);
    cbZoneFactoryDi = (lstrlen(ZoneFactoryDi)+1) * sizeof(ZoneFactoryDi[0]);
    cbSadGfx = sizeof(*pSadGfx) + cbGfxFriendlyName + cbZoneFactoryDi;
    
    pSadGfx = (PSYSAUDIO_GFX)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cbSadGfx);
    if (pSadGfx) {
        pSadGfx->Enable = TRUE;
        pSadGfx->hGfx = hGfx;
        pSadGfx->ulOrder = Order;
        pSadGfx->ulType = Type;
        pSadGfx->ulFlags = 0;
        
        pZoneFactoryDi = (PTSTR)(pSadGfx+1);
        lstrcpy(pZoneFactoryDi, ZoneFactoryDi);
        pSadGfx->ulDeviceNameOffset = (ULONG)((PBYTE)pZoneFactoryDi - (PBYTE)pSadGfx);
        
        pGfxFriendlyName = pZoneFactoryDi + lstrlen(pZoneFactoryDi) + 1;
        lstrcpy(pGfxFriendlyName, GfxFriendlyName);
        pSadGfx->ulFriendlyNameOffset = (ULONG)((PBYTE)pGfxFriendlyName - (PBYTE)pSadGfx);
        
        ASSERT((PBYTE)(pGfxFriendlyName + lstrlen(pGfxFriendlyName) + 1) == ((PBYTE)pSadGfx) + cbSadGfx);
        
        if (DeviceIoControl(hSad, IOCTL_KS_PROPERTY,
                            &Property, sizeof(Property),
                            pSadGfx, cbSadGfx,
                            &cbBytesReturned, NULL))
        {
            lresult = ERROR_SUCCESS;
        } else {
            // ISSUE-200/09/21-FrankYe Shoule we get other data regarding failure?
            lresult = GetLastError();
        }
                                  
        HeapFree(hHeap, 0, pSadGfx);
        
        
    } else {
        lresult = ERROR_OUTOFMEMORY;
    }
    
    return lresult;
}

LONG SadRemoveGfxFromZoneGraph(HANDLE hSad, HANDLE hGfx, PCTSTR GfxFriendlyName, PCTSTR ZoneFactoryDi, ULONG Type, ULONG Order)
{
    KSPROPERTY Property;
    PSYSAUDIO_GFX pSadGfx;
    ULONG cbSadGfx;
    PTSTR pZoneFactoryDi;
    ULONG cbZoneFactoryDi;
    PTSTR pGfxFriendlyName;
    ULONG cbGfxFriendlyName;
    ULONG cbBytesReturned;
    LONG lresult;
    
    ASSERT(!IsBadStringPtr(GfxFriendlyName, 5000));
    ASSERT(!IsBadStringPtr(ZoneFactoryDi, 5000));
    
    Property.Set = KSPROPSETID_Sysaudio;
    Property.Id = KSPROPERTY_SYSAUDIO_ADDREMOVE_GFX;
    Property.Flags = KSPROPERTY_TYPE_SET;
    
    cbGfxFriendlyName = (lstrlen(GfxFriendlyName)+1) * sizeof(GfxFriendlyName[0]);
    cbZoneFactoryDi = (lstrlen(ZoneFactoryDi)+1) * sizeof(ZoneFactoryDi[0]);
    cbSadGfx = sizeof(*pSadGfx) + cbGfxFriendlyName + cbZoneFactoryDi;
    
    pSadGfx = (PSYSAUDIO_GFX)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cbSadGfx);
    if (pSadGfx) {
        pSadGfx->Enable = FALSE;
        pSadGfx->hGfx = hGfx;
        pSadGfx->ulOrder = Order;
        pSadGfx->ulType = Type;
        pSadGfx->ulFlags = 0;
        
        pZoneFactoryDi = (PTSTR)(pSadGfx+1);
        lstrcpy(pZoneFactoryDi, ZoneFactoryDi);
        pSadGfx->ulDeviceNameOffset = (ULONG)((PBYTE)pZoneFactoryDi - (PBYTE)pSadGfx);
        
        pGfxFriendlyName = pZoneFactoryDi + lstrlen(pZoneFactoryDi) + 1;
        lstrcpy(pGfxFriendlyName, GfxFriendlyName);
        pSadGfx->ulFriendlyNameOffset = (ULONG)((PBYTE)pGfxFriendlyName - (PBYTE)pSadGfx);
        
        ASSERT((PBYTE)(pGfxFriendlyName + lstrlen(pGfxFriendlyName) + 1) == ((PBYTE)pSadGfx) + cbSadGfx);
        
        if (DeviceIoControl(hSad, IOCTL_KS_PROPERTY,
                            &Property, sizeof(Property),
                            pSadGfx, cbSadGfx,
                            &cbBytesReturned, NULL))
        {
            lresult = ERROR_SUCCESS;
        } else {
            // ISSUE-200/09/21-FrankYe Shoule we get other data regarding failure?
            lresult = GetLastError();
        }
                                  
        HeapFree(hHeap, 0, pSadGfx);
        
        
    } else {
        lresult = ERROR_OUTOFMEMORY;
    }
    
    return lresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\audiosrv\service.h ===
/****************************************************************************\
*
*  Module Name : service.h
*
*  Copyright (c) 1991-2000 Microsoft Corporation
*
\****************************************************************************/

#ifndef _SERVICE_H
#define _SERVICE_H


#ifdef __cplusplus
extern "C" {
#endif


//////////////////////////////////////////////////////////////////////////////
////
// internal name of the service
#define SZSERVICENAME        "AudioSrv"
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// todo: ServiceStart()must be defined by in your code.
////       The service should use ReportStatusToSCMgr to indicate
////       progress.  This routine must also be used by StartService()
////       to report to the SCM when the service is running.
////
////       If a ServiceStop procedure is going to take longer than
////       3 seconds to execute, it should spawn a thread to
////       execute the stop code, and return.  Otherwise, the
////       ServiceControlManager will believe that the service has
////       stopped responding
////
VOID  ServiceStart(SERVICE_STATUS_HANDLE ssh, DWORD dwArgc, LPTSTR *lpszArgv);
DWORD ServiceDeviceEvent(DWORD dwEventType, LPVOID lpEventData);
DWORD ServiceSessionChange(DWORD dwEventType, LPVOID lpEventData);
VOID  ServiceStop();
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// The following are procedures which
//// may be useful to call within the above procedures,
//// but require no implementation by the user.
//// They are implemented in service.c

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);
extern SERVICE_STATUS ssStatus;       // current status of the service

//////////////////////////////////////////////////////////////////////////////
////
// Process heap, initialized in DllMain.
EXTERN_C HANDLE hHeap;

//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\audiosrv\service.c ===
/*---------------------------------------------------------------------------
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Copyright (C) 1993-2001.  Microsoft Corporation.  All rights reserved.

MODULE:   service.c

PURPOSE:  Implements functions required by all Windows NT services

FUNCTIONS:
  DllMain(PVOID hModule, ULONG Reason, PCONTEXT pContext)
  ServiceCtrl(DWORD dwCtrlCode, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext);
  ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv);

---------------------------------------------------------------------------*/

#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>
#include "debug.h"
#include "service.h"

// internal variables
SERVICE_STATUS          ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   sshStatusHandle;
DWORD                   dwErr = 0;

// internal function prototypes
DWORD WINAPI ServiceCtrl(DWORD dwCtrlCode, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext);
VOID  WINAPI ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv);

//
//  FUNCTION: ServiceMain
//
//  PURPOSE: To perform actual initialization of the service
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This routine performs the service initialization and then calls
//    the user defined ServiceStart() routine to perform majority
//    of the work.
//
void WINAPI ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv)
{
    dprintf(TEXT("pid=%d\n"), GetCurrentProcessId());

   // register our service control handler:
   //
   sshStatusHandle = RegisterServiceCtrlHandlerEx(TEXT(SZSERVICENAME), ServiceCtrl, NULL);

   if (sshStatusHandle)
   {
       // SERVICE_STATUS members that don't change
       //
       ssStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
       ssStatus.dwServiceSpecificExitCode = 0;
    
    
       // report the status to the service control manager.
       // ISSUE-2000/10/17-FrankYe reduce the wait hint
       if (ReportStatusToSCMgr(SERVICE_START_PENDING, // service state
                               NO_ERROR,              // exit code
                               60000))                // wait hint
       {
           ServiceStart( sshStatusHandle, dwArgc, lpszArgv );
       }
   }
   return;
}



//
//  FUNCTION: ServiceCtrl
//
//  PURPOSE: This function is called by the SCM whenever
//           ControlService() is called on this service.
//
//  PARAMETERS:
//    dwCtrlCode  - The requested control code.
//    dwEventType - The type of event that has occurred. 
//    lpEventData - Additional device information, if required. The
//                   format of this data depends on the value of the dwControl
//                   and dwEventType parameters.
//    lpContext   - The user-defined data passed from
//                   RegisterServiceCtrlHandlerEx.
// 
//  RETURN VALUE:
//    The return value for this function depends on the control code received.
//
//  COMMENTS:
//
DWORD WINAPI ServiceCtrl(DWORD dwCtrlCode, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext)
{
   // Handle the requested control code.
   //
   switch (dwCtrlCode)
   {
   // Stop the service.
   //
   // SERVICE_STOP_PENDING should be reported before
   // setting the Stop Event - hServerStopEvent - in
   // ServiceStop().  This avoids a race condition
   // which may result in a 1053 - The Service did not respond...
   // error.
   case SERVICE_CONTROL_STOP:
      ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 0);
      ServiceStop();
      return NO_ERROR;

   case SERVICE_CONTROL_DEVICEEVENT:
       return ServiceDeviceEvent(dwEventType, lpEventData);

   case SERVICE_CONTROL_INTERROGATE:
       ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);
       return NO_ERROR;
      
   case SERVICE_CONTROL_SESSIONCHANGE:
      return ServiceSessionChange(dwEventType, lpEventData);

      // invalid control code
   default:
       return ERROR_CALL_NOT_IMPLEMENTED;
   }

   return ERROR_CALL_NOT_IMPLEMENTED;
}



//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID AddToMessageLog(LPTSTR lpszMsg)
{
   TCHAR   szMsg[256];
   HANDLE  hEventSource;
   LPTSTR  lpszStrings[2];


  dwErr = GetLastError();

  // Use event logging to log the error.
  //
  hEventSource = RegisterEventSource(NULL, TEXT(SZSERVICENAME));

  wsprintf(szMsg, TEXT("%s error: %d"), TEXT(SZSERVICENAME), dwErr);
  lpszStrings[0] = szMsg;
  lpszStrings[1] = lpszMsg;

  if (hEventSource != NULL)
  {
     ReportEvent(hEventSource, // handle of event source
                 EVENTLOG_ERROR_TYPE,  // event type
                 0,                    // event category
                 0,                    // event ID
                 NULL,                 // current user's SID
                 2,                    // strings in lpszStrings
                 0,                    // no bytes of raw data
                 lpszStrings,          // array of error strings
                 NULL);                // no raw data

     (VOID) DeregisterEventSource(hEventSource);
  }
}

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
//  COMMENTS:
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                         DWORD dwWin32ExitCode,
                         DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;
    
    
    // Accept only session notifications (no pause, stop, etc)
    ssStatus.dwControlsAccepted = SERVICE_ACCEPT_SESSIONCHANGE;
                                                   
    ssStatus.dwCurrentState = dwCurrentState;
    ssStatus.dwWin32ExitCode = dwWin32ExitCode;
    ssStatus.dwWaitHint = dwWaitHint;
    
    if ( ( dwCurrentState == SERVICE_RUNNING ) ||
       ( dwCurrentState == SERVICE_STOPPED ) )
        ssStatus.dwCheckPoint = 0;
    else
        ssStatus.dwCheckPoint = dwCheckPoint++;
    
    
    // Report the status of the service to the service control manager.
    //
    if (!(fResult = SetServiceStatus( sshStatusHandle, &ssStatus)))
    {
        AddToMessageLog(TEXT("SetServiceStatus"));
    }
    
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\audiosrv\ts.h ===
typedef struct {
    HANDLE Event;
    DWORD SessionId;
} SESSIONNOTIFICATION, *PSESSIONNOTIFICATION;

typedef CList<PSESSIONNOTIFICATION, PSESSIONNOTIFICATION>   CListSessionNotifications;

extern CListSessionNotifications *gplistSessionNotifications;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\audiosrv\sad.h ===
// ISSUE-2000/09/21-FrankYe What is friendly name for?
EXTERN_C
LONG
SadAddGfxToZoneGraph
(
    HANDLE hSad,
    HANDLE hGfx,
    PCTSTR GfxFriendlyName,
    PCTSTR ZoneFactoryDi,
    ULONG  Type,
    ULONG  Order
);

EXTERN_C
LONG
SadRemoveGfxFromZoneGraph
(
    HANDLE hSad,
    HANDLE hGfx,
    PCTSTR GfxFriendlyName,
    PCTSTR ZoneFactoryDi,
    ULONG  Type,
    ULONG  Order
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\avicap.h ===
/****************************************************************************
 *
 *   avicap.h
 * 
 *   Main include file.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992 - 1994 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#ifndef _INC_AVICAP
#define _INC_AVICAP

#ifndef VFWAPI
#ifdef WIN32
    #define VFWAPI  _stdcall
    #define VFWAPIV _stdcall
#else
    #define VFWAPI  FAR PASCAL
    #define VFWAPIV FAR CDECL
#endif
#endif
      
#ifdef __cplusplus
#define AVICapSM ::SendMessage  /* SendMessage in C++*/
#else
#define AVICapSM SendMessage    /* SendMessage in C */
#endif  /* __cplusplus */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifndef RC_INVOKED

// ------------------------------------------------------------------
//  Window Messages  WM_CAP... which can be sent to an AVICAP window
// ------------------------------------------------------------------

// Defines start of the message range
#define WM_CAP_START                    WM_USER

#define WM_CAP_GET_CAPSTREAMPTR         (WM_CAP_START+  1)

#define WM_CAP_SET_CALLBACK_ERROR       (WM_CAP_START+  2)
#define WM_CAP_SET_CALLBACK_STATUS      (WM_CAP_START+  3)
#define WM_CAP_SET_CALLBACK_YIELD       (WM_CAP_START+  4)
#define WM_CAP_SET_CALLBACK_FRAME       (WM_CAP_START+  5)
#define WM_CAP_SET_CALLBACK_VIDEOSTREAM (WM_CAP_START+  6)
#define WM_CAP_SET_CALLBACK_WAVESTREAM  (WM_CAP_START+  7)
#define WM_CAP_GET_USER_DATA            (WM_CAP_START+  8)
#define WM_CAP_SET_USER_DATA            (WM_CAP_START+  9)
    
#define WM_CAP_DRIVER_CONNECT           (WM_CAP_START+  10)
#define WM_CAP_DRIVER_DISCONNECT        (WM_CAP_START+  11)
#define WM_CAP_DRIVER_GET_NAME          (WM_CAP_START+  12) 
#define WM_CAP_DRIVER_GET_VERSION       (WM_CAP_START+  13) 
#define WM_CAP_DRIVER_GET_CAPS          (WM_CAP_START+  14) 

#define WM_CAP_FILE_SET_CAPTURE_FILE    (WM_CAP_START+  20)
#define WM_CAP_FILE_GET_CAPTURE_FILE    (WM_CAP_START+  21)
#define WM_CAP_FILE_ALLOCATE            (WM_CAP_START+  22)
#define WM_CAP_FILE_SAVEAS              (WM_CAP_START+  23)
#define WM_CAP_FILE_SET_INFOCHUNK       (WM_CAP_START+  24)
#define WM_CAP_FILE_SAVEDIB             (WM_CAP_START+  25)

#define WM_CAP_EDIT_COPY                (WM_CAP_START+  30)

#define WM_CAP_SET_AUDIOFORMAT          (WM_CAP_START+  35) 
#define WM_CAP_GET_AUDIOFORMAT          (WM_CAP_START+  36)

#define WM_CAP_DLG_VIDEOFORMAT          (WM_CAP_START+  41)
#define WM_CAP_DLG_VIDEOSOURCE          (WM_CAP_START+  42)
#define WM_CAP_DLG_VIDEODISPLAY         (WM_CAP_START+  43)
#define WM_CAP_GET_VIDEOFORMAT          (WM_CAP_START+  44)
#define WM_CAP_SET_VIDEOFORMAT          (WM_CAP_START+  45)
#define WM_CAP_DLG_VIDEOCOMPRESSION     (WM_CAP_START+  46)

#define WM_CAP_SET_PREVIEW              (WM_CAP_START+  50)
#define WM_CAP_SET_OVERLAY              (WM_CAP_START+  51)
#define WM_CAP_SET_PREVIEWRATE          (WM_CAP_START+  52)
#define WM_CAP_SET_SCALE                (WM_CAP_START+  53)
#define WM_CAP_GET_STATUS               (WM_CAP_START+  54)
#define WM_CAP_SET_SCROLL               (WM_CAP_START+  55)

#define WM_CAP_GRAB_FRAME               (WM_CAP_START+  60)
#define WM_CAP_GRAB_FRAME_NOSTOP        (WM_CAP_START+  61)

#define WM_CAP_SEQUENCE                 (WM_CAP_START+  62)
#define WM_CAP_SEQUENCE_NOFILE          (WM_CAP_START+  63)
#define WM_CAP_SET_SEQUENCE_SETUP       (WM_CAP_START+  64)
#define WM_CAP_GET_SEQUENCE_SETUP       (WM_CAP_START+  65)
#define WM_CAP_SET_MCI_DEVICE           (WM_CAP_START+  66)
#define WM_CAP_GET_MCI_DEVICE           (WM_CAP_START+  67)
#define WM_CAP_STOP                     (WM_CAP_START+  68)
#define WM_CAP_ABORT                    (WM_CAP_START+  69)

#define WM_CAP_SINGLE_FRAME_OPEN        (WM_CAP_START+  70) 
#define WM_CAP_SINGLE_FRAME_CLOSE       (WM_CAP_START+  71) 
#define WM_CAP_SINGLE_FRAME             (WM_CAP_START+  72) 

#define WM_CAP_PAL_OPEN                 (WM_CAP_START+  80) 
#define WM_CAP_PAL_SAVE                 (WM_CAP_START+  81) 
#define WM_CAP_PAL_PASTE                (WM_CAP_START+  82)
#define WM_CAP_PAL_AUTOCREATE           (WM_CAP_START+  83)
#define WM_CAP_PAL_MANUALCREATE         (WM_CAP_START+  84)

// Following added post VFW 1.1
#define WM_CAP_SET_CALLBACK_CAPCONTROL  (WM_CAP_START+  85)

// Defines end of the message range
#define WM_CAP_END                      WM_CAP_SET_CALLBACK_CAPCONTROL
                                        
// ------------------------------------------------------------------
//  Message crackers for above
// ------------------------------------------------------------------

#define capSetCallbackOnError(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_ERROR, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnStatus(hwnd, fpProc)       ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_STATUS, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnYield(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_YIELD, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnFrame(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_FRAME, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnVideoStream(hwnd, fpProc)  ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_VIDEOSTREAM, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnWaveStream(hwnd, fpProc)   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_WAVESTREAM, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnCapControl(hwnd, fpProc)   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_CAPCONTROL, 0, (LPARAM)(LPVOID)(fpProc)))

#define capSetUserData(hwnd, lUser)                ((BOOL)AVICapSM(hwnd, WM_CAP_SET_USER_DATA, 0, (LPARAM)lUser))
#define capGetUserData(hwnd)                       (AVICapSM(hwnd, WM_CAP_GET_USER_DATA, 0, 0))

#define capDriverConnect(hwnd, i)                  ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_CONNECT, (WPARAM)(i), 0L))
#define capDriverDisconnect(hwnd)                  ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_DISCONNECT, (WPARAM)0, 0L))
#define capDriverGetName(hwnd, szName, wSize)      ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_NAME, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capDriverGetVersion(hwnd, szVer, wSize)    ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_VERSION, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPSTR)(szVer)))
#define capDriverGetCaps(hwnd, s, wSize)           ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_CAPS, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPDRIVERCAPS)(s)))

#define capFileSetCaptureFile(hwnd, szName)        ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SET_CAPTURE_FILE, 0, (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capFileGetCaptureFile(hwnd, szName, wSize) ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_GET_CAPTURE_FILE, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capFileAlloc(hwnd, dwSize)                 ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_ALLOCATE, 0, (LPARAM)(DWORD)(dwSize)))
#define capFileSaveAs(hwnd, szName)                ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SAVEAS, 0, (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capFileSetInfoChunk(hwnd, lpInfoChunk)     ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SET_INFOCHUNK, (WPARAM)0, (LPARAM)(LPCAPINFOCHUNK)(lpInfoChunk)))
#define capFileSaveDIB(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SAVEDIB, 0, (LPARAM)(LPVOID)(LPSTR)(szName)))

#define capEditCopy(hwnd)                          ((BOOL)AVICapSM(hwnd, WM_CAP_EDIT_COPY, 0, 0L))

#define capSetAudioFormat(hwnd, s, wSize)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_AUDIOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPWAVEFORMATEX)(s)))
#define capGetAudioFormat(hwnd, s, wSize)          ((DWORD)AVICapSM(hwnd, WM_CAP_GET_AUDIOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPWAVEFORMATEX)(s)))
#define capGetAudioFormatSize(hwnd)                ((DWORD)AVICapSM(hwnd, WM_CAP_GET_AUDIOFORMAT, (WPARAM)0, (LPARAM) NULL))

#define capDlgVideoFormat(hwnd)                    ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOFORMAT, 0, 0L))
#define capDlgVideoSource(hwnd)                    ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOSOURCE, 0, 0L))
#define capDlgVideoDisplay(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEODISPLAY, 0, 0L))
#define capDlgVideoCompression(hwnd)               ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOCOMPRESSION, 0, 0L))

#define capGetVideoFormat(hwnd, s, wSize)          ((DWORD)AVICapSM(hwnd, WM_CAP_GET_VIDEOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(s)))
#define capGetVideoFormatSize(hwnd)                ((DWORD)AVICapSM(hwnd, WM_CAP_GET_VIDEOFORMAT, 0, NULL))
#define capSetVideoFormat(hwnd, s, wSize)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_VIDEOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(s)))

#define capPreview(hwnd, f)                        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_PREVIEW, (WPARAM)(BOOL)(f), 0L))
#define capPreviewRate(hwnd, wMS)                  ((BOOL)AVICapSM(hwnd, WM_CAP_SET_PREVIEWRATE, (WPARAM)(wMS), 0))
#define capOverlay(hwnd, f)                        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_OVERLAY, (WPARAM)(BOOL)(f), 0L))
#define capPreviewScale(hwnd, f)                   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SCALE, (WPARAM)(BOOL)f, 0L))
#define capGetStatus(hwnd, s, wSize)               ((BOOL)AVICapSM(hwnd, WM_CAP_GET_STATUS, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPSTATUS)(s)))
#define capSetScrollPos(hwnd, lpP)                 ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SCROLL, (WPARAM)0, (LPARAM)(LPPOINT)(lpP)))

#define capGrabFrame(hwnd)                         ((BOOL)AVICapSM(hwnd, WM_CAP_GRAB_FRAME, (WPARAM)0, (LPARAM)0L))
#define capGrabFrameNoStop(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_GRAB_FRAME_NOSTOP, (WPARAM)0, (LPARAM)0L))

#define capCaptureSequence(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_SEQUENCE, (WPARAM)0, (LPARAM)0L))
#define capCaptureSequenceNoFile(hwnd)             ((BOOL)AVICapSM(hwnd, WM_CAP_SEQUENCE_NOFILE, (WPARAM)0, (LPARAM)0L))
#define capCaptureStop(hwnd)                       ((BOOL)AVICapSM(hwnd, WM_CAP_STOP, (WPARAM)0, (LPARAM)0L))
#define capCaptureAbort(hwnd)                      ((BOOL)AVICapSM(hwnd, WM_CAP_ABORT, (WPARAM)0, (LPARAM)0L))

#define capCaptureSingleFrameOpen(hwnd)            ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME_OPEN, (WPARAM)0, (LPARAM)0L))
#define capCaptureSingleFrameClose(hwnd)           ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME_CLOSE, (WPARAM)0, (LPARAM)0L))
#define capCaptureSingleFrame(hwnd)                ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME, (WPARAM)0, (LPARAM)0L))

#define capCaptureGetSetup(hwnd, s, wSize)         ((BOOL)AVICapSM(hwnd, WM_CAP_GET_SEQUENCE_SETUP, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPTUREPARMS)(s)))
#define capCaptureSetSetup(hwnd, s, wSize)         ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SEQUENCE_SETUP, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPTUREPARMS)(s)))

#define capSetMCIDeviceName(hwnd, szName)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_MCI_DEVICE, 0, (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capGetMCIDeviceName(hwnd, szName, wSize)   ((BOOL)AVICapSM(hwnd, WM_CAP_GET_MCI_DEVICE, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPSTR)(szName)))

#define capPaletteOpen(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_OPEN, 0, (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capPaletteSave(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_SAVE, 0, (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capPalettePaste(hwnd)                      ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_PASTE, (WPARAM) 0, (LPARAM)0L))
#define capPaletteAuto(hwnd, iFrames, iColors)     ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_AUTOCREATE, (WPARAM)(iFrames), (LPARAM)(DWORD)(iColors)))
#define capPaletteManual(hwnd, fGrab, iColors)     ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_MANUALCREATE, (WPARAM)(fGrab), (LPARAM)(DWORD)(iColors)))

// ------------------------------------------------------------------
//  Structures 
// ------------------------------------------------------------------

typedef struct tagCapDriverCaps {
    WORD        wDeviceIndex;               // Driver index in system.ini
    BOOL        fHasOverlay;                // Can device overlay?
    BOOL        fHasDlgVideoSource;         // Has Video source dlg?
    BOOL        fHasDlgVideoFormat;         // Has Format dlg?
    BOOL        fHasDlgVideoDisplay;        // Has External out dlg?
    BOOL        fCaptureInitialized;        // Driver ready to capture?
    BOOL        fDriverSuppliesPalettes;    // Can driver make palettes?
    HVIDEO      hVideoIn;                   // Driver In channel
    HVIDEO      hVideoOut;                  // Driver Out channel
    HVIDEO      hVideoExtIn;                // Driver Ext In channel
    HVIDEO      hVideoExtOut;               // Driver Ext Out channel
} CAPDRIVERCAPS, *PCAPDRIVERCAPS, FAR *LPCAPDRIVERCAPS;

typedef struct tagCapStatus {
    UINT        uiImageWidth;               // Width of the image
    UINT        uiImageHeight;              // Height of the image
    BOOL        fLiveWindow;                // Now Previewing video?
    BOOL        fOverlayWindow;             // Now Overlaying video?
    BOOL        fScale;                     // Scale image to client?
    POINT       ptScroll;                   // Scroll position
    BOOL        fUsingDefaultPalette;       // Using default driver palette?
    BOOL        fAudioHardware;             // Audio hardware present?
    BOOL        fCapFileExists;             // Does capture file exist?
    DWORD       dwCurrentVideoFrame;        // # of video frames cap'td
    DWORD       dwCurrentVideoFramesDropped;// # of video frames dropped
    DWORD       dwCurrentWaveSamples;       // # of wave samples cap'td
    DWORD       dwCurrentTimeElapsedMS;     // Elapsed capture duration
    HPALETTE    hPalCurrent;                // Current palette in use
    BOOL        fCapturingNow;              // Capture in progress?
    DWORD       dwReturn;                   // Error value after any operation
    WORD        wNumVideoAllocated;         // Actual number of video buffers
    WORD        wNumAudioAllocated;         // Actual number of audio buffers
} CAPSTATUS, *PCAPSTATUS, FAR *LPCAPSTATUS;

                                            // Default values in parenthesis
typedef struct tagCaptureParms {
    DWORD       dwRequestMicroSecPerFrame;  // Requested capture rate
    BOOL        fMakeUserHitOKToCapture;    // Show "Hit OK to cap" dlg?
    WORD        wPercentDropForError;       // Give error msg if > (10%)
    BOOL        fYield;                     // Capture via background task?
    DWORD       dwIndexSize;                // Max index size in frames (32K)
    WORD        wChunkGranularity;          // Junk chunk granularity (2K)
    BOOL        fUsingDOSMemory;            // Use DOS buffers?
    WORD        wNumVideoRequested;         // # video buffers, If 0, autocalc
    BOOL        fCaptureAudio;              // Capture audio?
    WORD        wNumAudioRequested;         // # audio buffers, If 0, autocalc
    WORD        vKeyAbort;                  // Virtual key causing abort
    BOOL        fAbortLeftMouse;            // Abort on left mouse?
    BOOL        fAbortRightMouse;           // Abort on right mouse?
    BOOL        fLimitEnabled;              // Use wTimeLimit?
    WORD        wTimeLimit;                 // Seconds to capture
    BOOL        fMCIControl;                // Use MCI video source?
    BOOL        fStepMCIDevice;             // Step MCI device?
    DWORD       dwMCIStartTime;             // Time to start in MS
    DWORD       dwMCIStopTime;              // Time to stop in MS
    BOOL        fStepCaptureAt2x;           // Perform spatial averaging 2x
    WORD        wStepCaptureAverageFrames;  // Temporal average n Frames
    DWORD       dwAudioBufferSize;          // Size of audio bufs (0 = default)
    BOOL        fDisableWriteCache;         // Attempt to disable write cache
} CAPTUREPARMS, *PCAPTUREPARMS, FAR *LPCAPTUREPARMS;

typedef struct tagCapInfoChunk {
    FOURCC      fccInfoID;                  // Chunk ID, "ICOP" for copyright
    LPVOID      lpData;                     // pointer to data
    LONG        cbData;                     // size of lpData
} CAPINFOCHUNK, *PCAPINFOCHUNK, FAR *LPCAPINFOCHUNK;


// ------------------------------------------------------------------
//  Callback Definitions
// ------------------------------------------------------------------

typedef LRESULT (CALLBACK* CAPYIELDCALLBACK)  (HWND hWnd);
typedef LRESULT (CALLBACK* CAPSTATUSCALLBACK) (HWND hWnd, int nID, LPCSTR lpsz);
typedef LRESULT (CALLBACK* CAPERRORCALLBACK)  (HWND hWnd, int nID, LPCSTR lpsz);
typedef LRESULT (CALLBACK* CAPVIDEOCALLBACK)  (HWND hWnd, LPVIDEOHDR lpVHdr);
typedef LRESULT (CALLBACK* CAPWAVECALLBACK)   (HWND hWnd, LPWAVEHDR lpWHdr);
typedef LRESULT (CALLBACK* CAPCONTROLCALLBACK)(HWND hWnd, int nState);

// ------------------------------------------------------------------
//  CapControlCallback states
// ------------------------------------------------------------------
#define CONTROLCALLBACK_PREROLL         1 /* Waiting to start capture */
#define CONTROLCALLBACK_CAPTURING       2 /* Now capturing */

// ------------------------------------------------------------------
//  The only exported functions from AVICAP.DLL
// ------------------------------------------------------------------

HWND VFWAPI capCreateCaptureWindow (
        LPCSTR lpszWindowName, 
        DWORD dwStyle,
        int x, int y, int nWidth, int nHeight,
        HWND hwndParent, int nID);

BOOL VFWAPI capGetDriverDescription (WORD wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer);

#endif  /* RC_INVOKED */

// ------------------------------------------------------------------
// New Information chunk IDs
// ------------------------------------------------------------------
#define infotypeDIGITIZATION_TIME  mmioFOURCC ('I','D','I','T')
#define infotypeSMPTE_TIME         mmioFOURCC ('I','S','M','P')

// ------------------------------------------------------------------
// String IDs from status and error callbacks
// ------------------------------------------------------------------

#define IDS_CAP_BEGIN               300  /* "Capture Start" */
#define IDS_CAP_END                 301  /* "Capture End" */

#define IDS_CAP_INFO                401  /* "%s" */
#define IDS_CAP_OUTOFMEM            402  /* "Out of memory" */
#define IDS_CAP_FILEEXISTS          403  /* "File '%s' exists -- overwrite it?" */
#define IDS_CAP_ERRORPALOPEN        404  /* "Error opening palette '%s'" */
#define IDS_CAP_ERRORPALSAVE        405  /* "Error saving palette '%s'" */
#define IDS_CAP_ERRORDIBSAVE        406  /* "Error saving frame '%s'" */
#define IDS_CAP_DEFAVIEXT           407  /* "avi" */
#define IDS_CAP_DEFPALEXT           408  /* "pal" */
#define IDS_CAP_CANTOPEN            409  /* "Cannot open '%s'" */
#define IDS_CAP_SEQ_MSGSTART        410  /* "Select OK to start capture\nof video sequence\nto %s." */
#define IDS_CAP_SEQ_MSGSTOP         411  /* "Hit ESCAPE or click to end capture" */
                
#define IDS_CAP_VIDEDITERR          412  /* "An error occurred while trying to run VidEdit." */
#define IDS_CAP_READONLYFILE        413  /* "The file '%s' is a read-only file." */
#define IDS_CAP_WRITEERROR          414  /* "Unable to write to file '%s'.\nDisk may be full." */
#define IDS_CAP_NODISKSPACE         415  /* "There is no space to create a capture file on the specified device." */
#define IDS_CAP_SETFILESIZE         416  /* "Set File Size" */
#define IDS_CAP_SAVEASPERCENT       417  /* "SaveAs: %2ld%%  Hit Escape to abort." */
                
#define IDS_CAP_DRIVER_ERROR        418  /* Driver specific error message */

#define IDS_CAP_WAVE_OPEN_ERROR     419  /* "Error: Cannot open the wave input device.\nCheck sample size, frequency, and channels." */
#define IDS_CAP_WAVE_ALLOC_ERROR    420  /* "Error: Out of memory for wave buffers." */
#define IDS_CAP_WAVE_PREPARE_ERROR  421  /* "Error: Cannot prepare wave buffers." */
#define IDS_CAP_WAVE_ADD_ERROR      422  /* "Error: Cannot add wave buffers." */
#define IDS_CAP_WAVE_SIZE_ERROR     423  /* "Error: Bad wave size." */
                
#define IDS_CAP_VIDEO_OPEN_ERROR    424  /* "Error: Cannot open the video input device." */
#define IDS_CAP_VIDEO_ALLOC_ERROR   425  /* "Error: Out of memory for video buffers." */
#define IDS_CAP_VIDEO_PREPARE_ERROR 426  /* "Error: Cannot prepare video buffers." */
#define IDS_CAP_VIDEO_ADD_ERROR     427  /* "Error: Cannot add video buffers." */
#define IDS_CAP_VIDEO_SIZE_ERROR    428  /* "Error: Bad video size." */
                
#define IDS_CAP_FILE_OPEN_ERROR     429  /* "Error: Cannot open capture file." */
#define IDS_CAP_FILE_WRITE_ERROR    430  /* "Error: Cannot write to capture file.  Disk may be full." */
#define IDS_CAP_RECORDING_ERROR     431  /* "Error: Cannot write to capture file.  Data rate too high or disk full." */
#define IDS_CAP_RECORDING_ERROR2    432  /* "Error while recording" */
#define IDS_CAP_AVI_INIT_ERROR      433  /* "Error: Unable to initialize for capture." */
#define IDS_CAP_NO_FRAME_CAP_ERROR  434  /* "Warning: No frames captured.\nConfirm that vertical sync interrupts\nare configured and enabled." */
#define IDS_CAP_NO_PALETTE_WARN     435  /* "Warning: Using default palette." */
#define IDS_CAP_MCI_CONTROL_ERROR   436  /* "Error: Unable to access MCI device." */
#define IDS_CAP_MCI_CANT_STEP_ERROR 437  /* "Error: Unable to step MCI device." */
#define IDS_CAP_NO_AUDIO_CAP_ERROR  438  /* "Error: No audio data captured.\nCheck audio card settings." */
#define IDS_CAP_AVI_DRAWDIB_ERROR   439  /* "Error: Unable to draw this data format." */
#define IDS_CAP_COMPRESSOR_ERROR    440  /* "Error: Unable to initialize compressor." */
#define IDS_CAP_AUDIO_DROP_ERROR    441  /* "Error: Audio data was lost during capture, reduce capture rate." */
                
/* status string IDs */
#define IDS_CAP_STAT_LIVE_MODE      500  /* "Live window" */
#define IDS_CAP_STAT_OVERLAY_MODE   501  /* "Overlay window" */
#define IDS_CAP_STAT_CAP_INIT       502  /* "Setting up for capture - Please wait" */
#define IDS_CAP_STAT_CAP_FINI       503  /* "Finished capture, now writing frame %ld" */
#define IDS_CAP_STAT_PALETTE_BUILD  504  /* "Building palette map" */
#define IDS_CAP_STAT_OPTPAL_BUILD   505  /* "Computing optimal palette" */
#define IDS_CAP_STAT_I_FRAMES       506  /* "%d frames" */
#define IDS_CAP_STAT_L_FRAMES       507  /* "%ld frames" */
#define IDS_CAP_STAT_CAP_L_FRAMES   508  /* "Captured %ld frames" */
#define IDS_CAP_STAT_CAP_AUDIO      509  /* "Capturing audio" */
#define IDS_CAP_STAT_VIDEOCURRENT   510  /* "Captured %ld frames (%ld dropped) %d.%03d sec." */
#define IDS_CAP_STAT_VIDEOAUDIO     511  /* "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps).  %ld audio bytes (%d,%03d sps)" */
#define IDS_CAP_STAT_VIDEOONLY      512  /* "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps)" */
#define IDS_CAP_STAT_FRAMESDROPPED  513  /* "Dropped %ld of %ld frames (%d.%02d%%) during capture." */
#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif    /* __cplusplus */

#endif /* INC_AVICAP */



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\avicapi.h ===
/****************************************************************************
 *
 *   avicapi.h
 * 
 *   Internal, private definitions.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#ifndef _INC_AVICAP_INTERNAL
#define _INC_AVICAP_INTERNAL

#include <mmreg.h>
#include <compman.h>
#include "iaverage.h"

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */
                          
/* c8 uses underscores on all defines */
#ifdef DEBUG
#ifndef _DEBUG
#define _DEBUG
#endif
#endif

#define	IDS_CAP_RTL	10000

#ifndef LPHISTOGRAM
typedef DWORD huge * LPHISTOGRAM;
#endif

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) ((int)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount))
#define SWAP(x,y)   ((x)^=(y)^=(x)^=(y))

#define AVICAP                  DWORD FAR PASCAL
#define DROP_BUFFER_SIZE        2048
#define MAX_VIDEO_BUFFERS       1000
#define MIN_VIDEO_BUFFERS       5
#define DEF_WAVE_BUFFERS        4
#define MAX_WAVE_BUFFERS        10
#define _MAX_CAP_PATH           MAX_PATH  /* 260 */

// MCI Capture state machine
enum mcicapstates {
   CAPMCI_STATE_Uninitialized = 0,
   CAPMCI_STATE_Initialized,

   CAPMCI_STATE_StartVideo,
   CAPMCI_STATE_CapturingVideo,
   CAPMCI_STATE_VideoFini,

   CAPMCI_STATE_StartAudio,
   CAPMCI_STATE_CapturingAudio,
   CAPMCI_STATE_AudioFini,

   CAPMCI_STATE_AllFini
};

// -------------------------
//  CAPSTREAM structure
// -------------------------
#define CAPSTREAM_VERSION 1             // Increment whenever struct changes

// This structure is GlobalAlloc'd for each capture window instance.
// A pointer to the structure is stored in the Window extra bytes.
// Applications can retrieve a pointer to the stucture using 
//    the WM_CAP_GET_CAPSTREAMPTR message.
// I: internal variables which the client app should not modify
// M: variables which the client app can set via Send/PostMessage

typedef struct tagCAPSTREAM {
    DWORD           dwSize;                     // I: size of structure
    UINT            uiVersion;                  // I: version of structure
    HINSTANCE       hInst;                      // I: our instance
    HTASK           hTaskCapture;               // I: capture task handle
    DWORD           dwReturn;                   // I: capture task return val
    HWND            hwnd;                       // I: our hwnd

    // Use MakeProcInstance to create all callbacks !!!

    // Status, error callbacks 
    CAPSTATUSCALLBACK   CallbackOnStatus;       // M: Status callback
    CAPERRORCALLBACK    CallbackOnError;        // M: Error callback

    // Allows client to process messages during capture if set
    CAPYIELDCALLBACK    CallbackOnYield;        // M: Yield processing

    // Video and wave callbacks for Network or other specialized xfers
    CAPVIDEOCALLBACK    CallbackOnVideoFrame;   // M: Only during preview
    CAPVIDEOCALLBACK    CallbackOnVideoStream;  // M: Video buffer ready
    CAPWAVECALLBACK     CallbackOnWaveStream;   // M: Wave buffer ready
    CAPCONTROLCALLBACK  CallbackOnControl;      // M: External Start/Stop ctrl

    // Open channels on the video hardware device
    // and hardware capabilies
    CAPDRIVERCAPS   sCapDrvCaps;                // M: What can the driver do    
    HVIDEO          hVideoIn;                   // I: In channel
    HVIDEO          hVideoCapture;              // I: Ext In channel
    HVIDEO          hVideoDisplay;              // I: Ext Out channel
    BOOL            fHardwareConnected;         // I: ANY open channel?
     
    // Window to display video
    BOOL            fLiveWindow;                // M: Preview video
    BOOL            fOverlayWindow;             // M: Overlay video
    BOOL            fScale;                     // M: Scale image to client
    POINT           ptScroll;                   // I: Scroll position
    HANDLE          hdd;                        // I: hDrawDib access handle
    HCURSOR         hWaitCursor;                // I: hourglass
    UINT            uiRegion;                   // I: CheckWindowMove
    RECT            rcRegionRect;               // I: CheckWindowMove
    DWORD           dwRegionOrigin;             // I: CheckWindowMove

    // Window update timer
    UINT            idTimer;                    // I: ID of preview timer
    UINT            uTimeout;                   // M: Preview rate in mS.

    // Capture destination and control
    CAPTUREPARMS    sCapParms;                  // M: how to capture
    BOOL            fCapturingToDisk;           // M: if capturing to disk
    BOOL            fCapturingNow;              // I: if performing capture
    BOOL            fStepCapturingNow;          // I: if performing MCI step capture
    BOOL            fFrameCapturingNow;         // I: if performing single frame capture
    BOOL            fStopCapture;               // M: if stop requested
    BOOL            fAbortCapture;              // M: if abort requested
    DWORD           dwTimeElapsedMS;            // I: Capture time in millisec

    // Index 
    HGLOBAL         hIndex;                     // I: handle to index mem
    DWORD           dwIndex;                    // I: index index
    DWORD           dwVideoChunkCount;          // I: # of video frames cap'd
    DWORD           dwWaveChunkCount;           // I: # of audio buffers cap'd
    DWORD _huge *   lpdwIndexStart;             // I: index start ptr
    DWORD _huge *   lpdwIndexEntry;             // I: index current ptr
    LPBYTE          lpDOSWriteBuffer;           // I: ptr to DOS buffer
    DWORD           dwDOSBufferSize;            // I: DOS buffer size

    // Video format
    DWORD           dwActualMicroSecPerFrame;   // I: Actual cap rate
    LPBITMAPINFO    lpBitsInfo;                 // I: Video format
    int             dxBits;                     // I: video size x
    int             dyBits;                     // I: video size y
    LPSTR           lpBits;                     // I: Single frame capture buf
    VIDEOHDR        VidHdr;                     // I: Single frame header
    COMPVARS        CompVars;                   // M: Set by ICCompressorChoose
    LPIAVERAGE      lpia;                       // I: Image averaging struct
    VIDEOHDR        VidHdr2x;                   // I: VideoHeader at 2x
    LPBITMAPINFOHEADER  lpbmih2x;               // I: lpbi at 2x

    // Video Buffer management
    BOOL            fVideoDataIsCompressed;     // I: if don't use dwVideoSize
    DWORD           dwVideoSize;                // I: size of non-comp buffer incl chunk 
    DWORD           dwVideoJunkSize;            // I: Initial non-comp. junk size
    int             iNumVideo;                  // I: Number of actual video buffers
    int             iNextVideo;                 // I: index into video buffers
    DWORD           dwFramesDropped;            // I: number of frames dropped
    BYTE            DropFrame[DROP_BUFFER_SIZE];    // I: Create a Dummy VideoHdr
    LPVIDEOHDR      alpVideoHdr[MAX_VIDEO_BUFFERS]; // I: array of buf ptrs
    BOOL            fBuffersOnHardware;         // I: if driver all'd buffers

    // Palettes
    HPALETTE        hPalCurrent;                // I: handle of current pal
    BOOL            fUsingDefaultPalette;       // I: no user defined pal
    int             nPaletteColors;             // M: only changed by UI
    LPVOID          lpCapPal;                   // I: LPCAPPAL manual pals
    
    // Audio Capture Format
    BOOL            fAudioHardware;             // I: if audio hardware present
    LPWAVEFORMATEX  lpWaveFormat;               // I: wave format
    WAVEHDR         WaveHdr;                    // I: Wave header
    HWAVE           hWaveIn;                    // I: Wave input channel
    DWORD           dwWaveBytes;                // I: Total wave bytes cap'd
    DWORD           dwWaveSize;                 // I: wave buffer size

    // Audio Buffer management
    LPWAVEHDR       alpWaveHdr[MAX_WAVE_BUFFERS]; // I: wave buff array
    int             iNextWave;                  // I: Index into wave buffers
    int             iNumAudio;                  // I: Number of actual audio buffers
    BOOL            fAudioYield;                // I: ACM audio yield required
    BOOL            fAudioBreak;                // I: Audio underflow

    // MCI Capture
    char            achMCIDevice[_MAX_CAP_PATH];// MCI device name
    DWORD           dwMCIError;                 // I: Last MCI error value
    enum mcicapstates MCICaptureState;          // I: MCI State machine
    DWORD           dwMCICurrentMS;             // I: Current MCI position
    DWORD           dwMCIActualStartMS;         // I: Actual MCI start MS
    DWORD           dwMCIActualEndMS;           // I: Actual MCI end position

    // Output file
    char            achFile [_MAX_CAP_PATH];    // M: name of capture file
    char            achSaveAsFile [_MAX_CAP_PATH]; // M: name of saveas file
    BOOL            fCapFileExists;             // I: if have a capture file
    LONG            lCapFileSize;               // M: in bytes
    BOOL            fFileCaptured;              // I: if we've cap'd to file
    HMMIO           hmmio;                      // I: MMIO handle for writing
    DWORD           dwAVIHdrSize;               // I: size of header
    DWORD           dwAVIHdrPos;                // I: file offset of hdr
    
    LONG	    lUser;			// M: Data for the user
    LPVOID          lpInfoChunks;               // M: information chunks
    LONG            cbInfoChunks;               // M: sizeof information chks
    BOOL            fLastStatusWasNULL;         // I: don't repeat null msgs
    BOOL            fLastErrorWasNULL;          // I: don't repeat null msgs
} CAPSTREAM;
typedef CAPSTREAM FAR * LPCAPSTREAM;

// -------------------------
//  Full color log palette
// -------------------------

typedef struct tagFCLOGPALETTE {
    WORD         palVersion;
    WORD         palNumEntries;
    PALETTEENTRY palPalEntry[256];
} FCLOGPALETTE;

typedef struct {
    DWORD       dwType;
    DWORD       dwSize;
} RIFF, *PRIFF, FAR *LPRIFF;

extern HINSTANCE ghInst;
extern BOOL gfIsRTL;

// capinit.c
BOOL CapWinDisconnectHardware(LPCAPSTREAM lpcs);
BOOL CapWinConnectHardware (LPCAPSTREAM lpcs, WORD wDeviceIndex);
BOOL capInternalGetDriverDesc (WORD wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer);

// capwin.c
LONG FAR PASCAL _loadds CapWndProc (HWND hwnd, unsigned msg, WORD wParam, LONG lParam);
                  
// capavi.c                              
BOOL InitIndex (LPCAPSTREAM lpcs);
void FiniIndex (LPCAPSTREAM lpcs);
BOOL IndexVideo (LPCAPSTREAM lpcs, DWORD dwSize, BOOL bKeyFrame);
BOOL IndexAudio (LPCAPSTREAM lpcs, DWORD dwSize);
BOOL WriteIndex (LPCAPSTREAM lpcs, BOOL fJunkChunkWritten);
DWORD GetFreePhysicalMemory(void);
DWORD CalcWaveBufferSize (LPCAPSTREAM lpcs);
BOOL AVIFileInit(LPCAPSTREAM lpcs);
BOOL AVIFileFini (LPCAPSTREAM lpcs, BOOL fWroteJunkChunks, BOOL fAbort);
WORD AVIAudioInit (LPCAPSTREAM lpcs);
WORD AVIAudioFini (LPCAPSTREAM lpcs);
WORD AVIAudioPrepare (LPCAPSTREAM lpcs, HWND hWndCallback);
WORD AVIAudioUnPrepare (LPCAPSTREAM lpcs);
WORD AVIVideoInit (LPCAPSTREAM lpcs);
WORD AVIVideoPrepare (LPCAPSTREAM lpcs);
WORD AVIVideoUnPrepare (LPCAPSTREAM lpcs);
void AVIFini(LPCAPSTREAM lpcs);
WORD AVIInit (LPCAPSTREAM lpcs);
BOOL NEAR PASCAL AVIWrite(LPCAPSTREAM lpcs, LPVOID p, DWORD dwSize);
BOOL AVIWriteDummyFrames (LPCAPSTREAM lpcs, int nCount);
BOOL AVIWriteVideoFrame (LPCAPSTREAM lpcs, LPVIDEOHDR lpVidHdr);
BOOL FAR PASCAL SetInfoChunk(LPCAPSTREAM lpcs, LPCAPINFOCHUNK lpcic);

BOOL AVICapture (LPCAPSTREAM lpcs);


// capfile.c
BOOL FAR PASCAL fileCapFileIsAVI (LPSTR lpsz);
BOOL FAR PASCAL fileAllocCapFile(LPCAPSTREAM lpcs, DWORD dwNewSize);
BOOL FAR PASCAL fileSaveCopy(LPCAPSTREAM lpcs);
BOOL FAR PASCAL fileSavePalette(LPCAPSTREAM lpcs, LPSTR lpszFileName);
BOOL FAR PASCAL fileOpenPalette(LPCAPSTREAM lpcs, LPSTR lpszFileName);

//capmisc.c
WORD GetKey(BOOL fWait);
void errorDriverID (LPCAPSTREAM lpcs, DWORD dwError);
void FAR _cdecl statusUpdateStatus (LPCAPSTREAM lpcs, WORD wID, ...);
void FAR _cdecl errorUpdateError (LPCAPSTREAM lpcs, WORD wID, ...);

//capFrame.c
BOOL FAR PASCAL SingleFrameCaptureOpen (LPCAPSTREAM lpcs);
BOOL FAR PASCAL SingleFrameCaptureClose (LPCAPSTREAM lpcs);
BOOL FAR PASCAL SingleFrameCapture (LPCAPSTREAM lpcs);
BOOL SingleFrameWrite (
    LPCAPSTREAM             lpcs,       // capture stream
    LPVIDEOHDR              lpVidHdr,   // input header
    BOOL FAR 		    *pfKey,	// did it end up being a key frame?
    LONG FAR		    *plSize);	// size of returned image

//capMCI.c
void FAR PASCAL TimeMSToSMPTE (DWORD dwMS, LPSTR lpTime);
int CountMCIDevicesByType ( WORD wType );
void MCIDeviceClose (LPCAPSTREAM lpcs);
BOOL MCIDeviceOpen (LPCAPSTREAM lpcs);
BOOL FAR PASCAL MCIDeviceGetPosition (LPCAPSTREAM lpcs, LPDWORD lpdwPos);
BOOL FAR PASCAL MCIDeviceSetPosition (LPCAPSTREAM lpcs, DWORD dwPos);
BOOL FAR PASCAL MCIDevicePlay (LPCAPSTREAM lpcs);
BOOL FAR PASCAL MCIDevicePause (LPCAPSTREAM lpcs);
BOOL FAR PASCAL MCIDeviceStop (LPCAPSTREAM lpcs);
BOOL FAR PASCAL MCIDeviceStep (LPCAPSTREAM lpcs, BOOL fForward);
void FAR PASCAL _loadds MCIStepCapture (LPCAPSTREAM lpcs);

long FAR PASCAL muldiv32(long, long, long);
                        
#ifdef _DEBUG
  BOOL FAR PASCAL _Assert(BOOL f, LPSTR szFile, int iLine); 
  #define WinAssert(exp) (_Assert(exp, (LPSTR) __FILE__, __LINE__))
  extern void FAR CDECL dprintf(LPSTR, ...);
  #define DPF dprintf
#else
  #define dprintf ; / ## /
  #define DPF ; / ## /
  #define WinAssert(exp) 0
#endif                      


#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif    /* __cplusplus */

#endif /* INC_AVICAP_INTERNAL */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\capavi.c ===
/****************************************************************************
 *
 *   capavi.c
 *
 *   Main video capture module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>         // for _fmemset
#include <msvideo.h>
#include <drawdib.h>
#include <mmreg.h>
#include <mmddk.h>
#include <msacm.h>
#include <avifmt.h>
#include "avicap.h"
#include "avicapi.h"
#include "time.h"

time_t      ltime;

extern void NEAR PASCAL MemCopy(LPVOID, LPVOID, DWORD); // in memcopy.asm
extern WORD FAR PASCAL SmartDrv(char chDrive, WORD w);
extern WORD GetSizeOfWaveFormat (LPWAVEFORMATEX lpwf);

/* dialog function prototype */
LONG FAR PASCAL _export capseqDlgProc(HWND hwnd, unsigned msg, WORD wParam, LONG lParam);

#ifdef _DEBUG
    #define DSTATUS(lpcs, sz) statusUpdateStatus(lpcs, IDS_CAP_INFO, (LPSTR) sz)
#else
    #define DSTATUS(lpcs, sz)
#endif

///////////////////////////////////////////////////////////////////////////
//  The index array is used to record the positions
//  of every chunk in the RIFF (avi) file.
//
//  what this array is:
//
//      each entry contains the size of the data
//      high order bits encode the type of data (audio / video)
//      and whether the video chunk is a key frame, dropped frame, etc.
///////////////////////////////////////////////////////////////////////////

// The following are anded with the size in the index
#define IS_AUDIO_CHUNK        0x80000000
#define IS_KEYFRAME_CHUNK     0x40000000
#define IS_DUMMY_CHUNK        0x20000000
#define IS_LAST_DUMMY_CHUNK   0x10000000
#define INDEX_MASK  (IS_AUDIO_CHUNK | IS_KEYFRAME_CHUNK | IS_DUMMY_CHUNK | IS_LAST_DUMMY_CHUNK)


// Allocate the index table
// Returns: TRUE if index can be allocated
BOOL InitIndex (LPCAPSTREAM lpcs)
{
    lpcs->dwIndex = 0;

    WinAssert (lpcs->lpdwIndexStart == NULL);

    // Limit index size between 1 minute at 30fps and 3 hours at 30fps
    lpcs->sCapParms.dwIndexSize = max (lpcs->sCapParms.dwIndexSize, 1800);
    lpcs->sCapParms.dwIndexSize = min (lpcs->sCapParms.dwIndexSize, 324000L);
    dprintf("Max Index Size = %ld \n", lpcs->sCapParms.dwIndexSize);

    if (lpcs->hIndex = GlobalAlloc (GMEM_MOVEABLE,
                lpcs->sCapParms.dwIndexSize * sizeof (DWORD))) {
        if (lpcs->lpdwIndexEntry =
                lpcs->lpdwIndexStart =
                (DWORD _huge *)GlobalLock (lpcs->hIndex)) {
            GlobalPageLock (lpcs->hIndex);
            return TRUE;        // Success
        }
        GlobalFree (lpcs->hIndex);
    }
    lpcs->hIndex = NULL;
    lpcs->lpdwIndexStart = NULL;
    return FALSE;
}

// Deallocate the index table
void FiniIndex (LPCAPSTREAM lpcs)
{
    if (lpcs->hIndex) {
        GlobalPageUnlock (lpcs->hIndex);
        if (lpcs->lpdwIndexStart)
            GlobalUnlock (lpcs->hIndex);
        GlobalFree (lpcs->hIndex);
    }
    lpcs->hIndex = NULL;
    lpcs->lpdwIndexStart = NULL;
}


// Add an index entry for a video frame
// dwSize is the size of data ONLY, not including the chunk or junk
// Returns: TRUE if index space is not exhausted
BOOL IndexVideo (LPCAPSTREAM lpcs, DWORD dwSize, BOOL bKeyFrame)
{
    BOOL fOK = lpcs->dwIndex < lpcs->sCapParms.dwIndexSize;

    if (fOK) {
        *lpcs->lpdwIndexEntry++ = dwSize | (bKeyFrame ? IS_KEYFRAME_CHUNK : 0);
        lpcs->dwIndex++;
        lpcs->dwVideoChunkCount++;
    }
    return (fOK);
}


// Add an index entry for an audio buffer
// dwSize is the size of data ONLY, not including the chunk or junk
// Returns: TRUE if index space is not exhausted
BOOL IndexAudio (LPCAPSTREAM lpcs, DWORD dwSize)
{
    BOOL fOK = lpcs->dwIndex < lpcs->sCapParms.dwIndexSize;

    if (fOK) {
        *lpcs->lpdwIndexEntry++ = dwSize | IS_AUDIO_CHUNK;
        lpcs->dwIndex++;
        lpcs->dwWaveChunkCount++;
    }
    return (fOK);
}


// Write out the index at the end of the capture file.
// The single frame capture methods do not append
// JunkChunks!  Audio chunks do not have junk appended.
BOOL WriteIndex (LPCAPSTREAM lpcs, BOOL fJunkChunkWritten)
{
    BOOL  fChunkIsAudio;
    BOOL  fChunkIsKeyFrame;
    BOOL  fChunkIsDummy;
    BOOL  fChunkIsLastDummy;
    DWORD dwIndex;
    DWORD dw;
    DWORD dwDummySize;
    DWORD dwJunk;
    DWORD off;
    AVIINDEXENTRY   avii;
    MMCKINFO    ck;
    DWORD _huge *lpdw;

    if (lpcs->dwIndex > lpcs->sCapParms.dwIndexSize)
        return TRUE;

    off        = lpcs->dwAVIHdrSize;

    ck.cksize  = 0;
    ck.ckid    = ckidAVINEWINDEX;
    ck.fccType = 0;

    if (mmioCreateChunk(lpcs->hmmio,&ck,0))
        return FALSE;

    lpdw = lpcs->lpdwIndexStart;
    for (dwIndex= 0; dwIndex< lpcs->dwIndex; dwIndex++) {

        dw = *lpdw++;

        fChunkIsAudio      = (BOOL) ((dw & IS_AUDIO_CHUNK) != 0);
        fChunkIsKeyFrame   = (BOOL) ((dw & IS_KEYFRAME_CHUNK) != 0);
        fChunkIsDummy      = (BOOL) ((dw & IS_DUMMY_CHUNK) != 0);
        fChunkIsLastDummy  = (BOOL) ((dw & IS_LAST_DUMMY_CHUNK) != 0);
        dw &= ~(INDEX_MASK);

        if (fChunkIsAudio) {
            avii.ckid         = MAKEAVICKID(cktypeWAVEbytes, 1);
            avii.dwFlags      = 0;
        } else {
        if (lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RLE8)
            avii.ckid         = MAKEAVICKID(cktypeDIBcompressed, 0);
        else
            avii.ckid         = MAKEAVICKID(cktypeDIBbits, 0);
            avii.dwFlags      = fChunkIsKeyFrame ? AVIIF_KEYFRAME : 0;
        }
        avii.dwChunkLength    = dw;
        avii.dwChunkOffset    = off;

        if (mmioWrite(lpcs->hmmio, (LPVOID)&avii, sizeof(avii)) != sizeof(avii))
            return FALSE;

        dw += sizeof (RIFF);
        off += dw;

        // ooh, getting messy. We know that dummy chunks come in a group
        // (1 or more) and are always terminated by a IS_LAST_DUMMY_CHUNK flag.
        // only the last one gets junk append to round out to 2K
        if (fChunkIsDummy) {
            dwDummySize += sizeof(RIFF);
            if (!fChunkIsLastDummy)
                continue;
            else
                dw = dwDummySize;   // total size of all dummy entries in group
        }
        else
            dwDummySize = 0;

        if (fJunkChunkWritten & !fChunkIsAudio) {
           // If a Junk chunk was appended, move past it
           if (dw % lpcs->sCapParms.wChunkGranularity) {
                dwJunk = lpcs->sCapParms.wChunkGranularity - (dw % lpcs->sCapParms.wChunkGranularity);

                if (dwJunk < sizeof (RIFF))
                    off += lpcs->sCapParms.wChunkGranularity + dwJunk;
                else
                    off += dwJunk;
           }
        }

         if (off & 1)
             off++;
    }

    if (mmioAscend(lpcs->hmmio, &ck, 0))
        return FALSE;

    return TRUE;
}



// Allocate DOS memory for faster disk writes
LPVOID NEAR PASCAL AllocDosMem (DWORD dw)
{
    HANDLE h;

    if (h = LOWORD (GlobalDosAlloc(dw)))
        return (GlobalLock (h));
    return NULL;
}

// General purpose memory allocator
LPVOID NEAR PASCAL AllocMem (DWORD dw, BOOL fUseDOSMemory)
{
#if 0
    if (fUseDOSMemory)
        return AllocDosMem(dw);
#endif

    return GlobalAllocPtr (GMEM_MOVEABLE, dw);
}

void NEAR PASCAL FreeMem(LPVOID p)
{
    GlobalFreePtr(p);
}


#pragma optimize ("", off)

DWORD GetFreePhysicalMemory(void)
{
    DWORD   adw[ 0x30 / sizeof(DWORD) ];
    WORD    fFail;

    //
    //  if standard mode just ask KERNEL how much memory is free
    //
    //  if enhanced mode, call DPMI and find out how much *real*
    //  memory is free.
    //
    if (GetWinFlags() & WF_STANDARD)
    {
        return GetFreeSpace(0);
    }
    else _asm
    {
        mov     ax, 0500h
        push    ss
        pop     es
        lea     di, word ptr adw
        int     31h
        sbb     ax, ax
        mov     fFail, ax
    }

    if (fFail)
        return (0l);

    return (adw[2] * 4096);
}
#pragma optimize ("", on)

/*
 *  CalcWaveBufferSize   - Figure out how large to make the wave buffers
 *    a. At least .5 seconds
 *    b. But not less than 10K, (else capture frmae rate suffers)
 *    c. A multiple of lpcs->sCapParms.wChunkGranularity
 */
DWORD CalcWaveBufferSize (LPCAPSTREAM lpcs)
{
    DWORD dw;

    if (!lpcs-> lpWaveFormat)
        return 0L;

    // at least .5 second
    dw = (DWORD) lpcs->lpWaveFormat->nChannels *
         (DWORD) lpcs->lpWaveFormat->nSamplesPerSec *
         (lpcs->lpWaveFormat->wBitsPerSample / 8) / 2L;
    dw -= dw % lpcs->sCapParms.wChunkGranularity;
    dw = max ((1024L * 10), dw);                // at least 10K

//    dprintf("Wave buffer size = %ld \n", dw);
    return dw;
}

static BOOL IsWaveInDeviceMapped(HWAVEIN hWaveIn)
{
    DWORD err;
    DWORD dw;

    err = waveInMessage(hWaveIn,
        WIDM_MAPPER_STATUS,
        WAVEIN_MAPPER_STATUS_MAPPED,
        (DWORD)(LPVOID)&dw);

    return err == 0 && dw != 0;
}

// ****************************************************************
// ******************** Capture File Routines *********************
// ****************************************************************


/*
 * AVIFileInit
 *
 *       Perform all initialization required to write a capture file.
 *
 *       We take a slightly strange approach: We don't write
 *       out the header until we're done capturing.  For now,
 *       we just seek 2K into the file, which is where all of
 *       the real data will go.
 *
 *       When we're done, we'll come back and write out the header,
 *       because then we'll know all of the values we need.
 *
 *      Also allocate and init the index.
 */
BOOL AVIFileInit(LPCAPSTREAM lpcs)
{
#define TEMP_BUFF_SIZE  128
    LONG l;
    char ach[TEMP_BUFF_SIZE];
    LPBITMAPINFO lpBitsInfoOut;    // Possibly compressed output format

    /* No special video format given -- use the default */
    if (lpcs->CompVars.hic == NULL)
	lpBitsInfoOut = lpcs->lpBitsInfo;
    else
	lpBitsInfoOut = lpcs->CompVars.lpbiOut;

    WinAssert (lpcs->hmmio == NULL);   // Should never have a file handle on entry

    /* if the capture file has not been set then set it now */
    if (!(*lpcs->achFile)){
//       if (!fileSetCapFile())
             goto INIT_FILE_OPEN_ERROR;
    }

    /* we have a capture file, open it and set it up */
    lpcs->hmmio = mmioOpen(lpcs->achFile, NULL, MMIO_WRITE);
    if (!lpcs->hmmio) {
         /* try and create */
         lpcs->hmmio = mmioOpen(lpcs->achFile, NULL, MMIO_CREATE | MMIO_WRITE);
         if (!lpcs->hmmio) {
             goto INIT_FILE_OPEN_ERROR;
         }
    }

    /* pre-read the file */
    l = mmioSeek( lpcs->hmmio, 0L, SEEK_END );
    while( l > 0 ) {
         l = mmioSeek( lpcs->hmmio, -min(l, 50000L), SEEK_CUR );
        mmioRead( lpcs->hmmio, ach, sizeof(ach) );
    }

    /* Seek to 2K (or multiple of 2K), where we're going to write our data.
    ** later, we'll come back and fill in the file.
    */

    // l is zero for standard wave and video formats
    l = (GetSizeOfWaveFormat ((LPWAVEFORMATEX) lpcs->lpWaveFormat) -
                sizeof (PCMWAVEFORMAT)) +
                (lpBitsInfoOut->bmiHeader.biSize -
                sizeof (BITMAPINFOHEADER));

    // (2K + size of wave and video stream headers) rounded to next 2K
    lpcs->dwAVIHdrSize = AVI_HEADERSIZE +
        (((lpcs->cbInfoChunks + l + lpcs->sCapParms.wChunkGranularity - 1)
        / lpcs->sCapParms.wChunkGranularity) * lpcs->sCapParms.wChunkGranularity);


    dprintf("AVIHdrSize = %ld \n", lpcs->dwAVIHdrSize);
    mmioSeek(lpcs->hmmio, lpcs->dwAVIHdrSize, SEEK_SET);

    if (!InitIndex (lpcs))           // do all Index allocations
        mmioClose (lpcs->hmmio, 0);

    lpcs->dwVideoChunkCount = 0;
    lpcs->dwWaveChunkCount = 0;

INIT_FILE_OPEN_ERROR:
    return (lpcs->hmmio != NULL);
}

/*
 * AVIFileFini
 *
 *       Write out the index, deallocate the index, and close the file.
 *
 */
BOOL AVIFileFini (LPCAPSTREAM lpcs, BOOL fWroteJunkChunks, BOOL fAbort)
{
    MMCKINFO      ckRiff;
    MMCKINFO      ckList;
    MMCKINFO      ckStream;
    MMCKINFO      ck;
    int           i;
    DWORD         dw;
    AVIStreamHeader        strhdr;
    DWORD         dwDataEnd;
    BOOL        fRet = TRUE;
    RGBQUAD     argbq[256];
    MainAVIHeader   aviHdr;
    BOOL        fSound = lpcs->sCapParms.fCaptureAudio;
    LPBITMAPINFO lpBitsInfoOut;    // Possibly compressed output format

    /* No special video format given -- use the default */
    if (lpcs->CompVars.hic == NULL)
	lpBitsInfoOut = lpcs->lpBitsInfo;
    else
	lpBitsInfoOut = lpcs->CompVars.lpbiOut;

    if (lpcs->hmmio == NULL)  // This can be called even though never opened
        return FALSE;

    if (fAbort)
        goto FileError;

    if (!lpcs->dwWaveBytes)
        fSound = FALSE;

    dwDataEnd = mmioSeek(lpcs->hmmio, 0, SEEK_CUR);

    /* Seek to beginning of file, so we can write the header. */
    mmioSeek(lpcs->hmmio, 0, SEEK_SET);

    DSTATUS(lpcs, "Writing AVI header");

    /* Create RIFF chunk */
    ckRiff.cksize = 0;
    ckRiff.fccType = formtypeAVI;
    if(mmioCreateChunk(lpcs->hmmio,&ckRiff,MMIO_CREATERIFF)) {
         goto FileError;
    }

    /* Create header list */
    ckList.cksize = 0;
    ckList.fccType = listtypeAVIHEADER;
    if(mmioCreateChunk(lpcs->hmmio,&ckList,MMIO_CREATELIST)) {
         goto FileError;
    }

    /* Create AVI header chunk */
    ck.cksize = sizeof(MainAVIHeader);
    ck.ckid = ckidAVIMAINHDR;
    if(mmioCreateChunk(lpcs->hmmio,&ck,0)) {
         goto FileError;
    }

    lpcs->dwAVIHdrPos = ck.dwDataOffset;

    /* Calculate AVI header info */
    _fmemset(&aviHdr, 0, sizeof(aviHdr));
    if (fSound && lpcs->dwVideoChunkCount) {
         /* HACK HACK */
         /* Set rate that was captured based on length of audio data */

         aviHdr.dwMicroSecPerFrame = (DWORD)
                ((double)lpcs->dwWaveBytes * 1000000. /
                ((double)lpcs->lpWaveFormat->nAvgBytesPerSec *
                lpcs->dwVideoChunkCount + 0.5));
    } else {
         aviHdr.dwMicroSecPerFrame = lpcs->sCapParms.dwRequestMicroSecPerFrame;
    }
    lpcs->dwActualMicroSecPerFrame = aviHdr.dwMicroSecPerFrame;

    aviHdr.dwMaxBytesPerSec = (DWORD) muldiv32 (lpBitsInfoOut->bmiHeader.biSizeImage,
                                      1000000,
                                      lpcs->sCapParms.dwRequestMicroSecPerFrame) +
                                      (fSound ? lpcs->lpWaveFormat->nAvgBytesPerSec : 0);
    aviHdr.dwPaddingGranularity = 0L;
    aviHdr.dwFlags = AVIF_WASCAPTUREFILE | AVIF_HASINDEX;
    aviHdr.dwStreams = fSound ? 2 : 1;
    aviHdr.dwTotalFrames = lpcs->dwVideoChunkCount;
    aviHdr.dwInitialFrames = 0L;
    aviHdr.dwSuggestedBufferSize = 0L;
    aviHdr.dwWidth = lpBitsInfoOut->bmiHeader.biWidth;
    aviHdr.dwHeight = lpBitsInfoOut->bmiHeader.biHeight;

//  The following were set for all versions before Chicago Beta2
//  They are now listed as reserved...
//    aviHdr.dwRate = 1000000L;
//    aviHdr.dwScale = aviHdr.dwMicroSecPerFrame;
//    aviHdr.dwStart = 0L;
//    aviHdr.dwLength = lpcs->dwVideoChunkCount;

    /* Write AVI header info */
    if(mmioWrite(lpcs->hmmio, (LPSTR)&aviHdr, sizeof(aviHdr)) !=
             sizeof(aviHdr)) {
         goto FileError;
    }

    if(mmioAscend(lpcs->hmmio, &ck, 0)) {
         goto FileError;
    }

    DSTATUS(lpcs, "Writing AVI Stream header");

    /* Create stream header list */
    ckStream.cksize = 0;
    ckStream.fccType = listtypeSTREAMHEADER;
    if(mmioCreateChunk(lpcs->hmmio,&ckStream,MMIO_CREATELIST)) {
         goto FileError;
    }

    _fmemset(&strhdr, 0, sizeof(strhdr));
    strhdr.fccType = streamtypeVIDEO;
    if (lpcs->CompVars.hic)
        strhdr.fccHandler = lpcs->CompVars.fccHandler;
    else
        strhdr.fccHandler = lpBitsInfoOut->bmiHeader.biCompression;

    // A bit of history...
    // In VFW 1.0, we set fccHandler to 0 for BI_RLE8 formats
    // as a kludge to make Mplayer and Videdit play the files.
    // Just prior to 1.1 release, we found this broke Premiere,
    // so now (after AVICAP beta is on Compuserve), we change the
    // fccHandler to "MRLE".  Just ask Todd...
    // And now, at RC1, we change it again to "RLE ", Just ask Todd...
    if (strhdr.fccHandler == BI_RLE8)
        strhdr.fccHandler = mmioFOURCC('R', 'L', 'E', ' ');

    strhdr.dwFlags = 0L;
    strhdr.wPriority = 0L;
    strhdr.wLanguage = 0L;
    strhdr.dwInitialFrames = 0L;
    strhdr.dwScale = aviHdr.dwMicroSecPerFrame;
    strhdr.dwRate = 1000000L;
    strhdr.dwStart = 0L;
    strhdr.dwLength = lpcs->dwVideoChunkCount;        /* Needs to get filled in! */
    strhdr.dwQuality = (DWORD) -1L;         /* !!! ICQUALITY_DEFAULT */
    strhdr.dwSampleSize = 0L;

    ck.ckid = ckidSTREAMHEADER;
    if(mmioCreateChunk(lpcs->hmmio,&ck,0)) {
         goto FileError;
    }

    /* Write stream header data */
    if(mmioWrite(lpcs->hmmio, (LPSTR)&strhdr, sizeof(strhdr)) != sizeof(strhdr)) {
         goto FileError;
    }

    if(mmioAscend(lpcs->hmmio, &ck, 0)) {
         goto FileError;
    }

    /*
    **  !!! dont write palette for full color?
    */
    if (lpBitsInfoOut->bmiHeader.biBitCount > 8)
        lpBitsInfoOut->bmiHeader.biClrUsed = 0;

    /* Create DIB header chunk */
    ck.cksize = lpBitsInfoOut->bmiHeader.biSize +
                           lpBitsInfoOut->bmiHeader.biClrUsed *
                           sizeof(RGBQUAD);
    ck.ckid = ckidSTREAMFORMAT;
    if(mmioCreateChunk(lpcs->hmmio,&ck,0)) {
         goto FileError;
    }

    /* Write DIB header data */
    if(mmioWrite(lpcs->hmmio, (LPSTR)&lpBitsInfoOut->bmiHeader,
                               lpBitsInfoOut->bmiHeader.biSize) !=
             (LONG) lpBitsInfoOut->bmiHeader.biSize) {
         goto FileError;
    }

    if (lpBitsInfoOut->bmiHeader.biClrUsed > 0) {
        /* Get Palette info */
        if(GetPaletteEntries(lpcs->hPalCurrent, 0,
                                (WORD) lpBitsInfoOut->bmiHeader.biClrUsed,
                                (LPPALETTEENTRY) argbq) !=
                    (WORD)lpBitsInfoOut->bmiHeader.biClrUsed) {
            goto FileError;
        }

        for(i = 0; i < (int) lpBitsInfoOut->bmiHeader.biClrUsed; i++)
            SWAP(argbq[i].rgbRed, argbq[i].rgbBlue);

        /* Write Palette Info */
        dw = sizeof(RGBQUAD) * lpBitsInfoOut->bmiHeader.biClrUsed;
        if (mmioWrite(lpcs->hmmio, (LPSTR)argbq, dw) != (long)dw) {
            goto FileError;
        }
    }

    if(mmioAscend(lpcs->hmmio, &ck, 0)) {
         goto FileError;
    }

    // ADD FOURCC stuff here!!! for Video stream

    /* Ascend out of stream header */
    if(mmioAscend(lpcs->hmmio, &ckStream, 0)) {
         goto FileError;
    }

    /* If sound is enabled, then write WAVE header */
    if(fSound) {

         /* Create stream header list */
         ckStream.cksize = 0;
         ckStream.fccType = listtypeSTREAMHEADER;
         if(mmioCreateChunk(lpcs->hmmio,&ckStream,MMIO_CREATELIST)) {
             goto FileError;
         }

         _fmemset(&strhdr, 0, sizeof(strhdr));
         strhdr.fccType = streamtypeAUDIO;
         strhdr.fccHandler = 0L;
         strhdr.dwFlags = 0L;
         strhdr.wPriority = 0L;
         strhdr.wLanguage = 0L;
         strhdr.dwInitialFrames = 0L;
         strhdr.dwScale = lpcs->lpWaveFormat->nBlockAlign;
         strhdr.dwRate = lpcs->lpWaveFormat->nAvgBytesPerSec;
         strhdr.dwStart = 0L;
         strhdr.dwLength =  lpcs->dwWaveBytes /
                        lpcs->lpWaveFormat->nBlockAlign;
         strhdr.dwQuality = (DWORD)-1L;    /* !!! ICQUALITY_DEFAULT */
         strhdr.dwSampleSize = lpcs->lpWaveFormat->nBlockAlign;

         ck.ckid = ckidSTREAMHEADER;
         if(mmioCreateChunk(lpcs->hmmio,&ck,0)) {
             goto FileError;
         }

         if(mmioWrite(lpcs->hmmio, (LPSTR)&strhdr, sizeof(strhdr)) != sizeof(strhdr)) {
             goto FileError;
         }

         if(mmioAscend(lpcs->hmmio, &ck, 0)) {
             goto FileError;
         }

         ck.cksize = (LONG) GetSizeOfWaveFormat ((LPWAVEFORMATEX) lpcs->lpWaveFormat);
         ck.ckid = ckidSTREAMFORMAT;
         if(mmioCreateChunk(lpcs->hmmio,&ck,0)) {
             goto FileError;
         }

         /* Write WAVE header info */
         if(mmioWrite(lpcs->hmmio, (LPSTR)lpcs->lpWaveFormat, ck.cksize) != (LONG) ck.cksize) {
             goto FileError;
         }

         if(mmioAscend(lpcs->hmmio, &ck, 0)) {
             goto FileError;
         }

         /* Ascend out of stream header */
         if(mmioAscend(lpcs->hmmio, &ckStream, 0)) {
             goto FileError;
         }

    }

    // ADD FOURCC stuff here!!! for entire file
    DSTATUS(lpcs, "Writing Info chunks");
    if (lpcs->lpInfoChunks) {
        DSTATUS(lpcs, "Writing Info chunks");
        if (mmioWrite (lpcs->hmmio, lpcs->lpInfoChunks, lpcs->cbInfoChunks) !=
                lpcs->cbInfoChunks)
            goto FileError;
    }

    /* ascend from the Header list */
    if(mmioAscend(lpcs->hmmio, &ckList, 0)) {
         goto FileError;
    }


    ck.ckid = ckidAVIPADDING;
    if(mmioCreateChunk(lpcs->hmmio,&ck,0)) {
         goto FileError;
    }

    mmioSeek(lpcs->hmmio, lpcs->dwAVIHdrSize - 3 * sizeof(DWORD), SEEK_SET);

    if(mmioAscend(lpcs->hmmio, &ck, 0)) {
         goto FileError;
    }

    DSTATUS(lpcs, "Writing Movie LIST");

    /* Start the movi list */
    ckList.cksize = 0;
    ckList.fccType = listtypeAVIMOVIE;
    if(mmioCreateChunk(lpcs->hmmio,&ckList,MMIO_CREATELIST)) {
         goto FileError;
    }

    // Force the chunk to end on the next word boundary
    mmioSeek(lpcs->hmmio, dwDataEnd + (dwDataEnd & 1L), SEEK_SET);

    /* Ascend out of the movi list and the RIFF chunk so that */
    /* the sizes can be fixed */
    mmioAscend(lpcs->hmmio, &ckList, 0);

    /*
    ** Now write index out!
    */
    DSTATUS(lpcs, "Writing Index...");
    WriteIndex(lpcs, fWroteJunkChunks);

    lpcs->fFileCaptured = TRUE;     // we got a good file, allow editing of it
    goto Success;

FileError:
    lpcs->fFileCaptured = fRet = FALSE;      // bogus file - no editing allowed

Success:
    DSTATUS(lpcs, "Freeing Index...");
    FiniIndex (lpcs);
    mmioAscend(lpcs->hmmio, &ckRiff, 0);

    mmioSeek(lpcs->hmmio, 0, SEEK_END);

    mmioFlush(lpcs->hmmio, 0);

    /* Close the file */
    mmioClose(lpcs->hmmio, 0);
    lpcs->hmmio = NULL;

    return fRet;
}


// ****************************************************************
// ******************** Audio Buffer Control **********************
// ****************************************************************

// Audio buffers are always allocated under the presumption that
// audio capture may be enabled at any time.
// AVIAudioInit must be matched with AVIAudioFini (both only called once)
// AVIAudioPrepare must be matched with AVIAudioUnPrepare
//      (which may be called multiple times to enable and disable audio)


// AVI AudioInit - Allocate and initialize buffers for audio capture.
//                 This routine is also used by MCI capture.
//                 Returns: 0 on success, otherwise an error code.

WORD AVIAudioInit (LPCAPSTREAM lpcs)
{
    int         i;
    LPVOID        p;

    if (lpcs->sCapParms.wNumAudioRequested == 0)
        lpcs->sCapParms.wNumAudioRequested = DEF_WAVE_BUFFERS;

    // Alloc the wave memory
    for(i = 0; i < (int)lpcs->sCapParms.wNumAudioRequested; i++) {

        p = AllocMem(sizeof(WAVEHDR) + lpcs->dwWaveSize, FALSE /* DOSMem */);

        if (p == NULL)
            break;

        lpcs->alpWaveHdr[i] = p;
        lpcs->alpWaveHdr[i]->lpData          = (LPBYTE)p
                                               + sizeof(WAVEHDR) + sizeof(RIFF);
        lpcs->alpWaveHdr[i]->dwBufferLength  = lpcs->dwWaveSize - sizeof(RIFF);
        lpcs->alpWaveHdr[i]->dwBytesRecorded = 0;
        lpcs->alpWaveHdr[i]->dwUser          = 0;
        lpcs->alpWaveHdr[i]->dwFlags         = 0;
        lpcs->alpWaveHdr[i]->dwLoops         = 0;

        /* Set Chunk ID, Size in buffer */
        p = (LPBYTE)p + sizeof(WAVEHDR);

        ((LPRIFF)p)->dwType = MAKEAVICKID(cktypeWAVEbytes, 1);
        ((LPRIFF)p)->dwSize = lpcs->dwWaveSize - sizeof(RIFF);
    }

    lpcs->iNumAudio = i;

    return ((lpcs->iNumAudio == 0) ? IDS_CAP_WAVE_ALLOC_ERROR : 0);
}


//
// AVI AudioFini    - UnPrepares headers and resets the wave device.
//                      This routine is also used by MCI capture.
//                      Returns: 0 on success, otherwise an error code.

WORD AVIAudioFini (LPCAPSTREAM lpcs)
{
    int i;

    /* free headers and data */
    for(i=0; i < MAX_WAVE_BUFFERS; i++) {
        if (lpcs->alpWaveHdr[i]) {
            FreeMem(lpcs->alpWaveHdr[i]);
            lpcs->alpWaveHdr[i] = NULL;
        }
    }

    return 0;
}


//
// AVI AudioPrepare - Opens the wave device and adds the buffers
//                    Prepares headers and adds buffers to the device
//                    This routine is also used by MCI capture.
//                    Returns: 0 on success, otherwise an error code.

WORD AVIAudioPrepare (LPCAPSTREAM lpcs, HWND hWndCallback)
{
    UINT        uiError;
    int i;

    /* See if we can open that format for input */

    uiError = waveInOpen((LPHWAVEIN)&lpcs->hWaveIn,
        (UINT)WAVE_MAPPER, lpcs->lpWaveFormat,
        (DWORD) hWndCallback, 0L,
        (hWndCallback ? CALLBACK_WINDOW : 0L));

    if (uiError != MMSYSERR_NOERROR)
        return IDS_CAP_WAVE_OPEN_ERROR;

    lpcs->fAudioYield = IsWaveInDeviceMapped(lpcs->hWaveIn);
    lpcs->fAudioBreak = FALSE;
    DPF("AVICap:    AudioYield = %d \n", lpcs->fAudioYield);

    for(i = 0; i < (int)lpcs->sCapParms.wNumAudioRequested; i++) {
        if (waveInPrepareHeader(lpcs->hWaveIn, lpcs->alpWaveHdr[i],
                sizeof(WAVEHDR)))
            return IDS_CAP_WAVE_ALLOC_ERROR;

        if (waveInAddBuffer(lpcs->hWaveIn, lpcs->alpWaveHdr[i],
                sizeof(WAVEHDR)))
            return IDS_CAP_WAVE_ALLOC_ERROR;
    }

    lpcs->iNextWave = 0;        // current wave
    lpcs->dwWaveBytes = 0L;     // number of wave bytes
    lpcs->dwWaveChunkCount = 0; // number of wave frames

    return 0;
}

//
// AVI AudioUnPrepare - UnPrepares headers and closes the wave device.
//                      This routine is also used by MCI capture.
//                      Returns: 0 on success, otherwise an error code.

WORD AVIAudioUnPrepare (LPCAPSTREAM lpcs)
{
    int i;

    if (lpcs->hWaveIn) {
        waveInReset(lpcs->hWaveIn);

        /* unprepare headers by unlocking them */
        for(i=0; i < lpcs->iNumAudio; i++) {
            if (lpcs->alpWaveHdr[i]) {
                if (lpcs->alpWaveHdr[i]->dwFlags & WHDR_PREPARED)
                    waveInUnprepareHeader(lpcs->hWaveIn, lpcs->alpWaveHdr[i],
                                sizeof(WAVEHDR));
            }
        }

        waveInClose(lpcs->hWaveIn);
        lpcs->hWaveIn = NULL;
    }
    return 0;
}

// ****************************************************************
// ******************** Video Buffer Control **********************
// ****************************************************************

// AVIVideoInit -  Allocates, and initialize buffers for video capture.
//                 This routine is also used by MCI capture.
//                 Returns: 0 on success, otherwise an error code.

WORD AVIVideoInit (LPCAPSTREAM lpcs)
{
    int         iMaxVideo;
    DWORD       dwFreeMem;
    DWORD       dwUserRequests;
    DWORD       dwAudioMem;
    int         i;
    LPVOID      p;

    lpcs->iNextVideo = 0;
    lpcs->dwVideoChunkCount = 0;
    lpcs->dwFramesDropped = 0;

    // When performing MCI step capture, buffer array is not used
    if (lpcs->sCapParms.fStepMCIDevice)
        return 0;

    // If the user hasn't specified the number of video buffers to use,
    // assume the minimum

    if (lpcs->sCapParms.wNumVideoRequested == 0)
        lpcs->sCapParms.wNumVideoRequested = MIN_VIDEO_BUFFERS;

    iMaxVideo = min (MAX_VIDEO_BUFFERS, lpcs->sCapParms.wNumVideoRequested);

    // Post VFW 1.1a, see if the driver can allocate memory
    if (videoStreamAllocHdrAndBuffer (lpcs->hVideoIn,
                (LPVIDEOHDR FAR *) &p, (DWORD) sizeof(VIDEOHDR) + lpcs->dwVideoSize)
                        == DV_ERR_OK) {
        lpcs-> fBuffersOnHardware = TRUE;
        videoStreamFreeHdrAndBuffer (lpcs->hVideoIn, (LPVIDEOHDR) p);
    }
    else {
        lpcs-> fBuffersOnHardware = FALSE;

        // How much actual free physical memory exists?
        dwFreeMem = GetFreePhysicalMemory();

        dwAudioMem = lpcs->dwWaveSize * lpcs->sCapParms.wNumAudioRequested;

#define FOREVER_FREE 32768L   // Always keep this free for swap space

        // How much memory will be used if we allocate per the request?
        dwUserRequests = dwAudioMem +
                     lpcs->dwVideoSize * iMaxVideo +
                     FOREVER_FREE;

        // If request is greater than available memory, force fewer buffers
        if (dwUserRequests > dwFreeMem) {
            if (dwFreeMem > dwAudioMem)
                dwFreeMem -= dwAudioMem;
            iMaxVideo = (int)(((dwFreeMem * 8) / 10) / lpcs->dwVideoSize);
            iMaxVideo = min (MAX_VIDEO_BUFFERS, iMaxVideo);
            dprintf("iMaxVideo = %d\n", iMaxVideo);
        }
    } // endif not allocating buffers from hardware

    // Set up the buffers presuming fixed size DIBs and Junk chunks
    // These will be modified later if the device provides compressed data

    for (i=0; i < iMaxVideo; i++) {

        if (lpcs-> fBuffersOnHardware)
            videoStreamAllocHdrAndBuffer (lpcs->hVideoIn,
                (LPVIDEOHDR FAR *) &p, sizeof(VIDEOHDR) + lpcs->dwVideoSize);
        else
            p = AllocMem(sizeof(VIDEOHDR) + lpcs->dwVideoSize, lpcs->sCapParms.fUsingDOSMemory /* DOSMem */);

        if (p == NULL)
            break;

        lpcs->alpVideoHdr[i] = p;
        lpcs->alpVideoHdr[i]->lpData          = (LPBYTE)p + sizeof(VIDEOHDR) + sizeof(RIFF);
        lpcs->alpVideoHdr[i]->dwBufferLength  = lpcs->lpBitsInfo->bmiHeader.biSizeImage;
        lpcs->alpVideoHdr[i]->dwBytesUsed     = 0;
        lpcs->alpVideoHdr[i]->dwTimeCaptured  = 0;
        lpcs->alpVideoHdr[i]->dwUser          = 0;
        // Buffers on hardware are marked prepared during allocation!
        if (!lpcs-> fBuffersOnHardware)
            lpcs->alpVideoHdr[i]->dwFlags     = 0;

        p = (LPBYTE)p + sizeof(VIDEOHDR);

        if (lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RLE8)
             ((LPRIFF)p)->dwType = MAKEAVICKID(cktypeDIBcompressed, 0);
        else
             ((LPRIFF)p)->dwType = MAKEAVICKID(cktypeDIBbits, 0);
         ((LPRIFF)p)->dwSize = lpcs->lpBitsInfo->bmiHeader.biSizeImage;

         if(lpcs->dwVideoJunkSize) {
             p = ((BYTE huge *)p) + ((LPRIFF)p)->dwSize + sizeof(RIFF);

             ((LPRIFF)p)->dwType = ckidAVIPADDING;;
             ((LPRIFF)p)->dwSize = lpcs->dwVideoJunkSize;
         }
    }

    lpcs->iNumVideo = i;

    if (lpcs-> fBuffersOnHardware)
        dprintf("HARDWARE iNumVideo Allocated = %d \n", lpcs->iNumVideo);
    else if (lpcs->sCapParms.fUsingDOSMemory)
        dprintf("DOS iNumVideo Allocated = %d \n", lpcs->iNumVideo);
    else
        dprintf("HIGH iNumVideo Allocated = %d \n", lpcs->iNumVideo);

    return ((lpcs->iNumVideo == 0) ? IDS_CAP_VIDEO_ALLOC_ERROR : 0);
}

//
// AVIVideoPrepare -  Prepares headers and adds buffers to the device
//                    This routine is also used by MCI capture.
//                    Returns: 0 on success, otherwise an error code.
WORD AVIVideoPrepare (LPCAPSTREAM lpcs)
{
    int i;

    // When performing MCI step capture, buffer array is not used
    if (lpcs->sCapParms.fStepMCIDevice)
        return 0;

    // Open the video stream, setting the capture rate
    if (videoStreamInit(lpcs->hVideoIn,
                lpcs->sCapParms.dwRequestMicroSecPerFrame,
                0L, 0L, 0L )) {
        dprintf("cant open video device!\n");
        return IDS_CAP_VIDEO_OPEN_ERROR;
    }

    // Prepare (lock) the buffers, and give them to the device
    for (i=0; i < lpcs->iNumVideo; i++) {
        // If the buffers are on the hardware, don't Prepare them
        if (!lpcs-> fBuffersOnHardware) {
            if (videoStreamPrepareHeader (lpcs->hVideoIn,
                        lpcs->alpVideoHdr[i], sizeof(VIDEOHDR))) {
                lpcs->iNumVideo = i;
                dprintf("**** could only prepare %d Video!\n", lpcs->iNumVideo);
                break;
            }
        }

        if (videoStreamAddBuffer(lpcs->hVideoIn, lpcs->alpVideoHdr[i], sizeof(VIDEOHDR)))
             return IDS_CAP_VIDEO_ALLOC_ERROR;
    }
    return 0;
}

//
// AVI VideoUnPrepare - UnPrepares headers, frees memory, and
//                      resets the video in device.
//                      This routine is also used by MCI capture.
//                      Returns: 0 on success, otherwise an error code.

WORD AVIVideoUnPrepare (LPCAPSTREAM lpcs)
{
    int i;

    // When performing MCI step capture, buffer array is not used
    if (lpcs->sCapParms.fStepMCIDevice)
        return 0;

    /* Reset the buffers so they can be freed */
    if (lpcs->hVideoIn) {
        videoStreamReset(lpcs->hVideoIn);

        /* unprepare headers */
        /* Unlock and free headers and data */

        for(i = 0; i < MAX_VIDEO_BUFFERS; i++) {
            if (lpcs->alpVideoHdr[i]) {
                if (!lpcs-> fBuffersOnHardware) {
                    if (lpcs->alpVideoHdr[i]->dwFlags & VHDR_PREPARED)
                        videoStreamUnprepareHeader(lpcs->hVideoIn,
                            lpcs->alpVideoHdr[i],sizeof(VIDEOHDR));

                    FreeMem(lpcs->alpVideoHdr[i]);
                }
                else
                    videoStreamFreeHdrAndBuffer(lpcs->hVideoIn, lpcs->alpVideoHdr[i]);
                lpcs->alpVideoHdr[i] = NULL;
            }
        }
        // Shut down the video stream
        videoStreamFini(lpcs->hVideoIn);
    }
    return 0;
}

/*
 *  AVI Fini    - undo the mess that AVIInit did.
 *
 */
void AVIFini(LPCAPSTREAM lpcs)
{
    if (lpcs->lpDOSWriteBuffer) {
        FreeMem(lpcs->lpDOSWriteBuffer);
        lpcs->lpDOSWriteBuffer = NULL;
    }

    AVIVideoUnPrepare (lpcs);           // Free the video device and buffers

    AVIAudioUnPrepare (lpcs);           // Free the audio device
    AVIAudioFini (lpcs);                // Free the audio buffers
}

//
// AVI Init
//     This routine does all the non-File initalization for AVICapture.
//     Returns: 0 on success, Error string value on failure.
//

WORD AVIInit (LPCAPSTREAM lpcs)
{
    WORD         wError = 0;    // Success
    int          i;
    LPBITMAPINFO lpBitsInfoOut;    // Possibly compressed output format

    /* No special video format given -- use the default */
    if (lpcs->CompVars.hic == NULL)
	lpBitsInfoOut = lpcs->lpBitsInfo;
    else
	lpBitsInfoOut = lpcs->CompVars.lpbiOut;

    // -------------------------------------------------------
    // figure out buffer sizes
    // -------------------------------------------------------

    // Init all pointers to NULL
    for(i = 0; i < MAX_VIDEO_BUFFERS; i++)
        lpcs->alpVideoHdr[i] = NULL;

    for(i = 0; i < MAX_WAVE_BUFFERS; i++)
        lpcs->alpWaveHdr[i] = NULL;

    // .5 second of audio per buffer (or 10K, whichever is larger)
    if (lpcs->sCapParms.dwAudioBufferSize == 0)
        lpcs->dwWaveSize =  CalcWaveBufferSize (lpcs);
    else {
        if (!lpcs-> lpWaveFormat)
            lpcs->dwWaveSize = 0;
        else
            lpcs->dwWaveSize = lpcs->sCapParms.dwAudioBufferSize;
    }
    /* Set video buffer size to Image size
        (normally dx * dy * (depth / 8)) + sizeof(RIFF) */
    lpcs->dwVideoSize = lpcs->lpBitsInfo->bmiHeader.biSizeImage + sizeof(RIFF);
    lpcs->fVideoDataIsCompressed = (lpBitsInfoOut->bmiHeader.biCompression
                != BI_RGB);

    /* Pad out to multiple of lpcs->sCapParms.wChunkGranularity (2K) size */
    // Calc dwVideoJunkSize

    if (lpcs->dwVideoJunkSize = lpcs->sCapParms.wChunkGranularity - (lpcs->dwVideoSize % lpcs->sCapParms.wChunkGranularity)) {
         if (lpcs->dwVideoJunkSize < sizeof(RIFF))
             lpcs->dwVideoJunkSize += lpcs->sCapParms.wChunkGranularity;

         lpcs->dwVideoSize += lpcs->dwVideoJunkSize;

         lpcs->dwVideoJunkSize -= sizeof(RIFF);
    } else {
         lpcs->dwVideoJunkSize = 0L;
    }

    // -------------------------------------------------------
    //                    DOS copy buffer
    // -------------------------------------------------------

    lpcs->dwDOSBufferSize = max (lpcs->dwWaveSize, lpcs->dwVideoSize);

#if 0
    // Only get a DOS copy buffer if we're not trying to get DOS video buffers
    if (!lpcs->sCapParms.fUsingDOSMemory) {
        lpcs->lpDOSWriteBuffer = AllocDosMem(lpcs->dwDOSBufferSize);

        if (lpcs->lpDOSWriteBuffer) {
            dprintf("Allocated DOS write buffer (%ld bytes).\n", lpcs->dwDOSBufferSize);
        } else {
            dprintf("Unable to allocate DOS write buffer.\n");
        }
    }
#endif

    // -------------------------------------------------------
    //                    Init Sound
    // -------------------------------------------------------

    if (lpcs->sCapParms.fCaptureAudio) {
        if (wError = AVIAudioInit (lpcs)) {
            dprintf("can't init audio buffers!\n");
            goto AVIInitFailed;
        }
    }

    // -------------------------------------------------------
    //                    Init Video
    // -------------------------------------------------------

    if (wError = AVIVideoInit (lpcs)) {
        dprintf("AVIVideoInitFailed (no buffers alloc'd)!\n");
        goto AVIInitFailed;
    }

    // --------------------------------------------------------------
    //  Prepare audio buffers (lock em down) and give them to the device
    // --------------------------------------------------------------

    if (lpcs->sCapParms.fCaptureAudio) {
        if (wError = AVIAudioPrepare (lpcs, NULL)) {
            dprintf("can't prepare audio buffers!\n");
            goto AVIInitFailed;
        }
    }

    // --------------------------------------------------------------
    //  Prepare video buffers (lock em down) and give them to the device
    // --------------------------------------------------------------

    if (wError = AVIVideoPrepare (lpcs)) {
        dprintf("can't prepare video buffers!\n");
        goto AVIInitFailed;
    }

    // -------------------------------------------------------
    //   all done, return success
    // -------------------------------------------------------

    return (0);            // SUCCESS !

    // -------------------------------------------------------
    //   we got a error, return string ID of error message
    // -------------------------------------------------------
AVIInitFailed:
    AVIFini(lpcs);      // Shutdown everything
    return wError;
}

// Write data to the capture file
// Returns: TRUE on a successful write
BOOL NEAR PASCAL AVIWrite(LPCAPSTREAM lpcs, LPVOID p, DWORD dwSize)
{
    if (lpcs->lpDOSWriteBuffer) {
        MemCopy(lpcs->lpDOSWriteBuffer, p, dwSize);
        p = lpcs->lpDOSWriteBuffer;
    }

    return mmioWrite(lpcs->hmmio, p, (long)dwSize) == (long)dwSize;
}

//
// Writes dummy frames which on playback just repeat the previous frame
// nCount is a count of the number of frames to write
// Returns: TRUE on a successful write
BOOL AVIWriteDummyFrames (LPCAPSTREAM lpcs, int nCount)
{
    DWORD dwBytesToWrite;
    DWORD dwJunkSize;
    LPRIFF p;
    int j;

    p = (LPRIFF) lpcs->DropFrame;
    for (j = 0; j < nCount; j++) {
        // The index includes info on if this is a dummy chunk,
        // AND if this is the last dummy chunk in a sequence
        IndexVideo (lpcs, IS_DUMMY_CHUNK |
                ((j == nCount - 1) ? IS_LAST_DUMMY_CHUNK : 0), FALSE);
        if (lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RLE8)
            p->dwType = MAKEAVICKID(cktypeDIBcompressed, 0);
        else
            p->dwType  = MAKEAVICKID(cktypeDIBbits, 0);
        p->dwSize  = 0;
        p++;
    }

    dwBytesToWrite = nCount * sizeof(RIFF);

    /* Pad out to multiple of lpcs->sCapParms.wChunkGranularity (2K) size */

    if (dwJunkSize = (dwBytesToWrite % lpcs->sCapParms.wChunkGranularity)) {
       dwJunkSize = lpcs->sCapParms.wChunkGranularity - dwJunkSize;
       if (dwJunkSize < sizeof(RIFF))
            dwJunkSize += lpcs->sCapParms.wChunkGranularity;

        dwBytesToWrite += dwJunkSize;

        dwJunkSize -= sizeof(RIFF);
    } else {
        dwJunkSize = 0L;
    }

    // Now create a new junk chunk at the end of the compressed data
    if(dwJunkSize) {
        p->dwType = ckidAVIPADDING;
        p->dwSize = dwJunkSize;
    }

    /* write out the dummy frames, and possibly the junk chunk */
    return (AVIWrite(lpcs, lpcs->DropFrame, dwBytesToWrite));
}

// Writes compressed or uncompressed frames to the AVI file
// returns TRUE if no error, FALSE if end of file.

BOOL AVIWriteVideoFrame (LPCAPSTREAM lpcs, LPVIDEOHDR lpVidHdr)
{
    DWORD dwBytesToWrite;
    DWORD dwJunkSize;
    LPVOID p;
    LPVOID lpData;

    // If the device compresses the data, calculate new junk chunk
    // and fix the RIFF header

    //
    // We are automatically compressing during capture, so
    // first compress the frame.
    //
    if (lpcs->CompVars.hic) {
        DWORD       dwBytesUsed = 0;	// don't force a data rate
        BOOL        fKeyFrame;

        lpData = ICSeqCompressFrame(&lpcs->CompVars, 0,
            lpVidHdr->lpData, &fKeyFrame, &dwBytesUsed);

        ((RIFF FAR*)lpData)[-1].dwType = MAKEAVICKID(cktypeDIBbits, 0);
        ((RIFF FAR*)lpData)[-1].dwSize = dwBytesUsed;

        if (fKeyFrame)
            lpVidHdr->dwFlags |= VHDR_KEYFRAME;
        else
            lpVidHdr->dwFlags &= ~VHDR_KEYFRAME;

        lpVidHdr->dwBytesUsed = dwBytesUsed;
    }
    else {
        lpData = lpVidHdr->lpData;
    }

    if (lpcs->fVideoDataIsCompressed) {       // ie. if not BI_RGB

        // change the dwSize field in the RIFF chunk
        *((LPDWORD)((BYTE _huge *)lpVidHdr->lpData - sizeof(DWORD)))
                = lpVidHdr->dwBytesUsed;

         // Make sure that the JUNK chunk starts on a WORD boundary
         if (lpVidHdr->dwBytesUsed & 1)
             ++lpVidHdr->dwBytesUsed;

        dwBytesToWrite = lpVidHdr->dwBytesUsed + sizeof(RIFF);

        /* Pad out to multiple of lpcs->sCapParms.wChunkGranularity (2K) size */

        if (dwJunkSize = (dwBytesToWrite % lpcs->sCapParms.wChunkGranularity)) {
             dwJunkSize = lpcs->sCapParms.wChunkGranularity - dwJunkSize;
             if (dwJunkSize < sizeof(RIFF))
                dwJunkSize += lpcs->sCapParms.wChunkGranularity;

            dwBytesToWrite += dwJunkSize;

             // Now create a new junk chunk at the end of the compressed data
             p = (BYTE huge *)lpVidHdr->lpData + lpVidHdr->dwBytesUsed;

             ((LPRIFF)p)->dwType = ckidAVIPADDING;
             ((LPRIFF)p)->dwSize = dwJunkSize - sizeof(RIFF);
        }
    } // endif compressed data
    else {
        dwBytesToWrite = lpcs->dwVideoSize;
    } // endif not compressed data

    /* write out the chunk, video data, and possibly the junk chunk */
    return (AVIWrite(lpcs, (LPBYTE)lpData - sizeof(RIFF), dwBytesToWrite));
}

//
// Maintains info chunks which are written to the AVI header
//
BOOL FAR PASCAL SetInfoChunk(LPCAPSTREAM lpcs, LPCAPINFOCHUNK lpcic)
{
    DWORD       ckid   = lpcic->fccInfoID;
    LPVOID      lpData = lpcic->lpData;
    LONG        cbData = lpcic->cbData;
    LPBYTE      lp;
    LPBYTE      lpw;
    LPBYTE      lpEnd;
    LPBYTE      lpNext;
    LONG        cbSizeThis;
    BOOL        fOK = FALSE;

    // Delete all info chunks?
    if (ckid == 0) {
        if (lpcs->lpInfoChunks) {
            GlobalFreePtr (lpcs->lpInfoChunks);
            lpcs->lpInfoChunks = NULL;
            lpcs->cbInfoChunks = 0;
        }
        return TRUE;
    }

    // Try removing an entry if it already exists...
    // Also used if lpData is NULL to just remove an entry
    lpw   = (LPBYTE)lpcs->lpInfoChunks;           // always points at fcc
    lpEnd = (LPBYTE)lpcs->lpInfoChunks + lpcs->cbInfoChunks;
    while (lpw < lpEnd) {
        cbSizeThis = ((LPDWORD)lpw)[1];
        cbSizeThis += cbSizeThis & 1;           // force WORD alignment
        lpNext = lpw + cbSizeThis + sizeof (DWORD) * 2;
        if ((*(LPDWORD) lpw) == ckid) {
            lpcs->cbInfoChunks -= cbSizeThis + sizeof (DWORD) * 2;
            if (lpNext <= lpEnd) {
                if (lpEnd - lpNext)
                    hmemcpy(lpw, lpNext, lpEnd - lpNext);
                if (lpcs->cbInfoChunks) {
	           lpcs->lpInfoChunks = (LPBYTE) GlobalReAllocPtr( // shrink it
                        lpcs->lpInfoChunks,
                        lpcs->cbInfoChunks,
                        GMEM_MOVEABLE);
                }
                else {
                    if (lpcs->lpInfoChunks)
                        GlobalFreePtr (lpcs->lpInfoChunks);
                    lpcs->lpInfoChunks = NULL;
                }
                fOK = TRUE;
            }
            break;
        }
        else
            lpw = lpNext;
    }

    if (lpData == NULL || cbData == 0)         // Only deleting, get out
        return fOK;

    // Add a new entry
    cbData += cbData & 1;               // force WORD alignment
    cbData += sizeof(DWORD) * 2;        // add sizeof 2 FOURCCs
    if (lpcs->lpInfoChunks) {
	lp = (LPBYTE) GlobalReAllocPtr(lpcs->lpInfoChunks, lpcs->cbInfoChunks + cbData, GMEM_MOVEABLE);
    } else {
	lp = (LPBYTE) GlobalAllocPtr(GMEM_MOVEABLE, cbData);
    }

    if (!lp)
	return FALSE;

    // build RIFF chunk in block
    ((DWORD FAR *) (lp + lpcs->cbInfoChunks))[0] = ckid;
    ((DWORD FAR *) (lp + lpcs->cbInfoChunks))[1] = lpcic->cbData;

    hmemcpy(lp + lpcs->cbInfoChunks + sizeof(DWORD) * 2,
	    lpData,
	    cbData - sizeof(DWORD) * 2);
    lpcs->lpInfoChunks = lp;
    lpcs->cbInfoChunks += cbData;

    return TRUE;
}


/*
 *  AVI Capture
 *      This is the main streaming capture loop for both audio and
 * video.  It will first init all buffers and drivers and then go into a
 * loop checking for buffers to be filled.  When a buffer is filled then
 * the data for it is written out.
 * Afterwards it cleans up after itself (frees buffers etc...)
 * Returns: 0 on success, else error code
 */
void FAR PASCAL _loadds AVICapture1(LPCAPSTREAM lpcs)
{
    BOOL        fOK = TRUE;
    BOOL        fT;
    BOOL        fVideoBuffersInDOSMem;
    BOOL        fStopping;         // True when finishing capture
    BOOL        fStopped;          // True if driver notified to stop
    DWORD       dw;
    char        ach[128];
    char        achMsg[128];
    WORD        w;
    WORD        wError;         // Error String ID
    DWORD       dwDriverDropCount;
    WORD        wSmartDrv;
    LPVIDEOHDR  lpVidHdr;
    LPWAVEHDR   lpWaveHdr;
    DWORD       dwTimeStarted;  // When did we start in milliseconds
    DWORD       dwTimeStopped;
    DWORD       dwTimeToStop;   // Lesser of MCI capture time or frame limit
    BOOL        fTryToPaint = FALSE;
    HDC         hdc;
    HPALETTE    hpalT;
    HCURSOR     hOldCursor;
    RECT        rcDrawRect;
    DWORD       dwStreamError;
    CAPINFOCHUNK cic;

    lpcs-> dwReturn = DV_ERR_OK;

    hOldCursor = SetCursor(lpcs->hWaitCursor);

    statusUpdateStatus(lpcs, IDS_CAP_BEGIN);  // Always the first message

    // If not 1 Meg. free, give it up!!!
    if (GetFreePhysicalMemory () < (1024L * 1024L)) {
        errorUpdateError (lpcs, IDS_CAP_OUTOFMEM);
        lpcs-> dwReturn = IDS_CAP_OUTOFMEM;
        goto EarlyExit;
    }

    statusUpdateStatus(lpcs, IDS_CAP_STAT_CAP_INIT);

    // Try painting the DIB only if Live window
    fTryToPaint = lpcs->fLiveWindow;

    if (fTryToPaint) {
        hdc = GetDC(lpcs->hwnd);
        SetWindowOrg(hdc, lpcs->ptScroll.x, lpcs->ptScroll.y);
        hpalT = DrawDibGetPalette (lpcs->hdd);
        if (hpalT)
            hpalT = SelectPalette( hdc, hpalT, FALSE);
        RealizePalette(hdc);
        if (lpcs-> fScale)
            GetClientRect (lpcs->hwnd, &rcDrawRect);
        else
            SetRect (&rcDrawRect, 0, 0, lpcs->dxBits, lpcs->dyBits);
    }

    // -------------------------------------------------------
    //   When should capture stop?
    // -------------------------------------------------------

    // If using MCI, capture for the shorter of the MCI period,
    // or the capture limit

    if (lpcs->sCapParms.fLimitEnabled)
        dwTimeToStop = (DWORD) ((DWORD) 1000 * lpcs->sCapParms.wTimeLimit);
    else
        dwTimeToStop = (DWORD) -1L; // very large

    if (lpcs->sCapParms.fMCIControl) {
        // if MCI stop time not given, use lpcs->sCapParms.wTimeLimit
        if (lpcs->sCapParms.dwMCIStopTime == lpcs->sCapParms.dwMCIStartTime)
                    lpcs->sCapParms.dwMCIStopTime = lpcs->sCapParms.dwMCIStartTime +
                    (DWORD) ((DWORD)1000 * lpcs->sCapParms.wTimeLimit);

        dw = lpcs->sCapParms.dwMCIStopTime - lpcs->sCapParms.dwMCIStartTime;

        if (lpcs->sCapParms.fLimitEnabled)
            dwTimeToStop = min (dw, dwTimeToStop);
        else
            dwTimeToStop = dw;
    }

    //
    // never ever try to capture more than the index size!
    //
    if (lpcs->fCapturingToDisk) {
        dw = muldiv32(lpcs->sCapParms.dwIndexSize,
                lpcs->sCapParms.dwRequestMicroSecPerFrame,
                1000l);

        dwTimeToStop = min (dw, dwTimeToStop);
    }

    if (lpcs->sCapParms.fMCIControl) {
        fOK = FALSE;            // Assume the worst
        if (MCIDeviceOpen (lpcs)) {
            if (MCIDeviceSetPosition (lpcs, lpcs->sCapParms.dwMCIStartTime))
                fOK = TRUE;
        }
        if (!fOK) {
            errorUpdateError (lpcs, IDS_CAP_MCI_CONTROL_ERROR);
            statusUpdateStatus(lpcs, NULL);    // Clear status
            lpcs-> dwReturn = IDS_CAP_MCI_CONTROL_ERROR;
            goto EarlyExit;
        }
    }

    //
    // If we're compressing while capturing, warm up the compressor
    //
    if (lpcs->CompVars.hic) {
        if (ICSeqCompressFrameStart(&lpcs->CompVars, lpcs->lpBitsInfo) == NULL) {

	    // !!! We're in trouble here!
            dprintf("ICSeqCompressFrameStart failed !!!\n");
            lpcs-> dwReturn = IDS_CAP_COMPRESSOR_ERROR;
            errorUpdateError (lpcs, IDS_CAP_COMPRESSOR_ERROR);
            goto EarlyExit;
        }
        // Kludge, offset the lpBitsOut ptr
        // Compman allocates the compress buffer too large by
        // 2048 + 16 so we will still have room
        ((LPBYTE) lpcs->CompVars.lpBitsOut) += 8;
    }

    // No compression desired
    if (!lpcs->CompVars.hic)
	WinAssert(lpcs->CompVars.lpbiOut == NULL);

    // -------------------------------------------------------
    //  Open the output file
    // -------------------------------------------------------

    if (lpcs->fCapturingToDisk) {
        if (!AVIFileInit(lpcs)) {
            lpcs-> dwReturn = IDS_CAP_FILE_OPEN_ERROR;
            errorUpdateError (lpcs, IDS_CAP_FILE_OPEN_ERROR);
            goto EarlyExit;
        }
    }

    /* Make sure the parent has been repainted */
    UpdateWindow(lpcs->hwnd);

    //
    // call AVIInit() to get all the capture memory we will need
    //

    // Don't use DOS memory if capturing to Net
    fVideoBuffersInDOSMem = lpcs->sCapParms.fUsingDOSMemory;

    wError = AVIInit(lpcs);

    if (wError && fVideoBuffersInDOSMem) {
        lpcs->sCapParms.fUsingDOSMemory = FALSE;
        wError = AVIInit(lpcs);
    }

    if (wError) {
        /* Error in initalization - return */
        errorUpdateError (lpcs, wError);
        AVIFini(lpcs);
        AVIFileFini(lpcs, TRUE /* fWroteJunkChunks */, TRUE /* fAbort */);
        statusUpdateStatus(lpcs, NULL);    // Clear status
        lpcs-> dwReturn = wError;
        goto EarlyExit;
    }

    /* Click OK to capture string (must follow AVIInit) */
    LoadString(lpcs->hInst, IDS_CAP_SEQ_MSGSTART, ach, sizeof(ach));
    wsprintf(achMsg, ach, (LPSTR)lpcs->achFile);

    statusUpdateStatus(lpcs, NULL);

    // -------------------------------------------------------
    //   Ready to go, make the user click OK?
    // -------------------------------------------------------

    if (lpcs->sCapParms.fMakeUserHitOKToCapture && lpcs->fCapturingToDisk) {
	w = MessageBox(lpcs->hwnd, achMsg, "", MB_OKCANCEL | MB_ICONEXCLAMATION);
        if (w == IDCANCEL) {
            /* clean-up and get out */
            AVIFini(lpcs);
            AVIFileFini(lpcs, TRUE /* fWroteJunkChunks */, TRUE /* fAbort */);
            statusUpdateStatus(lpcs, NULL);    // Clear status
            goto EarlyExit;
        }
    } // endif forcing user to hit OK

    /* update the status, so the user knows how to stop */
    statusUpdateStatus(lpcs, IDS_CAP_SEQ_MSGSTOP);
    UpdateWindow(lpcs->hwnd);

    lpcs-> fCapturingNow = TRUE;

    GetAsyncKeyState(lpcs->sCapParms.vKeyAbort);
    GetAsyncKeyState(VK_ESCAPE);
    GetAsyncKeyState(VK_LBUTTON);
    GetAsyncKeyState(VK_RBUTTON);

    if (lpcs->sCapParms.fDisableWriteCache)
        wSmartDrv = SmartDrv(lpcs->achFile[0], (WORD)-1);  // turn all off....

    // Insert the digitization time
    cic.fccInfoID = mmioFOURCC ('I','D','I','T');
    time (&ltime);
    cic.lpData = (LPSTR) ctime(&ltime);
    cic.cbData  = 26;
    SetInfoChunk (lpcs, &cic);


    // -------------------------------------------------------
    //   Start MCI, Audio, and video streams
    // -------------------------------------------------------

    if (lpcs-> CallbackOnControl) {
        // Callback will preroll, then return on frame accurate postion
        // The 1 indicates recording is about to start
        // Callback can return FALSE to exit without capturing
        if (!((*(lpcs->CallbackOnControl)) (lpcs->hwnd, CONTROLCALLBACK_PREROLL ))) {
            /* clean-up and get out */
            AVIFini(lpcs);
            AVIFileFini(lpcs, TRUE /* fWroteJunkChunks */, TRUE /* fAbort */);
            statusUpdateStatus(lpcs, NULL);    // Clear status
            goto EarlyExit;
        }
    }

    if (lpcs->sCapParms.fMCIControl)
        MCIDevicePlay (lpcs);

    dwTimeStarted = timeGetTime();

    if(lpcs->sCapParms.fCaptureAudio)
        waveInStart(lpcs->hWaveIn);

    videoStreamStart(lpcs->hVideoIn);

    // -------------------------------------------------------
    //   MAIN CAPTURE LOOP
    // -------------------------------------------------------

    fOK=TRUE;
    fStopping = FALSE;    // TRUE when we need to stop
    fStopped = FALSE;     // TRUE if drivers notified we have stopped
    lpcs->dwTimeElapsedMS = 0;

    lpVidHdr = lpcs->alpVideoHdr[lpcs->iNextVideo];
    lpWaveHdr = lpcs->alpWaveHdr[lpcs->iNextWave];

    for (;;) {

        // The INTEL driver uses the GetError message to
        // process buffers, so call it often...
        videoStreamGetError (lpcs->hVideoIn, &dwStreamError, &dwDriverDropCount);

        // What time is it?
        lpcs->dwTimeElapsedMS = timeGetTime() - dwTimeStarted;

        // -------------------------------------------------------
        //        Is video buffer ready to be written?
        // -------------------------------------------------------
        if ((lpVidHdr->dwFlags & VHDR_DONE)) {
            if (lpVidHdr-> dwBytesUsed) {
                // Current time in milliseconds
                dw = muldiv32 ((lpcs->dwVideoChunkCount + 1),
                                lpcs->sCapParms.dwRequestMicroSecPerFrame, 1000);
                if (lpcs->CallbackOnVideoStream)
                    (*(lpcs->CallbackOnVideoStream)) (lpcs->hwnd, lpVidHdr);

                if (lpcs-> fCapturingToDisk) {
                    if (lpcs->dwVideoChunkCount &&
                                (dw < lpVidHdr->dwTimeCaptured)) {
                        // Has the capture device skipped frames?
                        // w = # of frames skipped
                        w = (WORD) muldiv32 ((lpVidHdr-> dwTimeCaptured - dw),
                                1000,
                                lpcs->sCapParms.dwRequestMicroSecPerFrame);
                        w = min (w, (sizeof (lpcs->DropFrame) / sizeof (RIFF) - sizeof (RIFF) ) );
                        lpcs->dwFramesDropped+= w;
                        fOK = AVIWriteDummyFrames (lpcs, w);

                        if (!fOK)
                            fStopping = TRUE;
                    } // end if writing dummy frames

                    if (!AVIWriteVideoFrame (lpcs, lpVidHdr)) {
                        fOK = FALSE;
                        fStopping = TRUE;
                        // "ERROR: Could not write to file."
                        errorUpdateError(lpcs, IDS_CAP_FILE_WRITE_ERROR);
                    }
                    else {
                        if (!IndexVideo(lpcs, lpVidHdr-> dwBytesUsed,
                                (BOOL) (lpVidHdr->dwFlags & VHDR_KEYFRAME)))
                            fStopping = TRUE;
                    }
                } // endif fCapturingToDisk
                // Warning: Kludge to create frame chunk count when net capture
                // follows.
                else
                    lpcs->dwVideoChunkCount++;

                // -------------------------------------------------------
                //         if we have *nothing* to do paint or show status.
                // -------------------------------------------------------
                w = (lpcs->iNextVideo + 1) % lpcs->iNumVideo;
                if (!(lpcs->alpVideoHdr[w]-> dwFlags & VHDR_DONE)) {
                    if (fTryToPaint && lpcs->dwVideoChunkCount &&
                                lpVidHdr-> dwFlags & VHDR_KEYFRAME) {
                        fTryToPaint = DrawDibDraw(lpcs->hdd, hdc,
                                0, 0,
                                rcDrawRect.right - rcDrawRect.left,
                                rcDrawRect.bottom - rcDrawRect.top,
                                /*lpcs->dxBits, lpcs->dyBits, */
                                (LPBITMAPINFOHEADER)lpcs->lpBitsInfo,
                                lpVidHdr-> lpData, 0, 0, -1, -1,
                                DDF_SAME_HDC | DDF_SAME_DIB | DDF_SAME_SIZE);
                    }
                }
                // if there is still more time, (or at least every 100 frames)
                // show status if we're not ending the capture
                if ((!fStopping) && (lpcs-> fCapturingToDisk) &&
                        ((lpcs->dwVideoChunkCount && (lpcs->dwVideoChunkCount % 100 == 0)) ||
                        (!(lpcs->alpVideoHdr[w]-> dwFlags & VHDR_DONE)) ) ) {

                    // "Captured %ld frames (Dropped %ld) %d.%03d sec. Hit Escape to Stop"
                    statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOCURRENT,
                            lpcs->dwVideoChunkCount, lpcs->dwFramesDropped,
                            (int)(lpcs-> dwTimeElapsedMS/1000), (int)(lpcs-> dwTimeElapsedMS%1000)
                            );
                } // endif next buffer not ready
            } // endif any bytes used in the buffer

             /* return the emptied buffer to the que */
            lpVidHdr->dwFlags &= ~VHDR_DONE;
            if (videoStreamAddBuffer(lpcs->hVideoIn,
                        lpVidHdr, sizeof (VIDEOHDR))) {
                fOK = FALSE;
                fStopping = TRUE;
                // "ERROR: Could not re-add buffer."
                  errorUpdateError (lpcs, IDS_CAP_VIDEO_ADD_ERROR);
            }

            /* increment the next Video buffer pointer */
            if (++lpcs->iNextVideo >= lpcs->iNumVideo)
                lpcs->iNextVideo = 0;

            lpVidHdr = lpcs->alpVideoHdr[lpcs->iNextVideo];
        }

        if (lpcs-> CallbackOnYield) {
            // If the yield callback returns FALSE, abort
            if (!((*(lpcs->CallbackOnYield)) (lpcs->hwnd)))
                fStopping = TRUE;
        }

        // Don't do peekMessage yield for ACM
        if (lpcs->sCapParms.fYield) {
            MSG msg;

            if (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
                // Kludge to get rid of timers from lpcs->hwnd
                if (msg.message == WM_TIMER && msg.hwnd == lpcs->hwnd)
                    ;
                else {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }

        if (lpcs-> CallbackOnControl) {
            // Outside routine is handling when to stop
            // The CONTROLCALLBACK_CAPTURING indicates we're asking when to stop
            if (!((*(lpcs->CallbackOnControl)) (lpcs->hwnd, CONTROLCALLBACK_CAPTURING )))
                fStopping = TRUE;
        }

        // -------------------------------------------------------
        //        Is audio buffer ready to be written?
        // -------------------------------------------------------
        if (lpcs->sCapParms.fCaptureAudio) {
            int iLastWave;

            //
            // we may need to yield for audio to get converted.
            //
            if (lpcs->fAudioYield)
                Yield();

            //
            // if all buffers are done, we have broke audio.
            //
            iLastWave = lpcs->iNextWave == 0 ?
                        lpcs->iNumAudio -1 : lpcs->iNextWave-1;

            if (!fStopping &&
                    lpcs->alpWaveHdr[iLastWave]->dwFlags & WHDR_DONE)
                lpcs->fAudioBreak = TRUE;

            w = lpcs->iNumAudio; // don't get stuck here forever...
            while (w && fOK && (lpWaveHdr-> dwFlags & WHDR_DONE)) {
                w--;
                if (lpWaveHdr-> dwBytesRecorded) {
                    /* Chunk info is included in the wave data */
                    /* Reset Chunk Size in buffer */
                    ((LPRIFF)(lpWaveHdr->lpData))[-1].dwSize =
                                lpWaveHdr-> dwBytesRecorded;
                    if (lpcs-> CallbackOnWaveStream) {
                        (*(lpcs->CallbackOnWaveStream)) (lpcs->hwnd, lpWaveHdr);
                    }
                    if (lpcs-> fCapturingToDisk) {
                        if(!AVIWrite (lpcs, lpWaveHdr-> lpData - sizeof(RIFF),
                                (lpWaveHdr-> dwBytesRecorded +
                                sizeof (RIFF) + 1) & ~1L)) {
                            fOK = FALSE;
                            fStopping = TRUE;
                            errorUpdateError (lpcs, IDS_CAP_FILE_WRITE_ERROR);
                         } else {
                            if (IndexAudio (lpcs, lpWaveHdr-> dwBytesRecorded))
                                lpcs->dwWaveBytes += lpWaveHdr-> dwBytesRecorded;
                            else
                                fStopping = TRUE;
                         }
                    } // endif capturing to disk
                    // Warning: Kludge to create wave chunk count when net capture
                    // follows.
                    else {
                        lpcs->dwWaveChunkCount++;
                        lpcs->dwWaveBytes += lpWaveHdr-> dwBytesRecorded;
                    }
                } // endif dwBytesRecorded

                lpWaveHdr-> dwBytesRecorded = 0;
                lpWaveHdr-> dwFlags &= ~WHDR_DONE;

                 /* return the emptied buffer to the que */
                if(waveInAddBuffer(lpcs->hWaveIn, lpWaveHdr, sizeof(WAVEHDR))) {
                    fOK = FALSE;
                    fStopping = TRUE;
                    errorUpdateError(lpcs, IDS_CAP_WAVE_ADD_ERROR);
                }

                /* increment the next wave buffer pointer */
                if(++lpcs->iNextWave >= lpcs->iNumAudio)
                    lpcs->iNextWave = 0;

                lpWaveHdr = lpcs->alpWaveHdr[lpcs->iNextWave];

            } // endwhile buffer available
         } // endif sound enabled

        // -------------------------------------------------------
        //        is there any reason to stop?
        // -------------------------------------------------------
        if (lpcs->sCapParms.vKeyAbort) {
            if (GetAsyncKeyState(lpcs->sCapParms.vKeyAbort & 0x00ff) & 0x0001) {
                fT = TRUE;
                if (lpcs->sCapParms.vKeyAbort & 0x8000)  // Ctrl?
                    fT = fT && (GetAsyncKeyState(VK_CONTROL) & 0x8000);
                if (lpcs->sCapParms.vKeyAbort & 0x4000)  // Shift?
                    fT = fT && (GetAsyncKeyState(VK_SHIFT) & 0x8000);
                fStopping = fT;      // User aborts
            }
        }
        if (lpcs->sCapParms.fAbortLeftMouse)
            if (GetAsyncKeyState(VK_LBUTTON) & 0x0001)
                fStopping = TRUE;      // User aborts
        if (lpcs->sCapParms.fAbortRightMouse)
            if (GetAsyncKeyState(VK_RBUTTON) & 0x0001)
                fStopping = TRUE;      // User aborts
        if (lpcs-> fAbortCapture || lpcs-> fStopCapture)
            fStopping = TRUE;          // Somebody above wants us to quit

        if (lpcs-> dwTimeElapsedMS > dwTimeToStop)
            fStopping = TRUE;      // all done

        // -------------------------------------------------------
        //        Quit only when we have stopped, and
        //      no more buffers are pending from any device.
        // -------------------------------------------------------
        if (fStopped) {
            if (!(lpVidHdr-> dwFlags & VHDR_DONE)) {
                if (lpcs->sCapParms.fCaptureAudio) {
                   if (!(lpWaveHdr-> dwFlags & WHDR_DONE))
                        break;
                }
                else
                    break;
            }
        }

        // -------------------------------------------------------
        //        Tell all the devices to stop
        // -------------------------------------------------------
        if (fStopping && !fStopped) {
            fStopped = TRUE;

            DSTATUS(lpcs, "Stopping....");

            if(lpcs->sCapParms.fCaptureAudio) {
                DSTATUS(lpcs, "Stopping Audio");
                waveInStop(lpcs->hWaveIn);
            }

            DSTATUS(lpcs, "Stopping Video");
            videoStreamStop(lpcs->hVideoIn);         // Stop everybody

            dwTimeStopped = timeGetTime ();

            if (lpcs->sCapParms.fMCIControl) {
                DSTATUS(lpcs, "Stopping MCI");
                MCIDevicePause (lpcs);
            }
            DSTATUS(lpcs, "Stopped");

            SetCursor(lpcs->hWaitCursor);  // Force cursor back to hourglass

        }


        if (fStopping) {
            // "Finished capture, now writing frame %ld"
            if (fOK) {
                statusUpdateStatus(lpcs, IDS_CAP_STAT_CAP_FINI, lpcs->dwVideoChunkCount);
            }
            else {               // Exit if problems
                statusUpdateStatus(lpcs, IDS_CAP_RECORDING_ERROR2);
                break;
            }
        }

    } // end of forever

    // -------------------------------------------------------
    //   END OF MAIN CAPTURE LOOP
    // -------------------------------------------------------

    if (lpcs->sCapParms.fDisableWriteCache)
        SmartDrv(lpcs->achFile[0], wSmartDrv);  // turn Smartdrive back on

    /* eat any keys that have been pressed */
    while(GetKey(FALSE))
        ;

    AVIFini(lpcs);  // does the Reset, and frees all buffers
    AVIFileFini(lpcs, TRUE /* fWroteJunkChunks */, FALSE /* fAbort */);

    // This is the corrected capture duration, based on audio samples
    lpcs->dwTimeElapsedMS = lpcs->dwActualMicroSecPerFrame *
                lpcs->dwVideoChunkCount / 1000;

    /* Notify if there was an error while recording */

    if(!fOK) {
        errorUpdateError (lpcs, IDS_CAP_RECORDING_ERROR);
    }


    if (lpcs-> fCapturingToDisk) {
        if (lpcs->dwVideoChunkCount)
            dw = muldiv32(lpcs->dwVideoChunkCount,1000000,lpcs-> dwTimeElapsedMS);
        else
            dw = 0;     // The muldiv32 doesn't give 0 if numerator is zero

        if(lpcs->sCapParms.fCaptureAudio) {
            // "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps).  %ld audio bytes (%d.%03d sps)"
            statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOAUDIO,
                  (WORD)(lpcs-> dwTimeElapsedMS/1000),
                  (WORD)(lpcs-> dwTimeElapsedMS%1000),
                  lpcs->dwVideoChunkCount,
                  lpcs->dwFramesDropped,
                  (WORD)(dw / 1000),
                  (WORD)(dw % 1000),
                  lpcs->dwWaveBytes,
                  (WORD) lpcs->lpWaveFormat->nSamplesPerSec / 1000,
                  (WORD) lpcs->lpWaveFormat->nSamplesPerSec % 1000);
        } else {
            // "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps)."
            statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOONLY,
                  (WORD)(lpcs-> dwTimeElapsedMS/1000),
                  (WORD)(lpcs-> dwTimeElapsedMS%1000),
                  lpcs->dwVideoChunkCount,
                  lpcs->dwFramesDropped,
                  (WORD)(dw / 1000),
                  (WORD)(dw % 1000));
        }
    } // endif capturing to disk (no warnings or errors if to net)

    // No frames captured, warn user that interrupts are probably not enabled.
    if (fOK && (lpcs->dwVideoChunkCount == 0)) {
        errorUpdateError (lpcs, IDS_CAP_NO_FRAME_CAP_ERROR);
    }
    // No audio captured, (but enabled), warn user audio card is hosed
    else if (fOK && lpcs->sCapParms.fCaptureAudio && (lpcs->dwWaveBytes == 0)) {
        errorUpdateError (lpcs, IDS_CAP_NO_AUDIO_CAP_ERROR);
    }
    // Audio underrun, inform user
    else if (fOK && lpcs->sCapParms.fCaptureAudio && lpcs->fAudioBreak) {
        errorUpdateError (lpcs, IDS_CAP_AUDIO_DROP_ERROR);
    }

    // If frames dropped, or changed capture rate, warn the user
    else if (fOK && lpcs->dwVideoChunkCount && lpcs->fCapturingToDisk) {

        // Warn user if dropped > 10% (default) of the frames
        if ((DWORD)100 * lpcs->dwFramesDropped / lpcs->dwVideoChunkCount >
                    lpcs-> sCapParms.wPercentDropForError) {

            // "%ld of %ld frames (%d.%03d\%) dropped during capture."
            errorUpdateError (lpcs, IDS_CAP_STAT_FRAMESDROPPED,
                  lpcs->dwFramesDropped,
                  lpcs->dwVideoChunkCount,
                  (WORD)(muldiv32(lpcs->dwFramesDropped,10000,lpcs->dwVideoChunkCount)/100),
                  (WORD)(muldiv32(lpcs->dwFramesDropped,10000,lpcs->dwVideoChunkCount)%100)
                  );
        }
    }

EarlyExit:

    //
    // If we were compressing while capturing, close it down
    //
    if (lpcs->CompVars.hic) {
        // Kludge, reset the lpBitsOut pointer
        if (lpcs->CompVars.lpBitsOut)
            ((LPBYTE) lpcs->CompVars.lpBitsOut) -= 8;
	ICSeqCompressFrameEnd(&lpcs->CompVars);
    }

    if (fTryToPaint) {
        if (hpalT)
             SelectPalette(hdc, hpalT, FALSE);
        ReleaseDC (lpcs->hwnd, hdc);
    }

    if (lpcs->sCapParms.fMCIControl)
        MCIDeviceClose (lpcs);

    // Let the user see where capture stopped
    if ((!lpcs->fLiveWindow) && (!lpcs->fOverlayWindow))
        videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );
    InvalidateRect( lpcs->hwnd, NULL, TRUE);

    SetCursor(hOldCursor);

    lpcs->fCapFileExists = (lpcs-> dwReturn == DV_ERR_OK);
    lpcs->fCapturingNow = FALSE;

    statusUpdateStatus(lpcs, IDS_CAP_END);      // Always the last message

    return;
}


// Returns TRUE if the capture task was created, or
// capture completed OK.

BOOL AVICapture (LPCAPSTREAM lpcs)
{
    WORD w;
    CAPINFOCHUNK cic;
    char szSMPTE[40];

    if (lpcs-> fCapturingNow)
        return IDS_CAP_VIDEO_OPEN_ERROR;

    lpcs-> fStopCapture  = FALSE;
    lpcs-> fAbortCapture = FALSE;
    lpcs-> hTaskCapture  = NULL;
    lpcs-> dwReturn      = 0;

    // Clear any SMPTE info chunk
    cic.fccInfoID = mmioFOURCC ('I','S','M','T');
    cic.lpData = NULL;
    cic.cbData = 0;
    SetInfoChunk (lpcs, &cic);

#if 1
    // And get ready to write a SMPTE info chunk
    if (lpcs->sCapParms.fMCIControl) {
        // create SMPTE string
        TimeMSToSMPTE (lpcs->sCapParms.dwMCIStartTime, (LPSTR) szSMPTE);
        cic.lpData = szSMPTE;
        cic.cbData = lstrlen (szSMPTE) + 1;
        SetInfoChunk (lpcs, &cic);
    }
#endif

    // Use an MCI device to do step capture capture???
    if (lpcs->sCapParms.fStepMCIDevice && lpcs->sCapParms.fMCIControl) {
        if (lpcs->sCapParms.fYield) {
            w = (WORD) mmTaskCreate((LPTASKCALLBACK) MCIStepCapture,
                        &lpcs->hTaskCapture, (DWORD) lpcs);
            // if task creation failed, turn off the capturing flag
            if (w != 0)
                lpcs->fCapturingNow = FALSE;
            return ((BOOL) !w);
        }
        else  {
            MCIStepCapture (lpcs);
            return ((BOOL) !lpcs->dwReturn);
        }
    }

    // No MCI device, just a normal streaming capture
    else if (lpcs->sCapParms.fYield) {
        w = (WORD) mmTaskCreate((LPTASKCALLBACK) AVICapture1,
                &lpcs->hTaskCapture, (DWORD) lpcs);
        // if task creation failed, turn off the capturing flag
        if (w != 0)
            lpcs->fCapturingNow = FALSE;
        return ((BOOL) !w);
    }
    else  {
        AVICapture1 (lpcs);
        return ((BOOL) !lpcs->dwReturn);
    }
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\audiosrv\ts.cpp ===
// ts.cpp : Server side code for terminal server event stuff
//
// Created by FrankYe on 7/3/2000
//

#include <windows.h>
#include <wtsapi32.h>
#include "debug.h"
#include "list.h"
#include "service.h"
#include "audiosrv.h"
#include "agfxs.h"
#include "ts.h"

//=============================================================================
//===   Global data   ===
//=============================================================================

CListSessionNotifications *gplistSessionNotifications;

//=============================================================================
//===   debug helpers   ===
//=============================================================================

#ifdef DBG
PTSTR astrWtsEvent[] = {
    NULL,
    TEXT("WTS_CONSOLE_CONNECT"),
    TEXT("WTS_CONSOLE_DISCONNECT"),
    TEXT("WTS_REMOTE_CONNECT"),
    TEXT("WTS_REMOTE_DISCONNECT"),
    TEXT("WTS_SESSION_LOGON"),
    TEXT("WTS_SESSION_LOGOFF")
};
#endif

//=============================================================================
//===   xxx   ===
//=============================================================================

DWORD ServiceSessionChange(DWORD EventType, LPVOID EventData)
{
    PWTSSESSION_NOTIFICATION pWtsNotification = (PWTSSESSION_NOTIFICATION)EventData;
    
    POSITION pos;

    // dprintf(TEXT("ServiceSessionChange: %s on session %d\n"), astrWtsEvent[EventType], pWtsNotification->dwSessionId);
    
    GFX_SessionChange(EventType, EventData);
    
    gplistSessionNotifications->Lock();

    pos = gplistSessionNotifications->GetHeadPosition();

    while (pos) {
        PSESSIONNOTIFICATION pNotification;
        pNotification = gplistSessionNotifications->GetNext(pos);
        if (pWtsNotification->dwSessionId == pNotification->SessionId) {
            SetEvent(pNotification->Event);
        }
    }

    gplistSessionNotifications->Unlock();

    return NO_ERROR;
}


long s_winmmRegisterSessionNotificationEvent(IN unsigned long dwProcessId,
                                             IN RHANDLE inhEvent,
                                             OUT PHANDLE_SESSIONNOTIFICATION phNotification)
{
    PSESSIONNOTIFICATION pNotification;
    HANDLE hEvent;
    LONG lresult;
    
    ASSERT(gplistSessionNotifications);
    
    hEvent = (HANDLE)inhEvent;
    
    pNotification = new SESSIONNOTIFICATION;
    if (pNotification) {
        if (ProcessIdToSessionId(dwProcessId, &pNotification->SessionId))
        {
            HANDLE hClientProcess;
        
            hClientProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwProcessId);
            if (hClientProcess) {
                if (DuplicateHandle(hClientProcess, hEvent,
                                    GetCurrentProcess(), &pNotification->Event,
                                    EVENT_MODIFY_STATE, FALSE, 0))
                {
                    POSITION posNotification;

                    posNotification = gplistSessionNotifications->AddTail(pNotification);
                    if (posNotification)
                    {
                        *phNotification = posNotification;
                        lresult = NO_ERROR;
                    } else {
                        lresult = ERROR_OUTOFMEMORY;
                    }

					if (lresult) {
                        CloseHandle(pNotification->Event);
                    }

                } else {
                    lresult = GetLastError();
                }

                CloseHandle(hClientProcess);
            } else {
                lresult = GetLastError();
            }
        } else {
            lresult = GetLastError();
        }

        if (lresult) {
            delete pNotification;
        }
    
    } else {
        lresult = ERROR_OUTOFMEMORY;
    }
    
    return lresult;
}

long s_winmmUnregisterSessionNotification(IN OUT PHANDLE_SESSIONNOTIFICATION phNotification)
{
    POSITION posNotification;
    LONG lresult;
    
    posNotification = (POSITION)*phNotification;
    
    if (posNotification) {
        PSESSIONNOTIFICATION pNotification;

        pNotification = gplistSessionNotifications->GetAt(posNotification);
        gplistSessionNotifications->RemoveAt(posNotification);

        CloseHandle(pNotification->Event);
        delete pNotification;

        *phNotification = NULL;

        lresult = NO_ERROR;
    } else {
        lresult = ERROR_INVALID_PARAMETER;
    }

    return lresult;
}

long s_winmmSessionConnectState(IN unsigned long dwProcessId, OUT int *outConnectState)
{
    DWORD dwSessionId;
    LONG lresult;

    if (ProcessIdToSessionId(dwProcessId, &dwSessionId)) {
        INT *pConnectState;
        DWORD BytesReturned;
        BOOL fresult;
        
        fresult = WTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE,
                                             dwSessionId,
                                             WTSConnectState,
                                             (LPTSTR*)&pConnectState,
                                             &BytesReturned);
        if (fresult) {
            ASSERT(BytesReturned == sizeof(*pConnectState));
            *outConnectState = *pConnectState;
            WTSFreeMemory(pConnectState);
            lresult = NO_ERROR;
        } else {
            lresult = GetLastError();
        }
    } else {
        lresult = GetLastError();
    }
    
    return lresult;
}

void __RPC_USER HANDLE_SESSIONNOTIFICATION_rundown(HANDLE_SESSIONNOTIFICATION hNotification)
{
    ASSERT(SERVICE_STOPPED != ssStatus.dwCurrentState);
    if (SERVICE_STOPPED == ssStatus.dwCurrentState) return;
    s_winmmUnregisterSessionNotification(&hNotification);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\capdriv.c ===
/****************************************************************************
 *
 *   capdriv.c
 * 
 *   Smartdrv control.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>

#pragma optimize ("", off)

// SD_CACHE_DRIVE:
// FUNCTION:
//        Enables and disables read or write caching for a particular
//        drive unit.  Returns the cache state of the drive in DL. Get
//        takes no action, but simply returns cache state for drive unit
//        in DL.
//
//        INPUT:
//                AX=MULT_SMARTDRV  (4A10h)
//                BX=SD_CACHE_DRIVE (3)
//                DL=CACHE_DRIVE_<get,read|write enable|disable>
//                BP=unit number of drive
//        OUTPUT:
//                DL=cache state of unit:
//                        Bit 7 set -> no caching enabled for this unit
//                        Bit 7 not set -> read caching enabled for this unit
//                        Bit 6 set -> write caching not enabled for this unit
//                        Bit 6 not set -> write caching enabled for this unit
//                        -1 -> not a cachable drive
//        USES:
//                ALL except DS,ES
//

#define MULT_SMARTDRV               0x4a10
#define SD_CACHE_DRIVE              3
#define CACHE_DRIVE_GET             0
#define CACHE_DRIVE_READ_ENABLE     1
#define CACHE_DRIVE_READ_DISABLE    2
#define CACHE_DRIVE_WRITE_ENABLE    3
#define CACHE_DRIVE_WRITE_DISABLE   4

#define F_WRITE_CACHE  (1 << 7)
#define F_READ_CACHE   (1 << 6)

WORD NEAR PASCAL SmartDrvCache(int iDrive, BYTE cmd)
{
    WORD    w;

    _asm {
        push    bp
        mov     ax, MULT_SMARTDRV
        mov     bx, SD_CACHE_DRIVE
        mov     dl, cmd
        mov     bp, iDrive
        int     2fh
        mov     al,dl
        xor     ah,ah
        pop     bp
        mov     w,ax
    }

    return w;
}

WORD FAR PASCAL SmartDrv(char chDrive, WORD w)
{
    WORD wCur;
    int  iDrive;

    iDrive = (chDrive | 0x20) - 'a';

    wCur = SmartDrvCache(iDrive, CACHE_DRIVE_GET);

    if (w & F_WRITE_CACHE)
        SmartDrvCache(iDrive, CACHE_DRIVE_WRITE_DISABLE);
    else
        SmartDrvCache(iDrive, CACHE_DRIVE_WRITE_ENABLE);

    if (w & F_READ_CACHE)
        SmartDrvCache(iDrive, CACHE_DRIVE_READ_DISABLE);
    else
        SmartDrvCache(iDrive, CACHE_DRIVE_READ_ENABLE);

    return wCur;
}

#pragma optimize ("", on)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\capdib.h ===
/****************************************************************************
 *
 *   capdib.h
 * 
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

void SetDefaultCaptureFormat (LPBITMAPINFOHEADER lpbih);
DWORD AllocNewGlobalBitmapInfo (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbi);
DWORD AllocNewBitSpace (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih);
DWORD DibInit (LPCAPSTREAM lpcs);
void DibFini (LPCAPSTREAM lpcs);
DWORD SendDriverFormat (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih, DWORD dwInfoHeaderSize);
DWORD SetFormatFromDIB (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih);
LPBITMAPINFO DibGetCurrentFormat (LPCAPSTREAM lpcs);
DWORD DibGetNewFormatFromDriver (LPCAPSTREAM lpcs);
BOOL DibNewFormatFromApp (LPCAPSTREAM lpcs, LPBITMAPINFO lpbi, WORD dwSize);
DWORD DibNewPalette (LPCAPSTREAM lpcs, HPALETTE hPalNew);
void DibPaint(LPCAPSTREAM lpcs, HDC hdc);
HANDLE CreatePackedDib (LPBITMAPINFO lpBitsInfo, LPSTR lpSrcBits, HPALETTE hPalette);
BOOL FAR PASCAL dibIsWritable (LPBITMAPINFO lpBitsInfo);
BOOL FAR PASCAL dibWrite(LPCAPSTREAM lpcs, HMMIO hmmio);
BOOL FAR PASCAL fileSaveDIB(LPCAPSTREAM lpcs, LPSTR lpszFileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\capdib.c ===
/****************************************************************************
 *
 *   capdib.c
 * 
 *   DIB processing module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <drawdib.h>
#include "avicap.h"
#include "avicapi.h"


//
// Initialize a DIB to the default format of 160x120x8, BI_RGB
//
void SetDefaultCaptureFormat (LPBITMAPINFOHEADER lpbih)
{
    lpbih->biSize              = sizeof (BITMAPINFOHEADER);
    lpbih->biWidth             = 160;
    lpbih->biHeight            = 120;
    lpbih->biBitCount          = 8;
    lpbih->biPlanes            = 1;
    lpbih->biCompression       = BI_RGB;
    lpbih->biSizeImage         = DIBWIDTHBYTES (*lpbih) * lpbih->biHeight;
    lpbih->biXPelsPerMeter     = 0;
    lpbih->biYPelsPerMeter     = 0;
    lpbih->biClrUsed           = 256;
    lpbih->biClrImportant      = 0;
}

// 
// Whenever we get a new format from the driver, OR
// start using a new palette, we must reallocate
// our global BITMAPINFOHEADER.  This allows JPEG
// quantization tables to be tacked onto the BITMAPINFO
// or any other format specific stuff.  The color table
// is always offset biSize from the start of the BITMAPINFO.
// Returns: 0 on success, or DV_ERR_... code
// 

DWORD AllocNewGlobalBitmapInfo (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbi)
{
    DWORD dwSize;

    dwSize = lpbi->biSize + 256 * sizeof (RGBQUAD);

    // The 256 entry above is HARDWIRED ON PURPOSE
    // If biClrUsed was used instead, we would have to realloc
    // whenever a palette is pasted (during DibNewPalette())!!!

    if (lpcs->lpBitsInfo) 
         lpcs->lpBitsInfo = (LPBITMAPINFO) GlobalReAllocPtr (lpcs->lpBitsInfo,
                dwSize, GHND);
    else
         lpcs->lpBitsInfo = (LPBITMAPINFO) GlobalAllocPtr (GHND, dwSize);

    if (!lpcs->lpBitsInfo)
         return (DV_ERR_NOMEM);

    // Copy over the BITMAPINFOHEADER
    hmemcpy ((HPSTR)lpcs->lpBitsInfo, (HPSTR)lpbi, lpbi->biSize);

    return DV_ERR_OK;
}

// 
// Whenever we get a new format from the driver
// allocate a new global bitspace.  This bitspace is used
// in preview mode and single frame capture.
// Returns: 0 on success, or DV_ERR_... code
// 

DWORD AllocNewBitSpace (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih)
{
    DWORD dwSize;

    dwSize = lpbih->biSizeImage;

    if (lpcs->lpBits) 
         lpcs->lpBits = GlobalReAllocPtr (lpcs->lpBits, dwSize, GHND);
    else
         lpcs->lpBits = GlobalAllocPtr (GHND, dwSize);

    if (!lpcs->lpBits)
         return (DV_ERR_NOMEM);

    return DV_ERR_OK;    
}

//
// Dib Inititialization code
// Returns: 0 on success, or DV_ERR_... code
//

DWORD DibInit (LPCAPSTREAM lpcs)
{
    BITMAPINFOHEADER bmih;
    
    SetDefaultCaptureFormat (&bmih);
    return ((WORD) AllocNewGlobalBitmapInfo (lpcs, &bmih));
}

//
// Fini code to free all bitmap resources
//
void DibFini (LPCAPSTREAM lpcs)
{
    if (lpcs->lpBits) {
        GlobalFreePtr (lpcs->lpBits);
        lpcs->lpBits = NULL;
    }
    if (lpcs->lpBitsInfo) {
        GlobalFreePtr (lpcs->lpBitsInfo);
        lpcs->lpBitsInfo = NULL;
    }
    lpcs->dxBits = 0;
    lpcs->dyBits = 0;
}

//
// Send a format to the driver.
// Whenever we do a format change, send the driver the 
// Source and destination rects.
// Returns: 0 on success, or DV_ERR_... code
//
DWORD SendDriverFormat (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih, DWORD dwInfoHeaderSize)
{
    RECT rc;
    DWORD dwError = DV_ERR_NOTSUPPORTED;

    rc.left = rc.top = 0;
    rc.right = (int) lpbih->biWidth;
    rc.bottom = (int) lpbih->biHeight;

    if (dwError = videoConfigure(lpcs->hVideoIn,
            DVM_FORMAT,
            VIDEO_CONFIGURE_SET, NULL, 
            (LPBITMAPINFOHEADER)lpbih, dwInfoHeaderSize,
            NULL, NULL ) ) {
        return dwError;
    }
    else {
         // Set the ExternalIn Destination rectangle to the same size
         videoMessage (lpcs->hVideoCapture,
                DVM_DST_RECT, 
                (DWORD) (LPVOID)&rc, VIDEO_CONFIGURE_SET);

         // Set the VideoIn Source Rectangle to the same size
         videoMessage (lpcs->hVideoIn,
                DVM_SRC_RECT, 
                (DWORD) (LPVOID)&rc, VIDEO_CONFIGURE_SET);

         // Set the VideoIn Destination Rectangle to the same size
         videoMessage (lpcs->hVideoIn,
                DVM_DST_RECT, 
                (DWORD) (LPVOID)&rc, VIDEO_CONFIGURE_SET);
    }
    return dwError;
}


//
// Given a DIB, see if the driver likes it, then
//  allocate the global BITMAPINFOHEADER and bitspace.  
//
//
DWORD SetFormatFromDIB (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih)
{
    DWORD dwError;

    // Fill optional fields in the DIB header
    if (lpbih->biSizeImage == 0) 
        lpbih->biSizeImage = DIBWIDTHBYTES (*lpbih) * lpbih->biHeight;

    // Is the format palatized or full-color
    if (lpbih->biBitCount <= 8 && lpbih->biClrUsed == 0)
        lpbih->biClrUsed = (1 << lpbih-> biBitCount);     // paletized

    // See if the driver will support it
    if (dwError = SendDriverFormat (lpcs, lpbih, lpbih->biSize) )
        return dwError;

    // Realloc our global header
    if (dwError = AllocNewGlobalBitmapInfo (lpcs, lpbih))
        return dwError;

    // Realloc the bits
    if (dwError = AllocNewBitSpace (lpcs, lpbih))
        return dwError;

    lpcs->dxBits = (int)lpbih->biWidth;
    lpcs->dyBits = (int)lpbih->biHeight;

    lpcs->VidHdr.lpData = lpcs->lpBits;
    lpcs->VidHdr.dwBufferLength = lpbih->biSizeImage;
    lpcs->VidHdr.dwUser = 0;
    lpcs->VidHdr.dwFlags = 0;
    
    return (DV_ERR_OK);
}


//
// Returns: a LPBITMAPINFO allocated from global memory
//      containing the current format, or NULL on error.
//      Note that this structure can be larger than 
//      sizeof (BITMAPINFO), ie. JPEG !!!
//

LPBITMAPINFO DibGetCurrentFormat (LPCAPSTREAM lpcs)
{
    DWORD               dwError;
    DWORD               dwSize = 0;
    LPBITMAPINFO        lpBInfo = NULL;

    if (!lpcs->fHardwareConnected)
        return NULL;

    // How large is the BITMAPINFOHEADER?
    videoConfigure( lpcs->hVideoIn,
            DVM_FORMAT,
             VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_QUERYSIZE,
             &dwSize, NULL, NULL, NULL, NULL);

    if (!dwSize)
        dwSize = sizeof (BITMAPINFOHEADER);

    if (!(lpBInfo = (LPBITMAPINFO) GlobalAllocPtr (GMEM_MOVEABLE, dwSize)))
         return (NULL);

    if (dwError = videoConfigure( lpcs->hVideoIn,
            DVM_FORMAT,
             VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT, NULL, 
             (LPBITMAPINFOHEADER) lpBInfo, dwSize,
             NULL, NULL ) ) {
        // very bad. the driver can't tell us its format. we're hosed.
        GlobalFreePtr (lpBInfo);
        return NULL;
     }

    return (lpBInfo);
}

//
// Main entry point when changing capture formats.
// This is called when the user closes the drivers format dialog.
// Returns: 0 on success, or DV_ERR_... code
//
DWORD DibGetNewFormatFromDriver (LPCAPSTREAM lpcs)
{
    BOOL                f;
    BITMAPINFOHEADER    bih;
    DWORD               dwError;
    LPBITMAPINFO        lpBInfo;

    if (!lpcs->fHardwareConnected)
        return DV_ERR_OK;       // Return OK if no hardware exists

    lpBInfo = DibGetCurrentFormat (lpcs);

    if (lpBInfo == NULL)
        return DV_ERR_NOTSUPPORTED;

    // Set our internal state
    if (dwError = SetFormatFromDIB (lpcs, (LPBITMAPINFOHEADER) lpBInfo)) {
        // couldn't change formats, time to punt!
        // Try to switch back to minimal format (120x160x8)

        errorDriverID (lpcs, dwError);

        SetDefaultCaptureFormat (&bih);
        dwError = SetFormatFromDIB (lpcs, &bih);
    }

    // Force a new frame to be taken, so the DIB contains good
    // data.  Especially important to prevent codecs from exploding!
    if (!dwError)
        videoFrame (lpcs->hVideoIn, &lpcs->VidHdr);

    if (lpBInfo) 
        GlobalFreePtr (lpBInfo);

    f = DrawDibBegin(lpcs->hdd,NULL,-1,-1,(LPBITMAPINFOHEADER)(lpcs->lpBitsInfo),-1,-1,0);
    if (!f)
        errorUpdateError (lpcs, IDS_CAP_AVI_DRAWDIB_ERROR);

    return (dwError);
}

//
// Main entry point when changing capture formats via App message.
// Returns: TRUE on success, or FALSE if format not supported
//
BOOL DibNewFormatFromApp (LPCAPSTREAM lpcs, LPBITMAPINFO lpbiNew, WORD dwSize)
{
    BOOL                f;
    DWORD               dwError;
    LPBITMAPINFO        lpBInfo;

    if (!lpcs->fHardwareConnected)
        return FALSE;

    lpBInfo = DibGetCurrentFormat (lpcs);  // Allocs memory!!!

    if (lpBInfo == NULL)
        return FALSE;

    // Set our internal state
    if (dwError = SetFormatFromDIB (lpcs, (LPBITMAPINFOHEADER) lpbiNew)) {
        // Driver didn't accept the format, 
        // switch back to the original

        errorDriverID (lpcs, dwError);

        SetFormatFromDIB (lpcs, (LPBITMAPINFOHEADER)lpBInfo);
    }

    // Force a new frame to be taken, so the DIB contains good
    // data.  Especially important to prevent codecs from exploding!
    videoFrame (lpcs->hVideoIn, &lpcs->VidHdr);

    if (lpBInfo) 
        GlobalFreePtr (lpBInfo);

    f = DrawDibBegin(lpcs->hdd,NULL,-1,-1,(LPBITMAPINFOHEADER)(lpcs->lpBitsInfo),-1,-1,0);
    if (!f)
        errorDriverID (lpcs, IDS_CAP_AVI_DRAWDIB_ERROR);

    return (dwError == DV_ERR_OK);
}


void xlatClut8 (BYTE _huge *pb, DWORD dwSize, BYTE _huge *xlat)
{
    DWORD dw;

    for (dw = 0; dw < dwSize; dw++, ((BYTE huge *)pb)++)
        *pb = xlat[*pb];
}

//
// DibNewPalette
//
// Performs three functions:
// 1. Updates the biClrUsed field if biBitCount <= 8.
// 2. Remaps BI_RGB images through a LUT when a new palette is assigned.
// 3. Copies the palette entries into our global BITMAPINFO
//
// Returns: TRUE on success
//
DWORD DibNewPalette (LPCAPSTREAM lpcs, HPALETTE hPalNew)
{
    LPBITMAPINFOHEADER  lpbi;
    int                 n;
    int                 nColors;
    BYTE FAR *          lpBits;
    RGBQUAD FAR *       lpRgb;
    BYTE                xlat[256];
    DWORD               dwSize;
    PALETTEENTRY        pe;

    if (!hPalNew || !lpcs->lpBits || !lpcs->lpBitsInfo)
        return FALSE;

    lpbi   = &(lpcs->lpBitsInfo->bmiHeader);
    lpRgb  = (RGBQUAD FAR *)((LPSTR)lpbi + (WORD)lpbi->biSize);
    lpBits = lpcs->lpBits;

    GetObject(hPalNew, sizeof(int), (LPSTR) &nColors);
    if (nColors > 256)
        nColors = 256;

    // Get the palette entries regardless of the compression
    // Supermac uses non BI_RGB with a palette!

    if (lpbi->biBitCount == 8) {
        for (n=0; n<nColors; n++) {
            GetPaletteEntries(hPalNew, n, 1, &pe);
            lpRgb[n].rgbRed   = pe.peRed;
            lpRgb[n].rgbGreen = pe.peGreen;
            lpRgb[n].rgbBlue  = pe.peBlue;
        }
    }

    if (lpbi->biBitCount == 8 && lpbi->biCompression == BI_RGB) {

        //
        //  build a xlat table. from the old Palette to the new palette.
        //
        for (n=0; n<(int)lpbi->biClrUsed; n++) {
            xlat[n] = (BYTE)GetNearestPaletteIndex(hPalNew,
                RGB(lpRgb[n].rgbRed,lpRgb[n].rgbGreen,lpRgb[n].rgbBlue));
        }

        //
        // translate the DIB bits
        //
        if ((dwSize = lpbi->biSizeImage) == 0)
            dwSize = lpbi->biHeight * DIBWIDTHBYTES(*lpbi);

        switch ((WORD)lpbi->biCompression)
        {
            case BI_RGB:
                xlatClut8(lpBits, dwSize, xlat);
        }
    }

    // Fix for Supermac, force biClrUsed to the number of palette entries
    // even if non-BI_RGB formats.

    if (lpbi-> biBitCount <= 8)
        lpbi->biClrUsed = nColors;

    return TRUE;
}


/* DibPaint(LPCAPSTREAM lpcs, hdc)
 *
 * Paint the current DIB into the window;
 */
void DibPaint(LPCAPSTREAM lpcs, HDC hdc)
{
    RECT        rc;
    BOOL        fOK;
    
    fOK = (lpcs->lpBits != NULL);
    
    if (fOK) {
        if (lpcs-> fScale) {
            GetClientRect(lpcs->hwnd, &rc);
            fOK = DrawDibDraw(lpcs->hdd, hdc, 0, 0, 
                  rc.right - rc.left, rc.bottom - rc.top,
                  (LPBITMAPINFOHEADER)lpcs->lpBitsInfo, lpcs->lpBits,
                   0, 0, -1, -1, DDF_BACKGROUNDPAL);
        }
        else 
            fOK = DrawDibDraw(lpcs->hdd, hdc, 0, 0, 
                lpcs->dxBits, lpcs->dyBits,
                (LPBITMAPINFOHEADER)lpcs->lpBitsInfo, lpcs->lpBits,
                0, 0, -1, -1, DDF_BACKGROUNDPAL);
    }
    if (!fOK) {
        SelectObject(hdc, GetStockObject(BLACK_BRUSH));
        GetClientRect(lpcs->hwnd, &rc);
        PatBlt(hdc, 0, 0, rc.right, rc.bottom, PATCOPY);
    }
}

/*
 *
 * CreatePackedDib() - return the current DIB in packed (ie CF_DIB) format
 *
 */

HANDLE CreatePackedDib (LPBITMAPINFO lpBitsInfo, LPSTR lpSrcBits, HPALETTE hPalette)
{
    HANDLE              hdib;
    LPBITMAPINFO        lpbi;
    int                 i;
    DWORD               dwSize;
    PALETTEENTRY        pe;
    LPBYTE              lpBits;
    RGBQUAD FAR *       lpRgb;

   // If the data is compressed, let ICM do the work for us...
    if ( lpBitsInfo->bmiHeader.biCompression != BI_RGB &&
         lpBitsInfo->bmiHeader.biCompression != BI_RLE8 &&
        (lpBitsInfo->bmiHeader.biBitCount != 8 ||
         lpBitsInfo->bmiHeader.biBitCount != 24 )) {

        LPBITMAPINFO lpOutFormat = NULL;
        HANDLE hPackedDIBOut = NULL;

        if (!(lpOutFormat = (LPBITMAPINFO)GlobalAllocPtr(
                        GMEM_MOVEABLE, sizeof (BITMAPINFOHEADER) + 
                        256 * sizeof (RGBQUAD))))
            return NULL;

        hmemcpy ((HPSTR)lpOutFormat, (HPSTR)lpBitsInfo, sizeof (BITMAPINFOHEADER));

        // Try to get an RGB format
        lpOutFormat->bmiHeader.biSize = sizeof (BITMAPINFOHEADER);
        lpOutFormat->bmiHeader.biCompression = BI_RGB;
        lpOutFormat->bmiHeader.biClrUsed = 0;
        lpOutFormat->bmiHeader.biClrImportant = 0;

        // Uh, oh, force to a 24-bit DIB if > 8 BPP
        if (lpBitsInfo->bmiHeader.biBitCount <= 8) 
            lpOutFormat->bmiHeader.biBitCount = 8;
        else
            lpOutFormat->bmiHeader.biBitCount = 24;

        lpOutFormat->bmiHeader.biSizeImage = 
                WIDTHBYTES (lpOutFormat->bmiHeader.biWidth * 
                (lpOutFormat->bmiHeader.biBitCount == 8 ? 1 : 3)) * 
                lpOutFormat->bmiHeader.biHeight;

        hPackedDIBOut = ICImageDecompress (
                NULL,           /*hic*/ 
                0,              /*uiFlags*/
                lpBitsInfo,     /*lpbiIn*/
                lpSrcBits,      /*lpBits*/
                lpOutFormat);   /*use default format chosen by compressor*/

        if (lpOutFormat)
            GlobalFreePtr (lpOutFormat);

        return (hPackedDIBOut);
    }

    dwSize = lpBitsInfo->bmiHeader.biSize +
              lpBitsInfo->bmiHeader.biClrUsed * sizeof(RGBQUAD) +
              lpBitsInfo->bmiHeader.biSizeImage;

    hdib = GlobalAlloc(GMEM_MOVEABLE, dwSize);

    if (!hdib)
         return NULL;

    lpbi = (LPVOID)GlobalLock(hdib);

    //
    // copy the header
    //
    hmemcpy ((HPSTR)lpbi, (HPSTR)lpBitsInfo, lpBitsInfo->bmiHeader.biSize);
    
    //
    // copy the color table
    //
    lpRgb  = (RGBQUAD FAR *)((LPSTR)lpbi + (WORD)lpbi->bmiHeader.biSize);
    for (i=0; i < (int)lpBitsInfo->bmiHeader.biClrUsed; i++) {
        GetPaletteEntries(hPalette, i, 1, &pe);
        lpRgb[i].rgbRed   = pe.peRed;
        lpRgb[i].rgbGreen = pe.peGreen;
        lpRgb[i].rgbBlue  = pe.peBlue;
        lpRgb[i].rgbReserved = 0;
    }

    //
    // copy the bits.
    //
    lpBits  =   (LPBYTE)lpbi + 
                lpbi->bmiHeader.biSize +
                lpbi->bmiHeader.biClrUsed * sizeof(RGBQUAD);

    hmemcpy ((LPSTR)lpBits, (LPSTR)lpSrcBits, 
                lpbi->bmiHeader.biSizeImage);

    GlobalUnlock (hdib);

    return hdib;
 }


 /*---------------------------------------------------------------------+
 | dibIsWritable() - return TRUE if the dib format is writable,                  |
 |                     by out dibWrite() function, FALSE if not.                 |
 |                                                                               |
 +---------------------------------------------------------------------*/
BOOL FAR PASCAL dibIsWritable (LPBITMAPINFO lpBitsInfo)
{
    if (!lpBitsInfo)
        return FALSE;

     // For now, just assume that all capture formats have an installed
     // codec which can convert to RGB.  In the future, each time the 
     // format is changed, test that the codec actually accepts the format.

     return TRUE;
 }
 
 
 /*---------------------------------------------------------------------+
 | dibWrite() - write out the DIB to a file. The global header is       |
 |                in <glpBitsInfo> and the actual dib bits are in                |
 |                <glpBits>.  If it is palettized then the palette is in         |
 |                <ghPalCurrent>.                                                |
 |                                                                               |
 |  We won't do error reporting in this function, let the caller take   |
 |  care of that along with Opening and Closing the HMMIO.              |
 |                                                                               |
 +---------------------------------------------------------------------*/
BOOL FAR PASCAL dibWrite(LPCAPSTREAM lpcs, HMMIO hmmio)
 {
     BITMAPFILEHEADER   bfh;
     DWORD              dw;
     HANDLE             hPackedDib = NULL;
     LPBITMAPINFO       lpbi = NULL;
     BOOL               fOK = FALSE;

     /* do some checking */
    WinAssert(hmmio != 0);
     
    if (!lpcs->lpBits || !lpcs->lpBitsInfo)
        return FALSE;

    // Create a packed DIB, converting from a compressed format,
    // if necessary.
    hPackedDib = CreatePackedDib (lpcs->lpBitsInfo,
                        lpcs->lpBits,
                        lpcs->hPalCurrent);

    lpbi = (LPBITMAPINFO) GlobalLock (hPackedDib);

    if (!lpbi)
        goto WriteError;

    /* initialize the bitmap file header */
    bfh.bfType = 'B' | 'M' << 8;
    bfh.bfSize = sizeof(bfh) + sizeof(BITMAPINFOHEADER) +
        lpbi->bmiHeader.biSizeImage + 
        (lpbi->bmiHeader.biBitCount > 8 ? 0 : (lpbi->bmiHeader.biClrUsed * sizeof(RGBQUAD)));
  
    bfh.bfReserved1 = bfh.bfReserved2 = 0;
    bfh.bfOffBits = bfh.bfSize - lpbi->bmiHeader.biSizeImage ;

    // dw is the size of the BITMAPINFO + color table + image
    dw = bfh.bfSize - sizeof(bfh);

    /* write out the file header portion */
    if (mmioWrite(hmmio, (HPSTR)&bfh, (LONG)sizeof(BITMAPFILEHEADER)) != 
                sizeof(BITMAPFILEHEADER)){
         goto WriteError;
    }
    
    /* now write out the header and bits */
    if (mmioWrite(hmmio, (HPSTR)lpbi, (LONG) dw) == (LONG) dw) {
         fOK = TRUE;
    }
    
WriteError:
    if (lpbi)
        GlobalUnlock (hPackedDib);
    if (hPackedDib)
        GlobalFree (hPackedDib);

    return fOK;
}

/*--------------------------------------------------------------+
| fileSaveDIB - save the frame as a DIB                         |
|   Top level routine to save a single frame                    |
+--------------------------------------------------------------*/
BOOL FAR PASCAL fileSaveDIB(LPCAPSTREAM lpcs, LPSTR lpszFileName)
{
    HMMIO               hmmio;
    HCURSOR             hOldCursor;
    BOOL                fOK;

    hmmio = mmioOpen(lpszFileName, NULL, MMIO_WRITE);
    if( !hmmio ) {
	/* try and create */    
        hmmio = mmioOpen(lpszFileName, NULL, MMIO_CREATE | MMIO_WRITE);
	if( !hmmio ) {
	    /* find out if the file was read only or we are just */
	    /* totally hosed up here.				 */
	    hmmio = mmioOpen(lpszFileName, NULL, MMIO_READ);
	    if (hmmio){
		/* file was read only, error on it */
                errorUpdateError (lpcs, IDS_CAP_READONLYFILE, (LPSTR)lpszFileName);
		mmioClose(hmmio, 0);
		return FALSE;
	    } else {
		/* even weirder error has occured here, give CANTOPEN */
                errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPSTR) lpszFileName);
		return FALSE;
	    }
	}
    }

    hOldCursor = SetCursor( lpcs-> hWaitCursor );

    mmioSeek(hmmio, 0, SEEK_SET);

    fOK = dibWrite(lpcs, hmmio);

    mmioClose( hmmio, 0 );

    SetCursor( hOldCursor );

    if (!fOK)
       errorUpdateError (lpcs, IDS_CAP_ERRORDIBSAVE, (LPSTR) lpszFileName);

    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\capmci.c ===
/****************************************************************************
 *
 *   capmci.c
 * 
 *   Control of MCI devices during capture.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>         // for _fmemset 
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <msvideo.h>
#include <drawdib.h>
#include <mmddk.h>

#include "avicap.h"
#include "avicapi.h"        

#ifdef _DEBUG
    #define DSTATUS(lpcs, sz) statusUpdateStatus(lpcs, IDS_CAP_INFO, (LPSTR) sz)
#else
    #define DSTATUS(lpcs, sz) 
#endif

DWORD SendDriverFormat (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih, DWORD dwInfoHeaderSize);

/*--------------------------------------------------------------+
| TimeMSToHMSString() - change milliseconds into SMPTE time     |
+--------------------------------------------------------------*/
void FAR PASCAL TimeMSToSMPTE (DWORD dwMS, LPSTR lpTime)
{
	DWORD	dwTotalSecs;
	LONG	lHundredths;
	WORD	wSecs;
	WORD	wMins;
	WORD	wHours;

	/* convert to number of seconds */
	dwTotalSecs = dwMS / 1000;
	
	/* keep the remainder part */
	lHundredths = (dwMS - (dwTotalSecs * 1000)) / 10;
		    
	/* break down into other components */
	wHours = (WORD)(dwTotalSecs / 3600);	// get # Hours
	dwTotalSecs -= (wHours * 3600);
	
	wMins = (WORD)(dwTotalSecs / 60);	// get # Mins
	dwTotalSecs -= (wMins * 60);
	
	wSecs = (WORD)dwTotalSecs;	// what's left is # seconds
	
	/* build the string */
	/* KLUDGE, force hundredths to SMPTE approximation of PAL frames */
	wsprintf((char far *)lpTime, "%02u:%02u:%02u:%02lu", wHours, wMins,
		    wSecs, (lHundredths * 25) / 100);
}


/*--------------------------------------------------------------+
| START OF MCI CONTROL SECTION                                 |
+--------------------------------------------------------------*/

/*
 *  CountMCIDevicesByType 
 *      Returns a count of the number of VCR or Videodisc
 *      devices that MCI claims to know about.
 */

int CountMCIDevicesByType ( WORD wType )
{
   int nTotal;
   DWORD dwCount;
   MCI_SYSINFO_PARMS mciSIP;

   mciSIP.dwCallback = NULL;
   mciSIP.lpstrReturn = (LPSTR) (LPVOID) &dwCount;
   mciSIP.dwRetSize = sizeof (dwCount);

   mciSIP.wDeviceType = wType;
   
   if (!mciSendCommand (NULL, MCI_SYSINFO, MCI_SYSINFO_QUANTITY,
        (DWORD) (LPVOID) &mciSIP))
       nTotal = (int) *( (LPDWORD) mciSIP.lpstrReturn);

   return nTotal;
}

/*
 *  MCIDeviceClose
 *      This routine closes the open MCI device.
 */

void MCIDeviceClose (LPCAPSTREAM lpcs)
{
    mciSendString( "close mciframes", NULL, 0, NULL );
}

/*
 *  MCIDeviceOpen
 *      This routine opens the mci device for use, and sets the
 *      time format to milliseconds.
 *      Return FALSE on error;
 */

BOOL MCIDeviceOpen (LPCAPSTREAM lpcs)
{
    char        ach[160];

    wsprintf( ach, "open %s shareable alias mciframes",
                (LPSTR) lpcs-> achMCIDevice);
    lpcs-> dwMCIError = mciSendString( ach, NULL, 0, NULL );
    if( lpcs-> dwMCIError ) {
        DPF (" MCI Error, open %s shareable alias mciframes", lpcs-> achMCIDevice);
        goto err_return;
    }    
    lpcs-> dwMCIError = mciSendString( "set mciframes time format milliseconds", 
        NULL, 0, NULL );
    if( lpcs-> dwMCIError ) {
        DPF (" MCI Error, set mciframes time format milliseconds");
        goto err_close;
    }
    return ( TRUE );
   
err_close:
    MCIDeviceClose (lpcs);
err_return:
    return ( FALSE );
}


/*
 *  MCIDeviceGetPosition
 *      Stores the current device position in milliseconds in lpdwPos.
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceGetPosition (LPCAPSTREAM lpcs, LPDWORD lpdwPos)
{
    char        ach[80];
    LPSTR       p;
    LONG        lv;
        
    lpcs-> dwMCIError = mciSendString( "status mciframes position wait", 
        ach, sizeof(ach), NULL );
    if( lpcs-> dwMCIError ) {
        DPF (" MCI Error, status mciframes position wait");
        *lpdwPos = 0L;
        return FALSE;
    }

    p = ach; 
    
    while (*p == ' ') p++;
    for (lv = 0; *p >= '0' && *p <= '9'; p++)
        lv = (10 * lv) + (*p - '0');
    *lpdwPos = lv;
    return TRUE;
}

/*
 *  MCIDeviceSetPosition
 *      Sets the current device position in milliseconds.
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceSetPosition (LPCAPSTREAM lpcs, DWORD dwPos)
{
    char        achCommand[40];
    char        ach[80];
    
    lpcs-> dwMCIError = mciSendString( "pause mciframes wait", ach, sizeof(ach), NULL );
    if (lpcs-> dwMCIError) {
        DPF (" MCI Error, pause mciframes wait");
        return FALSE;
    }    
    wsprintf(achCommand, "seek mciframes to %ld wait", dwPos);
    lpcs-> dwMCIError = mciSendString( achCommand, ach, sizeof(ach), NULL );
    if (lpcs-> dwMCIError)
        DPF (" MCI Error, seek mciframes to %ld wait", dwPos);
    return ( lpcs-> dwMCIError == 0 ? TRUE : FALSE );
}


/*
 *  MCIDevicePlay
 *      Start playing the current MCI device from the current position
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDevicePlay (LPCAPSTREAM lpcs)
{
    char        ach[80];
    
    lpcs-> dwMCIError = mciSendString( "play mciframes", ach, sizeof(ach), NULL );
    if (lpcs-> dwMCIError)
        DPF (" MCI Error, play mciframes");
    return ( lpcs-> dwMCIError == 0 ? TRUE : FALSE );
}

/*
 *  MCIDevicePause
 *      Pauses the current MCI device at the current position
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDevicePause (LPCAPSTREAM lpcs)
{
    char        ach[80];
    
    lpcs-> dwMCIError = mciSendString( "pause mciframes wait", ach, sizeof(ach), NULL );
    if (lpcs-> dwMCIError)
        DPF (" MCI Error, pause mciframes wait");
    return ( lpcs-> dwMCIError == 0 ? TRUE : FALSE );
}

/*
 *  MCIDeviceStop
 *      Stops the current MCI device
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceStop (LPCAPSTREAM lpcs)
{
    char        ach[80];
    
    lpcs-> dwMCIError = mciSendString( "stop mciframes wait", ach, sizeof(ach), NULL );
    if (lpcs-> dwMCIError)
        DPF (" MCI Error, stop mciframes wait");
    return ( lpcs-> dwMCIError == 0 ? TRUE : FALSE );
}

/*
 *  MCIDeviceStep
 *      Step the current MCI at the current position
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceStep (LPCAPSTREAM lpcs, BOOL fForward)
{
    char        ach[80];
    
    lpcs-> dwMCIError = mciSendString( fForward ? "step mciframes wait" : 
                "step mciframes reverse wait", ach, sizeof(ach), NULL );
    if (lpcs-> dwMCIError)
        DPF (" MCI Error, step mciframes wait");
    return ( lpcs-> dwMCIError == 0 ? TRUE : FALSE );
}

/*
 *  MCIDeviceFreeze
 *      freeze the current frame
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceFreeze(LPCAPSTREAM lpcs, BOOL fFreeze)
{
    lpcs-> dwMCIError = mciSendString( fFreeze ? "freeze mciframes wait" : 
                "unfreeze mciframes wait", NULL, 0, NULL);
    if (lpcs-> dwMCIError)
        DPF (" MCI Error, freeze mciframes wait");
    return ( lpcs-> dwMCIError == 0 ? TRUE : FALSE );
}


/*
 *  MCIStepCapture
 *      Main routine for performing MCI step capture.
 *      
 */
void FAR PASCAL _loadds MCIStepCapture (LPCAPSTREAM lpcs)
{
    BOOL        fOK = TRUE;
    BOOL        fT;
    BOOL        fKey;
    BOOL        fStopping;         // True when finishing capture
    DWORD       dw;
    WORD        w;
    WORD        wError;         // Error String ID
    LPVIDEOHDR  lpVidHdr;
    LPWAVEHDR   lpWaveHdr;
    DWORD       dwTimeToStop;   // Lesser of MCI capture time or frame limit
    BOOL        fTryToPaint = FALSE;
    HDC         hdc;
    HPALETTE    hpalT;
    RECT        rcDrawRect;
    LONG        lSize;

    statusUpdateStatus(lpcs, IDS_CAP_BEGIN);  // Always the first message

    // Verify capture parameters
    if ((!lpcs->sCapParms.fMCIControl) ||
        (!lpcs->sCapParms.fStepMCIDevice))
        goto EarlyExit;

    lpcs->MCICaptureState = CAPMCI_STATE_Uninitialized;

    lpcs-> fCapturingNow = TRUE;
    lpcs-> fStepCapturingNow = TRUE;
    lpcs-> dwReturn = DV_ERR_OK;

    // If not 1 Meg. free, give it up!!!
    if (GetFreePhysicalMemory () < (1024L * 1024L)) {
        errorUpdateError (lpcs, IDS_CAP_OUTOFMEM);
        lpcs-> dwReturn = IDS_CAP_OUTOFMEM;
        goto EarlyExit;
    }

    statusUpdateStatus(lpcs, IDS_CAP_STAT_CAP_INIT);

    // Try painting the DIB only if Live window
    fTryToPaint = lpcs->fLiveWindow;

    if (fTryToPaint) {
        hdc = GetDC(lpcs->hwnd);
        SetWindowOrg(hdc, lpcs->ptScroll.x, lpcs->ptScroll.y);
        hpalT = DrawDibGetPalette (lpcs->hdd);
        if (hpalT)
            hpalT = SelectPalette( hdc, hpalT, FALSE);
        RealizePalette(hdc);
        if (lpcs-> fScale)
            GetClientRect (lpcs->hwnd, &rcDrawRect);
        else
            SetRect (&rcDrawRect, 0, 0, lpcs->dxBits, lpcs->dyBits);
    }

    // -------------------------------------------------------
    //   When should capture stop?
    // -------------------------------------------------------

    // If using MCI, capture for the shorter of the MCI period,
    // or the capture limit

    if (lpcs->sCapParms.fLimitEnabled)
        dwTimeToStop = (DWORD) ((DWORD) 1000 * lpcs->sCapParms.wTimeLimit);
    else
        dwTimeToStop = (DWORD) -1L; // very large

    if (lpcs->sCapParms.fMCIControl) {
        // if MCI stop time not given, use lpcs->sCapParms.wTimeLimit
        if (lpcs->sCapParms.dwMCIStopTime == lpcs->sCapParms.dwMCIStartTime)
                    lpcs->sCapParms.dwMCIStopTime = lpcs->sCapParms.dwMCIStartTime +
                    (DWORD) ((DWORD)1000 * lpcs->sCapParms.wTimeLimit);

        dw = lpcs->sCapParms.dwMCIStopTime - lpcs->sCapParms.dwMCIStartTime;

        if (lpcs->sCapParms.fLimitEnabled) 
            dwTimeToStop = min (dw, dwTimeToStop);
        else 
            dwTimeToStop = dw;
    }

    //
    // never ever try to capture more than the index size!
    //
    if (lpcs->fCapturingToDisk) {
        dw = muldiv32(lpcs->sCapParms.dwIndexSize,
                lpcs->sCapParms.dwRequestMicroSecPerFrame,
                1000l);
        dwTimeToStop = min (dw, dwTimeToStop);
    }

    fOK = FALSE;            // Assume the worst
    if (MCIDeviceOpen (lpcs)) {
        if (MCIDeviceSetPosition (lpcs, lpcs->sCapParms.dwMCIStartTime))
            if (MCIDeviceStep (lpcs, TRUE))
                fOK = TRUE;
    }
    if (!fOK) {
        errorUpdateError (lpcs, IDS_CAP_MCI_CONTROL_ERROR);
        statusUpdateStatus(lpcs, NULL);    // Clear status
        lpcs-> dwReturn = IDS_CAP_MCI_CONTROL_ERROR;
        goto EarlyExit;
    }

    // -------------------------------------------------------
    //  Spatial and temporal averaging
    // -------------------------------------------------------

    // Frame Averaging, capture the same frame multiple times...
    lpcs->lpia = NULL;
    if (lpcs->sCapParms.wStepCaptureAverageFrames == 0)
        lpcs->sCapParms.wStepCaptureAverageFrames = 1;

    // Only allow averaging if an RGB format
    if (lpcs->lpBitsInfo->bmiHeader.biCompression != BI_RGB)
        lpcs->sCapParms.wStepCaptureAverageFrames = 1;

    // 2x Scaling
    lpcs->lpbmih2x = NULL;
    lpcs->VidHdr2x = lpcs->VidHdr;        // Init the 2x copy 

    if (lpcs->sCapParms.fStepCaptureAt2x && 
                lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RGB) {
        lpcs->VidHdr2x.lpData = NULL;
        lpcs->lpbmih2x = (LPBITMAPINFOHEADER) GlobalAllocPtr (GHND, 
                sizeof (BITMAPINFOHEADER) +
                256 * sizeof (RGBQUAD));
        _fmemcpy (lpcs->lpbmih2x, lpcs->lpBitsInfo, sizeof (BITMAPINFOHEADER) +
                256 * sizeof (RGBQUAD));

        // Try to force the driver into 2x mode
        lpcs->lpbmih2x->biHeight    *= 2;
        lpcs->lpbmih2x->biWidth     *= 2;
        lpcs->lpbmih2x->biSizeImage *= 4;
        if (!SendDriverFormat (lpcs, lpcs->lpbmih2x, sizeof (BITMAPINFOHEADER))) {
            // Success, allocate new bitspace
            lpcs->VidHdr2x.lpData = GlobalAllocPtr (GHND, 
                        lpcs->lpbmih2x->biSizeImage);
            lpcs->VidHdr2x.dwBufferLength = lpcs->lpbmih2x->biSizeImage;
        }

        // Something went wrong, no memory, or driver failed request
        // so revert back to original settings
        if (!lpcs->VidHdr2x.lpData) {
            SendDriverFormat (lpcs, (LPBITMAPINFOHEADER) lpcs->lpBitsInfo, 
                sizeof (BITMAPINFOHEADER));
            lpcs->sCapParms.fStepCaptureAt2x = FALSE;
            lpcs->VidHdr2x = lpcs->VidHdr;        // Back to the original settings
        }
    }
    else
        lpcs->sCapParms.fStepCaptureAt2x = FALSE;

    DPF (" StepCaptureAt2x = %d\r\n", (int) lpcs->sCapParms.fStepCaptureAt2x);

    //
    // If we're compressing while capturing, warm up the compressor
    //
    if (lpcs->CompVars.hic) {
        if (ICSeqCompressFrameStart(&lpcs->CompVars, lpcs->lpBitsInfo) == NULL) {

	    // !!! We're in trouble here!  
            dprintf("ICSeqCompressFrameStart failed !!!\n");
            lpcs-> dwReturn = IDS_CAP_COMPRESSOR_ERROR;
            errorUpdateError (lpcs, IDS_CAP_COMPRESSOR_ERROR);
            goto EarlyExit;
        }
        // Kludge, offset the lpBitsOut ptr 
        // Compman allocates the compress buffer too large by 
        // 2048 + 16 so we will still have room 
        ((LPBYTE) lpcs->CompVars.lpBitsOut) += 8;
    }

    // No compression desired
    if (!lpcs->CompVars.hic)
	WinAssert(lpcs->CompVars.lpbiOut == NULL);

    // -------------------------------------------------------
    //  Open the output file
    // -------------------------------------------------------

    if (lpcs->fCapturingToDisk) {
        if (!AVIFileInit(lpcs)) {
            lpcs-> dwReturn = IDS_CAP_FILE_OPEN_ERROR;
            errorUpdateError (lpcs, IDS_CAP_FILE_OPEN_ERROR);
            goto EarlyExit;
        }
    }    

    /* Make sure the parent has been repainted */
    UpdateWindow(lpcs->hwnd);

    //
    // AVIInit will allocate sound buffers, but not video buffers
    // when performing step capture.
    //

    wError = AVIInit(lpcs);

    if (wError) {
        lpcs->sCapParms.fUsingDOSMemory = FALSE;
        wError = AVIInit(lpcs);
    }

    if (wError) {
        /* Error in initalization - return */
        errorUpdateError (lpcs, wError);
        AVIFini(lpcs);  
        AVIFileFini(lpcs, TRUE /* fWroteJunkChunks */, TRUE /* fAbort */);
        statusUpdateStatus(lpcs, NULL);    // Clear status
        lpcs-> dwReturn = wError;
        goto EarlyExit;
    }

    /* update the status, so the user knows how to stop */
    statusUpdateStatus(lpcs, IDS_CAP_SEQ_MSGSTOP);
    UpdateWindow(lpcs->hwnd);


    if (lpcs->sCapParms.fStepCaptureAt2x || (lpcs->sCapParms.wStepCaptureAverageFrames != 1)) {
        LPIAVERAGE FAR * lppia = (LPIAVERAGE FAR *) &lpcs->lpia;

        statusUpdateStatus (lpcs, IDS_CAP_STAT_PALETTE_BUILD);
        if (!iaverageInit (lppia, lpcs->lpBitsInfo, lpcs->hPalCurrent)) {
            lpcs-> dwReturn = IDS_CAP_OUTOFMEM;
            goto CompressFrameFailure;                
        }
        statusUpdateStatus(lpcs, NULL);
    }
    DPF (" Averaging %d frames\r\n", lpcs->sCapParms.wStepCaptureAverageFrames);

    GetAsyncKeyState(lpcs->sCapParms.vKeyAbort);
    GetAsyncKeyState(VK_ESCAPE);
    GetAsyncKeyState(VK_LBUTTON);
    GetAsyncKeyState(VK_RBUTTON);


    // -------------------------------------------------------
    //   MAIN VIDEO CAPTURE LOOP
    // -------------------------------------------------------

    fOK=TRUE;             // Set FALSE on write errors
    fStopping = FALSE;    // TRUE when we need to stop

    lpVidHdr  = &lpcs->VidHdr;
    lpWaveHdr = lpcs->alpWaveHdr[lpcs->iNextWave];

    lpcs->MCICaptureState = CAPMCI_STATE_Initialized;
    lpcs->dwTimeElapsedMS = 0;

    // Move back to the starting position
    MCIDeviceSetPosition (lpcs, lpcs->sCapParms.dwMCIStartTime);
    MCIDevicePause (lpcs);

    // Where are we *really*
    MCIDeviceGetPosition (lpcs, &lpcs->dwMCIActualStartMS);

    // freeze video
    MCIDeviceFreeze(lpcs, TRUE);
    
    while (lpcs->MCICaptureState != CAPMCI_STATE_AllFini) {

        // -------------------------------------------------------
        //   is there any reason to stop or change states
        // -------------------------------------------------------
        if (lpcs->sCapParms.vKeyAbort) {
            if (GetAsyncKeyState(lpcs->sCapParms.vKeyAbort & 0x00ff) & 0x0001) {
                fT = TRUE;
                if (lpcs->sCapParms.vKeyAbort & 0x8000)  // Ctrl?
                    fT = fT && (GetAsyncKeyState(VK_CONTROL) & 0x8000);
                if (lpcs->sCapParms.vKeyAbort & 0x4000)  // Shift?
                    fT = fT && (GetAsyncKeyState(VK_SHIFT) & 0x8000);
                fStopping = fT;      // User aborts
            }
        }
#if 0
        // Ignore Left mouse on MCI Capture!!!
        if (lpcs->sCapParms.fAbortLeftMouse)
            if (GetAsyncKeyState(VK_LBUTTON) & 0x0001)
                fStopping = TRUE;      // User aborts
#endif

        if (lpcs->sCapParms.fAbortRightMouse)
            if (GetAsyncKeyState(VK_RBUTTON) & 0x0001)
                fStopping = TRUE;      // User aborts
        if (lpcs-> fAbortCapture) {
            fStopping = TRUE;          // Somebody above wants us to quit
        }
        if (lpcs-> dwTimeElapsedMS > dwTimeToStop)
            fStopping = TRUE;      // all done


        // -------------------------------------------------------
        //    State machine 
        // -------------------------------------------------------
        switch (lpcs-> MCICaptureState) {

        case CAPMCI_STATE_Initialized:
            // Begin video step capture
            DSTATUS(lpcs, "MCIState: Initialized");
            lpcs->MCICaptureState = CAPMCI_STATE_StartVideo;
            break;

        case CAPMCI_STATE_StartVideo:
            // Begin video step capture
            lpcs->dwTimeElapsedMS = 0;
            lpcs->MCICaptureState = CAPMCI_STATE_CapturingVideo;
            break;

        case CAPMCI_STATE_CapturingVideo:
            // In the state of capturing video
            if (lpcs-> fStopCapture || lpcs-> fAbortCapture)
                fStopping = TRUE;

            if (fStopping) {
                MCIDeviceGetPosition (lpcs, &lpcs->dwMCIActualEndMS);
                MCIDevicePause (lpcs);

                DSTATUS(lpcs, "MCIState: StoppingVideo");

                if (fOK && !lpcs-> fAbortCapture)
                    lpcs->MCICaptureState = CAPMCI_STATE_VideoFini;
                else
                    lpcs->MCICaptureState = CAPMCI_STATE_AllFini;

                lpcs-> fStopCapture  = FALSE;
                lpcs-> fAbortCapture = FALSE;
                fStopping = FALSE;
            }
            break;

        case CAPMCI_STATE_VideoFini:
            // Wait for all buffers to be returned from the driver
            // Then move on to audio capture
            lpcs->MCICaptureState = CAPMCI_STATE_StartAudio;
            DSTATUS(lpcs, "MCIState: VideoFini");
            break;

        case CAPMCI_STATE_StartAudio:
            // If no audio, go to AllFini state
            if (!lpcs->sCapParms.fCaptureAudio || !fOK) {
                lpcs->MCICaptureState = CAPMCI_STATE_AllFini;
                break;
            }

            // Move back to the starting position
            MCIDeviceSetPosition (lpcs, lpcs->dwMCIActualStartMS);
            MCIDeviceGetPosition (lpcs, &lpcs->dwMCICurrentMS);
            DSTATUS(lpcs, "MCIState: StartAudio");
            MCIDevicePlay (lpcs);
            waveInStart(lpcs->hWaveIn);
            lpcs->MCICaptureState = CAPMCI_STATE_CapturingAudio;
            lpcs->dwTimeElapsedMS = 0;
            fStopping = FALSE;
            break;

        case CAPMCI_STATE_CapturingAudio:
            // In the state of capturing audio
            if (lpcs-> fStopCapture || lpcs-> fAbortCapture)
                fStopping = TRUE;

            MCIDeviceGetPosition (lpcs, &lpcs->dwMCICurrentMS);
            if (lpcs->dwMCICurrentMS + 100 > lpcs->dwMCIActualEndMS)
                fStopping = TRUE;
            if (fStopping) {
                waveInStop(lpcs->hWaveIn);
                MCIDevicePause (lpcs);
                waveInReset(lpcs->hWaveIn);
                lpcs->MCICaptureState = CAPMCI_STATE_AudioFini;
            }
            break;

        case CAPMCI_STATE_AudioFini:
            // While more audio buffers to process
            if (lpWaveHdr-> dwFlags & WHDR_DONE)
                break;
            lpcs->MCICaptureState = CAPMCI_STATE_AllFini;
            break;

        case CAPMCI_STATE_AllFini:
            DSTATUS(lpcs, "MCIState: AllFini");
            if (fOK)
                statusUpdateStatus(lpcs, IDS_CAP_STAT_CAP_FINI, lpcs->dwVideoChunkCount);
            else 
                statusUpdateStatus(lpcs, IDS_CAP_RECORDING_ERROR2);
            break;
        }

        // -------------------------------------------------------
        //        If we are in the video capture phase
        // -------------------------------------------------------

        if (lpcs->MCICaptureState == CAPMCI_STATE_CapturingVideo) {

            // if averaging...
            if (lpcs-> lpia) {
                int j;

                iaverageZero (lpcs-> lpia);

                // sum together a bunch of frames
                for (j = 0; j < (int)lpcs->sCapParms.wStepCaptureAverageFrames; j++) {
                        
	            videoFrame( lpcs-> hVideoIn, &lpcs-> VidHdr2x);

    	            // Shrink by 2x??
                    if (lpcs-> sCapParms.fStepCaptureAt2x) {
                        CrunchDIB(
                            lpcs-> lpia,        // image averaging structure
                            (LPBITMAPINFOHEADER)  lpcs-> lpbmih2x,  // BITMAPINFO src
                            (LPVOID) lpcs-> VidHdr2x.lpData,      // input bits 
                            (LPBITMAPINFOHEADER)  lpcs->lpBitsInfo, // BITMAPINFO dst
                            (LPVOID) lpcs->VidHdr.lpData);       // output bits
                    }
                    iaverageSum (lpcs-> lpia, lpcs->lpBits);
                }
                iaverageDivide (lpcs-> lpia, lpcs->lpBits);
            }
            // otherwise, not averaging, just get a frame
            else {
	        videoFrame( lpcs-> hVideoIn, &lpcs->VidHdr);
            }                           
                                    
            if (lpcs->CallbackOnVideoFrame)
                (*(lpcs->CallbackOnVideoFrame)) (lpcs->hwnd, &lpcs->VidHdr);

            // Update the display
	    InvalidateRect(lpcs->hwnd, NULL, TRUE);
	    UpdateWindow(lpcs->hwnd);
	    
            if (lpcs-> fCapturingToDisk) {
                if (!SingleFrameWrite (lpcs, lpVidHdr, &fKey, &lSize)) {
                    fOK = FALSE;
                    fStopping = TRUE;
                    // "ERROR: Could not write to file."
                    errorUpdateError(lpcs, IDS_CAP_FILE_WRITE_ERROR);
                } 
                else {
                    if (!IndexVideo(lpcs, lSize, fKey))
                        fStopping = TRUE;
                }
            } // endif fCapturingToDisk
            // Warning: Kludge to create frame chunk count when net capture
            // follows.
            else
                lpcs->dwVideoChunkCount++;
            
            // if there is still more time, (or at least every 100 frames) 
            // show status if we're not ending the capture
            if ((!fStopping) && (lpcs-> fCapturingToDisk) &&
                    (lpcs->dwVideoChunkCount)) {

                // "Captured %ld frames (Dropped %ld) %d.%03d sec. Hit Escape to Stop"
                statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOCURRENT, 
                        lpcs->dwVideoChunkCount, lpcs->dwFramesDropped,
                        (int)(lpcs-> dwTimeElapsedMS/1000),
                        (int)(lpcs-> dwTimeElapsedMS%1000)
                        );
            } // endif next buffer not ready

            // Move the MCI source to the next capture point
            // unfreeze video
            MCIDeviceFreeze(lpcs, FALSE);
            for (;;) {
                MCIDeviceGetPosition (lpcs, &lpcs->dwMCICurrentMS);
                if (lpcs->dwMCICurrentMS > ((DWORD) (lpcs->dwMCIActualStartMS + 
                          muldiv32 (lpcs->dwVideoChunkCount,
                                lpcs->sCapParms.dwRequestMicroSecPerFrame,
                                1000L))))
                    break;
                MCIDeviceStep (lpcs, TRUE);
            }
            // freeze video
            MCIDeviceFreeze(lpcs, TRUE);
            lpcs-> dwTimeElapsedMS =
                    lpcs->dwMCICurrentMS - lpcs->dwMCIActualStartMS;

             /* return the emptied buffer to the que */
            lpVidHdr->dwFlags &= ~VHDR_DONE;
        }

        if (lpcs-> CallbackOnYield) {
            // If the yield callback returns FALSE, abort
            if (!((*(lpcs->CallbackOnYield)) (lpcs->hwnd)))
                fStopping = TRUE;
        }

        if (lpcs->sCapParms.fYield) { 
            MSG msg;

            if (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
                // Kludge to get rid of timers from lpcs->hwnd
                if (msg.message == WM_TIMER && msg.hwnd == lpcs->hwnd)
                    ;
                else {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }

        // -------------------------------------------------------
        //        Is audio buffer ready to be written?
        // -------------------------------------------------------
        if (lpcs->sCapParms.fCaptureAudio && 
                (lpcs-> MCICaptureState == CAPMCI_STATE_CapturingAudio ||
                lpcs-> MCICaptureState == CAPMCI_STATE_StartAudio ||
                lpcs-> MCICaptureState == CAPMCI_STATE_AudioFini)) {
            int iLastWave;

            //
            // we may need to yield for audio to get converted.
            //
            if (lpcs->fAudioYield)
                Yield();

            //
            // if all buffers are done, we have broke audio.
            //
            iLastWave = lpcs->iNextWave == 0 ? 
                        lpcs->iNumAudio -1 : lpcs->iNextWave-1;

            if (!fStopping && 
                    lpcs->alpWaveHdr[iLastWave]->dwFlags & WHDR_DONE)
                lpcs->fAudioBreak = TRUE;

            w = lpcs->iNumAudio; // don't get stuck here forever...
            while (w && fOK && (lpWaveHdr-> dwFlags & WHDR_DONE)) {
                w--;
                if (lpWaveHdr-> dwBytesRecorded) {
                    /* Chunk info is included in the wave data */
                    /* Reset Chunk Size in buffer */
                    ((LPRIFF)(lpWaveHdr->lpData))[-1].dwSize = 
                                lpWaveHdr-> dwBytesRecorded;
                    if (lpcs-> CallbackOnWaveStream) {
                        (*(lpcs->CallbackOnWaveStream)) (lpcs->hwnd, lpWaveHdr);
                    }
                    if (lpcs-> fCapturingToDisk) {
                        if(!AVIWrite (lpcs, lpWaveHdr-> lpData - sizeof(RIFF),
                                (lpWaveHdr-> dwBytesRecorded +
                                sizeof (RIFF) + 1) & ~1L)) {
                            fOK = FALSE;
                            fStopping = TRUE;
                            errorUpdateError (lpcs, IDS_CAP_FILE_WRITE_ERROR);
                         } else {
                            if (IndexAudio (lpcs, lpWaveHdr-> dwBytesRecorded))
                                lpcs->dwWaveBytes += lpWaveHdr-> dwBytesRecorded;
                            else
                                fStopping = TRUE;                                
                         }
                    } // endif capturing to disk
                    // Warning: Kludge to create wave chunk count when net capture
                    // follows.
                    else {
                        lpcs->dwWaveChunkCount++;
                        lpcs->dwWaveBytes += lpWaveHdr-> dwBytesRecorded;
                    }
                } // endif dwBytesRecorded
                
                lpWaveHdr-> dwBytesRecorded = 0;
                lpWaveHdr-> dwFlags &= ~WHDR_DONE;

                 /* return the emptied buffer to the que */
                if(waveInAddBuffer(lpcs->hWaveIn, lpWaveHdr, sizeof(WAVEHDR))) {
                    fOK = FALSE;
                    fStopping = TRUE;
                    errorUpdateError(lpcs, IDS_CAP_WAVE_ADD_ERROR);
                }

                /* increment the next wave buffer pointer */
                if(++lpcs->iNextWave >= lpcs->iNumAudio)
                    lpcs->iNextWave = 0;

                lpWaveHdr = lpcs->alpWaveHdr[lpcs->iNextWave];

            } // endwhile buffer available
        } // endif sound enabled
    } // end of forever

CompressFrameFailure:

    iaverageFini (lpcs->lpia);

    // Switch back to the normal format
    if (lpcs->sCapParms.fStepCaptureAt2x) {
        SendDriverFormat (lpcs, (LPBITMAPINFOHEADER) lpcs->lpBitsInfo, 
                sizeof (BITMAPINFOHEADER));
        GlobalFreePtr (lpcs->VidHdr2x.lpData);
        lpcs->VidHdr2x.lpData = NULL;
    }
    
    // And free the 2x memory
    if (lpcs->lpbmih2x) {
        GlobalFreePtr (lpcs->lpbmih2x);
        lpcs->lpbmih2x = NULL;
    }

    // -------------------------------------------------------
    //   END OF MAIN CAPTURE LOOP
    // -------------------------------------------------------
    
    lpcs-> dwTimeElapsedMS = lpcs-> dwMCIActualEndMS - lpcs->dwMCIActualStartMS;

    /* eat any keys that have been pressed */
    while(GetKey(FALSE))
        ;

    AVIFini(lpcs);  // does the Reset, and frees all buffers
    AVIFileFini(lpcs, FALSE /* fWroteJunkChunks */, FALSE /* fAbort */);
    

    /* Notify if there was an error while recording */

    if(!fOK) {
        errorUpdateError (lpcs, IDS_CAP_RECORDING_ERROR);
    }
    
    if (lpcs-> fCapturingToDisk) {
        if (lpcs->dwVideoChunkCount)
            dw = muldiv32(lpcs->dwVideoChunkCount,1000000,lpcs-> dwTimeElapsedMS);
        else 
            dw = 0;     // The muldiv32 doesn't give 0 if numerator is zero

        if(lpcs->sCapParms.fCaptureAudio) {
            // "Captured %d.%03d sec.  %ld frames (%d dropped) (%d.%03d fps).  %ld audio bytes (%d.%03d sps)"
            statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOAUDIO,
                  (WORD)(lpcs-> dwTimeElapsedMS/1000),
                  (WORD)(lpcs-> dwTimeElapsedMS%1000),
                  lpcs->dwVideoChunkCount,
                  lpcs->dwFramesDropped,
                  (WORD)(dw / 1000),
                  (WORD)(dw % 1000),
                  lpcs->dwWaveBytes,
                  (WORD) lpcs->lpWaveFormat->nSamplesPerSec / 1000,
                  (WORD) lpcs->lpWaveFormat->nSamplesPerSec % 1000);
        } else {
            // "Captured %d.%03d sec.  %ld frames (%d dropped) (%d.%03d fps)."
            statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOONLY,
                  (WORD)(lpcs-> dwTimeElapsedMS/1000),
                  (WORD)(lpcs-> dwTimeElapsedMS%1000),
                  lpcs->dwVideoChunkCount,
                  lpcs->dwFramesDropped,
                  (WORD)(dw / 1000),
                  (WORD)(dw % 1000));
        }
    } // endif capturing to disk (no warnings or errors if to net)

    // No frames captured, warn user that interrupts are probably not enabled.
    if (fOK && (lpcs->dwVideoChunkCount == 0)) {
        errorUpdateError (lpcs, IDS_CAP_NO_FRAME_CAP_ERROR);
    }
    // No audio captured, (but enabled), warn user audio card is hosed
    else if (fOK && lpcs->sCapParms.fCaptureAudio && (lpcs->dwWaveBytes == 0)) {
        errorUpdateError (lpcs, IDS_CAP_NO_AUDIO_CAP_ERROR);
    }

    // Audio underrun, inform user
    else if (fOK && lpcs->sCapParms.fCaptureAudio && lpcs->fAudioBreak) {
        errorUpdateError (lpcs, IDS_CAP_AUDIO_DROP_ERROR);
    }

    // If frames dropped, or changed capture rate, warn the user
    else if (fOK && lpcs->dwVideoChunkCount && lpcs->fCapturingToDisk) {

        // Warn user if dropped > 10% (default) of the frames
        if ((DWORD)100 * lpcs->dwFramesDropped / lpcs->dwVideoChunkCount >
                    lpcs-> sCapParms.wPercentDropForError) {

            // "%d of %ld frames (%d.%03d\%) dropped during capture."
            errorUpdateError (lpcs, IDS_CAP_STAT_FRAMESDROPPED,
                  lpcs->dwFramesDropped,
                  lpcs->dwVideoChunkCount,
                  (WORD)(muldiv32(lpcs->dwFramesDropped,10000,lpcs->dwVideoChunkCount)/100),
                  (WORD)(muldiv32(lpcs->dwFramesDropped,10000,lpcs->dwVideoChunkCount)%100)
                  );
        }
    }

EarlyExit:

    //
    // If we were compressing while capturing, close it down
    //
    if (lpcs->CompVars.hic) {
        // Kludge, reset the lpBitsOut pointer
        if (lpcs->CompVars.lpBitsOut)
            ((LPBYTE) lpcs->CompVars.lpBitsOut) -= 8;
	ICSeqCompressFrameEnd(&lpcs->CompVars);
    }

    if (fTryToPaint) {
        if (hpalT)
             SelectPalette(hdc, hpalT, FALSE);
        ReleaseDC (lpcs->hwnd, hdc);
    }

    if (lpcs->sCapParms.fMCIControl) 
        MCIDeviceClose (lpcs);

    // Let the user see where capture stopped
    if ((!lpcs->fLiveWindow) && (!lpcs->fOverlayWindow)) 
        videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );  
    InvalidateRect( lpcs->hwnd, NULL, TRUE);

    lpcs->fCapFileExists = (lpcs-> dwReturn == DV_ERR_OK);
    lpcs->fCapturingNow      = FALSE;
    lpcs-> fStepCapturingNow = FALSE;
    
    statusUpdateStatus(lpcs, IDS_CAP_END);  // Always the last message

    return;
}



       


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\capframe.c ===
/****************************************************************************
 *
 *   capframe.c
 * 
 *   Single frame capture
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>         // for _fmemset 
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <msvideo.h>
#include <drawdib.h>
#include <mmddk.h>
#include <avifmt.h>

#include "avicap.h"
#include "avicapi.h"        

#ifdef _DEBUG
    #define DSTATUS(lpcs, sz) statusUpdateStatus(lpcs, IDS_CAP_INFO, (LPSTR) sz)
#else
    #define DSTATUS(lpcs, sz) 
#endif


/*
 *  SingleFrameCaptureOpen
 *      
 */
BOOL FAR PASCAL SingleFrameCaptureOpen (LPCAPSTREAM lpcs)
{
    if (lpcs-> fCapturingNow || lpcs-> fFrameCapturingNow) {
        lpcs-> dwReturn = IDS_CAP_FILE_OPEN_ERROR;
        goto EarlyExit;
    }
    
    /* Warm up the compressor function */
    if (lpcs->CompVars.hic) {
        if (ICSeqCompressFrameStart(&lpcs->CompVars, lpcs->lpBitsInfo) == FALSE) {
            lpcs-> dwReturn = IDS_CAP_COMPRESSOR_ERROR;
            goto EarlyExit;
	}
        // Kludge, offset the lpBitsOut ptr 
        // Compman allocates the compress buffer too large by 
        // 2048 + 16 so we will still have room 
        ((LPBYTE) lpcs->CompVars.lpBitsOut) += 8;
    }

    if (!AVIFileInit(lpcs)) {
        lpcs-> dwReturn = IDS_CAP_FILE_OPEN_ERROR;
        goto EarlyExit;
    }

    lpcs-> fCapturingNow = TRUE;
    lpcs-> fFrameCapturingNow = TRUE;
    lpcs-> dwReturn = DV_ERR_OK;

    statusUpdateStatus(lpcs, IDS_CAP_BEGIN);  // Always the first message

    return TRUE;
            
EarlyExit:
    errorUpdateError(lpcs, (WORD) lpcs->dwReturn);
    return FALSE;
}


/*
 *  SingleFrameCaptureClose
 *      
 *      
 */
BOOL FAR PASCAL SingleFrameCaptureClose (LPCAPSTREAM lpcs)
{

    if ((!lpcs-> fCapturingNow) && (!lpcs-> fFrameCapturingNow)) {
        lpcs-> dwReturn = IDS_CAP_FILE_OPEN_ERROR;
        errorUpdateError(lpcs, (WORD) lpcs->dwReturn);
        return FALSE;
    }
    
    AVIFileFini(lpcs, FALSE /* fWroteJunkChunks */, FALSE /* fAbort */);
    
    if (lpcs->CompVars.hic) {
        // Kludge, offset the lpBitsOut ptr 
        if (lpcs->CompVars.lpBitsOut)
            ((LPBYTE) lpcs->CompVars.lpBitsOut) -= 8;
	ICSeqCompressFrameEnd(&lpcs->CompVars);
    }    

    lpcs->fCapFileExists = (lpcs-> dwReturn == DV_ERR_OK);
    lpcs->fCapturingNow = FALSE;
    lpcs->fFrameCapturingNow = FALSE;
    
    statusUpdateStatus(lpcs, IDS_CAP_END);  // Always the last message

    return TRUE;
}


// Writes compressed or uncompressed frames to the AVI file
// returns TRUE if no error, FALSE if end of file,
// and sets pfKey and plSize on exit.

BOOL SingleFrameWrite (
    LPCAPSTREAM             lpcs,       // capture stream
    LPVIDEOHDR              lpVidHdr,   // input header
    BOOL FAR 		    *pfKey,	// did it end up being a key frame?
    LONG FAR		    *plSize)	// size of returned image
{
    MMCKINFO    ck;
    BOOL        fOK = TRUE;
    DWORD	dwBytesUsed;
    BOOL	fKeyFrame;
    LPSTR	lpBits;

    if ((!lpcs-> fCapturingNow) ||
                (!(lpcs-> fStepCapturingNow || lpcs-> fFrameCapturingNow)) ||
                (!lpcs->hmmio)) {
        lpcs-> dwReturn = IDS_CAP_FILE_OPEN_ERROR;
        return FALSE;
    }
    
    /* Now compress the DIB to the format they chose */
    if (lpcs->CompVars.hic) {
	dwBytesUsed = 0;	// don't force a data rate
        lpBits = ICSeqCompressFrame(&lpcs->CompVars, 0,
    	        lpcs->lpBits, &fKeyFrame, &dwBytesUsed);

    /* They don't want it compressed */
    } else {
        // Use current values for writing the DIB to disk
        dwBytesUsed = lpcs->VidHdr.dwBytesUsed;
        fKeyFrame = (BOOL)(lpcs->VidHdr.dwFlags & VHDR_KEYFRAME);
        lpBits = lpcs->lpBits;
    }

    /* Create DIB Bits chunk */
    ck.cksize = dwBytesUsed;
    ck.ckid = MAKEAVICKID(cktypeDIBbits,0);
    ck.fccType = 0;
    if (mmioCreateChunk(lpcs->hmmio,&ck,0)) {
        fOK = FALSE;
    }

    /* Write DIB  data */
    if (fOK && mmioWrite(lpcs->hmmio, lpBits, dwBytesUsed) != 
                (LONG) dwBytesUsed) {
        fOK = FALSE;
    }
    
    if (fOK && mmioAscend(lpcs->hmmio, &ck, 0)) {
        fOK = FALSE;
    }

    *pfKey = fKeyFrame;
    *plSize = dwBytesUsed;

    return fOK;
}


/*
 *  SingleFrameCapture
 *      
 *  Append to the open single frame capture file.
 */
BOOL FAR PASCAL SingleFrameCapture (LPCAPSTREAM lpcs)
{
    LPVIDEOHDR lpVidHdr = &lpcs->VidHdr;
    BOOL fOK = FALSE;
    BOOL fKey;
    LONG lSize;

    if ((!lpcs-> fCapturingNow) ||
                (!(lpcs-> fStepCapturingNow || lpcs-> fFrameCapturingNow)) ||
                (!lpcs->hmmio)) {
        lpcs-> dwReturn = IDS_CAP_FILE_OPEN_ERROR;
        errorUpdateError(lpcs, (WORD) lpcs->dwReturn);
        return FALSE;
    }

    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );
    InvalidateRect( lpcs->hwnd, NULL, TRUE);

    if (lpVidHdr-> dwBytesUsed) {
        if (lpcs->CallbackOnVideoFrame)
            (*(lpcs->CallbackOnVideoFrame)) (lpcs->hwnd, lpVidHdr);

        if (!SingleFrameWrite (lpcs, lpVidHdr, &fKey, &lSize)) {
            // "ERROR: Could not write to file."
            errorUpdateError(lpcs, IDS_CAP_FILE_WRITE_ERROR);
        } 
        else {
            fOK = IndexVideo(lpcs, lSize, fKey);
            statusUpdateStatus (lpcs, IDS_CAP_STAT_CAP_L_FRAMES,
                            lpcs-> dwVideoChunkCount);
        }
    } // if the frame is done
    else
        errorUpdateError (lpcs, IDS_CAP_RECORDING_ERROR2);

    return fOK;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\capfile.c ===
/****************************************************************************
 *
 *   capfile.c
 * 
 *   AVI file writing module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <avifmt.h>
#include <drawdib.h>
#include "avicap.h"
#include "avicapi.h"


/*----------------------------------------------------------------------+
| fileCapFileIsAVI() - Returns TRUE if the capture file is a valid AVI |
|                                   |
+----------------------------------------------------------------------*/
BOOL FAR PASCAL fileCapFileIsAVI (LPSTR lpsz)
{
    BOOL        fReturn = TRUE;
    HMMIO       hmmioSource = NULL;
    MMCKINFO    ckRIFF;
    
    // Does the file exist?
    hmmioSource = mmioOpen(lpsz, NULL, MMIO_READ);
    if (!hmmioSource)
        return FALSE;
    
    // Is there an AVI RIFF chunk?
    // !!! Don't do a FINDRIFF for an AVI chunk or it'll take several minutes to
    // !!! come back from checking a really big file
    fReturn = (mmioDescend(hmmioSource, &ckRIFF, NULL, 0) == 0) &&
		(ckRIFF.ckid == FOURCC_RIFF) &&
		(ckRIFF.fccType == formtypeAVI);

    if (hmmioSource)
        mmioClose(hmmioSource, 0);

    return fReturn;
}

/*----------------------------------------------------------------------+
| fileSaveCopy() - save a copy of the current capture file.     |
|                                   |
+----------------------------------------------------------------------*/
BOOL FAR PASCAL fileSaveCopy(LPCAPSTREAM lpcs)
{
#define INITFILE_BUFF_SIZE  (1024L * 256L)
    BOOL        fReturn = TRUE;
    char        achCaption[80]; // caption on Open File dialog
    
    HMMIO       hmmioSource = NULL, hmmioDest = NULL;
    LONG        lFileSize, lFileSizeTotal, lTemp;
    HANDLE      hMem = NULL;
    LPSTR       lpstr = NULL;
    LONG        lBuffSize = INITFILE_BUFF_SIZE;
    MMCKINFO    ckRIFF;
    HCURSOR     hOldCursor;

    
    /* grab a big buffer to xfer the file in, start the */
    /* buffer size at 32K and hope we get that much.    */
TRYAGAIN:    
    hMem = GlobalAlloc(GMEM_MOVEABLE, lBuffSize);
    if (!hMem){
        /* we don't have this much mem, go for half that */
        lBuffSize /= 2;
        if (lBuffSize)
            goto TRYAGAIN;
        else {
            fReturn = FALSE;
            goto SAVECOPYOUT;
        }
    }

    /* let's go and create the destination file */
    hmmioDest = mmioOpen(lpcs->achSaveAsFile, NULL, MMIO_CREATE|MMIO_WRITE);
    if (!hmmioDest){
        /* we've got an error of some kind here, let's bail out */
        /* on this one.                     */
        errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPSTR)lpcs->achSaveAsFile);
        fReturn = FALSE;
        goto SAVECOPYOUT;
    }
    
    /* open up the source file and find the size */
    hmmioSource = mmioOpen(lpcs->achFile, NULL, MMIO_READ);
    if (!hmmioSource){
        /* we are totally hosed here, the source file can't even */
        /* be opened up, error out.              */
        errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPSTR)lpcs->achFile);
        fReturn = FALSE;
        goto SAVECOPYOUT;
    }
    
    /* go down to the RIFF chunk and find out the size of this  */
    /* thing.  If there is no RIFF chunk then we can safely */
    /* assume that the file is of 0 length.         */
    ckRIFF.fccType = formtypeAVI;
    if (mmioDescend(hmmioSource, &ckRIFF, NULL, MMIO_FINDRIFF) != 0){
        /* we are done, this file has no RIFF chunk so it's size */
        /* is 0 bytes.  Just close up and leave.         */
        goto SAVECOPYOUT;
    } else {
        /* there is a RIFF chunk, get the size of the file and  */
        /* get back to the start of the file.           */
        lFileSizeTotal = lFileSize = ckRIFF.cksize + 8;
        mmioAscend(hmmioSource, &ckRIFF, 0);
        mmioSeek(hmmioSource, 0L, SEEK_SET);
    }
    
    /* Before trying to write, seek to the end of the destination  */
    /* file and write one byte.  This both preallocates the file,  */
    /* and confirms enough disk is available for the copy, without */
    /* going through the trial and error of writing each byte.     */

    mmioSeek( hmmioDest, lFileSizeTotal - 1, SEEK_SET );
    mmioWrite( hmmioDest, (HPSTR) achCaption, 1L );
    if (mmioSeek (hmmioDest, 0, SEEK_END) < lFileSizeTotal) {

        /* Notify user with message that disk may be full. */
        errorUpdateError (lpcs, IDS_CAP_WRITEERROR, (LPSTR)lpcs->achSaveAsFile);
    
        /* close the file and delete it */
        mmioClose(hmmioDest, 0);
        mmioOpen(lpcs->achSaveAsFile, NULL, MMIO_DELETE);
        hmmioDest = NULL;
        fReturn = FALSE;
        goto SAVECOPYOUT;
    }
    
    mmioSeek (hmmioDest, 0L, SEEK_SET); // Back to the beginning

    UpdateWindow(lpcs->hwnd);             // Make everything pretty 

    hOldCursor = SetCursor( lpcs->hWaitCursor );

    /* lock our buffer and start xfering data */
    lpstr = GlobalLock(hMem);

    while (lFileSize > 0) {

        if (lFileSize < lBuffSize)
            lBuffSize = lFileSize;
        mmioRead(hmmioSource, (HPSTR)lpstr, lBuffSize);
        if (mmioWrite(hmmioDest, (HPSTR)lpstr, lBuffSize) <= 0) {
            /* we got a write error on the file, error on it */
            errorUpdateError (lpcs, IDS_CAP_WRITEERROR, (LPSTR)lpcs->achSaveAsFile);
        
            /* close the file and delete it */
            mmioClose(hmmioDest, 0);
            mmioOpen(lpcs->achSaveAsFile, NULL, MMIO_DELETE);
            hmmioDest = NULL;
            fReturn = FALSE;
            goto SAVECOPYOUT0;
        }

        // Let the user hit escape to get out
        if (GetAsyncKeyState(VK_ESCAPE) & 0x0001) {
            /* close the file and delete it */
            mmioClose(hmmioDest, 0);
            mmioOpen(lpcs->achSaveAsFile, NULL, MMIO_DELETE);
            hmmioDest = NULL;
            goto SAVECOPYOUT0;
        }

        lFileSize -= lBuffSize;

        // lTemp is percentage complete
        lTemp = muldiv32 (lFileSizeTotal - lFileSize, 100L, lFileSizeTotal);
        statusUpdateStatus (lpcs, IDS_CAP_SAVEASPERCENT, lTemp);

        Yield();
    } // endwhile more bytes to copy
SAVECOPYOUT0:
    SetCursor( hOldCursor );
    

SAVECOPYOUT:
    /* close files, free up mem, restore cursor and get out */
    if (hmmioSource) mmioClose(hmmioSource, 0);
    if (hmmioDest){
        mmioSeek(hmmioDest, 0L, SEEK_END);
        mmioClose(hmmioDest, 0);    
    }
    if (hMem) {
        GlobalUnlock(hMem);
        GlobalFree(hMem);
    }
    statusUpdateStatus (lpcs, NULL);    
    return fReturn;
}


/*--------------------------------------------------------------+
| fileAllocCapFile - allocate the capture file			|
|								|
+--------------------------------------------------------------*/
BOOL FAR PASCAL fileAllocCapFile(LPCAPSTREAM lpcs, DWORD dwNewSize)
{
    BOOL        fOK = FALSE;
    HMMIO       hmmio;
    WORD	w;
    HCURSOR     hOldCursor;

    lpcs->fCapFileExists = FALSE;
    hmmio = mmioOpen(lpcs->achFile, NULL, MMIO_WRITE);
    if( !hmmio ) {
	/* try and create */    
        hmmio = mmioOpen(lpcs-> achFile, NULL,
		MMIO_CREATE | MMIO_WRITE);
	if( !hmmio ) {
	    /* find out if the file was read only or we are just */
	    /* totally hosed up here.				 */
	    hmmio = mmioOpen(lpcs-> achFile, NULL, MMIO_READ);
	    if (hmmio){
		/* file was read only, error on it */
                errorUpdateError (lpcs, IDS_CAP_READONLYFILE, (LPSTR)lpcs-> achFile);
		mmioClose(hmmio, 0);
		return FALSE;
	    } else {
		/* even weirder error has occured here, give CANTOPEN */
                errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPSTR) lpcs-> achFile);
		return FALSE;
	    }
	}
    }

    /* find the size */
    lpcs-> lCapFileSize = mmioSeek(hmmio, 0L, SEEK_END);

    if( dwNewSize == 0 )
        dwNewSize = 1;
	    	    
    lpcs-> lCapFileSize = dwNewSize;
    hOldCursor = SetCursor( lpcs-> hWaitCursor );

    // Delete the existing file so we can recreate to the correct size
    mmioClose(hmmio, 0);	// close the file before deleting 
    mmioOpen(lpcs-> achFile, NULL, MMIO_DELETE);

    /* now create a new file with that name */
    hmmio = mmioOpen(lpcs-> achFile, NULL, MMIO_CREATE | MMIO_WRITE);
    if( !hmmio ) {
        return FALSE;
    }
   
    /* Seek to end of new file */
    fOK = (mmioSeek( hmmio, dwNewSize - 1, SEEK_SET ) == (LONG) dwNewSize - 1);

    // write any garbage byte at the end of the file
    fOK &= (mmioWrite( hmmio, (HPSTR) &w, 1L ) == 1); 
    mmioClose( hmmio, 0 );

    SetCursor( hOldCursor );

    if (!fOK)
        errorUpdateError (lpcs, IDS_CAP_NODISKSPACE);

    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\capinit.c ===
/****************************************************************************
 *
 *   capinit.c
 *
 *   Initialization code.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <ver.h>
#include <mmsystem.h>

//
// define these before any msvideo.h, so our functions get declared right.
//
#ifndef WIN32
#define VFWAPI  FAR PASCAL _loadds
#define VFWAPIV FAR CDECL  _loadds
#endif

#include "msvideo.h"
#include <drawdib.h>
#include "avicap.h"
#include "avicapi.h"

// for correct handling of capGetDriverDescription on NT and Chicago
// this is used by the NT version of avicap.dll (16bit) but not intended for
// public use, hence not in msvideo.h
DWORD WINAPI videoCapDriverDescAndVer (
        DWORD wDriverIndex,
        LPSTR lpszName, UINT cbName,
        LPSTR lpszVer, UINT cbVer);

HINSTANCE ghInst;
BOOL gfIsRTL;
char szCaptureWindowClass[] = "ClsCapWin";

typedef struct tagVS_VERSION
{
    WORD wTotLen;
    WORD wValLen;
    char szSig[16];
    VS_FIXEDFILEINFO vffInfo;
} VS_VERSION;

typedef struct tagLANGANDCP
{
    WORD wLanguage;
    WORD wCodePage;
} LANGANDCP;


BOOL FAR PASCAL RegisterCaptureClass (HINSTANCE hInst)
{
    WNDCLASS cls;

    // If we're already registered, we're OK
    if (GetClassInfo(hInst, szCaptureWindowClass, &cls))
	return TRUE;

    cls.hCursor           = LoadCursor(NULL, IDC_ARROW);
    cls.hIcon             = NULL;
    cls.lpszMenuName      = NULL;
    cls.lpszClassName     = szCaptureWindowClass;
    cls.hbrBackground     = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    cls.hInstance         = hInst;
    cls.style             = CS_HREDRAW|CS_VREDRAW | CS_BYTEALIGNCLIENT |
                            CS_GLOBALCLASS;
    cls.lpfnWndProc       = CapWndProc;
    cls.cbClsExtra        = 0;
    // Kludge, VB Status and Error GlobalAlloc'd ptrs + room to grow...
    cls.cbWndExtra        = sizeof (LPCAPSTREAM) + sizeof (DWORD) * 4;

    RegisterClass(&cls);

    return TRUE;
}

//
// Internal version
// Get the name and version of the video device
//
BOOL capInternalGetDriverDesc (WORD wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer)
{
   return (BOOL) videoCapDriverDescAndVer(
                     wDriverIndex,
                  lpszName, cbName,
                  lpszVer, cbVer);

}

//
// Exported version
// Get the name and version of the video device
//
BOOL VFWAPI capGetDriverDescription (WORD wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer)
{
    return (capInternalGetDriverDesc (wDriverIndex,
        lpszName, cbName,
        lpszVer, cbVer));
}

//
// Disconnect from hardware resources
//
BOOL CapWinDisconnectHardware(LPCAPSTREAM lpcs)
{
    if( lpcs->hVideoCapture ) {
        videoStreamFini (lpcs->hVideoCapture);
        videoClose( lpcs->hVideoCapture );
    }
    if( lpcs->hVideoDisplay ) {
        videoStreamFini (lpcs->hVideoDisplay);
        videoClose( lpcs->hVideoDisplay );
    }
    if( lpcs->hVideoIn ) {
        videoClose( lpcs->hVideoIn );
    }

    lpcs->fHardwareConnected = FALSE;

    lpcs->hVideoCapture = NULL;
    lpcs->hVideoDisplay = NULL;
    lpcs->hVideoIn = NULL;

    lpcs->sCapDrvCaps.fHasDlgVideoSource = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoFormat = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoDisplay = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoDisplay = FALSE;

    lpcs->sCapDrvCaps.hVideoIn          = NULL;
    lpcs->sCapDrvCaps.hVideoOut         = NULL;
    lpcs->sCapDrvCaps.hVideoExtIn       = NULL;
    lpcs->sCapDrvCaps.hVideoExtOut      = NULL;

    return TRUE;
}

//
// Connect to hardware resources
// Return: TRUE if hardware connected to the stream
//
BOOL CapWinConnectHardware (LPCAPSTREAM lpcs, WORD wDeviceIndex)
{
    DWORD dwError;
    CHANNEL_CAPS VideoCapsExternalOut;
    char ach1[_MAX_CAP_PATH];
    char ach2[_MAX_CAP_PATH * 3];
    CAPINFOCHUNK cic;
    HINSTANCE hInstT;

    lpcs->hVideoCapture = NULL;
    lpcs->hVideoDisplay = NULL;
    lpcs->hVideoIn = NULL;
    lpcs->fHardwareConnected = FALSE;
    lpcs->fUsingDefaultPalette = TRUE;
    lpcs->sCapDrvCaps.fHasDlgVideoSource = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoFormat = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoDisplay = FALSE;
    lpcs->sCapDrvCaps.wDeviceIndex = wDeviceIndex;

    // Clear any existing capture device name chunk
    cic.fccInfoID = mmioFOURCC ('I','S','F','T');
    cic.lpData = NULL;
    cic.cbData = 0;
    SetInfoChunk (lpcs, &cic);

    // try and open the video hardware!!!
    if( !(dwError = videoOpen( &lpcs->hVideoIn, wDeviceIndex, VIDEO_IN ) ) ) {
        if( !(dwError = videoOpen( &lpcs->hVideoCapture, wDeviceIndex, VIDEO_EXTERNALIN ) ) ) {
            // We don't require the EXTERNALOUT channel,
            // but do require EXTERNALIN and IN
            videoOpen( &lpcs->hVideoDisplay, wDeviceIndex, VIDEO_EXTERNALOUT );
            if( (!dwError) && lpcs->hVideoCapture && lpcs->hVideoIn ) {

                lpcs->fHardwareConnected = TRUE;
                capInternalGetDriverDesc (wDeviceIndex,
                        ach1, sizeof (ach1),
                        ach2, sizeof (ach2));
                lstrcat (ach1, ", ");
                lstrcat (ach1, ach2);

                statusUpdateStatus (lpcs, IDS_CAP_INFO, (LPSTR) ach1);

                // Make a string of the current task and capture driver
                ach2[0] = '\0';
                if (hInstT = GetWindowWord (GetParent (lpcs->hwnd), GWW_HINSTANCE))
                    GetModuleFileName (hInstT, ach2, sizeof (ach2));
                lstrcat (ach2, " -AVICAP- ");
                lstrcat (ach2, ach1);

                // Set software chunk with name of capture device
                if (*ach2) {
                    cic.lpData = ach2;
                    cic.cbData = lstrlen(ach2) + 1;
                    SetInfoChunk (lpcs, &cic);
                }
            }
        }
    }
    if (dwError)
        errorDriverID (lpcs, dwError);

    if(!lpcs->fHardwareConnected) {
       CapWinDisconnectHardware(lpcs);
    }
    else {
        if (lpcs->hVideoDisplay && videoGetChannelCaps (lpcs->hVideoDisplay,
                &VideoCapsExternalOut,
                sizeof (CHANNEL_CAPS)) == DV_ERR_OK) {
            lpcs->sCapDrvCaps.fHasOverlay = (BOOL)(VideoCapsExternalOut.dwFlags &
                (DWORD)VCAPS_OVERLAY);
        }
        else
             lpcs->sCapDrvCaps.fHasOverlay = FALSE;
        // if the hardware doesn't support it, make sure we don't enable
        if (!lpcs->sCapDrvCaps.fHasOverlay)
            lpcs->fOverlayWindow = FALSE;

       // Start the external in channel streaming continuously
       videoStreamInit (lpcs->hVideoCapture, 0L, 0L, 0L, 0L);
    } // end if hardware is available

#if 0
    // if we don't have a powerful machine, disable capture
    if (GetWinFlags() & (DWORD) WF_CPU286)
       CapWinDisconnectHardware(lpcs);
#endif

    if (!lpcs->fHardwareConnected){
        lpcs->fLiveWindow = FALSE;
        lpcs->fOverlayWindow = FALSE;
    }

    if (lpcs->hVideoIn)
        lpcs->sCapDrvCaps.fHasDlgVideoFormat = !videoDialog (lpcs-> hVideoIn,
                        lpcs-> hwnd, VIDEO_DLG_QUERY);

    if (lpcs->hVideoCapture)
         lpcs->sCapDrvCaps.fHasDlgVideoSource = !videoDialog (lpcs-> hVideoCapture,
                        lpcs-> hwnd, VIDEO_DLG_QUERY);

    if (lpcs->hVideoDisplay)
         lpcs->sCapDrvCaps.fHasDlgVideoDisplay = !videoDialog (lpcs-> hVideoDisplay,
                        lpcs-> hwnd, VIDEO_DLG_QUERY);

    lpcs->sCapDrvCaps.hVideoIn          = lpcs->hVideoIn;
    lpcs->sCapDrvCaps.hVideoOut         = NULL;
    lpcs->sCapDrvCaps.hVideoExtIn       = lpcs->hVideoCapture;
    lpcs->sCapDrvCaps.hVideoExtOut      = lpcs->hVideoDisplay;

    return lpcs->fHardwareConnected;
}



//
// Creates a child window of the capture class
// Normally:
//   Set lpszWindowName to NULL
//   Set dwStyle to WS_CHILD | WS_VISIBLE
//   Set hmenu to a unique child id

HWND VFWAPI capCreateCaptureWindow (
        LPCSTR lpszWindowName,
        DWORD dwStyle,
        int x, int y, int nWidth, int nHeight,
        HWND hwndParent, int nID)
{
    DWORD   fdwFlags;

#ifndef WS_EX_LEFTSCROLLBAR
#define WS_EX_LEFTSCROLLBAR 0
#define WS_EX_RIGHT         0
#define WS_EX_RTLREADING    0
#endif

    RegisterCaptureClass(ghInst);
    fdwFlags = gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0;
    return CreateWindowEx(fdwFlags,
	        szCaptureWindowClass,
                lpszWindowName,
                dwStyle,
                x, y, nWidth, nHeight,
                hwndParent, (HMENU) nID,
	        ghInst,
                NULL);
}


int CALLBACK LibMain(HINSTANCE hinst, WORD wDataSeg, WORD cbHeap,
    LPSTR lpszCmdLine )
{
    char   ach[2];

    ghInst = hinst;
    LoadString(ghInst, IDS_CAP_RTL, ach, sizeof(ach));
    gfIsRTL = ach[0] == '1';
    return TRUE;
}

int FAR PASCAL WEP(int i)
{
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\capmisc.h ===
/****************************************************************************
 *
 *   capmisc.h
 * 
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

void statusUpdateFromID (LPCAPSTREAM lpcs, DWORD dwError);
void statusUpdateStatus (LPCAPSTREAM lpcs, LPSTR lpc);
void ErrMsgID (LPCAPSTREAM lpcs, DWORD dwID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\capmisc.c ===
/****************************************************************************
 *
 *   capmisc.c
 * 
 *   Miscellaneous status and error routines.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <drawdib.h>
#include "avicap.h"
#include "avicapi.h"

static char szNull[] = "";

/*
 *
 *   GetKey
 *           Peek into the message que and get a keystroke
 *
 */
WORD GetKey(BOOL fWait)
{
    MSG msg;

    msg.wParam = 0;

    if (fWait)
         GetMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST);

    while(PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE|PM_NOYIELD))
         ;
    return msg.wParam;
}


// wID is the string resource, which can be a format string
void FAR _cdecl statusUpdateStatus (LPCAPSTREAM lpcs, WORD wID, ...)
{
    char ach[256];
    char szFmt[132];
    int j, k;
    BOOL fHasFormatChars = FALSE;
    
    if (lpcs-> CallbackOnStatus) {
        if (wID == NULL) {
            if (lpcs->fLastStatusWasNULL)   // No need to send NULL twice in a row
                return;
            lpcs->fLastStatusWasNULL = TRUE;
            lstrcpy (ach, szNull);
        }
        else if (!LoadString(lpcs->hInst, wID, szFmt, sizeof (szFmt))) {
            lpcs->fLastStatusWasNULL = FALSE;
            MessageBeep (0);
            return;
        }
        else {
            lpcs->fLastStatusWasNULL = FALSE;
            k = lstrlen (szFmt);
            for (j = 0; j < k; j++) {
                if (szFmt[j] == '%') {
                   fHasFormatChars = TRUE;
                   break;
                }
            }
            if (fHasFormatChars)
                wvsprintf(ach, szFmt, (LPSTR)(((WORD FAR *)&wID) + 1));
            else
                lstrcpy (ach, szFmt);
        }

        (*(lpcs->CallbackOnStatus)) (lpcs->hwnd, wID, ach);
    }
}

// wID is the string resource, which can be a format string
void FAR _cdecl errorUpdateError (LPCAPSTREAM lpcs, WORD wID, ...)
{
    char ach[256];
    char szFmt[132];
    int j, k;
    BOOL fHasFormatChars = FALSE;
    
    lpcs->dwReturn = wID;

    if (lpcs-> CallbackOnError) {
        if (wID == NULL) {
            if (lpcs->fLastErrorWasNULL)   // No need to send NULL twice in a row
                return;
            lpcs->fLastErrorWasNULL = TRUE;
            lstrcpy (ach, szNull);
        }
        else if (!LoadString(lpcs->hInst, wID, szFmt, sizeof (szFmt))) {
            MessageBeep (0);
            lpcs->fLastErrorWasNULL = FALSE;
            return;
        }
        else {
            lpcs->fLastErrorWasNULL = FALSE;
            k = lstrlen (szFmt);
            for (j = 0; j < k; j++) {
                if (szFmt[j] == '%') {
                   fHasFormatChars = TRUE;
                   break;
                }
            }
            if (fHasFormatChars)
                wvsprintf(ach, szFmt, (LPSTR)(((WORD FAR *)&wID) + 1));
            else
                lstrcpy (ach, szFmt);
        }

        (*(lpcs->CallbackOnError)) (lpcs->hwnd, wID, ach);
    }
}

// Callback client with ID of driver error msg
void errorDriverID (LPCAPSTREAM lpcs, DWORD dwError)
{
    char ach[132];
    
    lpcs->fLastErrorWasNULL = FALSE;
    lpcs->dwReturn = dwError;

    if (lpcs-> CallbackOnError) {
        if (!dwError)
            lstrcpy (ach, szNull);
        else {
            videoGetErrorText (lpcs->hVideoIn,
                        (UINT)dwError, ach, sizeof(ach));
        }
        (*(lpcs->CallbackOnError)) (lpcs->hwnd, IDS_CAP_DRIVER_ERROR, ach);
    }
}


#ifdef  _DEBUG

void FAR cdecl dprintf(LPSTR szFormat, ...)
{
    char ach[128];

    static BOOL fDebug = -1;

    if (fDebug == -1)
        fDebug = GetProfileInt("Debug", "AVICAP", FALSE);

    if (!fDebug)
        return;

    lstrcpy(ach, "AVICAP: ");
    wvsprintf(ach+8,szFormat,(LPSTR)(&szFormat+1));
    lstrcat(ach, "\r\n");

    OutputDebugString(ach);
}

/* _Assert(fExpr, szFile, iLine)
 *
 * If <fExpr> is TRUE, then do nothing.  If <fExpr> is FALSE, then display
 * an "assertion failed" message box allowing the user to abort the program,
 * enter the debugger (the "Retry" button), or igore the error.
 *
 * <szFile> is the name of the source file; <iLine> is the line number
 * containing the _Assert() call.
 */
#pragma optimize("", off)
BOOL FAR PASCAL
_Assert(BOOL fExpr, LPSTR szFile, int iLine)
{
         static char       ach[300];         // debug output (avoid stack overflow)
         int               id;
         int               iExitCode;
         void FAR PASCAL DebugBreak(void);

         /* check if assertion failed */
         if (fExpr)
                  return fExpr;

         /* display error message */
         wsprintf(ach, "File %s, line %d", (LPSTR) szFile, iLine);
         MessageBeep(MB_ICONHAND);
	 id = MessageBox(NULL, ach, "Assertion Failed", MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE);

         /* abort, debug, or ignore */
         switch (id)
         {

         case IDABORT:

                  /* kill this application */
                  iExitCode = 0;
#ifndef WIN32
                  _asm
                  {
                           mov      ah, 4Ch
                           mov      al, BYTE PTR iExitCode
                           int     21h
                  }
#endif // WIN16
                  break;

         case IDRETRY:

                  /* break into the debugger */
                  DebugBreak();
                  break;

         case IDIGNORE:

                  /* ignore the assertion failure */
                  break;

         }
         
         return FALSE;
}
#pragma optimize("", on)

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\cappal.h ===
/****************************************************************************
 *
 *   cappal.h
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

// Structure used when capturing a palette
typedef struct tagCAPPAL {
    WORD                wNumFrames;
    WORD                wNumColors;
    LPBYTE              lpBits;
    LPBYTE              lp16to8;
    VIDEOHDR            vHdr;
    BITMAPINFOHEADER    bi16;
    LPHISTOGRAM         lpHistogram;
    LPBITMAPINFO        lpbiSave;
} CAPPAL, FAR * LPCAPPAL;

BOOL PalInit (LPCAPSTREAM lpcs);
void PalFini (LPCAPSTREAM lpcs);
void PalDeleteCurrentPalette (LPCAPSTREAM lpcs);
BOOL PalGetPaletteFromDriver (LPCAPSTREAM lpcs);
DWORD PalSendPaletteToDriver (LPCAPSTREAM lpcs, HPALETTE hpal, LPBYTE lpXlateTable);
HPALETTE CopyPalette (HPALETTE hpal);
DWORD CapturePaletteInit (LPCAPSTREAM lpcs, LPCAPPAL lpcp);
DWORD CapturePaletteFini (LPCAPSTREAM lpcs, LPCAPPAL lpcp);
DWORD CapturePaletteFrames (LPCAPSTREAM lpcs, LPCAPPAL lpCapPal, int nCount);
BOOL CapturePaletteAuto (LPCAPSTREAM lpcs, int nCount, int nColors);
BOOL CapturePaletteManual (LPCAPSTREAM lpcs, BOOL fGrab, int nColors);
void CapturePaletteDialog (LPCAPSTREAM lpcs);
LONG FAR PASCAL _export cappalDlgProc(HWND hwnd, unsigned msg, WORD wParam, LONG lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\cappal.c ===
/****************************************************************************
 *
 *   cappal.c
 * 
 *   Palette processing module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <drawdib.h>
#include "avicap.h"
#include "avicapi.h"
#include "cappal.h"
#include "capdib.h"
#include "dibmap.h"

// 
// Allocate and initialize palette resources at Window create time
//
BOOL PalInit (LPCAPSTREAM lpcs)
{
    return (PalGetPaletteFromDriver (lpcs));
}

//
// Release palette resources at Window destroy time
// 
void PalFini (LPCAPSTREAM lpcs)
{
    PalDeleteCurrentPalette (lpcs);
}

//
// Delete our palette if it isn't the system default palette
//
void PalDeleteCurrentPalette (LPCAPSTREAM lpcs)
{
    if (lpcs->hPalCurrent &&
            (lpcs->hPalCurrent != GetStockObject(DEFAULT_PALETTE)))
        DeleteObject (lpcs->hPalCurrent);
    lpcs->hPalCurrent = NULL;
}

//
// Get the current palette (from the driver)
// Returns: TRUE if the driver can supply a palette
//

BOOL PalGetPaletteFromDriver (LPCAPSTREAM lpcs)
{
    FCLOGPALETTE        pal;

    PalDeleteCurrentPalette (lpcs); 
    
    pal.palVersion = 0x0300;
    pal.palNumEntries = 256;

    lpcs->sCapDrvCaps.fDriverSuppliesPalettes = FALSE;  // assume the worst

    if (lpcs->fHardwareConnected) {
        if (videoConfigure (lpcs->hVideoIn,
                DVM_PALETTE,
                VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT, NULL, 
                (LPVOID)&pal, sizeof(pal),
                NULL, NULL ) == DV_ERR_OK) {
            if (lpcs->hPalCurrent = CreatePalette ((LPLOGPALETTE) &pal))
                lpcs->sCapDrvCaps.fDriverSuppliesPalettes = TRUE;
        }
    }
    if (!lpcs->hPalCurrent)
        lpcs->hPalCurrent = GetStockObject (DEFAULT_PALETTE);

    DibNewPalette (lpcs, lpcs->hPalCurrent);
    
    return (lpcs->sCapDrvCaps.fDriverSuppliesPalettes);
}

// 
// Set the current palette used for capture by sending a copy to the driver
// and then copying the entries to out DIB.
// Returns DV_ERR_OK on success, or DV_ERR... on failure.
//
DWORD PalSendPaletteToDriver (LPCAPSTREAM lpcs, HPALETTE hpal, LPBYTE lpXlateTable)
{
    int                 nColors;
    FCLOGPALETTE        pal;
    HCURSOR             hOldCursor;

    // The following can take a while so repaint our parent
    UpdateWindow (GetParent (lpcs-> hwnd));
    UpdateWindow (lpcs->hwnd);

    if (!hpal)
        return FALSE;

    PalDeleteCurrentPalette (lpcs);

    lpcs->hPalCurrent = hpal;

    GetObject(hpal, sizeof(int), (LPVOID)&nColors);

    if( nColors <= 1 ) {    //!!>
        return( FALSE );
    }

    if (nColors > 256)      //???
        ;

    nColors = min(256, nColors);
    
    hOldCursor = SetCursor (lpcs-> hWaitCursor);

    statusUpdateStatus (lpcs, IDS_CAP_STAT_PALETTE_BUILD);

    pal.palVersion = 0x0300;
    pal.palNumEntries = nColors;

    GetPaletteEntries(hpal, 0, nColors, pal.palPalEntry);

    if (lpcs-> fHardwareConnected) {

        // first try to send both the xlate table and the palette
        if ((!lpXlateTable) || (videoConfigure( lpcs->hVideoIn,
                    DVM_PALETTERGB555,
                    VIDEO_CONFIGURE_SET, NULL, 
                    (LPLOGPALETTE)&pal, sizeof(pal),
                    lpXlateTable, (DWORD) 0x8000) != 0)) {
            
            // else send just the palette and make the driver build the table
            videoConfigure( lpcs->hVideoIn,
                    DVM_PALETTE,
                    VIDEO_CONFIGURE_SET, NULL, 
                    (LPLOGPALETTE)&pal, sizeof(pal),
                    NULL, NULL );
        }
    }
    
    // Supermac wants us to get the palette again, they might have
    // mucked with it!
    PalGetPaletteFromDriver (lpcs);     

    // Since the palette has changed, delete any existing compression
    // output format;  this forces a new output format to be selected
    if (lpcs->CompVars.lpbiOut) {
        GlobalFreePtr (lpcs->CompVars.lpbiOut);
        lpcs->CompVars.lpbiOut = NULL;
    }
    if (lpcs->CompVars.hic) {
        if (ICSeqCompressFrameStart(&lpcs->CompVars, lpcs->lpBitsInfo) == NULL) {
            lpcs-> dwReturn = IDS_CAP_COMPRESSOR_ERROR;
            errorUpdateError (lpcs, IDS_CAP_COMPRESSOR_ERROR);
        }
    }

    InvalidateRect (lpcs->hwnd, NULL, TRUE);
    UpdateWindow (lpcs->hwnd);

    SetCursor (hOldCursor);
    statusUpdateStatus (lpcs, NULL);
    
    return (TRUE);
}

//
// CopyPalette, makes a copy of a GDI logical palette
// Returns: a handle to the newly created palette, or NULL if error
//

HPALETTE CopyPalette (HPALETTE hpal)
{
    LPLOGPALETTE        lppal;
    int                 nNumEntries;

    if (!hpal)
        return NULL;

    GetObject (hpal,sizeof(int),(LPVOID)&nNumEntries);

    if (nNumEntries == 0)
        return NULL;

    lppal = (LPLOGPALETTE) GlobalAllocPtr (GHND,
                sizeof(LOGPALETTE) + nNumEntries * sizeof(PALETTEENTRY));

    if (!lppal)
        return NULL;

    lppal->palVersion    = 0x300;
    lppal->palNumEntries = nNumEntries;

    GetPaletteEntries(hpal,0,nNumEntries,lppal->palPalEntry);

    hpal = CreatePalette(lppal);

    GlobalFreePtr (lppal);

    return hpal;
}


//
// Allocate resources needed for palette capture
// Returns DV_ERR_OK on success, or DV_ERR... on failure.
// Note: if Init fails, you MUST call the Fini function to
// release resources.
//
DWORD CapturePaletteInit (LPCAPSTREAM lpcs, LPCAPPAL lpcp)
{
    DWORD dwError = DV_ERR_OK;
 
    lpcp->lpBits = NULL;
    lpcp->lp16to8 = NULL;
    lpcp->lpHistogram = NULL;
    lpcp->lpbiSave = NULL;
    lpcp->wNumFrames = 0;

    // Init an RGB16 header
    lpcp->bi16.biSize         = sizeof(BITMAPINFOHEADER);
    lpcp->bi16.biWidth        = lpcs->dxBits;
    lpcp->bi16.biHeight       = lpcs->dyBits;
    lpcp->bi16.biPlanes       = 1;
    lpcp->bi16.biBitCount     = 16;
    lpcp->bi16.biCompression  = BI_RGB;
    lpcp->bi16.biSizeImage    = DIBWIDTHBYTES(lpcp->bi16) * lpcp->bi16.biHeight;
    lpcp->bi16.biXPelsPerMeter= 0;
    lpcp->bi16.biYPelsPerMeter= 0;
    lpcp->bi16.biClrUsed      = 0;
    lpcp->bi16.biClrImportant = 0;

    // Allocate memory for the histogram, DIB, and XLate table
    lpcp->lpBits  = GlobalAllocPtr (GHND, lpcp->bi16.biSizeImage);
    lpcp->lp16to8 = GlobalAllocPtr (GHND, 0x8000l);
    lpcp->lpHistogram = InitHistogram(NULL);

    if (!lpcp->lpBits || !lpcp->lp16to8 || !lpcp->lpHistogram) {
        dwError = DV_ERR_NOMEM;
        goto PalInitError;
    }

    // Init the video header
    lpcp->vHdr.lpData = lpcp->lpBits;
    lpcp->vHdr.dwBufferLength = lpcp->bi16.biSizeImage;
    lpcp->vHdr.dwUser = 0;
    lpcp->vHdr.dwFlags = 0;

    // Save the current format
    lpcp->lpbiSave = DibGetCurrentFormat (lpcs);
        
    // Make sure we can set the format to 16 bit RGB
    if(dwError = videoConfigure( lpcs->hVideoIn, DVM_FORMAT,
            VIDEO_CONFIGURE_SET, NULL, 
            (LPBITMAPINFOHEADER)&lpcp->bi16, sizeof(BITMAPINFOHEADER),
            NULL, NULL ) ) {
        goto PalInitError;
    }
    
    // Put everything back the way it was
    if (dwError = videoConfigure( lpcs->hVideoIn, DVM_FORMAT,
            VIDEO_CONFIGURE_SET, NULL, 
            (LPBITMAPINFOHEADER)lpcp->lpbiSave, lpcp->lpbiSave->bmiHeader.biSize,
            NULL, NULL )) {
        goto PalInitError;
    }

PalInitError:
    return dwError;
}

//
// Free resources used for palette capture
//
DWORD CapturePaletteFini (LPCAPSTREAM lpcs, LPCAPPAL lpcp)
{
    if (lpcp->lpBits)
        GlobalFreePtr (lpcp->lpBits);
    if (lpcp->lp16to8)
        GlobalFreePtr (lpcp->lp16to8);
    if (lpcp->lpHistogram)
        FreeHistogram(lpcp->lpHistogram);
    if (lpcp->lpbiSave)
        GlobalFreePtr (lpcp->lpbiSave);
    return DV_ERR_OK;
}

//
//  CapturePaletteFrames() The workhorse of capture palette.
//
DWORD CapturePaletteFrames (LPCAPSTREAM lpcs, LPCAPPAL lpcp, int nCount)
{
    int j;
    DWORD dwError;

    // switch to RGB16 format
    if (dwError = videoConfigure( lpcs->hVideoIn,
                DVM_FORMAT,
                VIDEO_CONFIGURE_SET, NULL, 
                (LPBITMAPINFOHEADER)&lpcp->bi16, sizeof(BITMAPINFOHEADER),
                NULL, NULL ))
        goto CaptureFramesError;

    for (j = 0; j < nCount; j++){
        // Get a frame
        dwError = videoFrame(lpcs->hVideoIn, &lpcp->vHdr);

        // Let the user see it
        InvalidateRect (lpcs->hwnd, NULL, TRUE);
        UpdateWindow (lpcs->hwnd);

        // Histogram it
        DibHistogram(&lpcp->bi16, lpcp->lpBits, 0, 0, -1, -1, lpcp->lpHistogram);
        lpcp->wNumFrames++;
    }

    dwError = videoConfigure( lpcs->hVideoIn,
                DVM_FORMAT,
                VIDEO_CONFIGURE_SET, NULL, 
                (LPBITMAPINFOHEADER)lpcp->lpbiSave,
                lpcp->lpbiSave->bmiHeader.biSize,
                NULL, NULL );

//    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );

CaptureFramesError:
    return dwError;
}

//
//  CapturePaletteAuto() capture a palette from the video source
//  without user intervention.
//  Returns TRUE on success, FALSE on error
//
BOOL CapturePaletteAuto (LPCAPSTREAM lpcs, int nCount, int nColors)
{
    HPALETTE    hpal;
    HCURSOR     hOldCursor;
    DWORD       dwError = DV_ERR_OK;
    CAPPAL      cappal;
    LPCAPPAL    lpcp;

    lpcp = &cappal;
    
    if (nColors == 0)
        nColors = 256;
    
    lpcp->wNumColors = min (nColors, 256);

    if (nCount <= 0)            // Bug 175
        nCount = 1;
    
    if (dwError = CapturePaletteInit (lpcs, lpcp))
        goto PalAutoExit;

    hOldCursor = SetCursor(lpcs->hWaitCursor);

    CapturePaletteFrames (lpcs, lpcp, nCount);

    /* we grabbed a frame, time to compute a palette */
    statusUpdateStatus(lpcs, IDS_CAP_STAT_OPTPAL_BUILD);

    // The HPALETTE returned in the following becomes
    // our "global" palette, hence is not deleted here.
    hpal = HistogramPalette(lpcp->lpHistogram, lpcp->lp16to8, lpcp->wNumColors);

    // Send driver both the pal and xlate table
    PalSendPaletteToDriver(lpcs, hpal, (LPBYTE)lpcp->lp16to8 );     

    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );  // Update the display with a new image
    
    SetCursor(hOldCursor);

    InvalidateRect(lpcs->hwnd, NULL, TRUE);
    UpdateWindow(lpcs->hwnd);
    lpcs->fUsingDefaultPalette = FALSE;

PalAutoExit:
    CapturePaletteFini (lpcs, lpcp);
    statusUpdateStatus(lpcs, NULL);

   // If an error happened, display it
   if (dwError) 
        errorDriverID (lpcs, dwError);

    return (dwError == DV_ERR_OK);
}

//
//  CapturePaletteManual() capture a palette from the video source
//  with user intervention.
//  fGrab is TRUE on all but the last frame captured
//  Returns TRUE on success, FALSE on error
//
BOOL CapturePaletteManual (LPCAPSTREAM lpcs, BOOL fGrab, int nColors)
{
    HPALETTE    hpal;
    HCURSOR     hOldCursor;
    LPCAPPAL    lpcp;
    DWORD       dwError = DV_ERR_OK;

    hOldCursor = SetCursor(lpcs->hWaitCursor);

    // We're initializing for the first time, so alloc everything
    if (lpcs->lpCapPal == NULL) {

        if (lpcp = (LPCAPPAL) GlobalAllocPtr (GHND, sizeof(CAPPAL))) {
            lpcs->lpCapPal = lpcp;

            if (nColors == 0)
                nColors = 256;
            lpcp->wNumColors = min (nColors, 256);
            dwError = CapturePaletteInit (lpcs, lpcp);
        }
        else 
            dwError = IDS_CAP_OUTOFMEM;
    }
    lpcp = lpcs->lpCapPal;

    if (dwError != DV_ERR_OK) 
        goto PalManualExit;

    // Add a frame to the histogram 
    // Handle the case of telling us to stop before we ever started
    if (fGrab || !fGrab && (lpcp->wNumFrames == 0)) {
        CapturePaletteFrames (lpcs, lpcp, 1);
        lpcs->fUsingDefaultPalette = FALSE;
    }    
    // All done, send the new palette to the driver
    if (!fGrab) {
        statusUpdateStatus(lpcs, IDS_CAP_STAT_OPTPAL_BUILD);

        // The HPALETTE returned in the following becomes
        // our "global" palette, hence is not deleted here.
        hpal = HistogramPalette(lpcp->lpHistogram,
                        lpcp->lp16to8, lpcp->wNumColors);

        // Send driver both the pal and xlate table
        PalSendPaletteToDriver(lpcs, hpal, (LPBYTE)lpcp->lp16to8 );
    }

    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );  // Update the display with a new image
    InvalidateRect(lpcs->hwnd, NULL, TRUE);
    UpdateWindow(lpcs->hwnd);

PalManualExit:
    if (!fGrab || (dwError != DV_ERR_OK)) {
        if (lpcp != NULL) {
            CapturePaletteFini (lpcs, lpcp);
            GlobalFreePtr (lpcp);
            lpcs->lpCapPal = NULL;
        }
    }

    SetCursor(hOldCursor);
    statusUpdateStatus(lpcs, NULL);

   // If an error happened, display it
   if (dwError) {
        errorUpdateError (lpcs, (WORD) dwError);
        lpcs-> dwReturn = dwError;
    }       

    return (dwError == DV_ERR_OK);
}



/*--------------------------------------------------------------+
| fileSavePalette - save the current palette in a file  	|
|								|
+--------------------------------------------------------------*/
BOOL FAR PASCAL fileSavePalette(LPCAPSTREAM lpcs, LPSTR lpszFileName)
{
    HPALETTE            hpal;
    HMMIO               hmmio;
    WORD	        w;
    HCURSOR             hOldCursor;
    MMCKINFO            ckRiff;
    MMCKINFO            ck;
    int                 nColors;
    FCLOGPALETTE        pal;
    BOOL                fOK = FALSE;

    if ((hpal = lpcs->hPalCurrent) == NULL)
        return FALSE;

    hmmio = mmioOpen(lpszFileName, NULL, MMIO_WRITE);
    if( !hmmio ) {
	/* try and create */    
        hmmio = mmioOpen(lpszFileName, NULL, MMIO_CREATE | MMIO_WRITE);
	if( !hmmio ) {
	    /* find out if the file was read only or we are just */
	    /* totally hosed up here.				 */
	    hmmio = mmioOpen(lpszFileName, NULL, MMIO_READ);
	    if (hmmio){
		/* file was read only, error on it */
                errorUpdateError (lpcs, IDS_CAP_READONLYFILE, (LPSTR)lpszFileName);
		mmioClose(hmmio, 0);
		return FALSE;
	    } else {
		/* even weirder error has occured here, give CANTOPEN */
                errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPSTR) lpszFileName);
		return FALSE;
	    }
	}
    }

    hOldCursor = SetCursor( lpcs-> hWaitCursor );

    /* Seek to beginning of file, so we can write the header. */
    mmioSeek(hmmio, 0, SEEK_SET);

    /* Create RIFF chunk */
    ckRiff.fccType = mmioFOURCC('P','A','L',' ');
    if(mmioCreateChunk (hmmio,&ckRiff,MMIO_CREATERIFF)) {
         goto FileError;
    }

    /* Create Palette chunk */
    ck.cksize = 0;
    ck.ckid = mmioFOURCC('d','a','t','a');
    if(mmioCreateChunk(hmmio,&ck,0)) {
         goto FileError;
    }

    // Get the palette data here
    GetObject(hpal, sizeof(int), (LPVOID)&nColors);

    pal.palVersion = 0x0300;
    pal.palNumEntries = nColors;

    GetPaletteEntries(hpal, 0, nColors, pal.palPalEntry);

    // Calc the size of the logpalette
    // which is the sizeof palVersion + sizeof palNumEntries + colors
    w = sizeof (WORD) + sizeof (WORD) + nColors * sizeof (PALETTEENTRY);

    // Write out the palette
    if(mmioWrite(hmmio, (LPSTR)&pal, (DWORD) w) != (LONG) w) {
        goto FileError;
    }

    if(mmioAscend(hmmio, &ck, 0)) {
        goto FileError;
    }

    if(mmioAscend(hmmio, &ckRiff, 0)) {
        goto FileError;
    }

    fOK = TRUE;
    
FileError:
    mmioClose( hmmio, 0 );

    SetCursor( hOldCursor );

    if (!fOK)
        errorUpdateError (lpcs, IDS_CAP_ERRORPALSAVE, (LPSTR) lpszFileName);

    return fOK;
}
    

/*--------------------------------------------------------------+
| fileOpenPalette - use a new palette from the specified file   |
|								|
+--------------------------------------------------------------*/
BOOL FAR PASCAL fileOpenPalette(LPCAPSTREAM lpcs, LPSTR lpszFileName)
{
    HPALETTE            hpal;
    HMMIO               hmmio;
    WORD	        w;
    HCURSOR             hOldCursor;
    MMCKINFO            ckRiff;
    MMCKINFO            ck;
    FCLOGPALETTE        pal;
    BOOL                fOK = FALSE;

    if ((hpal = lpcs->hPalCurrent) == NULL)
        return FALSE;

    hmmio = mmioOpen(lpszFileName, NULL, MMIO_READ);
    if( !hmmio ) {
        errorUpdateError (lpcs, IDS_CAP_ERRORPALOPEN, (LPSTR) lpszFileName);
        return FALSE;
    }

    hOldCursor = SetCursor( lpcs-> hWaitCursor );

    /* Seek to beginning of file, so we can read the header. */
    mmioSeek(hmmio, 0, SEEK_SET);

    /* Find the RIFF chunk */
    ckRiff.fccType = mmioFOURCC('P','A','L',' ');
    if(mmioDescend (hmmio, &ckRiff, NULL, MMIO_FINDRIFF)) {
         goto PalOpenError;
    }

    /* Find the data chunk */
    ck.cksize = 0;
    ck.ckid = mmioFOURCC('d','a','t','a');
    if(mmioDescend (hmmio, &ck, &ckRiff, MMIO_FINDCHUNK)) {
         goto PalOpenError;
    }

    // First read just the Version and number of entries
    // which is the sizeof palVersion + sizeof palNumEntries
    w = sizeof (WORD) + sizeof (WORD);
    if(mmioRead(hmmio, (LPSTR)&pal, (DWORD) w) != (LONG) w) {
        goto PalOpenError;
    }

    // Do a bit of checking
    if ((pal.palVersion != 0x0300) || (pal.palNumEntries > 256))
        goto PalOpenError;
        
    // Now get the actual palette data
    // which is the sizeof palVersion + sizeof palNumEntries
    w = pal.palNumEntries * sizeof (PALETTEENTRY);
    if(mmioRead(hmmio, (LPSTR)&pal.palPalEntry, (DWORD) w) != (LONG) w) {
        goto PalOpenError;
    }

    if (hpal = CreatePalette ((LPLOGPALETTE) &pal)) {
        PalSendPaletteToDriver (lpcs, hpal, NULL /*lpXlateTable */);
        fOK = TRUE;
    }    
    
    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );  // grab a new frame

PalOpenError:
    mmioClose( hmmio, 0 );

    SetCursor( hOldCursor );
    InvalidateRect(lpcs->hwnd, NULL, TRUE);
    UpdateWindow(lpcs->hwnd);		// update the display with new frame

    if (!fOK)
        errorUpdateError (lpcs, IDS_CAP_ERRORPALOPEN, (LPSTR) lpszFileName);
    else
        lpcs->fUsingDefaultPalette = FALSE;

    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\capwin.c ===
/****************************************************************************
 *
 *   capwin.c
 *
 *   Main window proceedure.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <drawdib.h>
#include <mmreg.h>
#include <memory.h>
#include "avicap.h"
#include "avicapi.h"
#include "cappal.h"
#include "capdib.h"
#include "dibmap.h"

// GetWindowLong assignments
#define GWL_CAPSTREAM   0
#define GWL_CAPVBSTATUS 4       // Used by VB Status callback
#define GWL_CAPVBERROR  8       // Used by VB Error callback
#define GWL_CAP_SPARE1  12      // Room to grow
#define GWL_CAP_SPARE2  16      // Room to grow

#define ID_PREVIEWTIMER 9

//#ifdef _DEBUG
#ifdef PLASTIQUE
    #define MB(lpsz) MessageBox(NULL, lpsz, "", MB_OK);
#else
    #define MB(lpsz)
#endif


//
// Set the overlay rectangles on capture cards which support
// overlay, and then enable/disable the key color.
//
static void SetOverlayRectangles (LPCAPSTREAM lpcs)
{
    HDC hdc;
    BOOL fVisible;
    RECT rc;

    if (!lpcs->hVideoDisplay)
        return;

    hdc = GetDC (lpcs->hwnd);
    fVisible = (GetClipBox (hdc, &rc) != NULLREGION);
    ReleaseDC (lpcs->hwnd, hdc);

    if (!fVisible)  // disable the overlay if iconic
        videoStreamFini (lpcs->hVideoDisplay);
    else {
        // Destination
        GetClientRect (lpcs->hwnd, &rc);
        ClientToScreen (lpcs->hwnd, (LPPOINT)&rc);
        ClientToScreen (lpcs->hwnd, (LPPOINT)&rc+1);
        videoMessage (lpcs->hVideoDisplay,
                        DVM_DST_RECT,
                        (DWORD) (LPVOID) &rc, VIDEO_CONFIGURE_SET);

        // Overlay channel Source rectangle
        SetRect (&rc, lpcs->ptScroll.x, lpcs->ptScroll.y,
                lpcs->ptScroll.x + rc.right - rc.left,
                lpcs->ptScroll.y + rc.bottom - rc.top);
        videoMessage (lpcs->hVideoDisplay,
                        DVM_SRC_RECT,
                        (DWORD) (LPVOID) &rc, VIDEO_CONFIGURE_SET);

        videoStreamInit (lpcs->hVideoDisplay, 0L, 0L, 0L, 0L);
    }
}

// WM_POSITIONCHANGED and WM_POSITIONCHANGING don't do enough to
// handle clipping of the overlay window on the Intel board,
// which keys on black.  Do this routine on WM_PAINT and
// WM_ENTERIDLE messages.

void CheckWindowMove(LPCAPSTREAM lpcs, HDC hdcWnd, BOOL fForce)
{
    UINT    wRgn;
    RECT    rc;
    DWORD   dwOrg;
    HDC     hdc;
    BOOL    f;

    if (!lpcs->hwnd || !lpcs->hVideoDisplay || !lpcs->fOverlayWindow)
        return;

    //
    //  when the screen is locked for update by a window move operation
    //  we dont want to turn off the video.
    //
    //  we can tell if the screen is locked by checking a DC to the screen.
    //
    hdc = GetDC(NULL);
    f = GetClipBox(hdc, &rc) == NULLREGION;
    ReleaseDC(NULL, hdc);

    if (f) {
        lpcs->uiRegion = (UINT) -1;
        return;
    }

    if (fForce)
        lpcs->uiRegion = (UINT) -1;

    hdc = GetDC (lpcs->hwnd);
    wRgn = GetClipBox(hdc, &rc);
    dwOrg = GetDCOrg(hdc);
    ReleaseDC(lpcs->hwnd, hdc);

    if (wRgn == lpcs->uiRegion &&
                dwOrg == lpcs->dwRegionOrigin &&
                EqualRect(&rc, &lpcs->rcRegionRect))
        return;

    lpcs->uiRegion       = wRgn;
    lpcs->dwRegionOrigin = dwOrg;
    lpcs->rcRegionRect   = rc;

    SetOverlayRectangles (lpcs);

    if (hdcWnd)
        videoUpdate (lpcs->hVideoDisplay, lpcs->hwnd, hdcWnd);
    else
        InvalidateRect (lpcs->hwnd, NULL, TRUE);
}

//
// Create our little world
//
LPCAPSTREAM CapWinCreate (HWND hwnd)
{
    LPCAPSTREAM lpcs;
    WAVEFORMATEX wfex;

    if (!(lpcs = (LPCAPSTREAM) GlobalAllocPtr (GHND, sizeof (CAPSTREAM))))
        return NULL;

    SetWindowLong (hwnd, GWL_CAPSTREAM, (LONG)lpcs);

    lpcs-> dwSize = sizeof (CAPSTREAM);
    lpcs-> uiVersion = CAPSTREAM_VERSION;
    lpcs-> hwnd = hwnd;
    lpcs-> hInst = ghInst;
    lpcs-> hWaitCursor = LoadCursor(NULL, IDC_WAIT);
    lpcs-> hdd = DrawDibOpen();
    lpcs-> fAudioHardware = !!waveOutGetNumDevs();    // force 1 or 0


    // Video defaults
    lpcs-> sCapParms.dwRequestMicroSecPerFrame = 66667;   // 15fps
    lpcs-> sCapParms.vKeyAbort          = VK_ESCAPE;
    lpcs-> sCapParms.fAbortLeftMouse    = TRUE;
    lpcs-> sCapParms.fAbortRightMouse   = TRUE;
    lpcs-> sCapParms.wNumVideoRequested = MIN_VIDEO_BUFFERS;
    lpcs-> fCapturingToDisk             = TRUE;
    lpcs-> sCapParms.wPercentDropForError = 10;   // error msg if dropped > 10%
    lpcs-> sCapParms.wChunkGranularity  = 2048;

    // Audio defaults to 11K, 8bit, Mono
    lpcs-> sCapParms.fCaptureAudio = lpcs-> fAudioHardware;
    lpcs-> sCapParms.wNumAudioRequested = DEF_WAVE_BUFFERS;

    wfex.wFormatTag = WAVE_FORMAT_PCM;
    wfex.nChannels = 1;
    wfex.nSamplesPerSec = 11025;
    wfex.nAvgBytesPerSec = 11025;
    wfex.nBlockAlign = 1;
    wfex.wBitsPerSample = 8;
    wfex.cbSize = 0;
    SendMessage (hwnd, WM_CAP_SET_AUDIOFORMAT, 0, (LONG)(LPVOID)&wfex);

    // Palette defaults
    lpcs-> nPaletteColors = 256;

    // Capture defaults
    lpcs-> sCapParms.fUsingDOSMemory = FALSE;
    lstrcpy (lpcs-> achFile, "C:\\CAPTURE.AVI");    // Default capture file
    lpcs->fCapFileExists = fileCapFileIsAVI (lpcs->achFile);

    // Allocate index to 32K frames plus proportionate number of audio chunks
    lpcs->sCapParms.dwIndexSize = (32768ul + (32768ul / 15));

    lpcs->sCapParms.fDisableWriteCache = TRUE;

    // Init the COMPVARS structure
    lpcs->CompVars.cbSize = sizeof (COMPVARS);
    lpcs->CompVars.dwFlags = 0;

    return lpcs;
}

//
// Destroy our little world
//
void CapWinDestroy (LPCAPSTREAM lpcs)
{
    // Uh, oh.  Somebodys trying to kill us while capturing
    if (lpcs->fCapturingNow && lpcs->fFrameCapturingNow) {
        // Single frame capture in progress
        SingleFrameCaptureClose (lpcs);
    }
    else if (lpcs->fCapturingNow) {
        // Streaming capture in progress, OR
        // MCI step capture in progress

        lpcs->fAbortCapture = TRUE;
        while (lpcs->fCapturingNow)
            Yield ();
    }

    if (lpcs->idTimer)
        KillTimer(lpcs->hwnd, lpcs->idTimer);

    PalFini (lpcs);
    DibFini (lpcs);

    CapWinDisconnectHardware (lpcs);

    DrawDibClose (lpcs->hdd);

    if (lpcs->lpWaveFormat)
        GlobalFreePtr (lpcs-> lpWaveFormat);

    if (lpcs->CompVars.hic)
        ICCompressorFree(&lpcs->CompVars);

    if (lpcs->lpInfoChunks)
        GlobalFreePtr(lpcs->lpInfoChunks);

    GlobalFreePtr (lpcs);       // Free the instance memory
}

WORD GetSizeOfWaveFormat (LPWAVEFORMATEX lpwf)
{
    WORD wSize;

    if (lpwf == NULL)
        return sizeof (PCMWAVEFORMAT);

    if (lpwf->wFormatTag == WAVE_FORMAT_PCM)
        wSize = sizeof (PCMWAVEFORMAT);
    else
        wSize = sizeof (WAVEFORMATEX) + lpwf -> cbSize;

    return wSize;
}

// Returns TRUE if we got a new frame, else FALSE
// if fForce, then always get a new frame
BOOL GetAFrameThenCallback (LPCAPSTREAM lpcs, BOOL fForce)
{
    BOOL fOK = FALSE;
    static BOOL fRecursion = FALSE;
    BOOL fVisible;
    RECT rc;
    HDC  hdc;

    if (fRecursion)
        return FALSE;

    if (!lpcs->sCapDrvCaps.fCaptureInitialized)
        return fOK;

    fRecursion = TRUE;

    // Update the preview window if we got a timer and not saving to disk
    if (lpcs->fOverlayWindow)
        CheckWindowMove(lpcs, NULL, FALSE);

    if ((!lpcs->fCapturingNow) || lpcs->fStepCapturingNow || lpcs->fFrameCapturingNow) {
        hdc = GetDC (lpcs->hwnd);
        fVisible = (GetClipBox (hdc, &rc) != NULLREGION);
        ReleaseDC (lpcs->hwnd, hdc);

        if (fForce || (fVisible && (lpcs->fLiveWindow || lpcs->CallbackOnVideoFrame))) {
            videoFrame (lpcs->hVideoIn, &lpcs->VidHdr );
            fOK = TRUE;

            if (lpcs->CallbackOnVideoFrame)
                (*(lpcs->CallbackOnVideoFrame)) (lpcs->hwnd, &lpcs->VidHdr);

            if (fForce || lpcs->fLiveWindow) {
                InvalidateRect (lpcs->hwnd, NULL, TRUE);
                UpdateWindow (lpcs->hwnd);
            }
        } // if visible
    } // if we're not streaming

    fRecursion = FALSE;

    return fOK;
}

// Clear the Status and Error strings via callback
void FAR PASCAL ClearStatusAndError (LPCAPSTREAM lpcs)
{
    statusUpdateStatus(lpcs, NULL);     // Clear status
    errorUpdateError(lpcs, NULL);       // Clear error

}

// Process class specific commands >= WM_USER

DWORD PASCAL ProcessCommandMessages (LPCAPSTREAM lpcs, unsigned msg, WORD wParam, LPARAM lParam)
{
    DWORD dwReturn = 0L;
    DWORD dwT;

    switch (msg) {
        // Don't clear status and error on the following innocuous msgs
        case WM_CAP_GET_CAPSTREAMPTR:
        case WM_CAP_GET_USER_DATA:
        case WM_CAP_DRIVER_GET_NAME:
        case WM_CAP_DRIVER_GET_VERSION:
        case WM_CAP_DRIVER_GET_CAPS:
        case WM_CAP_GET_AUDIOFORMAT:
        case WM_CAP_GET_VIDEOFORMAT:
        case WM_CAP_GET_STATUS:
        case WM_CAP_SET_SEQUENCE_SETUP:
        case WM_CAP_GET_SEQUENCE_SETUP:
        case WM_CAP_GET_MCI_DEVICE:
            break;

        default:
            ClearStatusAndError (lpcs);
            break;
    }

    switch (msg) {
    case WM_CAP_GET_CAPSTREAMPTR:
        // return a pointer to the CAPSTREAM
        return (DWORD) (LPVOID) lpcs;

    case WM_CAP_GET_USER_DATA:
	return lpcs->lUser;

    case WM_CAP_DRIVER_GET_NAME:
        // Return the name of the capture driver in use
        // wParam is the length of the buffer pointed to by lParam
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return (capInternalGetDriverDesc (lpcs->sCapDrvCaps.wDeviceIndex,
                (LPSTR) lParam, (int) wParam, NULL, 0));

    case WM_CAP_DRIVER_GET_VERSION:
        // Return the version of the capture driver in use as text
        // wParam is the length of the buffer pointed to by lParam
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return (capInternalGetDriverDesc (lpcs->sCapDrvCaps.wDeviceIndex,
                NULL, 0, (LPSTR) lParam, (int) wParam));

    case WM_CAP_DRIVER_GET_CAPS:
        // wParam is the size of the CAPDRIVERCAPS struct
        // lParam points to a CAPDRIVERCAPS struct
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (wParam <= sizeof (CAPDRIVERCAPS) &&
                !IsBadWritePtr ((LPVOID) lParam, (UINT) wParam)) {
            dwT = min (wParam, sizeof (CAPDRIVERCAPS));
            _fmemcpy ((LPVOID) lParam, (LPVOID) &lpcs-> sCapDrvCaps, (WORD) dwT);
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_FILE_GET_CAPTURE_FILE:
        // wParam is the size
        // lParam points to a buffer in which capture file name is copied
        if (lParam) {
            lstrcpyn ((LPSTR) lParam, lpcs->achFile, wParam);
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_GET_AUDIOFORMAT:
        // if lParam == NULL, return the size
        // if lParam != NULL, wParam is the size, return bytes copied
        if (lpcs->lpWaveFormat == NULL)
            return FALSE;
        dwT = GetSizeOfWaveFormat ((LPWAVEFORMATEX) lpcs->lpWaveFormat);
        if (lParam == NULL)
            return (dwT);
        else {
            if (wParam < (WORD) dwT)
                return FALSE;
            else {
                hmemcpy ((LPVOID) lParam, (LPVOID) lpcs->lpWaveFormat, dwT);
                dwReturn = dwT;
            }
        }
        break;

    case WM_CAP_GET_MCI_DEVICE:
        // wParam is the size
        // lParam points to a buffer in which capture file name is copied
        if (lParam) {
            lstrcpyn ((LPSTR) lParam, lpcs->achMCIDevice, wParam);
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_GET_STATUS:
        // wParam is the size of the CAPSTATUS struct pointed to by lParam
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (IsBadWritePtr ((LPVOID) lParam, (UINT) wParam))
            return FALSE;

        if (wParam >= sizeof (CAPSTATUS)) {
            LPCAPSTATUS lpcc = (LPCAPSTATUS) lParam;

            lpcc-> fLiveWindow          = lpcs-> fLiveWindow;
            lpcc-> fOverlayWindow       = lpcs-> fOverlayWindow;
            lpcc-> fScale               = lpcs-> fScale;
            lpcc-> ptScroll             = lpcs-> ptScroll;
            lpcc-> fUsingDefaultPalette = lpcs-> fUsingDefaultPalette;
            lpcc-> fCapFileExists       = lpcs-> fCapFileExists;
            lpcc-> fAudioHardware       = lpcs-> fAudioHardware;
            lpcc-> uiImageWidth         = lpcs-> dxBits;
            lpcc-> uiImageHeight        = lpcs-> dyBits;

            // The following are updated dynamically during capture
            lpcc-> dwCurrentVideoFrame          = lpcs-> dwVideoChunkCount;
            lpcc-> dwCurrentVideoFramesDropped  = lpcs-> dwFramesDropped;
            if (lpcs->lpWaveFormat != NULL) {
                lpcc-> dwCurrentWaveSamples         =
                        muldiv32 (lpcs-> dwWaveBytes,
                                  lpcs-> lpWaveFormat-> nSamplesPerSec,
                                  lpcs-> lpWaveFormat-> nAvgBytesPerSec);
            }
            lpcc-> dwCurrentTimeElapsedMS       = lpcs-> dwTimeElapsedMS;

            // Added post alpha release
            lpcc-> fCapturingNow        = lpcs-> fCapturingNow;
            lpcc-> hPalCurrent          = lpcs-> hPalCurrent;
            lpcc-> dwReturn             = lpcs-> dwReturn;
            lpcc-> wNumVideoAllocated   = lpcs-> iNumVideo;
            lpcc-> wNumAudioAllocated   = lpcs-> iNumAudio;

            dwReturn = TRUE;
        }
        break;

    case WM_CAP_GET_SEQUENCE_SETUP:
        // wParam is sizeof CAPTUREPARMS
        // lParam = LPCAPTUREPARMS
        if (wParam <= sizeof (CAPTUREPARMS) &&
                !IsBadWritePtr ((LPVOID) lParam, (UINT) wParam)) {
            dwT = min (wParam, sizeof (CAPTUREPARMS));
            _fmemcpy ((LPVOID) lParam, (LPVOID) &lpcs->sCapParms, (WORD) dwT);
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_STOP:
        // Stop capturing a sequence
        if (lpcs-> fCapturingNow) {
            lpcs-> fStopCapture = TRUE;
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_ABORT:
        // Stop capturing a sequence
        if (lpcs-> fCapturingNow) {
            lpcs-> fAbortCapture = TRUE;
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_GET_VIDEOFORMAT:
        // if lParam == NULL, return the size
        // if lParam != NULL, wParam is the size, return bytes copied
        if (!lpcs->fHardwareConnected)
            return FALSE;
        dwT = ((LPBITMAPINFOHEADER)lpcs->lpBitsInfo)-> biSize +
	      ((LPBITMAPINFOHEADER)lpcs->lpBitsInfo)->biClrUsed * sizeof(RGBQUAD);
        if (lParam == NULL)
            return dwT;
        else {
            if (wParam < (WORD) dwT)
                return FALSE;
            else {
                hmemcpy ((LPVOID) lParam, (LPVOID) lpcs->lpBitsInfo, dwT);
                dwReturn = dwT;
            }
        }
        break;

    case WM_CAP_SINGLE_FRAME_OPEN:
        // wParam is not used
        // lParam is not used
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return SingleFrameCaptureOpen (lpcs);

    case WM_CAP_SINGLE_FRAME_CLOSE:
        // wParam is not used
        // lParam is not used
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return SingleFrameCaptureClose (lpcs);

    case WM_CAP_SINGLE_FRAME:
        // wParam is not used
        // lParam is not used
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return SingleFrameCapture (lpcs);

    case WM_CAP_SET_CALLBACK_STATUS:
        // Set the status callback proc
        if (lParam != NULL && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnStatus = (CAPSTATUSCALLBACK) lParam;
        return TRUE;

    case WM_CAP_SET_CALLBACK_ERROR:
        // Set the error callback proc
        if (lParam != NULL && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnError = (CAPERRORCALLBACK) lParam;
        return TRUE;

    case WM_CAP_SET_CALLBACK_FRAME:
        // Set the callback proc for single frame during preview
        if (lParam != NULL && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnVideoFrame = (CAPVIDEOCALLBACK) lParam;
        return TRUE;

    default:
        break;
    }

    // Once we start capturing, don't change anything
    if (lpcs-> fCapturingNow)
        return dwReturn;

    switch (msg) {

    case WM_CAP_SET_CALLBACK_YIELD:
        // Set the callback proc for wave buffer processing to net
        if (lParam != NULL && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnYield = (CAPYIELDCALLBACK) lParam;
        return TRUE;

    case WM_CAP_SET_CALLBACK_VIDEOSTREAM:
        // Set the callback proc for video buffer processing to net
        if (lParam != NULL && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnVideoStream = (CAPVIDEOCALLBACK) lParam;
        return TRUE;

    case WM_CAP_SET_CALLBACK_WAVESTREAM:
        // Set the callback proc for wave buffer processing to net
        if (lParam != NULL && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnWaveStream = (CAPWAVECALLBACK) lParam;
        return TRUE;

    case WM_CAP_SET_CALLBACK_CAPCONTROL:
        // Set the callback proc for frame accurate capture start/stop
        if (lParam != NULL && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnControl = (CAPCONTROLCALLBACK) lParam;
        return TRUE;

    case WM_CAP_SET_USER_DATA:
	lpcs->lUser = lParam;
	return TRUE;

    case WM_CAP_DRIVER_CONNECT:
        // Connect to a device
        // wParam contains the index of the driver in system.ini

        // If the same driver ID is requested, skip the request
        // Prevents multiple Inits from VB apps
        if (lpcs->fHardwareConnected &&
                (lpcs->sCapDrvCaps.wDeviceIndex == wParam))
            return TRUE;

        // First disconnect from any (possibly) existing device
        SendMessage (lpcs->hwnd, WM_CAP_DRIVER_DISCONNECT, 0, 0l);

        // and then connect to the new device
        if (CapWinConnectHardware (lpcs, (WORD) wParam /*wDeviceIndex*/)) {
            if (!DibGetNewFormatFromDriver (lpcs)) {  // Allocate our bitspace
                PalGetPaletteFromDriver (lpcs);
        	InvalidateRect(lpcs->hwnd, NULL, TRUE);
                lpcs->sCapDrvCaps.fCaptureInitialized = TRUE; // everything AOK!
                dwReturn = TRUE;
            }
        }
        break;

    case WM_CAP_DRIVER_DISCONNECT:
        MB ("About to disconnect from driver");
        // Disconnect from a device
        // wParam and lParam unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        CapWinDisconnectHardware (lpcs);
        DibFini (lpcs);
        PalFini (lpcs);
        InvalidateRect(lpcs->hwnd, NULL, TRUE);
        lpcs->sCapDrvCaps.fCaptureInitialized = FALSE;
        dwReturn = TRUE;
        break;

    case WM_CAP_FILE_SET_CAPTURE_FILE:
        // lParam points to the name of the capture file
        if (lParam) {
            BOOL fAlreadyExists;        // Don't create a file if new name
            OFSTRUCT of;
            HANDLE hFile;

            // Check for valid file names...
            if ((hFile = OpenFile ((LPSTR) lParam, &of, OF_WRITE)) == -1) {
                if ((hFile = OpenFile ((LPSTR) lParam, &of, OF_CREATE | OF_WRITE)) == -1)
                    return FALSE;
                fAlreadyExists = FALSE;
            }
            else
                fAlreadyExists = TRUE;

            _lclose (hFile);
            lstrcpyn (lpcs->achFile, (LPSTR) lParam, sizeof (lpcs->achFile));
            lpcs->fCapFileExists = fileCapFileIsAVI (lpcs->achFile);
            if (!fAlreadyExists)
                OpenFile ((LPSTR) lParam, &of, OF_DELETE);
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_FILE_ALLOCATE:
        // lParam contains the size to preallocate the capture file in bytes
        return fileAllocCapFile(lpcs, lParam);

    case WM_CAP_FILE_SAVEAS:
        // lParam points to the name of the SaveAs file
        if (lParam) {
            lstrcpyn (lpcs->achSaveAsFile, (LPSTR) lParam,
                        sizeof (lpcs->achSaveAsFile));
            return (fileSaveCopy(lpcs));
        }
        break;

    case WM_CAP_FILE_SET_INFOCHUNK:
        // wParam is not used
        // lParam is an LPCAPINFOCHUNK
        if (lParam) {
            return (SetInfoChunk(lpcs, (LPCAPINFOCHUNK) lParam));
        }
        break;

    case WM_CAP_FILE_SAVEDIB:
        // lParam points to the name of the DIB file
        if (lParam) {
            if (lpcs-> fOverlayWindow)
                GetAFrameThenCallback (lpcs, TRUE /*fForce*/);

            return (fileSaveDIB(lpcs, (LPSTR)lParam));
        }
        break;

    case WM_CAP_EDIT_COPY:
        // Copy the current image and palette to the clipboard
        // wParam and lParam unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs-> fOverlayWindow)
            GetAFrameThenCallback (lpcs, TRUE /*fForce*/);

        if (lpcs->sCapDrvCaps.fCaptureInitialized && OpenClipboard (lpcs->hwnd)) {
            EmptyClipboard();

            // put a copy of the current palette in the clipboard
            if (lpcs->hPalCurrent && lpcs->lpBitsInfo->bmiHeader.biBitCount <= 8)
                SetClipboardData(CF_PALETTE, CopyPalette (lpcs->hPalCurrent));

            // make a packed DIB out of the current image
            if (lpcs-> lpBits && lpcs->lpBitsInfo ) {
                if (SetClipboardData (CF_DIB, CreatePackedDib (lpcs->lpBitsInfo,
                        lpcs-> lpBits, lpcs-> hPalCurrent)))
                    dwReturn = TRUE;
                else
                    errorUpdateError (lpcs, IDS_CAP_OUTOFMEM);
            }

            CloseClipboard();
        }
        break;

    case WM_CAP_SET_AUDIOFORMAT:
        {
            // wParam is unused
            // lParam is LPWAVEFORMAT or LPWAVEFORMATEX
            WORD wSize;
            LPWAVEFORMATEX lpwf = (LPWAVEFORMATEX) lParam;
            UINT uiError;

            // Verify the waveformat is valid
            uiError = waveInOpen((LPHWAVEIN)NULL,
                        (UINT)WAVE_MAPPER, lpwf,
                        NULL /*hWndCallback */, 0L,
                        WAVE_FORMAT_QUERY);

            if (uiError) {
                errorUpdateError (lpcs, IDS_CAP_WAVE_OPEN_ERROR);
                return FALSE;
            }

            if (lpcs->lpWaveFormat)
                GlobalFreePtr (lpcs-> lpWaveFormat);

            wSize = GetSizeOfWaveFormat (lpwf);
            if (lpcs-> lpWaveFormat = (LPWAVEFORMATEX)
                    GlobalAllocPtr (GHND, sizeof (CAPSTREAM))) {
                hmemcpy (lpcs->lpWaveFormat, lpwf, (LONG) wSize);
            }
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_DLG_VIDEOSOURCE:
        // Show the dialog which controls the video source
        // NTSC vs PAL, input channel selection, etc.
        // wParam and lParam are unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs-> sCapDrvCaps.fHasDlgVideoSource) {
            videoDialog (lpcs->hVideoCapture, lpcs->hwnd, 0L );
            // Changing from NTSC to PAL could affect image dimensions!!!
            DibGetNewFormatFromDriver (lpcs);
            PalGetPaletteFromDriver (lpcs);

            // May need to inform parent of new layout here!
            InvalidateRect(lpcs->hwnd, NULL, TRUE);
            UpdateWindow(lpcs->hwnd);
        }
        return (lpcs-> sCapDrvCaps.fHasDlgVideoSource);

    case WM_CAP_DLG_VIDEOFORMAT:
        // Show the format dialog, user selects dimensions, depth, compression
        // wParam and lParam are unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->sCapDrvCaps.fHasDlgVideoFormat) {
            videoDialog (lpcs->hVideoIn, lpcs->hwnd, 0L );
            DibGetNewFormatFromDriver (lpcs);
            PalGetPaletteFromDriver (lpcs);

            // May need to inform parent of new layout here!
            InvalidateRect(lpcs->hwnd, NULL, TRUE);
            UpdateWindow(lpcs->hwnd);
        }
        return (lpcs-> sCapDrvCaps.fHasDlgVideoFormat);

    case WM_CAP_DLG_VIDEODISPLAY:
        // Show the dialog which controls output.
        // This dialog only affects the presentation, never the data format
        // wParam and lParam are unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->sCapDrvCaps.fHasDlgVideoDisplay)
            videoDialog (lpcs->hVideoDisplay, lpcs->hwnd, 0L);
        return (lpcs->sCapDrvCaps.fHasDlgVideoDisplay);

    case WM_CAP_DLG_VIDEOCOMPRESSION:
        // Show the dialog which selects video compression options.
        // wParam and lParam are unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        ICCompressorChoose(
                lpcs->hwnd,            // parent window for dialog
                ICMF_CHOOSE_KEYFRAME,  // want "key frame every" box
                lpcs->lpBitsInfo,      // input format (optional)
                NULL,                  // input data (optional)
                &lpcs->CompVars,       // data about the compressor/dlg
                NULL);                 // title bar (optional)
        return TRUE;

    case WM_CAP_SET_VIDEOFORMAT:
        // wParam is the size of the BITMAPINFO
        // lParam is an LPBITMAPINFO
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (IsBadReadPtr ((LPVOID) lParam, (UINT) wParam))
            return FALSE;

        return (DibNewFormatFromApp (lpcs, (LPBITMAPINFO) lParam, (WORD) wParam));

    case WM_CAP_SET_PREVIEW:
        // if wParam, enable preview via drawdib
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (wParam) {
            // turn off the overlay, if it is in use
            if (lpcs-> fOverlayWindow)
                SendMessage(lpcs->hwnd, WM_CAP_SET_OVERLAY, 0, 0L);
            lpcs->fLiveWindow = TRUE;
            statusUpdateStatus(lpcs, IDS_CAP_STAT_LIVE_MODE);
         } // endif enabling preview
         else {
            lpcs->fLiveWindow = FALSE;
        }
        InvalidateRect (lpcs->hwnd, NULL, TRUE);
        return TRUE;

    case WM_CAP_SET_OVERLAY:
        // if wParam, enable overlay in hardware
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (wParam && lpcs->sCapDrvCaps.fHasOverlay) {
            if (lpcs-> fLiveWindow)   // turn off preview mode
                SendMessage(lpcs->hwnd, WM_CAP_SET_PREVIEW, 0, 0L);
            lpcs->fOverlayWindow = TRUE;
            statusUpdateStatus(lpcs, IDS_CAP_STAT_OVERLAY_MODE);
        }
        else {
            lpcs->fOverlayWindow = FALSE;
            videoStreamFini (lpcs->hVideoDisplay); // disable overlay on hardware
        }
        InvalidateRect (lpcs->hwnd, NULL, TRUE);
        return (lpcs->sCapDrvCaps.fHasOverlay);

    case WM_CAP_SET_PREVIEWRATE:
        // wParam contains preview update rate in mS.
        // if wParam == 0 no timer is in use.
        if (lpcs->idTimer) {
            KillTimer(lpcs->hwnd, ID_PREVIEWTIMER);
            lpcs->idTimer = NULL;
        }
        if (wParam != 0) {
            lpcs->idTimer = SetTimer (lpcs->hwnd, ID_PREVIEWTIMER,
                        (UINT) wParam, NULL);
        }
        lpcs->uTimeout = (UINT) wParam;
        dwReturn = TRUE;
        break;

    case WM_CAP_GRAB_FRAME:
        // grab a single frame
        // wParam and lParam unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->sCapDrvCaps.fCaptureInitialized) {

           dwReturn = (DWORD) GetAFrameThenCallback (lpcs, TRUE /*fForce*/);

           // disable live and overlay mode when capturing a single frame
           if (lpcs->fLiveWindow)
               SendMessage(lpcs->hwnd, WM_CAP_SET_PREVIEW, 0, 0L);
           else if (lpcs->fOverlayWindow)
               SendMessage(lpcs->hwnd, WM_CAP_SET_OVERLAY, 0, 0L);
        }
        break;

    case WM_CAP_GRAB_FRAME_NOSTOP:
        // grab a single frame, but don't change state of overlay/preview
        // wParam and lParam unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        dwReturn = (LONG) GetAFrameThenCallback (lpcs, TRUE /*fForce*/);
        break;

    case WM_CAP_SEQUENCE:
        // This is the main entry for streaming video capture
        // wParam is unused
        // lParam is unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->sCapDrvCaps.fCaptureInitialized) {
            lpcs-> fCapturingToDisk = TRUE;
            return (AVICapture(lpcs));
        }
        break;

    case WM_CAP_SEQUENCE_NOFILE:
        // wParam is unused
        // lParam is unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->sCapDrvCaps.fCaptureInitialized) {
            lpcs-> fCapturingToDisk = FALSE;
            return (AVICapture(lpcs));
        }
        break;

    case WM_CAP_SET_SEQUENCE_SETUP:
        // wParam is sizeof CAPTUREPARMS
        // lParam = LPCAPTUREPARMS
        // The following were added after the Beta, init in case the client
        // has a smaller structure and doesn't access them.
        lpcs->sCapParms.dwAudioBufferSize = 0;
        lpcs->sCapParms.fDisableWriteCache = TRUE;

        if (wParam <= sizeof (CAPTUREPARMS)) {
            dwT = min (sizeof (CAPTUREPARMS), wParam);
            if (IsBadReadPtr ((LPVOID) lParam, (UINT) dwT))
                break;

            _fmemcpy ((LPVOID) &lpcs->sCapParms, (LPVOID) lParam, (WORD) dwT);

            // Validate stuff that isn't handled elsewhere
            if (lpcs->sCapParms.wChunkGranularity < 16)
                lpcs->sCapParms.wChunkGranularity = 16;
            if (lpcs->sCapParms.wChunkGranularity > 16384)
                lpcs->sCapParms.wChunkGranularity = 16384;

            if (lpcs->sCapParms.fLimitEnabled && (lpcs->sCapParms.wTimeLimit == 0))
                lpcs->sCapParms.wTimeLimit = 1;

            // Force Step MCI off if not using MCI control
            if (lpcs->sCapParms.fStepMCIDevice && !lpcs->sCapParms.fMCIControl)
                    lpcs->sCapParms.fStepMCIDevice = FALSE;

            // Prevent audio capture if no audio hardware
            lpcs-> sCapParms.fCaptureAudio =
                lpcs-> fAudioHardware && lpcs-> sCapParms.fCaptureAudio;

            // Limit audio buffers
            lpcs-> sCapParms.wNumAudioRequested =
                min (MAX_WAVE_BUFFERS, lpcs->sCapParms.wNumAudioRequested);

            // Limit video buffers
            lpcs-> sCapParms.wNumVideoRequested =
                min (MAX_VIDEO_BUFFERS, lpcs->sCapParms.wNumVideoRequested);

            dwReturn = TRUE;
        }
        break;

    case WM_CAP_SET_MCI_DEVICE:
        // lParam points to the name of the capture file
        if (IsBadReadPtr ((LPVOID) lParam, 1))
            return FALSE;
        if (lParam) {
            lstrcpyn (lpcs->achMCIDevice, (LPSTR) lParam, sizeof (lpcs->achMCIDevice));
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_SET_SCROLL:
        // lParam is an LPPOINT which contains the new scroll position
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (IsBadReadPtr ((LPVOID) lParam, sizeof (POINT)))
            return FALSE;
        {
            LPPOINT lpP = (LPPOINT) lParam;

            if (lpP->x < lpcs-> dxBits && lpP->y < lpcs-> dyBits) {
                lpcs->ptScroll = *lpP;
                InvalidateRect (lpcs->hwnd, NULL, TRUE);
                dwReturn = TRUE;
            }
        }
        break;

    case WM_CAP_SET_SCALE:
        // if wParam, Scale the window to the client region?
        if (!lpcs->fHardwareConnected)
            return FALSE;
        lpcs->fScale = (BOOL) wParam;
        return TRUE;

    case WM_CAP_PAL_OPEN:
        // Open a new palette
        // wParam is unused
        // lParam contains an LPSTR to the file
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (IsBadReadPtr ((LPVOID) lParam, 1))
            return FALSE;
        return fileOpenPalette(lpcs, (LPSTR) lParam /*lpszFileName*/);

    case WM_CAP_PAL_SAVE:
        // Save the current palette in a file
        // wParam is unused
        // lParam contains an LPSTR to the file
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (IsBadReadPtr ((LPVOID) lParam, 1))
            return FALSE;
        return fileSavePalette(lpcs, (LPSTR) lParam /*lpszFileName*/);

    case WM_CAP_PAL_AUTOCREATE:
        // Automatically capture a palette
        // wParam contains a count of the number of frames to average
        // lParam contains the number of colors desired in the palette
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return CapturePaletteAuto (lpcs, (int) wParam, (int) lParam);

    case WM_CAP_PAL_MANUALCREATE:
        // Manually capture a palette
        // wParam contains TRUE for each frame to capture, FALSE when done
        // lParam contains the number of colors desired in the palette
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return CapturePaletteManual (lpcs, (BOOL) wParam, (int) lParam);

    case WM_CAP_PAL_PASTE:
        // Paste a palette from the clipboard, send to the driver
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->sCapDrvCaps.fCaptureInitialized && OpenClipboard(lpcs->hwnd)) {
            HANDLE  hPal;

            hPal = GetClipboardData(CF_PALETTE);
            CloseClipboard();
            if (hPal) {
                PalSendPaletteToDriver (lpcs, CopyPalette(hPal),  NULL /* XlateTable */);
                InvalidateRect(lpcs->hwnd, NULL, TRUE);
                dwReturn = TRUE;
            }
        }
        break;

    default:
        break;
    }
    return dwReturn;
}


/*--------------------------------------------------------------+
| ****************** THE WINDOW PROCEDURE ********************* |
+--------------------------------------------------------------*/
LONG FAR PASCAL _export _loadds CapWndProc (HWND hwnd, unsigned msg, WORD wParam, LONG lParam)
{
    LPCAPSTREAM lpcs;
    PAINTSTRUCT ps;
    HDC         hdc;
    int         f;
    MSG         PMsg;

    lpcs = (LPCAPSTREAM) GetWindowLong (hwnd, GWL_CAPSTREAM);

    if (msg >= WM_CAP_START && msg <= WM_CAP_END)
        return (ProcessCommandMessages (lpcs, msg, wParam, lParam));

    switch (msg) {

    case WM_CREATE:
        lpcs = CapWinCreate (hwnd);
        break;

    case WM_TIMER:
        // Update the preview window if we got a timer and not saving to disk
        GetAFrameThenCallback (lpcs, FALSE /*fForce*/);

        // Added VFW 1.1b, Clear the queue of additional timer msgs???
        // Trying to correct "Hit OK to continue" dialog not appearing bug
        // due to app message queue continuously being full at large
        // image dimensions.
        PeekMessage (&PMsg, hwnd, WM_TIMER, WM_TIMER,PM_REMOVE|PM_NOYIELD);
        break;

    case WM_CLOSE:
        break;

    case WM_DESTROY:
        CapWinDestroy (lpcs);
        break;

    case WM_PALETTECHANGED:
        if (lpcs->hdd == NULL)
            break;

        hdc = GetDC(hwnd);
        if (f = DrawDibRealize(lpcs->hdd, hdc, TRUE /*fBackground*/))
            InvalidateRect(hwnd,NULL,TRUE);
        ReleaseDC(hwnd,hdc);
        return f;

    case WM_QUERYNEWPALETTE:
        if (lpcs->hdd == NULL)
            break;
        hdc = GetDC(hwnd);
        f = DrawDibRealize(lpcs->hdd, hdc, FALSE);
        ReleaseDC(hwnd, hdc);

        if (f)
            InvalidateRect(hwnd, NULL, TRUE);
        return f;

    case WM_SIZE:
    case WM_MOVE:
        if (lpcs->fOverlayWindow)    // Make the driver paint the key color
            InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_WINDOWPOSCHANGED:
        if (lpcs->fOverlayWindow)    // Make the driver paint the key color
            InvalidateRect(hwnd, NULL, TRUE);
        return 0;

    case WM_ERASEBKGND:
        return 0;  // don't bother to erase it

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        if (lpcs->fOverlayWindow) {
            CheckWindowMove(lpcs, ps.hdc, TRUE);
        }
        else {
            SetWindowOrg(hdc, lpcs->ptScroll.x, lpcs->ptScroll.y);
            DibPaint(lpcs, hdc);
        }
        EndPaint(hwnd, &ps);
        break;

    default:
        break;
    }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

#if 0
void dummyTest ()
{
    HWND hwnd;
    FARPROC fpProc;
    DWORD dwSize;
    WORD wSize;
    BOOL f;
    int i;
    char szName[80];
    char szVer[80];
    DWORD dwMS;
    int iFrames, iColors;
    char s;
    LPPOINT lpP;

    capSetCallbackOnError(hwnd, fpProc);
    capSetCallbackOnStatus(hwnd, fpProc);
    capSetCallbackOnYield(hwnd, fpProc);
    capSetCallbackOnFrame(hwnd, fpProc);
    capSetCallbackOnVideoStream(hwnd, fpProc);
    capSetCallbackOnWaveStream(hwnd, fpProc);

    capDriverConnect(hwnd, i);
    capDriverDisconnect(hwnd);
    capDriverGetName(hwnd, szName, wSize);
    capDriverGetVersion(hwnd, szVer, wSize);
    capDriverGetCaps(hwnd, s, wSize);

    capFileSetCaptureFile(hwnd, szName);
    capFileGetCaptureFile(hwnd, szName, wSize);
    capFileAlloc(hwnd, dwSize);
    capFileSaveAs(hwnd, szName);

    capEditCopy(hwnd);

    capSetAudioFormat(hwnd, s, wSize);
    capGetAudioFormat(hwnd, s, wSize);
    capGetAudioFormatSize(hwnd);

    capDlgVideoFormat(hwnd);
    capDlgVideoSource(hwnd);
    capDlgVideoDisplay(hwnd);

    capPreview(hwnd, f);
    capPreviewRate(hwnd, dwMS);
    capOverlay(hwnd, f);
    capPreviewScale(hwnd, f);
    capGetStatus(hwnd, s, wSize);
    capSetScrollPos(hwnd, lpP);

    capGrabFrame(hwnd);
    capGrabFrameNoStop(hwnd);
    capCaptureSequence(hwnd);
    capCaptureSequenceNoFile(hwnd);
    capCaptureGetSetup(hwnd, s, wSize);
    capCaptureSetSetup(hwnd, s, wSize);

    capCaptureSingleFrameOpen(hwnd);
    capCaptureSingleFrameClose(hwnd);
    capCaptureSingleFrame(hwnd);

    capSetMCIDeviceName(hwnd, szName);
    capGetMCIDeviceName(hwnd, szName, wSize);

    capPalettePaste(hwnd);
    capPaletteAuto(hwnd, iFrames, iColors);
}

#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\dibmap.h ===
/****************************************************************************
 *
 *   dibmap.h
 * 
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

typedef DWORD huge * LPHISTOGRAM;

#define RGB16(r,g,b) (\
            (((WORD)(r) >> 3) << 10) |  \
            (((WORD)(g) >> 3) << 5)  |  \
            (((WORD)(b) >> 3) << 0)  )

LPHISTOGRAM     InitHistogram(LPHISTOGRAM lpHistogram);
void            FreeHistogram(LPHISTOGRAM lpHistogram);
HPALETTE        HistogramPalette(LPHISTOGRAM lpHistogram, LPBYTE lp16to8, int nColors);
BOOL            DibHistogram(LPBITMAPINFOHEADER lpbi, LPBYTE lpBits, int x, int y, int dx, int dy, LPHISTOGRAM lpHistogram);
HANDLE          DibReduce(LPBITMAPINFOHEADER lpbi, LPBYTE lpBits, HPALETTE hpal, LPBYTE lp16to8);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\dibmap.c ===
/****************************************************************************
 *
 *   dibmap.c
 *
 *   Histrogram and optimal palette processing module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <windows.h>
#include "dibmap.h"

extern NEAR PASCAL MemCopy(LPVOID,LPVOID,DWORD);
extern NEAR PASCAL MemFill(LPVOID,DWORD,BYTE);

void Histogram24(BYTE huge *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram);
void Histogram16(BYTE huge *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram);
void Histogram8(BYTE huge *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors);
void Histogram4(BYTE huge *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors);
void Histogram1(BYTE huge *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors);

void Reduce24(BYTE huge *pbIn, int dx, int dy, WORD cbIn, BYTE huge *pbOut, WORD cbOut, LPBYTE lp16to8);
void Reduce16(BYTE huge *pbIn, int dx, int dy, WORD cbIn, BYTE huge *pbOut, WORD cbOut, LPBYTE lp16to8);
void Reduce8(BYTE huge *pbIn, int dx, int dy, WORD cbIn, BYTE huge *pbOut, WORD cbOut, LPBYTE lp8to8);
void Reduce4(BYTE huge *pbIn, int dx, int dy, WORD cbIn, BYTE huge *pbOut, WORD cbOut, LPBYTE lp8to8);
void Reduce1(BYTE huge *pbIn, int dx, int dy, WORD cbIn, BYTE huge *pbOut, WORD cbOut, LPBYTE lp8to8);

//
//  InitHistogram
//
//  create a zero'ed histogram table, or initialize a existing table
//  to all zeros.
//
LPHISTOGRAM InitHistogram(LPHISTOGRAM lpHistogram)
{
    if (lpHistogram == NULL)
        lpHistogram = (LPVOID)GlobalLock(GlobalAlloc(GHND,32768l*sizeof(DWORD)));

#if 0
    if (lpHistogram)
        MemFill(lpHistogram, 32768l * sizeof(DWORD), 0);
#endif

    return lpHistogram;
}

//
//  FreeHistogram
//
//  free a histogram table
//
void FreeHistogram(LPHISTOGRAM lpHistogram)
{
    GlobalFree((HGLOBAL)HIWORD((DWORD)lpHistogram));
}

//
//  DibHistogram
//
//  take all colors in a dib and increment its entry in the Histogram table
//
//  supports the following DIB formats: 1,4,8,16,24
//
BOOL DibHistogram(LPBITMAPINFOHEADER lpbi, LPBYTE lpBits, int x, int y, int dx, int dy, LPHISTOGRAM lpHistogram)
{
    int             i;
    WORD            WidthBytes;
    RGBQUAD FAR *   prgbq;
    WORD            argb16[256];

    if (lpbi == NULL || lpHistogram == NULL)
        return FALSE;

    if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
        lpbi->biClrUsed = (1 << (int)lpbi->biBitCount);

    if (lpBits == NULL)
        lpBits = (LPBYTE)lpbi + (int)lpbi->biSize + (int)lpbi->biClrUsed*sizeof(RGBQUAD);

    WidthBytes = (WORD)((lpbi->biBitCount * lpbi->biWidth + 7) / 8 + 3) & ~3;

    ((BYTE huge *)lpBits) += (DWORD)y*WidthBytes + ((x*(int)lpbi->biBitCount)/8);

    if (dx < 0 || dx > (int)lpbi->biWidth)
        dx = (int)lpbi->biWidth;

    if (dy < 0 || dy > (int)lpbi->biHeight)
        dy = (int)lpbi->biHeight;

    if ((int)lpbi->biBitCount <= 8)
    {
        prgbq = (LPVOID)((LPBYTE)lpbi + lpbi->biSize);

        for (i=0; i<(int)lpbi->biClrUsed; i++)
        {
            argb16[i] = RGB16(prgbq[i].rgbRed,prgbq[i].rgbGreen,prgbq[i].rgbBlue);
        }

        for (i=(int)lpbi->biClrUsed; i<256; i++)
        {
            argb16[i] = 0x0000;     // just in case!
        }
    }

    switch ((int)lpbi->biBitCount)
    {
        case 24:
            Histogram24(lpBits, dx, dy, WidthBytes, lpHistogram);
            break;

        case 16:
            Histogram16(lpBits, dx, dy, WidthBytes, lpHistogram);
            break;

        case 8:
            Histogram8(lpBits, dx, dy, WidthBytes, lpHistogram, argb16);
            break;

        case 4:
            Histogram4(lpBits, dx, dy, WidthBytes, lpHistogram, argb16);
            break;

        case 1:
            Histogram1(lpBits, dx, dy, WidthBytes, lpHistogram, argb16);
            break;
    }
}

//
// will convert the given DIB to a 8bit DIB with the specifed palette
//
HANDLE DibReduce(LPBITMAPINFOHEADER lpbiIn, LPBYTE pbIn, HPALETTE hpal, LPBYTE lp16to8)
{
    HANDLE              hdib;
    int                 nPalColors;
    int                 nDibColors;
    WORD                cbOut;
    WORD                cbIn;
    BYTE                xlat[256];
    BYTE huge *         pbOut;
    RGBQUAD FAR *       prgb;
    DWORD               dwSize;
    int                 i;
    int                 dx;
    int                 dy;
    PALETTEENTRY        pe;
    LPBITMAPINFOHEADER  lpbiOut;

    dx    = (int)lpbiIn->biWidth;
    dy    = (int)lpbiIn->biHeight;
    cbIn  = ((lpbiIn->biBitCount*dx+7)/8+3)&~3;
    cbOut = (dx+3)&~3;

    GetObject(hpal, sizeof(int), (LPVOID)&nPalColors);
    nDibColors = (int)lpbiIn->biClrUsed;

    if (nDibColors == 0 && lpbiIn->biBitCount <= 8)
        nDibColors = (1 << (int)lpbiIn->biBitCount);

    if (pbIn == NULL)
        pbIn = (LPBYTE)lpbiIn + (int)lpbiIn->biSize + nDibColors*sizeof(RGBQUAD);

    dwSize = (DWORD)cbOut * dy;

    hdib = GlobalAlloc(GMEM_MOVEABLE,sizeof(BITMAPINFOHEADER)
        + nPalColors*sizeof(RGBQUAD) + dwSize);

    if (!hdib)
        return NULL;

    lpbiOut = (LPVOID)GlobalLock(hdib);
    lpbiOut->biSize         = sizeof(BITMAPINFOHEADER);
    lpbiOut->biWidth        = lpbiIn->biWidth;
    lpbiOut->biHeight       = lpbiIn->biHeight;
    lpbiOut->biPlanes       = 1;
    lpbiOut->biBitCount     = 8;
    lpbiOut->biCompression  = BI_RGB;
    lpbiOut->biSizeImage    = dwSize;
    lpbiOut->biXPelsPerMeter= 0;
    lpbiOut->biYPelsPerMeter= 0;
    lpbiOut->biClrUsed      = nPalColors;
    lpbiOut->biClrImportant = 0;

    pbOut = (LPBYTE)lpbiOut + (int)lpbiOut->biSize + nPalColors*sizeof(RGBQUAD);
    prgb  = (LPVOID)((LPBYTE)lpbiOut + (int)lpbiOut->biSize);

    for (i=0; i<nPalColors; i++)
    {
        GetPaletteEntries(hpal, i, 1, &pe);

        prgb[i].rgbRed      = pe.peRed;
        prgb[i].rgbGreen    = pe.peGreen;
        prgb[i].rgbBlue     = pe.peBlue;
        prgb[i].rgbReserved = 0;
    }

    if ((int)lpbiIn->biBitCount <= 8)
    {
        prgb = (LPVOID)((LPBYTE)lpbiIn + lpbiIn->biSize);

        for (i=0; i<nDibColors; i++)
            xlat[i] = lp16to8[RGB16(prgb[i].rgbRed,prgb[i].rgbGreen,prgb[i].rgbBlue)];

        for (; i<256; i++)
            xlat[i] = 0;
    }

    switch ((int)lpbiIn->biBitCount)
    {
        case 24:
            Reduce24(pbIn, dx, dy, cbIn, pbOut, cbOut, lp16to8);
            break;

        case 16:
            Reduce16(pbIn, dx, dy, cbIn, pbOut, cbOut, lp16to8);
            break;

        case 8:
            Reduce8(pbIn, dx, dy, cbIn, pbOut, cbOut, xlat);
            break;

        case 4:
            Reduce4(pbIn, dx, dy, cbIn, pbOut, cbOut, xlat);
            break;

        case 1:
            Reduce1(pbIn, dx, dy, cbIn, pbOut, cbOut, xlat);
            break;
    }

    return hdib;
}

///////////////////////////////////////////////////////////////////////////////
//  cluster.c
///////////////////////////////////////////////////////////////////////////////

#define  IN_DEPTH    5               // # bits/component kept from input
#define  IN_SIZE     (1 << IN_DEPTH) // max value of a color component

typedef enum { red, green, blue } color;

typedef struct tagCut {
   long lvariance;              // for int version
   int cutpoint;
   unsigned long rem;           // for experimental fixed point
   color cutaxis;
   long w1, w2;
   double variance;
   } Cut;

typedef struct tagColorBox {    // from cluster.c
   struct tagColorBox *next;                /* pointer to next box */
   int   rmin, rmax, gmin, gmax, bmin, bmax;    /* bounding box */
   long variance, wt;                           /* weighted variance */
   long sum[3];                                 /* sum of values */
   } ColorBox;

static int InitBoxes(int nBoxes);
static void DeleteBoxes(void);
static int SplitBoxAxis(ColorBox *box, Cut cutaxis);
static void ShrinkBox(ColorBox *box);
static int ComputePalette(LPHISTOGRAM lpHistogram, LPBYTE lp16to8, LPPALETTEENTRY palette);
static COLORREF DetermineRepresentative(ColorBox *box, int palIndex);
static Cut FindSplitAxis(ColorBox *box);
static void SplitBox(ColorBox *box);
static void SortBoxes(void);

HANDLE hBoxes;
ColorBox *UsedBoxes;
ColorBox *FreeBoxes;
LPBYTE   glp16to8;

#ifndef WIN32

/*
 * to avoid all this 16 bit assembler with minimal changes to the
 * rest of the code the Win32 version will use a global pointer set by
 * UseHistogram and accessed by the hist() and IncHistogram macros.
 */
DWORD huge* glpHistogram;

#define UseHistogram(p)	(glpHistogram = (p))

#define hist(r,g,b)  ((DWORD huge *)glpHistogram)[(WORD)(b) | ((WORD)(g)<<IN_DEPTH) | ((WORD)(r)<<(IN_DEPTH*2))]

#define IncHistogram(w) if (lpHistogram[(WORD)(w)] < 0xFFFFFFFF) {  \
			    lpHistogram[(WORD)(w)]++;\
			}

#else

//#define hist(r,g,b)  ((DWORD huge *)glpHistogram)[(WORD)(b) | ((WORD)(g)<<IN_DEPTH) | ((WORD)(r)<<(IN_DEPTH*2))]
#define hist(r,g,b)  GetHistogram((BYTE)(r),(BYTE)(g),(BYTE)(b))

#pragma optimize ("", off)
//
//  set FS == lpHistogram.sel, so we can get at it quickly!
//
void NEAR PASCAL UseHistogram(LPHISTOGRAM lpHistogram)
{
    _asm {
        mov     ax,word ptr lpHistogram[2]

        _emit   08Eh                     ; mov  fs,ax
        _emit   0E0h
    }
}

//
//  get the DOWRD histogram count of a RGB
//
DWORD near _fastcall GetHistogram(BYTE r, BYTE g, BYTE b)
{
    if (0)              // avoid compiler warning NO RETURN VALUE
        return 0;

    _asm {
        ;
        ; on entry al=r, dl=g, bl=b  [0-31]
        ;
        ; map to a RGB16
        ;
        xor     ah,ah
        shl     ax,5
        or      al,dl
        shl     ax,5
        or      al,bl

        ; now ax = RGB16

        _emit 66h _asm xor bx,bx           ; xor ebx,ebx
                  _asm mov bx,ax           ; mov  bx,ax
        _emit 66h _asm shl bx,2            ; shl ebx,2

        _emit 64h _asm _emit 67h           ; mov dx,fs:[ebx][2]
        _emit 8Bh _asm _emit 53h
        _emit 02h

        _emit 64h _asm _emit 67h           ; mov ax,fs:[ebx][0]
        _emit 8Bh _asm _emit 03h
    }
}

//
//  increment the histogram count of a RGB16
//
//
//  #define IncHistogram(w) if (lpHistogram[(WORD)(w)] < 0xFFFFFFFF)
//                              lpHistogram[(WORD)(w)]++;
//
void near _fastcall IncHistogram(WORD rgb16)
{
    _asm {
        ;
        ; on entry ax = rgb16
        ;
        _emit 66h _asm xor bx,bx           ; xor ebx,ebx
                  _asm mov bx,ax           ; mov bx,ax
        _emit 66h _asm shl bx,2            ; shl ebx,2

        _emit 64h _asm _emit 67h           ; cmp dword ptr fs:[ebx], -1
        _emit 66h _asm _emit 83h
        _emit 3Bh _asm _emit 0FFh

        _emit 74h _asm _emit 05h           ; je  short @f

        _emit 64h _asm _emit 67h           ; inc dword ptr fs:[ebx]
        _emit 66h _asm _emit 0FFh
        _emit 03h
    }
}

#pragma optimize ("", on)

// !!! C8 generates a Jump into the middle of a 2 byte instruction
// 
#pragma optimize ("", off)
#endif

//
//  HistogramPalette
//
//  given a histogram, will reduce it to 'nColors' number of colors.
//  returns a optimal palette.  if specifed lp16to8 will contain the
//  translate table from RGB16 to the palette index.
//
//  you can specify lpHistogram as lp16to8
//
HPALETTE HistogramPalette(LPHISTOGRAM lpHistogram, LPBYTE lp16to8, int nColors)
{
    WORD     w;
    DWORD    dwMax;
    COLORREF rgb;
    ColorBox *box;
    int i;
    // Had to make this global to prevent VB 2.0 stack explosion
    static struct {
        WORD         palVersion;
        WORD         palNumEntries;
        PALETTEENTRY palPalEntry[256];
    }   pal;

    //
    //  the 'C' code cant handle >64k histogram counts.
    //  !!!fix this
    //
    for (dwMax=0,w=0; w<0x8000; w++)
        dwMax = max(dwMax,lpHistogram[w]);

    while (dwMax > 0xFFFFl)
    {
        for (w=0; w<0x8000; w++)
            lpHistogram[w] /= 2;

        dwMax /= 2;
    }

    if (!InitBoxes(min(nColors, 236)))
        return NULL;

    UseHistogram(lpHistogram);
    glp16to8 = lp16to8;

    /* while there are free boxes left, split the largest */

    i = 0;

    do {
       i++;
       SplitBox(UsedBoxes);
       }
    while (FreeBoxes && UsedBoxes->variance);

    SortBoxes();

    i=0;

    //
    // add some standard colors to the histogram
    //
    if (nColors > 236)
    {
        HDC hdc;
	HPALETTE hpal;

        hdc = GetDC(NULL);

        if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
        {
            GetSystemPaletteEntries(hdc, 0,   10, &pal.palPalEntry[0]);
            GetSystemPaletteEntries(hdc, 246, 10, &pal.palPalEntry[246]);

            i = 10;
        } else {	// we're a true colour device, so get the system
			// colours from the default palette.
	    hpal = GetStockObject(DEFAULT_PALETTE);
            GetPaletteEntries(hpal, 0, 10, &pal.palPalEntry[0]);
            GetPaletteEntries(hpal, 10, 10, &pal.palPalEntry[246]);
            i = 10;
	}

        ReleaseDC(NULL, hdc);
    }

    UseHistogram(lpHistogram); // Register FS trashed by above!

    /* Generate the representitives and the associated Palette mapping */
    /* NOTE:  Might loop less than nColors times.                      */
    for (box = UsedBoxes; box; box = box->next, i++)
    {
        rgb = DetermineRepresentative(box, i);
        pal.palPalEntry[i].peRed   = GetRValue(rgb);
        pal.palPalEntry[i].peGreen = GetGValue(rgb);
        pal.palPalEntry[i].peBlue  = GetBValue(rgb);
        pal.palPalEntry[i].peFlags = 0;
    }

    DeleteBoxes();

    if (nColors > 236)
    {
        for (; i<246; i++)
        {
            pal.palPalEntry[i].peRed   = 0;
            pal.palPalEntry[i].peGreen = 0;
            pal.palPalEntry[i].peBlue  = 0;
            pal.palPalEntry[i].peFlags = 0;
        }

        i = 256;
    }

    glp16to8 = NULL;

    pal.palVersion    = 0x300;
    pal.palNumEntries = i;
    return CreatePalette((LPLOGPALETTE)&pal);
}

#pragma optimize ("", on)

static void SortBoxes()
{
    ColorBox *box;
    ColorBox *newList;
    ColorBox *insBox;
    ColorBox *nextBox;

    newList = UsedBoxes;
    nextBox = newList->next;
    newList->next = NULL;

    for (box = nextBox; box; box = nextBox) { // just an insertion sort...
            nextBox = box->next;
            if (box->wt > newList->wt) {
                    box->next = newList;
                    newList = box;
            } else {
                    for (insBox = newList;
                            insBox->next && (box->wt < insBox->next->wt);
                            insBox = insBox->next) ;
                    box->next = insBox->next;
                    insBox->next = box;
            }
    }

    UsedBoxes = newList;
}


/*
   allocate space for nBoxes boxes, set up links.  On exit UsedBoxes
   points to one box, FreeBoxes points to remaining (nBoxes-1) boxes.
   return 0 if successful.
*/

static BOOL InitBoxes(int nBoxes)
{
    int i;

    hBoxes = LocalAlloc(LHND, nBoxes*sizeof(ColorBox));
    if (!hBoxes)
        return FALSE;

    UsedBoxes = (ColorBox*)LocalLock(hBoxes);
    FreeBoxes = UsedBoxes + 1;
    UsedBoxes->next = NULL;

    for (i = 0; i < nBoxes - 1; ++i)
    {
        FreeBoxes[i].next = FreeBoxes + i + 1;
    }
    FreeBoxes[nBoxes-2].next = NULL;

    /* save the bounding box */
    UsedBoxes->rmin = UsedBoxes->gmin = UsedBoxes->bmin = 0;
    UsedBoxes->rmax = UsedBoxes->gmax = UsedBoxes->bmax = IN_SIZE - 1;
    UsedBoxes->variance = 9999999;    /* arbitrary large # */

    return TRUE;
}

static void DeleteBoxes()
{
   LocalUnlock(hBoxes);
   LocalFree(hBoxes);
   hBoxes = NULL;
}

static void SplitBox(ColorBox *box)
{
   /*
      split box into two roughly equal halves and update the data structures
      appropriately.
   */
   Cut cutaxis;
   ColorBox *temp, *temp2, *prev;

   cutaxis = FindSplitAxis(box);

   /* split the box along that axis.  If rc != 0 then the box contains
      one color, and should not be split */
   if (SplitBoxAxis(box, cutaxis))
      return;

   /* shrink each of the boxes to fit the points they enclose */
   ShrinkBox(box);
   ShrinkBox(FreeBoxes);

   /* move old box down in list, if necessary */
   if (box->next && box->variance < box->next->variance)
   {
      UsedBoxes = box->next;
      temp = box;
      do {
         prev = temp;
         temp = temp->next;
         } while (temp && temp->variance > box->variance);
      box->next = temp;
      prev->next = box;
   }

   /* insert the new box in sorted order (descending), removing it
      from the free list. */
   if (FreeBoxes->variance >= UsedBoxes->variance)
   {
      temp = FreeBoxes;
      FreeBoxes = FreeBoxes->next;
      temp->next = UsedBoxes;
      UsedBoxes = temp;
   }
   else
   {
      temp = UsedBoxes;
      do {
         prev = temp;
         temp = temp->next;
         } while (temp && temp->variance > FreeBoxes->variance);
      temp2 = FreeBoxes->next;
      FreeBoxes->next = temp;
      prev->next = FreeBoxes;
      FreeBoxes = temp2;
   }
}

static Cut FindSplitAxis(ColorBox *box)
{
        unsigned long   proj_r[IN_SIZE],proj_g[IN_SIZE],proj_b[IN_SIZE];
        unsigned long   f;
        double          currentMax,mean;
        unsigned long   w,w1,m,m1;
        short           r,g,b;
        short           bestCut;
        color           bestAxis;
        Cut             cutRet;
        double          temp1,temp2;

        for (r = 0; r < IN_SIZE; r++) {
                proj_r[r] = proj_g[r] = proj_b[r] = 0;
        }

        w = 0;

        // Project contents of box down onto axes
        for (r = box->rmin; r <= box->rmax; r++) {
                for (g = box->gmin; g <= box->gmax; ++g) {
                        for (b = box->bmin; b <= box->bmax; ++b) {
                                f = hist(r,g,b);
                                proj_r[r] += f;
                                proj_g[g] += f;
                                proj_b[b] += f;
                        }
                }
                w += proj_r[r];
        }

        currentMax = 0.0f;

#define Check_Axis(l,color)                                     \
        m = 0;                                                  \
        for (l = box->l##min; l <= box->l##max; (l)++) {        \
                m += l * proj_##l[l];                           \
        }                                                       \
        mean = ((double) m) / ((double) w);                     \
                                                                \
        w1 = 0;                                                 \
        m1 = 0;                                                 \
        for (l = box->l##min; l <= box->l##max; l++) {          \
                w1 += proj_##l[l];                              \
                if (w1 == 0)                                    \
                        continue;                               \
                if (w1 == w)                                    \
                        break;                                  \
                m1 += l * proj_##l[l];                          \
                temp1 = mean - (((double) m1) / ((double) w1)); \
                temp2 = (((double) w1) / ((double) (w-w1))) * temp1 * temp1; \
                if (temp2 > currentMax) {                       \
                        bestCut = l;                            \
                        bestAxis = color;                       \
                        currentMax = temp2;                     \
                }                                               \
        }

        Check_Axis(r,red);
        Check_Axis(g,green);
        Check_Axis(b,blue);

        cutRet.cutaxis = bestAxis;
        cutRet.cutpoint = bestCut;

        return cutRet;
}

static int SplitBoxAxis(ColorBox *box, Cut cutaxis)
{
   /*
      Split box along splitaxis into two boxes, one of which is placed
      back in box, the other going in the first free box (FreeBoxes)
      If the box only contains one color, return non-zero, else return 0.
   */
   ColorBox *next;

   if ( box->variance == 0)
      return 1;

   /* copy all non-link information to new box */
   next = FreeBoxes->next;
   *FreeBoxes = *box;
   FreeBoxes->next = next;

   switch (cutaxis.cutaxis)
   {
      case red:
         box->rmax = cutaxis.cutpoint;
         FreeBoxes->rmin = cutaxis.cutpoint+1;
         break;
      case green:
         box->gmax = cutaxis.cutpoint;
         FreeBoxes->gmin = cutaxis.cutpoint+1;
         break;
      case blue:
         box->bmax = cutaxis.cutpoint;
         FreeBoxes->bmin = cutaxis.cutpoint+1;
         break;
   }

   return 0;
}

static void ShrinkBox(ColorBox *box)
{
        unsigned long n, sxx, sx2, var, quotient, remainder;
        int r,g,b;
        unsigned long   f;
        unsigned long   proj_r[IN_SIZE],proj_g[IN_SIZE],proj_b[IN_SIZE];

        n = 0;

        for (r = 0; r < IN_SIZE; r++) {
                proj_r[r] = proj_g[r] = proj_b[r] = 0;
        }

        // Project contents of box down onto axes
        for (r = box->rmin; r <= box->rmax; r++) {
                for (g = box->gmin; g <= box->gmax; ++g) {
                        for (b = box->bmin; b <= box->bmax; ++b) {
                                f = hist(r,g,b);
                                proj_r[r] += f;
                                proj_g[g] += f;
                                proj_b[b] += f;
                        }
                }
                n += proj_r[r];
        }

        box->wt = n;
        var = 0;

#define AddAxisVariance(c)                                              \
        sxx = 0; sx2 = 0;                                               \
        for (c = box->c##min; c <= box->c##max; c++) {                  \
                sxx += proj_##c[c] * c * c;                             \
                sx2 += proj_##c[c] * c;                                 \
        }                                                               \
        quotient = sx2 / n; /* This stuff avoids overflow */            \
        remainder = sx2 % n;                                            \
        var += sxx - quotient * sx2 - ((remainder * sx2)/n);

        AddAxisVariance(r);
        AddAxisVariance(g);
        AddAxisVariance(b);

        box->variance = var;
}

static COLORREF DetermineRepresentative(ColorBox *box, int palIndex)
{
   /*
      determines the rgb value to represent the pixels contained in
      box.  nbits is the # bits/component we're allowed to return.
   */
   long f;
   long Rval, Gval, Bval;
   unsigned long total;
   int r, g, b;
   WORD w;

   /* compute the weighted sum of the elements in the box */
   Rval = Gval = Bval = total = 0;
   for (r = box->rmin; r <= box->rmax; ++r)
   {
      for (g = box->gmin; g <= box->gmax; ++g)
      {
         for (b = box->bmin; b <= box->bmax; ++b)
         {
            if (glp16to8)
            {
                w = (WORD)(b) | ((WORD)(g)<<IN_DEPTH) | ((WORD)(r)<<(IN_DEPTH*2));
                glp16to8[w] = (BYTE)palIndex;
            }

            f = hist(r,g,b);
            if (f == 0L)
               continue;

            Rval += f * (long) r;
            Gval += f * (long) g;
            Bval += f * (long) b;

            total += f;
         }
      }
   }

   /* Bias the sum so that we round up at .5 */
   Rval += total / 2;
   Gval += total / 2;
   Bval += total / 2;

   return RGB(Rval*255/total/IN_SIZE, Gval*255/total/IN_SIZE, Bval*255/total/IN_SIZE);
}

///////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
//  write this stuff in ASM!
//
///////////////////////////////////////////////////////////////////////////////

void Histogram24(BYTE huge *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram)
{
    int x,y;
    BYTE r,g,b;
    WORD w;

    UseHistogram(lpHistogram);

    WidthBytes -= dx*3;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            b = *pb++;
            g = *pb++;
            r = *pb++;
            w = RGB16(r,g,b);
            IncHistogram(w);
        }
        pb += WidthBytes;
    }
}

void Histogram16(BYTE huge *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram)
{
    int x,y;
    WORD w;

    UseHistogram(lpHistogram);

    WidthBytes -= dx*2;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            w = *((WORD huge *)pb)++;
            w &= 0x7FFF;
            IncHistogram(w);
        }
        pb += WidthBytes;
    }
}

void Histogram8(BYTE huge *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors)
{
    int x,y;
    WORD w;

    UseHistogram(lpHistogram);

    WidthBytes -= dx;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            w = lpColors[*pb++];
            IncHistogram(w);
        }
        pb += WidthBytes;
    }
}

void Histogram4(BYTE huge *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors)
{
    int x,y;
    BYTE b;
    WORD w;

    UseHistogram(lpHistogram);

    WidthBytes -= (dx+1)/2;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<(dx+1)/2; x++)
        {
            b = *pb++;

            w = lpColors[b>>4];
            IncHistogram(w);

            w = lpColors[b&0x0F];
            IncHistogram(w);
        }
        pb += WidthBytes;
    }
}

void Histogram1(BYTE huge *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors)
{
    int x,y,i;
    BYTE b;
    WORD w;

    UseHistogram(lpHistogram);

    WidthBytes -= (dx+7)/8;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<(dx+7)/8; x++)
        {
            b = *pb++;

            for (i=0; i<8; i++)
            {
                w = lpColors[b>>7];
                IncHistogram(w);
                b<<=1;
            }
        }
        pb += WidthBytes;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  write this stuff in ASM! too
//
///////////////////////////////////////////////////////////////////////////////

void Reduce24(BYTE huge *pbIn, int dx, int dy, WORD cbIn, BYTE huge *pbOut, WORD cbOut, LPBYTE lp16to8)
{
    int x,y;
    BYTE r,g,b;

    cbOut -= dx;
    cbIn  -= dx*3;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            b = *pbIn++;
            g = *pbIn++;
            r = *pbIn++;
            *pbOut++ = lp16to8[RGB16(r,g,b)];
        }
        pbIn += cbIn;
        pbOut+= cbOut;
    }
}

void Reduce16(BYTE huge *pbIn, int dx, int dy, WORD cbIn, BYTE huge *pbOut, WORD cbOut, LPBYTE lp16to8)
{
    int x,y;
    WORD w;

    cbOut -= dx;
    cbIn  -= dx*2;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            w = *((WORD huge *)pbIn)++;
            *pbOut++ = lp16to8[w&0x7FFF];
        }
        pbIn += cbIn;
        pbOut+= cbOut;
    }
}

void Reduce8(BYTE huge *pbIn, int dx, int dy, WORD cbIn, BYTE huge *pbOut, WORD cbOut, LPBYTE lp8to8)
{
    int x,y;

    cbIn  -= dx;
    cbOut -= dx;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            *pbOut++ = lp8to8[*pbIn++];
        }
        pbIn  += cbIn;
        pbOut += cbOut;
    }
}

void Reduce4(BYTE huge *pbIn, int dx, int dy, WORD cbIn, BYTE huge *pbOut, WORD cbOut, LPBYTE lp8to8)
{
    int x,y;
    BYTE b;

    cbIn  -= (dx+1)/2;
    cbOut -= (dx+1)&~1;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<(dx+1)/2; x++)
        {
            b = *pbIn++;
            *pbOut++ = lp8to8[b>>4];
            *pbOut++ = lp8to8[b&0x0F];
        }
        pbIn  += cbIn;
        pbOut += cbOut;
    }
}

void Reduce1(BYTE huge *pbIn, int dx, int dy, WORD cbIn, BYTE huge *pbOut, WORD cbOut, LPBYTE lp8to8)
{
    int x,y;
    BYTE b;

    cbIn  -= (dx+7)/8;
    cbOut -= dx;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            if (x%8 == 0)
                b = *pbIn++;

            *pbOut++ = lp8to8[b>>7];
            b<<=1;
        }
        pbIn  += cbIn;
        pbOut += cbOut;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\memcopy.asm ===
?PLM=1	    ; PASCAL Calling convention is DEFAULT
?WIN=0      ; Windows calling convention
PMODE=1

.xlist
include cmacros.inc
include windows.inc
.list

	externA	    __WinFlags	    ; in KERNEL
	externA	    __AHINCR	    ; in KERNEL
	externA	    __AHSHIFT	    ; in KERNEL

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG	struc
lo	dw	?
hi	dw	?
LONG	ends

FARPOINTER	struc
off	dw	?
sel	dw	?
FARPOINTER	ends

; Manually perform "push" dword register instruction to remove warning
PUSHD macro reg
	db	66h
	push	reg
endm

; Manually perform "pop" dword register instruction to remove warning
POPD macro reg
	db	66h
	pop	reg
endm

; -------------------------------------------------------
;		DATA SEGMENT DECLARATIONS
; -------------------------------------------------------

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin Data
sEnd Data

sBegin CodeSeg
        assumes cs,CodeSeg
        assumes ds,DATA

;---------------------------Public-Routine------------------------------;
; MemCopy
;
;   copy memory
;
; Entry:
;	lpSrc	HPSTR to copy from
;	lpDst	HPSTR to copy to
;	cbMem	DWORD count of bytes to move
;
; Returns:
;	destination pointer
; Error Returns:
;	None
; Registers Preserved:
;	BP,DS,SI,DI
; Registers Destroyed:
;	AX,BX,CX,DX,FLAGS
; Calls:
;	nothing
;-----------------------------------------------------------------------;

cProc MemCopy,<NEAR,PASCAL,PUBLIC>,<ds>
	ParmD	lpDst
	ParmD	lpSrc
	ParmD	cbMem
cBegin
	.386
	PUSHD	di		; push edi
	PUSHD	si		; push esi
	cld

	mov	ecx,cbMem
	jecxz	mc386_exit

	movzx	edi,di
	movzx	esi,si
	lds	si,lpSrc
        les     di,lpDst

        mov     ebx,ecx
	shr	ecx,2		; get count in DWORDs
	rep	movs dword ptr es:[edi], dword ptr ds:[esi]
        mov     ecx,ebx
	and	ecx,3
	rep	movs byte ptr es:[edi], byte ptr ds:[esi]

mc386_exit:
	cld
	POPD	si		: pop esi
	POPD	di		; pop edi
	.286
cEnd

sEnd CodeSeg
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\iaverage.h ===
/****************************************************************************
 *
 *   iaverage.h
 * 
 *   Image averaging
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#ifndef _INC_AVERAGE
#define _INC_AVERAGE

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifndef RC_INVOKED

// -------------------------
//  Structures 
// -------------------------

typedef struct tagiAverage {
    BITMAPINFO      bi;                 // Copy of source format
    RGBQUAD         pe[256];            // Copy of color table
    LPBYTE          lpInverseMap;       // rgb15 to palette index 
    LPWORD          lpRGB;              // accumulator
    WORD            iCount;             // Count of images accumulated
} IAVERAGE, *PIAVERAGE, FAR *LPIAVERAGE;

BOOL iaverageInit   (LPIAVERAGE FAR * lppia, LPBITMAPINFO lpbi, HPALETTE hPal);
BOOL iaverageFini   (LPIAVERAGE lpia);
BOOL iaverageZero   (LPIAVERAGE lpia);
BOOL iaverageSum    (LPIAVERAGE lpia, LPVOID lpBits);
BOOL iaverageDivide (LPIAVERAGE lpia, LPVOID lpBits);
BOOL CrunchDIB(
    LPIAVERAGE lpia,
    LPBITMAPINFOHEADER  lpbiSrc,    // BITMAPINFO of source
    LPVOID              lpSrc,      // input bits to crunch
    LPBITMAPINFOHEADER  lpbiDst,    // BITMAPINFO of dest
    LPVOID              lpDst);     // output bits to crunch

#endif  /* RC_INVOKED */


#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif    /* __cplusplus */

#endif /* INC_AVERAGE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\libentry.asm ===
PAGE,132
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       LIBENTRY.ASM
;
;       Windows dynamic link library entry routine
;
;   This module generates a code segment called INIT_TEXT.
;   It initializes the local heap if one exists and then calls
;   the C routine LibMain() which should have the form:
;   BOOL FAR PASCAL LibMain(HANDLE hInstance,
;                           WORD   wDataSeg,
;                           WORD   cbHeap,
;                           DWORD  ignore);     /* Always NULL - ignore */
;
;   The result of the call to LibMain is returned to Windows.
;   The C routine should return TRUE if it completes initialization
;   successfully, FALSE if some error occurs.
;
;   Note - The last parameter to LibMain is included for compatibility
;   reasons.  Applications that wish to modify this file and remove the
;   parameter from LibMain may do so by simply removing the two
;   "push" instructions below marked with "****".
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

include cmacros.inc

externFP <LibMain>               ; the C routine to be called

createSeg INIT_TEXT, INIT_TEXT, BYTE, PUBLIC, CODE
sBegin	INIT_TEXT
assumes CS,INIT_TEXT

?PLM=0                           ; 'C'naming
externA  <_acrtused>             ; ensures that Win DLL startup code is linked

?PLM=1                           ; 'PASCAL' naming
externFP <LocalInit>             ; Windows heap init routine

cProc   LibEntry, <PUBLIC,FAR>   ; entry point into DLL

;include CONVDLL.INC

cBegin
        push    di               ; handle of the module instance
        push    ds               ; library data segment
        push    cx               ; heap size
        push    es               ; Always NULL  ****  May remove (see above)
        push    si               ; Always NULL  ****  May remove (see above)

        ; if we have some heap then initialize it
        jcxz    callc            ; jump if no heap specified

        ; call the Windows function LocalInit() to set up the heap
        ; LocalInit((LPSTR)start, WORD cbHeap);

        xor     ax,ax
        cCall   LocalInit <ds, ax, cx>
        or      ax,ax            ; did it do it ok ?
        jz      error            ; quit if it failed

        ; invoke the C routine to do any special initialization

callc:
        call    LibMain          ; invoke the 'C' routine (result in AX)
        jmp short exit           ; LibMain is responsible for stack clean up

error:
	pop	si		 ; clean up stack on a LocalInit error
        pop     es
        pop     cx
        pop     ds
        pop     di

exit:

cEnd

sEnd	INIT_TEXT

end LibEntry

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\iaverage.c ===
/*
 *
 * iaverage.c   Image averaging
 *
 * (C) Copyright Microsoft Corporation 1993. All rights reserved.
 *
 */

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>
#include <stdlib.h>
#include <ctype.h>
#include <memory.h>
#include <string.h>
#include <msvideo.h>
#include "iaverage.h"

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) (int)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)
#define RGB16(r,g,b)      ((((WORD)(r) >> 3) << 10) | \
                          (((WORD)(g) >> 3) << 5)  | \
                          (((WORD)(b) >> 3) ) )

typedef BYTE _huge  *   HPBYTE;
typedef WORD _huge  *   HPWORD;
typedef DWORD _huge *   HPDWORD;

/* Description:
        A sequence of images are averaged together using 16 bit
        accumulators for each of the Red, Green, and Blue components.
        The final processing step is to divide the accumulated values
        by the number of frames averaged, and transfer the results back
        into the destination DIB.

        Certain death will result if the image format is changed between
        iaverageInit and iaverageFini calls.
*/

//
// table to map a 5bit index (0-31) to a 8 bit value (0-255)
//
static BYTE aw5to8[32] = {(BYTE)-1};



/*
 *  iaverageInit
 *      Allocate memory for subsequent image averaging
 *      Return FALSE on error
 *
 */
BOOL iaverageInit (LPIAVERAGE FAR * lppia, LPBITMAPINFO lpbi, HPALETTE hPal)
{
    DWORD       dwSizeImage;
    LPIAVERAGE  lpia;
    int         i;

    *lppia = NULL;

    // Check for legal DIB formats
    if (lpbi->bmiHeader.biCompression != BI_RGB)
        return FALSE;

    if (lpbi->bmiHeader.biBitCount != 8 &&
        lpbi->bmiHeader.biBitCount != 16 &&
        lpbi->bmiHeader.biBitCount != 24 &&
        lpbi->bmiHeader.biBitCount != 32)
        return FALSE;

    //
    // init the 5bit to 8bit conversion table.
    //
    if (aw5to8[0] != 0)
        for (i=0; i<32; i++)
            aw5to8[i] = (BYTE)(i * 255 / 31);

    // Alloc memory for the image average structure
    lpia = (LPIAVERAGE) GlobalAllocPtr (GHND, sizeof (IAVERAGE));

    if (!lpia)
        return FALSE;

    // Save a copy of the header
    lpia->bi.bmiHeader = lpbi->bmiHeader;

    // and a copy of the color table and an inverse mapping table
    // if the image is 8 bit
    if (lpbi->bmiHeader.biBitCount == 8) {
        WORD r, g, b;
        LPBYTE lpB;

        hmemcpy (lpia->bi.bmiColors,
                        lpbi->bmiColors,
                        lpbi->bmiHeader.biClrUsed * sizeof (RGBQUAD));

        // Allocate and init the inverse LUT
        lpia->lpInverseMap= (LPBYTE) GlobalAllocPtr (GHND, 1024L * 32);
        lpB = lpia-> lpInverseMap;
        for (r = 0; r < 256; r += 8)
            for (g = 0; g < 256; g += 8)
                for (b = 0; b < 256; b += 8)
                    *lpB++ = (BYTE) GetNearestPaletteIndex (hPal, RGB(r,g,b));

    }

    dwSizeImage = lpbi->bmiHeader.biSizeImage;

    lpia->lpRGB = (LPINT) GlobalAllocPtr (GHND,
                        dwSizeImage * sizeof (WORD) * 3);

    if (lpia->lpRGB == NULL) {
        // Allocation failed, clean up
        iaverageFini (lpia);
        return FALSE;
    }

    *lppia = lpia;

    return TRUE;
}


/*
 *  iaverageFini
 *      Free memory used for image averaging
 *      and the iaverage structure itself
 *
 */
BOOL iaverageFini (LPIAVERAGE lpia)
{
    if (lpia == NULL)
        return FALSE;

    if (lpia->lpInverseMap)
        GlobalFreePtr (lpia->lpInverseMap);
    if (lpia->lpRGB)
        GlobalFreePtr (lpia->lpRGB);

    GlobalFreePtr (lpia);

    return TRUE;
}


/*
 *  iaverageZero
 *      Zeros the accumulator
 *
 */
BOOL iaverageZero (LPIAVERAGE lpia)
{
    DWORD   dwC;
    HPWORD  hpW;

    if (lpia == NULL)
        return FALSE;

    hpW = (HPWORD) lpia->lpRGB;
    dwC = lpia->bi.bmiHeader.biSizeImage * 3;
    while (--dwC)
        *hpW++ = 0;

    lpia-> iCount = 0;

    return TRUE;
}

/*
 *  iaverageSum
 *      Add the current image into the accumulator
 *      Image format must be 16 or 24 bit RGB
 */
BOOL iaverageSum (LPIAVERAGE lpia, LPVOID lpBits)
{
    HPWORD      hpRGB;
    DWORD       dwC;
    WORD        wRGB16;
    HPWORD      hpW;
    HPBYTE      hpB;
    WORD        w;

    if (lpia == NULL)
        return FALSE;

    hpRGB   = (HPWORD) lpia->lpRGB;

    if (lpia->bi.bmiHeader.biBitCount == 8) {
        hpB = (HPBYTE) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage; --dwC; ) {
            w = (WORD) *hpB++;
            *hpRGB++   += lpia->bi.bmiColors[w].rgbBlue;
            *hpRGB++   += lpia->bi.bmiColors[w].rgbGreen;
            *hpRGB++   += lpia->bi.bmiColors[w].rgbRed;
        }
    }

    else if (lpia->bi.bmiHeader.biBitCount == 16) {
        hpW = (HPWORD) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage / 2; --dwC; ) {
            wRGB16 = *hpW++;

            *hpRGB++  += aw5to8 [wRGB16         & 0x1f]; // b
            *hpRGB++  += aw5to8 [(wRGB16 >> 5)  & 0x1f]; // g
            *hpRGB++  += aw5to8 [(wRGB16 >> 10) & 0x1f]; // r

        }
    }

    else if (lpia->bi.bmiHeader.biBitCount == 24) {
        hpB = (HPBYTE) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage; --dwC; ) {
            *hpRGB++  += *hpB++;
        }
    }

    else if (lpia->bi.bmiHeader.biBitCount == 32) {
        hpB = (HPBYTE) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage / 4; --dwC; ) {
            *hpRGB++  += *hpB++; // b
            *hpRGB++  += *hpB++; // g
            *hpRGB++  += *hpB++; // r
            hpB++;
        }
    }

    lpia-> iCount++;            // Image counter

    return TRUE;
}

/*
 *  iaverageDivide
 *      Divide by the number of images captured, and xfer back into the
 *      destination DIB.
 *
 */
BOOL iaverageDivide (LPIAVERAGE lpia, LPVOID lpBits)
{
    HPWORD      hpRGB;
    WORD        r, g, b, w;
    DWORD       dwC;
    HPWORD      hpW;
    HPBYTE      hpB;

    if (lpia == NULL || lpia-> iCount == 0)
        return FALSE;

    hpRGB   = (HPWORD) lpia->lpRGB;

    if (lpia->bi.bmiHeader.biBitCount == 8) {
        hpB = (HPBYTE) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage; --dwC; ) {
            b = *hpRGB++ / lpia-> iCount;
            g = *hpRGB++ / lpia-> iCount;
            r = *hpRGB++ / lpia-> iCount;

            w = RGB16(r,g,b) & 0x7FFF;
            *hpB++ = * (lpia->lpInverseMap + w);

        }
    }

    else if (lpia->bi.bmiHeader.biBitCount == 16) {
        hpW = (HPWORD) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage / 2; --dwC; ) {
            b = *hpRGB++ / lpia-> iCount;
            g = *hpRGB++ / lpia-> iCount;
            r = *hpRGB++ / lpia-> iCount;

            *hpW++ = RGB16 (r, g, b);
        }
    }

    else if (lpia->bi.bmiHeader.biBitCount == 24) {
        hpB = (HPBYTE) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage; --dwC; ) {
            *hpB++ = (BYTE) (*hpRGB++  / lpia-> iCount);
        }
    }

    else if (lpia->bi.bmiHeader.biBitCount == 32) {
        hpB = (HPBYTE) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage / 4; --dwC; ) {
            *hpB++ = (BYTE) (*hpRGB++ / lpia-> iCount); // b
            *hpB++ = (BYTE) (*hpRGB++ / lpia-> iCount); // g
            *hpB++ = (BYTE) (*hpRGB++ / lpia-> iCount); // r
            hpB++;
        }
    }

    return TRUE;
}

// The following appropriated from Toddla's CDIB

/*****************************************************************************
 *
 *  SumRGB
 *
 *****************************************************************************/

#define SumRGB16(b0,b1,b2,b3) (\
             ((((WORD)pal.palPalEntry[b0].peRed +         \
                (WORD)pal.palPalEntry[b1].peRed +         \
                (WORD)pal.palPalEntry[b2].peRed +         \
                (WORD)pal.palPalEntry[b3].peRed)          \
                & 0x03E) << 5) |                          \
                                                          \
             ((((WORD)pal.palPalEntry[b0].peGreen +       \
                (WORD)pal.palPalEntry[b1].peGreen +       \
                (WORD)pal.palPalEntry[b2].peGreen +       \
                (WORD)pal.palPalEntry[b3].peGreen)        \
                & 0x003E)) |                              \
                                                          \
             ((((WORD)pal.palPalEntry[b0].peBlue +        \
                (WORD)pal.palPalEntry[b1].peBlue +        \
                (WORD)pal.palPalEntry[b2].peBlue +        \
                (WORD)pal.palPalEntry[b3].peBlue)         \
                & 0x003E) >> 5) )

/*****************************************************************************
 *
 *  RGB16
 *
 *****************************************************************************/

typedef struct { BYTE b,g,r; } RGB24;

#define rgb16(r,g,b) (\
            ((UINT)(r) << 10) |  \
            ((UINT)(g) << 5)  |  \
            ((UINT)(b) << 0)  )

#define RGB16R(rgb)     aw5to8[((UINT)(rgb) >> 10) & 0x1F]
#define RGB16G(rgb)     aw5to8[((UINT)(rgb) >> 5)  & 0x1F]
#define RGB16B(rgb)     aw5to8[((UINT)(rgb) >> 0)  & 0x1F]
#define RGB16r(rgb)     ((BYTE)((UINT)(rgb) >> 10) & 0x1F)
#define RGB16g(rgb)     ((BYTE)((UINT)(rgb) >> 5)  & 0x1F)
#define RGB16b(rgb)     ((BYTE)((UINT)(rgb) >> 0)  & 0x1F)

/*****************************************************************************
 *
 *  Pel() used for 24bit Crunch
 *
 *****************************************************************************/

#define Pel(p,x) (BYTE)(BitCount == 1 ? Pel1(p,x) : \
                        BitCount == 4 ? Pel4(p,x) : Pel8(p,x))

#define Pel1(p,x)   (BYTE)bit(((HPBYTE)(p))[(x)/8],7-((x)%8))
#define Pel4(p,x)   (BYTE)((x & 1) ? (((HPBYTE)(p))[(x)/2] & 15) : (((HPBYTE)(p))[(x)/2] >> 4))
#define Pel8(p,x)   (BYTE)(((HPBYTE)(p))[(x)])
#define Pel16(p,x)  (((HPWORD)(p))[(x)])
#define Pel24(p,x)  (((RGB24 _huge *)(p))[(x)])

/*****************************************************************************
 *
 *  CrunchDIB  - shrink a DIB down by 2 with color averaging
 *
 *     this routine works on 8, 16, 24, and 32 bpp DIBs
 *
 *     this routine can't be used "in place"
 *
 *****************************************************************************/

BOOL CrunchDIB(
    LPIAVERAGE lpia,                // image averaging structure
    LPBITMAPINFOHEADER  lpbiSrc,    // BITMAPINFO of source
    LPVOID              lpSrc,      // input bits to crunch
    LPBITMAPINFOHEADER  lpbiDst,    // BITMAPINFO of dest
    LPVOID              lpDst)      // output bits to crunch
{
    HPBYTE      pbSrc;
    HPBYTE      pbDst;
    HPBYTE      pb;
    HPWORD      pw;
    BYTE        r,g,b,b0,b1,b2,b3;
    WORD        w0,w1,w2,w3;
    RGB24       rgb0,rgb1,rgb2,rgb3;
    int         WidthBytesSrc;
    int         WidthBytesDst;
    UINT        x;
    UINT        y;
    UINT        dx;
    UINT        dy;
    int         i;
    COLORREF    rgb;
    int         BitCount;
    UINT        aw5to8[32];

     struct {
        WORD         palVersion;
	WORD         palNumEntries;
	PALETTEENTRY palPalEntry[256];
    }   pal;

   if (lpbiSrc->biCompression != BI_RGB)
        return FALSE;

    BitCount = (int)lpbiSrc->biBitCount;

    if (BitCount == 16)
        for (i=0; i<32; i++)
            aw5to8[i] = (UINT)i * 255u / 31u;

    dx = (int)lpbiDst->biWidth;
    WidthBytesDst = (((UINT)lpbiDst->biBitCount * dx + 31)&~31) / 8;

    dy = (int)lpbiSrc->biHeight;
    dx = (int)lpbiSrc->biWidth;
    WidthBytesSrc = (((UINT)lpbiSrc->biBitCount * dx + 31)&~31) / 8;

    dx &= ~1;
    dy &= ~1;

    pbSrc = lpSrc;
    pbDst = lpDst;

    if (lpbiSrc->biClrUsed == 0 && lpbiSrc->biBitCount <= 8)
        lpbiSrc->biClrUsed = (1 << (int)lpbiSrc->biBitCount);

    pal.palVersion = 0x300;
    pal.palNumEntries = (int)lpbiSrc->biClrUsed;

    for (i=0; i<(int)pal.palNumEntries; i++)
    {
        pal.palPalEntry[i].peRed   = ((LPRGBQUAD)(lpbiSrc+1))[i].rgbRed;
        pal.palPalEntry[i].peGreen = ((LPRGBQUAD)(lpbiSrc+1))[i].rgbGreen;
        pal.palPalEntry[i].peBlue  = ((LPRGBQUAD)(lpbiSrc+1))[i].rgbBlue;
        pal.palPalEntry[i].peFlags = 0;
    }

    if (lpbiDst->biBitCount == 8)
        _fmemcpy(lpbiDst+1,lpbiSrc+1,(int)lpbiSrc->biClrUsed*sizeof(RGBQUAD));

    if ((int)lpbiDst->biBitCount == (int)lpbiSrc->biBitCount)
    {
        switch((int)lpbiSrc->biBitCount)
        {
        case 8:
            for (y=0; y<dy; y+=2)
            {
                pb = pbDst;

                for (x=0; x<dx; x+=2)
                {
                    b0 = Pel8(pbSrc,x);
                    b1 = Pel8(pbSrc+WidthBytesSrc, x);
                    b2 = Pel8(pbSrc,x+1);
                    b3 = Pel8(pbSrc+WidthBytesSrc,x+1);

                    r = (BYTE) ((
                        (WORD)pal.palPalEntry[b0].peRed +
                        (WORD)pal.palPalEntry[b1].peRed +
                        (WORD)pal.palPalEntry[b2].peRed +
                        (WORD)pal.palPalEntry[b3].peRed) >> 2);

                    g = (BYTE) ((
                        (WORD)pal.palPalEntry[b0].peGreen +
                        (WORD)pal.palPalEntry[b1].peGreen +
                        (WORD)pal.palPalEntry[b2].peGreen +
                        (WORD)pal.palPalEntry[b3].peGreen) >> 2);

                    b = (BYTE) ((
                        (WORD)pal.palPalEntry[b0].peBlue +
                        (WORD)pal.palPalEntry[b1].peBlue +
                        (WORD)pal.palPalEntry[b2].peBlue +
                        (WORD)pal.palPalEntry[b3].peBlue) >> 2);

                    *pb++ = (BYTE)(*(lpia->lpInverseMap +
                                RGB16 (r, g, b)));
                }

                pbSrc += WidthBytesSrc*2;
                pbDst += WidthBytesDst;
            }
            break;

        case 16:
            for (y=0; y<dy; y+=2)
            {
                pw = (HPWORD)pbDst;

		for (x=0; x<dx; x += 2)
                {
                    w0 = Pel16(pbSrc,x);
                    w1 = Pel16(pbSrc,x+1);
                    w2 = Pel16(pbSrc+WidthBytesSrc,x);
                    w3 = Pel16(pbSrc+WidthBytesSrc,x+1);

                    r = ((BYTE)RGB16r(w0) + RGB16r(w1) + RGB16r(w2) + RGB16r(w3)) >> 2;
                    g = ((BYTE)RGB16g(w0) + RGB16g(w1) + RGB16g(w2) + RGB16g(w3)) >> 2;
                    b = ((BYTE)RGB16b(w0) + RGB16b(w1) + RGB16b(w2) + RGB16b(w3)) >> 2;

                    *pw++ = rgb16(r,g,b);
                }

                pbSrc += WidthBytesSrc*2;
                pbDst += WidthBytesDst;
            }
            break;

        case 24:
            for (y=0; y<dy; y+=2)
            {
                pb = pbDst;

		for (x=0; x<dx; x += 2)
                {
                    rgb0 = Pel24(pbSrc,x);
                    rgb1 = Pel24(pbSrc,x+1);
                    rgb2 = Pel24(pbSrc+WidthBytesSrc,x);
                    rgb3 = Pel24(pbSrc+WidthBytesSrc,x+1);

                    rgb = RGB(
                        ((UINT)rgb0.r + rgb1.r + rgb2.r + rgb3.r)/4,
                        ((UINT)rgb0.g + rgb1.g + rgb2.g + rgb3.g)/4,
                        ((UINT)rgb0.b + rgb1.b + rgb2.b + rgb3.b)/4);

                    *pb++ = GetBValue(rgb);
                    *pb++ = GetGValue(rgb);
                    *pb++ = GetRValue(rgb);
                }

                pbSrc += WidthBytesSrc*2;
                pbDst += WidthBytesDst;
            }
            break;

        case 32:
            for (y=0; y<dy; y+=2)
            {
                pb = pbDst;

		for (x=0; x<dx; x += 2)
                {
                    rgb0 = Pel24(pbSrc,x);
                    rgb1 = Pel24(pbSrc,x+1);
                    rgb2 = Pel24(pbSrc+WidthBytesSrc,x);
                    rgb3 = Pel24(pbSrc+WidthBytesSrc,x+1);

                    rgb = RGB(
                        ((UINT)rgb0.r + rgb1.r + rgb2.r + rgb3.r)/4,
                        ((UINT)rgb0.g + rgb1.g + rgb2.g + rgb3.g)/4,
                        ((UINT)rgb0.b + rgb1.b + rgb2.b + rgb3.b)/4);

                    *pb++ = GetBValue(rgb);
                    *pb++ = GetGValue(rgb);
                    *pb++ = GetRValue(rgb);
                    pb++;
                }

                pbSrc += WidthBytesSrc*2;
                pbDst += WidthBytesDst;
            }
            break;

        default:
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\mmdebug.h ===
/*
 * johnkn's debug logging and assert macros
 *
 */
 
#if !defined _INC_MMDEBUG_
#define _INC_MMDEBUG_
//
// prototypes for debug functions.
//
    #define SQUAWKNUMZ(num) #num
    #define SQUAWKNUM(num) SQUAWKNUMZ(num)
    #define SQUAWK __FILE__ "(" SQUAWKNUM(__LINE__) ") ----"
    #define DEBUGLINE __FILE__ "(" SQUAWKNUM(__LINE__) ") "
        
    #if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL

        int  FAR _cdecl AuxDebugEx(int, LPTSTR, ...);
        VOID WINAPI AuxDebugDump (int, LPVOID, int);
        int  WINAPI DebugSetOutputLevel (int);

       #if defined DEBUG_RETAIL
        #define INLINE_BREAK
       #else
        #define INLINE_BREAK _asm {int 3}
       #endif

       #if 0
        #undef  assert
        #define assert(exp) \
            (void)((exp) ? 0 : AuxDebugEx(-2, DEBUGLINE "assert failed: " #exp "\r\n", (int)__LINE__))

        #undef  assert2
        #define assert2(exp,sz) \
            (void)((exp) ? 0 : AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (int)__LINE__))
       #else
        #undef  assert
        #define assert(exp); {\
            if (!(exp)) {\
                AuxDebugEx(-2, DEBUGLINE "assert failed: " #exp "\r\n", (int)__LINE__); \
                INLINE_BREAK;\
                }\
            }
        #undef  assert2
        #define assert2(exp,sz); {\
            if (!(exp)) {\
                AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (int)__LINE__); \
                INLINE_BREAK;\
                }\
            }
        #undef  assert3
        #define assert3(exp,sz,arg); {\
            if (!(exp)) {\
                AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (int)__LINE__, (arg)); \
                INLINE_BREAK;\
                }\
            }
       #endif

      #define STATICFN

    #else // defined(DEBUG)
                      
      #define AuxDebugEx  1 ? (void)0 : (void)
      #define AuxDebugDump(a,b,c)
      
      #define assert(a)      ((void)0)
      #define assert2(a,b)   ((void)0)
      #define assert3(a,b,c) ((void)0)

      #define INLINE_BREAK
      #define DebugSetOutputLevel(i)
      #define STATICFN static

   #endif // defined(DEBUG)
   
   #define AuxDebug(sz) AuxDebugEx (1, DEBUGLINE sz "\r\n")
   #define AuxDebug2(sz,a) AuxDebugEx (1, DEBUGLINE sz "\r\n", (a))
   
#endif //_INC_MMDEBUG_

// =============================================================================

//
// include this in only one module in a DLL or APP
//   
#if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL
    #if (defined _INC_MMDEBUG_CODE_) && (_INC_MMDEBUG_CODE_ != FALSE)
    #undef _INC_MMDEBUG_CODE_
    #define _INC_MMDEBUG_CODE_ FALSE
       
    #include <stdarg.h>

    #if !defined WIN32 && !defined wvsprintfA
     #define wvsprintfA wvsprintf
    #endif

    int    debug_OutputOn = 0;

    /*+ AuxDebug - create a formatted string and output to debug terminal
     *
     *-=================================================================*/
    
    int FAR _cdecl AuxDebugEx (
       int    iLevel,
       LPTSTR lpFormat,
       ...)
       {
       char     szBuf[1024];
       int      cb;
       va_list  va;

       if (debug_OutputOn >= iLevel)
          {
          va_start (va, lpFormat);
          cb = wvsprintfA (szBuf, lpFormat, va);
          va_end (va);
          OutputDebugString (szBuf);
          }
    
       return cb;
       }

    /*+ AuxDebugDump -
     *
     *-=================================================================*/
    
    VOID WINAPI AuxDebugDump (
       int    iLevel,
       LPVOID lpvData,
       int    nCount)
       {
       LPBYTE   lpData = lpvData;
       char     szBuf[128];
       LPSTR    psz;
       int      cb;
       int      ix;
       BYTE     abRow[8];
                
       if (debug_OutputOn <= iLevel || nCount <= 0)
          return;

       do {
          cb = wsprintf (szBuf, "\t%08X: ", lpData);
          psz = szBuf + cb;

          for (ix = 0; ix < 8; ++ix)
             {
             LPBYTE lpb = lpData;

             abRow[ix] = '.';
             if (IsBadReadPtr (lpData + ix, 1))
                lstrcpy (psz, ".. ");
             else
                {
                wsprintf (psz, "%02X ", lpData[ix]);
                if (lpData[ix] >= 32 && lpData[ix] < 127)
                    abRow[ix] = lpData[ix];
                }
             psz += 3;
             }
          for (ix = 0; ix < 8; ++ix)
             *psz++ = abRow[ix];

          lstrcpy (psz, "\r\n");

          OutputDebugString (szBuf);

          } while (lpData += 8, (nCount -= 8) > 0);

       return;
       }
       
    /*+ DebugSetOutputLevel
     *
     *-=================================================================*/
    
    BOOL  WINAPI DebugSetOutputLevel (
        int nLevel)
        {      
        int nOldLevel = debug_OutputOn;
        debug_OutputOn = nLevel;
        return nOldLevel;
        }
    
    #endif // _INC_MMDEBUG_CODE_
#endif // DEBUG || _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\thunk.h ===
/****************************************************************************
 *
 *   thunk.h
 * 
 *   macros, defines, prototypes for avicap 16:32 thunks
 *
 *   Copyright (c) 1994 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

typedef LPVOID P16VOID;
typedef DWORD  P32VOID;
//#define P16VOID LPVOID
//#define P32VOID DWORD

// thunk helpers exported from the kernel
//
DWORD WINAPI GetCurrentProcessID(void);  // KERNEL
DWORD WINAPI SetWin32Event(DWORD hEvent); // KERNEL

P16VOID  WINAPI MapLS(P32VOID);
P16VOID  WINAPI UnMapLS(P16VOID);
P32VOID  WINAPI MapSL(P16VOID);

// generated by thunk compiler from avicapf.thk
//
BOOL FAR PASCAL avicapf_ThunkConnect16 (
    LPCSTR    pszDll16,
    LPCSTR    pszDll32,
    HINSTANCE hinst,
    DWORD     dwReason);

// thunk helpers in thunka.asm
//
DWORD FAR PASCAL capTileBuffer (
    DWORD dwLinear,
    DWORD dwSize);

#define PTR_FROM_TILE(dwTile) (LPVOID)(dwTile & 0xFFFF0000)

void  FAR PASCAL capUnTileBuffer (
    DWORD dwTileInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\muldiv32.asm ===
page    ,132
;---------------------------Module-Header-------------------------------;
; Module Name: MATH.ASM
;
; Contains FIXED point math routines.
;
; Created:  Sun 30-Aug-1987 19:28:30
; Author: Charles Whitmer [chuckwh]
;
; Copyright (c) 1987  Microsoft Corporation
;-----------------------------------------------------------------------;

?WIN	= 0
?PLM	= 1
?NODATA = 0

        .286

        .xlist
        include cmacros.inc
        include windows.inc
        .list

        externA __WinFlags

UQUAD   struc
uq0     dw      ?
uq1     dw      ?
uq2     dw      ?
uq3     dw      ?
UQUAD	ends

;       The following two equates are just used as shorthand
;       for the "word ptr" and "byte ptr" overrides.

wptr    equ     word ptr
bptr    equ     byte ptr

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

EAXtoDXAX   macro
        shld    edx,eax,16      ; move HIWORD(eax) to dx
        endm

DXAXtoEAX   macro
        ror     eax,16          ; xchg HIWORD(eax) and LOWORD(eax)
        shrd    eax,edx,16      ; move LOWORD(edx) to HIWORD(eax)
        endm

neg32       macro hi, lo
        neg lo
        adc hi,0                ; carry set unless lo zero
        neg hi
        endm

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes cs,CodeSeg
	assumes ds,nothing
        assumes es,nothing

;---------------------------Public-Routine------------------------------;
; long muldiv32(long, long, long)
;
; multiples two 32 bit values and then divides the result by a third
; 32 bit value with full 64 bit presision
;
; lResult = (lNumber * lNumerator) / lDenominator with correct rounding
;
; Entry:
;       lNumber = number to multiply by nNumerator
;       lNumerator = number to multiply by nNumber
;       lDenominator = number to divide the multiplication result by.
;   
; Returns:
;       DX:AX = result of multiplication and division.
;
; Error Returns:
;       none
; Registers Preserved:
;       DS,ES,SI,DI
; History:
;   Fri 05-Oct-1990 -by- Rob Williams [Robwi] 
;   Behavior consistent with MulDiv16 routine (signed, no int 0 on overflow)
;   Stole muldiv16 psuedocode
;
;   Wed 14-June-1990 -by-  Todd Laney [ToddLa]
;   converted it to 386/286 code. (by checking __WinFlags)
;
;   Tue 08-May-1990 -by-  Rob Williams [Robwi]
;   Wrote it.
;
;----------------------------Pseudo-Code--------------------------------;
; long FAR PASCAL muldiv32(long, long, long)
; long l;
; long Numer;
; long Denom;
; {
;
;   Sign = sign of Denom;   // Sign will keep track of final sign //
;
;
;   if (Denom < 0)
;   {
;	negate Denom;	// make sure Denom is positive //
;   }
;
;   if (l < 0)
;   {
;	negate l;	// make sure l is positive //
;   }
;
;   make Sign reflect any sign change;
;
;
;   if (Numer < 0)
;   {
;	negate Numer;	// make sure Numer is positive //
;   }
;
;   make Sign reflect any sign change;
;
;   Numer *= l;
;   Numer += (Denom/2); // adjust for rounding //
;
;   if (overflow)   // check for overflow, and handle divide by zero //
;   {
;	jump to md5;
;   }
;
;   result = Numer/Denom;
;
;   if (overflow)   // check again to see if overflow occured //
;   {
;	jump to md5;
;   }
;
;   if (Sign is negative)   // put sign on the result //
;   {
;	negate result;
;   }
;
;md6:
;   return(result);
;
;md5:
;   DX = 7FFF;	    // indicate overflow by //
;   AX = 0xFFFF     // return largest integer //
;   if (Sign is negative)
;   {
;	DX = 0x8000;	// with correct sign //
;	AX = 0x0000;	
;   }
;
;   jump to md6;
; }
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   muldiv32,<PUBLIC,FAR,NODATA,NONWIN>,<>
;       ParmD  lNumber
;       ParmD  lNumerator
;       ParmD  lDenominator
cBegin	<nogen>
	mov	ax,__WinFlags
        test    ax,WF_CPU286+WF_CPU086+WF_CPU186
        jz      md32_1
        jmp     NEAR PTR muldiv32_286
md32_1:
        errn$   muldiv32_386
cEnd    <nogen>

cProc   muldiv32_386,<PUBLIC,FAR,NODATA,NONWIN>,<>
        ParmD   lNumber
        ParmD   lNumerator
        ParmD   lDenominator
cBegin
        .386


        mov     ebx,lDenominator    ; get the demoninator
        mov     ecx,ebx	            ; ECX holds the final sign in hiword
        or      ebx,ebx             ; ensure the denominator is positive
        jns     md386_1
        neg     ebx

md386_1:
        mov     eax,lNumber         ; get the long we are multiplying
        xor     ecx,eax	            ; make ECX reflect any sign change
        or      eax,eax             ; ensure the long is positive
        jns     md386_2
        neg     eax

md386_2:
        mov     edx,lNumerator      ; get the numerator
        xor     ecx,edx	            ; make ECX reflect any sign change
        or      edx,edx             ; ensure the numerator is positive
        jns     md386_3
        neg     edx

md386_3:
        mul     edx                 ; multiply
        mov     cx,bx               ; get half of the demoninator to adjust for rounding
        sar     ebx,1               
        add     eax,ebx             ; adjust for possible rounding error
        adc     edx,0               ; this is really a long addition
        sal     ebx,1               ; restore the demoninator
        or      bx,cx               ; fix bottom bit
        cmp     edx,ebx             ; check for overflow
        jae     md386_5                 ; (ae handles /0 case)
        div     ebx                 ; divide
        or      eax,eax             ; If sign is set, then overflow occured
        js      md386_5                 ; Overflow.
        or      ecx,ecx             ; put the sign on the result
        jns     md386_6
        neg     eax

md386_6:
        EAXtoDXAX                   ; convert eax to dx:ax for 16 bit programs

        .286
cEnd 
        .386

md386_5:
        mov     eax,7FFFFFFFh       ; return the largest integer
        or      ecx,ecx             ; with the correct sign
        jns     md386_6
        not     eax
        jmp     md386_6

        .286

cProc   muldiv32_286,<PUBLIC,FAR,NODATA,NONWIN>,<di,si>
        ParmD  lNumber             
        ParmD  lNumerator
        ParmD  lDenominator
        LocalW wSign

cBegin

        mov     dx,lDenominator.hi      ; get the demoninator
        mov     si,dx	                ; SI holds the final sign 
        or      dx,dx                   ; ensure the denominator is positive
        jns     md286_1
        neg32   dx, lDenominator.lo
        mov     lDenominator.hi, dx


md286_1:
        mov     ax,lNumber.lo           ; get the long we are multiplying
        mov     dx,lNumber.hi           
        xor     si,dx	                ; make ECX reflect any sign change
        or      dx,dx                   ; ensure the long is positive
        jns     md286_2
        neg32   dx, ax

md286_2:
        mov     bx,lNumerator.lo        ; get the numerator
        mov     cx,lNumerator.hi        ; get the numerator
        xor     si,cx	                ; make ECX reflect any sign change
        or      cx,cx                   ; ensure the numerator is positive
        jns     md286_3
        neg32   cx, bx

md286_3:
        mov     wSign, si               ; save sign
        call    dmul                    ; multiply (result in dx:cx:bx:ax)
        mov     si, lDenominator.hi
        mov     di, lDenominator.lo
        sar     si, 1                   ; get half of the demoninator 
        rcr     di, 1                   ; to adjust for rounding
        add     ax, di                  ; adjust for possible rounding error
        adc     bx, si
        adc     cx, 0
        adc     dx, 0                   ; this is really a long addition

        sal     di, 1                   ; restore the demoninator
        rcl     si, 1

        or      di, lDenominator.lo     ; fix bottom bit

        cmp     dx, si                  ; begin overflow check (unsigned for div 0 check)
        ja      md286_5                 ; overflow
        jb      md286_7                 ; no overflow
        cmp     cx, di       
        jae     md286_5                 ; overflow

md286_7:
        call    qdiv                    ; DX:AX is quotient     
        or      dx,dx                   ; If sign is set, then overflow occured
        js      md286_5                 ; Overflow.
        mov     cx, wSign
        or      cx,cx                   ; put the sign on the result
        jns     md286_6
        neg32   dx,ax

md286_6:

cEnd

md286_5:
        mov     cx, wSign
        mov     ax, 0FFFFh              ; return the largest integer
        mov     dx, 7FFFh
        or      cx, cx                  ; with the correct sign
        jns     md286_6
        not     dx
        not     ax
        jmp     md286_6


;---------------------------Public-Routine------------------------------;
; idmul
;
; This is an extended precision multiply routine, intended to emulate
; 80386 imul instruction.
;
; Entry:
;       DX:AX = LONG
;       CX:BX = LONG
; Returns:
;       DX:CX:BX:AX = QUAD product
; Registers Destroyed:
;       none
; History:
;  Tue 26-Jan-1988 23:47:02  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   idmul,<PUBLIC,NEAR>,<si,di>
        localQ  qTemp
cBegin

; put one argument in safe registers

        mov     si,dx
        mov     di,ax

; do the low order unsigned product

        mul     bx
        mov     qTemp.uq0,ax
        mov     qTemp.uq1,dx

; do the high order signed product

        mov     ax,si
        imul    cx
        mov     qTemp.uq2,ax
        mov     qTemp.uq3,dx

; do a mixed product

        mov     ax,si
        cwd
        and     dx,bx
        sub     qTemp.uq2,dx            ; adjust for sign bit
        sbb     qTemp.uq3,0
        mul     bx
        add     qTemp.uq1,ax
        adc     qTemp.uq2,dx
        adc     qTemp.uq3,0

; do the other mixed product

        mov     ax,cx
        cwd
	and	dx,di
        sub     qTemp.uq2,dx
        sbb     qTemp.uq3,0
        mul     di

; pick up the answer

        mov     bx,ax
        mov     cx,dx
        xor     dx,dx

        mov     ax,qTemp.uq0
        add     bx,qTemp.uq1
        adc     cx,qTemp.uq2
        adc     dx,qTemp.uq3
cEnd

;---------------------------Public-Routine------------------------------;
; dmul
;
; This is an extended precision multiply routine, intended to emulate
; 80386 mul instruction.
;
; Entry:
;       DX:AX = LONG
;       CX:BX = LONG
; Returns:
;       DX:CX:BX:AX = QUAD product
; Registers Destroyed:
;       none
; History:
;  Tue 02-Feb-1988 10:50:44  -by-  Charles Whitmer [chuckwh]
; Copied from idmul and modified.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   dmul,<PUBLIC,NEAR>,<si,di>
        localQ  qTemp
cBegin

; put one argument in safe registers

        mov     si,dx
        mov     di,ax

; do the low order product

        mul     bx
        mov     qTemp.uq0,ax
        mov     qTemp.uq1,dx

; do the high order product

        mov     ax,si
        mul     cx
        mov     qTemp.uq2,ax
        mov     qTemp.uq3,dx

; do a mixed product

        mov     ax,si
        mul     bx
        add     qTemp.uq1,ax
        adc     qTemp.uq2,dx
        adc     qTemp.uq3,0

; do the other mixed product

        mov     ax,cx
        mul     di

; pick up the answer

        mov     bx,ax
        mov     cx,dx
        xor     dx,dx
        mov     ax,qTemp.uq0
        add     bx,qTemp.uq1
        adc     cx,qTemp.uq2
        adc     dx,qTemp.uq3
cEnd

;---------------------------Public-Routine------------------------------;
; iqdiv
;
; This is an extended precision divide routine which is intended to
; emulate the 80386 64 bit/32 bit IDIV instruction.  We don't have the
; 32 bit registers to work with, but we pack the arguments and results
; into what registers we do have.  We will divide two signed numbers
; and return the quotient and remainder.  We will do INT 0 for overflow,
; just like the 80386 microcode.  This should ease conversion later.
;
; This routine just keeps track of the signs and calls qdiv to do the
; real work.
;
; Entry:
;       DX:CX:BX:AX = QUAD Numerator
;       SI:DI       = LONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder
; Registers Destroyed:
;       DI,SI
; History:
;  Tue 26-Jan-1988 02:49:19  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;

WIMP    equ     1

IQDIV_RESULT_SIGN       equ     1
IQDIV_REM_SIGN          equ     2

        assumes ds,nothing
        assumes es,nothing

cProc   iqdiv,<PUBLIC,NEAR>
        localB  flags
cBegin
        mov     flags,0

; take the absolute value of the denominator

        or      si,si
        jns     denominator_is_cool
        xor     flags,IQDIV_RESULT_SIGN
        neg     di
        adc     si,0
        neg     si
denominator_is_cool:

; take the absolute value of the denominator

        or      dx,dx
        jns     numerator_is_cool
        xor     flags,IQDIV_RESULT_SIGN + IQDIV_REM_SIGN
        not     ax
        not     bx
        not     cx
        not     dx
        add     ax,1
        adc     bx,0
        adc     cx,0
        adc     dx,0
numerator_is_cool:

; do the unsigned division

        call    qdiv
ifdef WIMP
        jo      iqdiv_exit
endif

; check for overflow

        or      dx,dx
        jns     have_a_bit_to_spare
ifdef WIMP
        mov     ax,8000h
        dec     ah
        jmp     short iqdiv_exit
else
        int     0                       ; You're toast, Jack!
endif
have_a_bit_to_spare:

; negate the result, if required

        test    flags,IQDIV_RESULT_SIGN
        jz      result_is_done
        neg     ax
        adc     dx,0
        neg     dx
result_is_done:

; negate the remainder, if required

        test    flags,IQDIV_REM_SIGN
        jz      remainder_is_done
        neg     bx
        adc     cx,0
        neg     cx
remainder_is_done:
iqdiv_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; qdiv
;
; This is an extended precision divide routine which is intended to
; emulate the 80386 64 bit/32 bit DIV instruction.  We don't have the
; 32 bit registers to work with, but we pack the arguments and results
; into what registers we do have.  We will divide two unsigned numbers
; and return the quotient and remainder.  We will do INT 0 for overflow,
; just like the 80386 microcode.  This should ease conversion later.
;
; Entry:
;       DX:CX:BX:AX = UQUAD Numerator
;       SI:DI       = ULONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder
; Registers Destroyed:
;       none
; History:
;  Tue 26-Jan-1988 00:02:09  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   qdiv,<PUBLIC,NEAR>,<si,di>
        localQ  uqNumerator
        localD  ulDenominator
        localD  ulQuotient
        localW  cShift
cBegin

; stuff the quad word into local memory

        mov     uqNumerator.uq0,ax
        mov     uqNumerator.uq1,bx
        mov     uqNumerator.uq2,cx
        mov     uqNumerator.uq3,dx


; check for overflow

qdiv_restart:
        cmp     si,dx
        ja      qdiv_no_overflow
        jb      qdiv_overflow
        cmp     di,cx
        ja      qdiv_no_overflow
qdiv_overflow:
ifdef WIMP
        mov     ax,8000h
        dec     ah
        jmp     qdiv_exit
else
        int     0                       ; You're toast, Jack!
        jmp     qdiv_restart
endif
qdiv_no_overflow:

; check for a zero Numerator

        or      ax,bx
        or      ax,cx
        or      ax,dx
        jz      qdiv_exit_relay         ; quotient = remainder = 0

; handle the special case when the denominator lives in the low word

        or      si,si
        jnz     not_that_special

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=0):DI

        cmp     di,1                    ; separate out the trivial case
        jz      div_by_one
        xchg    dx,cx                   ; CX = remainder.hi = 0
        mov     ax,bx
        div     di
        mov     bx,ax                   ; BX = quotient.hi
        mov     ax,uqNumerator.uq0
        div     di                      ; AX = quotient.lo
        xchg    bx,dx                   ; DX = quotient.hi, BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit_relay:
        jmp     qdiv_exit

; calculate (DX=0):(CX=0):BX:uqNumerator.uq0 / (SI=0):(DI=1)

div_by_one:
        xchg    dx,bx                   ; DX = quotient.hi, BX = remainder.lo = 0
        mov     ax,uqNumerator.uq0      ; AX = quotient.lo
        jmp     qdiv_exit
not_that_special:

; handle the special case when the denominator lives in the high word

        or      di,di
        jnz     not_this_special_either

; calculate DX:CX:BX:uqNumerator.uq0 / SI:(DI=0)

        cmp     si,1                    ; separate out the trivial case
        jz      div_by_10000h
        mov     ax,cx
        div     si
        mov     cx,ax                   ; CX = quotient.hi
        mov     ax,bx
        div     si                      ; AX = quotient.lo
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
        jmp     qdiv_exit

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=1):(DI=0)

div_by_10000h:
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi = 0
        mov     ax,bx                   ; AX = quotient.lo
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
        jmp     qdiv_exit
not_this_special_either:

; normalize the denominator

        mov     dx,si
        mov     ax,di
        call    ulNormalize             ; DX:AX = normalized denominator
        mov     cShift,cx               ; CX < 16
        mov     ulDenominator.lo,ax
        mov     ulDenominator.hi,dx


; shift the Numerator by the same amount

        jcxz    numerator_is_shifted
        mov     si,-1
        shl     si,cl
        not     si                      ; SI = mask
        mov     bx,uqNumerator.uq3
        shl     bx,cl
        mov     ax,uqNumerator.uq2
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq3,bx
        xor     ax,di
        mov     bx,uqNumerator.uq1
        rol     bx,cl
        mov     di,si
        and     di,bx
        or      ax,di
        mov     uqNumerator.uq2,ax
        xor     bx,di
        mov     ax,uqNumerator.uq0
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq1,bx
        xor     ax,di
        mov     uqNumerator.uq0,ax
numerator_is_shifted:

; set up registers for division

        mov     dx,uqNumerator.uq3
        mov     ax,uqNumerator.uq2
        mov     di,uqNumerator.uq1
        mov     cx,ulDenominator.hi
        mov     bx,ulDenominator.lo

; check for case when Denominator has only 16 bits

        or      bx,bx
        jnz     must_do_long_division
        div     cx
        mov     si,ax
        mov     ax,uqNumerator.uq1
        div     cx
        xchg    si,dx                   ; DX:AX = quotient
        mov     di,uqNumerator.uq0      ; SI:DI = remainder (shifted)
        jmp     short unshift_remainder
must_do_long_division:

; do the long division, part IZ@NL@%

        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      first_division_is_safe
        mov     ulQuotient.hi,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short first_adjuster
first_division_is_safe:
        div     cx
        mov     ulQuotient.hi,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     first_adjuster_done     ; The remainder is UNSIGNED!  We have
first_adjuster:                         ; to use the carry flag to keep track
        dec     ulQuotient.hi           ; of the sign.  The adjuster loop
        add     di,bx                   ; watches for a change to the carry
        adc     si,cx                   ; flag which would indicate a sign
        jnc     first_adjuster          ; change IF we had more bits to keep
first_adjuster_done:                    ; a sign in.

; do the long division, part II

        mov     dx,si
        mov     ax,di
        mov     di,uqNumerator.uq0
        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      second_division_is_safe
        mov     ulQuotient.lo,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short second_adjuster
second_division_is_safe:
        div     cx
        mov     ulQuotient.lo,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     second_adjuster_done
second_adjuster:
        dec     ulQuotient.lo
        add     di,bx
        adc     si,cx
        jnc     second_adjuster
second_adjuster_done:
        mov     ax,ulQuotient.lo
        mov     dx,ulQuotient.hi

; unshift the remainder in SI:DI

unshift_remainder:
        mov     cx,cShift
        jcxz    remainder_unshifted
        mov     bx,-1
        shr     bx,cl
        not     bx
        shr     di,cl
        ror     si,cl
        and     bx,si
        or      di,bx
        xor     si,bx
remainder_unshifted:
        mov     cx,si
        mov     bx,di
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; ulNormalize
;
; Normalizes a ULONG so that the highest order bit is 1.  Returns the
; number of shifts done.  Also returns ZF=1 if the ULONG was zero.
;
; Entry:
;       DX:AX = ULONG
; Returns:
;       DX:AX = normalized ULONG
;       CX    = shift count
;       ZF    = 1 if the ULONG is zero, 0 otherwise
; Registers Destroyed:
;       none
; History:
;  Mon 25-Jan-1988 22:07:03  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   ulNormalize,<PUBLIC,NEAR>
cBegin

; shift by words

        xor     cx,cx
        or      dx,dx
        js      ulNormalize_exit
        jnz     top_word_ok
        xchg    ax,dx
        or      dx,dx
        jz      ulNormalize_exit        ; the zero exit
        mov     cl,16
        js      ulNormalize_exit
top_word_ok:

; shift by bytes

        or      dh,dh
        jnz     top_byte_ok
        xchg    dh,dl
        xchg    dl,ah
        xchg    ah,al
        add     cl,8
        or      dh,dh
        js      ulNormalize_exit
top_byte_ok:

; do the rest by bits

        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
ulNormalize_exit:
cEnd

sEnd   CodeSeg

       end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.16\msvideo.h ===
/****************************************************************************/
/*                                                                          */
/*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY   */
/*  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE     */
/*  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR   */
/*  PURPOSE.								    */
/*        MSVIDEO.H - Include file for Video APIs                           */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1993, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MSVIDEO
#define _INC_MSVIDEO	50	/* version number */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef _RCINVOKED

#ifdef BUILDDLL                         /* ;Internal */
#undef WINAPI                           /* ;Internal */
#define WINAPI FAR PASCAL _loadds       /* ;Internal */
#endif                                  /* ;Internal */

/* video data types */
DECLARE_HANDLE(HVIDEO);                 // generic handle
typedef HVIDEO FAR * LPHVIDEO;
#endif                                  // ifndef RCINVOKED

/****************************************************************************

                        version api

****************************************************************************/

DWORD FAR PASCAL VideoForWindowsVersion(void);

/****************************************************************************

                            Error Return Values

****************************************************************************/
#define DV_ERR_OK               (0)                  /* No error */
#define DV_ERR_BASE             (1)                  /* Error Base */
#define DV_ERR_NONSPECIFIC      (DV_ERR_BASE)
#define DV_ERR_BADFORMAT        (DV_ERR_BASE + 1)
				/* unsupported video format */
#define DV_ERR_STILLPLAYING     (DV_ERR_BASE + 2)
				/* still something playing */
#define DV_ERR_UNPREPARED       (DV_ERR_BASE + 3)
				/* header not prepared */
#define DV_ERR_SYNC             (DV_ERR_BASE + 4)
				/* device is synchronous */
#define DV_ERR_TOOMANYCHANNELS  (DV_ERR_BASE + 5)
				/* number of channels exceeded */
#define DV_ERR_NOTDETECTED	(DV_ERR_BASE + 6)    /* HW not detected */
#define DV_ERR_BADINSTALL	(DV_ERR_BASE + 7)    /* Can not get Profile */
#define DV_ERR_CREATEPALETTE	(DV_ERR_BASE + 8)
#define DV_ERR_SIZEFIELD	(DV_ERR_BASE + 9)
#define DV_ERR_PARAM1		(DV_ERR_BASE + 10)
#define DV_ERR_PARAM2		(DV_ERR_BASE + 11)
#define DV_ERR_CONFIG1		(DV_ERR_BASE + 12)
#define DV_ERR_CONFIG2		(DV_ERR_BASE + 13)
#define DV_ERR_FLAGS		(DV_ERR_BASE + 14)
#define DV_ERR_13		(DV_ERR_BASE + 15)

#define DV_ERR_NOTSUPPORTED     (DV_ERR_BASE + 16)   /* function not suported */
#define DV_ERR_NOMEM            (DV_ERR_BASE + 17)   /* out of memory */
#define DV_ERR_ALLOCATED        (DV_ERR_BASE + 18)   /* device is allocated */
#define DV_ERR_BADDEVICEID      (DV_ERR_BASE + 19)
#define DV_ERR_INVALHANDLE      (DV_ERR_BASE + 20)
#define DV_ERR_BADERRNUM        (DV_ERR_BASE + 21)
#define DV_ERR_NO_BUFFERS       (DV_ERR_BASE + 22)   /* out of buffers */

#define DV_ERR_MEM_CONFLICT     (DV_ERR_BASE + 23)   /* Mem conflict detected */
#define DV_ERR_IO_CONFLICT      (DV_ERR_BASE + 24)   /* I/O conflict detected */
#define DV_ERR_DMA_CONFLICT     (DV_ERR_BASE + 25)   /* DMA conflict detected */
#define DV_ERR_INT_CONFLICT     (DV_ERR_BASE + 26)   /* Interrupt conflict detected */
#define DV_ERR_PROTECT_ONLY     (DV_ERR_BASE + 27)   /* Can not run in standard mode */
#define DV_ERR_LASTERROR        (DV_ERR_BASE + 27)

#define DV_ERR_USER_MSG         (DV_ERR_BASE + 1000) /* Hardware specific errors */

/****************************************************************************

                         Callback Messages

Note that the values for all installable driver callback messages are
identical, (ie. MM_DRVM_DATA has the same value for capture drivers,
installable video codecs, and the audio compression manager).
****************************************************************************/
#ifndef _RCINVOKED

#ifndef MM_DRVM_OPEN
#define MM_DRVM_OPEN       0x3D0
#define MM_DRVM_CLOSE      0x3D1
#define MM_DRVM_DATA       0x3D2
#define MM_DRVM_ERROR      0x3D3
#endif

#define DV_VM_OPEN         MM_DRVM_OPEN         // Obsolete messages
#define DV_VM_CLOSE        MM_DRVM_CLOSE
#define DV_VM_DATA         MM_DRVM_DATA
#define DV_VM_ERROR        MM_DRVM_ERROR

/****************************************************************************

                         Structures

****************************************************************************/
/* video data block header */
typedef struct videohdr_tag {
    LPBYTE      lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* Length of data buffer */
    DWORD       dwBytesUsed;            /* Bytes actually used */
    DWORD       dwTimeCaptured;         /* Milliseconds from start of stream */
    DWORD       dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD       dwReserved[4];          /* reserved for driver */
} VIDEOHDR, NEAR *PVIDEOHDR, FAR * LPVIDEOHDR;

/* dwFlags field of VIDEOHDR */
#define VHDR_DONE       0x00000001  /* Done bit */
#define VHDR_PREPARED   0x00000002  /* Set if this header has been prepared */
#define VHDR_INQUEUE    0x00000004  /* Reserved for driver */
#define VHDR_KEYFRAME   0x00000008  /* Key Frame */
#define VHDR_VALID      0x0000000F  /* valid flags */     /* ;Internal */

/* Channel capabilities structure */
typedef struct channel_caps_tag {
    DWORD       dwFlags;                /* Capability flags*/
    DWORD       dwSrcRectXMod;          /* Granularity of src rect in x */
    DWORD       dwSrcRectYMod;          /* Granularity of src rect in y */
    DWORD       dwSrcRectWidthMod;      /* Granularity of src rect width */
    DWORD       dwSrcRectHeightMod;     /* Granularity of src rect height */
    DWORD       dwDstRectXMod;          /* Granularity of dst rect in x */
    DWORD       dwDstRectYMod;          /* Granularity of dst rect in y */
    DWORD       dwDstRectWidthMod;      /* Granularity of dst rect width */
    DWORD       dwDstRectHeightMod;     /* Granularity of dst rect height */
} CHANNEL_CAPS, NEAR *PCHANNEL_CAPS, FAR * LPCHANNEL_CAPS;

/* dwFlags of CHANNEL_CAPS */
#define VCAPS_OVERLAY       0x00000001      /* overlay channel */
#define VCAPS_SRC_CAN_CLIP  0x00000002      /* src rect can clip */
#define VCAPS_DST_CAN_CLIP  0x00000004      /* dst rect can clip */
#define VCAPS_CAN_SCALE     0x00000008      /* allows src != dst */

/****************************************************************************

                        video APIs

****************************************************************************/

DWORD WINAPI videoGetNumDevs(void);

DWORD WINAPI videoOpen  (LPHVIDEO lphVideo,
              DWORD dwDevice, DWORD dwFlags);
DWORD WINAPI videoClose (HVIDEO hVideo);
DWORD WINAPI videoDialog(HVIDEO hVideo, HWND hWndParent, DWORD dwFlags);
DWORD WINAPI videoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps,
                DWORD dwSize);
DWORD WINAPI videoUpdate (HVIDEO hVideo, HWND hWnd, HDC hDC);
DWORD WINAPI videoConfigure (HVIDEO hVideo, UINT msg, DWORD dwFlags,
		LPDWORD lpdwReturn, LPVOID lpData1, DWORD dwSize1,
                LPVOID lpData2, DWORD dwSize2);
DWORD WINAPI videoConfigureStorage (HVIDEO hVideo,
			LPSTR lpstrIdent, DWORD dwFlags);
DWORD WINAPI videoFrame(HVIDEO hVideo, LPVIDEOHDR lpVHdr);
DWORD WINAPI videoMessage(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2);

/* streaming APIs */
DWORD WINAPI videoStreamAddBuffer(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamGetError(HVIDEO hVideo, LPDWORD lpdwErrorFirst,
        LPDWORD lpdwErrorLast);
DWORD WINAPI videoGetErrorText(HVIDEO hVideo, UINT wError,
	        LPSTR lpText, UINT wSize);
DWORD WINAPI videoStreamGetPosition(HVIDEO hVideo, MMTIME FAR* lpInfo,
              DWORD dwSize);
DWORD WINAPI videoStreamInit(HVIDEO hVideo,
              DWORD dwMicroSecPerFrame, DWORD dwCallback,
              DWORD dwCallbackInst, DWORD dwFlags);
DWORD WINAPI videoStreamFini(HVIDEO hVideo);
DWORD WINAPI videoStreamPrepareHeader(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamReset(HVIDEO hVideo);
DWORD WINAPI videoStreamStart(HVIDEO hVideo);
DWORD WINAPI videoStreamStop(HVIDEO hVideo);
DWORD WINAPI videoStreamUnprepareHeader(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);

// for correct handling of capGetDriverDescription on NT and Chicago
DWORD WINAPI videoCapDriverDescAndVer (
        DWORD wDriverIndex,
        LPSTR lpszName, UINT cbName,
        LPSTR lpszVer, UINT cbVer);

/****************************************************************************

			API Flags

****************************************************************************/

// Types of channels to open with the videoOpen function
#define VIDEO_EXTERNALIN		0x0001
#define VIDEO_EXTERNALOUT		0x0002
#define VIDEO_IN			0x0004
#define VIDEO_OUT			0x0008

// Is a driver dialog available for this channel?
#define VIDEO_DLG_QUERY			0x0010

// videoConfigure (both GET and SET)
#define VIDEO_CONFIGURE_QUERY   	0x8000

// videoConfigure (SET only)
#define VIDEO_CONFIGURE_SET		0x1000

// videoConfigure (GET only)
#define VIDEO_CONFIGURE_GET		0x2000
#define VIDEO_CONFIGURE_QUERYSIZE	0x0001

#define VIDEO_CONFIGURE_CURRENT		0x0010
#define VIDEO_CONFIGURE_NOMINAL		0x0020
#define VIDEO_CONFIGURE_MIN		0x0040
#define VIDEO_CONFIGURE_MAX		0x0080


/****************************************************************************

			CONFIGURE MESSAGES

****************************************************************************/
#define DVM_USER                        0X4000

#define DVM_CONFIGURE_START		0x1000
#define DVM_CONFIGURE_END		0x1FFF

#define DVM_PALETTE			(DVM_CONFIGURE_START + 1)
#define DVM_FORMAT			(DVM_CONFIGURE_START + 2)
#define DVM_PALETTERGB555		(DVM_CONFIGURE_START + 3)
#define DVM_SRC_RECT    		(DVM_CONFIGURE_START + 4)
#define DVM_DST_RECT    		(DVM_CONFIGURE_START + 5)

#endif  /* ifndef _RCINVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDEO */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\capavi.c ===
/****************************************************************************
 *
 *   capavi.c
 *
 *   Main video capture module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include <vfw.h>
#include <mmreg.h>
#include <mmddk.h>

#include "ivideo32.h"
#include "mmdebug.h"

#ifdef USE_ACM
#include <msacm.h>
#endif

#include "avicapi.h"
#include "time.h"

// First, override the definition in media\inc\win32.h that causes strsafe to not work on Win64
#ifndef _X86_
#undef __inline
#endif // _X86_
// Then, include strsafe.h
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#define JMK_HACK_TIMERS    TRUE

#ifdef JMK_HACK_TIMERS
 #define _INC_MMTIMERS_CODE_ TRUE
 #define CLIPBOARDLOGSIZE 1000

 #ifndef MAKEFOURCC
  #define MAKEFOURCC(a,b,c,d) ((DWORD)(a) | ((DWORD)(b) << 8) | ((DWORD)(c) << 16) | ((DWORD)(d) << 24))
 #endif

 #define RIFFTYPE(dw) (((dw & 0xFF) << 24) | ((dw & 0xFF00) << 8) | ((dw & 0xFF0000) >> 8) | ((dw & 0xFF000000) >> 24))

 #include "mmtimers.h"

typedef struct _timerstuff {
     DWORD dwFrameTickTime;	// What we think the current frame time should be
     DWORD dwFrameStampTime;	// Stamped in the VIDEOHDR
     DWORD dwTimeWritten;       // Time WriteFile called
     DWORD dwTimeToWrite;       // Time WriteFile returned
     WORD  nFramesAppended;	// Accumulated appended dropped frames
     WORD  nDummyFrames;	// frames calc'ed as dropped
     DWORD dwVideoChunkCount;   // current 'frame'
     WORD  nAudioIndex;         // next audio buffer
     WORD  nVideoIndex;         // next video buffer
     BOOL  bPending;
     WORD  nSleepCount;
     DWORD dwSleepBegin;
     DWORD dwSleepEnd;
     };

 STATICDT PCTIMER  pctWriteBase;
 STATICDT struct _timerstuff * pCurTimerStuff;
 STATICDT struct _timerstuff * pTimerStuff;
 STATICDT HGLOBAL  hMemTimers;

 STATICDT struct _timerriff {
     FOURCC   fccRIFF;       // 'RIFF'
     DWORD    cbTotal;       // total (inclusive) size of riff data
     FOURCC   fccJMKD;       // 'JMKD' data type identifier
     DWORD    fccVCHD;       // 'VCHD' capture data header
     DWORD    cbVCHD;        // sizeof vchd data
     struct _vchd {
         DWORD            nPrio;
         DWORD            dwFramesCaptured;
         DWORD            dwFramesDropped;
         DWORD            dwDropFramesAppended;
         DWORD            dwDropFramesNotAppended;
         DWORD            dwTimerFrequency;
         DWORD            dwSpare[2];
         CAPTUREPARMS     cap;
         BITMAPINFOHEADER bmih;
         DWORD            nMaxVideoBuffers;
         struct _thkvideohdr {
             VIDEOHDR vh;
             LPBYTE   p32Buff;
             DWORD    p16Alloc;
             DWORD    dwMemHandle;
             DWORD    dwReserved;
             }            atvh[64];
         }    vchd;
     DWORD    fccChunk;      // chunk data type tag
     DWORD    cbChunk;       // non-inclusive size of chunk data
     } * pTimerRiff;

 STATICDT UINT nTimerIndex;
 STATICDT UINT nSleepCount;
#endif

#ifdef _DEBUG
    #define DSTATUS(lpcs, sz) statusUpdateStatus(lpcs, IDS_CAP_INFO, (LPTSTR) TEXT(sz))
#else
    #define DSTATUS(lpcs, sz)
#endif

// Allocate memory on a sector boundary

LPVOID FAR PASCAL AllocSectorAlignedMem (DWORD dwRequest, DWORD dwAlign)
{
    LPVOID pbuf;

    dwRequest = (DWORD) ROUNDUPTOSECTORSIZE (dwRequest, dwAlign) + dwAlign;      // round up to next page boundary

    pbuf = VirtualAlloc (NULL, dwRequest,
                        MEM_COMMIT | MEM_RESERVE,
                        PAGE_READWRITE);
    AuxDebugEx(4, DEBUGLINE "Allocated %d bytes of sector aligned memory at %8x\r\n", dwRequest, pbuf);
    return pbuf;
}

void FAR PASCAL FreeSectorAlignedMem (LPVOID pbuf)
{
   // the pointer we free had better be aligned on at least a 256 byte
   // boundary
   //
   assert (!((DWORD_PTR)pbuf & 255));
   VirtualFree ((LPVOID)((DWORD_PTR)pbuf & ~255), 0, MEM_RELEASE);
}

#define ONEMEG (1024L * 1024L)

DWORDLONG GetFreePhysicalMemory(void)
{
    MEMORYSTATUSEX ms;

	ms.dwLength = sizeof(ms);

    GlobalMemoryStatusEx(&ms);

    if (ms.ullTotalPhys > 8L * ONEMEG)
        return ms.ullTotalPhys - ONEMEG * 4;

    return(ms.ullTotalPhys /2);
}

// ****************************************************************
// ******************** Audio Buffer Control **********************
// ****************************************************************

// Audio buffers are always allocated under the presumption that
// audio capture may be enabled at any time.
// AVIAudioInit must be matched with AVIAudioFini (both only called once)
// AVIAudioPrepare must be matched with AVIAudioUnPrepare
//      (which may be called multiple times to enable and disable audio)


// AVI AudioInit - Allocate and initialize buffers for audio capture.
//                 This routine is also used by MCI capture.
//                 Returns: 0 on success, otherwise an error code.

UINT AVIAudioInit (LPCAPSTREAM lpcs)
{
    int		i;
    LPVOID      pHdr;
    LPVOID      p;

    if (lpcs->sCapParms.wNumAudioRequested == 0)
        lpcs->sCapParms.wNumAudioRequested = DEF_WAVE_BUFFERS;

    // .5 second of audio per buffer (or 10K, whichever is larger)
    if (lpcs->sCapParms.dwAudioBufferSize == 0)
        lpcs->dwWaveSize = CalcWaveBufferSize (lpcs);
    else {
        lpcs->dwWaveSize = 0;
        if (lpcs->lpWaveFormat)
            lpcs->dwWaveSize = lpcs->sCapParms.dwAudioBufferSize;
    }

    // Alloc the wave memory
    for(i = 0; i < (int)lpcs->sCapParms.wNumAudioRequested; i++) {

        pHdr = GlobalAllocPtr(GPTR, sizeof(WAVEHDR));

        if (pHdr == NULL)
            break;

        lpcs->alpWaveHdr[i] = pHdr;

        p = AllocSectorAlignedMem( sizeof(RIFF) + lpcs->dwWaveSize, lpcs->dwBytesPerSector);
        if (p == NULL) {
            GlobalFreePtr (pHdr);
            lpcs->alpWaveHdr[i] = NULL;
            break;
        }

        lpcs->alpWaveHdr[i]->lpData          = (LPBYTE)p + sizeof(RIFF);
        lpcs->alpWaveHdr[i]->dwBufferLength  = lpcs->dwWaveSize;
        lpcs->alpWaveHdr[i]->dwBytesRecorded = 0;
        lpcs->alpWaveHdr[i]->dwUser          = 0;
        lpcs->alpWaveHdr[i]->dwFlags         = 0;
        lpcs->alpWaveHdr[i]->dwLoops         = 0;

        ((LPRIFF)p)->dwType = MAKEAVICKID(cktypeWAVEbytes, 1);
        ((LPRIFF)p)->dwSize = lpcs->dwWaveSize;
    }

    lpcs->iNumAudio = i;

    return ((lpcs->iNumAudio == 0) ? IDS_CAP_WAVE_ALLOC_ERROR : 0);
}


//
// AVI AudioFini    - UnPrepares headers
//                      This routine is also used by MCI capture.
//                      Returns: 0 on success, otherwise an error code.

UINT AVIAudioFini (LPCAPSTREAM lpcs)
{
    int ii;

    /* free headers and data */
    for (ii=0; ii < MAX_WAVE_BUFFERS; ++ii) {
        if (lpcs->alpWaveHdr[ii]) {
            if (lpcs->alpWaveHdr[ii]->lpData)
                FreeSectorAlignedMem((LPBYTE)lpcs->alpWaveHdr[ii]->lpData - sizeof (RIFF));
            GlobalFreePtr(lpcs->alpWaveHdr[ii]);
            lpcs->alpWaveHdr[ii] = NULL;
        }
    }

    return 0;
}

//
// AVI AudioPrepare - Opens the wave device and adds the buffers
//                    Prepares headers and adds buffers to the device
//                    This routine is also used by MCI capture.
//                    Returns: 0 on success, otherwise an error code.

UINT AVIAudioPrepare (LPCAPSTREAM lpcs)
{
    UINT uiError;
    int  ii;

    /* See if we can open that format for input */

    // register event callback to avoid polling

    uiError = waveInOpen(&lpcs->hWaveIn,
        WAVE_MAPPER, lpcs->lpWaveFormat,
        (DWORD_PTR) lpcs->hCaptureEvent,  0, CALLBACK_EVENT );

    if (uiError != MMSYSERR_NOERROR)
        return IDS_CAP_WAVE_OPEN_ERROR;

    lpcs->fAudioYield = FALSE; // ACM is separate thread, don't yield
    lpcs->fAudioBreak = FALSE;

    DPF("AudioYield = %d", lpcs->fAudioYield);

    for (ii = 0; ii < (int)lpcs->sCapParms.wNumAudioRequested; ++ii) {

        if (waveInPrepareHeader (lpcs->hWaveIn, lpcs->alpWaveHdr[ii],
                                 sizeof(WAVEHDR)))
            return IDS_CAP_WAVE_ALLOC_ERROR;

        if (waveInAddBuffer (lpcs->hWaveIn, lpcs->alpWaveHdr[ii],
                             sizeof(WAVEHDR)))
            return IDS_CAP_WAVE_ALLOC_ERROR;
	AuxDebugEx(3, DEBUGLINE "Added wave buffer %d (%8x)\r\n", ii, lpcs->alpWaveHdr[ii]);
    }

    lpcs->iNextWave = 0;        // current wave
    lpcs->dwWaveBytes = 0L;     // number of wave bytes
    lpcs->dwWaveChunkCount = 0; // number of wave frames

    return 0;
}

//
// AVI AudioUnPrepare - UnPrepares headers and closes the wave device.
//                      This routine is also used by MCI capture.
//                      Returns: 0 on success, otherwise an error code.

UINT AVIAudioUnPrepare (LPCAPSTREAM lpcs)
{
    int ii;

    if (lpcs->hWaveIn)
    {
        waveInReset(lpcs->hWaveIn);

        // unprepare any headers that have been prepared
        //
        for (ii=0; ii < lpcs->iNumAudio; ++ii)
            if (lpcs->alpWaveHdr[ii] &&
                (lpcs->alpWaveHdr[ii]->dwFlags & WHDR_PREPARED))
                waveInUnprepareHeader (lpcs->hWaveIn,
                                       lpcs->alpWaveHdr[ii],
                                       sizeof(WAVEHDR));

        waveInClose(lpcs->hWaveIn);
        lpcs->hWaveIn = NULL;
    }

    return 0;
}

// ****************************************************************
// ******************** Video Buffer Control **********************
// ****************************************************************

#if defined CHICAGO

// Win95 capavi code
// AVIVideoInit -  Allocates, and initialize buffers for video capture.
//                 This routine is also used by MCI capture.
//                 Returns: 0 on success, otherwise an error code.

UINT AVIVideoInit (LPCAPSTREAM lpcs)
{
    UINT           iMaxVideo;
    DWORD          mmr;
    LPTHKVIDEOHDR  ptvh;
    UINT           ii;
    DWORD          cbVideo;

    lpcs->iNumVideo = 0;
    lpcs->iNextVideo = 0;
    lpcs->dwVideoChunkCount = 0;
    lpcs->dwFramesDropped = 0;
    lpcs->fBuffersOnHardware = FALSE;

    // When performing MCI step capture, buffer array is not used
    if (lpcs->sCapParms.fStepMCIDevice)
        return 0;

    cbVideo = ROUNDUPTOSECTORSIZE (lpcs->lpBitsInfo->bmiHeader.biSizeImage
                                   + sizeof(RIFF),
                                   lpcs->dwBytesPerSector)
              + lpcs->dwBytesPerSector;

    // If the user hasn't specified the number of video buffers to use,
    // assume the minimum

    if (lpcs->sCapParms.wNumVideoRequested == 0) {
        iMaxVideo = lpcs->sCapParms.wNumVideoRequested = MIN_VIDEO_BUFFERS;
	lpcs->fCaptureFlags |= CAP_fDefaultVideoBuffers;
    } else {
	// use the number of video buffers that the user requested
	// or the maximum that will fit in memory.
	//
	iMaxVideo = min (MAX_VIDEO_BUFFERS, lpcs->sCapParms.wNumVideoRequested);
    }

    if (iMaxVideo > 1)
    {
        DWORDLONG dwFreeMem;
        DWORDLONG dwUserRequests;
        DWORDLONG dwAudioMem;

        // How much actual free physical memory exists?
        dwFreeMem = GetFreePhysicalMemory();
        dwAudioMem = lpcs->dwWaveSize * lpcs->sCapParms.wNumAudioRequested;

        #define FOREVER_FREE 32768L   // Always keep this free for swap space

        // How much memory will be used if we allocate per the request?
        //
        dwUserRequests = dwAudioMem
                         + cbVideo * iMaxVideo
                         + FOREVER_FREE;

        // If request is greater than available memory, force fewer buffers
        //
        if (dwUserRequests > dwFreeMem)
        {
            if (dwFreeMem > dwAudioMem)
                dwFreeMem -= dwAudioMem;
            iMaxVideo = (int)(((dwFreeMem * 8) / 10) / cbVideo);
            iMaxVideo = min (MAX_VIDEO_BUFFERS, iMaxVideo);
            dprintf("iMaxVideo = %d\n", iMaxVideo);
        }
    }

    mmr = vidxAllocHeaders(lpcs->hVideoIn, iMaxVideo, &ptvh);
    if (mmr != MMSYSERR_NOERROR)
        return IDS_CAP_VIDEO_ALLOC_ERROR;

    AuxDebugEx (3, DEBUGLINE "vidxAllocHdrs returned ptvh=%X\r\n", ptvh);
    AuxDebugDump (8, ptvh, sizeof(*ptvh) * iMaxVideo);

    for (ii = 0; ii < iMaxVideo; ++ii)
    {
        LPVIDEOHDR pvh = NULL;
        LPRIFF     priff;

        // in chicago we let the thunk layer allocate memory
        // so that we can be assured that the memory can be easily
        // thunked.
        //
        // the pointer will be rounded up to a sector size boundary
        //
        mmr = vidxAllocBuffer (lpcs->hVideoIn, ii, &ptvh, cbVideo);
        if ((mmr != MMSYSERR_NOERROR) || (ptvh == NULL))
            break;

        lpcs->alpVideoHdr[ii] = pvh = &ptvh->vh;

        // vidxAllocBuffer actually returns a couple of extra fields
        // after the video header. the first of these holds the
        // linear address of the buffer.
        //
        priff = (LPVOID) ROUNDUPTOSECTORSIZE (ptvh->p32Buff, lpcs->dwBytesPerSector);

       #ifdef DEBUG
        {
        LPBYTE pb = (LPVOID)ptvh->p32Buff;
        AuxDebugEx (4, DEBUGLINE "buffer[%d] at %x linear. Doing touch test\r\n",
                    ii, ptvh->p32Buff);
        pb[0] = 0;
        pb[cbVideo-1] = 0;
        }
       #endif

        // write the riff header for this chunk.
        //
	priff->dwType = MAKEAVICKID(cktypeDIBbits, 0);
        if (lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RLE8)
            priff->dwType = MAKEAVICKID(cktypeDIBcompressed, 0);
        priff->dwSize = lpcs->lpBitsInfo->bmiHeader.biSizeImage;

        // init the video header
        //
        pvh->lpData = (LPVOID)(priff + 1);
        pvh->dwBufferLength  = priff->dwSize;
        pvh->dwBytesUsed     = 0;
        pvh->dwTimeCaptured  = 0;
        pvh->dwUser          = 0;
        pvh->dwFlags         = 0;

        AuxDebugEx (4, DEBUGLINE "lpVideoHdr[%d]==%X\r\n", ii, lpcs->alpVideoHdr[ii]);
        AuxDebugDump (8, lpcs->alpVideoHdr[ii], sizeof(*ptvh));
    }
    lpcs->iNumVideo = ii;
    lpcs->cbVideoAllocation = cbVideo;

    dprintf("cbVideo = %ld \n", cbVideo);
    dprintf("iNumVideo Allocated = %d \n", lpcs->iNumVideo);
    return lpcs->iNumVideo ? 0 : IDS_CAP_VIDEO_ALLOC_ERROR;
}

//
// AVIVideoPrepare -  Prepares headers and adds buffers to the device
//                    This routine is also used by MCI capture.
//                    Returns: 0 on success, otherwise an error code.

UINT AVIVideoPrepare (LPCAPSTREAM lpcs)
{
    int ii;

    // When performing MCI step capture, buffer array is not used
    if (lpcs->sCapParms.fStepMCIDevice)
        return 0;

   #ifdef JMK_HACK_CHECKHDR
    {
    LPTHKVIDEOHDR lptvh = (LPVOID)lpcs->alpVideoHdr[0];

    if (HIWORD(lptvh->vh.lpData) != HIWORD(lptvh->p32Buff))
        {
        AuxDebugEx (0, DEBUGLINE "before stream init: hdr trouble\r\n");

        AuxDebugEx (0, DEBUGLINE "iNext=%d, ptvh=%X\r\n", lpcs->iNextVideo, lptvh);
        AuxDebugDump (0, lptvh, sizeof(*lptvh));
        AuxDebugEx (0, DEBUGLINE "alpVideoHdrs=%X\r\n", lpcs->alpVideoHdr);
        AuxDebugDump (0, lpcs->alpVideoHdr, sizeof(lpcs->alpVideoHdr[0]) * 8);

        INLINE_BREAK;
        return IDS_CAP_VIDEO_OPEN_ERROR;
        }
    }
   #endif

    // Open the video stream, setting the capture rate
    //
    if (videoStreamInit(lpcs->hVideoIn,
                        lpcs->sCapParms.dwRequestMicroSecPerFrame,
                        lpcs->hRing0CapEvt,
                        0,
                        CALLBACK_EVENT))
    {
        dprintf("cant open video device!\n");
        return IDS_CAP_VIDEO_OPEN_ERROR;
    }

   #ifdef JMK_HACK_CHECKHDR
    {
    LPTHKVIDEOHDR lptvh = (LPVOID)lpcs->alpVideoHdr[0];

    if (HIWORD(lptvh->vh.lpData) != HIWORD(lptvh->p32Buff))
        {
        AuxDebugEx (0, DEBUGLINE "after stream init: hdr trouble\r\n");

        AuxDebugEx (0, DEBUGLINE "iNext=%d, ptvh=%X\r\n", lpcs->iNextVideo, lptvh);
        AuxDebugDump (0, lptvh, sizeof(*lptvh));
        AuxDebugEx (0, DEBUGLINE "alpVideoHdrs=%X\r\n", lpcs->alpVideoHdr);
        AuxDebugDump (0, lpcs->alpVideoHdr, sizeof(lpcs->alpVideoHdr[0]) * 8);

        INLINE_BREAK;
        return IDS_CAP_VIDEO_OPEN_ERROR;
        }
    }
   #endif

    // Prepare (lock) the buffers, and give them to the device
    //
    for (ii = 0; ii < lpcs->iNumVideo; ++ii)
    {
        if (vidxAddBuffer (lpcs->hVideoIn,
                           lpcs->alpVideoHdr[ii],
                           sizeof(VIDEOHDR)))
        {
            lpcs->iNumVideo = ii;
            dprintf("**** could only prepare %d Video buffers!\n", lpcs->iNumVideo);
            break;
        }
    }

   #ifdef JMK_HACK_CHECKHDR
    {
    LPTHKVIDEOHDR lptvh = (LPVOID)lpcs->alpVideoHdr[0];

    if (IsBadWritePtr (lptvh, sizeof(*lptvh)) ||
        HIWORD(lptvh->vh.lpData) != HIWORD(lptvh->p16Alloc))
        {
        AuxDebugEx (0, DEBUGLINE "after add buffers: hdr trouble\r\n");

        AuxDebugEx (0, DEBUGLINE "iNext=%d, ptvh=%X\r\n", lpcs->iNextVideo, lptvh);
        AuxDebugDump (0, lptvh, sizeof(*lptvh));
        AuxDebugEx (0, DEBUGLINE "alpVideoHdrs=%X\r\n", lpcs->alpVideoHdr);
        AuxDebugDump (0, lpcs->alpVideoHdr, sizeof(lpcs->alpVideoHdr[0]) * 8);

        INLINE_BREAK;
        return IDS_CAP_VIDEO_OPEN_ERROR;
        }
    }
   #endif

    return 0;
}

#else // code below is !CHICAGO

// this structure is used to keep track of memory allocation
// for video buffers used in capture.  it is allocated when
// allocating a videohdr would be called for
//
typedef struct _cap_videohdr {
    VIDEOHDR vh;
    LPBYTE   pAlloc;      // address of allocated buffer
    DWORD    dwMemIdent;  // identity of allocation (used in Chicago)
    DWORD    dwReserved;  // used in chicago
    BOOL     bHwBuffer;   // TRUE if buffer is allocated using videoStreamAllocBuffer
} CAPVIDEOHDR, FAR *LPCAPVIDEOHDR;

// AVIVideoInit -  Allocates, and initialize buffers for video capture.
//                 This routine is also used by MCI capture.
//                 Returns: 0 on success, otherwise an error code.

UINT AVIVideoInit (LPCAPSTREAM lpcs)
{
    int            iMaxVideo;
    int		   ii;
    LPCAPVIDEOHDR  pcvh;
    LPVOID         pbuf;
    DWORD          cbVideo;
    BOOL	   fAllowHardwareBuffers;


//#define SINGLEHEADERBLOCK

    lpcs->iNumVideo = 0;
    lpcs->iNextVideo = 0;
    lpcs->dwVideoChunkCount = 0;
    lpcs->dwFramesDropped = 0;
    lpcs->fBuffersOnHardware = FALSE;
    fAllowHardwareBuffers = GetProfileIntA ("Avicap32", "AllowHardwareBuffers", TRUE);

    // When performing MCI step capture, buffer array is not used
    if (lpcs->sCapParms.fStepMCIDevice)
        return 0;

    cbVideo = (DWORD) ROUNDUPTOSECTORSIZE (lpcs->lpBitsInfo->bmiHeader.biSizeImage
                                   + sizeof(RIFF),
                                   lpcs->dwBytesPerSector)
              + lpcs->dwBytesPerSector;

    // If the user hasn't specified the number of video buffers to use,
    // assume the minimum

    if (lpcs->sCapParms.wNumVideoRequested == 0) {
	UINT cDefaultVideoBuffers = GetProfileIntA ("Avicap32", "nVideoBuffers", MIN_VIDEO_BUFFERS);
	cDefaultVideoBuffers = min(MAX_VIDEO_BUFFERS, max(MIN_VIDEO_BUFFERS, cDefaultVideoBuffers));
        iMaxVideo = lpcs->sCapParms.wNumVideoRequested = cDefaultVideoBuffers;
	lpcs->fCaptureFlags |= CAP_fDefaultVideoBuffers;
    } else {
	// use the number of video buffers that the user requested
	// or the maximum that will fit in memory.
	//
	iMaxVideo = min (MAX_VIDEO_BUFFERS, lpcs->sCapParms.wNumVideoRequested);
    }

    // Post VFW 1.1a, see if the driver can allocate memory
    //
   #ifdef ALLOW_HW_BUFFERS
    if (fAllowHardwareBuffers && (videoStreamAllocBuffer (lpcs->hVideoIn, (LPVOID *) &pbuf, cbVideo)
        == DV_ERR_OK))
    {
	DWORD dwRet;
	dprintf("Allocated test h/w buffer at address %8x, size %d bytes", pbuf, cbVideo);
        lpcs->fBuffersOnHardware = TRUE;
        dwRet = videoStreamFreeBuffer (lpcs->hVideoIn, pbuf);

	dprintf("Freed test h/w buffer at address %8x, retcode 0x%x", pbuf, dwRet);
    }
    else
   #endif
    {
        DWORDLONG dwFreeMem;
        DWORDLONG dwUserRequests;
        DWORDLONG dwAudioMem;

        lpcs->fBuffersOnHardware = FALSE;

        // How much actual free physical memory exists?
        dwFreeMem = GetFreePhysicalMemory();
        dwAudioMem = lpcs->dwWaveSize * lpcs->sCapParms.wNumAudioRequested;

        #define FOREVER_FREE 32768L   // Always keep this free for swap space

        // How much memory will be used if we allocate per the request?
        //
        dwUserRequests = dwAudioMem
                         + cbVideo * iMaxVideo
                         + FOREVER_FREE;

        // If request is greater than available memory, force fewer buffers
        //
        if (dwUserRequests > dwFreeMem)
        {
            if (dwFreeMem > dwAudioMem)
                dwFreeMem -= dwAudioMem;
            iMaxVideo = (int)(((dwFreeMem * 8) / 10) / cbVideo);
            iMaxVideo = min (MAX_VIDEO_BUFFERS, iMaxVideo);
            dprintf("iMaxVideo = %d\n", iMaxVideo);
        }
    }

#ifdef SINGLEHEADERBLOCK
    pcvh = GlobalAllocPtr (GMEM_MOVEABLE, iMaxVideo * sizeof(CAPVIDEOHDR));
    // note: pcvh is freed by referencing through alpVideoHdr[0]
    if ( ! pcvh)
        return IDS_CAP_VIDEO_ALLOC_ERROR;

    AuxDebugEx (3, DEBUGLINE "allocated video headers pcvh=%X\r\n", pcvh);
#endif

    // Set up the buffers presuming fixed size DIBs and Junk chunks
    // These will be modified later if the device provides compressed data

    for (ii = 0; ii < iMaxVideo; ++ii)
    {
        LPVIDEOHDR pvh = NULL;
        LPRIFF     priff;

#ifndef SINGLEHEADERBLOCK
        pcvh = (LPCAPVIDEOHDR)GlobalAllocPtr(GMEM_MOVEABLE, sizeof(CAPVIDEOHDR));
        if (pcvh== NULL)
            break;
        lpcs->alpVideoHdr[ii] = (LPVIDEOHDR)pcvh;
        ZeroMemory(pcvh, sizeof (CAPVIDEOHDR));
#endif		

       #ifdef ALLOW_HW_BUFFERS
        //
        // for the first buffer, always try to allocate on hardware,
	// NO.  If we are not to use hardware buffers, then do not use them.
        // if that fails, grab virtual memory for the buffer.
        // for all but the first buffer, we use whatever worked for
        // the first buffer, and if that fails.  we stop allocating buffers
        //
        if (lpcs->fBuffersOnHardware)
        {
	    MMRESULT mmr;
            pbuf = NULL;
            mmr = videoStreamAllocBuffer (lpcs->hVideoIn, (LPVOID) &pbuf, cbVideo);
            if ((mmr != MMSYSERR_NOERROR) || (pbuf == NULL))
            {
                if (0 == ii)
                    break;  // nothing allocated

	        dprintf("Failed to allocate hardware buffer %d, rc=0x%x", ii, mmr);

		// if the user did not ask for a specific number of buffers,
		// or the hardware is set up to work with ONLY hardware
		// allocated buffers, take what we've got and work with that.
		if ((lpcs->fCaptureFlags & CAP_fDefaultVideoBuffers)
		  || (GetProfileIntA ("Avicap32", "HardwareBuffersOnly", FALSE)))
		{
		    break;
		}

                lpcs->fBuffersOnHardware = FALSE;
		// use normal memory for the remaining video buffers.
                pbuf = AllocSectorAlignedMem (cbVideo, lpcs->dwBytesPerSector);
            }
            else {
                lpcs->fBuffersOnHardware = TRUE;
		dprintf("Allocated hardware buffer %d at address %8x", ii, pbuf);
	    }
        }
        else
            pbuf = AllocSectorAlignedMem (cbVideo, lpcs->dwBytesPerSector);

       #else ! dont allow hw buffers

        pbuf = AllocSectorAlignedMem (cbVideo, lpcs->dwBytesPerSector);

       #endif // ALLOW_HW_BUFFERS

        if (pbuf == NULL) {
#ifndef SINGLEHEADERBLOCK
	    GlobalFreePtr(pcvh);
	    lpcs->alpVideoHdr[ii] = NULL;
#endif		
            break;
	}

        // save the original allocation pointer to the buffer
        // in the extra fields of the capture header. also remember
        // whether we got the buffer from the driver or not
        //
#ifndef SINGLEHEADERBLOCK
        pcvh->pAlloc = pbuf;
        pcvh->bHwBuffer = lpcs->fBuffersOnHardware;
        lpcs->alpVideoHdr[ii] = pvh = &pcvh->vh;
#else
        pcvh[ii].pAlloc = pbuf;
        pcvh[ii].bHwBuffer = lpcs->fBuffersOnHardware;
        lpcs->alpVideoHdr[ii] = pvh = &pcvh[ii].vh;
#endif		
        priff = (LPVOID) ROUNDUPTOSECTORSIZE (pbuf, lpcs->dwBytesPerSector);

        // write the riff header for this frame
        //
	priff->dwType = MAKEAVICKID(cktypeDIBbits, 0);
        if (lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RLE8)
            priff->dwType = MAKEAVICKID(cktypeDIBcompressed, 0);
        priff->dwSize = lpcs->lpBitsInfo->bmiHeader.biSizeImage;

        // fill in the video hdr for this frame
        //
        pvh->lpData          = (LPVOID)(priff + 1);
        pvh->dwBufferLength  = priff->dwSize;
        pvh->dwBytesUsed     = 0;
        pvh->dwTimeCaptured  = 0;
        pvh->dwUser          = 0;
        pvh->dwFlags         = 0;

        AuxDebugEx (4, DEBUGLINE "lpVideoHdr[%d]==%X\r\n", ii, lpcs->alpVideoHdr[ii]);
        AuxDebugDump (8, lpcs->alpVideoHdr[ii], sizeof(*pcvh));
    }
    lpcs->iNumVideo = ii;
    lpcs->cbVideoAllocation = cbVideo;

    // if we did not create even a single buffer, free the headers
    //

#ifdef SINGLEHEADERBLOCK
    if ( ! lpcs->iNumVideo)
        GlobalFreePtr (pcvh);
#else
    // we allocate video headers as we proceed.  There is nothing to free
#endif

   #ifdef ALLOW_HW_BUFFERS
    if (lpcs->fBuffersOnHardware)
        dprintf("HARDWARE iNumVideo Allocated = %d \n", lpcs->iNumVideo);
    else
   #endif
        dprintf("HIGH iNumVideo Allocated = %d \n", lpcs->iNumVideo);

    return lpcs->iNumVideo ? 0 : IDS_CAP_VIDEO_ALLOC_ERROR;
}

void CALLBACK
VideoCallback(
    HVIDEO hvideo,
    UINT msg,
    DWORD_PTR dwInstance,
    DWORD_PTR lParam1,
    DWORD_PTR lParam2
)
{
    LPCAPSTREAM lpcs = (LPCAPSTREAM) dwInstance;

    if (lpcs && lpcs->hCaptureEvent) {
        SetEvent(lpcs->hCaptureEvent);
    } else {
	AuxDebugEx(1, DEBUGLINE "VideoCallback with NO instance data\r\n");
    }
}

//
// AVIVideoPrepare -  Prepares headers and adds buffers to the device
//                    This routine is also used by MCI capture.
//                    Returns: 0 on success, otherwise an error code.
UINT AVIVideoPrepare (LPCAPSTREAM lpcs)
{
    MMRESULT mmr;
    int      ii;

    // When performing MCI step capture, buffer array is not used
    //
    if (lpcs->sCapParms.fStepMCIDevice)
        return 0;

    // Open the video stream, setting the capture rate
    //
    mmr = videoStreamInit (lpcs->hVideoIn,
                           lpcs->sCapParms.dwRequestMicroSecPerFrame,
                           (DWORD_PTR) VideoCallback,
                           (DWORD_PTR) lpcs,
                           CALLBACK_FUNCTION);
    if (mmr) {
        dprintf("cannot open video device!  Error is %d\n", mmr);
        return IDS_CAP_VIDEO_OPEN_ERROR;
    }

    // Prepare (lock) the buffers, and give them to the device
    //
    for (ii = 0; ii < lpcs->iNumVideo; ++ii)
    {
        mmr = videoStreamPrepareHeader (lpcs->hVideoIn,
                                        lpcs->alpVideoHdr[ii],
                                        sizeof(VIDEOHDR));
        if (mmr)
        {
            lpcs->iNumVideo = ii;
            dprintf("**** could only prepare %d Video buffers!\n", lpcs->iNumVideo);
            break;
        }

        mmr = videoStreamAddBuffer (lpcs->hVideoIn,
                                    lpcs->alpVideoHdr[ii],
                                    sizeof(VIDEOHDR));
        if (mmr)
             return IDS_CAP_VIDEO_ALLOC_ERROR;
	AuxDebugEx(3, DEBUGLINE "Added video buffer %d (%8x)\r\n", ii, lpcs->alpVideoHdr[ii]);
    }
    return 0;
}

#endif // not chicago

//
// AVI VideoUnPrepare - UnPrepares headers, frees memory, and
//                      resets the video in device.
//                      This routine is also used by MCI capture.
//                      Returns: 0 on success, otherwise an error code.

UINT AVIVideoUnPrepare (LPCAPSTREAM lpcs)
{
    // When performing MCI step capture, buffer array is not used
    //
    if (lpcs->sCapParms.fStepMCIDevice)
        return 0;

    // Reset the buffers so they can be freed
    //
    if (lpcs->hVideoIn) {
        videoStreamReset(lpcs->hVideoIn);

        // unprepare headers
        // Unlock and free headers and data

       #if defined CHICAGO
        vidxFreeHeaders (lpcs->hVideoIn);
        ZeroMemory (lpcs->alpVideoHdr, sizeof(lpcs->alpVideoHdr));
       #else
        {
            int ii;
#ifdef SINGLEHEADERBLOCK
            LPCAPVIDEOHDR pcvhAll = (LPVOID)lpcs->alpVideoHdr[0];
#endif

            for (ii = 0; ii < lpcs->iNumVideo; ++ii)
            {
                LPCAPVIDEOHDR pcvh = (LPVOID)lpcs->alpVideoHdr[ii];
                if (pcvh)
                {
                    if (pcvh->vh.dwFlags & VHDR_PREPARED)
                        videoStreamUnprepareHeader (lpcs->hVideoIn,
                                                    &pcvh->vh,
                                                    sizeof(VIDEOHDR));

                    if (pcvh->pAlloc) {
                     #ifdef ALLOW_HW_BUFFERS
			if (pcvh->bHwBuffer)
			{
			    dprintf("Freeing hardware buffer %d at address %8x", ii, pcvh->pAlloc);
                            videoStreamFreeBuffer (lpcs->hVideoIn, (LPVOID)pcvh->pAlloc);
			}
			else
                     #endif
			{
			dprintf("Freeing video buffer %d at address %8x", ii, pcvh->pAlloc);

                        FreeSectorAlignedMem (pcvh->pAlloc);
			}
                    } else {
			dprintf("NO buffer allocated for index %d", ii);
		    }

#ifndef SINGLEHEADERBLOCK
		    GlobalFreePtr(pcvh);
#endif
		    lpcs->alpVideoHdr[ii] = NULL;
                } else {
		    dprintf("NO video header for index %d", ii);
		}
	    }

#ifdef SINGLEHEADERBLOCK
            // free the array of video headers
            //
            if (pcvhAll) {
                GlobalFreePtr (pcvhAll);
	    }
#endif
	}
       #endif
        // Shut down the video stream
        videoStreamFini(lpcs->hVideoIn);
    }

    return 0;
}

/*
 *  AVI Fini    - undo the mess that AVIInit did.
 *
 */
void AVIFini(LPCAPSTREAM lpcs)
{
    AuxDebugEx (2, "AVIFini(%08x)\r\n", lpcs);

    if (lpcs->lpDropFrame) {
        FreeSectorAlignedMem (lpcs->lpDropFrame), lpcs->lpDropFrame = NULL;
    }

    AVIVideoUnPrepare (lpcs);           // Free the video device and buffers
    AVIAudioUnPrepare (lpcs);           // Free the audio device
    AVIAudioFini (lpcs);                // Free the audio buffers

    if (lpcs->hCaptureEvent) {
        CloseHandle (lpcs->hCaptureEvent), lpcs->hCaptureEvent = NULL;
    }

    if (lpcs->heSyncWrite) {
        CloseHandle (lpcs->heSyncWrite), lpcs->heSyncWrite = NULL;
    }

    if (lpcs->hCompletionPort) {
        CloseHandle (lpcs->hCompletionPort), lpcs->hCompletionPort = NULL;
    }

    if (hmodKernel) {
        pfnCreateIoCompletionPort = NULL;
        pfnGetQueuedCompletionStatus = NULL;
        FreeLibrary(hmodKernel);
        hmodKernel = 0;
    }

    AuxDebugEx (2, "AVIFini(...) exits\r\n");
}

//
// AVI Init
//     This routine does all the non-File initalization for AVICapture.
//     Returns: 0 on success, Error string value on failure.
//

UINT AVIInit (LPCAPSTREAM lpcs)
{
    UINT         wError = 0;    // Success
    LPBITMAPINFO lpBitsInfoOut;    // Possibly compressed output format

    // Allocate a DropFrame buffer
    if (lpcs->lpDropFrame == NULL) {
        assert (lpcs->dwBytesPerSector);
        lpcs->lpDropFrame = AllocSectorAlignedMem (lpcs->dwBytesPerSector, lpcs->dwBytesPerSector);
    }

    /* No special video format given -- use the default */
   #ifdef NEW_COMPMAN
    if (lpcs->CompVars.hic == NULL)
        lpBitsInfoOut = lpcs->lpBitsInfo;
    else
        lpBitsInfoOut = lpcs->CompVars.lpbiOut;
   #else
    lpBitsInfoOut = lpcs->lpBitsInfo;
   #endif

    // -------------------------------------------------------
    // figure out buffer sizes
    // -------------------------------------------------------

    // Init all pointers to NULL
    ZeroMemory (lpcs->alpVideoHdr, sizeof(lpcs->alpVideoHdr));
    ZeroMemory (lpcs->alpWaveHdr, sizeof(lpcs->alpWaveHdr));

    // -------------------------------------------------------
    //                    Init Sound
    // -------------------------------------------------------

    if (lpcs->sCapParms.fCaptureAudio) {
        if ((DWORD)(wError = AVIAudioInit (lpcs))) {
            dprintf("can't init audio buffers!\n");
            goto AVIInitFailed;
        }
    }

    // -------------------------------------------------------
    //                    Init Video
    // -------------------------------------------------------

    if ((DWORD)(wError = AVIVideoInit (lpcs))) {
        dprintf("AVIVideoInitFailed (no buffers alloc'd)!\n");
        goto AVIInitFailed;
    }

    // --------------------------------------------------------------
    //  Prepare audio buffers (lock em down) and give them to the device
    // --------------------------------------------------------------

    if (lpcs->sCapParms.fCaptureAudio) {
        if ((DWORD)(wError = AVIAudioPrepare (lpcs))) {
            dprintf("can't prepare audio buffers!\n");
            goto AVIInitFailed;
        }
    }

    // --------------------------------------------------------------
    //  Prepare video buffers (lock em down) and give them to the device
    // --------------------------------------------------------------

    if ((DWORD)(wError = AVIVideoPrepare (lpcs))) {
        dprintf("can't prepare video buffers!\n");
        goto AVIInitFailed;
    }

    // -------------------------------------------------------
    //   all done, return success
    // -------------------------------------------------------

    return (0);            // SUCCESS !

    // -------------------------------------------------------
    //   we got a error, return string ID of error message
    // -------------------------------------------------------
AVIInitFailed:
    AVIFini(lpcs);      // Shutdown everything
    return wError;
}

// Maintains info chunks which are written to the AVI header
//
BOOL FAR PASCAL SetInfoChunk(LPCAPSTREAM lpcs, LPCAPINFOCHUNK lpcic)
{
    DWORD       ckid   = lpcic->fccInfoID;
    LPVOID      lpData = lpcic->lpData;
    LONG        cbData = lpcic->cbData;
    LPBYTE      lp;
    LPBYTE      lpw;
    LPBYTE      lpEnd;
    LPBYTE      lpNext;
    LONG        cbSizeThis;
    BOOL        fOK = FALSE;

    // Delete all info chunks?
    if (ckid == 0) {
        if (lpcs->lpInfoChunks) {
            GlobalFreePtr (lpcs->lpInfoChunks);
            lpcs->lpInfoChunks = NULL;
            lpcs->cbInfoChunks = 0;
        }
        return TRUE;
    }

    // Try removing an entry if it already exists...
    // Also used if lpData is NULL to just remove an entry
    // note: lpw and lpEnd are LPRIFF values... except the code is written
    // to use them as pointers to an array of DWORD values. (yuk)
    //
    lpw   = (LPBYTE)lpcs->lpInfoChunks;           // always points at fcc
    lpEnd = (LPBYTE)lpcs->lpInfoChunks + lpcs->cbInfoChunks;
    while (lpw < lpEnd) {
        cbSizeThis = ((DWORD UNALIGNED FAR *)lpw)[1];
        cbSizeThis += cbSizeThis & 1;           // force WORD (16 bit) alignment

	// Point lpNext at the next RIFF block
        lpNext = lpw + cbSizeThis + sizeof (DWORD) * 2;

	// If this info chunk is the same as that passed in... we can delete the
	// existing information
        if ((*(DWORD UNALIGNED FAR *) lpw) == ckid) {
            lpcs->cbInfoChunks -= cbSizeThis + sizeof (DWORD) * 2;
	    // could have coded: lpcs->cbInfoChunks -= lpNext - lpw;
	    // the next line should always be true...
            if (lpNext <= lpEnd) {
                if (lpEnd - lpNext)
                    CopyMemory (lpw, lpNext, lpEnd - lpNext);
                if (lpcs->cbInfoChunks) {
                    lpcs->lpInfoChunks = (LPBYTE) GlobalReAllocPtr( // shrink it
                        lpcs->lpInfoChunks,
                        lpcs->cbInfoChunks,
                        GMEM_MOVEABLE);
                }
                else {
                    if (lpcs->lpInfoChunks)
                        GlobalFreePtr (lpcs->lpInfoChunks);
                    lpcs->lpInfoChunks = NULL;
                }
                fOK = TRUE;
            }
            break;
        }
        else
            lpw = lpNext;
    }

    if (lpData == NULL || cbData == 0)         // Only deleting, get out
        return fOK;

    // Add a new entry
    cbData += cbData & 1;               // force WORD (16 bit) alignment
    cbData += sizeof(RIFF);             // add sizeof RIFF
    if (lpcs->lpInfoChunks)
        lp = GlobalReAllocPtr(lpcs->lpInfoChunks, lpcs->cbInfoChunks + cbData, GMEM_MOVEABLE);
    else
        lp = GlobalAllocPtr(GMEM_MOVEABLE, cbData);

    if (!lp)
        return FALSE;

    // Save the pointer in our status block
    lpcs->lpInfoChunks = lp;

    // build RIFF chunk in block
    //
    ((LPRIFF)(lp + lpcs->cbInfoChunks))->dwType = ckid;
    ((LPRIFF)(lp + lpcs->cbInfoChunks))->dwSize = lpcic->cbData;

    CopyMemory (lp + lpcs->cbInfoChunks + sizeof(RIFF),
                lpData,
                cbData - sizeof(RIFF));

    // Update the length of the info chunk
    lpcs->cbInfoChunks += cbData;

    return TRUE;
}

/*+ ProcessNextVideoBuffer
 *
 *-===============================================================*/

STATICFN BOOL _inline ProcessNextVideoBuffer (
    LPCAPSTREAM  lpcs,
    BOOL         fStopping,
    LPUINT       lpuError,
    LPVIDEOHDR * plpvhDraw,
    LPBOOL       lpbPending)
{
    LPVIDEOHDR lpvh;

    *lpuError = 0;
    *plpvhDraw = NULL;
    *lpbPending = FALSE;

    lpvh = lpcs->alpVideoHdr[lpcs->iNextVideo];
    if (!(lpvh->dwFlags & VHDR_DONE)) {
        return fStopping;
    }

   #if defined CHICAGO
    {
    LPTHKVIDEOHDR lptvh = (LPVOID)lpvh;

    #ifdef JMK_HACK_CHECKHDR
     if (IsBadWritePtr (lptvh, sizeof(*lptvh)) ||
        HIWORD(lptvh->vh.lpData) != HIWORD(lptvh->p16Alloc))
        {
        OutputDebugStringA(DEBUGLINE "trouble with video hdr\r\n");

        AuxDebugEx (0, DEBUGLINE "iNext=%d, ptvh=%X\r\n", lpcs->iNextVideo, lptvh);
        AuxDebugDump (0, lptvh, sizeof(*lptvh));
        AuxDebugEx (0, DEBUGLINE "alpVideoHdrs=%X\r\n", lpcs->alpVideoHdr);
        AuxDebugDump (0, lpcs->alpVideoHdr, sizeof(lpcs->alpVideoHdr[0]) * 8);

        INLINE_BREAK;

        return TRUE;
        }
    #endif

    // Swap the linear pointer back (was swapped in vidxAddBuffer)
    //
    lptvh->vh.lpData = (LPVOID)(ROUNDUPTOSECTORSIZE(lptvh->p32Buff, lpcs->dwBytesPerSector) + sizeof(RIFF));
    }
   #endif

    if (lpvh->dwBytesUsed)
    {
        DWORD  dwTime;
        DWORD  dwBytesUsed = lpvh->dwBytesUsed;
        BOOL   fKeyFrame = lpvh->dwFlags & VHDR_KEYFRAME;
        LPVOID lpData = lpvh->lpData;

        // get expected time for this frame in milliseconds
        //
        dwTime = MulDiv (lpcs->dwVideoChunkCount + 1,
                         lpcs->sCapParms.dwRequestMicroSecPerFrame,
                         1000);

       #ifdef NEW_COMPMAN
        //
        // We are automatically compressing during capture, so
        // compress the frame before we pass it on to be written
        //
        if (lpcs->CompVars.hic)
        {
            LPRIFF priff;

            dwBytesUsed = 0;
            lpData = ICSeqCompressFrame(&lpcs->CompVars, 0,
                                        lpvh->lpData,
                                        &fKeyFrame,
                                        &dwBytesUsed);

            priff = ((LPRIFF)lpData) -1;
            priff->dwType = MAKEAVICKID(cktypeDIBbits, 0);
            priff->dwSize = dwBytesUsed;
        }
       #endif // NEW_COMPMAN

        // do video stream callback for this frame
        //
        if (lpcs->CallbackOnVideoStream)
            lpcs->CallbackOnVideoStream (lpcs->hwnd, lpvh);
        lpvh->dwFlags &= ~VHDR_DONE;

        // if we are not capturing to disk, just increment
        // the 'chunk count' (i.e. frame count?) and go on
        // otherwise we want to queue the frame up to write
        // here
        //
        if ( ! (lpcs->fCaptureFlags & CAP_fCapturingToDisk))
        {
            // Warning: Kludge to create frame chunk count when net capture
            // follows.
            ++lpcs->dwVideoChunkCount;
        }
        else
        {
            int nAppendDummyFrames = 0;

            // if the expected time for this frame is less than the
            // timestamp for the frame.  we may have dropped some frames
            // before this frame.
            //
            if (lpcs->dwVideoChunkCount && (dwTime < lpvh->dwTimeCaptured))
            {
                int  nDropCount;
                BOOL bPending;

                // calculate how many frames have been dropped.
                // NOTE: this number may be zero if dwTimeCaptured is just
                // a little bit late.
                //
                nDropCount = MulDiv(lpvh->dwTimeCaptured - dwTime,
                                    1000,
                                    lpcs->sCapParms.dwRequestMicroSecPerFrame);

               #ifdef JMK_HACK_TIMERS
                if (pTimerRiff)
                    pTimerRiff->vchd.dwDropFramesNotAppended += nDropCount;
               #endif

                // If any frames have been dropped, write them out before
                // we get back to writing the current frame.
                //
                if (nDropCount > 0)
                {
                    AuxDebugEx(2,"*****Adding %d to the dropcount\r\n", nDropCount);
                    lpcs->dwFramesDropped += nDropCount;
                    if (! AVIWriteDummyFrames (lpcs, nDropCount, lpuError, &bPending))
                        fStopping = TRUE;
                }
            }

           #ifdef JMK_HACK_TIMERS
	    if (pTimerRiff) {
	        if (nTimerIndex == CLIPBOARDLOGSIZE)
		    nTimerIndex = 0;
	
// nTimerIndex will be OK	if ((nTimerIndex < CLIPBOARDLOGSIZE) && pTimerStuff)
		if (pTimerStuff)
		{
	
		    pCurTimerStuff = &pTimerStuff[nTimerIndex];
                    ++nTimerIndex;

		    pCurTimerStuff->nFramesAppended = 0;
		    pCurTimerStuff->nDummyFrames  = (WORD)lpcs->dwFramesDropped;
		    pCurTimerStuff->dwFrameTickTime = dwTime;
		    pCurTimerStuff->dwFrameStampTime = lpvh->dwTimeCaptured;
		    pCurTimerStuff->dwVideoChunkCount = lpcs->dwVideoChunkCount;
                    pCurTimerStuff->dwTimeWritten = pcDeltaTicks(&pctWriteBase);
		    pCurTimerStuff->dwTimeToWrite = 0;
		    pCurTimerStuff->nVideoIndex = (WORD)lpcs->iNextVideo;
		    pCurTimerStuff->nAudioIndex = (WORD)lpcs->iNextWave;
		}
	    } // fClipboardLogging
           #endif // JMK_HACK_TIMERS

           // look ahead for dummy frames and try to
           // append them to the current frame
           //
           nAppendDummyFrames = 0;

           #define LOOKAHEAD_FOR_DUMMYS 1
           #ifdef LOOKAHEAD_FOR_DUMMYS
           {
            int        iNext;
            LPVIDEOHDR lpvhNext;
            iNext = lpcs->iNextVideo+1;
            if (iNext >= lpcs->iNumVideo)
                iNext = 0;

            // is the next frame done already?  if so
            // we can append any dropped frames to the end of
            // this frame before we write it out
            //
            lpvhNext = lpcs->alpVideoHdr[iNext];
            if (lpvhNext->dwFlags & VHDR_DONE)
            {
		// Recalculate the current time, which may have
		// changed if dummy frames were inserted above
		dwTime = MulDiv (lpcs->dwVideoChunkCount + 1,
                         lpcs->sCapParms.dwRequestMicroSecPerFrame,
                         1000);
	
                nAppendDummyFrames =
                    MulDiv (lpvhNext->dwTimeCaptured - dwTime,
                            1000,
                            lpcs->sCapParms.dwRequestMicroSecPerFrame);

                if ((--nAppendDummyFrames) < 0)
                    nAppendDummyFrames = 0;
		else {
		    AuxDebugEx(3, DEBUGLINE "Appending %d dummy frames", nAppendDummyFrames);
		}

                AuxDebugEx(1,"*****Adding %d to the dropcount in lookahead mode\r\n", nAppendDummyFrames);
                lpcs->dwFramesDropped += nAppendDummyFrames;

               #ifdef JMK_HACK_TIMERS
                if (pTimerRiff) {
                    pTimerRiff->vchd.dwDropFramesAppended += nAppendDummyFrames;
		    pCurTimerStuff->nFramesAppended = (WORD)nAppendDummyFrames;
		}
               #endif
            }
           }
           #endif

            if ( ! AVIWriteVideoFrame (lpcs,
                                       lpData,
                                       dwBytesUsed,
                                       fKeyFrame,
                                       lpcs->iNextVideo,
                                       nAppendDummyFrames,
                                       lpuError, lpbPending))
                fStopping = TRUE;

           #ifdef JMK_HACK_TIMERS
            if (pCurTimerStuff)
            {
                pCurTimerStuff->dwTimeToWrite = pcDeltaTicks(&pctWriteBase);
                pCurTimerStuff->bPending = (BOOL) *lpbPending;
            }
           #endif
        }

    }

    // return lpvh to the caller so that the frame can be
    // drawn (time permitting)
    //
    *plpvhDraw = lpvh;

    // increment the next Video buffer pointer
    //
    if (++lpcs->iNextVideo >= lpcs->iNumVideo)
        lpcs->iNextVideo = 0;

    return fStopping;
}

/*+ ProcessAudioBuffers
 *
 *-===============================================================*/

STATICFN BOOL _inline ProcessAudioBuffers (
    LPCAPSTREAM lpcs,
    BOOL        fStopping,
    LPUINT      lpuError)
{
    int       iLastWave;
    UINT      ii;
    LPWAVEHDR lpwh;

    *lpuError = 0;
    assert (lpcs->sCapParms.fCaptureAudio);

    // if all buffers are done, we have broke audio.
    //
    iLastWave = lpcs->iNextWave == 0 ? lpcs->iNumAudio -1 : lpcs->iNextWave-1;
    if (!fStopping && lpcs->alpWaveHdr[iLastWave]->dwFlags & WHDR_DONE)
        lpcs->fAudioBreak = TRUE;

    // process all done buffers, but no more than iNumAudio at one
    // pass (to avoid getting stuck here forever)
    //
    for (ii = 0; ii < (UINT)lpcs->iNumAudio; ++ii)
    {
        BOOL bPending;

        // if the next buffer is not done, break out of the loop
        // and return to the caller
        //
        lpwh = lpcs->alpWaveHdr[lpcs->iNextWave];
        if (!(lpwh->dwFlags & WHDR_DONE))
            break;
        lpwh->dwFlags &= ~WHDR_DONE;

        // is there any data in the buffer ?
        // if so, do wave stream callback, then write the
        // buffer
        //
        bPending = FALSE;
        if (lpwh->dwBytesRecorded)
        {
            if (lpcs->CallbackOnWaveStream)
               lpcs->CallbackOnWaveStream (lpcs->hwnd, lpwh);

            if ( ! (lpcs->fCaptureFlags & CAP_fCapturingToDisk))
            {
                lpcs->dwWaveChunkCount++;
                lpcs->dwWaveBytes += lpwh->dwBytesRecorded;
            }
            else
            {
                // write the audio buffer, bPending will be true
                // if the write will complete asynchronously
                //
                if ( ! AVIWriteAudio (lpcs, lpwh, lpcs->iNextWave,
                                      lpuError, &bPending))
                    fStopping = TRUE;
            }
        }

        // if we are not writing async, we can put the buffer
        // back on the wave driver's queue now
        //
        if ( ! bPending)
        {
            lpwh->dwBytesRecorded = 0;
	    AuxDebugEx(3, DEBUGLINE "Calling waveInAddBuffer for address %8x", lpwh);
            if (waveInAddBuffer(lpcs->hWaveIn, lpwh, sizeof(WAVEHDR)))
            {
                fStopping = TRUE;
                *lpuError = IDS_CAP_WAVE_ADD_ERROR;
            }
        }

        // increment the next wave buffer pointer
        //
        if (++lpcs->iNextWave >= lpcs->iNumAudio)
            lpcs->iNextWave = 0;
    }

    return fStopping;
}

/*+ ProcessAsyncIOBuffers
 *
 *-===============================================================*/

STATICFN BOOL _inline ProcessAsyncIOBuffers (
    LPCAPSTREAM lpcs,
    BOOL        fStopping,
    LPUINT      lpuError)
{
    UINT      ii;
    struct _avi_async * lpah;

    // if there are no async buffer headers, there is nothing to do!
    //
    *lpuError = 0;
    assert (lpcs->pAsync);

    //
    // process all done buffers, stopping when there are no more outstanding
    // iNextAsync can never go past iLastAsync.
    //
    while(lpcs->iNextAsync != lpcs->iLastAsync)
    {
        DWORD dwUsed;

        // if this async header has never been used,
        // we are done
        //
        lpah = &lpcs->pAsync[lpcs->iNextAsync];
        assert (lpah->uType);

        AuxDebugEx (2, DEBUGLINE "processing async io buffer %d off=%x\r\n",
                    lpcs->iNextAsync, lpah->ovl.Offset);

        // if the next buffer is not done, or failed break
        // out of the loop
        //
        // if the io on this block has already completed (because the IO
        // completed out of order) queue it to the device without waiting
        // otherwise get the next completion status.  If a block has
        // completed, and it is the block at the head of the async queue,
        // then it can be passed straight back to the device queue.  If the
        // completed block is not the one we are expecting, we mark the IO
        // as complete, then return.  Thought..call GetQueuedCompletionStatus
        // in a loop, until there are no more blocks pending.  This way we
        // might get to complete the block we want on this call to
        // ProcessAsyncIOBuffers.
        //
        if (lpah->uType & ASYNCIOPENDING) {
            DWORD dwWritten;
            DWORD key;
            LPOVERLAPPED povl;
            BOOL fResult =
            pfnGetQueuedCompletionStatus(lpcs->hCompletionPort,
                                        &dwWritten,
                                        &key,
                                        &povl,
                                        0);
            if (fResult) {
                // we dequeued a block.  Did we dequeue the one we wanted?
                ((struct _avi_async *)povl)->uType &= ~ASYNCIOPENDING;
                if ((PVOID)povl == (PVOID)lpah) {
                    // this is the one we wanted
                    // fall through and add back to the device queue
                    AuxDebugEx(2,"Dequeued the block we wanted at %8x\r\n", lpah);
                } else {
                    // the io block completed out of order.
                    // Clear the io pending flag and return.
                    AuxDebugEx(1,"Dequeued out of order at %8x\r\n", povl->hEvent);
                    break;
                }
            } else {
                if (povl) {
                    // a failed io operation
                    *lpuError = IDS_CAP_FILE_WRITE_ERROR;
		    AuxDebugEx(1, DEBUGLINE "A failed IO operation (GQCS)\r\n");
                    fStopping = TRUE;
                } else {
                    // nothing completed
		    AuxDebugEx(3, DEBUGLINE "Nothing completed on call to GQCS\r\n");
                    break;
                }
            }
        } else {
            // IO is already complete for this block
        }

        // the buffer is done, so now we need to queue the wave/video
        // buffer back to the wave/video driver
        //

	assert (!(lpah->uType & ASYNCIOPENDING));
        switch (lpah->uType)
        {
            case ASYNC_BUF_VIDEO:
            {
                LPVIDEOHDR lpvh = lpcs->alpVideoHdr[lpah->uIndex];
               #if defined CHICAGO
                if (vidxAddBuffer(lpcs->hVideoIn, lpvh, sizeof (VIDEOHDR)))
               #else
		AuxDebugEx(3, DEBUGLINE "Queueing video buffer lpvh=%x (index %d)\r\n", lpvh, lpah->uIndex);
                if (videoStreamAddBuffer(lpcs->hVideoIn, lpvh, sizeof (VIDEOHDR)))
               #endif
                {
                    fStopping = TRUE;
                    *lpuError = IDS_CAP_VIDEO_ADD_ERROR;
                }
            }
            break;

            case ASYNC_BUF_AUDIO:
            {
                LPWAVEHDR lpwh = lpcs->alpWaveHdr[lpah->uIndex];
                lpwh->dwBytesRecorded = 0;
		AuxDebugEx(3, DEBUGLINE "Queueing audio buffer lpwh=%x (index %d)\r\n", lpwh, lpah->uIndex);
                if (waveInAddBuffer (lpcs->hWaveIn, lpwh, sizeof(WAVEHDR)))
                {
                    fStopping = TRUE;
                    *lpuError = IDS_CAP_WAVE_ADD_ERROR;
                }
            }
            break;

            //case ASYNC_BUF_DROP:
            //{
            //}
            //break;
        }

	// mark the overlapped header structure as vacant
        lpah->uType = 0;
        lpah->uIndex = 0;

        // increment to the next async io buffer
        //
        if (++lpcs->iNextAsync  >= lpcs->iNumAsync)
            lpcs->iNextAsync = 0;  // wrapped...
    }

    return fStopping;
}

/*+ ShowCompletionStatus
 *
 *-===============================================================*/

STATICFN void ShowCompletionStatus (
    LPCAPSTREAM lpcs,
    BOOL        fCapturedOK)
{
    // Notify if there was an error while recording
    //
    if ( ! fCapturedOK)
        errorUpdateError (lpcs, IDS_CAP_RECORDING_ERROR);

    // put up completion message on status line
    //
    if (lpcs->fCaptureFlags & CAP_fCapturingToDisk)
    {
        DWORD dw;

        // The muldiv32 doesn't give 0 if numerator is zero
        dw = 0;
        if (lpcs->dwVideoChunkCount)
            dw = muldiv32(lpcs->dwVideoChunkCount,1000000,lpcs->dwTimeElapsedMS);

        if (lpcs->sCapParms.fCaptureAudio)
        {
            // "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps).  %ld audio bytes (%d.%03d sps)"
            statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOAUDIO,
                  (UINT)(lpcs->dwTimeElapsedMS/1000),
                  (UINT)(lpcs->dwTimeElapsedMS%1000),
                  lpcs->dwVideoChunkCount,
                  lpcs->dwFramesDropped,
                  (UINT)(dw / 1000),
                  (UINT)(dw % 1000),
                  lpcs->dwWaveBytes,
                  (UINT) lpcs->lpWaveFormat->nSamplesPerSec / 1000,
                  (UINT) lpcs->lpWaveFormat->nSamplesPerSec % 1000);
        }
        else
        {
            // "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps)."
            statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOONLY,
                  (UINT)(lpcs->dwTimeElapsedMS/1000),
                  (UINT)(lpcs->dwTimeElapsedMS%1000),
                  lpcs->dwVideoChunkCount,
                  lpcs->dwFramesDropped,
                  (UINT)(dw / 1000),
                  (UINT)(dw % 1000));
        }
    } // endif capturing to disk (no warnings or errors if to net)

    // if capture was successful, warn the user about various abnormal
    // conditions.
    //
    if (fCapturedOK)
    {
        if (lpcs->dwVideoChunkCount == 0)
        {
            // No frames captured, warn user that interrupts are probably not enabled.
            errorUpdateError (lpcs, IDS_CAP_NO_FRAME_CAP_ERROR);
        }
        else if (lpcs->sCapParms.fCaptureAudio && lpcs->dwWaveBytes == 0)
        {
            // No audio captured, warn user audio card is hosed
            errorUpdateError (lpcs, IDS_CAP_NO_AUDIO_CAP_ERROR);
        }
        else if (lpcs->sCapParms.fCaptureAudio && lpcs->fAudioBreak)
        {
            // some of the audio was dropped
            if(lpcs->CompVars.hic) {
		errorUpdateError (lpcs, IDS_CAP_AUDIO_DROP_COMPERROR);
	    } else {
		errorUpdateError (lpcs, IDS_CAP_AUDIO_DROP_ERROR);
	    }
        }
        else if (lpcs->fCaptureFlags & CAP_fCapturingToDisk)
        {
            DWORD dwPctDropped;

            assert (lpcs->dwVideoChunkCount);
            dwPctDropped = 100 * lpcs->dwFramesDropped / lpcs->dwVideoChunkCount;
            //
            // dropped > 10% (default) of the frames
            //
            if (dwPctDropped > lpcs->sCapParms.wPercentDropForError)
                errorUpdateError (lpcs, IDS_CAP_STAT_FRAMESDROPPED,
                      lpcs->dwFramesDropped,
                      lpcs->dwVideoChunkCount,
                      (UINT)(muldiv32(lpcs->dwFramesDropped,10000,lpcs->dwVideoChunkCount)/100),
                      (UINT)(muldiv32(lpcs->dwFramesDropped,10000,lpcs->dwVideoChunkCount)%100)/10
                      );
        }
    }
}

/*
 *  AVI Capture
 *      This is the main streaming capture loop for both audio and
 * video.  It will first init all buffers and drivers and then go into a
 * loop checking for buffers to be filled.  When a buffer is filled then
 * the data for it is written out.
 * Afterwards it cleans up after itself (frees buffers etc...)
 * Returns: 0 on success, else error code
 */
void FAR PASCAL _LOADDS AVICapture1(LPCAPSTREAM lpcs)
{
    BOOL        fCapturedOK = TRUE;
    BOOL        fStopping;         // True when finishing capture
    BOOL        fStopped;          // True if driver notified to stop
    TCHAR       ach[128];
    TCHAR       achMsg[128];
    UINT        wError;         // Error String ID
    LPVIDEOHDR  lpVidHdr;
    LPWAVEHDR   lpWaveHdr;
    DWORD       dwTimeStarted;  // When did we start in milliseconds
    DWORD       dwTimeStopped;
    DWORD       dwTimeToStop;   // Lesser of MCI capture time or frame limit
    BOOL        fTryToPaint = FALSE;
    BOOL        fTryToPaintAgain = FALSE;
    HDC         hdc;
    HPALETTE    hpalT;
    HCURSOR     hOldCursor;
    RECT        rcDrawRect;
    CAPINFOCHUNK cic;
    DWORD       dwOldPrio;
    BOOL        bVideoWritePending;
    LPVIDEOHDR  lpvhDraw;

    lpcs->fCaptureFlags |= CAP_fCapturingNow;
    // we should Assert that CAP_fCapturingNow is already turned on

    lpcs->dwReturn = DV_ERR_OK;

    hOldCursor = SetCursor(lpcs->hWaitCursor);

    statusUpdateStatus(lpcs, IDS_CAP_BEGIN);  // Always the first message

    // If not 1 Meg. free, give it up!!!
    if (GetFreePhysicalMemory () < (1024L * 1024L)) {
        errorUpdateError (lpcs, IDS_CAP_OUTOFMEM);
        goto EarlyExit;
    }

    statusUpdateStatus(lpcs, IDS_CAP_STAT_CAP_INIT);

    // Try painting the DIB only if Live window
    fTryToPaintAgain = fTryToPaint = lpcs->fLiveWindow;

    if (fTryToPaint) {
        hdc = GetDC(lpcs->hwnd);
        SetWindowOrgEx(hdc, lpcs->ptScroll.x, lpcs->ptScroll.y, NULL);
        hpalT = DrawDibGetPalette (lpcs->hdd);
        if (hpalT)
            hpalT = SelectPalette( hdc, hpalT, FALSE);
        RealizePalette(hdc);
        if (lpcs->fScale)
            GetClientRect (lpcs->hwnd, &rcDrawRect);
        else
            SetRect (&rcDrawRect, 0, 0, lpcs->dxBits, lpcs->dyBits);
    }

    // -------------------------------------------------------
    //   When should capture stop?
    // -------------------------------------------------------

    // If using MCI, capture for the shorter of the MCI period,
    // or the capture limit

    if (lpcs->sCapParms.fLimitEnabled)
        dwTimeToStop = (DWORD) ((DWORD) 1000 * lpcs->sCapParms.wTimeLimit);
    else
        dwTimeToStop = (DWORD) -1L; // very large

    if (lpcs->sCapParms.fMCIControl) {
        DWORD dwTime;

        // if MCI stop time not given, use lpcs->sCapParms.wTimeLimit
        if (lpcs->sCapParms.dwMCIStopTime == lpcs->sCapParms.dwMCIStartTime)
                    lpcs->sCapParms.dwMCIStopTime = lpcs->sCapParms.dwMCIStartTime +
                    (DWORD) ((DWORD)1000 * lpcs->sCapParms.wTimeLimit);

        dwTime = lpcs->sCapParms.dwMCIStopTime - lpcs->sCapParms.dwMCIStartTime;

        if (lpcs->sCapParms.fLimitEnabled)
            dwTimeToStop = min (dwTime, dwTimeToStop);
        else
            dwTimeToStop = dwTime;
    }

    //
    // never ever try to capture more than the index size!
    //
    if (lpcs->fCaptureFlags & CAP_fCapturingToDisk)
    {
        DWORD dwTime = MulDiv (lpcs->sCapParms.dwIndexSize,
                               lpcs->sCapParms.dwRequestMicroSecPerFrame,
                               1000l);

        dwTimeToStop = min (dwTime, dwTimeToStop);
    }

    // if doing MCI capture, initialize MCI device.  if init fails
    // go straight to the exit code
    //
    if (lpcs->sCapParms.fMCIControl)
    {
        if ( ! MCIDeviceOpen (lpcs) ||
             ! MCIDeviceSetPosition (lpcs, lpcs->sCapParms.dwMCIStartTime))
        {
            fCapturedOK = FALSE;
            errorUpdateError (lpcs, IDS_CAP_MCI_CONTROL_ERROR);
            statusUpdateStatus(lpcs, 0);    // Clear status
            goto EarlyExit;
        }
    }

    //
    // If we're compressing while capturing, warm up the compressor
    //
   #ifdef NEW_COMPMAN
    if (lpcs->CompVars.hic)
    {
        if ( ! ICSeqCompressFrameStart (&lpcs->CompVars, lpcs->lpBitsInfo))
        {
            // !!! We're in trouble here!
            dprintf("ICSeqCompressFrameStart failed !!!\n");
            errorUpdateError (lpcs, IDS_CAP_COMPRESSOR_ERROR);
            goto EarlyExit;
        }

	// HACK WARNING !!!
        // Kludge, offset the lpBitsOut ptr
        // Compman allocates the compress buffer too large by
        // 2048 + 16 so we will still have room
	// By stepping on 8 bytes we give ourselves room for a RIFF header
        //
        ((LPBYTE)lpcs->CompVars.lpBitsOut) += 8;

        assert(lpcs->CompVars.lpbiOut != NULL);
    }
   #endif

    // -------------------------------------------------------
    //  Open the output file
    // -------------------------------------------------------

    if (lpcs->fCaptureFlags & CAP_fCapturingToDisk) {
	if (!CapFileInit(lpcs))
	{
	    errorUpdateError (lpcs, IDS_CAP_FILE_OPEN_ERROR);
	    goto EarlyExit;
	}
    } else {
        AuxDebugEx (3, DEBUGLINE "Setting dwBytesPerSector to %d\r\n",DEFAULT_BYTESPERSECTOR);
        lpcs->dwBytesPerSector=DEFAULT_BYTESPERSECTOR;
    }

   #ifdef JMK_HACK_TIMERS
    // Allocate memory for logging capture results to the clipboard if requested
    if (GetProfileIntA ("Avicap32", "ClipboardLogging", FALSE))
    {
        AuxDebugEx (2, DEBUGLINE "ClipboardLogging Enabled\r\n");
        InitPerformanceCounters();
        pcBegin(), pctWriteBase = pc.base;

	hMemTimers = GlobalAlloc(GHND | GMEM_ZEROINIT,
                             sizeof(struct _timerriff) +
                             sizeof(struct _timerstuff) * CLIPBOARDLOGSIZE);

	if (hMemTimers && ((DWORD_PTR)(pTimerRiff = GlobalLock (hMemTimers))))
	    ;
	else if (hMemTimers)
	{
	    GlobalFree(hMemTimers);
	    pTimerRiff = 0;
	    pTimerStuff = 0;
	    hMemTimers = 0;
	}
	nTimerIndex = 0;
	nSleepCount = 0;
    }  // if ClipboardLogging
   #endif  // JMK_HACK_TIMERS

    // Make sure the parent has been repainted
    //
    UpdateWindow(lpcs->hwnd);

    //
    // call AVIInit() to get all the capture memory we will need
    //

    wError = IDS_CAP_AVI_INIT_ERROR;
    lpcs->hCaptureEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (lpcs->hCaptureEvent)
    {
       #ifdef CHICAGO
        lpcs->hRing0CapEvt = OpenVxDHandle (lpcs->hCaptureEvent);
        if ( ! lpcs->hRing0CapEvt)
            CloseHandle (lpcs->hCaptureEvent), lpcs->hCaptureEvent = NULL;
        else
       #endif
            wError = AVIInit(lpcs);

    }

    // if avifile init failed, cleanup and return error.
    //
    if (wError)
    {
        // Error in initalization - return
        //
        errorUpdateError (lpcs, wError);
        AVIFini(lpcs);
        AVIFileFini(lpcs, TRUE, TRUE);
        statusUpdateStatus(lpcs, 0);    // Clear status
        goto EarlyExit;
    }

    // Click OK to capture string (must follow AVIInit)
    //
    LoadString(lpcs->hInst, IDS_CAP_SEQ_MSGSTART, ach, NUMELMS(ach));
    // Fix: Change from wsprintf to StringCchPrintf so we don't overrun achMsg
    StringCchPrintf(achMsg, NUMELMS(achMsg), ach, (LPBYTE)lpcs->achFile);

    // clear status
    //
    statusUpdateStatus(lpcs, 0);

    // -------------------------------------------------------
    //   Ready to go, make the user click OK?
    // -------------------------------------------------------

    if (lpcs->sCapParms.fMakeUserHitOKToCapture && (lpcs->fCaptureFlags & CAP_fCapturingToDisk))
    {
        UINT idBtn;

        idBtn = MessageBox (lpcs->hwnd, achMsg, TEXT(""),
                            MB_OKCANCEL | MB_ICONEXCLAMATION);

        if (idBtn == IDCANCEL)
        {
            AVIFini(lpcs);
            AVIFileFini (lpcs, TRUE, TRUE);
            statusUpdateStatus (lpcs, 0);
            goto EarlyExit;
        }
    }

    // update the status, so the user knows how to stop
    //
    statusUpdateStatus(lpcs, IDS_CAP_SEQ_MSGSTOP);
    UpdateWindow(lpcs->hwnd);

    // this should be an ASSERT.  After all, we turned the flag on at the
    // top of the routine
    //lpcs->fCaptureFlags |= CAP_fCapturingNow;

    // query async key states to 'reset' them to current values
    //
    GetAsyncKeyState(lpcs->sCapParms.vKeyAbort);
    GetAsyncKeyState(VK_ESCAPE);
    GetAsyncKeyState(VK_LBUTTON);
    GetAsyncKeyState(VK_RBUTTON);

    // Insert the digitization time
    // strings written to the file should be ascii, since this is
    // an ascii file format.
    //
    //
    // no point in pulling in the whole C runtime just to get a silly
    // timestamp, so we just cook the system time into ascii right here.
    //
    {
    SYSTEMTIME time;
    // Note: both szDay and szMonth are explicitly null-terminated by virtue
    // of being C strings ... "xxx"
    static char szDay[] = "Sun\0Mon\0Tue\0Wed\0Thu\0Fri\0Sat";
    #define DAYLENGTH (sizeof(szDay)/7)
    static char szMonth[] = "Jan\0Feb\0Mar\0Apr\0May\0Jun\0Jul\0Aug\0Sep\0Oct\0Nov\0Dec";
    #define MONTHLENGTH (sizeof(szMonth)/12)
    char sz[30];

    GetLocalTime (&time);
    // note: GetLocalTime returns months in range 1-12
    //                    returns days in range 0-6

    //example: Fri Apr 29  8:25:12 1994
    wsprintfA(sz, "%s %s %2d %2d:%02d:%02d %4d",
              szDay + time.wDayOfWeek * DAYLENGTH,
              szMonth-MONTHLENGTH + time.wMonth * MONTHLENGTH,
              time.wDay, time.wHour, time.wMinute, time.wSecond, time.wYear);

    cic.fccInfoID = mmioFOURCC ('I','D','I','T');
    cic.lpData = sz;
    cic.cbData = 25;		  // WARNING: this length is static.
    SetInfoChunk (lpcs, &cic);
    }

    // -------------------------------------------------------
    //   Start MCI, Audio, and video streams
    // -------------------------------------------------------

    // Callback will preroll, then return on frame accurate postion
    // The 1 indicates recording is about to start
    // Callback can return FALSE to exit without capturing
    //
    if (lpcs->CallbackOnControl &&
        !lpcs->CallbackOnControl(lpcs->hwnd, CONTROLCALLBACK_PREROLL))
    {
        AVIFini(lpcs);
        AVIFileFini(lpcs, TRUE, TRUE);
        statusUpdateStatus(lpcs, 0);
        goto EarlyExit;
    }

    dwOldPrio = GetThreadPriority(GetCurrentThread());
    if (dwOldPrio != THREAD_PRIORITY_HIGHEST)
        SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

   #ifdef JMK_HACK_TIMERS
    if (pTimerRiff)
    {
	UINT ii;

        pTimerRiff->fccRIFF = RIFFTYPE('RIFF'); //MAKEFOURCC('R','I','F','F');
	pTimerRiff->cbTotal = sizeof(struct _timerriff) - 8 +
	    		  sizeof(struct _timerstuff) * CLIPBOARDLOGSIZE;
        pTimerRiff->fccJMKD = RIFFTYPE('JMKD'); //MAKEFOURCC('J','M','K','D');
        pTimerRiff->fccVCHD = RIFFTYPE('VCHD'); //MAKEFOURCC('V','C','H','D');
	
	pTimerRiff->cbVCHD  = sizeof(struct _vchd);
	pTimerRiff->vchd.nPrio = GetThreadPriority(GetCurrentThread());
	pTimerRiff->vchd.bmih = lpcs->lpBitsInfo->bmiHeader;
	pTimerRiff->vchd.cap  = lpcs->sCapParms;
	pTimerRiff->vchd.dwDropFramesAppended = 0;
	pTimerRiff->vchd.dwDropFramesNotAppended = 0;
        pTimerRiff->vchd.dwTimerFrequency = pcGetTickRate();
	
	for (ii = 0; ii < NUMELMS(pTimerRiff->vchd.atvh); ++ii)
	{
	    if (lpcs->alpVideoHdr[ii])
            {
	        struct _thkvideohdr * ptvh = (LPVOID)lpcs->alpVideoHdr[ii];
               #ifndef CHICAGO
                assert (sizeof(CAPVIDEOHDR) == sizeof(*ptvh));
               #endif
                pTimerRiff->vchd.atvh[ii] = *ptvh;
                pTimerRiff->vchd.nMaxVideoBuffers = ii;
            }
        }
	
        pTimerRiff->fccChunk = RIFFTYPE('VCAP'); //MAKEFOURCC('V','C','A','P');
	pTimerRiff->cbChunk = pTimerRiff->cbTotal - sizeof(*pTimerRiff);
	
	pTimerStuff = (LPVOID)(pTimerRiff + 1);
	pCurTimerStuff = &pTimerStuff[0];
    }  // fClipboardLogging
   #endif  // JMK_HACK_TIMERS

    // make sure that the fat is loaded before we begin capturing
    //
    AVIPreloadFat (lpcs);

    // start the MCI device
    //
    if (lpcs->sCapParms.fMCIControl)
        MCIDevicePlay (lpcs);

    dwTimeStarted = timeGetTime();

    // start audio & video streams
    //
    if (lpcs->sCapParms.fCaptureAudio)
        waveInStart(lpcs->hWaveIn);
    videoStreamStart(lpcs->hVideoIn);

    // -------------------------------------------------------
    //   MAIN CAPTURE LOOP
    // -------------------------------------------------------

    fCapturedOK=TRUE;
    fStopping = FALSE;    // TRUE when we need to stop
    fStopped = FALSE;     // TRUE if drivers notified we have stopped
    lpcs->dwTimeElapsedMS = 0;

    assert (lpcs->iNextVideo == 0);
    if (lpcs->sCapParms.fCaptureAudio) {
	assert (lpcs->iNextWave == 0);
	lpWaveHdr = lpcs->alpWaveHdr[lpcs->iNextWave];
	// lpWaveHdr is only interesting when we capture audio
    }

    lpVidHdr = lpcs->alpVideoHdr[lpcs->iNextVideo];

    DPF("Start of main capture loop");

    for (;;)
    {

        // The INTEL driver uses the GetError message to
        // process buffers, so call it often...
        // FIX JAYBO        videoStreamGetError (lpcs->hVideoIn, &dwStreamError, &dwDriverDropCount);


        // if there are no buffers to process, we either wait
        // or leave the loop forever (depending on whether we expect
        // more buffers to be done in the future)
        //
        if (!(lpVidHdr->dwFlags & VHDR_DONE) &&
            !(lpcs->sCapParms.fCaptureAudio
	        && (lpWaveHdr->dwFlags & WHDR_DONE)))
        {
            if (fStopped)
                break;

           #ifdef JMK_HACK_TIMERS
            if (pCurTimerStuff)
            {
               pCurTimerStuff->nSleepCount = ++nSleepCount;
               pCurTimerStuff->dwSleepBegin = pcGetTicks();
            }
           #endif

	    AuxDebugEx(2,DEBUGLINE "***** Waiting for something interesting to happen while capturing\r\n");
            WaitForSingleObject (lpcs->hCaptureEvent, 300);

           #ifdef JMK_HACK_TIMERS
            if (pCurTimerStuff)
	    {
               pCurTimerStuff->dwSleepEnd = pcGetTicks();
	    }
           #endif
        }

        // What time is it?
        lpcs->dwTimeElapsedMS = timeGetTime() - dwTimeStarted;

        // -------------------------------------------------------
        //        Is video buffer ready to be written?
        // -------------------------------------------------------

        if ((DWORD)(fStopping = ProcessNextVideoBuffer (lpcs,
                                                fStopping,
                                                &wError,
                                                &lpvhDraw,  // captured frame to draw if time permits
                                                &bVideoWritePending))) // TRUE if Write pending on lpvhDraw
        {
            AuxDebugEx (1, DEBUGLINE "ProcessVideo stopping\r\n");
            if (wError)
            {
                AuxDebugEx (1, DEBUGLINE "ProcessVideo return error %d\r\n", wError);
                errorUpdateError (lpcs, wError);
                fCapturedOK = FALSE;
                break;
            }
        }
        lpVidHdr = lpcs->alpVideoHdr[lpcs->iNextVideo];

        // if there is still more time, (or at least every 100 frames)
        // show status if we're not ending the capture
        //
        if (!fStopping &&
            (lpcs->fCaptureFlags & CAP_fCapturingToDisk) &&
            (!(lpVidHdr->dwFlags & VHDR_DONE) ||
              (lpcs->dwVideoChunkCount && (lpcs->dwVideoChunkCount % 100 == 0))))
        {
            // Captured %ld frames (Dropped %ld) %d.%03d sec. Hit Escape to Stop
            //
            statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOCURRENT,
                               lpcs->dwVideoChunkCount,
                               lpcs->dwFramesDropped,
                               (UINT)(lpcs->dwTimeElapsedMS/1000),
                               (UINT)(lpcs->dwTimeElapsedMS%1000));
        }

        // If the yield callback returns FALSE, abort
        //
        if (lpcs->CallbackOnYield && !lpcs->CallbackOnYield (lpcs->hwnd))
            fStopping = TRUE;

       #if 0 // this is a 16 bit ism??
        // Don't do peekMessage yield for ACM
        if (lpcs->sCapParms.fYield) {
            MSG msg;

            if (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
                // Kludge to get rid of timers from lpcs->hwnd
                if (msg.message == WM_TIMER && msg.hwnd == lpcs->hwnd)
                    ;
                else {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }
       #endif

        // Outside routine is handling when to stop
        // The CONTROLCALLBACK_CAPTURING indicates we're asking when to stop
        //
        if (lpcs->CallbackOnControl &&
            !lpcs->CallbackOnControl (lpcs->hwnd, CONTROLCALLBACK_CAPTURING))
            fStopping = TRUE;

        // -------------------------------------------------------
        //        Is audio buffer ready to be written?
        // -------------------------------------------------------

        if (lpcs->sCapParms.fCaptureAudio) {
            if ((DWORD)(fStopping = ProcessAudioBuffers (lpcs, fStopping, &wError)))
            {
                AuxDebugEx (1, DEBUGLINE "ProcessAudio stopping\r\n");
                if (wError)
                {
                    AuxDebugEx (1, DEBUGLINE "ProcessAudio return error %d\r\n", wError);
                    errorUpdateError (lpcs, wError);
                    fCapturedOK = FALSE;
                    break;
                }
            }
	    lpWaveHdr = lpcs->alpWaveHdr[lpcs->iNextWave];
	}

        // if we are not writing the frame async, we can put the video buffer
        // back on the video driver's queue now
        //
        if (lpvhDraw)
        {

            // if the next video header is not ready yet, and
            // we have no outstanding io buffers (in async mode) draw
            // the current one
            //
            if ( !(lpVidHdr->dwFlags & VHDR_DONE) &&
                (!lpcs->pAsync ||
                 (lpcs->iNextAsync+2 >= lpcs->iLastAsync)) &&
                lpvhDraw->dwBytesUsed)
            {
                AuxDebugEx (4, DEBUGLINE "time enough to draw!\r\n");
                if (fTryToPaintAgain &&
                    lpcs->dwVideoChunkCount &&
                    lpvhDraw->dwFlags & VHDR_KEYFRAME)
                {
                    fTryToPaintAgain = DrawDibDraw(lpcs->hdd, hdc,
                            0, 0,
                            rcDrawRect.right - rcDrawRect.left,
                            rcDrawRect.bottom - rcDrawRect.top,
                            /*lpcs->dxBits, lpcs->dyBits, */
                            (LPBITMAPINFOHEADER)lpcs->lpBitsInfo,
                            lpvhDraw->lpData, 0, 0, -1, -1,
                            DDF_SAME_HDC | DDF_SAME_DIB | DDF_SAME_SIZE);
                }
            }

            // if there is not a write pending for the draw frame
            // put it back into the video drivers queue now
            //
            if ( ! bVideoWritePending)
            {
		AuxDebugEx(3, DEBUGLINE "Queueing video buffer, lpvh=%8x", lpvhDraw);

                // return the emptied buffer to the que
                //
               #if defined CHICAGO
                if (vidxAddBuffer(lpcs->hVideoIn, lpvhDraw, sizeof (VIDEOHDR)))
               #else

                if (videoStreamAddBuffer(lpcs->hVideoIn, lpvhDraw, sizeof (VIDEOHDR)))
               #endif
                {
                    AuxDebugEx (2, DEBUGLINE "Failed to Queue Video buffer %08x\r\n", lpvhDraw);
                    errorUpdateError (lpcs, IDS_CAP_VIDEO_ADD_ERROR);
                    fCapturedOK = FALSE;
                    fStopping = TRUE;
                    break;
                }
            }
        }

        // ------------------------------------------------------------
        //        Any completed I/O buffers?
        // ------------------------------------------------------------

        if (lpcs->pAsync)
            if ((DWORD)(fStopping = ProcessAsyncIOBuffers (lpcs, fStopping, &wError)))
            {
                if (wError)
                {
                    errorUpdateError (lpcs, wError);
                    fCapturedOK = FALSE;
                    break;
                }
            }

        // -------------------------------------------------------
        //        is there any reason to stop?
        // -------------------------------------------------------

        if (!fStopping)
        {
            if (lpcs->sCapParms.vKeyAbort &&
                (GetAsyncKeyState(lpcs->sCapParms.vKeyAbort & 0x00ff) & 0x0001))
            {
                BOOL fT = TRUE;
                if (lpcs->sCapParms.vKeyAbort & 0x8000)  // Ctrl?
                    fT = fT && (GetAsyncKeyState(VK_CONTROL) & 0x8000);
                if (lpcs->sCapParms.vKeyAbort & 0x4000)  // Shift?
                    fT = fT && (GetAsyncKeyState(VK_SHIFT) & 0x8000);
                fStopping = fT;      // User aborts
            }
            if (lpcs->sCapParms.fAbortLeftMouse && (GetAsyncKeyState(VK_LBUTTON) & 0x0001))
                fStopping = TRUE;      // User aborts
            if (lpcs->sCapParms.fAbortRightMouse && (GetAsyncKeyState(VK_RBUTTON) & 0x0001))
                fStopping = TRUE;      // User aborts
            if ((lpcs->fCaptureFlags & CAP_fAbortCapture) || (lpcs->fCaptureFlags & CAP_fStopCapture))
                fStopping = TRUE;          // Somebody above wants us to quit
            if (lpcs->dwTimeElapsedMS > dwTimeToStop)
                fStopping = TRUE;      // all done

           #ifdef DEBUG
            if (fStopping)
               AuxDebugEx (1, DEBUGLINE "user stop\r\n");
           #endif
        }

        // -------------------------------------------------------
        //        Tell all the devices to stop
        // -------------------------------------------------------

        if (fStopping)
        {
            if ( ! fStopped)
            {
                fStopped = TRUE;
                DSTATUS(lpcs, "Stopping....");

                if (lpcs->sCapParms.fCaptureAudio)
                {
                    DSTATUS(lpcs, "Stopping Audio");
                    waveInStop(lpcs->hWaveIn);
                }

                DSTATUS(lpcs, "Stopping Video");
                videoStreamStop(lpcs->hVideoIn);         // Stop everybody

                dwTimeStopped = timeGetTime ();

                if (lpcs->sCapParms.fMCIControl)
                {
                    DSTATUS(lpcs, "Stopping MCI");
                    MCIDevicePause (lpcs);
                }
                DSTATUS(lpcs, "Stopped");

                // Force cursor back to hourglass
                //
                SetCursor(lpcs->hWaitCursor);
            }

            // "Finished capture, now writing frame %ld"
            //
            if (fCapturedOK)
                statusUpdateStatus(lpcs, IDS_CAP_STAT_CAP_FINI, lpcs->dwVideoChunkCount);
            else
            {
                statusUpdateStatus(lpcs, IDS_CAP_RECORDING_ERROR2);
                break;
            }

	    // Wait for all the async IO to complete ??
	    //
        }

    // -------------------------------------------------------
    //   END OF MAIN CAPTURE LOOP
    // -------------------------------------------------------
    }

    DPF("End of main capture loop");

    // eat any keys that have been pressed
    //
    while(GetKey(FALSE))
        ;

    // flush stuff to disk, close everything etc.
    //
    AVIFini(lpcs);
    AVIFileFini(lpcs, TRUE, !fCapturedOK);

    // This is the corrected capture duration, based on audio samples
    lpcs->dwTimeElapsedMS = lpcs->dwActualMicroSecPerFrame *
                            lpcs->dwVideoChunkCount / 1000;

    // update the status line with information about the completed
    // capture, or with erroor information
    //
    ShowCompletionStatus (lpcs, fCapturedOK);

EarlyExit:

    //
    // If we we're compressing while capturing, close it down
    //
   #ifdef NEW_COMPMAN
    if (lpcs->CompVars.hic) {
        // Kludge, reset the lpBitsOut pointer
        if (lpcs->CompVars.lpBitsOut)
            ((LPBYTE) lpcs->CompVars.lpBitsOut) -= 8;
        ICSeqCompressFrameEnd(&lpcs->CompVars);
    }
   #endif

    if (fTryToPaint) {
        if (hpalT)
             SelectPalette(hdc, hpalT, FALSE);
        ReleaseDC (lpcs->hwnd, hdc);
    }

    if (lpcs->sCapParms.fMCIControl)
        MCIDeviceClose (lpcs);

    // Let the user see where capture stopped
    if ((!lpcs->fLiveWindow) && (!lpcs->fOverlayWindow))
        videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );
    InvalidateRect( lpcs->hwnd, NULL, TRUE);

    SetThreadPriority (GetCurrentThread(), dwOldPrio);
    SetCursor(hOldCursor);

    lpcs->fCapFileExists = (lpcs->dwReturn == DV_ERR_OK);
    lpcs->fCaptureFlags &= ~CAP_fCapturingNow;

    statusUpdateStatus(lpcs, IDS_CAP_END);      // Always the last message

   #ifdef JMK_HACK_TIMERS
    if (pTimerRiff)
    {
        UINT    ii;
	UINT	kk;
        LPSTR   psz;
        HGLOBAL hMem;

        kk = (lpcs->dwVideoChunkCount >= CLIPBOARDLOGSIZE) ?
			CLIPBOARDLOGSIZE : nTimerIndex;

        hMem = GlobalAlloc (GHND, (16 * 5 + 2) * kk + 80);
	
        if (hMem && ((DWORD_PTR)(psz = GlobalLock (hMem))))
        {
            pTimerRiff->vchd.dwFramesCaptured = lpcs->dwVideoChunkCount;
            pTimerRiff->vchd.dwFramesDropped = lpcs->dwFramesDropped;

            pTimerRiff->cbTotal = sizeof(struct _timerriff) - 8 +
                                  sizeof(struct _timerstuff) * nTimerIndex;
            pTimerRiff->cbChunk = pTimerRiff->cbTotal - sizeof(*pTimerRiff);

            lstrcpyA(psz, "Slot#, VideoIndex, ExpectedTime, DriverTime, AccumulatedDummyFrames, CurrentAppendedDummies");
            for (ii = 0; ii < kk; ++ii)
            {
                psz += lstrlenA(psz);
                wsprintfA(psz, "\r\n%d, %ld, %ld, %ld, %d, %d",
			  ii,
			  pTimerStuff[ii].dwVideoChunkCount,
                          pTimerStuff[ii].dwFrameTickTime,
                          pTimerStuff[ii].dwFrameStampTime,
                          pTimerStuff[ii].nDummyFrames,
			  pTimerStuff[ii].nFramesAppended
                          );
            }

            GlobalUnlock (hMem);
            GlobalUnlock (hMemTimers);

            if (OpenClipboard (lpcs->hwnd))
            {
                EmptyClipboard ();
                SetClipboardData (CF_RIFF, hMemTimers);
                SetClipboardData (CF_TEXT, hMem);
                CloseClipboard ();
            }
            else
            {
                GlobalFree (hMem);
                GlobalFree (hMemTimers);
            }
        }
        else
        {
            // Failed to allocate or lock hMem.  Cleanup.
            //
            if (hMem)
                GlobalFree(hMem);

            // Free off the timer block.  (We have not set the
            // clipboard data.)
            //
            if (hMemTimers)
            {
                GlobalUnlock(hMemTimers);
                GlobalFree(hMemTimers);
            }
        }

        hMemTimers = NULL;
        pTimerRiff = NULL;
	pTimerStuff = NULL;
	pCurTimerStuff = NULL;
    }
   #endif

    return;
}


// Returns TRUE if the capture task was created, or
// capture completed OK.

BOOL AVICapture (LPCAPSTREAM lpcs)
{
    CAPINFOCHUNK cic;
    void (WINAPI _LOADDS * pfnCapture) (LPCAPSTREAM lpcs);

    if (lpcs->fCaptureFlags & CAP_fCapturingNow) {

	AuxDebugEx(4, DEBUGLINE "rejecting capture as previous capture still running\r\n");
        return IDS_CAP_VIDEO_OPEN_ERROR;
    }

    // if there is a previous capture thread, wait for it to finish and
    // clean it up
    // -it has set fCapturingNow to FALSE, so it will end 'soon' !
    if (lpcs->hThreadCapture) {
	AuxDebugEx(4, DEBUGLINE "Starting capture while previous capture thread still active\r\n");
        WaitForSingleObject(lpcs->hThreadCapture, INFINITE);

	CloseHandle(lpcs->hThreadCapture);
	lpcs->hThreadCapture = NULL;
    }

    // Turn off the STOP and ABORT capture bits
    lpcs->fCaptureFlags &= ~(CAP_fStopCapture | CAP_fAbortCapture);
    lpcs->dwReturn      = 0;

#if DONT_CLEAR_SMPTE_JAYBO
    // Prior to Win95, we always cleared out old SMPTE chunks,
    // but since Adobe may have created a chunk manually, don't
    // zap existing chunks.
    cic.fccInfoID = mmioFOURCC ('I','S','M','T');
    cic.lpData = NULL;
    cic.cbData = 0;
    SetInfoChunk (lpcs, &cic);
#endif

    // And get ready to write a SMPTE info chunk
    if (lpcs->sCapParms.fMCIControl) {
        // create SMPTE string
	CHAR szSMPTE[40];  // must write ansi
        TimeMSToSMPTE (lpcs->sCapParms.dwMCIStartTime, szSMPTE);
        cic.lpData = szSMPTE;
        cic.cbData = lstrlenA(szSMPTE) + 1;
        cic.fccInfoID = mmioFOURCC ('I','S','M','T');
        SetInfoChunk (lpcs, &cic);
    }

    // set pfnCapture to point to the capture function of choice.
    // Use an MCI device to do step capture capture???
    // assume No MCI device, just a normal streaming capture
    //
    pfnCapture = AVICapture1;
    if (lpcs->sCapParms.fStepMCIDevice && lpcs->sCapParms.fMCIControl)
        pfnCapture = MCIStepCapture;

    // if the fYield flag is true, create a thread to do the
    // capture loop.  otherwise do the capture loop inline
    //
    if (lpcs->sCapParms.fYield)
    {
        DWORD tid;

        lpcs->fCaptureFlags |= CAP_fCapturingNow;
	// future operations on this thread are now locked out.
	// we must turn this flag off if the thread creation fails

        lpcs->hThreadCapture = CreateThread (NULL,
                                             0,
                                             (LPTHREAD_START_ROUTINE) pfnCapture,
                                             lpcs,
                                             0,
                                             &tid);


        // if thread creation failed, turn off the capturing flag
        //
        if ( ! lpcs->hThreadCapture) {
	    AuxDebugEx(1,"Failed to create capture thread");
            lpcs->fCaptureFlags &= ~CAP_fCapturingNow;
	}

        return (lpcs->hThreadCapture != NULL);
    }
    else
    {
        pfnCapture (lpcs);
        return (0 == lpcs->dwReturn);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\avicapi.h ===
/****************************************************************************
 *
 *   avicapi.h
 *
 *   Internal, private definitions.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

//  This stuff is not going to work 64-bit
#pragma warning(disable:4312)


#ifndef _INC_AVICAP_INTERNAL
#define _INC_AVICAP_INTERNAL

#define ASYNCIO_PORT
#include <vfw.h>

#include <mmreg.h>
#include "iaverage.h"

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

/* c8 uses underscores on all defines */
#if defined DEBUG && !defined _DEBUG
 #define _DEBUG
#elif defined _DEBUG && !defined DEBUG
 #define DEBUG
#endif

#ifdef ASYNCIO_PORT
extern HINSTANCE hmodKernel;
extern HANDLE (WINAPI *pfnCreateIoCompletionPort)(
    HANDLE FileHandle,
    HANDLE ExistingCompletionPort,
    DWORD CompletionKey,
    DWORD NumberOfConcurrentThreads
    );

extern BOOL (WINAPI *pfnGetQueuedCompletionStatus)(
    HANDLE CompletionPort,
    LPDWORD lpNumberOfBytesTransferred,
    LPDWORD lpCompletionKey,
    LPOVERLAPPED *lpOverlapped,
    DWORD dwMilliseconds
    );

#endif

#if !defined NUMELMS
  #define NUMELMS(aa)           (sizeof(aa)/sizeof((aa)[0]))
  #define FIELDOFF(type,field)  (&(((type)0)->field))
  #define FIELDSIZ(type,field)  (sizeof(((type)0)->field))
#endif

//
// use the registry - not WIN.INI
//
#if defined(_WIN32) && defined(UNICODE)
#include "profile.h"
#endif

// switch off all references to the new vfw1.1 compman interfaces until we
// have the new compman ported to NT
#define NEW_COMPMAN

#ifndef _LPHISTOGRAM_DEFINED
#define _LPHISTOGRAM_DEFINED
typedef DWORD HUGE * LPHISTOGRAM;
#endif

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) ((int)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount))

// Swap palette entries around
#ifdef DEBUG
#define SWAPTYPE(x,y, type)  { type _temp_; _temp_=(x); (x)=(y), (y)=_temp_;}
#else
#define SWAPTYPE(x,y, type) ( (x)^=(y), (y)^=(x), (x)^=(y) )
#endif

#define ROUNDUPTOSECTORSIZE(dw, align) ((((DWORD_PTR)dw) + ((DWORD_PTR)align)-1) & ~(((DWORD_PTR)(align))-1))

#define MAX_VIDEO_BUFFERS       400    // By using this number the CAPSTREAM structure fits into a page
#define MIN_VIDEO_BUFFERS       5
#define DEF_WAVE_BUFFERS        4
#define MAX_WAVE_BUFFERS        10

// MCI Capture state machine
enum mcicapstates {
   CAPMCI_STATE_Uninitialized = 0,
   CAPMCI_STATE_Initialized,

   CAPMCI_STATE_StartVideo,
   CAPMCI_STATE_CapturingVideo,
   CAPMCI_STATE_VideoFini,

   CAPMCI_STATE_StartAudio,
   CAPMCI_STATE_CapturingAudio,
   CAPMCI_STATE_AudioFini,

   CAPMCI_STATE_AllFini
};

// -------------------------
//  CAPSTREAM structure
// -------------------------
#define CAPSTREAM_VERSION 3             // Increment whenever struct changes
#define DEFAULT_BYTESPERSECTOR  512

// This structure is GlobalAlloc'd for each capture window instance.
// A pointer to the structure is stored in the Window extra bytes.
// Applications can retrieve a pointer to the stucture using
//    the WM_CAP_GET_CAPSTREAMPTR message.
// I: internal variables which the client app should not modify
// M: variables which the client app can set via Send/PostMessage

typedef struct tagCAPSTREAM {
    DWORD           dwSize;                     // I: size of structure
    UINT            uiVersion;                  // I: version of structure
    HINSTANCE       hInst;                      // I: our instance

    HANDLE          hThreadCapture;             // I: capture task handle
    DWORD           dwReturn;                   // I: capture task return value

    HWND            hwnd;                       // I: our hwnd

    // Use MakeProcInstance to create all callbacks !!!
    // Status, error callbacks
    CAPSTATUSCALLBACK   CallbackOnStatus;       // M: Status callback
    CAPERRORCALLBACK    CallbackOnError;        // M: Error callback

#ifdef UNICODE
    DWORD  fUnicode;				// I:
    // definitions for fUnicode
    #define  VUNICODE_ERRORISANSI	0x00000001      // set if error msg thunking required
    #define  VUNICODE_STATUSISANSI	0x00000002      // set if status msg thunking required
#endif

    // event used in capture loop to avoid polling
    HANDLE hCaptureEvent;		  	// I:
#ifdef ASYNCIO_PORT
    HANDLE heSyncWrite;                         // I: Create an event for sync write
#endif
   #ifdef CHICAGO
    DWORD  hRing0CapEvt;			// I:
   #else
#ifdef ASYNCIO_PORT
    HANDLE pfnIOCompletionPort;                 // I: NT: async IO completion port creation
    HANDLE hCompletionPort;
#endif
   #endif

    // Allows client to process messages during capture if set
    CAPYIELDCALLBACK    CallbackOnYield;        // M: Yield processing

    // Video and wave callbacks for Network or other specialized xfers
    CAPVIDEOCALLBACK    CallbackOnVideoFrame;   // M: Only during preview
    CAPVIDEOCALLBACK    CallbackOnVideoStream;  // M: Video buffer ready
    CAPWAVECALLBACK     CallbackOnWaveStream;   // M: Wave buffer ready
    CAPCONTROLCALLBACK  CallbackOnControl;      // M: External Start/Stop ctrl

    // Open channels on the video hardware device
    // and hardware capabilies
    CAPDRIVERCAPS   sCapDrvCaps;                // M: What can the driver do
    HVIDEO          hVideoIn;                   // I: In channel
    HVIDEO          hVideoCapture;              // I: Ext In channel
    HVIDEO          hVideoDisplay;              // I: Ext Out channel
    BOOL            fHardwareConnected;         // I: ANY open channel?

    // Flags indicating whether dialog boxes are currently displayed
#define VDLG_VIDEOSOURCE	0x00000001	// Video Source dialog
#define VDLG_VIDEOFORMAT	0x00000002	// Video Format dialog
#define VDLG_VIDEODISPLAY	0x00000004	// Video Display dialog
#define VDLG_COMPRESSION	0x00000008	// Video Compression dialog
    DWORD           dwDlgsActive;		// I: state of dialogs

    // Window to display video
    BOOL            fLiveWindow;                // M: Preview video
    BOOL            fOverlayWindow;             // M: Overlay video
    BOOL            fScale;                     // M: Scale image to client
    POINT           ptScroll;                   // I: Scroll position
    HANDLE          hdd;                        // I: hDrawDib access handle
    HCURSOR         hWaitCursor;                // I: hourglass
    UINT            uiRegion;                   // I: CheckWindowMove
    RECT            rcRegionRect;               // I: CheckWindowMove
    POINT	    ptRegionOrigin;

    // Window update timer
    UINT_PTR        idTimer;                    // I: ID of preview timer
    UINT            uTimeout;                   // M: Preview rate in mS. (not used after setting the timer)

    // Capture destination and control
    CAPTUREPARMS    sCapParms;                  // M: how to capture

    BOOL 	    fCaptureFlags;		//    state of capture

// definitions of fCaptureFlags
#define CAP_fCapturingToDisk		0x0001  // M: if capturing to disk
#define CAP_fCapturingNow		0x0002  // I: if performing capture
#define CAP_fStepCapturingNow           0x0004  // I: if performing MCI step capture
#define CAP_fFrameCapturingNow          0x0008  // I: if performing single frame capture
#define CAP_fStopCapture                0x0010  // M: if stop requested
#define CAP_fAbortCapture               0x0020  // M: if abort requested
#define CAP_fDefaultVideoBuffers        0x0040  //    using default number of video buffers
#define CAP_fDefaultAudioBuffers        0x0080  //    using default number of audio buffers

    DWORD           dwTimeElapsedMS;            // I: Capture time in millisec

    // Index
    HGLOBAL         hIndex;                     // I: handle to index mem
    DWORD           dwIndex;                    // I: index index
    DWORD           dwVideoChunkCount;          // I: # of video frames cap'd
    DWORD           dwWaveChunkCount;           // I: # of audio buffers cap'd
    LPDWORD         lpdwIndexStart;             // I: index start ptr
    LPDWORD         lpdwIndexEntry;             // I: index current ptr

    // Video format
    DWORD           dwActualMicroSecPerFrame;   // I: Actual cap rate
    LPBITMAPINFO    lpBitsInfo;                 // I: Video format
    int             dxBits;                     // I: video size x
    int             dyBits;                     // I: video size y
    LPBYTE          lpBits;                     // I: Single frame capture buf
    LPBYTE          lpBitsUnaligned;            // I: Single frame capture buf
    VIDEOHDR        VidHdr;                     // I: Single frame header

#ifdef 	NEW_COMPMAN
    COMPVARS        CompVars;                   // M: Set by ICCompressorChoose
#endif

    LPIAVERAGE      lpia;                       // I: Image averaging struct
    VIDEOHDR        VidHdr2x;                   // I: VideoHeader at 2x
    LPBITMAPINFOHEADER  lpbmih2x;               // I: lpbi at 2x

    // Video Buffer management
    DWORD           cbVideoAllocation;          // I: size of non-comp buffer incl chunk (not used)
    int             iNumVideo;                  // I: Number of actual video buffers
    int             iNextVideo;                 // I: index into video buffers
    DWORD           dwFramesDropped;            // I: number of frames dropped
    LPVIDEOHDR      alpVideoHdr[MAX_VIDEO_BUFFERS]; // I: array of video buffer headers
    BOOL            fBuffersOnHardware;         // I: if driver all'd buffers
    LPSTR           lpDropFrame;

    // Palettes
    HPALETTE        hPalCurrent;                // I: handle of current pal
    BOOL            fUsingDefaultPalette;       // I: no user defined pal
    int             nPaletteColors;             // M: only changed by UI
    LPVOID          lpCapPal;                   // I: LPCAPPAL manual pals
    LPVOID          lpCacheXlateTable;          // I: 32KB xlate table cached

    // Audio Capture Format
    BOOL            fAudioHardware;             // I: if audio hardware present
    LPWAVEFORMATEX  lpWaveFormat;               // I: wave format
    WAVEHDR         WaveHdr;                    // I: Wave header
    HWAVEIN         hWaveIn;                    // I: Wave input channel
    DWORD           dwWaveBytes;                // I: Total wave bytes cap'd
    DWORD           dwWaveSize;                 // I: wave buffer size

    // Audio Buffer management
    LPWAVEHDR       alpWaveHdr[MAX_WAVE_BUFFERS]; // I: wave buff array
    int             iNextWave;                  // I: Index into wave buffers
    int             iNumAudio;                  // I: Number of actual audio buffers
    BOOL            fAudioYield;                // I: ACM audio yield required
    BOOL            fAudioBreak;                // I: Audio underflow

    // MCI Capture
    TCHAR           achMCIDevice[MAX_PATH];     // MCI device name
    DWORD           dwMCIError;                 // I: Last MCI error value
    enum mcicapstates MCICaptureState;          // I: MCI State machine
    DWORD           dwMCICurrentMS;             // I: Current MCI position
    DWORD           dwMCIActualStartMS;         // I: Actual MCI start MS
    DWORD           dwMCIActualEndMS;           // I: Actual MCI end position

    // Output file
    TCHAR           achFile [MAX_PATH];         // M: name of capture file
    TCHAR           achSaveAsFile [MAX_PATH];   // M: name of saveas file
    LONG            lCapFileSize;               // M: in bytes
    BOOL            fCapFileExists;             // I: if have a capture file
    BOOL            fFileCaptured;              // I: if we've cap'd to file

    // async file io
    //
    DWORD           dwAsyncWriteOffset;         // I: last file write offset
    UINT            iNextAsync;                 // I: next async io header to be done
    UINT            iLastAsync;                 // I: last async io header to be written
    UINT            iNumAsync;                  // I: number of async io headers
    struct _avi_async {
        OVERLAPPED ovl;                         // I: for WriteFile call
        UINT       uType;                       // I: write type (Video/Wave/Drop)
        UINT       uIndex;                      // I: index into alpWaveHdr or alpVideoHdr
        } *        pAsync;                      // I: ptr to array of async io headers
#define ASYNCIOPENDING 0x80000000               // or'ed to uType for pending IO
#ifdef USE_AVIFILE
    // these 4 fields when using avifile
    //
    BOOL            bUseAvifile;
    PAVISTREAM      pvideo;
    PAVISTREAM      paudio;
    PAVIFILE        pavifile;
#endif

    HMMIO           hmmio;                      // I: MMIO handle for writing
    HANDLE          hFile;                      // I: write via CreateFile
    DWORD           dwBytesPerSector;           // I: bytes per sector
    BOOL            fUsingNonBufferedIO;        // I: FILE_FLAG_NO_BUFFERING
    DWORD           dwAVIHdrSize;               // I: size of header
    DWORD           dwAVIHdrPos;                // I: file offset of hdr

    LPARAM	    lUser;			// M: Data for the user
    LPVOID          lpInfoChunks;               // M: information chunks
    LONG            cbInfoChunks;               // M: sizeof information chks
    BOOL            fLastStatusWasNULL;         // I: don't repeat null msgs
    BOOL            fLastErrorWasNULL;          // I: don't repeat null msgs
} CAPSTREAM;
typedef CAPSTREAM FAR * LPCAPSTREAM;

// values for capstream.pAsync[nn].wType field
//
#define ASYNC_BUF_VIDEO 1
#define ASYNC_BUF_AUDIO 2
#define ASYNC_BUF_DROP  3

// -------------------------
//  Full color log palette
// -------------------------

typedef struct tagFCLOGPALETTE {
    WORD         palVersion;
    WORD         palNumEntries;
    PALETTEENTRY palPalEntry[256];
} FCLOGPALETTE;

typedef struct {
    DWORD       dwType;
    DWORD       dwSize;
} RIFF, *PRIFF, FAR *LPRIFF;

extern HINSTANCE ghInstDll;
#define	IDS_CAP_RTL	10000
extern BOOL gfIsRTL;

// capinit.c
BOOL CapWinDisconnectHardware(LPCAPSTREAM lpcs);
BOOL CapWinConnectHardware (LPCAPSTREAM lpcs, UINT wDeviceIndex);
BOOL capInternalGetDriverDesc (UINT wDriverIndex,
        LPTSTR lpszName, int cbName,
        LPTSTR lpszVer, int cbVer);
BOOL capInternalGetDriverDescA(UINT wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer);

// capwin.c
LRESULT FAR PASCAL LOADDS EXPORT CapWndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

#if defined CHICAGO
 VOID WINAPI OpenMMDEVLDR(
     void);

 VOID WINAPI CloseMMDEVLDR(
     void);

 VOID FreeContigMem (
     DWORD hMemContig);

 LPVOID AllocContigMem (
     DWORD   cbSize,
     LPDWORD phMemContig);
#endif


// capavi.c
LPVOID FAR PASCAL AllocSectorAlignedMem (DWORD dwRequest, DWORD dwAlign);
void FAR PASCAL FreeSectorAlignedMem(LPVOID p);
DWORDLONG GetFreePhysicalMemory(void);
DWORD CalcWaveBufferSize (LPCAPSTREAM lpcs);
BOOL AVIFileFini (LPCAPSTREAM lpcs, BOOL fWroteJunkChunks, BOOL fAbort);
UINT AVIAudioInit (LPCAPSTREAM lpcs);
UINT AVIAudioFini (LPCAPSTREAM lpcs);
UINT AVIAudioPrepare (LPCAPSTREAM lpcs);
UINT AVIAudioUnPrepare (LPCAPSTREAM lpcs);
UINT AVIVideoInit (LPCAPSTREAM lpcs);
UINT AVIVideoPrepare (LPCAPSTREAM lpcs);
UINT AVIVideoUnPrepare (LPCAPSTREAM lpcs);
void AVIFini(LPCAPSTREAM lpcs);
UINT AVIInit (LPCAPSTREAM lpcs);
BOOL FAR PASCAL SetInfoChunk(LPCAPSTREAM lpcs, LPCAPINFOCHUNK lpcic);
BOOL AVICapture (LPCAPSTREAM lpcs);

// capio.c
//
BOOL InitIndex (LPCAPSTREAM lpcs);
void FiniIndex (LPCAPSTREAM lpcs);
BOOL WriteIndex (LPCAPSTREAM lpcs, BOOL fJunkChunkWritten);
BOOL CapFileInit(LPCAPSTREAM lpcs);
BOOL WINAPI AVIWriteAudio (
    LPCAPSTREAM lpcs,
    LPWAVEHDR   lpwh,
    UINT        uIndex,
    LPUINT      lpuError,
    LPBOOL      pbPending);
BOOL WINAPI AVIWriteVideoFrame (
    LPCAPSTREAM lpcs,
    LPBYTE      lpData,
    DWORD       dwBytesUsed,
    BOOL        fKeyFrame,
    UINT        uIndex,
    UINT        nDropped,
    LPUINT      lpuError,
    LPBOOL      pbPending);
BOOL WINAPI AVIWriteDummyFrames (
    LPCAPSTREAM lpcs,
    UINT        nCount,
    LPUINT      lpuError,
    LPBOOL      pbPending);
VOID WINAPI AVIPreloadFat (LPCAPSTREAM lpcs);

// capfile.c
BOOL FAR PASCAL fileCapFileIsAVI (LPTSTR lpsz);
BOOL FAR PASCAL fileAllocCapFile(LPCAPSTREAM lpcs, DWORD dwNewSize);
BOOL FAR PASCAL fileSaveCopy(LPCAPSTREAM lpcs);
BOOL FAR PASCAL fileSavePalette(LPCAPSTREAM lpcs, LPTSTR lpszFileName);
BOOL FAR PASCAL fileOpenPalette(LPCAPSTREAM lpcs, LPTSTR lpszFileName);

//capmisc.c
UINT GetKey(BOOL fWait);
void errorDriverID (LPCAPSTREAM lpcs, DWORD dwError);
void FAR CDECL statusUpdateStatus (LPCAPSTREAM lpcs, UINT wID, ...);
void FAR CDECL errorUpdateError (LPCAPSTREAM lpcs, UINT wID, ...);

//capFrame.c
BOOL FAR PASCAL SingleFrameCaptureOpen (LPCAPSTREAM lpcs);
BOOL FAR PASCAL SingleFrameCaptureClose (LPCAPSTREAM lpcs);
BOOL FAR PASCAL SingleFrameCapture (LPCAPSTREAM lpcs);
BOOL SingleFrameWrite (
    LPCAPSTREAM             lpcs,       // capture stream
    LPVIDEOHDR              lpVidHdr,   // input header
    BOOL FAR 		    *pfKey,	// did it end up being a key frame?
    LONG FAR		    *plSize);	// size of returned image

//capMCI.c
void FAR PASCAL TimeMSToSMPTE (DWORD dwMS, LPSTR lpTime);
int CountMCIDevicesByType ( UINT wType );
void MCIDeviceClose (LPCAPSTREAM lpcs);
BOOL MCIDeviceOpen (LPCAPSTREAM lpcs);
BOOL FAR PASCAL MCIDeviceGetPosition (LPCAPSTREAM lpcs, LPDWORD lpdwPos);
BOOL FAR PASCAL MCIDeviceSetPosition (LPCAPSTREAM lpcs, DWORD dwPos);
BOOL FAR PASCAL MCIDevicePlay (LPCAPSTREAM lpcs);
BOOL FAR PASCAL MCIDevicePause (LPCAPSTREAM lpcs);
BOOL FAR PASCAL MCIDeviceStop (LPCAPSTREAM lpcs);
BOOL FAR PASCAL MCIDeviceStep (LPCAPSTREAM lpcs, BOOL fForward);
void FAR PASCAL _LOADDS MCIStepCapture (LPCAPSTREAM lpcs);

#define AnsiToWide(lpwsz,lpsz,nChars) MultiByteToWideChar(CP_ACP, 0, lpsz, nChars, lpwsz, nChars)
#define WideToAnsi(lpsz,lpwsz,nChars) WideCharToMultiByte(CP_ACP, 0, lpwsz, nChars, lpsz, nChars, NULL, NULL)
#ifdef CHICAGO
 // chicago internal api to get a vxd visible alias for Win32 handle
 // this is used on the hCaptureEvent handle so that it can be signaled
 // from within 16 bit code.
 DWORD WINAPI OpenVxDHandle (HANDLE);
#endif

#ifdef _DEBUG
  BOOL FAR PASCAL _Assert(BOOL f, LPSTR szFile, int iLine);
  #define WinAssert(exp) (_Assert(exp, (LPSTR) __FILE__, __LINE__))
  extern void FAR CDECL dprintf(LPSTR, ...);
  #define DPF dprintf
#else
  #define dprintf ; / ## /
  #define DPF ; / ## /
  #define WinAssert(exp) 0
#endif


#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif    /* __cplusplus */

#endif /* INC_AVICAP_INTERNAL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\avicap.h ===
/****************************************************************************
 *
 *   avicap.h
 *
 *   Main include file.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#ifndef _INC_AVICAP
#define _INC_AVICAP

#if !defined(RC_INVOKED) && !defined(VFWAPI)
#ifdef _WIN32
    #define VFWAPI  WINAPI
    #define VFWAPIV WINAPIV
    #define _LOADDS
#else
    #define VFWAPI  FAR PASCAL
    #define VFWAPIV FAR CDECL
#endif
#endif

#if !defined _WIN32  && !defined LPTSTR
    #define LPTSTR LPSTR
#endif

// begin_vfw32
#ifdef __cplusplus
/* SendMessage in C++*/
#define AVICapSM(hwnd,m,w,l) ( (IsWindow(hwnd)) ? ::SendMessage(hwnd,m,w,l) : 0)
#else
/* SendMessage in C */
#define AVICapSM(hwnd,m,w,l) ( (IsWindow(hwnd)) ?   SendMessage(hwnd,m,w,l) : 0)
#endif  /* __cplusplus */

// end_vfw32
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

// begin_vfw32
#ifndef RC_INVOKED

// ------------------------------------------------------------------
//  Window Messages  WM_CAP... which can be sent to an AVICAP window
// ------------------------------------------------------------------



// UNICODE
//
// The Win32 version of AVICAP on NT supports UNICODE applications:
// for each API or message that takes a char or string parameter, there are
// two versions, ApiNameA and ApiNameW. The default name ApiName is #defined
// to one or other depending on whether UNICODE is defined. Apps can call
// the A and W apis directly, and mix them.
//
// The 32-bit AVICAP on NT uses unicode exclusively internally.
// ApiNameA() will be implemented as a call to ApiNameW() together with
// translation of strings.




// Defines start of the message range
#define WM_CAP_START                    WM_USER

// start of unicode messages
#define WM_CAP_UNICODE_START            WM_USER+100

#define WM_CAP_GET_CAPSTREAMPTR         (WM_CAP_START+  1)

// end_vfw32
#ifdef _WIN32
// begin_vfw32
#define WM_CAP_SET_CALLBACK_ERRORW     (WM_CAP_UNICODE_START+  2)
#define WM_CAP_SET_CALLBACK_STATUSW    (WM_CAP_UNICODE_START+  3)
#define WM_CAP_SET_CALLBACK_ERRORA     (WM_CAP_START+  2)
#define WM_CAP_SET_CALLBACK_STATUSA    (WM_CAP_START+  3)
#ifdef UNICODE
#define WM_CAP_SET_CALLBACK_ERROR       WM_CAP_SET_CALLBACK_ERRORW
#define WM_CAP_SET_CALLBACK_STATUS      WM_CAP_SET_CALLBACK_STATUSW
#else
#define WM_CAP_SET_CALLBACK_ERROR       WM_CAP_SET_CALLBACK_ERRORA
#define WM_CAP_SET_CALLBACK_STATUS      WM_CAP_SET_CALLBACK_STATUSA
#endif
// end_vfw32
#else
#define WM_CAP_SET_CALLBACK_ERROR       (WM_CAP_START+  2)
#define WM_CAP_SET_CALLBACK_STATUS      (WM_CAP_START+  3)
#endif
// begin_vfw32


#define WM_CAP_SET_CALLBACK_YIELD       (WM_CAP_START+  4)
#define WM_CAP_SET_CALLBACK_FRAME       (WM_CAP_START+  5)
#define WM_CAP_SET_CALLBACK_VIDEOSTREAM (WM_CAP_START+  6)
#define WM_CAP_SET_CALLBACK_WAVESTREAM  (WM_CAP_START+  7)
#define WM_CAP_GET_USER_DATA		(WM_CAP_START+  8)
#define WM_CAP_SET_USER_DATA		(WM_CAP_START+  9)

#define WM_CAP_DRIVER_CONNECT           (WM_CAP_START+  10)
#define WM_CAP_DRIVER_DISCONNECT        (WM_CAP_START+  11)

// end_vfw32
#ifdef _WIN32
// begin_vfw32
#define WM_CAP_DRIVER_GET_NAMEA        (WM_CAP_START+  12)
#define WM_CAP_DRIVER_GET_VERSIONA     (WM_CAP_START+  13)
#define WM_CAP_DRIVER_GET_NAMEW        (WM_CAP_UNICODE_START+  12)
#define WM_CAP_DRIVER_GET_VERSIONW     (WM_CAP_UNICODE_START+  13)
#ifdef UNICODE
#define WM_CAP_DRIVER_GET_NAME          WM_CAP_DRIVER_GET_NAMEW
#define WM_CAP_DRIVER_GET_VERSION       WM_CAP_DRIVER_GET_VERSIONW
#else
#define WM_CAP_DRIVER_GET_NAME          WM_CAP_DRIVER_GET_NAMEA
#define WM_CAP_DRIVER_GET_VERSION       WM_CAP_DRIVER_GET_VERSIONA
#endif
// end_vfw32
#else
#define WM_CAP_DRIVER_GET_NAME          (WM_CAP_START+  12)
#define WM_CAP_DRIVER_GET_VERSION       (WM_CAP_START+  13)
#endif
// begin_vfw32

#define WM_CAP_DRIVER_GET_CAPS          (WM_CAP_START+  14)

// end_vfw32
#ifdef _WIN32
// begin_vfw32
#define WM_CAP_FILE_SET_CAPTURE_FILEA  (WM_CAP_START+  20)
#define WM_CAP_FILE_GET_CAPTURE_FILEA  (WM_CAP_START+  21)
#define WM_CAP_FILE_SAVEASA            (WM_CAP_START+  23)
#define WM_CAP_FILE_SAVEDIBA           (WM_CAP_START+  25)
#define WM_CAP_FILE_SET_CAPTURE_FILEW  (WM_CAP_UNICODE_START+  20)
#define WM_CAP_FILE_GET_CAPTURE_FILEW  (WM_CAP_UNICODE_START+  21)
#define WM_CAP_FILE_SAVEASW            (WM_CAP_UNICODE_START+  23)
#define WM_CAP_FILE_SAVEDIBW           (WM_CAP_UNICODE_START+  25)
#ifdef UNICODE
#define WM_CAP_FILE_SET_CAPTURE_FILE    WM_CAP_FILE_SET_CAPTURE_FILEW
#define WM_CAP_FILE_GET_CAPTURE_FILE    WM_CAP_FILE_GET_CAPTURE_FILEW
#define WM_CAP_FILE_SAVEAS              WM_CAP_FILE_SAVEASW
#define WM_CAP_FILE_SAVEDIB             WM_CAP_FILE_SAVEDIBW
#else
#define WM_CAP_FILE_SET_CAPTURE_FILE    WM_CAP_FILE_SET_CAPTURE_FILEA
#define WM_CAP_FILE_GET_CAPTURE_FILE    WM_CAP_FILE_GET_CAPTURE_FILEA
#define WM_CAP_FILE_SAVEAS              WM_CAP_FILE_SAVEASA
#define WM_CAP_FILE_SAVEDIB             WM_CAP_FILE_SAVEDIBA
#endif
// end_vfw32
#else
#define WM_CAP_FILE_SET_CAPTURE_FILE    (WM_CAP_START+  20)
#define WM_CAP_FILE_GET_CAPTURE_FILE    (WM_CAP_START+  21)
#define WM_CAP_FILE_SAVEAS              (WM_CAP_START+  23)
#define WM_CAP_FILE_SAVEDIB             (WM_CAP_START+  25)
#endif
// begin_vfw32

// out of order to save on ifdefs
#define WM_CAP_FILE_ALLOCATE            (WM_CAP_START+  22)
#define WM_CAP_FILE_SET_INFOCHUNK       (WM_CAP_START+  24)

#define WM_CAP_EDIT_COPY                (WM_CAP_START+  30)

#define WM_CAP_SET_AUDIOFORMAT          (WM_CAP_START+  35)
#define WM_CAP_GET_AUDIOFORMAT          (WM_CAP_START+  36)

#define WM_CAP_DLG_VIDEOFORMAT          (WM_CAP_START+  41)
#define WM_CAP_DLG_VIDEOSOURCE          (WM_CAP_START+  42)
#define WM_CAP_DLG_VIDEODISPLAY         (WM_CAP_START+  43)
#define WM_CAP_GET_VIDEOFORMAT          (WM_CAP_START+  44)
#define WM_CAP_SET_VIDEOFORMAT          (WM_CAP_START+  45)
#define WM_CAP_DLG_VIDEOCOMPRESSION     (WM_CAP_START+  46)

#define WM_CAP_SET_PREVIEW              (WM_CAP_START+  50)
#define WM_CAP_SET_OVERLAY              (WM_CAP_START+  51)
#define WM_CAP_SET_PREVIEWRATE          (WM_CAP_START+  52)
#define WM_CAP_SET_SCALE                (WM_CAP_START+  53)
#define WM_CAP_GET_STATUS               (WM_CAP_START+  54)
#define WM_CAP_SET_SCROLL               (WM_CAP_START+  55)

#define WM_CAP_GRAB_FRAME               (WM_CAP_START+  60)
#define WM_CAP_GRAB_FRAME_NOSTOP        (WM_CAP_START+  61)

#define WM_CAP_SEQUENCE                 (WM_CAP_START+  62)
#define WM_CAP_SEQUENCE_NOFILE          (WM_CAP_START+  63)
#define WM_CAP_SET_SEQUENCE_SETUP       (WM_CAP_START+  64)
#define WM_CAP_GET_SEQUENCE_SETUP       (WM_CAP_START+  65)

// end_vfw32
#ifdef _WIN32
// begin_vfw32
#define WM_CAP_SET_MCI_DEVICEA         (WM_CAP_START+  66)
#define WM_CAP_GET_MCI_DEVICEA         (WM_CAP_START+  67)
#define WM_CAP_SET_MCI_DEVICEW         (WM_CAP_UNICODE_START+  66)
#define WM_CAP_GET_MCI_DEVICEW         (WM_CAP_UNICODE_START+  67)
#ifdef UNICODE
#define WM_CAP_SET_MCI_DEVICE           WM_CAP_SET_MCI_DEVICEW
#define WM_CAP_GET_MCI_DEVICE           WM_CAP_GET_MCI_DEVICEW
#else
#define WM_CAP_SET_MCI_DEVICE           WM_CAP_SET_MCI_DEVICEA
#define WM_CAP_GET_MCI_DEVICE           WM_CAP_GET_MCI_DEVICEA
#endif
// end_vfw32
#else
#define WM_CAP_SET_MCI_DEVICE           (WM_CAP_START+  66)
#define WM_CAP_GET_MCI_DEVICE           (WM_CAP_START+  67)
#endif
// begin_vfw32



#define WM_CAP_STOP                     (WM_CAP_START+  68)
#define WM_CAP_ABORT                    (WM_CAP_START+  69)

#define WM_CAP_SINGLE_FRAME_OPEN        (WM_CAP_START+  70)
#define WM_CAP_SINGLE_FRAME_CLOSE       (WM_CAP_START+  71)
#define WM_CAP_SINGLE_FRAME             (WM_CAP_START+  72)

// end_vfw32
#ifdef _WIN32
// begin_vfw32
#define WM_CAP_PAL_OPENA               (WM_CAP_START+  80)
#define WM_CAP_PAL_SAVEA               (WM_CAP_START+  81)
#define WM_CAP_PAL_OPENW               (WM_CAP_UNICODE_START+  80)
#define WM_CAP_PAL_SAVEW               (WM_CAP_UNICODE_START+  81)
#ifdef UNICODE
#define WM_CAP_PAL_OPEN                 WM_CAP_PAL_OPENW
#define WM_CAP_PAL_SAVE                 WM_CAP_PAL_SAVEW
#else
#define WM_CAP_PAL_OPEN                 WM_CAP_PAL_OPENA
#define WM_CAP_PAL_SAVE                 WM_CAP_PAL_SAVEA
#endif
// end_vfw32
#else
#define WM_CAP_PAL_OPEN                 (WM_CAP_START+  80)
#define WM_CAP_PAL_SAVE                 (WM_CAP_START+  81)
#endif
// begin_vfw32

#define WM_CAP_PAL_PASTE                (WM_CAP_START+  82)
#define WM_CAP_PAL_AUTOCREATE           (WM_CAP_START+  83)
#define WM_CAP_PAL_MANUALCREATE         (WM_CAP_START+  84)

// Following added post VFW 1.1
#define WM_CAP_SET_CALLBACK_CAPCONTROL  (WM_CAP_START+  85)


// Defines end of the message range
// end_vfw32
#ifdef _WIN32
// begin_vfw32
#define WM_CAP_UNICODE_END              WM_CAP_PAL_SAVEW
#define WM_CAP_END                      WM_CAP_UNICODE_END
// end_vfw32
#else
#define WM_CAP_END                      WM_CAP_SET_CALLBACK_CAPCONTROL
#endif
// begin_vfw32

// ------------------------------------------------------------------
//  Message crackers for above
// ------------------------------------------------------------------

// message wrapper macros are defined for the default messages only. Apps
// that wish to mix Ansi and UNICODE message sending will have to
// reference the _A and _W messages directly

#define capSetCallbackOnError(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_ERROR, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnStatus(hwnd, fpProc)       ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_STATUS, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnYield(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_YIELD, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnFrame(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_FRAME, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnVideoStream(hwnd, fpProc)  ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_VIDEOSTREAM, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnWaveStream(hwnd, fpProc)   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_WAVESTREAM, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnCapControl(hwnd, fpProc)   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_CAPCONTROL, 0, (LPARAM)(LPVOID)(fpProc)))

#define capSetUserData(hwnd, lUser)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_USER_DATA, 0, (LPARAM)lUser))
#define capGetUserData(hwnd)               (AVICapSM(hwnd, WM_CAP_GET_USER_DATA, 0, 0))

#define capDriverConnect(hwnd, i)                  ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_CONNECT, (WPARAM)(i), 0L))
#define capDriverDisconnect(hwnd)                  ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_DISCONNECT, (WPARAM)0, 0L))
#define capDriverGetName(hwnd, szName, wSize)      ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_NAME, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capDriverGetVersion(hwnd, szVer, wSize)    ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_VERSION, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPTSTR)(szVer)))
#define capDriverGetCaps(hwnd, s, wSize)           ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_CAPS, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPDRIVERCAPS)(s)))

#define capFileSetCaptureFile(hwnd, szName)        ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SET_CAPTURE_FILE, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capFileGetCaptureFile(hwnd, szName, wSize) ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_GET_CAPTURE_FILE, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capFileAlloc(hwnd, dwSize)                 ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_ALLOCATE, 0, (LPARAM)(DWORD)(dwSize)))
#define capFileSaveAs(hwnd, szName)                ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SAVEAS, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capFileSetInfoChunk(hwnd, lpInfoChunk)     ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SET_INFOCHUNK, (WPARAM)0, (LPARAM)(LPCAPINFOCHUNK)(lpInfoChunk)))
#define capFileSaveDIB(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SAVEDIB, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))

#define capEditCopy(hwnd)                          ((BOOL)AVICapSM(hwnd, WM_CAP_EDIT_COPY, 0, 0L))

#define capSetAudioFormat(hwnd, s, wSize)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_AUDIOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPWAVEFORMATEX)(s)))
#define capGetAudioFormat(hwnd, s, wSize)          ((DWORD)AVICapSM(hwnd, WM_CAP_GET_AUDIOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPWAVEFORMATEX)(s)))
#define capGetAudioFormatSize(hwnd)                ((DWORD)AVICapSM(hwnd, WM_CAP_GET_AUDIOFORMAT, (WPARAM)0, (LPARAM)0L))

#define capDlgVideoFormat(hwnd)                    ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOFORMAT, 0, 0L))
#define capDlgVideoSource(hwnd)                    ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOSOURCE, 0, 0L))
#define capDlgVideoDisplay(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEODISPLAY, 0, 0L))
#define capDlgVideoCompression(hwnd)               ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOCOMPRESSION, 0, 0L))

#define capGetVideoFormat(hwnd, s, wSize)          ((DWORD)AVICapSM(hwnd, WM_CAP_GET_VIDEOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(s)))
#define capGetVideoFormatSize(hwnd)            ((DWORD)AVICapSM(hwnd, WM_CAP_GET_VIDEOFORMAT, 0, 0L))
#define capSetVideoFormat(hwnd, s, wSize)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_VIDEOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(s)))

#define capPreview(hwnd, f)                        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_PREVIEW, (WPARAM)(BOOL)(f), 0L))
#define capPreviewRate(hwnd, wMS)                  ((BOOL)AVICapSM(hwnd, WM_CAP_SET_PREVIEWRATE, (WPARAM)(wMS), 0))
#define capOverlay(hwnd, f)                        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_OVERLAY, (WPARAM)(BOOL)(f), 0L))
#define capPreviewScale(hwnd, f)                   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SCALE, (WPARAM)(BOOL)f, 0L))
#define capGetStatus(hwnd, s, wSize)               ((BOOL)AVICapSM(hwnd, WM_CAP_GET_STATUS, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPSTATUS)(s)))
#define capSetScrollPos(hwnd, lpP)                 ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SCROLL, (WPARAM)0, (LPARAM)(LPPOINT)(lpP)))

#define capGrabFrame(hwnd)                         ((BOOL)AVICapSM(hwnd, WM_CAP_GRAB_FRAME, (WPARAM)0, (LPARAM)0L))
#define capGrabFrameNoStop(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_GRAB_FRAME_NOSTOP, (WPARAM)0, (LPARAM)0L))

#define capCaptureSequence(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_SEQUENCE, (WPARAM)0, (LPARAM)0L))
#define capCaptureSequenceNoFile(hwnd)             ((BOOL)AVICapSM(hwnd, WM_CAP_SEQUENCE_NOFILE, (WPARAM)0, (LPARAM)0L))
#define capCaptureStop(hwnd)                       ((BOOL)AVICapSM(hwnd, WM_CAP_STOP, (WPARAM)0, (LPARAM)0L))
#define capCaptureAbort(hwnd)                      ((BOOL)AVICapSM(hwnd, WM_CAP_ABORT, (WPARAM)0, (LPARAM)0L))

#define capCaptureSingleFrameOpen(hwnd)            ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME_OPEN, (WPARAM)0, (LPARAM)0L))
#define capCaptureSingleFrameClose(hwnd)           ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME_CLOSE, (WPARAM)0, (LPARAM)0L))
#define capCaptureSingleFrame(hwnd)                ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME, (WPARAM)0, (LPARAM)0L))

#define capCaptureGetSetup(hwnd, s, wSize)         ((BOOL)AVICapSM(hwnd, WM_CAP_GET_SEQUENCE_SETUP, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPTUREPARMS)(s)))
#define capCaptureSetSetup(hwnd, s, wSize)         ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SEQUENCE_SETUP, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPTUREPARMS)(s)))

#define capSetMCIDeviceName(hwnd, szName)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_MCI_DEVICE, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capGetMCIDeviceName(hwnd, szName, wSize)   ((BOOL)AVICapSM(hwnd, WM_CAP_GET_MCI_DEVICE, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPTSTR)(szName)))

#define capPaletteOpen(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_OPEN, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capPaletteSave(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_SAVE, 0, (LPARAM)(LPVOID)(LPTSTR)(szName)))
#define capPalettePaste(hwnd)                      ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_PASTE, (WPARAM) 0, (LPARAM)0L))
#define capPaletteAuto(hwnd, iFrames, iColors)     ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_AUTOCREATE, (WPARAM)(iFrames), (LPARAM)(DWORD)(iColors)))
#define capPaletteManual(hwnd, fGrab, iColors)     ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_MANUALCREATE, (WPARAM)(fGrab), (LPARAM)(DWORD)(iColors)))

// ------------------------------------------------------------------
//  Structures
// ------------------------------------------------------------------

typedef struct tagCapDriverCaps {
    UINT        wDeviceIndex;               // Driver index in system.ini
    BOOL        fHasOverlay;                // Can device overlay?
    BOOL        fHasDlgVideoSource;         // Has Video source dlg?
    BOOL        fHasDlgVideoFormat;         // Has Format dlg?
    BOOL        fHasDlgVideoDisplay;        // Has External out dlg?
    BOOL        fCaptureInitialized;        // Driver ready to capture?
    BOOL        fDriverSuppliesPalettes;    // Can driver make palettes?

// following always NULL on Win32.
    HANDLE      hVideoIn;                   // Driver In channel
    HANDLE      hVideoOut;                  // Driver Out channel
    HANDLE      hVideoExtIn;                // Driver Ext In channel
    HANDLE      hVideoExtOut;               // Driver Ext Out channel
} CAPDRIVERCAPS, *PCAPDRIVERCAPS, FAR *LPCAPDRIVERCAPS;

typedef struct tagCapStatus {
    UINT        uiImageWidth;               // Width of the image
    UINT        uiImageHeight;              // Height of the image
    BOOL        fLiveWindow;                // Now Previewing video?
    BOOL        fOverlayWindow;             // Now Overlaying video?
    BOOL        fScale;                     // Scale image to client?
    POINT       ptScroll;                   // Scroll position
    BOOL        fUsingDefaultPalette;       // Using default driver palette?
    BOOL        fAudioHardware;             // Audio hardware present?
    BOOL        fCapFileExists;             // Does capture file exist?
    DWORD       dwCurrentVideoFrame;        // # of video frames cap'td
    DWORD       dwCurrentVideoFramesDropped;// # of video frames dropped
    DWORD       dwCurrentWaveSamples;       // # of wave samples cap'td
    DWORD       dwCurrentTimeElapsedMS;     // Elapsed capture duration
    HPALETTE    hPalCurrent;                // Current palette in use
    BOOL        fCapturingNow;              // Capture in progress?
    DWORD       dwReturn;                   // Error value after any operation
    UINT        wNumVideoAllocated;         // Actual number of video buffers
    UINT        wNumAudioAllocated;         // Actual number of audio buffers
} CAPSTATUS, *PCAPSTATUS, FAR *LPCAPSTATUS;

                                            // Default values in parenthesis
typedef struct tagCaptureParms {
    DWORD       dwRequestMicroSecPerFrame;  // Requested capture rate
    BOOL        fMakeUserHitOKToCapture;    // Show "Hit OK to cap" dlg?
    UINT        wPercentDropForError;       // Give error msg if > (10%)
    BOOL        fYield;                     // Capture via background task?
    DWORD       dwIndexSize;                // Max index size in frames (32K)
    UINT        wChunkGranularity;          // Junk chunk granularity (2K)
    BOOL        fUsingDOSMemory;            // Use DOS buffers?
    UINT        wNumVideoRequested;         // # video buffers, If 0, autocalc
    BOOL        fCaptureAudio;              // Capture audio?
    UINT        wNumAudioRequested;         // # audio buffers, If 0, autocalc
    UINT        vKeyAbort;                  // Virtual key causing abort
    BOOL        fAbortLeftMouse;            // Abort on left mouse?
    BOOL        fAbortRightMouse;           // Abort on right mouse?
    BOOL        fLimitEnabled;              // Use wTimeLimit?
    UINT        wTimeLimit;                 // Seconds to capture
    BOOL        fMCIControl;                // Use MCI video source?
    BOOL        fStepMCIDevice;             // Step MCI device?
    DWORD       dwMCIStartTime;             // Time to start in MS
    DWORD       dwMCIStopTime;              // Time to stop in MS
    BOOL        fStepCaptureAt2x;           // Perform spatial averaging 2x
    UINT        wStepCaptureAverageFrames;  // Temporal average n Frames
    DWORD       dwAudioBufferSize;          // Size of audio bufs (0 = default)
    BOOL        fDisableWriteCache;         // Attempt to disable write cache
    UINT        AVStreamMaster;             // Which stream controls length?
} CAPTUREPARMS, *PCAPTUREPARMS, FAR *LPCAPTUREPARMS;

// ------------------------------------------------------------------
//  AVStreamMaster
//  Since Audio and Video streams generally use non-synchronized capture
//  clocks, this flag determines whether the audio stream is to be considered
//  the master or controlling clock when writing the AVI file:
//
//  AVSTREAMMASTER_AUDIO  - Audio is master, video frame duration is forced
//                          to match audio duration (VFW 1.0, 1.1 default)
//  AVSTREAMMASTER_NONE   - No master, audio and video streams may be of
//                          different lengths
// ------------------------------------------------------------------
#define AVSTREAMMASTER_AUDIO            0 /* Audio master (VFW 1.0, 1.1) */
#define AVSTREAMMASTER_NONE             1 /* No master */

typedef struct tagCapInfoChunk {
    FOURCC      fccInfoID;                  // Chunk ID, "ICOP" for copyright
    LPVOID      lpData;                     // pointer to data
    LONG        cbData;                     // size of lpData
} CAPINFOCHUNK, *PCAPINFOCHUNK, FAR *LPCAPINFOCHUNK;


// ------------------------------------------------------------------
//  Callback Definitions
// ------------------------------------------------------------------

typedef LRESULT (CALLBACK* CAPYIELDCALLBACK)  (HWND hWnd);
// end_vfw32
#ifdef _WIN32
// begin_vfw32
typedef LRESULT (CALLBACK* CAPSTATUSCALLBACKW) (HWND hWnd, int nID, LPCWSTR lpsz);
typedef LRESULT (CALLBACK* CAPERRORCALLBACKW)  (HWND hWnd, int nID, LPCWSTR lpsz);
typedef LRESULT (CALLBACK* CAPSTATUSCALLBACKA) (HWND hWnd, int nID, LPCSTR lpsz);
typedef LRESULT (CALLBACK* CAPERRORCALLBACKA)  (HWND hWnd, int nID, LPCSTR lpsz);
#ifdef UNICODE
#define CAPSTATUSCALLBACK  CAPSTATUSCALLBACKW
#define CAPERRORCALLBACK   CAPERRORCALLBACKW
#else
#define CAPSTATUSCALLBACK  CAPSTATUSCALLBACKA
#define CAPERRORCALLBACK   CAPERRORCALLBACKA
#endif
// end_vfw32
#else
typedef LRESULT (CALLBACK* CAPSTATUSCALLBACK) (HWND hWnd, int nID, LPCSTR lpsz);
typedef LRESULT (CALLBACK* CAPERRORCALLBACK)  (HWND hWnd, int nID, LPCSTR lpsz);
#endif
// begin_vfw32
typedef LRESULT (CALLBACK* CAPVIDEOCALLBACK)  (HWND hWnd, LPVIDEOHDR lpVHdr);
typedef LRESULT (CALLBACK* CAPWAVECALLBACK)   (HWND hWnd, LPWAVEHDR lpWHdr);
typedef LRESULT (CALLBACK* CAPCONTROLCALLBACK)(HWND hWnd, int nState);

// ------------------------------------------------------------------
//  CapControlCallback states
// ------------------------------------------------------------------
#define CONTROLCALLBACK_PREROLL         1 /* Waiting to start capture */
#define CONTROLCALLBACK_CAPTURING       2 /* Now capturing */

// ------------------------------------------------------------------
//  The only exported functions from AVICAP.DLL
// ------------------------------------------------------------------

// end_vfw32
#ifdef _WIN32
// begin_vfw32
HWND VFWAPI capCreateCaptureWindowA (
        LPCSTR lpszWindowName,
        DWORD dwStyle,
        int x, int y, int nWidth, int nHeight,
        HWND hwndParent, int nID);

BOOL VFWAPI capGetDriverDescriptionA (UINT wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer);

HWND VFWAPI capCreateCaptureWindowW (
        LPCWSTR lpszWindowName,
        DWORD dwStyle,
        int x, int y, int nWidth, int nHeight,
        HWND hwndParent, int nID);

BOOL VFWAPI capGetDriverDescriptionW (UINT wDriverIndex,
        LPWSTR lpszName, int cbName,
        LPWSTR lpszVer, int cbVer);
#ifdef UNICODE
#define capCreateCaptureWindow  capCreateCaptureWindowW
#define capGetDriverDescription capGetDriverDescriptionW
#else
#define capCreateCaptureWindow  capCreateCaptureWindowA
#define capGetDriverDescription capGetDriverDescriptionA
#endif
// end_vfw32
#else //_WIN32... what follows is 16 bit stuff
HWND VFWAPI capCreateCaptureWindow (
        LPCSTR lpszWindowName,
        DWORD dwStyle,
        int x, int y, int nWidth, int nHeight,
        HWND hwndParent, int nID);

BOOL VFWAPI capGetDriverDescription (WORD wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer);
#endif
// begin_vfw32

#endif  /* RC_INVOKED */

// ------------------------------------------------------------------
// New Information chunk IDs
// ------------------------------------------------------------------
#define infotypeDIGITIZATION_TIME  mmioFOURCC ('I','D','I','T')
#define infotypeSMPTE_TIME         mmioFOURCC ('I','S','M','P')

// ------------------------------------------------------------------
// String IDs from status and error callbacks
// ------------------------------------------------------------------

#define IDS_CAP_BEGIN               300  /* "Capture Start" */
#define IDS_CAP_END                 301  /* "Capture End" */

#define IDS_CAP_INFO                401  /* "%s" */
#define IDS_CAP_OUTOFMEM            402  /* "Out of memory" */
#define IDS_CAP_FILEEXISTS          403  /* "File '%s' exists -- overwrite it?" */
#define IDS_CAP_ERRORPALOPEN        404  /* "Error opening palette '%s'" */
#define IDS_CAP_ERRORPALSAVE        405  /* "Error saving palette '%s'" */
#define IDS_CAP_ERRORDIBSAVE        406  /* "Error saving frame '%s'" */
#define IDS_CAP_DEFAVIEXT           407  /* "avi" */
#define IDS_CAP_DEFPALEXT           408  /* "pal" */
#define IDS_CAP_CANTOPEN            409  /* "Cannot open '%s'" */
#define IDS_CAP_SEQ_MSGSTART        410  /* "Select OK to start capture\nof video sequence\nto %s." */
#define IDS_CAP_SEQ_MSGSTOP         411  /* "Hit ESCAPE or click to end capture" */

#define IDS_CAP_VIDEDITERR          412  /* "An error occurred while trying to run VidEdit." */
#define IDS_CAP_READONLYFILE        413  /* "The file '%s' is a read-only file." */
#define IDS_CAP_WRITEERROR          414  /* "Unable to write to file '%s'.\nDisk may be full." */
#define IDS_CAP_NODISKSPACE         415  /* "There is no space to create a capture file on the specified device." */
#define IDS_CAP_SETFILESIZE         416  /* "Set File Size" */
#define IDS_CAP_SAVEASPERCENT       417  /* "SaveAs: %2ld%%  Hit Escape to abort." */

#define IDS_CAP_DRIVER_ERROR        418  /* Driver specific error message */

#define IDS_CAP_WAVE_OPEN_ERROR     419  /* "Error: Cannot open the wave input device.\nCheck sample size, frequency, and channels." */
#define IDS_CAP_WAVE_ALLOC_ERROR    420  /* "Error: Out of memory for wave buffers." */
#define IDS_CAP_WAVE_PREPARE_ERROR  421  /* "Error: Cannot prepare wave buffers." */
#define IDS_CAP_WAVE_ADD_ERROR      422  /* "Error: Cannot add wave buffers." */
#define IDS_CAP_WAVE_SIZE_ERROR     423  /* "Error: Bad wave size." */

#define IDS_CAP_VIDEO_OPEN_ERROR    424  /* "Error: Cannot open the video input device." */
#define IDS_CAP_VIDEO_ALLOC_ERROR   425  /* "Error: Out of memory for video buffers." */
#define IDS_CAP_VIDEO_PREPARE_ERROR 426  /* "Error: Cannot prepare video buffers." */
#define IDS_CAP_VIDEO_ADD_ERROR     427  /* "Error: Cannot add video buffers." */
#define IDS_CAP_VIDEO_SIZE_ERROR    428  /* "Error: Bad video size." */

#define IDS_CAP_FILE_OPEN_ERROR     429  /* "Error: Cannot open capture file." */
#define IDS_CAP_FILE_WRITE_ERROR    430  /* "Error: Cannot write to capture file.  Disk may be full." */
#define IDS_CAP_RECORDING_ERROR     431  /* "Error: Cannot write to capture file.  Data rate too high or disk full." */
#define IDS_CAP_RECORDING_ERROR2    432  /* "Error while recording" */
#define IDS_CAP_AVI_INIT_ERROR      433  /* "Error: Unable to initialize for capture." */
#define IDS_CAP_NO_FRAME_CAP_ERROR  434  /* "Warning: No frames captured.\nConfirm that vertical sync interrupts\nare configured and enabled." */
#define IDS_CAP_NO_PALETTE_WARN     435  /* "Warning: Using default palette." */
#define IDS_CAP_MCI_CONTROL_ERROR   436  /* "Error: Unable to access MCI device." */
#define IDS_CAP_MCI_CANT_STEP_ERROR 437  /* "Error: Unable to step MCI device." */
#define IDS_CAP_NO_AUDIO_CAP_ERROR  438  /* "Error: No audio data captured.\nCheck audio card settings." */
#define IDS_CAP_AVI_DRAWDIB_ERROR   439  /* "Error: Unable to draw this data format." */
#define IDS_CAP_COMPRESSOR_ERROR    440  /* "Error: Unable to initialize compressor." */
#define IDS_CAP_AUDIO_DROP_ERROR    441  /* "Error: Audio data was lost during capture, reduce capture rate." */
#define IDS_CAP_AUDIO_DROP_COMPERROR 442  /* "Error: Audio data was lost during capture.  Try capturing without compressing." */

/* status string IDs */
#define IDS_CAP_STAT_LIVE_MODE      500  /* "Live window" */
#define IDS_CAP_STAT_OVERLAY_MODE   501  /* "Overlay window" */
#define IDS_CAP_STAT_CAP_INIT       502  /* "Setting up for capture - Please wait" */
#define IDS_CAP_STAT_CAP_FINI       503  /* "Finished capture, now writing frame %ld" */
#define IDS_CAP_STAT_PALETTE_BUILD  504  /* "Building palette map" */
#define IDS_CAP_STAT_OPTPAL_BUILD   505  /* "Computing optimal palette" */
#define IDS_CAP_STAT_I_FRAMES       506  /* "%d frames" */
#define IDS_CAP_STAT_L_FRAMES       507  /* "%ld frames" */
#define IDS_CAP_STAT_CAP_L_FRAMES   508  /* "Captured %ld frames" */
#define IDS_CAP_STAT_CAP_AUDIO      509  /* "Capturing audio" */
#define IDS_CAP_STAT_VIDEOCURRENT   510  /* "Captured %ld frames (%ld dropped) %d.%03d sec." */
#define IDS_CAP_STAT_VIDEOAUDIO     511  /* "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps).  %ld audio bytes (%d,%03d sps)" */
#define IDS_CAP_STAT_VIDEOONLY      512  /* "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps)" */
#define IDS_CAP_STAT_FRAMESDROPPED  513  /* "Dropped %ld of %ld frames (%d.%02d%%) during capture." */
// end_vfw32
#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif    /* __cplusplus */

#endif /* INC_AVICAP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\capdib.c ===
/****************************************************************************
 *
 *   capdib.c
 *
 *   DIB processing module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include <vfw.h>

#include "ivideo32.h"
#include "avicapi.h"


//
// Initialize a DIB to the default format of 160x120x8, BI_RGB
//
void SetDefaultCaptureFormat (LPBITMAPINFOHEADER lpbih)
{
    lpbih->biSize              = sizeof (BITMAPINFOHEADER);
    lpbih->biWidth             = 160;
    lpbih->biHeight            = 120;
    lpbih->biBitCount          = 8;
    lpbih->biPlanes            = 1;
    lpbih->biCompression       = BI_RGB;
    lpbih->biSizeImage         = DIBWIDTHBYTES (*lpbih) * lpbih->biHeight;
    lpbih->biXPelsPerMeter     = 0;
    lpbih->biYPelsPerMeter     = 0;
    lpbih->biClrUsed           = 256;
    lpbih->biClrImportant      = 0;
}

//
// Whenever we get a new format from the driver, OR
// start using a new palette, we must reallocate
// our global BITMAPINFOHEADER.  This allows JPEG
// quantization tables to be tacked onto the BITMAPINFO
// or any other format specific stuff.  The color table
// is always offset biSize from the start of the BITMAPINFO.
// Returns: 0 on success, or DV_ERR_... code
//

DWORD AllocNewGlobalBitmapInfo (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbi)
{
    DWORD dwSize;

    dwSize = lpbi->biSize + 256 * sizeof (RGBQUAD);

    // The 256 entry above is HARDWIRED ON PURPOSE
    // If biClrUsed was used instead, we would have to realloc
    // whenever a palette is pasted (during DibNewPalette())!!!

    if (lpcs->lpBitsInfo)
         lpcs->lpBitsInfo = (LPBITMAPINFO) GlobalReAllocPtr (lpcs->lpBitsInfo,
                dwSize, GHND);
    else
         lpcs->lpBitsInfo = (LPBITMAPINFO) GlobalAllocPtr (GHND, dwSize);

    if (!lpcs->lpBitsInfo)
         return (DV_ERR_NOMEM);

    // Copy over the BITMAPINFOHEADER
    CopyMemory (lpcs->lpBitsInfo, lpbi, lpbi->biSize);

    return DV_ERR_OK;
}

//
// Whenever we get a new format from the driver
// allocate a new global bitspace.  This bitspace is used
// in preview mode and single frame capture.
// Returns: 0 on success, or DV_ERR_... code
//

DWORD AllocNewBitSpace (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih)
{
    DWORD dwSize;

    // Allow room for a RIFF chunk prepended to the actual image,
    // and a junk chunk on the tail end

#define  RESERVE_FOR_RIFF  (512+sizeof(RIFF))

    dwSize = lpbih->biSizeImage + RESERVE_FOR_RIFF;

    if (lpcs->lpBitsUnaligned) {
#ifdef CHICAGO
         vidxFreePreviewBuffer (lpcs->hVideoIn,
                lpcs->lpBitsUnaligned);
#else
         FreeSectorAlignedMem (lpcs->lpBitsUnaligned);
#endif
         lpcs->lpBitsUnaligned = NULL;
         lpcs->lpBits = NULL;
    }

#ifdef CHICAGO
    if (MMSYSERR_NOERROR == vidxAllocPreviewBuffer (
                lpcs->hVideoIn,
                &lpcs->lpBitsUnaligned,
                dwSize)) {
        lpcs->lpBits = (LPBYTE) (ROUNDUPTOSECTORSIZE(lpcs->lpBitsUnaligned, 512)
                        + sizeof(RIFF));
    }

#else
    if (lpcs->lpBitsUnaligned = ((LPBYTE)AllocSectorAlignedMem (dwSize, 512))) {
        lpcs->lpBits = (LPBYTE) (ROUNDUPTOSECTORSIZE(lpcs->lpBitsUnaligned, 512)
                        + sizeof(RIFF));
    }
#endif

    if (!lpcs->lpBits)
         return (DV_ERR_NOMEM);

    return DV_ERR_OK;
}

//
// Dib Initialization code
// Returns: 0 on success, or DV_ERR_... code
//

DWORD DibInit (LPCAPSTREAM lpcs)
{
    BITMAPINFOHEADER bmih;

    SetDefaultCaptureFormat (&bmih);
    return ((WORD) AllocNewGlobalBitmapInfo (lpcs, &bmih));
}

//
// Fini code to free all bitmap resources
//
void DibFini (LPCAPSTREAM lpcs)
{
    if (lpcs->lpBits) {
#ifdef CHICAGO
        vidxFreePreviewBuffer (lpcs->hVideoIn, lpcs->lpBitsUnaligned);
#else
        FreeSectorAlignedMem (lpcs->lpBitsUnaligned);
#endif
        lpcs->lpBits = NULL;
        lpcs->lpBitsUnaligned = NULL;
    }
    if (lpcs->lpBitsInfo) {
        GlobalFreePtr (lpcs->lpBitsInfo);
        lpcs->lpBitsInfo = NULL;
    }
    lpcs->dxBits = 0;
    lpcs->dyBits = 0;
}

//
// Send a format to the driver.
// Whenever we do a format change, send the driver the
// Source and destination rects.
// Returns: 0 on success, or DV_ERR_... code
//
DWORD SendDriverFormat (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih, DWORD dwInfoHeaderSize)
{
    RECT rc;
    DWORD dwError = DV_ERR_NOTSUPPORTED;

    rc.left = rc.top = 0;
    rc.right = (int) lpbih->biWidth;
    rc.bottom = (int) lpbih->biHeight;

    if (dwError = videoConfigure(lpcs->hVideoIn,
            DVM_FORMAT,
            VIDEO_CONFIGURE_SET, NULL,
            (LPBITMAPINFOHEADER)lpbih, dwInfoHeaderSize,
            NULL, 0 ) ) {
        return dwError;
    } else {
        videoSetRect (lpcs->hVideoCapture, DVM_DST_RECT, rc);
        videoSetRect (lpcs->hVideoIn, DVM_SRC_RECT, rc);
        videoSetRect (lpcs->hVideoIn, DVM_DST_RECT, rc);
    }
    return dwError;
}


//
// Given a DIB, see if the driver likes it, then
//  allocate the global BITMAPINFOHEADER and bitspace.
//
//
DWORD SetFormatFromDIB (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih)
{
    DWORD dwError;

    // Fill optional fields in the DIB header
    if (lpbih->biSizeImage == 0)
        lpbih->biSizeImage = DIBWIDTHBYTES (*lpbih) * lpbih->biHeight;

    // Is the format palatized or full-color
    if (lpbih->biBitCount <= 8 && lpbih->biClrUsed == 0)
        lpbih->biClrUsed = (1 << lpbih->biBitCount);     // paletized

    // See if the driver will support it
    if (dwError = SendDriverFormat (lpcs, lpbih, lpbih->biSize) )
        return dwError;

    // Realloc our global header
    if (dwError = AllocNewGlobalBitmapInfo (lpcs, lpbih))
        return dwError;

    // Realloc the bits
    if (dwError = AllocNewBitSpace (lpcs, lpbih))
        return dwError;

    lpcs->dxBits = (int)lpbih->biWidth;
    lpcs->dyBits = (int)lpbih->biHeight;

    lpcs->VidHdr.lpData = lpcs->lpBits;
    lpcs->VidHdr.dwBufferLength = lpbih->biSizeImage;
    lpcs->VidHdr.dwUser = 0;
    lpcs->VidHdr.dwFlags = 0;

    return (DV_ERR_OK);
}


//
// Returns: a LPBITMAPINFO allocated from global memory
//      containing the current format, or NULL on error.
//      Note that this structure can be larger than
//      sizeof (BITMAPINFO), ie. JPEG !!!
//

LPBITMAPINFO DibGetCurrentFormat (LPCAPSTREAM lpcs)
{
    DWORD               dwError;
    DWORD               dwSize = 0;
    LPBITMAPINFO        lpBInfo = NULL;

    if (!lpcs->fHardwareConnected)
        return NULL;

    // How large is the BITMAPINFOHEADER?
    videoConfigure( lpcs->hVideoIn,
            DVM_FORMAT,
             VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_QUERYSIZE,
             &dwSize, 0, 0, NULL, 0);

    if (!dwSize)
        dwSize = sizeof (BITMAPINFOHEADER);

    if (!(lpBInfo = (LPBITMAPINFO) GlobalAllocPtr (GMEM_MOVEABLE, dwSize)))
         return (NULL);

    if (dwError = videoConfigure( lpcs->hVideoIn,
            DVM_FORMAT,
             VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT, NULL,
             (LPBITMAPINFOHEADER) lpBInfo, dwSize,
             NULL, 0 ) ) {
        // very bad. the driver can't tell us its format. we're hosed.
        GlobalFreePtr (lpBInfo);
        return NULL;
     }

    return (lpBInfo);
}

//
// Main entry point when changing capture formats.
// This is called when the user closes the drivers format dialog.
// Returns: 0 on success, or DV_ERR_... code
//
DWORD DibGetNewFormatFromDriver (LPCAPSTREAM lpcs)
{
    BOOL                f;
    BITMAPINFOHEADER    bih;
    DWORD               dwError;
    LPBITMAPINFO        lpBInfo;

    if (!lpcs->fHardwareConnected)
        return DV_ERR_OK;       // Return OK if no hardware exists

    lpBInfo = DibGetCurrentFormat (lpcs);

    if (lpBInfo == NULL)
        return DV_ERR_NOTSUPPORTED;

    // Set our internal state
    if (dwError = SetFormatFromDIB (lpcs, (LPBITMAPINFOHEADER) lpBInfo)) {
        // couldn't change formats, time to punt!
        // Try to switch back to minimal format (120x160x8)

        errorDriverID (lpcs, dwError);

        SetDefaultCaptureFormat (&bih);
        dwError = SetFormatFromDIB (lpcs, &bih);
    }

    // Force a new frame to be taken, so the DIB contains good
    // data.  Especially important to prevent codecs from exploding!
    if (!dwError)
        videoFrame (lpcs->hVideoIn, &lpcs->VidHdr);

    if (lpBInfo)
        GlobalFreePtr (lpBInfo);

    f = DrawDibBegin(lpcs->hdd,NULL,-1,-1,(LPBITMAPINFOHEADER)(lpcs->lpBitsInfo),-1,-1,0);
    if (!f) {
        errorUpdateError(lpcs, IDS_CAP_AVI_DRAWDIB_ERROR);
    }

    return (dwError);
}

//
// Main entry point when changing capture formats via App message.
// Returns: TRUE on success, or FALSE if format not supported
//
BOOL DibNewFormatFromApp (LPCAPSTREAM lpcs, LPBITMAPINFO lpbiNew, UINT dwSize)
{
    BOOL                f;
    DWORD               dwError;
    LPBITMAPINFO        lpBInfo;

    if (!lpcs->fHardwareConnected)
        return FALSE;

    lpBInfo = DibGetCurrentFormat (lpcs);  // Allocs memory!!!

    if (lpBInfo == NULL)
        return FALSE;

    // Set our internal state
    if (dwError = SetFormatFromDIB (lpcs, (LPBITMAPINFOHEADER) lpbiNew)) {
        // Driver didn't accept the format,
        // switch back to the original

        errorDriverID (lpcs, dwError);

        SetFormatFromDIB (lpcs, (LPBITMAPINFOHEADER)lpBInfo);
    }

    // Force a new frame to be taken, so the DIB contains good
    // data.  Especially important to prevent codecs from exploding!
    videoFrame (lpcs->hVideoIn, &lpcs->VidHdr);

    if (lpBInfo)
        GlobalFreePtr (lpBInfo);

    f = DrawDibBegin(lpcs->hdd,NULL,-1,-1,(LPBITMAPINFOHEADER)(lpcs->lpBitsInfo),-1,-1,0);
    if (!f) {
        errorUpdateError(lpcs, IDS_CAP_AVI_DRAWDIB_ERROR);
        //errorDriverID (lpcs, IDS_CAP_AVI_DRAWDIB_ERROR);
    }

    return (dwError == DV_ERR_OK);
}


void xlatClut8 (BYTE HUGE *pb, DWORD dwSize, BYTE HUGE *xlat)
{
    DWORD dw;

    for (dw = 0; dw < dwSize; dw++, ((BYTE huge *)pb)++)
        *pb = xlat[*pb];
}

//
// DibNewPalette
//
// Performs three functions:
// 1. Updates the biClrUsed field if biBitCount <= 8.
// 2. Remaps BI_RGB images through a LUT when a new palette is assigned.
// 3. Copies the palette entries into our global BITMAPINFO
//
// Returns: TRUE on success
//
DWORD DibNewPalette (LPCAPSTREAM lpcs, HPALETTE hPalNew)
{
    LPBITMAPINFOHEADER  lpbi;
    int                 n;
    short               nColors;
    BYTE FAR *          lpBits;
    RGBQUAD FAR *       lpRgb;
    BYTE                xlat[256];
    DWORD               dwSize;
    PALETTEENTRY        pe;

    if (!hPalNew || !lpcs->lpBits || !lpcs->lpBitsInfo)
        return FALSE;

    lpbi   = &(lpcs->lpBitsInfo->bmiHeader);
    lpRgb  = (RGBQUAD FAR *)((LPSTR)lpbi + (UINT)lpbi->biSize);
    lpBits = lpcs->lpBits;

    GetObject(hPalNew, sizeof(short), (LPSTR) &nColors);
    if (nColors > 256)
        nColors = 256;

    // Get the palette entries regardless of the compression
    // Supermac uses non BI_RGB with a palette!

    if (lpbi->biBitCount == 8) {
        for (n=0; n<nColors; n++) {
            GetPaletteEntries(hPalNew, n, 1, &pe);
            lpRgb[n].rgbRed   = pe.peRed;
            lpRgb[n].rgbGreen = pe.peGreen;
            lpRgb[n].rgbBlue  = pe.peBlue;
        }
    }

    if (lpbi->biBitCount == 8 && lpbi->biCompression == BI_RGB) {

        //
        //  build a xlat table. from the old Palette to the new palette.
        //
        for (n=0; n<(int)lpbi->biClrUsed; n++) {
            xlat[n] = (BYTE)GetNearestPaletteIndex(hPalNew,
                RGB(lpRgb[n].rgbRed,lpRgb[n].rgbGreen,lpRgb[n].rgbBlue));
        }

        //
        // translate the DIB bits
        //
        if ((dwSize = lpbi->biSizeImage) == 0)
            dwSize = lpbi->biHeight * DIBWIDTHBYTES(*lpbi);

        switch ((WORD)lpbi->biCompression)
        {
            case BI_RGB:
                xlatClut8(lpBits, dwSize, xlat);
        }
    }

    // Fix for Supermac, force biClrUsed to the number of palette entries
    // even if non-BI_RGB formats.

    if (lpbi->biBitCount <= 8)
        lpbi->biClrUsed = nColors;

    return TRUE;
}


/* DibPaint(LPCAPSTREAM lpcs, hdc)
 *
 * Paint the current DIB into the window;
 */
void DibPaint(LPCAPSTREAM lpcs, HDC hdc)
{
    RECT        rc;
    BOOL        fOK;

    fOK = (lpcs->lpBits != NULL);

    if (fOK) {
        if (lpcs->fScale) {
            GetClientRect(lpcs->hwnd, &rc);
            fOK = DrawDibDraw(lpcs->hdd, hdc, 0, 0,
                  rc.right - rc.left, rc.bottom - rc.top,
                  (LPBITMAPINFOHEADER)lpcs->lpBitsInfo, lpcs->lpBits,
                   0, 0, -1, -1,
#if defined _WIN32 && defined UNICODE
		    0 	// we don't support BACKGROUNDPAL yet in drawdib
#else
		   DDF_BACKGROUNDPAL
#endif
		   );
        }
        else
            fOK = DrawDibDraw(lpcs->hdd, hdc, 0, 0,
                lpcs->dxBits, lpcs->dyBits,
                (LPBITMAPINFOHEADER)lpcs->lpBitsInfo, lpcs->lpBits,
                0, 0, -1, -1,
#if defined _WIN32 && defined UNICODE
		    0 	// we don't support BACKGROUNDPAL yet in drawdib
#else
		   DDF_BACKGROUNDPAL
#endif
		   );

    }
    if (!fOK) {
        SelectObject(hdc, GetStockObject(BLACK_BRUSH));
        GetClientRect(lpcs->hwnd, &rc);
        PatBlt(hdc, 0, 0, rc.right, rc.bottom, PATCOPY);
    }
}

/*
 *
 * CreatePackedDib() - return the current DIB in packed (ie CF_DIB) format
 *
 */

HANDLE CreatePackedDib (LPBITMAPINFO lpBitsInfo, LPSTR lpSrcBits, HPALETTE hPalette)
{
    HANDLE              hdib;
    LPBITMAPINFO        lpbi;
    int                 i;
    DWORD               dwSize;
    PALETTEENTRY        pe;
    LPBYTE              lpBits;
    RGBQUAD FAR *       lpRgb;

    // If the data is compressed, let ICM do the work for us...
    if (lpBitsInfo->bmiHeader.biCompression != BI_RGB &&
         lpBitsInfo->bmiHeader.biCompression != BI_RLE8) {

        LPBITMAPINFO lpOutFormat = NULL;
        HANDLE hPackedDIBOut = NULL;

        if (!(lpOutFormat = (LPBITMAPINFO)GlobalAllocPtr(
                        GMEM_MOVEABLE, sizeof (BITMAPINFOHEADER) +
                        256 * sizeof (RGBQUAD))))
            return NULL;

        CopyMemory (lpOutFormat, lpBitsInfo, sizeof (BITMAPINFOHEADER));

        // Try to get an RGB format
        lpOutFormat->bmiHeader.biSize = sizeof (BITMAPINFOHEADER);
        lpOutFormat->bmiHeader.biCompression = BI_RGB;
        lpOutFormat->bmiHeader.biClrUsed = 0;
        lpOutFormat->bmiHeader.biClrImportant = 0;

        // Uh, oh, force to a 24-bit DIB if > 8 BPP
        if (lpBitsInfo->bmiHeader.biBitCount <= 8)
            lpOutFormat->bmiHeader.biBitCount = 8;
        else
            lpOutFormat->bmiHeader.biBitCount = 24;

        lpOutFormat->bmiHeader.biSizeImage =
                WIDTHBYTES (lpOutFormat->bmiHeader.biWidth *
                (lpOutFormat->bmiHeader.biBitCount == 8 ? 1 : 3)) *
                lpOutFormat->bmiHeader.biHeight;

        hPackedDIBOut = ICImageDecompress (
                NULL,           /*hic*/
                0,              /*uiFlags*/
                lpBitsInfo,     /*lpbiIn*/
                lpSrcBits,      /*lpBits*/
                lpOutFormat);   /*use default format chosen by compressor*/

        if (lpOutFormat)
            GlobalFreePtr (lpOutFormat);

        return (hPackedDIBOut);
    }

    dwSize = lpBitsInfo->bmiHeader.biSize +
              lpBitsInfo->bmiHeader.biClrUsed * sizeof(RGBQUAD) +
              lpBitsInfo->bmiHeader.biSizeImage;

    hdib = GlobalAlloc(GMEM_MOVEABLE, dwSize);

    if (!hdib)
         return NULL;

    lpbi = (LPVOID)GlobalLock(hdib);

    //
    // copy the header
    //
    CopyMemory (lpbi, lpBitsInfo, lpBitsInfo->bmiHeader.biSize);

    //
    // copy the color table
    //
    lpRgb  = (RGBQUAD FAR *)((LPSTR)lpbi + (WORD)lpbi->bmiHeader.biSize);
    for (i=0; i < (int)lpBitsInfo->bmiHeader.biClrUsed; i++) {
        GetPaletteEntries(hPalette, i, 1, &pe);
        lpRgb[i].rgbRed   = pe.peRed;
        lpRgb[i].rgbGreen = pe.peGreen;
        lpRgb[i].rgbBlue  = pe.peBlue;
        lpRgb[i].rgbReserved = 0;
    }

    //
    // copy the bits.
    //
    lpBits  =   (LPBYTE)lpbi +
                lpbi->bmiHeader.biSize +
                lpbi->bmiHeader.biClrUsed * sizeof(RGBQUAD);

    CopyMemory (lpBits, lpSrcBits,
                lpbi->bmiHeader.biSizeImage);

    GlobalUnlock (hdib);

    return hdib;
 }


 /*---------------------------------------------------------------------+
 | dibIsWritable() - return TRUE if the dib format is writable,                  |
 |                     by out dibWrite() function, FALSE if not.                 |
 |                                                                               |
 +---------------------------------------------------------------------*/
BOOL FAR PASCAL dibIsWritable (LPBITMAPINFO lpBitsInfo)
{
    if (!lpBitsInfo)
        return FALSE;

     // For now, just assume that all capture formats have an installed
     // codec which can convert to RGB.  In the future, each time the
     // format is changed, test that the codec actually accepts the format.

     return TRUE;
 }


 /*---------------------------------------------------------------------+
 | dibWrite() - write out the DIB to a file. The global header is       |
 |                in <glpBitsInfo> and the actual dib bits are in                |
 |                <glpBits>.  If it is palettized then the palette is in         |
 |                <ghPalCurrent>.                                                |
 |                                                                               |
 |  We won't do error reporting in this function, let the caller take   |
 |  care of that along with Opening and Closing the HMMIO.              |
 |                                                                               |
 +---------------------------------------------------------------------*/
BOOL FAR PASCAL dibWrite(LPCAPSTREAM lpcs, HMMIO hmmio)
 {
     BITMAPFILEHEADER   bfh;
     DWORD              dw;
     HANDLE             hPackedDib = NULL;
     LPBITMAPINFO       lpbi = NULL;
     BOOL               fOK = FALSE;

     /* do some checking */
    WinAssert(hmmio != 0);

    if (!lpcs->lpBits || !lpcs->lpBitsInfo)
        return FALSE;

    // Create a packed DIB, converting from a compressed format,
    // if necessary.
    hPackedDib = CreatePackedDib (lpcs->lpBitsInfo,
                        lpcs->lpBits,
                        lpcs->hPalCurrent);

    lpbi = (LPBITMAPINFO) GlobalLock (hPackedDib);

    if (!lpbi)
        goto WriteError;

    /* initialize the bitmap file header */
    bfh.bfType = 'B' | 'M' << 8;
    bfh.bfSize = sizeof(bfh) + sizeof(BITMAPINFOHEADER) +
        lpbi->bmiHeader.biSizeImage +
        (lpbi->bmiHeader.biBitCount > 8 ? 0 : (lpbi->bmiHeader.biClrUsed * sizeof(RGBQUAD)));

    bfh.bfReserved1 = bfh.bfReserved2 = 0;
    bfh.bfOffBits = bfh.bfSize - lpbi->bmiHeader.biSizeImage ;

    // dw is the size of the BITMAPINFO + color table + image
    dw = bfh.bfSize - sizeof(bfh);

    /* write out the file header portion */
    if (mmioWrite(hmmio, (HPSTR)&bfh, (LONG)sizeof(BITMAPFILEHEADER)) !=
                sizeof(BITMAPFILEHEADER)){
         goto WriteError;
    }

    /* now write out the header and bits */
    if (mmioWrite(hmmio, (HPSTR)lpbi, (LONG) dw) == (LONG) dw) {
         fOK = TRUE;
    }

WriteError:
    if (lpbi)
        GlobalUnlock (hPackedDib);
    if (hPackedDib)
        GlobalFree (hPackedDib);

    return fOK;
}

/*--------------------------------------------------------------+
| fileSaveDIB - save the frame as a DIB                         |
|   Top level routine to save a single frame                    |
+--------------------------------------------------------------*/
BOOL FAR PASCAL fileSaveDIB(LPCAPSTREAM lpcs, LPTSTR lpszFileName)
{
    HMMIO               hmmio;
    HCURSOR             hOldCursor;
    BOOL                fOK;

    hmmio = mmioOpen(lpszFileName, NULL, MMIO_WRITE);
    if( !hmmio ) {
	/* try and create */
        hmmio = mmioOpen(lpszFileName, NULL, MMIO_CREATE | MMIO_WRITE);
	if( !hmmio ) {
	    /* find out if the file was read only or we are just */
	    /* totally hosed up here.				 */
	    hmmio = mmioOpen(lpszFileName, NULL, MMIO_READ);
	    if (hmmio){
		/* file was read only, error on it */
                errorUpdateError (lpcs, IDS_CAP_READONLYFILE, (LPSTR)lpszFileName);
		mmioClose(hmmio, 0);
		return FALSE;
	    } else {
		/* even weirder error has occured here, give CANTOPEN */
                errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPSTR) lpszFileName);
		return FALSE;
	    }
	}
    }

    hOldCursor = SetCursor( lpcs->hWaitCursor );

    mmioSeek(hmmio, 0, SEEK_SET);

    fOK = dibWrite(lpcs, hmmio);

    mmioClose( hmmio, 0 );

    SetCursor( hOldCursor );

    if (!fOK)
       errorUpdateError (lpcs, IDS_CAP_ERRORDIBSAVE, (LPSTR) lpszFileName);

    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\capdib.h ===
/****************************************************************************
 *
 *   capdib.h
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992-1994 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

void SetDefaultCaptureFormat (LPBITMAPINFOHEADER lpbih);
DWORD AllocNewGlobalBitmapInfo (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbi);
DWORD AllocNewBitSpace (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih);
DWORD DibInit (LPCAPSTREAM lpcs);
void DibFini (LPCAPSTREAM lpcs);
DWORD SendDriverFormat (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih, DWORD dwInfoHeaderSize);
DWORD SetFormatFromDIB (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih);
LPBITMAPINFO DibGetCurrentFormat (LPCAPSTREAM lpcs);
DWORD DibGetNewFormatFromDriver (LPCAPSTREAM lpcs);
BOOL DibNewFormatFromApp (LPCAPSTREAM lpcs, LPBITMAPINFO lpbi, UINT dwSize);
DWORD DibNewPalette (LPCAPSTREAM lpcs, HPALETTE hPalNew);
void DibPaint(LPCAPSTREAM lpcs, HDC hdc);
HANDLE CreatePackedDib (LPBITMAPINFO lpBitsInfo, LPBYTE lpSrcBits, HPALETTE hPalette);
BOOL FAR PASCAL dibIsWritable (LPBITMAPINFO lpBitsInfo);
BOOL FAR PASCAL dibWrite(LPCAPSTREAM lpcs, HMMIO hmmio);
BOOL FAR PASCAL fileSaveDIB(LPCAPSTREAM lpcs, LPTSTR lpszFileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\capframe.c ===
/****************************************************************************
 *
 *   capframe.c
 *
 *   Single frame capture
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <vfw.h>
#include <mmddk.h>

#include "ivideo32.h"
#include "avicapi.h"

#include "mmdebug.h"

#ifdef _DEBUG
    #define DSTATUS(lpcs, sz) statusUpdateStatus(lpcs, IDS_CAP_INFO, (LPTSTR) TEXT(sz))
#else
    #define DSTATUS(lpcs, sz)
#endif


/*
 *  SingleFrameCaptureOpen
 *
 */
BOOL FAR PASCAL SingleFrameCaptureOpen (LPCAPSTREAM lpcs)
{
    UINT err;
    if ((lpcs->fCaptureFlags & CAP_fCapturingNow) || (lpcs->fCaptureFlags & CAP_fFrameCapturingNow)) {
        err = IDS_CAP_FILE_OPEN_ERROR;
        goto EarlyExit;
    }

#ifdef NEW_COMPMAN
    /* Warm up the compressor function */
    if (lpcs->CompVars.hic) {
        if (ICSeqCompressFrameStart(&lpcs->CompVars, lpcs->lpBitsInfo) == FALSE) {
            err = IDS_CAP_COMPRESSOR_ERROR;
            goto EarlyExit;
	}
        // Kludge, offset the lpBitsOut ptr
        // Compman allocates the compress buffer too large by
        // 2048 + 16 so we will still have room
        ((LPBYTE) lpcs->CompVars.lpBitsOut) += 8;
    }
#endif

    if (!CapFileInit(lpcs)) {
        err = IDS_CAP_FILE_OPEN_ERROR;
        goto EarlyExit;
    }

    lpcs->fCaptureFlags |= (CAP_fCapturingNow | CAP_fFrameCapturingNow);
    lpcs->dwReturn = DV_ERR_OK;

    statusUpdateStatus(lpcs, IDS_CAP_BEGIN);  // Always the first message

    return TRUE;

EarlyExit:
    errorUpdateError(lpcs, (UINT) err);
    return FALSE;
}


/*
 *  SingleFrameCaptureClose
 *
 *
 */
BOOL FAR PASCAL SingleFrameCaptureClose (LPCAPSTREAM lpcs)
{

    if ((!(lpcs->fCaptureFlags & CAP_fCapturingNow)) && (!(lpcs->fCaptureFlags & CAP_fFrameCapturingNow))) {
        errorUpdateError(lpcs, IDS_CAP_FILE_OPEN_ERROR);
        return FALSE;
    }

    AVIFileFini(lpcs, TRUE /* fWroteJunkChunks */, FALSE /* fAbort */);

#ifdef NEW_COMPMAN
    if (lpcs->CompVars.hic) {
        // Kludge, offset the lpBitsOut ptr
        if (lpcs->CompVars.lpBitsOut)
        ((LPBYTE) lpcs->CompVars.lpBitsOut) -= 8;
	ICSeqCompressFrameEnd(&lpcs->CompVars);
    }
#endif

    lpcs->fCapFileExists = (lpcs->dwReturn == DV_ERR_OK);
    lpcs->fCaptureFlags &= ~(CAP_fCapturingNow | CAP_fFrameCapturingNow);

    statusUpdateStatus(lpcs, IDS_CAP_END);  // Always the last message

    return TRUE;
}

/*
 *  SingleFrameCapture
 *
 *  Append to the open single frame capture file.
 */
BOOL FAR PASCAL SingleFrameCapture (LPCAPSTREAM lpcs)
{
    LPVIDEOHDR lpVidHdr = &lpcs->VidHdr;
    BOOL       fOK = FALSE;
    DWORD      dwBytesUsed;
    BOOL       fKeyFrame;
    LPSTR      lpData;

    if ((!(lpcs->fCaptureFlags & CAP_fCapturingNow)) ||
        (!((lpcs->fCaptureFlags & CAP_fStepCapturingNow) || (lpcs->fCaptureFlags & CAP_fFrameCapturingNow)))
        ) {
        errorUpdateError(lpcs, IDS_CAP_FILE_OPEN_ERROR);
        return FALSE;
    }

    videoFrame (lpcs->hVideoIn, &lpcs->VidHdr);
    InvalidateRect (lpcs->hwnd, NULL, TRUE);

    if (lpVidHdr->dwBytesUsed) {
        UINT wError;
        BOOL bPending = FALSE;

        if (lpcs->CallbackOnVideoFrame)
            lpcs->CallbackOnVideoFrame (lpcs->hwnd, lpVidHdr);

        // Prepend a RIFF chunk
        ((LPRIFF)lpVidHdr->lpData)[-1].dwType = MAKEAVICKID(cktypeDIBbits, 0);
        ((LPRIFF)lpVidHdr->lpData)[-1].dwSize = lpcs->VidHdr.dwBytesUsed;

       #ifdef NEW_COMPMAN
        //
        // We are automatically compressing during capture, so
        // compress the frame before we pass it on to be written
        //
        if (lpcs->CompVars.hic)
        {
            LPRIFF priff;

            dwBytesUsed = 0;
            lpData = ICSeqCompressFrame(&lpcs->CompVars, 0,
                                        lpVidHdr->lpData,
                                        &fKeyFrame,
                                        &dwBytesUsed);

            priff = ((LPRIFF)lpData) -1;
            priff->dwType = MAKEAVICKID(cktypeDIBbits, 0);
            priff->dwSize = dwBytesUsed;
        }
        else {
            lpData = lpVidHdr->lpData;
            dwBytesUsed = lpVidHdr->dwBytesUsed;
            fKeyFrame = lpVidHdr->dwFlags & VHDR_KEYFRAME;
        }
       #endif // NEW_COMPMAN

        // AVIWriteVideoFrame can compress while writing,
        // in this case, the dwBytesUsed and KeyFrame settings
        // may be modified, so pick these up after the write is finished

        AVIWriteVideoFrame (lpcs,
                        lpData,
                        dwBytesUsed,
                        fKeyFrame,
                        (UINT)-1, 0, &wError, &bPending);
        if (wError) {
            errorUpdateError(lpcs, wError);
        }
        else {
            fOK = TRUE;
            statusUpdateStatus (lpcs, IDS_CAP_STAT_CAP_L_FRAMES,
                                lpcs->dwVideoChunkCount);
        }
    } // if the frame is done
    else
        errorUpdateError (lpcs, IDS_CAP_RECORDING_ERROR2);

    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\capinit.c ===
/****************************************************************************
 *
 *   capinit.c
 *
 *   Initialization code.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>

#define MODULE_DEBUG_PREFIX "AVICAP32\\"
#define _INC_MMDEBUG_CODE_ TRUE
#include "MMDEBUG.H"

#if !defined CHICAGO
 #include <ntverp.h>
#endif

#include <mmsystem.h>

#include <vfw.h>
#include "ivideo32.h"
#include "avicapi.h"

HINSTANCE ghInstDll;
TCHAR szCaptureWindowClass[] = TEXT("ClsCapWin");


// If the following structure changes, update AVICAP and AVICAP.32 also!!!
typedef struct tCapDriverInfo {
   TCHAR szKeyEnumName[MAX_PATH];
   TCHAR szDriverName[MAX_PATH];
   TCHAR szDriverDescription[MAX_PATH];
   TCHAR szDriverVersion[80];
   TCHAR szSoftwareKey[MAX_PATH];
   DWORD dnDevNode;         // Set if this is a PnP device
   BOOL  fOnlySystemIni;    // If the [path]drivername is only in system.ini
   BOOL  fDisabled;         // User has disabled driver in the control panel
   BOOL  fActive;           // Reserved
} CAPDRIVERINFO, FAR *LPCAPDRIVERINFO;

DWORD videoCreateDriverList (void);
DWORD videoFreeDriverList (void);

extern UINT            wTotalVideoDevs;  // total video devices
extern LPCAPDRIVERINFO aCapDriverList[]; // Array of all capture drivers

#if !defined CHICAGO
  typedef struct tagVS_VERSION
  {
      WORD wTotLen;
      WORD wValLen;
      WORD wType;
      TCHAR szSig[16];
      WORD Padding1[1];
      VS_FIXEDFILEINFO vffInfo;
  } VS_VERSION;

  typedef struct tagLANGANDCP
  {
      WORD wLanguage;
      WORD wCodePage;
  } LANGANDCP;


/*
typedef struct _VS_FIXEDFILEINFO {  // vsffi
    DWORD dwSignature;
    DWORD dwStrucVersion;
    DWORD dwFileVersionMS;
    DWORD dwFileVersionLS;
    DWORD dwProductVersionMS;
    DWORD dwProductVersionLS;
    DWORD dwFileFlagsMask;
    DWORD dwFileFlags;
    DWORD dwFileOS;
    DWORD dwFileType;
    DWORD dwFileSubtype;
    DWORD dwFileDateMS;
    DWORD dwFileDateLS;
} VS_FIXEDFILEINFO;

VS_VERSION_INFO {
    WORD  wLength;
    WORD  wValueLength;
    WORD  wType;
    WCHAR szKey[16];
    WORD  Padding1[];
    VS_FIXEDFILEINFO Value;
    WORD  Padding2[];
    WORD  Children[];
};


*/

#endif

BOOL gfIsRTL;


/*  Helper */
void SafeAppend(LPTSTR psz1, LPCTSTR psz2, size_t nChars)
{
    int len1inchars = lstrlen(psz1);
    int spaceleftinchars = nChars - len1inchars;
    int charstocopy = min(spaceleftinchars, lstrlen(psz2) + 1);
    CopyMemory(psz1 + len1inchars, psz2, charstocopy * sizeof(TCHAR));
    /*  Null terminate */
    psz1[nChars - 1] = 0;
}
#define SAFEAPPEND(sz1, sz2) \
    SafeAppend(sz1, sz2, NUMELMS(sz1))

BOOL FAR PASCAL RegisterCaptureClass (HINSTANCE hInst)
{
    WNDCLASS cls;

    // If we're already registered, we're OK
    if (GetClassInfo(hInst, szCaptureWindowClass, &cls))
	return TRUE;

    cls.hCursor           = LoadCursor(NULL, IDC_ARROW);
    cls.hIcon             = NULL;
    cls.lpszMenuName      = NULL;
    cls.lpszClassName     = szCaptureWindowClass;
    cls.hbrBackground     = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    cls.hInstance         = hInst;
    cls.style             = CS_HREDRAW|CS_VREDRAW | CS_BYTEALIGNCLIENT |
                            CS_GLOBALCLASS | CS_DBLCLKS;
    cls.lpfnWndProc       = CapWndProc;
    cls.cbClsExtra        = 0;
    // Kludge, VB Status and Error GlobalAlloc'd ptrs + room to grow...
    cls.cbWndExtra        = sizeof (LPCAPSTREAM) + sizeof (DWORD) * 4;

    RegisterClass(&cls);

    return TRUE;
}

//
// Internal version
// Get the name and version of the video device
//
BOOL capInternalGetDriverDesc (UINT wDriverIndex,
        LPTSTR lpszName, int cbName,
        LPTSTR lpszVer, int cbVer)
{
   #ifdef CHICAGO
    // This calls into 16-bit AVICAP via a thunk
    return (BOOL) capxGetDriverDescription ((WORD) wDriverIndex,
                lpszName, (WORD) cbName,
                lpszVer, (WORD) cbVer);
   #else
    LPTSTR  lpVersion;
    UINT    wVersionLen;
    BOOL    bRetCode;
    TCHAR   szGetName[MAX_PATH];
    DWORD   dwVerInfoSize;
    DWORD   dwVerHnd;
    TCHAR   szBuf[MAX_PATH];
    BOOL    fGetName;
    BOOL    fGetVersion;



    fGetName = lpszName != NULL && cbName != 0;
    fGetVersion = lpszVer != NULL && cbVer != 0;

    if(fGetName)
        lpszName[0] = TEXT('\0');
    if(fGetVersion)
        lpszVer [0] = TEXT('\0');


    if(DV_ERR_OK != videoCreateDriverList ())
        return FALSE;

    if(wDriverIndex >= wTotalVideoDevs) {
       videoFreeDriverList ();
       return FALSE;
    }


    // Use description and version from registry,
    // but can be overwritten by the file's description and product version.
    if(fGetName) {
        if(lstrlen(aCapDriverList[wDriverIndex]->szDriverDescription))
            lstrcpyn(lpszName, aCapDriverList[wDriverIndex]->szDriverDescription, cbName);
        else   // If no description, we have at least the driver name.
            lstrcpyn(lpszName, aCapDriverList[wDriverIndex]->szDriverName,        cbName);
    }

    if(fGetVersion)
        lstrcpyn(lpszVer,  aCapDriverList[wDriverIndex]->szDriverVersion,         cbVer);

    lstrcpyn(szBuf, aCapDriverList[wDriverIndex]->szDriverName, MAX_PATH);

    videoFreeDriverList ();

    // You must find the size first before getting any file info
    dwVerInfoSize = GetFileVersionInfoSize(szBuf, &dwVerHnd);

    if (dwVerInfoSize) {
        LPTSTR   lpstrVffInfo;            // Pointer to block to hold info
        HANDLE  hMem;                     // handle to mem alloc'ed

        // Get a block big enough to hold version info
        hMem          = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize);
        lpstrVffInfo  = GlobalLock(hMem);

        // Get the File Version first
        if (GetFileVersionInfo(szBuf, 0L, dwVerInfoSize, lpstrVffInfo)) {
             VS_VERSION FAR *pVerInfo = (VS_VERSION FAR *) lpstrVffInfo;

             // fill in the file version
             wsprintf(szBuf,
                      TEXT("Version:  %d.%d.%d.%d"),
                      HIWORD(pVerInfo->vffInfo.dwFileVersionMS),
                      LOWORD(pVerInfo->vffInfo.dwFileVersionMS),
                      HIWORD(pVerInfo->vffInfo.dwFileVersionLS),
                      LOWORD(pVerInfo->vffInfo.dwFileVersionLS));
             if (fGetVersion)
                lstrcpyn (lpszVer, szBuf, cbVer);
        }

        // Now try to get the FileDescription
        // First try this for the "Translation" entry, and then
        // try the American english translation.
        // Keep track of the string length for easy updating.
        // 040904E4 represents the language ID and the four
        // least significant digits represent the codepage for
        // which the data is formatted.  The language ID is
        // composed of two parts: the low ten bits represent
        // the major language and the high six bits represent
        // the sub language.

        lstrcpy(szGetName, TEXT("\\StringFileInfo\\040904E4\\FileDescription"));

        wVersionLen   = 0;
        lpVersion     = NULL;

        // Look for the corresponding string.
        bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo,
                        (LPTSTR)szGetName,
                        (void FAR* FAR*)&lpVersion,
                        (UINT FAR *) &wVersionLen);

        if (fGetName && bRetCode && wVersionLen && lpVersion)
           lstrcpyn (lpszName, lpVersion, cbName);

        // Let go of the memory
        GlobalUnlock(hMem);
        GlobalFree(hMem);
    }
    return TRUE;

   #endif
}

#ifdef UNICODE
// ansi thunk for above (called from ansi thunk functions
// for capGetDriverDescriptionA, and WM_GET_DRIVER_NAMEA etc)
BOOL capInternalGetDriverDescA(UINT wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer)
{
    LPWSTR pName = NULL, pVer = NULL;
    BOOL bRet;

    if (lpszName) {
        pName = LocalAlloc(LPTR, cbName * sizeof(WCHAR));
    }

    if (lpszVer) {
        pVer = LocalAlloc(LPTR, cbVer * sizeof(WCHAR));
    }

    bRet = capInternalGetDriverDesc(
            wDriverIndex,
            pName, cbName,
            pVer, cbVer);

    if (lpszName) {
        WideToAnsi(lpszName, pName, cbName);
    }

    if (lpszVer) {
        WideToAnsi(lpszVer, pVer, cbVer);
    }

    if (pVer) {
        LocalFree(pVer);
    }

    if (pName) {
        LocalFree(pName);
    }

    return bRet;
}
#endif


//
// Exported version
// Get the name and version of the video device
//
// unicode and win-16 version - see ansi thunk below
BOOL VFWAPI capGetDriverDescription (UINT wDriverIndex,
        LPTSTR lpszName, int cbName,
        LPTSTR lpszVer, int cbVer)
{
    return (capInternalGetDriverDesc (wDriverIndex,
        lpszName, cbName,
        lpszVer, cbVer));
}

#ifdef UNICODE
// ansi thunk for above
BOOL VFWAPI capGetDriverDescriptionA(UINT wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer)
{
    return capInternalGetDriverDescA(wDriverIndex,
        lpszName, cbName, lpszVer, cbVer);
}
#endif


//
// Disconnect from hardware resources
//
BOOL CapWinDisconnectHardware(LPCAPSTREAM lpcs)
{
    if( lpcs->hVideoCapture ) {
        videoStreamFini (lpcs->hVideoCapture);
        videoClose( lpcs->hVideoCapture );
    }
    if( lpcs->hVideoDisplay ) {
        videoStreamFini (lpcs->hVideoDisplay);
        videoClose( lpcs->hVideoDisplay );
    }
    if( lpcs->hVideoIn ) {
        videoClose( lpcs->hVideoIn );
    }

    lpcs->fHardwareConnected = FALSE;

    lpcs->hVideoCapture = NULL;
    lpcs->hVideoDisplay = NULL;
    lpcs->hVideoIn = NULL;

    lpcs->sCapDrvCaps.fHasDlgVideoSource = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoFormat = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoDisplay = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoDisplay = FALSE;
    lpcs->sCapDrvCaps.fHasOverlay = FALSE;
    lpcs->sCapDrvCaps.fDriverSuppliesPalettes = FALSE;

    lpcs->sCapDrvCaps.hVideoIn          = NULL;
    lpcs->sCapDrvCaps.hVideoOut         = NULL;
    lpcs->sCapDrvCaps.hVideoExtIn       = NULL;
    lpcs->sCapDrvCaps.hVideoExtOut      = NULL;

    return TRUE;
}

//
// Connect to hardware resources
// Return: TRUE if hardware connected to the stream
//
BOOL CapWinConnectHardware (LPCAPSTREAM lpcs, UINT wDeviceIndex)
{
    DWORD dwError;
    CHANNEL_CAPS VideoCapsExternalOut;
    TCHAR ach1[MAX_PATH];
    TCHAR ach2[MAX_PATH * 3];
    CAPINFOCHUNK cic;
    HINSTANCE hInstT;

    lpcs->hVideoCapture = NULL;
    lpcs->hVideoDisplay = NULL;
    lpcs->hVideoIn = NULL;
    lpcs->fHardwareConnected = FALSE;
    lpcs->fUsingDefaultPalette = TRUE;
    lpcs->sCapDrvCaps.fHasDlgVideoSource = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoFormat = FALSE;
    lpcs->sCapDrvCaps.fHasDlgVideoDisplay = FALSE;
    lpcs->sCapDrvCaps.wDeviceIndex = wDeviceIndex;

    // Clear any existing capture device name chunk
    cic.fccInfoID = mmioFOURCC ('I','S','F','T');
    cic.lpData = NULL;
    cic.cbData = 0;
    SetInfoChunk (lpcs, &cic);

    // try and open the video hardware!!!
    if( !(dwError = videoOpen( &lpcs->hVideoIn, wDeviceIndex, VIDEO_IN ) ) ) {
        if( !(dwError = videoOpen( &lpcs->hVideoCapture, wDeviceIndex, VIDEO_EXTERNALIN ) ) ) {
            // We don't require the EXTERNALOUT channel,
            // but do require EXTERNALIN and IN
            videoOpen( &lpcs->hVideoDisplay, wDeviceIndex, VIDEO_EXTERNALOUT );
            if( (!dwError) && lpcs->hVideoCapture && lpcs->hVideoIn ) {

                lpcs->fHardwareConnected = TRUE;
                capInternalGetDriverDesc (wDeviceIndex,
                        ach1, sizeof (ach1) / sizeof(TCHAR),
                        ach2, sizeof (ach2) / sizeof(TCHAR));
                SAFEAPPEND(ach1, TEXT(", "));
                SAFEAPPEND(ach1, ach2);

                statusUpdateStatus (lpcs, IDS_CAP_INFO, (LPTSTR) ach1);

                // Make a string of the current task and capture driver
                ach2[0] = '\0';
                if (hInstT = GetWindowInstance (GetParent(lpcs->hwnd)))
                    GetModuleFileName (hInstT, ach2, sizeof (ach2)/sizeof(TCHAR));
                SAFEAPPEND (ach2, TEXT(" -AVICAP32- "));
                SAFEAPPEND (ach2, ach1);

                // Set software chunk with name of capture device
                if (*ach2) {

#ifdef UNICODE
		    // INFO chunks must be ASCII data
		    CHAR achA[MAX_PATH*3];
                    cic.cbData = lstrlen(ach2) + 1;  // set the number of characters
		    WideToAnsi(achA, ach2, cic.cbData);
                    cic.lpData = achA;
#else
                    cic.lpData = ach2;
                    cic.cbData = lstrlen(ach2) + 1;
#endif
                    SetInfoChunk (lpcs, &cic);
                }
            }
        }
    }
    if (dwError)
        errorDriverID (lpcs, dwError);

    if(!lpcs->fHardwareConnected) {
       CapWinDisconnectHardware(lpcs);
    }
    else {
        if (lpcs->hVideoDisplay && videoGetChannelCaps (lpcs->hVideoDisplay,
                &VideoCapsExternalOut,
                sizeof (CHANNEL_CAPS)) == DV_ERR_OK) {
            lpcs->sCapDrvCaps.fHasOverlay = (BOOL)(VideoCapsExternalOut.dwFlags &
                (DWORD)VCAPS_OVERLAY);
        }
        else
             lpcs->sCapDrvCaps.fHasOverlay = FALSE;
        // if the hardware doesn't support it, make sure we don't enable
        if (!lpcs->sCapDrvCaps.fHasOverlay)
            lpcs->fOverlayWindow = FALSE;

       // Start the external in channel streaming continuously
       videoStreamInit (lpcs->hVideoCapture, 0L, 0L, 0L, 0L);
    } // end if hardware is available

#if 0
    // if we don't have a powerful machine, disable capture
    if (GetWinFlags() & (DWORD) WF_CPU286)
       CapWinDisconnectHardware(lpcs);
#endif

    if (!lpcs->fHardwareConnected){
        lpcs->fLiveWindow = FALSE;
        lpcs->fOverlayWindow = FALSE;
    }

    if (lpcs->hVideoIn)
        lpcs->sCapDrvCaps.fHasDlgVideoFormat = !videoDialog (lpcs->hVideoIn,
                        lpcs->hwnd, VIDEO_DLG_QUERY);

    if (lpcs->hVideoCapture)
         lpcs->sCapDrvCaps.fHasDlgVideoSource = !videoDialog (lpcs->hVideoCapture,
                        lpcs->hwnd, VIDEO_DLG_QUERY);

    if (lpcs->hVideoDisplay)
         lpcs->sCapDrvCaps.fHasDlgVideoDisplay = !videoDialog (lpcs->hVideoDisplay,
                        lpcs->hwnd, VIDEO_DLG_QUERY);

    // these handles are not supported on WIN32 for the good reason that
    // the videoXXX api set is not published for 32-bit
    // we might want to make use of the handles ourselves...???
    lpcs->sCapDrvCaps.hVideoIn          = NULL;
    lpcs->sCapDrvCaps.hVideoOut         = NULL;
    lpcs->sCapDrvCaps.hVideoExtIn       = NULL;
    lpcs->sCapDrvCaps.hVideoExtOut      = NULL;

    return lpcs->fHardwareConnected;
}



//
// Creates a child window of the capture class
// Normally:
//   Set lpszWindowName to NULL
//   Set dwStyle to WS_CHILD | WS_VISIBLE
//   Set hmenu to a unique child id

// Unicode and Win-16 version. See ansi thunk below
HWND VFWAPI capCreateCaptureWindow (
        LPCTSTR lpszWindowName,
        DWORD dwStyle,
        int x, int y, int nWidth, int nHeight,
        HWND hwndParent, int nID)
{
    DWORD   dwExStyle;

    dwExStyle = gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0;
    RegisterCaptureClass(ghInstDll);

#ifdef USE_AVIFILE
    AVIFileInit();
#endif

    return CreateWindowEx(dwExStyle,
                szCaptureWindowClass,
                lpszWindowName,
                dwStyle,
                x, y, nWidth, nHeight,
                hwndParent, (HMENU) nID,
                ghInstDll,
                NULL);
}

#ifdef UNICODE
// ansi thunk
HWND VFWAPI capCreateCaptureWindowA (
                LPCSTR lpszWindowName,
                DWORD dwStyle,
                int x, int y, int nWidth, int nHeight,
                HWND hwndParent, int nID)
{
    LPWSTR pw;
    int chsize;
    HWND hwnd;

    if (lpszWindowName == NULL) {
        pw = NULL;
    } else {
        // remember the null
        chsize = lstrlenA(lpszWindowName) + 1;
        pw = LocalLock(LocalAlloc(LPTR, chsize * sizeof(WCHAR)));

        AnsiToWide(pw, lpszWindowName, chsize);
    }

    hwnd = capCreateCaptureWindowW(pw, dwStyle, x, y, nWidth, nHeight,
                hwndParent, nID);

    if (pw != NULL) {
        LocalFree(LocalHandle(pw));
    }
    return(hwnd);
}
#endif


#ifdef CHICAGO

static char pszDll16[] = "AVICAP.DLL";
static char pszDll32[] = "AVICAP32.DLL";

BOOL PASCAL avicapf_ThunkConnect32(LPCSTR pszDll16, LPCSTR pszDll32, HINSTANCE hinst, DWORD dwReason);

BOOL WINAPI DllMain(
    HANDLE hInstance,
    DWORD  dwReason,
    LPVOID reserved)
{
    #if defined DEBUG || defined DEBUG_RETAIL
    DebugSetOutputLevel (GetProfileInt ("Debug", "Avicap32", 0));
    AuxDebugEx (1, DEBUGLINE "DllEntryPoint, %08x,%08x,%08x\r\n", hInstance, dwReason, reserved);
    #endif

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        char   ach[2];
        ghInstDll = hInstance;

        LoadString(ghInstDll, IDS_CAP_RTL, ach, sizeof(ach));
        gfIsRTL = ach[0] == TEXT('1');

        // INLINE_BREAK;
        if (!avicapf_ThunkConnect32(pszDll16, pszDll32, hInstance, dwReason))
            return FALSE;

       #if defined _WIN32 && defined CHICAGO
        // we do this so that we can Get LinPageLock & PageAllocate services
        //
        ;
//        OpenMMDEVLDR();
       #endif

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {

       #if defined _WIN32 && defined CHICAGO
       ;
//        CloseMMDEVLDR();
       #endif

        return avicapf_ThunkConnect32(pszDll16, pszDll32, hInstance, dwReason);
    }

    return TRUE;
}

#else // this is the NT dll entry point

BOOL DllInstanceInit(HANDLE hInstance, DWORD dwReason, LPVOID reserved)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
	TCHAR  ach[2];

	ghInstDll = hInstance;
	DisableThreadLibraryCalls(hInstance);
        LoadString(ghInstDll, IDS_CAP_RTL, ach, NUMELMS(ach));
        gfIsRTL = ach[0] == TEXT('1');
	DebugSetOutputLevel (GetProfileIntA("Debug", "Avicap32", 0));
        videoInitHandleList();
    } else if (dwReason == DLL_PROCESS_DETACH) {
        videoDeleteHandleList();
    }
    return TRUE;
}

#endif // CHICAGO / NT dll entry point
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\capmci.c ===
/****************************************************************************
 *
 *   capmci.c
 *
 *   Control of MCI devices during capture.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <vfw.h>
#include <mmddk.h>

#include "ivideo32.h"
#include "avicapi.h"

#include "mmdebug.h"

// First, override the definition in media\inc\win32.h that causes strsafe to not work on Win64
#ifndef _X86_
#undef __inline
#endif // _X86_
// Then, include strsafe.h
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#ifdef _DEBUG
    #define DSTATUS(lpcs, sz) statusUpdateStatus(lpcs, IDS_CAP_INFO, (LPTSTR) TEXT(sz))
#else
    #define DSTATUS(lpcs, sz)
#endif

DWORD SendDriverFormat (LPCAPSTREAM lpcs, LPBITMAPINFOHEADER lpbih, DWORD dwInfoHeaderSize);

/*--------------------------------------------------------------+
| TimeMSToSMPTE() - change milliseconds into SMPTE time     |
+--------------------------------------------------------------*/
void FAR PASCAL TimeMSToSMPTE (DWORD dwMS, LPSTR lpTime)
{
	DWORD	dwTotalSecs;
	LONG	lHundredths;
	WORD	wSecs;
	WORD	wMins;
	WORD	wHours;

	/* convert to number of seconds */
	dwTotalSecs = dwMS / 1000;
	
	/* keep the remainder part */
	lHundredths = (dwMS - (dwTotalSecs * 1000)) / 10;
		
	/* break down into other components */
	wHours = (WORD)(dwTotalSecs / 3600);	// get # Hours
	dwTotalSecs -= (wHours * 3600);
	
	wMins = (WORD)(dwTotalSecs / 60);	// get # Mins
	dwTotalSecs -= (wMins * 60);
	
	wSecs = (WORD)dwTotalSecs;	// what's left is # seconds
	
	/* build the string */
	/* KLUDGE, force hundredths to SMPTE approximation of PAL frames */
	wsprintfA((LPSTR)lpTime, "%02u:%02u:%02u:%02lu", wHours, wMins,
		    wSecs, (lHundredths * 25) / 100);
}


/*--------------------------------------------------------------+
| START OF MCI CONTROL SECTION                                 |
+--------------------------------------------------------------*/

/*
 *  CountMCIDevicesByType
 *      Returns a count of the number of VCR or Videodisc
 *      devices that MCI claims to know about.
 */

int CountMCIDevicesByType ( UINT wType )
{
   int nTotal = 0;
   DWORD dwCount;
   MCI_SYSINFO_PARMS mciSIP;

   mciSIP.dwCallback = 0;
   mciSIP.lpstrReturn = (LPTSTR) (LPVOID) &dwCount;
   mciSIP.dwRetSize = sizeof (dwCount);

   mciSIP.wDeviceType = wType;

   if (!mciSendCommand (0, MCI_SYSINFO, MCI_SYSINFO_QUANTITY,
        (DWORD_PTR) (LPVOID) &mciSIP))
       nTotal = (int) *( (LPDWORD) mciSIP.lpstrReturn);

   return nTotal;
}

/*
 *  MCIDeviceClose
 *      This routine closes the open MCI device.
 */

void MCIDeviceClose (LPCAPSTREAM lpcs)
{
    mciSendString( TEXT("close mciframes"), NULL, 0, NULL );
}

/*
 *  MCIDeviceOpen
 *      This routine opens the mci device for use, and sets the
 *      time format to milliseconds.
 *      Return FALSE on error;
 */

BOOL MCIDeviceOpen (LPCAPSTREAM lpcs)
{
    TCHAR        ach[160];

    // Fix: Change from wsprintf to StringCchPrintf so we don't overrun ach
    StringCchPrintf( ach, NUMELMS(ach), TEXT("open %s shareable alias mciframes"),
                (LPTSTR) lpcs->achMCIDevice);
    lpcs->dwMCIError = mciSendString( ach, NULL, 0, NULL );
    if( lpcs->dwMCIError ) {
        DPF (" MCI Error, open %s shareable alias mciframes", lpcs->achMCIDevice);
        goto err_return;
    }
    lpcs->dwMCIError = mciSendString( TEXT("set mciframes time format milliseconds"),
        NULL, 0, NULL );
    if( lpcs->dwMCIError ) {
        DPF (" MCI Error, set mciframes time format milliseconds");
        goto err_close;
    }
    return ( TRUE );

err_close:
    MCIDeviceClose (lpcs);
err_return:
    return ( FALSE );
}


/*
 *  MCIDeviceGetPosition
 *      Stores the current device position in milliseconds in lpdwPos.
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceGetPosition (LPCAPSTREAM lpcs, LPDWORD lpdwPos)
{
    TCHAR        ach[80];
    LPTSTR       p;
    LONG        lv;

    lpcs->dwMCIError = mciSendString( TEXT("status mciframes position wait"),
        ach, sizeof(ach)/sizeof(TCHAR), NULL );
    if( lpcs->dwMCIError ) {
        DPF (" MCI Error, status mciframes position wait");
        *lpdwPos = 0L;
        return FALSE;
    }

    p = ach;

    while (*p == ' ') p++;
    for (lv = 0; *p >= '0' && *p <= '9'; p++)
        lv = (10 * lv) + (*p - '0');
    *lpdwPos = lv;
    return TRUE;
}

/*
 *  MCIDeviceSetPosition
 *      Sets the current device position in milliseconds.
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceSetPosition (LPCAPSTREAM lpcs, DWORD dwPos)
{
    TCHAR        achCommand[40];
    TCHAR        ach[80];

    lpcs->dwMCIError = mciSendString( TEXT("pause mciframes wait"), ach, sizeof(ach)/sizeof(TCHAR), NULL );
    if (lpcs->dwMCIError) {
        DPF (" MCI Error, pause mciframes wait");
        return FALSE;
    }
    wsprintf(achCommand, TEXT("seek mciframes to %ld wait"), dwPos);
    lpcs->dwMCIError = mciSendString( achCommand, ach, sizeof(ach)/sizeof(TCHAR), NULL );
    if (lpcs->dwMCIError)
        DPF (" MCI Error, seek mciframes to %ld wait", dwPos);
    return ( lpcs->dwMCIError == 0 ? TRUE : FALSE );
}


/*
 *  MCIDevicePlay
 *      Start playing the current MCI device from the current position
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDevicePlay (LPCAPSTREAM lpcs)
{
    TCHAR        ach[80];

    lpcs->dwMCIError = mciSendString( TEXT("play mciframes"), ach, sizeof(ach)/sizeof(TCHAR), NULL );
    if (lpcs->dwMCIError)
        DPF (" MCI Error, play mciframes");
    return ( lpcs->dwMCIError == 0 ? TRUE : FALSE );
}

/*
 *  MCIDevicePause
 *      Pauses the current MCI device at the current position
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDevicePause (LPCAPSTREAM lpcs)
{
    TCHAR        ach[80];

    lpcs->dwMCIError = mciSendString( TEXT("pause mciframes wait"), ach, sizeof(ach)/sizeof(TCHAR), NULL );
    if (lpcs->dwMCIError)
        DPF (" MCI Error, pause mciframes wait");
    return ( lpcs->dwMCIError == 0 ? TRUE : FALSE );
}

/*
 *  MCIDeviceStop
 *      Stops the current MCI device
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceStop (LPCAPSTREAM lpcs)
{
    TCHAR        ach[80];

    lpcs->dwMCIError = mciSendString( TEXT("stop mciframes wait"), ach, sizeof(ach)/sizeof(TCHAR), NULL );
    if (lpcs->dwMCIError)
        DPF (" MCI Error, stop mciframes wait");
    return ( lpcs->dwMCIError == 0 ? TRUE : FALSE );
}

/*
 *  MCIDeviceStep
 *      Step the current MCI at the current position
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceStep (LPCAPSTREAM lpcs, BOOL fForward)
{
    TCHAR        ach[80];

    lpcs->dwMCIError = mciSendString(
                          fForward ? TEXT("step mciframes wait") :
                TEXT("step mciframes reverse wait"), ach, sizeof(ach)/sizeof(TCHAR), NULL );
    if (lpcs->dwMCIError)
        DPF (" MCI Error, step mciframes wait");
    return ( lpcs->dwMCIError == 0 ? TRUE : FALSE );
}

/*
 *  MCIDeviceFreeze
 *      freeze the current frame
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceFreeze(LPCAPSTREAM lpcs, BOOL fFreeze)
{
    lpcs->dwMCIError = mciSendString( fFreeze ? TEXT("freeze mciframes wait") :
                TEXT("unfreeze mciframes wait"), NULL, 0, NULL);
    if (lpcs->dwMCIError)
        DPF (" MCI Error, freeze mciframes wait");
    return ( lpcs->dwMCIError == 0 ? TRUE : FALSE );
}


/*
 *  MCIStepCapture
 *      Main routine for performing MCI step capture.
 *
 */
void FAR PASCAL _LOADDS MCIStepCapture (LPCAPSTREAM lpcs)
{
    BOOL        fOK = TRUE;
    BOOL        fT;
    BOOL        fStopping;         // True when finishing capture
    DWORD       dw;
    int         iNumAudio;
    UINT        wError;         // Error String ID
    LPVIDEOHDR  lpVidHdr;
    LPWAVEHDR   lpWaveHdr;
    DWORD       dwTimeToStop;   // Lesser of MCI capture time or frame limit
    BOOL        fTryToPaint = FALSE;
    HDC         hdc;
    HPALETTE    hpalT;
    RECT        rcDrawRect;
#define PROMPTFORSTEPCAPTURE
#ifdef PROMPTFORSTEPCAPTURE
    TCHAR       ach[128];
    TCHAR       achMsg[128];
#endif

    statusUpdateStatus(lpcs, IDS_CAP_BEGIN);  // Always the first message

    // Verify capture parameters
    if ((!lpcs->sCapParms.fMCIControl) ||
        (!lpcs->sCapParms.fStepMCIDevice))
        goto EarlyExit;

    lpcs->MCICaptureState = CAPMCI_STATE_Uninitialized;

    lpcs->fCaptureFlags |= (CAP_fCapturingNow | CAP_fStepCapturingNow);
    lpcs->dwReturn = DV_ERR_OK;

    // If not 1 Meg. free, give it up!!!
    if (GetFreePhysicalMemory () < (1024L * 1024L)) {
        errorUpdateError (lpcs, IDS_CAP_OUTOFMEM);
        goto EarlyExit;
    }

    statusUpdateStatus(lpcs, IDS_CAP_STAT_CAP_INIT);

    // Try painting the DIB only if Live window
    fTryToPaint = lpcs->fLiveWindow;

    if (fTryToPaint) {
        hdc = GetDC(lpcs->hwnd);
        SetWindowOrgEx(hdc, lpcs->ptScroll.x, lpcs->ptScroll.y, NULL);
        hpalT = DrawDibGetPalette (lpcs->hdd);
        if (hpalT)
            hpalT = SelectPalette( hdc, hpalT, FALSE);
        RealizePalette(hdc);
        if (lpcs->fScale)
            GetClientRect (lpcs->hwnd, &rcDrawRect);
        else
            SetRect (&rcDrawRect, 0, 0, lpcs->dxBits, lpcs->dyBits);
    }

    // -------------------------------------------------------
    //   When should capture stop?
    // -------------------------------------------------------

    // If using MCI, capture for the shorter of the MCI period,
    // or the capture limit

    if (lpcs->sCapParms.fLimitEnabled)
        dwTimeToStop = (DWORD) ((DWORD) 1000 * lpcs->sCapParms.wTimeLimit);
    else
        dwTimeToStop = (DWORD) -1L; // very large

    if (lpcs->sCapParms.fMCIControl) {
        // if MCI stop time not given, use lpcs->sCapParms.wTimeLimit
        if (lpcs->sCapParms.dwMCIStopTime == lpcs->sCapParms.dwMCIStartTime)
                    lpcs->sCapParms.dwMCIStopTime = lpcs->sCapParms.dwMCIStartTime +
                    (DWORD) ((DWORD)1000 * lpcs->sCapParms.wTimeLimit);

        dw = lpcs->sCapParms.dwMCIStopTime - lpcs->sCapParms.dwMCIStartTime;

        if (lpcs->sCapParms.fLimitEnabled)
            dwTimeToStop = min (dw, dwTimeToStop);
        else
            dwTimeToStop = dw;
    }

    //
    // never ever try to capture more than the index size!
    //
    if (lpcs->fCaptureFlags & CAP_fCapturingToDisk) {
	dw = MulDiv(lpcs->sCapParms.dwIndexSize,
                lpcs->sCapParms.dwRequestMicroSecPerFrame,
                1000l);
	dwTimeToStop = min (dw, dwTimeToStop);
    }

    fOK = FALSE;            // Assume the worst
    if (MCIDeviceOpen (lpcs)) {
        if (MCIDeviceSetPosition (lpcs, lpcs->sCapParms.dwMCIStartTime))
            if (MCIDeviceStep (lpcs, TRUE))
                fOK = TRUE;
    }
    if (!fOK) {
        errorUpdateError (lpcs, IDS_CAP_MCI_CONTROL_ERROR);
        statusUpdateStatus(lpcs, 0);    // Clear status
        goto EarlyExit;
    }

    // -------------------------------------------------------
    //  Spatial and temporal averaging
    // -------------------------------------------------------

    // Frame Averaging, capture the same frame multiple times...
    lpcs->lpia = NULL;
    if (lpcs->sCapParms.wStepCaptureAverageFrames == 0)
        lpcs->sCapParms.wStepCaptureAverageFrames = 1;

    // Only allow averaging if an RGB format
    if (lpcs->lpBitsInfo->bmiHeader.biCompression != BI_RGB)
        lpcs->sCapParms.wStepCaptureAverageFrames = 1;

    // 2x Scaling
    lpcs->lpbmih2x = NULL;
    lpcs->VidHdr2x = lpcs->VidHdr;        // Init the 2x copy

    if (lpcs->sCapParms.fStepCaptureAt2x &&
                lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RGB) {
        lpcs->VidHdr2x.lpData = NULL;
        lpcs->lpbmih2x = (LPBITMAPINFOHEADER) GlobalAllocPtr (GHND,
                sizeof (BITMAPINFOHEADER) +
                256 * sizeof (RGBQUAD));
        CopyMemory (lpcs->lpbmih2x, lpcs->lpBitsInfo,
                    sizeof (BITMAPINFOHEADER) + 256 * sizeof (RGBQUAD));

        // Try to force the driver into 2x mode
        lpcs->lpbmih2x->biHeight    *= 2;
        lpcs->lpbmih2x->biWidth     *= 2;
        lpcs->lpbmih2x->biSizeImage *= 4;
        if (!SendDriverFormat (lpcs, lpcs->lpbmih2x, sizeof (BITMAPINFOHEADER))) {
            // Success, allocate new bitspace
            lpcs->VidHdr2x.lpData = GlobalAllocPtr (GHND,
                        lpcs->lpbmih2x->biSizeImage);
            lpcs->VidHdr2x.dwBufferLength = lpcs->lpbmih2x->biSizeImage;
        }

        // Something went wrong, no memory, or driver failed request
        // so revert back to original settings
        if (!lpcs->VidHdr2x.lpData) {
            SendDriverFormat (lpcs, (LPBITMAPINFOHEADER) lpcs->lpBitsInfo,
                sizeof (BITMAPINFOHEADER));
            lpcs->sCapParms.fStepCaptureAt2x = FALSE;
            lpcs->VidHdr2x = lpcs->VidHdr;        // Back to the original settings
        }
    }
    else
        lpcs->sCapParms.fStepCaptureAt2x = FALSE;

    DPF (" StepCaptureAt2x = %d\r\n", (int) lpcs->sCapParms.fStepCaptureAt2x);

    //
    // If we're compressing while capturing, warm up the compressor
    //
#ifdef NEW_COMPMAN
    if (lpcs->CompVars.hic) {
        if (ICSeqCompressFrameStart(&lpcs->CompVars, lpcs->lpBitsInfo) == 0) {

	    // !!! We're in trouble here!
            dprintf("ICSeqCompressFrameStart failed !!!\n");
            errorUpdateError (lpcs, IDS_CAP_COMPRESSOR_ERROR);
            goto EarlyExit;
        }
        // Kludge, offset the lpBitsOut ptr
        // Compman allocates the compress buffer too large by
        // 2048 + 16 so we will still have room
        ((LPBYTE) lpcs->CompVars.lpBitsOut) += 8;
    }

    // No compression desired
    if (!lpcs->CompVars.hic)
	WinAssert(lpcs->CompVars.lpbiOut == NULL);
#endif


    // -------------------------------------------------------
    //  Open the output file
    // -------------------------------------------------------

    if (lpcs->fCaptureFlags & CAP_fCapturingToDisk) {
        if (!CapFileInit(lpcs)) {
            errorUpdateError (lpcs, IDS_CAP_FILE_OPEN_ERROR);
            goto EarlyExit;
        }
    }

    /* Make sure the parent has been repainted */
    UpdateWindow(lpcs->hwnd);

    //
    // AVIInit will allocate sound buffers, but not video buffers
    // when performing step capture.
    //

    wError = IDS_CAP_AVI_INIT_ERROR;
    lpcs->hCaptureEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (lpcs->hCaptureEvent)
    {
       #ifdef CHICAGO
        lpcs->hRing0CapEvt = OpenVxDHandle (lpcs->hCaptureEvent);
        if ( ! lpcs->hRing0CapEvt)
            CloseHandle (lpcs->hCaptureEvent), lpcs->hCaptureEvent = NULL;
        else
       #endif
	wError = AVIInit(lpcs);
    }

    if (wError) {
        lpcs->sCapParms.fUsingDOSMemory = FALSE;
        wError = AVIInit(lpcs);
    }

    if (wError) {
        /* Error in initalization - return */
        errorUpdateError (lpcs, wError);
        AVIFini(lpcs);
        AVIFileFini(lpcs, TRUE /* fWroteJunkChunks */, TRUE /* fAbort */);
        statusUpdateStatus(lpcs, 0);    // Clear status
	// assert(lpcs->dwReturn == wError);
        goto EarlyExit;
    }

#ifdef PROMPTFORSTEPCAPTURE
    // -------------------------------------------------------
    //   Ready to go, make the user click OK?
    // -------------------------------------------------------

    // Click OK to capture string (must follow AVIInit)
    //
    LoadString(lpcs->hInst, IDS_CAP_SEQ_MSGSTART, ach, NUMELMS(ach));
    // Fix: Change from wsprintf to StringCchPrintf so we don't overrun achMsg
    StringCchPrintf(achMsg, NUMELMS(achMsg), ach, (LPBYTE)lpcs->achFile);

    if (lpcs->sCapParms.fMakeUserHitOKToCapture && (lpcs->fCaptureFlags & CAP_fCapturingToDisk))
    {
        UINT idBtn;

        idBtn = MessageBox (lpcs->hwnd, achMsg, TEXT(""),
                            MB_OKCANCEL | MB_ICONEXCLAMATION);

        if (idBtn == IDCANCEL)
        {
            AVIFini(lpcs);
            AVIFileFini (lpcs, TRUE, TRUE);
            statusUpdateStatus (lpcs, 0);
            goto EarlyExit;
        }
    }
#endif // PROMPTFORSTEPCAPTURE

    /* update the status, so the user knows how to stop */
    statusUpdateStatus(lpcs, IDS_CAP_SEQ_MSGSTOP);
    UpdateWindow(lpcs->hwnd);


    if (lpcs->sCapParms.fStepCaptureAt2x || (lpcs->sCapParms.wStepCaptureAverageFrames != 1)) {
        LPIAVERAGE FAR * lppia = (LPIAVERAGE FAR *) &lpcs->lpia;

        statusUpdateStatus (lpcs, IDS_CAP_STAT_PALETTE_BUILD);
        if (!iaverageInit (lppia, lpcs->lpBitsInfo, lpcs->hPalCurrent)) {
            lpcs->dwReturn = IDS_CAP_OUTOFMEM;
            goto CompressFrameFailure;
        }
        statusUpdateStatus(lpcs, 0);
    }
    DPF (" Averaging %d frames\r\n", lpcs->sCapParms.wStepCaptureAverageFrames);

    GetAsyncKeyState(lpcs->sCapParms.vKeyAbort);
    GetAsyncKeyState(VK_ESCAPE);
    GetAsyncKeyState(VK_LBUTTON);
    GetAsyncKeyState(VK_RBUTTON);


    // -------------------------------------------------------
    //   MAIN VIDEO CAPTURE LOOP
    // -------------------------------------------------------

    fOK=TRUE;             // Set FALSE on write errors
    fStopping = FALSE;    // TRUE when we need to stop

    lpVidHdr  = &lpcs->VidHdr;
    lpWaveHdr = lpcs->alpWaveHdr[lpcs->iNextWave];

    lpcs->MCICaptureState = CAPMCI_STATE_Initialized;
    lpcs->dwTimeElapsedMS = 0;

    // Move back to the starting position
    MCIDeviceSetPosition (lpcs, lpcs->sCapParms.dwMCIStartTime);
    MCIDevicePause (lpcs);

    // Where are we *really*
    MCIDeviceGetPosition (lpcs, &lpcs->dwMCIActualStartMS);

    // freeze video
    MCIDeviceFreeze(lpcs, TRUE);

    while (lpcs->MCICaptureState != CAPMCI_STATE_AllFini) {

        // -------------------------------------------------------
        //   is there any reason to stop or change states
        // -------------------------------------------------------
        if (lpcs->sCapParms.vKeyAbort) {
            if (GetAsyncKeyState(lpcs->sCapParms.vKeyAbort & 0x00ff) & 0x0001) {
                fT = TRUE;
                if (lpcs->sCapParms.vKeyAbort & 0x8000)  // Ctrl?
                    fT = fT && (GetAsyncKeyState(VK_CONTROL) & 0x8000);
                if (lpcs->sCapParms.vKeyAbort & 0x4000)  // Shift?
                    fT = fT && (GetAsyncKeyState(VK_SHIFT) & 0x8000);
                fStopping = fT;      // User aborts
            }
        }
#if 0
        // Ignore Left mouse on MCI Capture!!!
        if (lpcs->sCapParms.fAbortLeftMouse)
            if (GetAsyncKeyState(VK_LBUTTON) & 0x0001)
                fStopping = TRUE;      // User aborts
#endif

        if (lpcs->sCapParms.fAbortRightMouse)
            if (GetAsyncKeyState(VK_RBUTTON) & 0x0001)
                fStopping = TRUE;      // User aborts
        if (lpcs->fCaptureFlags & CAP_fAbortCapture) {
            fStopping = TRUE;          // Somebody above wants us to quit
        }
        if (lpcs->dwTimeElapsedMS > dwTimeToStop)
            fStopping = TRUE;      // all done


        // -------------------------------------------------------
        //    State machine
        // -------------------------------------------------------
        switch (lpcs->MCICaptureState) {

        case CAPMCI_STATE_Initialized:
            // Begin video step capture
            DSTATUS(lpcs, "MCIState: Initialized");
            lpcs->MCICaptureState = CAPMCI_STATE_StartVideo;
            break;

        case CAPMCI_STATE_StartVideo:
            // Begin video step capture
            lpcs->dwTimeElapsedMS = 0;
            lpcs->MCICaptureState = CAPMCI_STATE_CapturingVideo;
            break;

        case CAPMCI_STATE_CapturingVideo:
            // In the state of capturing video
            if ((lpcs->fCaptureFlags & CAP_fStopCapture) || (lpcs->fCaptureFlags & CAP_fAbortCapture))
                fStopping = TRUE;

            if (fStopping) {
                MCIDeviceGetPosition (lpcs, &lpcs->dwMCIActualEndMS);
                MCIDevicePause (lpcs);

                DSTATUS(lpcs, "MCIState: StoppingVideo");

                if (fOK && !(lpcs->fCaptureFlags & CAP_fAbortCapture))
                    lpcs->MCICaptureState = CAPMCI_STATE_VideoFini;
                else
                    lpcs->MCICaptureState = CAPMCI_STATE_AllFini;

                lpcs->fCaptureFlags &= ~CAP_fStopCapture;
                lpcs->fCaptureFlags &= ~CAP_fAbortCapture;
                fStopping = FALSE;
            }
            break;

        case CAPMCI_STATE_VideoFini:
            // Wait for all buffers to be returned from the driver
            // Then move on to audio capture
            lpcs->MCICaptureState = CAPMCI_STATE_StartAudio;
            DSTATUS(lpcs, "MCIState: VideoFini");
            break;

        case CAPMCI_STATE_StartAudio:
            // If no audio, go to AllFini state
            if (!lpcs->sCapParms.fCaptureAudio || !fOK) {
                lpcs->MCICaptureState = CAPMCI_STATE_AllFini;
                break;
            }

            // Move back to the starting position
            MCIDeviceSetPosition (lpcs, lpcs->dwMCIActualStartMS);
            MCIDeviceGetPosition (lpcs, &lpcs->dwMCICurrentMS);
            DSTATUS(lpcs, "MCIState: StartAudio");
            MCIDevicePlay (lpcs);
            waveInStart(lpcs->hWaveIn);
            lpcs->MCICaptureState = CAPMCI_STATE_CapturingAudio;
            lpcs->dwTimeElapsedMS = 0;
            fStopping = FALSE;
            break;

        case CAPMCI_STATE_CapturingAudio:
            // In the state of capturing audio
            if ((lpcs->fCaptureFlags & CAP_fStopCapture) || (lpcs->fCaptureFlags & CAP_fAbortCapture))
                fStopping = TRUE;

            MCIDeviceGetPosition (lpcs, &lpcs->dwMCICurrentMS);
            if (lpcs->dwMCICurrentMS + 100 > lpcs->dwMCIActualEndMS)
                fStopping = TRUE;
            if (fStopping) {
                waveInStop(lpcs->hWaveIn);
                MCIDevicePause (lpcs);
                waveInReset(lpcs->hWaveIn);
                lpcs->MCICaptureState = CAPMCI_STATE_AudioFini;
            }
            break;

        case CAPMCI_STATE_AudioFini:
            // While more audio buffers to process
            if (lpWaveHdr->dwFlags & WHDR_DONE)
                break;
            lpcs->MCICaptureState = CAPMCI_STATE_AllFini;
            break;

        case CAPMCI_STATE_AllFini:
            DSTATUS(lpcs, "MCIState: AllFini");
            if (fOK)
                statusUpdateStatus(lpcs, IDS_CAP_STAT_CAP_FINI, lpcs->dwVideoChunkCount);
            else
                statusUpdateStatus(lpcs, IDS_CAP_RECORDING_ERROR2);
            break;
        }

        // -------------------------------------------------------
        //        If we are in the video capture phase
        // -------------------------------------------------------

        if (lpcs->MCICaptureState == CAPMCI_STATE_CapturingVideo) {
            BOOL   fKeyFrame;
            LPBYTE lpData;
            DWORD  dwBytesUsed;

            // if averaging...
            if (lpcs->lpia) {
                int j;

                iaverageZero (lpcs->lpia);

                // sum together a bunch of frames
                for (j = 0; j < (int)lpcs->sCapParms.wStepCaptureAverageFrames; j++) {

                    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr2x);

    	            // Shrink by 2x??
                    if (lpcs->sCapParms.fStepCaptureAt2x) {
                        CrunchDIB(
                            lpcs->lpia,        // image averaging structure
                            (LPBITMAPINFOHEADER)  lpcs->lpbmih2x,  // BITMAPINFO src
                            (LPVOID) lpcs->VidHdr2x.lpData,      // input bits
                            (LPBITMAPINFOHEADER)  lpcs->lpBitsInfo, // BITMAPINFO dst
                            (LPVOID) lpcs->VidHdr.lpData);       // output bits
                    }
                    iaverageSum (lpcs->lpia, lpcs->lpBits);
                }
                iaverageDivide (lpcs->lpia, lpcs->lpBits);
            }
            // otherwise, not averaging, just get a frame
            else {
                videoFrame( lpcs->hVideoIn, &lpcs->VidHdr);
            }

            fKeyFrame = lpVidHdr->dwFlags & VHDR_KEYFRAME;

            #ifdef NEW_COMPMAN
            //
            // If we are automatically compressing during capture
            // compress the frame before we write it
            //
            if (lpcs->CompVars.hic)
            {
                LPRIFF priff;

                dwBytesUsed = 0;
                lpData = ICSeqCompressFrame(&lpcs->CompVars, 0,
                                            lpVidHdr->lpData,
                                            &fKeyFrame,
                                            &dwBytesUsed);

                // so what if compression fails??
		// Note: the next line is a HACK and relies on the knowledge of how
		// the compression buffer has been allocated.

                priff = ((LPRIFF)lpData) -1;
                priff->dwType = MAKEAVICKID(cktypeDIBbits, 0);
                priff->dwSize = dwBytesUsed;
            } else
            #endif // NEW_COMPMAN
            {
                 lpData = lpVidHdr->lpData;
                 dwBytesUsed = lpVidHdr->dwBytesUsed;
            }

            if (lpcs->CallbackOnVideoFrame)
                lpcs->CallbackOnVideoFrame(lpcs->hwnd, &lpcs->VidHdr);

            // Update the display
	    InvalidateRect(lpcs->hwnd, NULL, TRUE);
	    UpdateWindow(lpcs->hwnd);
	
            if (lpcs->fCaptureFlags & CAP_fCapturingToDisk) {
                UINT wError;
                BOOL bPending;
                if (!AVIWriteVideoFrame (lpcs,
                        lpData,
                        dwBytesUsed,
                        fKeyFrame,
                        (UINT)-1, 0, &wError, &bPending)) {
                    fStopping = TRUE;
                    if (wError)
                    {
                        fOK = FALSE;
                        errorUpdateError(lpcs, wError);
                    }
                assert (!bPending);
                }
            } // endif fCapturingToDisk
            // Warning: Kludge to create frame chunk count when net capture
            // follows.
            else
                lpcs->dwVideoChunkCount++;

            // if there is still more time, (or at least every 100 frames)
            // show status if we're not ending the capture
            if ((!fStopping) && (lpcs->fCaptureFlags & CAP_fCapturingToDisk) &&
                    (lpcs->dwVideoChunkCount)) {

                // "Captured %ld frames (Dropped %ld) %d.%03d sec. Hit Escape to Stop"
                statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOCURRENT,
                        lpcs->dwVideoChunkCount, lpcs->dwFramesDropped,
                        (int)(lpcs->dwTimeElapsedMS/1000),
                        (int)(lpcs->dwTimeElapsedMS%1000)
                        );
            } // endif next buffer not ready

            // Move the MCI source to the next capture point
            // unfreeze video
            MCIDeviceFreeze(lpcs, FALSE);
            {
            DWORD dwPrevMS = lpcs->dwMCICurrentMS;
            UINT  nNonAdvanceCount = 0;
            DWORD dwTargetMS = lpcs->dwMCIActualStartMS
                               + MulDiv (lpcs->dwVideoChunkCount,
                                         lpcs->sCapParms.dwRequestMicroSecPerFrame,
                                         1000L);
            for (;;)
                {
                MCIDeviceGetPosition (lpcs, &lpcs->dwMCICurrentMS);
                if (lpcs->dwMCICurrentMS > dwTargetMS)
                    break;

                if (lpcs->dwMCICurrentMS <= dwPrevMS)
                    {
                    if (++nNonAdvanceCount > 5)
                        {
                        fStopping = TRUE;
                        break;
                        }
                    }
                else
                    nNonAdvanceCount = 0;

                MCIDeviceStep (lpcs, TRUE);
                }
            }
            // freeze video
            MCIDeviceFreeze(lpcs, TRUE);
            lpcs->dwTimeElapsedMS =
                    lpcs->dwMCICurrentMS - lpcs->dwMCIActualStartMS;

             /* return the emptied buffer to the que */
            lpVidHdr->dwFlags &= ~VHDR_DONE;
        }

        if (lpcs->CallbackOnYield) {
            // If the yield callback returns FALSE, abort
            if ( ! lpcs->CallbackOnYield(lpcs->hwnd))
                fStopping = TRUE;
        }

        if (lpcs->sCapParms.fYield) {
            MSG msg;

            if (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
                // Kludge to get rid of timers from lpcs->hwnd
                if (msg.message == WM_TIMER && msg.hwnd == lpcs->hwnd)
                    ;
                else {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }

        // -------------------------------------------------------
        //        Is audio buffer ready to be written?
        // -------------------------------------------------------
        if (lpcs->sCapParms.fCaptureAudio &&
                (lpcs->MCICaptureState == CAPMCI_STATE_CapturingAudio ||
                lpcs->MCICaptureState == CAPMCI_STATE_StartAudio ||
                lpcs->MCICaptureState == CAPMCI_STATE_AudioFini)) {
            int iLastWave;

            //
            // we may need to yield for audio to get converted.
            //
            if (lpcs->fAudioYield)
                Yield();

            //
            // if all buffers are done, we have broke audio.
            //
            iLastWave = lpcs->iNextWave == 0 ?
                        lpcs->iNumAudio -1 : lpcs->iNextWave-1;

            if (!fStopping &&
                    lpcs->alpWaveHdr[iLastWave]->dwFlags & WHDR_DONE)
                lpcs->fAudioBreak = TRUE;

            iNumAudio = lpcs->iNumAudio; // don't get stuck here forever...
	    // We should probably assert that iNumAudio is >= 0...

            while (iNumAudio && fOK && (lpWaveHdr->dwFlags & WHDR_DONE)) {
                iNumAudio--;
                if (lpWaveHdr->dwBytesRecorded) {
                    /* Chunk info is included in the wave data */
                    /* Reset Chunk Size in buffer */
                    ((LPRIFF)(lpWaveHdr->lpData))[-1].dwSize =
                                lpWaveHdr->dwBytesRecorded;
                    if (lpcs->CallbackOnWaveStream) {
                        lpcs->CallbackOnWaveStream(lpcs->hwnd, lpWaveHdr);
                    }
                    if (lpcs->fCaptureFlags & CAP_fCapturingToDisk) {
                        BOOL bPending = FALSE;
                        UINT wError;

                        if(!AVIWriteAudio(lpcs, lpWaveHdr, lpcs->iNextWave, &wError, &bPending)) {
                            fStopping = TRUE;
                            if (wError) {
                                fOK = FALSE;
                                errorUpdateError (lpcs, wError);
                            }
                         }
                    } // endif capturing to disk
                    // Warning: Kludge to create wave chunk count when net capture
                    // follows.
                    else {
                        lpcs->dwWaveChunkCount++;
                        lpcs->dwWaveBytes += lpWaveHdr->dwBytesRecorded;
                    }
                } // endif dwBytesRecorded

                lpWaveHdr->dwBytesRecorded = 0;
                lpWaveHdr->dwFlags &= ~WHDR_DONE;

                 /* return the emptied buffer to the device que */
                if(waveInAddBuffer(lpcs->hWaveIn, lpWaveHdr, sizeof(WAVEHDR))) {
                    fOK = FALSE;
                    fStopping = TRUE;
                    errorUpdateError(lpcs, IDS_CAP_WAVE_ADD_ERROR);
                }

                /* increment the next wave buffer pointer */
                if(++lpcs->iNextWave >= lpcs->iNumAudio)
                    lpcs->iNextWave = 0;

                lpWaveHdr = lpcs->alpWaveHdr[lpcs->iNextWave];

            } // endwhile buffer available
        } // endif sound enabled
    } // end of forever

CompressFrameFailure:

    iaverageFini (lpcs->lpia);

    // Switch back to the normal format
    if (lpcs->sCapParms.fStepCaptureAt2x) {
        SendDriverFormat (lpcs, (LPBITMAPINFOHEADER) lpcs->lpBitsInfo,
                sizeof (BITMAPINFOHEADER));
        GlobalFreePtr (lpcs->VidHdr2x.lpData);
        lpcs->VidHdr2x.lpData = NULL;
    }

    // And free the 2x memory
    if (lpcs->lpbmih2x) {
        GlobalFreePtr (lpcs->lpbmih2x);
        lpcs->lpbmih2x = NULL;
    }

    // -------------------------------------------------------
    //   END OF MAIN CAPTURE LOOP
    // -------------------------------------------------------

    lpcs->dwTimeElapsedMS = lpcs->dwMCIActualEndMS - lpcs->dwMCIActualStartMS;

    /* eat any keys that have been pressed */
    while(GetKey(FALSE))
        ;

    AVIFini(lpcs);  // does the Reset, and frees all buffers
    AVIFileFini(lpcs, TRUE /* fWroteJunkChunks */, FALSE /* fAbort */);


    /* Notify if there was an error while recording */

    if(!fOK) {
	dprintf("Replacing error %x with %x (IDS_CAP_RECORDING_ERROR)\n", lpcs->dwReturn, IDS_CAP_RECORDING_ERROR);
        errorUpdateError (lpcs, IDS_CAP_RECORDING_ERROR);
    }

    if (lpcs->fCaptureFlags & CAP_fCapturingToDisk) {
        if (lpcs->dwVideoChunkCount)
            dw = MulDiv(lpcs->dwVideoChunkCount,1000000,lpcs->dwTimeElapsedMS);
        else
            dw = 0;     // The MulDiv doesn't give 0 if numerator is zero

        if(lpcs->sCapParms.fCaptureAudio) {
            // "Captured %d.%03d sec.  %ld frames (%d dropped) (%d.%03d fps).  %ld audio bytes (%d.%03d sps)"
            statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOAUDIO,
                  (UINT)(lpcs->dwTimeElapsedMS/1000),
                  (UINT)(lpcs->dwTimeElapsedMS%1000),
                  lpcs->dwVideoChunkCount,
                  lpcs->dwFramesDropped,
                  (UINT)(dw / 1000),
                  (UINT)(dw % 1000),
                  lpcs->dwWaveBytes,
                  (UINT) lpcs->lpWaveFormat->nSamplesPerSec / 1000,
                  (UINT) lpcs->lpWaveFormat->nSamplesPerSec % 1000);
        } else {
            // "Captured %d.%03d sec.  %ld frames (%d dropped) (%d.%03d fps)."
            statusUpdateStatus(lpcs, IDS_CAP_STAT_VIDEOONLY,
                  (UINT)(lpcs->dwTimeElapsedMS/1000),
                  (UINT)(lpcs->dwTimeElapsedMS%1000),
                  lpcs->dwVideoChunkCount,
                  lpcs->dwFramesDropped,
                  (UINT)(dw / 1000),
                  (UINT)(dw % 1000));
        }
    } // endif capturing to disk (no warnings or errors if to net)

    if (fOK) {
        // No frames captured, warn user that interrupts are probably not enabled.
        if (lpcs->dwVideoChunkCount == 0) {
            errorUpdateError (lpcs, IDS_CAP_NO_FRAME_CAP_ERROR);
        }
        // No audio captured, (but enabled), warn user audio card is hosed
        else if (lpcs->sCapParms.fCaptureAudio && (lpcs->dwWaveBytes == 0)) {
            errorUpdateError (lpcs, IDS_CAP_NO_AUDIO_CAP_ERROR);
        }

        // Audio underrun, inform user
        else if (lpcs->sCapParms.fCaptureAudio && lpcs->fAudioBreak) {
            if(lpcs->CompVars.hic) {
    	    errorUpdateError (lpcs, IDS_CAP_AUDIO_DROP_COMPERROR);
            } else {
    	    errorUpdateError (lpcs, IDS_CAP_AUDIO_DROP_ERROR);
            }
        }

        // If frames dropped, or changed capture rate, warn the user
        else if (lpcs->dwVideoChunkCount && (lpcs->fCaptureFlags & CAP_fCapturingToDisk)) {

            // Warn user if dropped > 10% (default) of the frames
            if ((DWORD)100 * lpcs->dwFramesDropped / lpcs->dwVideoChunkCount >
                        lpcs->sCapParms.wPercentDropForError) {

                // "%d of %ld frames (%d.%03d\%) dropped during capture."
                errorUpdateError (lpcs, IDS_CAP_STAT_FRAMESDROPPED,
                      lpcs->dwFramesDropped,
                      lpcs->dwVideoChunkCount,
                      (UINT)(MulDiv(lpcs->dwFramesDropped,10000,lpcs->dwVideoChunkCount)/100),
                      (UINT)(MulDiv(lpcs->dwFramesDropped,10000,lpcs->dwVideoChunkCount)%100)/10
                      );
            }
        }
    }

EarlyExit:

    //
    // If we were compressing while capturing, close it down
    //
#ifdef NEW_COMPMAN
    if (lpcs->CompVars.hic) {
        // Kludge, reset the lpBitsOut pointer
        if (lpcs->CompVars.lpBitsOut)
            ((LPBYTE) lpcs->CompVars.lpBitsOut) -= 8;
	ICSeqCompressFrameEnd(&lpcs->CompVars);
    }
#endif

    if (fTryToPaint) {
        if (hpalT)
             SelectPalette(hdc, hpalT, FALSE);
        ReleaseDC (lpcs->hwnd, hdc);
    }

    if (lpcs->sCapParms.fMCIControl)
        MCIDeviceClose (lpcs);

    // Let the user see where capture stopped
    if ((!lpcs->fLiveWindow) && (!lpcs->fOverlayWindow))
        videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );
    InvalidateRect( lpcs->hwnd, NULL, TRUE);

    lpcs->fCapFileExists = (lpcs->dwReturn == DV_ERR_OK);
    lpcs->fCaptureFlags &= ~CAP_fCapturingNow;
    lpcs->fCaptureFlags &= ~CAP_fStepCapturingNow;

    statusUpdateStatus(lpcs, IDS_CAP_END);  // Always the last message

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\capmisc.c ===
/****************************************************************************
 *
 *   capmisc.c
 *
 *   Miscellaneous status and error routines.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include <vfw.h>

#include "ivideo32.h"
#include "avicapi.h"

#include <stdarg.h>

// First, override the definition in media\inc\win32.h that causes strsafe to not work on Win64
#ifndef _X86_
#undef __inline
#endif // _X86_
// Then, include strsafe.h
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

static TCHAR szNull[] = TEXT("");

/*
 *
 *   GetKey
 *           Peek into the message que and get a keystroke
 *
 */
UINT GetKey(BOOL fWait)
{
    MSG msg;

    msg.wParam = 0;

    if (fWait)
         GetMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST);

    while(PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE|PM_NOYIELD))
         ;
    return (UINT) msg.wParam;
}

// wID is the string resource, which can be a format string
//
void FAR CDECL statusUpdateStatus (LPCAPSTREAM lpcs, UINT wID, ...)
{
    TCHAR ach[256];
    TCHAR szFmt[132];
    va_list va;

    if (!lpcs->CallbackOnStatus)
        return;

    if (wID == 0) {
        if (lpcs->fLastStatusWasNULL)   // No need to send NULL twice in a row
            return;
        lpcs->fLastStatusWasNULL = TRUE;
        ach[0] = 0;
    }
    else {
        lpcs->fLastStatusWasNULL = FALSE;
        if (!LoadString(lpcs->hInst, wID, szFmt, NUMELMS(szFmt))) {
            MessageBeep (0);
            return;
        }
        else {
            va_start(va, wID);
            // Fix: Change from wvsprintf to StringCchVPrintf so we don't overrun ach
            StringCchVPrintf(ach, NUMELMS(ach), szFmt, va);
            va_end(va);
        }
    }

   #ifdef UNICODE
    //
    // if the status callback function is expecting ansi
    // strings, then convert the UNICODE status string to
    // ansi before calling him
    //
    if (lpcs->fUnicode & VUNICODE_STATUSISANSI) {

        char achAnsi[256];

        // convert string to Ansi and callback.
        // that we cast achAnsi to WChar on the call to
        // avoid a bogus warning.
        //
        WideToAnsi(achAnsi, ach, lstrlen(ach)+1);
        lpcs->CallbackOnStatus(lpcs->hwnd, wID, (LPWSTR)achAnsi);
    }
    else
   #endif
       lpcs->CallbackOnStatus(lpcs->hwnd, wID, ach);
}

// wID is the string resource, which can be a format string
//
void FAR CDECL errorUpdateError (LPCAPSTREAM lpcs, UINT wID, ...)
{
    TCHAR ach[256];
    TCHAR szFmt[132];
    va_list va;

    lpcs->dwReturn = wID;

    if (!lpcs->CallbackOnError)
        return;

    if (wID == 0) {
        if (lpcs->fLastErrorWasNULL)   // No need to send NULL twice in a row
            return;
        lpcs->fLastErrorWasNULL = TRUE;
        ach[0] = 0;
    }
    else if (!LoadString(lpcs->hInst, wID, szFmt, NUMELMS(szFmt))) {
        MessageBeep (0);
        lpcs->fLastErrorWasNULL = FALSE;
        return;
    }
    else {
        lpcs->fLastErrorWasNULL = FALSE;
        va_start(va, wID);
        // Fix: Change from wvsprintf to StringCchVPrintf so we don't overrun ach
        StringCchVPrintf(ach, NUMELMS(ach), szFmt, va);
        va_end(va);
    }

   #ifdef UNICODE
    if (lpcs->fUnicode & VUNICODE_ERRORISANSI)
    {
        char achAnsi[256];

        // convert string to Ansi and callback.
        // that we cast achAnsi to WChar on the call to
        // avoid a bogus warning.
        //
        WideToAnsi(achAnsi, ach, lstrlen(ach)+1);
        lpcs->CallbackOnError(lpcs->hwnd, wID, (LPWSTR)achAnsi);
    }
    else
   #endif
    {
        lpcs->CallbackOnError(lpcs->hwnd, wID, ach);
    }
}

// Callback client with ID of driver error msg
void errorDriverID (LPCAPSTREAM lpcs, DWORD dwError)
{
    // this is the correct code, but NT VfW 1.0 has a bug
    // that videoGetErrorText is ansi. need vfw1.1 to fix this

#ifndef UNICODE
    char ach[132];
#endif

    lpcs->fLastErrorWasNULL = FALSE;
    lpcs->dwReturn = dwError;

    if (!lpcs->CallbackOnError)
        return;


   #ifdef UNICODE
    if (lpcs->fUnicode & VUNICODE_ERRORISANSI) {
        char achAnsi[256];
	achAnsi[0]=0;
        if (dwError)
            videoGetErrorTextA(lpcs->hVideoIn, dwError, achAnsi, NUMELMS(achAnsi));
        lpcs->CallbackOnError (lpcs->hwnd, IDS_CAP_DRIVER_ERROR, (LPWSTR)achAnsi);
    } else {
	// pass unicode string to error handler
        WCHAR achWide[256];
	achWide[0]=0;
        if (dwError)
            videoGetErrorTextW(lpcs->hVideoIn, dwError, achWide, NUMELMS(achWide));
        lpcs->CallbackOnError (lpcs->hwnd, IDS_CAP_DRIVER_ERROR, (LPWSTR)achWide);
    }
   #else  // not unicode
    ach[0] = 0;
    if (dwError)
        videoGetErrorText (lpcs->hVideoIn, dwError, ach, NUMELMS(ach));
        lpcs->CallbackOnError(lpcs->hwnd, IDS_CAP_DRIVER_ERROR, ach);
   #endif
}

#ifdef  _DEBUG

void FAR cdecl dprintf(LPSTR szFormat, ...)
{
    UINT n;
    char ach[256];
    va_list va;

    static BOOL fDebug = -1;

    if (fDebug == -1)
        fDebug = GetProfileIntA("Debug", "AVICAP32", FALSE);

    if (!fDebug)
        return;

#ifdef _WIN32
    n = wsprintfA(ach, "AVICAP32: (tid %x) ", GetCurrentThreadId());
#else
    strcpy(ach, "AVICAP32: ");
    n = strlen(ach);
#endif

    va_start(va, szFormat);
    wvsprintfA(ach+n, szFormat, va);
    va_end(va);

    lstrcatA(ach, "\r\n");

    OutputDebugStringA(ach);
}

/* _Assert(fExpr, szFile, iLine)
 *
 * If <fExpr> is TRUE, then do nothing.  If <fExpr> is FALSE, then display
 * an "assertion failed" message box allowing the user to abort the program,
 * enter the debugger (the "Retry" button), or igore the error.
 *
 * <szFile> is the name of the source file; <iLine> is the line number
 * containing the _Assert() call.
 */

BOOL FAR PASCAL
_Assert(BOOL fExpr, LPSTR szFile, int iLine)
{
    static char       ach[300];         // debug output (avoid stack overflow)
    int               id;
    int               iExitCode;
    void FAR PASCAL DebugBreak(void);

    /* check if assertion failed */
    if (fExpr)
             return fExpr;

    /* display error message */
    wsprintfA(ach, "File %s, line %d", (LPSTR) szFile, iLine);
    MessageBeep(MB_ICONHAND);
    id = MessageBoxA (NULL, ach, "Assertion Failed",
                      MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE);

    /* abort, debug, or ignore */
    switch (id)
    {
    case IDABORT: /* kill this application */
        iExitCode = 0;
        ExitProcess(0);
        break;

    case IDRETRY: /* break into the debugger */
        DebugBreak();
        break;

    case IDIGNORE:
        /* ignore the assertion failure */
        break;
    }

    return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\capfile.c ===
/****************************************************************************
 *
 *   capfile.c
 *
 *   AVI file writing module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include <vfw.h>

#include "ivideo32.h"
#include "avicapi.h"


/*----------------------------------------------------------------------+
| fileCapFileIsAVI() - Returns TRUE if the capture file is a valid AVI  |
|                                                                       |
+----------------------------------------------------------------------*/
BOOL FAR PASCAL fileCapFileIsAVI (LPTSTR lpsz)
{
    BOOL        fReturn = TRUE;
    HMMIO       hmmioSource = NULL;
    MMCKINFO    ckRIFF;

    // Does the file exist?
    hmmioSource = mmioOpen(lpsz, NULL, MMIO_READ);
    if (!hmmioSource)
        return FALSE;

    // Is there an AVI RIFF chunk?
    // !!! Don't do a FINDRIFF for an AVI chunk or it'll take several minutes to
    // !!! come back from checking a really big file
    fReturn = (mmioDescend(hmmioSource, &ckRIFF, NULL, 0) == 0) &&
		(ckRIFF.ckid == FOURCC_RIFF) &&
		(ckRIFF.fccType == formtypeAVI);

    if (hmmioSource)
        mmioClose(hmmioSource, 0);

    return fReturn;
}

/*----------------------------------------------------------------------+
| fileSaveCopy() - save a copy of the current capture file.             |
|                                                                       |
+----------------------------------------------------------------------*/
BOOL FAR PASCAL fileSaveCopy(LPCAPSTREAM lpcs)
{
#define INITFILE_BUFF_SIZE  (1024L * 256L)
    BOOL        fReturn = TRUE;
    char        achCaption[80]; // caption on Open File dialog

    HMMIO       hmmioSource = NULL, hmmioDest = NULL;
    LONG        lFileSize, lFileSizeTotal, lTemp;
    HANDLE      hMem = NULL;
    LPBYTE      lpstr = NULL;
    LONG        lBuffSize = INITFILE_BUFF_SIZE;
    MMCKINFO    ckRIFF;
    HCURSOR     hOldCursor;

    UpdateWindow(lpcs->hwnd);             // Make everything pretty

    hOldCursor = SetCursor( lpcs->hWaitCursor );
    if (0 == lstrcmpi(lpcs->achSaveAsFile, lpcs->achFile)) {
        // IF the source and destination names are the same, then there
        // is nothing to do
        return(TRUE);
    }


    /* grab a big buffer to xfer the file in, start the */
    /* buffer size at 32K and hope we get that much.    */
TRYAGAIN:
    hMem = GlobalAlloc(GMEM_MOVEABLE, lBuffSize);
    if (!hMem){
        /* we don't have this much mem, go for half that */
        lBuffSize /= 2;
        if (lBuffSize)
            goto TRYAGAIN;
        else {
            fReturn = FALSE;
            goto SAVECOPYOUT;
        }
    }

    /* open up the source file and find the size                       */
    /* Open the source first in case source==destination. Despite the  */
    /* test above this may still be the case (consider two net use     */
    /* commands to the same share point with different drive letters). */
    /* When we open the destination we truncate the file, which will   */
    /* lose any existing data.                                         */
    hmmioSource = mmioOpen(lpcs->achFile, NULL, MMIO_READ | MMIO_DENYWRITE);
    if (!hmmioSource){
        /* we are totally hosed here, the source file can't even */
        /* be opened up, error out.              */
        errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPTSTR)lpcs->achFile);
        fReturn = FALSE;
        goto SAVECOPYOUT;
    }

    /* let's go and create the destination file */

    hmmioDest = mmioOpen(lpcs->achSaveAsFile, NULL, MMIO_CREATE|MMIO_WRITE);
    if (!hmmioDest){
        /* we've got an error of some kind here, let's bail out */
        /* on this one.                     */
        errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPTSTR)lpcs->achSaveAsFile);
        fReturn = FALSE;
        goto SAVECOPYOUT;
    }


    /* go down to the RIFF chunk and find out the size of this  */
    /* thing.  If there is no RIFF chunk then we can safely */
    /* assume that the file is of 0 length.         */
    ckRIFF.fccType = formtypeAVI;
    if (mmioDescend(hmmioSource, &ckRIFF, NULL, MMIO_FINDRIFF) != 0){
        /* we are done, this file has no RIFF chunk so it's size */
        /* is 0 bytes.  Just close up and leave.         */
        goto SAVECOPYOUT;
    } else {
        /* there is a RIFF chunk, get the size of the file and  */
        /* get back to the start of the file.           */
        lFileSizeTotal = lFileSize = ckRIFF.cksize + 8;
        mmioAscend(hmmioSource, &ckRIFF, 0);
        mmioSeek(hmmioSource, 0L, SEEK_SET);
    }

    /* Before trying to write, seek to the end of the destination  */
    /* file and write one byte.  This both preallocates the file,  */
    /* and confirms enough disk is available for the copy, without */
    /* going through the trial and error of writing each byte.     */

    mmioSeek( hmmioDest, lFileSizeTotal - 1, SEEK_SET );
    mmioWrite( hmmioDest, (HPSTR) achCaption, 1L );
    if (mmioSeek (hmmioDest, 0, SEEK_END) < lFileSizeTotal) {

        /* Notify user with message that disk may be full. */
        errorUpdateError (lpcs, IDS_CAP_WRITEERROR, (LPTSTR)lpcs->achSaveAsFile);

        /* close the file and delete it */
        mmioClose(hmmioDest, 0);
        mmioOpen(lpcs->achSaveAsFile, NULL, MMIO_DELETE);
        hmmioDest = NULL;
        fReturn = FALSE;
        goto SAVECOPYOUT;
    }

    mmioSeek (hmmioDest, 0L, SEEK_SET); // Back to the beginning

    UpdateWindow(lpcs->hwnd);             // Make everything pretty

    hOldCursor = SetCursor( lpcs->hWaitCursor );


    /* lock our buffer and start xfering data */
    lpstr = GlobalLock(hMem);
    if (!lpstr) {
        fReturn = FALSE;
        goto SAVECOPYOUT;
    }

    while (lFileSize > 0) {

        if (lFileSize < lBuffSize)
            lBuffSize = lFileSize;
        mmioRead(hmmioSource, (HPSTR)lpstr, lBuffSize);
        if (mmioWrite(hmmioDest, (HPSTR)lpstr, lBuffSize) <= 0) {
            /* we got a write error on the file, error on it */
            errorUpdateError (lpcs, IDS_CAP_WRITEERROR, (LPTSTR)lpcs->achSaveAsFile);

            /* close the file and delete it */
            mmioClose(hmmioDest, 0);
            mmioOpen(lpcs->achSaveAsFile, NULL, MMIO_DELETE);
            hmmioDest = NULL;
            fReturn = FALSE;
            goto SAVECOPYOUT0;
        }

        // Let the user hit escape to get out
        if (GetAsyncKeyState(VK_ESCAPE) & 0x0001) {
            /* close the file and delete it */
            mmioClose(hmmioDest, 0);
            mmioOpen(lpcs->achSaveAsFile, NULL, MMIO_DELETE);
            hmmioDest = NULL;
            goto SAVECOPYOUT0;
        }

        lFileSize -= lBuffSize;

        // lTemp is percentage complete
        lTemp = MulDiv (lFileSizeTotal - lFileSize, 100L, lFileSizeTotal);
        statusUpdateStatus (lpcs, IDS_CAP_SAVEASPERCENT, lTemp);

        Yield();
    } // endwhile more bytes to copy

SAVECOPYOUT:
SAVECOPYOUT0:
    SetCursor( hOldCursor );

    /* close files, free up mem, restore cursor and get out */
    if (hmmioSource) mmioClose(hmmioSource, 0);
    if (hmmioDest){
        mmioSeek(hmmioDest, 0L, SEEK_END);
        mmioClose(hmmioDest, 0);
    }
    if (hMem) {
        if (lpstr) {
            GlobalUnlock(hMem);
        }
        GlobalFree(hMem);
    }
    statusUpdateStatus (lpcs, 0);
    return fReturn;
}


/*--------------------------------------------------------------+
| fileAllocCapFile - allocate the capture file			|
|								|
+--------------------------------------------------------------*/
BOOL FAR PASCAL fileAllocCapFile(LPCAPSTREAM lpcs, DWORD dwNewSize)
{
    BOOL        fOK = FALSE;
    HMMIO       hmmio;
    UINT	w;
    HCURSOR     hOldCursor;

    lpcs->fCapFileExists = FALSE;
    hmmio = mmioOpen(lpcs->achFile, NULL, MMIO_WRITE);
    if( !hmmio ) {
	/* try and create */
        hmmio = mmioOpen(lpcs-> achFile, NULL,
		MMIO_CREATE | MMIO_WRITE);
	if( !hmmio ) {
	    /* find out if the file was read only or we are just */
	    /* totally hosed up here.				 */
	    hmmio = mmioOpen(lpcs-> achFile, NULL, MMIO_READ);
	    if (hmmio){
		/* file was read only, error on it */
                errorUpdateError (lpcs, IDS_CAP_READONLYFILE, (LPTSTR)lpcs-> achFile);
		mmioClose(hmmio, 0);
		return FALSE;
	    } else {
		/* even weirder error has occured here, give CANTOPEN */
                errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPTSTR) lpcs-> achFile);
		return FALSE;
	    }
	}
    }

    /* find the size */
    lpcs-> lCapFileSize = mmioSeek(hmmio, 0L, SEEK_END);

    if( dwNewSize == 0 )
        dwNewSize = 1;
	    	
    lpcs-> lCapFileSize = dwNewSize;
    hOldCursor = SetCursor( lpcs-> hWaitCursor );

    // Delete the existing file so we can recreate to the correct size
    mmioClose(hmmio, 0);	// close the file before deleting
    mmioOpen(lpcs-> achFile, NULL, MMIO_DELETE);

    /* now create a new file with that name */
    hmmio = mmioOpen(lpcs-> achFile, NULL, MMIO_CREATE | MMIO_WRITE);
    if( !hmmio ) {
        return FALSE;
    }

    /*
     * rather than just leaving the allocated space as garbage, we
     * create it as a junk filler chunk
     */
    {
        MMCKINFO ck;

        ck.ckid = mmioFOURCC('J', 'U', 'N', 'K');
        ck.cksize = dwNewSize - 8L;
        fOK = (mmioCreateChunk(hmmio, &ck, 0) == 0);
        fOK &= (mmioSeek(hmmio, dwNewSize - 9, SEEK_CUR) == (LONG)dwNewSize-1);
        fOK &= (mmioWrite( hmmio, (HPSTR) &w, 1L ) == 1);
        mmioAscend(hmmio, &ck, 0);
    }


    mmioClose( hmmio, 0 );

    SetCursor( hOldCursor );

    if (!fOK)
        errorUpdateError (lpcs, IDS_CAP_NODISKSPACE);

    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\cappal.c ===
/****************************************************************************
 *
 *   cappal.c
 *
 *   Palette processing module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include <vfw.h>

#include "ivideo32.h"
#include "avicapi.h"
#include "cappal.h"
#include "capdib.h"
#include "dibmap.h"

//
// Allocate and initialize palette resources at Window create time
//
BOOL PalInit (LPCAPSTREAM lpcs)
{
    return (PalGetPaletteFromDriver (lpcs));
}

//
// FreePaletteCache - free the RGB555 Xlate table
//
void FreePaletteCache (LPCAPSTREAM lpcs)
{
    if (lpcs->lpCacheXlateTable) {
        GlobalFreePtr (lpcs->lpCacheXlateTable);
	lpcs->lpCacheXlateTable = NULL;
    }
}

//
// Release palette resources at Window destroy time
//
void PalFini (LPCAPSTREAM lpcs)
{
    PalDeleteCurrentPalette (lpcs);

    FreePaletteCache (lpcs);
}

//
// Delete our palette if it isn't the system default palette
//
void PalDeleteCurrentPalette (LPCAPSTREAM lpcs)
{
    if (lpcs->hPalCurrent &&
            (lpcs->hPalCurrent != GetStockObject(DEFAULT_PALETTE)))
        DeleteObject (lpcs->hPalCurrent);
    lpcs->hPalCurrent = NULL;
}

//
// Get the current palette (from the driver)
// Returns: TRUE if the driver can supply a palette
//

BOOL PalGetPaletteFromDriver (LPCAPSTREAM lpcs)
{
    FCLOGPALETTE        pal;

    PalDeleteCurrentPalette (lpcs);

    pal.palVersion = 0x0300;
    pal.palNumEntries = 256;

    lpcs->sCapDrvCaps.fDriverSuppliesPalettes = FALSE;  // assume the worst

    if (lpcs->fHardwareConnected) {
        if (videoConfigure (lpcs->hVideoIn,
                DVM_PALETTE,
                VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT, NULL,
                (LPVOID)&pal, sizeof(pal),
                NULL, 0 ) == DV_ERR_OK) {
            if (lpcs->hPalCurrent = CreatePalette ((LPLOGPALETTE) &pal))
                lpcs->sCapDrvCaps.fDriverSuppliesPalettes = TRUE;
        }
    }
    if (!lpcs->hPalCurrent)
        lpcs->hPalCurrent = GetStockObject (DEFAULT_PALETTE);

    DibNewPalette (lpcs, lpcs->hPalCurrent);

    return (lpcs->sCapDrvCaps.fDriverSuppliesPalettes);
}

//
// Set the current palette used for capture by sending a copy to the driver
// and then copying the entries to out DIB.
// This may also be called when reconnecting a driver and using a cached
// copy of the palette.
// Returns TRUE on success, or FALSE on failure.
//
DWORD PalSendPaletteToDriver (LPCAPSTREAM lpcs, HPALETTE hpal, LPBYTE lpXlateTable)
{
    short               nColors;
    FCLOGPALETTE        pal;
    HCURSOR             hOldCursor;

    // The following can take a while so repaint our parent
    UpdateWindow (GetParent (lpcs-> hwnd));
    UpdateWindow (lpcs->hwnd);

    if (!hpal)
        return FALSE;

    // Allocate a xlate table cache?
    if (lpXlateTable) {
        if (lpcs->lpCacheXlateTable == NULL) {
            lpcs->lpCacheXlateTable = GlobalAllocPtr (GHND, 0x8000l);
            if (!lpcs->lpCacheXlateTable)
                return FALSE;
        }

        // If we're not using the cached table, update the cache
        if (lpcs->lpCacheXlateTable != lpXlateTable)
            _fmemcpy (lpcs->lpCacheXlateTable, lpXlateTable, (UINT) 0x8000l);
    }
    else {
        FreePaletteCache (lpcs);
    }

    // Don't destroy the current palette when reconnecting...
    if (hpal != lpcs->hPalCurrent) {
        PalDeleteCurrentPalette (lpcs);
        lpcs->hPalCurrent = hpal;
    }

    GetObject(hpal, sizeof(short), (LPVOID)&nColors);

    if( nColors <= 1 ) {    //!!>
        return( FALSE );
    }

    nColors = min(256, nColors);

    hOldCursor = SetCursor (lpcs-> hWaitCursor);

    statusUpdateStatus (lpcs, IDS_CAP_STAT_PALETTE_BUILD);

    pal.palVersion = 0x0300;
    pal.palNumEntries = nColors;

    GetPaletteEntries(hpal, 0, nColors, pal.palPalEntry);

    if (lpcs-> fHardwareConnected) {

        // first try to send both the xlate table and the palette
        if ((!lpXlateTable) || (videoConfigure( lpcs->hVideoIn,
                    DVM_PALETTERGB555,
                    VIDEO_CONFIGURE_SET, NULL,
                    (LPLOGPALETTE)&pal, sizeof(pal),
                    lpXlateTable, (DWORD) 0x8000) != 0)) {

            // else send just the palette and make the driver build the table
            if (videoConfigure( lpcs->hVideoIn,
                    DVM_PALETTE,
                    VIDEO_CONFIGURE_SET, NULL,
                    (LPLOGPALETTE)&pal, sizeof(pal),
                    NULL, 0 )) {
                // Scrncap doesn't support setting a palette, so
                // delete the palette cache
                FreePaletteCache (lpcs);
            }
        }
    }

    // Supermac wants us to get the palette again, they might have
    // mucked with it!
    PalGetPaletteFromDriver (lpcs);

    // Since the palette has changed, delete any existing compression
    // output format;  this forces a new output format to be selected
    if (lpcs->CompVars.lpbiOut) {
        GlobalFreePtr (lpcs->CompVars.lpbiOut);
        lpcs->CompVars.lpbiOut = NULL;
    }
    if (lpcs->CompVars.hic) {
        if (ICSeqCompressFrameStart(&lpcs->CompVars, lpcs->lpBitsInfo) == 0) {
            errorUpdateError (lpcs, IDS_CAP_COMPRESSOR_ERROR);
        }
    }

    InvalidateRect (lpcs->hwnd, NULL, TRUE);
    UpdateWindow (lpcs->hwnd);

    SetCursor (hOldCursor);
    statusUpdateStatus (lpcs, 0);

    return (TRUE);
}

//
// CopyPalette, makes a copy of a GDI logical palette
// Returns: a handle to the newly created palette, or NULL if error
//

HPALETTE CopyPalette (HPALETTE hpal)
{
    LPLOGPALETTE        lppal;
    short               nNumEntries;

    if (!hpal)
        return NULL;

    GetObject (hpal,sizeof(short),(LPVOID)&nNumEntries);

    if (nNumEntries == 0)
        return NULL;

    lppal = (LPLOGPALETTE) GlobalAllocPtr (GHND,
                sizeof(LOGPALETTE) + nNumEntries * sizeof(PALETTEENTRY));

    if (!lppal)
        return NULL;

    lppal->palVersion    = 0x300;
    lppal->palNumEntries = nNumEntries;

    GetPaletteEntries(hpal,0,nNumEntries,lppal->palPalEntry);

    hpal = CreatePalette(lppal);

    GlobalFreePtr (lppal);

    return hpal;
}


//
// Allocate resources needed for palette capture
// Returns DV_ERR_OK on success, or DV_ERR... on failure.
// Note: if Init fails, you MUST call the Fini function to
// release resources.
//
DWORD CapturePaletteInit (LPCAPSTREAM lpcs, LPCAPPAL lpcp)
{
    DWORD dwError = DV_ERR_OK;

    lpcp->lpBits = NULL;
    lpcp->lp16to8 = NULL;
    lpcp->lpHistogram = NULL;
    lpcp->lpbiSave = NULL;
    lpcp->wNumFrames = 0;

    // Init an RGB16 header
    lpcp->bi16.biSize         = sizeof(BITMAPINFOHEADER);
    lpcp->bi16.biWidth        = lpcs->dxBits;
    lpcp->bi16.biHeight       = lpcs->dyBits;
    lpcp->bi16.biPlanes       = 1;
    lpcp->bi16.biBitCount     = 16;
    lpcp->bi16.biCompression  = BI_RGB;
    lpcp->bi16.biSizeImage    = DIBWIDTHBYTES(lpcp->bi16) * lpcp->bi16.biHeight;
    lpcp->bi16.biXPelsPerMeter= 0;
    lpcp->bi16.biYPelsPerMeter= 0;
    lpcp->bi16.biClrUsed      = 0;
    lpcp->bi16.biClrImportant = 0;

    // Allocate memory for the histogram, DIB, and XLate table
    lpcp->lpBits  = GlobalAllocPtr (GHND, lpcp->bi16.biSizeImage);
    lpcp->lp16to8 = GlobalAllocPtr (GHND, 0x8000l);
    lpcp->lpHistogram = InitHistogram(NULL);

    if (!lpcp->lpBits || !lpcp->lp16to8 || !lpcp->lpHistogram) {
        dwError = DV_ERR_NOMEM;
        goto PalInitError;
    }

    // Init the video header
    lpcp->vHdr.lpData = lpcp->lpBits;
    lpcp->vHdr.dwBufferLength = lpcp->bi16.biSizeImage;
    lpcp->vHdr.dwUser = 0;
    lpcp->vHdr.dwFlags = 0;

    // Save the current format
    lpcp->lpbiSave = DibGetCurrentFormat (lpcs);

    // Make sure we can set the format to 16 bit RGB
    if(dwError = videoConfigure( lpcs->hVideoIn, DVM_FORMAT,
            VIDEO_CONFIGURE_SET, NULL,
            (LPBITMAPINFOHEADER)&lpcp->bi16, sizeof(BITMAPINFOHEADER),
            NULL, 0 ) ) {
        goto PalInitError;
    }

    // Put everything back the way it was
    if (dwError = videoConfigure( lpcs->hVideoIn, DVM_FORMAT,
            VIDEO_CONFIGURE_SET, NULL,
            (LPBITMAPINFOHEADER)lpcp->lpbiSave, lpcp->lpbiSave->bmiHeader.biSize,
            NULL, 0 )) {
        goto PalInitError;
    }

PalInitError:
    return dwError;
}

//
// Free resources used for palette capture
//
DWORD CapturePaletteFini (LPCAPSTREAM lpcs, LPCAPPAL lpcp)
{
    if (lpcp->lpBits) {
        GlobalFreePtr (lpcp->lpBits);
        lpcp->lpBits = NULL;
    }
    if (lpcp->lp16to8) {
        GlobalFreePtr (lpcp->lp16to8);
        lpcp->lp16to8 = NULL;
    }
    if (lpcp->lpHistogram) {
        FreeHistogram(lpcp->lpHistogram);
        lpcp->lpHistogram = NULL;
    }
    if (lpcp->lpbiSave) {
        GlobalFreePtr (lpcp->lpbiSave);
        lpcp->lpbiSave = NULL;
    }
    return DV_ERR_OK;
}

//
//  CapturePaletteFrames() The workhorse of capture palette.
//
DWORD CapturePaletteFrames (LPCAPSTREAM lpcs, LPCAPPAL lpcp, int nCount)
{
    int j;
    DWORD dwError;

    // switch to RGB16 format
    if (dwError = videoConfigure( lpcs->hVideoIn,
                DVM_FORMAT,
                VIDEO_CONFIGURE_SET, NULL,
                (LPBITMAPINFOHEADER)&lpcp->bi16, sizeof(BITMAPINFOHEADER),
                NULL, 0 ))
        goto CaptureFramesError;

    for (j = 0; j < nCount; j++){
        // Get a frame
        dwError = videoFrame(lpcs->hVideoIn, &lpcp->vHdr);

        // Let the user see it
        InvalidateRect (lpcs->hwnd, NULL, TRUE);
        UpdateWindow (lpcs->hwnd);

        // Histogram it
        DibHistogram(&lpcp->bi16, lpcp->lpBits, 0, 0, -1, -1, lpcp->lpHistogram);
        lpcp->wNumFrames++;
    }

    dwError = videoConfigure( lpcs->hVideoIn,
                DVM_FORMAT,
                VIDEO_CONFIGURE_SET, NULL,
                (LPBITMAPINFOHEADER)lpcp->lpbiSave,
                lpcp->lpbiSave->bmiHeader.biSize,
                NULL, 0 );

//    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );

CaptureFramesError:
    return dwError;
}

//
//  CapturePaletteAuto() capture a palette from the video source
//  without user intervention.
//  Returns TRUE on success, FALSE on error
//
BOOL CapturePaletteAuto (LPCAPSTREAM lpcs, int nCount, int nColors)
{
    HPALETTE    hpal;
    HCURSOR     hOldCursor;
    DWORD       dwError = DV_ERR_OK;
    CAPPAL      cappal;
    LPCAPPAL    lpcp;

    lpcp = &cappal;

    if (!lpcs->sCapDrvCaps.fDriverSuppliesPalettes)
        return FALSE;

    if (nColors <= 0 || nColors > 256)
        return FALSE;

    lpcp->wNumColors = max (nColors, 2);  // at least 2 colors

    if (nCount <= 0)
        return FALSE;

    if (dwError = CapturePaletteInit (lpcs, lpcp))
        goto PalAutoExit;

    hOldCursor = SetCursor(lpcs->hWaitCursor);

    CapturePaletteFrames (lpcs, lpcp, nCount);

    /* we grabbed a frame, time to compute a palette */
    statusUpdateStatus(lpcs, IDS_CAP_STAT_OPTPAL_BUILD);

    // The HPALETTE returned in the following becomes
    // our "global" palette, hence is not deleted here.
    hpal = HistogramPalette(lpcp->lpHistogram, lpcp->lp16to8, lpcp->wNumColors);

    // Send driver both the pal and xlate table
    PalSendPaletteToDriver(lpcs, hpal, (LPBYTE)lpcp->lp16to8 );

    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );  // Update the display with a new image

    SetCursor(hOldCursor);

    InvalidateRect(lpcs->hwnd, NULL, TRUE);
    UpdateWindow(lpcs->hwnd);
    lpcs->fUsingDefaultPalette = FALSE;

PalAutoExit:
    CapturePaletteFini (lpcs, lpcp);
    statusUpdateStatus(lpcs, 0);

   // If an error happened, display it
   if (dwError)
        errorDriverID (lpcs, dwError);

    return (dwError == DV_ERR_OK);
}

//
//  CapturePaletteManual() capture a palette from the video source
//  with user intervention.
//  fGrab is TRUE on all but the last frame captured
//  Returns TRUE on success, FALSE on error
//
BOOL CapturePaletteManual (LPCAPSTREAM lpcs, BOOL fGrab, int nColors)
{
    HPALETTE    hpal;
    HCURSOR     hOldCursor;
    LPCAPPAL    lpcp;
    DWORD       dwError = DV_ERR_OK;

    if (!lpcs->sCapDrvCaps.fDriverSuppliesPalettes)
        return FALSE;

    hOldCursor = SetCursor(lpcs->hWaitCursor);

    // We're initializing for the first time, so alloc everything
    if (lpcs->lpCapPal == NULL) {

        if (lpcp = (LPCAPPAL) GlobalAllocPtr (GHND, sizeof(CAPPAL))) {
            lpcs->lpCapPal = lpcp;

            if (nColors == 0)
                nColors = 256;
            lpcp->wNumColors = min (nColors, 256);
            dwError = CapturePaletteInit (lpcs, lpcp);
        }
        else
            dwError = IDS_CAP_OUTOFMEM;
    }
    lpcp = lpcs->lpCapPal;

    if (dwError != DV_ERR_OK)
        goto PalManualExit;

    // Add a frame to the histogram
    // Handle the case of telling us to stop before we ever started
    if (fGrab || !fGrab && (lpcp->wNumFrames == 0)) {
        CapturePaletteFrames (lpcs, lpcp, 1);
        lpcs->fUsingDefaultPalette = FALSE;
    }
    // All done, send the new palette to the driver
    if (!fGrab) {
        statusUpdateStatus(lpcs, IDS_CAP_STAT_OPTPAL_BUILD);

        // The HPALETTE returned in the following becomes
        // our "global" palette, hence is not deleted here.
        hpal = HistogramPalette(lpcp->lpHistogram,
                        lpcp->lp16to8, lpcp->wNumColors);

        // Send driver both the pal and xlate table
        PalSendPaletteToDriver(lpcs, hpal, (LPBYTE)lpcp->lp16to8 );
    }

    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );  // Update the display with a new image
    InvalidateRect(lpcs->hwnd, NULL, TRUE);
    UpdateWindow(lpcs->hwnd);

PalManualExit:
    if (!fGrab || (dwError != DV_ERR_OK)) {
        if (lpcp != NULL) {
            CapturePaletteFini (lpcs, lpcp);
            GlobalFreePtr (lpcp);
            lpcs->lpCapPal = NULL;
        }
    }

    SetCursor(hOldCursor);
    statusUpdateStatus(lpcs, 0);

    // If an error happened, display it
    if (dwError) {
        errorUpdateError (lpcs, (UINT) dwError);
    }

    return (dwError == DV_ERR_OK);
}



/*--------------------------------------------------------------+
| fileSavePalette - save the current palette in a file  	|
|								|
+--------------------------------------------------------------*/
BOOL FAR PASCAL fileSavePalette(LPCAPSTREAM lpcs, LPTSTR lpszFileName)
{
    HPALETTE            hpal;
    HMMIO               hmmio;
    WORD	        w;
    HCURSOR             hOldCursor;
    MMCKINFO            ckRiff;
    MMCKINFO            ck;
    short               nColors;
    FCLOGPALETTE        pal;
    BOOL                fOK = FALSE;

    if ((hpal = lpcs->hPalCurrent) == NULL)
        return FALSE;

    hmmio = mmioOpen(lpszFileName, NULL, MMIO_WRITE);
    if( !hmmio ) {
	/* try and create */
        hmmio = mmioOpen(lpszFileName, NULL, MMIO_CREATE | MMIO_WRITE);
	if( !hmmio ) {
	    /* find out if the file was read only or we are just */
	    /* totally hosed up here.				 */
	    hmmio = mmioOpen(lpszFileName, NULL, MMIO_READ);
	    if (hmmio){
		/* file was read only, error on it */
                errorUpdateError (lpcs, IDS_CAP_READONLYFILE, (LPTSTR) lpszFileName);
		mmioClose(hmmio, 0);
		return FALSE;
	    } else {
		/* even weirder error has occured here, give CANTOPEN */
                errorUpdateError (lpcs, IDS_CAP_CANTOPEN, (LPTSTR) lpszFileName);
		return FALSE;
	    }
	}
    }

    hOldCursor = SetCursor( lpcs-> hWaitCursor );

    /* Seek to beginning of file, so we can write the header. */
    mmioSeek(hmmio, 0, SEEK_SET);

    /* Create RIFF chunk */
    ckRiff.fccType = mmioFOURCC('P','A','L',' ');
    if(mmioCreateChunk (hmmio,&ckRiff,MMIO_CREATERIFF)) {
         goto FileError;
    }

    /* Create Palette chunk */
    ck.cksize = 0;
    ck.ckid = mmioFOURCC('d','a','t','a');
    if(mmioCreateChunk(hmmio,&ck,0)) {
         goto FileError;
    }

    // Get the palette data here
    GetObject(hpal, sizeof(short), (LPVOID)&nColors);

    pal.palVersion = 0x0300;
    pal.palNumEntries = nColors;

    GetPaletteEntries(hpal, 0, nColors, pal.palPalEntry);

    // Calc the size of the logpalette
    // which is the sizeof palVersion + sizeof palNumEntries + colors
    w = sizeof (WORD) + sizeof (WORD) + nColors * sizeof (PALETTEENTRY);

    // Write out the palette
    if(mmioWrite(hmmio, (LPBYTE)&pal, (DWORD) w) != (LONG) w) {
        goto FileError;
    }

    if(mmioAscend(hmmio, &ck, 0)) {
        goto FileError;
    }

    if(mmioAscend(hmmio, &ckRiff, 0)) {
        goto FileError;
    }

    fOK = TRUE;

FileError:
    mmioClose( hmmio, 0 );

    SetCursor( hOldCursor );

    if (!fOK)
        errorUpdateError (lpcs, IDS_CAP_ERRORPALSAVE, (LPTSTR) lpszFileName);

    return fOK;
}


/*--------------------------------------------------------------+
| fileOpenPalette - use a new palette from the specified file   |
|								|
+--------------------------------------------------------------*/
BOOL FAR PASCAL fileOpenPalette(LPCAPSTREAM lpcs, LPTSTR lpszFileName)
{
    HPALETTE            hpal;
    HMMIO               hmmio;
    WORD	        w;
    HCURSOR             hOldCursor;
    MMCKINFO            ckRiff;
    MMCKINFO            ck;
    FCLOGPALETTE        pal;
    BOOL                fOK = FALSE;

    if ((hpal = lpcs->hPalCurrent) == NULL)
        return FALSE;

    hmmio = mmioOpen(lpszFileName, NULL, MMIO_READ);
    if( !hmmio ) {
        errorUpdateError (lpcs, IDS_CAP_ERRORPALOPEN, (LPTSTR) lpszFileName);
        return FALSE;
    }

    hOldCursor = SetCursor( lpcs-> hWaitCursor );

    /* Seek to beginning of file, so we can read the header. */
    mmioSeek(hmmio, 0, SEEK_SET);

    /* Find the RIFF chunk */
    ckRiff.fccType = mmioFOURCC('P','A','L',' ');
    if(mmioDescend (hmmio, &ckRiff, NULL, MMIO_FINDRIFF)) {
         goto PalOpenError;
    }

    /* Find the data chunk */
    ck.cksize = 0;
    ck.ckid = mmioFOURCC('d','a','t','a');
    if(mmioDescend (hmmio, &ck, &ckRiff, MMIO_FINDCHUNK)) {
         goto PalOpenError;
    }

    // First read just the Version and number of entries
    // which is the sizeof palVersion + sizeof palNumEntries
    w = sizeof (WORD) + sizeof (WORD);
    if(mmioRead(hmmio, (LPBYTE)&pal, (DWORD) w) != (LONG) w) {
        goto PalOpenError;
    }

    // Do a bit of checking
    if ((pal.palVersion != 0x0300) || (pal.palNumEntries > 256))
        goto PalOpenError;

    // Now get the actual palette data
    // which is the sizeof palVersion + sizeof palNumEntries
    w = pal.palNumEntries * sizeof (PALETTEENTRY);
    if(mmioRead(hmmio, (LPBYTE)&pal.palPalEntry, (DWORD) w) != (LONG) w) {
        goto PalOpenError;
    }

    if (hpal = CreatePalette ((LPLOGPALETTE) &pal)) {
        PalSendPaletteToDriver (lpcs, hpal, NULL /*lpXlateTable */);
        fOK = TRUE;
    }

    videoFrame( lpcs->hVideoIn, &lpcs->VidHdr );  // grab a new frame

PalOpenError:
    mmioClose( hmmio, 0 );

    SetCursor( hOldCursor );
    InvalidateRect(lpcs->hwnd, NULL, TRUE);
    UpdateWindow(lpcs->hwnd);		// update the display with new frame

    if (!fOK)
        errorUpdateError (lpcs, IDS_CAP_ERRORPALOPEN, (LPTSTR) lpszFileName);
    else
    lpcs->fUsingDefaultPalette = FALSE;

    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\capio.c ===
/****************************************************************************
 *
 *   capio.c
 *
 *   i/o routines for video capture
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

//#define USE_AVIFILE 1
#define JMK_HACK_DONTWRITE TRUE

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include <vfw.h>
#include <mmreg.h>
#include <mmddk.h>

#include "ivideo32.h"
#include "mmdebug.h"

#ifdef USE_ACM
#include <msacm.h>
#endif

#include "avicapi.h"
#include "time.h"

extern UINT GetSizeOfWaveFormat (LPWAVEFORMATEX lpwf);
STATICFN BOOL IndexVideo (LPCAPSTREAM lpcs, DWORD dwSize, BOOL bKeyFrame);
STATICFN BOOL IndexAudio (LPCAPSTREAM lpcs, DWORD dwSize);

#ifdef _DEBUG
    #define DSTATUS(lpcs, sz) statusUpdateStatus(lpcs, IDS_CAP_INFO, (LPTSTR) TEXT(sz))
#else
    #define DSTATUS(lpcs, sz)
#endif

//
// Define function variables for dynamically linking to the async IO
// completion routines on NT.  This should allow the same code to run
// on Win95 which does not have these entry points.
//

HANDLE (WINAPI *pfnCreateIoCompletionPort)(
    HANDLE FileHandle,
    HANDLE ExistingCompletionPort,
    DWORD CompletionKey,
    DWORD NumberOfConcurrentThreads
    );

BOOL (WINAPI *pfnGetQueuedCompletionStatus)(
    HANDLE CompletionPort,
    LPDWORD lpNumberOfBytesTransferred,
    LPDWORD lpCompletionKey,
    LPOVERLAPPED *lpOverlapped,
    DWORD dwMilliseconds
    );

HINSTANCE hmodKernel;           // Handle to loaded Kernel32.dll

#ifdef USE_AVIFILE
#include "capio.avf"
#else //---------------- ! using Avifile ----------------------------

// The following are anded with the size in the index
#define IS_AUDIO_CHUNK        0x80000000
#define IS_KEYFRAME_CHUNK     0x40000000
#define IS_DUMMY_CHUNK        0x20000000
#define IS_GRANULAR_CHUNK     0x10000000
#define INDEX_MASK  (IS_AUDIO_CHUNK | IS_KEYFRAME_CHUNK | IS_DUMMY_CHUNK | IS_GRANULAR_CHUNK)


// Add an index entry for a video frame
// dwSize is the size of data ONLY, not including the chunk or junk
// Returns: TRUE if index space is not exhausted
//
STATICFN BOOL IndexVideo (LPCAPSTREAM lpcs, DWORD dwSize, BOOL bKeyFrame)
{
    if (lpcs->dwIndex < lpcs->sCapParms.dwIndexSize) {
        *lpcs->lpdwIndexEntry = dwSize | (bKeyFrame ? IS_KEYFRAME_CHUNK : 0);
        ++lpcs->lpdwIndexEntry;
        ++lpcs->dwIndex;
        ++lpcs->dwVideoChunkCount;
        return TRUE;
    }
    dprintf("\n***WARNING*** Indexvideo space exhausted\n");
    return FALSE;
}

// Add an index entry for an audio buffer
// dwSize is the size of data ONLY, not including the chunk or junk
// Returns: TRUE if index space is not exhausted
//
STATICFN BOOL IndexAudio (LPCAPSTREAM lpcs, DWORD dwSize)
{
    if (lpcs->dwIndex < lpcs->sCapParms.dwIndexSize) {
       *lpcs->lpdwIndexEntry = dwSize | IS_AUDIO_CHUNK;
       ++lpcs->lpdwIndexEntry;
       ++lpcs->dwIndex;
       ++lpcs->dwWaveChunkCount;
       return TRUE;
    }
    dprintf("\n***WARNING*** Indexaudio space exhausted\n");
    return FALSE;
}

DWORD CalcWaveBufferSize (LPCAPSTREAM lpcs)
{
    DWORD dw;

    if (!lpcs->lpWaveFormat)
        return 0L;

    // at least .5 second
    dw = lpcs->lpWaveFormat->nAvgBytesPerSec / 2;
    if (lpcs->sCapParms.wChunkGranularity) {
        if (dw % lpcs->sCapParms.wChunkGranularity) {
            dw += lpcs->sCapParms.wChunkGranularity -
                dw % lpcs->sCapParms.wChunkGranularity;
        }
    }
    dw = max ((1024L * 16), dw);                // at least 16K
    dw -= sizeof(RIFF);

    dprintf("Wave buffer size = %ld", dw);
    return dw;
}

/*
 * AVIPreloadFat
 *
 *   Force FAT for this file to be loaded into the FAT cache
 *
 */

VOID WINAPI AVIPreloadFat (LPCAPSTREAM lpcs)
{
    DWORD dw;
   #ifdef CHICAGO
    DWORD dwPos;

    assert (lpcs->lpDropFrame);

    // save the current file pointer then seek to the end of the file
    //
    dwPos = SetFilePointer (lpcs->hFile, 0, NULL, FILE_CURRENT);
    dw = SetFilePointer (lpcs->hFile, 0, NULL, FILE_END);
    if ((dw == (DWORD)-1) || (dw < lpcs->dwBytesPerSector)) {
        // put the file pointer back to where it was
        SetFilePointer (lpcs->hFile, dwPos, NULL, FILE_BEGIN);
        return;
    }

    // read the last sector of the file, just to force
    // the fat for the file to be loaded
    //
    ReadFile (lpcs->hFile, lpcs->lpDropFrame, lpcs->dwBytesPerSector, &dw, NULL);

    // put the file pointer back to where it was
    //
    SetFilePointer (lpcs->hFile, dwPos, NULL, FILE_BEGIN);
   #else
    // Load all the FAT information.   On NT this is sufficient for FAT
    // files.  On NTFS partitiions there is no way we can read in all the
    // mapping information.
    GetFileSize(lpcs->hFile, &dw);
   #endif
}


#ifdef JMK_HACK_DONTWRITE
static BOOL bDontWrite;
#endif

// Write data to the capture file
// Returns: TRUE on a successful write
//
UINT NEAR PASCAL AVIWrite (
    LPCAPSTREAM lpcs,
    LPVOID      pbuf,
    DWORD       dwSize,
    UINT        uIndex, // index of header for this buffer, -1 for step capture
    UINT        uType,
    LPBOOL      lpbPending)
{
    DWORD dwWritten;
    DWORD dwGran;

    // the buffer must be sector aligned if using non-buffered IO
    // and the size must be at least word aligned
    // uIndex == -1 if this is a dummy frame write
    // uIndex == Index into alpVideoHdr OR index in alpWaveHdr based on uType
    //
    assert (!lpcs->fUsingNonBufferedIO || (!((DWORD_PTR)pbuf & (lpcs->dwBytesPerSector - 1))));
    assert (!(dwSize & 1));
    assert (dwSize);

    assert (*lpbPending == FALSE);

    // if we are doing non-buffered io, we need to pad each write
    // to an even multiple of sector size bytes, we do this by adding
    // a junk riff chunk into the write buffer after dwSize bytes
    //
    dwGran = lpcs->sCapParms.wChunkGranularity;
    if (lpcs->fUsingNonBufferedIO)
       dwGran = max (lpcs->dwBytesPerSector,
                (DWORD) lpcs->sCapParms.wChunkGranularity);

    assert (dwGran);

    if (dwSize % dwGran)
    {
        DWORD dwSizeT = dwGran - (dwSize % dwGran);
        LPRIFF priff = (LPRIFF)((LPBYTE)pbuf + dwSize + (dwSize & 1));

        if (dwSizeT < sizeof(RIFF))
            dwSizeT += dwGran;

        // add the junk riff chunk to the end of the buffer
        //
        priff->dwType = ckidAVIPADDING;
        priff->dwSize = dwSizeT - sizeof(RIFF);
        dwSize += dwSizeT;
    }

   #ifdef _DEBUG
    if (dwSize)
    {
        volatile BYTE bt;
        AuxDebugEx (8, DEBUGLINE "touch test of AviWrite buffer %08X\r\n", pbuf);
        bt = ((LPBYTE)pbuf)[dwSize-1];
    }

    // List all of the RIFF chunks within the block being written
    //
    dwWritten = 0;
    while (dwWritten < dwSize)
    {
        LPRIFF priff = (LPVOID)((LPBYTE)pbuf + dwWritten);
        AuxDebugEx (4, DEBUGLINE "RIFF=%.4s size=%08X\r\n",
                   &priff->dwType, priff->dwSize);
        dwWritten += priff->dwSize + sizeof(RIFF);
    }
   #endif


    // BUGBUG, Remove the following line when done performance testing
   #ifdef JMK_HACK_DONTWRITE
    if (bDontWrite)
        return 0;
   #endif

    if (lpcs->pAsync)
    {
        struct _avi_async * lpah = &lpcs->pAsync[lpcs->iLastAsync];
        UINT  iLastAsync;

        // set iLastAsync to point to what lpcs->iLastAsync
        // would be if we were to increment it.  If we end up
        // with an i/o that does not complete synchronously
        // we will then update lpcs->iLastAsync so that we can
        // remember to check for completion later
        //
        if ((iLastAsync = lpcs->iLastAsync+1) >= lpcs->iNumAsync)
            iLastAsync = 0;

        // is the async buffer that we are trying to use
        // already in use?
        //
        if (iLastAsync == lpcs->iNextAsync) {
	    AuxDebugEx(1, DEBUGLINE "async buffer already in use\r\n");
            return IDS_CAP_FILE_WRITE_ERROR;
	}
        assert (!lpah->uType);

        // init the async buffer with the info that we will need
        // to release the buffer when the io is complete
        //
        ZeroMemory (&lpah->ovl, sizeof(lpah->ovl));
        if (uIndex == -1) {
            // We want a synchronous write
            assert (!(((DWORD_PTR)(lpcs->heSyncWrite))&1));
            lpah->ovl.hEvent = (HANDLE)(((DWORD_PTR)lpcs->heSyncWrite) | 1);
            // OR'ing hEvent with 1 prevents the IOCompletionPort being used
	    // ...and I know this sounds a bit tacky but this is what the
	    // docs actually say.
        } else {
            lpah->ovl.hEvent = 0;
        }

        lpah->ovl.Offset = lpcs->dwAsyncWriteOffset;
        // attempt an async write.  if WriteFile fails, we then
        // need to check if it's a real failure, or just an instance
        // of delayed completion.  if delayed completion, we fill out
        // the lpah structure so that we know what buffer to re-use
        // when the io finally completes.
        //
	if ( ! WriteFile (lpcs->hFile, pbuf, dwSize, &dwWritten, &lpah->ovl))
        {
            UINT n = GetLastError();
            if ((ERROR_IO_PENDING == n) || (ERROR_INVALID_HANDLE == n))
            {
                // if we are passed a index of -1, that means that
                // this buffer is not associated with any entry in the
                // header array.  in this case, we must have the io complete
                // before we return from this function.
               //
               if (uIndex == (UINT)-1)
               {
                    AuxDebugEx(3, "Waiting for a block to write synchonously\n");
                    if ( ! GetOverlappedResult (lpcs->hFile, &lpah->ovl, &dwWritten, TRUE))
                    {
                        AuxDebugEx (1, DEBUGLINE "WriteFile failed %d\r\n", GetLastError());
                        return IDS_CAP_FILE_WRITE_ERROR;
                    }
                }
                else
                {
                    // io is begun, but not yet completed. so setup info in
                    // the pending io array so that we can check later for completion
                    //
                    *lpbPending = TRUE;
                    lpah->uType = uType | ASYNCIOPENDING;
                    lpah->uIndex = uIndex;
		    AuxDebugEx(2, DEBUGLINE "IOPending... iLastAsync was %d, will be %d, uIndex=%d, Event=%d\r\n",lpcs->iLastAsync , iLastAsync, uIndex, lpah->ovl.hEvent);
                    lpcs->iLastAsync = iLastAsync;
                }
            }
            else
            {
                AuxDebugEx (1, DEBUGLINE "WriteFile failed %d\r\n", GetLastError());
                return IDS_CAP_FILE_WRITE_ERROR;
	    }
	}

        // we get to here only when the io succeeds or is pending
        // so update the seek offset for use in the next write operation
        //
        lpcs->dwAsyncWriteOffset += dwSize;
    }
    else
    {
	// We are writing synchronously to the file
        if (!WriteFile (lpcs->hFile, pbuf, dwSize, &dwWritten, NULL) ||
            !(dwWritten == dwSize))
            return IDS_CAP_FILE_WRITE_ERROR;
    }

    return 0;
}

/*
 * CapFileInit
 *
 *       Perform all initialization required to write a capture file.
 *
 *       We take a slightly strange approach: We don't write
 *       out the header until we're done capturing.  For now,
 *       we just seek 2K into the file, which is where all of
 *       the real data will go.
 *
 *       When we're done, we'll come back and write out the header,
 *       because then we'll know all of the values we need.
 *
 *      Also allocate and init the index.
 */
BOOL CapFileInit (LPCAPSTREAM lpcs)
{
    LONG l;
    LPBITMAPINFO lpBitsInfoOut;    // Possibly compressed output format
    DWORD dwOpenFlags;

    // No special video format given -- use the default
    lpBitsInfoOut = lpcs->CompVars.lpbiOut;
    if (lpcs->CompVars.hic == NULL)
        lpBitsInfoOut = lpcs->lpBitsInfo;


    assert (lpcs->hmmio == NULL);   // Should never have a file handle on entry

    // if the capture file has not been set then set it now
    if (!(*lpcs->achFile))
         goto INIT_FILE_OPEN_ERROR;

    // Get the Bytes per sector for the drive
    {
        DWORD dwSectorsPerCluster;
        DWORD dwFreeClusters;
        DWORD dwClusters;
        TCHAR szFullPathName[MAX_PATH];
        LPTSTR pszFilePart;

        GetFullPathName (lpcs->achFile,
                NUMELMS (szFullPathName),
                szFullPathName,
                &pszFilePart);

        if (szFullPathName[1] == TEXT(':') && szFullPathName[2] == TEXT('\\')) {
            szFullPathName[3] = TEXT('\0');  // Terminate after "x:\"

            GetDiskFreeSpace (szFullPathName,
                   &dwSectorsPerCluster,
                   &lpcs->dwBytesPerSector,
                   &dwFreeClusters,
                   &dwClusters);
            AuxDebugEx (3, DEBUGLINE "BytesPerSector=%d\r\n",
                lpcs->dwBytesPerSector);
        }
        else {
            // This handles cases where we do not have a "x:\" filename
            // Principally this will be "\\server\name\path..."
            lpcs->dwBytesPerSector = DEFAULT_BYTESPERSECTOR;
            AuxDebugEx (3, DEBUGLINE "FullPath=%s\r\n", szFullPathName);
            AuxDebugEx (3, DEBUGLINE "GetFullPath failed, Forcing dwBytesPerSector to %d\r\n",DEFAULT_BYTESPERSECTOR);
        }

    // bytes per sector must be non-zero and a power of two
    //
    assert (lpcs->dwBytesPerSector);
    assert (!(lpcs->dwBytesPerSector & (lpcs->dwBytesPerSector-1)));
    }

   #ifdef ZERO_THE_FILE_FOR_TESTING
    {
    char c[64 * 1024];
    DWORD dwSize;
    DWORD dwBW;
    // Open the file just to zero it

    lpcs->hFile = CreateFile (lpcs->achFile,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (lpcs->hFile == INVALID_HANDLE_VALUE) {
        lpcs->hFile = 0;
        goto INIT_FILE_OPEN_ERROR;
    }

    ZeroMemory (c, sizeof(c));
    SetFilePointer (lpcs->hFile, 0, NULL, FILE_BEGIN);
    dwSize = GetFileSize (lpcs->hFile, NULL);

    while (SetFilePointer (lpcs->hFile, 0, NULL, FILE_CURRENT) < dwSize)
        WriteFile (lpcs->hFile, c, sizeof(c), &dwBW, NULL);
    }

    CloseHandle(lpcs->hFile);  // Close the "normal" open
   #endif

    // We can use non-buffered I/O if the ChunkGranularity is
    // a multiple of BytesPerSector.  Better check that wChunkGranularity
    // has indeed been set

    if (0 == lpcs->sCapParms.wChunkGranularity)
        lpcs->sCapParms.wChunkGranularity = lpcs->dwBytesPerSector;

    dwOpenFlags = FILE_ATTRIBUTE_NORMAL;
    lpcs->fUsingNonBufferedIO =
            (lpcs->sCapParms.wChunkGranularity >= lpcs->dwBytesPerSector) &&
           ((lpcs->sCapParms.wChunkGranularity % lpcs->dwBytesPerSector) == 0) &&
            (lpcs->CompVars.hic == NULL) &&
            (!(lpcs->fCaptureFlags & CAP_fStepCapturingNow)) &&
            (!(lpcs->fCaptureFlags & CAP_fFrameCapturingNow));

    AuxDebugEx (3, DEBUGLINE "fUsingNonBufferedIO=%d\r\n", lpcs->fUsingNonBufferedIO);

    // setup CreateFile flags based on whether we are using
    // non-buffered io and/or overlapped io
    //
    if (lpcs->fUsingNonBufferedIO)
    {
        dwOpenFlags |= FILE_FLAG_NO_BUFFERING;
#ifdef CHICAGO
    #define DOASYNCIO FALSE
    #pragma message (SQUAWK "find a better way to set AsyncIO flag")
#else
    #define DOASYNCIO TRUE
#endif
       #ifdef CHICAGO
        if (GetProfileIntA ("Avicap32", "AsyncIO", DOASYNCIO))
       #else
            if (!pfnCreateIoCompletionPort) {
                hmodKernel = LoadLibrary(TEXT("kernel32"));
                if (hmodKernel) {

#define IOCP (void *(__stdcall *)(void *,void *,unsigned long ,unsigned long ))
#define GQCS (int (__stdcall *)(void *,unsigned long *,unsigned long *,struct _OVERLAPPED ** ,unsigned long ))
                    pfnCreateIoCompletionPort = IOCP GetProcAddress(hmodKernel, "CreateIoCompletionPort");
                    pfnGetQueuedCompletionStatus = GQCS GetProcAddress(hmodKernel, "GetQueuedCompletionStatus");
                    if (!pfnCreateIoCompletionPort && !pfnGetQueuedCompletionStatus) {
                        pfnCreateIoCompletionPort = NULL;
                        pfnGetQueuedCompletionStatus = NULL;
                        FreeLibrary(hmodKernel);
                    }
                }
            }
            DPF("CreateIoCompletionPort @%x", pfnCreateIoCompletionPort);
            DPF("GetQueuedCompletionStatus @%x", pfnGetQueuedCompletionStatus);

            // give a way to override the async default option.
            if (!GetProfileIntA ("Avicap32", "AsyncIO",  DOASYNCIO)
              || !pfnCreateIoCompletionPort) {
		AuxDebugEx (2, DEBUGLINE "NOT doing Async IO\r\n");
	    } else
       #endif
        {
            AuxDebugEx (3, DEBUGLINE "Doing Async IO\r\n");
            dwOpenFlags |= FILE_FLAG_OVERLAPPED;

            // We are requested to do async io.  Allocate an array
            // of async io headers and initialize the async io fields
            // in the CAPSTREAM structure
            //
            {
                UINT iNumAsync = NUMELMS(lpcs->alpVideoHdr) + NUMELMS(lpcs->alpWaveHdr) + 2;
		// This is quite a lot of buffers.  Perhaps we should limit
		// ourselves to lpcs->iNumVideo and lpcs->iNumAudio EXCEPT
		// these fields have not yet been set up.  We would need
		// to look in the cap stream structure to get the information.
		// It is simpler to assume the maximum numbers.
		// Set the offset for the first write to the file
                lpcs->dwAsyncWriteOffset = lpcs->dwAVIHdrSize;
                lpcs->iNextAsync = lpcs->iLastAsync = 0;
                // Create the manual reset event for synchronous writing
                if ((lpcs->heSyncWrite = CreateEvent(NULL, TRUE, FALSE, NULL))
                  && (NULL != (lpcs->pAsync = (LPVOID)GlobalAllocPtr (GMEM_MOVEABLE | GMEM_ZEROINIT,
                                               sizeof(*lpcs->pAsync) * iNumAsync)))) {
                    lpcs->iNumAsync = iNumAsync;
                } else {
                    // cannot allocate the memory.  Go synchronous
                    dprintf("Failed to allocate async buffers");
                    if (lpcs->heSyncWrite) {
                        CloseHandle(lpcs->heSyncWrite);
                        lpcs->heSyncWrite = 0;
                    }
                    dwOpenFlags &= ~(FILE_FLAG_OVERLAPPED);
		}
            }
        }
    }

    // Open the capture file, using Non Buffered I/O
    // if possible, given sector size, and buffer granularity
    //
reopen:
    lpcs->hFile = CreateFile (lpcs->achFile,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_ALWAYS,
                    dwOpenFlags,
                    NULL);

    if (lpcs->hFile == INVALID_HANDLE_VALUE) {
        lpcs->hFile = 0;
        goto INIT_FILE_OPEN_ERROR;
    }

#ifdef ASYNCIO_PORT
    if (dwOpenFlags & FILE_FLAG_OVERLAPPED) {
        lpcs->hCompletionPort = pfnCreateIoCompletionPort(lpcs->hFile, NULL, (DWORD)1, 0);

        if (!lpcs->hCompletionPort) {
            // if we cannot create the completion port, write synchronously.
            dwOpenFlags &= ~FILE_FLAG_OVERLAPPED;
            CloseHandle(lpcs->hFile);
            GlobalFreePtr(lpcs->pAsync);
            lpcs->iNumAsync=0;
            if (lpcs->heSyncWrite) {
                CloseHandle(lpcs->heSyncWrite);
                lpcs->heSyncWrite = 0;
            }
            DPF("COULD NOT create the async completion port");
            goto reopen;
        } else {
            DPF("Created the async completion port");
        }
    }
#endif

    // BUGBUG, Remove the following line when done performance testing
   #ifdef JMK_HACK_DONTWRITE
    bDontWrite = GetProfileIntA("AVICAP32", "DontWrite", FALSE);
   #endif

    // Seek to a multiple of ChunkGranularity + AVIHEADERSIZE.
    // This is the point at which we'll start writing
    // Later, we'll come back and fill in the AVI header and index.

    // l is zero for standard wave and video formats
    l = (GetSizeOfWaveFormat ((LPWAVEFORMATEX) lpcs->lpWaveFormat) -
                sizeof (PCMWAVEFORMAT)) +
                (lpBitsInfoOut->bmiHeader.biSize -
                sizeof (BITMAPINFOHEADER));

    // (2K + size of wave and video stream headers) rounded to next 2K
    lpcs->dwAVIHdrSize = AVI_HEADERSIZE +
        (((lpcs->cbInfoChunks + l + lpcs->sCapParms.wChunkGranularity - 1)
        / lpcs->sCapParms.wChunkGranularity) * lpcs->sCapParms.wChunkGranularity);
    // we should assert that AVI_HEADERSIZE is a multiple of wChunkGranularity


    dprintf("AVIHdrSize = %ld", lpcs->dwAVIHdrSize);

    SetFilePointer (lpcs->hFile, lpcs->dwAVIHdrSize, NULL, FILE_BEGIN);
    if (lpcs->pAsync) {
        lpcs->dwAsyncWriteOffset = lpcs->dwAVIHdrSize;
    }

    // do all Index allocations
    if (!InitIndex (lpcs))
        CloseHandle (lpcs->hFile), lpcs->hFile = 0;

    lpcs->dwVideoChunkCount = 0;
    lpcs->dwWaveChunkCount = 0;

INIT_FILE_OPEN_ERROR:
    if (lpcs->hFile) {
	return(TRUE);
    }
    if (lpcs->pAsync) {
	GlobalFreePtr(lpcs->pAsync), lpcs->pAsync=NULL;
    }
    if (lpcs->heSyncWrite) {
        CloseHandle(lpcs->heSyncWrite);
        lpcs->heSyncWrite = 0;
    }
    return (FALSE);
}

///////////////////////////////////////////////////////////////////////////
//  The index array is used to record the positions
//  of every chunk in the RIFF (avi) file.
//
//  what this array is:
//
//      each entry contains the size of the data
//      high order bits encode the type of data (audio / video)
//      and whether the video chunk is a key frame, dropped frame, etc.
///////////////////////////////////////////////////////////////////////////

// Allocate the index table
// Returns: TRUE if index can be allocated
//
BOOL InitIndex (LPCAPSTREAM lpcs)
{
    lpcs->dwIndex = 0;

    // we assume that we have not already allocated an index
    //
    assert (lpcs->lpdwIndexStart == NULL);

    // Limit index size between 1 minute at 30fps and 3 hours at 30fps
    lpcs->sCapParms.dwIndexSize = max (lpcs->sCapParms.dwIndexSize, 1800);
    lpcs->sCapParms.dwIndexSize = min (lpcs->sCapParms.dwIndexSize, 324000L);
    dprintf("Max Index Size = %ld", lpcs->sCapParms.dwIndexSize);

    if (lpcs->hIndex = GlobalAlloc (GMEM_MOVEABLE,
                lpcs->sCapParms.dwIndexSize * sizeof (DWORD))) {
        if (lpcs->lpdwIndexEntry =
            lpcs->lpdwIndexStart = (LPDWORD)GlobalLock (lpcs->hIndex))
            return TRUE;        // Success

        GlobalFree (lpcs->hIndex);
	lpcs->hIndex = NULL;
    }
    lpcs->lpdwIndexStart = NULL;
    return FALSE;
}

// Deallocate the index table
//
void FiniIndex (LPCAPSTREAM lpcs)
{
    if (lpcs->hIndex) {
        if (lpcs->lpdwIndexStart)
            GlobalUnlock (lpcs->hIndex);
        GlobalFree (lpcs->hIndex);
	lpcs->hIndex = NULL;
    }
    lpcs->lpdwIndexStart = NULL;
}



// Write out the index at the end of the capture file.
// The single frame capture methods do not append
// JunkChunks!  Audio chunks also now may have junk appended.
//
BOOL WriteIndex (LPCAPSTREAM lpcs, BOOL fJunkChunkWritten)
{
    BOOL  fChunkIsAudio;
    BOOL  fChunkIsKeyFrame;
    BOOL  fChunkIsDummy;
    BOOL  fChunkIsGranular;
    DWORD dwIndex;
    DWORD dw;
    DWORD dwJunk;
    DWORD off;
    AVIINDEXENTRY   avii;
    MMCKINFO    ck;
    LPDWORD lpdw;
    DWORD   dwGran;

    // determine which granularity (if any) to use
    // when calculating junk appended
    //
    dwGran = 0;
    if (fJunkChunkWritten)
    {
        dwGran = lpcs->sCapParms.wChunkGranularity;
        if (lpcs->fUsingNonBufferedIO)
           dwGran = max (lpcs->dwBytesPerSector, dwGran);
    }


    if (lpcs->dwIndex > lpcs->sCapParms.dwIndexSize)
        return TRUE;

    off        = lpcs->dwAVIHdrSize;

    ck.cksize  = 0;
    ck.ckid    = ckidAVINEWINDEX;
    ck.fccType = 0;

    if (mmioCreateChunk(lpcs->hmmio,&ck,0)) {
	dprintf("Failed to create chunk for index");
        return FALSE;
    }

    lpdw = lpcs->lpdwIndexStart;
    for (dwIndex= 0; dwIndex < lpcs->dwIndex; dwIndex++) {

        dw = *lpdw++;

        fChunkIsAudio      = (BOOL) ((dw & IS_AUDIO_CHUNK) != 0);
        fChunkIsKeyFrame   = (BOOL) ((dw & IS_KEYFRAME_CHUNK) != 0);
        fChunkIsDummy      = (BOOL) ((dw & IS_DUMMY_CHUNK) != 0);
        fChunkIsGranular   = (BOOL) ((dw & IS_GRANULAR_CHUNK) != 0);
        dw &= ~(INDEX_MASK);

        if (fChunkIsAudio) {
            avii.ckid         = MAKEAVICKID(cktypeWAVEbytes, 1);
            avii.dwFlags      = 0;
        } else {
            avii.ckid         = MAKEAVICKID(cktypeDIBbits, 0);
            if (lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RLE8)
                avii.ckid         = MAKEAVICKID(cktypeDIBcompressed, 0);
            avii.dwFlags      = fChunkIsKeyFrame ? AVIIF_KEYFRAME : 0;
        }
        avii.dwChunkLength    = dw;
        avii.dwChunkOffset    = off;

        if (mmioWrite(lpcs->hmmio, (LPVOID)&avii, sizeof(avii)) != sizeof(avii)) {
	    dprintf("Failed to write index chunk %d", dwIndex);
            return FALSE;
	}

        dw += sizeof (RIFF);
        // round to word boundary
        //
        dw += (dw & 1);
        off += dw;

        // If a Junk chunk was appended, move past it
        //
        if (fChunkIsGranular && dwGran && (off % dwGran)) {
            dwJunk = dwGran - (off % dwGran);

            if (dwJunk < sizeof (RIFF))
                off += dwGran;
            off += dwJunk;
        }
    }

    if (mmioAscend(lpcs->hmmio, &ck, 0)){
	dprintf("Failed to ascend at end of index writing");
        return FALSE;
    }

    return TRUE;
}

/*
 * AVIFileFini
 *
 *       Write out the index, deallocate the index, and close the file.
 *
 */
BOOL AVIFileFini (LPCAPSTREAM lpcs, BOOL fWroteJunkChunks, BOOL fAbort)
{
    MMCKINFO      ckRiff;
    MMCKINFO      ckList;
    MMCKINFO      ckStream;
    MMCKINFO      ck;
    UINT          ii;
    DWORD         dw;
    AVIStreamHeader        strhdr;
    DWORD         dwDataEnd;
    BOOL          fRet = TRUE;
    RGBQUAD       argbq[256];
    MainAVIHeader aviHdr;
    BOOL          fSound;
    LPBITMAPINFO  lpBitsInfoOut;    // Possibly compressed output format

    // No special video format given -- use the default
    //
    lpBitsInfoOut = lpcs->lpBitsInfo;
   #ifdef NEW_COMPMAN
    if (lpcs->CompVars.hic != NULL)
        lpBitsInfoOut = lpcs->CompVars.lpbiOut;
   #endif

    // if the capture file has not been opened, we have nothing to do
    //
    if (lpcs->hFile == 0)
        return FALSE;

    // save off the current seek position.  this is the end of the capture
    // data.  then close the capture file,  we will do the final work
    // on the capture file using mmio & buffered io.
    //
    if (lpcs->pAsync)
        dwDataEnd = lpcs->dwAsyncWriteOffset;
    else
        dwDataEnd = SetFilePointer (lpcs->hFile, 0, NULL, FILE_CURRENT);

    CloseHandle (lpcs->hFile), lpcs->hFile = 0;

    // if we had allocated space for async buffers, free them now
    //
    if (lpcs->pAsync)
    {
        GlobalFreePtr (lpcs->pAsync);
        lpcs->pAsync = NULL;
        lpcs->iNextAsync = lpcs->iLastAsync = lpcs->iNumAsync = 0;
    }

    // if we are aborting capture, we are done
    lpcs->hmmio = mmioOpen(lpcs->achFile, NULL, MMIO_WRITE);
    assert (lpcs->hmmio != NULL);

    //
    if (fAbort)
        goto FileError;

    if (!lpcs->dwWaveBytes)
        fSound = FALSE;
    else
        fSound = lpcs->sCapParms.fCaptureAudio && (!(lpcs->fCaptureFlags & CAP_fFrameCapturingNow));

    // Seek to beginning of file, so we can write the header.
    mmioSeek(lpcs->hmmio, 0, SEEK_SET);

    DSTATUS(lpcs, "Writing AVI header");

    // Create RIFF/AVI chunk
    ckRiff.cksize = 0;
    ckRiff.fccType = formtypeAVI;
    if (mmioCreateChunk(lpcs->hmmio,&ckRiff,MMIO_CREATERIFF))
         goto FileError;

    // Create header list
    ckList.cksize = 0;
    ckList.fccType = listtypeAVIHEADER;
    if (mmioCreateChunk(lpcs->hmmio,&ckList,MMIO_CREATELIST))
         goto FileError;

    // Create AVI header chunk
    ck.cksize = sizeof(MainAVIHeader);
    ck.ckid = ckidAVIMAINHDR;
    if (mmioCreateChunk(lpcs->hmmio,&ck,0))
         goto FileError;

    lpcs->dwAVIHdrPos = ck.dwDataOffset;

    // Calculate AVI header info
    //
    ZeroMemory (&aviHdr, sizeof(aviHdr));

    //
    // Set the stream lengths based on the Master stream
    //
   #if 0 // stream length calc with unconditional audio master
    aviHdr.dwMicroSecPerFrame = lpcs->sCapParms.dwRequestMicroSecPerFrame;
    if (fSound && lpcs->dwVideoChunkCount) {
         /* HACK HACK */
         /* Set rate that was captured based on length of audio data */

         aviHdr.dwMicroSecPerFrame = (DWORD) MulDiv ((LONG)lpcs->dwWaveBytes,
                   1000000,
                   (LONG)(lpcs->lpWaveFormat->nAvgBytesPerSec * lpcs->dwVideoChunkCount));
    }
   #else

    // Init a value in case we're not capturing audio
    aviHdr.dwMicroSecPerFrame = lpcs->sCapParms.dwRequestMicroSecPerFrame;

    switch (lpcs->sCapParms.AVStreamMaster) {
        case AVSTREAMMASTER_NONE:
            break;

        case AVSTREAMMASTER_AUDIO:
        default:
            // VFW 1.0 and 1.1 ALWAYS munged frame rate to match audio
            // duration.
            if (fSound && lpcs->sCapParms.fCaptureAudio && lpcs->dwVideoChunkCount) {
                // Modify the video framerate based on audio duration
                aviHdr.dwMicroSecPerFrame = (DWORD)
                    ((double)lpcs->dwWaveBytes * 1000000. /
                    ((double)lpcs->lpWaveFormat->nAvgBytesPerSec *
                    lpcs->dwVideoChunkCount + 0.5));
            }
            break;
    }
   #endif
    lpcs->dwActualMicroSecPerFrame = aviHdr.dwMicroSecPerFrame;

    aviHdr.dwMaxBytesPerSec = (DWORD) MulDiv (lpBitsInfoOut->bmiHeader.biSizeImage,
                                      1000000,
                                      lpcs->sCapParms.dwRequestMicroSecPerFrame) +
                                      (fSound ? lpcs->lpWaveFormat->nAvgBytesPerSec : 0);
    aviHdr.dwPaddingGranularity = 0L;
    aviHdr.dwFlags = AVIF_WASCAPTUREFILE | AVIF_HASINDEX;
    aviHdr.dwStreams = fSound ? 2 : 1;
    aviHdr.dwTotalFrames = lpcs->dwVideoChunkCount;
    aviHdr.dwInitialFrames = 0L;
    aviHdr.dwSuggestedBufferSize = 0L;
    aviHdr.dwWidth = lpBitsInfoOut->bmiHeader.biWidth;
    aviHdr.dwHeight = lpBitsInfoOut->bmiHeader.biHeight;

#if 0 // unnecessary due to the ZeroMemory call above
    aviHdr.dwReserved[0] = 0;
    aviHdr.dwReserved[1] = 0;
    aviHdr.dwReserved[2] = 0;
    aviHdr.dwReserved[3] = 0;
#endif
    //aviHdr.dwRate = 1000000L;
    //aviHdr.dwScale = aviHdr.dwMicroSecPerFrame;
    //aviHdr.dwStart = 0L;
    //aviHdr.dwLength = lpcs->dwVideoChunkCount;

    // Write AVI header info
    if (mmioWrite(lpcs->hmmio, (LPBYTE)&aviHdr, sizeof(aviHdr)) != sizeof(aviHdr) ||
        mmioAscend(lpcs->hmmio, &ck, 0))
        goto FileError;

    DSTATUS(lpcs, "Writing AVI Stream header");

    // Create stream header list
    ckStream.cksize = 0;
    ckStream.fccType = listtypeSTREAMHEADER;
    if (mmioCreateChunk(lpcs->hmmio,&ckStream,MMIO_CREATELIST))
        goto FileError;

    ZeroMemory (&strhdr, sizeof(strhdr));
    strhdr.fccType = streamtypeVIDEO;
    strhdr.fccHandler = lpBitsInfoOut->bmiHeader.biCompression;
   #ifdef NEW_COMPMAN
    if (lpcs->CompVars.hic)
        strhdr.fccHandler = lpcs->CompVars.fccHandler;
   #endif

    // A bit of history...
    // In VFW 1.0, we set fccHandler to 0 for BI_RLE8 formats
    // as a kludge to make Mplayer and Videdit play the files.
    // Just prior to 1.1 release, we found this broke Premiere,
    // so now (after AVICAP beta is on Compuserve), we change the
    // fccHandler to "MRLE".  Just ask Todd...
    // And now, at RC1, we change it again to "RLE ", Just ask Todd...
    if (strhdr.fccHandler == BI_RLE8)
        strhdr.fccHandler = mmioFOURCC('R', 'L', 'E', ' ');

    //strhdr.dwFlags = 0L;
   #ifdef NEW_COMPMAN
    //strhdr.wPriority = 0L;
    //strhdr.wLanguage = 0L;
   #else
    //strhdr.dwPriority = 0L;
   #endif

    //strhdr.dwInitialFrames = 0L;
    strhdr.dwScale = aviHdr.dwMicroSecPerFrame;
    strhdr.dwRate = 1000000L;
    //strhdr.dwStart = 0L;
    strhdr.dwLength = lpcs->dwVideoChunkCount;        /* Needs to get filled in! */
    strhdr.dwQuality = (DWORD) -1L;         /* !!! ICQUALITY_DEFAULT */
    //strhdr.dwSampleSize = 0L;

    //
    // Write stream header data
    //
    ck.ckid = ckidSTREAMHEADER;
    if (mmioCreateChunk(lpcs->hmmio,&ck,0) ||
        mmioWrite(lpcs->hmmio, (LPBYTE)&strhdr, sizeof(strhdr)) != sizeof(strhdr) ||
        mmioAscend(lpcs->hmmio, &ck, 0))
        goto FileError;

    /*
    **  !!! dont write palette for full color?
    */
    if (lpBitsInfoOut->bmiHeader.biBitCount > 8)
        lpBitsInfoOut->bmiHeader.biClrUsed = 0;

    /* Create DIB header chunk */
    ck.cksize = lpBitsInfoOut->bmiHeader.biSize +
                           lpBitsInfoOut->bmiHeader.biClrUsed *
                           sizeof(RGBQUAD);
    ck.ckid = ckidSTREAMFORMAT;
    if (mmioCreateChunk(lpcs->hmmio,&ck,0))
         goto FileError;

    /* Write DIB header data */
    if (mmioWrite(lpcs->hmmio, (LPBYTE)&lpBitsInfoOut->bmiHeader,
                               lpBitsInfoOut->bmiHeader.biSize) !=
             (LONG) lpBitsInfoOut->bmiHeader.biSize)
         goto FileError;

    if (lpBitsInfoOut->bmiHeader.biClrUsed > 0) {
        // Get Palette info
        if ((ii = GetPaletteEntries(lpcs->hPalCurrent, 0,
                                (UINT) lpBitsInfoOut->bmiHeader.biClrUsed,
                                (LPPALETTEENTRY) argbq)) !=
                    (UINT)lpBitsInfoOut->bmiHeader.biClrUsed)
            goto FileError;

	// Reorder the palette from PALETTEENTRY order to RGBQUAD order
	// by swapping the red and blue palette entries.
        //for (ii = 0; ii < lpBitsInfoOut->bmiHeader.biClrUsed; ++ii)
        while (ii--)
            SWAPTYPE(argbq[ii].rgbRed, argbq[ii].rgbBlue, BYTE);


        // Write Palette Info
        dw = sizeof(RGBQUAD) * lpBitsInfoOut->bmiHeader.biClrUsed;
        if (mmioWrite(lpcs->hmmio, (LPBYTE)argbq, dw) != (long)dw)
            goto FileError;
    }

    if (mmioAscend(lpcs->hmmio, &ck, 0))
         goto FileError;

    // ADD FOURCC stuff here!!! for Video stream

    // Ascend out of stream header
    if (mmioAscend(lpcs->hmmio, &ckStream, 0))
         goto FileError;

    /* If sound is enabled, then write WAVE header */
    if (fSound) {

         /* Create stream header list */
         ckStream.cksize = 0;
         ckStream.fccType = listtypeSTREAMHEADER;
         if (mmioCreateChunk(lpcs->hmmio,&ckStream,MMIO_CREATELIST))
             goto FileError;

         ZeroMemory (&strhdr, sizeof(strhdr));
         strhdr.fccType = streamtypeAUDIO;
         strhdr.fccHandler = 0L;
         strhdr.dwFlags = 0L;
        #ifdef NEW_COMPMAN
         strhdr.wPriority = 0L;
         strhdr.wLanguage = 0L;
        #else
         strhdr.dwPriority  = 0L;
        #endif
         strhdr.dwInitialFrames = 0L;
         strhdr.dwScale = lpcs->lpWaveFormat->nBlockAlign;
         strhdr.dwRate = lpcs->lpWaveFormat->nAvgBytesPerSec;
         strhdr.dwStart = 0L;
         strhdr.dwLength =  lpcs->dwWaveBytes /
                        lpcs->lpWaveFormat->nBlockAlign;
         strhdr.dwQuality = (DWORD)-1L;    /* !!! ICQUALITY_DEFAULT */
         strhdr.dwSampleSize = lpcs->lpWaveFormat->nBlockAlign;

         ck.ckid = ckidSTREAMHEADER;
         if (mmioCreateChunk(lpcs->hmmio,&ck,0) ||
             mmioWrite(lpcs->hmmio, (LPBYTE)&strhdr, sizeof(strhdr)) != sizeof(strhdr) ||
             mmioAscend(lpcs->hmmio, &ck, 0))
             goto FileError;

         ck.cksize = (LONG) GetSizeOfWaveFormat ((LPWAVEFORMATEX) lpcs->lpWaveFormat);
         ck.ckid = ckidSTREAMFORMAT;
         if (mmioCreateChunk(lpcs->hmmio,&ck,0) ||
             mmioWrite(lpcs->hmmio, (LPBYTE)lpcs->lpWaveFormat, ck.cksize) != (LONG) ck.cksize ||
             mmioAscend(lpcs->hmmio, &ck, 0))
             goto FileError;

         /* Ascend out of stream header */
         if (mmioAscend(lpcs->hmmio, &ckStream, 0))
             goto FileError;
    }

    // ADD FOURCC stuff here!!! for entire file
    DSTATUS(lpcs, "Writing Info chunks");
    if (lpcs->lpInfoChunks) {
        DSTATUS(lpcs, "Writing Info chunks");
        if (mmioWrite (lpcs->hmmio, lpcs->lpInfoChunks, lpcs->cbInfoChunks) !=
                lpcs->cbInfoChunks)
            goto FileError;
    }

    /* ascend from the Header list */
    if (mmioAscend(lpcs->hmmio, &ckList, 0))
         goto FileError;


    ck.ckid = ckidAVIPADDING;
    if (mmioCreateChunk(lpcs->hmmio,&ck,0))
         goto FileError;

    // The data must begin at offset lpcs->dwAVIHdrSize.
    // To create a valid RIFF file we must write the LIST/AVI chunk before
    // this point.  Hence we end the junk section at the end of the header
    // leaving room for the LIST chunk header.
    mmioSeek(lpcs->hmmio, lpcs->dwAVIHdrSize - 3 * sizeof(DWORD), SEEK_SET);

    if (mmioAscend(lpcs->hmmio, &ck, 0))
         goto FileError;

    DSTATUS(lpcs, "Writing Movie LIST");

    /* Start the movi list */
    ckList.cksize = 0;
    ckList.fccType = listtypeAVIMOVIE;
    if (mmioCreateChunk(lpcs->hmmio,&ckList,MMIO_CREATELIST))
         goto FileError;

    // Force the chunk to end on the next word boundary
    dprintf("IndexStartOffset = %8X\n", dwDataEnd);
    mmioSeek(lpcs->hmmio, dwDataEnd + (dwDataEnd & 1L), SEEK_SET);

    /* Ascend out of the movi list and the RIFF chunk so that */
    /* the sizes can be fixed */
    mmioAscend(lpcs->hmmio, &ckList, 0);

    /*
    ** Now write index out!
    */
    DSTATUS(lpcs, "Writing Index...");
    WriteIndex(lpcs, fWroteJunkChunks);

    lpcs->fFileCaptured = TRUE;     // we got a good file, allow editing of it
    goto Success;

FileError:
    lpcs->fFileCaptured = fRet = FALSE;      // bogus file - no editing allowed

Success:
    DSTATUS(lpcs, "Freeing Index...");
    FiniIndex (lpcs);
    mmioAscend(lpcs->hmmio, &ckRiff, 0);

    mmioSeek(lpcs->hmmio, 0, SEEK_END);

    mmioFlush(lpcs->hmmio, 0);

    // Close the file
    mmioClose(lpcs->hmmio, 0);
    lpcs->hmmio = NULL;

    return fRet;
}

//
// Prepends dummy frame entries to the current valid video frame.
// Bumps the index, but does not actually trigger a write operation.
// nCount is a count of the number of frames to write
// Returns: TRUE on a successful write

BOOL WINAPI AVIWriteDummyFrames (
    LPCAPSTREAM lpcs,
    UINT        nCount,
    LPUINT      lpuError,
    LPBOOL      lpbPending)
{
    DWORD  dwBytesToWrite;
    DWORD  dwType;
    LPRIFF priff;
    UINT   jj;

    *lpbPending = FALSE;
    *lpuError = 0;
    if ( ! nCount)
        return TRUE;

    // create a buffer full of dummy chunks to act as placeholders
    // for the dropped frames
    //
    dwType = MAKEAVICKID(cktypeDIBbits, 0);
    if (lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RLE8)
        dwType = MAKEAVICKID(cktypeDIBcompressed, 0);

    // dont try to write more than 1 'sector' worth of dummy
    // frames
    //
    dwBytesToWrite = nCount * sizeof(RIFF);
    if (dwBytesToWrite > lpcs->dwBytesPerSector)
    {
#ifdef DEBUG
	UINT n = nCount;
#endif
        dwBytesToWrite = lpcs->dwBytesPerSector;
#ifdef DEBUG
        nCount = dwBytesToWrite / sizeof(RIFF);
	assert(nCount*sizeof(RIFF) == dwBytesToWrite);
	dprintf("Forced to reduce dummy frames from %d to %d", n, nCount);
#endif
    }

    // create index entries for the dummy chunks
    //
    for (jj = 0; jj < nCount-1; ++jj)
        IndexVideo (lpcs, IS_DUMMY_CHUNK, FALSE);
    IndexVideo (lpcs, IS_DUMMY_CHUNK | IS_GRANULAR_CHUNK, FALSE);

    // fill in the drop frame buffer with dummy frames
    //
    priff = (LPRIFF)lpcs->lpDropFrame;
    for (jj = 0; jj < nCount; ++jj, ++priff)
    {
        priff->dwSize  = 0;
        priff->dwType  = dwType;
    }

    //
    // cant use a single dummy frame buffer when we are doing async
    // write because we cant write 'n' dummy frames to the buffer
    // if it is currently already queued to an IO.
    //
    // perhaps several dummy frames?  1 frame, 2 frames, 3 frames, etc
    // create dynamically?
    //

    // write out the dummy frames
    //
    AuxDebugEx (3, DEBUGLINE "DummyFrames  Count=%d, ToWrite=%d\r\n",
                nCount, dwBytesToWrite);

    *lpuError = AVIWrite (lpcs,
                          lpcs->lpDropFrame,
                          dwBytesToWrite,
                          (UINT)-1,  // force sync completion
                          ASYNC_BUF_DROP,
                          lpbPending);
    return !(*lpuError);
}

// Writes compressed or uncompressed frames to the AVI file
// returns TRUE if no error, FALSE if end of file.
//
BOOL WINAPI AVIWriteVideoFrame (
    LPCAPSTREAM lpcs,
    LPBYTE      lpData,
    DWORD       dwBytesUsed,
    BOOL        fKeyFrame,
    UINT        uIndex,
    UINT        nDropped,
    LPUINT      lpuError,
    LPBOOL      lpbPending)
{
    DWORD  dwBytesToWrite;
    LPRIFF priff;

    *lpuError = 0;
    *lpbPending = FALSE;
    if (!IndexVideo (lpcs,
                dwBytesUsed | (nDropped ? 0 : IS_GRANULAR_CHUNK),
                fKeyFrame))
        return FALSE;

    // adjust the size field of the RIFF chunk that preceeds the
    // data to be written
    //
    priff = ((LPRIFF)lpData)-1;
    priff->dwSize = dwBytesUsed;
    dwBytesUsed += dwBytesUsed & 1;
    dwBytesToWrite = dwBytesUsed + sizeof(RIFF);

    if (nDropped)
    {
        UINT  jj;
        DWORD dwType;

        // determine the 'type' of the dummy chunks
        //
        dwType = MAKEAVICKID(cktypeDIBbits, 0);
        if (lpcs->lpBitsInfo->bmiHeader.biCompression == BI_RLE8)
            dwType = MAKEAVICKID(cktypeDIBcompressed, 0);

        // dont try to write more than 1 'sector' worth of dummy
        // frames
        //
        if (nDropped > (lpcs->dwBytesPerSector / sizeof(RIFF)))
            nDropped = lpcs->dwBytesPerSector / sizeof(RIFF);

        // create index entries for the dummy chunks
        //
        for (jj = 0; jj < nDropped-1; ++jj)
            IndexVideo (lpcs, IS_DUMMY_CHUNK, FALSE);

        IndexVideo (lpcs, IS_DUMMY_CHUNK | IS_GRANULAR_CHUNK, FALSE);

        // fill in the drop frame buffer with dummy frames
        //
        priff = (LPRIFF)(lpData + dwBytesToWrite - sizeof(RIFF));
        for (jj = 0; jj < nDropped; ++jj, ++priff)
        {
            priff->dwSize  = 0;
            priff->dwType  = dwType;
        }
        dwBytesToWrite += nDropped * sizeof(RIFF);
    }

    // AviWrite will write the data and create any trailing junk
    // that is necessary
    //

    // write out the chunk, video data, and possibly the junk chunk
    //
    AuxDebugEx (3, DEBUGLINE "Calling AVIWrite - Video=%8x dw=%8x\r\n",
                (LPBYTE)lpData - sizeof(RIFF), dwBytesToWrite);

    *lpuError = AVIWrite (lpcs,
                          (LPBYTE)lpData - sizeof(RIFF),
                          dwBytesToWrite,
                          uIndex,
                          ASYNC_BUF_VIDEO,
                          lpbPending);
    return !(*lpuError);
}

// New for Chicago, align audio buffers on wChunkGranularity boundaries!
//
BOOL WINAPI AVIWriteAudio (
    LPCAPSTREAM lpcs,
    LPWAVEHDR   lpwh,
    UINT        uIndex,
    LPUINT      lpuError,
    LPBOOL      lpbPending)
{
    DWORD  dwBytesToWrite;
    LPRIFF priff;

    *lpuError = 0;
    *lpbPending = FALSE;

    // change the dwSize field in the RIFF chunk
    priff = ((LPRIFF)lpwh->lpData) -1;
    priff->dwSize = lpwh->dwBytesRecorded;

    if ( ! IndexAudio (lpcs, lpwh->dwBytesRecorded | IS_GRANULAR_CHUNK))
        return FALSE;

    // update total bytes of wave audio recorded
    //
    lpcs->dwWaveBytes += lpwh->dwBytesRecorded;

    // pad the data to be written to a WORD (16 bit) boundary
    //
    lpwh->dwBytesRecorded += lpwh->dwBytesRecorded & 1;
    dwBytesToWrite = lpwh->dwBytesRecorded + sizeof(RIFF);

    // write out the chunk, audio data, and possibly the junk chunk
    AuxDebugEx (3, DEBUGLINE "Audio=%8x dw=%8x\r\n",
                lpwh->lpData - sizeof(RIFF), dwBytesToWrite);
    *lpuError = AVIWrite (lpcs,
                          lpwh->lpData - sizeof(RIFF),
                          dwBytesToWrite,
                          uIndex,
                          ASYNC_BUF_AUDIO,
                          lpbPending);
    return !(*lpuError);
}
    #endif  //---------------- USE_AVIFILE ----------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\cappal.h ===
/****************************************************************************
 *
 *   cappal.h
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992-1994 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

// Structure used when capturing a palette
typedef struct tagCAPPAL {
    WORD                wNumFrames;
    WORD                wNumColors;
    LPBYTE              lpBits;
    LPBYTE              lp16to8;
    VIDEOHDR            vHdr;
    BITMAPINFOHEADER    bi16;
    LPHISTOGRAM         lpHistogram;
    LPBITMAPINFO        lpbiSave;
} CAPPAL, FAR * LPCAPPAL;

BOOL PalInit (LPCAPSTREAM lpcs);
void PalFini (LPCAPSTREAM lpcs);
void PalDeleteCurrentPalette (LPCAPSTREAM lpcs);
BOOL PalGetPaletteFromDriver (LPCAPSTREAM lpcs);
DWORD PalSendPaletteToDriver (LPCAPSTREAM lpcs, HPALETTE hpal, LPBYTE lpXlateTable);
HPALETTE CopyPalette (HPALETTE hpal);
DWORD CapturePaletteInit (LPCAPSTREAM lpcs, LPCAPPAL lpcp);
DWORD CapturePaletteFini (LPCAPSTREAM lpcs, LPCAPPAL lpcp);
DWORD CapturePaletteFrames (LPCAPSTREAM lpcs, LPCAPPAL lpCapPal, int nCount);
BOOL CapturePaletteAuto (LPCAPSTREAM lpcs, int nCount, int nColors);
BOOL CapturePaletteManual (LPCAPSTREAM lpcs, BOOL fGrab, int nColors);
void CapturePaletteDialog (LPCAPSTREAM lpcs);
LONG FAR PASCAL EXPORT cappalDlgProc(HWND hwnd, unsigned msg, UINT wParam, LONG lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\dibmap.c ===
/****************************************************************************
 *
 *   dibmap.c
 *
 *   Histrogram and optimal palette processing module.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <windows.h>
#include <win32.h>
#include "dibmap.h"

#ifndef _WIN32
extern NEAR PASCAL MemCopy(LPVOID,LPVOID,DWORD);
#endif

extern NEAR PASCAL MemFill(LPVOID,DWORD,BYTE);

void Histogram24(BYTE huge *pb, int dx, int dy, UINT WidthBytes, LPHISTOGRAM lpHistogram);
void Histogram16(BYTE huge *pb, int dx, int dy, UINT WidthBytes, LPHISTOGRAM lpHistogram);
void Histogram8(BYTE huge *pb, int dx, int dy, UINT WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors);
void Histogram4(BYTE huge *pb, int dx, int dy, UINT WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors);
void Histogram1(BYTE huge *pb, int dx, int dy, UINT WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors);

void Reduce24(BYTE huge *pbIn, int dx, int dy, UINT cbIn, BYTE huge *pbOut, UINT cbOut, LPBYTE lp16to8);
void Reduce16(BYTE huge *pbIn, int dx, int dy, UINT cbIn, BYTE huge *pbOut, UINT cbOut, LPBYTE lp16to8);
void Reduce8(BYTE huge *pbIn, int dx, int dy, UINT cbIn, BYTE huge *pbOut, UINT cbOut, LPBYTE lp8to8);
void Reduce4(BYTE huge *pbIn, int dx, int dy, UINT cbIn, BYTE huge *pbOut, UINT cbOut, LPBYTE lp8to8);
void Reduce1(BYTE huge *pbIn, int dx, int dy, UINT cbIn, BYTE huge *pbOut, UINT cbOut, LPBYTE lp8to8);

//
//  InitHistogram
//
//  create a zero'ed histogram table, or initialize a existing table
//  to all zeros.
//
LPHISTOGRAM InitHistogram(LPHISTOGRAM lpHistogram)
{
    if (lpHistogram == NULL)
        lpHistogram = (LPVOID)GlobalAllocPtr(GHND,32768l*sizeof(DWORD));

#if 0
    if (lpHistogram)
        MemFill(lpHistogram, 32768l * sizeof(DWORD), 0);
#endif

    return lpHistogram;
}

//
//  FreeHistogram
//
//  free a histogram table
//
void FreeHistogram(LPHISTOGRAM lpHistogram)
{
    GlobalFreePtr(lpHistogram);
}

//
//  DibHistogram
//
//  take all colors in a dib and increment its entry in the Histogram table
//
//  supports the following DIB formats: 1,4,8,16,24
//
BOOL DibHistogram(LPBITMAPINFOHEADER lpbi, LPBYTE lpBits, int x, int y, int dx, int dy, LPHISTOGRAM lpHistogram)
{
    int             i;
    UINT            WidthBytes;
    RGBQUAD FAR *   prgbq;
    WORD            argb16[256];

    if (lpbi == NULL || lpHistogram == NULL)
        return FALSE;

    if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
        lpbi->biClrUsed = (1 << (int)lpbi->biBitCount);

    if (lpBits == NULL)
        lpBits = (LPBYTE)lpbi + (int)lpbi->biSize + (int)lpbi->biClrUsed*sizeof(RGBQUAD);

    WidthBytes = (UINT)((lpbi->biBitCount * lpbi->biWidth + 7) / 8 + 3) & ~3;

    ((BYTE huge *)lpBits) += (DWORD)y*WidthBytes + ((x*(int)lpbi->biBitCount)/8);

    if (dx < 0 || dx > (int)lpbi->biWidth)
        dx = (int)lpbi->biWidth;

    if (dy < 0 || dy > (int)lpbi->biHeight)
        dy = (int)lpbi->biHeight;

    if ((int)lpbi->biBitCount <= 8)
    {
        prgbq = (LPVOID)((LPBYTE)lpbi + lpbi->biSize);

        for (i=0; i<(int)lpbi->biClrUsed; i++)
        {
            argb16[i] = RGB16(prgbq[i].rgbRed,prgbq[i].rgbGreen,prgbq[i].rgbBlue);
        }

        for (i=(int)lpbi->biClrUsed; i<256; i++)
        {
            argb16[i] = 0x0000;     // just in case!
        }
    }

    switch ((int)lpbi->biBitCount)
    {
        case 24:
            Histogram24(lpBits, dx, dy, WidthBytes, lpHistogram);
            break;

        case 16:
            Histogram16(lpBits, dx, dy, WidthBytes, lpHistogram);
            break;

        case 8:
            Histogram8(lpBits, dx, dy, WidthBytes, lpHistogram, argb16);
            break;

        case 4:
            Histogram4(lpBits, dx, dy, WidthBytes, lpHistogram, argb16);
            break;

        case 1:
            Histogram1(lpBits, dx, dy, WidthBytes, lpHistogram, argb16);
            break;
    }

    return TRUE;
}

//
// will convert the given DIB to a 8bit DIB with the specifed palette
//
HANDLE DibReduce(LPBITMAPINFOHEADER lpbiIn, LPBYTE pbIn, HPALETTE hpal, LPBYTE lp16to8)
{
    HANDLE              hdib;
    int                 nPalColors;
    int                 nDibColors;
    UINT                cbOut;
    UINT                cbIn;
    BYTE                xlat[256];
    BYTE HUGE *         pbOut;
    RGBQUAD FAR *       prgb;
    DWORD               dwSize;
    int                 i;
    int                 dx;
    int                 dy;
    PALETTEENTRY        pe;
    LPBITMAPINFOHEADER  lpbiOut;

    dx    = (int)lpbiIn->biWidth;
    dy    = (int)lpbiIn->biHeight;
    cbIn  = ((lpbiIn->biBitCount*dx+7)/8+3)&~3;
    cbOut = (dx+3)&~3;

#ifdef _WIN32
    // careful with GetObject in Win32: this (counter-intuitively) writes
    // a short not an INT for the number of colours
    // (despite being passed a 32 bit variable)
    // BUT the code uses INTs more efficiently
    // So we must initialize the variable to 0 to clear the high 16bits
    nPalColors = 0;
#endif
    GetObject(hpal, sizeof(nPalColors), (LPVOID)&nPalColors);
    nDibColors = (int)lpbiIn->biClrUsed;

    if (nDibColors == 0 && lpbiIn->biBitCount <= 8)
        nDibColors = (1 << (int)lpbiIn->biBitCount);

    if (pbIn == NULL)
        pbIn = (LPBYTE)lpbiIn + (int)lpbiIn->biSize + nDibColors*sizeof(RGBQUAD);

    dwSize = (DWORD)cbOut * dy;

    hdib = GlobalAlloc(GMEM_MOVEABLE,sizeof(BITMAPINFOHEADER)
        + nPalColors*sizeof(RGBQUAD) + dwSize);

    if (!hdib)
        return NULL;

    lpbiOut = (LPVOID)GlobalLock(hdib);
    lpbiOut->biSize         = sizeof(BITMAPINFOHEADER);
    lpbiOut->biWidth        = lpbiIn->biWidth;
    lpbiOut->biHeight       = lpbiIn->biHeight;
    lpbiOut->biPlanes       = 1;
    lpbiOut->biBitCount     = 8;
    lpbiOut->biCompression  = BI_RGB;
    lpbiOut->biSizeImage    = dwSize;
    lpbiOut->biXPelsPerMeter= 0;
    lpbiOut->biYPelsPerMeter= 0;
    lpbiOut->biClrUsed      = nPalColors;
    lpbiOut->biClrImportant = 0;

    pbOut = (LPBYTE)lpbiOut + (int)lpbiOut->biSize + nPalColors*sizeof(RGBQUAD);
    prgb  = (LPVOID)((LPBYTE)lpbiOut + (int)lpbiOut->biSize);

    for (i=0; i<nPalColors; i++)
    {
        GetPaletteEntries(hpal, i, 1, &pe);

        prgb[i].rgbRed      = pe.peRed;
        prgb[i].rgbGreen    = pe.peGreen;
        prgb[i].rgbBlue     = pe.peBlue;
        prgb[i].rgbReserved = 0;
    }

    if ((int)lpbiIn->biBitCount <= 8)
    {
        prgb = (LPVOID)((LPBYTE)lpbiIn + lpbiIn->biSize);

        for (i=0; i<nDibColors; i++)
            xlat[i] = lp16to8[RGB16(prgb[i].rgbRed,prgb[i].rgbGreen,prgb[i].rgbBlue)];

        for (; i<256; i++)
            xlat[i] = 0;
    }

    switch ((int)lpbiIn->biBitCount)
    {
        case 24:
            Reduce24(pbIn, dx, dy, cbIn, pbOut, cbOut, lp16to8);
            break;

        case 16:
            Reduce16(pbIn, dx, dy, cbIn, pbOut, cbOut, lp16to8);
            break;

        case 8:
            Reduce8(pbIn, dx, dy, cbIn, pbOut, cbOut, xlat);
            break;

        case 4:
            Reduce4(pbIn, dx, dy, cbIn, pbOut, cbOut, xlat);
            break;

        case 1:
            Reduce1(pbIn, dx, dy, cbIn, pbOut, cbOut, xlat);
            break;
    }

    return hdib;
}

///////////////////////////////////////////////////////////////////////////////
//  cluster.c
///////////////////////////////////////////////////////////////////////////////

#define  IN_DEPTH    5               // # bits/component kept from input
#define  IN_SIZE     (1 << IN_DEPTH) // max value of a color component

typedef enum { red, green, blue } color;

typedef struct tagCut {
   int cutpoint;
   color cutaxis;
   } Cut;

typedef struct tagColorBox {    // from cluster.c
   struct tagColorBox *next;                /* pointer to next box */
   int   rmin, rmax, gmin, gmax, bmin, bmax;    /* bounding box */
   long variance, wt;                           /* weighted variance */
   long sum[3];                                 /* sum of values */
   } ColorBox;

static int InitBoxes(int nBoxes);
static void DeleteBoxes(void);
static int SplitBoxAxis(ColorBox *box, Cut cutaxis);
static void ShrinkBox(ColorBox *box);
static int ComputePalette(LPHISTOGRAM lpHistogram, LPBYTE lp16to8, LPPALETTEENTRY palette);
static COLORREF DetermineRepresentative(ColorBox *box, int palIndex);
static Cut FindSplitAxis(ColorBox *box);
static void SplitBox(ColorBox *box);
static void SortBoxes(void);

HANDLE hBoxes;
ColorBox *UsedBoxes;
ColorBox *FreeBoxes;
LPBYTE   glp16to8;

#ifdef _WIN32

/*
 * to avoid all this 16 bit assembler with minimal changes to the
 * rest of the code the Win32 version will use a global pointer set by
 * UseHistogram and accessed by the hist() and IncHistogram macros.
 */
DWORD HUGE* glpHistogram;

#define UseHistogram(p)	(glpHistogram = (p))

#define hist(r,g,b)  ((DWORD HUGE *)glpHistogram)[(WORD)(b) | ((WORD)(g)<<IN_DEPTH) | ((WORD)(r)<<(IN_DEPTH*2))]

#define IncHistogram(w) if (lpHistogram[(UINT)(w)] < 0xFFFFFFFF) {  \
			    lpHistogram[(UINT)(w)]++;\
			}

#else

#define hist(r,g,b)  GetHistogram((BYTE)(r),(BYTE)(g),(BYTE)(b))



#pragma optimize ("", off)
//
//  set FS == lpHistogram.sel, so we can get at it quickly!
//
void NEAR PASCAL UseHistogram(LPHISTOGRAM lpHistogram)
{
    _asm {
        mov     ax,word ptr lpHistogram[2]

        _emit   08Eh                     ; mov  fs,ax
        _emit   0E0h
    }
}



//
//  get the DWORD histogram count of a RGB
//
DWORD NEAR _FASTCALL GetHistogram(BYTE r, BYTE g, BYTE b)
{

    if (0)              // avoid compiler warning NO RETURN VALUE
        return 0;

    _asm {
        ;
        ; on entry al=r, dl=g, bl=b  [0-31]
        ;
        ; map to a RGB16
        ;
        xor     ah,ah
        shl     ax,5
        or      al,dl
        shl     ax,5
        or      al,bl

        ; now ax = RGB16

        _emit 66h _asm xor bx,bx           ; xor ebx,ebx
                  _asm mov bx,ax           ; mov  bx,ax
        _emit 66h _asm shl bx,2            ; shl ebx,2

        _emit 64h _asm _emit 67h           ; mov dx,fs:[ebx][2]
        _emit 8Bh _asm _emit 53h
        _emit 02h

        _emit 64h _asm _emit 67h           ; mov ax,fs:[ebx][0]
        _emit 8Bh _asm _emit 03h
    }
}

//
//  increment the histogram count of a RGB16
//
//
//  #define IncHistogram(w) if (lpHistogram[(WORD)(w)] < 0xFFFFFFFF)
//                              lpHistogram[(WORD)(w)]++;
//
void NEAR _FASTCALL IncHistogram(WORD rgb16)
{
    _asm {
        ;
        ; on entry ax = rgb16
        ;
        _emit 66h _asm xor bx,bx           ; xor ebx,ebx
                  _asm mov bx,ax           ; mov bx,ax
        _emit 66h _asm shl bx,2            ; shl ebx,2

        _emit 64h _asm _emit 67h           ; cmp dword ptr fs:[ebx], -1
        _emit 66h _asm _emit 83h
        _emit 3Bh _asm _emit 0FFh

        _emit 74h _asm _emit 05h           ; je  short @f

        _emit 64h _asm _emit 67h           ; inc dword ptr fs:[ebx]
        _emit 66h _asm _emit 0FFh
        _emit 03h
    }
}

#pragma optimize ("", on)

// !!! C8 generates a Jump into the middle of a 2 byte instruction
// 
#pragma optimize ("", off)

#endif  //_WIN32

//
//  HistogramPalette
//
//  given a histogram, will reduce it to 'nColors' number of colors.
//  returns a optimal palette.  if specifed lp16to8 will contain the
//  translate table from RGB16 to the palette index.
//
//  you can specify lpHistogram as lp16to8
//
HPALETTE HistogramPalette(LPHISTOGRAM lpHistogram, LPBYTE lp16to8, int nColors)
{
    UINT     w;
    DWORD    dwMax;
    COLORREF rgb;
    ColorBox *box;
    int i;
    // Had to make this global to prevent VB 2.0 stack explosion
    static struct {
        WORD         palVersion;
        WORD         palNumEntries;
        PALETTEENTRY palPalEntry[256];
    }   pal;

    //
    //  the 'C' code cant handle >64k histogram counts.
    //  !!!fix this
    //
    for (dwMax=0,w=0; w<0x8000; w++)
        dwMax = max(dwMax,lpHistogram[w]);

    while (dwMax > 0xFFFFl)
    {
        for (w=0; w<0x8000; w++)
            lpHistogram[w] /= 2;

        dwMax /= 2;
    }

    if (!InitBoxes(min(nColors, 236)))
        return NULL;

    UseHistogram(lpHistogram);
    glp16to8 = lp16to8;

    /* while there are free boxes left, split the largest */

    i = 0;

    do {
       i++;
       SplitBox(UsedBoxes);
       }
    while (FreeBoxes && UsedBoxes->variance);

    SortBoxes();

    i=0;

    //
    // add some standard colors to the histogram
    //
    if (nColors > 236)
    {
        HDC hdc;
	HPALETTE hpal;

        hdc = GetDC(NULL);

        if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
        {
        GetSystemPaletteEntries(hdc, 0,   10, &pal.palPalEntry[0]);
        GetSystemPaletteEntries(hdc, 246, 10, &pal.palPalEntry[246]);

        i = 10;
        } else {	// we're a true colour device, so get the system
			// colours from the default palette.
	    hpal = GetStockObject(DEFAULT_PALETTE);
            GetPaletteEntries(hpal, 0, 10, &pal.palPalEntry[0]);
            GetPaletteEntries(hpal, 10, 10, &pal.palPalEntry[246]);
            i = 10;
	}

        ReleaseDC(NULL, hdc);
    }

    // probably not needed on C-only versions (NT).
    UseHistogram(lpHistogram); // Register FS trashed by above!


    /* Generate the representitives and the associated Palette mapping */
    /* NOTE:  Might loop less than nColors times.                      */
    for (box = UsedBoxes; box; box = box->next, i++)
    {
        rgb = DetermineRepresentative(box, i);
        pal.palPalEntry[i].peRed   = GetRValue(rgb);
        pal.palPalEntry[i].peGreen = GetGValue(rgb);
        pal.palPalEntry[i].peBlue  = GetBValue(rgb);
        pal.palPalEntry[i].peFlags = 0;
    }

    DeleteBoxes();

    if (nColors > 236)
    {
        for (; i<246; i++)
        {
            pal.palPalEntry[i].peRed   = 0;
            pal.palPalEntry[i].peGreen = 0;
            pal.palPalEntry[i].peBlue  = 0;
            pal.palPalEntry[i].peFlags = 0;
        }

        i = 256;
    }

    glp16to8 = NULL;

    pal.palVersion    = 0x300;
    pal.palNumEntries = (WORD) i;
    return CreatePalette((LPLOGPALETTE)&pal);
}

#pragma optimize ("", on)

static void SortBoxes()
{
    ColorBox *box;
    ColorBox *newList;
    ColorBox *insBox;
    ColorBox *nextBox;

    newList = UsedBoxes;
    nextBox = newList->next;
    newList->next = NULL;

    for (box = nextBox; box; box = nextBox) { // just an insertion sort...
            nextBox = box->next;
            if (box->wt > newList->wt) {
                    box->next = newList;
                    newList = box;
            } else {
                    for (insBox = newList;
                            insBox->next && (box->wt < insBox->next->wt);
                            insBox = insBox->next) ;
                    box->next = insBox->next;
                    insBox->next = box;
            }
    }

    UsedBoxes = newList;
}


/*
   allocate space for nBoxes boxes, set up links.  On exit UsedBoxes
   points to one box, FreeBoxes points to remaining (nBoxes-1) boxes.
   return 0 if successful.
*/

static BOOL InitBoxes(int nBoxes)
{
    int i;

    hBoxes = LocalAlloc(LHND, nBoxes*sizeof(ColorBox));
    if (!hBoxes)
        return FALSE;

    UsedBoxes = (ColorBox*)LocalLock(hBoxes);
    FreeBoxes = UsedBoxes + 1;
    UsedBoxes->next = NULL;

    for (i = 0; i < nBoxes - 1; ++i)
    {
        FreeBoxes[i].next = FreeBoxes + i + 1;
    }
    FreeBoxes[nBoxes-2].next = NULL;

    /* save the bounding box */
    UsedBoxes->rmin = UsedBoxes->gmin = UsedBoxes->bmin = 0;
    UsedBoxes->rmax = UsedBoxes->gmax = UsedBoxes->bmax = IN_SIZE - 1;
    UsedBoxes->variance = 9999999;    /* arbitrary large # */

    return TRUE;
}

static void DeleteBoxes()
{
   LocalUnlock(hBoxes);
   LocalFree(hBoxes);
   hBoxes = NULL;
}

static void SplitBox(ColorBox *box)
{
   /*
      split box into two roughly equal halves and update the data structures
      appropriately.
   */
   Cut cutaxis;
   ColorBox *temp, *temp2, *prev;

   cutaxis = FindSplitAxis(box);

   /* split the box along that axis.  If rc != 0 then the box contains
      one color, and should not be split */
   if (SplitBoxAxis(box, cutaxis))
      return;

   /* shrink each of the boxes to fit the points they enclose */
   ShrinkBox(box);
   ShrinkBox(FreeBoxes);

   /* move old box down in list, if necessary */
   if (box->next && box->variance < box->next->variance)
   {
      UsedBoxes = box->next;
      temp = box;
      do {
         prev = temp;
         temp = temp->next;
         } while (temp && temp->variance > box->variance);
      box->next = temp;
      prev->next = box;
   }

   /* insert the new box in sorted order (descending), removing it
      from the free list. */
   if (FreeBoxes->variance >= UsedBoxes->variance)
   {
      temp = FreeBoxes;
      FreeBoxes = FreeBoxes->next;
      temp->next = UsedBoxes;
      UsedBoxes = temp;
   }
   else
   {
      temp = UsedBoxes;
      do {
         prev = temp;
         temp = temp->next;
         } while (temp && temp->variance > FreeBoxes->variance);
      temp2 = FreeBoxes->next;
      FreeBoxes->next = temp;
      prev->next = FreeBoxes;
      FreeBoxes = temp2;
   }
}

static Cut FindSplitAxis(ColorBox *box)
{
        unsigned long   proj_r[IN_SIZE],proj_g[IN_SIZE],proj_b[IN_SIZE];
        unsigned long   f;
        double          currentMax,mean;
        unsigned long   w,w1,m,m1;
        short           r,g,b;
        short           bestCut;
        color           bestAxis;
        Cut             cutRet;
        double          temp1,temp2;

        for (r = 0; r < IN_SIZE; r++) {
                proj_r[r] = proj_g[r] = proj_b[r] = 0;
        }

        w = 0;

        // Project contents of box down onto axes
        for (r = (WORD) box->rmin; r <= (WORD) box->rmax; r++) {
                for (g = (WORD) box->gmin; g <= (WORD) box->gmax; ++g) {
                        for (b = (WORD) box->bmin; b <= (WORD) box->bmax; ++b) {
                                f = hist(r,g,b);
                                proj_r[r] += f;
                                proj_g[g] += f;
                                proj_b[b] += f;
                        }
                }
                w += proj_r[r];
        }

        currentMax = 0.0f;

#define Check_Axis(l,color)                                     \
        m = 0;                                                  \
        for (l = (WORD) box->l##min; l <= (WORD) box->l##max; (l)++) {        \
                m += l * proj_##l[l];                           \
        }                                                       \
        mean = ((double) m) / ((double) w);                     \
                                                                \
        w1 = 0;                                                 \
        m1 = 0;                                                 \
        for (l = (WORD) box->l##min; l <= box->l##max; l++) {          \
                w1 += proj_##l[l];                              \
                if (w1 == 0)                                    \
                        continue;                               \
                if (w1 == w)                                    \
                        break;                                  \
                m1 += l * proj_##l[l];                          \
                temp1 = mean - (((double) m1) / ((double) w1)); \
                temp2 = (((double) w1) / ((double) (w-w1))) * temp1 * temp1; \
                if (temp2 > currentMax) {                       \
                        bestCut = l;                            \
                        bestAxis = color;                       \
                        currentMax = temp2;                     \
                }                                               \
        }

        Check_Axis(r,red);
        Check_Axis(g,green);
        Check_Axis(b,blue);

        cutRet.cutaxis = bestAxis;
        cutRet.cutpoint = bestCut;


        return cutRet;
}

static int SplitBoxAxis(ColorBox *box, Cut cutaxis)
{
   /*
      Split box along splitaxis into two boxes, one of which is placed
      back in box, the other going in the first free box (FreeBoxes)
      If the box only contains one color, return non-zero, else return 0.
   */
   ColorBox *next;

   if ( box->variance == 0)
      return 1;

   /* copy all non-link information to new box */
   next = FreeBoxes->next;
   *FreeBoxes = *box;
   FreeBoxes->next = next;

   switch (cutaxis.cutaxis)
   {
      case red:
         box->rmax = cutaxis.cutpoint;
         FreeBoxes->rmin = cutaxis.cutpoint+1;
         break;
      case green:
         box->gmax = cutaxis.cutpoint;
         FreeBoxes->gmin = cutaxis.cutpoint+1;
         break;
      case blue:
         box->bmax = cutaxis.cutpoint;
         FreeBoxes->bmin = cutaxis.cutpoint+1;
         break;
   }

   return 0;
}

static void ShrinkBox(ColorBox *box)
{
        unsigned long n, sxx, sx2, var, quotient, remainder;
        int r,g,b;
        unsigned long   f;
        unsigned long   proj_r[IN_SIZE],proj_g[IN_SIZE],proj_b[IN_SIZE];

        n = 0;

        for (r = 0; r < IN_SIZE; r++) {
                proj_r[r] = proj_g[r] = proj_b[r] = 0;
        }

        // Project contents of box down onto axes
        for (r = box->rmin; r <= box->rmax; r++) {
                for (g = box->gmin; g <= box->gmax; ++g) {
                        for (b = box->bmin; b <= box->bmax; ++b) {
                                f = hist(r,g,b);
                                proj_r[r] += f;
                                proj_g[g] += f;
                                proj_b[b] += f;
                        }
                }
                n += proj_r[r];
        }

        box->wt = n;
        var = 0;

#define AddAxisVariance(c)                                              \
        sxx = 0; sx2 = 0;                                               \
        for (c = box->c##min; c <= box->c##max; c++) {                  \
                sxx += proj_##c[c] * c * c;                             \
                sx2 += proj_##c[c] * c;                                 \
        }                                                               \
        quotient = sx2 / n; /* This stuff avoids overflow */            \
        remainder = sx2 % n;                                            \
        var += sxx - quotient * sx2 - ((remainder * sx2)/n);

        AddAxisVariance(r);
        AddAxisVariance(g);
        AddAxisVariance(b);

        box->variance = var;
}

static COLORREF DetermineRepresentative(ColorBox *box, int palIndex)
{
   /*
      determines the rgb value to represent the pixels contained in
      box.  nbits is the # bits/component we're allowed to return.
   */
   long f;
   long Rval, Gval, Bval;
   unsigned long total;
   int r, g, b;
   UINT w;

   /* compute the weighted sum of the elements in the box */
   Rval = Gval = Bval = total = 0;
   for (r = box->rmin; r <= box->rmax; ++r)
   {
      for (g = box->gmin; g <= box->gmax; ++g)
      {
         for (b = box->bmin; b <= box->bmax; ++b)
         {
            if (glp16to8)
            {
                w = (UINT)(b) | ((WORD)(g)<<IN_DEPTH) | ((WORD)(r)<<(IN_DEPTH*2));
                glp16to8[w] = (BYTE)palIndex;
            }

            f = hist(r,g,b);
            if (f == 0L)
               continue;

            Rval += f * (long) r;
            Gval += f * (long) g;
            Bval += f * (long) b;

            total += f;
         }
      }
   }

   /* Bias the sum so that we round up at .5 */
   Rval += total / 2;
   Gval += total / 2;
   Bval += total / 2;

   return RGB(Rval*255/total/IN_SIZE, Gval*255/total/IN_SIZE, Bval*255/total/IN_SIZE);
}

///////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
//  write this stuff in ASM!
//
///////////////////////////////////////////////////////////////////////////////

void Histogram24(BYTE HUGE *pb, int dx, int dy, UINT WidthBytes, LPHISTOGRAM lpHistogram)
{
    int x,y;
    BYTE r,g,b;
    UINT w;

    UseHistogram(lpHistogram);

    WidthBytes -= dx*3;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            b = *pb++;
            g = *pb++;
            r = *pb++;
            w = RGB16(r,g,b);
            IncHistogram(w);
        }
        pb += WidthBytes;
    }
}

void Histogram16(BYTE HUGE *pb, int dx, int dy, UINT WidthBytes, LPHISTOGRAM lpHistogram)
{
    int x,y;
    UINT w;

    UseHistogram(lpHistogram);

    WidthBytes -= dx*2;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            w = *((WORD HUGE *)pb)++;
            w &= 0x7FFF;
            IncHistogram(w);
        }
        pb += WidthBytes;
    }
}

void Histogram8(BYTE HUGE *pb, int dx, int dy, UINT WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors)
{
    int x,y;
    UINT w;

    UseHistogram(lpHistogram);

    WidthBytes -= dx;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            w = lpColors[*pb++];
            IncHistogram(w);
        }
        pb += WidthBytes;
    }
}

void Histogram4(BYTE HUGE *pb, int dx, int dy, UINT WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors)
{
    int x,y;
    BYTE b;
    UINT w;

    UseHistogram(lpHistogram);

    WidthBytes -= (dx+1)/2;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<(dx+1)/2; x++)
        {
            b = *pb++;

            w = lpColors[b>>4];
            IncHistogram(w);

            w = lpColors[b&0x0F];
            IncHistogram(w);
        }
        pb += WidthBytes;
    }
}

void Histogram1(BYTE HUGE *pb, int dx, int dy, UINT WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors)
{
    int x,y,i;
    BYTE b;
    UINT w;

    UseHistogram(lpHistogram);

    WidthBytes -= (dx+7)/8;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<(dx+7)/8; x++)
        {
            b = *pb++;

            for (i=0; i<8; i++)
            {
                w = lpColors[b>>7];
                IncHistogram(w);
                b<<=1;
            }
        }
        pb += WidthBytes;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  write this stuff in ASM! too
//  -- if you do - please leave the C version #ifdef _WIN32
//
///////////////////////////////////////////////////////////////////////////////

void Reduce24(BYTE HUGE *pbIn, int dx, int dy, UINT cbIn, BYTE HUGE *pbOut, UINT cbOut, LPBYTE lp16to8)
{
    int x,y;
    BYTE r,g,b;

    cbOut -= dx;
    cbIn  -= dx*3;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            b = *pbIn++;
            g = *pbIn++;
            r = *pbIn++;
            *pbOut++ = lp16to8[RGB16(r,g,b)];
        }
        pbIn += cbIn;
        pbOut+= cbOut;
    }
}

void Reduce16(BYTE huge *pbIn, int dx, int dy, UINT cbIn, BYTE huge *pbOut, UINT cbOut, LPBYTE lp16to8)
{
    int x,y;
    WORD w;

    cbOut -= dx;
    cbIn  -= dx*2;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            w = *((WORD HUGE *)pbIn)++;
            *pbOut++ = lp16to8[w&0x7FFF];
        }
        pbIn += cbIn;
        pbOut+= cbOut;
    }
}

void Reduce8(BYTE HUGE *pbIn, int dx, int dy, UINT cbIn, BYTE HUGE *pbOut, UINT cbOut, LPBYTE lp8to8)
{
    int x,y;

    cbIn  -= dx;
    cbOut -= dx;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            *pbOut++ = lp8to8[*pbIn++];
        }
        pbIn  += cbIn;
        pbOut += cbOut;
    }
}

void Reduce4(BYTE HUGE *pbIn, int dx, int dy, UINT cbIn, BYTE HUGE *pbOut, UINT cbOut, LPBYTE lp8to8)
{
    int x,y;
    BYTE b;

    cbIn  -= (dx+1)/2;
    cbOut -= (dx+1)&~1;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<(dx+1)/2; x++)
        {
            b = *pbIn++;
            *pbOut++ = lp8to8[b>>4];
            *pbOut++ = lp8to8[b&0x0F];
        }
        pbIn  += cbIn;
        pbOut += cbOut;
    }
}

void Reduce1(BYTE HUGE *pbIn, int dx, int dy, UINT cbIn, BYTE HUGE *pbOut, UINT cbOut, LPBYTE lp8to8)
{
    int x,y;
    BYTE b;

    cbIn  -= (dx+7)/8;
    cbOut -= dx;

    for (y=0; y<dy; y++)
    {
        for (x=0; x<dx; x++)
        {
            if (x%8 == 0)
                b = *pbIn++;

            *pbOut++ = lp8to8[b>>7];
            b<<=1;
        }
        pbIn  += cbIn;
        pbOut += cbOut;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\iaverage.h ===
/****************************************************************************
 *
 *   iaverage.h
 *
 *   Image averaging
 *
 *   Copyright (c) 1992-1994 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#ifndef _INC_AVERAGE
#define _INC_AVERAGE

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifndef RC_INVOKED

// -------------------------
//  Structures
// -------------------------

typedef struct tagiAverage {
    BITMAPINFO      bi;                 // Copy of source format
    RGBQUAD         pe[256];            // Copy of color table
    LPBYTE          lpInverseMap;       // rgb15 to palette index
    LPWORD          lpRGB;              // accumulator
    WORD            iCount;             // Count of images accumulated
} IAVERAGE, *PIAVERAGE, FAR *LPIAVERAGE;

BOOL iaverageInit   (LPIAVERAGE FAR * lppia, LPBITMAPINFO lpbi, HPALETTE hPal);
BOOL iaverageFini   (LPIAVERAGE lpia);
BOOL iaverageZero   (LPIAVERAGE lpia);
BOOL iaverageSum    (LPIAVERAGE lpia, LPVOID lpBits);
BOOL iaverageDivide (LPIAVERAGE lpia, LPVOID lpBits);
BOOL CrunchDIB(
    LPIAVERAGE lpia,
    LPBITMAPINFOHEADER  lpbiSrc,    // BITMAPINFO of source
    LPVOID              lpSrc,      // input bits to crunch
    LPBITMAPINFOHEADER  lpbiDst,    // BITMAPINFO of dest
    LPVOID              lpDst);     // output bits to crunch

#endif  /* RC_INVOKED */


#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif    /* __cplusplus */

#endif /* INC_AVERAGE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\dibmap.h ===
/****************************************************************************
 *
 *   dibmap.h
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992-1994 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#ifndef _LPHISTOGRAM_DEFINED
#define _LPHISTOGRAM_DEFINED
typedef DWORD HUGE * LPHISTOGRAM;
#endif

#define RGB16(r,g,b) (\
            (((WORD)(r) >> 3) << 10) |  \
            (((WORD)(g) >> 3) << 5)  |  \
            (((WORD)(b) >> 3) << 0)  )

LPHISTOGRAM     InitHistogram(LPHISTOGRAM lpHistogram);
void            FreeHistogram(LPHISTOGRAM lpHistogram);
HPALETTE        HistogramPalette(LPHISTOGRAM lpHistogram, LPBYTE lp16to8, int nColors);
BOOL            DibHistogram(LPBITMAPINFOHEADER lpbi, LPBYTE lpBits, int x, int y, int dx, int dy, LPHISTOGRAM lpHistogram);
HANDLE          DibReduce(LPBITMAPINFOHEADER lpbi, LPBYTE lpBits, HPALETTE hpal, LPBYTE lp16to8);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\capwin.c ===
/****************************************************************************
 *
 *   capwin.c
 *
 *   Main window proceedure.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 ***************************************************************************/

#define INC_OLE2
#pragma warning(disable:4103)
#include <windows.h>
#include <windowsx.h>
#include <win32.h>
#include <mmsystem.h>
#include <vfw.h>
#include <mmreg.h>
#include <memory.h>

#include "ivideo32.h"
#include "avicapi.h"
#include "cappal.h"
#include "capdib.h"
#include "dibmap.h"

#ifdef UNICODE
#include <stdlib.h>
#endif

// GetWindowLong assignments
#define GWL_CAPSTREAM   0

#define ID_PREVIEWTIMER 9

//#ifdef _DEBUG
#ifdef PLASTIQUE
    #define MB(lpsz) MessageBoxA(NULL, lpsz, "", MB_OK);
#else
    #define MB(lpsz)
#endif


// #if defined _WIN32 && defined CHICAGO
#if defined NO_LONGER_USED

#include <mmdevldr.h>
#include <vmm.h>
#include "mmdebug.h"

#pragma message (SQUAWK "move these defines later")
#define MMDEVLDR_IOCTL_PAGEALLOCATE  7
#define MMDEVLDR_IOCTL_PAGEFREE      8
#define PageContig      0x00000004
#define PageFixed       0x00000008
//end

HANDLE hMMDevLdr = NULL;

/*****************************************************************************

  @doc INTERNAL

  @function HANDLE | OpenMMDEVLDR | Open a file handle to the MMDEVLDR VxD
  in order to access the DeviceIoControl functions.

  @rdesc opens a shared handle to MMDEVLDR

*****************************************************************************/

VOID WINAPI OpenMMDEVLDR(
    void)
{
    AuxDebugEx (5, DEBUGLINE "OpenMMDEVLDR()r\n");

    if (hMMDevLdr)
        return;

    hMMDevLdr = CreateFile(
        "\\\\.\\MMDEVLDR.VXD", // magic name to attach to an already loaded vxd
        GENERIC_WRITE,
        FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_GLOBAL_HANDLE,
        NULL);

    AuxDebugEx (5, DEBUGLINE "OpenMMDEVLDR returns %08Xr\n", hMMDevLdr);
    return;
}

VOID WINAPI CloseMMDEVLDR(
    void)
{
    if (! hMMDevLdr)
        return;

    CloseHandle (hMMDevLdr);
    hMMDevLdr = NULL;
}

/*****************************************************************************

  @doc INTERNAL

  @function DWORD | LinPageLock | Call the VMM service LinPageLock via
   DeviceIoControl through MMDEVLDR.

  @parm DWORD | dwStartPage | Starting page of the linear region to lock.

  @parm DWORD | dwPageCount | Number of 4K pages to lock.

  @parm DWORD | fdwLinPageLock | Flags expected by the VMM service.
   @flag PAGEMAPGLOBAL | Return an alias to the locked region which
    is valid in all process contexts.

  @rdesc Meaningless unless PAGEMAPGLOBAL specified. If it was, then the
   return value is the alias pointer to the start of the linear region
   (NOTE: A *POINTER*, NOT a page address). The pointer will be page
   aligned (i.e. the low 12 bits will be zero.)

*****************************************************************************/

DWORD WINAPI LinPageLock(
    DWORD           dwStartPage,
    DWORD           dwPageCount,
    DWORD           fdwLinPageLock)
{
    LOCKUNLOCKPARMS lup;
    DWORD           dwRet;
    DWORD           cbRet;

    AuxDebugEx (6, DEBUGLINE "LinPageLock(%08x,%08x,%08x)\r\n",
                 dwStartPage, dwPageCount, fdwLinPageLock);

    assert (hMMDevLdr != NULL);
    if (INVALID_HANDLE_VALUE == hMMDevLdr)
        return 0;

    lup.dwStartPage = dwStartPage;
    lup.dwPageCount = dwPageCount;
    lup.fdwOperation= fdwLinPageLock;


    if ( ! DeviceIoControl (hMMDevLdr,
                            MMDEVLDR_IOCTL_LINPAGELOCK,
                            &lup,
                            sizeof(lup),
                            &dwRet,
                            sizeof(dwRet),
                            &cbRet,
                            NULL))
    {
        AuxDebug("LinPageLock failed!!!");
        dwRet = 0;
    }

    return dwRet;
}

/*****************************************************************************

  @doc INTERNAL

  @function DWORD | LinPageUnLock | Call the VMM service LinPageUnLock via
   DeviceIoControl through MMDEVLDR.

  @parm DWORD | dwStartPage | Starting page of the linear region to unlock.

  @parm DWORD | dwPageCount | Number of 4K pages to lock.

  @parm DWORD | fdwLinPageLock | Flags expected by the VMM service.
   @flag PAGEMAPGLOBAL | Return an alias to the locked region which
    is valid in all process contexts.

  @comm
   If PAGEMAPGLOBAL was specified on the <f LinPageLock> call, it must
   also be specified here. In this case, <p dwStartPage> should be the
   page address of the returned alias pointer in global memory.

*****************************************************************************/

void WINAPI LinPageUnLock(
    DWORD           dwStartPage,
    DWORD           dwPageCount,
    DWORD           fdwLinPageLock)
{
    LOCKUNLOCKPARMS lup;

    AuxDebugEx (6, DEBUGLINE "LinPageUnLock (%08x,%08x,%08x)\r\n",
                dwStartPage, dwPageCount, fdwLinPageLock);

    assert (hMMDevLdr != NULL);
    assert (INVALID_HANDLE_VALUE != hMMDevLdr);
    if (INVALID_HANDLE_VALUE == hMMDevLdr)
        return;

    lup.dwStartPage = dwStartPage;
    lup.dwPageCount = dwPageCount;
    lup.fdwOperation = fdwLinPageLock;

    DeviceIoControl (hMMDevLdr,
                     MMDEVLDR_IOCTL_LINPAGEUNLOCK,
                     &lup,
                     sizeof(lup),
                     NULL,
                     0,
                     NULL,
                     NULL);
}

/*+ FreeContigMem
 *
 *-==================================================================*/

VOID FreeContigMem (
    DWORD hMemContig)
{
    DWORD dwRet;
    DWORD cbRet;

    assert (hMMDevLdr != NULL);
    assert (INVALID_HANDLE_VALUE != hMMDevLdr);
    if (INVALID_HANDLE_VALUE == hMMDevLdr)
        return;

    DeviceIoControl (hMMDevLdr,
                     MMDEVLDR_IOCTL_PAGEFREE,
                     &hMemContig,
                     sizeof(hMemContig),
                     &dwRet,
                     sizeof(dwRet),
                     &cbRet,
                     NULL);
}

/*+ AllocContigMem
 *
 *-==================================================================*/

LPVOID AllocContigMem (
    DWORD   cbSize,
    LPDWORD phMemContig)
{
    struct _memparms {
       DWORD flags;
       DWORD nPages;
       } mp;
    struct _memret {
       LPVOID lpv;
       DWORD  hMem;
       DWORD  nPages;
       DWORD  dwPhys;
       } mr;
    DWORD  cbRet;

    mr.lpv = NULL;
    *phMemContig = 0;

    mp.nPages = (cbSize + 4095) >> 12;
    mp.flags = PageContig+PageFixed;

    AuxDebugEx (2, DEBUGLINE "Contig allocate %08X pages\r\n", mp.nPages);

    assert (hMMDevLdr != NULL);
    assert (INVALID_HANDLE_VALUE != hMMDevLdr);
    if (INVALID_HANDLE_VALUE == hMMDevLdr)
        return NULL;

    if ( ! DeviceIoControl (hMMDevLdr,
                            MMDEVLDR_IOCTL_PAGEALLOCATE,
                            &mp,
                            sizeof(mp),
                            &mr,
                            sizeof(mr),
                            &cbRet,
                            NULL))
    {
        AuxDebugEx(0, "Contig Allocate failed!!!\r\n");
        mr.lpv = NULL;
        mr.hMem = 0;
        mr.nPages = 0;
        mr.dwPhys = 0;
    }

    *phMemContig = mr.hMem;

    AuxDebugEx(2, "Contig Allocate returns %08X\r\n", mr.lpv);
    return mr.lpv;
}

/*+
 *
 *-================================================================*/

PVOID WINAPI CreateGlobalAlias (
    PVOID   pOriginal,
    DWORD   cbOriginal,
    LPDWORD pnPages)
{
    DWORD   dwStartPage;
    DWORD   dwPageCount;
    DWORD   dwPageOffset;
    DWORD   dwAliasBase;
    PVOID   pAlias;

    AuxDebugEx (6, DEBUGLINE "CreateGlobalAlias(%08X,%08X,..)\r\n",
                pOriginal, cbOriginal);

    dwStartPage  = ((DWORD)pOriginal) >> 12;
    dwPageOffset = ((DWORD)pOriginal) & ((1 << 12)-1);
    dwPageCount  = ((((DWORD)pOriginal) + cbOriginal - 1) >> 12) - dwStartPage + 1;

    *pnPages = 0;
    dwAliasBase = LinPageLock (dwStartPage, dwPageCount, PAGEMAPGLOBAL);
    if ( ! dwAliasBase)
        return NULL;

    pAlias = (PVOID)(dwAliasBase + dwPageOffset);
    *pnPages = dwPageCount;

    AuxDebugEx (6, DEBUGLINE "CreateGlobalAlias returns %08X nPages %d\r\n", pAlias, dwPageCount);
    return pAlias;
}

/*+
 *
 *-================================================================*/

VOID WINAPI FreeGlobalAlias(
    PVOID        pAlias,
    DWORD        nPages)
{
    AuxDebugEx (6, DEBUGLINE "FreeGlobalAlias(%08X,%08X)\r\n", pAlias, nPages);

    LinPageUnLock (((DWORD)pAlias) >> 12, nPages, PAGEMAPGLOBAL);
}
#endif


#if defined _WIN32 && defined CHICAGO


/*+ videoFrame
 *
 *-================================================================*/

DWORD WINAPI videoFrame (
    HVIDEO hVideo,
    LPVIDEOHDR lpVHdr)
{
    return vidxFrame (hVideo, lpVHdr);
}

#endif



//
// Set the overlay rectangles on capture cards which support
// overlay, and then enable/disable the key color.
//
static void SetOverlayRectangles (LPCAPSTREAM lpcs)
{
    HDC hdc;
    BOOL fVisible;
    RECT rc;

    if (!lpcs->hVideoDisplay)
        return;

    hdc = GetDC (lpcs->hwnd);
    fVisible = (GetClipBox (hdc, &rc) != NULLREGION);
    ReleaseDC (lpcs->hwnd, hdc);

    if (!fVisible)  // disable the overlay if iconic
        videoStreamFini (lpcs->hVideoDisplay);
    else {
        // Destination
        GetClientRect (lpcs->hwnd, &rc);
        ClientToScreen (lpcs->hwnd, (LPPOINT)&rc);
        ClientToScreen (lpcs->hwnd, (LPPOINT)&rc+1);

        videoSetRect (lpcs->hVideoDisplay, DVM_DST_RECT, rc);

        // Overlay channel Source rectangle
        SetRect (&rc, lpcs->ptScroll.x, lpcs->ptScroll.y,
                lpcs->ptScroll.x + rc.right - rc.left,
                lpcs->ptScroll.y + rc.bottom - rc.top);
        videoSetRect (lpcs->hVideoDisplay, DVM_SRC_RECT, rc);

        videoStreamInit (lpcs->hVideoDisplay, 0L, 0L, 0L, 0L);
    }
}

// WM_POSITIONCHANGED and WM_POSITIONCHANGING don't do enough to
// handle clipping of the overlay window on the Intel board,
// which keys on black.  Do this routine on WM_PAINT and
// WM_ENTERIDLE messages.

void CheckWindowMove(LPCAPSTREAM lpcs, HDC hdcWnd, BOOL fForce)
{
    UINT    wRgn;
    RECT    rc;
#ifdef _WIN32
    POINT   ptOrg;
#else
    DWORD   dwOrg;
#endif
    HDC     hdc;
    BOOL    f;

    if (!lpcs->hwnd || !lpcs->hVideoDisplay || !lpcs->fOverlayWindow)
        return;

    //
    //  when the screen is locked for update by a window move operation
    //  we dont want to turn off the video.
    //
    //  we can tell if the screen is locked by checking a DC to the screen.
    //
    hdc = GetDC(NULL);
    f = GetClipBox(hdc, &rc) == NULLREGION;
    ReleaseDC(NULL, hdc);

    if (f) {
        lpcs->uiRegion = (UINT) -1;
        return;
    }

    if (fForce)
        lpcs->uiRegion = (UINT) -1;

    hdc = GetDC (lpcs->hwnd);
    wRgn = GetClipBox(hdc, &rc);
#ifdef _WIN32
    GetDCOrgEx(hdc, &ptOrg);
#else
    dwOrg = GetDCOrg(hdc);
#endif
    ReleaseDC(lpcs->hwnd, hdc);

    if (wRgn == lpcs->uiRegion &&
#ifdef _WIN32
                ptOrg.x == lpcs->ptRegionOrigin.x &&
		ptOrg.y == lpcs->ptRegionOrigin.y &&
#else
                dwOrg == lpcs->dwRegionOrigin &&
#endif
                EqualRect(&rc, &lpcs->rcRegionRect))
        return;

    lpcs->uiRegion       = wRgn;
#ifdef _WIN32
    lpcs->ptRegionOrigin = ptOrg;
#else
    lpcs->dwRegionOrigin = dwOrg;
#endif

    lpcs->rcRegionRect   = rc;

    SetOverlayRectangles (lpcs);

    if (hdcWnd)
        videoUpdate (lpcs->hVideoDisplay, lpcs->hwnd, hdcWnd);
    else
        InvalidateRect (lpcs->hwnd, NULL, TRUE);
}

//
// Create our little world
//
LPCAPSTREAM CapWinCreate (HWND hwnd)
{
    LPCAPSTREAM lpcs;
    WAVEFORMATEX wfex;

    if (!(lpcs = (LPCAPSTREAM) GlobalAllocPtr (GHND, sizeof (CAPSTREAM))))
        return NULL;

    SetWindowLongPtr (hwnd, GWL_CAPSTREAM, (LONG_PTR)lpcs);

    lpcs->dwSize = sizeof (CAPSTREAM);
    lpcs->uiVersion = CAPSTREAM_VERSION;
    lpcs->hwnd = hwnd;
    lpcs->hInst = ghInstDll;
    lpcs->hWaitCursor = LoadCursor(NULL, IDC_WAIT);
    lpcs->hdd = DrawDibOpen();
    lpcs->fAudioHardware = !!waveOutGetNumDevs();    // force 1 or 0


    // Video defaults
    lpcs->sCapParms.dwRequestMicroSecPerFrame = 66667;   // 15fps
    lpcs->sCapParms.vKeyAbort          = VK_ESCAPE;
    lpcs->sCapParms.fAbortLeftMouse    = TRUE;
    lpcs->sCapParms.fAbortRightMouse   = TRUE;
    lpcs->sCapParms.wNumVideoRequested = MIN_VIDEO_BUFFERS;
    lpcs->sCapParms.wPercentDropForError = 10;   // error msg if dropped > 10%
    lpcs->sCapParms.wChunkGranularity  = 0;

    // Audio defaults to 11K, 8bit, Mono
    lpcs->sCapParms.fCaptureAudio = lpcs->fAudioHardware;
    lpcs->sCapParms.wNumAudioRequested = DEF_WAVE_BUFFERS;

    lpcs->fCaptureFlags |= CAP_fCapturingToDisk;
    lpcs->fCaptureFlags |= CAP_fDefaultVideoBuffers;
    lpcs->fCaptureFlags |= CAP_fDefaultAudioBuffers;

    wfex.wFormatTag = WAVE_FORMAT_PCM;
    wfex.nChannels = 1;
    wfex.nSamplesPerSec = 11025;
    wfex.nAvgBytesPerSec = 11025;
    wfex.nBlockAlign = 1;
    wfex.wBitsPerSample = 8;
    wfex.cbSize = 0;
    SendMessage (hwnd, WM_CAP_SET_AUDIOFORMAT, 0, (LPARAM)(LPVOID)&wfex);

    // Palette defaults
    lpcs->nPaletteColors = 256;

    // Capture defaults
    lpcs->sCapParms.fUsingDOSMemory = FALSE;
    lstrcpy (lpcs->achFile, TEXT("C:\\CAPTURE.AVI"));    // Default capture file
    lpcs->fCapFileExists = fileCapFileIsAVI (lpcs->achFile);

    // Allocate index to 32K frames plus proportionate number of audio chunks
    lpcs->sCapParms.dwIndexSize = (32768ul + (32768ul / 15));
    lpcs->sCapParms.fDisableWriteCache = FALSE;

#ifdef NEW_COMPMAN
    // Init the COMPVARS structure
    lpcs->CompVars.cbSize = sizeof (COMPVARS);
    lpcs->CompVars.dwFlags = 0;
#endif

    return lpcs;
}

//
// Destroy our little world
//
void CapWinDestroy (LPCAPSTREAM lpcs)
{
    // Uh, oh.  Somebodys trying to kill us while capturing
    if (lpcs->fCaptureFlags & CAP_fCapturingNow) {
	if (lpcs->fCaptureFlags & CAP_fFrameCapturingNow) {
	    // Single frame capture in progress
	    SingleFrameCaptureClose (lpcs);
	}
	else {
	    // Streaming capture in progress, OR
	    // MCI step capture in progress

	    lpcs->fCaptureFlags |= CAP_fAbortCapture;
#ifdef _WIN32
	    // wait for capture thread to go away

	    // we must have a capture thread
	    WinAssert(lpcs->hThreadCapture != 0);
	    while (MsgWaitForMultipleObjects(1, &lpcs->hThreadCapture, FALSE,
		INFINITE, QS_SENDMESSAGE) != WAIT_OBJECT_0) {
		MSG msg;

		// just a single peekmessage with NOREMOVE will
		// process the inter-thread send and not affect the queue
		PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
	    }
	    CloseHandle(lpcs->hThreadCapture);
	    lpcs->hThreadCapture = 0;

	    // it should have stopped capturing
	    WinAssert(!(lpcs->fCaptureFlags & CAP_fCapturingNow));

#else
	    while (lpcs->fCapturingNow)
		Yield ();
#endif
    	}
    }

    if (lpcs->idTimer)
        KillTimer(lpcs->hwnd, lpcs->idTimer);

    PalFini (lpcs);
    DibFini (lpcs);

    CapWinDisconnectHardware (lpcs);

    DrawDibClose (lpcs->hdd);

    if (lpcs->lpWaveFormat)
        GlobalFreePtr (lpcs->lpWaveFormat);

#ifdef NEW_COMPMAN
    if (lpcs->CompVars.hic)
        ICCompressorFree(&lpcs->CompVars);
#endif

    if (lpcs->lpInfoChunks)
        GlobalFreePtr(lpcs->lpInfoChunks);

    WinAssert (!lpcs->pAsync);
    GlobalFreePtr (lpcs);       // Free the instance memory
}

UINT GetSizeOfWaveFormat (LPWAVEFORMATEX lpwf)
{
    UINT wSize;

    if ((lpwf == NULL) || (lpwf->wFormatTag == WAVE_FORMAT_PCM))
        wSize = sizeof (PCMWAVEFORMAT);
    else
        wSize = sizeof (WAVEFORMATEX) + lpwf->cbSize;

    return wSize;
}

// Returns TRUE if we got a new frame, else FALSE
// if fForce, then always get a new frame
BOOL GetAFrameThenCallback (LPCAPSTREAM lpcs, BOOL fForce)
{
    BOOL fOK = FALSE;
    static BOOL fRecursion = FALSE;
    BOOL fVisible;
    RECT rc;
    HDC  hdc;

    if (fRecursion)
        return FALSE;

    if (!lpcs->sCapDrvCaps.fCaptureInitialized)
        return fOK;

    fRecursion = TRUE;

    // Update the preview window if we got a timer and not saving to disk
    if (lpcs->fOverlayWindow)
        CheckWindowMove(lpcs, NULL, FALSE);

    if ((!(lpcs->fCaptureFlags & CAP_fCapturingNow))
       || (lpcs->fCaptureFlags & CAP_fStepCapturingNow)
       || (lpcs->fCaptureFlags & CAP_fFrameCapturingNow)) {
        hdc = GetDC (lpcs->hwnd);
        fVisible = (GetClipBox (hdc, &rc) != NULLREGION);
        ReleaseDC (lpcs->hwnd, hdc);

        if (fForce || (fVisible && (lpcs->fLiveWindow || lpcs->CallbackOnVideoFrame))) {
            videoFrame (lpcs->hVideoIn, &lpcs->VidHdr);
            fOK = TRUE;

            if (lpcs->CallbackOnVideoFrame)
                lpcs->CallbackOnVideoFrame(lpcs->hwnd, &lpcs->VidHdr);

            if (fForce || lpcs->fLiveWindow) {
                InvalidateRect (lpcs->hwnd, NULL, TRUE);
                UpdateWindow (lpcs->hwnd);
            }
        } // if visible
    } // if we're not streaming

    fRecursion = FALSE;

    return fOK;
}

// Clear the Status and Error strings via callback
__inline void FAR PASCAL ClearStatusAndError (LPCAPSTREAM lpcs)
{
    statusUpdateStatus(lpcs, 0);     // Clear status
    errorUpdateError(lpcs, 0);       // Clear error

}

// Process class specific commands >= WM_USER

DWORD_PTR PASCAL ProcessCommandMessages (LPCAPSTREAM lpcs, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD_PTR dwReturn = 0L;
    DWORD dwT;

    switch (msg) {
        // Don't clear status and error on the following innocuous msgs
        case WM_CAP_GET_CAPSTREAMPTR:
        case WM_CAP_GET_USER_DATA:
        case WM_CAP_DRIVER_GET_NAME:
        case WM_CAP_DRIVER_GET_VERSION:
        case WM_CAP_DRIVER_GET_CAPS:
        case WM_CAP_GET_AUDIOFORMAT:
        case WM_CAP_GET_VIDEOFORMAT:
        case WM_CAP_GET_STATUS:
        case WM_CAP_SET_SEQUENCE_SETUP:
        case WM_CAP_GET_SEQUENCE_SETUP:
        case WM_CAP_GET_MCI_DEVICE:
        case WM_CAP_SET_PREVIEWRATE:
        case WM_CAP_SET_SCROLL:
#ifdef UNICODE
        // ...or on the ansi thunks for these messages
        case WM_CAP_DRIVER_GET_NAMEA:
        case WM_CAP_DRIVER_GET_VERSIONA:
        case WM_CAP_GET_MCI_DEVICEA:
#endif
            break;

        default:
            ClearStatusAndError (lpcs);
            break;
    }

    switch (msg) {
    case WM_CAP_GET_CAPSTREAMPTR:
        // return a pointer to the CAPSTREAM
        return (DWORD_PTR) (LPVOID) lpcs;

    case WM_CAP_GET_USER_DATA:
	return lpcs->lUser;

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_DRIVER_GET_NAME:
        // Return the name of the capture driver in use
        // wParam is the length of the buffer pointed to by lParam
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return (capInternalGetDriverDesc (lpcs->sCapDrvCaps.wDeviceIndex,
                (LPTSTR) lParam, (int) wParam, NULL, 0));

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_DRIVER_GET_VERSION:
        // Return the version of the capture driver in use as text
        // wParam is the length of the buffer pointed to by lParam
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return (capInternalGetDriverDesc (lpcs->sCapDrvCaps.wDeviceIndex,
                NULL, 0, (LPTSTR) lParam, (int) wParam));

#ifdef UNICODE
    // ansi/unicode thunk versions of the above entrypoint
    case WM_CAP_DRIVER_GET_NAMEA:
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return capInternalGetDriverDescA(lpcs->sCapDrvCaps.wDeviceIndex,
                (LPSTR) lParam, (int) wParam, NULL, 0);

    // ansi/unicode thunk versions of the above entrypoint
    case WM_CAP_DRIVER_GET_VERSIONA:
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return capInternalGetDriverDescA(lpcs->sCapDrvCaps.wDeviceIndex,
                NULL, 0, (LPSTR) lParam, (int) wParam);
#endif


    case WM_CAP_DRIVER_GET_CAPS:
        // wParam is the size of the CAPDRIVERCAPS struct
        // lParam points to a CAPDRIVERCAPS struct
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (wParam <= sizeof (CAPDRIVERCAPS) &&
                !IsBadWritePtr ((LPVOID) lParam, (UINT) wParam)) {
            dwT = min ((UINT) wParam, sizeof (CAPDRIVERCAPS));
            _fmemcpy ((LPVOID) lParam, (LPVOID) &lpcs->sCapDrvCaps, (UINT) dwT);
            dwReturn = TRUE;
        }
        break;


    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_FILE_GET_CAPTURE_FILE:
        // wParam is the size (in characters)
        // lParam points to a buffer in which capture file name is copied
        if (lParam) {
            lstrcpyn ((LPTSTR) lParam, lpcs->achFile, (UINT) wParam);
            dwReturn = TRUE;
        }
        break;
#ifdef UNICODE
    // ansi/unicode thunk
    case WM_CAP_FILE_GET_CAPTURE_FILEA:
        if (lParam) {
            Iwcstombs((LPSTR) lParam, lpcs->achFile, (int) wParam);
            dwReturn = TRUE;
        }
        break;
#endif


    case WM_CAP_GET_AUDIOFORMAT:
        // if lParam == NULL, return the size
        // if lParam != NULL, wParam is the size, return bytes copied
        if (lpcs->lpWaveFormat == NULL)
            return FALSE;
        dwT = GetSizeOfWaveFormat ((LPWAVEFORMATEX) lpcs->lpWaveFormat);
        if (lParam == 0)
            return (dwT);
        else {
            if (wParam < (UINT) dwT)
                return FALSE;
            else {
                hmemcpy ((LPVOID) lParam, (LPVOID) lpcs->lpWaveFormat, dwT);
                dwReturn = dwT;
            }
        }
        break;

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_GET_MCI_DEVICE:
        // wParam is the size in characters
        // lParam points to a buffer in which MCI device name is copied
        if (lParam) {
            lstrcpyn ((LPTSTR) lParam, lpcs->achMCIDevice, (UINT) wParam);
            dwReturn = TRUE;
        }
        break;
#ifdef UNICODE
    // ansi thunk of above
    case WM_CAP_GET_MCI_DEVICEA:
        if (lParam) {
            Iwcstombs( (LPSTR) lParam, lpcs->achMCIDevice, (int) wParam);
            dwReturn = TRUE;
        }
        break;
#endif

    case WM_CAP_GET_STATUS:
        // wParam is the size of the CAPSTATUS struct pointed to by lParam
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (IsBadWritePtr ((LPVOID) lParam, (UINT) wParam))
            return FALSE;

        if (wParam >= sizeof (CAPSTATUS)) {
            LPCAPSTATUS lpcc = (LPCAPSTATUS) lParam;

            lpcc->fLiveWindow          = lpcs->fLiveWindow;
            lpcc->fOverlayWindow       = lpcs->fOverlayWindow;
            lpcc->fScale               = lpcs->fScale;
            lpcc->ptScroll             = lpcs->ptScroll;
            lpcc->fUsingDefaultPalette = lpcs->fUsingDefaultPalette;
            lpcc->fCapFileExists       = lpcs->fCapFileExists;
            lpcc->fAudioHardware       = lpcs->fAudioHardware;
            lpcc->uiImageWidth         = lpcs->dxBits;
            lpcc->uiImageHeight        = lpcs->dyBits;

            // The following are updated dynamically during capture
            lpcc->dwCurrentVideoFrame          = lpcs->dwVideoChunkCount;
            lpcc->dwCurrentVideoFramesDropped  = lpcs->dwFramesDropped;
            if (lpcs->lpWaveFormat != NULL) {
            lpcc->dwCurrentWaveSamples         =
                  MulDiv (lpcs->dwWaveBytes,
                          lpcs->lpWaveFormat->nSamplesPerSec,
                          lpcs->lpWaveFormat->nAvgBytesPerSec);
            }
            lpcc->dwCurrentTimeElapsedMS       = lpcs->dwTimeElapsedMS;

            // Added post alpha release
	    if (lpcs->fCaptureFlags & CAP_fCapturingNow) {
		lpcc->fCapturingNow    = TRUE;
	    } else {
		lpcc->fCapturingNow    = FALSE;
	    }
            lpcc->hPalCurrent          = lpcs->hPalCurrent;
            lpcc->dwReturn             = lpcs->dwReturn;
            lpcc->wNumVideoAllocated   = lpcs->iNumVideo;
            lpcc->wNumAudioAllocated   = lpcs->iNumAudio;

            dwReturn = TRUE;
        }
        break;

    case WM_CAP_GET_SEQUENCE_SETUP:
        // wParam is sizeof CAPTUREPARMS
        // lParam = LPCAPTUREPARMS
        if (wParam <= sizeof (CAPTUREPARMS) &&
                !IsBadWritePtr ((LPVOID) lParam, (UINT) wParam)) {
            dwT = min ((UINT) wParam, sizeof (CAPTUREPARMS));
            _fmemcpy ((LPVOID) lParam, (LPVOID) &lpcs->sCapParms, (UINT) dwT);
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_STOP:
        // Stop capturing a sequence
        if (lpcs->fCaptureFlags & CAP_fCapturingNow) {
            lpcs->fCaptureFlags |= CAP_fStopCapture;
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_ABORT:
        // Stop capturing a sequence
        if (lpcs->fCaptureFlags & CAP_fCapturingNow) {
            lpcs->fCaptureFlags |= CAP_fAbortCapture;
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_GET_VIDEOFORMAT:
        // if lParam == NULL, return the size
        // if lParam != NULL, wParam is the size, return bytes copied
        if (!lpcs->fHardwareConnected)
            return FALSE;
        dwT = ((LPBITMAPINFOHEADER)lpcs->lpBitsInfo)->biSize +
	      ((LPBITMAPINFOHEADER)lpcs->lpBitsInfo)->biClrUsed * sizeof(RGBQUAD);
        if (lParam == 0)
            return dwT;
        else {
            if (wParam < (UINT) dwT)
                return FALSE;
            else {
                hmemcpy ((LPVOID) lParam, (LPVOID) lpcs->lpBitsInfo, dwT);
                dwReturn = dwT;
            }
        }
        break;

    case WM_CAP_SINGLE_FRAME_OPEN:
        // wParam is not used
        // lParam is not used
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return SingleFrameCaptureOpen (lpcs);

    case WM_CAP_SINGLE_FRAME_CLOSE:
        // wParam is not used
        // lParam is not used
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return SingleFrameCaptureClose (lpcs);

    case WM_CAP_SINGLE_FRAME:
        // wParam is not used
        // lParam is not used
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return SingleFrameCapture (lpcs);

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_SET_CALLBACK_STATUS:
        // Set the status callback proc
        if (lParam != 0 && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnStatus = (CAPSTATUSCALLBACK) lParam;
	lpcs->fLastStatusWasNULL = TRUE;
#ifdef UNICODE
        lpcs->fUnicode &= ~VUNICODE_STATUSISANSI;
#endif
        return TRUE;

#ifdef UNICODE
    // ansi thunk for above
    case WM_CAP_SET_CALLBACK_STATUSA:
        // Set the status callback proc
        if (lParam != 0 && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnStatus = (CAPSTATUSCALLBACK) lParam;
	lpcs->fLastStatusWasNULL = TRUE;
        lpcs->fUnicode |= VUNICODE_STATUSISANSI;
        return TRUE;
#endif

    // unicode and win-16 version - see ansi version below
    case WM_CAP_SET_CALLBACK_ERROR:
        // Set the error callback proc
        if (lParam != 0 && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnError = (CAPERRORCALLBACK) lParam;
	lpcs->fLastErrorWasNULL = TRUE;
#ifdef UNICODE
        lpcs->fUnicode &= ~VUNICODE_ERRORISANSI;
#endif
        return TRUE;


#ifdef UNICODE
    // ansi version of above
    case WM_CAP_SET_CALLBACK_ERRORA:
        // Set the error callback proc
        if (lParam != 0 && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnError = (CAPERRORCALLBACK) lParam;
	lpcs->fLastErrorWasNULL = TRUE;
        lpcs->fUnicode |= VUNICODE_ERRORISANSI;
        return TRUE;
#endif

    case WM_CAP_SET_CALLBACK_FRAME:
        // Set the callback proc for single frame during preview
        if (lParam != 0 && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnVideoFrame = (CAPVIDEOCALLBACK) lParam;
        return TRUE;

    default:
        break;
    }

    // Once we start capturing, don't change anything
    if (lpcs->fCaptureFlags & CAP_fCapturingNow)
        return dwReturn;

    switch (msg) {

    case WM_CAP_SET_CALLBACK_YIELD:
        // Set the callback proc for wave buffer processing to net
        if (lParam != 0 && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnYield = (CAPYIELDCALLBACK) lParam;
        return TRUE;

    case WM_CAP_SET_CALLBACK_VIDEOSTREAM:
        // Set the callback proc for video buffer processing to net
        if (lParam != 0 && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnVideoStream = (CAPVIDEOCALLBACK) lParam;
        return TRUE;

    case WM_CAP_SET_CALLBACK_WAVESTREAM:
        // Set the callback proc for wave buffer processing to net
        if (lParam != 0 && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnWaveStream = (CAPWAVECALLBACK) lParam;
        return TRUE;

    case WM_CAP_SET_CALLBACK_CAPCONTROL:
        // Set the callback proc for frame accurate capture start/stop
        if (lParam != 0 && IsBadCodePtr ((FARPROC) lParam))
            return FALSE;
        lpcs->CallbackOnControl = (CAPCONTROLCALLBACK) lParam;
        return TRUE;

    case WM_CAP_SET_USER_DATA:
	lpcs->lUser = lParam;
	return TRUE;

    case WM_CAP_DRIVER_CONNECT:
        // Connect to a device
        // wParam contains the index of the driver

        // If the same driver ID is requested, skip the request
        // Prevents multiple Inits from VB apps
        if (lpcs->fHardwareConnected &&
                (lpcs->sCapDrvCaps.wDeviceIndex == wParam))
            return TRUE;

        // First disconnect from any (possibly) existing device
        SendMessage (lpcs->hwnd, WM_CAP_DRIVER_DISCONNECT, 0, 0l);

        // and then connect to the new device
        if (CapWinConnectHardware (lpcs, (UINT) wParam /*wDeviceIndex*/)) {
            if (!DibGetNewFormatFromDriver (lpcs)) {  // Allocate our bitspace
                // Use the cached palette if available
                if (lpcs->hPalCurrent && lpcs->lpCacheXlateTable) {
                    PalSendPaletteToDriver (lpcs, lpcs->hPalCurrent, lpcs->lpCacheXlateTable);
                }
                else
                    PalGetPaletteFromDriver (lpcs);

                // Get a frame using the possibly cached palette
                videoFrame (lpcs->hVideoIn, &lpcs->VidHdr);
        	InvalidateRect(lpcs->hwnd, NULL, TRUE);
                lpcs->sCapDrvCaps.fCaptureInitialized = TRUE; // everything AOK!
                dwReturn = TRUE;
            }
        }
        break;

    case WM_CAP_DRIVER_DISCONNECT:
        MB ("About to disconnect from driver");
        // Disconnect from a device
        // wParam and lParam unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        CapWinDisconnectHardware (lpcs);
        DibFini (lpcs);
        /* PalFini (lpcs); keep the palette cached for reconnections */
        InvalidateRect(lpcs->hwnd, NULL, TRUE);
        lpcs->sCapDrvCaps.fCaptureInitialized = FALSE;
        dwReturn = TRUE;
        break;

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_FILE_SET_CAPTURE_FILE:
        // lParam points to the name of the capture file
        if (lParam) {
            BOOL fAlreadyExists;        // Don't create a file if new name
#ifndef _WIN32
            OFSTRUCT of;
#endif
            HANDLE hFile;

            // Check for valid file names...
#ifdef _WIN32
    // can't use OpenFile for UNICODE names
            if ((hFile = CreateFile(
                            (LPTSTR) lParam,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL)) == INVALID_HANDLE_VALUE) {
                if ((hFile = CreateFile(
                                (LPTSTR) lParam,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL)) == INVALID_HANDLE_VALUE) {
#else

            if ((hFile = OpenFile ((LPTSTR) lParam, &of, OF_WRITE)) == -1) {
                if ((hFile = OpenFile ((LPTSTR) lParam, &of, OF_CREATE | OF_WRITE)) == -1) {
#endif
                    return FALSE;
                }
                fAlreadyExists = FALSE;
            }
            else
                fAlreadyExists = TRUE;

#ifdef _WIN32
            CloseHandle(hFile);
#else
            _lclose (hFile);
#endif
            lstrcpyn (lpcs->achFile, (LPTSTR) lParam, NUMELMS(lpcs->achFile));
            lpcs->fCapFileExists = fileCapFileIsAVI (lpcs->achFile);

            if (!fAlreadyExists) {
		// Delete the file created by CREATE_NEW (or OF_CREATE)
		// when verifying that we can write to this file location
#ifdef _WIN32
                DeleteFile ((LPTSTR) lParam);
#else
                OpenFile ((LPTSTR) lParam, &of, OF_DELETE);
#endif
            }
            dwReturn = TRUE;
        }
        break;

#ifdef UNICODE
    // Ansi thunk for above.
    case WM_CAP_FILE_SET_CAPTURE_FILEA:
        // lParam points to the name of the capture file
        if (lParam) {
            LPWSTR pw;
            int chsize;

            // remember the null
            chsize = lstrlenA( (LPSTR) lParam) + 1;
            pw = LocalAlloc(LPTR, chsize * sizeof(WCHAR));
	    if (pw) {
                Imbstowcs(pw, (LPSTR) lParam, chsize);
                dwReturn = ProcessCommandMessages(lpcs, WM_CAP_FILE_SET_CAPTURE_FILEW,
                                0, (LPARAM)pw);
                LocalFree(pw);
	    }
        }
        break;
#endif

    case WM_CAP_FILE_ALLOCATE:
        // lParam contains the size to preallocate the capture file in bytes
        return fileAllocCapFile(lpcs, (DWORD) lParam);

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_FILE_SAVEAS:
        // lParam points to the name of the SaveAs file
        if (lParam) {
            lstrcpyn (lpcs->achSaveAsFile, (LPTSTR) lParam,
                        NUMELMS(lpcs->achSaveAsFile));
            return (fileSaveCopy(lpcs));
        }
        break;

#ifdef UNICODE
    // ansi thunk for above
    case WM_CAP_FILE_SAVEASA:
        // lParam points to the name of the SaveAs file
        if (lParam) {
            LPWSTR pw;
            int chsize;

            // remember the null
            chsize = lstrlenA( (LPSTR) lParam)+1;
            pw = LocalAlloc(LPTR, chsize * sizeof(WCHAR));
	    if (pw) {
                Imbstowcs(pw, (LPSTR) lParam, chsize);
                dwReturn = ProcessCommandMessages(lpcs, WM_CAP_FILE_SAVEASW,
                                0, (LPARAM)pw);
                LocalFree(pw);
	    }
        }
        break;
#endif

    case WM_CAP_FILE_SET_INFOCHUNK:
        // wParam is not used
        // lParam is an LPCAPINFOCHUNK
        if (lParam) {
            return (SetInfoChunk(lpcs, (LPCAPINFOCHUNK) lParam));
        }
        break;

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_FILE_SAVEDIB:
        // lParam points to the name of the DIB file
        if (lParam) {
            if (lpcs->fOverlayWindow)
                GetAFrameThenCallback (lpcs, TRUE /*fForce*/);

            return (fileSaveDIB(lpcs, (LPTSTR)lParam));
        }
        break;

#ifdef UNICODE
    // ansi thunk for above
    case WM_CAP_FILE_SAVEDIBA:
        if (lParam) {
            LPWSTR pw;
            int chsize;

            if (lpcs->fOverlayWindow)
                GetAFrameThenCallback (lpcs, TRUE /*fForce*/);

            // remember the null
            chsize = lstrlenA( (LPSTR) lParam)+1;
            pw = LocalAlloc(LPTR, chsize * sizeof(WCHAR));
	    if (pw) {
                Imbstowcs(pw, (LPSTR) lParam, chsize);
                dwReturn = fileSaveDIB(lpcs, pw);
                LocalFree(pw);
	    }
        }
        break;
#endif


    case WM_CAP_EDIT_COPY:
        // Copy the current image and palette to the clipboard
        // wParam and lParam unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->fOverlayWindow)
            GetAFrameThenCallback (lpcs, TRUE /*fForce*/);

        if (lpcs->sCapDrvCaps.fCaptureInitialized && OpenClipboard (lpcs->hwnd)) {
            EmptyClipboard();

            // put a copy of the current palette in the clipboard
            if (lpcs->hPalCurrent && lpcs->lpBitsInfo->bmiHeader.biBitCount <= 8)
                SetClipboardData(CF_PALETTE, CopyPalette (lpcs->hPalCurrent));

            // make a packed DIB out of the current image
            if (lpcs->lpBits && lpcs->lpBitsInfo ) {
                if (SetClipboardData (CF_DIB, CreatePackedDib (lpcs->lpBitsInfo,
                        lpcs->lpBits, lpcs->hPalCurrent)))
                    dwReturn = TRUE;
                else
                    errorUpdateError (lpcs, IDS_CAP_OUTOFMEM);
            }

            CloseClipboard();
        }
        break;

    case WM_CAP_SET_AUDIOFORMAT:
        {
            // wParam is unused
            // lParam is LPWAVEFORMAT or LPWAVEFORMATEX
            UINT wSize;
            LPWAVEFORMATEX lpwf = (LPWAVEFORMATEX) lParam;
            UINT uiError;

            // Verify the waveformat is valid
            uiError = waveInOpen(NULL, WAVE_MAPPER, lpwf, 0, 0L,WAVE_FORMAT_QUERY);

            if (uiError) {
                errorUpdateError (lpcs, IDS_CAP_WAVE_OPEN_ERROR);
                return FALSE;
            }

            if (lpcs->lpWaveFormat)
                GlobalFreePtr (lpcs->lpWaveFormat);

            wSize = GetSizeOfWaveFormat (lpwf);
            if (lpcs->lpWaveFormat = (LPWAVEFORMATEX)
                    GlobalAllocPtr (GHND, sizeof (CAPSTREAM))) {
                hmemcpy (lpcs->lpWaveFormat, lpwf, (LONG) wSize);
            }
            dwReturn = TRUE;
        }
        break;

    case WM_CAP_DLG_VIDEOSOURCE:
        // Show the dialog which controls the video source
        // NTSC vs PAL, input channel selection, etc.
        // wParam and lParam are unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->dwDlgsActive & VDLG_VIDEOSOURCE)
            return FALSE;
        if (lpcs->sCapDrvCaps.fHasDlgVideoSource) {
	    lpcs->dwDlgsActive |= VDLG_VIDEOSOURCE;
            videoDialog (lpcs->hVideoCapture, lpcs->hwnd, 0L );
            // Changing from NTSC to PAL could affect image dimensions!!!
            DibGetNewFormatFromDriver (lpcs);
            PalGetPaletteFromDriver (lpcs);

            // May need to inform parent of new layout here!
            InvalidateRect(lpcs->hwnd, NULL, TRUE);
            UpdateWindow(lpcs->hwnd);
	    lpcs->dwDlgsActive &= ~VDLG_VIDEOSOURCE;
        }
        return (lpcs->sCapDrvCaps.fHasDlgVideoSource);

    case WM_CAP_DLG_VIDEOFORMAT:
        // Show the format dialog, user selects dimensions, depth, compression
        // wParam and lParam are unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->dwDlgsActive & VDLG_VIDEOFORMAT)
            return FALSE;
        if (lpcs->sCapDrvCaps.fHasDlgVideoFormat) {
	    lpcs->dwDlgsActive |= VDLG_VIDEOFORMAT;
            videoDialog (lpcs->hVideoIn, lpcs->hwnd, 0L );
            DibGetNewFormatFromDriver (lpcs);
            PalGetPaletteFromDriver (lpcs);

            // May need to inform parent of new layout here!
            InvalidateRect(lpcs->hwnd, NULL, TRUE);
            UpdateWindow(lpcs->hwnd);
	    lpcs->dwDlgsActive &= ~VDLG_VIDEOFORMAT;
        }
        return (lpcs->sCapDrvCaps.fHasDlgVideoFormat);

    case WM_CAP_DLG_VIDEODISPLAY:
        // Show the dialog which controls output.
        // This dialog only affects the presentation, never the data format
        // wParam and lParam are unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->dwDlgsActive & VDLG_VIDEODISPLAY)
            return FALSE;
        if (lpcs->sCapDrvCaps.fHasDlgVideoDisplay) {
	    lpcs->dwDlgsActive |= VDLG_VIDEODISPLAY;
            videoDialog (lpcs->hVideoDisplay, lpcs->hwnd, 0L);
	    lpcs->dwDlgsActive &= ~VDLG_VIDEODISPLAY;
        }
        return (lpcs->sCapDrvCaps.fHasDlgVideoDisplay);

    case WM_CAP_DLG_VIDEOCOMPRESSION:
#ifndef NEW_COMPMAN
	return FALSE;
#else
        // Show the dialog which selects video compression options.
        // wParam and lParam are unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
	if (lpcs->dwDlgsActive & VDLG_COMPRESSION)
            return FALSE;
	lpcs->dwDlgsActive |= VDLG_COMPRESSION;
        ICCompressorChoose(
                lpcs->hwnd,            // parent window for dialog
                ICMF_CHOOSE_KEYFRAME,  // want "key frame every" box
                lpcs->lpBitsInfo,      // input format (optional)
                NULL,                  // input data (optional)
                &lpcs->CompVars,       // data about the compressor/dlg
                NULL);                 // title bar (optional)
	lpcs->dwDlgsActive &= ~VDLG_COMPRESSION;
        return TRUE;
#endif

    case WM_CAP_SET_VIDEOFORMAT:
        // wParam is the size of the BITMAPINFO
        // lParam is an LPBITMAPINFO
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (IsBadReadPtr ((LPVOID) lParam, (UINT) wParam))
            return FALSE;

        return (DibNewFormatFromApp (lpcs, (LPBITMAPINFO) lParam, (UINT) wParam));

    case WM_CAP_SET_PREVIEW:
        // if wParam, enable preview via drawdib
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (wParam) {
            // turn off the overlay, if it is in use
            if (lpcs->fOverlayWindow)
                SendMessage(lpcs->hwnd, WM_CAP_SET_OVERLAY, 0, 0L);
            lpcs->fLiveWindow = TRUE;
            statusUpdateStatus(lpcs, IDS_CAP_STAT_LIVE_MODE);
         } // endif enabling preview
         else {
            lpcs->fLiveWindow = FALSE;
        }
        InvalidateRect (lpcs->hwnd, NULL, TRUE);
        return TRUE;

    case WM_CAP_SET_OVERLAY:
        // if wParam, enable overlay in hardware
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (wParam && lpcs->sCapDrvCaps.fHasOverlay) {
            if (lpcs->fLiveWindow)   // turn off preview mode
                SendMessage(lpcs->hwnd, WM_CAP_SET_PREVIEW, 0, 0L);
            lpcs->fOverlayWindow = TRUE;
            statusUpdateStatus(lpcs, IDS_CAP_STAT_OVERLAY_MODE);
        }
        else {
            lpcs->fOverlayWindow = FALSE;
            videoStreamFini (lpcs->hVideoDisplay); // disable overlay on hardware
        }
        InvalidateRect (lpcs->hwnd, NULL, TRUE);
        return (lpcs->sCapDrvCaps.fHasOverlay);

    case WM_CAP_SET_PREVIEWRATE:
        // wParam contains preview update rate in mS.
        // if wParam == 0 no timer is in use.
        if (lpcs->idTimer) {
            KillTimer(lpcs->hwnd, ID_PREVIEWTIMER);
            lpcs->idTimer = 0;
        }
        if (wParam != 0) {
            lpcs->idTimer = SetTimer (lpcs->hwnd, ID_PREVIEWTIMER,
                        (UINT) wParam, NULL);
        }
        lpcs->uTimeout = (UINT) wParam;
        dwReturn = TRUE;
        break;

    case WM_CAP_GRAB_FRAME:
        // grab a single frame
        // wParam and lParam unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->sCapDrvCaps.fCaptureInitialized) {

           dwReturn = (DWORD) GetAFrameThenCallback (lpcs, TRUE /*fForce*/);

           // disable live and overlay mode when capturing a single frame
           if (lpcs->fLiveWindow)
               SendMessage(lpcs->hwnd, WM_CAP_SET_PREVIEW, 0, 0L);
           else if (lpcs->fOverlayWindow)
               SendMessage(lpcs->hwnd, WM_CAP_SET_OVERLAY, 0, 0L);
        }
        break;

    case WM_CAP_GRAB_FRAME_NOSTOP:
        // grab a single frame, but don't change state of overlay/preview
        // wParam and lParam unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        dwReturn = (LONG) GetAFrameThenCallback (lpcs, TRUE /*fForce*/);
        break;

    case WM_CAP_SEQUENCE:
        // This is the main entry for streaming video capture
        // wParam is unused
        // lParam is unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->sCapDrvCaps.fCaptureInitialized) {
            lpcs->fCaptureFlags |= CAP_fCapturingToDisk;
            return (AVICapture(lpcs));
        }
        break;

    case WM_CAP_SEQUENCE_NOFILE:
        // wParam is unused
        // lParam is unused
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->sCapDrvCaps.fCaptureInitialized) {
            lpcs->fCaptureFlags &= ~CAP_fCapturingToDisk;
            return (AVICapture(lpcs));
        }
        break;

    case WM_CAP_SET_SEQUENCE_SETUP:
        // wParam is sizeof CAPTUREPARMS
        // lParam = LPCAPTUREPARMS
        // The following were added after the Beta, init in case the client
        // has a smaller structure and doesn't access them.
	// WHICH BETA ?? (SteveDav)  We should change the comment to include a date

        lpcs->sCapParms.dwAudioBufferSize = 0;
        lpcs->sCapParms.fDisableWriteCache = TRUE;
        lpcs->sCapParms.AVStreamMaster = AVSTREAMMASTER_AUDIO;

        if (wParam <= sizeof (CAPTUREPARMS)) {
            dwT = min (sizeof (CAPTUREPARMS), (UINT) wParam);
            if (IsBadReadPtr ((LPVOID) lParam, (UINT) dwT))
                break;

            _fmemcpy ((LPVOID) &lpcs->sCapParms, (LPVOID) lParam, (UINT) dwT);

            // Validate stuff that isn't handled elsewhere
            if (lpcs->sCapParms.wChunkGranularity != 0 &&
                lpcs->sCapParms.wChunkGranularity < 16)
                lpcs->sCapParms.wChunkGranularity = 16;
            if (lpcs->sCapParms.wChunkGranularity > 16384)
                lpcs->sCapParms.wChunkGranularity = 16384;

            if (lpcs->sCapParms.fLimitEnabled && (lpcs->sCapParms.wTimeLimit == 0))
                lpcs->sCapParms.wTimeLimit = 1;

            // Force Step MCI off if not using MCI control
            if (lpcs->sCapParms.fStepMCIDevice && !lpcs->sCapParms.fMCIControl)
                    lpcs->sCapParms.fStepMCIDevice = FALSE;

            // Prevent audio capture if no audio hardware
            lpcs->sCapParms.fCaptureAudio =
                lpcs->fAudioHardware && lpcs->sCapParms.fCaptureAudio;

            // Limit audio buffers
            lpcs->sCapParms.wNumAudioRequested =
                min (MAX_WAVE_BUFFERS, lpcs->sCapParms.wNumAudioRequested);

            // Limit video buffers
            lpcs->sCapParms.wNumVideoRequested =
                min (MAX_VIDEO_BUFFERS, lpcs->sCapParms.wNumVideoRequested);

            dwReturn = TRUE;
        }
        break;

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_SET_MCI_DEVICE:
        // lParam points to the name of the MCI Device
        if (IsBadStringPtr ((LPVOID) lParam, 1))
            return FALSE;
        if (lParam) {
            lstrcpyn (lpcs->achMCIDevice, (LPTSTR) lParam, NUMELMS(lpcs->achMCIDevice));
            dwReturn = TRUE;
        }
        break;
#ifdef UNICODE
    // ansi thunk for above
    case WM_CAP_SET_MCI_DEVICEA:
        // lParam points to Ansi name of MCI device
        if (lParam) {
            //remember the null
            int chsize = lstrlenA( (LPSTR) lParam)+1;
            Imbstowcs(lpcs->achMCIDevice, (LPSTR) lParam,
                min(chsize, NUMELMS(lpcs->achMCIDevice)));
            dwReturn = TRUE;
        }
        break;
#endif


    case WM_CAP_SET_SCROLL:
        // lParam is an LPPOINT which points to the new scroll position
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (IsBadReadPtr ((LPVOID) lParam, sizeof (POINT)))
            return FALSE;

        {
            LPPOINT lpP = (LPPOINT) lParam;

            if (lpP->x < lpcs->dxBits && lpP->y < lpcs->dyBits) {
                lpcs->ptScroll = *lpP;
                InvalidateRect (lpcs->hwnd, NULL, TRUE);
                dwReturn = TRUE;
            }
        }
        break;

    case WM_CAP_SET_SCALE:
        // if wParam, Scale the window to the client region?
        if (!lpcs->fHardwareConnected)
            return FALSE;
        lpcs->fScale = (BOOL) wParam;
        return TRUE;

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_PAL_OPEN:
        // Open a new palette
        // wParam is unused
        // lParam contains an LPTSTR to the file
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (IsBadStringPtr ((LPVOID) lParam, 1))
            return FALSE;
        return fileOpenPalette(lpcs, (LPTSTR) lParam /*lpszFileName*/);
#ifdef UNICODE
    // ansi thunk for above
    case WM_CAP_PAL_OPENA:
        // lParam contains (ANSI) lpstr for filename
        if (lParam) {
            // remember the null
            int chsize = lstrlenA( (LPSTR) lParam)+1;
            LPWSTR pw = LocalAlloc(LPTR, chsize * sizeof(WCHAR));
	    if (pw) {
                Imbstowcs(pw, (LPSTR) lParam, chsize);
                dwReturn = fileOpenPalette(lpcs, pw);
                LocalFree(pw);
	    }
        }
        break;
#endif

    // unicode and win-16 version - see ansi thunk below
    case WM_CAP_PAL_SAVE:
        // Save the current palette in a file
        // wParam is unused
        // lParam contains an LPTSTR to the file
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (IsBadStringPtr ((LPVOID) lParam, 1))
            return FALSE;
        return fileSavePalette(lpcs, (LPTSTR) lParam /*lpszFileName*/);
#ifdef UNICODE
    // ansi thunk for above
    case WM_CAP_PAL_SAVEA:
        // lParam contains (ANSI) lpstr for filename
        if (lParam) {
            // remember the null
            int chsize = lstrlenA( (LPSTR) lParam)+1;
            LPWSTR pw = LocalAlloc(LPTR, chsize * sizeof(WCHAR));
	    if (pw) {
                Imbstowcs(pw, (LPSTR) lParam, chsize);
                dwReturn = fileSavePalette(lpcs, pw);
                LocalFree(pw);
	    }
        }
        break;
#endif


    case WM_CAP_PAL_AUTOCREATE:
        // Automatically capture a palette
        // wParam contains a count of the number of frames to average
        // lParam contains the number of colors desired in the palette
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return CapturePaletteAuto (lpcs, (int) wParam, (int) lParam);

    case WM_CAP_PAL_MANUALCREATE:
        // Manually capture a palette
        // wParam contains TRUE for each frame to capture, FALSE when done
        // lParam contains the number of colors desired in the palette
        if (!lpcs->fHardwareConnected)
            return FALSE;
        return CapturePaletteManual (lpcs, (BOOL) wParam, (int) lParam);

    case WM_CAP_PAL_PASTE:
        // Paste a palette from the clipboard, send to the driver
        if (!lpcs->fHardwareConnected)
            return FALSE;
        if (lpcs->sCapDrvCaps.fCaptureInitialized && OpenClipboard(lpcs->hwnd)) {
            HANDLE  hPal;

            hPal = GetClipboardData(CF_PALETTE);
            CloseClipboard();
            if (hPal) {
                PalSendPaletteToDriver (lpcs, CopyPalette(hPal),  NULL /* XlateTable */);
                InvalidateRect(lpcs->hwnd, NULL, TRUE);
                dwReturn = TRUE;
            }
        }
        break;

    default:
        break;
    }
    return dwReturn;
}


/*--------------------------------------------------------------+
| ****************** THE WINDOW PROCEDURE ********************* |
+--------------------------------------------------------------*/
LRESULT FAR PASCAL LOADDS EXPORT CapWndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LPCAPSTREAM lpcs;
    PAINTSTRUCT ps;
    HDC         hdc;
    MSG         PMsg;
    int         f;

    lpcs = (LPCAPSTREAM) GetWindowLongPtr (hwnd, GWL_CAPSTREAM);

    if (msg >= WM_CAP_START && msg <= WM_CAP_END)
        return (ProcessCommandMessages (lpcs, msg, wParam, lParam));

    switch (msg) {

    case WM_CREATE:
        lpcs = CapWinCreate (hwnd);
        break;

    case WM_TIMER:
        // Update the preview window if we got a timer and not saving to disk
        GetAFrameThenCallback (lpcs, FALSE /*fForce*/);

        // Added VFW 1.1b, Clear the queue of additional timer msgs!!!

        // Even in Win32, processing frame timers can swamp all other
        // activity in the app, so clear the queue after each frame is done.

        // This successfully corrected a problem with the "Hit OK to continue"
        // dialog not appearing bug due to app message queue
        // swamping with timer messages at large
        // image dimensions and preview rates.

        PeekMessage (&PMsg, hwnd, WM_TIMER, WM_TIMER,PM_REMOVE|PM_NOYIELD);
        break;

    case WM_CLOSE:
        break;

    case WM_DESTROY:
        CapWinDestroy (lpcs);
        break;

    case WM_PALETTECHANGED:
        if (lpcs->hdd == NULL)
            break;

        hdc = GetDC(hwnd);
        if (f = DrawDibRealize(lpcs->hdd, hdc, TRUE /*fBackground*/))
            InvalidateRect(hwnd,NULL,TRUE);
        ReleaseDC(hwnd,hdc);
        return f;

    case WM_QUERYNEWPALETTE:
        if (lpcs->hdd == NULL)
            break;
        hdc = GetDC(hwnd);
        f = DrawDibRealize(lpcs->hdd, hdc, FALSE);
        ReleaseDC(hwnd, hdc);

        if (f)
            InvalidateRect(hwnd, NULL, TRUE);
        return f;

    case WM_SIZE:
    case WM_MOVE:
        if (lpcs->fOverlayWindow)    // Make the driver paint the key color
            InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_WINDOWPOSCHANGED:
        if (lpcs->fOverlayWindow)    // Make the driver paint the key color
            InvalidateRect(hwnd, NULL, TRUE);
        return 0;

    case WM_ERASEBKGND:
        return 0;  // don't bother to erase it

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        if (lpcs->fOverlayWindow) {
            CheckWindowMove(lpcs, ps.hdc, TRUE);
        }
        else {
#ifdef _WIN32
            SetWindowOrgEx(hdc, lpcs->ptScroll.x, lpcs->ptScroll.y, NULL);
#else
            SetWindowOrg(hdc, lpcs->ptScroll.x, lpcs->ptScroll.y);
#endif
            DibPaint(lpcs, hdc);
        }
        EndPaint(hwnd, &ps);
        break;

    default:
        break;
    }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

#if 0
void dummyTest ()
{
    HWND hwnd;
    FARPROC fpProc;
    DWORD dwSize;
    WORD  wSize;
    BOOL f;
    int i;
    char szName[80];
    char szVer[80];
    DWORD dwMS;
    int iFrames, iColors;
    char s;
    LPPOINT lpP;

    capSetCallbackOnError(hwnd, fpProc);
    capSetCallbackOnStatus(hwnd, fpProc);
    capSetCallbackOnYield(hwnd, fpProc);
    capSetCallbackOnFrame(hwnd, fpProc);
    capSetCallbackOnVideoStream(hwnd, fpProc);
    capSetCallbackOnWaveStream(hwnd, fpProc);

    capDriverConnect(hwnd, i);
    capDriverDisconnect(hwnd);
    capDriverGetName(hwnd, szName, wSize);
    capDriverGetVersion(hwnd, szVer, wSize);
    capDriverGetCaps(hwnd, s, wSize);

    capFileSetCaptureFile(hwnd, szName);
    capFileGetCaptureFile(hwnd, szName, wSize);
    capFileAlloc(hwnd, dwSize);
    capFileSaveAs(hwnd, szName);

    capEditCopy(hwnd);

    capSetAudioFormat(hwnd, s, wSize);
    capGetAudioFormat(hwnd, s, wSize);
    capGetAudioFormatSize(hwnd);

    capDlgVideoFormat(hwnd);
    capDlgVideoSource(hwnd);
    capDlgVideoDisplay(hwnd);

    capPreview(hwnd, f);
    capPreviewRate(hwnd, dwMS);
    capOverlay(hwnd, f);
    capPreviewScale(hwnd, f);
    capGetStatus(hwnd, s, wSize);
    capSetScrollPos(hwnd, lpP);

    capGrabFrame(hwnd);
    capGrabFrameNoStop(hwnd);
    capCaptureSequence(hwnd);
    capCaptureSequenceNoFile(hwnd);
    capCaptureGetSetup(hwnd, s, wSize);
    capCaptureSetSetup(hwnd, s, wSize);

    capCaptureSingleFrameOpen(hwnd);
    capCaptureSingleFrameClose(hwnd);
    capCaptureSingleFrame(hwnd);

    capSetMCIDeviceName(hwnd, szName);
    capGetMCIDeviceName(hwnd, szName, wSize);

    capPalettePaste(hwnd);
    capPaletteAuto(hwnd, iFrames, iColors);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\iaverage.c ===
/*
 *
 * iaverage.c   Image averaging
 *
 * (C) Copyright Microsoft Corporation 1993. All rights reserved.
 *
 */

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <win32.h>
#include <memory.h>
#include <stdlib.h>
#include <ctype.h>
#include <memory.h>
#include <string.h>
#include <vfw.h>

#include "ivideo32.h"
#include "iaverage.h"

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) (int)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)
#define RGB16(r,g,b)      ((((WORD)(r) >> 3) << 10) | \
                          (((WORD)(g) >> 3) << 5)  | \
                          (((WORD)(b) >> 3) ) )

typedef BYTE HUGE  *   HPBYTE;
typedef WORD HUGE  *   HPWORD;
typedef DWORD HUGE *   HPDWORD;

#ifdef _WIN32
typedef RGBQUAD FAR * LPRGBQUAD;
#endif

#ifdef _WIN32
#define _fmemcpy	memcpy
#endif

/* Description:
        A sequence of images are averaged together using 16 bit
        accumulators for each of the Red, Green, and Blue components.
        The final processing step is to divide the accumulated values
        by the number of frames averaged, and transfer the results back
        into the destination DIB.

        Certain death will result if the image format is changed between
        iaverageInit and iaverageFini calls.
*/

//
// table to map a 5bit index (0-31) to a 8 bit value (0-255)
//
static BYTE aw5to8[32] = {(BYTE)-1};



/*
 *  iaverageInit
 *      Allocate memory for subsequent image averaging
 *      Return FALSE on error
 *
 */
BOOL iaverageInit (LPIAVERAGE FAR * lppia, LPBITMAPINFO lpbi, HPALETTE hPal)
{
    DWORD       dwSizeImage;
    LPIAVERAGE  lpia;
    int         i;

    *lppia = NULL;

    // Check for legal DIB formats
    if (lpbi->bmiHeader.biCompression != BI_RGB)
        return FALSE;

    if (lpbi->bmiHeader.biBitCount != 8 &&
        lpbi->bmiHeader.biBitCount != 16 &&
        lpbi->bmiHeader.biBitCount != 24 &&
        lpbi->bmiHeader.biBitCount != 32)
        return FALSE;

    //
    // init the 5bit to 8bit conversion table.
    //
    if (aw5to8[0] != 0)
        for (i=0; i<32; i++)
            aw5to8[i] = (BYTE)(i * 255 / 31);

    // Alloc memory for the image average structure
    lpia = (LPIAVERAGE) GlobalAllocPtr(GHND, sizeof (IAVERAGE));

    if (!lpia)
        return FALSE;

    // Save a copy of the header
    lpia->bi.bmiHeader = lpbi->bmiHeader;

    // and a copy of the color table and an inverse mapping table
    // if the image is 8 bit
    if (lpbi->bmiHeader.biBitCount == 8) {
        WORD r, g, b;
        LPBYTE lpB;

        hmemcpy (lpia->bi.bmiColors,
                        lpbi->bmiColors,
                        lpbi->bmiHeader.biClrUsed * sizeof (RGBQUAD));

        // Allocate and init the inverse LUT
        lpia->lpInverseMap= (LPBYTE) GlobalAllocPtr(GHND, 1024L * 32);
        lpB = lpia-> lpInverseMap;
        for (r = 0; r < 256; r += 8)
            for (g = 0; g < 256; g += 8)
                for (b = 0; b < 256; b += 8)
                    *lpB++ = (BYTE) GetNearestPaletteIndex (hPal, RGB(r,g,b));

    }

    dwSizeImage = lpbi->bmiHeader.biSizeImage;

    lpia->lpRGB = (LPWORD) GlobalAllocPtr(GHND,
					dwSizeImage * sizeof (WORD) * 3);

    if (lpia->lpRGB == 0) {
        // Allocation failed, clean up
        iaverageFini (lpia);
        return FALSE;
    }

    *lppia = lpia;

    return TRUE;
}


/*
 *  iaverageFini
 *      Free memory used for image averaging
 *      and the iaverage structure itself
 *
 */
BOOL iaverageFini (LPIAVERAGE lpia)
{
    if (lpia == NULL)
        return FALSE;

    if (lpia->lpInverseMap)
        GlobalFreePtr(lpia->lpInverseMap);
    if (lpia->lpRGB)
        GlobalFreePtr(lpia->lpRGB);

    GlobalFreePtr(lpia);

    return TRUE;
}


/*
 *  iaverageZero
 *      Zeros the accumulator
 *
 */
BOOL iaverageZero (LPIAVERAGE lpia)
{
    DWORD   dwC;
    HPWORD  hpW;

    if (lpia == NULL)
        return FALSE;

    hpW = (HPWORD) lpia->lpRGB;
    dwC = lpia->bi.bmiHeader.biSizeImage * 3;
    while (--dwC)
        *hpW++ = 0;

    lpia-> iCount = 0;

    return TRUE;
}

/*
 *  iaverageSum
 *      Add the current image into the accumulator
 *      Image format must be 16 or 24 bit RGB
 */
BOOL iaverageSum (LPIAVERAGE lpia, LPVOID lpBits)
{
    HPWORD      hpRGB;
    DWORD       dwC;
    WORD        wRGB16;
    HPWORD      hpW;
    HPBYTE      hpB;
    WORD        w;

    if (lpia == NULL)
        return FALSE;

    hpRGB   = (HPWORD) lpia->lpRGB;

    if (lpia->bi.bmiHeader.biBitCount == 8) {
        hpB = (HPBYTE) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage; --dwC; ) {
            w = (WORD) *hpB++;
            *hpRGB++   += lpia->bi.bmiColors[w].rgbBlue;
            *hpRGB++   += lpia->bi.bmiColors[w].rgbGreen;
            *hpRGB++   += lpia->bi.bmiColors[w].rgbRed;
        }
    }

    else if (lpia->bi.bmiHeader.biBitCount == 16) {
        hpW = (HPWORD) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage / 2; --dwC; ) {
            wRGB16 = *hpW++;

            *hpRGB++  += aw5to8 [wRGB16         & 0x1f]; // b
            *hpRGB++  += aw5to8 [(wRGB16 >> 5)  & 0x1f]; // g
            *hpRGB++  += aw5to8 [(wRGB16 >> 10) & 0x1f]; // r

        }
    }

    else if (lpia->bi.bmiHeader.biBitCount == 24) {
        hpB = (HPBYTE) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage; --dwC; ) {
            *hpRGB++  += *hpB++;
        }
    }

    else if (lpia->bi.bmiHeader.biBitCount == 32) {
        hpB = (HPBYTE) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage / 4; --dwC; ) {
            *hpRGB++  += *hpB++; // b
            *hpRGB++  += *hpB++; // g
            *hpRGB++  += *hpB++; // r
            hpB++;
        }
    }

    lpia-> iCount++;            // Image counter

    return TRUE;
}

/*
 *  iaverageDivide
 *      Divide by the number of images captured, and xfer back into the
 *      destination DIB.
 *
 */
BOOL iaverageDivide (LPIAVERAGE lpia, LPVOID lpBits)
{
    HPWORD      hpRGB;
    WORD        r, g, b, w;
    DWORD       dwC;
    HPWORD      hpW;
    HPBYTE      hpB;

    if (lpia == NULL || lpia-> iCount == 0)
        return FALSE;

    hpRGB   = (HPWORD) lpia->lpRGB;

    if (lpia->bi.bmiHeader.biBitCount == 8) {
        hpB = (HPBYTE) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage; --dwC; ) {
            b = *hpRGB++ / lpia-> iCount;
            g = *hpRGB++ / lpia-> iCount;
            r = *hpRGB++ / lpia-> iCount;

            w = RGB16(r,g,b) & 0x7FFF;
            *hpB++ = * (lpia->lpInverseMap + w);

        }
    }

    else if (lpia->bi.bmiHeader.biBitCount == 16) {
        hpW = (HPWORD) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage / 2; --dwC; ) {
            b = *hpRGB++ / lpia-> iCount;
            g = *hpRGB++ / lpia-> iCount;
            r = *hpRGB++ / lpia-> iCount;

            *hpW++ = RGB16 (r, g, b);
        }
    }

    else if (lpia->bi.bmiHeader.biBitCount == 24) {
        hpB = (HPBYTE) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage; --dwC; ) {
            *hpB++ = (BYTE) (*hpRGB++  / lpia-> iCount);
        }
    }

    else if (lpia->bi.bmiHeader.biBitCount == 32) {
        hpB = (HPBYTE) lpBits;
        for (dwC = lpia->bi.bmiHeader.biSizeImage / 4; --dwC; ) {
            *hpB++ = (BYTE) (*hpRGB++ / lpia-> iCount); // b
            *hpB++ = (BYTE) (*hpRGB++ / lpia-> iCount); // g
            *hpB++ = (BYTE) (*hpRGB++ / lpia-> iCount); // r
            hpB++;
        }
    }

    return TRUE;
}

// The following appropriated from Toddla's CDIB

/*****************************************************************************
 *
 *  SumRGB
 *
 *****************************************************************************/

#define SumRGB16(b0,b1,b2,b3) (\
             ((((WORD)pal.palPalEntry[b0].peRed +         \
                (WORD)pal.palPalEntry[b1].peRed +         \
                (WORD)pal.palPalEntry[b2].peRed +         \
                (WORD)pal.palPalEntry[b3].peRed)          \
                & 0x03E) << 5) |                          \
                                                          \
             ((((WORD)pal.palPalEntry[b0].peGreen +       \
                (WORD)pal.palPalEntry[b1].peGreen +       \
                (WORD)pal.palPalEntry[b2].peGreen +       \
                (WORD)pal.palPalEntry[b3].peGreen)        \
                & 0x003E)) |                              \
                                                          \
             ((((WORD)pal.palPalEntry[b0].peBlue +        \
                (WORD)pal.palPalEntry[b1].peBlue +        \
                (WORD)pal.palPalEntry[b2].peBlue +        \
                (WORD)pal.palPalEntry[b3].peBlue)         \
                & 0x003E) >> 5) )

/*****************************************************************************
 *
 *  RGB16
 *
 *****************************************************************************/

typedef struct { BYTE b,g,r; } RGB24;

#define rgb16(r,g,b) (\
            ((UINT)(r) << 10) |  \
            ((UINT)(g) << 5)  |  \
            ((UINT)(b) << 0)  )

#define RGB16R(rgb)     aw5to8[((UINT)(rgb) >> 10) & 0x1F]
#define RGB16G(rgb)     aw5to8[((UINT)(rgb) >> 5)  & 0x1F]
#define RGB16B(rgb)     aw5to8[((UINT)(rgb) >> 0)  & 0x1F]
#define RGB16r(rgb)     ((BYTE)((UINT)(rgb) >> 10) & 0x1F)
#define RGB16g(rgb)     ((BYTE)((UINT)(rgb) >> 5)  & 0x1F)
#define RGB16b(rgb)     ((BYTE)((UINT)(rgb) >> 0)  & 0x1F)

/*****************************************************************************
 *
 *  Pel() used for 24bit Crunch
 *
 *****************************************************************************/

#define Pel(p,x) (BYTE)(BitCount == 1 ? Pel1(p,x) : \
                        BitCount == 4 ? Pel4(p,x) : Pel8(p,x))

#define Pel1(p,x)   (BYTE)bit(((HPBYTE)(p))[(x)/8],7-((x)%8))
#define Pel4(p,x)   (BYTE)((x & 1) ? (((HPBYTE)(p))[(x)/2] & 15) : (((HPBYTE)(p))[(x)/2] >> 4))
#define Pel8(p,x)   (BYTE)(((HPBYTE)(p))[(x)])
#define Pel16(p,x)  (((HPWORD)(p))[(x)])
#define Pel24(p,x)  (((RGB24 HUGE *)(p))[(x)])

/*****************************************************************************
 *
 *  CrunchDIB  - shrink a DIB down by 2 with color averaging
 *
 *     this routine works on 8, 16, 24, and 32 bpp DIBs
 *
 *     this routine can't be used "in place"
 *
 *****************************************************************************/

BOOL CrunchDIB(
    LPIAVERAGE lpia,                // image averaging structure
    LPBITMAPINFOHEADER  lpbiSrc,    // BITMAPINFO of source
    LPVOID              lpSrc,      // input bits to crunch
    LPBITMAPINFOHEADER  lpbiDst,    // BITMAPINFO of dest
    LPVOID              lpDst)      // output bits to crunch
{
    HPBYTE      pbSrc;
    HPBYTE      pbDst;
    HPBYTE      pb;
    HPWORD      pw;
    BYTE        r,g,b,b0,b1,b2,b3;
    WORD        w0,w1,w2,w3;
    RGB24       rgb0,rgb1,rgb2,rgb3;
    int         WidthBytesSrc;
    int         WidthBytesDst;
    UINT        x;
    UINT        y;
    UINT        dx;
    UINT        dy;
    int         i;
    COLORREF    rgb;
    int         BitCount;
    UINT        aw5to8[32];

     struct {
        WORD         palVersion;
	WORD         palNumEntries;
	PALETTEENTRY palPalEntry[256];
    }   pal;

   if (lpbiSrc->biCompression != BI_RGB)
        return FALSE;

    BitCount = (int)lpbiSrc->biBitCount;

    if (BitCount == 16)
        for (i=0; i<32; i++)
            aw5to8[i] = (UINT)i * 255u / 31u;

    dx = (int)lpbiDst->biWidth;
    WidthBytesDst = (((UINT)lpbiDst->biBitCount * dx + 31)&~31) / 8;

    dy = (int)lpbiSrc->biHeight;
    dx = (int)lpbiSrc->biWidth;
    WidthBytesSrc = (((UINT)lpbiSrc->biBitCount * dx + 31)&~31) / 8;

    dx &= ~1;
    dy &= ~1;

    pbSrc = lpSrc;
    pbDst = lpDst;

    if (lpbiSrc->biClrUsed == 0 && lpbiSrc->biBitCount <= 8)
        lpbiSrc->biClrUsed = (1 << (int)lpbiSrc->biBitCount);

    pal.palVersion = 0x300;
    pal.palNumEntries = (int)lpbiSrc->biClrUsed;

    for (i=0; i<(int)pal.palNumEntries; i++)
    {
        pal.palPalEntry[i].peRed   = ((LPRGBQUAD)(lpbiSrc+1))[i].rgbRed;
        pal.palPalEntry[i].peGreen = ((LPRGBQUAD)(lpbiSrc+1))[i].rgbGreen;
        pal.palPalEntry[i].peBlue  = ((LPRGBQUAD)(lpbiSrc+1))[i].rgbBlue;
        pal.palPalEntry[i].peFlags = 0;
    }

    if (lpbiDst->biBitCount == 8)
        _fmemcpy(lpbiDst+1,lpbiSrc+1,(int)lpbiSrc->biClrUsed*sizeof(RGBQUAD));

    if ((int)lpbiDst->biBitCount == (int)lpbiSrc->biBitCount)
    {
        switch((int)lpbiSrc->biBitCount)
        {
        case 8:
            for (y=0; y<dy; y+=2)
            {
                pb = pbDst;

                for (x=0; x<dx; x+=2)
                {
                    b0 = Pel8(pbSrc,x);
                    b1 = Pel8(pbSrc+WidthBytesSrc, x);
                    b2 = Pel8(pbSrc,x+1);
                    b3 = Pel8(pbSrc+WidthBytesSrc,x+1);

                    r = (BYTE) ((
                        (WORD)pal.palPalEntry[b0].peRed +
                        (WORD)pal.palPalEntry[b1].peRed +
                        (WORD)pal.palPalEntry[b2].peRed +
                        (WORD)pal.palPalEntry[b3].peRed) >> 2);

                    g = (BYTE) ((
                        (WORD)pal.palPalEntry[b0].peGreen +
                        (WORD)pal.palPalEntry[b1].peGreen +
                        (WORD)pal.palPalEntry[b2].peGreen +
                        (WORD)pal.palPalEntry[b3].peGreen) >> 2);

                    b = (BYTE) ((
                        (WORD)pal.palPalEntry[b0].peBlue +
                        (WORD)pal.palPalEntry[b1].peBlue +
                        (WORD)pal.palPalEntry[b2].peBlue +
                        (WORD)pal.palPalEntry[b3].peBlue) >> 2);

                    *pb++ = (BYTE)(*(lpia->lpInverseMap +
                                RGB16 (r, g, b)));
                }

                pbSrc += WidthBytesSrc*2;
                pbDst += WidthBytesDst;
            }
            break;

        case 16:
            for (y=0; y<dy; y+=2)
            {
                pw = (HPWORD)pbDst;

		for (x=0; x<dx; x += 2)
                {
                    w0 = Pel16(pbSrc,x);
                    w1 = Pel16(pbSrc,x+1);
                    w2 = Pel16(pbSrc+WidthBytesSrc,x);
                    w3 = Pel16(pbSrc+WidthBytesSrc,x+1);

                    r = ((BYTE)RGB16r(w0) + RGB16r(w1) + RGB16r(w2) + RGB16r(w3)) >> 2;
                    g = ((BYTE)RGB16g(w0) + RGB16g(w1) + RGB16g(w2) + RGB16g(w3)) >> 2;
                    b = ((BYTE)RGB16b(w0) + RGB16b(w1) + RGB16b(w2) + RGB16b(w3)) >> 2;

                    *pw++ = rgb16(r,g,b);
                }

                pbSrc += WidthBytesSrc*2;
                pbDst += WidthBytesDst;
            }
            break;

        case 24:
            for (y=0; y<dy; y+=2)
            {
                pb = pbDst;

		for (x=0; x<dx; x += 2)
                {
                    rgb0 = Pel24(pbSrc,x);
                    rgb1 = Pel24(pbSrc,x+1);
                    rgb2 = Pel24(pbSrc+WidthBytesSrc,x);
                    rgb3 = Pel24(pbSrc+WidthBytesSrc,x+1);

                    rgb = RGB(
                        ((UINT)rgb0.r + rgb1.r + rgb2.r + rgb3.r)/4,
                        ((UINT)rgb0.g + rgb1.g + rgb2.g + rgb3.g)/4,
                        ((UINT)rgb0.b + rgb1.b + rgb2.b + rgb3.b)/4);

                    *pb++ = GetBValue(rgb);
                    *pb++ = GetGValue(rgb);
                    *pb++ = GetRValue(rgb);
                }

                pbSrc += WidthBytesSrc*2;
                pbDst += WidthBytesDst;
            }
            break;

        case 32:
            for (y=0; y<dy; y+=2)
            {
                pb = pbDst;

		for (x=0; x<dx; x += 2)
                {
                    rgb0 = Pel24(pbSrc,x);
                    rgb1 = Pel24(pbSrc,x+1);
                    rgb2 = Pel24(pbSrc+WidthBytesSrc,x);
                    rgb3 = Pel24(pbSrc+WidthBytesSrc,x+1);

                    rgb = RGB(
                        ((UINT)rgb0.r + rgb1.r + rgb2.r + rgb3.r)/4,
                        ((UINT)rgb0.g + rgb1.g + rgb2.g + rgb3.g)/4,
                        ((UINT)rgb0.b + rgb1.b + rgb2.b + rgb3.b)/4);

                    *pb++ = GetBValue(rgb);
                    *pb++ = GetGValue(rgb);
                    *pb++ = GetRValue(rgb);
                    pb++;
                }

                pbSrc += WidthBytesSrc*2;
                pbDst += WidthBytesDst;
            }
            break;

        default:
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\mmdebug.h ===
/*
 * johnkn's debug logging and assert macros
 *
 */

#if !defined _INC_MMDEBUG_
#define _INC_MMDEBUG_
//
// prototypes for debug functions.
//
#if !defined(_WIN32) && !defined(LPTSTR)
    #define LPTSTR LPSTR
#endif

    #define SQUAWKNUMZ(num) #num
    #define SQUAWKNUM(num) SQUAWKNUMZ(num)
    #define SQUAWK __FILE__ "(" SQUAWKNUM(__LINE__) ") ----"
    #define DEBUGLINE __FILE__ "(" SQUAWKNUM(__LINE__) ") "

    #if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL

        int  FAR _cdecl AuxDebugEx(int, LPSTR, ...);
        VOID WINAPI AuxDebugDump (int, LPVOID, int);
        int  WINAPI DebugSetOutputLevel (int);

       #if defined DEBUG_RETAIL
        #define INLINE_BREAK
       #else
        #ifdef _X86_
         #define INLINE_BREAK _asm {int 3}
        #else
         #define INLINE_BREAK DebugBreak()
        #endif
       #endif

       #if 0
        #undef  assert
        #define assert(exp) \
            (void)((exp) ? 0 : AuxDebugEx(-2, DEBUGLINE "assert failed: " #exp "\r\n", (int)__LINE__))

        #undef  assert2
        #define assert2(exp,sz) \
            (void)((exp) ? 0 : AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (int)__LINE__))
       #else
        #undef  assert
        #define assert(exp); {\
            if (!(exp)) {\
                AuxDebugEx(-2, DEBUGLINE "assert failed: " #exp "\r\n", (int)__LINE__); \
                INLINE_BREAK;\
                }\
            }
        #undef  assert2
        #define assert2(exp,sz); {\
            if (!(exp)) {\
                AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (int)__LINE__); \
                INLINE_BREAK;\
                }\
            }
        #undef  assert3
        #define assert3(exp,sz,arg); {\
            if (!(exp)) {\
                AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (int)__LINE__, (arg)); \
                INLINE_BREAK;\
                }\
            }
       #endif

     #ifndef STATICFN
      #define STATICFN
     #endif

    #else // defined(DEBUG)

      #define AuxDebugEx  1 ? (void)0 : (void)
      #define AuxDebugDump(a,b,c)

      #define assert(a)      ((void)0)
      #define assert2(a,b)   ((void)0)
      #define assert3(a,b,c) ((void)0)

      #define INLINE_BREAK
      #define DebugSetOutputLevel(i)
     #ifndef STATICFN
      #define STATICFN static
     #endif

   #endif // defined(DEBUG)

   #define AuxDebug(sz) AuxDebugEx (1, DEBUGLINE sz "\r\n")
   #define AuxDebug2(sz,a) AuxDebugEx (1, DEBUGLINE sz "\r\n", (a))

#endif //_INC_MMDEBUG_

// =============================================================================

//
// include this in only one module in a DLL or APP
//
#if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL
    #if (defined _INC_MMDEBUG_CODE_) && (_INC_MMDEBUG_CODE_ != FALSE)
    #undef _INC_MMDEBUG_CODE_
    #define _INC_MMDEBUG_CODE_ FALSE

    #include <stdarg.h>

    #if !defined _WIN32 && !defined wvsprintfA
     #define wvsprintfA wvsprintf
    #endif

    int    debug_OutputOn = 0;

    /*+ AuxDebug - create a formatted string and output to debug terminal
     *
     *-=================================================================*/

    int FAR _cdecl AuxDebugEx (
       int    iLevel,
       LPSTR lpFormat,
       ...)
       {
      #ifdef _WIN32
       char     szBuf[1024];
      #else
       static char  szBuf[512];
      #endif
       int      cb;
       va_list  va;
       char FAR * psz;

       if (debug_OutputOn >= iLevel)
          {
          va_start (va, lpFormat);
          cb = wvsprintfA (szBuf, lpFormat, va);
          va_end (va);

          // eat leading ..\..\ which we get from __FILE__ since
          // george's wierd generic makefile stuff.
          //
          psz = szBuf;
          while (psz[0] == '.' && psz[1] == '.' && psz[2] == '\\')
             psz += 3;

          #ifdef MODULE_DEBUG_PREFIX
           if (psz != szBuf)
              OutputDebugStringA (MODULE_DEBUG_PREFIX);
          #endif

          OutputDebugStringA (psz);
          }

       return cb;
       }

    /*+ AuxDebugDump -
     *
     *-=================================================================*/

    VOID WINAPI AuxDebugDump (
       int    iLevel,
       LPVOID lpvData,
       int    nCount)
       {
       LPBYTE   lpData = lpvData;
       char     szBuf[128];
       LPSTR    psz;
       int      cb;
       int      ix;
       BYTE     abRow[8];

       if (debug_OutputOn <= iLevel || nCount <= 0)
          return;

       do {
          cb = wsprintfA(szBuf, "\t%08X: ", lpData);
          psz = szBuf + cb;

          for (ix = 0; ix < 8; ++ix)
             {
             LPBYTE lpb = lpData;

             abRow[ix] = '.';
             if (IsBadReadPtr (lpData + ix, 1))
                lstrcpyA (psz, ".. ");
             else
                {
                wsprintfA (psz, "%02X ", lpData[ix]);
                if (lpData[ix] >= 32 && lpData[ix] < 127)
                    abRow[ix] = lpData[ix];
                }
             psz += 3;
             }
          for (ix = 0; ix < 8; ++ix)
             *psz++ = abRow[ix];

          lstrcpyA (psz, "\r\n");

          OutputDebugStringA (szBuf);

          } while (lpData += 8, (nCount -= 8) > 0);

       return;
       }

    /*+ DebugSetOutputLevel
     *
     *-=================================================================*/

    BOOL  WINAPI DebugSetOutputLevel (
        int nLevel)
        {
        int nOldLevel = debug_OutputOn;
        debug_OutputOn = nLevel;
        return nOldLevel;
        }

    #endif // _INC_MMDEBUG_CODE_
#endif // DEBUG || _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\ivideo32.h ===
/****************************************************************************/
/*                                                                          */
/*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY   */
/*  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE     */
/*  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR   */
/*  PURPOSE.								    */
/*        MSVIDEO.H - Include file for Video APIs                           */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1993, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_IVIDEO32
#define _INC_IVIDEO32   50      /* version number */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#include <vfw.h>

#define LOADDS
#define EXPORT

#if defined(_WIN32) && defined(UNICODE)
// unicode conversions

int Iwcstombs(LPSTR lpstr, LPCWSTR lpwstr, int len);
int Imbstowcs(LPWSTR lpwstr, LPCSTR lpstr, int len);

#endif

//#ifndef _RCINVOKED
///* video data types */
//DECLARE_HANDLE(HVIDEO);                 // generic handle
//typedef HVIDEO FAR * LPHVIDEO;
//#endif                                  // ifndef RCINVOKED

/****************************************************************************

                        video APIs

****************************************************************************/

#if defined _WIN32

#if defined DAYTONA
void videoInitHandleList(void);
void videoDeleteHandleList(void);
#endif

#if defined CHICAGO

  typedef struct _thk_videohdr {
      VIDEOHDR vh;
      LPBYTE   p32Buff;
      DWORD    p16Alloc;
      DWORD    dwMemHandle;
      DWORD    dwReserved;
  } THKVIDEOHDR, FAR *LPTHKVIDEOHDR;

  WORD FAR PASCAL _loadds capxGetDriverDescription (WORD wDriverIndex,
        LPSTR lpszName, WORD cbName,
        LPSTR lpszVer, WORD cbVer);

  DWORD WINAPI vidxAllocHeaders(
      HVIDEO          hVideo,
      UINT            nHeaders,
      LPTHKVIDEOHDR * lpHdrs);

  DWORD WINAPI vidxFreeHeaders(
      HVIDEO hv);

  DWORD WINAPI vidxAllocBuffer (
      HVIDEO          hv,
      UINT            iHdr,
      LPTHKVIDEOHDR * pp32Hdr,
      DWORD           dwSize);

  DWORD vidxFreeBuffer (
      HVIDEO hv,
      DWORD  p32Hdr);

  DWORD WINAPI vidxSetRect (
      HVIDEO hv,
      UINT wMsg,
      int left,
      int top,
      int right,
      int bottom);

  DWORD WINAPI vidxFrame (
      HVIDEO     hVideo,
      LPVIDEOHDR lpVHdr);

  #define videoSetRect(h,msg,rc) vidxSetRect (h, msg, rc.left, rc.top, rc.right, rc.bottom)

  DWORD WINAPI vidxAddBuffer (
      HVIDEO     hVideo,
      LPVIDEOHDR lpVHdr,
      DWORD      cbData);

  DWORD WINAPI vidxAllocPreviewBuffer (
      HVIDEO     hVideo,
      LPVOID     *lpBits,
      DWORD      cbData);

  DWORD WINAPI vidxFreePreviewBuffer (
      HVIDEO     hVideo,
      LPVOID     lpBits);

  DWORD WINAPI videoOpen  (LPHVIDEO lphVideo,
              DWORD dwDevice, DWORD dwFlags);
  DWORD WINAPI videoClose (HVIDEO hVideo);
  DWORD WINAPI videoDialog(HVIDEO hVideo, HWND hWndParent, DWORD dwFlags);
  DWORD WINAPI videoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps,
              DWORD dwSize);
  DWORD WINAPI videoUpdate (HVIDEO hVideo, HWND hWnd, HDC hDC);
  DWORD WINAPI videoConfigure (HVIDEO hVideo, UINT msg, DWORD dwFlags,
              LPDWORD lpdwReturn, LPVOID lpData1, DWORD dwSize1,
              LPVOID lpData2, DWORD dwSize2);

  DWORD WINAPI videoFrame(HVIDEO hVideo, LPVIDEOHDR lpVHdr);
  DWORD WINAPI videoGetErrorText(HVIDEO hVideo, UINT wError,
              LPSTR lpText, UINT wSize);
  DWORD WINAPI videoStreamInit(HVIDEO hVideo,
              DWORD dwMicroSecPerFrame, DWORD_PTR dwCallback,
              DWORD_PTR dwCallbackInst, DWORD dwFlags);
  DWORD WINAPI videoStreamFini(HVIDEO hVideo);

  //DWORD WINAPI videoStreamPrepareHeader(HVIDEO hVideo,
  //            LPVIDEOHDR lpVHdr, DWORD dwSize);
  //DWORD WINAPI videoStreamAddBuffer(HVIDEO hVideo,
  //            LPVIDEOHDR lpVHdr, DWORD dwSize);
  DWORD WINAPI videoStreamReset(HVIDEO hVideo);
  DWORD WINAPI videoStreamStart(HVIDEO hVideo);
  DWORD WINAPI videoStreamStop(HVIDEO hVideo);
  DWORD WINAPI videoStreamUnprepareHeader(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);


#else
 #define videoSetRect(h,msg,rc) videoMessage (h, msg, (DWORD_PTR)(LPVOID)&rc, VIDEO_CONFIGURE_SET)

DWORD WINAPI videoGetNumDevs(void);

DWORD WINAPI videoOpen  (LPHVIDEO lphVideo,
              DWORD dwDevice, DWORD dwFlags);
DWORD WINAPI videoClose (HVIDEO hVideo);
DWORD WINAPI videoDialog(HVIDEO hVideo, HWND hWndParent, DWORD dwFlags);
DWORD WINAPI videoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps,
                DWORD dwSize);
DWORD WINAPI videoUpdate (HVIDEO hVideo, HWND hWnd, HDC hDC);
DWORD WINAPI videoConfigure (HVIDEO hVideo, UINT msg, DWORD dwFlags,
		LPDWORD lpdwReturn, LPVOID lpData1, DWORD dwSize1,
                LPVOID lpData2, DWORD dwSize2);

DWORD WINAPI videoConfigureStorage (HVIDEO hVideo,
                      LPTSTR lpstrIdent, DWORD dwFlags);

DWORD WINAPI videoFrame(HVIDEO hVideo, LPVIDEOHDR lpVHdr);
LRESULT WINAPI videoMessage(HVIDEO hVideo, UINT msg, LPARAM dwP1, LPARAM dwP2);

/* streaming APIs */
DWORD WINAPI videoStreamAddBuffer(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamGetError(HVIDEO hVideo, LPDWORD lpdwErrorFirst,
        LPDWORD lpdwErrorLast);

DWORD WINAPI videoGetErrorTextA(HVIDEO hVideo, UINT wError,
              LPSTR lpText, UINT wSize);
DWORD WINAPI videoGetErrorTextW(HVIDEO hVideo, UINT wError,
              LPWSTR lpText, UINT wSize);

#ifdef UNICODE
  #define videoGetErrorText  videoGetErrorTextW
#else
  #define videoGetErrorText  videoGetErrorTextA
#endif // !UNICODE

DWORD WINAPI videoStreamGetPosition(HVIDEO hVideo, MMTIME FAR* lpInfo,
              DWORD dwSize);
DWORD WINAPI videoStreamInit(HVIDEO hVideo,
              DWORD dwMicroSecPerFrame, DWORD_PTR dwCallback,
              DWORD_PTR dwCallbackInst, DWORD dwFlags);
DWORD WINAPI videoStreamFini(HVIDEO hVideo);
DWORD WINAPI videoStreamPrepareHeader(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamReset(HVIDEO hVideo);
DWORD WINAPI videoStreamStart(HVIDEO hVideo);
DWORD WINAPI videoStreamStop(HVIDEO hVideo);
DWORD WINAPI videoStreamUnprepareHeader(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);

// Added for Win95 & NT PPC
//
DWORD WINAPI videoStreamAllocBuffer(HVIDEO hVideo,
              LPVOID FAR * plpBuffer, DWORD dwSize);
DWORD WINAPI videoStreamFreeBuffer(HVIDEO hVideo,
              LPVOID lpBuffer);
#endif // CHICAGO
#endif // _WIN32

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDEO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\mmtimers.h ===
/* + mmtimers.h
 *
 * Accurate timers using pentium cpu clock, QueryPerformanceCounter
 * or GetTickCount depending on what system the code is run on
 *
 * Copyright (C) 1995, Microsoft Corporation, all rights reserved
 *
 *-========================================================================*/
 
#if !defined _INC_MMTIMERS_
#define _INC_MMTIMERS_

  typedef struct {
    DWORD dwlo;
    DWORD dwhi;
    } PCTIMER, NEAR * PPCTIMER;

  struct _pctimer_global {
    DWORD    dwRawHz;
    DWORD    dwMicroAdjust;
    union {
      DWORD    dwRawKhz;
      WORD     wRawKhz;
    };
    union {
      DWORD    dwRawMhz;
      WORD     wRawMhz;
    };
    DWORD    dwTimerKhz;
    PCTIMER  base;
    DWORD (WINAPI * DifTicks     )(PCTIMER *);
    DWORD (WINAPI * DifMicrosec  )(PCTIMER *);
    DWORD (WINAPI * DifMillisec  )(PCTIMER *);
    DWORD (WINAPI * DeltaTicks   )(PCTIMER *);
    DWORD (WINAPI * DeltaMicrosec)(PCTIMER *);
    DWORD (WINAPI * DeltaMillisec)(PCTIMER *);
    UINT     uTimerType;
    };
  extern struct _pctimer_global pc;

  extern VOID WINAPI InitPerformanceCounters ();

  #define pcBegin()          pc.DeltaTicks(&pc.base)
  #define pcGetTime()        pc.DifMillisec(&pc.base)
  #define pcGetTicks()       pc.DifMicrosec(&pc.base)
  #define pcGetTickRate()   (pc.dwTimerKhz * 1000)
  #define pcBeginTimer(ppt) (pc.DeltaMicrosec(ppt), 0)
  #define pcDeltaTicks(ppt)  pc.DeltaMicrosec(ppt)

#endif //_INC_MMTIMERS_

// =============================================================================

//
// include this in only one module in a DLL or APP
//   
#if (defined _INC_MMTIMERS_CODE_) && (_INC_MMTIMERS_CODE_ != FALSE)
#undef _INC_MMTIMERS_CODE_
#define _INC_MMTIMERS_CODE_ FALSE

  static DWORD WINAPI tgtDeltaTime (PCTIMER *pctimer)
  {
        DWORD dwTime = timeGetTime();
        DWORD dwDelta = dwTime - pctimer->dwlo;
        pctimer->dwlo = dwTime;
        return dwDelta;
  }

  static DWORD WINAPI tgtDiffTime (PCTIMER *pctimer)
  {
        return timeGetTime() - pctimer->dwlo;
  }

  struct _pctimer_global pc = {1000, 0, 1, 0, 1,
                               0, 0,
                               (LPVOID)tgtDiffTime,
                               (LPVOID)tgtDiffTime,
                               (LPVOID)tgtDiffTime,
                               (LPVOID)tgtDeltaTime,
                               (LPVOID)tgtDeltaTime,
                               (LPVOID)tgtDeltaTime,
                               0,
                               };

  #if defined WIN32 || defined _WIN32

    #if !defined _X86_
      #define Scale(value,scalar) (DWORD)((value).QuadPart / (scalar))
    #else
      //
      // c9 wants to do LARGE_INTEGER division by calling a library
      // routine. We get a link error for projects that are not
      // already using the C-runtime, so to avoid that, we do the division
      // using x86 assembler
      //
      #pragma warning(disable:4704)
      #pragma warning(disable:4035)
      DWORD _inline Scale(
          LARGE_INTEGER value,
          DWORD         scalar)
      {
          _asm {
            mov  ecx, scalar
            mov  eax, value.LowPart
            mov  edx, value.HighPart
            jecxz bail
            cmp  edx, ecx
            jb ok_to_divide
            push eax
            mov  eax, edx
            xor  edx, edx
            div  ecx
            pop  eax
          ok_to_divide:
            div  ecx
          bail:
          }
      }
    #endif

    static VOID WINAPI qpcInitTimer (PCTIMER * pbase)
    {
       QueryPerformanceCounter ((LPVOID)pbase);
    }

    static DWORD WINAPI qpcDiffTicks (PCTIMER * pbase)
    {
       LARGE_INTEGER *plarge = (LPVOID)pbase;
       LARGE_INTEGER ticks;

       QueryPerformanceCounter (&ticks);
       ticks.QuadPart -= plarge->QuadPart;
       return ticks.LowPart;
    }

    static DWORD WINAPI qpcDiffMicrosec (PCTIMER * pbase)
    {
       LARGE_INTEGER *plarge = (LPVOID)pbase;
       LARGE_INTEGER ticks;

       QueryPerformanceCounter (&ticks);
       ticks.QuadPart -= plarge->QuadPart;
       ticks.LowPart = Scale(ticks, pc.dwRawMhz);
       if (pc.dwMicroAdjust)
           return MulDiv (ticks.LowPart, 1000000, pc.dwMicroAdjust);
       return ticks.LowPart;
    }

    static DWORD WINAPI qpcDiffMillisec (PCTIMER * pbase)
    {
       LARGE_INTEGER *plarge = (LPVOID)pbase;
       LARGE_INTEGER ticks;

       QueryPerformanceCounter (&ticks);
       ticks.QuadPart -= plarge->QuadPart;
       return Scale(ticks, pc.dwRawKhz);
    }

    static DWORD WINAPI qpcDeltaTicks (PCTIMER * pbase)
    {
       LARGE_INTEGER *plarge = (LPVOID)pbase;
       LARGE_INTEGER ticks = *plarge;

       QueryPerformanceCounter (plarge);
       ticks.QuadPart = plarge->QuadPart - ticks.QuadPart;
       return ticks.LowPart;
    }

    static DWORD WINAPI qpcDeltaMicrosec (PCTIMER * pbase)
    {
       LARGE_INTEGER *plarge = (LPVOID)pbase;
       LARGE_INTEGER ticks = *plarge;

       QueryPerformanceCounter (plarge);
       ticks.QuadPart = plarge->QuadPart - ticks.QuadPart;
       ticks.LowPart = Scale(ticks, pc.dwRawMhz);
       if (pc.dwMicroAdjust)
           return MulDiv (ticks.LowPart, 1000000, pc.dwMicroAdjust);
       return ticks.LowPart;
    }

    static DWORD WINAPI qpcDeltaMillisec (PCTIMER * pbase)
    {
       LARGE_INTEGER *plarge = (LPVOID)pbase;
       LARGE_INTEGER ticks = *plarge;

       QueryPerformanceCounter (plarge);
       ticks.QuadPart = plarge->QuadPart - ticks.QuadPart;
       return Scale(ticks, pc.dwRawKhz);
    }

    static DWORD WINAPI qpcTimerFreq ()
    {
       LARGE_INTEGER freq;
       if (QueryPerformanceFrequency (&freq))
          return freq.LowPart;
       return 0;
    }

    #ifdef _X86_

      #pragma warning(disable:4704)
      #pragma warning(disable:4035)

      static VOID WINAPI p5InitTimer (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov ebx, pBase
            mov [ebx], eax
            mov [ebx+4], edx
         }
      }

      static DWORD WINAPI p5DiffTicks (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov ebx, pBase
            sub eax, [ebx]
            sbb edx, [ebx+4]
         }
      }

      static DWORD WINAPI p5DiffMicrosec (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov ebx, pBase
            sub eax, [ebx]
            sbb edx, [ebx+4]

            mov  ecx, pc.dwRawMhz
            jecxz bail
            cmp  edx, ecx
            jb ok_to_divide
            push eax
            mov  eax, edx
            xor  edx, edx
            div  ecx
            pop  eax
          ok_to_divide:
            div  ecx
          bail:
         }
      }

      static DWORD WINAPI p5DiffMillisec (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov ebx, pBase
            sub eax, [ebx]
            sbb edx, [ebx+4]

            mov  ecx, pc.dwRawKhz
            jecxz bail
            cmp  edx, ecx
            jb ok_to_divide
            push eax
            mov  eax, edx
            xor  edx, edx
            div  ecx
            pop  eax
          ok_to_divide:
            div  ecx
          bail:
         }
      }

      static DWORD WINAPI p5DeltaTicks (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov  ebx, pBase
            mov  ecx, eax
            sub  eax, [ebx]
            mov  [ebx], ecx
            mov  ecx, edx
            sbb  edx, [ebx+4]
            mov  [ebx+4], ecx
         }
      }
      static DWORD WINAPI p5DeltaMicrosec (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov  ebx, pBase
            mov  ecx, eax
            sub  eax, [ebx]
            mov  [ebx], ecx
            mov  ecx, edx
            sbb  edx, [ebx+4]
            mov  [ebx+4], ecx

            mov  ecx, pc.dwRawMhz
            jecxz bail
            cmp  edx, ecx
            jb ok_to_divide
            push eax
            mov  eax, edx
            xor  edx, edx
            div  ecx
            pop  eax
          ok_to_divide:
            div  ecx
          bail:
         }
      }

      static DWORD WINAPI p5DeltaMillisec (PCTIMER * pBase)
      {
         _asm {
            _emit 0x0f
            _emit 0x31

            mov  ebx, pBase
            mov  ecx, eax
            sub  eax, [ebx]
            mov  [ebx], ecx
            mov  ecx, edx
            sbb  edx, [ebx+4]
            mov  [ebx+4], ecx

            mov  ecx, pc.dwRawKhz
            jecxz bail
            cmp  edx, ecx
            jb ok_to_divide
            push eax
            mov  eax, edx
            xor  edx, edx
            div  ecx
            pop  eax
          ok_to_divide:
            div  ecx
          bail:
         }
      }

      static DWORD WINAPI p5TimerFreq ()
      {
          SYSTEM_INFO si;

          GetSystemInfo(&si);
          if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL &&
              si.wProcessorLevel == 5
             )
          {
             PCTIMER timer;
             LARGE_INTEGER qpc1, qpc2;
             DWORD   dwTime;
             DWORD   dwTicks;
             OSVERSIONINFO osv;
             #define MS_INTERVAL 500

             // pentium timers dont work correctly on NT so
             // dont use them
             //
             {
             osv.dwOSVersionInfoSize = sizeof(osv);
             GetVersionEx (&osv);
             }

             // dont use pentium timers if they take more
             // than about 12 microsec to execute
             //
             p5InitTimer  (&timer);
             if (p5DeltaTicks (&timer) > (60 * 12) &&
                 p5DeltaTicks (&timer) > (60 * 12))
             {
                // pentium timers are too slow to try and use them.
                // just go with QueryPerformanceCounter instead
                //
                return 0;
             }

             // for some reason, if you use timeBeginPeriod
             // on NT.  it decides that my 90mhz pentium is an 88mhz
             // pentium.
             //
             //if (osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
             //   timeBeginPeriod (1);

             p5InitTimer (&timer);
             QueryPerformanceCounter (&qpc1);
             Sleep(MS_INTERVAL);
             QueryPerformanceCounter (&qpc2);
             dwTicks = p5DiffTicks(&timer);

             //if (osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
             //   timeEndPeriod (1);

             dwTime = (DWORD)(qpc2.QuadPart - qpc1.QuadPart);
             QueryPerformanceFrequency (&qpc1);
             dwTime = MulDiv(dwTime, 1000, qpc1.LowPart);

             if (dwTime < MS_INTERVAL * 9 / 10)
                return 0;

             pc.dwRawMhz = (dwTicks + dwTime * 1000/2) /dwTime /1000;
             pc.dwRawKhz = pc.dwRawMhz * 1000;
             pc.dwRawHz  = pc.dwRawKhz * 1000;
             pc.dwMicroAdjust = 0;
             pc.dwTimerKhz = 1000;

             return pc.dwRawHz;
          }

          return 0;
      }

    #endif

    VOID WINAPI InitPerformanceCounters (void)
    {
        DWORD dwFreq;

       #ifdef _X86_
        if (p5TimerFreq())
        {
            pc.DifTicks      = p5DiffTicks;
            pc.DifMicrosec   = p5DiffMicrosec;
            pc.DifMillisec   = p5DiffMillisec;
            pc.DeltaTicks    = p5DeltaTicks;
            pc.DeltaMicrosec = p5DeltaMicrosec;
            pc.DeltaMillisec = p5DeltaMillisec;
            pc.uTimerType    = 5;
            return;
        }
       #endif

        if (dwFreq = qpcTimerFreq())
        {
            pc.dwRawKhz = dwFreq / 1000;
            pc.dwRawMhz = pc.dwRawKhz / 1000;
            pc.dwMicroAdjust = dwFreq / pc.dwRawMhz;
            if (pc.dwMicroAdjust == 1000000)
                pc.dwMicroAdjust = 0;
            pc.dwTimerKhz = 1000;

            pc.DifTicks      = qpcDiffTicks;
            pc.DifMicrosec   = qpcDiffMicrosec;
            pc.DifMillisec   = qpcDiffMillisec;
            pc.DeltaTicks    = qpcDeltaTicks;
            pc.DeltaMicrosec = qpcDeltaMicrosec;
            pc.DeltaMillisec = qpcDeltaMillisec;
            pc.uTimerType    = 1;
        }
    }

  #else // win16

    #pragma warning(disable:4704)
    #pragma warning(disable:4035)

    static VOID WINAPI p5InitTimer (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          xor bx, bx
          mov bx, pBase
          _emit 0x66
          mov [bx], ax
          _emit 0x66
          mov [bx+4], dx
       }
    }

    static DWORD WINAPI p5DiffTicks (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          xor bx, bx
          mov bx, pBase
          _emit 0x66
          sub ax, [bx]
          _emit 0x66
          sbb dx, [bx+4]
       }
    }

    static DWORD WINAPI p5DiffMicrosec (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          xor bx, bx
          mov bx, pBase
          _emit 0x66
          sub ax, [bx]
          _emit 0x66
          sbb dx, [bx+4]

          //_emit 0x66
          mov  cx, pc.wRawMhz
          _emit 0x66
          jcxz bail
          _emit 0x66
          cmp  dx, cx
          jb ok_to_divide
          _emit 0x66
          push ax
          _emit 0x66
          mov  ax, dx
          _emit 0x66
          xor  dx, dx
          _emit 0x66
          div  cx
          _emit 0x66
          pop  ax
        ok_to_divide:
          _emit 0x66
          div  cx
        bail:
       }
    }

    static DWORD WINAPI p5DiffMillisec (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          xor bx, bx
          mov bx, pBase
          _emit 0x66
          sub ax, [bx]
          _emit 0x66
          sbb dx, [bx+4]

          _emit 0x66
          mov  cx, pc.wRawKhz
          _emit 0x66
          jcxz  bail
          _emit 0x66
          cmp  dx, cx
          jb ok_to_divide
          _emit 0x66
          push ax
          _emit 0x66
          mov  ax, dx
          _emit 0x66
          xor  dx, dx
          _emit 0x66
          div  cx
          _emit 0x66
          pop  ax
        ok_to_divide:
          _emit 0x66
          div  cx
        bail:
       }
    }

    static DWORD WINAPI p5DeltaTicks (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          mov  bx, pBase
          _emit 0x66
          mov  cx, ax
          _emit 0x66
          sub  ax, [bx]
          _emit 0x66
          mov  [bx], cx
          _emit 0x66
          mov  cx, dx
          _emit 0x66
          sbb  dx, [bx+4]
          _emit 0x66
          mov  [bx+4], cx
       }
    }
    static DWORD WINAPI p5DeltaMicrosec (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          mov  bx, pBase
          _emit 0x66
          mov  cx, ax
          _emit 0x66
          sub  ax, [bx]
          _emit 0x66
          mov  [bx], cx
          _emit 0x66
          mov  cx, dx
          _emit 0x66
          sbb  dx, [bx+4]
          _emit 0x66
          mov  [bx+4], cx

          _emit 0x66
          mov  cx, pc.wRawMhz
          _emit 0x66
          jcxz  bail
          _emit 0x66
          cmp  dx, cx
          jb ok_to_divide
          _emit 0x66
          push ax
          _emit 0x66
          mov  ax, dx
          _emit 0x66
          xor  dx, dx
          _emit 0x66
          div  cx
          _emit 0x66
          pop  ax
        ok_to_divide:
          _emit 0x66
          div  cx
        bail:
       }
    }

    static DWORD WINAPI p5DeltaMillisec (PCTIMER * pBase)
    {
       _asm {
          _emit 0x0f
          _emit 0x31

          _emit 0x66
          mov  bx, pBase
          _emit 0x66
          mov  cx, ax
          _emit 0x66
          sub  ax, [bx]
          _emit 0x66
          mov  [bx], cx
          _emit 0x66
          mov  cx, dx
          _emit 0x66
          sbb  dx, [bx+4]
          _emit 0x66
          mov  [bx+4], cx

          //_emit 0x66
          mov  cx, pc.wRawKhz
          _emit 0x66
          jcxz  bail
          _emit 0x66
          cmp  dx, cx
          jb ok_to_divide
          _emit 0x66
          push ax
          _emit 0x66
          mov  ax, dx
          _emit 0x66
          xor  dx, dx
          _emit 0x66
          div  cx
          _emit 0x66
          pop  ax
        ok_to_divide:
          _emit 0x66
          div  cx
        bail:

       }
    }

    // 16 bit code for detecting CPU type so we can decide
    // whether or not it is ok to use the pentium timing stuff
    //
    int WINAPI pcGetCpuID ()
    {
    _asm {
        _emit 0x66
        pushf       ; save eflags

        // check for 486 by attempting to set the 0x40000 bit
        // in eflags.  if we can set it, the processor is 486 or better
        //
        _emit 0x66
        pushf               ; push eflags
        pop   ax            ; move eflags to dx:ax
        pop   dx
        or    dx, 4         ; set 0x40000 bit in eflags
        push  dx            ; put back onto stack
        push  ax
        _emit 0x66
        popf                ; pop modified flags back into eflags
        _emit 0x66
        pushf               ; push eflags back onto stack
        pop   ax            ; move eflags in to dx:bx
        pop   dx

        _emit 0x66
        popf        ; restore origonal eflags

        mov   bx, 3 ; assume 386
        test  dx, 4 ; 486 will preserve 0x40000 bit on push/pop of eflags
        jz    ret_procid
        inc   bx    ; this is a 486 or higher

        // if we get to here it is a 486 or greater

        // check for pentium or higher by attempting to toggle the
        // ID bit (0x200000) in eflags.
        // on a pentium, this bit will toggle, on 486 it will not
        //
        _emit  0x66
        pushf                   ; save eflags
        _emit  0x66
        pushf                   ; get eflags
        pop    ax               ; put eflags into dx:ax
        pop    dx
        xor    dx, 0x20         ; toggle 0x200000 bit in eflags
        push   dx
        push   ax               ; push modified eflags from dx:ax
        _emit  0x66
        popf                    ; load changed eflags
        _emit  0x66
        pushf                   ; get eflags again
        pop    ax               ; discard eflags lo
        pop    ax               ; get eflags hi
        xor    dx, ax           ; did anything change?
        _emit  0x66             ; restore old eflags
        popf

        test   dx, 0x20         ; did we change the 20 bit?
        jz     ret_procid       ; if not, bx already has 4, return that

        // if we get to here, it is a pentium or greater

        // use the pentium CPUID instruction to detect exact processor
        // type
        //
        _emit 0x0F            ; cpuid instruction
        _emit 0xA2
        shr   ax, 8           ; extract family field
        and   ax, 0x0F
        mov   bx, ax          ; 5 is pentium, others are higher

       ret_procid:
        mov   ax, bx
        }
    }

    static DWORD WINAPI p5TimerFreq ()
    {
        if (pcGetCpuID() >= 5)
        {
           DWORD   dw;
           DWORD   dwTicks;
           static PCTIMER timer;

           p5InitTimer (&timer);
           dw = timeGetTime() + 200;
           while (timeGetTime() < dw)
               ;
           dw = timeGetTime() - dw;
           dwTicks = p5DiffTicks(&timer);

           pc.dwRawMhz = (dwTicks + dw * 1000/2) /dw /1000;
           pc.dwRawKhz = pc.dwRawMhz * 1000;
           pc.dwRawHz  = pc.dwRawKhz * 1000;
           pc.dwMicroAdjust = 0;
           pc.dwTimerKhz = 1000;

           return pc.dwRawHz;
        }

        return 0;
    }

    VOID WINAPI InitPerformanceCounters (void)
    {
        if (p5TimerFreq() != 0l)
        {
            pc.DifTicks      = p5DiffTicks;
            pc.DifMicrosec   = p5DiffMicrosec;
            pc.DifMillisec   = p5DiffMillisec;
            pc.DeltaTicks    = p5DeltaTicks;
            pc.DeltaMicrosec = p5DeltaMicrosec;
            pc.DeltaMillisec = p5DeltaMillisec;
            pc.uTimerType    = 5;
            return;
        }
    }

  #endif // WIN32

#endif // _INC_MMTIMERS_CODE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\msvideoi.h ===
/****************************************************************************/
/*                                                                          */
/* NOTE: The original location of this file was in the (ms)video            */
/*       subdirectory.  It was moved to AVICAP when the video thunks were   */
/*       moved to AVICAP.  There is probably some spurious information.     */
/*                                                                          */
/*        MSVIDEOI.H - Internal Include file for Video APIs                 */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1994, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifdef BUILDDLL
#undef WINAPI
#define WINAPI FAR PASCAL _loadds
#endif

/****************************************************************************

                   Digital Video Driver Structures

****************************************************************************/

#define MAXVIDEODRIVERS 10

/****************************************************************************

                            Globals

****************************************************************************/

//extern UINT      wTotalVideoDevs;                  // total video devices
// The module handle is used in drawdib to load strings from the resource file
//extern HINSTANCE ghInst;                           // our module handle

extern SZCODE szNull[];
extern SZCODE szVideo[];
extern SZCODE szSystemIni[];
extern SZCODE szDrivers[];

/* internal video function prototypes */

#ifdef _WIN32
/*
 * don't lock pages in NT
 */
#define HugePageLock(x, y)		(TRUE)
#define HugePageUnlock(x, y)
#else

BOOL FAR PASCAL HugePageLock(LPVOID lpArea, DWORD dwLength);
void FAR PASCAL HugePageUnlock(LPVOID lpArea, DWORD dwLength);

#define videoGetErrorTextW videoGetErrorText

#endif

/****************************************************************************
****************************************************************************/

#ifdef DEBUG_RETAIL
    #define DebugErr(flags, sz)         {static SZCODE ach[] = "AVICAP32: "sz; DebugOutput((flags)   | DBF_DRIVER, ach); }
#else
    #define DebugErr(flags, sz)
#endif

/****************************************************************************
****************************************************************************/

#ifdef DEBUG
    extern int videoDebugLevel;
    extern void FAR CDECL dprintf(LPSTR szFormat, ...);
    #define DPF( _x_ )	if (videoDebugLevel >= 1) thkdprintf _x_
    #define DPF0( _x_ )                           thkdprintf _x_
    #define DPF1( _x_ )	if (videoDebugLevel >= 1) thkdprintf _x_
    #define DPF2( _x_ )	if (videoDebugLevel >= 2) thkdprintf _x_
    #define DPF3( _x_ )	if (videoDebugLevel >= 3) thkdprintf _x_
    #define DPF4( _x_ ) if (videoDebugLevel >= 4) thkdprintf _x_
#else
    /* debug printf macros */
    #define DPF( x )
    #define DPF0( x )
    #define DPF1( x )
    #define DPF2( x )
    #define DPF3( x )
    #define DPF4( x )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\pentime.h ===
/*+ pentime.h
 *
 * pentium specific high precision timer functions for 16 or 32 bit apps
 * (16 bit also needs pentime.asm)
 *
 *-======================================================================*/

#ifndef PENTIME_H
#define PENTIME_H

typedef struct {
    DWORD dwlo;
    DWORD dwhi;
    } PENTIMER, NEAR * PPENTIMER;

void FAR PASCAL pentimeInitTimer (
    PPENTIMER pptimer);

DWORD FAR PASCAL pentimeGetMicrosecs (
    PPENTIMER pptimer);

DWORD FAR PASCAL pentimeGetMicrosecDelta (
    PPENTIMER pptimer);

DWORD FAR PASCAL pentimeGetMillisecs (
    PPENTIMER pptimer);

struct _pentime_global {
    DWORD    dwTimerKhz;
    BOOL     bActive;
    PENTIMER base;
    DWORD    dwCpuMhz;
    DWORD    dwCpuKhz;
    };
extern struct _pentime_global pentime;

//
// macros to make whether to use pentium timers or not a runtime option
//
#ifdef _X86_

  #define pentimeGetTime()       pentime.bActive ? pentimeGetMillisecs(&pentime.base) : timeGetTime()
  #define pentimeGetTicks()      pentime.bActive ? pentimeGetMicrosecs(&pentime.base) : timeGetTime()
  #define pentimeBegin()         pentime.bActive ? (pentimeInitTimer(&pentime.base), 0l) : (void)(pentime.base.dwlo = timeGetTime())
  #define pentimeGetTickRate()   (pentime.bActive ? (pentime.dwTimerKhz * 1000) : 1000l)
  #define pentimeGetDeltaTicks(ppt) pentime.bActive ? pentimeGetMicrosecDelta(ppt) : \
    ((ppt)->dwhi = (ppt)->dwlo, (ppt)->dwlo = timeGetTime(), (ppt)->dwlo - (ppt)->dwhi)

#else

  #define pentimeGetTime()       timeGetTime()
  #define pentimeGetTicks()      timeGetTime()
  #define pentimeBegin()         (pentime.base.dwlo = timeGetTime())
  #define pentimeGetTickRate()   (1000l)
  #define pentimeGetDeltaTicks(ppt) \
    ((ppt)->dwhi = (ppt)->dwlo, (ppt)->dwlo = timeGetTime(), (ppt)->dwlo - (ppt)->dwhi)

#endif

#if (defined _INC_PENTIME_CODE_) && (_INC_PENTIME_CODE_ != FALSE)
    #undef _INC_PENTIME_CODE_
    #define _INC_PENTIME_CODE_ FALSE

    struct _pentime_global pentime = {1, 0};

   #ifdef _WIN32
     #ifdef _X86_
      static BYTE opGetP5Ticks[] = {
          0x0f, 0x31,                   // rtdsc
          0xc3                          // ret
          };

      static void (WINAPI * GetP5Ticks)() = (LPVOID)opGetP5Ticks;

      #pragma warning(disable:4704)
      #pragma warning(disable:4035)

      void FAR PASCAL pentimeInitTimer (
          PPENTIMER pptimer)
      {
          GetP5Ticks();
          _asm {
              mov  ebx, pptimer
              mov  [ebx], eax
              mov  [ebx+4], edx
          };
      }

      DWORD FAR PASCAL pentimeGetCpuTicks (
          PPENTIMER pptimer)
      {
          GetP5Ticks();
          _asm {
              mov  ebx, pptimer
              sub  eax, [ebx]
              sbb  edx, [ebx+4]
          };
      }

      DWORD FAR PASCAL pentimeGetMicrosecs (
          PPENTIMER pptimer)
      {
          GetP5Ticks();
          _asm {
              mov  ebx, pptimer
              sub  eax, [ebx]
              sbb  edx, [ebx+4]
              and  edx, 31               // to prevent overflow
              mov  ecx, pentime.dwCpuMhz
              div  ecx
          };
      }

      DWORD WINAPI pentimeGetMicrosecDelta (
          PPENTIMER pptimer)
      {
          GetP5Ticks();
          _asm {
              mov  ebx, pptimer
              mov  ecx, eax
              sub  eax, [ebx]
              mov  [ebx], ecx
              mov  ecx, edx
              sbb  edx, [ebx+4]
              mov  [ebx+4], ecx
              and  edx, 31
              mov  ecx, pentime.dwCpuMhz
              div  ecx
          };
      }

      DWORD FAR PASCAL pentimeGetMillisecs (
          PPENTIMER pptimer)
      {
          GetP5Ticks();
          _asm {
              mov  ebx, pptimer
              sub  eax, [ebx]
              sbb  edx, [ebx+4]
              and  edx, 0x7fff           // to prevent overflow
              mov  ecx, pentime.dwCpuKhz
              div  ecx
          };
      }
     #endif

      void FAR PASCAL pentimeSetMhz (
          DWORD dwCpuMhz)
      {
          pentime.dwCpuMhz = dwCpuMhz;
          pentime.dwCpuKhz = dwCpuMhz * 1000;
      }
   #else // 16 bit - set mhz is in ASM file

    void FAR PASCAL pentimeSetMhz (
        DWORD dwCpuMhz);

   #endif

    void FAR PASCAL pentimeInit (
        BOOL  bIsPentium,
        DWORD dwCpuMhz)
    {
        if (pentime.bActive = bIsPentium)
        {
            pentimeSetMhz (dwCpuMhz);
            pentime.dwTimerKhz = 1000;
        }
        else
            pentime.dwTimerKhz = 1;

        pentimeBegin();
    }

   #ifdef _WIN32
    VOID WINAPI pentimeDetectCPU ()
    {
        SYSTEM_INFO si;
        static DWORD MS_INTERVAL = 500; // measure pentium cpu clock for this
                                        // many millisec.  the larger this number
                                        // the more accurate our Mhz measurement.
                                        // numbers less than 100 are unlikely
                                        // to be reliable because of the slop
                                        // in GetTickCount

       #ifdef _X86_
        GetSystemInfo(&si);
        if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL &&
            si.wProcessorLevel == 5
           )
        {
            DWORD     dw;
            PENTIMER  qwTicks;
            DWORD     dwTicks;

            pentime.bActive = TRUE;
            pentime.dwTimerKhz = 1000;

            timeBeginPeriod(1);
            dw = timeGetTime ();
            pentimeInitTimer (&qwTicks);

            Sleep(MS_INTERVAL);

            dw = timeGetTime() - dw;
            dwTicks = pentimeGetCpuTicks (&qwTicks);
            timeEndPeriod(1);

            // calculate the CPU Mhz value and Khz value
            // to use as millisec and microsec divisors
            //
            pentime.dwCpuMhz = (dwTicks + dw*500)/dw/1000;
            pentime.dwCpuKhz = pentime.dwCpuMhz * 1000;
        }
        else
       #endif
        {
            pentime.bActive = FALSE;
            pentime.dwTimerKhz = 1;
        }
    }
   #else // win16
    VOID WINAPI pentimeDetectCPU ()
    {
        pentimeInit (FALSE, 33);
    }
   #endif


#endif // _INC_PENTIME_CODE_
#endif // PENTIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\profile.c ===
/*
 * AVICAP32:
 *
 * profile.c
 *
 * win32/win16 utility functions to read and write profile items
 * for VFW
 *
 * ONLY mmGetProfileIntA is supported here
 *
 */

#if defined(_WIN32) && defined(UNICODE)
// This whole file is only used for 32 bit code.  It is the implementation
// that allows Win GetProfilexxx calls to use the registry.

#include <windows.h>
#include <windowsx.h>

#include <profile.key>
#include <win32.h>
#include <stdlib.h>  // for atoi

#include "profile.h"

static HKEY GetKeyA(LPCSTR appname, BOOL fCreate)
{
    HKEY key = 0;
    char achName[MAX_PATH];

    lstrcpyA(achName, KEYNAMEA);
    lstrcpynA(achName + NUMELMS(KEYNAMEA) - 1, appname,
              NUMELMS(achName) - NUMELMS(KEYNAMEA) + 1);

    if ((!fCreate && RegOpenKeyA(ROOTKEY, achName, &key) == ERROR_SUCCESS)
        || (fCreate && RegCreateKeyA(ROOTKEY, achName, &key) == ERROR_SUCCESS)) {
    }

    return(key);
}

#define GetKey GetKeyA

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
UINT
mmGetProfileIntA(LPCSTR appname, LPCSTR valuename, INT uDefault)
{
    DWORD dwType;
    INT value = uDefault;
    DWORD dwData;
    int cbData;

    HKEY key = GetKeyA(appname, FALSE);

    if (key) {

        cbData = sizeof(dwData);
        if (RegQueryValueExA(
            key,
            (LPSTR)valuename,
            NULL,
            &dwType,
            (PBYTE) &dwData,
            &cbData) == ERROR_SUCCESS) {
            if (dwType == REG_DWORD || dwType == REG_BINARY) {
                value = (INT)dwData;
            } else if (dwType == REG_SZ) {
		value = atoi((LPSTR) &dwData);
	    }
	}

        RegCloseKey(key);
    }

    return((UINT)value);
}

#endif // DAYTONA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\profile.h ===
/*
 * AVICAP32:
 *
 * utility functions to read and write values to the profile,
 * using win.ini for Win16/Win95 or current
 * the registry for Win32 NT.  (Trivial to change to registry for Win95)
 *
 * The only routine that AVICAP32 uses is GetProfileIntA
 */

#if defined(_WIN32) && defined(UNICODE)

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
UINT mmGetProfileIntA(LPCSTR appname, LPCSTR valuename, INT uDefault);

// Now map all instances of GetProfileIntA to mmGetProfileIntA
#define GetProfileIntA mmGetProfileIntA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\video16.h ===
/***************************************************************************
 *
 *  video16.h
 *
 *  Copyright (c) 1994  Microsoft Corporation
 *
 *  32-bit Thunks for avicap32.dll
 *
 *  Structures for mapping video
 *
 **************************************************************************/


/*
 *  Make sure the compiler doesn't think it knows better about packing
 *  The 16-bit stack is effectively pack(2)
 */

 #pragma pack(2)

/*
 *  Definitions to help with thunking video calls
 */

 typedef WORD HVIDEO16;
 typedef HVIDEO16 *LPHVIDEO16;


/*
 *  Note that everything is in the reverse order to keep with the PASCAL
 *  calling convention on the other side
 */


/****************************************************************************

   video entry point parameter lists

 ****************************************************************************/


typedef struct {
    DWORD    dwP2;
    DWORD    dwP1;
    WORD     msg;
    HVIDEO16 hVideo;
} UNALIGNED *PvideoMessageParms16;

typedef struct {
    DWORD    dwFlags;
    DWORD    dwDeviceId;
    LPHVIDEO16 lphVideo;
} UNALIGNED *PvideoOpenParms16;

typedef struct {
    HVIDEO16 hVideo;
} UNALIGNED *PvideoCloseParms16;


/*
 *  Our shadow header structure for use with callbacks
 *  (see videoStreamAddBuffer)
 */

typedef struct {
    LPVOID      pHdr16;        /* Remember address on 16-bit side */
    LPVOID      pHdr32;        /* 32-bit version of pHdr16        */
    LPBYTE      lpData16;      /* Remember pointer for flushing   */
    VIDEOHDR    videoHdr;
} VIDEOHDR32, *PVIDEOHDR32;


/*
 *  Instance data for videoStreamInit - contains pointer to 16-bit side
 *  instance data
 */

typedef struct {
    DWORD dwFlags;                // Real flags
    DWORD dwCallbackInst;         // Real instance data
    DWORD dwCallback;
    HVIDEO16 hVideo;
} VIDEOINSTANCEDATA32, *PVIDEOINSTANCEDATA32;

/*
 *  Thunk 16-bit mmtime
 */

#pragma pack(2)

typedef struct {
   WORD    wType;              /* indicates the contents of the union */
   union {
       DWORD ms;               /* milliseconds */
       DWORD sample;           /* samples */
       DWORD cb;               /* byte count */
       struct {                /* SMPTE */
           BYTE hour;          /* hours */
           BYTE min;           /* minutes */
           BYTE sec;           /* seconds */
           BYTE frame;         /* frames  */
           BYTE fps;           /* frames per second */
           BYTE dummy;         /* pad */
           } smpte;
       struct {                /* MIDI */
           DWORD songptrpos;   /* song pointer position */
           } midi;
       } u;
   } MMTIME16;

#pragma pack()



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\acmcmprs.h ===
/*	-	-	-	-	-	-	-	-	*/

/*
**	Copyright (C) Microsoft Corporation 1993 - 1995. All rights reserved.
*/

/*	-	-	-	-	-	-	-	-	*/

/*	-	-	-	-	-	-	-	-	*/

#define	implement	struct
#define	implementations	private

/*
** _StdClassImplementations
** Defines the standard implementations for a class object.
*/

#ifndef _StdClassImplementations
#define	_StdClassImplementations(Impl)	\
	STDMETHODIMP QueryInterface(const IID FAR& riid, void FAR* FAR* ppv);	\
	STDMETHODIMP_(ULONG) AddRef();	\
	STDMETHODIMP_(ULONG) Release()
#endif


#include "mmreg.h"
#include "msacm.h"

/*	-	-	-	-	-	-	-	-	*/

class FAR CACMCmpStream : IAVIStream{
public:
    static HRESULT MakeInst(IUnknown FAR* pUnknownOuter, const IID FAR& riid, void FAR* FAR* ppv);
    LONG SetUpCompression();
private:
    CACMCmpStream(IUnknown FAR* pUnknownOuter, IUnknown FAR* FAR* ppUnknown);
    public:
    _StdClassImplementations(CAVIStreamImpl);
    STDMETHODIMP Create      (THIS_ LPARAM lParam1, LPARAM lParam2);
    STDMETHODIMP Info        (THIS_ AVISTREAMINFOW FAR * psi, LONG lSize);
    STDMETHODIMP_(LONG) FindSample (THIS_ LONG lPos, LONG lFlags);
    STDMETHODIMP ReadFormat  (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG FAR *cbFormat);
    STDMETHODIMP SetFormat   (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG cbFormat);
    STDMETHODIMP Read        (THIS_ LONG lStart, LONG lSamples,
			    LPVOID lpBuffer, LONG cbBuffer,
			    LONG FAR * plBytes, LONG FAR * plSamples);
    STDMETHODIMP Write       (THIS_ LONG lStart, LONG lSamples,
			      LPVOID lpBuffer, LONG cbBuffer, DWORD dwFlags,
			      LONG FAR *plSampWritten,
			      LONG FAR *plBytesWritten);
    STDMETHODIMP Delete      (THIS_ LONG lStart, LONG lSamples);
    STDMETHODIMP ReadData    (THIS_ DWORD fcc, LPVOID lp, LONG FAR *lpcb);
    STDMETHODIMP WriteData   (THIS_ DWORD fcc, LPVOID lp, LONG cb);
#ifdef _WIN32
    STDMETHODIMP SetInfo(AVISTREAMINFOW FAR *lpInfo, LONG cbInfo);
#else
    STDMETHODIMP Reserved1            (THIS);
    STDMETHODIMP Reserved2            (THIS);
    STDMETHODIMP Reserved3            (THIS);
    STDMETHODIMP Reserved4            (THIS);
    STDMETHODIMP Reserved5            (THIS);
#endif

public:
    IUnknown FAR*	m_pUnknownOuter;

    // Instance data
    ULONG		m_refs;
    AVISTREAMINFOW     m_avistream;      // stream info
    PAVISTREAM		m_pavi;
    HACMSTREAM		m_hs;

    LPWAVEFORMATEX	m_lpFormat;
    LONG		m_cbFormat;
    LPWAVEFORMATEX	m_lpFormatC;
    LONG		m_cbFormatC;

    LONG		m_cbIn;
    BYTE _huge *	m_lpIn;
    LONG		m_cbOut;
    BYTE _huge *	m_lpOut;
    ACMSTREAMHEADER	m_acm;

    LONG		m_dwPosIn;
    LONG		m_dwPosOut;
    LONG		m_dwSamplesLeft;
    LONG		m_dwBytesMissing;
};




/*----------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\vidthunk.h ===
/****************************************************************************
    vidthunk.h

    Contains definitions for video thunks (16/32 bit) (for avicap32.dll)

    Copyright (c) Microsoft Corporation 1994. All rights reserved

****************************************************************************/

//
// NOTE - 32bit handles have 0x8000 'or'ed in - this makes a BIG ASSUMPTION
// about how handles are generated on the 32-bit side.  We ASSUME here
// that :
//
//    32bit msvideo.dll always uses OpenDriver to create handles
//
//    The OpenDriver returns indices into its table (ie small positive
//    numbers).
//

#define  Is32bitHandle(h) (((h) & 0x8000) != 0)
#define  Make32bitHandle(h) ((h) | 0x8000)
#define  Map32bitHandle(h) ((h) & 0x7FFF)

#ifdef WIN32
#include <wownt32.h>
//
//  Thunking support
//

#define GET_VDM_POINTER_NAME            "WOWGetVDMPointer"
#define GET_HANDLE_MAPPER16             "WOWHandle16"
#define GET_HANDLE_MAPPER32             "WOWHandle32"
#define GET_CALLBACK16                  "WOWCallback16"
#define GET_MAPPING_MODULE_NAME         TEXT("wow32.dll")

typedef LPVOID (APIENTRY *LPGETVDMPOINTER)( DWORD Address, DWORD dwBytes, BOOL fProtectMode );
#define WOW32ResolveMemory( p ) (LPVOID)(GetVdmPointer( (DWORD)(DWORD_PTR)(p), 0, TRUE ))

typedef HANDLE  (APIENTRY *LPWOWHANDLE32)(WORD, WOW_HANDLE_TYPE);
typedef WORD    (APIENTRY *LPWOWHANDLE16)(HANDLE, WOW_HANDLE_TYPE);
typedef DWORD   (APIENTRY *LPWOWCALLBACK16)(DWORD vpfn16, DWORD dwParam);

#define StartThunk(Function)                           \
          LRESULT ReturnCode = 0;                        \
          DPF2(("Entering function %s", #Function));

#define EndThunk()                                     \
          DPF2(("  Returned %4X :%4X\n",               \
                   HIWORD(ReturnCode),                 \
                   LOWORD(ReturnCode)));               \
          return ReturnCode;

#define ThunkHWND(h16) ((HWND)lpWOWHandle32((WORD)h16, WOW_TYPE_HWND))
#define ThunkHDC(h16)  ((HDC) lpWOWHandle32((WORD)h16, WOW_TYPE_HDC))
#define ThunkHPAL(h16) ((HPALETTE)lpWOWHandle32((WORD)h16, WOW_TYPE_HPALETTE))

#endif // WIN32

/*
 *  Useful structures and mapping
 */

typedef struct {
    short left, top, right, bottom;
} RECT_SHORT;


#define SHORT_RECT_TO_RECT(OutRect, InRect)  \
    OutRect.left = (LONG)InRect.left;        \
    OutRect.top = (LONG)InRect.top;          \
    OutRect.right = (LONG)InRect.right;      \
    OutRect.bottom = (LONG)InRect.bottom;

#define RECT_TO_SHORT_RECT(OutRect, InRect)  \
    OutRect.left = (short)InRect.left;       \
    OutRect.top = (short)InRect.top;         \
    OutRect.right = (short)InRect.right;     \
    OutRect.bottom = (short)InRect.bottom;


//
//  Function ids across the thunking layer (used by 32 and 16 bit)
//
enum {
   vidThunkvideoMessage32=1,
   vidThunkvideoGetNumDevs32,
   vidThunkvideoOpen32,
   vidThunkvideoClose32,

   compThunkICInfo32,
   compThunkICSendMessage32,
   compThunkICOpen32,
   compThunkICClose32,

   vidThunkvideoGetDriverDesc32
};

#ifndef WIN32
typedef struct _VIDTHUNK
{
//
//  Thunking stuff
//
    DWORD           (FAR PASCAL *lpfnCallproc32W)(DWORD, DWORD, DWORD,
                                                  DWORD, DWORD,
                                                  LPVOID, DWORD, DWORD);
    LPVOID          lpvThunkEntry;
    DWORD           dwVideo32Handle;


} VIDTHUNK, *PVIDTHUNK, FAR *LPVIDTHUNK;
#endif // !WIN32

//
// The following functions generate calls to the 32-bit side
//

#ifdef _INC_MSVIDEO

LRESULT FAR PASCAL videoMessage32(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2);
LRESULT FAR PASCAL videoGetNumDevs32(void);
LRESULT FAR PASCAL videoClose32(HVIDEO hVideo);
LRESULT FAR PASCAL videoOpen32(LPHVIDEO lphVideo, DWORD dwDeviceID, DWORD dwFlags);
DWORD FAR PASCAL videoGetDriverDesc32(DWORD wDriverIndex,
        			LPSTR lpszName, short cbName,
        			LPSTR lpszVer, short cbVer);

#endif // _INC_MSVIDEO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\acmcmprs.cpp ===
/****************************************************************************
 *
 *  ACMSTRM.C
 *
 *  routine for compressing audio with the ACM
 *
 *  Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/


//
// What this file does:
//
// Given an audio Stream (that is, essentially, a function that it can call
// to get audio samples), this presents the same sort of interface and allows
// other people to call it to get compressed audio.
//

#include <win32.h>
#include <vfw.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <ctype.h>
#include <mmreg.h>
#include <msacm.h>
#include "avifilei.h"	// uUseCount
#include "acmcmprs.h"
#include "avifile.rc"	// for resource ids
#include "debug.h"

EXTERN_C HINSTANCE ghMod;


#define WAVEFORMATSIZE(pwf) \
	((((LPWAVEFORMAT)(pwf))->wFormatTag == WAVE_FORMAT_PCM) ? \
		sizeof(PCMWAVEFORMAT) : \
		sizeof(WAVEFORMATEX) + ((LPWAVEFORMATEX)(pwf))->cbSize)


HRESULT CACMCmpStream::MakeInst(
	IUnknown FAR*	pUnknownOuter,
	const IID FAR&	riid,
	void FAR* FAR*	ppv)
{
    IUnknown FAR*	pUnknown;
    CACMCmpStream FAR* pAVIStream;
    HRESULT	hresult;

    pAVIStream = new FAR CACMCmpStream(pUnknownOuter, &pUnknown);
    if (!pAVIStream)
	return ResultFromScode(E_OUTOFMEMORY);
    hresult = pUnknown->QueryInterface(riid, ppv);
    if (FAILED(GetScode(hresult)))
	delete pAVIStream;
    return hresult;
}

/*	-	-	-	-	-	-	-	-	*/

CACMCmpStream::CACMCmpStream(
	IUnknown FAR*	pUnknownOuter,
	IUnknown FAR* FAR* ppUnknown)
{
    m_pavi = 0;
    m_hs = 0;
    m_lpFormat = 0;
    m_lpFormatC = 0;
    m_lpIn = 0;
    m_lpOut = 0;

    if (pUnknownOuter)
	m_pUnknownOuter = pUnknownOuter;
    else
	m_pUnknownOuter = this;
    *ppUnknown = this;
    m_refs = 0;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CACMCmpStream::QueryInterface(
	const IID FAR&	iid,
	void FAR* FAR*	ppv)
{
    if (iid == IID_IUnknown)
	*ppv = (IUnknown FAR *) this;
    else if (iid == IID_IAVIStream)
	*ppv = (IAVIStream FAR *) this;
    else {
	*ppv = NULL;
	return ResultFromScode(E_NOINTERFACE);
    }
    AddRef();
    return NULL;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CACMCmpStream::AddRef()
{
    uUseCount++;
    return ++m_refs;
}

/*	-	-	-	-	-	-	-	-	*/

LONG CACMCmpStream::SetUpCompression()
{
    LONG	    	    lRet = AVIERR_OK;
    MMRESULT		err;


    // Get the initial format
    AVIStreamFormatSize(m_pavi, AVIStreamStart(m_pavi), &m_cbFormat);
    m_lpFormat = (LPWAVEFORMATEX) GlobalAllocPtr(GHND | GMEM_SHARE, m_cbFormat);
    if (!m_lpFormat) {
	lRet = AVIERR_MEMORY;
	goto exit;
    }
    AVIStreamReadFormat(m_pavi, AVIStreamStart(m_pavi), m_lpFormat, &m_cbFormat);

    if (m_lpFormatC != NULL) {
	// we already have the format, let's hope it works...

	// We could check if the format matches the original format....
	if (m_cbFormat == m_cbFormatC &&
		(_fmemcmp(m_lpFormat, m_lpFormatC, (int) m_cbFormat) == 0))
	    goto sameformat;
	
    } else if (m_lpFormat->wFormatTag != WAVE_FORMAT_PCM) {
	acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT, (LPVOID)&m_cbFormatC);
	m_lpFormatC = (LPWAVEFORMATEX) GlobalAllocPtr(GHND | GMEM_SHARE, m_cbFormatC);
	if (!m_lpFormatC) {
	    lRet = AVIERR_MEMORY;
	    goto exit;
	}

	m_lpFormatC->wFormatTag = WAVE_FORMAT_PCM;
	
	if (acmFormatSuggest(NULL, m_lpFormat, m_lpFormatC, m_cbFormatC, 0L) != 0)
	    goto sameformat;
    } else {
sameformat:
	DPF("Leaving the format unchanged....\n");
	m_lpFormatC = m_lpFormat;
	m_cbFormatC = m_cbFormat;
	m_lpFormat = NULL;
	m_cbFormat = 0;

	m_hs = (HACMSTREAM) -1;
	
	goto exit;
    }

    ACMFORMATDETAILS	afdU;
    ACMFORMATTAGDETAILS	aftdU;
    ACMFORMATDETAILS	afdC;
    ACMFORMATTAGDETAILS	aftdC;

    afdU.cbStruct = sizeof(afdU);
    afdU.pwfx = m_lpFormat;
    afdU.cbwfx = m_cbFormat;
    afdU.fdwSupport = 0;
    afdU.dwFormatTag = m_lpFormat->wFormatTag;

    acmFormatDetails(NULL, &afdU, ACM_FORMATDETAILSF_FORMAT);

    aftdU.cbStruct = sizeof(aftdU);
    aftdU.dwFormatTag = m_lpFormat->wFormatTag;
    aftdU.fdwSupport = 0;

    acmFormatTagDetails(NULL,
			&aftdU, ACM_FORMATTAGDETAILSF_FORMATTAG);

    afdC.cbStruct = sizeof(afdC);
    afdC.pwfx = m_lpFormatC;
    afdC.cbwfx = m_cbFormatC;
    afdC.dwFormatTag = m_lpFormatC->wFormatTag;
    afdC.fdwSupport = 0;

    acmFormatDetails(NULL, &afdC, ACM_FORMATDETAILSF_FORMAT);

    aftdC.cbStruct = sizeof(aftdC);
    aftdC.dwFormatTag = m_lpFormatC->wFormatTag;
    aftdC.fdwSupport = 0;

    acmFormatTagDetails(NULL,
			&aftdC,
			ACM_FORMATTAGDETAILSF_FORMATTAG);

    DPF("Converting %s %s to %s %s\n", (LPSTR) &aftdU.szFormatTag, (LPSTR) &afdU.szFormat, (LPSTR) &aftdC.szFormatTag, (LPSTR) &afdC.szFormat);

    // Open the compressor they asked for...
    lRet = acmStreamOpen(&m_hs,		    // returned stream handle
			 NULL,		    // use any converter you want
			 m_lpFormat,	    // starting format
			 m_lpFormatC,	    // ending format
			 0L,		    // no filter
			 0L,		    // no callback
			 0L,		    // instance data for callback
			 ACM_STREAMOPENF_NONREALTIME);//emph. quality not speed


    // !!! translate error code

    if (!m_hs) {
	DPF("Unable to convert!\n");
#if 0
	TCHAR *		pachMessage;
	TCHAR		achTemp[128];
	static int	iEntered = 0;
	LPTSTR		aStrings[4];
// !!! This isn't defined in dev\inc\windows.h.  I don't understand why.
#ifndef FORMAT_MESSAGE_ARGUMENT_ARRAY
#define FORMAT_MESSAGE_ARGUMENT_ARRAY  0
#endif

	aStrings[0] = (LPTSTR) &aftdU.szFormatTag;
	aStrings[1] = (LPTSTR) &afdU.szFormat;
	aStrings[2] = (LPTSTR) &aftdC.szFormatTag;
	aStrings[3] = (LPTSTR) &afdC.szFormat;
	
	FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
		      FORMAT_MESSAGE_ALLOCATE_BUFFER |
		      FORMAT_MESSAGE_ARGUMENT_ARRAY,
		      (LPVOID) ghInst,
		      IDS_CNVTERR,
		      0,  // !!! GetSystemDefaultLanguage?
		      (LPTSTR) &pachMessage,
		      999,
		      (LPDWORD) &aStrings);  // !!! needs to be va_list for NT?
	
	LoadString(ghInst, IDS_ACMERR, (LPTSTR)achTemp, sizeof(achTemp)/sizeof(TCHAR));
	
	if (iEntered++ == 0)	
	    MessageBox(NULL, pachMessage, achTemp, MB_OK);
	iEntered--;

	LocalFree((HLOCAL) pachMessage);
#endif
	
	lRet = AVIERR_ERROR;
	goto exit;
    }

    // Fix avistream header
    m_avistream.dwSampleSize = m_lpFormatC->nBlockAlign;
    m_avistream.dwScale = m_lpFormatC->nBlockAlign;
    m_avistream.dwRate = m_lpFormatC->nAvgBytesPerSec;

    acmStreamSize(m_hs,
		  AVIStreamLength(m_pavi) * m_lpFormat->nBlockAlign,
		  (LPDWORD) &m_avistream.dwLength,
		  ACM_STREAMSIZEF_SOURCE);

    // !!! acmStreamSize rounds up here, do we need to compensate?
    // !!! should we round off/up here?
    m_avistream.dwLength /= m_lpFormatC->nBlockAlign;

    m_avistream.dwQuality = 0; // !!!

    m_cbIn = 4096; // !!!
    m_cbIn -= m_cbIn % m_lpFormat->nBlockAlign; // round down to block aligned

    acmStreamSize(m_hs,
		  m_cbIn,
		  (LPDWORD) &m_cbOut,
		  ACM_STREAMSIZEF_SOURCE);

    DPF("ACM conversion: input %ld bytes, output %ld bytes\n", m_cbIn, m_cbOut);

    m_lpIn = (BYTE _huge *) GlobalAllocPtr(GHND, m_cbIn);
    m_lpOut = (BYTE _huge *) GlobalAllocPtr(GHND, m_cbOut);

    if (!m_lpIn || !m_lpOut) {
	lRet = AVIERR_MEMORY;
	goto exit;
    }

    m_acm.cbStruct = sizeof(m_acm);
    m_acm.fdwStatus = 0;
    m_acm.dwUser = 0;
    m_acm.pbSrc = m_lpIn;
    m_acm.cbSrcLength = m_cbIn;
    m_acm.cbSrcLengthUsed = 0;
    m_acm.pbDst = m_lpOut;
    m_acm.cbDstLength = m_cbOut;
    m_acm.cbDstLengthUsed = 0;

    // !!! add in start, end flags for ACM....
    err = acmStreamPrepareHeader(m_hs, &m_acm, 0);

    if (err != 0) {
	DPF("acmStreamPrepareHeader returns %u\n", err);

	return AVIERR_COMPRESSOR;
    }

    m_dwPosIn = m_dwPosOut = 0;

    m_dwSamplesLeft = 0;

exit:
    if (lRet != AVIERR_OK) {
	// Don't release here!
    }

    return lRet;
}

/*	-	-	-	-	-	-	-	-	*/

//
//  ACM stream:
//
//  lParam1 should be a PAVISTREAM (an audio one!)
//
//  lParam2 should be an LPWAVEFORMAT for the format you want converted
//  to.
//
STDMETHODIMP CACMCmpStream::Create(LPARAM lParam1, LPARAM lParam2)
{
    PAVISTREAM		    pavi = (PAVISTREAM) lParam1;
    LPAVICOMPRESSOPTIONS    lpOpts = (LPAVICOMPRESSOPTIONS) lParam2;
    LPWAVEFORMAT	    lpwfNew = NULL;
    LONG	    	    lRet = AVIERR_OK;

    DPF("Creating ACM compression stream....\n");
    // Get the stream header for future reference....
    pavi->Info(&m_avistream, sizeof(m_avistream));
    m_avistream.fccHandler = 0;
    if (m_avistream.fccType != streamtypeAUDIO) {
	DPF("Stream isn't audio!\n");
	lRet = AVIERR_INTERNAL;
	goto exit;
    }

    if (acmGetVersion() < 0x02000000L) {
	DPF("Bad ACM version!\n");
	lRet = AVIERR_INTERNAL;
	goto exit;
    }

    if (lpOpts && lpOpts->lpFormat) {
	lpwfNew = (LPWAVEFORMAT) lpOpts->lpFormat;

	if (lpOpts->cbFormat < WAVEFORMATSIZE(lpwfNew)) {
	    DPF("Bad format size!\n");
	    lRet = AVIERR_INTERNAL;
	    goto exit;
	}
	
	m_cbFormatC = WAVEFORMATSIZE(lpwfNew);
	m_lpFormatC = (LPWAVEFORMATEX) GlobalAllocPtr(GMEM_MOVEABLE, m_cbFormatC);
	if (m_lpFormatC == NULL) {
	    DPF("Out of memory for format!\n");
	    lRet = AVIERR_MEMORY;
	    goto exit;
	}

	hmemcpy(m_lpFormatC, lpOpts->lpFormat, m_cbFormatC);
    } else {
	m_cbFormatC = 0;
	m_lpFormatC = NULL;
    }

    // Make sure the uncompressed stream doesn't go away without our
    // knowledge....
    AVIStreamAddRef(pavi);

    // Don't put this in the structure until we've done the AddRef....
    m_pavi = pavi;

exit:
    return ResultFromScode(lRet);
}

STDMETHODIMP_(ULONG) CACMCmpStream::Release()
{
    uUseCount--;

    if (--m_refs)
	return m_refs;

    if (m_lpFormat) {
	GlobalFreePtr(m_lpFormat);

	if (m_hs) {
	    m_acm.cbSrcLength = m_cbIn;
	    acmStreamUnprepareHeader(m_hs, &m_acm, 0);
	
	    acmStreamClose(m_hs, 0);
	}
    }

    if (m_lpIn) {
	GlobalFreePtr(m_lpIn);
    }

    if (m_lpOut) {
	GlobalFreePtr(m_lpOut);
    }

    if (m_pavi) {
	// Release our hold on the uncompressed stream....
	AVIStreamClose(m_pavi);
    }

    if (m_lpFormatC)
	GlobalFreePtr(m_lpFormatC);

    delete this;

    return 0;
}


STDMETHODIMP CACMCmpStream::Info(AVISTREAMINFOW FAR * psi, LONG lSize)
{
    if (m_hs == 0) {
	LONG	lRet;
	
	// !!! If they ask for info before writing or setting the
	// format, this will become a "read" stream!
	lRet = SetUpCompression();

	if (lRet != 0)
	    return ResultFromScode(lRet);
    }

    hmemcpy(psi, &m_avistream, min(lSize, sizeof(m_avistream)));

//    return sizeof(m_avistream);
    return 0;
}

STDMETHODIMP CACMCmpStream::ReadFormat(LONG lPos, LPVOID lpFormat, LONG FAR *lpcbFormat)
{
    LONG    lRet;

    if (m_hs == 0) {
	lRet = SetUpCompression();

	if (lRet != 0)
	    return ResultFromScode(lRet);
    }

    if (lpFormat)
	hmemcpy(lpFormat,
		m_lpFormatC,
		min(*lpcbFormat, (LONG) m_cbFormatC));

    *lpcbFormat = (LONG) m_cbFormatC;
    return 0;
}

STDMETHODIMP CACMCmpStream::Read(
                      LONG       lStart,
                      LONG       lSamples,
                      LPVOID     lpBuffer,
                      LONG       cbBuffer,
                      LONG FAR * plBytes,
                      LONG FAR * plSamples)
{
    LONG		lRet;

    MMRESULT		err;

    HRESULT		hr;

    if (plBytes)
	*plBytes = 0;
    if (plSamples)
	*plSamples = 0;

    if (m_hs == 0) {
	lRet = SetUpCompression();

	if (lRet != 0)
	    return ResultFromScode(lRet);
    }

    if (m_lpFormat == NULL) {
	// Just return original format....
	return AVIStreamRead(m_pavi, lStart, lSamples,
			     lpBuffer, cbBuffer, plBytes, plSamples);
    }

    if (lStart < 0 || lStart > (LONG) (m_avistream.dwStart + m_avistream.dwLength))
	return ResultFromScode(AVIERR_BADPARAM);

    if (lSamples == AVISTREAMREAD_CONVENIENT) {
	// If they didn't specify a number of samples, fill their buffer....
	lSamples = (cbBuffer ? cbBuffer : 32768L) / m_lpFormatC->nBlockAlign;
    }

    // Don't let anybody try to read past the end....
    if (lSamples + lStart >
		    (LONG) (m_avistream.dwStart + m_avistream.dwLength))
	lSamples = (LONG) (m_avistream.dwStart + m_avistream.dwLength) -
			       lStart;

    if (lSamples <= 0)
	return ResultFromScode(AVIERR_BADPARAM);

    if (lpBuffer) {
	LONG	lBytes;

	if (cbBuffer < lSamples * m_lpFormatC->nBlockAlign) {
	    DPF("Returning buffer too small\n");
	    if (plBytes)
		*plBytes = lSamples * m_lpFormatC->nBlockAlign;
	
	    return ResultFromScode(AVIERR_BUFFERTOOSMALL);
	}

	if (lStart < m_dwPosOut) {
	    // !!! return to beginning!
	    m_dwPosOut = 0;
	    m_dwPosIn = AVIStreamStart(m_pavi);
	    m_dwSamplesLeft = 0;
	}
	
	while (lSamples > 0) {
	    DPF("Want %ld samples at %ld  (PosOut=%ld, SamplesLeft=%ld)\n", lSamples, lStart, m_dwPosOut, m_dwSamplesLeft);
	    if (lStart >= m_dwPosOut + m_dwSamplesLeft) {
		// Throw away current converted buffer....
		m_dwPosOut += m_dwSamplesLeft;
		
		hr = AVIStreamRead(m_pavi,
			      m_dwPosIn, m_cbIn / m_lpFormat->nBlockAlign,
			      m_lpIn, m_cbIn, &lBytes, &lRet);

		if (lBytes != m_cbIn) {
		    DPF("AVIStreamRead: Asked for %lx bytes at %lx, got %lx!\n", m_cbIn, m_dwPosIn, lBytes);

		    if (lBytes < m_cbIn) {
			// Fill buffer with silence, and hope....
			BYTE _huge *hp;
			LONG	    cb;
			BYTE	    b;

			cb = (m_cbIn - lBytes);
			hp = (BYTE _huge *) m_lpIn + lBytes;

			if ((m_lpFormat->wFormatTag == WAVE_FORMAT_PCM) &&
					(m_lpFormat->wBitsPerSample == 8))
			    b = 0x80;
			else
			    b = 0;

			while (cb-- > 0)
			    *hp++ = b;

			// If we couldn't read anything, pretend we
			// really read enough.
			if (lBytes == 0 && m_dwPosIn >= AVIStreamLength(m_pavi)) {
			    lBytes = m_cbIn;
			    hr = NOERROR;
			}
		    }

		    // !!!
		    // lSampLen = lRet; // !!!
		    // lByteLen = lSampLen * m_lpFormat->nBlockAlign;
		}

		if (FAILED(GetScode(hr))) {
		    DPF("AVIStreamReadFailed! (start=%lx, len=%lx, err=%08lx)\n", m_dwPosIn, m_cbIn / m_lpFormat->nBlockAlign, hr);
		    return hr;
		}

		m_acm.cbSrcLength = lBytes;

		err = acmStreamConvert(m_hs, &m_acm, ACM_STREAMCONVERTF_BLOCKALIGN);

		if (err != 0) {
		    DPF("acmStreamConvert returns %u\n", err);

		    return ResultFromScode(AVIERR_COMPRESSOR);
		}

		DPF("Converted %lu of %lu bytes to %lu bytes (buffer size = %lu)\n", m_acm.cbSrcLengthUsed, m_acm.cbSrcLength, m_acm.cbDstLengthUsed, m_acm.cbDstLength);

		if (m_acm.cbSrcLengthUsed == 0) {
		    err = acmStreamConvert(m_hs, &m_acm, 0);

		    if (err != 0) {
			DPF("acmStreamConvert returns %u\n", err);

			return ResultFromScode(AVIERR_COMPRESSOR);
		    }

		    DPF("Converted (non-blockalign) %lu of %lu bytes to %lu bytes (buffer size = %lu)\n", m_acm.cbSrcLengthUsed, m_acm.cbSrcLength, m_acm.cbDstLengthUsed, m_acm.cbDstLength);
		}
		
		// Lie: say that the ACM returned a full block....
		// !!! acm.cbDstLengthUsed += m_lpFormatC->nBlockAlign - 1;
		// acm.cbDstLengthUsed -= acm.cbDstLengthUsed % m_lpFormatC->nBlockAlign;

		m_dwPosIn += m_acm.cbSrcLengthUsed / m_lpFormat->nBlockAlign;
		m_dwSamplesLeft = (m_acm.cbDstLengthUsed +  m_lpFormatC->nBlockAlign - 1) / m_lpFormatC->nBlockAlign;

		if (m_dwSamplesLeft == 0) {
		    // Instead, say that we got one block back, 0 bytes long.
		    DPF("ACM returned no data at all!  Ack!\n");
		    m_dwSamplesLeft = 1;
		}
		
		m_dwBytesMissing = m_dwSamplesLeft * m_lpFormatC->nBlockAlign - m_acm.cbDstLengthUsed;
	    }

	    if (lStart >= m_dwPosOut) {
		LONG		lSamplesRead;
		LONG		lBytesRead;
		
		lSamplesRead = min(m_dwSamplesLeft - (lStart - m_dwPosOut),
				   lSamples);

		lBytesRead = lSamplesRead * m_lpFormatC->nBlockAlign;

		if (m_dwBytesMissing &&
		    (lStart - m_dwPosOut + lSamplesRead == m_dwSamplesLeft)) {
		    DPF("Not copying %ld missing bytes....\n", m_dwBytesMissing);
		    lBytesRead -= m_dwBytesMissing;
		}
		
		DPF("Copying %ld samples... (%ld bytes)\n", lSamplesRead, lBytesRead);
		hmemcpy(lpBuffer,
			(BYTE _huge *) m_lpOut +
				(lStart - m_dwPosOut) * m_lpFormatC->nBlockAlign,
			lBytesRead);

		if (plBytes)
		    *plBytes += lBytesRead;

		if (plSamples)
		    *plSamples += lSamplesRead;

		lSamples -= lSamplesRead;
		lpBuffer = (BYTE _huge *) lpBuffer +
				   lSamplesRead * m_lpFormatC->nBlockAlign;
		lStart += lSamplesRead;
	    }
	}
    } else {
	// We always assume we could read whatever they asked for....
	if (plBytes)
	    *plBytes = lSamples * m_lpFormatC->nBlockAlign;

	if (plSamples)
	    *plSamples = lSamples;
    }
    return 0;
}

STDMETHODIMP_(LONG) CACMCmpStream::FindSample(LONG lPos, LONG lFlags)
{
    if (lFlags & FIND_FORMAT) {
	if (lFlags & FIND_PREV)
	    return 0;
	else {
	    if (lPos > 0)
		return -1;
	    else
		return 0;
	}
    }

    return lPos;
}


STDMETHODIMP CACMCmpStream::SetFormat(LONG lPos,LPVOID lpFormat,LONG cbFormat)
{
    // !!! It should really be possible to use SetFormat & Write on this
    // stream.....
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CACMCmpStream::Write(LONG lStart,
				  LONG lSamples,
				  LPVOID lpBuffer,
				  LONG cbBuffer,
				  DWORD dwFlags,
				  LONG FAR *plSampWritten,
				  LONG FAR *plBytesWritten)
{
    // !!!
    // Maybe this is the place to decompress data and write it to the original
    // stream?
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CACMCmpStream::Delete(LONG lStart,LONG lSamples)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CACMCmpStream::ReadData(DWORD fcc, LPVOID lp, LONG FAR *lpcb)
{
    return AVIStreamReadData(m_pavi, fcc, lp, lpcb);
}

STDMETHODIMP CACMCmpStream::WriteData(DWORD fcc, LPVOID lp, LONG cb)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

#if 0
STDMETHODIMP CACMCmpStream::Clone(PAVISTREAM FAR * ppaviNew)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}
#endif


#ifdef _WIN32
STDMETHODIMP CACMCmpStream::SetInfo(AVISTREAMINFOW FAR *lpInfo, LONG cbInfo)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

#else
STDMETHODIMP CACMCmpStream::Reserved1(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CACMCmpStream::Reserved2(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CACMCmpStream::Reserved3(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CACMCmpStream::Reserved4(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CACMCmpStream::Reserved5(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\thunk32.c ===
//==========================================================================;
//  thunk32.c
//
//  Copyright (c) 1991-1994 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//      This module contains routines for thunking the video APIs
//      from 16-bit Windows to 32-bit WOW.
//
//  History:
//
//==========================================================================;

//  This stuff is not going to work 64-bit
#pragma warning(disable:4312)


/*

    WOW Thunking design:

        Thunks are generated as follows :

        16-bit :

*/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#include <win32.h>
#ifdef _WIN32
#include <ivideo32.h>
#ifndef _INC_MSVIDEO
#define _INC_MSVIDEO    50      /* version number */
#endif
#else
#include <vfw.h>
#endif
#include <msviddrv.h>
#include <msvideoi.h>
#ifdef _WIN32
    #include <wownt32.h>
    #include <stdlib.h>        // for mbstowcs and wcstombs
    #include <video16.h>
#ifdef UNICODE
    #include "profile.h"       // NT only (for now?)
#endif
#endif // WIN32

// in capinit.c
BOOL capInternalGetDriverDescA(UINT wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer);

//
// pick up the function definitions
//

#include "vidthunk.h"

#ifdef DEBUG
#define MODNAME "AVICAP32"
int videoDebugLevel = -1;
void videoDebugInit(VOID)
{
    if (videoDebugLevel == -1)
        videoDebugLevel = GetProfileIntA("Debug", MODNAME, 0);
}
#else
    #define videoDebugInit()
#endif

/* -------------------------------------------------------------------------
** Handle and memory mapping functions.
** -------------------------------------------------------------------------
*/
LPWOWHANDLE32          lpWOWHandle32;
LPWOWHANDLE16          lpWOWHandle16;
LPWOWCALLBACK16        lpWOWCallback16;
LPGETVDMPOINTER        GetVdmPointer;
int                    ThunksInitialized;

#ifdef WIN32
#ifdef DEBUG
void FAR cdecl thkdprintf(LPSTR szFormat, ...)
{
    char ach[128];
    va_list va;

#define MARKER "AVICAP (thunk): "
    lstrcpyA(ach, MARKER);

    va_start(va, szFormat);
    wvsprintfA(ach+sizeof(MARKER), szFormat, va);
    va_end(va);
    OutputDebugStringA(ach);
}
#endif
#endif

//
//  Useful functions
//

//
//  CopyAlloc - allocate a new piece of memory, and copy the data in
//  Must use LocalFree to release the memory later
//
PVOID CopyAlloc(PVOID   pvSrc, UINT    uSize)
{
    PVOID   pvDest;

    pvDest = (PVOID)LocalAlloc(LMEM_FIXED, uSize);

    if (pvDest != NULL) {
        CopyMemory(pvDest, pvSrc, uSize);
    }

    return pvDest;
}

/*
 *  Copy data from source to dest where source is a 32bit pointer
 *  and dest is a 16bit pointer
 */
void CopyTo16Bit(LPVOID Dest16, LPVOID Src32, DWORD Length)
{
    PVOID Dest32;

    if (Src32 == NULL) {
        return;
    }

    Dest32 = GetVdmPointer((DWORD)(DWORD_PTR)Dest16, Length, TRUE);

    CopyMemory(Dest32, Src32, Length);
}


/*
 *  Copy data from source to dest where source is a 16bit pointer
 *  and dest is a 32bit pointer
 */
void CopyTo32Bit(LPVOID Dest32, LPVOID Src16, DWORD Length)
{
    PVOID Src32;

    if (Src16 == NULL) {
        return;
    }

    Src32 = GetVdmPointer((DWORD)(DWORD_PTR)Src16, Length, TRUE);

    CopyMemory(Dest32, Src32, Length);
}

/*
 *  Copy data from source to dest where source is a 16bit pointer
 *  and dest is a 32bit pointer ONLY if the source is not aligned
 *
 *  Returns which pointer to use (src or dest)
 */
LPVOID CopyIfNotAligned(LPVOID Dest32, LPVOID Src16, DWORD Length)
{
    PVOID Src32;

    if (Src16 == NULL) {
        return Dest32;
    }

    Src32 = GetVdmPointer((DWORD)(DWORD_PTR)Src16, Length, TRUE);

    CopyMemory(Dest32, Src32, Length);

    return Dest32;
}


typedef struct _callback {
    WORD flags;
    WORD hVideo16;
    WORD msg;
    DWORD dwCallback16inst;
    DWORD dw1;
    DWORD dw2;
}  CALLBACK16;
typedef CALLBACK16 * PCALLBACK16;

/*
 *  Callbacks
 */

void MyVideoCallback(HANDLE handle,
                     UINT msg,
                     DWORD dwUser,
                     DWORD dw1,
                     DWORD dw2)
{
    PVIDEOINSTANCEDATA32 pInst;
    BOOL fFree = FALSE;

    pInst = (PVIDEOINSTANCEDATA32)dwUser;

    DPF3(("Video callback - handle = %8X, msg = %8X, dwUser = %8X, dw1 = %8X, dw2 = %8X\n",
              handle, msg, dwUser, dw1, dw2));

    switch (msg) {

   /*
    *  What are the parameters for these messages ??
    */

    case MM_DRVM_OPEN:

       /*
        *  We get this when we INIT_STREAM
        */

        break;

    case MM_DRVM_CLOSE:

       /*
        *  Device is closing - this is where we free our structures
        *  (just in case the 32-bit side called close to clean up).
        *  dwUser points to our data
        */

        fFree = TRUE;

        break;

    case MM_DRVM_DATA:

       /*
        *  We have data - this means a buffer has been returned in
        *  dw1
        */

        {
            PVIDEOHDR32 pHdr32;

            pHdr32 = CONTAINING_RECORD((PVIDEOHDR)dw1,
                                       VIDEOHDR32,
                                       videoHdr);

            dw1 = (DWORD)(DWORD_PTR)pHdr32->pHdr16; // For callback below

           /*
            *  Map back the data and free our structure
            */

            {
                VIDEOHDR Hdr16;
                Hdr16 = pHdr32->videoHdr;
                Hdr16.lpData = pHdr32->lpData16;
                memcpy(pHdr32->pHdr32, (LPVOID)&Hdr16, sizeof(VIDEOHDR));
            }

           /*
            *  Clean up our local structure
            */

            LocalFree((HLOCAL)pHdr32);

        }

        break;

    case MM_DRVM_ERROR:
       /*
        *  dw1 = frames skipped - unfortunately there's nobody to tell!
        */

        break;
    }

   /*
    *  Call back the application if appropriate
    */

    switch (pInst->dwFlags & CALLBACK_TYPEMASK) {
        case CALLBACK_WINDOW:
            PostMessage(ThunkHWND(LOWORD(pInst->dwCallback)),
                    msg, (WPARAM)handle, (LPARAM)dw1);
            break;

        case CALLBACK_FUNCTION:
#if 0
            // Must call a generic 16 bit callback passing a pointer to
            // a parameter array.
            {

                WORD hMem;
                PCALLBACK16 pCallStruct;
                pCallStruct = WOWGlobalAllocLock16(0, sizeof(CALLBACK16), &hMem);
                if (pCallStruct) {
                    pCallStruct->flags = HIWORD(pInst->dwFlags);
                    pCallStruct->hVideo16 = (WORD)pInst->hVideo;
                    pCallStruct->msg = (WORD)msg;
                    pCallStruct->dwCallback16inst = pInst->dwCallbackInst;
                    pCallStruct->dw1 = (DWORD)dw1;
                    pCallStruct->dw2 = (DWORD)dw2;

                    lpWOWCallback16(pInst->dwCallback, pCallStruct);

                    // Now free off the callback structure
                    WOWGlobalUnlockFree16(pCallStruct);

                }
            }
#endif
            break;
    }

    if (fFree) {
        LocalFree((HLOCAL)pInst);
    }
}

//
//  Thunking callbacks to WOW32 (or wherever)
//


typedef struct tag_video_stream_init_parms16 {
       DWORD  dwMicroSecPerFrame;
       DWORD  dwCallback;
       DWORD  dwCallbackInst;
       DWORD  dwFlags;
       DWORD_PTR  hVideo;
} VIDEO_STREAM_INIT_PARMS16, FAR * LPVIDEO_STREAM_INIT_PARMS16;


//--------------------------------------------------------------------------;
//
//  DWORD videoThunk32
//
//  Description:
//
//      32-bit function dispatcher for thunks.
//
//  Arguments:
//      DWORD dwThunkId:
//
//      DWORD dw1:
//
//      DWORD dw2:
//
//      DWORD dw3:
//
//      DWORD dw4:
//
//  Return (DWORD):
//
//  History:
//
//--------------------------------------------------------------------------;

DWORD videoThunk32(DWORD dwThunkId,DWORD dw1,DWORD dw2,DWORD dw3,DWORD dw4)
{
    //
    //  Make sure we've got thunking functionality
    //
    if (ThunksInitialized <= 0) {

        HMODULE hMod;

        if (ThunksInitialized == -1) {
            return MMSYSERR_ERROR;
        }

        videoDebugInit();

        hMod = GetModuleHandle(GET_MAPPING_MODULE_NAME);
        if (hMod != NULL) {

            GetVdmPointer =
                (LPGETVDMPOINTER)GetProcAddress(hMod, GET_VDM_POINTER_NAME);
            lpWOWHandle32 =
                (LPWOWHANDLE32)GetProcAddress(hMod, GET_HANDLE_MAPPER32 );
            lpWOWHandle16 =
                (LPWOWHANDLE16)GetProcAddress(hMod, GET_HANDLE_MAPPER16 );
            lpWOWCallback16 =
                (LPWOWCALLBACK16)GetProcAddress(hMod, GET_CALLBACK16 );
        }

        if ( GetVdmPointer == NULL
          || lpWOWHandle16 == NULL
          || lpWOWHandle32 == NULL ) {

            ThunksInitialized = -1;
            return MMSYSERR_ERROR;

        } else {
            ThunksInitialized = 1;
        }
    }


    //
    //  Perform the requested function
    //

    switch (dwThunkId) {

        case vidThunkvideoMessage32:
            return (DWORD) videoMessage32((HVIDEO)dw1, (UINT)dw2, dw3, dw4);
            break;

        case vidThunkvideoGetNumDevs32:
            return (DWORD) videoGetNumDevs32();
            break;

        case vidThunkvideoOpen32:
            return (DWORD) videoOpen32((LPHVIDEO)dw1, dw2, dw3);
            break;

        case vidThunkvideoClose32:
            return (DWORD) videoClose32((HVIDEO)dw1);
            break;

	case vidThunkvideoGetDriverDesc32:
	{
	    LPSTR lpszName = NULL, lpszVer = NULL;
	    short cbName, cbVer;
	    DWORD dwRet;

	    cbName = (short) LOWORD(dw4);
	    cbVer = (short) HIWORD(dw4);

	    // for chicago, need to call WOW32GetVdmPointerFix
	    // (via getprocaddr!)

	    if ((dw2 != 0) && (cbName > 0)) {
		lpszName = WOW32ResolveMemory(dw2);
	    }
	    if ((dw3 != 0) && (cbVer > 0)) {
		lpszVer = WOW32ResolveMemory(dw3);
	    }


	    dwRet = capInternalGetDriverDescA(
	    		dw1,   // device id
			lpszName,
			cbName,
			lpszVer,
			cbVer);

#if 0 //should do this for chicago
	    if (lpszName) {
		WOWGetVDMPointerUnfix(dw2);
	    }
	    if (lpszVer) {
		WOWGetVDMPointerUnfix(dw3);
	    }
#endif
	    return dwRet;
	}


        default:
            return(0);
    }
}


LRESULT FAR PASCAL videoMessage32(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2)
{
    StartThunk(videoMessage);
    DPF2(("\tvideoMessage id = %4X, lParam1 = %8X, lParam2 = %8X",
              msg, dwP1, dwP2));

   /*
    *  We ONLY support (and we only ever will support) messages which
    *  have ALREADY been defined.  New 32-bit driver messages will NOT
    *  be supported from 16-bit apps.
    */

    switch (msg) {
    case DVM_GETVIDEOAPIVER:
        {
            DWORD ApiVer;

            ReturnCode = videoMessage((HVIDEO)hVideo,
                                      (UINT)msg,
                                      (DWORD_PTR)&ApiVer,
                                      dwP2);

            if (ReturnCode == DV_ERR_OK) {
                CopyTo16Bit((LPVOID)dwP1, &ApiVer, sizeof(DWORD));
            }
        }
        break;

    case DVM_GETERRORTEXT:
        {
            VIDEO_GETERRORTEXT_PARMS vet;
            VIDEO_GETERRORTEXT_PARMS MappedVet;

           /*
            *  Get the parameter block
            */

            CopyTo32Bit((LPVOID)&vet, (LPVOID)dwP1, sizeof(vet));
            MappedVet = vet;

           /*
            *  Map the string pointer
            */

            MappedVet.lpText = WOW32ResolveMemory(vet.lpText);

            ReturnCode = videoMessage(hVideo,
                                      msg,
                                      (DWORD_PTR)&MappedVet,
                                      0);
        }
        break;

    case DVM_GET_CHANNEL_CAPS:
        {
            CHANNEL_CAPS Caps;

            ReturnCode = videoMessage((HVIDEO)hVideo,
                                      (UINT)msg,
                                      (DWORD_PTR)&Caps,
                                      dwP2);

           /*
            *  If successful return the data to the 16-bit app
            */

            if (ReturnCode == DV_ERR_OK) {
                 CopyTo16Bit((LPVOID)dwP1, (LPVOID)&Caps,
                             sizeof(Caps));
            }

        }
        break;

    case DVM_UPDATE:
        {
            ReturnCode = videoMessage(hVideo,
                                      msg,
                                      (DWORD_PTR)ThunkHWND(dwP1),
                                      (DWORD_PTR)ThunkHDC(dwP2));
        }
        break;

    case DVM_PALETTE:
    case DVM_PALETTERGB555:
    case DVM_FORMAT:
       /*
        *  This stuff all comes from videoConfigure
        *
        *  Let's hope this data is all DWORDs!
        */
        {
            VIDEOCONFIGPARMS vcp, MappedVcp;
            DWORD dwReturn;

            BOOL Ok;

            Ok = TRUE;

            CopyTo32Bit((LPVOID)&vcp, (LPVOID)dwP2, sizeof(vcp));
            MappedVcp.lpdwReturn = &dwReturn;
            MappedVcp.dwSize1 = vcp.dwSize1;
            MappedVcp.dwSize2 = vcp.dwSize2;

           /*
            *  Get some storage to store the answer
            */

            if (MappedVcp.dwSize1 != 0) {
                MappedVcp.lpData1 = (LPSTR)LocalAlloc(LPTR, MappedVcp.dwSize1);
                if (MappedVcp.lpData1 == NULL) {
                    Ok = FALSE;
                } else {
                    if (MappedVcp.dwSize2 != 0) {
                        MappedVcp.lpData2 = (LPSTR)LocalAlloc(LPTR, MappedVcp.dwSize2);
                        if (MappedVcp.lpData2 == NULL) {
                            Ok = FALSE;

                            if (MappedVcp.dwSize1 != 0) {
                                LocalFree((HLOCAL)MappedVcp.lpData1);
                            }
                        }
                    }
                }
            }

            if (Ok) {

                CopyTo32Bit(MappedVcp.lpData1, vcp.lpData1, MappedVcp.dwSize1);
                CopyTo32Bit(MappedVcp.lpData2, vcp.lpData2, MappedVcp.dwSize2);

                ReturnCode = videoMessage(hVideo,
                                          msg,
                                          dwP1,
                                          (DWORD_PTR)&MappedVcp);

                if (ReturnCode == DV_ERR_OK) {

                    if (vcp.lpdwReturn != NULL) {
                        CopyTo16Bit(vcp.lpdwReturn, MappedVcp.lpdwReturn,
                                    sizeof(DWORD));
                    }

                    CopyTo16Bit(vcp.lpData1, MappedVcp.lpData1, MappedVcp.dwSize1);
                    CopyTo16Bit(vcp.lpData2, MappedVcp.lpData2, MappedVcp.dwSize2);
                }

                if (MappedVcp.dwSize1 != 0) {
                    LocalFree((HLOCAL)MappedVcp.lpData1);
                }
                if (MappedVcp.dwSize2 != 0) {
                    LocalFree((HLOCAL)MappedVcp.lpData2);
                }
            } else {
                ReturnCode = DV_ERR_NOMEM;
            }
        }
        break;

    case DVM_CONFIGURESTORAGE:
        {
            LPSTR lpStrIdent;
            lpStrIdent = WOW32ResolveMemory(dwP1);

            ReturnCode = videoMessage(hVideo,
                                      msg,
                                      (DWORD_PTR)lpStrIdent,
                                      dwP2);

        }
        break;

    case DVM_DIALOG:
        {
            ReturnCode = videoMessage(hVideo,
                                      msg,
                                      (DWORD_PTR)ThunkHWND(dwP1),
                                      dwP2);
        }
        break;

    case DVM_SRC_RECT:
    case DVM_DST_RECT:
       /*
        *  If it's a query only then don't bother with the
        *  rectangle
        */

        if (dwP2 & VIDEO_CONFIGURE_QUERY) {
            ReturnCode = videoMessage(hVideo,
                                      msg,
                                      dwP1,
                                      dwP2);
        } else {

           /*
            *  The rectangle is regarded as 'in' and 'out'
            *  We need to translate between 16-bit and 32-bit rectangle structures
            */

            RECT_SHORT SRect;
            RECT Rect;

            CopyTo32Bit((LPVOID)&SRect, (LPVOID)dwP1, sizeof(SRect));

            SHORT_RECT_TO_RECT(Rect, SRect);

            ReturnCode = videoMessage(hVideo,
                                      msg,
                                      (DWORD_PTR)&Rect,
                                      dwP2);

            if (ReturnCode == DV_ERR_OK) {
                RECT_TO_SHORT_RECT(SRect, Rect);
                CopyTo16Bit((LPVOID)dwP1, (LPVOID)&SRect, sizeof(SRect));
            }
        }
        break;

    case DVM_STREAM_PREPAREHEADER:
    case DVM_STREAM_UNPREPAREHEADER:
    case DVM_FRAME:
    case DVM_STREAM_ADDBUFFER:
        {
            VIDEOHDR Hdr32;
            LPBYTE pData16, pData32;
            DWORD dwSize;

            dwSize = (UINT)msg == DVM_FRAME ? sizeof(VIDEOHDR) :
                                    min(dwP2, sizeof(VIDEOHDR));

            CopyTo32Bit((LPVOID)&Hdr32, (LPVOID)dwP1, dwSize);

            pData16 = Hdr32.lpData;

           /*
            *  Create a mapping for the pointer
            */

            pData32 = GetVdmPointer((DWORD)(DWORD_PTR)pData16, Hdr32.dwBufferLength, TRUE);
            Hdr32.lpData = pData32;

            if (msg == DVM_STREAM_ADDBUFFER) {

                PVIDEOHDR32 pHdr32;

               /*
                *  Allocate our callback structure and pass this
                *  as our header (suitably offset to the video header part).
                */

                pHdr32 = (PVIDEOHDR32)LocalAlloc(LPTR, sizeof(VIDEOHDR32));

                if (pHdr32 == NULL) {
                    ReturnCode = DV_ERR_NOMEM;
                } else {

                   /*
                    *  Remember the old header so we can pass it back
                    *  and the old data pointer so we can flush it
                    */

                    pHdr32->pHdr16 = (LPVOID)dwP1;

                    /*
                     *  Some systems can't handle GetVdmPointer at interrupt
                     *  time so get a pointer here
                     */

                    pHdr32->pHdr32 = WOW32ResolveMemory(dwP1);
                    pHdr32->lpData16 = pData16;
                    pHdr32->videoHdr = Hdr32;

                    ReturnCode = videoMessage(hVideo,
                                              msg,
                                              (DWORD_PTR)&pHdr32->videoHdr,
                                              dwP2);
                   /*
                    *  If everything was OK copy it back
                    */

                    if (ReturnCode == DV_ERR_OK) {
                        Hdr32.lpData = pData16;
                        CopyTo16Bit((LPVOID)dwP1, (LPVOID)&Hdr32, dwSize);
                    }
                }

            } else {

               /*
                *  Prepare/unprepare the header for 32bit
                */

                ReturnCode = videoMessage(hVideo,
                                          msg,
                                          (DWORD_PTR)&Hdr32,
                                          dwP2);

               /*
                *  If everything was OK copy it back
                */

                if (ReturnCode == DV_ERR_OK) {
                    Hdr32.lpData = pData16;
                    CopyTo16Bit((LPVOID)dwP1, (LPVOID)&Hdr32, dwSize);
                }
            }
        }
        break;

    case DVM_STREAM_RESET:
    case DVM_STREAM_FINI:
    case DVM_STREAM_STOP:
    case DVM_STREAM_START:

       /*
        *  Note that the MM_DRVM_CLOSE message will cause us to clean up our
        *  callback structures on DVM_STREAM_FINI.
        */

        ReturnCode = videoMessage(hVideo,
                                  msg,
                                  0,
                                  0);
        break;

    case DVM_STREAM_GETPOSITION:
        {
            MMTIME mmTime;
            MMTIME16 mmTime16;

            ReturnCode = videoMessage(hVideo,
                                      msg,
                                      (DWORD_PTR)&mmTime,
                                      sizeof(mmTime));

            if (ReturnCode == DV_ERR_OK) {
                mmTime16.wType = (WORD)mmTime.wType;
                CopyMemory((LPVOID)&mmTime16.u,
                           (LPVOID)&mmTime.u, sizeof(mmTime16.u));

                CopyTo16Bit((LPVOID)dwP1, (LPVOID)&mmTime16,
                            min(sizeof(mmTime16), dwP2));

            }
        }

        break;

    case DVM_STREAM_INIT:
        {
            VIDEO_STREAM_INIT_PARMS vsip;
            VIDEO_STREAM_INIT_PARMS16 vsip16;
            PVIDEOINSTANCEDATA32 pInst32;

#if 0
// always do callback
            VIDEO_STREAM_INIT_PARMS16 * pvsip = WOW32ResolveMemory(dwP1);
            if (!(pvsip->dwFlags & CALLBACK_TYPEMASK)) {
                // No callback wanted by the 16 bit code.  Pass call
                // straight through

                ReturnCode = videoMessage((HVIDEO)hVideo,
                                          (UINT)msg,
                                          (DWORD_PTR)pvsip,
                                          (DWORD_PTR)dwP2);

            } else
#endif
	    {
                // We set up a callback to a 32 bit routine, that in
                // turn will callback to the 16 bit function/window
                pInst32 = (PVIDEOINSTANCEDATA32)
                            LocalAlloc(LPTR, sizeof(VIDEOINSTANCEDATA32));

                if (pInst32 == NULL) {
                    ReturnCode = DV_ERR_NOMEM;
                } else {
                    CopyTo32Bit((LPVOID)&vsip16, (LPVOID)dwP1,
                                min(sizeof(vsip16), dwP2));

                    pInst32->dwFlags = vsip16.dwFlags;
                    pInst32->dwCallbackInst = vsip16.dwCallbackInst;
                    pInst32->dwCallback = vsip16.dwCallback;
                    pInst32->hVideo = (HVIDEO16)vsip16.hVideo;

                   /*
                    *  Make up our own parms.  Only set up a callback if
                    *  the user wanted one
                    */

                    vsip.dwCallback = (DWORD_PTR)MyVideoCallback;
                    vsip.dwFlags = (vsip.dwFlags & ~CALLBACK_TYPEMASK) |
                                   CALLBACK_FUNCTION;
                    vsip.dwCallbackInst = (DWORD_PTR)pInst32;

                    ReturnCode = videoMessage((HVIDEO)hVideo,
                                              (UINT)msg,
                                              (DWORD_PTR)&vsip,
                                              (DWORD_PTR)dwP2);

                    if (ReturnCode != DV_ERR_OK) {
                        LocalFree((HLOCAL)pInst32);
                    } else {
                        // The instance block will be freed off by the
                        // 32 bit callback routine when all over
                    }
                }
            }
        }
        break;

    case DVM_STREAM_GETERROR:
        {
            DWORD dwError;
            DWORD dwFramesSkipped;

            ReturnCode = videoMessage(hVideo,
                                      msg,
                                      (DWORD_PTR)&dwError,
                                      (DWORD_PTR)&dwFramesSkipped);

            if (ReturnCode == DV_ERR_OK) {
                CopyTo16Bit((LPVOID)dwP1, &dwError, sizeof(DWORD));
                CopyTo16Bit((LPVOID)dwP2, &dwFramesSkipped, sizeof(DWORD));
            }
        }
        break;

    default:
        DPF2(("videoMessage - Message not implemented %X\n", (UINT)msg));
        ReturnCode = DV_ERR_NOTSUPPORTED;

    }
    EndThunk();
}

INLINE LRESULT FAR PASCAL videoGetNumDevs32(void)
{
    StartThunk(videoGetNumDevs);
    ReturnCode = videoGetNumDevs();
    EndThunk();
}

LRESULT FAR PASCAL videoClose32(HVIDEO hVideo)
{
    StartThunk(videoClose)
    ReturnCode = videoClose(hVideo);
    EndThunk();
}

LRESULT FAR PASCAL videoOpen32(LPHVIDEO lphVideo, DWORD dwDeviceID, DWORD dwFlags)
{
    HVIDEO  hVideo;
    StartThunk(videoOpen);

    ReturnCode = videoOpen(
                      &hVideo,
                      dwDeviceID,
                      dwFlags);

    if (ReturnCode == DV_ERR_OK) {
        lphVideo = WOW32ResolveMemory((PVOID)lphVideo);
        * (HVIDEO UNALIGNED *)lphVideo = hVideo;
    }
    EndThunk();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\afclip.c ===
/****************************************************************************
 *
 *  AVICLIP.C
 *
 *  Clipboard support for AVIFile
 *
 *  Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>
#include <ole2.h>
#include <vfw.h>
#include "avimem.h"
#include "enumfetc.h"
#include "debug.h"

//#define TRYLINKS
#ifdef TRYLINKS
static  SZCODE aszLink[]              = TEXT("OwnerLink");
#endif

#ifndef _WIN32
#define AVIStreamInfoW AVIStreamInfo
#endif

/* From avifps.h.... */
BOOL FAR TaskHasExistingProxies(void);

#define OWNER_DISPLAY   0

STDMETHODIMP AVIClipQueryInterface(LPDATAOBJECT lpd, REFIID riid, LPVOID FAR* ppvObj);
STDMETHODIMP_(ULONG) AVIClipAddRef(LPDATAOBJECT lpd);
STDMETHODIMP_(ULONG) AVIClipRelease(LPDATAOBJECT lpd);
STDMETHODIMP AVIClipGetData(LPDATAOBJECT lpd, LPFORMATETC pformatetcIn,
			LPSTGMEDIUM pmedium );
STDMETHODIMP AVIClipGetDataHere(LPDATAOBJECT lpd, LPFORMATETC pformatetc,
			LPSTGMEDIUM pmedium );
STDMETHODIMP AVIClipQueryGetData(LPDATAOBJECT lpd, LPFORMATETC pformatetc );
STDMETHODIMP AVIClipGetCanonicalFormatEtc(LPDATAOBJECT lpd, LPFORMATETC pformatetc,
			LPFORMATETC pformatetcOut);
STDMETHODIMP AVIClipSetData(LPDATAOBJECT lpd, LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
			BOOL fRelease);
STDMETHODIMP AVIClipEnumFormatEtc(LPDATAOBJECT lpd, DWORD dwDirection,
			LPENUMFORMATETC FAR* ppenumFormatEtc);
STDMETHODIMP AVIClipDAdvise(LPDATAOBJECT lpd, FORMATETC FAR* pFormatetc, DWORD advf,
		LPADVISESINK pAdvSink, DWORD FAR* pdwConnection);
STDMETHODIMP AVIClipDUnadvise(LPDATAOBJECT lpd, DWORD dwConnection);
STDMETHODIMP AVIClipEnumDAdvise(LPDATAOBJECT lpd, LPENUMSTATDATA FAR* ppenumAdvise);

IDataObjectVtbl AVIClipVtbl = {
    AVIClipQueryInterface,
    AVIClipAddRef,
    AVIClipRelease,
    AVIClipGetData,
    AVIClipGetDataHere,
    AVIClipQueryGetData,
    AVIClipGetCanonicalFormatEtc,
    AVIClipSetData,
    AVIClipEnumFormatEtc,
    AVIClipDAdvise,
    AVIClipDUnadvise,
    AVIClipEnumDAdvise
};

#define N_FORMATS   (sizeof(FormatList) / sizeof(FormatList[0]))
FORMATETC FormatList[] = {
    // CF_WAVE must be first, see AVIPutFileOnClipboard
    {CF_WAVE, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    {CF_DIB, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    // CF_PALETTE must be last, see AVIPutFileOnClipboard
    {CF_PALETTE, NULL, DVASPECT_CONTENT, -1, TYMED_GDI}
};

#define AVICLIP_MAGIC   0x42424242

typedef struct {
    IDataObjectVtbl FAR * lpVtbl;
    DWORD               Magic;

    ULONG		ulRefCount;

    PAVIFILE		pf;

    WORD		wFormats;
    LPFORMATETC         lpFormats;

    //!!! what about IDataView
    //!!! what about a IGetFrame

    HWND                hwndMci;
    PGETFRAME           pgf;

} AVICLIP, FAR * LPAVICLIP;

#if OWNER_DISPLAY
static LRESULT CALLBACK _loadds ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LONG lParam);
static WNDPROC OldClipboardWindowProc;
static LPAVICLIP lpcClipboard;
#endif

#include "olehack.h"

long glOleRefCount = 0;

HRESULT FAR PASCAL InitOle(BOOL fForceLoad)
{
    HRESULT hr;


    hr = OleInitialize(NULL);
    if (SUCCEEDED(hr)) InterlockedIncrement(&glOleRefCount);
    return S_FALSE == hr ? S_OK : hr;
}

void FAR PASCAL TermOle(void)
{
    // Someone's calling us too many times... protect them from their selves
    //
    if (glOleRefCount == 0) {
    	DPF("TermOle called too many times...\n");
	    return;
    }

    InterlockedDecrement(&glOleRefCount);

    OleUninitialize();

}

STDAPI AVIGetDataObject(PAVIFILE pf, LPDATAOBJECT FAR *ppDataObj)
{
    LPAVICLIP	lpc;
    PAVISTREAM	ps;

    *ppDataObj = NULL;
    if (pf == NULL) {
	return NOERROR;
    }

    AVIFileAddRef(pf);

    lpc = (LPAVICLIP) GlobalAllocPtr(GHND | GMEM_SHARE, sizeof(AVICLIP));

    if (!lpc)
	return ResultFromScode(AVIERR_MEMORY);

    InitOle(TRUE);

    lpc->lpVtbl = &AVIClipVtbl;
    lpc->ulRefCount = 1;
    lpc->pf = pf;

    lpc->wFormats = N_FORMATS;
    lpc->lpFormats = FormatList;
    lpc->Magic = AVICLIP_MAGIC;

    //
    // if there is no video in the file, dont offer video
    // CF_WAVE must be first.
    //
    if (AVIFileGetStream(pf, &ps, streamtypeVIDEO, 0L) != NOERROR) {
        lpc->wFormats = 1;
    }
    else {
        //
        // if the video format is higher than 8bpp dont offer a palette
        // CF_PALETTE must be last.
        //
	AVISTREAMINFOW		strhdr;
	BITMAPINFOHEADER	bi;
	DWORD			dwcbFormat;

	// get the stream header
	AVIStreamInfoW(ps, &strhdr, sizeof(strhdr));
	
	// now read the format of this thing
	dwcbFormat = sizeof(bi);
	AVIStreamReadFormat(ps, strhdr.dwStart, (LPVOID)&bi, (LONG FAR *)&dwcbFormat);

	// if it is true color (i.e., > 8bpp) then don't use the palette
        if (bi.biBitCount > 8) {
	    DPF("Turning off CF_PALETTE now\n");
            lpc->wFormats--;	// don't use CF_PALETTE
        }

        ps->lpVtbl->Release(ps);
    }

    //
    // if there is no audio in the file, dont offer audio
    // CF_WAVE must be first.
    //
    if (AVIFileGetStream(pf, &ps, streamtypeAUDIO, 0L) != NOERROR) {
        lpc->wFormats--;
        lpc->lpFormats++;
    }
    else {
        ps->lpVtbl->Release(ps);
    }

    *ppDataObj = (LPDATAOBJECT) lpc;

    return 0;
}


/**************************************************************************
* @doc EXTERNAL AVIPutFileOnClipboard
*
* @api HRESULT | AVIPutFileOnClipboard | Puts a file described by the passed
*	in PAVIFILE onto the clipboard.
*
* @parm PAVIFILE | pfile | Handle representing the file to put on the clipboard.
*
* @comm
*
* @rdesc Returns zero on success or an error code.
*
* @xref AVIPutStreamOnClipboard AVIGetFromClipboard
*
*************************************************************************/
STDAPI AVIPutFileOnClipboard(PAVIFILE pf)
{
    LPDATAOBJECT lpd;
    HRESULT	hr;

    InitOle(TRUE);

    hr = AVIGetDataObject(pf, &lpd);

    hr = OleSetClipboard(lpd);

    if (lpd) {
	lpd->lpVtbl->Release(lpd);

#if OWNER_DISPLAY
	lpcClipboard = lpc;

	//
	// hook the clipboard owner so we can do OWNER_DISPLAY formats
	//
	{
	HWND hwnd = GetClipboardOwner();

	if (OldClipboardWindowProc == NULL) {

	    if (hwnd) {
		OldClipboardWindowProc = (WNDPROC)SetWindowLong(hwnd,
		    GWL_WNDPROC, (LONG)ClipboardWindowProc);
	    }
	}

	if (OpenClipboard(hwnd)) {
	    SetClipboardData(CF_OWNERDISPLAY, NULL);
	    CloseClipboard();
	}
	}
#endif
    }

    TermOle();

    return hr;
}

/**************************************************************************
* @doc EXTERNAL AVIGetFromClipboard
*
* @api HRESULT | AVIGetFromClipboard | Get a file or stream off of the
*	clipboard.
*
* @parm PAVIFILE FAR * | ppfile | Pointer to a variable that can
*
* @comm If <p ppfile> is not NULL, the function will first attempt to
*	retrieve a file from the clipboard.  Then, if <p ppstream> is not
*	NULL, it will attempt to retrieve a stream.
*
*	Any file or stream retrieved from the clipboard using this
*	function should eventually be released with <f AVIStreamClose>
*	or <f AVIFileClose>.
*
* @rdesc Returns zero on success or an error code.  If there is no suitable
*	data on the clipboard, no error code will be returned, but
*	the returned variables will be NULL.
*
* @xref AVIPutStreamOnClipboard AVIGetFromClipboard
*
*************************************************************************/
STDAPI AVIGetFromClipboard(PAVIFILE FAR * lppf)
{
    LPDATAOBJECT	lpd = NULL;
    HRESULT		hr = NOERROR;
    FORMATETC		fetc;
    STGMEDIUM		stg;

    if (!lppf)
	return ResultFromScode(E_POINTER);
	
    *lppf = NULL;

    InitOle(TRUE);

    OleGetClipboard(&lpd);

    if (lpd) {
#ifdef DEBUGXX
	// Print out lots of stuff about what's on the clipboard....
	{
	    LPENUMFORMATETC	lpEnum = NULL;
	    TCHAR		achTemp[256];

	    lpd->lpVtbl->EnumFormatEtc(lpd, DATADIR_GET, &lpEnum);

	    if (lpEnum) {
		DPF("Formats available:\n");
		while(lpEnum->lpVtbl->Next(lpEnum, 1,
					   (LPFORMATETC)&fetc,
					   NULL) == NOERROR) {
		    achTemp[0] = TEXT('\0');
		    GetClipboardFormatName(fetc.cfFormat, achTemp, sizeof(achTemp)/sizeof(achTemp[0]));
		    DPF("\t%u\t%lu\t%ls\n", fetc.cfFormat, fetc.tymed, (LPTSTR)achTemp);

		    if ((fetc.cfFormat == CF_WAVE) ||
			    (fetc.cfFormat == CF_DIB) ||
			    (fetc.cfFormat == CF_RIFF) ||
			    (fetc.cfFormat == CF_METAFILEPICT) ||
			    (fetc.cfFormat == CF_BITMAP) ||
			    (fetc.cfFormat == CF_PENDATA))
			continue;
		
		    if (fetc.tymed & TYMED_HGLOBAL) {
			fetc.tymed = TYMED_HGLOBAL;
			hr = lpd->lpVtbl->GetData(lpd, &fetc, &stg);
			if (hr == 0) {
			    LPVOID  lp = GlobalLock(stg.hGlobal);
			    DPF("%s\n", (LPSTR) lp);

			    GlobalUnlock(stg.hGlobal);
			
			    ReleaseStgMedium(&stg);
			}
		    }
		}
	    }
	}
#endif
	
	lpd->lpVtbl->QueryInterface(lpd, &IID_IAVIFile, lppf);

	// Try for IAVIStream here?

#ifdef TRYLINKS
	// See if there's a link to a type of file we can open....
	if (!*lppf) {
	    UINT        cfLink;

	    cfLink      = RegisterClipboardFormat(aszLink);

	    fetc.cfFormat = cfLink;
	    fetc.ptd = 0;
	    fetc.dwAspect = DVASPECT_CONTENT;
	    fetc.lindex = -1;
	    fetc.tymed = TYMED_HGLOBAL;

	    hr = lpd->lpVtbl->GetData(lpd, &fetc, &stg);

	    if (hr == 0) {
		LPTSTR lp = GlobalLock(stg.hGlobal);
		LPTSTR lpName;

		lpName = lp + lstrlen(lp) + 1;
		DPF("Got CF_LINK (%s/%s) data from clipboard...\n", lp,lpName);
		hr = AVIFileOpen(lppf, lpName, OF_READ | OF_SHARE_DENY_WRITE, NULL);

		if (hr == 0) {
		    DPF("Opened file from link!\n");

		    // !!! If the app name is "MPlayer", we could get
		    // the selection out of the data....
		}

		GlobalUnlock(stg.hGlobal);
		ReleaseStgMedium(&stg);
	    }
	}
#endif
	
	if (!*lppf) {
	    PAVISTREAM	aps[2];
	    int		cps = 0;
	
	    fetc.cfFormat = CF_DIB;
	    fetc.ptd = 0;
	    fetc.dwAspect = DVASPECT_CONTENT;
	    fetc.lindex = -1;
	    fetc.tymed = TYMED_HGLOBAL;

	    // CF_BITMAP, CF_PALETTE?
	
	    hr = lpd->lpVtbl->GetData(lpd, &fetc, &stg);

	    if (hr == 0) {
		DPF("Got CF_DIB data from clipboard...\n");
		hr = AVIMakeStreamFromClipboard(CF_DIB, stg.hGlobal, &aps[cps]);

		if (hr == 0) {
		    cps++;
		}

		ReleaseStgMedium(&stg);
	    }
	
	    fetc.cfFormat = CF_WAVE;
	    fetc.ptd = 0;
	    fetc.dwAspect = DVASPECT_CONTENT;
	    fetc.lindex = -1;
	    fetc.tymed = TYMED_HGLOBAL;

	
	    hr = lpd->lpVtbl->GetData(lpd, &fetc, &stg);

	    if (hr == 0) {
		DPF("Got CF_WAVE data from clipboard...\n");
		hr = AVIMakeStreamFromClipboard(CF_WAVE, stg.hGlobal, &aps[cps]);

		if (hr == 0) {
		    cps++;
		}

		ReleaseStgMedium(&stg);
	    }

	    if (cps) {
		hr = AVIMakeFileFromStreams(lppf, cps, aps);

		while (cps-- > 0)
		    AVIStreamClose(aps[cps]);
	    } else
		hr = ResultFromScode(AVIERR_NODATA);
	}
	
	lpd->lpVtbl->Release(lpd);
    }

    TermOle();

    return hr;
}

/**************************************************************************
* @doc EXTERNAL AVIClearClipboard
*
* @api HRESULT | AVIClearClipboard | Releases any file or stream that
*	has been put on the Clipboard.
*
* @comm Applications should use this function before exiting if they use
*	     other Clipboard routines.  Do not use this function just to
*       clear the clipboard; it might not return until other
*       applications have finished using the data placed on the Clipboard.
*       Ideally, call this function after hiding your application's windows.
*
* @rdesc Returns zero on success or an error code.
*
* @xref AVIPutStreamOnClipboard AVIGetFromClipboard
*
*************************************************************************/
STDAPI AVIClearClipboard(void)
{
    HRESULT hr;

    InitOle(TRUE);

    hr = OleFlushClipboard();

    while (TaskHasExistingProxies()) {
	MSG msg;

	DPF("AVIClearClipboard: Waiting while streams in use....\n");
	while(PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
	    TranslateMessage(&msg);
	    DispatchMessage(&msg);
	}
    }

    TermOle();

    return hr;
}

typedef     LPBITMAPINFOHEADER PDIB;

#ifndef BI_BITFIELDS
	#define BI_BITFIELDS 3
#endif

#ifndef HALFTONE
	#define HALFTONE COLORONCOLOR
#endif


#define DibCompression(lpbi)    (DWORD)(((LPBITMAPINFOHEADER)(lpbi))->biCompression)
#define DibColors(lpbi)         ((RGBQUAD FAR *)((LPBYTE)(lpbi) + (int)(lpbi)->biSize))

#define DibNumColors(lpbi)      ((lpbi)->biClrUsed == 0 && (lpbi)->biBitCount <= 8 \
                                    ? (int)(1 << (int)(lpbi)->biBitCount)          \
                                    : (int)(lpbi)->biClrUsed)


/*
 *  CreateBIPalette()
 *
 *  Given a Pointer to a BITMAPINFO struct will create a
 *  a GDI palette object from the color table.
 *
 */
HPALETTE DibCreatePalette(PDIB pdib)
{
    LOGPALETTE         *pPal;
    HPALETTE            hpal = NULL;
    int                 nNumColors;
    int                 i;
    RGBQUAD FAR *       pRgb;

    if (!pdib)
        return NULL;

    nNumColors = DibNumColors(pdib);

    if (nNumColors == 3 && DibCompression(pdib) == BI_BITFIELDS)
        nNumColors = 0;

    if (nNumColors > 0)
    {
        pRgb = DibColors(pdib);
        pPal = (LOGPALETTE*)LocalAlloc(LPTR,sizeof(LOGPALETTE) + nNumColors * sizeof(PALETTEENTRY));

        if (!pPal)
            goto exit;

        pPal->palNumEntries = (WORD) nNumColors;
        pPal->palVersion    = 0x300;

        for (i = 0; i < nNumColors; i++)
        {
            pPal->palPalEntry[i].peRed   = pRgb->rgbRed;
            pPal->palPalEntry[i].peGreen = pRgb->rgbGreen;
            pPal->palPalEntry[i].peBlue  = pRgb->rgbBlue;
            pPal->palPalEntry[i].peFlags = (BYTE)0;

            pRgb++;
        }

        hpal = CreatePalette(pPal);
        LocalFree((HLOCAL)pPal);
    }
    else
    {
#ifdef _WIN32
        HDC hdc = GetDC(NULL);
        hpal = CreateHalftonePalette(hdc);
        ReleaseDC(NULL, hdc);
#endif
    }

exit:
    return hpal;
}

STDMETHODIMP AVIClipQueryInterface(LPDATAOBJECT lpd, REFIID riid, LPVOID FAR* ppvObj)
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;
    SCODE scode;

    if (IsEqualIID(riid, &IID_IDataObject) ||
			IsEqualIID(riid, &IID_IUnknown)) {
	
	DPF2("Clip   %p: Usage++=%lx\n", lpd, lpc->ulRefCount + 1);

        ++lpc->ulRefCount;
        *ppvObj = lpd;
        scode = S_OK;
    }
    else if (lpc->pf && IsEqualIID(riid, &IID_IAVIFile)) {
	AVIFileAddRef(lpc->pf);
	*ppvObj = lpc->pf;
	scode = S_OK;
    }
    else {                 // unsupported interface
        *ppvObj = NULL;
        scode = E_NOINTERFACE;
    }

    return ResultFromScode(scode);
}

STDMETHODIMP_(ULONG) AVIClipAddRef(LPDATAOBJECT lpd)
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;

    DPF2("Clip   %p: Usage++=%lx\n", lpd, lpc->ulRefCount + 1);

    return ++lpc->ulRefCount;
}

STDMETHODIMP_(ULONG) AVIClipRelease(LPDATAOBJECT lpd)
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;

    DPF2("Clip   %p: Usage--=%lx\n", lpd, lpc->ulRefCount - 1);

    if (--lpc->ulRefCount)
	return lpc->ulRefCount;

    if (lpc->pf)
        AVIFileClose(lpc->pf);

    if (lpc->pgf)
        AVIStreamGetFrameClose(lpc->pgf);

    if (lpc->hwndMci)
        DestroyWindow(lpc->hwndMci);

#if OWNER_DISPLAY
    if (lpc == lpcClipboard)
        lpcClipboard = NULL;
#endif

    GlobalFreePtr(lpc);
    TermOle();

    return 0;
}


// *** IDataObject METHODIMPs ***
STDMETHODIMP AVIClipGetData(LPDATAOBJECT lpd, LPFORMATETC pformatetcIn,
			LPSTGMEDIUM pmedium )
{
    LPAVICLIP		lpc = (LPAVICLIP) lpd;
    SCODE		sc = S_OK;

    LPVOID		lp;
    LPBITMAPINFOHEADER	lpbi;
    DWORD		cb;
    PGETFRAME		pgf = NULL;
    PAVISTREAM		ps = NULL;

    pmedium->pUnkForRelease = NULL;

    if (pformatetcIn->cfFormat == CF_DIB ||
	pformatetcIn->cfFormat == CF_PALETTE) {
	
	AVIFileGetStream(lpc->pf, &ps, streamtypeVIDEO, 0L);

	if (!ps) {
	    sc = E_FAIL;
	    goto error;
	}
	
	pgf = AVIStreamGetFrameOpen(ps, NULL);

	if (!pgf) {
	    DPF("AVIClipGetData: AVIStreamGetFrameOpen failed!\n");
	    sc = E_FAIL;
	    goto error;
	}
	
	lpbi = AVIStreamGetFrame(pgf, 0);
	
        if (! lpbi) {
	    DPF("AVIClipGetData: AVIStreamGetFrame failed!\n");
            sc = E_OUTOFMEMORY;
            goto error;
        }

	if (pformatetcIn->cfFormat == CF_DIB) {
	    DPF("Building CF_DIB data\n");
	    // Verify caller asked for correct medium
	    if (!(pformatetcIn->tymed & TYMED_HGLOBAL)) {
		sc = DATA_E_FORMATETC;
		goto error;
	    }

	    cb = lpbi->biSize +
		 lpbi->biClrUsed * sizeof(RGBQUAD) +
		 lpbi->biSizeImage;
	    pmedium->hGlobal = GlobalAlloc(GHND | GMEM_SHARE, cb);

	    if (!pmedium->hGlobal) {
		sc = E_OUTOFMEMORY;
		goto error;
	    }

	    lp = GlobalLock(pmedium->hGlobal);

	    hmemcpy(lp, lpbi, cb);

	    GlobalUnlock(pmedium->hGlobal);
	
	    pmedium->tymed = TYMED_HGLOBAL;
	} else /* if (pformatetcIn->cfFormat == CF_PALETTE) */ {
	    HPALETTE	hpal;

	    // Verify caller asked for correct medium
	    if (!(pformatetcIn->tymed & TYMED_GDI)) {
		sc = DATA_E_FORMATETC;
		goto error;
	    }

	    hpal = DibCreatePalette(lpbi);

	    pmedium->hGlobal = hpal;
	    pmedium->tymed = TYMED_GDI;
	    DPF("Building CF_PALETTE data: hpal = %p\n", (UINT_PTR) hpal);
	}
    } else if (pformatetcIn->cfFormat == CF_WAVE) {
	LONG		cbFormat;
	AVISTREAMINFOW	strhdr;
#define formtypeWAVE            mmioFOURCC('W', 'A', 'V', 'E')
#define ckidWAVEFORMAT          mmioFOURCC('f', 'm', 't', ' ')
#define ckidWAVEDATA	        mmioFOURCC('d', 'a', 't', 'a')
	
	DPF("Building CF_WAVE data\n");
	AVIFileGetStream(lpc->pf, &ps, streamtypeAUDIO, 0L);

	if (!ps) {
	    sc = E_FAIL;
	    goto error;
	}

	AVIStreamInfoW(ps, &strhdr, sizeof(strhdr));

	AVIStreamReadFormat(ps, strhdr.dwStart, NULL, &cbFormat);
	
	cb = strhdr.dwLength * strhdr.dwSampleSize +
	     cbFormat + 5 * sizeof(DWORD) + 2 * sizeof(DWORD);
	
	pmedium->hGlobal = GlobalAlloc(GHND | GMEM_SHARE, cb);

	if (!pmedium->hGlobal) {
	    sc = E_OUTOFMEMORY;
	    goto error;
	}

	lp = GlobalLock(pmedium->hGlobal);

	*((DWORD _huge *)lp)++ = FOURCC_RIFF;
	*((DWORD _huge *)lp)++ = cb - 2 * sizeof(DWORD);
	*((DWORD _huge *)lp)++ = formtypeWAVE;

	*((DWORD _huge *)lp)++ = ckidWAVEFORMAT;
	*((DWORD _huge *)lp)++ = cbFormat;

	AVIStreamReadFormat(ps, strhdr.dwStart, lp, &cbFormat);

	lp = (BYTE _huge *) lp + cbFormat;

	cb = strhdr.dwLength * strhdr.dwSampleSize;
	*((DWORD UNALIGNED _huge *)lp)++ = ckidWAVEDATA;
	*((DWORD UNALIGNED _huge *)lp)++ = cb;

	AVIStreamRead(ps, strhdr.dwStart, strhdr.dwLength, lp, cb, NULL, NULL);
	
	GlobalUnlock(pmedium->hGlobal);
	
	pmedium->tymed = TYMED_HGLOBAL;	
    } else {
        sc = DATA_E_FORMATETC;
	
	//goto error;
    }

error:

    if (pgf)
	AVIStreamGetFrameClose(pgf);
    if (ps)
	AVIStreamClose(ps);

    DPF2("GetData returns %lx\n", (DWORD) sc);
    return ResultFromScode(sc);
}

STDMETHODIMP AVIClipGetDataHere(LPDATAOBJECT lpd, LPFORMATETC pformatetc,
			LPSTGMEDIUM pmedium )
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;

    return ResultFromScode(DATA_E_FORMATETC);
}

STDMETHODIMP AVIClipQueryGetData(LPDATAOBJECT lpd, LPFORMATETC pformatetc )
{
    LPAVICLIP		lpc = (LPAVICLIP) lpd;
    PAVISTREAM		ps = NULL;

    // set defaults for passing to AVIFileGetStream
    UINT		type = TYMED_HGLOBAL; // except for CF_PALETTE
    FOURCC	streamtype = streamtypeVIDEO; // except for CF_WAVE

    switch (pformatetc->cfFormat) {

	case CF_PALETTE:
	    type = TYMED_GDI;
	    break;

	case CF_DIB:
            // everything is set up
	    break;

	case CF_WAVE:
	    streamtype = streamtypeAUDIO;
	    break;

	default:
	    return ResultFromScode(DATA_E_FORMATETC);
    }

    AVIFileGetStream(lpc->pf, &ps, streamtype, 0L);
    if (ps) {
	ps->lpVtbl->Release(ps);
	if (pformatetc->tymed & type) {
	    return NOERROR;
	}
    }
    return ResultFromScode(DATA_E_FORMATETC);
}

STDMETHODIMP AVIClipGetCanonicalFormatEtc(LPDATAOBJECT lpd, LPFORMATETC pformatetc,
			LPFORMATETC pformatetcOut)
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;

    return ResultFromScode(E_NOTIMPL);
}

STDMETHODIMP AVIClipSetData(LPDATAOBJECT lpd, LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
			BOOL fRelease)
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;

    return ResultFromScode(E_FAIL);
}

STDMETHODIMP AVIClipEnumFormatEtc(LPDATAOBJECT lpd, DWORD dwDirection,
			LPENUMFORMATETC FAR* ppenumFormatEtc)
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;

    SCODE sc = S_OK;
    if (dwDirection == DATADIR_GET) {
	// Build an enumerator....
        *ppenumFormatEtc = OleStdEnumFmtEtc_Create(
				lpc->wFormats, lpc->lpFormats);
	
        if (*ppenumFormatEtc == NULL)
            sc = E_OUTOFMEMORY;
    } else if (dwDirection == DATADIR_SET) {
        /* OLE2NOTE: a document that is used to transfer data
        **    (either via the clipboard or drag/drop does NOT
        **    accept SetData on ANY format!
        */
        sc = E_NOTIMPL;
        goto error;
    } else {
        sc = E_INVALIDARG;
        goto error;
    }

error:
    return ResultFromScode(sc);
}


STDMETHODIMP AVIClipDAdvise(LPDATAOBJECT lpd, FORMATETC FAR* pFormatetc, DWORD advf,
		LPADVISESINK pAdvSink, DWORD FAR* pdwConnection)
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;

    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

STDMETHODIMP AVIClipDUnadvise(LPDATAOBJECT lpd, DWORD dwConnection)
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;

    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

STDMETHODIMP AVIClipEnumDAdvise(LPDATAOBJECT lpd, LPENUMSTATDATA FAR* ppenumAdvise)
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;

    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

#if OWNER_DISPLAY

/**************************************************************************
* @doc INTERNAL AVIFILE
*
* @api ClipboardWindowProc
*
*************************************************************************/
static LRESULT CALLBACK _loadds ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LONG lParam)
{
    WNDPROC x;
    HWND hwndViewer;
    PAINTSTRUCT ps;
    RECT rc;
    LPAVICLIP lpc;

    switch (msg) {
        case WM_DESTROY:
        case WM_DESTROYCLIPBOARD:
            DPF("WM_DESTROYCLIPBOARD\n");

            x = OldClipboardWindowProc;
            SetWindowLong(hwnd, GWL_WNDPROC, (LONG)x);
            OldClipboardWindowProc = NULL;
            return (*x)(hwnd, msg, wParam, lParam);

        case WM_RENDERFORMAT:
            DPF("WM_RENDERFORMAT cf=%d\n", (int)wParam);
            break;

        case WM_PAINTCLIPBOARD:
            DPF("WM_PAINTCLIPBOARD\n");

            hwndViewer = (HWND)wParam;

            if (!lParam)
                break;

            lpc = lpcClipboard;

            if (lpc == NULL)
                break;

            ps = *(LPPAINTSTRUCT)GlobalLock((HGLOBAL)lParam);

            FillRect(ps.hdc, &ps.rcPaint, GetStockObject(DKGRAY_BRUSH));

	    GlobalUnlock((HGLOBAL) lParam);
            return 0;
            break;

        case WM_SIZECLIPBOARD:
            DPF("WM_SIZECLIPBOARD\n");

            hwndViewer = (HWND)wParam;

            lpc = lpcClipboard;

            if (lpc == NULL)
                break;

            if (lParam)
                rc = *(LPRECT)GlobalLock((HGLOBAL)lParam);
            else
                SetRectEmpty(&rc);

            if (IsRectEmpty(&rc)) {
            }
            else {
            }
            break;

        case WM_VSCROLLCLIPBOARD:
        case WM_HSCROLLCLIPBOARD:
            DPF("WM_VHSCROLLCLIPBOARD\n");
            hwndViewer = (HWND)wParam;
            break;

        case WM_ASKCBFORMATNAME:
            DPF("WM_ASKCBFORMATNAME\n");
            break;
    }

    return OldClipboardWindowProc(hwnd, msg, wParam, lParam);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avicap.io\video.c ===
/****************************************************************************
    video.c

    Contains video APIs

    Copyright (c) Microsoft Corporation 1992 - 1995. All rights reserved.

****************************************************************************/

#include <windows.h>
#include <mmsystem.h>

#include "win32.h"
#include "msviddrv.h"
#include <vfw.h>
#include <ivideo32.h>
#include "msvideoi.h"

#ifdef DEBUG
  extern void FAR CDECL dprintf(LPSTR, ...);
#else
  #define dprintf ; / ## /
#endif

#ifdef WIN32
#include <mmddk.h>
#include <stdlib.h>
#endif

/*****************************************************************************
 * Variables
 *
 ****************************************************************************/

SZCODE  szNull[]        = TEXT("");
SZCODE  szVideo[]       = TEXT("msvideo");

#ifndef WIN32
SZCODE  szDrivers[]     = "Drivers";
#else
STATICDT SZCODE  szDrivers[]     = DRIVERS_SECTION;
#endif

SZCODE szDriversDescRegKey[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc");

STATICDT SZCODE  szSystemIni[]   = TEXT("system.ini");

UINT    wTotalVideoDevs;                  // total video devices
extern HINSTANCE ghInstDll;               // our module handle

// -----------------------------------------------------------
// If the following structure changes, update AVICAP and AVICAP.32 also!!!

typedef struct tCapDriverInfo {
   TCHAR szKeyEnumName[MAX_PATH];
   TCHAR szDriverName[MAX_PATH];
   TCHAR szDriverDescription[MAX_PATH];
   TCHAR szDriverVersion[80];
   TCHAR szSoftwareKey[MAX_PATH];
   DWORD dnDevNode;         // Set if this is a PnP device
   BOOL  fOnlySystemIni;    // If the [path]drivername is only in system.ini
   BOOL  fDisabled;         // User has disabled driver in the control panel
   BOOL  fActive;           // Reserved
} CAPDRIVERINFO, FAR *LPCAPDRIVERINFO;

#ifndef DEVNODE
typedef	DWORD	   DEVNODE;	// Devnode.
#endif

#ifndef LPHKEY
typedef HKEY FAR * LPHKEY;
#endif

// Registry settings of interest to capture drivers
SZCODE  szRegKey[]          = TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaResources\\msvideo");
SZCODE  szRegActive[]       = TEXT("Active");
SZCODE  szRegDisabled[]     = TEXT("Disabled");
SZCODE  szRegDescription[]  = TEXT("Description");
SZCODE  szRegDevNode[]      = TEXT("DevNode");
SZCODE  szRegDriver[]       = TEXT("Driver");
SZCODE  szRegSoftwareKey[]  = TEXT("SOFTWAREKEY");

LPCAPDRIVERINFO aCapDriverList[MAXVIDEODRIVERS]; // Array of all capture drivers


/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api BOOL | videoRegOpenMSVideoKey | This function returns a key
 *      for the msvideo node in the registry.
 *      If the key does not exist it will be created,
 *      and the default entries made.
 *
 * @rdesc Returns Key on success, else NULL.
 ****************************************************************************/
HKEY videoRegOpenMSVideoKey (void)
{
    HKEY hKey = NULL;

    // Get the key if it already exists
    if (RegOpenKey (
                HKEY_LOCAL_MACHINE,
                szRegKey,
                &hKey) != ERROR_SUCCESS) {

        // Otherwise make a new key
        if (RegCreateKey (
                        HKEY_LOCAL_MACHINE,
                        szRegKey,
                        &hKey) == ERROR_SUCCESS) {
            // Add the default entries to the msvideo node?

        }
    }
    return hKey;
}

/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api BOOL | videoRegGetDriverByIndex | This function returns information
 *      about a capture driver by index from the registry.
 *
 * @parm DWORD | dwDeviceID | Identifies the video device to open.
 *      The value of <p dwDeviceID> varies from zero to one less
 *      than the number of video capture devices installed in the system.
 *
 * @parm LPDEVNODE | lpDevnode | Specifies a far pointer to a buffer
 *   used to return an <t DEVNODE> handle.  For non Plug-and-Play devices,
 *   this return value will be NULL.
 *
 * @parm LPBOOL | lpEnabled | Specifies a far pointer to a buffer
 *   used to return a <t BOOL> flag.  If this value is TRUE, the driver is
 *   enabled, if FALSE, the corresponding device is disabled.
 *
 * @rdesc Returns TRUE if successful, or FALSE if a driver was not found
 *  with the <p dwDeviceID> index.
 *
 * @comm Because the indexes of the MSVIDEO devices in the SYSTEM.INI
 *       file can be non-contiguous, applications should not assume
 *       the indexes range between zero and the number of devices minus
 *       one.
 *
 ****************************************************************************/


BOOL videoRegGetKeyByIndex (
        HKEY            hKeyMSVideoRoot,
        DWORD           dwDeviceID,
        LPCAPDRIVERINFO lpCapDriverInfo,
        LPHKEY          phKeyChild)
{
    BOOL fOK = FALSE;
    HKEY hKeyEnum;
    int i;

    *phKeyChild = (HKEY) 0;

    for (i=0; i < MAXVIDEODRIVERS; i++) {

        if (RegEnumKey (
                hKeyMSVideoRoot,
                i,
                lpCapDriverInfo-> szKeyEnumName,
                sizeof(lpCapDriverInfo->szKeyEnumName)/sizeof(TCHAR)) != ERROR_SUCCESS)
            break;

        // Found a subkey, does it match the requested index?
        if (i == (int) dwDeviceID) {

            if (RegOpenKey (
                        hKeyMSVideoRoot,
                        lpCapDriverInfo-> szKeyEnumName,
                        &hKeyEnum) == ERROR_SUCCESS) {

                *phKeyChild = hKeyEnum;  // Found it!!!
                fOK = TRUE;

            }
            break;
        }
    } // endof all driver indices
    return fOK;
}

// Fetches driver info listed in the registry.
// Returns: TRUE if the index was valid, FALSE if no driver at that index
// Note: Registry entry ordering is random.

BOOL videoRegGetDriverByIndex (
        DWORD           dwDeviceID,
        LPCAPDRIVERINFO lpCapDriverInfo)
{
    DWORD dwType;
    DWORD dwSize;
    BOOL fOK;
    HKEY hKeyChild;
    HKEY hKeyMSVideoRoot;

    // Always start clean since the entry may be recycled
    _fmemset (lpCapDriverInfo, 0, sizeof (CAPDRIVERINFO));

    if (!(hKeyMSVideoRoot = videoRegOpenMSVideoKey()))
        return FALSE;

    if (fOK = videoRegGetKeyByIndex (
                hKeyMSVideoRoot,
                dwDeviceID,
                lpCapDriverInfo,
                &hKeyChild)) {

        // Fetch the values:
        //      Active
        //      Disabled
        //      Description
        //      DEVNODE
        //      Driver
        //      SOFTWAREKEY

        dwSize = sizeof(BOOL);          // Active
        RegQueryValueEx(
                   hKeyChild,
                   szRegActive,
                   NULL,
                   &dwType,
                   (LPBYTE) &lpCapDriverInfo->fActive,
                   &dwSize);

        dwSize = sizeof(BOOL);          // Enabled
        RegQueryValueEx(
                   hKeyChild,
                   szRegDisabled,
                   NULL,
                   &dwType,
                   (LPBYTE) &lpCapDriverInfo->fDisabled,
                   &dwSize);
        // Convert this thing to a bool
        lpCapDriverInfo->fDisabled = (lpCapDriverInfo->fDisabled == '1');

        // DriverDescription
        dwSize = sizeof (lpCapDriverInfo->szDriverDescription) / sizeof (TCHAR);
        RegQueryValueEx(
                   hKeyChild,
                   szRegDescription,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szDriverDescription,
                   &dwSize);

        // DEVNODE
        dwSize = sizeof(DEVNODE);
        RegQueryValueEx(
                   hKeyChild,
                   szRegDevNode,
                   NULL,
                   &dwType,
                   (LPBYTE) &lpCapDriverInfo->dnDevNode,
                   &dwSize);

        // DriverName
        dwSize = sizeof (lpCapDriverInfo->szDriverName) / sizeof (TCHAR);
        RegQueryValueEx(
                   hKeyChild,
                   szRegDriver,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szDriverName,
                   &dwSize);

        // SoftwareKey
        dwSize = sizeof (lpCapDriverInfo->szSoftwareKey) / sizeof (TCHAR);
        RegQueryValueEx(
                   hKeyChild,
                   szRegSoftwareKey,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szSoftwareKey,
                   &dwSize);

        RegCloseKey (hKeyChild);

    } // if the subkey could be opened

    RegCloseKey (hKeyMSVideoRoot);

    return fOK;
}

// Fetches driver info listed in system.ini
// Returns: TRUE if the index was valid, FALSE if no driver at that index

BOOL videoIniGetDriverByIndex (
        DWORD           dwDeviceID,
        LPCAPDRIVERINFO lpCapDriverInfo)
{
    TCHAR szKey[sizeof(szVideo)/sizeof(TCHAR) + 2];
    int w = (int) dwDeviceID;
    BOOL fOK = FALSE;

    // Always start clean since the entry may be recycled
    _fmemset (lpCapDriverInfo, 0, sizeof (CAPDRIVERINFO));

    lstrcpy(szKey, szVideo);
    szKey[(sizeof(szVideo)/sizeof(TCHAR)) - 1] = (TCHAR)0;
    if( w > 0 ) {
        szKey[(sizeof(szVideo)/sizeof(TCHAR))] = (TCHAR)0;
        szKey[(sizeof(szVideo)/sizeof(TCHAR))-1] = (TCHAR) TEXT('1' + (w-1) );  // driver ordinal
    }

    // Only get its driver name
    if (GetPrivateProfileString(szDrivers, szKey, szNull,
                lpCapDriverInfo->szDriverName,
                sizeof(lpCapDriverInfo->szDriverName)/sizeof(TCHAR),
                szSystemIni)) {

        HKEY hKey = NULL;
        DWORD dwSize, dwType;

        // Get the key if it already exists

        // Get Drivers.Desc from its Drivers32 driver name
        if (ERROR_SUCCESS == RegOpenKey (
                HKEY_LOCAL_MACHINE,
                szDriversDescRegKey,
                &hKey) != ERROR_SUCCESS) {
            // DriverDescription
            dwSize = sizeof (lpCapDriverInfo->szDriverDescription) / sizeof (TCHAR);
            // [drivers.desc]
            //   DriverName = DriverDescription
            dwType = REG_SZ;
            RegQueryValueEx(
                   hKey,
                   lpCapDriverInfo->szDriverName,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szDriverDescription,
                   &dwSize);

            RegCloseKey (hKey);
        }  else {
            dprintf("videoIniGetDriverByIndex: RegOpenKey of Drivers.Desc failed !!\n");
        }





        // Found an entry at the requested index
        // The description and version info will be inserted as
        // requested by the client app.

        lpCapDriverInfo-> fOnlySystemIni = TRUE;

        fOK = TRUE;
    }

    return fOK;
}

DWORD videoFreeDriverList (void)

{
    int i;

    // Free the driver list
    for (i = 0; i < MAXVIDEODRIVERS; i++) {
        if (aCapDriverList[i])
            GlobalFreePtr (aCapDriverList[i]);
        aCapDriverList[i] = NULL;
    }

    wTotalVideoDevs = 0;

    return DV_ERR_OK;
}

// This function may be called a number of times to create the
// current driver array.  Since Capscrn assumes it can throw a
// driver into system.ini on the fly and have it immediately accessible,
// this routine is called on videoGetNumDevs() and when AVICapx.dll
// tries to get the driver description and version.
//
// Drivers in the registry will be the first entries in the list.
//
// If a driver is listed in the registry AND in system.ini AND
// the full path to the drivers match, the system.ini entry will NOT
// be in the resulting list.

// The variable wTotalVideoDevs is set as a byproduct of this function.

// Returns DV_ERR_OK on success, even if no drivers are installed.
//
DWORD videoCreateDriverList (void)

{
    int i, j, k;


    // Delete the existing list
    videoFreeDriverList ();

    // Allocate an array of pointers to all possible capture drivers
    for (i = 0; i < MAXVIDEODRIVERS; i++) {
        aCapDriverList[i] = (LPCAPDRIVERINFO) GlobalAllocPtr (
                GMEM_MOVEABLE |
                GMEM_SHARE |
                GMEM_ZEROINIT,
                sizeof (CAPDRIVERINFO));
        if (aCapDriverList[i] == NULL) {
            videoFreeDriverList ();
            return DV_ERR_NOMEM;
        }
    }

    // Walk the list of Registry drivers and get each entry
    // Get VFW drivers from MediaResource\MsVideo
    for (i = 0; i < MAXVIDEODRIVERS; i++) {
        if (videoRegGetDriverByIndex (
                    (DWORD) i, aCapDriverList[wTotalVideoDevs])) {

            dprintf("MediaResource: idx %d, DriverName %x, Desc %x\n", wTotalVideoDevs, aCapDriverList[wTotalVideoDevs]->szDriverName, aCapDriverList[wTotalVideoDevs]->szDriverDescription);

            wTotalVideoDevs++;
        }
        else
            break;
    }

    if (wTotalVideoDevs == MAXVIDEODRIVERS)
        goto AllDone;

    // Now add the entries listed in system.ini, [Drivers#2] section, (msvideo[0-9] = driver.drv)
    // to the driver array, ONLY if the entry doesn't exactly match
    // an existing registry entry.

    for (j = 0; j < MAXVIDEODRIVERS; j++) {
        // Get driver name such as *.dll
        if (videoIniGetDriverByIndex ((DWORD) j,
                        aCapDriverList[wTotalVideoDevs])) {

            // Found an entry, now see if it is a duplicate of an existing
            // registry entry

            for (k = 0; k < (int) wTotalVideoDevs; k++) {

                if (lstrcmpi (aCapDriverList[k]->szDriverName,
                    aCapDriverList[wTotalVideoDevs]->szDriverName) == 0) {

                    // Found an exact match, so skip it!
                    goto SkipThisEntry;
                }
            }

            if (wTotalVideoDevs >= MAXVIDEODRIVERS - 1)
                break;

            dprintf("Drivers32: idx %d, DriverName %x\n", wTotalVideoDevs, aCapDriverList[wTotalVideoDevs]->szDriverName);

            wTotalVideoDevs++;

SkipThisEntry:
            ;
        } // If sytem.ini entry was found
    } // For all system.ini possibilities

AllDone:


    // Decrement wTotalVideoDevs for any entries which are marked as disabled
    // And remove disabled entries from the list
    for (i = 0; i < MAXVIDEODRIVERS; ) {

        if (aCapDriverList[i] && aCapDriverList[i]->fDisabled) {

            GlobalFreePtr (aCapDriverList[i]);

            // Shift down the remaining drivers
            for (j = i; j < MAXVIDEODRIVERS - 1; j++) {
                aCapDriverList[j] = aCapDriverList[j + 1];
            }
            aCapDriverList[MAXVIDEODRIVERS - 1] = NULL;

            wTotalVideoDevs--;
        }
        else
            i++;
    }

    // Free the unused pointers
    for (i = wTotalVideoDevs; i < MAXVIDEODRIVERS; i++) {
        if (aCapDriverList[i])
            GlobalFreePtr (aCapDriverList[i]);
        aCapDriverList[i] = NULL;
    }

    // Put PnP drivers first in the list
    // These are the only entries that have a DevNode
    for (k = i = 0; i < (int) wTotalVideoDevs; i++) {
        if (aCapDriverList[i]-> dnDevNode) {
            LPCAPDRIVERINFO lpCDTemp;

            if (k != i) {
                // Swap the entries
                lpCDTemp = aCapDriverList[k];
                aCapDriverList[k] = aCapDriverList[i];
                aCapDriverList[i] = lpCDTemp;
            }
            k++;   // Index of first non-PnP driver
        }
    }

    dprintf("videoCreateDriverList: DeviceList contains %d Video Device(s).\n", wTotalVideoDevs);

    return DV_ERR_OK;
}



// ----------------------------------------------------------------------
//
// To clean up when a WOW app exits, we need to maintain a list of
// open devices. A list of HANDLEINFO structs is hung off g_pHandles.
// An item is added to the head of this list in videoOpen, and removed
// in videoClose. When a WOW app exits, winmm will call our WOWAppExit
// function: for each entry in the list that is owned by the exiting thread,
// we call videoClose to close the device and remove the handle entry.
//

// one of these per open handle
typedef struct _HANDLEINFO {
    HVIDEO hv;
    HANDLE hThread;
    struct _HANDLEINFO * pNext;
} HANDLEINFO, * PHANDLEINFO;

// head of global list of open handles
PHANDLEINFO g_pHandles;

// critical section that protects global list
CRITICAL_SECTION csHandles;

// init list and critsec
void
videoInitHandleList()
{
    g_pHandles = NULL;
    InitializeCriticalSection(&csHandles);
}

// finished with critsec list
void
videoDeleteHandleList()
{
    // don't need critical section as no-one else can be using
    // it now (we are about to delete the critsec)

    // empty everything out of the list
    while (g_pHandles) {
        videoClose(g_pHandles->hv);
    }

    DeleteCriticalSection(&csHandles);
}



// add a handle to the list
void
videoAddHandle(HVIDEO hv)
{
    PHANDLEINFO pinfo = HeapAlloc(GetProcessHeap(), 0, sizeof(HANDLEINFO));

    if (!pinfo) {
        // couldn't allocate the memory - best thing to do is
        // forget it - nothing bad will happen except that we
        // might possibly fail to clean up if this is a wow app and
        // it exits without closing the capture device.
        return;
    }

    pinfo->hv = hv;
    pinfo->hThread = GetCurrentTask();

    EnterCriticalSection(&csHandles);

    pinfo->pNext = g_pHandles;
    g_pHandles = pinfo;

    LeaveCriticalSection(&csHandles);
}

// delete an entry from the handle list given the HVIDEO.
// caller must close the HVIDEO
// should be called before closing (in case the HVIDEO is reassigned after
// closing and before removing from the list
void
videoDelete(HVIDEO hv)
{
    PHANDLEINFO * ppNext;
    PHANDLEINFO pinfo;

    EnterCriticalSection(&csHandles);

    ppNext = &g_pHandles;
    while (*ppNext) {
        if ((*ppNext)->hv == hv) {
            pinfo = *ppNext;
            *ppNext = pinfo->pNext;
            HeapFree(GetProcessHeap(), 0, pinfo);
            break;

        } else {
            ppNext = &(*ppNext)->pNext;
        }
    }

    LeaveCriticalSection(&csHandles);
}

// close any handles open by this task
void
AppCleanup(HANDLE hTask)
{
    PHANDLEINFO pinfo;

    EnterCriticalSection(&csHandles);

    pinfo = g_pHandles;
    while (pinfo) {

        if (pinfo->hThread == hTask) {

            // get the next pointer before videoClose deletes the entry
            HVIDEO hv = pinfo->hv;
            pinfo = pinfo->pNext;

            videoClose(hv);
        } else {
            pinfo = pinfo->pNext;
        }
    }

    LeaveCriticalSection(&csHandles);
}


// ----------------------------------------------------------------------




/*****************************************************************************
 * @doc INTERNAL  VIDEO validation code for VIDEOHDRs
 ****************************************************************************/

#define IsVideoHeaderPrepared(hVideo, lpwh)      ((lpwh)->dwFlags &  VHDR_PREPARED)
#define MarkVideoHeaderPrepared(hVideo, lpwh)    ((lpwh)->dwFlags |= VHDR_PREPARED)
#define MarkVideoHeaderUnprepared(hVideo, lpwh)  ((lpwh)->dwFlags &=~VHDR_PREPARED)



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @func DWORD | videoMessage | This function sends messages to a
 *   video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies the handle to the video device channel.
 *
 * @parm UINT | wMsg | Specifies the message to send.
 *
 * @parm DWORD | dwP1 | Specifies the first parameter for the message.
 *
 * @parm DWORD | dwP2 | Specifies the second parameter for the message.
 *
 * @rdesc Returns the message specific value returned from the driver.
 *
 * @comm This function is used for configuration messages such as
 *      <m DVM_SRC_RECT> and <m DVM_DST_RECT>, and
 *      device specific messages.
 *
 * @xref <f videoConfigure>
 *
 ****************************************************************************/
LRESULT WINAPI videoMessage(HVIDEO hVideo, UINT msg, LPARAM dwP1, LPARAM dwP2)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return SendDriverMessage ((HDRVR)hVideo, msg, dwP1, dwP2);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoGetNumDevs | This function returns the number of MSVIDEO
 *   devices installed.
 *
 * @rdesc Returns the number of MSVIDEO devices listed in the
 *  [drivers] (or [drivers32] for NT) section of the SYSTEM.INI file.
 *
 * @comm Because the indexes of the MSVIDEO devices in the SYSTEM.INI
 *       file can be non-contiguous, applications should not assume
 *       the indexes range between zero and the number of devices minus
 *       one.
 *
 * @xref <f videoOpen>
 ****************************************************************************/
DWORD WINAPI videoGetNumDevs(void)
{
    DWORD dwNumDevs = 0;

    if(DV_ERR_OK == videoCreateDriverList ()) {
       dwNumDevs = wTotalVideoDevs;  // Save it before reseting to 0 in videoFreeDriverList.
       videoFreeDriverList ();    
    }
                                                                       
    return dwNumDevs;
}

/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoGetErrorText | This function retrieves a
 *   description of the error identified by the error number.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *	This might be NULL if the error is not device specific.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPSTR | lpText | Specifies a far pointer to a buffer used to
 *       return the zero-terminated string corresponding to the error number.
 *
 * @parm UINT | wSize | Specifies the length, in bytes, of the buffer
 *       referenced by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following error is defined:
 *   @flag DV_ERR_BADERRNUM | Specified error number is out of range.
 *   @flag DV_ERR_SIZEFIELD | The return buffer is not large enough
 *         to handle the error text.
 *
 * @comm If the error description is longer than the buffer,
 *   the description is truncated. The returned error string is always
 *   zero-terminated. If <p wSize> is zero, nothing is copied and zero
 *   is returned.
 ****************************************************************************/
#ifdef UNICODE  // Translate UNICODE response to ansi
DWORD WINAPI videoGetErrorTextA(HVIDEO hVideo, UINT wError,
			LPSTR lpText, UINT wSize)
{
    VIDEO_GETERRORTEXT_PARMS vet;

    if (IsBadWritePtr (lpText, wSize))
        return DV_ERR_PARAM1;

    lpText[0] = 0;
    if (((wError >= DV_ERR_BASE) && (wError <= DV_ERR_LASTERROR))) {
        if (wSize > 1) {
            if (!LoadStringA(ghInstDll, wError, lpText, wSize))
                return DV_ERR_BADERRNUM;
            else
                return DV_ERR_OK;
        }
        else
            return DV_ERR_SIZEFIELD;
    }
    else if (wError >= DV_ERR_USER_MSG && hVideo) {
        DWORD dwResult;
        LPWSTR lpwstr = LocalAlloc(LPTR, wSize*sizeof(WCHAR));
        if (NULL == lpwstr) {
            return(DV_ERR_NOMEM);
        }
        vet.dwError = (DWORD) wError;
        vet.lpText = lpwstr;
        vet.dwLength = (DWORD) wSize;
        dwResult = (DWORD) videoMessage (hVideo, DVM_GETERRORTEXT, (DWORD_PTR) (LPVOID) &vet,
                        (DWORD_PTR) NULL);
        if (DV_ERR_OK == dwResult) {
            Iwcstombs(lpText, lpwstr, wSize);
        }
        LocalFree(lpwstr);
        return(dwResult);
    }
    else
        return DV_ERR_BADERRNUM;
}
#endif //UNICODE

//
// The unicode/Win16 equivalent of the above
//

DWORD WINAPI videoGetErrorText(HVIDEO hVideo, UINT wError,
			LPTSTR lpText, UINT wSize)
{
    VIDEO_GETERRORTEXT_PARMS vet;
    lpText[0] = 0;

    if (((wError > DV_ERR_BASE) && (wError <= DV_ERR_LASTERROR))) {
        if (wSize > 1) {
            if (!LoadString(ghInstDll, wError, lpText, wSize))
                return DV_ERR_BADERRNUM;
            else
                return DV_ERR_OK;
        }
        else
            return DV_ERR_SIZEFIELD;
    }
    else if (wError >= DV_ERR_USER_MSG && hVideo) {
        vet.dwError = (DWORD) wError;
        vet.lpText = lpText;
        vet.dwLength = (DWORD) wSize;
        return (DWORD) videoMessage (hVideo, DVM_GETERRORTEXT, (DWORD_PTR) (LPVOID) &vet,
                        (DWORD_PTR) NULL);
    }
    else
        return DV_ERR_BADERRNUM;
}


/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoGetChannelCaps | This function retrieves a
 *   description of the capabilities of a channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPCHANNEL_CAPS | lpChannelCaps | Specifies a far pointer to a
 *      <t CHANNEL_CAPS> structure.
 *
 * @parm DWORD | dwSize | Specifies the size, in bytes, of the
 *       <t CHANNEL_CAPS> structure.
 *
 * @rdesc Returns zero if the function is successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_UNSUPPORTED | Function is not supported.
 *
 * @comm The <t CHANNEL_CAPS> structure returns the capability
 *   information. For example, capability information might
 *   include whether or not the channel can crop and scale images,
 *   or show overlay.
 ****************************************************************************/
DWORD WINAPI videoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps,
			DWORD dwSize)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpChannelCaps, sizeof (CHANNEL_CAPS)))
        return DV_ERR_PARAM1;

    // _fmemset (lpChannelCaps, 0, sizeof (CHANNEL_CAPS));

    lpChannelCaps->dwFlags = 0;
    lpChannelCaps->dwSrcRectXMod = 0;
    lpChannelCaps->dwSrcRectYMod = 0;
    lpChannelCaps->dwSrcRectWidthMod = 0;
    lpChannelCaps->dwSrcRectHeightMod = 0;
    lpChannelCaps->dwDstRectXMod = 0;
    lpChannelCaps->dwDstRectYMod = 0;
    lpChannelCaps->dwDstRectWidthMod = 0;
    lpChannelCaps->dwDstRectHeightMod = 0;

    return (DWORD) videoMessage(hVideo, DVM_GET_CHANNEL_CAPS, (DWORD_PTR) lpChannelCaps,
	    (DWORD_PTR) dwSize);
}


/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoUpdate | This function directs a channel to
 *   repaint the display.  It applies only to VIDEO_EXTERNALOUT channels.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm HWND | hWnd | Specifies the handle of the window to be used
 *      by the channel for image display.
 *
 * @parm HDC | hDC | Specifies a handle to a device context.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_UNSUPPORTED | Specified message is unsupported.
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 * @comm This message is normally sent
 *   whenever the client window receives a <m WM_MOVE>, <m WM_SIZE>,
 *   or <m WM_PAINT> message.
 ****************************************************************************/
DWORD WINAPI videoUpdate (HVIDEO hVideo, HWND hWnd, HDC hDC)
{
    if ((!hVideo) || (!hWnd) || (!hDC) )
        return DV_ERR_INVALHANDLE;

    return (DWORD) videoMessage(hVideo, DVM_UPDATE, (DWORD_PTR) hWnd, (DWORD_PTR) hDC);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoOpen | This function opens a channel on the
 *  specified video device.
 *
 * @parm LPHVIDEO | lphvideo | Specifies a far pointer to a buffer
 *   used to return an <t HVIDEO> handle. The video capture driver
 *   uses this location to return
 *   a handle that uniquely identifies the opened video device channel.
 *   Use the returned handle to identify the device channel when
 *   calling other video functions.
 *
 * @parm DWORD | dwDeviceID | Identifies the video device to open.
 *      The value of <p dwDeviceID> varies from zero to one less
 *      than the number of video capture devices installed in the system.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device.
 *      The following flags are defined:
 *
 *   @flag VIDEO_EXTERNALIN| Specifies the channel is opened
 *	     for external input. Typically, external input channels
 *      capture images into a frame buffer.
 *
 *   @flag VIDEO_EXTERNALOUT| Specifies the channel is opened
 *      for external output. Typically, external output channels
 *      display images stored in a frame buffer on an auxilary monitor
 *      or overlay.
 *
 *   @flag VIDEO_IN| Specifies the channel is opened
 *      for video input. Video input channels transfer images
 *      from a frame buffer to system memory buffers.
 *
 *   @flag VIDEO_OUT| Specifies the channel is opened
 *      for video output. Video output channels transfer images
 *      from system memory buffers to a frame buffer.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_BADDEVICEID | Indicates the specified device ID is out of range.
 *   @flag DV_ERR_ALLOCATED | Indicates the specified resource is already allocated.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm
 *   At a minimum, all capture drivers support a VIDEO_EXTERNALIN
 *   and a VIDEO_IN channel.
 *   Use <f videoGetNumDevs> to determine the number of video
 *   devices present in the system.
 *
 * @xref <f videoClose>
 ****************************************************************************/
DWORD WINAPI videoOpen (LPHVIDEO lphVideo, DWORD dwDeviceID, DWORD dwFlags)
{
    TCHAR szKey[MAX_PATH];  
    TCHAR szbuf[MAX_PATH];
    UINT w;
    VIDEO_OPEN_PARMS vop;       // Same as IC_OPEN struct!!!
    DWORD dwVersion = VIDEOAPIVERSION;
    DWORD dwErr;
    DWORD dwNumDevs = 0;

    if (IsBadWritePtr ((LPVOID) lphVideo, sizeof (HVIDEO)) )
        return DV_ERR_PARAM1;

    vop.dwSize = sizeof (VIDEO_OPEN_PARMS);
    vop.fccType = OPEN_TYPE_VCAP;       // "vcap"
    vop.fccComp = 0L;
    vop.dwVersion = VIDEOAPIVERSION;
    vop.dwFlags = dwFlags;      // In, Out, External In, External Out
    vop.dwError = DV_ERR_OK;

    w = (UINT)dwDeviceID;
    *lphVideo = NULL;

    dwNumDevs = videoGetNumDevs();

    // No drivers installed
    if (dwNumDevs == 0) 
        return DV_ERR_BADINSTALL;

    if (w >= MAXVIDEODRIVERS)
        return DV_ERR_BADDEVICEID;

    dwErr = videoCreateDriverList ();
    if(DV_ERR_OK != dwErr)
        return dwErr;
    
    if(w < dwNumDevs) {
       lstrcpyn(szKey, aCapDriverList[w]->szDriverName, MAX_PATH);
       lstrcpyn(szbuf, aCapDriverList[w]->szDriverName, MAX_PATH);
       videoFreeDriverList ();

       dprintf("szKey %x, szDrivers %x, szbuf %x\n", szKey, szDrivers, szbuf);

#ifdef THIS_IS_ANCIENT_CODE
        // Removed for VFW1.1
        // Only early Alpha 1.0 drivers required this...

        // Check driver version number by doing a configuration open...
        // Version 1 used LPARAM = dwFlags
        // Version 2 uses LPARAM = LPVIDEO_OPEN_PARMS

        if (hVideoTemp = OpenDriver(szKey, szDrivers, (LPARAM) NULL)) {
            HVIDEO hVideoTemp;

            // Version 1 drivers had the added bug of returning
            // the version from this message, instead of in
            // lParam1
            if (videoMessage (hVideoTemp, DVM_GETVIDEOAPIVER,
                        (LPARAM) (LPVOID) &dwVersion, 0L) == 1)
                dwVersion = 1;
            CloseDriver(hVideoTemp, 0L, 0L );
        }

        if (dwVersion == 1)
            *lphVideo = OpenDriver(szKey, szDrivers, dwFlags);
        else
#endif // THIS_IS_ANCIENT_CODE

        *lphVideo = (HVIDEO)OpenDriver(szKey, szDrivers, (LPARAM) (LPVOID) &vop);

	    if( ! *lphVideo ) {
            if (vop.dwError)    // if driver returned an error code...
                return vop.dwError;
            else {
#ifdef WIN32
		        if (GetFileAttributes(szbuf) == (DWORD) -1)
#else
                OFSTRUCT of;

                if (OpenFile (szbuf, &of, OF_EXIST) == HFILE_ERROR)
#endif
                    return (DV_ERR_BADINSTALL);
                else
                    return (DV_ERR_NOTDETECTED);
            }
	    }
    } else {
        videoFreeDriverList ();
        return( DV_ERR_BADINSTALL );
    }

    videoAddHandle(*lphVideo);

    return DV_ERR_OK;

}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoClose | This function closes the specified video
 *   device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *  If this function is successful, the handle is invalid
 *   after this call.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NONSPECIFIC | The driver failed to close the channel.
 *
 * @comm If buffers have been sent with <f videoStreamAddBuffer> and
 *   they haven't been returned to the application,
 *   the close operation fails. You can use <f videoStreamReset> to mark all
 *   pending buffers as done.
 *
 * @xref <f videoOpen> <f videoStreamInit> <f videoStreamFini> <f videoStreamReset>
 ****************************************************************************/
DWORD WINAPI videoClose (HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    videoDelete(hVideo);

    return (CloseDriver((HDRVR)hVideo, 0L, 0L ) ? DV_ERR_OK : DV_ERR_NONSPECIFIC);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoConfigure | This function sets or retrieves
 *      the options for a configurable driver.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm UINT | msg  | Specifies the option to set or retrieve. The
 *       following options are defined:
 *
 *   @flag DVM_PALETTE | Indicates a palette is being sent to the driver
 *         or retrieved from the driver.
 *
 *   @flag DVM_PALETTERGB555 | Indicates an RGB555 palette is being
 *         sent to the driver.
 *
 *   @flag DVM_FORMAT | Indicates format information is being sent to
 *         the driver or retrieved from the driver.
 *
 * @parm DWORD | dwFlags | Specifies flags for configuring or
 *   interrogating the device driver. The following flags are defined:
 *
 *   @flag VIDEO_CONFIGURE_SET | Indicates values are being sent to the driver.
 *
 *   @flag VIDEO_CONFIGURE_GET | Indicates values are being obtained from the driver.
 *
 *   @flag VIDEO_CONFIGURE_QUERY | Determines if the
 *      driver supports the option specified by <p msg>. This flag
 *      should be combined with either the VIDEO_CONFIGURE_SET or
 *      VIDEO_CONFIGURE_GET flag. If this flag is
 *      set, the <p lpData1>, <p dwSize1>, <p lpData2>, and <p dwSize2>
 *      parameters are ignored.
 *
 *   @flag VIDEO_CONFIGURE_QUERYSIZE | Returns the size, in bytes,
 *      of the configuration option in <p lpdwReturn>. This flag is only valid if
 *      the VIDEO_CONFIGURE_GET flag is also set.
 *
 *   @flag VIDEO_CONFIGURE_CURRENT | Requests the current value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_NOMINAL | Requests the nominal value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_MIN | Requests the minimum value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_MAX | Get the maximum value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *	
 * @parm LPDWORD | lpdwReturn  | Points to a DWORD used for returning information
 *      from the driver.  If
 *      the VIDEO_CONFIGURE_QUERYSIZE flag is set, <p lpdwReturn> is
 *      filled with the size of the configuration option.
 *
 * @parm LPVOID | lpData1  |Specifies a pointer to message specific data.
 *
 * @parm DWORD | dwSize1  | Specifies the size, in bytes, of the <p lpData1>
 *       buffer.
 *
 * @parm LPVOID | lpData2  | Specifies a pointer to message specific data.
 *
 * @parm DWORD | dwSize2  | Specifies the size, in bytes, of the <p lpData2>
 *       buffer.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @xref <f videoOpen> <f videoMessage>
 *
 ****************************************************************************/
DWORD WINAPI videoConfigure (HVIDEO hVideo, UINT msg, DWORD dwFlags,
		LPDWORD lpdwReturn, LPVOID lpData1, DWORD dwSize1,
                LPVOID lpData2, DWORD dwSize2)
{
    VIDEOCONFIGPARMS    vcp;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (lpData1)
        if (IsBadHugeReadPtr (lpData1, dwSize1))
            return DV_ERR_CONFIG1;

    if (lpData2)
        if (IsBadHugeReadPtr (lpData2, dwSize2))
            return DV_ERR_CONFIG2;

    if (dwFlags & VIDEO_CONFIGURE_QUERYSIZE) {
        if (!lpdwReturn)
            return DV_ERR_NONSPECIFIC;
        if (IsBadWritePtr (lpdwReturn, sizeof (*lpdwReturn)) )
            return DV_ERR_NONSPECIFIC;
    }

    vcp.lpdwReturn = lpdwReturn;
    vcp.lpData1 = lpData1;
    vcp.dwSize1 = dwSize1;
    vcp.lpData2 = lpData2;
    vcp.dwSize2 = dwSize2;

    return (DWORD) videoMessage(hVideo, msg, dwFlags,
	    (DWORD_PTR)(LPVIDEOCONFIGPARMS)&vcp );
}



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoConfigureStorage | This function saves or loads
 *	     all configurable options for a channel.  Options
 *      can be saved and recalled for each application or each application
 *      instance.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPSTR | lpstrIdent  | Identifies the application or instance.
 *      Use an arbitrary string which uniquely identifies your application
 *      or instance.
 *
 * @parm DWORD | dwFlags | Specifies any flags for the function. The following
 *   flags are defined:
 *   @flag VIDEO_CONFIGURE_GET | Requests that the values be loaded.
 *   @flag VIDEO_CONFIGURE_SET | Requests that the values be saved.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @comm The method used by a driver to save configuration options is
 *      device dependent.
 *
 * @xref <f videoOpen>
 ****************************************************************************/
#ifdef UNICODE
DWORD WINAPI videoConfigureStorageA(HVIDEO hVideo,
			LPSTR lpstrIdent, DWORD dwFlags)
{
    DWORD ret;
    LPWSTR lpwstr;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;


    // Convert the input string to Unicode
    // Call the driver, free the Unicode string and return the result
    ret = strlen(lpstrIdent);
    lpwstr = LocalAlloc(LPTR, ret*sizeof(WCHAR));
    if (!lpwstr) {
        return(DV_ERR_NOMEM);
    }

    Imbstowcs(lpwstr, lpstrIdent, ret);

    ret = (DWORD) videoMessage(hVideo, DVM_CONFIGURESTORAGE,
	    (DWORD_PTR)lpwstr, dwFlags);

    LocalFree(lpwstr);
    return(ret);
}

#endif

// On NT the header file will have ensured that videoConfigureStorage is
// defined by a macro to videoConfigureStorageW
DWORD WINAPI videoConfigureStorage(HVIDEO hVideo,
			LPWSTR lpstrIdent, DWORD dwFlags)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return (DWORD) videoMessage(hVideo, DVM_CONFIGURESTORAGE,
	    (DWORD_PTR)lpstrIdent, dwFlags);
}




/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoDialog | This function displays a channel-specific
 *     dialog box used to set configuration parameters.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm HWND | hWndParent | Specifies the parent window handle.
 *
 * @parm DWORD | dwFlags | Specifies flags for the dialog box. The
 *   following flag is defined:
 *   @flag VIDEO_DLG_QUERY | If this flag is set, the driver immediately
 *	     returns zero if it supplies a dialog box for the channel,
 *           or DV_ERR_NOTSUPPORTED if it does not.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @comm Typically, each dialog box displayed by this
 *      function lets the user select options appropriate for the channel.
 *      For example, a VIDEO_IN channel dialog box lets the user select
 *      the image dimensions and bit depth.
 *
 * @xref <f videoOpen> <f videoConfigureStorage>
 ****************************************************************************/
DWORD WINAPI videoDialog (HVIDEO hVideo, HWND hWndParent, DWORD dwFlags)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if ((!hWndParent) || (!IsWindow (hWndParent)) )
        return DV_ERR_INVALHANDLE;

    return (DWORD) videoMessage(hVideo, DVM_DIALOG, (DWORD_PTR)hWndParent, dwFlags);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////


/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api DWORD | videoPrepareHeader | This function prepares the
 *	header and data
 *	by performing a <f GlobalPageLock>.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it
 *   specifies an error number.
 ****************************************************************************/
DWORD WINAPI videoPrepareHeader(LPVIDEOHDR lpVideoHdr, DWORD dwSize)
{
    if (!HugePageLock(lpVideoHdr, (DWORD_PTR)sizeof(VIDEOHDR)))
        return DV_ERR_NOMEM;

    if (!HugePageLock(lpVideoHdr->lpData, lpVideoHdr->dwBufferLength)) {
        HugePageUnlock(lpVideoHdr, (DWORD_PTR)sizeof(VIDEOHDR));
        return DV_ERR_NOMEM;
    }

    lpVideoHdr->dwFlags |= VHDR_PREPARED;

    return DV_ERR_OK;
}

/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api DWORD | videoUnprepareHeader | This function unprepares the header and
 *   data if the driver returns DV_ERR_NOTSUPPORTED.
 *
 * @rdesc Currently always returns DV_ERR_OK.
 ****************************************************************************/
DWORD WINAPI videoUnprepareHeader(LPVIDEOHDR lpVideoHdr, DWORD dwSize)
{

    HugePageUnlock(lpVideoHdr->lpData, lpVideoHdr->dwBufferLength);
    HugePageUnlock(lpVideoHdr, (DWORD_PTR)sizeof(VIDEOHDR));

    lpVideoHdr->dwFlags &= ~VHDR_PREPARED;

    return DV_ERR_OK;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamAllocHdrAndBuffer | This function is used to allow
 *      drivers to optionally allocate video buffers.  Normally, the client
 *      application is responsible for allocating buffer memory, but devices
 *      which have on-board memory may optionally allocate headers and buffers
 *      using this function. Generally, this will avoid an additional data copy,
 *      resulting in faster capture rates.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR FAR * | plpvideoHdr | Specifies a pointer to the address of a
 *   <t VIDEOHDR> structure.  The driver saves the buffer address in this
 *   location, or NULL if it cannot allocate a buffer.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure
 *      and associated video buffer in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the driver does not have on-board memory.
 *
 * @comm If the driver
 *   allocates buffers via this method, the <f videoStreamPrepareHeader> and
 *   <f videoStreamUnprepareHeader> functions should be used.
 *
 *   The buffer allocated must be accessible for DMA by the host.
 *
 * @xref <f videoStreamPrepareHeader>
 ****************************************************************************/
DWORD WINAPI videoStreamAllocHdrAndBuffer(HVIDEO hVideo,
		LPVIDEOHDR FAR * plpvideoHdr, DWORD dwSize)
{
#ifdef OBSOLETE
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (plpvideoHdr, sizeof (VIDEOHDR *)) )
        return DV_ERR_PARAM1;

    *plpvideoHdr = NULL;        // Init to NULL ptr

    wRet = (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_ALLOCHDRANDBUFFER,
            (DWORD_PTR)plpvideoHdr, (DWORD_PTR)dwSize);

    if (*plpvideoHdr == NULL ||
                IsBadHugeWritePtr (*plpvideoHdr, dwSize)) {
        DebugErr(DBF_WARNING,"videoStreamAllocHdrAndBuffer: Allocation failed.");
        *plpvideoHdr = NULL;
        return wRet;
    }

    if (IsVideoHeaderPrepared(HVIDEO, *plpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamAllocHdrAndBuffer: header is already prepared.");
        return DV_ERR_OK;
    }

    (*plpvideoHdr)->dwFlags = 0;

    if (wRet == DV_ERR_OK)
        MarkVideoHeaderPrepared(hVideo, *plpvideoHdr);

    return wRet;
#endif
    return DV_ERR_NOTSUPPORTED;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamFreeHdrAndBuffer | This function is used to free
 *      buffers allocated by the driver using the <f videoStreamAllocHdrAndBuffer>
 *      function.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr | Specifies a pointer to the
 *   <t VIDEOHDR> structure and associated buffer to be freed.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the driver does not have on-board memory.
 *
 * @comm If the driver
 *   allocates buffers via this method, the <f videoStreamPrepareHeader> and
 *   <f videoStreamUnprepareHeader> functions should be used.
 *
 * @xref <f videoStreamPrepareHeader>
 ****************************************************************************/

DWORD WINAPI videoStreamFreeHdrAndBuffer(HVIDEO hVideo,
		LPVIDEOHDR lpvideoHdr)
{
#ifdef OBSOLETE
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (lpvideoHdr->dwFlags & VHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "videoStreamFreeHdrAndBuffer: buffer still in queue.");
        return DV_ERR_STILLPLAYING;
    }

    if (!IsVideoHeaderPrepared(hVideo, lpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamFreeHdrAndBuffer: header is not prepared.");
    }

    wRet = (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_FREEHDRANDBUFFER,
            (DWORD_PTR)lpvideoHdr, (DWORD_PTR)0);

    if (wRet != DV_ERR_OK)
    {
        DebugErr(DBF_WARNING,"videoStreamFreeHdrAndBuffer: Error freeing buffer.");
    }

    return wRet;
#endif
    return DV_ERR_NOTSUPPORTED;
}

DWORD WINAPI videoStreamAllocBuffer(HVIDEO hVideo,
		LPVOID FAR * plBuffer, DWORD dwSize)
{
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

// as this code is internal to our dll we do not need to check access rights
//    if (IsBadWritePtr (plpvideoHdr, sizeof (VIDEOHDR *)) )
//        return DV_ERR_PARAM1;

    *plBuffer = NULL;        // Init to NULL ptr

    wRet = (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_ALLOCBUFFER,
            (DWORD_PTR)plBuffer, (DWORD_PTR)dwSize);

    if (*plBuffer == NULL) {
        DebugErr(DBF_WARNING,"videoStreamAllocBuffer: Allocation failed.");
	dprintf("videoStreamAllocBuffer: Allocation failed, wRet=0x%d",wRet);
        *plBuffer = NULL;
        return wRet;
    }
    return wRet;
}

DWORD WINAPI videoStreamFreeBuffer(HVIDEO hVideo,
		LPVOID lpBuffer)
{
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    wRet = (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_FREEBUFFER,
            (DWORD_PTR)lpBuffer, (DWORD_PTR)0);

    if (wRet != DV_ERR_OK)
    {
        DebugErr(DBF_WARNING,"videoStreamFreeBuffer: Error freeing buffer.");
	dprintf("videoStreamFreeBuffer: error %d freeing buffer", wRet);
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamPrepareHeader | This function prepares a buffer
 *   for video streaming.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr | Specifies a pointer to a
 *   <t VIDEOHDR> structure identifying the buffer to be prepared.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm Use this function after <f videoStreamInit> or
 *   after <f videoStreamReset> to prepare the data buffers
 *   for streaming data.
 *
 *   The <t VIDEOHDR> data structure and the data block pointed to by its
 *   <e VIDEOHDR.lpData> member must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags, and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared will have no effect
 *   and the function will return zero. Typically, this function is used
 *   to ensure that the buffer will be available for use at interrupt time.
 *
 * @xref <f videoStreamUnprepareHeader>
 ****************************************************************************/
DWORD WINAPI videoStreamPrepareHeader(HVIDEO hVideo,
		LPVIDEOHDR lpvideoHdr, DWORD dwSize)
{
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (IsVideoHeaderPrepared(HVIDEO, lpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamPrepareHeader: header is already prepared.");
        return DV_ERR_OK;
    }

    lpvideoHdr->dwFlags = 0;

    wRet = (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_PREPAREHEADER,
            (DWORD_PTR)lpvideoHdr, (DWORD_PTR)dwSize);

    if (wRet == DV_ERR_NOTSUPPORTED)
        wRet = videoPrepareHeader(lpvideoHdr, dwSize);

    if (wRet == DV_ERR_OK)
        MarkVideoHeaderPrepared(hVideo, lpvideoHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamUnprepareHeader | This function clears the
 *  preparation performed by <f videoStreamPrepareHeader>.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr |  Specifies a pointer to a <t VIDEOHDR>
 *   structure identifying the data buffer to be unprepared.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_STILLPLAYING | Indicates the structure identified by <p lpvideoHdr>
 *   is still in the queue.
 *
 * @comm This function is the complementary function to <f videoStreamPrepareHeader>.
 *   You must call this function before freeing the data buffer with <f GlobalFree>.
 *   After passing a buffer to the device driver with <f videoStreamAddBuffer>, you
 *   must wait until the driver is finished with the buffer before calling
 *   <f videoStreamUnprepareHeader>. Unpreparing a buffer that has not been
 *   prepared or has been already unprepared has no effect,
 *   and the function returns zero.
 *
 * @xref <f videoStreamPrepareHeader>
 ****************************************************************************/
DWORD WINAPI videoStreamUnprepareHeader(HVIDEO hVideo, LPVIDEOHDR lpvideoHdr, DWORD dwSize)
{
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (lpvideoHdr->dwFlags & VHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "videoStreamUnprepareHeader: buffer still in queue.");
        return DV_ERR_STILLPLAYING;
    }

    if (!IsVideoHeaderPrepared(hVideo, lpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamUnprepareHeader: header is not prepared.");
        return DV_ERR_OK;
    }

    wRet = (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_UNPREPAREHEADER,
            (DWORD_PTR)lpvideoHdr, (DWORD_PTR)dwSize);

    if (wRet == DV_ERR_NOTSUPPORTED)
        wRet = videoUnprepareHeader(lpvideoHdr, dwSize);

    if (wRet == DV_ERR_OK)
        MarkVideoHeaderUnprepared(hVideo, lpvideoHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamAddBuffer | This function sends a buffer to a
 *   video-capture device. After the buffer is filled by the device,
 *   the device sends it back to the application.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr | Specifies a far pointer to a <t VIDEOHDR>
 *   structure that identifies the buffer.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_UNPREPARED | Indicates the <p lpvideoHdr> structure hasn't been prepared.
 *   @flag DV_ERR_STILLPLAYING | Indicates a buffer is still in the queue.
 *   @flag DV_ERR_PARAM1 | The <p lpvideoHdr> parameter is invalid or
 *       the <e VIDEOHDR.dwBufferLength> member of the <t VIDEOHDR>
 *       structure is not set to the proper value.
 *
 * @comm The data buffer must be prepared with <f videoStreamPrepareHeader>
 *   before it is passed to <f videoStreamAddBuffer>. The <t VIDEOHDR> data
 *   structure and the data buffer referenced by its <e VIDEOHDR.lpData>
 *   member must be allocated with <f GlobalAlloc> using the GMEM_MOVEABLE
 *   and GMEM_SHARE flags, and locked with <f GlobalLock>. Set the
 *   <e VIDEOHDR.dwBufferLength> member to the size of the header.
 *
 * @xref <f videoStreamPrepareHeader>
 ****************************************************************************/
DWORD WINAPI videoStreamAddBuffer(HVIDEO hVideo, LPVIDEOHDR lpvideoHdr, DWORD dwSize)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (!IsVideoHeaderPrepared(hVideo, lpvideoHdr))
    {
        DebugErr(DBF_WARNING, "videoStreamAddBuffer: buffer not prepared.");
        return DV_ERR_UNPREPARED;
    }

    if (lpvideoHdr->dwFlags & VHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "videoStreamAddBuffer: buffer already in queue.");
        return DV_ERR_STILLPLAYING;
    }

    return (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_ADDBUFFER, (DWORD_PTR)lpvideoHdr, (DWORD_PTR)dwSize);
}



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamStop | This function stops streaming on a video channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following error is defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 * @comm If there are any buffers in the queue, the current buffer will be
 *   marked as done (the <e VIDEOHDR.dwBytesRecorded> member in
 *   the <t VIDEOHDR> header will contain the actual length of data), but any
 *   empty buffers in the queue will remain there. Calling this
 *   function when the channel is not started has no effect, and the
 *   function returns zero.
 *
 * @xref <f videoStreamStart> <f videoStreamReset>
 ****************************************************************************/
DWORD WINAPI videoStreamStop(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return (DWORD) videoMessage((HVIDEO)hVideo, DVM_STREAM_STOP, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamReset | This function stops streaming
 *	     on the specified video device channel and resets the current position
 *      to zero.  All pending buffers are marked as done and
 *      are returned to the application.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 *
 * @xref <f videoStreamReset> <f videoStreamStop> <f videoStreamAddBuffer> <f videoStreamClose>
/****************************************************************************/
DWORD WINAPI videoStreamReset(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return (DWORD) videoMessage((HVIDEO)hVideo, DVM_STREAM_RESET, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamGetPosition | This function retrieves the current
 *   position of the specified video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPMMTIME | lpInfo | Specifies a far pointer to an <t MMTIME>
 *   structure.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t MMTIME> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *
 * @comm Before using <f videoStreamGetPosition>, set the
 *   <e MMTIME.wType> member of the <t MMTIME> structure to indicate
 *   the time format desired. After
 *   <f videoStreamGetPosition> returns, check the <e MMTIME.wType>
 *   member to  determine if the your time format is supported. If
 *   not, <e MMTIME.wType> specifies an alternate format.
 *   Video capture drivers typically provide the millisecond time
 *   format.
 *
 *   The position is set to zero when streaming is started with
 *   <f videoStreamStart>.
 ****************************************************************************/
DWORD WINAPI videoStreamGetPosition(HVIDEO hVideo, LPMMTIME lpInfo, DWORD dwSize)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpInfo, sizeof (MMTIME)) )
        return DV_ERR_PARAM1;

    return (DWORD) videoMessage(hVideo, DVM_STREAM_GETPOSITION,
            (DWORD_PTR)lpInfo, (DWORD_PTR)dwSize);
}

// ============================================

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamInit | This function initializes a video
 *     device channel for streaming.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm DWORD | dwMicroSecPerFrame | Specifies the number of microseconds
 *     between frames.
 *
 * @parm DWORD | dwCallback | Specifies the address of a callback
 *   function or a handle to a window called during video
 *   streaming. The callback function or window processes
 *  messages related to the progress of streaming.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user
 *  instance data passed to the callback function. This parameter is not
 *  used with window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device channel.
 *   The following flags are defined:
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_BADDEVICEID | Indicates the device ID specified in
 *         <p hVideo> is not valid.
 *   @flag DV_ERR_ALLOCATED | Indicates the resource specified is already allocated.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm If a window or function is chosen to receive callback information, the following
 *   messages are sent to it to indicate the
 *   progress of video input:
 *
 *   <m MM_DRVM_OPEN> is sent at the time of <f videoStreamInit>
 *
 *   <m MM_DRVM_CLOSE> is sent at the time of <f videoStreamFini>
 *
 *   <m MM_DRVM_DATA> is sent when a buffer of image data is available
 *
 *   <m MM_DRVM_ERROR> is sent when an error occurs
 *
 *   Callback functions must reside in a DLL.
 *   You do not have to use <f MakeProcInstance> to get
 *   a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | videoFunc | <f videoFunc> is a placeholder for an
 *   application-supplied function name. The actual name must be exported by
 *   including it in an EXPORTS statement in the DLL's module-definition file.
 *   This is used only when a callback function is specified in
 *   <f videoStreamInit>.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel
 *   associated with the callback.
 *
 * @parm DWORD | wMsg | Specifies the <m MM_DRVM_> messages. Messages indicate
 *       errors and when image data is available. For information on
 *       these messages, see <f videoStreamInit>.
 *
 * @parm DWORD | dwInstance | Specifies the user instance
 *   data specified with <f videoStreamInit>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL. Any data the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref <f videoOpen> <f videoStreamFini> <f videoClose>
 ****************************************************************************/
DWORD WINAPI videoStreamInit(HVIDEO hVideo,
              DWORD dwMicroSecPerFrame, DWORD_PTR dwCallback,
              DWORD_PTR dwCallbackInst, DWORD dwFlags)
{
    VIDEO_STREAM_INIT_PARMS vsip;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (dwCallback && ((dwFlags & CALLBACK_TYPEMASK) == CALLBACK_FUNCTION) ) {
        if (IsBadCodePtr ((FARPROC) dwCallback) )
            return DV_ERR_PARAM2;
        if (!dwCallbackInst)
            return DV_ERR_PARAM2;
    }

    if (dwCallback && ((dwFlags & CALLBACK_TYPEMASK) == CALLBACK_WINDOW) ) {
        if (!IsWindow((HWND)(dwCallback)) )
            return DV_ERR_PARAM2;
    }

    vsip.dwMicroSecPerFrame = dwMicroSecPerFrame;
    vsip.dwCallback = dwCallback;
    vsip.dwCallbackInst = dwCallbackInst;
    vsip.dwFlags = dwFlags;
    vsip.hVideo = (DWORD_PTR)hVideo;

    return (DWORD) videoMessage(hVideo, DVM_STREAM_INIT,
                (DWORD_PTR) (LPVIDEO_STREAM_INIT_PARMS) &vsip,
                (DWORD_PTR) sizeof (VIDEO_STREAM_INIT_PARMS));
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamFini | This function terminates streaming
 *     from the specified device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_STILLPLAYING | Indicates there are still buffers in the queue.
 *
 * @comm If there are buffers that have been sent with
 *   <f videoStreamAddBuffer> that haven't been returned to the application,
 *   this operation will fail. Use <f videoStreamReset> to return all
 *   pending buffers.
 *
 *   Each call to <f videoStreamInit> must be matched with a call to
 *   <f videoStreamFini>.
 *
 *   For VIDEO_EXTERNALIN channels, this function is used to
 *   halt capturing of data to the frame buffer.
 *
 *   For VIDEO_EXTERNALOUT channels supporting overlay,
 *   this function is used to disable the overlay.
 *
 * @xref <f videoStreamInit>
 ****************************************************************************/
DWORD WINAPI videoStreamFini(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return (DWORD) videoMessage(hVideo, DVM_STREAM_FINI, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamStart | This function starts streaming on the
 *   specified video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 *
 * @xref <f videoStreamReset> <f videoStreamStop> <f videoStreamAddBuffer> <f videoStreamClose>
/****************************************************************************/
DWORD WINAPI videoStreamStart(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return (DWORD) videoMessage(hVideo, DVM_STREAM_START, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamGetError | This function returns the error
 *   most recently encountered.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPDWORD | lpdwErrorID | Specifies a far pointer to the <t DWORD>
 *      used to return the error ID.
 *
 * @parm LPDWORD | lpdwErrorValue | Specifies a far pointer to the <t DWORD>
 *      used to return the number of frames skipped.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following error is defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 * @comm While streaming video data, a capture
 *      driver can fill buffers faster than the client application can
 *      save the buffers to disk.  In this case, the
 *      DV_ERR_NO_BUFFERS error is returned in <p lpdwErrorID>
 *      and <p lpdwErrorValue> contains a count of the number of
 *      frames missed.  After
 *      receiving this message and returning the error status, a driver
 *      should reset its internal error flag to DV_ERR_OK and
 *      the count of missed frames to zero.
 *
 *      Applications should send this message frequently during capture
 *      since some drivers which do not have access to interrupts use
 *      this message to trigger buffer processing.
 *
 * @xref <f videoOpen>
/****************************************************************************/
DWORD WINAPI videoStreamGetError(HVIDEO hVideo, LPDWORD lpdwError,
        LPDWORD lpdwFramesSkipped)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpdwError, sizeof (DWORD)) )
        return DV_ERR_PARAM1;

    if (IsBadWritePtr (lpdwFramesSkipped, sizeof (DWORD)) )
        return DV_ERR_PARAM2;

    return (DWORD) videoMessage(hVideo, DVM_STREAM_GETERROR, (DWORD_PTR) lpdwError,
        (DWORD_PTR) lpdwFramesSkipped);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoFrame | This function transfers a single frame
 *   to or from a video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *      The channel must be of type VIDEO_IN or VIDEO_OUT.
 *
 * @parm LPVIDEOHDR | lpVHdr | Specifies a far pointer to an <t VIDEOHDR>
 *      structure.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_PARAM1 | The <p lpVDHdr> parameter is invalid or
 *       the <e VIDEOHDR.dwBufferLength> member of the <t VIDEOHDR>
 *       structure is not set to the proper value.
 *
 * @comm Use this function with a VIDEO_IN channel to transfer a single
 *      image from the frame buffer.
 *      Use this function with a VIDEO_OUT channel to transfer a single
 *      image to the frame buffer.
 *
 * @xref <f videoOpen>
/****************************************************************************/
DWORD WINAPI videoFrame (HVIDEO hVideo, LPVIDEOHDR lpVHdr)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (!lpVHdr)
        return DV_ERR_PARAM1;

    if (IsBadWritePtr (lpVHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    return (DWORD) videoMessage(hVideo, DVM_FRAME, (DWORD_PTR) lpVHdr,
                        sizeof(VIDEOHDR));
}

/**************************************************************************
* @doc INTERNAL VIDEO
*
* @api void | videoCleanup | clean up video stuff
*   called in MSVIDEOs WEP()
*
**************************************************************************/
void FAR PASCAL videoCleanup(HTASK hTask)
{
}

//
//  Assist with unicode conversions
//

int Iwcstombs(LPSTR lpstr, LPCWSTR lpwstr, int len)
{
    return WideCharToMultiByte(GetACP(), 0, lpwstr, -1, lpstr, len, NULL, NULL);
}

int Imbstowcs(LPWSTR lpwstr, LPCSTR lpstr, int len)
{
    return MultiByteToWideChar(GetACP(),
                               MB_PRECOMPOSED,
                               lpstr,
                               -1,
                               lpwstr,
                               len);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\avicmprs.h ===
/*	-	-	-	-	-	-	-	-	*/

/*
**	Copyright (C) Microsoft Corporation 1993  - 1995. All rights reserved.
*/

/*	-	-	-	-	-	-	-	-	*/

#define	CAVICmpStreamImpl	CS	// Can't handle long exported names

/* Remove warning of using object during initialization. */
#pragma warning(disable:4355)

/*	-	-	-	-	-	-	-	-	*/

#define	implement	struct
#define	implementations	private

/*
** _StdClassImplementations
** Defines the standard implementations for a class object.
*/

#define	_StdClassImplementations(Impl)	\
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppv);	\
	STDMETHODIMP_(ULONG) AddRef();	\
	STDMETHODIMP_(ULONG) Release()

#ifdef __cplusplus
class FAR CAVICmpStream {
public:
    static HRESULT Create(IUnknown FAR* pUnknownOuter, REFIID riid, LPVOID FAR* ppv);
    CAVICmpStream(IUnknown FAR* pUnknownOuter, IUnknown FAR* FAR* ppUnknown);
    HRESULT SetUpCompression();
private:
implementations:
    implement CUnknownImpl : IUnknown {
    public:
	_StdClassImplementations(CUnknownImpl);
	CUnknownImpl(CAVICmpStream FAR* pAVIStream);
    private:
	CAVICmpStream FAR*	m_pAVIStream;
	ULONG	m_refs;
    };
    implement CAVICmpStreamImpl : IAVIStream {
    public:
	_StdClassImplementations(CAVICmpStreamImpl);
	CAVICmpStreamImpl(CAVICmpStream FAR* pAVIStream);
	~CAVICmpStreamImpl();
	STDMETHODIMP Create      (THIS_ LPARAM lParam1, LPARAM lParam2);
	STDMETHODIMP Info        (THIS_ AVISTREAMINFOW FAR * psi, LONG lSize);
	STDMETHODIMP_(LONG)  FindSample (THIS_ LONG lPos, LONG lFlags);
	STDMETHODIMP ReadFormat  (THIS_ LONG lPos,
				LPVOID lpFormat, LONG FAR *cbFormat);
	STDMETHODIMP SetFormat   (THIS_ LONG lPos,
				LPVOID lpFormat, LONG cbFormat);
	STDMETHODIMP Read        (THIS_ LONG lStart, LONG lSamples,
				LPVOID lpBuffer, LONG cbBuffer,
				LONG FAR * plBytes, LONG FAR * plSamples);
	STDMETHODIMP Write       (THIS_ LONG lStart, LONG lSamples,
				  LPVOID lpBuffer, LONG cbBuffer,
				  DWORD dwFlags,
				  LONG FAR *plSampWritten,
				  LONG FAR *plBytesWritten);
	STDMETHODIMP Delete      (THIS_ LONG lStart, LONG lSamples);
	STDMETHODIMP ReadData    (THIS_ DWORD fcc, LPVOID lp, LONG FAR *lpcb);
	STDMETHODIMP WriteData   (THIS_ DWORD fcc, LPVOID lp, LONG cb);
#ifdef _WIN32
	STDMETHODIMP SetInfo(AVISTREAMINFOW FAR *lpInfo, LONG cbInfo);
#else
	STDMETHODIMP Reserved1            (THIS);
	STDMETHODIMP Reserved2            (THIS);
	STDMETHODIMP Reserved3            (THIS);
	STDMETHODIMP Reserved4            (THIS);
	STDMETHODIMP Reserved5            (THIS);
#endif
    private:
	void ReadPalette(LONG lPos, LONG lPal, LPRGBQUAD prgb);
	// private functions here?
	CAVICmpStream FAR*	m_pAVIStream;
    };
public:
    CUnknownImpl	m_Unknown;
    CAVICmpStreamImpl	m_AVIStream;
    LONG ICCrunch(LPBITMAPINFOHEADER lpbi, LPVOID lp);
    void ResetInst(void);

public:
    IUnknown FAR*	m_pUnknownOuter;

    // AVIStream Instance data
    AVISTREAMINFOW     avistream;      // stream info
    PAVISTREAM		pavi;
    PGETFRAME		pgf;
    LONG		lFrameCurrent;
    HIC			hic;
    LPBITMAPINFOHEADER	lpbiC;
    LPVOID		lpC;
    LPBITMAPINFOHEADER	lpbiU;
    LPVOID		lpU;
    LPBITMAPINFOHEADER	lpFormat;
    LONG		cbFormat;
    LPBITMAPINFOHEADER	lpFormatOrig;
    LONG		cbFormatOrig;
    DWORD		dwKeyFrameEvery;
    DWORD		fccIC;
    DWORD		dwICFlags;
    LPVOID		lpHandler;
    LONG		cbHandler;
    DWORD		dwMaxSize;

    DWORD		dwQualityLast;
    LONG		lLastKeyFrame;
    DWORD		dwSaved;
    DWORD		m_ckid;
    DWORD		m_dwFlags;
};
#endif

DEFINE_AVIGUID(CLSID_AVICmprsStream,           0x00020001, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\avicmprs.cpp ===
/****************************************************************************
 *
 *  AVICMPRS.C
 *
 *  routine for compressing AVI files...
 *
 *      AVISave()
 *
 *  Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/


//
// What this file does:
//
// Given an AVI Stream (that is, essentially, a function that it can call
// to get video frames), this presents the same sort of interface and allows
// other people to call it to get compressed frames.
//

#include <win32.h>
#include <vfw.h>
#include "avifilei.h"
#include "avicmprs.h"
#include "debug.h"

#ifndef _WIN32
#define AVIStreamInfoW AVIStreamInfo
#endif

#define ALIGNULONG(i)     ((i+3)&(~3))                  /* ULONG aligned ! */
#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) (int)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)
#define DIBPTR(lpbi) ((LPBYTE)(lpbi) + \
	    (int)(lpbi)->biSize + \
	    (int)(lpbi)->biClrUsed * sizeof(RGBQUAD) )

void CAVICmpStream::ResetInst(void)
{
    lFrameCurrent = -1;
    lLastKeyFrame = 0;
    dwQualityLast = ICQUALITY_HIGH;
    dwSaved = 0;
}

/*      -       -       -       -       -       -       -       -       */

HRESULT CAVICmpStream::Create(
	IUnknown FAR*   pUnknownOuter,
	const IID FAR&  riid,
	void FAR* FAR*  ppv)
{
	IUnknown FAR*   pUnknown;
	CAVICmpStream FAR*      pAVIStream;
	HRESULT hresult;

	pAVIStream = new FAR CAVICmpStream(pUnknownOuter, &pUnknown);
	if (!pAVIStream)
		return ResultFromScode(E_OUTOFMEMORY);
	hresult = pUnknown->QueryInterface(riid, ppv);
	if (FAILED(GetScode(hresult)))
		delete pAVIStream;
	return hresult;
}

/*      -       -       -       -       -       -       -       -       */

CAVICmpStream::CAVICmpStream(
	IUnknown FAR*   pUnknownOuter,
	IUnknown FAR* FAR*      ppUnknown) :
	m_Unknown(this),
	m_AVIStream(this)
{
	// clear extra junk...
	pavi = 0;
	pgf = 0;
	hic = 0;
	lpbiC = 0;
	lpbiU = 0;
	lpFormat = 0;
	cbFormat = 0;
	lpFormatOrig = 0;
	cbFormatOrig = 0;
	lpHandler = 0;
	cbHandler = 0;
	
	if (pUnknownOuter)
		m_pUnknownOuter = pUnknownOuter;
	else
		m_pUnknownOuter = &m_Unknown;
	*ppUnknown = &m_Unknown;
}

/*      -       -       -       -       -       -       -       -       */

CAVICmpStream::CUnknownImpl::CUnknownImpl(
	CAVICmpStream FAR*      pAVIStream)
{
	m_pAVIStream = pAVIStream;
	m_refs = 0;
}

/*      -       -       -       -       -       -       -       -       */

STDMETHODIMP CAVICmpStream::CUnknownImpl::QueryInterface(
	const IID FAR&  iid,
	void FAR* FAR*  ppv)
{
	if (iid == IID_IUnknown)
		*ppv = &m_pAVIStream->m_Unknown;
	else if (iid == IID_IAVIStream)
		*ppv = &m_pAVIStream->m_AVIStream;
	else {
		*ppv = NULL;
		return ResultFromScode(E_NOINTERFACE);
	}
	AddRef();
	return AVIERR_OK;
}

/*      -       -       -       -       -       -       -       -       */

STDMETHODIMP_(ULONG) CAVICmpStream::CUnknownImpl::AddRef()
{
	uUseCount++;
	return ++m_refs;
}

/*      -       -       -       -       -       -       -       -       */

CAVICmpStream::CAVICmpStreamImpl::CAVICmpStreamImpl(
	CAVICmpStream FAR*      pAVIStream)
{
	m_pAVIStream = pAVIStream;
}

/*      -       -       -       -       -       -       -       -       */

CAVICmpStream::CAVICmpStreamImpl::~CAVICmpStreamImpl()
{
}

/*      -       -       -       -       -       -       -       -       */

STDMETHODIMP CAVICmpStream::CAVICmpStreamImpl::QueryInterface(
	const IID FAR&  iid,
	void FAR* FAR*  ppv)
{
	return m_pAVIStream->m_pUnknownOuter->QueryInterface(iid, ppv);
}

/*      -       -       -       -       -       -       -       -       */

STDMETHODIMP_(ULONG) CAVICmpStream::CAVICmpStreamImpl::AddRef()
{
	return m_pAVIStream->m_pUnknownOuter->AddRef();
}

/*      -       -       -       -       -       -       -       -       */

STDMETHODIMP_(ULONG) CAVICmpStream::CAVICmpStreamImpl::Release()
{
	return m_pAVIStream->m_pUnknownOuter->Release();
}

/*      -       -       -       -       -       -       -       -       */

HRESULT CAVICmpStream::SetUpCompression()
{
    LONG                lRet = AVIERR_OK;
    LPBITMAPINFOHEADER  lpbi;
    CAVICmpStream FAR * pinst = this;   // for convenience....
    LRESULT             dw;

    pinst->pgf = AVIStreamGetFrameOpen(pinst->pavi, NULL);
    if (!pinst->pgf) {
	// !!! we couldn't decompress the stream!
	lRet = AVIERR_INTERNAL;
	goto exit;
    }

    if (pinst->avistream.fccHandler == comptypeDIB)
	goto exit;

    lpbi = (LPBITMAPINFOHEADER) AVIStreamGetFrame(pinst->pgf, 0);

    if (lpbi == NULL) {
	lRet = AVIERR_INTERNAL;
	goto exit;
    }

    /*
    ** get the size required to hold the format.
    ** if the compressor fails return an error
    */
    dw = ICCompressGetFormatSize(pinst->hic, lpbi);
    if ((LONG) dw < (LONG)sizeof(BITMAPINFOHEADER))
	goto ic_error;

    pinst->cbFormat = (DWORD) dw;
    pinst->lpFormat = (LPBITMAPINFOHEADER) GlobalAllocPtr(GHND | GMEM_SHARE, pinst->cbFormat);
    if (!pinst->lpFormat) {
	lRet = AVIERR_MEMORY;
	goto exit;
    }

    /*
    ** get the compressed format from the compressor.
    */
    dw = ICCompressGetFormat(pinst->hic, lpbi, pinst->lpFormat);
    if ((LONG) dw < 0)
	goto ic_error;

    pinst->avistream.rcFrame.right = pinst->avistream.rcFrame.left +
					  (int) pinst->lpFormat->biWidth;
    pinst->avistream.rcFrame.bottom = pinst->avistream.rcFrame.top +
					  (int) pinst->lpFormat->biHeight;

    dw = ICCompressBegin(pinst->hic, lpbi, pinst->lpFormat);

    if (dw != ICERR_OK)
	goto ic_error;

    /*
    ** allocate buffer to hold compressed data.
    */
    dw = ICCompressGetSize(pinst->hic, lpbi, pinst->lpFormat);

    pinst->lpbiC = (LPBITMAPINFOHEADER)
	GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, pinst->cbFormat + dw);

    if (!pinst->lpbiC) {
	lRet = AVIERR_MEMORY;
	goto exit;
    }

    hmemcpy((LPVOID)pinst->lpbiC, pinst->lpFormat, pinst->cbFormat);

    pinst->lpC = (LPBYTE) pinst->lpbiC + pinst->lpbiC->biSize +
				pinst->lpbiC->biClrUsed * sizeof(RGBQUAD);
	
    //
    //  check for temporal compress, and allocate a previous
    //  DIB buffer if needed
    //
    if (pinst->dwKeyFrameEvery != 1 && !(dwICFlags & VIDCF_FASTTEMPORALC)) {
	pinst->lpbiU = (LPBITMAPINFOHEADER)
	    GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE,
		    sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));

	if (!pinst->lpbiU) {
	    lRet = AVIERR_MEMORY;
	    goto exit;
	}

	dw = ICDecompressGetFormat(pinst->hic, pinst->lpFormat, pinst->lpbiU);

	if ((LONG) dw < 0)
	    goto ic_error;

	if (pinst->lpbiU->biSizeImage == 0)
	    pinst->lpbiU->biSizeImage = pinst->lpbiU->biHeight *
					    DIBWIDTHBYTES(*pinst->lpbiU);

	pinst->lpbiU = (LPBITMAPINFOHEADER)
	    GlobalReAllocPtr(pinst->lpbiU,
		pinst->lpbiU->biSize +
			pinst->lpbiU->biClrUsed * sizeof(RGBQUAD) +
			pinst->lpbiU->biSizeImage,
		GMEM_MOVEABLE | GMEM_SHARE);

	if (!pinst->lpbiU) {
	    lRet = AVIERR_MEMORY;
	    goto exit;
	}

	pinst->lpU = (LPBYTE) pinst->lpbiU + pinst->lpbiU->biSize +
				pinst->lpbiU->biClrUsed * sizeof(RGBQUAD);
	
	dw = ICDecompressBegin(pinst->hic, pinst->lpFormat, pinst->lpbiU);

	if (dw != ICERR_OK)
	    goto ic_error;
    }

    // !!! We really should check if the new stream has palette changes....

exit:
    if (lRet != AVIERR_OK) {
	// Clean up before returning...
    }

    return ResultFromScode(lRet);

ic_error:
    if (dw == ICERR_BADFORMAT)
	lRet = AVIERR_BADFORMAT;
    else if (dw == ICERR_MEMORY)
	lRet = AVIERR_MEMORY;
    else
	lRet = AVIERR_INTERNAL;
    goto exit;
}

/*      -       -       -       -       -       -       -       -       */

STDMETHODIMP CAVICmpStream::CAVICmpStreamImpl::Create(LPARAM lParam1, LPARAM lParam2)
{
    CAVICmpStream FAR * pinst = m_pAVIStream;
    ICINFO          icinfo;
    AVICOMPRESSOPTIONS FAR *lpOpt = (AVICOMPRESSOPTIONS FAR *)lParam2;
    LONG            lRet = AVIERR_OK;

    // The AVI Stream that we're compressing is passsed in in the <szFile>
    // parameter.
    pinst->pavi = (PAVISTREAM)lParam1;

    // Make sure the uncompressed stream doesn't go away without our
    // knowledge....
    AVIStreamAddRef(pinst->pavi);
    // !!! how can we check if pinst->pavi is valid?

    // Get the stream header for future reference....
    AVIStreamInfoW(pinst->pavi, &pinst->avistream, sizeof(pinst->avistream));

    pinst->ResetInst();

    if (!lpOpt || (lpOpt->fccHandler == comptypeDIB)) {
	pinst->avistream.fccHandler = comptypeDIB;
	lRet = AVIERR_OK;
	goto exit;
    }

    pinst->avistream.fccHandler = lpOpt->fccHandler;

    // Open the compressor they asked for in the options structure...
    pinst->hic = ICOpen(ICTYPE_VIDEO, lpOpt->fccHandler, ICMODE_COMPRESS);

    if (!pinst->hic) {
	lRet = AVIERR_NOCOMPRESSOR;
	goto exit;
    }

    if (lpOpt->cbParms) {
	ICSetState(pinst->hic, lpOpt->lpParms, lpOpt->cbParms);
    }

    pinst->avistream.dwQuality = lpOpt->dwQuality;

    if (pinst->avistream.dwQuality == ICQUALITY_DEFAULT) {
	pinst->avistream.dwQuality = ICGetDefaultQuality(pinst->hic);
    }

    /*
    **  get info about this compressor
    */
    ICGetInfo(pinst->hic,&icinfo,sizeof(icinfo));

    pinst->dwICFlags = icinfo.dwFlags;

    if (lpOpt->dwFlags & AVICOMPRESSF_KEYFRAMES)
	pinst->dwKeyFrameEvery = lpOpt->dwKeyFrameEvery;
    else
	pinst->dwKeyFrameEvery = 1;

    if (!(icinfo.dwFlags & VIDCF_TEMPORAL))
	pinst->dwKeyFrameEvery = 1;     // compressor doesn't do temporal


    if (lpOpt->dwFlags & AVICOMPRESSF_DATARATE)
	pinst->dwMaxSize = muldiv32(lpOpt->dwBytesPerSecond,
				pinst->avistream.dwScale,
				pinst->avistream.dwRate);
    else
	pinst->dwMaxSize = 0;


    {
	ICCOMPRESSFRAMES    iccf;
	LRESULT               dw;


	iccf.lpbiOutput = pinst->lpbiC;
	iccf.lOutput = 0;

	iccf.lpbiInput = pinst->lpbiU;
	iccf.lInput = 0;

	iccf.lStartFrame = 0;
	iccf.lFrameCount = (LONG) pinst->avistream.dwLength;

	iccf.lQuality = (LONG) pinst->avistream.dwQuality;
	iccf.lDataRate = (LONG) lpOpt->dwBytesPerSecond;

	iccf.lKeyRate = (LONG) pinst->dwKeyFrameEvery;

	iccf.dwRate = pinst->avistream.dwRate;
	iccf.dwScale = pinst->avistream.dwScale;

	iccf.dwOverheadPerFrame = 0;
	iccf.dwReserved2 = 0;
	iccf.GetData = NULL;
	iccf.PutData = NULL;

	dw = ICSendMessage(pinst->hic,
		      ICM_COMPRESS_FRAMES_INFO,
		      (DWORD_PTR) (LPVOID) &iccf,
		      sizeof(iccf));

	// If they support this message, don't give
	// warning for data rate!
	if (dw == ICERR_OK) {
	    DPF("Compressor supports COMPRESSFRAMESINFO\n");
	    // !!! fDataRateChanged = TRUE;
	}

#ifdef STATUSCALLBACKS
	ICSetStatusProc(pinst->hic,
			0,
			pinst,
			CompressStatusProc);
#endif
    }


exit:
    if (lRet != AVIERR_OK) {
	// Clean up before returning...
    }

    return ResultFromScode(lRet);
}

STDMETHODIMP_(ULONG) CAVICmpStream::CUnknownImpl::Release()
{
    CAVICmpStream FAR * pinst = m_pAVIStream;

    uUseCount--;
    if (!--m_refs) {
	if (pinst->hic) {
	    ICCompressEnd(pinst->hic);

	    if (pinst->dwKeyFrameEvery != 1 && pinst->lpbiU)
		ICDecompressEnd(pinst->hic);

	    if (pinst->lpbiU)
		GlobalFreePtr((LPVOID) pinst->lpbiU);

	    if (pinst->lpbiC)
		GlobalFreePtr((LPVOID) pinst->lpbiC);

	    ICClose(pinst->hic);
	}

	if (pinst->pgf) {
	    AVIStreamGetFrameClose(pinst->pgf);
	    pinst->pgf = 0;
	}

	if (pinst->pavi) {
	    // Release our hold on the uncompressed stream....
	    AVIStreamClose(pinst->pavi);
	}

	if (pinst->lpFormat)
	    GlobalFreePtr(pinst->lpFormat);

	if (pinst->lpFormatOrig)
	    GlobalFreePtr(pinst->lpFormatOrig);

	delete pinst;
	return 0;
    }

    return m_refs;
}


STDMETHODIMP CAVICmpStream::CAVICmpStreamImpl::Info(AVISTREAMINFOW FAR * psi, LONG lSize)
{
    CAVICmpStream FAR * pinst = m_pAVIStream;

    hmemcpy(psi, &pinst->avistream, min(lSize, sizeof(pinst->avistream)));

//    return sizeof(pinst->avistream);
    return ResultFromScode(0);
}

STDMETHODIMP CAVICmpStream::CAVICmpStreamImpl::Read(
		      LONG       lStart,
		      LONG       lSamples,
		      LPVOID     lpBuffer,
		      LONG       cbBuffer,
		      LONG FAR * plBytes,
		      LONG FAR * plSamples)
{
    CAVICmpStream FAR * pinst = m_pAVIStream;
    LPBITMAPINFOHEADER  lpbi;
    LONG                lRet;

    if (!pinst->pgf) {
	HRESULT     hr;
	hr = pinst->SetUpCompression();

	if (hr != NOERROR)
	    return hr;
    }

    if (pinst->hic == 0) {
	lpbi = (LPBITMAPINFOHEADER) AVIStreamGetFrame(pinst->pgf, lStart);

	if (!lpbi)
	    return ResultFromScode(AVIERR_MEMORY);

	if (plBytes)
	    *plBytes = lpbi->biSizeImage;

	if (lpBuffer) {
	    if ((LONG) lpbi->biSizeImage > cbBuffer)
		return ResultFromScode(AVIERR_BUFFERTOOSMALL);
	
	    hmemcpy(lpBuffer, DIBPTR(lpbi), min((DWORD) cbBuffer, lpbi->biSizeImage));
	}

	if (plSamples)
	    *plSamples = 1;

	return AVIERR_OK;
    }

    if (lStart < pinst->lFrameCurrent)
	pinst->ResetInst();

    while (pinst->lFrameCurrent < lStart) {
	++pinst->lFrameCurrent;

	lpbi = (LPBITMAPINFOHEADER) AVIStreamGetFrame(pinst->pgf, pinst->lFrameCurrent);

	if (lpbi == NULL) {
	    pinst->ResetInst(); // Make sure we don't assume anything
	    return ResultFromScode(AVIERR_INTERNAL);
	}
	
	// !!! Check if format has changed!

	lRet = pinst->ICCrunch(lpbi, DIBPTR(lpbi));
	if (lRet != AVIERR_OK) {
	    pinst->ResetInst(); // Make sure we don't assume anything
	    return ResultFromScode(AVIERR_INTERNAL);    // !!! error < 0.
	}
    }

    if (plBytes)
	*plBytes = pinst->lpbiC->biSizeImage;

    if (lpBuffer) {
	if ((LONG) pinst->lpbiC->biSizeImage > cbBuffer)
	    return ResultFromScode(AVIERR_BUFFERTOOSMALL);
	
	hmemcpy(lpBuffer, pinst->lpC,
		min((DWORD) cbBuffer, pinst->lpbiC->biSizeImage));
    }

    if (plSamples)
	*plSamples = 1;

    return AVIERR_OK;
}

STDMETHODIMP_(LONG) CAVICmpStream::CAVICmpStreamImpl::FindSample(LONG lPos, LONG lFlags)
{
    CAVICmpStream FAR * pinst = m_pAVIStream;
    if (lFlags & FIND_KEY) {
	if (pinst->hic == 0)
	    return lPos;
	
	if (lFlags & FIND_PREV) {
	    /* If the frame they're asking about isn't the one we have,
	    ** we have to go actually do the work and find out.
	    */
	    if (lPos < pinst->lLastKeyFrame || lPos > pinst->lFrameCurrent)
		Read(lPos, 1, NULL, 0, NULL, NULL);

	    return pinst->lLastKeyFrame;
	} else {
	    return -1; // !!! Find Next KeyFrame
	}
    }
    if (lFlags & FIND_ANY) {
	return lPos;
    }
    if (lFlags & FIND_FORMAT) {
	// !!! This is wrong in the case where we're compressing something
	// with a palette change and the compressor preserves it....
	if (lFlags & FIND_PREV)
	    return 0;
	else
	    return -1;
    }

    return -1;

}

/////////////////////////////////////////////////////////////////////////////
//
//  ICCrunch()
//
//  crunch a frame and make it fit into the specifed size, by varing the
//  quality.  the suplied quality is the upper bound.
//
//  if the compressor can crunch, then let it crunch
//
//  if the compressor does quality, then vary the quality
//
//  if the compressor does not do quality, then the caller gets what
//  ever it will do.
//
//
//  The frame to be compressed is passed in in lpbi.
//
//  The compressed frame can be found in the lpC member variable....
//
/////////////////////////////////////////////////////////////////////////////

LONG CAVICmpStream::ICCrunch(LPBITMAPINFOHEADER lpbi, LPVOID lp)
{
    DWORD   dw;
    DWORD   dwFlags;
    DWORD   dwSize;
    DWORD   ckid;
    DWORD   dwQuality = avistream.dwQuality;
    DWORD   dwQualityMin;
    DWORD   dwQualityMax;
    DWORD   dwMaxSizeThisFrame;
    DWORD   dwSizeMin;
    DWORD   dwSizeMax;
    BOOL    fKeyFrame=FALSE;
    BOOL    fFastTemporal = (dwICFlags & VIDCF_FASTTEMPORALC) != 0;
    BOOL    fCrunch;            /* are we crunching? */
    BOOL    fFirst=TRUE;

    dwMaxSizeThisFrame = dwMaxSize;

    if (lFrameCurrent == 0 || (dwKeyFrameEvery != 0 &&
	    lFrameCurrent - lLastKeyFrame >= (long)dwKeyFrameEvery)) {
	fKeyFrame = TRUE;
    }

    //
    //  give the key frames more space, and take some away from the
    //  non key frames.
    //
    //  give the key frame two shares, assuming we have more frames to
    //  go around.
    //
    if (dwKeyFrameEvery > 0) {
	if (lFrameCurrent == 0) {
	    dwMaxSizeThisFrame = 0xffffff;
	} else if (fKeyFrame) {
	    dwMaxSizeThisFrame = dwMaxSizeThisFrame + dwSaved;
	    dwSaved = 0;
	} else {
	    DWORD       dwTakeAway;

	    dwTakeAway = dwMaxSizeThisFrame / dwKeyFrameEvery;
	    if (dwSaved > dwMaxSizeThisFrame)
		dwTakeAway = 0;
	
	    dwMaxSizeThisFrame -= dwTakeAway;
	    dwSaved += dwTakeAway;

	    /* Try to give a little extra space to each frame */
	    dwMaxSizeThisFrame += dwSaved / dwKeyFrameEvery;
	    dwSaved -= dwSaved / dwKeyFrameEvery;
	}
    } else {
	// the only key frame is frame zero
	if (lFrameCurrent == 0)
	    dwMaxSizeThisFrame = 0xffffff;
	else {
	    /* Give each frame whatever extra there is.... */
	    dwMaxSizeThisFrame += dwSaved;
	    dwSaved = 0;
	}
    }

    //
    //  if the device supports crunching or does not do quality we dont
    //  crunch.
    //
    fCrunch = dwMaxSizeThisFrame > 0 && !(dwICFlags & VIDCF_CRUNCH) &&
	 (dwICFlags & VIDCF_QUALITY);

////if (lFrameCurrent > 0 && fCrunch)
////    dwQuality = dwQualityLast;

    DPF("ICCrunch: Frame %ld, Quality = %ld, MaxSize = %ld\n", lFrameCurrent, avistream.dwQuality, dwMaxSizeThisFrame);

    dwQualityMin = 0;
    dwQualityMax = dwQuality;

    dwSizeMin = 0;
    dwSizeMax = dwMaxSizeThisFrame;

    for (;;) {
	ckid = 0L;

	// This is NOT how we tell the compressor to make a keyframe, but
	// somebody might think it is, so this is just to avoid the possibility
	// of breaking an old compressor.  Probably not necessary.
	// 
	dwFlags = fKeyFrame ? AVIIF_KEYFRAME : 0;

	//
	//  compress the frame
	//
	dw = ICCompress(hic,
		// THIS is how we tell the compressor to make a keyframe
		fKeyFrame ? ICCOMPRESS_KEYFRAME : 0,	// flags
		lpbiC,          // output format
		lpC,            // output data
		lpbi,           // format of frame to compress
		lp,             // frame data to compress
		&ckid,          // ckid for data in AVI file
		&dwFlags,       // flags in the AVI index.
		lFrameCurrent,  // frame number of seq.
		dwMaxSizeThisFrame,     // reqested size in bytes. (if non zero)
		dwQuality,      // quality value
		fKeyFrame | fFastTemporal ? NULL : lpbiU,
		fKeyFrame | fFastTemporal ? NULL : lpU);

	if (dw != ICERR_OK)
	    break;

	dwSize = lpbiC->biSizeImage;

	DPF("                     Quality = %ld, Size = %ld, %c\n", dwQuality, dwSize, (dwFlags & AVIIF_KEYFRAME) ? 'K' : ' ');

	//
	// if the device can't crunch (does not do it it self, or does not do
	// quality) then we are done.
	//
	if (!fCrunch)
	    break;

	//
	//  we are crunching, see if the frame fit.
	//
	if (dwSize <= dwMaxSizeThisFrame) {
	    dwQualityMin = dwQuality;
	    dwSizeMin = dwSize;

	    //
	    //  when the quality gets too close bail out.
	    //
	    if (dwQualityMax - dwQualityMin <= 10)
		break;

	    //
	    //  if we get within 512 bytes it is good enough
	    //
	    if ((LONG) (dwMaxSizeThisFrame - dwSize) <= (LONG) min(512L, dwMaxSizeThisFrame / 8L))
		break;

	    //
	    // if the first try, (with the user specifed quality) made it
	    // then use it.  otherwise we need to search.
	    //
	    if (fFirst)
		break;
	}
	else {
	    //
	    //  when the quality gets too close bail out.
	    //
	    if (dwQualityMax - dwQualityMin <= 1)
		break;

	    dwQualityMax = dwQuality;
	    dwSizeMax = dwSize;
	}

	if (fFirst && dwQuality != dwQualityLast)
	    dwQuality = dwQualityLast;
	else
	    dwQuality = (dwQualityMin + dwQualityMax) / 2;

#if 0
	    //
	    // make a guess based on how close we are now.
	    //
	    dwQuality = dwQualityMin + muldiv32(dwQualityMax-dwQualityMin,
			dwMaxSizeThisFrame-dwSizeMin,dwSizeMax-dwSizeMin);
#endif
	fFirst = FALSE;
    }

#if 0
    /* If this wasn't the first frame, save up any extra space for later */
    if (dwSize < dwMaxSizeThisFrame && lFrameCurrent > 0) {
	dwSaved += dwMaxSizeThisFrame - dwSize;

	// HACK: limit this, so it doesn't get too big!!!
	if (dwSaved > 32768L)
	    dwSaved = 32768L;
	if (dwSaved > dwMaxSizeThisFrame * 5)
	    dwSaved = dwMaxSizeThisFrame * 5;
    }
#endif

    if (dw != ICERR_OK) {
	if (dw == ICERR_BADFORMAT)
	    return AVIERR_BADFORMAT;
	else
	    return AVIERR_INTERNAL;
    }

    if (dwFlags & AVIIF_KEYFRAME) {
	lLastKeyFrame = lFrameCurrent;
    }

    //
    // remember the quality that worked, it will be the best guess next time.
    //
    dwQualityLast = dwQuality;

    //
    //  decompress the image into the offscreen buffer, for use next time.
    //
    if (dwKeyFrameEvery != 1 && lpbiU && !fFastTemporal) {
	dw = ICDecompress(hic, 0,
	    lpbiC,lpC,
	    lpbiU,lpU);

	// !!! error check?
    }

    //
    // return the dwFlags and ckid, by stuffing them in the stream info.
    //
    m_ckid = ckid;
    m_dwFlags = dwFlags;

    return AVIERR_OK;
}

/**************************************************************************
* @doc  INTERNAL DRAWDIB
*
* @api BOOL | DibEq | This function compares two dibs.
*
* @parm LPBITMAPINFOHEADER lpbi1 | Pointer to one bitmap.
*       this DIB is assumed to have the colors after the BITMAPINFOHEADER
*
* @parm LPBITMAPINFOHEADER | lpbi2 | Pointer to second bitmap.
*       this DIB is assumed to have the colors after biSize bytes.
*
* @rdesc Returns TRUE if bitmaps are identical, FALSE otherwise.
*
**************************************************************************/
static inline BOOL DibEq(LPBITMAPINFOHEADER lpbi1, LPBITMAPINFOHEADER lpbi2)
{
    return
	lpbi1->biCompression == lpbi2->biCompression   &&
	lpbi1->biSize        == lpbi2->biSize          &&
	lpbi1->biWidth       == lpbi2->biWidth         &&
	lpbi1->biHeight      == lpbi2->biHeight        &&
	lpbi1->biBitCount    == lpbi2->biBitCount;
}

STDMETHODIMP CAVICmpStream::CAVICmpStreamImpl::SetFormat(LONG lPos,LPVOID lpFormat,LONG cbFormat)
{
    CAVICmpStream FAR * pinst = m_pAVIStream;

    LONG                lRet = AVIERR_OK;
    HRESULT             hr;
    LPBITMAPINFOHEADER  lpbi = (LPBITMAPINFOHEADER) lpFormat;
    LRESULT             dw;

    if (pinst->pgf)
	return ResultFromScode(AVIERR_UNSUPPORTED);
	
    if (lpbi->biCompression != BI_RGB)
	return ResultFromScode(AVIERR_UNSUPPORTED);

    if (pinst->avistream.fccHandler == 0)
	pinst->avistream.fccHandler = comptypeDIB;

    if (pinst->lpFormatOrig) {
	if ((cbFormat = pinst->cbFormatOrig) &&
	    (_fmemcmp(pinst->lpFormatOrig, lpFormat, (int) cbFormat) == 0))
	    return AVIERR_OK;

	DPF("AVICmprs: SetFormat when format already set!\n");
    }

    //
    // Can only currently set the palette at the end of the file
    //
    if (lPos < (LONG) (pinst->avistream.dwStart + pinst->avistream.dwLength))
	return ResultFromScode(AVIERR_UNSUPPORTED);

    if (pinst->avistream.fccHandler == comptypeDIB) {
	return AVIStreamSetFormat(pinst->pavi, lPos,
				  lpFormat, cbFormat);
    }

    if (pinst->lpFormatOrig) {
	//
	// We can only change the palette for things with palettes....
	//
	if (lpbi->biBitCount > 8 || lpbi->biClrUsed == 0)
	    return ResultFromScode(AVIERR_UNSUPPORTED);

	//
	// Be sure only the palette is changing, nothing else....
	//
	if (cbFormat != pinst->cbFormatOrig)
	    return ResultFromScode(AVIERR_UNSUPPORTED);

	if (!DibEq((LPBITMAPINFOHEADER) lpFormat,
		   (LPBITMAPINFOHEADER) pinst->lpFormatOrig))
	    return ResultFromScode(AVIERR_UNSUPPORTED);

	dw = ICCompressGetFormat(pinst->hic, lpFormat, pinst->lpFormat);
	if ((LONG) dw < 0)
	    goto ic_error;

	ICCompressEnd(pinst->hic);
	dw = ICCompressBegin(pinst->hic, lpFormat, pinst->lpFormat);

	if (dw != ICERR_OK)
	    goto ic_error;

	
	if (pinst->dwKeyFrameEvery != 1 && pinst->lpbiU &&
    				!(pinst->dwICFlags & VIDCF_FASTTEMPORALC)) {
	    ICDecompressEnd(pinst->hic);

	    dw = ICDecompressGetFormat(pinst->hic, pinst->lpFormat, pinst->lpbiU);

	    if ((LONG) dw < 0)
		goto ic_error;

	    dw = ICDecompressBegin(pinst->hic, pinst->lpFormat, pinst->lpbiU);

	    if (dw != ICERR_OK)
		goto ic_error;
	}

	goto setformatandexit;
    }


    pinst->lpFormatOrig = (LPBITMAPINFOHEADER)
	GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, cbFormat);
    pinst->cbFormatOrig = cbFormat;

    if (!pinst->lpFormatOrig) {
	lRet = AVIERR_MEMORY;
	goto exit;
    }

    hmemcpy(pinst->lpFormatOrig, lpFormat, cbFormat);

    /*
    ** get the size required to hold the format.
    ** if the compressor fails return an error
    */
    dw = ICCompressGetFormatSize(pinst->hic, lpFormat);
    if ((LONG) dw < (LONG)sizeof(BITMAPINFOHEADER))
	goto ic_error;

    pinst->cbFormat = (DWORD) dw;
    pinst->lpFormat = (LPBITMAPINFOHEADER) GlobalAllocPtr(GHND | GMEM_SHARE, pinst->cbFormat);
    if (!pinst->lpFormat) {
	lRet = AVIERR_MEMORY;
	goto exit;
    }

    /*
    ** get the compressed format from the compressor.
    */
    dw = ICCompressGetFormat(pinst->hic, lpFormat, pinst->lpFormat);
    if ((LONG) dw < 0)
	goto ic_error;

    pinst->avistream.rcFrame.right = pinst->avistream.rcFrame.left +
					  (int) pinst->lpFormat->biWidth;
    pinst->avistream.rcFrame.bottom = pinst->avistream.rcFrame.top +
					  (int) pinst->lpFormat->biHeight;

    dw = ICCompressBegin(pinst->hic, lpFormat, pinst->lpFormat);

    if (dw != ICERR_OK)
	goto ic_error;

    /*
    ** allocate buffer to hold compressed data.
    */
    dw = ICCompressGetSize(pinst->hic, lpFormat, pinst->lpFormat);

    pinst->lpbiC = (LPBITMAPINFOHEADER)
	GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, pinst->cbFormat + dw);

    if (!pinst->lpbiC) {
	lRet = AVIERR_MEMORY;
	goto exit;
    }

    hmemcpy((LPVOID)pinst->lpbiC, pinst->lpFormat, pinst->cbFormat);

    pinst->lpC = (LPBYTE) pinst->lpbiC + pinst->lpbiC->biSize +
				pinst->lpbiC->biClrUsed * sizeof(RGBQUAD);
	
    //
    //  check for temporal compress, and allocate a previous
    //  DIB buffer if needed
    //
    if (pinst->dwKeyFrameEvery != 1 &&
				!(pinst->dwICFlags & VIDCF_FASTTEMPORALC)) {
	pinst->lpbiU = (LPBITMAPINFOHEADER)
	    GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE,
		    sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));

	if (!pinst->lpbiU) {
	    lRet = AVIERR_MEMORY;
	    goto exit;
	}

	dw = ICDecompressGetFormat(pinst->hic, pinst->lpFormat, pinst->lpbiU);

	if ((LONG) dw < 0)
	    goto ic_error;

	if (pinst->lpbiU->biSizeImage == 0)
	    pinst->lpbiU->biSizeImage = pinst->lpbiU->biHeight *
					    DIBWIDTHBYTES(*pinst->lpbiU);

	pinst->lpbiU = (LPBITMAPINFOHEADER)
	    GlobalReAllocPtr(pinst->lpbiU,
		pinst->lpbiU->biSize +
			pinst->lpbiU->biClrUsed * sizeof(RGBQUAD) +
			pinst->lpbiU->biSizeImage,
		GMEM_MOVEABLE | GMEM_SHARE);

	if (!pinst->lpbiU) {
	    lRet = AVIERR_MEMORY;
	    goto exit;
	}

	pinst->lpU = (LPBYTE) pinst->lpbiU + pinst->lpbiU->biSize +
				pinst->lpbiU->biClrUsed * sizeof(RGBQUAD);
	
	dw = ICDecompressBegin(pinst->hic, pinst->lpFormat, pinst->lpbiU);

	if (dw != ICERR_OK)
	    goto ic_error;
    }

setformatandexit:
    hr = AVIStreamSetFormat(pinst->pavi, lPos,
			    pinst->lpFormat, pinst->cbFormat);

    if (hr != NOERROR)
	return hr;

exit:
    if (lRet != AVIERR_OK) {
	// Clean up before returning...
    }

    return ResultFromScode(lRet);

ic_error:
    if (dw == ICERR_BADFORMAT)
	lRet = AVIERR_BADFORMAT;
    else if (dw == ICERR_MEMORY)
	lRet = AVIERR_MEMORY;
    else
	lRet = AVIERR_INTERNAL;
    goto exit;
}

STDMETHODIMP CAVICmpStream::CAVICmpStreamImpl::Write(LONG lStart,
						     LONG lSamples,
						     LPVOID lpBuffer,
						     LONG cbBuffer,
						     DWORD dwFlags,
						     LONG FAR *plSampWritten,
						     LONG FAR *plBytesWritten)
{
    CAVICmpStream FAR * pinst = m_pAVIStream;

    LONG                lRet;

    if (pinst->pgf)
	return ResultFromScode(AVIERR_UNSUPPORTED);
	
    if (lStart < (LONG) (pinst->avistream.dwStart + pinst->avistream.dwLength))
	return ResultFromScode(AVIERR_UNSUPPORTED);

    if (lSamples > 1)
	return ResultFromScode(AVIERR_UNSUPPORTED);

    pinst->lFrameCurrent = lStart;

    if (pinst->avistream.fccHandler == comptypeDIB) {
	// !!! Check here that the frame is the right size....
	dwFlags |= AVIIF_KEYFRAME;
    } else {
	lRet = pinst->ICCrunch(pinst->lpFormatOrig, lpBuffer);
	if (lRet != AVIERR_OK)
	    return ResultFromScode(lRet);
	lpBuffer = pinst->lpC;
	cbBuffer = pinst->lpbiC->biSizeImage;
	dwFlags = pinst->lLastKeyFrame == lStart ? AVIIF_KEYFRAME : 0;
    }

    return AVIStreamWrite(pinst->pavi,
			  lStart,
			  lSamples,
			  lpBuffer,
			  cbBuffer,
			  dwFlags,
			  plSampWritten,
			  plBytesWritten);
}

STDMETHODIMP CAVICmpStream::CAVICmpStreamImpl::Delete(LONG lStart,LONG lSamples)
{
    CAVICmpStream FAR * pinst = m_pAVIStream;

    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVICmpStream::CAVICmpStreamImpl::ReadData(DWORD fcc, LPVOID lp, LONG FAR *lpcb)
{
    CAVICmpStream FAR * pinst = m_pAVIStream;

    // Don't pass through 'strd' data!
    if (fcc == ckidSTREAMHANDLERDATA) {
	if (pinst->cbHandler) {
	    hmemcpy(lp, pinst->lpHandler, min(*lpcb, pinst->cbHandler));
	}
	*lpcb = pinst->cbHandler;
	return AVIERR_OK;
    }

    return AVIStreamReadData(pinst->pavi, fcc, lp, lpcb);
}

STDMETHODIMP CAVICmpStream::CAVICmpStreamImpl::WriteData(DWORD fcc, LPVOID lp, LONG cb)
{
    CAVICmpStream FAR * pinst = m_pAVIStream;

    return ResultFromScode(AVIERR_UNSUPPORTED);
}

#if 0
STDMETHODIMP CAVICmpStream::CAVICmpStreamImpl::Clone(PAVISTREAM FAR * ppaviNew)
{
    CAVICmpStream FAR * pinst = m_pAVIStream;

    return ResultFromScode(AVIERR_UNSUPPORTED);
}

#endif


#ifdef _WIN32
STDMETHODIMP CAVICmpStream::CAVICmpStreamImpl::SetInfo(AVISTREAMINFOW FAR *lpInfo, LONG cbInfo)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

#else
STDMETHODIMP CAVICmpStream::CAVICmpStreamImpl::Reserved1(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVICmpStream::CAVICmpStreamImpl::Reserved2(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVICmpStream::CAVICmpStreamImpl::Reserved3(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVICmpStream::CAVICmpStreamImpl::Reserved4(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVICmpStream::CAVICmpStreamImpl::Reserved5(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}
#endif
/*      -       -       -       -       -       -       -       -       */

#ifndef _WIN32
static void C816InternalCompilerError(CAVICmpStream FAR * pinst, LPBITMAPINFOHEADER lpbi, LPVOID lpFormat, LONG cbFormat)
{
    if (pinst->hic == 0) {
	pinst->cbFormat = lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);

	if (lpFormat)
	    hmemcpy(lpFormat, lpbi, min(cbFormat, (LONG) pinst->cbFormat));
    } else {
	if (lpFormat) {
	    hmemcpy(lpFormat, pinst->lpFormat, min(cbFormat, (LONG) pinst->cbFormat));

	    if (pinst->lpFormat->biClrUsed > 0) {
		// Make sure we have the right colors!
		// !!! This is bad--We may need to restart the compressor...
		hmemcpy((LPBYTE) lpFormat + pinst->lpFormat->biSize,
			(LPBYTE) lpbi + lpbi->biSize,
			pinst->lpFormat->biClrUsed * sizeof(RGBQUAD));
	    }
	}
    }
}
#endif

STDMETHODIMP CAVICmpStream::CAVICmpStreamImpl::ReadFormat(LONG lPos, LPVOID lpFormat, LONG FAR *lpcbFormat)
{
    CAVICmpStream FAR * pinst = m_pAVIStream;

    LPBITMAPINFOHEADER  lpbi;

    if (!pinst->pgf) {
	HRESULT     hr;
	hr = pinst->SetUpCompression();

	if (hr != NOERROR)
	    return hr;
    }

    lpbi = (LPBITMAPINFOHEADER) AVIStreamGetFrame(pinst->pgf, lPos);

    if (!lpbi)
	return ResultFromScode(AVIERR_MEMORY);
#ifdef _WIN32
    if (pinst->hic == 0) {
	pinst->cbFormat = lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);

	if (lpFormat)
	    hmemcpy(lpFormat, lpbi, min(*lpcbFormat, (LONG) pinst->cbFormat));
    } else {
	if (lpFormat) {
	    hmemcpy(lpFormat, pinst->lpFormat, min(*lpcbFormat, (LONG) pinst->cbFormat));

	    // Fix: Ensure we don't write more than *lpcbFormat bytes by ensuring biSize is smaller
	    // than *lpcbFormat, and only copying at most *lpcbFormat - pinst->lpFormat->biSize bytes.
            // The "signed" and "unsigned" casts are all correct - they avoid compiler errors.
	    if (pinst->lpFormat->biClrUsed > 0 && signed(pinst->lpFormat->biSize) >= 0 && signed(pinst->lpFormat->biSize) < *lpcbFormat) {
		// Make sure we have the right colors!
		// !!! This is bad--We may need to restart the compressor...
		hmemcpy((LPBYTE) lpFormat + pinst->lpFormat->biSize,
			(LPBYTE) lpbi + lpbi->biSize,
			min(unsigned(*lpcbFormat) - pinst->lpFormat->biSize,pinst->lpFormat->biClrUsed * sizeof(RGBQUAD)));
	    }
	}
    }
#else
    ::C816InternalCompilerError(pinst, lpbi, lpFormat, *lpcbFormat);
#endif
    *lpcbFormat = pinst->cbFormat;
    return AVIERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\avifile.cpp ===
/****************************************************************************
 *
 *  AVIFILE.C
 *
 *  routines for reading Standard AVI files
 *
 *  Copyright (c) 1992  - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>
#include <ole2.h>
#include <vfw.h>
#include "avifilei.h"
#include "avifile.rc"
#include <checkbmi.h>

#include "debug.h"

#if !defined NUMELMS
 #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

#ifdef _WIN32
// We need a structure to read in the AVIStreamHeader from persistent
// storage.  This structure contains a RECT element, which in 16 bit land
// contains 4 16-bit values.  Hence when 16 bit AVIFILE.DLL writes the
// file out, it uses a RECT composed of 4 16-bit values.  On WIN32 we have
// to map this "short rect" to a WIN32 RECT of 4 32-bit elements.  In order
// that 16 bit code can continue to read/write files interchangeably with
// 32 bit code we map the two structures on read/write.

// The AVIStreamHeader structure exists on disk.  Hence the RECT struct
// is the same size for all systems, i.e. SHORT, 16 bit values.  The code
// that reads/writes files, and returns INFO will map these 16 bit values
// to the 32 bit RECT structure as appropriate.
typedef struct tagSRECT {
    SHORT    left;
    SHORT    top;
    SHORT    right;
    SHORT    bottom;
} SRECT;

typedef struct {
    FOURCC              fccType;
    FOURCC              fccHandler;
    DWORD               dwFlags;        /* Contains AVITF_* flags */
    WORD                wPriority;
    WORD                wLanguage;
    DWORD               dwInitialFrames;
    DWORD               dwScale;
    DWORD               dwRate; /* dwRate / dwScale == samples/second */
    DWORD               dwStart;
    DWORD               dwLength; /* In units above... */

    // new....
    DWORD               dwSuggestedBufferSize;
    DWORD               dwQuality;
    DWORD               dwSampleSize;
    SRECT               rcFrame;    /* does each frame need this? */

    /* additional type-specific data goes in StreamInfo chunk */

    /* For video: position within rectangle... */
    /* For audio: volume?  stereo channel? */
} AVIStreamHeaderShort;
#else
// Map one name to the other for 16 bit code...
#define AVIStreamHeaderShort AVIStreamHeader
#endif


#if defined _WIN32 && !defined UNICODE
//
// This is Win 95 code.  Explicit unicode stuff is needed.
//

int LoadUnicodeString(HINSTANCE hinst, UINT wID, LPWSTR lpBuffer, int cchBuffer)
{
    char    ach[256];
    int     i;

    i = LoadString(hinst, wID, ach, NUMELMS(ach));

    if (i > 0)
        MultiByteToWideChar(CP_ACP, 0, ach, -1, lpBuffer, cchBuffer);

    return i;
}

#define lstrlenW    lstrlenUnicode

int
WINAPI
lstrlenUnicode(
    LPCWSTR lpString
    )
{
    int count = 0;

    while (*lpString++)
        count++;

    return count;
}


#else
#define LoadUnicodeString   LoadString
#endif

extern "C" {
LPSTR FAR lstrzcpyA (LPSTR pszTarget, LPCSTR pszSource, size_t cchMax)
{
        lstrcpynA (pszTarget, pszSource, cchMax -1);
        pszTarget[ cchMax -1 ] = TEXT('\0');
        return pszTarget;
}


LPWSTR FAR lstrzcpyW (LPWSTR pszTarget, LPCWSTR pszSource, size_t cchMax)
{
        lstrcpynW (pszTarget, pszSource, cchMax -1);
        pszTarget[ cchMax -1 ] = TEXT('\0');
        return pszTarget;
}


LPTSTR FAR lstrzcpy (LPTSTR pszTarget, LPCTSTR pszSource, size_t cchMax)
{
        lstrcpyn (pszTarget, pszSource, cchMax -1);
        pszTarget[ cchMax -1 ] = TEXT('\0');
        return pszTarget;
}


LPWSTR FAR lstrzcpyAtoW (LPWSTR pszTarget, LPCSTR pszSourceA, size_t cchMax)
{
        LPWSTR pszSourceW;

        pszSourceW = (LPWSTR)GlobalAllocPtr(GMEM_MOVEABLE,sizeof(WCHAR)*cchMax);
        if (pszSourceW != NULL) {
            mbstowcs(pszSourceW, pszSourceA, cchMax);
            lstrcpynW (pszTarget, pszSourceW, cchMax -1);
            pszTarget[ cchMax -1 ] = TEXT('\0');
            GlobalFreePtr(pszSourceW);
        }
        return pszTarget;
}


LPSTR FAR lstrzcpyWtoA (LPSTR pszTarget, LPCWSTR pszSourceW, size_t cchMax)
{
        LPSTR pszSourceA;

        pszSourceA = (LPSTR)GlobalAllocPtr (GMEM_MOVEABLE, cchMax);
        if (pszSourceA != NULL) {
            wcstombs(pszSourceA, pszSourceW, cchMax);
            lstrcpynA (pszTarget, pszSourceA, cchMax -1);
            pszTarget[ cchMax -1 ] = TEXT('\0');
            GlobalFreePtr(pszSourceA);
        }
        return pszTarget;
}
} // extern "C"




extern "C" STDAPI CalculateFileDataRate(PAVIFILE pf, LONG FAR *plMaxBytesPerSec);

//#undef StreamFromFOURCC
//#define StreamFromFOURCC(fcc) (UINT)(HIBYTE(LOWORD(fcc)) - (BYTE)'0')

BOOL AddToIndex(CAVIFile FAR * pfile, DWORD ckid, DWORD cksize, LONG off, DWORD dwFlags);

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

EXTERN_C void DecodeRle(LPBITMAPINFOHEADER lpbi, BYTE _huge *pb, BYTE _huge *prle, DWORD dwInSize);
EXTERN_C HINSTANCE ghMod;

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

#define comptypeNONE            mmioFOURCC('N','O','N','E')
#define comptypeRLE0            mmioFOURCC('R','L','E','0')
#define comptypeRLE             mmioFOURCC('R','L','E',' ')

#define WIDTHBYTES(i)       ((UINT)((i+31)&(~31))/8)
#define DIBWIDTHBYTES(lpbi) (UINT)WIDTHBYTES((UINT)(lpbi)->biWidth * (UINT)(lpbi)->biBitCount)

LONG    lBufferSize = 0;
int     nBuffers = 0;

#define ckidSTREAMNAME         mmioFOURCC('s', 't', 'r', 'n')

/***************************************************************************
 ***************************************************************************/


/***************************************************************************
 ***************************************************************************/

EXTERN_C LONG FAR PASCAL shfileReadProc(HANDLE hsf, LONG lSeek, LONG lRead, LPVOID lpBuffer)
{
    if (shfileSeek((HSHFILE)hsf, lSeek, SEEK_SET) == -1)
        return -1;

    if (shfileRead((HSHFILE)hsf, (HPSTR)lpBuffer, lRead) != lRead)
        return -1;

    return lRead;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

#define INDEX_WRITE_SIZE    32l*1024
#define INDEX_READ_SIZE     32l*1024

static BOOL WriteOutIndex(CAVIFile FAR *pfile, DWORD dwOffsetMovie)
{
    MMCKINFO ck;
    PAVIINDEXENTRY pIndex;
    LONG cnt = INDEX_WRITE_SIZE / sizeof(*pIndex);
    LONG l;
    BOOL f=FALSE;
#ifdef DEBUG
    DWORD time;
#endif

    /*
    ** Now write index out!
    */
    ck.ckid = ckidAVINEWINDEX;
    ck.cksize = sizeof(AVIINDEXENTRY) * pfile->px->nIndex;

    if (shfileCreateChunk(pfile->hshfile, &ck, 0))
        return FALSE;

    DPF("Writing Index", time=timeGetTime());

    pIndex = (PAVIINDEXENTRY)GlobalAllocPtr(GHND,INDEX_WRITE_SIZE);

    if (pIndex) {

        for (l=0; l < pfile->px->nIndex; ) {

            cnt = IndexGetFileIndex(pfile->px, l, cnt, pIndex, -(LONG)dwOffsetMovie);
            if (cnt == 0)
                break;

            //l = cnt * sizeof(AVIINDEXENTRY);
            if (shfileWrite(pfile->hshfile, (HPSTR)pIndex,
                        cnt * sizeof(AVIINDEXENTRY))
                != cnt * (LONG)sizeof(AVIINDEXENTRY))
                 goto exit;

            l += cnt;

            DPF("!.");
        }

        DPF("!Done (%ldms)\n", timeGetTime()-time);

        if (!shfileAscend(pfile->hshfile, &ck, 0))
            f = TRUE;

      exit:
        GlobalFreePtr(pIndex);
    }

    return f;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

static BOOL ReadInIndex(CAVIFile FAR *pfile, DWORD size, DWORD dwOffsetMovie, BOOL fRle)
{
    PAVIINDEXENTRY pIndex;
    LONG cnt;
    LONG lIndexAdjust;
    BOOL f = FALSE;
#ifdef DEBUG
    DWORD time;
#endif

    pIndex = (PAVIINDEXENTRY)GlobalAllocPtr(GHND,INDEX_READ_SIZE);

    if (pIndex == NULL)
        goto exit;

    pfile->px = IndexCreate();

    if (pfile->px == 0)
        goto exit;

    DPF("Reading index.", time = timeGetTime());

    if (pfile->avihdr.dwFlags & AVIF_MUSTUSEINDEX)
        lIndexAdjust = dwOffsetMovie;
    else
        lIndexAdjust = -1;      // set when we read first index entry.

    while (size > 0) {

        cnt = min(INDEX_READ_SIZE, size);

        if (shfileRead(pfile->hshfile,(HPSTR)pIndex,cnt) != cnt)
            goto exit;

        size -= cnt;
        cnt /= sizeof(AVIINDEXENTRY);

        //
        // fix up the index
        //
        if (lIndexAdjust == -1) {
            lIndexAdjust = (LONG)(dwOffsetMovie + sizeof(DWORD)) -
                (LONG)pIndex->dwChunkOffset;
        }

        pfile->px = IndexAddFileIndex(pfile->px, pIndex, cnt, lIndexAdjust, fRle);

        if (pfile->px == NULL)
            goto exit;

        DPF("!.");
    }

    DPF("!Done (%ldms)\n", timeGetTime() - time);

    f = TRUE;

exit:
    if (pIndex)
        GlobalFreePtr(pIndex);

    return f;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

HRESULT SaveChanges(CAVIFile FAR * pfile, BOOL fRelease)
{
    CAVIStream FAR *            pavi;
    int                         stream;
    MMCKINFO                    ck;
    MMCKINFO                    ckRIFF;
    MMCKINFO                    ckLIST;
    MMCKINFO                    ckStream;
    LONG                        lCur;
    HRESULT                     hr = AVIERR_OK;
    AVIStreamHeaderShort        strhdr;

    // Clean up interleaving
    if (pfile->fInRecord) {
        if (pfile->px->nIndex > pfile->lRecordIndex + 1) {
            AVIFileEndRecord((PAVIFILE) pfile);
        }

        // back out of last record....
        --pfile->px->nIndex;
        pfile->lWriteLoc -= 3 * sizeof(DWORD);
        shfileSeek(pfile->hshfile, pfile->lWriteLoc, SEEK_SET);
        pfile->fInRecord = FALSE;
    }

    // Go back and write out the header

    lCur = shfileSeek(pfile->hshfile, 0, SEEK_CUR);
    shfileSeek(pfile->hshfile, 0, SEEK_SET);

    /* Create RIFF chunk */
    ckRIFF.cksize = 0;
    ckRIFF.fccType = formtypeAVI;
    if (shfileCreateChunk(pfile->hshfile, &ckRIFF, MMIO_CREATERIFF)) {
        goto FileError;
    }

    /* Create header list */
    ckLIST.cksize = 0;
    ckLIST.fccType = listtypeAVIHEADER;
    if (shfileCreateChunk(pfile->hshfile, &ckLIST, MMIO_CREATELIST)) {
        goto FileError;
    }

    /* Create AVI header chunk */
    ck.cksize = sizeof(pfile->avihdr);
    ck.ckid = ckidAVIMAINHDR;
    if (shfileCreateChunk(pfile->hshfile, &ck, 0)) {
        goto FileError;
    }

    CalculateFileDataRate(&pfile->m_AVIFile, (LONG FAR *) &pfile->avihdr.dwMaxBytesPerSec);

    // !!! CalculateFileDataRate may have seeked us to the wrong place....
    shfileSeek(pfile->hshfile, ck.dwDataOffset, SEEK_SET);

    /* Write AVI header info */
    if (shfileWrite(pfile->hshfile,
                  (HPSTR)&pfile->avihdr,
                  sizeof(pfile->avihdr)) != sizeof(pfile->avihdr)) {
        goto FileError;
    }

    if (shfileAscend(pfile->hshfile, &ck, 0)) {
        goto FileError;
    }


#if 0
    for (l = 0;
         l < muldiv32(pfile->avihdr.dwTotalFrames,
                             pfile->avihdr.dwMicroSecPerFrame,
                             1000000L);
         l++) {

             for (stream = 0; stream < (int) pfile->avihdr.dwStreams; stream++) {
             }
    }
#endif

    for (stream = 0; stream < (int) pfile->avihdr.dwStreams; stream++) {
        pavi = pfile->ps[stream];

        /* Create stream header list */
        ckStream.cksize = 0;
        ckStream.fccType = listtypeSTREAMHEADER;
        if (shfileCreateChunk(pfile->hshfile,&ckStream,MMIO_CREATELIST)) {
            goto FileError;
        }

        ck.ckid = ckidSTREAMHEADER;
        if (shfileCreateChunk(pfile->hshfile, &ck, 0)) {
            goto FileError;
        }


        // Make an AVIStreamHeader from the AVISTREAMINFO
        strhdr.fccType =                pavi->avistream.fccType;
        strhdr.fccHandler =             pavi->avistream.fccHandler;
        strhdr.dwFlags =                pavi->avistream.dwFlags;
        strhdr.wPriority =              pavi->avistream.wPriority;
        strhdr.wLanguage =              pavi->avistream.wLanguage;
        strhdr.dwRate =                 pavi->avistream.dwRate;
        strhdr.dwScale =                pavi->avistream.dwScale;
        strhdr.dwStart =                pavi->avistream.dwStart;
        strhdr.dwLength =               pavi->avistream.dwLength;
        strhdr.dwSuggestedBufferSize =  pavi->avistream.dwSuggestedBufferSize;
        strhdr.dwQuality =              pavi->avistream.dwQuality;
        strhdr.dwSampleSize =           pavi->avistream.dwSampleSize;

#ifdef _WIN32
        // Write out the Short rectangle format
        strhdr.rcFrame.left   =         (SHORT)pavi->avistream.rcFrame.left   ;
        strhdr.rcFrame.right  =         (SHORT)pavi->avistream.rcFrame.right  ;
        strhdr.rcFrame.top    =         (SHORT)pavi->avistream.rcFrame.top    ;
        strhdr.rcFrame.bottom =         (SHORT)pavi->avistream.rcFrame.bottom ;
#else
        strhdr.rcFrame =                pavi->avistream.rcFrame;
#endif

        strhdr.dwInitialFrames =        pavi->avistream.dwInitialFrames;

        if (shfileWrite(pfile->hshfile, (HPSTR) &strhdr, sizeof(strhdr)) !=
                                                            sizeof(strhdr)) {
            goto FileError;
        }

        if (shfileAscend(pfile->hshfile, &ck, 0)) {
            goto FileError;
        }


        ck.cksize = pavi->cbFormat;
        ck.ckid = ckidSTREAMFORMAT;

        if (shfileCreateChunk(pfile->hshfile, &ck, 0))
            goto FileError;

        if (shfileWrite(pfile->hshfile, (HPSTR) pavi->lpFormat, ck.cksize) !=
                        (LONG) ck.cksize)
            goto FileError;

        if (shfileAscend(pfile->hshfile, &ck, 0))
            goto FileError;

        if (pavi->avistream.szName[0]) {
            long sz = lstrlenW(pavi->avistream.szName)+1;
            ck.cksize = sz;
            ck.ckid = ckidSTREAMNAME;

            if (shfileCreateChunk(pfile->hshfile, &ck, 0))
                goto FileError;

#ifdef _WIN32
            // the file format expects ANSI names!
            LPSTR  pA = (LPSTR) GlobalAllocPtr(GPTR, sz);
            if (pA == 0) {
                DPF(("memory allocation failed for Unicode conversion"));
                goto FileError;
            }
            WideCharToMultiByte(CP_ACP, 0, pavi->avistream.szName, -1,
                        pA, sz, NULL, NULL);

            sz = shfileWrite(pfile->hshfile, (HPSTR) pA, ck.cksize);

            GlobalFreePtr(pA);

            if (sz != (LONG) ck.cksize)
                goto FileError;
#else
            if (shfileWrite(pfile->hshfile, (HPSTR) pavi->avistream.szName, ck.cksize) !=
                            (LONG) ck.cksize)
                goto FileError;
#endif

            if (shfileAscend(pfile->hshfile, &ck, 0))
                goto FileError;
        }

        if (pavi->extra.cb) {
            DPF2("Writing %ld bytes of extra stream data.\n", pavi->extra.cb);
            if (shfileWrite(pfile->hshfile, (HPSTR) pavi->extra.lp, pavi->extra.cb) !=
                        (LONG) pavi->extra.cb)
                goto FileError;
        }

        /* Ascend out of stream's header */
        if (shfileAscend(pfile->hshfile, &ckStream, 0)) {
            goto FileError;
        }
    }

    /* ascend from the Header list */
    if (shfileAscend(pfile->hshfile, &ckLIST, 0)) {
        goto FileError;
    }

    lCur = shfileSeek(pfile->hshfile, 0, SEEK_CUR);

    DPF("Data list start = %ld, current pos = %ld\n", pfile->lDataListStart, lCur);

    if (lCur + 8 > pfile->lDataListStart) {
        // !!! Ack: we didn't leave enough space for the header.
        // !!! How can we avoid this?
        DPF("Header was too big!  Failing!\n");
        goto FileError;
    }

    /* Pad this header out so that the real data will start on a 2K
    ** boundary by writing a JUNK chunk.
    */
    ck.ckid = ckidAVIPADDING;
    ck.cksize = pfile->lDataListStart - lCur - 8;
    if (shfileCreateChunk(pfile->hshfile,&ck,0)) {
        goto FileError;
    }

    shfileZero(pfile->hshfile, pfile->lDataListStart - lCur - 8);

    if (shfileAscend(pfile->hshfile, &ck, 0)) {
        goto FileError;
    }

    /* Start the 'movi' list, where all of the actual data will be. */
    ckLIST.cksize = pfile->lWriteLoc - pfile->lDataListStart - 8;
    ckLIST.fccType = listtypeAVIMOVIE;
    if (shfileCreateChunk(pfile->hshfile, &ckLIST, MMIO_CREATELIST)) {
        goto FileError;
    }

    shfileSeek(pfile->hshfile, pfile->lWriteLoc, SEEK_SET);

    if (shfileAscend(pfile->hshfile, &ckLIST, 0))
        goto FileError;

    if (!WriteOutIndex(pfile, ckLIST.dwDataOffset))
        goto FileError;

    //
    // Write out any extra data around
    //
    if (pfile->extra.cb) {
        DPF2("Writing %ld bytes of extra file data.\n", pfile->extra.cb);

        if (shfileWrite(pfile->hshfile,
                      (HPSTR) pfile->extra.lp,
                      pfile->extra.cb) !=
                 (LONG) pfile->extra.cb)
            goto FileError;
    }

FinishUp:
    if (shfileAscend(pfile->hshfile, &ckRIFF, 0)) {
        hr = ResultFromScode(AVIERR_FILEWRITE);
    }


    //
    // Always flush to be sure that the data really made it to the disk....
    //
    if (shfileFlush(pfile->hshfile, 0)) {
        hr = ResultFromScode(AVIERR_FILEWRITE);
    }

    return hr;

FileError:
    DPF("SaveChanges returning Error! This error will be ignored!\n");
    hr = ResultFromScode(AVIERR_FILEWRITE);
    goto FinishUp;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CAVIFile::CUnknownImpl::Release()
{
    CAVIFile FAR * pfile = m_pAVIFile;
    CAVIStream FAR * pavi;
    int iStream;
    CLock tlock(pfile);

    DPF2("File   %p: Usage--=%lx\n", (DWORD_PTR) (LPVOID) this, m_refs - 1);

    uUseCount--;
    if (!--m_refs) {

        if (pfile->fDirty) {
            ++m_refs;
            SaveChanges(pfile, TRUE);
            --m_refs;

            // Unfortunately, it's too late to tell about any errors....
        }

        for (iStream = 0; iStream < (int)pfile->avihdr.dwStreams; iStream++) {
            pavi = pfile->ps[iStream];

            if (!pavi)
                continue;

            delete pavi;
        }

        if (pfile->hshfile) {
            shfileRelease(pfile->hshfile);
            shfileClose(pfile->hshfile, 0);
        }

        if (pfile->px)
            FreeIndex(pfile->px);

        if (pfile->extra.lp) {
            DPF2("Freeing %ld bytes of extra file data.\n", pfile->extra.cb);
            GlobalFreePtr(pfile->extra.lp);
        }

        if (pfile->pb)
            EndBuffered(pfile->pb);

        pfile->hshfile = NULL;

        pfile->px = NULL;

        // done with critsec now - no-one else has any refs to it
        tlock.Exit();
#ifdef _WIN32
        DeleteCriticalSection(&pfile->m_critsec);
#endif
        delete pfile;
        return 0;
    } else {
        if (pfile->hshfile)
            shfileRelease(pfile->hshfile);
    }

    return m_refs;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

#ifndef _WIN32
STDMETHODIMP CAVIFile::CAVIFileImpl::Save(
                                   LPCTSTR szFile,
                                   AVICOMPRESSOPTIONS FAR *lpOptions,
                                   AVISAVECALLBACK lpfnCallback)
{
    CAVIFile FAR * pfile = m_pAVIFile;
    HRESULT hr = ResultFromScode(AVIERR_OK);

    CLock tlock(pfile);

    if (pfile->fDirty) {
        hr = SaveChanges(pfile, FALSE);
    }

    return hr;
}

#endif
#define SLASH(c)     ((c) == TEXT('/') || (c) == TEXT('\\'))

/*--------------------------------------------------------------+
| FileName  - return a pointer to the filename part of szPath   |
|             with no preceding path.                           |
+--------------------------------------------------------------*/
LPTSTR FAR FileName(LPCTSTR lszPath)
{
    LPCTSTR   lszCur;
#ifdef _WIN32
    // We really should be using GetFileTitle API as this will provide
    // better validation on the input name.
#endif

    for (lszCur = lszPath + lstrlen(lszPath); lszCur > lszPath && !SLASH(*lszCur) && *lszCur != ':';) {
#ifdef _WIN32
        lszCur = CharPrev(lszPath, lszCur);
#else
        lszCur = AnsiPrev(lszPath, lszCur);
#endif
    }
    if (lszCur == lszPath)
        return (LPTSTR)lszCur;
    else
        return (LPTSTR)(lszCur + 1);
}

// We do not currently use the last defined parameter for IsRectBogus
// Use a macro to remove it.  (It can be quickly restored.)
#define ISRECTBOGUS(lprc, dwW, dwH, lpbi) IsRectBogus(lprc, dwW, dwH)

INLINE BOOL IsRectBogus(LPRECT lprc, DWORD dwFrameWidth, DWORD dwFrameHeight)
                 // unused LPBITMAPINFOHEADER lpbi)
{
    if (IsRectEmpty(lprc))
        return TRUE;

    if (lprc->right - lprc->left > (int) dwFrameWidth)
        return TRUE;

    if (lprc->bottom - lprc->top > (int) dwFrameHeight)
        return TRUE;

    // !!!! Check that rectangle matches lpbi?

    // We've run out of things to check, so it's OK....
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::OpenInternal(DWORD mode)
{
    CAVIFile FAR * pfile = this;
    CAVIStream FAR *        pavi;
    MMCKINFO        ck;
    MMCKINFO        ckRIFF;
    MMCKINFO        ckLIST;
    MMCKINFO        ckStream;
    DWORD           dwSize;
    BOOL            fRle=FALSE;
    LONG            l;
    int             iStream;
    int             i;
    HRESULT         hr = ResultFromScode(AVIERR_OK);
    IUnknown FAR *  pUnk;
    AVIStreamHeaderShort strhdr;
    TCHAR            ach[20];
    TCHAR            ach2[20];
    int             iStreamNumber;
#ifdef DEBUG
    DWORD time;
#endif

    CLock tlock(pfile);


    if (!pfile->hshfile) {
        hr = ResultFromScode(AVIERR_FILEOPEN);
        goto error;
    }

    if (mode & OF_CREATE) {
        // make a empty index.
        pfile->px = IndexCreate();

        if (pfile->px == 0)
            goto memerror;

        pfile->lWriteLoc = 0;
        pfile->lHeaderSize = sizeof(MainAVIHeader) + 11 * sizeof(DWORD);

#ifndef AVIF_TRUSTCKTYPE
#define AVIF_TRUSTCKTYPE        0x00000800      // Use CKType to find key frames?
#endif

        pfile->avihdr.dwFlags = AVIF_HASINDEX | AVIF_TRUSTCKTYPE;
    } else {

        /* Read RIFF chunk */
        if (shfileDescend(pfile->hshfile, &ckRIFF, NULL, 0) != 0)
            goto readerror;

        /*
         * check for a 'QuickTime AVI' file, a QuickTime AVI file is a
         * QuickTime public movie with a AVI file in the 'mdat' atom.
         */
        if (ckRIFF.cksize == mmioFOURCC('m','d','a','t'))
        {
            /*
             * now the 'mdat' atom better be a RIFF/AVI or we cant handle it.
             */
            if (shfileDescend(pfile->hshfile, &ckRIFF, NULL, 0) != 0)
                goto formaterror;
        }

        if (ckRIFF.ckid != FOURCC_RIFF)
            goto formaterror;

        if (ckRIFF.fccType != formtypeAVI)
            goto formaterror;

        /* Read header list */
        ckLIST.fccType = listtypeAVIHEADER;
        if (FindChunkAndKeepExtras(&pfile->extra, pfile->hshfile, &ckLIST, &ckRIFF, MMIO_FINDLIST))
            goto error;

        pfile->lHeaderSize = ckLIST.cksize + 8 * sizeof(DWORD);

        /* Read AVI header chunk */
        ck.ckid = ckidAVIMAINHDR;
        if (FindChunkAndKeepExtras(&pfile->extra, pfile->hshfile, &ck, &ckLIST, MMIO_FINDCHUNK))
            goto error;

        dwSize = min(ck.cksize, sizeof(MainAVIHeader));

        /* Read AVI header info */
        if (shfileRead(pfile->hshfile, (HPSTR)&pfile->avihdr, dwSize) != (LONG)dwSize)
            goto readerror;

        if (shfileAscend(pfile->hshfile, &ck, 0))
            goto readerror;

        /*  Check there aren't more streams than we can handle */
        if (pfile->avihdr.dwStreams > MAXSTREAMS) {
            /*  Make sure we don't crash deleteing non-existent streams */
            pfile->avihdr.dwStreams = 0;
            goto error;
        }

        for (iStream = 0; iStream < (int)pfile->avihdr.dwStreams; iStream++) {
            pfile->ps[iStream] = NULL;
        }

        /* Allocate stream data stuff, read streams */
        for (iStream = 0; iStream < (int)pfile->avihdr.dwStreams; ) {

            if (shfileDescend(pfile->hshfile, &ckStream, &ckLIST, 0) != 0)
                goto readerror;

            //
            //  found a non-stream header skip
            //
            if (ckStream.fccType != listtypeSTREAMHEADER ||
                    ckStream.ckid != FOURCC_LIST) {
                if ((hr = ReadIntoExtra(&pfile->extra,
                                  pfile->hshfile,
                                  &ckStream)) != ResultFromScode(AVIERR_OK))
                    goto error;

                if (shfileAscend(pfile->hshfile, &ckStream, 0) != 0)
                    goto readerror;

                continue;
            }

            pfile->ps[iStream] = new FAR CAVIStream(NULL, &pUnk);
            if (!pfile->ps[iStream])
                goto memerror;

            pavi = pfile->ps[iStream];
            pavi->pfile = pfile;
            pavi->iStream = iStream;

            //
            //  walk every chunk in this stream header, until we are done.
            //
            while (shfileDescend(pfile->hshfile, &ck, &ckStream, 0) == 0) {
                switch (ck.ckid) {
                    case ckidSTREAMHEADER:
                        //
                        // set these to sane default's incase the file
                        // header is not big enough
                        //
                        // NOTE the stream rectangle is set to NULL, if
                        // this is a video stream it will be corrected
                        // when we process the format.
                        //
                        strhdr.dwQuality = (DWORD) ICQUALITY_DEFAULT;

#ifdef _WIN32
                        // Set the 16 bit rectangle values to 0
                        strhdr.rcFrame.left =
                        strhdr.rcFrame.right=
                        strhdr.rcFrame.top  =
                        strhdr.rcFrame.bottom = 0;
#else
                        SetRectEmpty(&strhdr.rcFrame);
#endif

                        l = min(ck.cksize, sizeof(strhdr));

                        if (shfileRead(pfile->hshfile, (HPSTR)&strhdr, l) != l)
                            goto readerror;

                        // Copy fields from strhdr into StreamInfo
                        pavi->avistream.fccType =       strhdr.fccType;
                        pavi->avistream.fccHandler =    strhdr.fccHandler;
                        pavi->avistream.dwFlags =       strhdr.dwFlags; //!!!
                        pavi->avistream.dwCaps =        0; // !!!
                        pavi->avistream.wPriority =     strhdr.wPriority;
                        pavi->avistream.wLanguage =     strhdr.wLanguage;
                        pavi->avistream.dwRate =        strhdr.dwRate;
                        pavi->avistream.dwScale =       strhdr.dwScale;
                        pavi->avistream.dwStart =       strhdr.dwStart;
                        pavi->avistream.dwLength =      strhdr.dwLength;
                        pavi->avistream.dwSuggestedBufferSize = strhdr.dwSuggestedBufferSize;
                        pavi->avistream.dwInitialFrames = strhdr.dwInitialFrames;
                        pavi->avistream.dwQuality =     strhdr.dwQuality;
                        pavi->avistream.dwSampleSize =  strhdr.dwSampleSize;

#ifdef _WIN32
                        // Copy the 16 bit rectangle we have read from
                        // persistent storage into a WIN32 RECT (32 bit)
                        // structure.  There is no operator= defined for
                        // this "short rect" to RECT assignment.
                        pavi->avistream.rcFrame.left  = strhdr.rcFrame.left;
                        pavi->avistream.rcFrame.top   = strhdr.rcFrame.top;
                        pavi->avistream.rcFrame.right = strhdr.rcFrame.right;
                        pavi->avistream.rcFrame.bottom= strhdr.rcFrame.bottom;
#else
                        pavi->avistream.rcFrame = strhdr.rcFrame;
#endif

                        pavi->avistream.dwEditCount =   0;
                        pavi->avistream.dwFormatChangeCount =   0;

                        // Make up a stream name out of the filename, stream
                        // type, and stream number.
                        if (pavi->avistream.fccType == streamtypeVIDEO)
                            LoadString(ghMod, IDS_VIDEO, ach, NUMELMS(ach));
                        else if (pavi->avistream.fccType == streamtypeAUDIO)
                            LoadString(ghMod, IDS_AUDIO, ach, NUMELMS(ach));
                        else
                            wsprintf(ach, TEXT("'%4.4hs'"),
                                (LPSTR)&(pavi->avistream.fccType));

                        // figure out what # stream of this type this is....
                        iStreamNumber = 1;
                        for (i = 0; i < iStream; i++) {
                            if (pfile->ps[i]->avistream.fccType ==
                                        pavi->avistream.fccType)
                                ++iStreamNumber;
                        }
                        LoadString(ghMod, IDS_SSSTREAMD, ach2, NUMELMS(ach2));

                        {
                           TCHAR achTemp[MAX_PATH];

                           wsprintf(achTemp,
                               (LPTSTR)ach2,
                               (LPTSTR)FileName(pfile->achFile),
                               (LPTSTR)ach,
                               iStreamNumber);

#if defined _WIN32 && !defined UNICODE
                           lstrzcpyAtoW (pavi->avistream.szName,
                                         achTemp,
                                         NUMELMS (pavi->avistream.szName));
#else
                           lstrzcpy (pavi->avistream.szName,
                                     achTemp,
                                     NUMELMS (pavi->avistream.szName));
#endif
                        }
                        break;

                    case ckidSTREAMFORMAT:

                        if (pavi->lpFormat == NULL) {
                            pavi->cbFormat = ck.cksize;
                            pavi->lpFormat = GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE,
                                                            ck.cksize);

                            if (pavi->lpFormat == NULL)
                                goto memerror;

                            if (shfileRead(pfile->hshfile, (HPSTR) pavi->lpFormat, (LONG)ck.cksize) != (LONG)ck.cksize)
                                goto readerror;

                            #define lpbi ((LPBITMAPINFOHEADER)pavi->lpFormat)

                            if (pavi->avistream.fccType != streamtypeVIDEO)
                                break;

                            if (!ValidateBitmapInfoHeader(lpbi, ck.cksize)) {
                                break;
                            }
                            //
                            // make sure this is set
                            //
                            if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
                                lpbi->biClrUsed = (1 << (int)lpbi->biBitCount);

                            //
                            // fix up bogus stream rectangles.
                            //
                            if (ISRECTBOGUS(&pavi->avistream.rcFrame,
                                            pfile->avihdr.dwWidth,
                                            pfile->avihdr.dwHeight,
                                            lpbi)) {
                                SetRect(&pavi->avistream.rcFrame, 0, 0,
                                    (int)lpbi->biWidth, (int)lpbi->biHeight);
                            }

                            //
                            // make sure the biCompression is right for
                            // RLE files.
                            //
                            if (lpbi->biCompression == 0 && lpbi->biBitCount == 8) {
                                if (pavi->avistream.fccHandler == comptypeRLE0 ||
                                    pavi->avistream.fccHandler == comptypeRLE)
                                    lpbi->biCompression = BI_RLE8;
                            }

                            if (pavi->avistream.fccHandler == comptypeNONE &&
                                lpbi->biCompression == 0)
                                pavi->avistream.fccHandler = comptypeDIB;

                            if (pavi->avistream.fccHandler == 0 &&
                                lpbi->biCompression == 0)
                                pavi->avistream.fccHandler = comptypeDIB;

                            // Assuming a DIB handler has RGB data will blow up
                            // if it has RLE data, and VidEdit et. al write out
                            // confusing files like this.
                            //if (pavi->avistream.fccHandler == comptypeDIB)
                            //    lpbi->biCompression = BI_RGB;

                            if (lpbi->biCompression <= BI_RLE8)
                                fRle = TRUE;

                            #undef lpbi
                        }
                        break;

                    case ckidSTREAMHANDLERDATA:

                        if (pavi->lpData == NULL) {
                            pavi->cbData = ck.cksize;
                            pavi->lpData = GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE,
                                                          ck.cksize);

                            if (pavi->lpData == NULL)
                                goto memerror;

                            if (shfileRead(pfile->hshfile, (HPSTR)pavi->lpData,
                                         (LONG)ck.cksize) != (LONG)ck.cksize)
                                goto readerror;
                        }
                        break;

                    case ckidSTREAMNAME:
                    {
#ifdef _WIN32
                        char achTemp[MAX_PATH];

                        l = (LONG)min((LONG) ck.cksize, NUMELMS(achTemp));

                        if (shfileRead(pfile->hshfile, (LPSTR)achTemp, l) != l) {
                            goto readerror;
                        }

                        MultiByteToWideChar(CP_ACP, 0, achTemp, -1,
                                            pavi->avistream.szName,
                                            NUMELMS(pavi->avistream.szName));
#else
                        l = min((LONG) ck.cksize, NUMELMS(pavi->avistream.szName));

                        if (shfileRead(pfile->hshfile,
                                       (HPSTR)pavi->avistream.szName, l) != l)
                            goto readerror;
#endif
                    }
                        break;


                    case ckidAVIPADDING:
                    case mmioFOURCC('p','a','d','d'):
                        break;

                    default:
                        if ((hr = ReadIntoExtra(&pavi->extra,
                                          pfile->hshfile,
                                          &ck)) != ResultFromScode(AVIERR_OK))
                            goto error;

                        break;
                }

                if (shfileAscend(pfile->hshfile, &ck, 0) != 0)
                    goto readerror;
            }

            /* Ascend out of stream header */
            if (shfileAscend(pfile->hshfile, &ckStream, 0) != 0)
                goto readerror;

            if (pavi->avistream.fccType == 0)
                goto formaterror;

            if (pavi->lpFormat == NULL)
                goto formaterror;

            //
            // make sure the sample size is set right
            //
            switch(pavi->avistream.fccType) {
                case streamtypeAUDIO:
                    /* Hack for backward compatibility with audio */
                    pavi->avistream.dwSampleSize =
                        ((LPWAVEFORMAT)pavi->lpFormat)->nBlockAlign;

                    // For audio, this number isn't useful when reading.
                    // !!!pavi->avistream.dwInitialFrames = 0;
                    // !!! We should let people read what the header says....
                    break;

                case streamtypeVIDEO:
                    // !!! But what if the samples are all the right size?
                    pavi->avistream.dwSampleSize = 0;
                    break;

                default:
                    // !!! ??? pavi->avistream.dwInitialFrames = 0;
                    // !!! ??? pavi->avistream.dwSampleSize = 0;
                    break;
            }


            l = NUMELMS(pavi->avistream.szName) - 1;
            pavi->avistream.szName[l] = TEXT('\0');

            // next stream
            iStream++;
        }

        // Read extra data at end of header list....
        FindChunkAndKeepExtras(&pfile->extra, pfile->hshfile, &ck, &ckLIST, 0);

        if (shfileAscend(pfile->hshfile, &ckLIST, 0))
            goto readerror;

        /* Find big data chunk */
        ckLIST.fccType = listtypeAVIMOVIE;
        if (FindChunkAndKeepExtras(&pfile->extra, pfile->hshfile, &ckLIST, &ckRIFF, MMIO_FINDLIST))
            goto error;

        pfile->lDataListStart = ckLIST.dwDataOffset - 2 * sizeof(DWORD);

        if (shfileAscend(pfile->hshfile, &ckLIST, 0))
            goto readerror;

        // Keep track of where data can be written
        pfile->lWriteLoc = ckLIST.dwDataOffset + ckLIST.cksize;

        //
        // read in or create a index, we only want the index entries for the
        // stream we are interested in!
        //
        ck.ckid = ckidAVINEWINDEX;
        if (FindChunkAndKeepExtras(&pfile->extra, pfile->hshfile, &ck, &ckRIFF, MMIO_FINDCHUNK) == 0 && ck.cksize != 0) {

            if (!ReadInIndex(pfile, ck.cksize, ckLIST.dwDataOffset, fRle))
                goto formaterror;

        } else {
            /* Seek back to beginning of list, so we can scan */
            shfileSeek(pfile->hshfile, ckLIST.dwDataOffset + sizeof(DWORD), SEEK_SET);

            //!!! should we really scan big files, or give a error?

            pfile->px = IndexCreate();

            if (pfile->px == 0)
                goto formaterror;

            DPF("Scanning index", time = timeGetTime());

            /* Scan through chunks... */
            while (shfileDescend(pfile->hshfile, &ck, &ckLIST, 0) == 0) {

                AddToIndex(pfile,ck.ckid,ck.cksize,ck.dwDataOffset-8,0);

                /* Hack: don't ascend from LISTs */
                if (ck.ckid != FOURCC_LIST) {
                    if (shfileAscend(pfile->hshfile, &ck, 0) != 0)
                        goto readerror;
                }

                if (pfile->px->nIndex % 512 == 0) {
                    DPF("!.");
                }
            }

            DPF("!Done (%ldms)\n", timeGetTime() - time);
        }

        if (pfile->px->nIndex == 0)
            goto formaterror;

        // Read extra data at end of file....
        FindChunkAndKeepExtras(&pfile->extra, pfile->hshfile, &ck, &ckRIFF, 0);

        // shfileSetBuffer(pfile->hshfile, NULL, 0L, 0);

        //
        //  compute dwSuggestedBufferSize
        //
        if (pfile->avihdr.dwFlags & AVIF_ISINTERLEAVED) {

            LONG l;
            LONG lLen;

            pfile->avihdr.dwSuggestedBufferSize = 0;

            for (l=IndexFirst(pfile->px, STREAM_REC);
                 l != -1;
                 l = IndexNext(pfile->px, l, 0)) {

                lLen = IndexLength(pfile->px, l);

                if (pfile->avihdr.dwSuggestedBufferSize < (DWORD)lLen)
                    pfile->avihdr.dwSuggestedBufferSize = (DWORD)lLen;
            }
        }

#ifdef USE_DIRECTIO
        // don't use additional buffering if we're using direct io
        if (shfileIsDirect(pfile->hshfile)) {
            pfile->pb = NULL;
        } else
#endif
        {

            if ((pfile->avihdr.dwFlags & AVIF_ISINTERLEAVED) &&
                    pfile->avihdr.dwInitialFrames) {

            pfile->pb = InitBuffered((int) pfile->avihdr.dwInitialFrames * 2,
                                         pfile->avihdr.dwSuggestedBufferSize,
                                     pfile->hshfile,
                                         pfile->px);
            }
            else /* if (pfile->avihdr.dwSuggestedBufferSize > 0 &&
                     pfile->avihdr.dwSuggestedBufferSize < 32l*1024) */ {

                int  nBuffers = GetProfileIntA("avifile", "buffers", 5);

                pfile->pb = InitBuffered(nBuffers,
                                         min(pfile->avihdr.dwSuggestedBufferSize * 2, 32768L),
                                     pfile->hshfile,
                                         pfile->px);
            }
        }
    }

    return ResultFromScode(AVIERR_OK);

readerror:
    return ResultFromScode(AVIERR_FILEREAD);

memerror:
    return ResultFromScode(AVIERR_MEMORY);

formaterror:
    return ResultFromScode(AVIERR_BADFORMAT);

error:
    if (hr == ResultFromScode(AVIERR_OK))
        return ResultFromScode(AVIERR_ERROR);
    return hr;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

#ifndef _WIN32
STDMETHODIMP CAVIFile::CAVIFileImpl::Open(LPCTSTR szFile, UINT mode)
{
    CAVIFile FAR * pfile = m_pAVIFile;
    UINT            ui;

    CLock tlock(pfile);

    if (pfile->achFile[0])
        return ResultFromScode(-1);

    pfile->mode = mode;
    lstrcpy(pfile->achFile, szFile);

    // Assumptions about avilib.cpp:
    // We're assuming that if CREATE is set, WRITE is set too.
    // We're assuming that we'll always see READWRITE instead of just WRITE.

// If it ain't broke, don't fix it - who do I look like, the share flag
// standards enforcing committee?
#if 0
    // force the share flags to the 'correct' values
    if (mode & OF_READWRITE) {
        pfile->mode = (mode & ~(MMIO_SHAREMODE)) | OF_SHARE_EXCLUSIVE;
    } else {
        pfile->mode = (mode & ~(MMIO_SHAREMODE)) | OF_SHARE_DENY_WRITE;
    }
#endif

    // try to open the actual file
    // If the first attempt fails, no system error box, please.
    ui = SetErrorMode(SEM_NOOPENFILEERRORBOX);

    pfile->hshfile = shfileOpen(pfile->achFile, NULL, pfile->mode);

    if (!pfile->hshfile && ((mode & MMIO_RWMODE) == OF_READ)) {
        // if the open fails, try again without the share flags.
        pfile->mode &= ~(MMIO_SHAREMODE);

        pfile->hshfile = shfileOpen(pfile->achFile, NULL, pfile->mode);
    }

    if (pfile->hshfile)
        shfileAddRef(pfile->hshfile);  // compensate for later rel of IUnknown

    SetErrorMode(ui);

    return pfile->OpenInternal(mode);
}
#endif

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::GetStream(PAVISTREAM FAR *ppavi, DWORD fccType, LONG lParam)
{
    CAVIFile FAR * pfile = m_pAVIFile;

    CAVIStream FAR *pavi;
    int             iStreamCur;
    int             iStreamWant;
    int             iStream;
    LONG            lLength;

    // thread locking
    CLock tlock(pfile);

    *ppavi = NULL;

    iStreamWant = (int)lParam;

    if (iStreamWant < 0 || iStreamWant >= (int)pfile->avihdr.dwStreams)
        return ResultFromScode(AVIERR_NODATA);

    /* Allocate stream data stuff, read streams */
    for (iStreamCur = -1, iStream = 0;
            iStream < (int)pfile->avihdr.dwStreams;
            iStream++) {
        if (fccType == 0 || pfile->ps[iStream]->avistream.fccType == fccType)
            iStreamCur++;

        if (iStreamCur == iStreamWant)
            break;
    }

    if (iStreamCur != iStreamWant)
        return ResultFromScode(AVIERR_NODATA);

    pavi = pfile->ps[iStream];

    if (pavi->fInit)
        goto returnnow;

    pavi->fInit = TRUE;

#if 0
    if ((pf->mode & (OF_WRITE | OF_READWRITE)) == 0) {
        pavi->hshfile = shfileOpen(pfile->achFile, NULL, MMIO_ALLOCBUF | pfile->mode);

        if (!pavi->hshfile)
            goto error;
    } else
#endif
    pavi->hshfile = pfile->hshfile;

    pavi->lPal = -4242;

    pavi->psx = MakeStreamIndex(pfile->px, iStream,
        (LONG)pavi->avistream.dwStart - pavi->avistream.dwInitialFrames,
        (LONG)pavi->avistream.dwSampleSize,
        pfile->hshfile, shfileReadProc, NULL);

    if (pavi->psx == NULL) {
        pavi->fInit = FALSE;  // sigh; failed.
        return ResultFromScode(AVIERR_MEMORY);
    }

    AddRef();   // Now safe.  We only ever return AVIERR_OK after this.

    pavi->avistream.dwSuggestedBufferSize = pavi->psx->lMaxSampleSize;

    if (pavi->psx->lPalFrames == 0)
        pavi->avistream.dwFlags &= ~AVISF_VIDEO_PALCHANGES;
    else
        pavi->avistream.dwFlags |= AVISF_VIDEO_PALCHANGES;

    pavi->pb = pavi->pfile->pb;

    if (!pavi->pb) {

#ifdef USE_DIRECTIO
        if (!shfileIsDirect(pavi->hshfile))
#endif
        {

            lBufferSize = GetProfileIntA("avifile", "buffersize", 0) * 1024L;
            nBuffers = GetProfileIntA("avifile", "buffers", 0);

            if (lBufferSize && nBuffers && !(pavi->pfile->mode & OF_CREATE)) {
                pavi->pb = InitBuffered(nBuffers, lBufferSize,
                                    pavi->hshfile, NULL);
            }
        }
    }

    //
    //  use ReadBuffered() to read data!
    //
    if (pavi->pb) {
        pavi->psx->hFile = (HANDLE)pavi->pb;
        pavi->psx->Read  = (STREAMIOPROC)BufferedRead;
    }

    lLength = pavi->psx->lEnd - pavi->psx->lStart;

    if (lLength != (LONG)pavi->avistream.dwLength +
                            (LONG)pavi->avistream.dwInitialFrames) {
#ifdef DEBUG
        DPF("Stream %d: Length is %ld, header says %ld.\n",
            iStream, lLength,
            pavi->avistream.dwLength + pavi->avistream.dwInitialFrames);
#endif
        //!!! should we correct the header!!!
    }

returnnow:
    pavi->m_AVIStream.QueryInterface(IID_IAVIStream, (LPVOID FAR *) ppavi);
    Assert(*ppavi);  // We had better return an interface pointer

    //
    // all done return success.
    //
    return ResultFromScode(AVIERR_OK); // success
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::CreateStream(
                                   PAVISTREAM FAR *ppavi,
                                   AVISTREAMINFOW FAR *psi)
{
    CAVIFile FAR * pf = m_pAVIFile;
    CAVIStream FAR * pavi;
    int         iStream = (int) pf->avihdr.dwStreams;
    IUnknown FAR *  pUnk;

    CLock tlock(m_pAVIFile);

    // !!! If we are writing to an existing file, and not to a new file, we have
    // a limitation where we cannot grow the size of the header.
    // Check to see if the header will take up too much room!
    if (pf->lWriteLoc > 0) {
        LONG lHeader = sizeof(AVIStreamHeader) +
                       pf->lHeaderSize +
                       8 * sizeof(DWORD) +
                       lstrlenW(psi->szName);
        if (lHeader > pf->lDataListStart) {
            DPF("Header will be too big with this new stream!\n");
            return ResultFromScode(AVIERR_UNSUPPORTED);
        }
    }
    pf->lHeaderSize += sizeof(AVIStreamHeader) + 8 * sizeof(DWORD) +
                       lstrlenW(psi->szName);

    if (iStream >= MAXSTREAMS) {
        DPF("Ack: Too many streams: we only support %ld.\n", (LONG) MAXSTREAMS);

        return ResultFromScode(AVIERR_UNSUPPORTED);
    }

    if ((pf->mode & (OF_WRITE | OF_READWRITE)) == 0)
        return ResultFromScode(AVIERR_READONLY);

    pf->ps[iStream] = new FAR CAVIStream(NULL, &pUnk);

    if (!pf->ps[iStream])
        return ResultFromScode(AVIERR_MEMORY);

    pavi = pf->ps[iStream];
    pavi->iStream = iStream;
    pavi->pfile = pf;
    pavi->avistream = *psi;
    pavi->avistream.dwLength = 0;       // no data initially
    pavi->avistream.dwSuggestedBufferSize = 0;
    pavi->hshfile = pf->hshfile;
    pavi->m_AVIStream.AddRef();
    AddRef();

    pavi->lpFormat = NULL;      // This will be set leater with a SetFormat
    pavi->cbFormat = 0;

    if (pavi->avistream.fccType == streamtypeAUDIO) {
        SetRectEmpty(&pavi->avistream.rcFrame);
    }

    pf->avihdr.dwStreams++;

    if (pavi->iStream == 0) {
        pavi->pfile->avihdr.dwMicroSecPerFrame =
                max(1000L, muldiv32(1000000L,
                                     pavi->avistream.dwScale,
                                     pavi->avistream.dwRate));
    }

    /* Make sure the width and height of the created file are right.... */
    pf->avihdr.dwWidth = max(pf->avihdr.dwWidth,
                             (DWORD) pavi->avistream.rcFrame.right);
    pf->avihdr.dwHeight = max(pf->avihdr.dwHeight,
                             (DWORD) pavi->avistream.rcFrame.bottom);

    // Only if interleaved?
    pf->avihdr.dwInitialFrames = max(pf->avihdr.dwInitialFrames,
                                     pavi->avistream.dwInitialFrames);

    *ppavi = &pavi->m_AVIStream;

    return ResultFromScode(AVIERR_OK);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

#if 0
STDMETHODIMP CAVIFile::CAVIFileImpl::AddStream(
                                PAVISTREAM pavi,
                                PAVISTREAM FAR *ppaviNew)
{
    CAVIFile FAR * pf = m_pAVIFile;
    CAVIStream FAR * paviNew;
    int         iStream = (int) pf->avihdr.dwStreams;
    HRESULT     hr;
    IUnknown FAR *  pUnk;

    if ((pf->mode & (OF_WRITE | OF_READWRITE)) == 0)
        return ResultFromScode(AVIERR_READONLY);

    pfile->ps[iStream] = new FAR CAVIStream(NULL, &pUnk);

    if (!pfile->ps[iStream])
        return ResultFromScode(AVIERR_MEMORY);

    paviNew = pf->ps[iStream];
    paviNew->iStream = iStream;
    paviNew->pfile = pf;
    AVIStreamInfo(pavi, &paviNew->avistream, sizeof(paviNew->avistream));
    paviNew->hshfile = pf->hshfile;
    paviNew->m_AVIStream.AddRef();
    paviNew->paviBase = pavi;
    AVIStreamAddRef(pavi);

    paviNew->cbFormat = AVIStreamFormatSize(pavi, 0);
    paviNew->lpFormat = GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, paviNew->cbFormat);
    if (!paviNew->lpFormat) {
        AVIStreamClose((PAVISTREAM) pf->ps[iStream]);
        return ResultFromScode(AVIERR_MEMORY);
    }

    AVIStreamReadFormat(pavi, 0, paviNew->lpFormat, &paviNew->cbFormat);

    pf->avihdr.dwStreams++;

    AddRef();

    if (paviNew->iStream == 0) {
        pf->avihdr.dwMicroSecPerFrame =
                muldiv32(1000000L,
                         paviNew->avistream.dwScale,
                         paviNew->avistream.dwRate);
    }

    *ppaviNew = (PAVISTREAM) paviNew;

    return ResultFromScode(AVIERR_OK);
}
#endif

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::WriteData(
                       DWORD ckid,
                       LPVOID lpData,
                       LONG cbData)
{
    CAVIFile FAR *      pf = m_pAVIFile;
    CLock tlock(m_pAVIFile);

    // !!! Anything else we can check?
    if (lpData == NULL || cbData == 0)
        return ResultFromScode(AVIERR_BADPARAM);

    if ((pf->mode & (OF_WRITE | OF_READWRITE)) == 0)
        return ResultFromScode(AVIERR_READONLY);

    pf->fDirty = TRUE;

    return WriteExtra(&pf->extra, ckid, lpData, cbData);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::ReadData(
                      DWORD ckid,
                      LPVOID lpData,
                      LONG FAR *lpcbData)
{
    CAVIFile FAR * pf = m_pAVIFile;

    CLock tlock(m_pAVIFile);

    return ReadExtra(&pf->extra, ckid, lpData, lpcbData);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::EndRecord()
{
    CAVIFile FAR * pf = m_pAVIFile;
    CLock tlock(m_pAVIFile);

    if ((pf->mode & (OF_WRITE | OF_READWRITE)) == 0)
        return ResultFromScode(AVIERR_READONLY);

    pf->fDirty = TRUE;
    pf->avihdr.dwFlags |= AVIF_ISINTERLEAVED;

    if (pf->lWriteLoc == 0) {
        pf->lWriteLoc = (pf->lHeaderSize + 1024 + 2047) & ~(2047);

        // Leave room for start of first 'rec' chunk....
        pf->lWriteLoc -= 3 * sizeof(DWORD);

        pf->lDataListStart = pf->lWriteLoc - 3 * sizeof(DWORD);
        DPF("Writing first chunk at position %lu\n", pf->lWriteLoc);
    }

    shfileSeek(pf->hshfile, pf->lWriteLoc, SEEK_SET);

    if (pf->fInRecord) {

#ifndef NOPADDING
        {
            DWORD       dwCurOffset;
            DWORD       dwPadNeeded;
            MMCKINFO ck;

            dwCurOffset = shfileSeek(pf->hshfile, 0, SEEK_CUR);

            // want to start next record at 2K-12 byte boundary
            dwCurOffset = (dwCurOffset + 12) % 2048;

            if (dwCurOffset != 0) {
                // we need to pad....
                dwPadNeeded = 4096 - dwCurOffset - 8;
                if (dwPadNeeded >= 2048)
                    dwPadNeeded -= 2048;

                ck.ckid = mmioFOURCC('J','U','N','K');
                ck.cksize = dwPadNeeded;

                if (shfileCreateChunk(pf->hshfile, &ck, 0)) {
                    return ResultFromScode(AVIERR_FILEWRITE);
                }

                shfileZero(pf->hshfile, dwPadNeeded);

                if (shfileAscend(pf->hshfile, &ck, 0))
                    return ResultFromScode(AVIERR_FILEWRITE);
            }
        }
#endif

        if (shfileAscend(pf->hshfile, (MMCKINFO FAR *) &pf->ckRecord, 0))
            return ResultFromScode(AVIERR_FILEWRITE);

        IndexSetLength(pf->px, pf->lRecordIndex, pf->ckRecord.cksize);

        //
        // Keep the main suggested buffer size as big as the biggest
        // record....
        //
        if (pf->ckRecord.cksize + 3 * sizeof(DWORD) >
                                            pf->avihdr.dwSuggestedBufferSize)
            pf->avihdr.dwSuggestedBufferSize = pf->ckRecord.cksize +
                                                           3 * sizeof(DWORD);
    }

    /* Start the next 'rec' list */
    pf->ckRecord.cksize = 0;
    pf->ckRecord.fccType = listtypeAVIRECORD;
    pf->fInRecord = TRUE;
    if (shfileCreateChunk(pf->hshfile, (MMCKINFO FAR *) &pf->ckRecord, MMIO_CREATELIST)) {
        return ResultFromScode(AVIERR_FILEWRITE);
    }

    pf->lWriteLoc = shfileSeek(pf->hshfile, 0, SEEK_CUR);

    pf->lRecordIndex = pf->px->nIndex;

    if (!AddToIndex(pf, pf->ckRecord.fccType, 0,
        pf->ckRecord.dwDataOffset - 2 * sizeof(DWORD), AVIIF_LIST)) {
        return ResultFromScode(AVIERR_MEMORY);
    }

    return ResultFromScode(AVIERR_OK);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::Info(
                  AVIFILEINFOW FAR * pfi,
                  LONG lSize)
{
    CAVIFile FAR * pf = m_pAVIFile;

    if (pfi == NULL)
        return ResultFromScode(AVIERR_BADPARAM);

    if (lSize < sizeof(AVIFILEINFOW))
        return ResultFromScode(AVIERR_BUFFERTOOSMALL);

    CLock tlock(m_pAVIFile);

    pfi->dwMaxBytesPerSec =       pf->avihdr.dwMaxBytesPerSec;
    pfi->dwFlags =                (pf->avihdr.dwFlags & AVIF_ISINTERLEAVED);
    pfi->dwCaps  =              AVIFILECAPS_CANREAD | AVIFILECAPS_CANWRITE;
    pfi->dwStreams =              pf->avihdr.dwStreams;
    pfi->dwSuggestedBufferSize =  pf->avihdr.dwSuggestedBufferSize;
    pfi->dwWidth =                pf->avihdr.dwWidth;
    pfi->dwHeight =               pf->avihdr.dwHeight;
    pfi->dwScale =                pf->avihdr.dwMicroSecPerFrame;
    pfi->dwRate =                 1000000L;
    pfi->dwLength =               pf->avihdr.dwTotalFrames;
    pfi->dwEditCount =            0;

    LoadUnicodeString(ghMod, IDS_AVIFILE, pfi->szFileType, NUMELMS(pfi->szFileType));

    return AVIERR_OK;
}


///////////////////////////////////////////////////////////////////////////
//
//  AVIFileClose()
//
//      close a AVIFile stream
//
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CAVIStream::CUnknownImpl::Release()
{
    CAVIStream FAR * pavi = m_pAVIStream;

    CLock tlock(pavi->pfile);

    uUseCount--;

    if (m_refs < 20) {
        DPF2("Stream %p: Usage--=%lx\n", (DWORD_PTR) (LPVOID) this, m_refs - 1);
    }

    shfileRelease(pavi->hshfile);

    if (!--m_refs) {
        if (pavi->hshfile != pavi->pfile->hshfile) {
            shfileClose(pavi->hshfile, 0);
            pavi->hshfile = 0;
        }

        if (pavi->pb && pavi->pb != pavi->pfile->pb) {
            EndBuffered(pavi->pb);
            pavi->pb = 0;
        }

        if (pavi->psx) {
            FreeStreamIndex(pavi->psx);
            pavi->psx = NULL;
        }

        pavi->fInit = FALSE;

        // this call can cause the AVIFile object to be deleted, and
        // thus we must release the critical section first. There is no
        // danger in this, as nothing unsafe can happen to us between
        // releasing it here and getting it again when we enter
        // the file Release() call.
        tlock.Exit();

        pavi->pfile->m_AVIFile.Release();
        return 0;
    }
    return m_refs;
}

/*      -       -       -       -       -       -       -       -       */

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

void CAVIStream::CAVIStreamImpl::ReadPalette(LONG lPos, LONG lPal, LPRGBQUAD prgb)
{
    CAVIStream FAR * pavi = m_pAVIStream;

    CLock tlock(pavi->pfile);

    LPBITMAPINFOHEADER lpbi = (LPBITMAPINFOHEADER) pavi->lpFormat;
    LONG l;
    int i,n;

    static struct {
        BYTE                bFirstEntry;    /* first entry to change */
        BYTE                bNumEntries;    /* # entries to change (0 if 256) */
        WORD                wFlags;         /* Mostly to preserve alignment... */
        PALETTEENTRY        peNew[256];     /* New color specifications */
    } pc;

    DPF("Reading palette: lPos = %ld, lPal = %ld\n", lPos, lPal);

    if (lPal > lPos)
        lPal = 0;

    //
    //  get the palette colors in the initial format header
    //
    if (lPal <= 0) {
        hmemcpy(prgb,(LPBYTE)lpbi+(int)lpbi->biSize, lpbi->biClrUsed * sizeof(RGBQUAD));
        lPal = -1;
    }

    for (;;) {
        //
        //  search index forward for next palette change
        //
        l = StreamFindSample(pavi->psx, lPal+1, FIND_FORMAT|FIND_NEXT);

        if (l < 0 || l > lPos || l == lPal)
            break;

        lPal = l;

        if (l <= (LONG) pavi->avistream.dwStart)
            continue;

        LONG off = StreamFindSample(pavi->psx, lPal, FIND_FORMAT|FIND_OFFSET);
        LONG len = StreamFindSample(pavi->psx, lPal, FIND_FORMAT|FIND_LENGTH);

#ifdef DEBUG
        DWORD adw[2];
        shfileSeek(pavi->hshfile, off-8, SEEK_SET);
        shfileRead(pavi->hshfile, (HPSTR)adw, sizeof(adw));
        Assert(TWOCCFromFOURCC(adw[0]) == cktypePALchange);
        Assert(adw[1] == (DWORD) len);
#endif

        if (len > (LONG)(sizeof(AVIPALCHANGE) + (LONG)lpbi->biClrUsed * sizeof(PALETTEENTRY) * 2)) {
            DPF("Palette chunk obviously too large!\n");
            break;
        }

        //
        //  read palchange from file and apply it
        //
        shfileSeek(pavi->hshfile, off, SEEK_SET);

        while (len >= (LONG)sizeof(AVIPALCHANGE)) {

            if (shfileRead(pavi->hshfile, (HPSTR)&pc, sizeof(AVIPALCHANGE)) !=
                        sizeof(AVIPALCHANGE)) {
                DPF("Error reading palette change\n");
                break;
            }

            n = pc.bNumEntries == 0 ? 256 : (int)pc.bNumEntries;

            if ((DWORD) n > lpbi->biClrUsed) {
                DPF("%d colors in palette change, only %lu in movie!\n", n, lpbi->biClrUsed);
                break;
            }

            if (pc.bFirstEntry + n > (int)lpbi->biClrUsed) {
                DPF("%d colors in palette change, only %lu in movie!\n", n, lpbi->biClrUsed);
                break;
            }

            if (shfileRead(pavi->hshfile,
                           (HPSTR)&pc.peNew,
                           n * sizeof(PALETTEENTRY)) !=
                   (LONG) (n * sizeof(PALETTEENTRY))) {
                DPF("Error reading palette change entries\n");
                break;
            }

            for (i=0; i<n; i++) {
                pavi->argbq[pc.bFirstEntry+i].rgbRed       = pc.peNew[i].peRed;
                pavi->argbq[pc.bFirstEntry+i].rgbGreen     = pc.peNew[i].peGreen;
                pavi->argbq[pc.bFirstEntry+i].rgbBlue      = pc.peNew[i].peBlue;
                pavi->argbq[pc.bFirstEntry+i].rgbReserved  = 0;
            }

            len -= n * sizeof(PALETTEENTRY) + sizeof(AVIPALCHANGE);
        }
    }
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::ReadFormat(LONG lPos, LPVOID lpFormat, LONG FAR *lpcbFormat)
{
    CAVIStream FAR * pavi = m_pAVIStream;
    CLock tlock(pavi->pfile);

    LONG lPal;
    LPBITMAPINFOHEADER lpbi;

    if (lpcbFormat == NULL)
        return ResultFromScode(AVIERR_BADPARAM);

    if (lpFormat == NULL || *lpcbFormat == 0) {
        *lpcbFormat = pavi->cbFormat;
        return AVIERR_OK;
    }

    if (pavi->avistream.dwFlags & AVISF_VIDEO_PALCHANGES) {

        Assert(pavi->psx);

        //
        //  now go find the nearest palette change
        //
        lPal = StreamFindSample(pavi->psx, lPos, FIND_FORMAT|FIND_PREV);

        if (lPal < 0)
            lPal = 0;

        if (lPal != pavi->lPal) {
            ReadPalette(lPal, pavi->lPal, pavi->argbq);
            pavi->lPal = lPal;
        }

        lpbi = (LPBITMAPINFOHEADER) pavi->lpFormat;

        hmemcpy(lpFormat, lpbi, min((LONG) lpbi->biSize, *lpcbFormat));

        if (*lpcbFormat > (LONG) lpbi->biSize) {
            hmemcpy((LPBYTE)lpFormat + (int)lpbi->biSize, pavi->argbq,
                    min(lpbi->biClrUsed * sizeof(RGBQUAD),
                        *lpcbFormat - lpbi->biSize));
        }
    }
    else {
        hmemcpy(lpFormat, pavi->lpFormat, min(*lpcbFormat, pavi->cbFormat));
    }

    if (*lpcbFormat < pavi->cbFormat) {
        *lpcbFormat = pavi->cbFormat;
        return ResultFromScode(AVIERR_BUFFERTOOSMALL);
    }

    *lpcbFormat = pavi->cbFormat;

    return AVIERR_OK;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Create(LPARAM lParam1, LPARAM lParam2)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Info(AVISTREAMINFOW FAR * psi, LONG lSize)
{
    CAVIStream FAR * pavi = m_pAVIStream;

    CLock tlock(pavi->pfile);

    if (psi == NULL)
        return ResultFromScode(AVIERR_BADPARAM);

    if (lSize < sizeof(pavi->avistream))
        return ResultFromScode(AVIERR_BUFFERTOOSMALL);

    hmemcpy(psi, &pavi->avistream, sizeof(pavi->avistream));

    return AVIERR_OK;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(LONG) CAVIStream::CAVIStreamImpl::FindSample(LONG lPos, LONG lFlags)
{
    CAVIStream FAR * pavi = m_pAVIStream;
    CLock tlock(pavi->pfile);

    if (pavi->paviBase) {
        // If we haven't copied over the data yet, delegate.
        return AVIStreamFindSample(pavi->paviBase, lPos, lFlags);
    }

#ifdef _WIN32
    if (!lPos && (lFlags & FIND_FROM_START)) {
        lPos = pavi->avistream.dwStart;
    } else
#endif
    if (lPos < (LONG)pavi->avistream.dwStart)
        return -1;

    if (lPos >= (LONG)(pavi->avistream.dwStart + pavi->avistream.dwLength))
        return -1;

    lPos = StreamFindSample(pavi->psx, lPos, (UINT)lFlags);

    return lPos < 0 ? -1 : lPos;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Read(
                 LONG       lStart,
                 LONG       lSamples,
                 LPVOID     lpBuffer,
                 LONG       cbBuffer,
                 LONG FAR * plBytes,
                 LONG FAR * plSamples)
{
    CAVIStream FAR *    pavi = m_pAVIStream;
    LONG                lBytes;
    CLock tlock(pavi->pfile);

    if (pavi->paviBase) {
        // If we haven't copied over the data yet, delegate.
        return AVIStreamRead(pavi->paviBase, lStart, lSamples,
                             lpBuffer, cbBuffer, plBytes, plSamples);
    }

    Assert(pavi->psx);

    // !!! What if start too big? Length too long?

    if (lStart < (LONG) pavi->avistream.dwStart) {
        DPF("Read before start!\n");
        return ResultFromScode(AVIERR_BADPARAM);
    }

    // Handle one of the sillier aspects of AVI files:
    // Certain RLE-encoded files have their first frames split
    // up into lots of small pieces.  This code puts all of those
    // pieces back together again if necessary.

    if ((lStart == (LONG) pavi->avistream.dwStart) &&
                    (pavi->avistream.fccType == streamtypeVIDEO) &&
                    (pavi->avistream.dwInitialFrames > 0)) {

        LPBITMAPINFOHEADER  lpbi = (LPBITMAPINFOHEADER) pavi->lpFormat;
        LPVOID              lp;

        lStart -= (LONG) pavi->avistream.dwInitialFrames;
        lBytes = (DWORD)(WORD)DIBWIDTHBYTES(lpbi) * (DWORD)(WORD)lpbi->biHeight;

        //
        // a NULL buffer means return the size buffer needed to read
        // the given sample.
        //
        if (lpBuffer == NULL || cbBuffer == 0) {

            if (plBytes)
                *plBytes = lBytes;

            return AVIERR_OK;
        }

        if (cbBuffer < lBytes) {
            if (plBytes)
                *plBytes = lBytes;
            DPF("ReadFirst: Buffer is %ld bytes, needed %ld\n", cbBuffer, lBytes);
            return ResultFromScode(AVIERR_BUFFERTOOSMALL);
        }

        lp = GlobalAllocPtr(GMEM_MOVEABLE, lBytes);

        if (!lp)
            return ResultFromScode(AVIERR_MEMORY);

        while (lStart <= (LONG)pavi->avistream.dwStart) {

            if (StreamRead(pavi->psx, lStart, 1, lp, lBytes) < 0) {
                GlobalFreePtr(lp);
                return ResultFromScode(AVIERR_FILEREAD);
            }

            // We probably shouldn't assume RLE here....
            DecodeRle(lpbi, (BYTE _huge *) lpBuffer, (BYTE _huge *) lp, lBytes);
            lStart++;
        }

        GlobalFreePtr(lp);
        goto done;
    }

    //
    // do the read
    //
    lBytes = StreamRead(pavi->psx,lStart,lSamples,lpBuffer,cbBuffer);

    //
    // check for error
    //
    if (lBytes < 0) {

        if (plBytes)
            *plBytes = 0;

        if (plSamples)
            *plSamples = 0;

        if (cbBuffer == 0)
            return ResultFromScode(AVIERR_ERROR);

        //
        // the error may have been buffer too small, check this.
        //
        if (cbBuffer < pavi->psx->lSampleSize)
            return ResultFromScode(AVIERR_BUFFERTOOSMALL);

        lBytes = StreamFindSample(pavi->psx,lStart,FIND_PREV|FIND_LENGTH);

        if (cbBuffer < lBytes) {

            if (plBytes)
                *plBytes = lBytes;

            return ResultFromScode(AVIERR_BUFFERTOOSMALL);
        }
        else
            return ResultFromScode(AVIERR_FILEREAD);
    }

done:
    if (plBytes)
        *plBytes = lBytes;

    if (plSamples) {
        LONG lSampleSize = pavi->psx->lSampleSize;

        if (lSampleSize)
            *plSamples = lBytes / lSampleSize;
        else
            *plSamples = 1;
    }

    return AVIERR_OK;
}

/**************************************************************************
* @doc  INTERNAL DRAWDIB
*
* @api BOOL | DibEq | This function compares two dibs.
*
* @parm LPBITMAPINFOHEADER lpbi1 | Pointer to one bitmap.
*       this DIB is assumed to have the colors after the BITMAPINFOHEADER
*
* @parm LPBITMAPINFOHEADER | lpbi2 | Pointer to second bitmap.
*       this DIB is assumed to have the colors after biSize bytes.
*
* @rdesc Returns TRUE if bitmaps are identical, FALSE otherwise.
*
**************************************************************************/
inline BOOL DibEq(LPBITMAPINFOHEADER lpbi1, LPBITMAPINFOHEADER lpbi2)
{
    return
        lpbi1->biCompression == lpbi2->biCompression   &&
        lpbi1->biSize        == lpbi2->biSize          &&
        lpbi1->biWidth       == lpbi2->biWidth         &&
        lpbi1->biHeight      == lpbi2->biHeight        &&
        lpbi1->biBitCount    == lpbi2->biBitCount;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::SetFormat(LONG lPos,LPVOID lpFormat,LONG cbFormat)
{
    CAVIStream FAR *    pavi = m_pAVIStream;
    CLock tlock(pavi->pfile);
    LPBITMAPINFOHEADER  lpbi = (LPBITMAPINFOHEADER) lpFormat;
    int                 i;
    RGBQUAD FAR *       lprgb;
    struct {
        BYTE            bFirstEntry;    /* first entry to change */
        BYTE            bNumEntries;    /* # entries to change (0 if 256) */
        WORD            wFlags;         /* Mostly to preserve alignment... */
        PALETTEENTRY    pe[256];
    } s;


    //
    // Make sure the stream isn't read-only
    //
    if ((pavi->pfile->mode & (OF_WRITE | OF_READWRITE)) == 0)
        return ResultFromScode(AVIERR_READONLY);

    if (pavi->lpFormat == NULL) {
        // !!! If we are writing to an existing file, and not to a new file, we
        // have a limitation where we cannot grow the size of the header.
        // Check to see if the header will take up too much room!
        if (pavi->pfile->lWriteLoc > 0) {
            LONG lHeader = pavi->cbFormat +
                           pavi->pfile->lHeaderSize +
                           2 * sizeof(DWORD);
            if (lHeader > pavi->pfile->lDataListStart) {
                DPF("Header will be too big with this format!\n");
                return ResultFromScode(AVIERR_UNSUPPORTED);
            }
        }
        pavi->pfile->lHeaderSize += cbFormat + 2 * sizeof(DWORD);

        // This is a new stream, whose format hasn't been set.
        pavi->lpFormat = GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, cbFormat);
        if (!pavi->lpFormat) {
            return ResultFromScode(AVIERR_MEMORY);
        }

        hmemcpy(pavi->lpFormat, lpFormat, cbFormat);
        pavi->cbFormat = cbFormat;

        if (pavi->avistream.fccType == streamtypeVIDEO) {

            if (ISRECTBOGUS(&pavi->avistream.rcFrame,
                            pavi->pfile->avihdr.dwWidth,
                            pavi->pfile->avihdr.dwHeight,
                            lpbi)) {
                DPF("Resetting stream rectangle....\n");
                SetRect(&pavi->avistream.rcFrame, 0, 0,
                    (int)lpbi->biWidth, (int)lpbi->biHeight);
            }

            if (lpbi->biClrUsed > 0) {
                // Get the right colors, so that we can detect palette changes
                hmemcpy(pavi->argbq,
                        (LPBYTE) lpbi + lpbi->biSize,
                        lpbi->biClrUsed * sizeof(RGBQUAD));
            }

            /* Make sure the width and height of the created file are right.... */
            pavi->pfile->avihdr.dwWidth = max(pavi->pfile->avihdr.dwWidth,
                                 (DWORD) pavi->avistream.rcFrame.right);
            pavi->pfile->avihdr.dwHeight = max(pavi->pfile->avihdr.dwHeight,
                                 (DWORD) pavi->avistream.rcFrame.bottom);
        }

        return ResultFromScode(AVIERR_OK);
    }

    //
    // First, check if the format is actually different....
    //
    if (cbFormat == pavi->cbFormat &&
                (_fmemcmp(pavi->lpFormat, lpFormat, (int) cbFormat) == 0))
        return ResultFromScode(AVIERR_OK);

    //
    // We really only support format changes if they're palette changes...
    //
    if (pavi->avistream.fccType != streamtypeVIDEO) {
        return ResultFromScode(AVIERR_UNSUPPORTED);
    }

    //
    // Can only currently set the palette at the end of the file
    //
    if (lPos < (LONG) (pavi->avistream.dwStart + pavi->avistream.dwLength))
        return ResultFromScode(AVIERR_UNSUPPORTED);

    //
    // We can only change the palette for things with palettes....
    //
    if (lpbi->biBitCount > 8 || lpbi->biClrUsed == 0)
        return ResultFromScode(AVIERR_UNSUPPORTED);

    //
    // Be sure only the palette is changing, nothing else....
    //
    if (cbFormat != pavi->cbFormat)
        return ResultFromScode(AVIERR_UNSUPPORTED);

    if (!DibEq((LPBITMAPINFOHEADER) lpFormat,
               (LPBITMAPINFOHEADER) pavi->lpFormat))
        return ResultFromScode(AVIERR_UNSUPPORTED);

    // !!! Need to do here:
    // Get the correct palette for this point in the file, and check
    // that the new palette is in fact different.
    lprgb = (RGBQUAD FAR *) ((LPBYTE) lpbi + lpbi->biSize);

    if (_fmemcmp(pavi->argbq, lprgb, (UINT) lpbi->biClrUsed * sizeof(RGBQUAD)) == 0)
        return ResultFromScode(AVIERR_OK);

    //
    // Make the new format the current one....
    //
    hmemcpy(pavi->argbq, lprgb, lpbi->biClrUsed * sizeof(RGBQUAD));
    pavi->lPal = lPos;

    //
    // And be sure the stream is marked as having changes...
    //
    pavi->avistream.dwFlags |= AVISF_VIDEO_PALCHANGES;

    s.bFirstEntry = 0;
    s.bNumEntries = (BYTE) lpbi->biClrUsed;
    s.wFlags = 0;
    for (i = 0; i < (int) lpbi->biClrUsed; i++, lprgb++) {
        s.pe[i].peRed = lprgb->rgbRed;
        s.pe[i].peGreen = lprgb->rgbGreen;
        s.pe[i].peBlue = lprgb->rgbBlue;
    }

    // !!! Hack: use Write to write the palette change....

    return Write(lPos,
                 0,
                 &s,
                 sizeof(AVIPALCHANGE) + lpbi->biClrUsed * sizeof(PALETTEENTRY),
                 AVIIF_NOTIME, NULL, NULL);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Write(LONG lStart,
                                               LONG lSamples,
                                               LPVOID lpData,
                                               LONG cbData,
                                               DWORD dwFlags,
                                               LONG FAR *plSampWritten,
                                               LONG FAR *plBytesWritten)
{
    CAVIStream FAR *        pavi = m_pAVIStream;
    CLock tlock(pavi->pfile);
    MMCKINFO        ck;
    WORD            cktype;
    HRESULT         hr;
    DWORD           dwmsec;

    // !!! Idea: if it's audio-like data, and everything else matches the
    // last chunk written out, then merge the new data in with the old
    // data, rather than making a new chunk....

    if ((pavi->pfile->mode & (OF_WRITE | OF_READWRITE)) == 0)
        return ResultFromScode(AVIERR_READONLY);

    if (!pavi->lpFormat) {
        // The format must be set before any write calls
        // are made....
        return ResultFromScode(E_UNEXPECTED);
    }

    if (pavi->avistream.fccType == streamtypeAUDIO)
        cktype = aviTWOCC('w', 'b');
    else if (pavi->avistream.fccType == streamtypeVIDEO) {
        if (dwFlags & AVIIF_NOTIME)
            cktype = aviTWOCC('p', 'c');
        else {
            LPBITMAPINFOHEADER lpbi = (LPBITMAPINFOHEADER) pavi->lpFormat;

            if ((dwFlags & AVIIF_KEYFRAME) ||
                (lpbi->biCompression <= BI_RLE8 && cbData == (LONG) lpbi->biSizeImage))
                cktype = aviTWOCC('d', 'b');
            else
                cktype = aviTWOCC('d', 'c');
            // !!! 00dx ack!
        }
    } else {
        cktype = aviTWOCC('d', 'c');
    }

    ck.ckid = MAKEAVICKID(cktype, pavi->iStream);
    ck.cksize = cbData;

    if (lStart < 0)
        lStart = pavi->avistream.dwStart + pavi->avistream.dwLength;

    if (lStart > (LONG) (pavi->avistream.dwStart + pavi->avistream.dwLength)) {
        if (pavi->avistream.dwSampleSize == 0) {
            // !!! hack--insert lots of blank index entries....

            while (lStart > (LONG) (pavi->avistream.dwStart + pavi->avistream.dwLength)) {
#if 1
                hr = Write(pavi->avistream.dwStart + pavi->avistream.dwLength,
                            1,
                            NULL,
                            0,
                            0,
                            NULL,
                            NULL);

                if (FAILED(hr))
                    return hr;
#else
                if (!AddToIndex(pavi->pfile, ck.ckid, 0, 0, 0))
                    return ResultFromScode(AVIERR_MEMORY);

                ++pavi->avistream.dwLength;
                pavi->pfile->avihdr.dwFlags |= AVIF_MUSTUSEINDEX;
#endif
            }
        } else
            return ResultFromScode(AVIERR_BADPARAM);
    }

    if (lStart < (LONG) (pavi->avistream.dwStart + pavi->avistream.dwLength))
        return ResultFromScode(AVIERR_UNSUPPORTED);

    pavi->pfile->fDirty = TRUE;

    if (pavi->pfile->lWriteLoc == 0) {
        pavi->pfile->lWriteLoc = (pavi->pfile->lHeaderSize + 1024 + 2047) & ~(2047);
        pavi->pfile->lDataListStart = pavi->pfile->lWriteLoc - 3 * sizeof(DWORD);
        DPF("Writing first chunk at position %lu\n", pavi->pfile->lWriteLoc);
    }

#if 0
    if ((lStart == (LONG) (pavi->avistream.dwStart + pavi->avistream.dwLength)) &&
        (pavi->avistream.fccType == streamtypeAUDIO) &&
        (pavi->pfile->lIndex > 0)) {
            AVIINDEXENTRY   idx = pavi->pfile->pIndex[pavi->pfile->lIndex - 1];

            if ((idx.ckid == ckid) &&
                (idx.dwChunkOffset +
                 2 * sizeof(DWORD) +
                 idx.dwChunkLength == lWriteLoc)) {

                // We could append to the previous chunk here....

            }
    }

#endif

#ifdef DONTWRITEZEROLENGTH
    if (cbData == 0) {
        ck.dwDataOffset = 0;
        pavi->pfile->avihdr.dwFlags |= AVIF_MUSTUSEINDEX;
    } else
#endif
    {
        shfileSeek(pavi->hshfile, pavi->pfile->lWriteLoc, SEEK_SET);
        shfileCreateChunk(pavi->hshfile, &ck, 0);

        if (cbData) {
            if (shfileWrite(pavi->hshfile, (HPSTR) lpData, cbData) != cbData)
                return ResultFromScode(AVIERR_FILEWRITE);
        }

        if (shfileAscend(pavi->hshfile, &ck, 0) != 0)
            return ResultFromScode(AVIERR_FILEWRITE);

        pavi->pfile->lWriteLoc = shfileSeek(pavi->hshfile, 0, SEEK_CUR);
    }

    if (!AddToIndex(pavi->pfile, ck.ckid, cbData,
                    ck.dwDataOffset - 2 * sizeof(DWORD), dwFlags))
        return ResultFromScode(AVIERR_MEMORY);

    //
    // if we dont have a stream index now is a good time to make one.
    //
    if (pavi->psx == NULL) {

        pavi->psx = MakeStreamIndex(pavi->pfile->px, pavi->iStream,
            (LONG)pavi->avistream.dwStart - pavi->avistream.dwInitialFrames,
            (LONG)pavi->avistream.dwSampleSize,
            pavi->pfile->hshfile, shfileReadProc, NULL);

        //!!! what about pavi->pb

        if (!(dwFlags & AVIIF_NOTIME))
            pavi->psx->lEnd -= lSamples;    // correct for the decrement below
    }

    if (pavi->psx == NULL) {
        DPF("CAVIStream::Write no stream index!\n");
        return ResultFromScode(AVIERR_MEMORY);
    }

    if (!(dwFlags & AVIIF_NOTIME)) {
        pavi->avistream.dwLength += lSamples;

        if (pavi->psx)
            pavi->psx->lEnd += lSamples;
    }

    if (cbData > (LONG) pavi->avistream.dwSuggestedBufferSize)
        pavi->avistream.dwSuggestedBufferSize = cbData;

    if (cbData > (LONG) pavi->pfile->avihdr.dwSuggestedBufferSize)
        pavi->pfile->avihdr.dwSuggestedBufferSize = cbData;

    // Recalculate the overall file length....
    dwmsec = muldiv32(pavi->avistream.dwLength,
                             pavi->avistream.dwScale * 1000L,
                             pavi->avistream.dwRate);
    pavi->pfile->avihdr.dwTotalFrames =
        max(pavi->pfile->avihdr.dwTotalFrames,
            (DWORD) muldiv32(dwmsec, 1000L,
                             pavi->pfile->avihdr.dwMicroSecPerFrame));
    // !!! The above calculation could easily overflow.
    // !!! NEEDS TO BE REORGANIZED!

    if (plBytesWritten)
        *plBytesWritten = cbData;

    if (plSampWritten)
        *plSampWritten = lSamples;

    return ResultFromScode(AVIERR_OK);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Delete(LONG lStart,LONG lSamples)
{
    CAVIStream FAR *      pavi = m_pAVIStream;
    CLock tlock(pavi->pfile);

    if ((pavi->pfile->mode & (OF_WRITE | OF_READWRITE)) == 0)
        return ResultFromScode(AVIERR_READONLY);

    // go through and kill things from the index?

    // !!! what about keyframe boundaries?

    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::ReadData(DWORD ckid, LPVOID lp, LONG FAR *lpcb)
{
    CAVIStream FAR *      pavi = m_pAVIStream;
    CLock tlock(pavi->pfile);

    return ReadExtra(&pavi->extra, ckid, lp, lpcb);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::WriteData(DWORD ckid, LPVOID lp, LONG cb)
{
    CAVIStream FAR *      pavi = m_pAVIStream;
    CLock tlock(pavi->pfile);

    DPF("WriteData asked to write %ld bytes\n", cb);

    if ((pavi->pfile->mode & (OF_WRITE | OF_READWRITE)) == 0)
        return ResultFromScode(AVIERR_READONLY);

    // !!! If we are writing to an existing file, and not to a new file, we have
    // a limitation where we cannot grow the size of the header.
    // Check to see if the header will take up too much room.
    if (pavi->pfile->lWriteLoc > 0) {
        LONG lHeader = cb + pavi->pfile->lHeaderSize + 2 * sizeof(DWORD);
        if (lHeader > pavi->pfile->lDataListStart) {
            DPF("Header will be too big with this extra data!\n");
            return ResultFromScode(AVIERR_UNSUPPORTED);
        }
    }

    pavi->pfile->lHeaderSize += cb + 3 * sizeof(DWORD);

    pavi->pfile->fDirty = TRUE;

    return WriteExtra(&pavi->extra, ckid, lp, cb);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

#if 0
STDMETHODIMP CAVIStream::CAVIStreamImpl::Clone(PAVISTREAM FAR * ppaviNew)
{
    CAVIStream FAR *      pavi = m_pAVIStream;

    return ResultFromScode(AVIERR_UNSUPPORTED);
}
#endif


STDMETHODIMP CAVIStream::CStreamingImpl::Begin(LONG  lStart,
                                               LONG  lEnd,
                                               LONG  lRate)
{
    CAVIStream FAR *      pavi = m_pAVIStream;
    CLock tlock(pavi->pfile);

#ifdef USE_DIRECTIO
    if (shfileIsDirect(pavi->hshfile)) {
        shfileStreamStart(pavi->hshfile);
    } else
#endif
        if (pavi->pb)
            BeginBufferedStreaming(pavi->pb, lRate > 0);

    return ResultFromScode(AVIERR_OK);
}


STDMETHODIMP CAVIStream::CStreamingImpl::End()
{
    CAVIStream FAR *      pavi = m_pAVIStream;
    CLock tlock(pavi->pfile);

#ifdef USE_DIRECTIO
    if (shfileIsDirect(pavi->hshfile)) {
        shfileStreamStop(pavi->hshfile);
    } else
#endif
        if (pavi->pb)
            EndBufferedStreaming(pavi->pb);

    return ResultFromScode(AVIERR_OK);
}



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

static
BOOL AddToIndex(CAVIFile FAR * pfile, DWORD ckid, DWORD cksize, LONG off, DWORD dwFlags)
{
    PAVIINDEX px;
    AVIINDEXENTRY idx;

    idx.ckid          = ckid;
    idx.dwChunkOffset = off;
    idx.dwChunkLength = cksize;
    idx.dwFlags       = dwFlags;

    px = IndexAddFileIndex(pfile->px, &idx, 1, 0, FALSE);

    if (px == NULL)
        return FALSE;

    //
    // GlobalReAlloc may have moved our pointer, we need to patch all
    // places we use it!
    //
    if (px != pfile->px) {

        DPF("Index pointer has changed!\n");

        pfile->px = px;

        for (int i=0; i<(int)pfile->avihdr.dwStreams; i++) {

            CAVIStream FAR *ps = pfile->ps[i];

            if (ps->psx)
                ps->psx->px = px;
        }

        if (pfile->pb)
            pfile->pb->px = px;
    }

    return TRUE;
}

#ifdef _WIN32
STDMETHODIMP CAVIStream::CAVIStreamImpl::SetInfo(AVISTREAMINFOW FAR *lpInfo, LONG cbInfo)
{
    CAVIStream FAR * pavi = m_pAVIStream;

    CLock tlock(pavi->pfile);

    if ((pavi->pfile->mode & (OF_WRITE | OF_READWRITE)) == 0)
        return ResultFromScode(AVIERR_READONLY);

    if ((cbInfo < sizeof(AVISTREAMINFOW)) ||
        (IsBadReadPtr(lpInfo, sizeof(AVISTREAMINFOW))))
        return ResultFromScode(AVIERR_BADPARAM);

    // Things we don't copy:
    // fccType
    // fccHandler
    // dwFlags
    // dwCaps
    // dwLength
    // dwInitialFrames
    // dwSuggestedBufferSize
    // dwSampleSize
    // dwEditCount
    // dwFormatChangeCount

    pavi->avistream.wPriority = lpInfo->wPriority;
    pavi->avistream.wLanguage = lpInfo->wLanguage;
    pavi->avistream.dwScale   = lpInfo->dwScale;
    pavi->avistream.dwRate    = lpInfo->dwRate;
    pavi->avistream.dwStart   = lpInfo->dwStart;  // !!! ???
    pavi->avistream.dwQuality = lpInfo->dwQuality;
    pavi->avistream.rcFrame   = lpInfo->rcFrame;

    if (lpInfo->szName[0])
        _fmemcpy(pavi->avistream.szName, lpInfo->szName, sizeof(pavi->avistream.szName));

    pavi->pfile->fDirty = TRUE;

    return NOERROR;
}

STDMETHODIMP CAVIFile::CAVIFileImpl::DeleteStream(DWORD fccType, LONG lParam)
{
    CAVIFile FAR * pfile = m_pAVIFile;

    CAVIStream FAR *pavi;
    int             iStreamCur;
    int             iStreamWant;
    int             iStream;

    // thread locking
    CLock tlock(pfile);

    iStreamWant = (int)lParam;

    if (iStreamWant < 0 || iStreamWant >= (int)pfile->avihdr.dwStreams)
        return ResultFromScode(AVIERR_NODATA);

    /* Allocate stream data stuff, read streams */
    for (iStreamCur = -1, iStream = 0;
            iStream < (int)pfile->avihdr.dwStreams;
            iStream++) {
        if (fccType == 0 || pfile->ps[iStream]->avistream.fccType == fccType)
            iStreamCur++;

        if (iStreamCur == iStreamWant)
            break;
    }

    if (iStreamCur != iStreamWant)
        return ResultFromScode(AVIERR_NODATA);

    pavi = pfile->ps[iStream];

    // Is somebody using this stream?
    if (pavi->fInit)
        return ResultFromScode(AVIERR_UNSUPPORTED);

    pfile->avihdr.dwStreams++;

    pfile->lHeaderSize -= sizeof(AVIStreamHeader) + 8 * sizeof(DWORD) +
                       lstrlenW(pavi->avistream.szName);

    while (iStream < (int) pfile->avihdr.dwStreams) {
        pfile->ps[iStream] = pfile->ps[iStream + 1];
        iStream++;
    }

    delete pavi;

    return ResultFromScode(AVIERR_UNSUPPORTED);
}
#else
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::Reserved1(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::Reserved2(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::Reserved3(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::Reserved4(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIFile::CAVIFileImpl::Reserved5(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Reserved1(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Reserved2(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Reserved3(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Reserved4(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAVIStream::CAVIStreamImpl::Reserved5(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

#endif

#ifdef CUSTOMMARSHAL
CAVIFile::CMarshalImpl::CMarshalImpl(
        CAVIFile FAR*   pAVIFile)
{
        m_pAVIFile = pAVIFile;
}


STDMETHODIMP CAVIFile::CMarshalImpl::QueryInterface(
        const IID FAR&  iid,
        void FAR* FAR*  ppv)
{
        return m_pAVIFile->m_pUnknownOuter->QueryInterface(iid, ppv);
}

/*      -       -       -       -       -       -       -       -       */

STDMETHODIMP_(ULONG) CAVIFile::CMarshalImpl::AddRef()
{
        return m_pAVIFile->m_pUnknownOuter->AddRef();
}

/*      -       -       -       -       -       -       -       -       */

STDMETHODIMP_(ULONG) CAVIFile::CMarshalImpl::Release()
{
        return m_pAVIFile->m_pUnknownOuter->Release();
}

/*      -       -       -       -       -       -       -       -       */



// *** IMarshal methods ***
STDMETHODIMP CAVIFile::CMarshalImpl::GetUnmarshalClass (THIS_ REFIID riid, LPVOID pv,
                    DWORD dwDestContext, LPVOID pvDestContext,
                    DWORD mshlflags, LPCLSID pCid)
{
    HRESULT hr = NOERROR;
    IUnknown FAR * pUnk = &m_pAVIFile->m_Unknown;

    DPF("(F) UnMarshalClass called (context = %lx)\n", dwDestContext);

    if (dwDestContext != MSHCTX_LOCAL) {
        LPMARSHAL    pMarshal;

        DPF("Marshal context is %lu: delegating...\n", dwDestContext);

        hr = CoGetStandardMarshal(riid, NULL,
                                  dwDestContext, pvDestContext,
                                  mshlflags, &pMarshal);

        if (hr != NOERROR)
            return hr;

        hr = pMarshal->GetUnmarshalClass(riid, pv,
                                         dwDestContext, pvDestContext,
                                         mshlflags, pCid);

        pMarshal->Release();

        return hr;
    }
    *pCid = CLSID_AVISimpleUnMarshal;
    return hr;
}

STDMETHODIMP CAVIFile::CMarshalImpl::GetMarshalSizeMax (THIS_ REFIID riid, LPVOID pv,
                    DWORD dwDestContext, LPVOID pvDestContext,
                    DWORD mshlflags, LPDWORD pSize)
{
    HRESULT hr = NOERROR;
    IUnknown FAR * pUnk = &m_pAVIFile->m_Unknown;

    if (dwDestContext != MSHCTX_LOCAL) {
        LPMARSHAL    pMarshal;

        hr = CoGetStandardMarshal(riid, NULL, dwDestContext, pvDestContext,
                                  mshlflags, &pMarshal);

        if (hr != NOERROR)
            return hr;

        hr = pMarshal->GetMarshalSizeMax(riid, pv,
                                         dwDestContext, pvDestContext,
                                         mshlflags, pSize);

        pMarshal->Release();

        return hr;
    }
    *pSize = sizeof(pUnk);

    return hr;
}

STDMETHODIMP CAVIFile::CMarshalImpl::MarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
                    LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
                    DWORD mshlflags)
{
    HRESULT hr = NOERROR;
    IUnknown FAR * pUnk = &m_pAVIFile->m_Unknown;

    DPF("MarshalInterface (F) called\n");

    if (dwDestContext != MSHCTX_LOCAL) {
        LPMARSHAL    pMarshal;

        DPF("Marshal context is %lu: delegating...\n", dwDestContext);

        hr = CoGetStandardMarshal(riid, NULL,
                                  dwDestContext, pvDestContext,
                                  mshlflags, &pMarshal);

        if (hr != NOERROR)
            return hr;

        hr = pMarshal->MarshalInterface(pStm, riid, pv,
                                        dwDestContext, pvDestContext,
                                        mshlflags);

        pMarshal->Release();

        return hr;
    }

    if ((riid != IID_IAVIStream && riid != IID_IAVIFile && riid != IID_IUnknown))
        return ResultFromScode(E_INVALIDARG);

    if ((hr = pStm->Write(&pUnk, sizeof(pUnk), NULL)) == NOERROR)
        AddRef();

    DPF("Returns %lx\n", (DWORD) (LPVOID) hr);
    return hr;
}

STDMETHODIMP CAVIFile::CMarshalImpl::UnmarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
                    LPVOID FAR* ppv)
{
    HRESULT hr = ResultFromScode(E_FAIL);

    DPF("(F) UnMarshalInterface called!!!\n");
    return hr;
}

STDMETHODIMP CAVIFile::CMarshalImpl::ReleaseMarshalData (THIS_ LPSTREAM pStm)
{
    HRESULT hr = NOERROR;
    IUnknown FAR * pUnk;

    hr = pStm->Read(&pUnk,sizeof(pUnk),NULL);
    DPF("(F) ReleaseMarshalData\n");
    if (hr == NOERROR)
        pUnk->Release();

    return hr;
}

STDMETHODIMP CAVIFile::CMarshalImpl::DisconnectObject (THIS_ DWORD dwReserved)
{
    HRESULT hr = NOERROR;

    return hr;
}


CAVIStream::CMarshalImpl::CMarshalImpl(
        CAVIStream FAR* pAVIStream)
{
        m_pAVIStream = pAVIStream;
}


STDMETHODIMP CAVIStream::CMarshalImpl::QueryInterface(
        const IID FAR&  iid,
        void FAR* FAR*  ppv)
{
        return m_pAVIStream->m_pUnknownOuter->QueryInterface(iid, ppv);
}

/*      -       -       -       -       -       -       -       -       */

STDMETHODIMP_(ULONG) CAVIStream::CMarshalImpl::AddRef()
{
        return m_pAVIStream->m_pUnknownOuter->AddRef();
}

/*      -       -       -       -       -       -       -       -       */

STDMETHODIMP_(ULONG) CAVIStream::CMarshalImpl::Release()
{
        return m_pAVIStream->m_pUnknownOuter->Release();
}

/*      -       -       -       -       -       -       -       -       */



// *** IMarshal methods ***
STDMETHODIMP CAVIStream::CMarshalImpl::GetUnmarshalClass (THIS_ REFIID riid, LPVOID pv,
                    DWORD dwDestContext, LPVOID pvDestContext,
                    DWORD mshlflags, LPCLSID pCid)
{
    HRESULT hr = NOERROR;
    IUnknown FAR * pUnk = &m_pAVIStream->m_Unknown;

    DPF("(S) UnMarshalClass called (context = %lx)\n", dwDestContext);
    *pCid = CLSID_AVISimpleUnMarshal;
    return hr;
}

STDMETHODIMP CAVIStream::CMarshalImpl::GetMarshalSizeMax (THIS_ REFIID riid, LPVOID pv,
                    DWORD dwDestContext, LPVOID pvDestContext,
                    DWORD mshlflags, LPDWORD pSize)
{
    HRESULT hr = NOERROR;
    IUnknown FAR * pUnk = &m_pAVIStream->m_Unknown;

    *pSize = sizeof(pUnk);

    return hr;
}

STDMETHODIMP CAVIStream::CMarshalImpl::MarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
                    LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
                    DWORD mshlflags)
{
    HRESULT hr = NOERROR;
    IUnknown FAR * pUnk = &m_pAVIStream->m_Unknown;

    DPF("MarshalInterface (S) called\n");
    if ((riid != IID_IAVIStream && riid != IID_IAVIStream && riid != IID_IUnknown))
        return ResultFromScode(E_INVALIDARG);

    if ((hr = pStm->Write(&pUnk, sizeof(pUnk), NULL)) == NOERROR)
        AddRef();

    DPF("Returns %lx\n", (DWORD) (LPVOID) hr);
    return hr;
}

STDMETHODIMP CAVIStream::CMarshalImpl::UnmarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
                    LPVOID FAR* ppv)
{
    HRESULT hr = ResultFromScode(E_FAIL);

    DPF("(S) UnMarshalInterface called!!!\n");
    return hr;
}

STDMETHODIMP CAVIStream::CMarshalImpl::ReleaseMarshalData (THIS_ LPSTREAM pStm)
{
    HRESULT hr = NOERROR;
    IUnknown FAR * pUnk;

    hr = pStm->Read(&pUnk,sizeof(pUnk),NULL);
    DPF("(S) ReleaseMarshalData\n");
    if (hr == NOERROR)
        pUnk->Release();

    return hr;
}

STDMETHODIMP CAVIStream::CMarshalImpl::DisconnectObject (THIS_ DWORD dwReserved)
{
    HRESULT hr = NOERROR;

    return hr;
}
#endif  // CUSTOMMARSHAL only


/***************************************************************************

  DecodeRle   - 'C' version

  Play back a RLE buffer into a DIB buffer

  returns
      none

 ***************************************************************************/

void DecodeRle(LPBITMAPINFOHEADER lpbi, BYTE _huge *pb, BYTE _huge *prle, DWORD dwInSize)
{
    BYTE    cnt;
    BYTE    b;
    WORD    x;
    WORD    dx,dy;
    DWORD   wWidthBytes;
    DWORD   dwOutSize;
    DWORD   dwJump;

    #define RLE_ESCAPE  0
    #define RLE_EOL     0
    #define RLE_EOF     1
    #define RLE_JMP     2
    #define RLE_RUN     3

#if 0
#ifndef _WIN32
    //
    // this uses ASM code found in RLEA.ASM
    //
    if (!(WinFlags & WF_CPU286))
        DecodeRle386(lpbi, pb, prle);
    else if (lpbi->biSizeImage < 65536l)
        DecodeRle286(lpbi, pb, prle);
    else
#endif
#endif
#define EatOutput(_x_) \
    {                            \
        if (dwOutSize < (_x_)) { \
            return;              \
        }                        \
        dwOutSize -= (_x_);      \
    }
#define EatInput(_x_) \
    {                            \
        if (dwInSize < (_x_)) {  \
            return;              \
        }                        \
        dwInSize -= (_x_);       \
    }

    if (lpbi->biHeight <= 0) {
        return;
    }
    {
        wWidthBytes = (WORD)lpbi->biWidth+3 & ~3;
        dwOutSize = wWidthBytes * (DWORD)lpbi->biHeight;

        x = 0;

        for(;;)
        {
            EatInput(2);
            cnt = *prle++;
            b   = *prle++;

            if (cnt == RLE_ESCAPE)
            {
                switch (b)
                {
                    case RLE_EOF:
                        return;

                    case RLE_EOL:
                        EatOutput(wWidthBytes - x);
                        pb += wWidthBytes - x;
                        x = 0;
                        break;

                    case RLE_JMP:
                        EatInput(2);
                        dx = (WORD)*prle++;
                        dy = (WORD)*prle++;

                        dwJump = (DWORD)wWidthBytes * dy + dx;
                        EatOutput(dwJump);
			pb += dwJump;
                        x  += dx;

                        break;

                    default:
                        cnt = b;
                        EatOutput(cnt);
                        EatInput(cnt);
                        x  += cnt;
                        while (cnt-- > 0)
                            *pb++ = *prle++;

                        if (b & 1) {
                            EatInput(1);
                            prle++;
                        }

                        break;
                }
            }
            else
            {
                x += cnt;
                EatOutput(cnt);

                while (cnt-- > 0)
                    *pb++ = b;
            }
        }
    }
}





CAVIFile::CPersistStorageImpl::CPersistStorageImpl(
        CAVIFile FAR*   pAVIFile)
{
        m_pAVIFile = pAVIFile;
}


STDMETHODIMP CAVIFile::CPersistStorageImpl::QueryInterface(
        const IID FAR&  iid,
        void FAR* FAR*  ppv)
{
        return m_pAVIFile->m_pUnknownOuter->QueryInterface(iid, ppv);
}

/*      -       -       -       -       -       -       -       -       */

STDMETHODIMP_(ULONG) CAVIFile::CPersistStorageImpl::AddRef()
{
        return m_pAVIFile->m_pUnknownOuter->AddRef();
}

/*      -       -       -       -       -       -       -       -       */

STDMETHODIMP_(ULONG) CAVIFile::CPersistStorageImpl::Release()
{
        return m_pAVIFile->m_pUnknownOuter->Release();
}

/*      -       -       -       -       -       -       -       -       */

        // *** IPersist methods ***
STDMETHODIMP CAVIFile::CPersistStorageImpl::GetClassID (LPCLSID lpClassID)
{
    CAVIFile FAR * pfile = m_pAVIFile;

    return NOERROR;
}

        // *** IPersistStorage methods ***
STDMETHODIMP CAVIFile::CPersistStorageImpl::IsDirty ()
{
    CAVIFile FAR * pfile = m_pAVIFile;

    if (pfile->fDirty)
        return NOERROR;
    else
        return ResultFromScode(S_FALSE);
}

STDMETHODIMP CAVIFile::CPersistStorageImpl::InitNew (LPSTORAGE pStg)
{
    CAVIFile FAR * pfile = m_pAVIFile;

    return NOERROR;
}

STDMETHODIMP CAVIFile::CPersistStorageImpl::Load (LPSTORAGE pStg)
{
    CAVIFile FAR * pfile = m_pAVIFile;

    return NOERROR;
}

STDMETHODIMP CAVIFile::CPersistStorageImpl::Save (LPSTORAGE pStgSave, BOOL fSameAsLoad)
{
    CAVIFile FAR * pfile = m_pAVIFile;

    return NOERROR;
}

STDMETHODIMP CAVIFile::CPersistStorageImpl::SaveCompleted (LPSTORAGE pStgNew)
{
    CAVIFile FAR * pfile = m_pAVIFile;


    return NOERROR;
}

STDMETHODIMP CAVIFile::CPersistStorageImpl::HandsOffStorage ()
{
    CAVIFile FAR * pfile = m_pAVIFile;

    return NOERROR;
}




CAVIFile::CPersistFileImpl::CPersistFileImpl(
        CAVIFile FAR*   pAVIFile)
{
        m_pAVIFile = pAVIFile;
}


STDMETHODIMP CAVIFile::CPersistFileImpl::QueryInterface(
        const IID FAR&  iid,
        void FAR* FAR*  ppv)
{
        return m_pAVIFile->m_pUnknownOuter->QueryInterface(iid, ppv);
}

/*      -       -       -       -       -       -       -       -       */

STDMETHODIMP_(ULONG) CAVIFile::CPersistFileImpl::AddRef()
{
        return m_pAVIFile->m_pUnknownOuter->AddRef();
}

/*      -       -       -       -       -       -       -       -       */

STDMETHODIMP_(ULONG) CAVIFile::CPersistFileImpl::Release()
{
        return m_pAVIFile->m_pUnknownOuter->Release();
}

/*      -       -       -       -       -       -       -       -       */

        // *** IPersist methods ***
STDMETHODIMP CAVIFile::CPersistFileImpl::GetClassID (LPCLSID lpClassID)
{
    CAVIFile FAR * pfile = m_pAVIFile;

    return NOERROR;
}

        // *** IPersistFile methods ***
STDMETHODIMP CAVIFile::CPersistFileImpl::IsDirty ()
{
    CAVIFile FAR * pfile = m_pAVIFile;

    if (pfile->fDirty)
        return NOERROR;
    else
        return ResultFromScode(S_FALSE);
}

STDMETHODIMP CAVIFile::CPersistFileImpl::Load (LPCOLESTR lpszFileName, DWORD grfMode)
{
    CAVIFile FAR * pfile = m_pAVIFile;
    UINT            ui;

    CLock tlock(pfile);

    if (pfile->achFile[0])
        return ResultFromScode(-1);

    pfile->mode = grfMode;
#if defined _WIN32 && !defined UNICODE
    WideCharToMultiByte(CP_ACP, 0, lpszFileName, -1,
                        pfile->achFile, NUMELMS(pfile->achFile), NULL, NULL);
#else
    lstrcpy(pfile->achFile, lpszFileName);
#endif
    // Assumptions about avilib.cpp:
    // We're assuming that if CREATE is set, WRITE is set too.
    // We're assuming that we'll always see READWRITE instead of just WRITE.

// If it ain't broke, don't fix it - who do I look like, the share flag
// standards enforcing committee?
#if 0
    // force the share flags to the 'correct' values
    if (grfMode & OF_READWRITE) {
        pfile->mode = (grfMode & ~(MMIO_SHAREMODE)) | OF_SHARE_EXCLUSIVE;
    } else {
        pfile->mode = (grfMode & ~(MMIO_SHAREMODE)) | OF_SHARE_DENY_WRITE;
    }
#endif

    // try to open the actual file
    // If the first attempt fails, no system error box, please.
    ui = SetErrorMode(SEM_NOOPENFILEERRORBOX);

    pfile->hshfile = shfileOpen(pfile->achFile, NULL, pfile->mode);

    if (!pfile->hshfile && ((grfMode & MMIO_RWMODE) == OF_READ)) {
        // if the open fails, try again without the share flags.
        pfile->mode &= ~(MMIO_SHAREMODE);

        pfile->hshfile = shfileOpen(pfile->achFile, NULL, pfile->mode);
    }
    SetErrorMode(ui);

    if (pfile->hshfile) {
        shfileAddRef(pfile->hshfile);  // compensate for later release of IPersistFile
        shfileAddRef(pfile->hshfile);  // compensate for later release of IPersistFile
    }

    return pfile->OpenInternal(grfMode);
}

STDMETHODIMP CAVIFile::CPersistFileImpl::Save (LPCOLESTR lpszFileName, BOOL fRemember)
{
    CAVIFile FAR * pfile = m_pAVIFile;

    return NOERROR;
}

STDMETHODIMP CAVIFile::CPersistFileImpl::SaveCompleted (LPCOLESTR lpszFileName)
{
    CAVIFile FAR * pfile = m_pAVIFile;

    return NOERROR;
}

STDMETHODIMP CAVIFile::CPersistFileImpl::GetCurFile (LPOLESTR FAR * lplpszFileName)
{
    CAVIFile FAR * pfile = m_pAVIFile;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\avifps.h ===
// avifps.h - AVIStream proxy / stub header

#include <ole2.h>
#include <cobjps.h>

#ifndef _WIN32
#include "olepriv.h"
#endif

enum {
    IAVISTREAM_Create = 0,
    IAVISTREAM_Info,
    IAVISTREAM_FindSample,
    IAVISTREAM_ReadFormat,
    IAVISTREAM_SetFormat,
    IAVISTREAM_Read,
    IAVISTREAM_Write,
    IAVISTREAM_Delete,
    IAVISTREAM_ReadData,
    IAVISTREAM_WriteData,
    IAVISTREAM_Reserved1,
    IAVISTREAM_Reserved2,
    IAVISTREAM_Reserved3,
    IAVISTREAM_Reserved4,
    IAVISTREAM_Reserved5,
    IAVISTREAM_SetInfo
};

// interface proxy for IAVIStream; always aggregated
class FAR CPrxAVIStream : public IAVIStream
{
public:
    static IRpcProxyBuffer FAR* Create(IUnknown FAR* pUnkOuter);

    // IUnknown methods (for external interface(s))
    STDMETHOD(QueryInterface) ( REFIID iid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    // IAVIStream methods
    STDMETHOD(Create)      (THIS_ LPARAM lParam1, LPARAM lParam2);
    STDMETHOD(Info)        (THIS_ AVISTREAMINFOW FAR * psi, LONG lSize);
    STDMETHOD_(LONG, FindSample)(THIS_ LONG lPos, LONG lFlags);
    STDMETHOD(ReadFormat)  (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG FAR *lpcbFormat);
    STDMETHOD(SetFormat)   (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG cbFormat);
    STDMETHOD(Read)        (THIS_ LONG lStart, LONG lSamples,
			    LPVOID lpBuffer, LONG cbBuffer,
			    LONG FAR * plBytes, LONG FAR * plSamples);
    STDMETHOD(Write)       (THIS_ LONG lStart, LONG lSamples,
			    LPVOID lpBuffer, LONG cbBuffer,
			    DWORD dwFlags,
			    LONG FAR *plSampWritten,
			    LONG FAR *plBytesWritten);
    STDMETHOD(Delete)      (THIS_ LONG lStart, LONG lSamples);
    STDMETHOD(ReadData)    (THIS_ DWORD fcc, LPVOID lp, LONG FAR *lpcb);
    STDMETHOD(WriteData)   (THIS_ DWORD fcc, LPVOID lp, LONG cb);
#ifdef _WIN32
    STDMETHODIMP SetInfo(AVISTREAMINFOW FAR *lpInfo, LONG cbInfo);
#else
    STDMETHOD(Reserved1)   (THIS);
    STDMETHOD(Reserved2)   (THIS);
    STDMETHOD(Reserved3)   (THIS);
    STDMETHOD(Reserved4)   (THIS);
    STDMETHOD(Reserved5)   (THIS);
#endif
    
private:
    CPrxAVIStream(IUnknown FAR* pUnkOuter);
    ~CPrxAVIStream();


    // IRpcProxyBuffer which is also the controlling unknown
    struct CProxyImpl : IRpcProxyBuffer
	    {
public:
    CProxyImpl(CPrxAVIStream FAR* pPrxAVIStream)
	    { m_pPrxAVIStream = pPrxAVIStream; }

    STDMETHOD(QueryInterface)(REFIID iid, LPVOID FAR* ppv);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    STDMETHOD(Connect)(IRpcChannelBuffer FAR* pRpcChannelBuffer);
    STDMETHOD_(void, Disconnect)(void);

	    private:
		CPrxAVIStream FAR* m_pPrxAVIStream;
	    };
    friend CProxyImpl;

    CProxyImpl m_Proxy;


    // private state:
    ULONG		m_refs;
    IUnknown FAR*	m_pUnkOuter;
    IRpcChannelBuffer FAR*	m_pRpcChannelBuffer;
    AVISTREAMINFOW	m_sh;
};




// interface stub for IAVIStream
class FAR CStubAVIStream : public IRpcStubBuffer
{
public:
    static HRESULT Create(IUnknown FAR* pUnkObject, IRpcStubBuffer FAR* FAR* ppStub);

    STDMETHOD(QueryInterface) (REFIID iid, LPVOID FAR* ppv);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    STDMETHOD(Connect)(IUnknown FAR* pUnkObject);
    STDMETHOD_(void, Disconnect)(void);
    STDMETHOD(Invoke)(RPCOLEMESSAGE FAR *pMessage, IRpcChannelBuffer FAR *pChannel);
    STDMETHOD_(IRpcStubBuffer FAR *, IsIIDSupported)(REFIID iid);
    STDMETHOD_(ULONG, CountRefs)(void);
    STDMETHOD(DebugServerQueryInterface)(LPVOID FAR *ppv);
    STDMETHOD_(void, DebugServerRelease)(LPVOID pv);

private:	
    CStubAVIStream(void);
    ~CStubAVIStream(void);

    ULONG	    m_refs;

    IAVIStream FAR* m_pAVIStream;
};



// Proxy/Stub Factory for pssamp.dll: supports IPSFactory only.
class FAR CPSFactory : public IPSFactoryBuffer
{
public:
    CPSFactory();

    STDMETHOD(QueryInterface)(REFIID iid, LPVOID FAR* ppv);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    STDMETHOD(CreateProxy)(IUnknown FAR* pUnkOuter, REFIID iid,
			   IRpcProxyBuffer FAR* FAR* ppProxy, LPVOID FAR* ppv);
    STDMETHOD(CreateStub)(REFIID iid, IUnknown FAR* pUnkServer,
			  IRpcStubBuffer FAR* FAR* ppStub);

private:
    ULONG	m_refs;
};

DEFINE_AVIGUID(CLSID_AVIStreamPS,           0x0002000D, 0, 0);



enum {
    IAVIFILE_Open = 0,
    IAVIFILE_Info,
    IAVIFILE_GetStream,
    IAVIFILE_CreateStream,
    IAVIFILE_Save,
    IAVIFILE_ReadData,
    IAVIFILE_WriteData,
    IAVIFILE_EndRecord,
    IAVIFILE_Reserved1,
    IAVIFILE_Reserved2,
    IAVIFILE_Reserved3,
    IAVIFILE_Reserved4,
    IAVIFILE_Reserved5
};

// interface proxy for IAVIFile; always aggregated
class FAR CPrxAVIFile : public IAVIFile
{
public:
    static IRpcProxyBuffer FAR* Create(IUnknown FAR* pUnkOuter);

    // IUnknown methods (for external interface(s))
    STDMETHOD(QueryInterface) ( REFIID iid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    // IAVIFile methods
#ifndef _WIN32
    STDMETHOD(Open)		    (THIS_
                                     LPCTSTR szFile,
                                     UINT mode);
#endif
    STDMETHOD(Info)                 (THIS_
                                     AVIFILEINFOW FAR * pfi,
                                     LONG lSize);
    STDMETHOD(GetStream)            (THIS_
                                     PAVISTREAM FAR * ppStream,
				     DWORD fccType,
                                     LONG lParam);
    STDMETHOD(CreateStream)         (THIS_
                                     PAVISTREAM FAR * ppStream,
                                     AVISTREAMINFOW FAR * psi);
#ifndef _WIN32
    STDMETHOD(Save)                 (THIS_
                                     LPCTSTR szFile,
                                     AVICOMPRESSOPTIONS FAR *lpOptions,
                                     AVISAVECALLBACK lpfnCallback);
#endif
    STDMETHOD(WriteData)            (THIS_
                                     DWORD ckid,
                                     LPVOID lpData,
                                     LONG cbData);
    STDMETHOD(ReadData)             (THIS_
                                     DWORD ckid,
                                     LPVOID lpData,
                                     LONG FAR *lpcbData);
    STDMETHOD(EndRecord)            (THIS);
#ifdef _WIN32
    STDMETHODIMP DeleteStream            (THIS_
				     DWORD fccType,
				     LONG lParam);

#else
    STDMETHODIMP Reserved1            (THIS);
    STDMETHODIMP Reserved2            (THIS);
    STDMETHODIMP Reserved3            (THIS);
    STDMETHODIMP Reserved4            (THIS);
    STDMETHODIMP Reserved5            (THIS);
#endif


private:
    CPrxAVIFile(IUnknown FAR* pUnkOuter);
    ~CPrxAVIFile();


    // IRpcProxyBuffer which is also the controlling unknown
    struct CProxyImpl : IRpcProxyBuffer
	    {
public:
    CProxyImpl(CPrxAVIFile FAR* pPrxAVIFile)
	    { m_pPrxAVIFile = pPrxAVIFile; }

    STDMETHOD(QueryInterface)(REFIID iid, LPVOID FAR* ppv);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    STDMETHOD(Connect)(IRpcChannelBuffer FAR* pRpcChannelBuffer);
    STDMETHOD_(void, Disconnect)(void);

	    private:
		CPrxAVIFile FAR* m_pPrxAVIFile;
	    };
    friend CProxyImpl;

    CProxyImpl m_Proxy;


    // private state:
    ULONG		m_refs;
    IUnknown FAR*	m_pUnkOuter;
    IRpcChannelBuffer FAR*	m_pRpcChannelBuffer;
    AVIFILEINFOW	m_fi;
};




// interface stub for IAVIFile
class FAR CStubAVIFile : public IRpcStubBuffer
{
public:
    static HRESULT Create(IUnknown FAR* pUnkObject, IRpcStubBuffer FAR* FAR* ppStub);

    STDMETHOD(QueryInterface) (REFIID iid, LPVOID FAR* ppv);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    STDMETHOD(Connect)(IUnknown FAR* pUnkObject);
    STDMETHOD_(void, Disconnect)(void);
    STDMETHOD(Invoke)(RPCOLEMESSAGE FAR *pMessage, IRpcChannelBuffer FAR *pChannel);
    STDMETHOD_(IRpcStubBuffer FAR *, IsIIDSupported)(REFIID iid);
    STDMETHOD_(ULONG, CountRefs)(void);
    STDMETHOD(DebugServerQueryInterface)(LPVOID FAR *ppv);
    STDMETHOD_(void, DebugServerRelease)(LPVOID pv);

private:	
    CStubAVIFile(void);
    ~CStubAVIFile(void);

    ULONG	    m_refs;

    IAVIFile FAR* m_pAVIFile;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\avifps.cpp ===
// avifps.cpp - proxy and stub code for IAVIFile & IAVIStream
//
//
//  Copyright (c) 1993 - 1995 Microsoft Corporation.  All Rights Reserved.
//
// History:
//  Created by DavidMay         6/19/93
//
//
// What's in this file:
//
//  Code to enable "standard marshalling" of the IAVIFile and IAVIStream
//  interfaces, consisting of the following classes:
//
//  CPSFactory, derived from IPSFactory:
//      Proxy/stub factory, called from DllGetClassObject to create
//      the other classes.
//
//  CPrxAVIStream, derived from IAVIStream:
//      This class serves as a stand-in for the interface in the app that's
//      calling it.  Uses RPC to communicate with....
//
//  CStubAVIStream, derived from IRpcStubBuffer:
//      This class in the called app receives requests from the proxy
//      and forwards them to the actual implementation of the IAVIStream.
//
//  CPrxAVIFile & CStubAVIFile, just like the stream versions.
//
//
//  Also included:
//  The function TaskHasExistingProxies can be used by an application
//  before exiting to check whether any of its objects are being used
//  by other applications.  This is done by keeping track of what active
//  stubs exist within a given task context.
//

#include <win32.h>
#pragma warning(disable:4355)
#include <vfw.h>
#include "avifps.h"
#include "debug.h"

#include "olehack.h"

#ifndef _WIN32
#define PropagateResult(hrOld, scNew)   ResultFromScode(scNew)
#endif

// when thunking between 16-bit ansi and 32-bit unicode apps, the
// AVISTREAMINFO and AVIFILEINFO structures are different. What is transmitted
// is a common format that includes space for both unicode and ansi strings.
// ansi apps will not send or use the unicode strings. unicode apps will send
// both.

typedef struct _PS_STREAMINFO {
    DWORD               fccType;
    DWORD               fccHandler;
    DWORD               dwFlags;        /* Contains AVITF_* flags */
    DWORD               dwCaps;
    WORD                wPriority;
    WORD                wLanguage;
    DWORD               dwScale;
    DWORD               dwRate; /* dwRate / dwScale == samples/second */
    DWORD               dwStart;
    DWORD               dwLength; /* In units above... */
    DWORD               dwInitialFrames;
    DWORD               dwSuggestedBufferSize;
    DWORD               dwQuality;
    DWORD               dwSampleSize;
    POINTS              ptFrameTopLeft;
    POINTS              ptFrameBottomRight;
    DWORD               dwEditCount;
    DWORD               dwFormatChangeCount;
    char                szName[64];
    DWORD               bHasUnicode;
    WCHAR               szUnicodeName[64];
} PS_STREAMINFO, FAR * LPPS_STREAMINFO;

typedef struct _PS_FILEINFO {
    DWORD               dwMaxBytesPerSec;       // max. transfer rate
    DWORD               dwFlags;                // the ever-present flags
    DWORD               dwCaps;
    DWORD               dwStreams;
    DWORD               dwSuggestedBufferSize;

    DWORD               dwWidth;
    DWORD               dwHeight;

    DWORD               dwScale;        
    DWORD               dwRate; /* dwRate / dwScale == samples/second */
    DWORD               dwLength;

    DWORD               dwEditCount;

    char                szFileType[64];         // descriptive string for file type?
    DWORD               bHasUnicode;
    WCHAR               szUnicodeType[64];      
} PS_FILEINFO, FAR * LPPS_FILEINFO;



#ifndef _WIN32
//
// These constants are defined in the 32-bit UUID.LIB, but not
// in any 16-bit LIB.  They are stolen here from the .IDL files
// in the TYPES project.
//
extern "C" {
const IID IID_IRpcStubBuffer = {0xD5F56AFC,0x593b,0x101A,{0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A}};
const IID IID_IRpcProxyBuffer = {0xD5F56A34,0x593b,0x101A,{0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A}};
const IID IID_IPSFactoryBuffer = {0xD5F569D0,0x593b,0x101A,{0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A}};
}
#endif

// functions for proxy/stub usage tracking; see end of this file.
void UnregisterStubUsage(void);
void RegisterStubUsage(void);
extern "C" BOOL FAR TaskHasExistingProxies(void);



#if 0   // this function is actually in classobj.cpp,
// but if this were a separate proxy/stub DLL, it would look like this.
STDAPI DllGetClassObject(const CLSID FAR&       rclsid,
                         const IID FAR& riid,
                         void FAR* FAR* ppv)
{
    HRESULT     hresult;

    DPF("DllGetClassObject\n");

    if (rclsid == CLSID_AVIStreamPS) {
        return (*ppv = (LPVOID)new CPSFactory()) != NULL
                ? NOERROR : ResultFromScode(E_OUTOFMEMORY);
    } else {
        return ResultFromScode(E_UNEXPECTED);
    }
}
#endif

/*
 *      IMPLEMENTATION of CPSFactory
 *
 *
 *  Note: This Factory supports proxies and stubs for two separate
 *  interfaces, IID_IAVIFile and IID_IAVIStream.
 */

CPSFactory::CPSFactory(void)
{
    m_refs = 1;
}



// controlling unknown for PSFactory
STDMETHODIMP CPSFactory::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (iid == IID_IUnknown || iid == IID_IPSFactoryBuffer)
    {
        *ppv = this;
        ++m_refs;
        return NOERROR;
    }
    else
    {
        *ppv = NULL;
        return ResultFromScode(E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG) CPSFactory::AddRef(void)
{
    return ++m_refs;
}

STDMETHODIMP_(ULONG) CPSFactory::Release(void)
{
    if (--m_refs == 0)
    {
        delete this;
        return 0;
    }

    return m_refs;
}


// create proxy for given interface
STDMETHODIMP CPSFactory::CreateProxy(IUnknown FAR* pUnkOuter, REFIID iid,
        IRpcProxyBuffer FAR* FAR* ppProxy, void FAR* FAR* ppv)
{
    IRpcProxyBuffer FAR* pProxy;
    HRESULT     hresult;

    *ppProxy = NULL;
    *ppv = NULL;

    if (pUnkOuter == NULL)
        return ResultFromScode(E_INVALIDARG);

    if (iid == IID_IAVIStream) {
        if ((pProxy = CPrxAVIStream::Create(pUnkOuter)) == NULL)
            return ResultFromScode(E_OUTOFMEMORY);
    } else if (iid == IID_IAVIFile) {
        if ((pProxy = CPrxAVIFile::Create(pUnkOuter)) == NULL)
            return ResultFromScode(E_OUTOFMEMORY);
    } else
        return ResultFromScode(E_NOINTERFACE);

    hresult = pProxy->QueryInterface(iid, ppv);

    if (hresult == NOERROR)
        *ppProxy = pProxy;                      // transfer ref to caller
    else
        pProxy->Release();                      // free proxy just created

    return hresult;
}



// create stub for given interface
STDMETHODIMP CPSFactory::CreateStub(REFIID iid, IUnknown FAR* pUnkServer, IRpcStubBuffer FAR* FAR* ppStub)
{
    if (iid == IID_IAVIStream) {
        return CStubAVIStream::Create(pUnkServer, ppStub);
    } else if (iid == IID_IAVIFile) {
        return CStubAVIFile::Create(pUnkServer, ppStub);
    } else {
        *ppStub = NULL;
        return ResultFromScode(E_NOINTERFACE);
    }
}





/*
 *  IMPLEMENTATION of CPrxAVIStream
 *
 */


// create unconnected CPrxAVIStream; return controlling IProxy/IUnknokwn FAR*
IRpcProxyBuffer FAR* CPrxAVIStream::Create(IUnknown FAR* pUnkOuter)
{
    CPrxAVIStream FAR* pPrxAVIStream;

    if ((pPrxAVIStream = new CPrxAVIStream(pUnkOuter)) == NULL)
        return NULL;

    return &pPrxAVIStream->m_Proxy;
}


CPrxAVIStream::CPrxAVIStream(IUnknown FAR* pUnkOuter) : m_Proxy(this)
{
    // NOTE: could assert here since we should always be aggregated
    if (pUnkOuter == NULL)
        pUnkOuter = &m_Proxy;

    m_refs = 1;
    m_pUnkOuter = pUnkOuter;
    m_pRpcChannelBuffer = NULL;
    m_sh.fccType = 0;

    InitOle(TRUE);

    DPF("PrxStream %p: Usage++=%lx\n", (DWORD_PTR) (LPVOID) this, 1L);
}


CPrxAVIStream::~CPrxAVIStream(void)
{
    m_Proxy.Disconnect();

    TermOle();
}
                

// Methods for controlling unknown
STDMETHODIMP CPrxAVIStream::CProxyImpl::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (iid == IID_IUnknown || iid == IID_IRpcProxyBuffer)
        *ppv = (void FAR *)this;
    else if (iid ==  IID_IAVIStream)
        *ppv = (void FAR *)m_pPrxAVIStream;
    else {
        *ppv = NULL;
        return ResultFromScode(E_NOINTERFACE);
    }

    // simplest way to be correct: always addref the pointer we will return;
    // easy since all interfaces here are derived from IUnknown.
    ((IUnknown FAR*) *ppv)->AddRef();

    return NOERROR;
}

STDMETHODIMP_(ULONG) CPrxAVIStream::CProxyImpl::AddRef(void)
{
    return ++m_pPrxAVIStream->m_refs;
}

STDMETHODIMP_(ULONG) CPrxAVIStream::CProxyImpl::Release(void)
{
    if (--m_pPrxAVIStream->m_refs == 0)
    {
        delete m_pPrxAVIStream;
        return 0;
    }
    return m_pPrxAVIStream->m_refs;
}


// connect proxy to channel given
STDMETHODIMP CPrxAVIStream::CProxyImpl::Connect(IRpcChannelBuffer FAR* pRpcChannelBuffer)
{
    if (m_pPrxAVIStream->m_pRpcChannelBuffer != NULL)
        return ResultFromScode(E_UNEXPECTED);

    if (pRpcChannelBuffer == NULL)
        return ResultFromScode(E_INVALIDARG);

    (m_pPrxAVIStream->m_pRpcChannelBuffer = pRpcChannelBuffer)->AddRef();
    return NOERROR;
}


// disconnect proxy from any current channel
STDMETHODIMP_(void) CPrxAVIStream::CProxyImpl::Disconnect(void)
{
    if (m_pPrxAVIStream->m_pRpcChannelBuffer)
    {
        m_pPrxAVIStream->m_pRpcChannelBuffer->Release();
        m_pPrxAVIStream->m_pRpcChannelBuffer = NULL;
    }
}



// IUnknown methods for external interface(s); always delegate
STDMETHODIMP CPrxAVIStream::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    return m_pUnkOuter->QueryInterface(iid, ppv);
}

STDMETHODIMP_(ULONG) CPrxAVIStream::AddRef(void)
{
    DPF("PrxStream %p: Usage++=%lx\n", (DWORD_PTR) (LPVOID) this, m_refs + 1);
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CPrxAVIStream::Release(void)
{
    DPF("PrxStream %p: Usage--=%lx\n", (DWORD_PTR) (LPVOID) this, m_refs - 1);
    return m_pUnkOuter->Release();
}



// IAVIStream interface methods

STDMETHODIMP CPrxAVIStream::Create(LPARAM lParam1, LPARAM lParam2)
{
    return ResultFromScode(E_NOTIMPL);
}

#ifdef _WIN32
STDMETHODIMP CPrxAVIStream::Info(AVISTREAMINFOW FAR * psi, LONG lSize)
#else
STDMETHODIMP CPrxAVIStream::Info(AVISTREAMINFO FAR * psi, LONG lSize)
#endif
{
    HRESULT hrMarshal;
    HRESULT hrMethod = NOERROR;
    IRpcChannelBuffer FAR* pChannel = m_pRpcChannelBuffer;
    RPCOLEMESSAGE Message;

    _fmemset(&Message, 0, sizeof(Message));

    if (pChannel == NULL)
        return ResultFromScode(RPC_E_CONNECTION_TERMINATED);

    //
    // NOTE: We take advantage here of the fact that we assume the
    // stream is read-only and not being changed on the other end!
    //
    // To avoid some intertask calls, we assume that the result
    // of the Info() method will not change.
    //
    if (m_sh.fccType == 0) {

        // we might be talking to 16 or 32-bit stub, so we need to
        // exchange a common (superset) format and pick out the bits we need.

        // format in: lSize
        // format out: PS_STREAMINFO, hrMethod
        Message.cbBuffer = sizeof(lSize);
        Message.iMethod = IAVISTREAM_Info;
        
        if ((hrMarshal = pChannel->GetBuffer(&Message, IID_IAVIStream)) != NOERROR)
            goto ErrExit;

        ((DWORD FAR *)Message.Buffer)[0] = sizeof(PS_STREAMINFO);
        
        if ((hrMarshal = pChannel->SendReceive(&Message,(ULONG*) &hrMethod)) != NOERROR) {
            ;
ErrExit:
            return PropagateResult(hrMarshal, RPC_E_CLIENT_CANTMARSHAL_DATA);
        }

        hrMethod = ((HRESULT FAR *)Message.Buffer)[0];
        PS_STREAMINFO FAR * psinfo = (PS_STREAMINFO FAR *)
                        ((LPBYTE)Message.Buffer + sizeof(HRESULT));

        // get the bits we want
        m_sh.fccType    = psinfo->fccType;
        m_sh.fccHandler = psinfo->fccHandler;
        m_sh.dwFlags    = psinfo->dwFlags;        /* Contains AVITF_* flags */
        m_sh.dwCaps     = psinfo->dwCaps;
        m_sh.wPriority  = psinfo->wPriority;
        m_sh.wLanguage  = psinfo->wLanguage;
        m_sh.dwScale    = psinfo->dwScale;
        m_sh.dwRate     = psinfo->dwRate; /* dwRate / dwScale == samples/second */
        m_sh.dwStart    = psinfo->dwStart;
        m_sh.dwLength   = psinfo->dwLength; /* In units above... */
        m_sh.dwInitialFrames = psinfo->dwInitialFrames;
        m_sh.dwSuggestedBufferSize = psinfo->dwSuggestedBufferSize;
        m_sh.dwQuality  = psinfo->dwQuality;
        m_sh.dwSampleSize = psinfo->dwSampleSize;

        // RECTs are different sizes, so use POINTS (WORD point)
        m_sh.rcFrame.top = psinfo->ptFrameTopLeft.y;    
        m_sh.rcFrame.left = psinfo->ptFrameTopLeft.x;
        m_sh.rcFrame.bottom = psinfo->ptFrameBottomRight.y;     
        m_sh.rcFrame.right = psinfo->ptFrameBottomRight.x;

        m_sh.dwEditCount = psinfo->dwEditCount;
        m_sh.dwFormatChangeCount = psinfo->dwFormatChangeCount;

#ifdef _WIN32   
        // use unicode if we've been sent it
        if (psinfo->bHasUnicode) {
            _fmemcpy(m_sh.szName, psinfo->szUnicodeName, sizeof(m_sh.szName));
        } else {
            // need ansi->unicode thunk
            MultiByteToWideChar(
                CP_ACP, 0,
                psinfo->szName,
                -1,
                m_sh.szName,
                NUMELMS(m_sh.szName));
        }
#else
        // we only use the ansi which is always sent
        _fmemcpy(m_sh.szName, psinfo->szName, sizeof(m_sh.szName));
#endif

        pChannel->FreeBuffer(&Message);
    }

    _fmemcpy(psi, &m_sh, min((int) lSize, sizeof(m_sh)));

    return hrMethod;
}


STDMETHODIMP_(LONG) CPrxAVIStream::FindSample(LONG lPos, LONG lFlags)
{
    HRESULT hrMarshal;
    HRESULT hrMethod;
    IRpcChannelBuffer FAR* pChannel = m_pRpcChannelBuffer;
    LONG    lResult;

    if (pChannel == NULL)
        return -1; // !!! ResultFromScode(RPC_E_CONNECTION_TERMINATED);

    RPCOLEMESSAGE Message;

    _fmemset(&Message, 0, sizeof(Message));

    // format in: lPos, lFlags
    // format out: hrMethod, lResult
    Message.cbBuffer = sizeof(lPos) + sizeof(lFlags);
    Message.iMethod = IAVISTREAM_FindSample;

    if ((hrMarshal = pChannel->GetBuffer(&Message, IID_IAVIStream)) != NOERROR)
        goto ErrExit;

    ((DWORD FAR *)Message.Buffer)[0] = lPos;
    ((DWORD FAR *)Message.Buffer)[1] = lFlags;

    if ((hrMarshal = pChannel->SendReceive(&Message, (ULONG*) &hrMethod)) != NOERROR) {
        goto ErrExit;
    }

    hrMethod = ((HRESULT FAR *)Message.Buffer)[0];
    lResult = ((LONG FAR *)Message.Buffer)[1];

    pChannel->FreeBuffer(&Message);

    DPF("Proxy: FindSample (%ld) returns (%ld)\n", lPos, lResult);
    return lResult; // !!! hrMethod;

ErrExit:
    DPF("Proxy: FindSample returning error...\n");
    return -1; // !!! PropagateResult(hrMarshal, RPC_E_CLIENT_CANTMARSHAL_DATA);
}


STDMETHODIMP CPrxAVIStream::ReadFormat(LONG lPos, LPVOID lpFormat, LONG FAR *lpcbFormat)
{
    HRESULT hrMarshal;
    HRESULT hrMethod;
    IRpcChannelBuffer FAR* pChannel = m_pRpcChannelBuffer;

    if (pChannel == NULL)
        return ResultFromScode(RPC_E_CONNECTION_TERMINATED);

    // check that size is 0 if pointer is null
    if (lpFormat == NULL) {
        *lpcbFormat = 0;
    }

    // format in: dw, *lpcbFormat
    // format out: hrMethod, *lpcbFormat, format data

    RPCOLEMESSAGE Message;

    _fmemset(&Message, 0, sizeof(Message));

    Message.cbBuffer = sizeof(lPos) + sizeof(*lpcbFormat);
    Message.iMethod = IAVISTREAM_ReadFormat;

    if ((hrMarshal = pChannel->GetBuffer(&Message, IID_IAVIStream)) != NOERROR)
        goto ErrExit;

    ((DWORD FAR *)Message.Buffer)[0] = lPos;
    ((DWORD FAR *)Message.Buffer)[1] = lpFormat ? *lpcbFormat : 0;

    if ((hrMarshal = pChannel->SendReceive(&Message, (ULONG*) &hrMethod)) != NOERROR) {
        goto ErrExit;
    }

    hrMethod = ((HRESULT FAR *)Message.Buffer)[0];

    if (lpFormat && *lpcbFormat && hrMethod == NOERROR)
        hmemcpy(lpFormat, (LPBYTE) Message.Buffer + 2*sizeof(DWORD),
                min(*lpcbFormat, (long) ((DWORD FAR *) Message.Buffer)[1]));

    // write the size last, so we don't copy more than user's buffer
    *lpcbFormat = ((DWORD FAR *)Message.Buffer)[1];

    pChannel->FreeBuffer(&Message);

    return hrMethod;

ErrExit:
    return PropagateResult(hrMarshal, RPC_E_CLIENT_CANTMARSHAL_DATA);
}


STDMETHODIMP CPrxAVIStream::Read(
                 LONG       lStart,
                 LONG       lSamples,
                 LPVOID     lpBuffer,
                 LONG       cbBuffer,
                 LONG FAR * plBytes,
                 LONG FAR * plSamples)
{
    HRESULT hrMarshal;
    HRESULT hrMethod;
    IRpcChannelBuffer FAR* pChannel = m_pRpcChannelBuffer;
    LONG    lTemp;

    if (pChannel == NULL)
        return ResultFromScode(RPC_E_CONNECTION_TERMINATED);

    if (lpBuffer == NULL)
        cbBuffer = 0;

    // format on input: lPos, lLength, cb
    // format on output: hresult, samples, cb, frame
    RPCOLEMESSAGE Message;

    _fmemset(&Message, 0, sizeof(Message));

    Message.cbBuffer = sizeof(lStart) + sizeof(lSamples) + sizeof(cbBuffer);
    Message.iMethod = IAVISTREAM_Read;

    if ((hrMarshal = pChannel->GetBuffer(&Message, IID_IAVIStream)) != NOERROR)
        goto ErrExit;

    ((DWORD FAR *)Message.Buffer)[0] = lStart;
    ((DWORD FAR *)Message.Buffer)[1] = lSamples;
    ((DWORD FAR *)Message.Buffer)[2] = lpBuffer ? cbBuffer : 0;

    if ((hrMarshal = pChannel->SendReceive(&Message, (ULONG*) &hrMethod)) != NOERROR) {
        goto ErrExit;
    }

    hrMethod = ((HRESULT FAR *)Message.Buffer)[0];

    lTemp = ((DWORD FAR *)Message.Buffer)[1];
    if (plBytes)
        *plBytes = lTemp;

    if (plSamples)
        *plSamples = ((DWORD FAR *)Message.Buffer)[2];

    if (lpBuffer && lTemp && hrMethod == NOERROR)
        hmemcpy(lpBuffer, (LPBYTE) Message.Buffer + 3*sizeof(DWORD), lTemp);

    pChannel->FreeBuffer(&Message);

    return hrMethod;

ErrExit:
    return PropagateResult(hrMarshal, RPC_E_CLIENT_CANTMARSHAL_DATA);
}

//
// All of the writing-related messages are not remoted....
//
STDMETHODIMP CPrxAVIStream::SetFormat(LONG lPos,LPVOID lpFormat,LONG cbFormat)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIStream::Write(LONG lStart,
                                  LONG lSamples,
                                  LPVOID lpData,
                                  LONG cbData,
                                  DWORD dwFlags,
                                  LONG FAR *plSampWritten,
                                  LONG FAR *plBytesWritten)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIStream::Delete(LONG lStart,LONG lSamples)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIStream::ReadData(DWORD ckid, LPVOID lp, LONG FAR *lpcb)
{
    // !!! This should really be remoted!
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIStream::WriteData(DWORD ckid, LPVOID lp, LONG cb)
{
    return ResultFromScode(E_NOTIMPL);
}


#ifdef _WIN32
STDMETHODIMP CPrxAVIStream::SetInfo(AVISTREAMINFOW FAR *lpInfo, LONG cbInfo)
{
    return ResultFromScode(E_NOTIMPL);
}

#else
STDMETHODIMP CPrxAVIStream::Reserved1(void)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIStream::Reserved2(void)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIStream::Reserved3(void)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIStream::Reserved4(void)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIStream::Reserved5(void)
{
    return ResultFromScode(E_NOTIMPL);
}

#endif


/*
 *  IMPLEMENTATION of CStubAVIStream
 *      
 */

// create connected interface stub
HRESULT CStubAVIStream::Create(IUnknown FAR* pUnkObject, IRpcStubBuffer FAR* FAR* ppStub)
{
    CStubAVIStream FAR* pStubAVIStream;

    *ppStub = NULL;

    if ((pStubAVIStream = new CStubAVIStream()) == NULL)
        return ResultFromScode(E_OUTOFMEMORY);

    HRESULT hresult;
    if ((hresult = pStubAVIStream->Connect(pUnkObject)) != NOERROR)
    {
        pStubAVIStream->Release();
        return hresult;
    }

    *ppStub = pStubAVIStream;
    return NOERROR;
}


CStubAVIStream::CStubAVIStream(void)
{
    m_refs       = 1; /// !!! ??? 0
    DPF("StubStream %p: Usage++=%lx  (C)\n", (DWORD_PTR) (LPVOID) this, 1L);
    m_pAVIStream = NULL;
    RegisterStubUsage();
    InitOle(TRUE);
}


CStubAVIStream::~CStubAVIStream(void)
{
    UnregisterStubUsage();
    Disconnect();
    TermOle();
}


// controling unknown methods for interface stub
STDMETHODIMP CStubAVIStream::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{

    if (iid == IID_IUnknown || iid == IID_IRpcStubBuffer)
    {
        *ppv = this;
        DPF("StubStream %p: Usage++=%lx  (QI)\n", (DWORD_PTR) (LPVOID) this, m_refs + 1);
        ++m_refs;
        return NOERROR;
    }
    else
    {
        *ppv = NULL;
        return ResultFromScode(E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG) CStubAVIStream::AddRef(void)
{
    DPF("StubStream %p: Usage++=%lx\n", (DWORD_PTR) (LPVOID) this, m_refs + 1);
    return ++m_refs;
}

STDMETHODIMP_(ULONG) CStubAVIStream::Release(void)
{
    DPF("StubStream %p: Usage--=%lx\n", (DWORD_PTR) (LPVOID) this, m_refs - 1);
    if (--m_refs == 0)
    {
        if (m_pAVIStream) {
            DPF("Releasing stream in funny place!\n");
            m_pAVIStream->Release();
            m_pAVIStream = NULL;
        }
        delete this;
        return 0;
    }

    return m_refs;
}


// connect interface stub to server object
STDMETHODIMP CStubAVIStream::Connect(IUnknown FAR* pUnkObj)
{
    HRESULT     hr;

    if (m_pAVIStream)
        // call Disconnect first
        return ResultFromScode(E_UNEXPECTED);

    if (pUnkObj == NULL)
        return ResultFromScode(E_INVALIDARG);
                
    // NOTE: QI ensures out param is zero if error
    hr = pUnkObj->QueryInterface(IID_IAVIStream, (LPVOID FAR*)&m_pAVIStream);

    DPF("CStubAVIStream::Connect: Result = %lx, stream = %p\n", hr, (DWORD_PTR) m_pAVIStream);
    return hr;
}


// disconnect interface stub from server objec
STDMETHODIMP_(void) CStubAVIStream::Disconnect(void)
{
    DPF("CStubAVIStream::Disconnect\n");
    if (m_pAVIStream) {
        DPF("Disconnect: Releasing stream\n");
        m_pAVIStream->Release();
        m_pAVIStream = NULL;
    }
}


// remove method call
STDMETHODIMP CStubAVIStream::Invoke
        (RPCOLEMESSAGE FAR *pMessage, IRpcChannelBuffer FAR *pChannel)
{
    HRESULT     hresult;
    HRESULT     hrMethod;

    DPF("!AVISTREAM: Invoke: ");

    if (!m_pAVIStream) {
        DPF("!No stream!\n");
        return ResultFromScode(RPC_E_UNEXPECTED);
    }

#if 0
    if (iid != IID_IAVIStream) {
        DPF("!Wrong interface\n");

        return ResultFromScode(RPC_E_UNEXPECTED);
    }
#endif

    switch (pMessage->iMethod)
    {
        case IAVISTREAM_Info:
            // format on input: lSize
            // format on output: hresult, PS_STREAMINFO
        {
            DWORD lSize;
#ifdef _WIN32
            AVISTREAMINFOW si;
#else
            AVISTREAMINFO si;
#endif

            DPF("!Info\n");

            // need to send a common ansi/unicode version with both strings
            PS_STREAMINFO psinfo;
            hrMethod = m_pAVIStream->Info(&si, sizeof(si));

            // copy all members
            psinfo.fccType      = si.fccType;
            psinfo.fccHandler   = si.fccHandler;
            psinfo.dwFlags      = si.dwFlags;        /* Contains AVITF_* flags */
            psinfo.dwCaps       = si.dwCaps;
            psinfo.wPriority    = si.wPriority;
            psinfo.wLanguage    = si.wLanguage;
            psinfo.dwScale      = si.dwScale;
            psinfo.dwRate       = si.dwRate; /* dwRate / dwScale == samples/second */
            psinfo.dwStart      = si.dwStart;
            psinfo.dwLength     = si.dwLength; /* In units above... */
            psinfo.dwInitialFrames      = si.dwInitialFrames;
            psinfo.dwSuggestedBufferSize        = si.dwSuggestedBufferSize;
            psinfo.dwQuality    = si.dwQuality;
            psinfo.dwSampleSize = si.dwSampleSize;
            psinfo.dwEditCount  = si.dwEditCount;
            psinfo.dwFormatChangeCount  = si.dwFormatChangeCount;

            // RECT is different size, so use POINTS
            psinfo.ptFrameTopLeft.x = (short) si.rcFrame.left;
            psinfo.ptFrameTopLeft.y = (short) si.rcFrame.top;
            psinfo.ptFrameBottomRight.x = (short) si.rcFrame.right;
            psinfo.ptFrameBottomRight.y = (short) si.rcFrame.bottom;

#ifdef _WIN32   
            // send both UNICODE and ansi
            hmemcpy(psinfo.szUnicodeName, si.szName, sizeof(psinfo.szUnicodeName));
            psinfo.bHasUnicode = TRUE;
            WideCharToMultiByte(CP_ACP, 0,
                si.szName,
                -1,
                psinfo.szName,
                NUMELMS(psinfo.szName),
                NULL, NULL);
#else
            // just send ansi version for 16-bit stub
            psinfo.bHasUnicode = FALSE;
            hmemcpy(psinfo.szName, si.szName, sizeof(si.szName));
#endif

            lSize = ((DWORD FAR *)pMessage->Buffer)[0];


            pMessage->cbBuffer = lSize + sizeof(hrMethod);
        
            if ((hresult = pChannel->GetBuffer(pMessage, IID_IAVIStream)) != NOERROR)
                return PropagateResult(hresult, RPC_E_SERVER_CANTUNMARSHAL_DATA);

            ((HRESULT FAR *)pMessage->Buffer)[0] = hrMethod;

            hmemcpy((LPBYTE) pMessage->Buffer + sizeof(hrMethod),
                    &psinfo,
                    lSize);
                
            return NOERROR;
        }

        case IAVISTREAM_FindSample:
            // format on input: lPos, lFlags
            // format on output: hResult, lResult
        {
            LONG lPos, lFlags, lResult;

            lPos = ((DWORD FAR *)pMessage->Buffer)[0];
            lFlags = ((DWORD FAR *)pMessage->Buffer)[1];

            DPF("!FindSample (%ld)\n", lPos);
        
            lResult = m_pAVIStream->FindSample(lPos, lFlags);

            hrMethod = 0; // !!!

            pMessage->cbBuffer = sizeof(lResult) + sizeof(hrMethod);
        
            if ((hresult = pChannel->GetBuffer(pMessage, IID_IAVIStream)) != NOERROR)
                return PropagateResult(hresult, RPC_E_SERVER_CANTUNMARSHAL_DATA);

            ((HRESULT FAR *)pMessage->Buffer)[0] = hrMethod;
            ((DWORD FAR *)pMessage->Buffer)[1] = lResult;

            return NOERROR;
        }

        case IAVISTREAM_ReadFormat:
            // format on input: lPos, cbFormat
            // format on output: hresult, cbFormat, format
        {

            LONG cbIn;
            LONG cb;
            DWORD lPos;
            LPVOID lp;

            lPos = ((DWORD FAR *)pMessage->Buffer)[0];
            cb = cbIn = ((DWORD FAR *)pMessage->Buffer)[1];
        
            DPF("!ReadFormat (%ld)\n", lPos);
        
            pMessage->cbBuffer = sizeof(cbIn) + cbIn + sizeof(hrMethod);
        
            if ((hresult = pChannel->GetBuffer(pMessage, IID_IAVIStream)) != NOERROR)
                return PropagateResult(hresult, RPC_E_SERVER_CANTUNMARSHAL_DATA);

            lp = cbIn ? (LPBYTE) pMessage->Buffer + 2 * sizeof(DWORD) : NULL;
        
            hrMethod = m_pAVIStream->ReadFormat(lPos, lp, &cb);

            ((HRESULT FAR *)pMessage->Buffer)[0] = hrMethod;
            ((DWORD FAR *)pMessage->Buffer)[1] = cb;
            pMessage->cbBuffer = (ULONG)(sizeof(cbIn) + sizeof(hrMethod) +
                                 ((cb && cbIn) ? cb : 0));

            return NOERROR;
        }

        case IAVISTREAM_Read:
            // format on input: lPos, lSamples, cb
            // format on output: hresult, samples, cb, frame
        {

            LONG cb;
            LONG lPos, lSamples;
            LPVOID lp;


            lPos = ((DWORD FAR *)pMessage->Buffer)[0];
            lSamples = ((DWORD FAR *)pMessage->Buffer)[1];
            cb = ((DWORD FAR *)pMessage->Buffer)[2];
        
            DPF("!Read (%ld, %ld) ", lPos, lSamples);

            pMessage->cbBuffer = 3 * sizeof(DWORD) + cb;
        
            if ((hresult = pChannel->GetBuffer(pMessage, IID_IAVIStream)) != NOERROR)
                return PropagateResult(hresult, RPC_E_SERVER_CANTUNMARSHAL_DATA);

            lp = cb ? (LPBYTE) pMessage->Buffer + 3 * sizeof(DWORD) : NULL;

            DPF("! %ld bytes ", cb);

            hrMethod = m_pAVIStream->Read(lPos, lSamples, lp, cb, &cb, &lSamples);

            DPF("! -> %ld bytes\n", cb);

            ((HRESULT FAR *)pMessage->Buffer)[0] = hrMethod;
            ((DWORD FAR *)pMessage->Buffer)[1] = cb;
            ((DWORD FAR *)pMessage->Buffer)[2] = lSamples;

            return NOERROR;
        }

        default:
            // unknown method
        
            DPF("!Unknown method (%d)\n", pMessage->iMethod);

            return ResultFromScode(RPC_E_UNEXPECTED);
    }
}


// return TRUE if we support given interface
STDMETHODIMP_(IRpcStubBuffer FAR *) CStubAVIStream::IsIIDSupported(REFIID iid)
{
    // if we are connected, we have already checked for this interface;
    // if we are not connected, it doesn't matter.
    return iid == IID_IAVIStream ? (IRpcStubBuffer *) this : 0;
}


// returns number of refs we have to object
STDMETHODIMP_(ULONG) CStubAVIStream::CountRefs(void)
{
    // return 1 if connected; 0 if not.
    return m_pAVIStream != NULL;
}

STDMETHODIMP CStubAVIStream::DebugServerQueryInterface(LPVOID FAR *ppv)
{
    *ppv = m_pAVIStream;

    if (!m_pAVIStream) {
        DPF("!No stream!\n");
        return ResultFromScode(E_UNEXPECTED);
    }

    return NOERROR;
}

STDMETHODIMP_(void) CStubAVIStream::DebugServerRelease(LPVOID pv)
{


}




/*
 *  IMPLEMENTATION of CPrxAVIFile
 *
 */


// create unconnected CPrxAVIFile; return controlling IProxy/IUnknokwn FAR*
IRpcProxyBuffer FAR* CPrxAVIFile::Create(IUnknown FAR* pUnkOuter)
{
    CPrxAVIFile FAR* pPrxAVIFile;

    if ((pPrxAVIFile = new CPrxAVIFile(pUnkOuter)) == NULL)
                return NULL;

    return &pPrxAVIFile->m_Proxy;
}


CPrxAVIFile::CPrxAVIFile(IUnknown FAR* pUnkOuter) : m_Proxy(this)
{
    // NOTE: could assert here since we should always be aggregated
    if (pUnkOuter == NULL)
        pUnkOuter = &m_Proxy;

    m_refs = 1;
    m_pUnkOuter = pUnkOuter;
    m_pRpcChannelBuffer = NULL;
    m_fi.dwStreams = 0;
}


CPrxAVIFile::~CPrxAVIFile(void)
{
    m_Proxy.Disconnect();
}


// Methods for controlling unknown
STDMETHODIMP CPrxAVIFile::CProxyImpl::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (iid == IID_IUnknown || iid == IID_IRpcProxyBuffer)
        *ppv = (void FAR *)this;
    else if (iid ==  IID_IAVIFile)
        *ppv = (void FAR *)m_pPrxAVIFile;
    else
    {
        *ppv = NULL;
        return ResultFromScode(E_NOINTERFACE);
    }

    // simplest way to be correct: always addref the pointer we will return;
    // easy since all interfaces here are derived from IUnknown.
    ((IUnknown FAR*) *ppv)->AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CPrxAVIFile::CProxyImpl::AddRef(void)
{
    return ++m_pPrxAVIFile->m_refs;
}

STDMETHODIMP_(ULONG) CPrxAVIFile::CProxyImpl::Release(void)
{
    if (--m_pPrxAVIFile->m_refs == 0)
    {
        delete m_pPrxAVIFile;
        return 0;
    }
    return m_pPrxAVIFile->m_refs;
}


// connect proxy to channel given
STDMETHODIMP CPrxAVIFile::CProxyImpl::Connect(IRpcChannelBuffer FAR* pChannelChannelBuffer)
{
    if (m_pPrxAVIFile->m_pRpcChannelBuffer != NULL)
        return ResultFromScode(E_UNEXPECTED);

    if (pChannelChannelBuffer == NULL)
        return ResultFromScode(E_INVALIDARG);

    (m_pPrxAVIFile->m_pRpcChannelBuffer = pChannelChannelBuffer)->AddRef();
    return NOERROR;
}


// disconnect proxy from any current channel
STDMETHODIMP_(void) CPrxAVIFile::CProxyImpl::Disconnect(void)
{
    if (m_pPrxAVIFile->m_pRpcChannelBuffer)
    {
        m_pPrxAVIFile->m_pRpcChannelBuffer->Release();
        m_pPrxAVIFile->m_pRpcChannelBuffer = NULL;
    }
}



// IUnknown methods for external interface(s); always delegate
STDMETHODIMP CPrxAVIFile::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    return m_pUnkOuter->QueryInterface(iid, ppv);
}

STDMETHODIMP_(ULONG) CPrxAVIFile::AddRef(void)
{
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CPrxAVIFile::Release(void)
{
    return m_pUnkOuter->Release();
}



// IAVIFile interface methods

#ifdef _WIN32
STDMETHODIMP CPrxAVIFile::Info(AVIFILEINFOW FAR * psi, LONG lSize)
#else
STDMETHODIMP CPrxAVIFile::Info(AVIFILEINFO FAR * psi, LONG lSize)
#endif
{
    HRESULT hrMarshal;
    HRESULT hrMethod = NOERROR;
    IRpcChannelBuffer FAR* pChannel = m_pRpcChannelBuffer;

    if (pChannel == NULL)
        return ResultFromScode(RPC_E_CONNECTION_TERMINATED);

    if (m_fi.dwStreams == 0) {
        RPCOLEMESSAGE Message;

        _fmemset(&Message, 0, sizeof(Message));

        // format in: lSize
        // format out: hrMethod, PS_FILEINFO
        Message.cbBuffer = sizeof(lSize);
        Message.iMethod = IAVIFILE_Info;
        
        if ((hrMarshal = pChannel->GetBuffer(&Message, IID_IAVIFile)) != NOERROR)
            goto ErrExit;

        ((DWORD FAR *)Message.Buffer)[0] = sizeof(PS_FILEINFO);
        
        if ((hrMarshal = pChannel->SendReceive(&Message, (ULONG*) &hrMethod)) != NOERROR) {
            ;
ErrExit:
            return PropagateResult(hrMarshal, RPC_E_CLIENT_CANTMARSHAL_DATA);
        }

        hrMethod = ((HRESULT FAR *)Message.Buffer)[0];

        PS_FILEINFO FAR * psinfo = (PS_FILEINFO FAR *)
                        ((LPBYTE)Message.Buffer + sizeof(HRESULT));

        // get the bits we want
        m_fi.dwMaxBytesPerSec   = psinfo->dwMaxBytesPerSec;     // max. transfer rate
        m_fi.dwFlags    = psinfo->dwFlags;              // the ever-present flags
        m_fi.dwCaps     = psinfo->dwCaps;
        m_fi.dwStreams  = psinfo->dwStreams;
        m_fi.dwSuggestedBufferSize = psinfo->dwSuggestedBufferSize;
        m_fi.dwWidth    = psinfo->dwWidth;
        m_fi.dwHeight   = psinfo->dwHeight;
        m_fi.dwScale    = psinfo->dwScale;      
        m_fi.dwRate     = psinfo->dwRate;       /* dwRate / dwScale == samples/second */
        m_fi.dwLength   = psinfo->dwLength;
        m_fi.dwEditCount = psinfo->dwEditCount;


#ifdef _WIN32   
        // use unicode if we've been sent it
        if (psinfo->bHasUnicode) {
            _fmemcpy(m_fi.szFileType,
                psinfo->szUnicodeType, sizeof(m_fi.szFileType));
        } else {
            // need ansi->unicode thunk
            MultiByteToWideChar(
                CP_ACP, 0,
                psinfo->szFileType,
                -1,
                m_fi.szFileType,
                NUMELMS(m_fi.szFileType));
        }
#else
        // we only use the ansi which is always sent
        _fmemcpy(m_fi.szFileType, psinfo->szFileType, sizeof(m_fi.szFileType));
#endif

        pChannel->FreeBuffer(&Message);
    }

    _fmemcpy(psi, &m_fi, min((int) lSize, sizeof(m_fi)));

    return hrMethod;

}

#ifndef _WIN32
STDMETHODIMP CPrxAVIFile::Open(LPCTSTR szFile, UINT mode)
{
    return ResultFromScode(E_NOTIMPL);
}
#endif

STDMETHODIMP CPrxAVIFile::GetStream(PAVISTREAM FAR * ppStream,
                                     DWORD fccType,
                                     LONG lParam)
{
    HRESULT hrMarshal;
    HRESULT hrMethod = NOERROR;
    IRpcChannelBuffer FAR* pChannel = m_pRpcChannelBuffer;

    if (pChannel == NULL)
        return ResultFromScode(RPC_E_CONNECTION_TERMINATED);

    RPCOLEMESSAGE Message;

    _fmemset(&Message, 0, sizeof(Message));

    // format in: fccType lParam
    // format out: returned interface (marshalled)
    Message.cbBuffer = sizeof(fccType) + sizeof(lParam);
    Message.iMethod = IAVIFILE_GetStream;

    if ((hrMarshal = pChannel->GetBuffer(&Message, IID_IAVIFile)) != NOERROR)
        goto ErrExit;

    ((DWORD FAR *)Message.Buffer)[0] = fccType;
    ((DWORD FAR *)Message.Buffer)[1] = lParam;

    if ((hrMarshal = pChannel->SendReceive(&Message, (ULONG*) &hrMethod)) != NOERROR) {
        ;
ErrExit:
        return PropagateResult(hrMarshal, RPC_E_CLIENT_CANTMARSHAL_DATA);
    }

    hrMethod = ((HRESULT FAR *)Message.Buffer)[0];

    if (hrMethod == NOERROR) {
        HGLOBAL     h;
        LPSTREAM    pstm;

        h = GlobalAlloc(GHND, Message.cbBuffer - sizeof(hrMethod));

        hmemcpy(GlobalLock(h),
                (LPBYTE) Message.Buffer + sizeof(hrMethod),
                Message.cbBuffer - sizeof(hrMethod));

        CreateStreamOnHGlobal(h, FALSE, &pstm);
        
        CoUnmarshalInterface(pstm, IID_IAVIStream, (LPVOID FAR *) ppStream);

        pstm->Release();

        pChannel->FreeBuffer(&Message);
    }

    return hrMethod;
}

STDMETHODIMP CPrxAVIFile::CreateStream(
                                     PAVISTREAM FAR * ppStream,
#ifdef _WIN32
                                     AVISTREAMINFOW FAR * psi)
#else
                                     AVISTREAMINFO FAR * psi)
#endif
{
    return ResultFromScode(E_NOTIMPL);
}

#ifndef _WIN32
STDMETHODIMP CPrxAVIFile::Save(
                                     LPCTSTR szFile,
                                     AVICOMPRESSOPTIONS FAR *lpOptions,
                                     AVISAVECALLBACK lpfnCallback)
{

    return ResultFromScode(E_NOTIMPL);
}
#endif


STDMETHODIMP CPrxAVIFile::ReadData(DWORD ckid, LPVOID lp, LONG FAR *lpcb)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIFile::WriteData(DWORD ckid, LPVOID lp, LONG cb)
{
    return ResultFromScode(E_NOTIMPL);
}

STDMETHODIMP CPrxAVIFile::EndRecord()
{
    return ResultFromScode(E_NOTIMPL);
}

#ifdef _WIN32
STDMETHODIMP CPrxAVIFile::DeleteStream(DWORD fccType, LONG lParam)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}
#else
STDMETHODIMP CPrxAVIFile::Reserved1(void)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIFile::Reserved2(void)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIFile::Reserved3(void)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIFile::Reserved4(void)
{
    return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CPrxAVIFile::Reserved5(void)
{
    return ResultFromScode(E_NOTIMPL);
}

#endif


/*
 *  IMPLEMENTATION of CStubAVIFile
 *      
 */

// create connected interface stub
HRESULT CStubAVIFile::Create(IUnknown FAR* pUnkObject, IRpcStubBuffer FAR* FAR* ppStub)
{
        CStubAVIFile FAR* pStubAVIFile;

        *ppStub = NULL;

    if ((pStubAVIFile = new CStubAVIFile()) == NULL)
                return ResultFromScode(E_OUTOFMEMORY);

        HRESULT hresult;
        if ((hresult = pStubAVIFile->Connect(pUnkObject)) != NOERROR)
        {
                pStubAVIFile->Release();
                return hresult;
        }

        *ppStub = pStubAVIFile;
        return NOERROR;
}


CStubAVIFile::CStubAVIFile(void)
{
    m_refs = 1;
    m_pAVIFile = NULL;
    RegisterStubUsage();
}


CStubAVIFile::~CStubAVIFile(void)
{
    UnregisterStubUsage();
    Disconnect();
}


// controling unknown methods for interface stub
STDMETHODIMP CStubAVIFile::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{

    if (iid == IID_IUnknown || iid == IID_IRpcStubBuffer)
    {
        *ppv = this;
        ++m_refs;
        return NOERROR;
    }
    else
    {
        *ppv = NULL;
        return ResultFromScode(E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG) CStubAVIFile::AddRef(void)
{
        return ++m_refs;
}

STDMETHODIMP_(ULONG) CStubAVIFile::Release(void)
{
        if (--m_refs == 0)
        {
                delete this;
                return 0;
        }

        return m_refs;
}


// connect interface stub to server object
STDMETHODIMP CStubAVIFile::Connect(IUnknown FAR* pUnkObj)
{
        if (m_pAVIFile)
                // call Disconnect first
                return ResultFromScode(E_UNEXPECTED);

        if (pUnkObj == NULL)
                return ResultFromScode(E_INVALIDARG);
                
        // NOTE: QI ensures out param is zero if error
        return pUnkObj->QueryInterface(IID_IAVIFile, (LPVOID FAR*)&m_pAVIFile);
}


// disconnect interface stub from server objec
STDMETHODIMP_(void) CStubAVIFile::Disconnect(void)
{
        if (m_pAVIFile) {
                m_pAVIFile->Release();
                m_pAVIFile = NULL;
        }
}


// remove method call
STDMETHODIMP CStubAVIFile::Invoke
        (RPCOLEMESSAGE FAR *pMessage, IRpcChannelBuffer FAR *pChannel)
{
    HRESULT     hresult;
    HRESULT             hrMethod;
        
    if (!m_pAVIFile)
        return ResultFromScode(RPC_E_UNEXPECTED);

#if 0
    if (iid != IID_IAVIFile)
        return ResultFromScode(RPC_E_UNEXPECTED);
#endif

    switch (pMessage->iMethod)
    {
        case IAVIFILE_Info:
            // format on input: lSize
            // format on output: hresult, AVIFILEINFO
        {
            DWORD lSize;
#ifdef _WIN32
            AVIFILEINFOW si;
#else
            AVIFILEINFO si;
#endif
            PS_FILEINFO psinfo;
            hrMethod = m_pAVIFile->Info(&si, sizeof(si));

            // copy all members
            psinfo.dwMaxBytesPerSec     = si.dwMaxBytesPerSec;
            psinfo.dwFlags      = si.dwFlags;
            psinfo.dwCaps       = si.dwCaps;
            psinfo.dwStreams    = si.dwStreams;
            psinfo.dwSuggestedBufferSize        = si.dwSuggestedBufferSize;
            psinfo.dwWidth      = si.dwWidth;
            psinfo.dwHeight     = si.dwHeight;
            psinfo.dwScale      = si.dwScale;   
            psinfo.dwRate       = si.dwRate;
            psinfo.dwLength     = si.dwLength;
            psinfo.dwEditCount  = si.dwEditCount;

#ifdef _WIN32   
            // send both UNICODE and ansi
            hmemcpy(psinfo.szUnicodeType, si.szFileType, NUMELMS(psinfo.szFileType));
            psinfo.bHasUnicode = TRUE;
            WideCharToMultiByte(CP_ACP, 0,
                si.szFileType,
                -1,
                psinfo.szFileType,
                NUMELMS(psinfo.szFileType),
                NULL, NULL);
#else
            // just send ansi version for 16-bit stub
            psinfo.bHasUnicode = FALSE;
            hmemcpy(psinfo.szFileType, si.szFileType, sizeof(si.szFileType));
#endif

            lSize = ((DWORD FAR *)pMessage->Buffer)[0];

            pMessage->cbBuffer = lSize + sizeof(hrMethod);
        
            if ((hresult = pChannel->GetBuffer(pMessage, IID_IAVIStream)) != NOERROR)
                return PropagateResult(hresult, RPC_E_SERVER_CANTUNMARSHAL_DATA);

            ((HRESULT FAR *)pMessage->Buffer)[0] = hrMethod;

            hmemcpy((LPBYTE) pMessage->Buffer + sizeof(hrMethod),
                    &psinfo,
                    lSize);


            return NOERROR;
        }

        case IAVIFILE_GetStream:
            // format on input: fccType, lParam
            // format on output: marshalled IAVIStream pointer
        {
            DWORD           lParam, fccType;
            PAVISTREAM      ps;
            HGLOBAL         h;
            DWORD           dwDestCtx = 0;
            LPVOID          pvDestCtx = NULL;
            DWORD           cb;
            LPSTREAM        pstm;
        
            fccType = ((DWORD FAR *)pMessage->Buffer)[0];
            lParam = ((DWORD FAR *)pMessage->Buffer)[1];
        
            hrMethod = m_pAVIFile->GetStream(&ps, fccType, lParam);

            if (hrMethod == NOERROR) {

                pChannel->GetDestCtx(&dwDestCtx, &pvDestCtx);

#ifdef _WIN32
                cb = 0;
                CoGetMarshalSizeMax(&cb, IID_IAVIStream, ps,
                                    dwDestCtx, pvDestCtx, MSHLFLAGS_NORMAL);
#else
                cb = 800; // !!!!!!!
#endif

                h = GlobalAlloc(GHND, cb);

                CreateStreamOnHGlobal(h, FALSE, &pstm);

                CoMarshalInterface(pstm, IID_IAVIStream, ps,
                                   dwDestCtx, pvDestCtx, MSHLFLAGS_NORMAL);

                pstm->Release();
            } else
                cb = 0;

            pMessage->cbBuffer = cb + sizeof(hrMethod);
        
            if ((hresult = pChannel->GetBuffer(pMessage, IID_IAVIStream)) != NOERROR)
                return PropagateResult(hresult, RPC_E_SERVER_CANTUNMARSHAL_DATA);

            ((HRESULT FAR *)pMessage->Buffer)[0] = hrMethod;

            if (cb) {
                hmemcpy((LPBYTE) pMessage->Buffer + sizeof(hrMethod),
                        GlobalLock(h), cb);
                GlobalUnlock(h);
                GlobalFree(h);
            }

            return NOERROR;

        }


        default:
                // unknown method
                return ResultFromScode(RPC_E_UNEXPECTED);
        }
}


// return TRUE if we support given interface
STDMETHODIMP_(IRpcStubBuffer FAR *) CStubAVIFile::IsIIDSupported(REFIID iid)
{
        // if we are connected, we have already checked for this interface;
        // if we are not connected, it doesn't matter.
        return iid == IID_IAVIFile ? (IRpcStubBuffer *) this : 0;
}


// returns number of refs we have to object
STDMETHODIMP_(ULONG) CStubAVIFile::CountRefs(void)
{
        // return 1 if connected; 0 if not.
        return m_pAVIFile != NULL;
}



STDMETHODIMP CStubAVIFile::DebugServerQueryInterface(LPVOID FAR *ppv)
{
    *ppv = m_pAVIFile;

    if (!m_pAVIFile) {
        DPF("!No File!\n");
        return ResultFromScode(E_UNEXPECTED);
    }

    return NOERROR;
}

STDMETHODIMP_(void) CStubAVIFile::DebugServerRelease(LPVOID pv)
{


}



//
// The following functions exist to allow an application to determine
// if another application is using any of its objects.
//
// !!!!!!   I don't know if this really works.
//

#define MAXTASKCACHE    64
HTASK   ahtaskUsed[MAXTASKCACHE];
int     aiRefCount[MAXTASKCACHE];

void RegisterStubUsage(void)
{
    HTASK htask = GetCurrentTask();
    int i;

    for (i = 0; i < MAXTASKCACHE; i++) {
        if (ahtaskUsed[i] == htask) {
            ++aiRefCount[i];
            return;
        }
    }

    for (i = 0; i < MAXTASKCACHE; i++) {
        if (ahtaskUsed[i] == NULL) {
            ahtaskUsed[i] = htask;
            aiRefCount[i] = 1;
            return;
        }
    }

    DPF("Ack: Proxy cache full!\n");
}

void UnregisterStubUsage(void)
{
    HTASK htask = GetCurrentTask();
    int i;

    for (i = 0; i < MAXTASKCACHE; i++) {
        if (ahtaskUsed[i] == htask) {
            if (--aiRefCount[i] <= 0) {
                ahtaskUsed[i] = NULL;
                aiRefCount[i] = 0;
            }
            return;
        }
    }

    DPF("Ack: Proxy not in cache!\n");
}

BOOL FAR TaskHasExistingProxies(void)
{
    HTASK htask = GetCurrentTask();
    int i;

    for (i = 0; i < MAXTASKCACHE; i++) {
        if (ahtaskUsed[i] == htask) {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\avifile.h ===
/****************************************************************************
 *
 *  AVIFILE.H
 *
 *  routines for reading Standard AVI files
 *
 *  Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#if !defined( _AVIFILE_H_ )
#define _AVIFILE_H_

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

// begin_vfw32

/*
 * Ansi - Unicode thunking.
 *
 * Unicode or Ansi-only apps can call the avifile APIs.
 * any Win32 app who wants to use
 * any of the AVI COM interfaces must be UNICODE - the AVISTREAMINFO and
 * AVIFILEINFO structures used in the Info methods of these interfaces are
 * the unicode variants, and no thunking to or from ansi takes place
 * except in the AVIFILE api entrypoints.
 *
 * For Ansi/Unicode thunking: for each entrypoint or structure that
 * uses chars or strings, two versions are declared in the Win32 version,
 * ApiNameW and ApiNameA. The default name ApiName is #defined to one or
 * other of these depending on whether UNICODE is defined (during
 * compilation of the app that is including this header). The source will
 * contain ApiName and ApiNameA (with ApiName being the Win16 implementation,
 * and also #defined to ApiNameW, and ApiNameA being the thunk entrypoint).
 *
 */

#ifndef mmioFOURCC
    #define mmioFOURCC( ch0, ch1, ch2, ch3 ) \
	( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
	( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#ifndef streamtypeVIDEO
#define streamtypeVIDEO		mmioFOURCC('v', 'i', 'd', 's')
#define streamtypeAUDIO		mmioFOURCC('a', 'u', 'd', 's')
#define streamtypeMIDI		mmioFOURCC('m', 'i', 'd', 's')
#define streamtypeTEXT		mmioFOURCC('t', 'x', 't', 's')
#endif

#ifndef AVIIF_KEYFRAME
#define AVIIF_KEYFRAME      0x00000010L // this frame is a key frame.
#endif

// For GetFrame::SetFormat - use the best format for the display
#define AVIGETFRAMEF_BESTDISPLAYFMT	1

//
// Structures used by AVIStreamInfo & AVIFileInfo.
//
// These are related to, but not identical to, the header chunks
// in an AVI file.
//

/*
 *
 * --- AVISTREAMINFO ------------------------------------------------
 *
 * for Unicode/Ansi thunking we need to declare three versions of this!
 */
// end_vfw32
#ifdef _WIN32
// begin_vfw32
typedef struct _AVISTREAMINFOW {
    DWORD		fccType;
    DWORD               fccHandler;
    DWORD               dwFlags;        /* Contains AVITF_* flags */
    DWORD		dwCaps;
    WORD		wPriority;
    WORD		wLanguage;
    DWORD               dwScale;
    DWORD               dwRate; /* dwRate / dwScale == samples/second */
    DWORD               dwStart;
    DWORD               dwLength; /* In units above... */
    DWORD		dwInitialFrames;
    DWORD               dwSuggestedBufferSize;
    DWORD               dwQuality;
    DWORD               dwSampleSize;
    RECT                rcFrame;
    DWORD		dwEditCount;
    DWORD		dwFormatChangeCount;
    WCHAR		szName[64];
} AVISTREAMINFOW, FAR * LPAVISTREAMINFOW;

typedef struct _AVISTREAMINFOA {
    DWORD		fccType;
    DWORD               fccHandler;
    DWORD               dwFlags;        /* Contains AVITF_* flags */
    DWORD		dwCaps;
    WORD		wPriority;
    WORD		wLanguage;
    DWORD               dwScale;
    DWORD               dwRate; /* dwRate / dwScale == samples/second */
    DWORD               dwStart;
    DWORD               dwLength; /* In units above... */
    DWORD		dwInitialFrames;
    DWORD               dwSuggestedBufferSize;
    DWORD               dwQuality;
    DWORD               dwSampleSize;
    RECT                rcFrame;
    DWORD		dwEditCount;
    DWORD		dwFormatChangeCount;
    char		szName[64];
} AVISTREAMINFOA, FAR * LPAVISTREAMINFOA;

#ifdef UNICODE
#define AVISTREAMINFO	AVISTREAMINFOW
#define LPAVISTREAMINFO	LPAVISTREAMINFOW
#else
#define AVISTREAMINFO	AVISTREAMINFOA
#define LPAVISTREAMINFO	LPAVISTREAMINFOA
#endif

// end_vfw32

#else //win16 variant

#define AVISTREAMINFOW	AVISTREAMINFO
typedef struct _AVISTREAMINFO {
    DWORD		fccType;
    DWORD               fccHandler;
    DWORD               dwFlags;        /* Contains AVITF_* flags */
    DWORD		dwCaps;
    WORD		wPriority;
    WORD		wLanguage;
    DWORD               dwScale;
    DWORD               dwRate; /* dwRate / dwScale == samples/second */
    DWORD               dwStart;
    DWORD               dwLength; /* In units above... */
    DWORD		dwInitialFrames;
    DWORD               dwSuggestedBufferSize;
    DWORD               dwQuality;
    DWORD               dwSampleSize;
    RECT                rcFrame;
    DWORD		dwEditCount;
    DWORD		dwFormatChangeCount;
    char		szName[64];
} AVISTREAMINFO, FAR * LPAVISTREAMINFO;

#endif

// begin_vfw32

#define AVISTREAMINFO_DISABLED			0x00000001
#define AVISTREAMINFO_FORMATCHANGES		0x00010000

/*
 * --- AVIFILEINFO ----------------------------------------------------
 *
 */

// end_vfw32

#ifdef _WIN32

// begin_vfw32

typedef struct _AVIFILEINFOW {
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwCaps;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;

    DWORD		dwWidth;
    DWORD		dwHeight;

    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwLength;

    DWORD		dwEditCount;

    WCHAR		szFileType[64];		// descriptive string for file type?
} AVIFILEINFOW, FAR * LPAVIFILEINFOW;

typedef struct _AVIFILEINFOA {
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwCaps;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;

    DWORD		dwWidth;
    DWORD		dwHeight;

    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwLength;

    DWORD		dwEditCount;

    char		szFileType[64];		// descriptive string for file type?
} AVIFILEINFOA, FAR * LPAVIFILEINFOA;

#ifdef UNICODE
#define AVIFILEINFO	AVIFILEINFOW
#define LPAVIFILEINFO	LPAVIFILEINFOW
#else
#define AVIFILEINFO	AVIFILEINFOA
#define LPAVIFILEINFO	LPAVIFILEINFOA
#endif

// end_vfw32

#else  // win16 variant

#define AVIFILEINFOW	AVIFILEINFO
typedef struct _AVIFILEINFO {
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwCaps;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;

    DWORD		dwWidth;
    DWORD		dwHeight;

    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwLength;

    DWORD		dwEditCount;

    char		szFileType[64];		// descriptive string for file type?
} AVIFILEINFO, FAR * LPAVIFILEINFO;

#endif

// begin_vfw32

// Flags for dwFlags
#define AVIFILEINFO_HASINDEX		0x00000010
#define AVIFILEINFO_MUSTUSEINDEX	0x00000020
#define AVIFILEINFO_ISINTERLEAVED	0x00000100
#define AVIFILEINFO_WASCAPTUREFILE	0x00010000
#define AVIFILEINFO_COPYRIGHTED		0x00020000

// Flags for dwCaps
#define AVIFILECAPS_CANREAD		0x00000001
#define AVIFILECAPS_CANWRITE		0x00000002
#define AVIFILECAPS_ALLKEYFRAMES	0x00000010
#define AVIFILECAPS_NOCOMPRESSION	0x00000020

typedef BOOL (FAR PASCAL * AVISAVECALLBACK)(int);

/************************************************************************/
/* Declaration for the AVICOMPRESSOPTIONS structure.  Make sure it 	*/
/* matches the AutoDoc in avisave.c !!!                            	*/
/************************************************************************/

typedef struct {
    DWORD	fccType;		    /* stream type, for consistency */
    DWORD       fccHandler;                 /* compressor */
    DWORD       dwKeyFrameEvery;            /* keyframe rate */
    DWORD       dwQuality;                  /* compress quality 0-10,000 */
    DWORD       dwBytesPerSecond;           /* bytes per second */
    DWORD       dwFlags;                    /* flags... see below */
    LPVOID      lpFormat;                   /* save format */
    DWORD       cbFormat;
    LPVOID      lpParms;                    /* compressor options */
    DWORD       cbParms;
    DWORD       dwInterleaveEvery;          /* for non-video streams only */
} AVICOMPRESSOPTIONS, FAR *LPAVICOMPRESSOPTIONS;

//
// Defines for the dwFlags field of the AVICOMPRESSOPTIONS struct
// Each of these flags determines if the appropriate field in the structure
// (dwInterleaveEvery, dwBytesPerSecond, and dwKeyFrameEvery) is payed
// attention to.  See the autodoc in avisave.c for details.
//
#define AVICOMPRESSF_INTERLEAVE		0x00000001    // interleave
#define AVICOMPRESSF_DATARATE		0x00000002    // use a data rate
#define AVICOMPRESSF_KEYFRAMES		0x00000004    // use keyframes
#define AVICOMPRESSF_VALID		0x00000008    // has valid data?

// end_vfw32

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#include <vfw.h>


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

// begin2_vfw32

//
// functions
//

STDAPI_(void) AVIFileInit(void);   // Call this first!
STDAPI_(void) AVIFileExit(void);

STDAPI_(ULONG) AVIFileAddRef       (PAVIFILE pfile);
STDAPI_(ULONG) AVIFileRelease      (PAVIFILE pfile);

#ifdef _WIN32
STDAPI AVIFileOpenA       (PAVIFILE FAR * ppfile, LPCSTR szFile,
			  UINT uMode, LPCLSID lpHandler);
STDAPI AVIFileOpenW       (PAVIFILE FAR * ppfile, LPCWSTR szFile,
			  UINT uMode, LPCLSID lpHandler);
#ifdef UNICODE
#define AVIFileOpen	  AVIFileOpenW	
#else
#define AVIFileOpen	  AVIFileOpenA	
#endif
#else // win16
STDAPI AVIFileOpen       (PAVIFILE FAR * ppfile, LPCSTR szFile,
			  UINT uMode, LPCLSID lpHandler);
#define AVIFileOpenW	AVIFileOpen	    /* ;Internal */
#endif

#ifdef _WIN32
STDAPI AVIFileInfoW (PAVIFILE pfile, LPAVIFILEINFOW pfi, LONG lSize);
STDAPI AVIFileInfoA (PAVIFILE pfile, LPAVIFILEINFOA pfi, LONG lSize);
#ifdef UNICODE
#define AVIFileInfo	AVIFileInfoW
#else
#define AVIFileInfo	AVIFileInfoA
#endif
#else //win16 version
STDAPI AVIFileInfo (PAVIFILE pfile, LPAVIFILEINFO pfi, LONG lSize);
#define AVIFileInfoW AVIFileInfo	    /* ;Internal */
#endif


STDAPI AVIFileGetStream     (PAVIFILE pfile, PAVISTREAM FAR * ppavi, DWORD fccType, LONG lParam);


#ifdef _WIN32
STDAPI AVIFileCreateStreamW (PAVIFILE pfile, PAVISTREAM FAR *ppavi, AVISTREAMINFOW FAR * psi);
STDAPI AVIFileCreateStreamA (PAVIFILE pfile, PAVISTREAM FAR *ppavi, AVISTREAMINFOA FAR * psi);
#ifdef UNICODE
#define AVIFileCreateStream	AVIFileCreateStreamW
#else
#define AVIFileCreateStream	AVIFileCreateStreamA
#endif
#else //win16 version
STDAPI AVIFileCreateStream(PAVIFILE pfile, PAVISTREAM FAR *ppavi, AVISTREAMINFO FAR * psi);
#define AVIFileCreateStreamW AVIFileCreateStream	    /* ;Internal */
#endif

STDAPI AVIFileWriteData	(PAVIFILE pfile,
					 DWORD ckid,
					 LPVOID lpData,
					 LONG cbData);
STDAPI AVIFileReadData	(PAVIFILE pfile,
					 DWORD ckid,
					 LPVOID lpData,
					 LONG FAR *lpcbData);
STDAPI AVIFileEndRecord	(PAVIFILE pfile);

STDAPI_(ULONG) AVIStreamAddRef       (PAVISTREAM pavi);
STDAPI_(ULONG) AVIStreamRelease      (PAVISTREAM pavi);

// end2_vfw32

#ifdef _WIN32
// begin2_vfw32
STDAPI AVIStreamInfoW (PAVISTREAM pavi, LPAVISTREAMINFOW psi, LONG lSize);
STDAPI AVIStreamInfoA (PAVISTREAM pavi, LPAVISTREAMINFOA psi, LONG lSize);
#ifdef UNICODE
#define AVIStreamInfo	AVIStreamInfoW
#else
#define AVIStreamInfo	AVIStreamInfoA
#endif
// end2_vfw32
#else // win16
STDAPI AVIStreamInfo (PAVISTREAM pavi, LPAVISTREAMINFO psi, LONG lSize);
#define AVIStreamInfoW AVIStreamInfo		/* ;Internal */
#endif

// begin2_vfw32

STDAPI_(LONG) AVIStreamFindSample(PAVISTREAM pavi, LONG lPos, LONG lFlags);
STDAPI AVIStreamReadFormat   (PAVISTREAM pavi, LONG lPos,LPVOID lpFormat,LONG FAR *lpcbFormat);
STDAPI AVIStreamSetFormat    (PAVISTREAM pavi, LONG lPos,LPVOID lpFormat,LONG cbFormat);
STDAPI AVIStreamReadData     (PAVISTREAM pavi, DWORD fcc, LPVOID lp, LONG FAR *lpcb);
STDAPI AVIStreamWriteData    (PAVISTREAM pavi, DWORD fcc, LPVOID lp, LONG cb);

STDAPI AVIStreamRead         (PAVISTREAM pavi,
			      LONG lStart,
			      LONG lSamples,
			      LPVOID lpBuffer,
			      LONG cbBuffer,
			      LONG FAR * plBytes,
			      LONG FAR * plSamples);
#define AVISTREAMREAD_CONVENIENT	(-1L)

STDAPI AVIStreamWrite        (PAVISTREAM pavi,
			      LONG lStart, LONG lSamples,
			      LPVOID lpBuffer, LONG cbBuffer, DWORD dwFlags,
			      LONG FAR *plSampWritten,
			      LONG FAR *plBytesWritten);

// Right now, these just use AVIStreamInfo() to get information, then
// return some of it.  Can they be more efficient?
STDAPI_(LONG) AVIStreamStart        (PAVISTREAM pavi);
STDAPI_(LONG) AVIStreamLength       (PAVISTREAM pavi);
STDAPI_(LONG) AVIStreamTimeToSample (PAVISTREAM pavi, LONG lTime);
STDAPI_(LONG) AVIStreamSampleToTime (PAVISTREAM pavi, LONG lSample);


STDAPI AVIStreamBeginStreaming(PAVISTREAM pavi, LONG lStart, LONG lEnd, LONG lRate);
STDAPI AVIStreamEndStreaming(PAVISTREAM pavi);

//
// helper functions for using IGetFrame
//
STDAPI_(PGETFRAME) AVIStreamGetFrameOpen(PAVISTREAM pavi,
					 LPBITMAPINFOHEADER lpbiWanted);
STDAPI_(LPVOID) AVIStreamGetFrame(PGETFRAME pg, LONG lPos);
STDAPI AVIStreamGetFrameClose(PGETFRAME pg);


// !!! We need some way to place an advise on a stream....
// STDAPI AVIStreamHasChanged   (PAVISTREAM pavi);



// Shortcut function
// end2_vfw32
#ifdef _WIN32
// begin2_vfw32
STDAPI AVIStreamOpenFromFileA(PAVISTREAM FAR *ppavi, LPCSTR szFile,
			     DWORD fccType, LONG lParam,
			     UINT mode, CLSID FAR *pclsidHandler);
STDAPI AVIStreamOpenFromFileW(PAVISTREAM FAR *ppavi, LPCWSTR szFile,
			     DWORD fccType, LONG lParam,
			     UINT mode, CLSID FAR *pclsidHandler);
#ifdef UNICODE
#define AVIStreamOpenFromFile	AVIStreamOpenFromFileW
#else
#define AVIStreamOpenFromFile	AVIStreamOpenFromFileA
#endif
// end2_vfw32
#else // win16
STDAPI AVIStreamOpenFromFile(PAVISTREAM FAR *ppavi, LPCSTR szFile,
			     DWORD fccType, LONG lParam,
			     UINT mode, CLSID FAR *pclsidHandler);
#define AVIStreamOpenFromFileW AVIStreamOpenFromFile	/* ;Internal */
#endif
// begin2_vfw32

// Use to create disembodied streams
STDAPI AVIStreamCreate(PAVISTREAM FAR *ppavi, LONG lParam1, LONG lParam2,
		       CLSID FAR *pclsidHandler);



// PHANDLER    AVIAPI AVIGetHandler         (PAVISTREAM pavi, PAVISTREAMHANDLER psh);
// PAVISTREAM  AVIAPI AVIGetStream          (PHANDLER p);

//
// flags for AVIStreamFindSample
//
#define FIND_DIR        0x0000000FL     // direction
#define FIND_NEXT       0x00000001L     // go forward
#define FIND_PREV       0x00000004L     // go backward
#define FIND_FROM_START 0x00000008L     // start at the logical beginning

#define FIND_TYPE       0x000000F0L     // type mask
#define FIND_KEY        0x00000010L     // find key frame.
#define FIND_ANY        0x00000020L     // find any (non-empty) sample
#define FIND_FORMAT     0x00000040L     // find format change

#define FIND_RET        0x0000F000L     // return mask
#define FIND_POS        0x00000000L     // return logical position
#define FIND_LENGTH     0x00001000L     // return logical size
#define FIND_OFFSET     0x00002000L     // return physical position
#define FIND_SIZE       0x00003000L     // return physical size
#define FIND_INDEX      0x00004000L     // return physical index position


//
//  stuff to support backward compat.
//
#define AVIStreamFindKeyFrame AVIStreamFindSample
#define FindKeyFrame	FindSample

#define AVIStreamClose AVIStreamRelease
#define AVIFileClose   AVIFileRelease
#define AVIStreamInit  AVIFileInit
#define AVIStreamExit  AVIFileExit

#define SEARCH_NEAREST  FIND_PREV
#define SEARCH_BACKWARD FIND_PREV
#define SEARCH_FORWARD  FIND_NEXT
#define SEARCH_KEY      FIND_KEY
#define SEARCH_ANY      FIND_ANY

//
//  helper macros.
//
#define     AVIStreamSampleToSample(pavi1, pavi2, l) \
            AVIStreamTimeToSample(pavi1,AVIStreamSampleToTime(pavi2, l))

#define     AVIStreamNextSample(pavi, l) \
            AVIStreamFindSample(pavi,l+1,FIND_NEXT|FIND_ANY)

#define     AVIStreamPrevSample(pavi, l) \
            AVIStreamFindSample(pavi,l-1,FIND_PREV|FIND_ANY)

#define     AVIStreamNearestSample(pavi, l) \
            AVIStreamFindSample(pavi,l,FIND_PREV|FIND_ANY)

#define     AVIStreamNextKeyFrame(pavi,l) \
            AVIStreamFindSample(pavi,l+1,FIND_NEXT|FIND_KEY)

#define     AVIStreamPrevKeyFrame(pavi, l) \
            AVIStreamFindSample(pavi,l-1,FIND_PREV|FIND_KEY)

#define     AVIStreamNearestKeyFrame(pavi, l) \
            AVIStreamFindSample(pavi,l,FIND_PREV|FIND_KEY)

#define     AVIStreamIsKeyFrame(pavi, l) \
            (AVIStreamNearestKeyFrame(pavi,l) == l)

#define     AVIStreamPrevSampleTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamPrevSample(pavi,AVIStreamTimeToSample(pavi,t)))

#define     AVIStreamNextSampleTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamNextSample(pavi,AVIStreamTimeToSample(pavi,t)))

#define     AVIStreamNearestSampleTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamNearestSample(pavi,AVIStreamTimeToSample(pavi,t)))

#define     AVIStreamNextKeyFrameTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamNextKeyFrame(pavi,AVIStreamTimeToSample(pavi, t)))

#define     AVIStreamPrevKeyFrameTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamPrevKeyFrame(pavi,AVIStreamTimeToSample(pavi, t)))

#define     AVIStreamNearestKeyFrameTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamNearestKeyFrame(pavi,AVIStreamTimeToSample(pavi, t)))

#define     AVIStreamStartTime(pavi) \
            AVIStreamSampleToTime(pavi, AVIStreamStart(pavi))

#define     AVIStreamLengthTime(pavi) \
            AVIStreamSampleToTime(pavi, AVIStreamLength(pavi))

#define     AVIStreamEnd(pavi) \
            (AVIStreamStart(pavi) + AVIStreamLength(pavi))

#define     AVIStreamEndTime(pavi) \
            AVIStreamSampleToTime(pavi, AVIStreamEnd(pavi))

#define     AVIStreamSampleSize(pavi, lPos, plSize) \
	    AVIStreamRead(pavi,lPos,1,NULL,0,plSize,NULL)

#define     AVIStreamFormatSize(pavi, lPos, plSize) \
            AVIStreamReadFormat(pavi,lPos,NULL,plSize)

#define     AVIStreamDataSize(pavi, fcc, plSize) \
            AVIStreamReadData(pavi,fcc,NULL,plSize)

/****************************************************************************
 *
 *  AVISave routines and structures
 *
 ***************************************************************************/

#ifndef comptypeDIB
#define comptypeDIB         mmioFOURCC('D', 'I', 'B', ' ')
#endif

STDAPI AVIMakeCompressedStream(
		PAVISTREAM FAR *	    ppsCompressed,
		PAVISTREAM		    ppsSource,
		AVICOMPRESSOPTIONS FAR *    lpOptions,
		CLSID FAR *pclsidHandler);

// end2_vfw32
#ifdef _WIN32
// begin2_vfw32
EXTERN_C HRESULT CDECL AVISaveA (LPCSTR               szFile,
		CLSID FAR *pclsidHandler,
		AVISAVECALLBACK     lpfnCallback,
		int                 nStreams,
		PAVISTREAM	    pfile,
		LPAVICOMPRESSOPTIONS lpOptions,
		...);

STDAPI AVISaveVA(LPCSTR               szFile,
		CLSID FAR *pclsidHandler,
		AVISAVECALLBACK     lpfnCallback,
		int                 nStreams,
		PAVISTREAM FAR *    ppavi,
		LPAVICOMPRESSOPTIONS FAR *plpOptions);
EXTERN_C HRESULT CDECL AVISaveW (LPCWSTR               szFile,
		CLSID FAR *pclsidHandler,
		AVISAVECALLBACK     lpfnCallback,
		int                 nStreams,
		PAVISTREAM	    pfile,
		LPAVICOMPRESSOPTIONS lpOptions,
		...);

STDAPI AVISaveVW(LPCWSTR               szFile,
		CLSID FAR *pclsidHandler,
		AVISAVECALLBACK     lpfnCallback,
		int                 nStreams,
		PAVISTREAM FAR *    ppavi,
		LPAVICOMPRESSOPTIONS FAR *plpOptions);
#ifdef UNICODE
#define AVISave		AVISaveW
#define AVISaveV	AVISaveVW
#else
#define AVISave		AVISaveA
#define AVISaveV	AVISaveVA
#endif
// end2_vfw32
#else // Win16
EXTERN_C HRESULT CDECL AVISave (LPCSTR               szFile,
		CLSID FAR *pclsidHandler,
		AVISAVECALLBACK     lpfnCallback,
		int                 nStreams,
		PAVISTREAM	    pfile,
		LPAVICOMPRESSOPTIONS lpOptions,
		...);

STDAPI AVISaveV(LPCSTR               szFile,
		CLSID FAR *pclsidHandler,
		AVISAVECALLBACK     lpfnCallback,
		int                 nStreams,
		PAVISTREAM FAR *    ppavi,
		LPAVICOMPRESSOPTIONS FAR *plpOptions);

#endif
// begin2_vfw32



STDAPI_(INT_PTR) AVISaveOptions(HWND hwnd,
			     UINT	uiFlags,
			     int	nStreams,
			     PAVISTREAM FAR *ppavi,
			     LPAVICOMPRESSOPTIONS FAR *plpOptions);

STDAPI AVISaveOptionsFree(int nStreams,
			     LPAVICOMPRESSOPTIONS FAR *plpOptions);

// FLAGS FOR uiFlags:
//
// Same as the flags for ICCompressorChoose (see compman.h)
// These determine what the compression options dialog for video streams
// will look like.

// end2_vfw32
#ifdef _WIN32
// begin2_vfw32
STDAPI AVIBuildFilterW(LPWSTR lpszFilter, LONG cbFilter, BOOL fSaving);
STDAPI AVIBuildFilterA(LPSTR lpszFilter, LONG cbFilter, BOOL fSaving);
#ifdef UNICODE
#define AVIBuildFilter	AVIBuildFilterW
#else
#define AVIBuildFilter	AVIBuildFilterA
#endif
// end2_vfw32
#else //win16
STDAPI AVIBuildFilter(LPSTR lpszFilter, LONG cbFilter, BOOL fSaving);
#endif

// begin2_vfw32
STDAPI AVIMakeFileFromStreams(PAVIFILE FAR *	ppfile,
			       int		nStreams,
			       PAVISTREAM FAR *	papStreams);

STDAPI AVIMakeStreamFromClipboard(UINT cfFormat, HANDLE hGlobal, PAVISTREAM FAR *ppstream);

/****************************************************************************
 *
 *  Clipboard routines
 *
 ***************************************************************************/

STDAPI AVIPutFileOnClipboard(PAVIFILE pf);

STDAPI AVIGetFromClipboard(PAVIFILE FAR * lppf);

STDAPI AVIClearClipboard(void);

/****************************************************************************
 *
 *  Editing routines
 *
 ***************************************************************************/
STDAPI CreateEditableStream(
		PAVISTREAM FAR *	    ppsEditable,
		PAVISTREAM		    psSource);

STDAPI EditStreamCut(PAVISTREAM pavi, LONG FAR *plStart, LONG FAR *plLength, PAVISTREAM FAR * ppResult);

STDAPI EditStreamCopy(PAVISTREAM pavi, LONG FAR *plStart, LONG FAR *plLength, PAVISTREAM FAR * ppResult);

STDAPI EditStreamPaste(PAVISTREAM pavi, LONG FAR *plPos, LONG FAR *plLength, PAVISTREAM pstream, LONG lStart, LONG lEnd);

STDAPI EditStreamClone(PAVISTREAM pavi, PAVISTREAM FAR *ppResult);


// end2_vfw32
#ifdef _WIN32
// begin2_vfw32
STDAPI EditStreamSetNameA(PAVISTREAM pavi, LPCSTR lpszName);
STDAPI EditStreamSetNameW(PAVISTREAM pavi, LPCWSTR lpszName);
STDAPI EditStreamSetInfoW(PAVISTREAM pavi, LPAVISTREAMINFOW lpInfo, LONG cbInfo);
STDAPI EditStreamSetInfoA(PAVISTREAM pavi, LPAVISTREAMINFOA lpInfo, LONG cbInfo);
#ifdef UNICODE
#define EditStreamSetInfo	EditStreamSetInfoW
#define EditStreamSetName	EditStreamSetNameW
#else
#define EditStreamSetInfo	EditStreamSetInfoA
#define EditStreamSetName	EditStreamSetNameA
#endif
// end2_vfw32
#else // win16
STDAPI EditStreamSetInfo(PAVISTREAM pavi, LPAVISTREAMINFO lpInfo, LONG cbInfo);
#define EditStreamSetInfoW EditStreamSetInfo	    /* ;Internal */
STDAPI EditStreamSetName(PAVISTREAM pavi, LPCSTR lpszName);
#define EditStreamSetNameW EditStreamSetName	    /* ;Internal */
#endif


#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif

// begin2_vfw32

/*	-	-	-	-	-	-	-	-	*/

#ifndef AVIERR_OK
#define AVIERR_OK               0L

#define MAKE_AVIERR(error)	MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x4000 + error)

// !!! Questions to be answered:
// How can you get a string form of these errors?
// Which of these errors should be replaced by errors in SCODE.H?
#define AVIERR_UNSUPPORTED      MAKE_AVIERR(101)
#define AVIERR_BADFORMAT        MAKE_AVIERR(102)
#define AVIERR_MEMORY           MAKE_AVIERR(103)
#define AVIERR_INTERNAL         MAKE_AVIERR(104)
#define AVIERR_BADFLAGS         MAKE_AVIERR(105)
#define AVIERR_BADPARAM         MAKE_AVIERR(106)
#define AVIERR_BADSIZE          MAKE_AVIERR(107)
#define AVIERR_BADHANDLE        MAKE_AVIERR(108)
#define AVIERR_FILEREAD         MAKE_AVIERR(109)
#define AVIERR_FILEWRITE        MAKE_AVIERR(110)
#define AVIERR_FILEOPEN         MAKE_AVIERR(111)
#define AVIERR_COMPRESSOR       MAKE_AVIERR(112)
#define AVIERR_NOCOMPRESSOR     MAKE_AVIERR(113)
#define AVIERR_READONLY		MAKE_AVIERR(114)
#define AVIERR_NODATA		MAKE_AVIERR(115)
#define AVIERR_BUFFERTOOSMALL	MAKE_AVIERR(116)
#define AVIERR_CANTCOMPRESS	MAKE_AVIERR(117)
#define AVIERR_USERABORT        MAKE_AVIERR(198)
#define AVIERR_ERROR            MAKE_AVIERR(199)
#endif
// end2_vfw32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\avifilei.h ===
#include "extra.h"
#include "fileshar.h"
#include "aviidx.h"
#include "buffer.h"
#include <ole2.h>
/*	-	-	-	-	-	-	-	-	*/

/*
**	Copyright (C) Microsoft Corporation 1993-1995. All rights reserved.
*/

/*	-	-	-	-	-	-	-	-	*/


#define	CFactoryImpl	CI	// Can't handle long exported names
#define	CAVIFileImpl	CF	// Can't handle long exported names
#define	CAVIStreamImpl	CS	// Can't handle long exported names

/* Remove warning of using object during initialization. */
#pragma warning(disable:4355)

#ifndef OLESTR	    // work with old OLE headers
typedef char      OLECHAR;
typedef LPSTR     LPOLESTR;
typedef LPCSTR    LPCOLESTR;
#define OLESTR(str) str
#endif


/*	-	-	-	-	-	-	-	-	*/

#define	implement	struct
#define	implementations	private

/*
** _StdClassImplementations
** Defines the standard implementations for a class object.
*/

#define	_StdClassImplementations(Impl)	\
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppv);	\
	STDMETHODIMP_(ULONG) AddRef();	\
	STDMETHODIMP_(ULONG) Release()


/*	-	-	-	-	-	-	-	-	*/

class FAR CAVIFileCF {
public:
    static HRESULT Create(const CLSID FAR& rclsid, REFIID riid, LPVOID FAR* ppv);
private:
    CAVIFileCF(const CLSID FAR& rclsid, IUnknown FAR* FAR* ppUnknown);
implementations:
    implement CUnknownImpl : IUnknown {
    public:
	_StdClassImplementations(CUnknownImpl);
	CUnknownImpl(CAVIFileCF FAR* pAVIFileCF);
    private:
	CAVIFileCF FAR*	m_pAVIFileCF;
	ULONG	m_refs;
    };
    implement CFactoryImpl : IClassFactory {
    public:
	_StdClassImplementations(CFactoryImpl);
	CFactoryImpl(CAVIFileCF FAR* pAVIFileCF);
	STDMETHODIMP CreateInstance(IUnknown FAR* pUnknownOuter, REFIID riid, LPVOID FAR* ppv);
	STDMETHODIMP LockServer(BOOL fLock);
    private:
	CAVIFileCF FAR*	m_pAVIFileCF;
    };
public:
    CUnknownImpl	m_Unknown;
    CFactoryImpl	m_Factory;
public:
    CLSID	m_clsid;
};

/*	-	-	-	-	-	-	-	-	*/

class FAR CAVIFile;

class FAR CAVIStream {
public:
    CAVIStream(IUnknown FAR* pUnknownOuter, IUnknown FAR* FAR* ppUnknown);
    ~CAVIStream();
private:
implementations:
    implement CUnknownImpl : IUnknown {
    public:
	_StdClassImplementations(CUnknownImpl);
	CUnknownImpl(CAVIStream FAR* pAVIStream);
    private:
	CAVIStream FAR*	m_pAVIStream;
	ULONG	m_refs;
    };
    implement CAVIStreamImpl : IAVIStream {
    public:
	_StdClassImplementations(CAVIStreamImpl);
	CAVIStreamImpl(CAVIStream FAR* pAVIStream);
	~CAVIStreamImpl();
	STDMETHODIMP Create      (THIS_ LPARAM lParam1, LPARAM lParam2);
	STDMETHODIMP Info        (THIS_ AVISTREAMINFOW FAR * psi, LONG lSize);
        STDMETHODIMP_(LONG) FindSample(THIS_ LONG lPos, LONG lFlags);
	STDMETHODIMP ReadFormat  (THIS_ LONG lPos,
				LPVOID lpFormat, LONG FAR *cbFormat);
	STDMETHODIMP SetFormat   (THIS_ LONG lPos,
				LPVOID lpFormat, LONG cbFormat);
	STDMETHODIMP Read        (THIS_ LONG lStart, LONG lSamples,
				LPVOID lpBuffer, LONG cbBuffer,
				LONG FAR * plBytes, LONG FAR * plSamples);
	STDMETHODIMP Write       (THIS_ LONG lStart, LONG lSamples,
				  LPVOID lpBuffer, LONG cbBuffer,
				  DWORD dwFlags,
				  LONG FAR *plSampWritten,
				  LONG FAR *plBytesWritten);
	STDMETHODIMP Delete      (THIS_ LONG lStart, LONG lSamples);
	STDMETHODIMP ReadData    (THIS_ DWORD fcc, LPVOID lp, LONG FAR *lpcb);
	STDMETHODIMP WriteData   (THIS_ DWORD fcc, LPVOID lp, LONG cb);
#ifdef _WIN32
	STDMETHODIMP SetInfo(AVISTREAMINFOW FAR *lpInfo, LONG cbInfo);
#else
	STDMETHODIMP Reserved1            (THIS);
	STDMETHODIMP Reserved2            (THIS);
	STDMETHODIMP Reserved3            (THIS);
	STDMETHODIMP Reserved4            (THIS);
	STDMETHODIMP Reserved5            (THIS);
#endif
    private:
	void ReadPalette(LONG lPos, LONG lPal, LPRGBQUAD prgb);
	// private functions here?
	CAVIStream FAR*	m_pAVIStream;
    };
    implement CStreamingImpl : IAVIStreaming {
    public:
	_StdClassImplementations(CStreamingImpl);
	CStreamingImpl(CAVIStream FAR* pAVIStream);
	~CStreamingImpl();
	STDMETHODIMP Begin (THIS_
			  LONG  lStart,	
			  LONG  lEnd,	
			  LONG  lRate);
	STDMETHODIMP End   (THIS);
    private:
	// private functions here?
	CAVIStream FAR*	m_pAVIStream;
    };

#ifdef CUSTOMMARSHAL
    struct CMarshalImpl : IMarshal {
    public:
	CMarshalImpl(CAVIStream FAR* pAVIStream);
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// *** IMarshal methods ***
	STDMETHODIMP GetUnmarshalClass (THIS_ REFIID riid, LPVOID pv,
			    DWORD dwDestContext, LPVOID pvDestContext,
			    DWORD mshlflags, LPCLSID pCid);
	STDMETHODIMP GetMarshalSizeMax (THIS_ REFIID riid, LPVOID pv,
			    DWORD dwDestContext, LPVOID pvDestContext,
			    DWORD mshlflags, LPDWORD pSize);
	STDMETHODIMP MarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
			    LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
			    DWORD mshlflags);
	STDMETHODIMP UnmarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
			    LPVOID FAR* ppv);
	STDMETHODIMP ReleaseMarshalData (THIS_ LPSTREAM pStm);
	STDMETHODIMP DisconnectObject (THIS_ DWORD dwReserved);
	CAVIStream FAR*	m_pAVIStream;
    };
#endif	// CUSTOMMARSHAL

public:
    CUnknownImpl	m_Unknown;
    CAVIStreamImpl	m_AVIStream;
#ifdef CUSTOMMARSHAL
    CMarshalImpl	m_Marshal;
#endif
    CStreamingImpl	m_Streaming;

public:
    IUnknown FAR*	m_pUnknownOuter;

    // AVIStream Instance data
    AVISTREAMINFOW             avistream;      // stream info
    CAVIFile FAR *		pfile;
    int				iStream;

    PAVISTREAM                  paviBase;

    //
    //  stream instance data
    //
    HSHFILE                     hshfile;        // file I/O

    LONG                        lPal;           // last palette change
    RGBQUAD                     argbq[256];     // current palette

    LPVOID                      lpFormat;       // stream format
    LONG                        cbFormat;

    LPVOID                      lpData;         // stream handler data
    LONG                        cbData;

    EXTRA			extra;

    PBUFSYSTEM                  pb;

    BOOL                        fInit;

    PSTREAMINDEX                psx;
};

/*	-	-	-	-	-	-	-	-	*/
#define MAXSTREAMS		64


class FAR CAVIFile {
public:
    static HRESULT Create(IUnknown FAR* pUnknownOuter, REFIID riid, LPVOID FAR* ppv);

    STDMETHODIMP OpenInternal(DWORD mode);

private:
    CAVIFile(IUnknown FAR* pUnknownOuter, IUnknown FAR* FAR* ppUnknown);
implementations:
    implement CUnknownImpl : IUnknown {
    public:
	_StdClassImplementations(CUnknownImpl);
	CUnknownImpl(CAVIFile FAR* pAVIFile);
    private:
	CAVIFile FAR*	m_pAVIFile;
	ULONG	m_refs;
    };
    implement CAVIFileImpl : IAVIFile {
    public:
	_StdClassImplementations(CAVIFileImpl);
	CAVIFileImpl(CAVIFile FAR* pAVIFile);
	~CAVIFileImpl();
#ifndef _WIN32
	STDMETHODIMP Open		    (THIS_
					 LPCTSTR szFile,
					 UINT mode);
#endif
	STDMETHODIMP Info                 (THIS_
					 AVIFILEINFOW FAR * pfi,
					 LONG lSize);
	STDMETHODIMP GetStream            (THIS_
					 PAVISTREAM FAR * ppStream,
					 DWORD fccType,
					 LONG lParam);
	STDMETHODIMP CreateStream         (THIS_
					 PAVISTREAM FAR * ppStream,
					 AVISTREAMINFOW FAR * psi);
#ifndef _WIN32
	STDMETHODIMP Save                 (THIS_
					 LPCTSTR szFile,
					 AVICOMPRESSOPTIONS FAR *lpOptions,
					 AVISAVECALLBACK lpfnCallback);
#endif
	STDMETHODIMP WriteData            (THIS_
					 DWORD ckid,
					 LPVOID lpData,
					 LONG cbData);
	STDMETHODIMP ReadData             (THIS_
					 DWORD ckid,
					 LPVOID lpData,
					 LONG FAR *lpcbData);
	STDMETHODIMP EndRecord            (THIS);
#ifdef _WIN32
	STDMETHODIMP DeleteStream            (THIS_
					 DWORD fccType,
					 LONG lParam);

#else
	STDMETHODIMP Reserved1            (THIS);
	STDMETHODIMP Reserved2            (THIS);
	STDMETHODIMP Reserved3            (THIS);
	STDMETHODIMP Reserved4            (THIS);
	STDMETHODIMP Reserved5            (THIS);
#endif
    private:
	// private functions here?
	CAVIFile FAR*	m_pAVIFile;
    };

#ifdef CUSTOMMARSHAL
    struct CMarshalImpl : IMarshal {
    public:
	CMarshalImpl(CAVIFile FAR* pAVIFile);
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// *** IMarshal methods ***
	STDMETHODIMP GetUnmarshalClass (THIS_ REFIID riid, LPVOID pv,
			    DWORD dwDestContext, LPVOID pvDestContext,
			    DWORD mshlflags, LPCLSID pCid);
	STDMETHODIMP GetMarshalSizeMax (THIS_ REFIID riid, LPVOID pv,
			    DWORD dwDestContext, LPVOID pvDestContext,
			    DWORD mshlflags, LPDWORD pSize);
	STDMETHODIMP MarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
			    LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
			    DWORD mshlflags);
	STDMETHODIMP UnmarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
			    LPVOID FAR* ppv);
	STDMETHODIMP ReleaseMarshalData (THIS_ LPSTREAM pStm);
	STDMETHODIMP DisconnectObject (THIS_ DWORD dwReserved);
	CAVIFile FAR*	m_pAVIFile;
    };
#endif	// CUSTOMMARSHAL

    struct CPersistStorageImpl : IPersistStorage {
    public:
	CPersistStorageImpl(CAVIFile FAR* pAVIFile);
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// *** IPersist methods ***
	STDMETHODIMP GetClassID (LPCLSID lpClassID);

	// *** IPersistStorage methods ***
	STDMETHODIMP IsDirty ();
	STDMETHODIMP InitNew (LPSTORAGE pStg);
	STDMETHODIMP Load (LPSTORAGE pStg);
	STDMETHODIMP Save (LPSTORAGE pStgSave, BOOL fSameAsLoad);
	STDMETHODIMP SaveCompleted (LPSTORAGE pStgNew);
	STDMETHODIMP HandsOffStorage ();
	CAVIFile FAR*	m_pAVIFile;
    };

    struct CPersistFileImpl : IPersistFile {
    public:
	CPersistFileImpl(CAVIFile FAR* pAVIFile);
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// *** IPersist methods ***
	STDMETHODIMP GetClassID (LPCLSID lpClassID);

	// *** IPersistFile methods ***
	STDMETHODIMP IsDirty ();
	STDMETHODIMP Load (LPCOLESTR lpszFileName, DWORD grfMode);
	STDMETHODIMP Save (LPCOLESTR lpszFileName, BOOL fRemember);
	STDMETHODIMP SaveCompleted (LPCOLESTR lpszFileName);
	STDMETHODIMP GetCurFile (LPOLESTR FAR * lplpszFileName);
	
	CAVIFile FAR*	m_pAVIFile;
    };

public:
    CUnknownImpl	m_Unknown;
    CAVIFileImpl	m_AVIFile;
#ifdef CUSTOMMARSHAL
    CMarshalImpl	m_Marshal;
#endif
    CPersistStorageImpl	m_PersistS;
    CPersistFileImpl	m_PersistF;

public:
    IUnknown FAR*	m_pUnknownOuter;

    //
    //  AVIFile instance data
    //
    MainAVIHeader FARSTRUCT     avihdr;         // file info
    LONG			lHeaderSize;
    TCHAR			achFile[260];
    DWORD			mode;
    HSHFILE                     hshfile;          // file I/O
    LONG			lDataListStart;
    BOOL			fInRecord;
    LONG			lRecordIndex;
    MMCKINFO			ckRecord;
    LONG			lWriteLoc;
    EXTRA			extra;
    BOOL			fDirty;
    CAVIStream FAR *            ps[MAXSTREAMS];

    PAVIINDEX                   px;         // the index
    PBUFSYSTEM                  pb;

#ifdef _WIN32
    CRITICAL_SECTION		m_critsec;
#endif
};

// this class can be used to provide thread locking by declaring
// an automatic instance on the stack. The non-win32 class does nothing
class FAR CLock {

#ifdef _WIN32

private:
    LPCRITICAL_SECTION pcritsec;

public:
    CLock(CAVIFile FAR* pfile)
    {
	pcritsec = &pfile->m_critsec;
	EnterCriticalSection(pcritsec);
    };

    ~CLock()
    {
	if (pcritsec != NULL) {	    // Because we may explicitly leave before
				    // the automatic instance is destroyed
	    LeaveCriticalSection(pcritsec);
	}
    };

    // Normally we enter/leave the critical section automatically by
    // creating an automatic instance of the Class, and letting C++ call
    // the destructor when the instance goes out of scope.  Exit is
    // provided to allow the user to explicitly release the critsec.
    void Exit()
    {
	LPCRITICAL_SECTION ptmp = pcritsec;
	pcritsec = NULL;
	if (ptmp != NULL) {
	    LeaveCriticalSection(ptmp);
	}
    };
#else
public:
    CLock(CAVIFile FAR* pfile)
    {
    };
    ~CLock()
    {
    };
    void Exit()
    {
    };
#endif
};

#ifdef _WIN32
// for C files
#define EnterCrit(pfile)	(EnterCriticalSection(&pfile->m_critsec))
#define LeaveCrit(p)		(LeaveCriticalSection(&pfile->m_critsec))

#else
#define EnterCrit(p)
#define LeaveCrit(p)

#endif


/*
** The usage counter keeps track of the overall usage of objects based on
** implementations provided by the component. This allows one to determine
** when the implementation is no longer in use.
*/

extern UINT	uUseCount;
extern BOOL	fLocked;

/*	-	-	-	-	-	-	-	-	*/


DEFINE_AVIGUID(CLSID_ACMCmprs,		0x0002000F, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\avigraph.c ===
#include <win32.h>
#include <vfw.h>
#include "debug.h"

// !!! Note: doesn't take AVI File overhead into account
// !!! Doesn't take padding into account!


// AVIDataSize:
// Calculates the amount of data in the given PAVISTREAM
// from time msStart to msStart + ms
LONG AVIDataSize(PAVISTREAM ps, LONG msStart, LONG ms) 
{
    LONG    lBytes;
    LONG    l;

    LONG    sampStart;
    LONG    sampEnd;
    LONG    samp;

    AVISTREAMINFOW sinfo;
    HRESULT hr;
    
    sampStart = AVIStreamTimeToSample(ps, msStart);
    sampEnd = AVIStreamTimeToSample(ps, msStart + ms);

    AVIStreamInfoW(ps, &sinfo, sizeof(sinfo));
    
    if (sinfo.dwSampleSize > 0) {
	hr = AVIStreamRead(ps,
			   sampStart,
			   sampEnd - sampStart,
			   NULL, 0,
			   &lBytes, &l);

	if (hr != NOERROR)
	    return 0;
	    
	if (l != sampEnd - sampStart) {
            DPF("Ack: wrong number of samples!\n");
	}
    } else {
	lBytes = 0;

	for (samp = sampStart; samp < sampEnd; samp++) {
	    hr = AVIStreamSampleSize(ps, samp, &l);

	    if (hr != NOERROR)
		return 0;
	    
	    lBytes += l;
	}
    }
    
    return lBytes;
}

#define MAXSTREAMS  64

#define TIMEINT	    250
#define TIMELEN	    1000

STDAPI CalculateFileDataRate(PAVIFILE pf, LONG FAR *plMaxBytesPerSec)
{
    PAVISTREAM	aps[MAXSTREAMS];
    LONG	alMaxData[MAXSTREAMS];
    AVIFILEINFO	finfo;
    int		stream;
    HRESULT	hr;
    LONG	msecLength = 0;
    LONG	l;
    LONG	lStart;
    LONG	lDataSize;
    LONG	lMaxDataSize = 0;

    AVIFileInfo(pf, &finfo, sizeof(finfo));

    for (stream = 0; stream < (int) finfo.dwStreams; stream++) {
	hr = AVIFileGetStream(pf, &aps[stream], 0, stream);

	if (hr != NOERROR) {
	    while (--stream >= 0)
		AVIStreamRelease(aps[stream]);

	    return hr;
	}
	
	l = AVIStreamEndTime(aps[stream]);
	msecLength = max(l, msecLength);
	alMaxData[stream] = 0;
    }

    lStart = 0;

    DPF("Time\t\t\tData Rate\n");
    do {
	lStart += TIMEINT;
	
	lDataSize = 0;
	
	
	for (stream = 0; stream < (int) finfo.dwStreams; stream++) {
	    l = AVIDataSize(aps[stream], lStart, TIMELEN);

	    lDataSize += l;
	    
	    alMaxData[stream] = max(alMaxData[stream], l);
	}

	lMaxDataSize = max(lDataSize, lMaxDataSize);

#ifdef DEBUG
	if (lStart < 50 * TIMEINT) {  // print at most 50 debug lines....
	    DPF("%lu\t\t\t%lu\n", lStart, muldiv32(lDataSize, 1000, TIMELEN));
	}
#endif
    } while (lStart < msecLength);

    *plMaxBytesPerSec = muldiv32(lMaxDataSize, 1000, TIMELEN);

    DPF("Max data rate for file: %ld\n", muldiv32(lMaxDataSize, 1000, TIMELEN));
    for (stream = 0; stream < (int) finfo.dwStreams; stream++) {
	DPF("Max data rate for stream %u: %ld\n", stream, muldiv32(alMaxData[stream], 1000, TIMELEN));
	AVIStreamRelease(aps[stream]);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\aviidx.cpp ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1995. All rights reserved.

   AVIIDX.C - AVI Index stuff

*****************************************************************************/

#include <win32.h>      // Win16/32 porting
#include <vfw.h>
#include "aviidx.h"

#ifdef AVIIDX_READONLY
    #include "common.h"     // for DEBUG
#else
    #include "debug.h"      // for DEBUG
#endif


/***************************************************************************
 ***************************************************************************/

#define INDEXALLOC      512
#define STACK           _based(_segname("_STACK"))

/***************************************************************************
 ***************************************************************************/

//
// used by SearchIndex() to return where a sample is
//
typedef struct {
    LONG    lx;             // index position
    LONG    lPos;           // position in samples.
    LONG    lSize;          // size in samples.
    LONG    lOffset;        // file offset.
    LONG    lLength;        // size in bytes.
}   IDXPOS;

/***************************************************************************
 *
 * @doc INTERNAL
 *
 * @api PAVIINDEX | IndexAddFileIndex
 *
 *  add a bunch of entries from a AVIFILE index to the index.
 *
 ***************************************************************************/

EXTERN_C PAVIINDEX IndexAddFileIndex(PAVIINDEX px, AVIINDEXENTRY _huge *pidx, LONG cnt, LONG lAdjust, BOOL fRle)
{
    LONG        lx;
    LONG        l;
    LONG        lxRec;
    DWORD       ckid;
    UINT        stream;
    DWORD       offset;
    DWORD       length;
    UINT        flags;

    Assert(px);
    Assert(pidx);

    if (px == NULL || pidx == NULL)
        return NULL;

    Assert(sizeof(AVIINDEXENTRY) > sizeof(AVIIDX));

    //
    // grow the index if needed.
    //
    if (px->nIndex + cnt > px->nIndexSize) {

        LONG grow = px->nIndex + cnt - px->nIndexSize;
        LPVOID p;

        if (grow < INDEXALLOC)
            grow = INDEXALLOC;

        p = (LPVOID)GlobalReAllocPtr(px,sizeof(AVIINDEX) +
                (px->nIndexSize + grow) * sizeof(AVIIDX),
		GMEM_MOVEABLE | GMEM_SHARE);

	if (!p)
            return NULL;
	
        px = (PAVIINDEX)p;
        px->nIndexSize += grow;
    }

    for (lxRec=-1,l=0; l < cnt; l++,pidx++) {

        lx = px->nIndex + l;

        //
        // adjust the offset to be absolute
        //
        offset = pidx->dwChunkOffset + lAdjust;
        length = pidx->dwChunkLength;
        ckid   = pidx->ckid;
        stream = StreamFromFOURCC(ckid);
        flags  = 0;

        if (ckid == listtypeAVIRECORD)
            stream = STREAM_REC;

        if (ckid == listtypeAVIRECORD)
            lxRec = lx;

        //
        // handle over flows in a "sane" way.
        //
        if (offset >= MAX_OFFSET)
            break;

        if (stream >= MAX_STREAM)
            break;

        if (length >= MAX_LENGTH)
            length = MAX_LENGTH-1;

        if (pidx->dwFlags & AVIIF_KEYFRAME)
            flags |= IDX_KEY;
        else
            flags |= IDX_NONKEY;

        //
        // length == 0 samples are not real
        //
        if (length == 0)
            flags &= ~(IDX_NONKEY|IDX_KEY);

        //
        // mark palette changes
        //
        if (TWOCCFromFOURCC(ckid) == cktypePALchange) {
            flags |= IDX_PAL;
            flags &= ~(IDX_NONKEY|IDX_KEY);
        }

        //
        // fix up bogus index's by adding any missing KEYFRAME
        // bits. ie this only applies for RLE files.
        //
        if (fRle && length > 0 && TWOCCFromFOURCC(ckid) == cktypeDIBbits)
            flags |= IDX_KEY;

        //
        // do we need to support these?
        //
        if (fRle && TWOCCFromFOURCC(ckid) == aviTWOCC('d', 'x'))
            flags |= IDX_HALF;

        //
        // audio is always a key.
        //
        if (TWOCCFromFOURCC(ckid) == cktypeWAVEbytes)
            flags |= IDX_KEY|IDX_NONKEY;    //hack to get audio back!

        //
        // make sure records are marked as contining a key
        //
        //if (lxRec > 0 && (flags & IDX_KEY))
        //  IndexSetKey(px, lxRec);

        IndexSetFlags(px,lx,flags);
        IndexSetOffset(px,lx,offset);
        IndexSetLength(px,lx,length);
        IndexSetStream(px,lx,stream);

    }

    cnt = l;
    px->nIndex += cnt;

    return px;
}

/***************************************************************************
 ***************************************************************************/

static LONG FAR PASCAL mmioReadProc(HMMIO hmmio, LONG lSeek, LONG lRead, LPVOID lpBuffer)
{
    if (mmioSeek(hmmio, lSeek, SEEK_SET) == -1)
        return -1;

    if (mmioRead(hmmio, (HPSTR)lpBuffer, lRead) != lRead)
        return -1;

    return lRead;
}

/***************************************************************************
 ***************************************************************************/

static LONG FAR PASCAL mmioWriteProc(HMMIO hmmio, LONG lSeek, LONG lWrite, LPVOID lpBuffer)
{
    if (mmioSeek(hmmio, lSeek, SEEK_SET) == -1)
        return -1;

    if (mmioWrite(hmmio, (HPSTR)lpBuffer, lWrite) != lWrite)
        return -1;

    return lWrite;
}

/***************************************************************************
 *
 * @doc INTERNAL
 *
 * @api PSTREAMINDEX | MakeStreamIndex
 *
 *  makes a STREAMINDEX structure that will be used later to read/find
 *  samples in a stream.
 *
 ***************************************************************************/

EXTERN_C PSTREAMINDEX MakeStreamIndex(PAVIINDEX px, UINT stream, LONG lStart, LONG lSampleSize, HANDLE hFile, STREAMIOPROC ReadProc, STREAMIOPROC WriteProc)
{
    LONG         lPos;
    LONG         lx;
    PSTREAMINDEX psx;

    Assert(px);

    if (px == NULL)
        return NULL;

    psx = (PSTREAMINDEX)LocalAlloc(LPTR, sizeof(STREAMINDEX));

    if (psx == NULL)
        return NULL;

    //!!! fixed length sample streams should never have this

    if (lSampleSize != 0 && lStart < 0) {
#ifdef DEBUG
        //AssertSz(0, "Audio streams should not have initial frames");
#endif
        lStart = 0;
    }

    psx->px             = px;
    psx->lStart         = lStart;
    psx->lSampleSize    = lSampleSize;
    psx->lMaxSampleSize = 0;
    psx->stream         = stream;
    psx->flags          = 0;

    psx->lStart         = lStart;
    psx->lxStart        = IndexFirst(px, stream);

    psx->lPos           = lStart;
    psx->lx             = psx->lxStart;

    psx->lFrames        = 0;
    psx->lKeyFrames     = 0;
    psx->lPalFrames     = 0;
    psx->lNulFrames     = 0;

    psx->hFile          = hFile;

    if (ReadProc == NULL)
        psx->Read       = (STREAMIOPROC)mmioReadProc;
    else
        psx->Read       = ReadProc;

    if (WriteProc == NULL)
        psx->Write      = (STREAMIOPROC)mmioWriteProc;
    else
        psx->Write      = WriteProc;

    lPos = lStart;

    for (lx = psx->lxStart; lx >= 0 && lx < px->nIndex; lx=IndexNext(px, lx, 0)) {

        if (psx->lMaxSampleSize < IndexLength(px, lx))
            psx->lMaxSampleSize = IndexLength(px, lx);

        //
        // make sure the start sample is a key frame (unless it's wave data!)
        //
        if (lPos == 0 || (lPos >= 0 && lPos == psx->lStart)) {
	    if ((IndexFlags(px, lx) & (IDX_KEY|IDX_NONKEY)) !=
						(IDX_KEY|IDX_NONKEY)) {
		IndexSetKey(px, lx);
	    }
	}

        //
	// make sure sample size is correct
	//
        if (psx->lSampleSize &&
                ((IndexLength(px, lx) % lSampleSize) != 0)) {
            DPF("!!! Bad chunk size found: force sample size to 0???\n");
            // psx->lSampleSize = 0; !!! turned off because of possible
	    // partial audio chunks at file's end.....
	}

        //
        //  or all the flags together so we can see what a stream has.
        //
        psx->flags |= IndexFlags(px, lx);

        //
        //  check for all key frames.
        //
        if (IndexFlags(px, lx) & IDX_KEY)
            psx->lKeyFrames++;

        //
        //  check for all palette changes
        //
        if (IndexFlags(px, lx) & IDX_PAL)
            psx->lPalFrames++;

        //
        //  check for empty frames
        //
        if (IndexLength(px, lx) == 0)
            psx->lNulFrames++;

        //
        // advance the position
        //
        if (!(IndexFlags(px,lx) & IDX_NOTIME)) {
            if (lSampleSize)
                lPos += IndexLength(px, lx) / lSampleSize;
            else
                lPos++;
        }

        psx->lFrames++;
    }

    //
    //  correct the length
    //
    psx->lEnd = lPos;

    DPF("MakeStreamIndex  stream=#%d lStart=%ld, lEnd=%ld\n", stream, psx->lStart, psx->lEnd);
    DPF("                 lFrames = %ld, lKeys = %ld, lPals = %ld, lEmpty = %ld\n", psx->lFrames, psx->lKeyFrames, psx->lPalFrames, psx->lNulFrames);

    return psx;
}

#ifndef AVIIDX_READONLY

/***************************************************************************
 *
 * @doc INTERNAL
 *
 * @api PAVIINDEX | IndexGetFileIndex
 *
 *     make a file index out of a in memory index
 *
 ***************************************************************************/

EXTERN_C LONG IndexGetFileIndex(PAVIINDEX px, LONG l, LONG cnt, PAVIINDEXENTRY pidx, LONG lAdjust)
{
    LONG            lx;
    DWORD           ckid;
    UINT            stream;
    DWORD           offset;
    DWORD           length;
    UINT            flags;
    DWORD           dwFlags;

    Assert(pidx);
    Assert(px);

    if (pidx == NULL || px == NULL)
        return NULL;

    Assert(sizeof(AVIINDEXENTRY) > sizeof(AVIIDX));

    for (lx=l; lx < px->nIndex && lx < l+cnt; lx++) {
        //
        // adjust the offset to be relative
        //
        offset = IndexOffset(px,lx) + lAdjust;
        length = IndexLength(px,lx);
        stream = IndexStream(px,lx);
        flags  = IndexFlags(px, lx);

        if (length == MAX_LENGTH-1) {
        }

        ckid = MAKEAVICKID(0, stream);
        dwFlags = 0;

        //
        //  set the flags, there are only a few flags in file index's
        //  AVIIF_KEYFRAME, AVIIF_LIST, AVIIF_NOTIME
        //
        if (flags & IDX_KEY)
            dwFlags |= AVIIF_KEYFRAME;

        if (flags & IDX_PAL)
            dwFlags |= AVIIF_NOTIME;

        if (stream == STREAM_REC)
            dwFlags |= AVIIF_LIST;

        //
        //  now figure out the ckid
        //
        if (stream == STREAM_REC)
            ckid = listtypeAVIRECORD;

        else if ((flags & (IDX_KEY|IDX_NONKEY)) == (IDX_KEY|IDX_NONKEY))
            ckid |= MAKELONG(0, aviTWOCC('w', 'b'));

        else if (flags & IDX_PAL)
            ckid |= MAKELONG(0, aviTWOCC('p', 'c'));

        else if (flags & IDX_HALF)
            ckid |= MAKELONG(0, aviTWOCC('d', 'x'));

        else if (flags & IDX_KEY)
            ckid |= MAKELONG(0, aviTWOCC('d', 'b'));

        else
            ckid |= MAKELONG(0, aviTWOCC('d', 'c'));

        //
        // set the info
        //
        pidx->dwChunkOffset = offset;
        pidx->dwChunkLength = length;
        pidx->dwFlags       = dwFlags;
        pidx->ckid          = ckid;

        pidx++;
    }

    return lx - l;  // return count copied
}

/***************************************************************************
 *
 * @doc INTERNAL
 *
 * @api PAVIINDEX | IndexCreate | make a index.
 *
 ***************************************************************************/

EXTERN_C PAVIINDEX IndexCreate(void)
{
    PAVIINDEX px;

    px = (PAVIINDEX)GlobalAllocPtr(GHND | GMEM_SHARE,
        sizeof(AVIINDEX) + INDEXALLOC * sizeof(AVIIDX));

    if (px == NULL)
        return NULL;

    px->nIndex      = 0;          // index size
    px->nIndexSize  = INDEXALLOC; // allocated size

    return px;
}

#endif // AVIIDX_READONLY

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LONG | IndexFirst | returns the first index entry for a stream
 *
 * @rdesc returns the first index entry, -1 for error
 *
 ***************************************************************************/

EXTERN_C LONG IndexFirst(PAVIINDEX px, UINT stream)
{
    LONG l;

    Assert(px);

    for (l=0; l<px->nIndex; l++) {

        if (IndexStream(px, l) == stream)
            return l;
    }

    return ERR_IDX;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LONG | IndexNext | go forward in a index
 *
 ***************************************************************************/

EXTERN_C LONG IndexNext(PAVIINDEX px, LONG l, UINT f)
{
    WORD bStream;

    Assert(px);

    if (l < 0 || l >= px->nIndex)
        return ERR_IDX;

    bStream = IndexStream(px, l);

    for (l++; l<px->nIndex; l++) {

        if (IndexStream(px, l) != bStream)
            continue;

        if (!f || (IndexFlags(px, l) & f))
            return l;
    }

    return ERR_IDX;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LONG | IndexPrev | step backward in a stream
 *
 ***************************************************************************/
EXTERN_C LONG IndexPrev(PAVIINDEX px, LONG l, UINT f)
{
    WORD bStream;

    Assert(px);

    if (l < 0 || l >= px->nIndex)
        return ERR_IDX;

    bStream = IndexStream(px, l);

    for (l--; l>=0; l--) {

        if (IndexStream(px, l) != bStream)
            continue;

        if (!f || (IndexFlags(px, l) & f))
            return l;
    }

    return ERR_IDX;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

INLINE BOOL StreamNext(PSTREAMINDEX psx, LONG FAR& l, LONG FAR& lPos, UINT flags)
{
    BYTE                bStream = (BYTE) psx->stream;
    LONG                lSampleSize = psx->lSampleSize;
    LONG                lSave = l;
    LONG                lPosSave = lPos;
    PAVIINDEX           px = psx->px;

    Assert(px && l >= 0 && l < px->nIndex);

    if (lSampleSize == 0) {

        lPos += 1;
        l++;

        for (; l<px->nIndex; l++) {

            if (IndexStream(px, l) != bStream)
                continue;

            if (!flags || (IndexFlags(px, l) & flags))
                return TRUE;

	    if (!(IndexFlags(px, l) & IDX_NOTIME))
		lPos += 1;
        }
    }
    else {

        lPos += IndexLength(px, l) / lSampleSize;
        l++;

        for (; l<px->nIndex; l++) {

            if (IndexStream(px, l) != bStream)
                continue;

            if (!flags || (IndexFlags(px, l) & flags))
                return TRUE;

            lPos += IndexLength(px, l) / lSampleSize;
        }
    }

    lPos = lPosSave;
    l    = lSave;

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

INLINE BOOL StreamPrev(PSTREAMINDEX psx, LONG FAR& l, LONG FAR& lPos, UINT flags)
{
    BYTE                bStream = (BYTE) psx->stream;
    LONG                lSampleSize = psx->lSampleSize;
    LONG                lSave = l;
    LONG                lPosSave = lPos;
    PAVIINDEX           px = psx->px;

    Assert(px && l >= 0 && l < px->nIndex);

    if (lSampleSize == 0) {

        for (l--;l>=0;l--) {

            if (IndexStream(px, l) != bStream)
                continue;

	    if (!(IndexFlags(px, l) & IDX_NOTIME))
		lPos -= 1;

            if (!flags || (IndexFlags(px, l) & flags))
                return TRUE;
        }
    }
    else {
        for (l--;l>=0;l--) {

            if (IndexStream(px, l) != bStream)
                continue;

            lPos -= IndexLength(px, l) / lSampleSize;

            if (!flags || (IndexFlags(px, l) & flags))
                return TRUE;
        }
    }

    lPos = lPosSave;
    l    = lSave;

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

static LONG SearchIndex(PSTREAMINDEX psx,LONG lPos,UINT uFlags,IDXPOS FAR *pos)
{
    LONG                l;
    LONG                lScan;
    LONG                lFound;
    LONG                lFoundPos;
    LONG                lLen;
    UINT                flags;
    PAVIINDEX           px = psx->px;

    Assert(psx);
    Assert(psx->px);

    if (psx == NULL)
        return ERR_POS;

    if (lPos < psx->lStart)
        return ERR_POS;

    if (lPos >= psx->lEnd)
        return ERR_POS;

    //
    // figure out where to start in the index.
    //
    if (psx->lx != -1) {
        lScan  = psx->lPos;
        l      = psx->lx;
    }
    else {
        DPF3("Starting index search at begining\n");
        lScan = psx->lStart;

        for (l=0; l<px->nIndex; l++)
            if (IndexStream(px, l) == (UINT)psx->stream)
                break;
    }

    Assert(l >= 0 && l < px->nIndex);
    Assert(IndexStream(px, l) == psx->stream);

#ifdef DEBUG
    if (!(uFlags & FIND_DIR))
        uFlags |= FIND_PREV;

    switch (uFlags & (FIND_TYPE|FIND_DIR)) {
        case FIND_NEXT|FIND_KEY:    DPF3("SearchIndex(%d): %ld next key, start=%ld",psx->stream, lPos, lScan); break;
        case FIND_NEXT|FIND_ANY:    DPF3("SearchIndex(%d): %ld next any, start=%ld",psx->stream, lPos, lScan); break;
        case FIND_NEXT|FIND_FORMAT: DPF3("SearchIndex(%d): %ld next fmt, start=%ld",psx->stream, lPos, lScan); break;
        case FIND_NEXT:             DPF3("SearchIndex(%d): %ld next    , start=%ld",psx->stream, lPos, lScan); break;

        case FIND_PREV|FIND_KEY:    DPF3("SearchIndex(%d): %ld prev key, start=%ld",psx->stream, lPos, lScan); break;
        case FIND_PREV|FIND_ANY:    DPF3("SearchIndex(%d): %ld prev any, start=%ld",psx->stream, lPos, lScan); break;
        case FIND_PREV|FIND_FORMAT: DPF3("SearchIndex(%d): %ld prev fmt, start=%ld",psx->stream, lPos, lScan); break;
        case FIND_PREV:             DPF3("SearchIndex(%d): %ld prev    , start=%ld",psx->stream, lPos, lScan); break;
    }

    LONG time = timeGetTime();
#endif

    lLen = psx->lSampleSize == 0 ? 1 : IndexLength(px, l) / psx->lSampleSize;

    if (lScan+lLen <= lPos) {
        //
        // search forward for this position
        //
        while (lScan <= lPos) {

            lFound = l;
            lFoundPos = lScan;

            if (lScan == lPos)
                break;

            if (!StreamNext(psx, l, lScan, IDX_KEY|IDX_NONKEY))
                break;
        }

        if ((lScan > lPos) && !(uFlags & FIND_NEXT)) {
            lScan = lFoundPos;
            l     = lFound;
        }
    }
    else if (lScan > lPos) {
        //
        // search backward for this position
        //
        while (lScan >= lPos) {

            lFound = l;
            lFoundPos = lScan;

            if (lScan == lPos)
                break;

            if (!StreamPrev(psx, l, lScan, IDX_KEY|IDX_NONKEY))
                break;
        }

        if (uFlags & FIND_NEXT) {
            lScan = lFoundPos;
            l     = lFound;
        }
    }
    else {
        Assert(lScan <= lPos && lPos < lScan+lLen);
    }

    Assert(l >= 0 && l < px->nIndex);
    Assert(IndexStream(px, l) == psx->stream);

    //
    //  cache what we found.
    //
    psx->lx   = l;
    psx->lPos = lScan;

    if (uFlags & FIND_TYPE) {

        switch (uFlags & FIND_TYPE) {
            case FIND_ANY:      flags = IDX_KEY|IDX_NONKEY; break;
            case FIND_FORMAT:   flags = IDX_PAL;            break;
            case FIND_KEY:      flags = IDX_KEY;            break;
        }

        if (!(IndexFlags(px, l) & flags)) {

            if (!(uFlags & FIND_NEXT)) {
                if (!StreamPrev(psx, l, lScan, flags)) {
                    DPF3("!, EOI, time = %ld\n", timeGetTime() - time);
                    return ERR_POS;
                }
            }
            else {
                if (!StreamNext(psx, l, lScan, flags)) {
                    DPF3("!, EOI, time = %ld\n", timeGetTime() - time);
                    return ERR_POS;
                }
            }
        }

        Assert(l >= 0 && l < px->nIndex);
        Assert(IndexStream(px, l) == psx->stream);
        Assert(IndexFlags(px, l) & flags);
    }

    Assert(lScan >= psx->lStart && lScan < psx->lEnd);

    DPF3("!, found %ld, time = %ld\n", lScan, timeGetTime() - time);

    if (pos == NULL)
        return lScan;

    if (psx->lSampleSize != 0) {

        lLen = IndexLength(px, l);

        if (lLen == MAX_LENGTH-1)
            lLen = 0x7FFFFFFF;

        if (psx->lSampleSize > 1)
            lLen /= psx->lSampleSize;
    }
    else {
        lLen = 1;
    }

    pos->lx      = l;
    pos->lPos    = lScan;
    pos->lSize   = lLen;
    pos->lOffset = IndexOffset(px, l);
    pos->lLength = IndexLength(px, l);

    //
    //  if the FIND_TYPE is not one of FIND_ANY, FIND_KEY, FIND_FORMAT
    //  make sure we realy found the wanted sample.
    //
    if ((uFlags & FIND_TYPE) == 0) {
        if (lPos < lScan || lPos >= lScan+lLen) {
            pos->lOffset = -1;
            pos->lLength = 0;
            pos->lSize   = 0;
            pos->lPos    = lPos;
        }
        else if (psx->lSampleSize > 0) {
            pos->lOffset += (lPos - lScan) * psx->lSampleSize;
            pos->lLength -= (lPos - lScan) * psx->lSampleSize;
            pos->lSize   -= (lPos - lScan);
            pos->lPos     = lPos;
        }
    }

    return pos->lPos;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LONG | FindSample | find a sample in a stream
 *
 ***************************************************************************/

EXTERN_C LONG StreamFindSample(PSTREAMINDEX psx,LONG lPos,UINT uFlags)
{
    Assert(psx);
    Assert(psx->px);

    if (lPos < psx->lStart)
        return ERR_POS;

    if (lPos >= psx->lEnd)
        return ERR_POS;

    if ((uFlags & FIND_RET) == FIND_POS) {

        switch (uFlags & FIND_TYPE) {
            case FIND_FORMAT:
                if (psx->lPalFrames == 0) {
                    if ((uFlags & FIND_NEXT) && lPos > psx->lStart)
                        return ERR_POS;
                    else
                        return psx->lStart;
                }
                break;

            case FIND_ANY:
                if (psx->lNulFrames == 0) {
                    return lPos;
                }
                break;

            case FIND_KEY:
                if (psx->lKeyFrames == psx->lFrames) {
                    return lPos;
                }
                break;

            default:
                return lPos;
        }

        return SearchIndex(psx, lPos, uFlags, NULL);
    }
    else {
        IDXPOS pos;

        if (SearchIndex(psx, lPos, uFlags, &pos) == ERR_POS)
            return ERR_POS;

        switch (uFlags & FIND_RET) {
            case FIND_POS:
                return pos.lPos;

            case FIND_OFFSET:
                return pos.lOffset + 8;

            case FIND_LENGTH:
                return pos.lLength;

            case FIND_SIZE:
                return pos.lSize;

            case FIND_INDEX:
                return pos.lx;
        }
    }

    return ERR_POS;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LONG | StreamRead | read from a stream
 *
 ***************************************************************************/

EXTERN_C LONG StreamRead(
    PSTREAMINDEX  psx,
    LONG          lStart,
    LONG          lSamples,
    LPVOID        lpBuffer,
    LONG          cbBuffer)
{
    LONG          lBytes;
    LONG          lSampleSize;
    LONG          lSeek;
    LONG          lRead;
    IDXPOS        pos;

    Assert(psx);
    Assert(psx->px);
    Assert(psx->hFile);
    Assert(psx->Read);

    if (lStart < psx->lStart)
        return -1;

    if (lStart >= psx->lEnd)
        return -1;

    //DPF("%cst: %d : %d\n", psx->stream ? '\t':' ', psx->stream, lStart);

    //
    // find nearest chunk
    //
    if (SearchIndex(psx, lStart, FIND_PREV, &pos) == ERR_POS)
        return -1;

    //
    // only continue if the sample we want is in here.
    //
    if (lStart < pos.lPos || lStart >= pos.lPos + pos.lSize)
        return 0;

    //
    // if they give us a NULL buffer dummy up the cbBuffer so we return
    // what we would have read if we had enough room
    //
    if (lpBuffer == NULL && cbBuffer == 0 && lSamples != 0)
        cbBuffer = 0x7FFFFFFF;

    if (lSampleSize = psx->lSampleSize) {

        // If they wanted to read/write only a "convenient amount",
        // pretend the buffer is only large enough to hold the
        // rest of this chunk.

        if (lSamples == -1l)
            cbBuffer = min(cbBuffer, pos.lLength);

        /* Fixed-length samples, if lSamples is zero, just fill the buffer. */

        if (lSamples > 0)
            lSamples = min(lSamples, cbBuffer / lSampleSize);
        else
            lSamples = cbBuffer / lSampleSize;

        lBytes = lSamples * lSampleSize;
    } else {
        lBytes = pos.lLength;
    }

    if (lpBuffer == NULL)
        return lBytes;

    if (cbBuffer < lBytes)
        return -1;   // buffer is too small

#define WORDALIGN(x) ((x) + ((x) & 1))

    if (lSampleSize == 0)
    {
        DWORD adw[2];
        psx->Read(psx->hFile, pos.lOffset, sizeof(adw), adw);
        if (StreamFromFOURCC(adw[0]) != psx->stream) {
	    Assert(0);
	} else {
	    Assert(WORDALIGN(adw[1]) == WORDALIGN((DWORD)pos.lLength));
	    pos.lLength = adw[1];	// !!! Make netware video work!
	    lBytes = pos.lLength;
	}
    }
    else
    {
#ifdef DEBUG
        IDXPOS x;
        DWORD  adw[2];
        SearchIndex(psx, lStart, FIND_PREV|FIND_ANY, &x);
        psx->Read(psx->hFile, x.lOffset, sizeof(adw), adw);
        Assert(StreamFromFOURCC(adw[0]) == psx->stream);
        Assert(WORDALIGN(adw[1]) == WORDALIGN((DWORD)x.lLength));
#endif
    }

    cbBuffer = lBytes;
    lBytes = 0;

    while (cbBuffer > 0) {

        lSeek = pos.lOffset + 8;
        lRead = min(pos.lLength,cbBuffer);

	if (lRead <= 0) {
            DPF3("!!!! lRead <= 0 in AVIStreamRead\n");
	    break;
        }

        DPF3("StreamRead: %ld bytes @%ld\n", lRead, lSeek);

        if (psx->Read(psx->hFile, lSeek, lRead, lpBuffer) != lRead)
            return -1;

	lBytes   += lRead;
	cbBuffer -= lRead;

	if (cbBuffer > 0) {
	    if (lSampleSize == 0) {
		DPF("%ld bytes to read, but sample size is 0!\n", cbBuffer);
		break;
	    }

            lpBuffer = (LPVOID) (((BYTE _huge *)lpBuffer) + lRead);

            lStart += lRead / lSampleSize;
            lStart = SearchIndex(psx, lStart, FIND_PREV, &pos);

            if (lStart == ERR_POS)
		break;
        }
    }

    //
    // success return number of bytes read
    //
    return lBytes;
}

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LONG | StreamWrite | write to a stream
 *
 ***************************************************************************/

EXTERN_C LONG StreamWrite(
    PSTREAMINDEX  psx,
    LONG          lStart,
    LONG          lSamples,
    LPVOID        lpBuffer,
    LONG          cbBuffer)
{
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\aviiface.h ===
/****************************************************************************
 *
 *  AVIIFACE.H
 *
 *  Interface definitions for AVIFile
 *
 *  Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#ifdef _WIN32

// begin_vfw32

#include <ole2.h>

// end_vfw32

#else
#include <compobj.h>
#endif

// begin_vfw32
/*	-	-	-	-	-	-	-	-	*/


/****** AVI Stream Interface *******************************************/

#undef  INTERFACE
#define INTERFACE   IAVIStream

DECLARE_INTERFACE_(IAVIStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIStream methods ***
    STDMETHOD(Create)      (THIS_ LPARAM lParam1, LPARAM lParam2) PURE ;
// end_vfw32
#ifdef _WIN32
// begin_vfw32
    STDMETHOD(Info)        (THIS_ AVISTREAMINFOW FAR * psi, LONG lSize) PURE ;
// end_vfw32
#else
    STDMETHOD(Info)        (THIS_ AVISTREAMINFO FAR * psi, LONG lSize) PURE ;
#endif
// begin_vfw32
    STDMETHOD_(LONG, FindSample)(THIS_ LONG lPos, LONG lFlags) PURE ;
    STDMETHOD(ReadFormat)  (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG FAR *lpcbFormat) PURE ;
    STDMETHOD(SetFormat)   (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG cbFormat) PURE ;
    STDMETHOD(Read)        (THIS_ LONG lStart, LONG lSamples,
			    LPVOID lpBuffer, LONG cbBuffer,
			    LONG FAR * plBytes, LONG FAR * plSamples) PURE ;
    STDMETHOD(Write)       (THIS_ LONG lStart, LONG lSamples,
			    LPVOID lpBuffer, LONG cbBuffer,
			    DWORD dwFlags,
			    LONG FAR *plSampWritten,
			    LONG FAR *plBytesWritten) PURE ;
    STDMETHOD(Delete)      (THIS_ LONG lStart, LONG lSamples) PURE;
    STDMETHOD(ReadData)    (THIS_ DWORD fcc, LPVOID lp, LONG FAR *lpcb) PURE ;
    STDMETHOD(WriteData)   (THIS_ DWORD fcc, LPVOID lp, LONG cb) PURE ;
#ifdef _WIN32
    STDMETHOD(SetInfo) (THIS_ AVISTREAMINFOW FAR * lpInfo,
			    LONG cbInfo) PURE;
#else
    STDMETHOD(Reserved1)            (THIS) PURE;
    STDMETHOD(Reserved2)            (THIS) PURE;
    STDMETHOD(Reserved3)            (THIS) PURE;
    STDMETHOD(Reserved4)            (THIS) PURE;
    STDMETHOD(Reserved5)            (THIS) PURE;
#endif
};

typedef       IAVIStream FAR* PAVISTREAM;


#undef  INTERFACE
#define INTERFACE   IAVIStreaming

DECLARE_INTERFACE_(IAVIStreaming, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIStreaming methods ***
    STDMETHOD(Begin) (THIS_
		      LONG  lStart,		    // start of what we expect
						    // to play
		      LONG  lEnd,		    // expected end, or -1
		      LONG  lRate) PURE;	    // Should this be a float?
    STDMETHOD(End)   (THIS) PURE;
};

typedef       IAVIStreaming FAR* PAVISTREAMING;


#undef  INTERFACE
#define INTERFACE   IAVIEditStream

DECLARE_INTERFACE_(IAVIEditStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIEditStream methods ***
    STDMETHOD(Cut) (THIS_ LONG FAR *plStart,
			  LONG FAR *plLength,
			  PAVISTREAM FAR * ppResult) PURE;
    STDMETHOD(Copy) (THIS_ LONG FAR *plStart,
			   LONG FAR *plLength,
			   PAVISTREAM FAR * ppResult) PURE;
    STDMETHOD(Paste) (THIS_ LONG FAR *plPos,
			    LONG FAR *plLength,
			    PAVISTREAM pstream,
			    LONG lStart,
			    LONG lEnd) PURE;
    STDMETHOD(Clone) (THIS_ PAVISTREAM FAR *ppResult) PURE;
// end_vfw32
#ifdef _WIN32
// begin_vfw32
    STDMETHOD(SetInfo) (THIS_ AVISTREAMINFOW FAR * lpInfo,
			    LONG cbInfo) PURE;
// end_vfw32
#else
    STDMETHOD(SetInfo) (THIS_ AVISTREAMINFO FAR * lpInfo,
			    LONG cbInfo) PURE;
#endif
// begin_vfw32
};

typedef       IAVIEditStream FAR* PAVIEDITSTREAM;


/****** AVI File Interface *******************************************/


#undef  INTERFACE
#define INTERFACE   IAVIFile
#define PAVIFILE IAVIFile FAR*

DECLARE_INTERFACE_(IAVIFile, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIFile methods ***
// end_vfw32
#ifndef _WIN32
    STDMETHOD(Open)		    (THIS_
                                     const char FAR * szFile,
                                     UINT mode) PURE;
    STDMETHOD(Info)                 (THIS_
                                     AVIFILEINFO FAR * pfi,
                                     LONG lSize) PURE;
    STDMETHOD(GetStream)            (THIS_
                                     PAVISTREAM FAR * ppStream,
				     DWORD fccType,
                                     LONG lParam) PURE;
    STDMETHOD(CreateStream)         (THIS_
                                     PAVISTREAM FAR * ppStream,
                                     AVISTREAMINFO FAR * psi) PURE;
    STDMETHOD(Save)                 (THIS_
                                     const char FAR * szFile,
                                     AVICOMPRESSOPTIONS FAR *lpOptions,
                                     AVISAVECALLBACK lpfnCallback) PURE;
#else
// begin_vfw32
    STDMETHOD(Info)                 (THIS_
                                     AVIFILEINFOW FAR * pfi,
                                     LONG lSize) PURE;
    STDMETHOD(GetStream)            (THIS_
                                     PAVISTREAM FAR * ppStream,
				     DWORD fccType,
                                     LONG lParam) PURE;
    STDMETHOD(CreateStream)         (THIS_
                                     PAVISTREAM FAR * ppStream,
                                     AVISTREAMINFOW FAR * psi) PURE;
// end_vfw32
#endif
// begin_vfw32
    STDMETHOD(WriteData)            (THIS_
                                     DWORD ckid,
                                     LPVOID lpData,
                                     LONG cbData) PURE;
    STDMETHOD(ReadData)             (THIS_
                                     DWORD ckid,
                                     LPVOID lpData,
                                     LONG FAR *lpcbData) PURE;
    STDMETHOD(EndRecord)            (THIS) PURE;
// end_vfw32
#ifdef _WIN32
// begin_vfw32
    STDMETHOD(DeleteStream)         (THIS_
				     DWORD fccType,
                                     LONG lParam) PURE;
// end_vfw32
#else
    STDMETHOD(Reserved1)            (THIS) PURE;
    STDMETHOD(Reserved2)            (THIS) PURE;
    STDMETHOD(Reserved3)            (THIS) PURE;
    STDMETHOD(Reserved4)            (THIS) PURE;
    STDMETHOD(Reserved5)            (THIS) PURE;
#endif
// begin_vfw32
};

#undef PAVIFILE
typedef       IAVIFile FAR* PAVIFILE;

/****** GetFrame Interface *******************************************/

#undef  INTERFACE
#define INTERFACE   IGetFrame
#define PGETFRAME   IGetFrame FAR*

DECLARE_INTERFACE_(IGetFrame, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IGetFrame methods ***

    STDMETHOD_(LPVOID,GetFrame) (THIS_ LONG lPos) PURE;
//  STDMETHOD_(LPVOID,GetFrameData) (THIS_ LONG lPos) PURE;

    STDMETHOD(Begin) (THIS_ LONG lStart, LONG lEnd, LONG lRate) PURE;
    STDMETHOD(End) (THIS) PURE;

    STDMETHOD(SetFormat) (THIS_ LPBITMAPINFOHEADER lpbi, LPVOID lpBits, int x, int y, int dx, int dy) PURE;

//  STDMETHOD(DrawFrameStart) (THIS) PURE;
//  STDMETHOD(DrawFrame) (THIS_ LONG lPos, HDC hdc, int x, int y, int dx, int dy) PURE;
//  STDMETHOD(DrawFrameEnd) (THIS) PURE;
};

#undef PGETFRAME
typedef IGetFrame FAR* PGETFRAME;

/****** GUIDs *******************************************/

#define DEFINE_AVIGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

DEFINE_AVIGUID(IID_IAVIFile,            0x00020020, 0, 0);
DEFINE_AVIGUID(IID_IAVIStream,          0x00020021, 0, 0);
DEFINE_AVIGUID(IID_IAVIStreaming,       0x00020022, 0, 0);
DEFINE_AVIGUID(IID_IGetFrame,           0x00020023, 0, 0);
DEFINE_AVIGUID(IID_IAVIEditStream,      0x00020024, 0, 0);
#ifndef UNICODE
DEFINE_AVIGUID(CLSID_AVISimpleUnMarshal,        0x00020009, 0, 0);
#endif

DEFINE_AVIGUID(CLSID_AVIFile,           0x00020000, 0, 0);

#define	AVIFILEHANDLER_CANREAD		0x0001
#define	AVIFILEHANDLER_CANWRITE		0x0002
#define	AVIFILEHANDLER_CANACCEPTNONRGB	0x0004
// end_vfw32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\aviidx.h ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985 - 1995. All rights reserved.

   AVIIDX.H - AVI Index stuff

*****************************************************************************/

#ifndef _INC_AVIFMT
#include <vfw.h>
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
	#define EXTERN_C extern "C"
#else
	#define EXTERN_C extern
#endif
#endif

#define ERR_POS     (-100)      // bad position
#define ERR_IDX     (-1)        // bad index

typedef AVIINDEXENTRY _huge *PAVIINDEXENTRY;


// to some customers, this 1Gb limit is not worth the few bytes it saves.
#ifndef _WIN32

//
//  this is the in memory form of a AVI INDEX, we want this to be 8 bytes
//  to save memory.
//
//  the bit fields may not be portable, so a new structure will be needed.
//
//  we always access via macros, so changing the structure should be posible
//
//  this stucture sotres the following:
//
//      offset  0-1GB   (30 bits)   we assume even number so only need 29bits
//      flags           (4 bits)
//      stream  0-127   (7 bits)
//      length  0-4MB   (24 bits)
//
#pragma pack(1)
typedef union {
    struct {
        DWORD   offset;     // 0-1GB
        DWORD   length;     // 0-4MB
    };
    struct {
        BYTE    ack[3];     // 24 bits of the offset
        WORD    flags;      // access to all flags
        BYTE    smag[3];    // length (24 bits)
    };
#if 0   // I hate bit-fields
    struct {
        DWORD   offset:29;  // 0-1GB
        DWORD   key:1;
        DWORD   nonkey:1;
        DWORD   pal:1;
        DWORD   stream:7;   // 0-127
        DWORD   half:1;
        DWORD   length:24;  // 0-4MB
    };
#endif
}   AVIIDX;
#pragma pack()

//
// limits
//
#define MAX_OFFSET  (1l<<30)
#define MAX_LENGTH  (1l<<24)
#define MAX_STREAM  (1l<<7)

//
//  index flags
//
#define IDX_OFFHI   0x001F      // hi part of offset.
#define IDX_KEY     0x0020      // key frame
#define IDX_NONKEY  0x0040      // not a key frame (but not blank either)
#define IDX_PAL     0x0080      // palette change
#define IDX_STREAM  0x7F00      // stream number
#define IDX_HALF    0x8000      // RLE half frame.
#define IDX_NOTIME  IDX_PAL

//
// macros to acces index to help porting
//
#define Index(px, lx)               ((AVIIDX _huge *)px)[lx+1]
#define IndexOffset(px, lx)         (LONG)((Index(px,lx).offset & 0x1FFFFFFF) * 2)
#define IndexLength(px, lx)         (LONG)((Index(px,lx).length) >> 8)
#define IndexStream(px, lx)         (BYTE)((Index(px,lx).flags & IDX_STREAM) >> 8)
#define IndexFlags(px, lx)          (UINT)(Index(px,lx).flags)

#define IndexSetOffset(px, lx, x)   { Index(px,lx).offset &= ~0x1FFFFFFF; Index(px,lx).offset |= (DWORD)(x)>>1; }
#define IndexSetLength(px, lx, x)   { Index(px,lx).length &= ~0xFFFFFF00; Index(px,lx).length |= (DWORD)(x)<<8; }
#define IndexSetStream(px, lx, x)   { Index(px,lx).flags  &= ~IDX_STREAM; Index(px,lx).flags  |= (DWORD)(x)<<8; }
#define IndexSetFlags(px, lx, x)    { Index(px,lx).flags  &= IDX_STREAM|IDX_OFFHI; Index(px,lx).flags |= (UINT)(x); }
#define IndexSetKey(px, lx)         { Index(px,lx).flags  |= IDX_KEY; Index(px,lx).flags &= ~(IDX_NONKEY); }

#else // --- 4Gb version of index macros ----------------------------------

typedef struct {
    WORD  flags;
    WORD  stream;
    DWORD offset;
    long  length;
} AVIIDX;

//
// limits
//
#define MAX_OFFSET  ((DWORD)0xffffffff)	// signed in some places ??
#define MAX_LENGTH  (1l<<30)
#define MAX_STREAM  (1l<<16)

//
//  index flags
//
#define IDX_KEY     0x0020      // key frame
#define IDX_NONKEY  0x0040      // not a key frame (but not blank either)
#define IDX_PAL     0x0080      // palette change
#define IDX_HALF    0x8000      // RLE half frame.
#define IDX_NOTIME  IDX_PAL

//
// macros to acces index to help porting
//
#define Index(px, lx)               (px)->idx[lx]
#define IndexOffset(px, lx)         (Index(px,lx).offset)
#define IndexLength(px, lx)         (Index(px,lx).length)
#define IndexStream(px, lx)         (Index(px,lx).stream)
#define IndexFlags(px, lx)          (Index(px,lx).flags)

#define IndexSetOffset(px, lx, x)   { Index(px,lx).offset = (DWORD)(x); }
#define IndexSetLength(px, lx, x)   { Index(px,lx).length = (long)(x); }
#define IndexSetStream(px, lx, x)   { Index(px,lx).stream = (WORD)(x); }
#define IndexSetFlags(px, lx, x)    { Index(px,lx).flags  = (WORD)(x); }
#define IndexSetKey(px, lx)         { Index(px,lx).flags |= IDX_KEY; Index(px,lx).flags &= ~(IDX_NONKEY); }


#endif //------------------------------------------------------------------
//
// special streams
//
#define STREAM_REC      0x7F        // interleave records.

//
// this is the header we put on a list of AVIIDX entries.
//
#pragma warning(disable:4200)
typedef struct
{
    LONG            nIndex;         // number of entries in index
    LONG            nIndexSize;     // alocated size
    AVIIDX          idx[];          // the entries.
}   AVIINDEX, _huge *PAVIINDEX;

//
// AVI Stream Index
//
typedef LONG (FAR PASCAL *STREAMIOPROC)(HANDLE hFile, LONG off, LONG cb, LPVOID p);

typedef struct
{
    UINT            stream;         // stream number
    UINT            flags;          // combination of all flags in index.

    PAVIINDEX       px;             // main index

    LONG            lx;             // Index index
    LONG            lPos;           // index position

    LONG            lxStart;        // Index start

    LONG            lStart;         // start of stream
    LONG            lEnd;           // end of stream

    LONG            lMaxSampleSize; // largest sample
    LONG            lSampleSize;    // sample size for stream

    LONG            lFrames;        // total "frames"
    LONG            lKeyFrames;     // total key "frames"
    LONG            lPalFrames;     // total pal "frames"
    LONG            lNulFrames;     // total nul "frames"

    HANDLE          hFile;
    STREAMIOPROC    Read;
    STREAMIOPROC    Write;

}   STREAMINDEX, *PSTREAMINDEX;

//
// create and free a index.
//
EXTERN_C PAVIINDEX IndexCreate(void);
#define   FreeIndex(px)  GlobalFreePtr(px)

//
//  convert to and from a file index
//
EXTERN_C PAVIINDEX IndexAddFileIndex(PAVIINDEX px, AVIINDEXENTRY _huge *pidx, LONG cnt, LONG lAdjust, BOOL fRle);
EXTERN_C LONG      IndexGetFileIndex(PAVIINDEX px, LONG l, LONG cnt, PAVIINDEXENTRY pidx, LONG lAdjust);

EXTERN_C PSTREAMINDEX MakeStreamIndex(PAVIINDEX px, UINT stream, LONG lStart, LONG lSampleSize, HANDLE hFile, STREAMIOPROC ReadProc, STREAMIOPROC WriteProc);
#define FreeStreamIndex(psx)    LocalFree((HLOCAL)psx)

//
// index access functions
//
EXTERN_C LONG IndexFirst(PAVIINDEX px, UINT stream);
EXTERN_C LONG IndexNext (PAVIINDEX px, LONG lx, UINT f);
EXTERN_C LONG IndexPrev (PAVIINDEX px, LONG lx, UINT f);

//
//  search index for data
//
#ifndef FIND_DIR
#define FIND_DIR        0x0000000FL     // direction
#define FIND_NEXT       0x00000001L     // go forward
#define FIND_PREV       0x00000004L     // go backward
#define FIND_FROM_START 0x00000008L	// start at the logical beginning

#define FIND_TYPE       0x000000F0L     // type mask
#define FIND_KEY        0x00000010L     // find key frame.
#define FIND_ANY        0x00000020L     // find any (non-empty) sample
#define FIND_FORMAT     0x00000040L     // find format change
#endif

#ifndef FIND_RET
#define FIND_RET        0x0000F000L     // return mask
#define FIND_POS        0x00000000L     // return logical position
#define FIND_LENGTH     0x00001000L     // return logical size
#define FIND_OFFSET     0x00002000L     // return physical position
#define FIND_SIZE       0x00003000L     // return physical size
#define FIND_INDEX      0x00004000L     // return physical index position
#endif

EXTERN_C LONG StreamFindSample(PSTREAMINDEX psx, LONG lPos, UINT f);
EXTERN_C LONG StreamRead(PSTREAMINDEX psx, LONG lStart, LONG lSamples, LPVOID lpBuffer, LONG cbBuffer);
EXTERN_C LONG StreamWrite(PSTREAMINDEX psx, LONG lStart, LONG lSamples, LPVOID lpBuffer, LONG cbBuffer);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\avilib.cpp ===
/****************************************************************************
 *
 *  AVILIB.CPP
 *
 *  routines for reading a AVIStream
 *
 *  Copyright (c) 1992-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>
#ifndef _WIN32
#include <ole2.h>
#endif
#include <vfw.h>
#include <shellapi.h>
#include <memory.h>     // for _fmemset

#include "avifilei.h"
#include "aviopts.h"	// string resources
#include "debug.h"

#include <stdlib.h>

#include "olehack.h"

#if !defined NUMELMS
 #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

#ifndef _WIN32
#undef HKEY_CLASSES_ROOT
#define HKEY_CLASSES_ROOT       0x00000001
#define AVIFileOpenA	AVIFileOpen
#define AVIFileCreateStreamA AVIFileCreateStream
BOOL	gfOleInitialized;
STDAPI_(void) MyFreeUnusedLibraries(void);
#endif

#define ValidPAVI(pavi)  (pavi != NULL)

#define V_PAVI(pavi, err)   \
    if (!ValidPAVI(pavi))   \
        return err;


#ifdef SHELLOLE
#ifdef _WIN32
#define CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv) \
		SHCoCreateInstance(NULL, (const CLSID FAR *)&rclsid, pUnkOuter, riid, ppv)
#undef Assert
#include <shlobj.h>
#include <shellp.h>
#endif
#endif

/****************************************************************************

    strings

****************************************************************************/

#undef SZCODE
#define SZCODE const TCHAR _based(_segname("_CODE"))


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

EXTERN_C HINSTANCE ghMod;

static int iInit = 0;

#define InRange(id, idFirst, idLast)  ((UINT)(id-idFirst) <= (UINT)(idLast-idFirst))
// scan lpsz for a number of hex digits (at most 8); update lpsz, return
// value in Value; check for chDelim; return TRUE for success.
BOOL  HexStringToDword(LPCTSTR FAR * lplpsz, DWORD FAR * lpValue, int cDigits, char chDelim)
{
    int ich;
    LPCTSTR lpsz = *lplpsz;
    DWORD Value = 0;
    BOOL fRet = TRUE;

    for (ich = 0; ich < cDigits; ich++)
    {
	TCHAR ch = lpsz[ich];
        if (InRange(ch, '0', '9'))
	{
            Value = (Value << 4) + ch - '0';
	}
        else if ( InRange( (ch |= ('a'-'A')), 'a', 'f') )
	{
            Value = (Value << 4) + ch - 'a' + 10;
	}
        else
            return(FALSE);
    }

    if (chDelim)
    {
	fRet = (lpsz[ich++]==chDelim);
    }

    *lpValue = Value;
    *lplpsz = lpsz+ich;

    return fRet;
}

// parse above format; return TRUE if succesful; always writes over *pguid.
STDAPI_(BOOL)  GUIDFromString(LPCTSTR lpsz, LPGUID pguid)
{
	DWORD dw;
	if (*lpsz++ != '{' /*}*/ )
		return FALSE;

	if (!HexStringToDword(&lpsz, &pguid->Data1, sizeof(DWORD)*2, '-'))
		return FALSE;

	if (!HexStringToDword(&lpsz, &dw, sizeof(WORD)*2, '-'))
		return FALSE;

	pguid->Data2 = (WORD)dw;

	if (!HexStringToDword(&lpsz, &dw, sizeof(WORD)*2, '-'))
		return FALSE;

	pguid->Data3 = (WORD)dw;

	if (!HexStringToDword(&lpsz, &dw, sizeof(BYTE)*2, 0))
		return FALSE;

	pguid->Data4[0] = (BYTE)dw;

	if (!HexStringToDword(&lpsz, &dw, sizeof(BYTE)*2, '-'))
		return FALSE;

	pguid->Data4[1] = (BYTE)dw;

	if (!HexStringToDword(&lpsz, &dw, sizeof(BYTE)*2, 0))
		return FALSE;

	pguid->Data4[2] = (BYTE)dw;

	if (!HexStringToDword(&lpsz, &dw, sizeof(BYTE)*2, 0))
		return FALSE;

	pguid->Data4[3] = (BYTE)dw;

	if (!HexStringToDword(&lpsz, &dw, sizeof(BYTE)*2, 0))
		return FALSE;

	pguid->Data4[4] = (BYTE)dw;

	if (!HexStringToDword(&lpsz, &dw, sizeof(BYTE)*2, 0))
		return FALSE;

	pguid->Data4[5] = (BYTE)dw;

	if (!HexStringToDword(&lpsz, &dw, sizeof(BYTE)*2, 0))
		return FALSE;

	pguid->Data4[6] = (BYTE)dw;
	if (!HexStringToDword(&lpsz, &dw, sizeof(BYTE)*2, /*(*/ '}'))
		return FALSE;

	pguid->Data4[7] = (BYTE)dw;

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

/**************************************************************************
* @doc INTERNAL InitRegistry()
*
* @api void | write all the default AVIFile/AVIStream handlers to the
*             registry.
*
* @comm This function should be enhanced so that some of the key values
*	can be loaded from resources, instead of a static string table....
*
* @xref AVIStreamInit
*
*************************************************************************/

#if 0 // Registry is now setup on install or upgrade
#ifndef CHICAGO
// !!! Chicago currently sets these registry entries up at setup time.
// NT should someday do the same thing.

#include "avireg.h"
static void InitRegistry()
{
    TCHAR **ppch = aszReg;
    TCHAR ach[80];

    LONG cb;

    // !!! This should have a version number or something in it....

    if (RegQueryValue(HKEY_CLASSES_ROOT, ppch[0], ach, (cb = sizeof(ach),&cb)) == ERROR_SUCCESS &&
        lstrcmpi(ach, ppch[1]) == 0) {
	DPF("Registry is up to date: %ls\n\t%ls\n\t%ls\n", ach, ppch[0], ppch[1]);
        return;
    }
    DPF("Setting: (was) %ls\n\t%ls\n\t(now) %ls\n", ach, ppch[0], ppch[1]);

    while (ppch[0])
    {
#ifdef MAX_RC_CONSTANT
	if (((UINT) ppch[1]) < MAX_RC_CONSTANT) {
	    LoadString(ghMod, (UINT) ppch[1], ach, sizeof(ach)/sizeof(TCHAR));
	    RegSetValue(HKEY_CLASSES_ROOT, ppch[0], REG_SZ, ach, 0L);

	} else
#endif
{
#ifdef _WIN32
	    // string is too long for win 16
#endif
	    if (*ppch[1] == TEXT('@')) {

		// This can only be generously described as a hack.  We
		// need to set a named value, but without restructuring
		// avireg.h completely (or reimplementing something different)
		// we cannot do so.  Hence we allow "special" values.  If the
		// "value" starts with "@" we interpret it to mean that this
		// is the value name, and the actual value follows.
		HKEY hKey = 0;
		DWORD Type = REG_SZ;

		RegOpenKeyEx(HKEY_CLASSES_ROOT, ppch[0], 0, KEY_SET_VALUE, &hKey);
		if (hKey) {
		    LONG l =
		    RegSetValueEx(hKey, ppch[1]+1, 0,
				    REG_SZ,
				    (LPBYTE)(ppch[2]),
				    (1+lstrlen(ppch[2]))*sizeof(TCHAR)); // include NULL length
		    DPF2("Set Value Ex, return is %d\n\tValue is:%ls\n\tData is:%ls\n", l, ppch[1]+1, ppch[2]);
		    RegCloseKey(hKey);
		}
		++ppch;  // we must step three strings for named values
	    } else {
		DPF2("Setting registry value: %ls\n\t%ls\n", ppch[0], ppch[1]);
		RegSetValue(HKEY_CLASSES_ROOT, ppch[0], REG_SZ, ppch[1], 0L);
	    }
}
        ppch += 2;
    }
}
#endif
#endif

/**************************************************************************
* @doc EXTERNAL AVIFileInit
*
* @api void | AVIFileInit | This function initalizes the AVIFILE library.
*
* @comm Call this function before using any other AVIFILE functions.
*
* @xref <f AVIFileExit>
*
*************************************************************************/
// Force dynlink to OLE on NT as we use link to CoCreateInstance whereas
// Win95 uses the Shell instance call.
#ifdef DAYTONA
#define INITOLE (iInit==1)   //Force load on NT if this is the first init
#else
#define INITOLE FALSE
#endif

STDAPI_(void) AVIFileInit()
{
    iInit++;
    DPF("AVIFileInit: level now==%d\n", iInit);
#if defined(SHELLOLE) || defined(DAYTONA)
#ifndef _WIN32
    CoInitialize(NULL);
#endif
    InitOle(INITOLE);
#else
    OleInitialize(NULL);
#endif

#if 0 // Registry is now setup on install or upgrade
#ifndef CHICAGO
    if (iInit == 1) {
        InitRegistry();
    }
#endif
#endif
}

/**************************************************************************
* @doc EXTERNAL AVIFileExit
*
* @api void | AVIFileExit | This function exits the AVIFILE library.
*
* @comm Call this function after using any other AVIFILE functions.
*
* @xref <f AVIFileInit>
*
*************************************************************************/
STDAPI_(void) AVIFileExit()
{
    iInit--;
    DPF("AVIFileExit: level now %d\n", iInit);

#if defined(SHELLOLE) || defined(DAYTONA)
    TermOle();
#ifndef _WIN32
    MyFreeUnusedLibraries();
    CoUninitialize();
#endif
#else // not SHELLOLE
    CoFreeUnusedLibraries();

    OleUninitialize();
#endif
}


/**************************************************************************
* @doc INTERNAL AVIFileCreate
*
* @api LONG | AVIFileCreate | Initializes an empty AVI File interface
*	pointer.
*
* @parm PAVIFILE FAR * | ppfile | Pointer to where the new <t PAVIFILE>
*	should be returned.
*
* @parm LONG | lParam | Specifies a parameter passed to the handler.
*
* @parm CLSID FAR * | pclsidHandler | Specifies a pointer to a
*       class ID used to create the file.
*
* @devnote Nobody should have to call this function, because AVIFileOpen
*   does it.  In fact, why do we even have this?
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref AVIFileOpen
*
*************************************************************************/
STDAPI AVIFileCreate (PAVIFILE FAR *ppfile, LONG lParam,
		      CLSID FAR *pclsidHandler)
{
    CLSID   clsid;
    HRESULT hr;

    if (!iInit) {
	return ResultFromScode(CO_E_NOTINITIALIZED);
    }

//    AVIStreamInit();

    if (pclsidHandler)
	clsid = *pclsidHandler;
    else {
//    if (pfh == NULL)
//	pfh = &AVIFFileHandler;
    }

    if (FAILED(GetScode(hr = CoCreateInstance((REFCLSID) clsid,
					 NULL, CLSCTX_INPROC,
					 (REFIID) IID_IAVIFile,
					 (void FAR* FAR*)ppfile)))) {
	DPF("AVIFileCreate: CoCreateInstance failed code == %8x\n", hr);
	return hr;  // !!! PropagateHResult?
    }

    return AVIERR_OK;
}

// Remove trailing spaces after a file...
void FixFourCC(LPSTR lp)
{
    int i;

    for (i = 3; i >= 0; i--) {
	if (lp[i] == ' ')
	    lp[i] = '\0';
	else
	    break;
    }
}

// Returns a pointer to the extension of a filename....
LPCOLESTR FindExtension(LPCOLESTR lp)
{
    LPCOLESTR lpExt = lp;
    int i;

// Goto end of string
    while (*lpExt != TEXT('\0'))
    {
        ++lpExt;
    }

// Must be at least 2 characters in string
    if (lpExt - lp < 2 * sizeof(TCHAR))
        return NULL;

    lpExt -= 1;

// Does not count if last character is '.'
    if (*lpExt == TEXT('.'))
        return NULL;

    lpExt -= 1;
// Now looking at second to the last character.  Check this and the two
// previous characters for a '.'

    for (i=1; i<=3; ++i)
    {
// Cannot have path separator here
        if (*lpExt == TEXT('/') || *lpExt == TEXT('\\'))
            return NULL;

        if (*lpExt == TEXT('.'))
        {
            ++lpExt;
	    return lpExt;
        }
        if (lpExt == lp)
            return NULL;
        --lpExt;
    }
    return NULL;
}

/**************************************************************************
* @doc INTERNAL GetHandlerFromFile
*
* @api PAVIFILEHANDLER | GetHandlerFromFile | Figure out what handler
*	to use for a file by looking at its extension, its RIFF type,
*	and possibly other things.
*
* @parm LPCTSTR | szFile | The file to look at.
*
* @parm CLSID FAR * | pclsidHandler | Pointer to a classID.
*
* @comm We don't look at the extensions yet.  We need a better way to
*	add handlers.
*
* @rdesc Returns the <PAVIFILEHANDLER> to use, or NULL if it can't find
*	one.
*
* @xref AVIFileOpen AVIRegisterLoader
*
*************************************************************************/
#define	HKEY_AVIFILE_ROOT	HKEY_CLASSES_ROOT
#ifdef _WIN32
static SZCODE aszRegRIFF[] = TEXT("AVIFile\\RIFFHandlers\\%.4hs");
#else
static SZCODE aszRegRIFF[] = TEXT("AVIFile\\RIFFHandlers\\%.4s");
#endif
static SZCODE aszRegExt[] = TEXT("AVIFile\\Extensions");
static SZCODE aszRegClsid[] = TEXT("Clsid");
static SZCODE aszRegExtTmpl[] = TEXT("%s\\%.3ls");

BOOL GetHandlerFromFile(LPCOLESTR szFile, CLSID FAR *pclsid)
{
    LPCOLESTR   lpExt;
    TCHAR    achKey[100];
    TCHAR    achClass[100];
    LONG    lcbClass;

#if !defined _WIN32 || defined UNICODE
    DWORD   dw[3];
    HMMIO   hmmio;
    // I hate share
    hmmio = mmioOpen((LPTSTR) szFile, NULL, MMIO_READ | MMIO_DENYWRITE);

    if (hmmio == NULL)
        hmmio = mmioOpen((LPTSTR) szFile, NULL, MMIO_READ | MMIO_DENYNONE);

    if (hmmio == NULL)
        hmmio = mmioOpen((LPTSTR) szFile, NULL, MMIO_READ);

    if (hmmio == NULL)
        goto UseExtension;

    if (mmioRead(hmmio, (HPSTR) dw, sizeof(dw)) != sizeof(dw)) {
	mmioClose(hmmio, 0);
	goto UseExtension;
    }

    mmioClose(hmmio, 0);

    if (dw[0] != FOURCC_RIFF)
        goto UseExtension;

    FixFourCC((LPSTR) &dw[2]);

    // Look up the RIFF type in the registration database....
    wsprintf(achKey, aszRegRIFF, (LPSTR) &dw[2]);

    lcbClass = sizeof(achClass);
    RegQueryValue(HKEY_CLASSES_ROOT, achKey, achClass, &lcbClass);

    if (GUIDFromString(achClass, pclsid))
	return TRUE;

UseExtension:
#endif
    lpExt = FindExtension(szFile);
    if (lpExt) {
	// Look up the extension in the registration database....
	wsprintf(achKey, aszRegExtTmpl, (LPTSTR) aszRegExt, lpExt);
	
	lcbClass = sizeof(achClass);
	RegQueryValue(HKEY_CLASSES_ROOT, achKey, achClass, &lcbClass);

        if (GUIDFromString(achClass, pclsid))
	    return TRUE;
    }

    // !!! Use IStorage?

    return FALSE;
}

/**************************************************************************
* @doc EXTERNAL AVIFileOpen
*
* @api LONG | AVIFileOpen | Opens an AVI file and returns a file interface
*	pointer used to access it.
*
* @parm PAVIFILE FAR * | ppfile | Pointer to the location used to return
*       the new <t PAVIFILE> file pointer.
*
* @parm LPCTSTR | szFile | Specifies a zero-terminated string
*       containing the name of the file to open.
*
* @parm UINT | mode | Specifies the mode to use when opening the file.
*
*
*       @flag	OF_READ | Opens the file for reading only. This is the
*       	default, if OF_WRITE and OF_READWRITE are not specified.
*
*       @flag	OF_WRITE | Opens the file for writing. You should not
*       	read from a file opened in this mode.
*
*       @flag	OF_READWRITE | Opens the file for both reading and writing.
*
*       @flag	OF_CREATE | Creates a new file.
*       	If the file already exists, it is truncated to zero length.
*
*       @flag	OF_DENYWRITE | Opens the file and denies other
*       	processes write access to the file. <f AVIFileOpen> fails
*       	if the file has been opened in compatibility or for write
*       	access by any other process.
*
*       @flag	OF_DENYREAD | Opens the file and denies other
*       	processes read access to the file. <f AVIFileOpen> fails if the
*       	file has been opened in compatibility mode or for read access
*       	by any other process.
*
*       @flag	OF_DENYNONE | Opens the file without denying other
*       	processes read or write access to the file. <f AVIFileOpen>
*       	fails if the file has been opened in compatibility mode
*       	by any other process.
*
*	@flag	OF_EXCLUSIVE | Opens the file and denies other processes
*		any access to the file.  <f AVIFileOpen> will fail if any
*		other process has opened the file.
*
*       See <f OpenFile> for more information about these flags.
*
* @parm CLSID FAR * | pclsidHandler | Specifies a pointer to a class ID
*       identifying the handler you want to use. If NULL, the system
*       chooses one from the registration database based on the file
*       extension or the file's RIFF type.
*
* @comm In general, the mode specified is used to open
*	     the file.
*
*	Be sure to call <f AVIFileInit> at least once in your
*	application before calling this function, and to balance each
*	call to <f AVIFileInit> with a call to <f AVIFileExit>.
*
* @rdesc Returns zero if successful; otherwise returns an error code.
*	Possible error returns include:
*
*	@flag AVIERR_BADFORMAT | The file was corrupted or not in the
*	    proper format, and could not be read.
*
*	@flag AVIERR_MEMORY | The file could not be opened because
*	    there was not enough memory.
*
*	@flag AVIERR_FILEREAD | A disk error occurred while reading the
*	    file.
*
*	@flag AVIERR_FILEOPEN | A disk error occurred while opening the
*	    file.
*
*	@flag REGDB_E_CLASSNOTREG | No handler could be found to open
*	    this type of file.
*
* @xref <f AVIFileRelease> <f AVIFileInit>
*
*************************************************************************/
STDAPI
#ifdef _WIN32
AVIFileOpenW
#else
AVIFileOpen
#endif
(PAVIFILE FAR *ppfile,
			 LPCOLESTR szFile,
			 UINT mode,
			 CLSID FAR *pclsidHandler)
{
    CLSID   clsid;
    HRESULT hr;
    LPUNKNOWN punk;

// We used to just fail if AVIFileInit wasn't called
#if 0
    if (!iInit) {
	return ResultFromScode(E_UNEXPECTED);
    }
#endif

#if 0
    // Now we do it for them


    hr = CoInitialize(NULL);

    // Let them know what they did wrong
    if (GetScode(hr) == NOERROR) {
#ifdef DEBUG
	MessageBoxA(NULL, "You didn't call AVIFileInit!", "Bad dog!",
	    MB_OK | MB_ICONHAND);
#endif
    } else
	CoUninitialize();
#endif

    *ppfile = 0;

    if (pclsidHandler) {

	clsid = *pclsidHandler;
	DPF2("AVIFileOpen using explicit clsid %8x, %8x, %8x, %8x\n", clsid);
    }
    else {
	if (!GetHandlerFromFile(szFile, &clsid)) {
	    DPF("Couldn't find handler for %s\n", (LPTSTR) szFile);
	    return ResultFromScode(REGDB_E_CLASSNOTREG);
	}
    }

    if (FAILED(GetScode(hr = CoCreateInstance((REFCLSID) clsid,
					 NULL, CLSCTX_INPROC,
					 (REFIID) IID_IUnknown,
					 (void FAR* FAR*)&punk)))) {
	DPF("CoCreateInstance returns %08lx\n", (DWORD) hr);
	return hr;
    }

    //
    // Let's simplify things for the handlers.  They will only see...
    //		OF_CREATE | OF_READWRITE	or...
    //		OF_READWRITE			or...
    //		OF_READ
    //

    if (mode & OF_READWRITE)
	mode &= ~(OF_WRITE | OF_READ);

    if (mode & OF_CREATE) {
	mode &= ~(OF_WRITE | OF_READ);
	mode |= OF_READWRITE;
    }

    if (mode & OF_WRITE) {
	mode &= ~(OF_WRITE | OF_READ);
	mode |= OF_READWRITE;
    }

#ifdef _WIN32
    IPersistFile * lpPersist = NULL;

    hr = punk->QueryInterface(IID_IPersistFile, ( LPVOID FAR *) &lpPersist);

    if (SUCCEEDED(GetScode(hr))) {
	hr = punk->QueryInterface(IID_IAVIFile, ( LPVOID FAR *) ppfile);
	if (SUCCEEDED(GetScode(hr))) {
	    if (FAILED(GetScode(hr = lpPersist->Load(szFile, mode)))) {
		DPF("Open method returns %08lx\n", (DWORD) hr);
		(*ppfile)->Release();
		*ppfile = NULL;
	    }
	}
	lpPersist->Release();
    }
#else
    hr = punk->QueryInterface(IID_IAVIFile, ( LPVOID FAR *) ppfile);

    if (SUCCEEDED(GetScode(hr))) {
	if (FAILED(GetScode(hr = (*ppfile)->Open(szFile, mode)))) {
	    DPF("Open method returns %08lx\n", (DWORD) hr);
	    (*ppfile)->Release();
	    *ppfile = NULL;
	}
    }
#endif
    punk->Release();

    return hr;
}


#ifdef _WIN32
/*
 * Ansi thunk for AVIFileOpen
 */
STDAPI AVIFileOpenA (PAVIFILE FAR *ppfile,
			 LPCSTR szFile,
			 UINT mode,
			 CLSID FAR *pclsidHandler)
{
    LPWSTR lpW;
    int sz;
    HRESULT hr;

    // remember the null
    sz = lstrlenA(szFile) + 1;

    lpW = (LPWSTR) (LocalAlloc(LPTR, sz * sizeof(WCHAR)));

    if (lpW == NULL) {
	return ResultFromScode(AVIERR_MEMORY);
    }

    MultiByteToWideChar(CP_ACP, 0, szFile, -1, lpW, sz);

    hr = AVIFileOpenW(ppfile, lpW, mode, pclsidHandler);

    LocalFree((HANDLE)lpW);
    return hr;
}
#endif



/**************************************************************************
* @doc EXTERNAL AVIFileAddRef
*
* @api LONG | AVIFileAddRef | Increases the reference count of an AVI file.
*
* @parm PAVIFILE | pfile | Specifies the handle for an open AVI file.
*
* @rdesc Returns the reference count of the file.  This return value
*	should be used only for debugging purposes.
*
* @comm Balance each call to <f AVIFileAddRef> with a call to
*       <f AVIFileRelease>.
*
* @xref <f AVIFileRelease>
*
*************************************************************************/
STDAPI_(ULONG) AVIFileAddRef(PAVIFILE pfile)
{
    return pfile->AddRef();
}

/**************************************************************************
* @doc EXTERNAL AVIFileRelease
*
* @api LONG | AVIFileRelease | Reduces the reference count of an AVI file
*	interface handle by one, and closes the file if the count reaches
*	zero.
*
* @parm PAVIFILE | pfile | Specifies a handle to an open AVI file.
*
* @comm Balance each call to <f AVIFileAddRef> or <f AVIFileOpen>
*       a call to <f AVIFileRelease>.
*
* @devnote Currently, this saves all changes to the file.  Should a separate
*	Save command be needed to do this?
*
* @rdesc Returns the reference count of the file.  This return value
*	should be used only for debugging purposes.
*
* @xref AVIFileOpen AVIFileAddRef
*
*************************************************************************/
STDAPI_(ULONG) AVIFileRelease(PAVIFILE pfile)
{
    return pfile->Release();
}

/**************************************************************************
* @doc EXTERNAL AVIFileInfo
*
* @api LONG | AVIFileInfo | Obtains information about an AVI file.
*
* @parm PAVIFILE | pfile | Specifies a handle to an open AVI file.
*
* @parm AVIFILEINFO FAR * | pfi | Pointer to the structure used to
*       return file information.
*
* @parm LONG | lSize | Specifies the size of the structure.  This value
*	should be at least sizeof(AVIFILEINFO), obviously.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
*************************************************************************/
STDAPI AVIFileInfoW	         (PAVIFILE pfile, AVIFILEINFOW FAR * pfi,
				  LONG lSize)
{
    _fmemset(pfi, 0, (int)lSize);
    return pfile->Info(pfi, lSize);
}

#ifdef _WIN32
// ansi thunk for above function
STDAPI AVIFileInfoA(
    PAVIFILE pfile,
    LPAVIFILEINFOA pfiA,
    LONG lSize)
{
    AVIFILEINFOW fiW;
    HRESULT hr;

    // if size too small - tough
    if (lSize < sizeof(AVIFILEINFOA)) {
	return ResultFromScode(AVIERR_BADSIZE);
    }

    hr = AVIFileInfoW(pfile, &fiW, sizeof(fiW));

    pfiA->dwMaxBytesPerSec       = fiW.dwMaxBytesPerSec;
    pfiA->dwFlags                = fiW.dwFlags;
    pfiA->dwCaps                 = fiW.dwCaps;
    pfiA->dwStreams              = fiW.dwStreams;
    pfiA->dwSuggestedBufferSize  = fiW.dwSuggestedBufferSize;
    pfiA->dwWidth                = fiW.dwWidth;
    pfiA->dwHeight               = fiW.dwHeight;
    pfiA->dwScale                = fiW.dwScale;
    pfiA->dwRate                 = fiW.dwRate;
    pfiA->dwLength               = fiW.dwLength;
    pfiA->dwEditCount            = fiW.dwEditCount;

    // convert the name
    WideCharToMultiByte(CP_ACP, 0, fiW.szFileType, -1,
			pfiA->szFileType, NUMELMS(pfiA->szFileType), NULL, NULL);

    return hr;
}
#endif




/**************************************************************************
* @doc EXTERNAL AVIFileGetStream
*
* @api LONG | AVIFileGetStream | Returns a pointer to a stream interface
*      that is a component of a file.
*
* @parm PAVIFILE | pfile | Specifies a handle to an open AVI file.
*
* @parm PAVISTREAM FAR * | ppavi | Pointer to the return location
*       for the new stream interface pointer.
*
* @parm DWORD | fccType | Specifies a four-character code
*       indicating the type of stream to be opened.
*       Zero indicates that any stream can be opened. The following
*       definitions apply to the data commonly
*       found in AVI streams:
*
* @flag streamtypeAUDIO | Indicates an audio stream.
* @flag streamtypeMIDI | Indicates a MIDI stream.
* @flag streamtypeTEXT | Indicates a text stream.
* @flag streamtypeVIDEO | Indicates a video stream.
*
* @parm LONG | lParam | Specifies an integer indicating which stream
*       of the type defined by <p fccType> should actually be accessed.
*
* @comm Balance each call to <f AVIFileGetStream> with a call to
*       <f AVIStreamRelease> using the stream handle returned.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*	Possible error codes include:
*
*	@flag AVIERR_NODATA | There is no stream in the file corresponding
*	    to the values passed in for <p fccType> and <p lParam>.
*	@flag AVIERR_MEMORY | Not enough memory.
*
* @xref <f AVIStreamRelease>
*
*************************************************************************/
STDAPI AVIFileGetStream     (PAVIFILE pfile, PAVISTREAM FAR * ppavi, DWORD fccType, LONG lParam)
{
    return pfile->GetStream(ppavi, fccType, lParam);
}

#if 0
// !!! This would be used to save changes, if AVIFileRelease didn't do that.
STDAPI AVIFileSave		 (PAVIFILE pfile,
					  LPCTSTR szFile,
					  AVISAVEOPTIONS FAR *lpOptions,
					  AVISAVECALLBACK lpfnCallback,
					  PAVIFILEHANDLER pfh)
{
    if (pfile->FileSave == NULL)
	return -1;

    return pfile->FileSave(pfile, szFile, lpOptions, lpfnCallback);
}
#endif

/**************************************************************************
* @doc EXTERNAL AVIFileCreateStream
*
* @api LONG | AVIFileCreateStream | Creates a new stream in an existing file,
*      and returns a stream interface pointer for it.
*
* @parm PAVIFILE | pfile | Specifies a handle to an open AVI file.
*
* @parm PAVISTREAM FAR * | ppavi | Specifies a pointer used to return the new
*       stream interface pointer.
*
* @parm AVISTREAMINFO FAR * | psi | Specifies a pointer to a structure
*       containing information about the new stream. This structure
*       contains the type of the new stream and its sample rate.
*
* @comm Balance each call to <f AVIFileCreateStream> with a call to
*       <f AVIStreamRelease> using the returned stream handle.
*
*       This function fails with a return value of AVIERR_READONLY unless
*       the file was opened with write permission.
*
*       After creating the stream, call <f AVIStreamSetFormat>
*       before using <f AVIStreamWrite> to write to the stream.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref <f AVIStreamRelease> <f AVIFileGetStream> <f AVIStreamSetFormat>
*
*************************************************************************/

STDAPI
#ifdef _WIN32
AVIFileCreateStreamW
#else
AVIFileCreateStream
#endif
        (PAVIFILE pfile,
	 PAVISTREAM FAR *ppavi,
	 AVISTREAMINFOW FAR *psi)
{
    *ppavi = NULL;
    return pfile->CreateStream(ppavi, psi);
}

#ifdef _WIN32
/*
 * Ansi thunk for AVIFileCreateStream
 */
STDAPI AVIFileCreateStreamA (PAVIFILE pfile,
					 PAVISTREAM FAR *ppavi,
					 AVISTREAMINFOA FAR *psi)
{
    *ppavi = NULL;
    AVISTREAMINFOW siW;
#ifdef UNICODE
    // Copy the AVISTREAMINFOA structure to the unicode equivalent.  We
    // rely on the fact - policed - that the szName element is the last
    // field in the structure.
    memcpy(&siW, psi, FIELD_OFFSET(AVISTREAMINFOA, szName));
    Assert((FIELD_OFFSET(AVISTREAMINFOA, szName) + sizeof(psi->szName)) == sizeof(*psi));
#else
    memcpy(&siW, psi, sizeof(*psi)-sizeof(psi->szName));
#endif

    // convert the name
    MultiByteToWideChar(CP_ACP, 0, psi->szName, NUMELMS(psi->szName),
				    siW.szName, NUMELMS(siW.szName));
    return pfile->CreateStream(ppavi, &siW);
    // no need to copy anything back ??
}
#endif

/**************************************************************************
* @doc INTERNAL AVIFileAddStream
*
* @api LONG | AVIFileAddStream | Adds an existing stream into
*	an existing file, and returns a stream interface pointer for it.
*
* @parm PAVIFILE | pfile | Specifies a handle to an open AVI file.
*
* @parm PAVISTREAM | pavi | Specifies a stream interface pointer
*       for the stream being added.
*
* @parm PAVISTREAM FAR * | ppaviNew | Pointer to a buffer used
*       to return the new stream interface pointer.
*
* @comm Balance each call to <f AVIFileAddStream> with a call to
*       <f AVIStreamRelease> using the returned stream handle.
*
*	This call fails with a return value of AVIERR_READONLY unless
*	the file was opened with write permission.
*
* @devnote This function still doesn't really work.  Perhaps it should just
*	be a helper function that gets data from the stream and calls
*	AVIFileCreateStream, then copies the data from one stream to another.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref AVIStreamRelease AVIFileGetStream AVIFileCreateStream
*
*************************************************************************/
#if 0
STDAPI AVIFileAddStream	(PAVIFILE pfile,
					 PAVISTREAM pavi,
					 PAVISTREAM FAR * ppaviNew)
{
//    if (pfile->FileAddStream == NULL)
//	return -1;

    return pfile->AddStream(pavi, ppaviNew);
}
#endif

/**************************************************************************
* @doc EXTERNAL AVIFileWriteData
*
* @api LONG | AVIFileWriteData | Writes some additional data to the file.
*
* @parm PAVIFILE | pfile | Specifies a handle to an open AVI file.
*
* @parm DWORD | ckid | Specifies a four-character code identifying the data.
*
* @parm LPVOID | lpData | Specifies a pointer to the data to write.
*
* @parm LONG | cbData | Specifies the size of the memory block
*       referenced by <p lpData>.
*
* @comm This function fails with a return value of AVIERR_READONLY unless
*       the file was opened with write permission.
*
*       Use <f AVIStreamWriteData> instead of this function to write
*       data that applies to an individual stream.
*
* @devnote !!! Somewhere, we should specify some types.
*	!!! Should the data block contain the ckid and cksize?
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref <f AVIStreamWriteData> <f AVIFileReadData>
*
*************************************************************************/
STDAPI AVIFileWriteData	(PAVIFILE pfile,
					 DWORD ckid,
					 LPVOID lpData,
					 LONG cbData)
{
//    if (pfile->FileWriteData == NULL)
//	return -1;

    return pfile->WriteData(ckid, lpData, cbData);
}

/**************************************************************************
* @doc EXTERNAL AVIFileReadData
*
* @api LONG | AVIFileReadData | Reads optional header data from the file.
*
* @parm PAVIFILE | pfile | Specifies a handle to an open AVI file.
*
* @parm DWORD | ckid | Specifies a four-character code identifying the data.
*
* @parm LPVOID | lpData | Specifies a pointer to a buffer used to return
*       the data read.
*
* @parm LONG FAR * | lpcbData | Specifies a pointer to a location indicating
*	the size of the memory block referred to by <p lpData>. If
*	the read is successful, the value is changed to indicate the
*	amount of data read.
*
* @devnote !!! Somewhere, we should specify some types.
*	!!! Should the data block contain the ckid and cksize?
*
*	@comm Do not use this function to read video and audio data. Use it
*  only to read additional information such as author
*	information or copyright information that applies to the file
*	as a whole. Information that applies to a single stream should
*	be read using <f AVIStreamReadData>.
*	
* @rdesc Returns zero if successful; otherwise it returns an error code.
*       The return value AVIERR_NODATA indicates that data with the
*       requested chunk ID does not exist.
*
* @xref <f AVIStreamReadData> <f AVIFileWriteData>
*
*************************************************************************/
STDAPI AVIFileReadData	(PAVIFILE pfile,
					 DWORD ckid,
					 LPVOID lpData,
					 LONG FAR * lpcbData)
{
    return pfile->ReadData(ckid, lpData, lpcbData);
}

/**************************************************************************
* @doc EXTERNAL AVIFileEndRecord
*
* @api LONG | AVIFileEndRecord | Marks the end of a record, if writing out
*	a strictly interleaved file.
*
* @parm PAVIFILE | pfile | Specifies a handle to a currently open AVI file.
*
* @comm <f AVIFileSave> uses this function when writing files that are
*	have audio interleaved every frame.  In general, applications
*	should not need to use this function.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref <f AVIFileSave> <f AVIStreamWrite>
*
*************************************************************************/
STDAPI AVIFileEndRecord	(PAVIFILE pfile)
{
//    if (pfile->FileEndRecord == NULL)
//	return -1;

    return pfile->EndRecord();
}



/**************************************************************************
* @doc EXTERNAL AVIStreamAddRef
*
* @api LONG | AVIStreamAddRef | Increases the reference count of an AVI stream.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open AVI stream.
*
* @comm Balance each call to <f AVIStreamAddRef> with a call to
*       <f AVIStreamRelease>.
*
* @rdesc Returns the current reference count of the stream.  This value
*	should only be used for debugging purposes.
*
* @xref <f AVIStreamRelease>
*
*************************************************************************/
STDAPI_(ULONG) AVIStreamAddRef       (PAVISTREAM pavi)
{
    return pavi->AddRef();
}

/**************************************************************************
* @doc EXTERNAL AVIStreamRelease
*
* @api LONG | AVIStreamRelease | Reduces the reference count of an AVI stream
*	interface handle by one, and closes the stream if the count reaches
*	zero.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @comm Balance each call to <f AVIStreamAddRef> or <f AVIFileGetStream>
*       with a call to <f AVIStreamRelease>.
*
* @rdesc Returns the current reference count of the stream.  This value
*	should only be used for debugging purposes.
*
* @xref <f AVIFileGetStream> <f AVIStreamAddRef>
*
*************************************************************************/
STDAPI_(ULONG) AVIStreamRelease        (PAVISTREAM pavi)
{
    return pavi->Release();
}

/**************************************************************************
* @doc EXTERNAL AVIStreamInfo
*
* @api LONG | AVIStreamInfo | Obtains stream header information.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm AVISTREAMINFO FAR * | psi | Specifies a pointer to a structure
*       used to return stream information.
*
* @parm LONG | lSize | Specifies the size of the structure used for
*       <p psi>.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
*************************************************************************/
STDAPI AVIStreamInfoW         (PAVISTREAM pavi, AVISTREAMINFOW FAR * psi, LONG lSize)
{
    _fmemset(psi, 0, (int)lSize);

    return pavi->Info(psi, lSize);
}

#ifdef _WIN32
//Ansi thunk for above function
STDAPI AVIStreamInfoA(
    PAVISTREAM pavi,
    LPAVISTREAMINFOA psi,
    LONG lSize
)
{
    HRESULT hr;
    AVISTREAMINFOW sW;

    hr = AVIStreamInfoW(pavi, &sW, sizeof(sW));

    // is the size big enough
    if (lSize < sizeof(AVISTREAMINFOA)) {
	return ResultFromScode(AVIERR_BADSIZE);
    }

    // copy non-char-related fields
    psi->fccType		= sW.fccType;
    psi->fccHandler             = sW.fccHandler;
    psi->dwFlags                = sW.dwFlags;
    psi->dwCaps                 = sW.dwCaps;
    psi->wPriority              = sW.wPriority;
    psi->wLanguage              = sW.wLanguage;
    psi->dwScale                = sW.dwScale;
    psi->dwRate                 = sW.dwRate;
    psi->dwStart                = sW.dwStart;
    psi->dwLength               = sW.dwLength;
    psi->dwInitialFrames        = sW.dwInitialFrames;
    psi->dwSuggestedBufferSize  = sW.dwSuggestedBufferSize;
    psi->dwQuality              = sW.dwQuality;
    psi->dwSampleSize           = sW.dwSampleSize;
    psi->rcFrame                = sW.rcFrame;
    psi->dwEditCount            = sW.dwEditCount;
    psi->dwFormatChangeCount    = sW.dwFormatChangeCount;

    // convert the name
    WideCharToMultiByte(CP_ACP, 0, sW.szName, -1,
			psi->szName, NUMELMS(psi->szName), NULL, NULL);

    return hr;
}
#endif


/**************************************************************************
* @doc EXTERNAL AVIStreamFindSample
*
* @api LONG | AVIStreamFindSample | Returns the position of
*      a key frames or non-empty frame relative to the specified position.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm LONG | lPos | Specifies the starting position
*       for the search.
*
* @parm LONG | lFlags | The following flags are defined:
*
* @flag FIND_KEY     | Finds a key frame.
* @flag FIND_ANY     | Finds a non-empty sample.
* @flag FIND_FORMAT  | Finds a format change.
*
* @flag FIND_NEXT    | Finds nearest sample, frame, or format change
*                      searching forward. The current sample is
*                      included in the search. Use this flag with the
*                      FIND_ANY, FIND_KEY, or FIND_FORMAT flag.
*
* @flag FIND_PREV    | Finds nearest sample, frame, or format change
*                      searching backwards. The current sample is
*                      included in the search. Use this flag with the
*                      FIND_ANY, FIND_KEY, or FIND_FORMAT flag.
*
*
* @comm The FIND_KEY, FIND_ANY, and FIND_FORMAT flags are mutually exclusive.
*       The FIND_NEXT and FIND_PREV flags are also mutually exclusive.
*       For example:
*
* @ex       FIND_PREV|FIND_KEY      Returns the first key sample prior to or at
*                               <p lPos>.
*
*       FIND_PREV|FIND_ANY      Returns the first non-empty sample prior to
*                               or at <p lPos>.
*
*       FIND_NEXT|FIND_KEY      Returns the first key sample after <p lPos>,
*                               or -1 if a key sample does not follow <p lPos>.
*
*       FIND_NEXT|FIND_ANY      Returns the first non-empty sample after <p lPos>,
*                               or -1 if a sample does not exist after <p lPos>.
*
*       FIND_NEXT|FIND_FORMAT   Returns the first format change after or
*                               at <p lPos>, or -1 if the stream does not
*                               have format changes.
*
*       FIND_PREV|FIND_FORMAT   Returns the first format change prior to
*                               or at <p lPos>. If the stream does not
*                               have format changes, it returns the first sample
*
* @rdesc Returns the position found.  In many boundary cases, this
*	function will return -1; see the example above for details.
*
*************************************************************************/
STDAPI_(LONG) AVIStreamFindSample(PAVISTREAM pavi, LONG lPos, LONG lFlags)
{
    // Default to Find Previous Key Frame
    if ((lFlags & FIND_TYPE) == 0)
        lFlags |= FIND_KEY;
    if ((lFlags & FIND_DIR) == 0)
        lFlags |= FIND_PREV;

    return pavi->FindSample(lPos, lFlags);
}

/**************************************************************************
* @doc EXTERNAL AVIStreamReadFormat
*
* @api LONG | AVIStreamReadFormat | Reads the stream format data.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm LONG | lPos | Specifies the position in the stream
*       used to obtain the format data.
*
* @parm LPVOID | lpFormat | Specifies a pointer to a buffer
*       used to return the format data.
*
* @parm LONG FAR * | lpcbFormat | Specifies a pointer to a
*       location indicating the size of the memory block
*       referred to by <p lpFormat>. On return, the value is
*       changed to indicate the amount of data read. If
*       <p lpFormat> is NULL, this parameter can be used
*       to obtain the amount of memory needed to return the format.
*
* @comm This function will return part of the format even if the buffer
*	provided is not large enough to hold the entire format. In this case
*	the return value will be AVIERR_BUFFERTOOSMALL, and the location
*	referenced by <p lpcbFormat> will be filled in with the size
*	of the entire format.
*
*	This is useful because it allows you to use a buffer the
*	size of a <t BITMAPINFOHEADER> structure and
*	retrieve just the common part of the video format if you are not
*	interested in extended format information or palette information.
*
* @rdesc Returns zero if successful, otherwise it returns an error code.
*
*************************************************************************/
STDAPI AVIStreamReadFormat   (PAVISTREAM pavi, LONG lPos,
					  LPVOID lpFormat, LONG FAR *lpcbFormat)
{
//    if (pavi->StreamReadFormat == NULL)
//	return -1;

    return pavi->ReadFormat(lPos, lpFormat, lpcbFormat);
}

/**************************************************************************
* @doc EXTERNAL AVIStreamSetFormat
*
* @api LONG | AVIStreamSetFormat | Sets the format of a stream at the
*      specified position.
*
* @parm PAVISTREAM | pavi | Specifies a handle to open stream.
*
* @parm LONG | lPos | Specifies the position in the stream to
*       receive the format.
*
* @parm LPVOID | lpFormat | Specifies a pointer to a structure
*       containing the new format.
*
* @parm LONG | cbFormat | Specifies the size of the block of memory
*       referred to by <p lpFormat> in bytes.
*
* @comm After creating a new stream with <f AVIFileCreateStream>,
*       call this function to set the stream's format.
*
*      The handler for writing AVI files does not, in general, accept
*      format changes. Aside from setting the initial format for a
*      stream, only changes in the palette of a video stream are allowed
*      in an AVI file. The palette change must be after
*      any frames already written to the AVI file.  Other handlers may
*     impose different restrictions.
*
* @rdesc Returns zero if successful, otherwise it returns an error code.
*
* @xref <f AVIFileCreateStream> <f AVIStreamReadFormat>
*
*************************************************************************/
STDAPI AVIStreamSetFormat   (PAVISTREAM pavi, LONG lPos,
					 LPVOID lpFormat, LONG cbFormat)
{
//    if (pavi->StreamSetFormat == NULL)
//	return -1;

    return pavi->SetFormat(lPos, lpFormat, cbFormat);
}

/**************************************************************************
* @doc EXTERNAL AVIStreamReadData
*
* @api LONG | AVIStreamReadData | Reads optional header data from a stream.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm DWORD | ckid | Specifies a four-character code identifying the data.
*
* @parm LPVOID | lpData | Specifies a pointer to used to return
*       the data read.
*
* @parm LONG FAR * | lpcbData | Points to a location which
*       specifies the buffer size used for <p lpData>.
*	If the read is successful, AVIFile changes this value
*       to indicate the amount of data written into the buffer for
*       <p lpData>.
*
* @comm This function only retrieves header information
*       from the stream. To read the actual multimedia content of the
*       stream, use <f AVIStreamRead>.
*
* @devnote !!! Somewhere, we should specify some types.
*	!!! Should the data block contain the ckid and cksize?
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*        The return value AVIERR_NODATA indicates the system could not
*        find any data with the specified chunk ID.
*
* @xref <f AVIFileReadData> <f AVIStreamWriteData> <f AVIStreamWrite>
*
*************************************************************************/
STDAPI AVIStreamReadData     (PAVISTREAM pavi, DWORD ckid, LPVOID lpData, LONG FAR *lpcbData)
{
//    if (pavi->StreamReadData == NULL)
//	return -1;

    return pavi->ReadData(ckid, lpData, lpcbData);
}

/**************************************************************************
* @doc EXTERNAL AVIStreamWriteData
*
* @api LONG | AVIStreamWriteData | Writes optional data to the stream.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm DWORD | ckid | Specifies a four-character code identifying the data.
*
* @parm LPVOID | lpData | Specifies a pointer to a buffer containing
*       the data to write.
*
* @parm LONG | cbData | Indicates the number of bytes of data to be copied
*	from <p lpData> into the stream.
*
* @comm This function only writes header information to the stream.
*       To write the actual multimedia content of the stream, use
*       <f AVIStreamWrite>. Use <f AVIFileWriteData> to write
*       data that applies to an entire file.
*
*       This call fails with a return value of AVIERR_READONLY unless
*       the file was opened with write permission.
*
* @devnote !!! Somewhere, we should specify some types.
*	!!! Should the data block contain the ckid and cksize?
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref <f AVIFileWriteData> <f AVIStreamReadData> <f AVIStreamWrite>
*
*************************************************************************/
STDAPI AVIStreamWriteData     (PAVISTREAM pavi, DWORD ckid, LPVOID lpData, LONG cbData)
{
    return pavi->WriteData(ckid, lpData, cbData);
}

/**************************************************************************
* @doc EXTERNAL AVIStreamRead
*
* @api LONG | AVIStreamRead | Reads audio or video data from a stream.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm LONG | lStart | Specifies the starting sample to read.
*
* @parm LONG | lSamples | Specifies the number of samples to read.
*
* @parm LPVOID | lpBuffer | Specifies a pointer to a buffer used to
*       return the data.
*
* @parm LONG | cbBuffer | Specifies the size of buffer pointed to by <p lpBuffer>.
*
* @parm LONG FAR * | plBytes | Specifies a pointer to the location
*       used to return number of bytes of data written into the
*       buffer for <p lpBuffer>.  <p plBytes> can be NULL.
*
* @parm LONG FAR * | plSamples | Specifies a pointer to the location
*       used to return the number of samples written into the buffer for
*       for <p lpBuffer>.  <p plSamples> can be NULL.
*
* @comm If <p lpBuffer> is NULL, this function does not read
*       any data; it returns information about the size of data
*       that would be read.
*
*	See <f AVIStreamLength> for a discussion of how sample numbers
*	correspond to the data you want to read.
*
* @rdesc Returns zero if successful, or an error code.  Use <p plBytes>
*	and <p plSamples> to find out how much was actually read.
*
*	Possible errors include:
*
*	@flag AVIERR_BUFFERTOOSMALL | The buffer size <p cbBuffer> was
*	    too small to read in even a single sample of data.
*
*	@flag AVIERR_MEMORY | There was not enough memory for some
*	    reason to complete the read operation.
*
*	@flag AVIERR_FILEREAD | A disk error occurred while reading the
*	    file.
*
* @xref <f AVIFileGetStream> <f AVIStreamFindSample> <f AVIStreamWrite>
*
*************************************************************************/
STDAPI AVIStreamRead         (PAVISTREAM pavi,
					  LONG lStart, LONG lSamples,
					  LPVOID lpBuffer, LONG cbBuffer,
					  LONG FAR * plBytes, LONG FAR * plSamples)
{
//    if (pavi->StreamRead == NULL)
//	return -1;

    return pavi->Read(lStart, lSamples, lpBuffer, cbBuffer, plBytes, plSamples);
}

/**************************************************************************
* @doc EXTERNAL AVIStreamWrite
*
* @api LONG | AVIStreamWrite | Writes data to a stream.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm LONG | lStart | Specifies the starting sample to write.
*
* @parm LONG | lSamples | Specifies the number of samples to write.
*
* @parm LPVOID | lpBuffer | Specifies a pointer to buffer
*       containing the data to write.
*
* @parm LONG | cbBuffer | Specifies the size of buffer used by <p lpBuffer>.
*
* @parm DWORD | dwFlags | Specifies any flags associated with this data.
*       The following flags are defined:
*
* @flag AVIIF_KEYFRAME | Indicates this data does not rely on preceding
*       data in the file.
*
* @parm LONG FAR * | plSampWritten | Specifies a pointer to a location
*       used to return the number of samples written. This can be set
*       to NULL.
*
* @parm LONG FAR * | plBytesWritten | Specifies a pointer to a location
*       used to return the number of bytes written. This can be set
*       to NULL.
*
* @comm The default AVI file handler only supports writing to the end
*	of a stream.  The WAVE file handler supports writing anywhere.
*
*	This function overwrites existing data, rather than inserting
*	new data.
*
*	See <f AVIStreamLength> for a discussion of how sample numbers
*	correspond to the data you want to read.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref <f AVIFileGetStream> <f AVIFileCreateStream> <f AVIStreamRead>
*
*************************************************************************/
STDAPI AVIStreamWrite        (PAVISTREAM pavi,
			      LONG lStart, LONG lSamples,
			      LPVOID lpBuffer, LONG cbBuffer,
			      DWORD dwFlags,
			      LONG FAR *plSampWritten,
			      LONG FAR *plBytesWritten)
{
//    if (pavi->StreamWrite == NULL)
//	return -1;

    return pavi->Write(lStart, lSamples, lpBuffer, cbBuffer,
		       dwFlags, plSampWritten, plBytesWritten);
}

/**************************************************************************
* @doc INTERNAL AVIStreamDelete
*
* @api LONG | AVIStreamDelete | Deletes data from a stream.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm LONG | lStart | Specifies the starting sample to delete.
*
* @parm LONG | lSamples | Specifies the number of samples to delete.
*
* @devnote This isn't implemented by anybody yet.  Should it be?  Wave files,
*	for instance, would have to copy lots of data around....
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref
*
*************************************************************************/
STDAPI AVIStreamDelete       (PAVISTREAM pavi, LONG lStart, LONG lSamples)
{
//    if (pavi->StreamDelete == NULL)
//	return -1;

    return pavi->Delete(lStart, lSamples);
}

#if 0
// !!! should this exist?
STDAPI AVIStreamClone	 (PAVISTREAM pavi, PAVISTREAM FAR *ppaviNew)
{
//    if (pavi->StreamClone == NULL)
//	return -1;

    return pavi->Clone(ppaviNew);
}
#endif

/**************************************************************************
* @doc EXTERNAL AVIStreamStart
*
* @api LONG | AVIStreamStart | Returns the starting sample of the stream.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @rdesc Returns the starting sample number for the stream, or -1 on error.
*
* @comm See <f AVIStreamLength> for a discussion of how sample numbers
*	correspond to the data you want to read.
*
* @xref <f AVIStreamSampleToTime> <f AVIStreamLength>
*
*************************************************************************/
STDAPI_(LONG) AVIStreamStart        (PAVISTREAM pavi)
{
    AVISTREAMINFOW	    avistream;

    pavi->Info(&avistream, sizeof(avistream));

    return (LONG) avistream.dwStart;
}

/**************************************************************************
* @doc EXTERNAL AVIStreamLength
*
* @api LONG | AVIStreamLength | Returns the length of the stream in samples.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @devnote Currently, this doesn't call a handler function at all.
*
* @rdesc Returns the stream's length in samples, or -1 on error.
*
* @comm Values in samples can be converted to milliseconds using
*	the <f AVIStreamSampleToTime> function.
*
*	For video streams, each sample generally corresponds to a
*	frame of video.  There may, however, be sample numbers for
*	which no video data is actually present: If <f AVIStreamRead>
*	is called at those positions, it will return a data length
*	of zero bytes.  You can use <f AVIStreamFindSample> with the
*	FIND_ANY flag to find sample numbers which actually have data.
*
*	For audio streams, each sample corresponds to one "block"
*	of data.  Note the conflicting terminology here: if you're
*	working with 22KHz ADPCM data, each block of audio data is
*	256 bytes, corresponding to about 500 "audio samples" which
*	will be presented to the speaker each 22000th of a second.
*	From the point of view of the AVIFile APIs, however, each 256-byte
*	block is a single sample, because they cannot be subdivided.
*
*	Note that the stream's starting position may not be zero; see
*	<f AVIStreamStart>.  Valid positions within a stream range from
*	start to start+length; there is no actual data present at position
*	start+length, but that corresponds to a time after the last data
*	has been rendered.
*
* @xref <f AVIStreamInfo>
*
*************************************************************************/
STDAPI_(LONG) AVIStreamLength       (PAVISTREAM pavi)
{
    AVISTREAMINFOW	    avistream;
    HRESULT		    hr;

    hr = pavi->Info(&avistream, sizeof(avistream));

    if (hr != NOERROR) {
	DPF("Error in AVIStreamLength!\n");
	return 1;
    }

    return (LONG) avistream.dwLength;
}

/**************************************************************************
* @doc EXTERNAL AVIStreamTimeToSample
*
* @api LONG | AVIStreamTimeToSample | Converts from milliseconds to samples.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm LONG | lTime | Specifies the time in milliseconds.
*
* @devnote Currently, this doesn't call a handler function at all.
*
* @comm Samples typically correspond to audio samples or video frames.
*       Other stream types might support different formats than these.

* @rdesc Returns the converted time, or -1 on error.
*
* @xref AVIStreamSampleToTime
*
*************************************************************************/
STDAPI_(LONG) AVIStreamTimeToSample (PAVISTREAM pavi, LONG lTime)
{
    AVISTREAMINFOW	    avistream;
    HRESULT		    hr;
    LONG		    lSample;

    // Invalid time
    if (lTime < 0)
	return -1;

    hr = pavi->Info(&avistream, sizeof(avistream));

    if (hr != NOERROR || avistream.dwScale == 0 || avistream.dwRate == 0) {
	DPF("Error in AVIStreamTimeToSample!\n");
	return lTime;
    }

    // This is likely to overflow if we're not careful for long AVIs
    // so keep the 1000 inside the brackets.

    if (avistream.dwRate / avistream.dwScale < 1000)
	lSample =  muldivrd32(lTime, avistream.dwRate, avistream.dwScale * 1000);
    else
	lSample =  muldivru32(lTime, avistream.dwRate, avistream.dwScale * 1000);

    lSample = min(max(lSample, (LONG) avistream.dwStart),
		  (LONG) (avistream.dwStart + avistream.dwLength));

    return lSample;
}

/**************************************************************************
* @doc EXTERNAL AVIStreamSampleToTime
*
* @api LONG | AVIStreamSampleToTime | Converts from samples to milliseconds.
*   Samples can correspond to blocks of audio samples, video frames, or other format
*   depending on the stream type.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm LONG | lSample | Specifies the position information.
*
* @rdesc Returns the converted time, or -1 on error.
*
* @xref <f AVIStreamTimeToSample>
*
*************************************************************************/
STDAPI_(LONG) AVIStreamSampleToTime (PAVISTREAM pavi, LONG lSample)
{
    AVISTREAMINFOW	    avistream;
    HRESULT		    hr;

    hr = pavi->Info(&avistream, sizeof(avistream));

    if (hr != NOERROR || avistream.dwRate == 0 || avistream.dwScale == 0) {
	DPF("Error in AVIStreamSampleToTime!\n");
	return lSample;
    }

    lSample = min(max(lSample, (LONG) avistream.dwStart),
		  (LONG) (avistream.dwStart + avistream.dwLength));

    // lSample * 1000 would overflow too easily
    if (avistream.dwRate / avistream.dwScale < 1000)
	return muldivrd32(lSample, avistream.dwScale * 1000, avistream.dwRate);
    else
	return muldivru32(lSample, avistream.dwScale * 1000, avistream.dwRate);
}


/**************************************************************************
* @doc EXTERNAL AVIStreamOpenFromFile
*
* @api LONG | AVIStreamOpenFromFile | This function provides a convenient
*      way to open a single stream from a file.
*
* @parm PAVISTREAM FAR * | ppavi | Specifies a pointer to the location
*       used to return the new stream handle.
*
* @parm LPCTSTR | szFile | Specifies a zero-terminated string containing
*       the name of the file to open.
*
* @parm DWORD | fccType | Specifies a four-character code
*       indicating the type of stream to be opened.
*       Zero indicates that any stream can be opened. The following
*       definitions apply to the data commonly
*       found in AVI streams:
*
* @flag streamtypeAUDIO | Indicates an audio stream.
* @flag streamtypeMIDI | Indicates a MIDI stream.
* @flag streamtypeTEXT | Indicates a text stream.
* @flag streamtypeVIDEO | Indicates a video stream.
*
* @parm LONG | lParam | Indicates which stream of the type specified in
*	<p fccType> should actually be accessed.
*
* @parm UINT | mode | Specifies the mode to use when opening the file.
*       This function can only open existing streams so the OF_CREATE
*       mode flag cannot be used. See
*       <f OpenFile> for more information about the available flags.
*
* @parm CLSID FAR * | pclsidHandler | Specifies a pointer to a class ID
*       identifying the handler you want to use. If NULL, the system
*       chooses one from the registration database based on the file
*       extension or the file's RIFF type.
*
* @comm Balance each call to <f AVIStreamOpenFromFile> with a
*       call to <f AVIStreamRelease> using the stream handle returned.
*
*	This function calls <f AVIFileOpen>, <f AVIFileGetStream>, and
*       <f AVIFileRelease>.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref <f AVIFileOpen> <f AVIFileGetStream>
*
*************************************************************************/
STDAPI AVIStreamOpenFromFileW(PAVISTREAM FAR *ppavi,
				  LPCWSTR szFile,
				  DWORD fccType, LONG lParam,
				  UINT mode, CLSID FAR *pclsidHandler)
{
    PAVIFILE	pfile;
    HRESULT	hr;

    hr = AVIFileOpenW(&pfile, szFile, mode, pclsidHandler);

    if (!FAILED(GetScode(hr))) {
	hr  = AVIFileGetStream(pfile, ppavi, fccType, lParam);

        AVIFileRelease(pfile);  // the stream still has a reference to the file
    }

    return hr;
}

#ifdef _WIN32
// Ansi thunk
STDAPI AVIStreamOpenFromFileA(PAVISTREAM FAR *ppavi,
				  LPCSTR szFile,
				  DWORD fccType, LONG lParam,
				  UINT mode, CLSID FAR *pclsidHandler)
{
    PAVIFILE	pfile;
    HRESULT	hr;

    hr = AVIFileOpenA(&pfile, szFile, mode, pclsidHandler);

    if (!FAILED(GetScode(hr))) {
	hr  = AVIFileGetStream(pfile, ppavi, fccType, lParam);

        AVIFileRelease(pfile);  // the stream still has a reference to the file
    }

    return hr;
}
#endif

/**************************************************************************
* @doc EXTERNAL AVIStreamCreate
*
* @api LONG | AVIStreamCreate | Creates a stream not associated with any
*	file.
*
* @parm PAVISTREAM FAR * | ppavi | Pointer to a location to return the
*	new stream handle.
*
* @parm LONG | lParam1 | Specifies stream-handler specific information.
*
* @parm LONG | lParam2 | Specifies stream-handler specific information.
*
* @parm CLSID FAR * | pclsidHandler | Pointer to the class ID used
*       for the stream.
*
* @comm Balance each call to <f AVIStreamCreate> with a
*       call to <f AVIStreamRelease>.
*
*	You should not need to call this function; functions like
*	<f CreateEditableStream> and <f AVIMakeCompressedStream>
*	use it internally.
*
* @rdesc Returns zero if successful; otherwise returns an error code.
*
* @xref <f AVIFileOpen> <f AVIFileGetStream>
*
*************************************************************************/
STDAPI AVIStreamCreate (PAVISTREAM FAR *ppavi, LONG lParam1, LONG lParam2,
		      CLSID FAR *pclsidHandler)
{
    CLSID   clsid;
    HRESULT hr;

    if (!iInit) {
	return ResultFromScode(E_UNEXPECTED);
    }

    if (pclsidHandler)
	clsid = *pclsidHandler;
    else {
	return ResultFromScode(REGDB_E_CLASSNOTREG);
    }

    if (FAILED(GetScode(hr = CoCreateInstance((REFCLSID) clsid,
					 NULL, CLSCTX_INPROC,
					 (REFIID) IID_IAVIStream,
					 (void FAR* FAR*)ppavi))))
	return hr;

    if (FAILED(GetScode(hr = (*ppavi)->Create(lParam1, lParam2)))) {
	(*ppavi)->Release();
	// AVIStreamExit();
    }

    return AVIERR_OK;
}


/**************************************************************************
* @doc EXTERNAL AVIStreamBeginStreaming
*
* @api LONG | AVIStreamBeginStreaming | Specifies the parameters for
*      streaming and lets a stream handler prepare for streaming.
*
* @parm PAVISTREAM | pavi | Specifies a pointer to a stream.
*
* @parm LONG | lStart | Specifies the starting point for streaming.
*
* @parm LONG | lEnd | Specifies the ending point for streaming.
*
* @parm LONG | lRate | Specifies the speed at which the file will be
*	read relative to its natural speed.  Specify 1000 for the normal speed.
*
* @comm Many stream implementations ignore this function.
*
* @rdesc Returns zero if successful; otherwise returns an error code.
*
* @xref <f AVIStreamEndStreaming>
*
*************************************************************************/
STDAPI AVIStreamBeginStreaming(PAVISTREAM   pavi,
			       LONG	    lStart,
			       LONG	    lEnd,
			       LONG	    lRate)
{
    IAVIStreaming FAR * pi;
    HRESULT hr;

    if (FAILED(GetScode(pavi->QueryInterface(IID_IAVIStreaming,
					     (void FAR* FAR*) &pi))))
	return AVIERR_OK;

    hr = pi->Begin(lStart, lEnd, lRate);

    pi->Release();

    return hr;
}


/**************************************************************************
* @doc EXTERNAL AVIStreamEndStreaming
*
* @api LONG | AVIStreamEndStreaming | Ends streaming.
*
* @parm PAVISTREAM | pavi | Specifies a pointer to a stream.
*
* @comm Many stream implementations ignore this function.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref AVIStreamBeginStreaming
*
*************************************************************************/
STDAPI AVIStreamEndStreaming(PAVISTREAM   pavi)
{
    IAVIStreaming FAR * pi;
    HRESULT hr;

    if (FAILED(GetScode(pavi->QueryInterface(IID_IAVIStreaming, (LPVOID FAR *) &pi))))
	return AVIERR_OK;

    hr = pi->End();

    pi->Release();

    return hr;
}

#if 0
/*******************************************************************
* @doc INTERNAL AVIStreamHasChanged
*
* @api LONG | AVIStreamHasChanged | This function forces an update
* of the strem information for the specified stream.
*
* @parm PAVISTREAM | pavi | Interface pointer for an AVI stream instance.
*
* @rdesc Returns AVIERR_OK on success.
*
****************************************************************/
STDAPI AVIStreamHasChanged(PAVISTREAM pavi)
{
    pavi->lFrame = -4224;   // bogus value

    AVIStreamInfo(pavi, &pavi->avistream, sizeof(pavi->avistream));

    // !!! Only need to do this if format changes?
    AVIReleaseCachedData(pavi);

    return AVIERR_OK;
}
#endif

#ifdef _WIN32
static SZCODE aszRegCompressors[] = TEXT("AVIFile\\Compressors\\%.4hs");
#else
static SZCODE aszRegCompressors[] = TEXT("AVIFile\\Compressors\\%.4ls");
#endif

/*******************************************************************
* @doc EXTERNAL AVIMakeCompressedStream
*
* @api HRESULT | AVIMakeCompressedStream | Returns a pointer to a
*      compressed stream created from an uncompressed stream.
*      The uncompressed stream is compressed using
*      the compression options specified.
*
* @parm PAVISTREAM FAR * | ppsCompressed | Specifies a pointer to
*       the location used to return the compressed stream pointer.
*
* @parm PAVISTREAM | psSource | Specifies a pointer to the stream to be compressed.
*
* @parm AVICOMPRESSOPTIONS FAR * | lpOptions | Specifies a pointer to a
*       structure indicating the type compression to use and the options
*       to apply.
*
* @parm CLSID FAR * | pclsidHandler | Specifies a pointer to a
*       class ID used to create the stream.
*
* @comm This supports both audio and video compression. Applications
*       can use the created stream for reading or writing.
*
*   For video compression, either specify a handler to use or specify
*   the format for the compressed data.
*
*   For audio compression, you can only specify a format for the compressed
*   data.
*
* @rdesc Returns AVIERR_OK on success, or an error code.
*	Possible errors include:
*
*   @flag AVIERR_NOCOMPRESSOR | No suitable compressor can be found.
*
*   @flag AVIERR_MEMORY | There was not enough memory to complete the operation.
*
*   @flag AVIERR_UNSUPPORTED | Compression is not supported for this type
*	of data.  This error may be returned if you try to compress
*	data that is not audio or video.
*
*
*
****************************************************************/
STDAPI AVIMakeCompressedStream(
		PAVISTREAM FAR *	    ppsCompressed,
		PAVISTREAM		    psSource,
		AVICOMPRESSOPTIONS FAR *    lpOptions,
		CLSID FAR *pclsidHandler)
{
    CLSID   clsid;
    TCHAR    achKey[100];
    TCHAR    achClass[100];
    LONG    lcbClass;
    AVISTREAMINFO strhdr;
    HRESULT hr;


    *ppsCompressed = NULL;

    if (pclsidHandler) {
	clsid = *pclsidHandler;
    } else {
	if (FAILED(GetScode(hr = AVIStreamInfo(psSource,
					       &strhdr,
					       sizeof(strhdr)))))
	    return hr;

	// Look up the stream type in the registration database to find
	// the appropriate compressor....
	wsprintf(achKey, aszRegCompressors, (LPSTR) &strhdr.fccType);

	lcbClass = sizeof(achClass);
	RegQueryValue(HKEY_CLASSES_ROOT, achKey, achClass, &lcbClass);

        if (!GUIDFromString(achClass, &clsid))
	    return ResultFromScode(AVIERR_UNSUPPORTED);
    }

    if (FAILED(GetScode(hr = CoCreateInstance((REFCLSID) clsid,
					 NULL, CLSCTX_INPROC,
					 (REFIID) IID_IAVIStream,
					 (void FAR* FAR*)ppsCompressed))))
	return hr;  // !!! PropagateHResult?

    if (FAILED(GetScode(hr = (*ppsCompressed)->Create((LPARAM) psSource,
						  (LPARAM) lpOptions)))) {
	(*ppsCompressed)->Release();
	*ppsCompressed = NULL;
	return hr;
    }

    return AVIERR_OK;
}


typedef struct {
    TCHAR	achClsid[64];
    TCHAR	achExtString[128];
} TEMPFILTER, FAR * LPTEMPFILTER;

SZCODE aszAnotherExtension[] = TEXT(";*.%s");

/***************************************************************************
 *
 * @doc INTERNAL MCIAVI
 *
 * @api LONG | atol | local version of atol
 *
 ***************************************************************************/

static LONG NEAR PASCAL atol(TCHAR FAR *sz)
{
    LONG l = 0;

    while (*sz)
    	l = l*10 + *sz++ - TEXT('0');
    	
    return l;    	
}	


// lstrcat lines will compile wrong with optimizations
// compiler! - Have less bugs!
#ifndef _WIN32
#pragma optimize("", off)
#endif

/*******************************************************************
* @doc EXTERNAL AVIBuildFilter
*
* @api HRESULT | AVIBuildFilter | Builds a filter specification for passing
*   to <f GetOpenFileName> or <f GetSaveFileName>.
*
* @parm LPTSTR | lpszFilter | Pointer to buffer where the filter string
*   should be returned.
*
* @parm LONG | cbFilter | Size of buffer pointed to by <p lpszFilter>.
*
* @parm BOOL | fSaving | Indicates whether the filter should include only
*   formats that can be written, or all formats that can be read.
*
* @rdesc Returns AVIERR_OK on success.
*
* @comm This function does not check if the DLLs referenced
*       in the registration database actually exist.
*
****************************************************************/
STDAPI AVIBuildFilter(LPTSTR lpszFilter, LONG cbFilter, BOOL fSaving)
{
#define MAXFILTERS  256
    LPTEMPFILTER    lpf;
    int		    i;
    int		    cf = 0;
    HKEY    hkey;
    LONG    lRet;
    DWORD   dwSubKey;
    TCHAR   ach[128];
    TCHAR   ach2[128];
    TCHAR   achExt[10];
    LONG    cb;
    TCHAR   achAllFiles[40];
    int	    cbAllFiles;

    // This string has a NULL in it, so remember its length for real....
    cbAllFiles = LoadString(ghMod,
			    IDS_ALLFILES,
			    achAllFiles,
			    sizeof(achAllFiles)/sizeof(TCHAR));
    for (i = 0; i < cbAllFiles; i++)
	if (achAllFiles[i] == TEXT('@'))
	    achAllFiles[i] = TEXT('\0');

    // Allocate a largish amount of memory (98304 until the constants change)
    lpf = (LPTEMPFILTER) GlobalAllocPtr(GHND, sizeof(TEMPFILTER) * MAXFILTERS);

    if (!lpf) {
	return ResultFromScode(AVIERR_MEMORY);
    }

    lRet = RegOpenKey(HKEY_CLASSES_ROOT, aszRegExt, &hkey);

    if (lRet != ERROR_SUCCESS) {
	GlobalFreePtr(lpf);
	return ResultFromScode(AVIERR_ERROR);
    }

    // Make sure that AVI files come first in the list....
    // !!! Should use StringFromClsid here!
    lstrcpy(lpf[1].achClsid, TEXT("{00020000-0000-0000-C000-000000000046}"));
    cf = 1;

    //
    // First, scan through the Extensions list looking for all of the
    // handlers that are installed
    //
    for (dwSubKey = 0; ; dwSubKey++) {
	lRet = RegEnumKey(hkey, dwSubKey, achExt, sizeof(achExt)/sizeof(achExt[0]));

	if (lRet != ERROR_SUCCESS) {
	    break;
	}

	cb = sizeof(ach);
	lRet = RegQueryValue(hkey, achExt, ach, &cb);
	
	if (lRet != ERROR_SUCCESS) {
	    break;
	}

	//
	// See if we've seen this handler before
	//
	for (i = 1; i <= cf; i++) {
	    if (lstrcmp(ach, lpf[i].achClsid) == 0) {
		break;

	    }
	}

	//
	// If not, add it to our list of handlers
	//
	if (i == cf + 1) {
	    if (cf == MAXFILTERS) {
		DPF("Too many filters!\n");
		continue;
	    }
	
	    lstrcpy(lpf[i].achClsid, ach);
	
	    cb = sizeof(ach);
	    wsprintf(ach2, TEXT("%s\\AVIFile"), (LPTSTR) ach);
	    lRet = RegQueryValue(hkey, ach2, ach, &cb);
	    if (ERROR_SUCCESS == lRet) {
		lRet = atol(ach);

		if (fSaving) {
		    if (!(lRet & AVIFILEHANDLER_CANWRITE))
			continue;
		} else {
		    if (!(lRet & AVIFILEHANDLER_CANREAD))
			continue;
		}
	    }

	    cf++;
	}
	
	wsprintf(ach, aszAnotherExtension, (LPTSTR) achExt);
	
	lstrcat(lpf[i].achExtString, lpf[i].achExtString[0] ?
						ach : ach + 1);
	
	lstrcat(lpf[0].achExtString, lpf[0].achExtString[0] ?
						ach : ach + 1);
    }

    RegCloseKey(hkey);

    lRet = RegOpenKey(HKEY_CLASSES_ROOT, aszRegClsid, &hkey);

    if (lRet != ERROR_SUCCESS) {
	GlobalFreePtr(lpf);
	return ResultFromScode(AVIERR_ERROR);
    }

    //
    // Now, scan through our list of handlers and build up the
    // filter to use....
    //
    for (i = 0; i <= cf; i++) {
	if (i == 0) {
	    cb = wsprintf(lpszFilter, TEXT("All multimedia files")) + 1;  // !!!
	} else {

	    cb = sizeof(ach);
	    lRet = RegQueryValue(hkey, lpf[i].achClsid, ach, &cb);
	    if (ERROR_SUCCESS != lRet) {
		continue;  // iterate if we fail to read the data
	    }

	    if (cbFilter < (LONG)(lstrlen(lpf[i].achExtString) +
			    (LONG)lstrlen(ach) + 10)) {
		break; // !!!
	    }

	    cb = wsprintf(lpszFilter, TEXT("%s"), // "%s (%s)", Todd doesn't like this
			  (LPTSTR) ach, (LPTSTR) lpf[i].achExtString) + 1;
	}

	cbFilter -= cb;
	lpszFilter += cb;

#ifdef UNICODE
        lstrcpynW(
#else
	_fstrncpy(
#endif
                    lpszFilter, lpf[i].achExtString, (int) cbFilter);

	cbFilter -= lstrlen(lpf[i].achExtString) + 1;
	lpszFilter += lstrlen(lpf[i].achExtString) + 1;

	if (cbFilter <= 0) {
	    GlobalFreePtr(lpf);
	    RegCloseKey(hkey);
	    return ResultFromScode(AVIERR_BUFFERTOOSMALL);
	}
    }

    if (cbFilter > cbAllFiles) {
	_fmemcpy(lpszFilter, achAllFiles, cbAllFiles*sizeof(TCHAR));
	cbFilter -= cbAllFiles;
	lpszFilter += cbAllFiles;
    }

    RegCloseKey(hkey);
	
    *lpszFilter++ = TEXT('\0');
    --cbFilter;		     // This line is bogus

    GlobalFreePtr(lpf);

    return AVIERR_OK;
}

#ifndef _WIN32
#pragma optimize("", on)
#endif

#ifdef UNICODE
// Ansi thunk for AVIBuildFilter
STDAPI AVIBuildFilterA(LPSTR lpszFilter, LONG cbFilter, BOOL fSaving)
{

    // get the UNICODE filter block
    LPWSTR lpW, lpWSave;
    HRESULT hr;
    int sz;

    int    cbCount,cbMFilter=0;

    lpWSave = lpW = (LPWSTR)(LocalAlloc(LPTR, cbFilter * sizeof(WCHAR)));

    hr = AVIBuildFilterW(lpW, cbFilter, fSaving);

    if (FAILED(hr)) {
        LocalFree((HANDLE)lpW);
	return hr;
    }

    // now translate each null-term unicode string in the double-null block
    LPSTR pFilter = lpszFilter;
    while( (sz = lstrlen(lpW)) > 0) {

	// add on space for NULL
	sz++;

//#ifdef DBCS
//The maximum number of DBCS Multibyte string bytes is not equal
//  to the number of Widechar string charcters.
    cbCount = WideCharToMultiByte(CP_ACP, 0, lpW, -1,
			pFilter, cbFilter-cbMFilter-1, NULL, NULL);
    cbMFilter += cbCount;
    pFilter += cbCount;
    lpW += sz;
    if( cbMFilter >= cbFilter-1 )	break;
//#else
//	wcstombs(pFilter, lpW, sz);
//	lpW += sz;
//	pFilter += sz;
//#endif
    }

    // add extra terminating null
    *pFilter = '\0';

    LocalFree((HANDLE)lpWSave);
    return hr;
}
#else
#ifdef _WIN32
STDAPI AVIBuildFilterW(LPWSTR lpszFilter, LONG cbFilter, BOOL fSaving)
{
    return E_FAIL;
}
#endif
#endif




/*****************************************************************************
 *
 * dprintf() is called by the DPF macro if DEBUG is defined at compile time.
 *
 * The messages will be send to COM1: like any debug message. To
 * enable debug output, add the following to WIN.INI :
 *
 * [debug]
 * ICSAMPLE=1
 *
 ****************************************************************************/

#ifdef DEBUG

//
// I wish languages would make up their mind about defines!!!!!
//
#ifndef WINDLL
#define WINDLL
#define _WINDLL
#define __WINDLL
#endif
#include <stdarg.h>

#define MODNAME "AVIFILE"
static int iDebug = -1;

void cdecl dpf(LPSTR szFormat, va_list va)
{
#ifdef _WIN32
    char ach[512];
#else
    char ach[128];
#endif
    UINT n=0;

    if (szFormat[0] == '!')
        ach[0]=0, szFormat++;
    else {
#ifdef _WIN32
	n = wsprintfA(ach, MODNAME": (tid %x) ", GetCurrentThreadId());
#else
        lstrcpyA(ach, MODNAME ": ");
	n = lstrlenA(ach);
#endif
    }

    wvsprintfA(ach+n,szFormat,va);
    OutputDebugStringA(ach);
}

void cdecl dprintf0(LPSTR szFormat, ...)
{
    va_list va;
    va_start(va, szFormat);
    dpf(szFormat, va);
    va_end(va);
}


void cdecl dprintf(LPSTR szFormat, ...)
{
    if (iDebug == -1)
        iDebug = GetProfileIntA("Debug", MODNAME, 0);

    if (iDebug < 1)
        return;

    va_list va;
    va_start(va, szFormat);
    dpf(szFormat, va);
    va_end(va);
}

void cdecl dprintf2(LPSTR szFormat, ...)
{
    if (iDebug == -1)
        iDebug = GetProfileIntA("Debug", MODNAME, 0);

    if (iDebug < 2)
        return;

    va_list va;
    va_start(va, szFormat);
    dpf(szFormat, va);
    va_end(va);
}

void cdecl dprintf3(LPSTR szFormat, ...)
{
    if (iDebug == -1)
        iDebug = GetProfileIntA("Debug", MODNAME, 0);

    if (iDebug < 3)
        return;

    va_list va;
    va_start(va, szFormat);
    dpf(szFormat, va);
    va_end(va);
}

#endif

#ifdef DEBUG

/* _Assert(szExpr, szFile, iLine)
 *
 * If <fExpr> is TRUE, then do nothing.  If <fExpr> is FALSE, then display
 * an "assertion failed" message box allowing the user to abort the program,
 * enter the debugger (the "Retry" button), or igore the error.
 *
 * <szFile> is the name of the source file; <iLine> is the line number
 * containing the _Assert() call.
 */
void FAR PASCAL
_Assert(char *szExp, char *szFile, int iLine)
{
	static char	ach[300];	// debug output (avoid stack overflow)
	int		id;
	void FAR PASCAL DebugBreak(void);

        /* display error message */

        if (szExp)
            wsprintfA(ach, "(%s)\nFile %s, line %d", (LPSTR)szExp, (LPSTR)szFile, iLine);
        else
            wsprintfA(ach, "File %s, line %d", (LPSTR) szFile, iLine);

	MessageBeep(MB_ICONHAND);
	id = MessageBoxA(NULL, ach, "Assertion Failed", MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE);
	/* abort, debug, or ignore */
	switch (id)
	{
	case IDABORT:
                FatalAppExit(0, TEXT("Good Bye"));
		break;

	case IDRETRY:
		/* break into the debugger */
		DebugBreak();
		break;

	case IDIGNORE:
		/* ignore the assertion failure */
		break;
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\avilibcf.cpp ===
/*	-	-	-	-	-	-	-	-	*/

/*
**	Copyright (C) Microsoft Corporation 1993 - 1995. All rights reserved.
*/

/*	-	-	-	-	-	-	-	-	*/

#include <win32.h>
#include <vfw.h>
#include "avifilei.h"
#include "avicmprs.h"
#include "acmcmprs.h"
#include "wavefile.h"

#ifdef CHICAGO
#include "unmarsh.h"
#endif
#include "editstrm.h"

/*	-	-	-	-	-	-	-	-	*/

HRESULT CAVIFileCF::Create(
	const CLSID FAR&	rclsid,
	REFIID	riid,
	LPVOID FAR*	ppv)
{
	CAVIFileCF FAR*	pAVIFileCF;
	IUnknown FAR*	pUnknown;
	HRESULT hresult;

	pAVIFileCF = new FAR CAVIFileCF(rclsid, &pUnknown);
	if (pAVIFileCF == NULL)
		return ResultFromScode(E_OUTOFMEMORY);
	hresult = pUnknown->QueryInterface(riid, ppv);
	if (FAILED(GetScode(hresult)))
		delete pAVIFileCF;
	return hresult;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIFileCF::CAVIFileCF(
	const CLSID FAR&	rclsid,
	IUnknown FAR* FAR*	ppUnknown) :
	m_Unknown(this),
	m_Factory(this)
{
	m_clsid = rclsid;
	*ppUnknown = &m_Unknown;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIFileCF::CUnknownImpl::CUnknownImpl(
	CAVIFileCF FAR*	pAVIFileCF)
{
	m_pAVIFileCF = pAVIFileCF;
	m_refs = 0;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIFileCF::CUnknownImpl::QueryInterface(
	REFIID	iid,
	LPVOID FAR*	ppv)
{
	if (iid == IID_IUnknown)
		*ppv = &m_pAVIFileCF->m_Unknown;
	else if (iid == IID_IClassFactory)
		*ppv = &m_pAVIFileCF->m_Factory;
	else {
		*ppv = NULL;
		return ResultFromScode(E_NOINTERFACE);
	}
	AddRef();
	return AVIERR_OK;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIFileCF::CUnknownImpl::AddRef()
{
	return ++m_refs;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIFileCF::CUnknownImpl::Release()
{
	if (!--m_refs) {
		delete this;
		return 0;
	}
	return m_refs;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIFileCF::CFactoryImpl::CFactoryImpl(
	CAVIFileCF FAR*	pAVIFileCF)
{
	m_pAVIFileCF = pAVIFileCF;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIFileCF::CFactoryImpl::QueryInterface(
	REFIID	iid,
	LPVOID FAR*	ppv)
{
	return m_pAVIFileCF->m_Unknown.QueryInterface(iid, ppv);
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIFileCF::CFactoryImpl::AddRef()
{
	return m_pAVIFileCF->m_Unknown.AddRef();
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIFileCF::CFactoryImpl::Release()
{
	return m_pAVIFileCF->m_Unknown.Release();
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIFileCF::CFactoryImpl::CreateInstance(
	IUnknown FAR*	pUnknownOuter,
	REFIID	riid,
	LPVOID FAR*	ppv)
{
	if (IsEqualCLSID(m_pAVIFileCF->m_clsid, CLSID_AVIFile)) {
		return CAVIFile::Create(pUnknownOuter, riid, ppv);
	} else
	if (IsEqualCLSID(m_pAVIFileCF->m_clsid, CLSID_AVICmprsStream)) {
		return CAVICmpStream::Create(pUnknownOuter, riid, ppv);
	} else
	if (IsEqualCLSID(m_pAVIFileCF->m_clsid, CLSID_ACMCmprs)) {
		return CACMCmpStream::MakeInst(pUnknownOuter, riid, ppv);
	} else
#ifdef CUSTOMMARSHAL
	if (IsEqualCLSID(m_pAVIFileCF->m_clsid, CLSID_AVISimpleUnMarshal)) {
		return CUnMarshal::Create(pUnknownOuter, riid, ppv);
	} else
#endif
	if (IsEqualCLSID(m_pAVIFileCF->m_clsid, CLSID_AVIWaveFileReader)) {
		return WaveFileCreate(pUnknownOuter, riid, ppv);
	} else
	if (IsEqualCLSID(m_pAVIFileCF->m_clsid, CLSID_EditStream)) {
		return CEditStream::NewInstance(pUnknownOuter, riid, ppv);
	} else {
		return ResultFromScode(CO_E_CANTDETERMINECLASS); // !!!
	}
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIFileCF::CFactoryImpl::LockServer(
	BOOL	fLock)
{
	fLocked = fLock;
	return AVIERR_OK;
}

/*	-	-	-	-	-	-	-	-	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\avimem.h ===
/*	-	-	-	-	-	-	-	-	*/

/*
**	Copyright (C) Microsoft Corporation 1993 - 1995. All rights reserved.
*/

#ifdef __cplusplus
class FAR CAVIMemStream : public IAVIStream {
public:
    CAVIMemStream();
public:
    STDMETHODIMP QueryInterface(const IID FAR& riid, void FAR* FAR* ppv);	\
    STDMETHODIMP_(ULONG) AddRef();	\
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP Create      (THIS_ LPARAM lParam1, LPARAM lParam2);
    STDMETHODIMP Info        (THIS_ AVISTREAMINFOW FAR * psi, LONG lSize);
    STDMETHODIMP_(LONG)  FindSample (THIS_ LONG lPos, LONG lFlags);
    STDMETHODIMP ReadFormat  (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG FAR *cbFormat);
    STDMETHODIMP SetFormat   (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG cbFormat);
    STDMETHODIMP Read        (THIS_ LONG lStart, LONG lSamples,
			    LPVOID lpBuffer, LONG cbBuffer,
			    LONG FAR * plBytes, LONG FAR * plSamples);
    STDMETHODIMP Write       (THIS_ LONG lStart, LONG lSamples,
			      LPVOID lpBuffer, LONG cbBuffer,
			      DWORD dwFlags,
			      LONG FAR *plSampWritten,
			      LONG FAR *plBytesWritten);
    STDMETHODIMP Delete      (THIS_ LONG lStart, LONG lSamples);
    STDMETHODIMP ReadData    (THIS_ DWORD fcc, LPVOID lp, LONG FAR *lpcb);
    STDMETHODIMP WriteData   (THIS_ DWORD fcc, LPVOID lp, LONG cb);
#ifdef _WIN32
    STDMETHODIMP SetInfo(AVISTREAMINFOW FAR *lpInfo, LONG cbInfo);
#else
    STDMETHODIMP Reserved1            (THIS);
    STDMETHODIMP Reserved2            (THIS);
    STDMETHODIMP Reserved3            (THIS);
    STDMETHODIMP Reserved4            (THIS);
    STDMETHODIMP Reserved5            (THIS);
#endif

public:
    ULONG	m_refs;

    LPVOID	m_lpMemory;

    LPVOID	m_lpFormat;
    LONG	m_cbFormat;
    LPVOID	m_lpData;
    LONG	m_cbData;

    AVISTREAMINFOW     m_avistream;      // stream info
};
#endif

#ifdef __cplusplus
extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\avimem.cpp ===
/****************************************************************************
 *
 *  AVIMEM.C
 *
 *  routine for putting a stream interface on top of data in memory
 *
 *  Copyright (c) 1992  - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>
#include <vfw.h>
#include "avifilei.h"
#include "avimem.h"

#define WIDTHBYTES(i)       ((UINT)((i+31)&(~31))/8)
#define DIBWIDTHBYTES(lpbi) (UINT)WIDTHBYTES((UINT)(lpbi)->biWidth * (UINT)(lpbi)->biBitCount)

STDAPI AVIMakeStreamFromClipboard(UINT cfFormat, HANDLE hGlobal, PAVISTREAM FAR *ppstream)
{
    CAVIMemStream FAR*	pAVIStream;
    HRESULT		hr;
    LPVOID		lp;

    if (cfFormat != CF_DIB && cfFormat != CF_WAVE)
	return ResultFromScode(AVIERR_UNSUPPORTED);

    pAVIStream = new FAR CAVIMemStream();
    if (!pAVIStream)
	return ResultFromScode(E_OUTOFMEMORY);

    lp = GlobalAllocPtr(GMEM_MOVEABLE, GlobalSize(hGlobal));
    if (!lp)
	return ResultFromScode(E_OUTOFMEMORY);

    hmemcpy(lp, GlobalLock(hGlobal), GlobalSize(hGlobal));
	
    pAVIStream->Create((LPARAM) cfFormat, (LPARAM) lp);

    GlobalUnlock(hGlobal);

    hr = pAVIStream->QueryInterface(IID_IAVIStream, (LPVOID FAR *) ppstream);
    if (FAILED(GetScode(hr)))
	delete pAVIStream;
    return hr;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIMemStream::CAVIMemStream()
{
    m_lpData = NULL;
    m_lpMemory = NULL;
    m_lpFormat = NULL;
    m_refs = 0;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIMemStream::QueryInterface(
	const IID FAR&	iid,
	void FAR* FAR*	ppv)
{
    if (iid == IID_IUnknown)
	*ppv = this;
    else if (iid == IID_IAVIStream)
	*ppv = this;
    else {
	*ppv = NULL;
	return ResultFromScode(E_NOINTERFACE);
    }
    AddRef();
    return AVIERR_OK;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIMemStream::AddRef()
{
    uUseCount++;
    return ++m_refs;
}


/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIMemStream::Create(LPARAM lParam1, LPARAM lParam2)
{
    UINT    cfFormat = (UINT) lParam1;
    m_lpMemory = (LPVOID) lParam2;

    if (cfFormat == CF_DIB) {
	LPBITMAPINFOHEADER lpbi;
	
	m_lpFormat = m_lpMemory;
	lpbi = (LPBITMAPINFOHEADER) m_lpFormat;

	if (lpbi->biSizeImage == 0) {
            /*  This assignment is probably wrong but it's effectively been in there
                for many years and also on win9x so we'll have to leave it like that
                Changed assignment in 'if' test to straght assignment
                Removed code to assign biSizeImage as it wasn't reachable (BI_RGB == 0)
            */
            lpbi->biCompression = BI_RGB;
	}

	_fmemset(&m_avistream, 0, sizeof(m_avistream));
	m_avistream.fccType = streamtypeVIDEO;
	m_avistream.fccHandler = 0;
	m_avistream.dwStart = 0;
	m_avistream.dwLength = 1;
	m_avistream.dwScale = 1;
	m_avistream.dwRate = 15;
	m_avistream.dwSampleSize = 0;
	SetRect(&m_avistream.rcFrame, 0, 0,
		(int) lpbi->biWidth,
		(int) lpbi->biHeight);
	
	m_cbFormat = lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);
	m_lpData = (LPBYTE) m_lpMemory + m_cbFormat;
	m_cbData = lpbi->biSizeImage;
    } else if (cfFormat == CF_WAVE) {
	DWORD _huge * lpdw;
	LPWAVEFORMAT lpwf;
#define ckidWAVEFORMAT          mmioFOURCC('f', 'm', 't', ' ')
#define ckidWAVEDATA	        mmioFOURCC('d', 'a', 't', 'a')

	lpdw = (DWORD _huge *) ((LPBYTE) m_lpMemory + 12);

	while (*lpdw != ckidWAVEFORMAT)
	    lpdw = (DWORD _huge *)
		   (((BYTE _huge *) lpdw) + lpdw[1] + sizeof(DWORD) * 2);
	
	m_lpFormat = (LPBYTE) (lpdw + 2);
	m_cbFormat = lpdw[1];

	do {
	    lpdw = (DWORD _huge *)
		   (((BYTE _huge *) lpdw) + lpdw[1] + sizeof(DWORD) * 2);
	} while (*lpdw != ckidWAVEDATA);
	
	m_lpData = (LPBYTE) (lpdw + 2);
	m_cbData = lpdw[1];

	lpwf = (LPWAVEFORMAT) m_lpFormat;
	
	_fmemset(&m_avistream, 0, sizeof(m_avistream));
	m_avistream.fccType = streamtypeAUDIO;
	m_avistream.fccHandler = 0;
	m_avistream.dwStart = 0;
	m_avistream.dwSampleSize = lpwf->nBlockAlign;
	m_avistream.dwLength = m_cbData / m_avistream.dwSampleSize;
	m_avistream.dwScale = lpwf->nBlockAlign;
	m_avistream.dwRate = lpwf->nAvgBytesPerSec;
    }

    return 0;
}

STDMETHODIMP_(ULONG) CAVIMemStream::Release()
{
    uUseCount--;
    if (!--m_refs) {
	if (m_lpMemory) {
	    GlobalFreePtr(m_lpMemory);
	}

	delete this;
	return 0;
    }

    return m_refs;
}


STDMETHODIMP CAVIMemStream::Info(AVISTREAMINFOW FAR * psi, LONG lSize)
{
    hmemcpy(psi, &m_avistream, min(lSize, sizeof(m_avistream)));

//    return sizeof(m_avistream);
    return ResultFromScode(0);
}

STDMETHODIMP CAVIMemStream::ReadFormat(LONG lPos, LPVOID lpFormat, LONG FAR *lpcbFormat)
{
    if (lpFormat) {
	hmemcpy(lpFormat, m_lpFormat, min(*lpcbFormat, (LONG) m_cbFormat));
    }

    *lpcbFormat = m_cbFormat;
    return AVIERR_OK;
}

STDMETHODIMP CAVIMemStream::Read(
                      LONG       lStart,
                      LONG       lSamples,
                      LPVOID     lpBuffer,
                      LONG       cbBuffer,
                      LONG FAR * plBytes,
                      LONG FAR * plSamples)
{
    // !!! CONVENIENT?
    if (lStart + lSamples > (LONG) m_avistream.dwLength)
	lSamples = (LONG) m_avistream.dwLength - lStart;
	
    if (lSamples == 0 || lStart >= (LONG) m_avistream.dwLength) {
	if (plBytes)
	    *plBytes = 0;
	if (plSamples)
	    *plSamples = 0;
    }

    if (m_avistream.dwSampleSize) {
	if (lSamples > 0)
	    lSamples = min(lSamples, cbBuffer / (LONG) m_avistream.dwSampleSize);
	else
	    lSamples = cbBuffer / m_avistream.dwSampleSize;

	if (plBytes)
	    *plBytes = lSamples * m_avistream.dwSampleSize;

	if (plSamples)
	    *plSamples = lSamples;

	if (lpBuffer) {
	    hmemcpy(lpBuffer,
		(BYTE _huge *) m_lpData + lStart * m_avistream.dwSampleSize,
		lSamples * m_avistream.dwSampleSize);
	
	    if (cbBuffer < (LONG) m_avistream.dwSampleSize)
	        return ResultFromScode(AVIERR_BUFFERTOOSMALL);
	}
    } else {
	if (plBytes)
	    *plBytes = m_cbData;

	if (plSamples)
	    *plSamples = 1;
	if (lpBuffer) {
	    hmemcpy(lpBuffer, m_lpData, min(cbBuffer, m_cbData));

	    if (cbBuffer < m_cbData)
		return ResultFromScode(AVIERR_BUFFERTOOSMALL);
	}
    }

    return AVIERR_OK;
}

STDMETHODIMP_(LONG) CAVIMemStream::FindSample(LONG lPos, LONG lFlags)
{
    if (lFlags & FIND_FORMAT) {
	if (lFlags & FIND_PREV)
	    return 0;
	else {
	    if (lPos > 0)
		return -1;
	    else
		return 0;
	}
    }
    return lPos;
}


STDMETHODIMP CAVIMemStream::SetFormat(LONG lPos,LPVOID lpFormat,LONG cbFormat)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVIMemStream::Write(LONG lStart,
						     LONG lSamples,
						     LPVOID lpBuffer,
						     LONG cbBuffer,
						     DWORD dwFlags,
						     LONG FAR *plSampWritten,
						     LONG FAR *plBytesWritten)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVIMemStream::Delete(LONG lStart,LONG lSamples)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVIMemStream::ReadData(DWORD fcc, LPVOID lp, LONG FAR *lpcb)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVIMemStream::WriteData(DWORD fcc, LPVOID lp, LONG cb)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

#if 0
STDMETHODIMP CAVIMemStream::Clone(PAVISTREAM FAR * ppaviNew)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

#endif

#ifdef _WIN32
STDMETHODIMP CAVIMemStream::SetInfo(AVISTREAMINFOW FAR *lpInfo, LONG cbInfo)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}
#else
STDMETHODIMP CAVIMemStream::Reserved1(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVIMemStream::Reserved2(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVIMemStream::Reserved3(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVIMemStream::Reserved4(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CAVIMemStream::Reserved5(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\aviopts.h ===
/*---------------------------------------------------------------------+
| IntOpts.h - Header file for Interleaving options dialog              |
|							               |
|(C) Copyright Microsoft Corporation 1991 - 1995.  All rights reserved.|
+---------------------------------------------------------------------*/

/*
 * Defines
 */

#define comptypeNONE            0

#include "avifile.rc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\avireg.h ===
// !!! These strings should be resources!

static TCHAR * aszReg[] = {
    // Increment the interface value if ANY change is made, otherwise NT will
    // not rewrite the correct registry values.
     TEXT("Interface\\{00020020-0000-0000-C000-000000000046}"), TEXT("AVIFile Interface 1.23"),
     TEXT("Interface\\{00020020-0000-0000-C000-000000000046}\\ProxyStubClsid"), TEXT("{0002000d-0000-0000-C000-000000000046}"),
     TEXT("Interface\\{00020020-0000-0000-C000-000000000046}\\ProxyStubClsid32"), TEXT("{0002000d-0000-0000-C000-000000000046}"),

     TEXT("Interface\\{00020021-0000-0000-C000-000000000046}"), TEXT("AVIStream Interface"),
     TEXT("Interface\\{00020021-0000-0000-C000-000000000046}\\ProxyStubClsid"), TEXT("{0002000d-0000-0000-C000-000000000046}"),
     TEXT("Interface\\{00020021-0000-0000-C000-000000000046}\\ProxyStubClsid32"), TEXT("{0002000d-0000-0000-C000-000000000046}"),

     TEXT("Clsid\\{0002000d-0000-0000-C000-000000000046}"), TEXT("IAVIStream & IAVIFile Proxy"),
     TEXT("Clsid\\{0002000d-0000-0000-C000-000000000046}\\InprocServer"), TEXT("avifile.dll"),
     TEXT("Clsid\\{0002000d-0000-0000-C000-000000000046}\\InprocServer32"), TEXT("avifil32.dll"),
     TEXT("Clsid\\{0002000d-0000-0000-C000-000000000046}\\InprocServer32"), TEXT("@ThreadingModel"), TEXT("Both"),

     TEXT("Clsid\\{00020000-0000-0000-C000-000000000046}"), TEXT("Microsoft AVI Files"),
     TEXT("Clsid\\{00020000-0000-0000-C000-000000000046}\\InprocServer"), TEXT("avifile.dll"),
     TEXT("Clsid\\{00020000-0000-0000-C000-000000000046}\\InprocServer32"), TEXT("avifil32.dll"),
     TEXT("Clsid\\{00020000-0000-0000-C000-000000000046}\\InprocServer32"), TEXT("@ThreadingModel"), TEXT("Both"),
     TEXT("Clsid\\{00020000-0000-0000-C000-000000000046}\\AVIFile"), TEXT("7"),

     TEXT("Clsid\\{00020001-0000-0000-C000-000000000046}"), TEXT("AVI Compressed Stream"),
     TEXT("Clsid\\{00020001-0000-0000-C000-000000000046}\\InprocServer"), TEXT("avifile.dll"),
     TEXT("Clsid\\{00020001-0000-0000-C000-000000000046}\\InprocServer32"), TEXT("avifil32.dll"),
     TEXT("Clsid\\{00020001-0000-0000-C000-000000000046}\\InprocServer32"), TEXT("@ThreadingModel"), TEXT("Both"),

     TEXT("Clsid\\{00020003-0000-0000-C000-000000000046}"), TEXT("Microsoft Wave File"),
     TEXT("Clsid\\{00020003-0000-0000-C000-000000000046}\\InprocServer32"), TEXT("avifil32.dll"),
     TEXT("Clsid\\{00020003-0000-0000-C000-000000000046}\\InprocServer32"), TEXT("@ThreadingModel"), TEXT("Both"),
     TEXT("Clsid\\{00020003-0000-0000-C000-000000000046}\\AVIFile"), TEXT("7"),

#ifdef CHICAGO
     TEXT("Clsid\\{00020009-0000-0000-C000-000000000046}"), TEXT("Simple AVIFile unmarshaller"),
     TEXT("Clsid\\{00020009-0000-0000-C000-000000000046}\\InprocServer"), TEXT("avifile.dll"),
     TEXT("Clsid\\{00020009-0000-0000-C000-000000000046}\\InprocServer32"), TEXT("avifil32.dll"),
     TEXT("Clsid\\{00020009-0000-0000-C000-000000000046}\\InprocServer32"), TEXT("@ThreadingModel"), TEXT("Both"),
#endif

     TEXT("Clsid\\{0002000F-0000-0000-C000-000000000046}"), TEXT("ACM Compressed Audio Stream"),
     TEXT("Clsid\\{0002000F-0000-0000-C000-000000000046}\\InprocServer"), TEXT("avifile.dll"),
     TEXT("Clsid\\{0002000F-0000-0000-C000-000000000046}\\InprocServer32"), TEXT("avifil32.dll"),
     TEXT("Clsid\\{0002000F-0000-0000-C000-000000000046}\\InprocServer32"), TEXT("@ThreadingModel"), TEXT("Both"),


     TEXT("AVIFile"), TEXT("Video for Windows 1.1 Information"),
     TEXT("AVIFile\\RIFFHandlers\\AVI"), TEXT("{00020000-0000-0000-C000-000000000046}"),
     TEXT("AVIFile\\RIFFHandlers\\WAVE"), TEXT("{00020003-0000-0000-C000-000000000046}"),

     TEXT("AVIFile\\Extensions\\AVI"), TEXT("{00020000-0000-0000-C000-000000000046}"),
     TEXT("AVIFile\\Extensions\\WAV"), TEXT("{00020003-0000-0000-C000-000000000046}"),
     TEXT("AVIFile\\Extensions\\AU"), TEXT("{00020003-0000-0000-C000-000000000046}"),
     TEXT("AVIFile\\Compressors\\vids"), TEXT("{00020001-0000-0000-C000-000000000046}"),
     TEXT("AVIFile\\Compressors\\auds"), TEXT("{0002000F-0000-0000-C000-000000000046}"),

     NULL, NULL};


#ifdef THESESHOULDNOTBEHERE
     // Since these aren't built in to AVIFILE.DLL, they should
     // be registered separately.
     TEXT("Clsid\\{00020003-0000-0000-C000-000000000046}"), TEXT("Microsoft Wave File"),
     TEXT("Clsid\\{00020003-0000-0000-C000-000000000046}\\InprocServer") S32, TEXT("wavef32.dll"),
     TEXT("Clsid\\{00020003-0000-0000-C000-000000000046}\\AVIFile"), TEXT("7"),

    #ifdef DEBUG
     TEXT("Clsid\\{00020004-0000-0000-C000-000000000046}"), TEXT("Nigel's lyric files"),
     TEXT("Clsid\\{00020004-0000-0000-C000-000000000046}\\InprocServer") S32, TEXT("lyrfile.dll"),
     TEXT("Clsid\\{00020004-0000-0000-C000-000000000046}\\AVIFile"), TEXT("1"),
    #endif

     TEXT("Clsid\\{00020006-0000-0000-C000-000000000046}"), TEXT("DIB Sequences"),
     TEXT("Clsid\\{00020006-0000-0000-C000-000000000046}\\InprocServer"), TEXT("dseqfile.dll"),
     TEXT("Clsid\\{00020006-0000-0000-C000-000000000046}\\InprocServer32"), TEXT("dseqf32.dll"),
     TEXT("Clsid\\{00020006-0000-0000-C000-000000000046}\\AVIFile"), TEXT("7"),

     TEXT("Clsid\\{0002000A-0000-0000-C000-000000000046}"), TEXT("TGA Sequences"),
     TEXT("Clsid\\{0002000A-0000-0000-C000-000000000046}\\InprocServer") S32, TEXT("tgaf32.dll"),
     TEXT("Clsid\\{0002000A-0000-0000-C000-000000000046}\\AVIFile"), TEXT("7"),

     TEXT("Clsid\\{00020007-0000-0000-C000-000000000046}"), TEXT("Autodesk FLx"),
     TEXT("Clsid\\{00020007-0000-0000-C000-000000000046}\\InprocServer") S32, TEXT("flif32.dll"),
     TEXT("Clsid\\{00020007-0000-0000-C000-000000000046}\\AVIFile"), TEXT("1"),

#ifdef DEBUG
     TEXT("Clsid\\{0002000E-0000-0000-C000-000000000046}"), TEXT("Various Medbits Formats"),
     TEXT("Clsid\\{0002000E-0000-0000-C000-000000000046}\\InprocServer") S32, TEXT("mbitfile.dll"),
     TEXT("Clsid\\{0002000E-0000-0000-C000-000000000046}\\AVIFile"), TEXT("1"),

     TEXT("Clsid\\{00020008-0000-0000-C000-000000000046}"), TEXT("QuickTime Movies"),
     TEXT("Clsid\\{00020008-0000-0000-C000-000000000046}\\InprocServer") S32, TEXT("qtfile.dll"),
     TEXT("Clsid\\{00020008-0000-0000-C000-000000000046}\\AVIFile"), TEXT("1"),

     TEXT("Clsid\\{5C2B8200-E2C8-1068-B1CA-6066188C6002}"), TEXT("JPEG (JFIF) Files"),
     TEXT("Clsid\\{5C2B8200-E2C8-1068-B1CA-6066188C6002}\\InprocServer") S32, TEXT("jfiffile.dll"),
     TEXT("Clsid\\{5C2B8200-E2C8-1068-B1CA-6066188C6002}\\AVIFile"), TEXT("3"),
#endif

     TEXT("AVIFile\\RIFFHandlers\\WAVE"), TEXT("{00020003-0000-0000-C000-000000000046}"),
     TEXT("AVIFile\\Extensions\\WAV"), TEXT("{00020003-0000-0000-C000-000000000046}"),
     TEXT("AVIFile\\Extensions\\AU"), TEXT("{00020003-0000-0000-C000-000000000046}"),
     TEXT("AVIFile\\Extensions\\DIB"), TEXT("{00020006-0000-0000-C000-000000000046}"),
     TEXT("AVIFile\\Extensions\\BMP"), TEXT("{00020006-0000-0000-C000-000000000046}"),
     TEXT("AVIFile\\Extensions\\FLI"), TEXT("{00020007-0000-0000-C000-000000000046}"),
     TEXT("AVIFile\\Extensions\\FLC"), TEXT("{00020007-0000-0000-C000-000000000046}"),
     TEXT("AVIFile\\Extensions\\TGA"), TEXT("{0002000A-0000-0000-C000-000000000046}"),
#ifdef DEBUG
     TEXT("AVIFile\\Extensions\\LYR"), TEXT("{00020004-0000-0000-C000-000000000046}"),
     TEXT("AVIFile\\Extensions\\GIF"), TEXT("{0002000E-0000-0000-C000-000000000046}"),
     TEXT("AVIFile\\Extensions\\PCX"), TEXT("{0002000E-0000-0000-C000-000000000046}"),
     TEXT("AVIFile\\Extensions\\MOV"), TEXT("{00020008-0000-0000-C000-000000000046}"),
     TEXT("AVIFile\\Extensions\\JPG"), TEXT("{5C2B8200-E2C8-1068-B1CA-6066188C6002}"),
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\aviopts.c ===
/****************************************************************************
 *
 *  AVIOPTS.C
 *
 *  routine for bringing up the compression options dialog
 *
 *      AVISaveOptions()
 *
 *  Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>
#include <mmreg.h>
#include <msacm.h>
#include <vfw.h>
#include "aviopts.h"
#include "avifile.rc"

#if !defined NUMELMS
 #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif


/****************************************************************************
 ***************************************************************************/

extern HINSTANCE ghMod;

INT_PTR FAR PASCAL _export AVICompressOptionsDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

/****************************************************************************
 ***************************************************************************/


int  gnNumStreams = 0;			// how many streams in array
int  gnCurStream = 0;			// which stream's options we're setting
PAVISTREAM FAR *gapAVI;	        	// array of stream pointers
LPAVICOMPRESSOPTIONS FAR *gapOpt;	// array of option structures to fill
UINT	  guiFlags;
COMPVARS  gCompVars;                    // for ICCompressorChoose

/****************************************************************************
 ***************************************************************************/
/*************************************************************
* @doc EXTERNAL AVISaveOptions
*
* @api BOOL | AVISaveOptions | This function gets the save options for
*      a file and returns them in a buffer.
*
* @parm HWND | hwnd | Specifies the parent window handle for the Compression Options
*       dialog box.
*
* @parm UINT | uiFlags | Specifies the flags for displaying the
*       Compression Options dialog box. The following flags are defined:
*
* @flag ICMF_CHOOSE_KEYFRAME | Displays a "Key frame every" box for
*       the video options. This is the same flag used in <f ICCompressorChoose>.
*
* @flag ICMF_CHOOSE_DATARATE | Displays a "Data rate" box for the video
*       options. This is the same flag used in <f ICCompressorChoose>.
*
* @flag ICMF_CHOOSE_PREVIEW | Displays a "Preview" button for
*       the video options. This button previews the compression
*       using a frame from the stream. This is the same flag
*      used in <f ICCompressorChoose>.
*
* @parm int | nStreams | Specifies the number of streams
*       that will have their options set by the dialog box.
*
* @parm PAVISTREAM FAR * | ppavi | Specifies a pointer to an
*       array of stream interface pointers. The <p nStreams>
*       parameter indicates the number of pointers in the array.
*
* @parm LPAVICOMPRESSOPTIONS FAR * | plpOptions | Specifies a pointer
*       to an array of <t LPAVICOMPRESSOPTIONS> pointers
*       to hold the compression options set by the dialog box. The
*       <p nStreams> parameter indicates the number of
*       pointers in the array.
*
* @rdesc Returns TRUE if the user pressed OK, FALSE for CANCEL or an error.
*
* @comm This function presents a standard Compression Options dialog
*       box using <p hwnd> as the parent window handle. When the
*       user is finished selecting the compression options for
*       each stream, the options are returned in the <t AVICOMPRESSOPTIONS>
*       structures in the array referenced by <p lpOptions>. The caller
*       must pass the interface pointers for the streams
*       in the array referenced by <p ppavi>.
*
******************************************************************/
STDAPI_(INT_PTR) AVISaveOptions(HWND hwnd, UINT uiFlags, int nStreams, PAVISTREAM FAR *ppavi, LPAVICOMPRESSOPTIONS FAR *plpOptions)
{
    INT_PTR     f;
    AVICOMPRESSOPTIONS FAR *aOptions;
    int		i;

    /* Save the stream pointer */
    gnNumStreams = nStreams;
    gnCurStream = -1;
    gapAVI = ppavi;
    gapOpt = plpOptions;
    guiFlags = uiFlags;

    //
    // Remember the old compression options in case we cancel and need to
    // restore them
    //
    aOptions = (AVICOMPRESSOPTIONS FAR *)GlobalAllocPtr(GMEM_MOVEABLE,
			nStreams * sizeof(AVICOMPRESSOPTIONS));
    if (!aOptions)
	return FALSE;

#if 0 //def _WIN32
    CopyMemory((PVOID)aOptions, (PVOID)*plpOptions, nStreams * sizeof(AVICOMPRESSOPTIONS));
#else
    // We really ought to use memcpy on this...
    for (i = 0; i < nStreams; i++)
	aOptions[i] = *plpOptions[i];
#endif

    f = DialogBox (ghMod, MAKEINTRESOURCE(IDD_COMPRESSOPTIONS), hwnd,
		           AVICompressOptionsDlgProc);

    //
    // The user cancelled... put the old compression options back.
    //
    if (f == 0)	{

#if 0 //def _WIN32
	CopyMemory((PVOID)*plpOptions, (PVOID)aOptions, nStreams * sizeof(AVICOMPRESSOPTIONS));
#else
	// We really ought to use memcpy on this...
        for (i = 0; i < nStreams; i++)
	    *plpOptions[i] = aOptions[i];
#endif
    }
	
    // Couldn't bring up the dialog
    if (f == -1)
	f = 0;

    GlobalFreePtr(aOptions);

    // !!! Returning TRUE doesn't guarantee something actually changed...
    return f;
}

/*************************************************************
* @doc EXTERNAL AVISaveOptionsFree
*
* @api LONG | AVISaveOptionsFree | This function frees the resources allocated
*      by <f AVISaveOptions>.
*
* @parm int | nStreams | Specifies the number of <t AVICOMPRESSOPTIONS>
*       structures in the array passed in as the next parameter.
*
* @parm LPAVICOMPRESSOPTIONS FAR * | plpOptions | Specifies a pointer
*       to an array of <t LPAVICOMPRESSOPTIONS> pointers
*       to hold the compression options set by the dialog box. The
*       resources in each of these structures that were allocated by
*       <f AVISaveOptions> will be freed.
*
* @rdesc This function always returns AVIERR_OK (zero)
*
* @comm This function frees the resources allocated by <f AVISaveOptions>.
**************************************************************/
STDAPI AVISaveOptionsFree(int nStreams, LPAVICOMPRESSOPTIONS FAR *plpOptions)
{
    for (; nStreams > 0; nStreams--) {
	if (plpOptions[nStreams-1]->lpParms)
	    GlobalFreePtr(plpOptions[nStreams-1]->lpParms);
	plpOptions[nStreams-1]->lpParms = NULL;
	if (plpOptions[nStreams-1]->lpFormat)
	    GlobalFreePtr(plpOptions[nStreams-1]->lpFormat);
	plpOptions[nStreams-1]->lpFormat = NULL;
    }
    return AVIERR_OK;
}

/****************************************************************************
 	Bring up the compression options for the current stream
 ***************************************************************************/
BOOL StreamOptions(HWND hwnd) {
    AVISTREAMINFO	avis;
    BOOL		f = FALSE;
    LONG		lTemp;
    UINT		w;

    // Get the stream type
    if (AVIStreamInfo(gapAVI[gnCurStream], &avis, sizeof(avis)) != 0)
        return FALSE;

    //
    // Video stream -- bring up the video compression dlg
    //
    if (avis.fccType == streamtypeVIDEO) {

        // The structure we have now is not filled in ... init it
        if (!(gapOpt[gnCurStream]->dwFlags & AVICOMPRESSF_VALID)) {
	    _fmemset(gapOpt[gnCurStream], 0,
		    sizeof(AVICOMPRESSOPTIONS));
	    gapOpt[gnCurStream]->fccHandler = comptypeDIB;
	    gapOpt[gnCurStream]->dwQuality = (DWORD)ICQUALITY_DEFAULT;
        }

        _fmemset(&gCompVars, 0, sizeof(gCompVars));
        gCompVars.cbSize = sizeof(gCompVars);
        gCompVars.dwFlags = ICMF_COMPVARS_VALID;
        gCompVars.fccHandler = gapOpt[gnCurStream]->fccHandler;
        gCompVars.lQ = gapOpt[gnCurStream]->dwQuality;
        gCompVars.lpState = gapOpt[gnCurStream]->lpParms;
        gCompVars.cbState = gapOpt[gnCurStream]->cbParms;
        gCompVars.lKey =
	    (gapOpt[gnCurStream]->dwFlags & AVICOMPRESSF_KEYFRAMES)?
	    (gapOpt[gnCurStream]->dwKeyFrameEvery) : 0;
        gCompVars.lDataRate =
	    (gapOpt[gnCurStream]->dwFlags & AVICOMPRESSF_DATARATE) ?
	    (gapOpt[gnCurStream]->dwBytesPerSecond / 1024) : 0;

        // !!! Don't pass flags verbatim if others are defined!!!
        f = ICCompressorChoose(hwnd, guiFlags, NULL,
		    gapAVI[gnCurStream], &gCompVars, NULL);

        /* Set the options to our new values */
        gapOpt[gnCurStream]->lpParms = gCompVars.lpState;
        gapOpt[gnCurStream]->cbParms = gCompVars.cbState;
	gCompVars.lpState = NULL;	// so it won't be freed
        gapOpt[gnCurStream]->fccHandler = gCompVars.fccHandler;
        gapOpt[gnCurStream]->dwQuality = gCompVars.lQ;
        gapOpt[gnCurStream]->dwKeyFrameEvery = gCompVars.lKey;
        gapOpt[gnCurStream]->dwBytesPerSecond = gCompVars.lDataRate
	    * 1024;
        if (gCompVars.lKey)
	    gapOpt[gnCurStream]->dwFlags |= AVICOMPRESSF_KEYFRAMES;
        else
	    gapOpt[gnCurStream]->dwFlags &=~AVICOMPRESSF_KEYFRAMES;
        if (gCompVars.lDataRate)
	    gapOpt[gnCurStream]->dwFlags |= AVICOMPRESSF_DATARATE;
        else
	    gapOpt[gnCurStream]->dwFlags &=~AVICOMPRESSF_DATARATE;

        // If they pressed OK, we have valid stuff in here now.
        if (f)
	    gapOpt[gnCurStream]->dwFlags |= AVICOMPRESSF_VALID;
	
        // Close the stuff opened by ICCompressorChoose
        ICCompressorFree(&gCompVars);

    //
    // Bring up the ACM format dialog and stuff it in our
    // compression options structure
    //
    } else if (avis.fccType == streamtypeAUDIO) {

        ACMFORMATCHOOSE acf;
	LONG lsizeF = 0;

        if (acmGetVersion() < 0x02000000L) {
	    TCHAR achACM[160];
	    TCHAR achACMV[40];
	
	    LoadString(ghMod, IDS_BADACM, achACM, sizeof(achACM)/sizeof(TCHAR));
	    LoadString(ghMod, IDS_BADACMV, achACMV, sizeof(achACMV)/sizeof(TCHAR));

	    MessageBox(hwnd, achACM, achACMV, MB_OK | MB_ICONHAND);
	    return FALSE;
        }

        _fmemset(&acf, 0, sizeof(acf));	// or ACM blows up
        acf.cbStruct = sizeof(ACMFORMATCHOOSE);
        // If our options struct has valid data, use it to init
        // the acm dialog with, otherwise pick a default.
        acf.fdwStyle = (gapOpt[gnCurStream]->dwFlags & AVICOMPRESSF_VALID)
			       ? ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT : 0;
        acf.hwndOwner = hwnd;

	// Make sure the AVICOMPRESSOPTIONS has a big enough lpFormat
	acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT, (LPVOID)&lTemp);
	if ((gapOpt[gnCurStream]->cbFormat == 0 ||
			gapOpt[gnCurStream]->lpFormat == NULL) && lTemp) {
	    gapOpt[gnCurStream]->lpFormat =
			GlobalAllocPtr(GMEM_MOVEABLE, lTemp);
	    gapOpt[gnCurStream]->cbFormat = lTemp;
	} else if (gapOpt[gnCurStream]->cbFormat < (DWORD)lTemp && lTemp) {
	    gapOpt[gnCurStream]->lpFormat =
			GlobalReAllocPtr(gapOpt[gnCurStream]->lpFormat, lTemp,
				GMEM_MOVEABLE);
	    gapOpt[gnCurStream]->cbFormat = lTemp;
	}
	
	if (!gapOpt[gnCurStream]->lpFormat)
	    return FALSE;

        acf.pwfx = gapOpt[gnCurStream]->lpFormat;
        acf.cbwfx = gapOpt[gnCurStream]->cbFormat;

	//
	// Only ask for choices that we can actually convert to
	//
	AVIStreamReadFormat(gapAVI[gnCurStream],
		AVIStreamStart(gapAVI[gnCurStream]), NULL, &lsizeF);

	// !!! Work around ACM bug by making sure our format is big enough
	lsizeF = max(lsizeF, sizeof(WAVEFORMATEX));
	acf.pwfxEnum = (LPWAVEFORMATEX)
		       GlobalAllocPtr(GMEM_MOVEABLE | GMEM_ZEROINIT, lsizeF);
	
	if (acf.pwfxEnum) {
	    AVIStreamReadFormat(gapAVI[gnCurStream],
		AVIStreamStart(gapAVI[gnCurStream]), acf.pwfxEnum, &lsizeF);
	    acf.fdwEnum |= ACM_FORMATENUMF_CONVERT;
	}

        // If they pressed OK, we now have valid stuff in here!
        w = acmFormatChoose(&acf);

	if (w == MMSYSERR_NOERROR)
	    gapOpt[gnCurStream]->dwFlags |= AVICOMPRESSF_VALID;
	else if (w != ACMERR_CANCELED) {
	    MessageBeep(0); // !!! Should really be a message box!
	}

	if (acf.pwfxEnum)
	    GlobalFreePtr(acf.pwfxEnum);

	f = (w == MMSYSERR_NOERROR);
    }

    return f;
}

#if defined _WIN32 && !defined UNICODE	// Chicago only

/*
 * convert a UNICODE string to 'normal'
 */
LPTSTR WINAPI aviWideToText (LPTSTR lpszOut, LPWSTR lpwIn, UINT cch)
{
   if (sizeof(TCHAR) != sizeof(WCHAR))
      WideCharToMultiByte(CP_ACP, 0, lpwIn, cch, lpszOut, cch, NULL, NULL);
   else
      lstrcpyn (lpszOut, (LPTSTR)lpwIn, cch);
   return lpszOut;
}
#else
 #define aviWideToText(lpszOut,lpwIn,cch) lstrcpyn(lpszOut,lpwIn,cch)
#endif // _WIN32 on CHICAGO

STATICDT SZCODE aszXbyXbyX[] = TEXT("%ldx%ldx%d\n");
STATICDT SZCODE aszBlahSpaceBlah[] = TEXT("%s %s");

//
// Somebody chose a new stream.  Do we need to grey InterleaveOpts?
// Set the current stream.
//
void NEAR PASCAL NewStreamChosen(HWND hwnd)
{
    AVISTREAMINFO   avis;
    HIC		    hic;
    ICINFO	    icinfo;
    ACMFORMATDETAILS acmfmt;
    ACMFORMATTAGDETAILS	aftd;
    LONG	    lsizeF;
    LPBITMAPINFOHEADER lp = NULL;
    TCHAR	    szFFDesc[80];
    TCHAR	    szDesc[120];

    gnCurStream = (int)SendDlgItemMessage(hwnd, IDC_intCHOOSESTREAM,
			    CB_GETCURSEL, 0, 0L);
    if (gnCurStream < 0)
	return;

    if (AVIStreamInfo(gapAVI[gnCurStream], &avis, sizeof(avis)) != 0)
	return;

    //
    // Show a string describing the current format
    //
    szDesc[0] = TEXT('\0');

    lsizeF = 0;
    AVIStreamReadFormat(gapAVI[gnCurStream],
	    AVIStreamStart(gapAVI[gnCurStream]), NULL, &lsizeF);
    if (lsizeF) {
	lp = (LPBITMAPINFOHEADER)GlobalAllocPtr(GHND, lsizeF);
	if (lp) {
	    if (AVIStreamReadFormat(gapAVI[gnCurStream],
				    AVIStreamStart(gapAVI[gnCurStream]),
				    lp, &lsizeF) == AVIERR_OK) {
		if (avis.fccType == streamtypeVIDEO) {
		    wsprintf(szDesc, aszXbyXbyX, lp->biWidth,
			     lp->biHeight, lp->biBitCount);
		    if (lp->biCompression == BI_RGB) {
			LoadString(ghMod, IDS_FFDESC, szFFDesc,
				   sizeof(szFFDesc)/sizeof(TCHAR));
			lstrcat(szDesc, szFFDesc);
		    } else {
			hic = ICDecompressOpen(ICTYPE_VIDEO,avis.fccHandler,
					       lp, NULL);
			if (hic) {
                            if (ICGetInfo(hic, &icinfo,sizeof(icinfo)) != 0) {
                                UINT cb = lstrlen(szDesc);
                                aviWideToText (szDesc + cb,
                                               icinfo.szDescription,
                                               NUMELMS(szDesc) - cb);
                            }
			    ICClose(hic);
			}
		    }
		} else if (avis.fccType == streamtypeAUDIO) {
		    _fmemset(&acmfmt, 0, sizeof(acmfmt));
		    acmfmt.pwfx = (LPWAVEFORMATEX) lp;
		    acmfmt.cbStruct = sizeof(ACMFORMATDETAILS);
		    acmfmt.dwFormatTag = acmfmt.pwfx->wFormatTag;
		    acmfmt.cbwfx = lsizeF;
		    aftd.cbStruct = sizeof(aftd);
		    aftd.dwFormatTag = acmfmt.pwfx->wFormatTag;
		    aftd.fdwSupport = 0;

		    if ((acmFormatTagDetails(NULL,
					     &aftd,
					     ACM_FORMATTAGDETAILSF_FORMATTAG) == 0) &&
			(acmFormatDetails(NULL, &acmfmt,
					  ACM_FORMATDETAILSF_FORMAT) == 0)) {
			wsprintf(szDesc, aszBlahSpaceBlah, (LPTSTR) acmfmt.szFormat,
				 (LPTSTR) aftd.szFormatTag);
		    }
		}
	    }
		
	    GlobalFreePtr(lp);
	}
    }
    SetDlgItemText(hwnd, IDC_intFORMAT, szDesc);

    //
    // AUDIO and VIDEO streams have a compression dialog
    //
    if (avis.fccType == streamtypeAUDIO ||
		    avis.fccType == streamtypeVIDEO)
	EnableWindow(GetDlgItem(hwnd, IDC_intOPTIONS), TRUE);
    else
	EnableWindow(GetDlgItem(hwnd, IDC_intOPTIONS), FALSE);

}


/*--------------------------------------------------------------+
* Dialog Proc for the main compression options dialog		*
+--------------------------------------------------------------*/
INT_PTR FAR PASCAL _export AVICompressOptionsDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  int   i, nVal;
  AVISTREAMINFO avis;
  DWORD dw;
  BOOL	f;

  switch(msg){
    case WM_INITDIALOG:

	    //
	    // If we've only got one stream to set the options for, it seems
	    // strange to bring up a box to let you choose which stream you want.
	    // Let's skip straight to the proper options dlg box.
	    //
	    if (gnNumStreams == 1) {
		gnCurStream = 0;
		EndDialog(hwnd, StreamOptions(hwnd));
		return TRUE;
	    }

            /* Add the list of streams to the drop-down box */
            for (nVal = 0; nVal < gnNumStreams; nVal++) {
		// Get the name of this stream
		AVIStreamInfo(gapAVI[nVal], &avis, sizeof(avis));
                SendDlgItemMessage(hwnd, IDC_intCHOOSESTREAM, CB_ADDSTRING, 0,
                                (LONG_PTR) (LPTSTR)avis.szName);
	    }

            // Set our initial selection to the first item
            SendDlgItemMessage(hwnd, IDC_intCHOOSESTREAM, CB_SETCURSEL, 0, 0L);
	    // Make sure we see it
            SendMessage(hwnd, WM_COMMAND,
		GET_WM_COMMAND_MPS(IDC_intCHOOSESTREAM, hwnd, CBN_SELCHANGE));

	    // Set the interleave boxes for these streams. Every stream should
	    // be interleaved the same way, so just look at the first guy.
	    // !!! Admittedly, some app might only set the interleaving for
	    // the audio stream, and we won't get his intended default here.
	    // Default to interleave every 1 if we're uninitialized
	    if (gapOpt[0]->dwFlags & AVICOMPRESSF_VALID) {
		f = (gapOpt[0]->dwFlags & AVICOMPRESSF_INTERLEAVE) != 0;
		dw = gapOpt[0]->dwInterleaveEvery;
	    } else {
		dw = 1;
		f = FALSE;
	    }
	    CheckDlgButton(hwnd, IDC_intINTERLEAVE, f);
	    SetDlgItemInt(hwnd, IDC_intINTERLEAVEEDIT, (int)dw, FALSE);
	    EnableWindow(GetDlgItem(hwnd, IDC_intINTERLEAVEEDIT), f);

            return TRUE;
	
    case WM_COMMAND:
	switch(GET_WM_COMMAND_ID(wParam, lParam)){
            case IDOK:
		// Set the interleaving for every stream to be the same,
		// whatever we have chosen.  AVIFile doesn't support
		// interleaving different streams in different ways.
    		f = IsDlgButtonChecked(hwnd, IDC_intINTERLEAVE);
		dw = (DWORD)GetDlgItemInt(hwnd, IDC_intINTERLEAVEEDIT,
				NULL, FALSE);
		for (i = 0; i < gnNumStreams; i++) {
		    gapOpt[i]->dwInterleaveEvery = dw;
		    if (f)
			gapOpt[i]->dwFlags |= AVICOMPRESSF_INTERLEAVE;
		    else
			gapOpt[i]->dwFlags &=~AVICOMPRESSF_INTERLEAVE;
		}
		// fall through	(AAAAaaaahhhhh.....)

	    case IDCANCEL:
                EndDialog(hwnd, wParam == IDOK);
                break;

            case IDC_intOPTIONS:
		StreamOptions(hwnd);
		break;

	    //
	    // Somebody chose a new stream.
	    //
            case IDC_intCHOOSESTREAM:
                if (GET_WM_COMMAND_CMD(wParam, lParam) != CBN_SELCHANGE)
                    break;

		NewStreamChosen(hwnd);
                break;

	    case IDC_intINTERLEAVE:
		// Enable the "interleave every" edit box iff we've checked it
    		f = IsDlgButtonChecked(hwnd, IDC_intINTERLEAVE);
		EnableWindow(GetDlgItem(hwnd, IDC_intINTERLEAVEEDIT), f);
		break;

	    default:
		break;
	}
	break;
	
    default:
	return FALSE;
  }
  return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\buffer.c ===
#include <win32.h>
#include <mmsystem.h>
#include "debug.h"
#include "aviidx.h"
#include "buffer.h"
#include <vfw.h>

#ifndef _WIN32
LONG	glDosBufUsage;
LPVOID  glpDosBuf;
LONG	glDosBufSize;
#endif

// Idea: keep a bunch (five, maybe) of buffers.

PBUFSYSTEM PASCAL InitBuffered(int nBuffers,
				LONG lBufSize,
                                HSHFILE hshfile,
                                PAVIINDEX px)
{
    PBUFSYSTEM pb = (PBUFSYSTEM)LocalAlloc(LPTR,
            sizeof(BUFSYSTEM) + sizeof(BUFFER) * nBuffers);

    int		i;
    LONG	l;

    if (!pb)
        return NULL;

    DPF("InitBuffered (%04x): %dx%ldK, pIndex = %p\n", pb, nBuffers, lBufSize / 1024, (DWORD_PTR) (LPVOID) px);

    pb->nBuffers = nBuffers;
    pb->lBufSize = lBufSize;

    pb->px = px;
    pb->lx = 0;

    pb->lpBufMem = GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, lBufSize * nBuffers);

    if (!pb->lpBufMem) {
	DPF("Couldn't allocate buffer memory!\n");
	EndBuffered(pb);
	return NULL;
    }

    pb->hshfile = hshfile;

    l = shfileSeek(hshfile, 0, SEEK_CUR);
    pb->lFileLength = shfileSeek(hshfile, 0, SEEK_END);
    shfileSeek(hshfile, l, SEEK_SET);

    for (i = 0; i < nBuffers; i++) {
	pb->aBuf[i].lpBuffer = (BYTE _huge *) pb->lpBufMem + i * lBufSize;
        pb->aBuf[i].lOffset  = -1;
    }

    return pb;
}

LONG FAR PASCAL BufferedRead(PBUFSYSTEM pb, LONG lPos, LONG cb, LPVOID lp)
{
    int	    i;
    LPVOID  lpCopy;
    LONG    cbCopy;
    LONG    cbRead = cb;
    LONG    l;

#if 0
    if (cb > pb->lBufSize) {
        if (shfileSeek(pb->hshfile, lPos, SEEK_SET) == -1)
            return 0;

        if (shfileRead(pb->hshfile, lp, cb) != cb)
            return 0;

        return cb;
    }
#endif

    while (cb > 0) {

	if (lPos >= pb->lFileLength)
	    break;
	
	// Find a buffer.
	for (i = 0; i < pb->nBuffers; i++) {
	    if (pb->aBuf[i].lOffset < 0)
		continue;

	    if (pb->aBuf[i].lOffset <= lPos &&
			pb->aBuf[i].lOffset + pb->aBuf[i].lLength > lPos)
		break;
	}

        // If we didn't find a buffer with valid data, read more.

	if (i >= pb->nBuffers) {
	    i = pb->iNextBuf;

            if (pb->px) {

                LONG off,len;

                for (l = pb->lx; l>=0 && l<pb->px->nIndex; ) {

                    off = IndexOffset(pb->px, l);
                    len = IndexLength(pb->px, l) + 2*sizeof(DWORD);

                    if (off <= lPos && lPos < off + len)
                        break;

                    if (lPos < off)
                        l--;
                    else
                        l++;
                }

                if (l == pb->px->nIndex || l < 0) {
                    DPF("Ran out of index!\n");
                    goto ack;
                }

                if (len > pb->lBufSize) {
                    DPF("Chunk is bigger than buffer.\n");
                    goto ack;
                }

                pb->aBuf[i].lOffset = off;
                pb->aBuf[i].lLength = len;

                DPF2("Buffer: Reading %lx bytes at %lx\n", pb->aBuf[i].lLength, pb->aBuf[i].lOffset);

                //
                //  read as many records that will fit in our buffer
                //
                //  we should scan backward!
                //
                for (l++; l<pb->px->nIndex; l++) {

                    off = IndexOffset(pb->px, l);
                    len = IndexLength(pb->px, l) + 2*sizeof(DWORD);

                    if (off < pb->aBuf[i].lOffset + pb->aBuf[i].lLength)
                        continue;

                    if (off != pb->aBuf[i].lOffset + pb->aBuf[i].lLength)
                        break;

                    if (pb->aBuf[i].lLength + len > pb->lBufSize)
                        break;

                    pb->aBuf[i].lLength += len;

                    DPF2("        Reading %lx bytes at %lx\n", pb->aBuf[i].lLength, pb->aBuf[i].lOffset);
                }

                if (l < pb->px->nIndex)
                    pb->lx = l;     // save this for next time.

	    } else
	    {
ack:
		// Always read aligned with the buffer size....
                pb->aBuf[i].lOffset = lPos - (lPos % pb->lBufSize);

		pb->aBuf[i].lLength =
			min(pb->lFileLength - pb->aBuf[i].lOffset,
                                      pb->lBufSize);

                DPF("Buffer: Reading %lx bytes at %lx\n", pb->aBuf[i].lLength, pb->aBuf[i].lOffset);
            }

            shfileSeek(pb->hshfile, pb->aBuf[i].lOffset, SEEK_SET);
#ifndef _WIN32
	    if (glpDosBuf) {
		if (shfileRead(pb->hshfile,
			       glpDosBuf,
			       pb->aBuf[i].lLength) != pb->aBuf[i].lLength)
                    return 0;
		hmemcpy(pb->aBuf[i].lpBuffer, glpDosBuf, pb->aBuf[i].lLength);
	    }
            else
#endif
            {
		if (shfileRead(pb->hshfile,
			       pb->aBuf[i].lpBuffer,
			       pb->aBuf[i].lLength) != pb->aBuf[i].lLength)
                    return 0;
	    }

	    // !!! We should use an LRU algorithm or something here....
	    pb->iNextBuf = (i + 1) % pb->nBuffers;
	}

	lpCopy = (BYTE _huge *) pb->aBuf[i].lpBuffer + lPos - pb->aBuf[i].lOffset;

	cbCopy = min(cb, pb->aBuf[i].lLength - (lPos - pb->aBuf[i].lOffset));

	hmemcpy(lp, lpCopy, cbCopy);

	lp = (BYTE _huge *) lp + cbCopy;
	cb -= cbCopy;
	lPos += cbCopy;
    }

    return cbRead;
}

LONG FAR PASCAL BeginBufferedStreaming(PBUFSYSTEM pb, BOOL fForward)
{
    if (pb->fStreaming++)
	return 0;

    DPF("Streaming....\n");

#ifndef _WIN32
    if (pb->px) {
	if (glDosBufSize < pb->lBufSize
#ifdef DEBUG
	    && GetProfileInt("avifile", "dosbuffer", 1)
#endif
	   ) {
	    LPVOID lpDosBuf;
	
	    lpDosBuf = (LPVOID)MAKELONG(0, LOWORD(GlobalDosAlloc(pb->lBufSize)));
	
	    if (!lpDosBuf) {
		DPF("Couldn't get DOS buffer!\n");
            } else {
                GlobalReAlloc((HANDLE)HIWORD(lpDosBuf), 0, GMEM_MODIFY|GMEM_SHARE);

		if (glpDosBuf)
                    GlobalDosFree(HIWORD(glpDosBuf));

                glpDosBuf = lpDosBuf;
                glDosBufSize = pb->lBufSize;
	    }
	}
	if (glpDosBuf && (glDosBufSize >= pb->lBufSize)) {
	    pb->fUseDOSBuf = TRUE;
	    glDosBufUsage++;
	} else
	    pb->fUseDOSBuf = FALSE;	
    }
#endif

    return 0;
}

LONG FAR PASCAL EndBufferedStreaming(PBUFSYSTEM pb)
{
    if (!pb->fStreaming)
	return AVIERR_INTERNAL;

    if (--pb->fStreaming)
	return 0;

    DPF("No longer streaming....\n");

#ifndef _WIN32
    if (pb->fUseDOSBuf) {
	if (--glDosBufUsage == 0) {
	    if (glpDosBuf)
		GlobalDosFree(HIWORD(glpDosBuf));

	    glpDosBuf = NULL;
	}

	pb->fUseDOSBuf = FALSE;
    }
#endif

    return 0;
}


void FAR PASCAL EndBuffered(PBUFSYSTEM pb)
{
    DPF("Freeing bufsystem %04x....\n", pb);

    if (pb->lpBufMem)
	GlobalFreePtr(pb->lpBufMem);

#ifndef _WIN32
    if (pb->fUseDOSBuf) {
	if (--glDosBufUsage == 0) {
	    if (glpDosBuf)
		GlobalDosFree(HIWORD(glpDosBuf));

	    glpDosBuf = NULL;
	    glDosBufSize = 0;
	}
    }
#endif

    LocalFree((HLOCAL)pb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\avisave.c ===
/****************************************************************************
 *
 *  AVISAVE.C
 *
 *  routine for writing Standard AVI files
 *
 *      AVISave()
 *
 *  Copyright (c) 1992-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>

#ifdef USE_ISVALIDINTERFACE
#include <valid.h>
#endif

#include <vfw.h>
#include "avicmprs.h"
#include "debug.h"

#include <stdlib.h>
#ifndef _WIN32	// DS!=SS nightmare
#ifndef WINDLL
#define WINDLL	
#define _WINDLL
#define __WINDLL
#endif
#endif
#include <stdarg.h>

#ifdef UNICODE
#include <wchar.h>
#endif

//extern LONG FAR PASCAL muldiv32(LONG,LONG,LONG);

/************************************************************************/
/* Auto-doc for the AVICOMPRESSOPTIONS structure.  Make sure it matches	*/
/* the declarations in avifile.h !!!                                    */
/************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL AVICOMPRESSOPTIONS
 *
 * @types AVICOMPRESSOPTIONS | This structure contains information
 *	       about a stream and how it is to be compressed and saved.
 *        This structure passes data to <f AVIMakeCompressedStream>
 *        (or <f AVISave> which uses <f AVIMakeCompressedStream>).
 *
 * @field DWORD | fccType | Specifies a four-character code
 *        indicating the stream type. The following
 *        constants have been defined for the data commonly
 *        found in AVI streams:
 *
 * @flag  streamtypeAUDIO | Indicates an audio stream.
 * @flag  streamtypeMIDI | Indicates a MIDI stream.
 * @flag  streamtypeTEXT | Indicates a text stream.
 * @flag  streamtypeVIDEO | Indicates a video stream.
 *
 * @field DWORD | fccHandler | For a video stream, specifies the
 *        four-character code for the compressor handler that
 *        will compress this stream when it is saved
 *        (For example, mmioFOURCC('M','S','V','C')).
*         This member is not used for audio streams.
 *
 * @field DWORD | dwKeyFrameEvery | Specifies the maximum period
 *        between key frames. This member is used only
 *        if the AVICOMPRESSF_KEYFRAMES flag is set, otherwise
 *        every frame is a key frame.
 *
 * @field DWORD | dwQuality | Specifies the quality value passed
 *        to a video compressor. This member is not used for
 *        an audio compressor.
 *
 * @field DWORD | dwBytesPerSecond | Specifies the data rate a video
 *	       compressor should use.  This member is used only
 *        if the AVICOMPRESSF_DATARATE flag is set.
 *
 * @field DWORD | dwFlags | Specifies the flags used for compression:
 *
 *   @flag AVICOMPRESSF_INTERLEAVE | Indicates this stream is to be interleaved
 *         every <e AVICOMPRESSOPTIONS.dwInterleaveEvery> frames
 *         with respect to the first stream.
 *
 *   @flag AVICOMPRESSF_KEYFRAMES | Indicates this video stream
 *         is to be saved with key frames at least
 *         every <e AVICOMPRESSOPTIONS.dwKeyFrameEvery> frames.
 *	   By default, every frame will be a key frame.
 *
 *   @flag AVICOMPRESSF_DATARATE | Indicates this video stream
 *         is to be compressed with the data rate
 *         specified in <e AVICOMPRESSOPTIONS.dwBytesPerSecond>.
 *
 *   @flag AVICOMPRESSF_VALID | Indicates this structure contains
 *         valid data. If this flag is set, AVIFile uses the structure
 *         data to set the default compression values for <f AVISaveOptions>.
 *         If an empty structure is passed and this flag is not set,
 *         some defaults will be chosen.
 *
 * @field LPVOID | lpFormat | Specifies a pointer to a structure
 *        defining the data format. For an audio stream,
 *        this is an <t LPWAVEFORMAT> structure.
 *
 * @field DWORD | cbFormat | Specifies the size of the data referenced by
 *	       <e AVICOMPRESSOPTIONS.lpFormat>
 *
 * @field LPVOID | lpParms | Used internally to store compressor
 *        specific data.
 *
 * @field DWORD | cbParms | Specifies the size of the data referenced by
 *        <e AVICOMPRESSOPTIONS.lpParms>
 *
 * @field DWORD | dwInterleaveEvery | Specifies how often
 *        to interleave stream data with the data
 *        from the first stream.  Used only if the
 *	       AVICOMPRESSF_INTERLEAVE flag is set.
 *
 ***************************************************************************/

/*******************************************************************
* @doc EXTERNAL AVISave
*
* @api LONG | AVISave | This function is used to save an AVI file.
*
* @parm LPCTSTR | szFile | Specifies a zero-terminated string
*       containing the name of the file to save.
*
* @parm CLSID FAR * | pclsidHandler | Specifies a pointer to the
*       file handler used to write the file. The file will
*       be created by calling <f AVIFileOpen> using this handler. If
*       a handler is not specified, a default one is selected based
*       upon the file extension.
*
* @parm AVISAVECALLBACK | lpfnCallback | Specifies a far pointer to
 *      a callback function for the save operation.
*
* @parm int | nStreams | Specifies the number of streams saved in the
*       the file.
*
* @parm PAVISTREAM | pavi | Specifies a pointer an AVI stream.
*       This parameter is paired with <p lpOptions>. The parameter
*       pair can be repeated as a variable number of arguments.
*
* @parm LPAVICOMPRESSOPTIONS | lpOptions | Specifies a pointer to an
*       <t AVICOMPRESSOPTIONS> structure containing the compression
*       options for the stream referenced by <p pavi>.
*       This parameter is paired with <p pavi>. The parameter
*       pair can be repeated as a variable number of arguments.
*
* @parm .| . . | Additional streams can be appened
*       by including more <p pavi> and <p lpOptions> parameter pairs.
*
* @rdesc Returns AVIERR_OK if successful; otherwise it returns an error code.
*
* @comm This function saves an AVI sequence to the file
*       specified by <p szFile>. The <p pavi> and <p lpOptions> parameters
*       define the streams saved. If saving more than one stream,
*       repeat the <p pavi> and <p lpOptions> parameter pair for
*       each additional stream.
*
*      A callback function can be supplied in <p lpfnCallback> to
*      display status information and let the user cancel the
*      save operation.  The callback uses the following format:
*
*      LONG FAR PASCAL SaveCallback(int nPercent)
*	
*	    The <p nPercent> parameter specifies the percentage of the
*      file saved.
*
*	    The callback function should return AVIERR_OK if the
*      operation should continue and AVIERR_USERABORT if the
*      user wishes to abort the save operation.
*
*
* @xref <f AVISaveV> <f AVISaveOptions>
*
*******************************************************************/
EXTERN_C HRESULT CDECL AVISave(LPCTSTR               szFile,
		    CLSID FAR *pclsidHandler,
                    AVISAVECALLBACK     lpfnCallback,
		    int			nStreams,
                    PAVISTREAM          pavi,
                    LPAVICOMPRESSOPTIONS lpOptions,
		    ...
		    )
{
    PAVISTREAM FAR 		*apavi;
    LPAVICOMPRESSOPTIONS FAR	*alpOptions;
    int	i;
    HRESULT	hr;

    //
    // We were passed arguments of the form PAVI, OPTIONS, PAVI, OPTIONS, etc.
    // for AVISaveV, we need to separate these into an array of PAVI's and
    // an array of LPAVICOMPRESSOPTIONS.
    //

    // !!!not only that, but we need to do it properly, using va_arg etc!!!
    va_list va;



    apavi = (PAVISTREAM FAR *)GlobalAllocPtr(GMEM_MOVEABLE,
			nStreams * sizeof(PAVISTREAM));
    alpOptions = (LPAVICOMPRESSOPTIONS FAR *)GlobalAllocPtr(GMEM_MOVEABLE,
			nStreams * sizeof(LPAVICOMPRESSOPTIONS));
    if (!apavi || !alpOptions)
	return ResultFromScode(AVIERR_MEMORY);

    // first two args are explicit
    if (nStreams) {
	apavi[0] = pavi;
	alpOptions[0] = lpOptions;
    }

    // do the rest by *portable* varargs methods
    va_start(va, lpOptions);
    for (i = 1; i < nStreams; i++) {
	apavi[i] = va_arg(va, PAVISTREAM);
	alpOptions[i] = va_arg(va, LPAVICOMPRESSOPTIONS);
    }
    va_end(va);

    hr = AVISaveV(szFile, pclsidHandler, lpfnCallback, nStreams, apavi,
			alpOptions);

    GlobalFreePtr(apavi);
    GlobalFreePtr(alpOptions);
    return hr;
}


#ifdef UNICODE
//ansi thunk for AVISave - same, but calls AVISaveVA instead
EXTERN_C HRESULT CDECL
AVISaveA(
    LPCSTR      szFile,
    CLSID FAR *pclsidHandler,
    AVISAVECALLBACK     lpfnCallback,
    int			nStreams,
    PAVISTREAM          pavi,
    LPAVICOMPRESSOPTIONS lpOptions,
    ...
)
{
    PAVISTREAM FAR 		*apavi;
    LPAVICOMPRESSOPTIONS FAR	*alpOptions;
    int	i;
    HRESULT	hr;

    //
    // We were passed arguments of the form PAVI, OPTIONS, PAVI, OPTIONS, etc.
    // for AVISaveV, we need to separate these into an array of PAVI's and
    // an array of LPAVICOMPRESSOPTIONS.
    //

    // !!!not only that, but we need to do it properly, using va_arg etc!!!
    va_list va;


    apavi = (PAVISTREAM FAR *)GlobalAllocPtr(GMEM_MOVEABLE,
			nStreams * sizeof(PAVISTREAM));
    alpOptions = (LPAVICOMPRESSOPTIONS FAR *)GlobalAllocPtr(GMEM_MOVEABLE,
			nStreams * sizeof(LPAVICOMPRESSOPTIONS));
    if (!apavi || !alpOptions)
	return ResultFromScode(AVIERR_MEMORY);

    // first two args are explicit
    if (nStreams) {
	apavi[0] = pavi;
	alpOptions[0] = lpOptions;
    }

    // do the rest by *portable* varargs methods
    va_start(va, lpOptions);
    for (i = 1; i < nStreams; i++) {
	apavi[i] = va_arg(va, PAVISTREAM);
	alpOptions[i] = va_arg(va, LPAVICOMPRESSOPTIONS);
    }
    va_end(va);

    hr = AVISaveVA(szFile, pclsidHandler, lpfnCallback, nStreams, apavi,
			alpOptions);

    GlobalFreePtr(apavi);
    GlobalFreePtr(alpOptions);
    return hr;
}
#else
#ifdef _WIN32
EXTERN_C HRESULT CDECL
AVISaveW(
    LPCWSTR      szFile,
    CLSID FAR *pclsidHandler,
    AVISAVECALLBACK     lpfnCallback,
    int			nStreams,
    PAVISTREAM          pavi,
    LPAVICOMPRESSOPTIONS lpOptions,
    ...
)
{
    return E_FAIL;
}
#endif
#endif




BOOL FAR PASCAL DummySaveCallback(int iProgress)
{
    return FALSE;   // do nothing, allow save to continue
}



#ifdef UNICODE
// Ansi thunk for AVISaveV
STDAPI AVISaveVA(LPCSTR               szFile,
		CLSID FAR *pclsidHandler,
                    AVISAVECALLBACK     lpfnCallback,
		    int			nStreams,
		    PAVISTREAM FAR *	ppavi,
		    LPAVICOMPRESSOPTIONS FAR * plpOptions)
{

    // convert the filename, and then call AVISaveVW
    LPWSTR pW;
    int sz;
    HRESULT hr;

    sz = lstrlenA(szFile)+1;
    pW = (LPWSTR) (LocalAlloc(LPTR, sz * sizeof(WCHAR)));
    if (pW == NULL) {
	return ResultFromScode(AVIERR_MEMORY);
    }

    mbstowcs(pW, szFile, sz);

    hr = AVISaveVW(pW, pclsidHandler, lpfnCallback, nStreams, ppavi, plpOptions);

    LocalFree((HANDLE)pW);

    return hr;
}
#else
#if _WIN32
STDAPI AVISaveVW(LPCWSTR               szFile,
		CLSID FAR *pclsidHandler,
                    AVISAVECALLBACK     lpfnCallback,
		    int			nStreams,
		    PAVISTREAM FAR *	ppavi,
		    LPAVICOMPRESSOPTIONS FAR * plpOptions)
{
    return E_FAIL;
}
#endif
#endif


/**************************************************************************
* @doc EXTERNAL AVIStreamTimeToSampleNoClip
*
* @api LONG | AVIStreamTimeToSampleNoClip | Converts from milliseconds to
*	samples.  It is different from the regular API in that 1) it doesn't
*	clip to the size of the stream, and will return "theoretical" positions
*	past the start or end, and 2) it will always round UP because that's
*	what we want.
*
* @parm PAVISTREAM | pavi | Specifies a handle to an open stream.
*
* @parm LONG | lTime | Specifies the time in milliseconds.
*
* @devnote Currently, this doesn't call a handler function at all.
*
* @comm Samples typically correspond to audio samples or video frames.
*       Other stream types might support different formats than these.

* @rdesc Returns the converted time, or -1 on error.
*
* @xref AVIStreamSampleToTime
*
*************************************************************************/
STDAPI_(LONG) AVIStreamTimeToSampleNoClip (PAVISTREAM pavi, LONG lTime)
{
    AVISTREAMINFOW	    avistream;
    HRESULT		    hr;
    LONG		    lSample;

    // Invalid time
    if (lTime < 0)
	return -1;

    hr = pavi->lpVtbl->Info(pavi, &avistream, sizeof(avistream));

    if (hr != NOERROR || avistream.dwScale == 0) {
	DPF("Error in AVIStreamTimeToSample!\n");
	return lTime;
    }

    // This is likely to overflow if we're not careful for long AVIs
    // so keep the 1000 inside the brackets.
    lSample =  muldivru32(lTime, avistream.dwRate, avistream.dwScale * 1000);

    return lSample;
}

// Converts from samples to milliseconds.
// It is different from the regular API in that 1) it doesn't
// clip to the size of the stream, and will return "theoretical" positions
// past the start or end, and 2) it will always round DOWN because that's
// what we want.
STDAPI_(LONG) AVIStreamSampleToTimeNoClip (PAVISTREAM pavi, LONG lSample)
{
    AVISTREAMINFOW	    avistream;
    HRESULT		    hr;

    hr = pavi->lpVtbl->Info(pavi, &avistream, sizeof(avistream));

    if (hr != NOERROR || avistream.dwRate == 0) {
	DPF("Error in AVIStreamSampleToTime!\n");
	return lSample;
    }

    // lSample * 1000 would overflow too easily
    return muldivrd32(lSample, avistream.dwScale * 1000, avistream.dwRate);
}


#define     AVIStreamSampleToSampleNoClip(pavi1, pavi2, l) \
            AVIStreamTimeToSampleNoClip(pavi1,AVIStreamSampleToTimeNoClip(pavi2, l))



/**********************************************************************
* @doc EXTERNAL AVISaveV
*
* @api LONG | AVISaveV | This function is used to save an AVI file.
*
* @parm LPCTSTR | szFile | Specifies a zero-terminated string
*       containing the name of the file to save.
*
* @parm CLSID FAR * | pclsidHandler | Specifies a pointer to the
*       file handler used to write the file. The file will
*       be created by calling <f AVIFileOpen> using this handler. If
*       a handler is not specified, a default one is selected based upon
*       the file extension.
*
* @parm AVISAVECALLBACK | lpfnCallback | Specifies a pointer to a callback
*       function used to display status information and let the use
*       cancel the save operation.
*
* @parm int | nStreams | Specifies the number of streams to save.
*
* @parm PAVISTREAM FAR * | ppavi | Specifies a pointer to an
*       array of <t PAVISTREAM> pointers. The array uses one pointer
*       for each stream.
*
* @parm LPAVICOMPRESSOPTIONS FAR * | plpOptions | Specifies a pointer
*       to an array of <t LPAVICOMPRESSOPTIONS> pointers. The
*       uses one pointer for each stream.
*
* @rdesc Returns AVIERR_OK on success, an error code otherwise.
*
* @comm This function is equivalent to <f AVISave> except
*       the streams are passed in an array instead of as a
*       variable number of arguments. (<f AVISaveV> is to <f AVISave>
*       as <f wvsprintf> is to <f wsprintf>.)
*
* @xref <f AVISave> <f AVISaveOptions>
*
********************************************************************/
STDAPI AVISaveV(LPCTSTR               szFile,
		CLSID FAR *pclsidHandler,
                    AVISAVECALLBACK     lpfnCallback,
		    int			nStreams,
		    PAVISTREAM FAR *	ppavi,
		    LPAVICOMPRESSOPTIONS FAR * plpOptions)
{
    int		    stream;
    MainAVIHeader   hdrNew;
    PAVIFILE	    pfilesave = 0;
    HRESULT	    hr;
    AVISTREAMINFOW  strhdr;
    AVIFILEINFOW    finfo;
    LONG	    cbFormat;
    DWORD	    dwSamplesRead;
    LPVOID	    lpBuffer = 0;
    DWORD	    dwBufferSize;
    LONG	    l;
    DWORD	    dwSize;
    DWORD	    dwFlags;
    WORD	    cktype;
    LPBITMAPINFOHEADER lpbi;
    DWORD	    dwInterleaveEvery = 0;

#define MAXSTREAMS  64

    int		    iVideoStream = -1;
    PAVISTREAM	    apavi[MAXSTREAMS];
    PAVISTREAM	    apaviNew[MAXSTREAMS];
    LONG	    lDone[MAXSTREAMS];
    LONG	    lInterval;


    if (nStreams > MAXSTREAMS)
	return ResultFromScode(AVIERR_INTERNAL);
    for (stream = 0; stream < nStreams; stream++) {
	apavi[stream] = NULL;
	apaviNew[stream] = NULL;
    }

    //
    // Open file and write out the main header
    //
    DPF("Creating new file\n");

    hr = AVIFileOpen(&pfilesave, szFile, OF_CREATE | OF_WRITE | OF_SHARE_EXCLUSIVE, pclsidHandler);
    if (hr != 0)
	goto Error;

    AVIFileInfoW(pfilesave, &finfo, sizeof(finfo));

    DPF("Creating compressed streams\n");

    for (stream = 0; stream < nStreams; stream++) {

#ifdef USE_ISVALIDINTERFACE
	if (!IsValidInterface(ppavi[stream])) {
	    hr = ResultFromScode(AVIERR_INTERNAL);
	    goto Error;
	}
#endif

	hr = AVIStreamInfoW(ppavi[stream], &strhdr, sizeof(strhdr));

	if (hr != AVIERR_OK) {
	    DPF("Error from AVIStreamInfo!\n");
	    goto Error;
	}

	// Find the video stream....
	if (strhdr.fccType == streamtypeVIDEO) {
	    if (iVideoStream < 0) {
		iVideoStream = stream;
	    }
	// Allow interleaving for any other type of stream
	} else {
	    if (dwInterleaveEvery == 0) {
		// Should the interleave factor be in the options at all?
		if (plpOptions && plpOptions[stream] &&
			plpOptions[stream]->dwFlags & AVICOMPRESSF_INTERLEAVE)
		    dwInterleaveEvery = plpOptions[stream]->dwInterleaveEvery;
	    }
	}

	apavi[stream] = NULL;
	
	if (plpOptions && plpOptions[stream] &&
		    (plpOptions[stream]->fccHandler ||
		     plpOptions[stream]->lpFormat)) {
	    DWORD   dwKeyFrameEvery = plpOptions[stream]->dwKeyFrameEvery;

	    if (finfo.dwCaps & AVIFILECAPS_ALLKEYFRAMES)
		plpOptions[stream]->dwKeyFrameEvery = 1;
	
	    // If they've given compression options for this stream,
	    // use them....
	    hr = AVIMakeCompressedStream(&apavi[stream],
					 ppavi[stream],
					 plpOptions[stream],
					 NULL);

	    plpOptions[stream]->dwKeyFrameEvery = dwKeyFrameEvery;
	
	    if (hr != 0) {
		DPF("AVISave: Failed to create compressed stream!\n");
		apavi[stream] = NULL;
		goto Error;	// !!!
	    } else {
		hr = AVIStreamInfoW(apavi[stream], &strhdr, sizeof(strhdr));
		if (hr != 0) {
		    DPF("AVISave: Failed to create compressed stream!\n");
		    AVIStreamClose(apavi[stream]);
		    apavi[stream] = NULL;
		    goto Error;	// !!!
		}
	    }
	}

	if (apavi[stream] == NULL) {
	    // otherwise just copy the stream over....
	    apavi[stream] = ppavi[stream];
	    AVIStreamAddRef(apavi[stream]);
	}

	lDone[stream] = AVIStreamStart(apavi[stream]);
    }

    // Put the video stream first, so interleaving will work.
    // !!!
    if (iVideoStream > 0) {
	PAVISTREAM p;

	p = apavi[iVideoStream];
	apavi[iVideoStream] = apavi[0];
	apavi[0] = p;
	iVideoStream = 0;
    }

    if (lpfnCallback == NULL)
	lpfnCallback = DummySaveCallback;

    /* pick a good buffer size and go for it.... */
    dwBufferSize = 32768L;

    lpBuffer = GlobalAllocPtr(GMEM_MOVEABLE, dwBufferSize);
    if (!lpBuffer) {
	hr = ResultFromScode(AVIERR_MEMORY);
	goto Error;
    }

    //
    // Construct AVI file header
    //
    AVIStreamInfoW(apavi[0], &strhdr, sizeof(strhdr));
    hdrNew.dwMicroSecPerFrame = muldiv32(1000000L, strhdr.dwScale, strhdr.dwRate);
    hdrNew.dwMaxBytesPerSec = 0;
    hdrNew.dwPaddingGranularity = 0;

    hdrNew.dwFlags = AVIF_HASINDEX;	
    hdrNew.dwFlags &= ~(AVIF_ISINTERLEAVED | AVIF_WASCAPTUREFILE |
					AVIF_MUSTUSEINDEX);

    hdrNew.dwTotalFrames = strhdr.dwLength;
    hdrNew.dwInitialFrames = 0;	

    hdrNew.dwStreams = nStreams;	
    hdrNew.dwSuggestedBufferSize = 32768;
		
    if (iVideoStream >= 0) {
	cbFormat = dwBufferSize;
	hr = AVIStreamReadFormat(apavi[iVideoStream],
				 AVIStreamStart(apavi[iVideoStream]),
				 lpBuffer,
				 &cbFormat);

	if (cbFormat < sizeof(BITMAPINFOHEADER)) {
	    hr = ResultFromScode(AVIERR_INTERNAL);
	}

	if (hr != 0) {
	    DPF("AVISave: Error from initial ReadFormat!\n");
	    goto Error;
	}
	
	lpbi = (LPBITMAPINFOHEADER) lpBuffer;

	hdrNew.dwWidth = lpbi->biWidth;
	hdrNew.dwHeight = lpbi->biHeight;
	lInterval = 1;
    } else {
	hdrNew.dwWidth = 0;
	hdrNew.dwHeight = 0;
	lInterval = AVIStreamTimeToSample(apavi[0], 500);
    }
		
    //
    // Loop through streams and write out stream header
    //
    for (stream = 0; stream < nStreams; stream++) {
	// DPF2("Making stream %d header LIST\n", stream);

        AVIStreamInfoW(apavi[stream], &strhdr, sizeof(strhdr));
	strhdr.dwInitialFrames = 0;

	// If we're interleaving, skew all streams but video by 3/4 of a second
	// so their renderers won't starve
	if (dwInterleaveEvery > 0 && stream > 0) {
	    if (strhdr.fccType != streamtypeVIDEO) {
		strhdr.dwInitialFrames = AVIStreamTimeToSample(apavi[0], 750);
		DPF("Stream %d has %lu initial frames\n", stream, strhdr.dwInitialFrames);
	    }
	}
	
	
	//
	// Get stream format and write it out
	//
	cbFormat = dwBufferSize;
	hr = AVIStreamReadFormat(apavi[stream], AVIStreamStart(apavi[stream]),
				 lpBuffer, &cbFormat);
	if (hr != AVIERR_OK)
	    goto Error;

	// !!! Overflow?
	if (!cbFormat) {
	    // !!!
	}
	
	hr = AVIFileCreateStreamW(pfilesave, &apaviNew[stream], &strhdr);

#if 0
	if (hr != AVIERR_OK || apaviNew[stream] == NULL)
	    goto Error;
#else
	// If we can't make a stream, continue with the other streams....
	if (hr != AVIERR_OK || apaviNew[stream] == NULL) {
	    int i;

	    DPF("AVISave: Couldn't create stream in new file!\n");
	    AVIStreamClose(apavi[stream]);
	
	    for (i = stream + 1; i < nStreams; i++) {
		apavi[stream] = apavi[stream + 1];
	    }
	    --nStreams;
	    --stream;
	    continue;
	}
#endif

	hr = AVIStreamSetFormat(apaviNew[stream], 0, lpBuffer, cbFormat);
	if (hr != AVIERR_OK) {
	    DPF("Initial set format failed!\n");
	    goto Error;
	}
	
	cbFormat = dwBufferSize;
	hr = AVIStreamReadData(apavi[stream], ckidSTREAMHANDLERDATA,
				     lpBuffer, &cbFormat);
	// !!! overflow?
	
	if (hr == AVIERR_OK && cbFormat) {
	    /*
	    ** Make the stream Data data chunk
	    */
	    // DPF2("Making stream %ld Data data chunk\n", stream);
	    hr = AVIStreamWriteData(apaviNew[stream], ckidSTREAMHANDLERDATA,
			lpBuffer, cbFormat);
	    if (hr != AVIERR_OK)
		goto Error;
	}

	if (strhdr.dwInitialFrames > hdrNew.dwInitialFrames)
	    hdrNew.dwInitialFrames = strhdr.dwInitialFrames;

	// This will round UP to the nearest video sample, which is what we want
	dwSize = AVIStreamSampleToSampleNoClip(apavi[0],
				    apavi[stream],
				    AVIStreamLength(apavi[stream]));
	
	if (dwSize > hdrNew.dwTotalFrames)
	    hdrNew.dwTotalFrames = dwSize;
	
	// !!! Should call ReadExtra and WriteExtra to move over information!
    }

    if (nStreams <= 0) {
	DPF("No streams at all accepted by the file!\n");
	goto Error;
    }

    //
    // We've written the header.  Now, there are two possibilities:
    //
    // 1.) File is interleaved.  We loop in time from beginning to end,
    //	    then loop through the streams and write out any data for the
    //	    current time.
    //
    // 2.) File is not interleaved.  We loop through the streams and
    //	    write each one out separately.
    //

    if (dwInterleaveEvery > 0) {
	DPF("Saving interleaved: factor = %lu, intial = %lu, total = %lu\n", dwInterleaveEvery, hdrNew.dwInitialFrames, hdrNew.dwTotalFrames);

	if (dwInterleaveEvery == 1) {
	    hdrNew.dwFlags |= AVIF_ISINTERLEAVED;
	    AVIFileEndRecord(pfilesave); // Make first record....
	}

	//
	// Interleaved case: loop from start to end...
	//
	for (l = - (LONG) hdrNew.dwInitialFrames;
		l < (LONG) hdrNew.dwTotalFrames;
		l += lInterval) {

 	    //DPF2("Writing data for frame #%ld/%lu\n", l, hdrNew.dwTotalFrames);

	    //
	    // Loop through all of the streams to see what needs to be
	    // done at this time...
	    //	
	    for (stream = 0; stream < nStreams; stream++) {
		LONG	lPos;
		LONG	lPosNext;
		
		LONG	lStart;
		LONG	lEnd;

		hr = AVIStreamInfoW(apaviNew[stream], &strhdr, sizeof(strhdr));

		if (hr != AVIERR_OK)
		    goto Error;

		if (l < - (LONG) strhdr.dwInitialFrames)
		    continue;
		
		// !!! Better use of TWOCCs...
		if (strhdr.fccType == streamtypeAUDIO)
		    cktype = cktypeWAVEbytes;
		else if (strhdr.fccType == streamtypeVIDEO) {
		    if (strhdr.fccHandler == comptypeDIB)
			cktype = cktypeDIBbits;
		    else
			cktype = cktypeDIBcompressed;
		} else
		    cktype = aviTWOCC('x', 'x');

		//
		// Time is based on the first stream:
		// Right now, we want to write out any data in the current
		// stream that lines up between time <l> and <l+1> in the
		// first stream.
		//
		lPos = l + strhdr.dwInitialFrames;
		lPosNext = lPos + lInterval;

		lStart = lDone[stream];
		
		if (l >= (LONG) hdrNew.dwTotalFrames - lInterval) {
		    // If this is going to be the last time through the
		    // interleave loop, make sure everything gets written.
		    lEnd = AVIStreamEnd(apavi[stream]);
		} else {
		    //
		    // Complication: to make other data come in bigger chunks,
		    // we only write it out every once in a while.
		    // We will interleave any non-video stream, not just audio.
		    if (strhdr.fccType != streamtypeVIDEO && stream != 0) {
			if ((lPos % dwInterleaveEvery) != 0)
			    continue;

			lPosNext = lPos + dwInterleaveEvery;
		    }

		    if (stream != 0) {
			//
			// Figure out the data for this stream that needs to be
			// written this time. Round UP so that the data goes
			// early in the file so the stream won't starve.
			//
			lEnd = AVIStreamSampleToSampleNoClip(apavi[stream],
						apavi[0], lPosNext);
		    } else {
			lEnd = lPosNext;
		    }
		
		    lEnd = min(lEnd, AVIStreamEnd(apavi[stream]));
		}

		lDone[stream] = lEnd;

 		//DPF2("   Stream %d: (%ld - %ld)\n", stream, lStart, lEnd);

		//
		// Loop until we've read all we want.
		//
		while (lEnd > lStart) {
		    // !!! Right here, we should call AVIStreamGetFormat
		    // and then call AVIStreamSetFormat on the new
		    // streams.
		    // !!! Whose job is it to tell if the format has really
		    // changed?
		    cbFormat = dwBufferSize;
		    hr = AVIStreamReadFormat(apavi[stream],
					lStart,
					lpBuffer,
					&cbFormat);
		    if (hr != AVIERR_OK) {
			DPF("AVIStreamReadFormat failed!\n");
			goto Error;
		    }
		
		    hr = AVIStreamSetFormat(apaviNew[stream],
					   lStart,
					   lpBuffer,
					   cbFormat);
		    if (hr != AVIERR_OK) {
			// !!! Oh, well: we couldn't write the palette change...
			DPF("AVIStreamSetFormat failed!\n");
		    }

ReadAgain0:
		    cbFormat = dwBufferSize;
		    dwSamplesRead = 0;
		
		    hr = AVIStreamRead(apavi[stream], lStart,
					    lEnd - lStart,
					    lpBuffer, dwBufferSize,
					    &dwSize, &dwSamplesRead);

		    if (// dwSamplesRead == 0 &&
			    (GetScode(hr) == AVIERR_BUFFERTOOSMALL)) {
			//
			// The frame didn't fit in our buffer.
			// Make a bigger buffer.
			//
			dwBufferSize *= 2;
			DPF("Resizing buffer to be %lx bytes\n", dwBufferSize);
			lpBuffer = GlobalReAllocPtr(lpBuffer, dwBufferSize, GMEM_MOVEABLE);
			if (lpBuffer)
			    goto ReadAgain0;

			hr = ResultFromScode(AVIERR_MEMORY);
		    }

		    if (hr != 0) {
			DPF("AVISave: Error %08lx reading stream %d, position %ld!\n", (DWORD) hr, stream, lStart);
			goto Error;
		    }

		    dwFlags = 0;

		    if (AVIStreamFindSample(apavi[stream], lStart,
				FIND_KEY | FIND_PREV) == lStart)
			dwFlags |= AVIIF_KEYFRAME;
		
		    hr = AVIStreamWrite(apaviNew[stream],
					  -1, dwSamplesRead,
					  lpBuffer, dwSize,
					  // cktype, // !!!
					  dwFlags, 0L, 0L);

		    if (hr != AVIERR_OK)
			goto Error;

		    lStart += dwSamplesRead;

 		    if ((LONG) dwSamplesRead != lEnd - lStart) {
 			// DPF2("       %lu of %lu actually read....\n", dwSamplesRead, lEnd - lStart);
		    }

		}
	    }

	    //
	    // Mark the end of the frame, in case we're writing out
	    // the "strict" interleaved format with LIST 'rec' chunks...
	    //
	    if (dwInterleaveEvery == 1) {
		hr = AVIFileEndRecord(pfilesave);
		if (hr != AVIERR_OK) {
		    DPF("AVISave: Error from EndRecord!\n");
		    goto Error;
		}
	    }

	    // Give the application a chance to update status and the user
	    // a chance to abort...
	    if (lpfnCallback((int)
			     muldiv32(l + hdrNew.dwInitialFrames, 100,
				      hdrNew.dwInitialFrames +
					      hdrNew.dwTotalFrames))) {
		hr = ResultFromScode(AVIERR_USERABORT);
		DPF("AVISave: Aborted!\n");
		goto Error;
	    }
	}
    } else {
	//
	// Non-interleaved case: loop through the streams and write
	// each one out by itself.
	//
	DPF("Saving non-interleaved.\n");

	for (stream = 0; stream < nStreams; stream++) {
	    if (lpfnCallback(MulDiv(stream, 100, nStreams))) {
		hr = ResultFromScode(AVIERR_USERABORT);
		goto Error;
	    }
		
            AVIStreamInfoW(apavi[stream], &strhdr, sizeof(strhdr));

	    DPF("Saving stream %d: start=%lx, len=%lx\n", stream, strhdr.dwStart, strhdr.dwLength);
	
	    // !!! Need better cktype handling....
	    if (strhdr.fccType == streamtypeAUDIO)
		cktype = cktypeWAVEbytes;
	    else if (strhdr.fccType == streamtypeVIDEO) {
		if (strhdr.fccHandler == comptypeDIB)
		    cktype = cktypeDIBbits;
		else
		    cktype = cktypeDIBcompressed;
	    } else
		cktype = aviTWOCC('x', 'x');

	    //
	    // As usual, there are two possibilities:
	    //
	    // 1.) "wave-like" data, where lots of samples can be in
	    // a single chunk.  In this case, we write out big chunks
	    // with many samples at a time.
	    //
	    // 2.) "video-like" data, where each sample is a different
	    // size, and thus each must be written individually.
	    //
	    if (strhdr.dwSampleSize != 0) {
		/* It's wave-like data: lots of samples per chunk */

		l = strhdr.dwStart;
		while (l < (LONG) strhdr.dwLength) {
		    DWORD	dwRead;
		
		    // Make the format of the new stream
		    // match the old one at every point....
		    //
		    // !!! Whose job is it to tell if the format has really
		    // changed?
		    cbFormat = dwBufferSize;
		    hr = AVIStreamReadFormat(apavi[stream],
					l,
					lpBuffer,
					&cbFormat);
		    if (hr != AVIERR_OK) {
			DPF("AVIStreamReadFormat failed!\n");
			goto Error;
		    }

		    hr = AVIStreamSetFormat(apaviNew[stream],
				       l,
				       lpBuffer,
				       cbFormat);
		    if (hr != AVIERR_OK) {
			DPF("AVIStreamSetFormat failed!\n");
			// !!! Oh, well: we couldn't write the palette change...
		    }


		    //
		    // Read some data...
		    //
ReadAgain1:
		    dwSize = dwBufferSize;
		    dwSamplesRead = 0;
		    dwRead = min(dwBufferSize / strhdr.dwSampleSize,
				 strhdr.dwLength - (DWORD) l);

		    hr = AVIStreamRead(apavi[stream], l, dwRead,
				       lpBuffer, dwBufferSize,
				       &dwSize, &dwSamplesRead);

		    if (// dwSamplesRead == 0 &&
				(GetScode(hr) == AVIERR_BUFFERTOOSMALL)) {
			//
			// The frame didn't fit in our buffer.
			// Make a bigger buffer.
			//
			dwBufferSize *= 2;
			lpBuffer = GlobalReAllocPtr(lpBuffer, dwBufferSize, GMEM_MOVEABLE);
			if (lpBuffer)
			    goto ReadAgain1;
		    }

		    // !!! Check if format has changed

		    dwFlags = 0; // !!! KEYFRAME?

		    DPF("Save: Read %lx/%lx samples at %lx\n", dwSamplesRead, dwRead, l);
		
		    if (hr != AVIERR_OK) {
			DPF("Save: Read failed! (%08lx) pos=%lx, len=%lx\n", (DWORD) hr, l, dwRead);

			goto Error;
		    }

		    if (dwSamplesRead == 0) {
			DPF("Ack: Read zero samples!");
			
			if (l + 1 == (LONG) strhdr.dwLength) {
			    DPF("Pretending it's OK, since this was the last one....");
			    break;
			}

			hr = ResultFromScode(AVIERR_FILEREAD);
			goto Error;
		    }
		
		    l += dwSamplesRead;

		    //
		    // Write the data out...
		    //
		    hr = AVIStreamWrite(apaviNew[stream],
					  -1, dwSamplesRead,
					  lpBuffer, dwSize,
// !!!					  cktype, // !!!TWOCCFromFOURCC(ckid),
					  dwFlags, 0L, 0L);

		    if (hr != AVIERR_OK) {
			DPF("AVIStreamWrite failed! (%08lx)\n", (DWORD) hr);

			goto Error;
		    }
		
		    if (lpfnCallback(MulDiv(stream, 100, nStreams) +
			   (int) muldiv32(l, 100,
					   nStreams * strhdr.dwLength))) {
			hr = ResultFromScode(AVIERR_USERABORT);
			goto Error;
		    }
		}
	    } else {
		/* It's video-like data: one sample (frame) per chunk */

		for (l = strhdr.dwStart;
			l < (LONG) strhdr.dwLength;
			l++) {
		    // !!! Right here, we should call AVIStreamGetFormat
		    // and then call AVIStreamSetFormat on the new
		    // streams.
		    // !!! Whose job is it to tell if the format has really
		    // changed?
		
		    cbFormat = dwBufferSize;
		    hr = AVIStreamReadFormat(apavi[stream],
					l,
					lpBuffer,
					&cbFormat);
		    if (hr != AVIERR_OK) {
			DPF("AVIStreamReadFormat failed!\n");
			goto Error;
		    }

		    hr = AVIStreamSetFormat(apaviNew[stream],
				       l,
				       lpBuffer,
				       cbFormat);
		    if (hr != AVIERR_OK) {
			// !!! Oh, well: we couldn't write the palette change...
			DPF("AVIStreamSetFormat failed!\n");
		    }


    ReadAgain:
		    dwSize = dwBufferSize;
		    /* Write out a single frame.... */
		    dwSamplesRead = 0;
		    hr = AVIStreamRead(apavi[stream], l, 1,
					    lpBuffer, dwBufferSize,
					    &dwSize, &dwSamplesRead);

		    // !!! Check if format has changed (palette change)

		    if (// dwSamplesRead == 0 &&
				(GetScode(hr) == AVIERR_BUFFERTOOSMALL)) {
			//
			// The frame didn't fit in our buffer.
			// Make a bigger buffer.
			//
			dwBufferSize *= 2;
			lpBuffer = GlobalReAllocPtr(lpBuffer, dwBufferSize, GMEM_MOVEABLE);
			if (lpBuffer)
			    goto ReadAgain;
		    }

		    if (dwSamplesRead != 1 || hr != 0) {
			hr = ResultFromScode(AVIERR_FILEREAD);
			goto Error;
		    }

		    dwFlags = 0; // !!!!

		    //
		    // Check whether this should be marked a key frame.
		    //
		    // !!! shouldn't this be returned from AVIStreamRead()?
		    //
		    if (AVIStreamFindSample(apavi[stream], l,
				FIND_KEY | FIND_PREV) == l)
			dwFlags |= AVIIF_KEYFRAME;

		    //
		    // Write the chunk out.
		    //
		    hr = AVIStreamWrite(apaviNew[stream],
					  -1, dwSamplesRead,
					  lpBuffer, dwSize,
// !!!					  cktype, // !!!TWOCCFromFOURCC(ckid),
					  dwFlags, 0L, 0L);

		    if (hr != AVIERR_OK)
			goto Error;

		    //
		    // Video frames can be big, so call back every time.
		    //
		    if (lpfnCallback(MulDiv(stream, 100, nStreams) +
			   (int) muldiv32(l, 100, nStreams * strhdr.dwLength))) {
			hr = ResultFromScode(AVIERR_USERABORT);
			goto Error;
		    }
		}
	    }
	}
    }

Error:
    //
    // We're done, one way or another.
    //

    /* Free buffer */
    if (lpBuffer) {
	GlobalFreePtr(lpBuffer);
    }

    // If everything's OK so far, finish writing the file.
    // Close the file, free resources associated with writing it.
    if (pfilesave) {
	// Release all of our new streams
	for (stream = 0; stream < nStreams; stream++) {
	    if (apaviNew[stream])
		AVIStreamClose(apaviNew[stream]);
	}
	
	if (hr != AVIERR_OK)
	    AVIFileClose(pfilesave);
	else {
	    // !!! ACK: AVIFileClose doesn't return an error! How do I tell
	    // if it worked?
	    // !!! does this mean I need a Flush() call?
	    /* hr = */ AVIFileClose(pfilesave);
	}
	
    }

    // Release all of our streams
    for (stream = 0; stream < nStreams; stream++) {
	if (apavi[stream])
	    AVIStreamClose(apavi[stream]);
    }

    if (hr != 0) {
	DPF("AVISave: Returning error %08lx\n", (DWORD) hr);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\classobj.cpp ===
/*	-	-	-	-	-	-	-	-	*/

/*
**	Copyright (C) Microsoft Corporation 1993 - 1995. All rights reserved.
*/

/*	-	-	-	-	-	-	-	-	*/

#define INITGUID
#include <win32.h>
#include <vfw.h>

#include "avifilei.h"
#include "avicmprs.h"
#include "avifps.h"
#include "editstrm.h"
#include "wavefile.h"

#include "debug.h"

#ifndef _WIN32
DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);
DEFINE_OLEGUID(IID_IClassFactory,       0x00000001L, 0, 0);
DEFINE_OLEGUID(IID_IMalloc,             0x00000002L, 0, 0);
DEFINE_OLEGUID(IID_IMarshal,            0x00000003L, 0, 0);
#endif

extern "C"	HINSTANCE	ghMod;
		HINSTANCE	ghMod;

/*      -       -       -       -       -       -       -       -       */

EXTERN_C int CALLBACK LibMain(
        HINSTANCE       hInstance,
        UINT            uDataSeg,
        UINT            cbHeapSize,
        LPCTSTR          pszCmdLine)
{
	// save our module handle
	ghMod = hInstance;
	return TRUE;
}

EXTERN_C int CALLBACK WEP(BOOL fSystemExit)
{
	return TRUE;
}

/*	-	-	-	-	-	-	-	-	*/

STDAPI DllGetClassObject(
	const CLSID FAR&	rclsid,
	const IID FAR&	riid,
	void FAR* FAR*	ppv)
{
	HRESULT	hresult;

	DPF("DllGetClassObject\n");

        *ppv = NULL;

	if (rclsid == CLSID_AVIFile ||
	    rclsid == CLSID_ACMCmprs ||
#ifdef CHICAGO
	    rclsid == CLSID_AVISimpleUnMarshal ||
#endif
	    rclsid == CLSID_AVIWaveFileReader ||
	    rclsid == CLSID_AVICmprsStream) {
	    hresult = CAVIFileCF::Create(rclsid, riid, ppv);
	    return hresult;
	} else if (rclsid == CLSID_AVIStreamPS) {
            CPSFactory *cps = new CPSFactory();
            if (cps) {
                hresult = cps->QueryInterface(riid, ppv);
                cps->Release();
            } else {
                hresult = E_OUTOFMEMORY;
            }
            return hresult;
	} else {
	    return ResultFromScode(E_UNEXPECTED);
	}
}

/*      -       -       -       -       -       -       -       -       */

#ifdef _WIN32

EXTERN_C BOOL WINAPI DLLEntryPoint(HINSTANCE hModule, ULONG Reason, LPVOID pv)
{
    switch (Reason)
    {
        case DLL_PROCESS_ATTACH:
            LibMain(hModule, 0, 0, NULL);
            DisableThreadLibraryCalls(hModule);
            break;

        case DLL_PROCESS_DETACH:
            WEP(FALSE);
            break;

        //case DLL_THREAD_DETACH:
        //    break;

        //case DLL_THREAD_ATTACH:
        //    break;
    }

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\buffer.h ===
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#include "fileshar.h"
    
#pragma warning(disable:4200)

typedef struct {
    LONG    lOffset;
    LONG    lLength;
    LPVOID  lpBuffer;
} BUFFER;

typedef struct {
    int	    nBuffers;
    LONG    lBufSize;
    LPVOID  lpBufMem;
    HSHFILE hshfile;
    BOOL    fStreaming;
    BOOL    fUseDOSBuf;
    PAVIINDEX px;
    LONG      lx;
    LONG    lFileLength;
    int	    iNextBuf;
    BUFFER  aBuf[];
} BUFSYSTEM, *PBUFSYSTEM;

PBUFSYSTEM FAR PASCAL InitBuffered(int nBuffers, LONG lBufSize,
				    HSHFILE hshfile,
                                    PAVIINDEX px);

LONG FAR PASCAL BufferedRead(PBUFSYSTEM pb, LONG l, LONG cb, LPVOID lp);

LONG FAR PASCAL BeginBufferedStreaming(PBUFSYSTEM pb, BOOL fForward);
LONG FAR PASCAL EndBufferedStreaming(PBUFSYSTEM pb);

void FAR PASCAL EndBuffered(PBUFSYSTEM pb);


#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\device.cpp ===
/*	-	-	-	-	-	-	-	-	*/

/*
**	Copyright (C) Microsoft Corporation 1993-1995. All rights reserved.
*/

/*	-	-	-	-	-	-	-	-	*/

#include <win32.h>
#include <vfw.h>
#include "avifilei.h"
#include "debug.h"

/*	-	-	-	-	-	-	-	-	*/

UINT	uUseCount;
BOOL	fLocked;

/*	-	-	-	-	-	-	-	-	*/

STDAPI DllCanUnloadNow(
	void)
{
	DPF("DllCanUnloadNow: Usage = %u\n", uUseCount);
	return ResultFromScode((fLocked || uUseCount) ? S_FALSE : S_OK);
}

/*	-	-	-	-	-	-	-	-	*/

HRESULT CAVIFile::Create(
	IUnknown FAR*	pUnknownOuter,
	const IID FAR&	riid,
	void FAR* FAR*	ppv)
{
	IUnknown FAR*	pUnknown;
	CAVIFile FAR*	pAVIFile;
	HRESULT	hresult;

	pAVIFile = new FAR CAVIFile(pUnknownOuter, &pUnknown);
	if (!pAVIFile)
		return ResultFromScode(E_OUTOFMEMORY);
	hresult = pUnknown->QueryInterface(riid, ppv);
	if (FAILED(GetScode(hresult)))
		delete pAVIFile;
	return hresult;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIFile::CAVIFile(
	IUnknown FAR*	pUnknownOuter,
	IUnknown FAR* FAR*	ppUnknown) :
	m_Unknown(this),
	m_PersistS(this),
	m_PersistF(this),
	m_AVIFile(this)
#ifdef CUSTOMMARSHAL
	, m_Marshal(this)
#endif
{
	hshfile = 0;
	achFile[0] = TEXT('\0');
	fInRecord = FALSE;
	lWriteLoc = 0;
	fDirty = 0;
	extra.lp = 0;
	extra.cb = 0;
	_fmemset(&avihdr, 0, sizeof(avihdr));
	_fmemset(ps, 0, sizeof(ps));
	avihdr.dwStreams = 0;
	lHeaderSize = 0;
        px = NULL;
	pb = NULL;

	if (pUnknownOuter) {
	    DPF("(F) Being aggregated!\n");
	    m_pUnknownOuter = pUnknownOuter;
	} else
	    m_pUnknownOuter = &m_Unknown;
	*ppUnknown = &m_Unknown;

#ifdef WIN32
	InitializeCriticalSection(&m_critsec);
#endif
}

/*	-	-	-	-	-	-	-	-	*/

CAVIFile::CUnknownImpl::CUnknownImpl(
	CAVIFile FAR*	pAVIFile)
{
	m_pAVIFile = pAVIFile;
	m_refs = 0;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIFile::CUnknownImpl::QueryInterface(
	const IID FAR&	iid,
	void FAR* FAR*	ppv)
{
	if (iid == IID_IUnknown
#ifdef CUSTOMMARSHAL
		 || iid == CLSID_AVISimpleUnMarshal
#endif
	)
		*ppv = &m_pAVIFile->m_Unknown;
	else if (iid == IID_IAVIFile)
		*ppv = &m_pAVIFile->m_AVIFile;
#if 0
	else if (iid == IID_IPersistStorage)
		*ppv = &m_pAVIFile->m_PersistS;
#endif
	else if (iid == IID_IPersistFile)
		*ppv = &m_pAVIFile->m_PersistF;
#ifdef CUSTOMMARSHAL
	else if (iid == IID_IMarshal) {
		DPF("(F) QueryInterface (IMarshal)\n");
		*ppv = &m_pAVIFile->m_Marshal;
	}
#endif
	else {
		*ppv = NULL;
		return ResultFromScode(E_NOINTERFACE);
	}
	AddRef();
	return AVIERR_OK;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIFile::CUnknownImpl::AddRef()
{
	DPF2("File   %p: Usage++=%lx\n", (DWORD_PTR) (LPVOID) this, m_refs + 1);

	if (m_pAVIFile->hshfile)
	    shfileAddRef(m_pAVIFile->hshfile);
	uUseCount++;
	return ++m_refs;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIFile::CAVIFileImpl::CAVIFileImpl(
	CAVIFile FAR*	pAVIFile)
{
	m_pAVIFile = pAVIFile;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIFile::CAVIFileImpl::~CAVIFileImpl()
{
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIFile::CAVIFileImpl::QueryInterface(
	const IID FAR&	iid,
	void FAR* FAR*	ppv)
{
	return m_pAVIFile->m_pUnknownOuter->QueryInterface(iid, ppv);
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIFile::CAVIFileImpl::AddRef()
{
	return m_pAVIFile->m_pUnknownOuter->AddRef();
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIFile::CAVIFileImpl::Release()
{
	return m_pAVIFile->m_pUnknownOuter->Release();
}

/*	-	-	-	-	-	-	-	-	*/


/*	-	-	-	-	-	-	-	-	*/

CAVIStream::CAVIStream(
	IUnknown FAR*	pUnknownOuter,
	IUnknown FAR* FAR*	ppUnknown) :
	m_Unknown(this),
	m_AVIStream(this),
#ifdef CUSTOMMARSHAL
	m_Marshal(this),
#endif
	m_Streaming(this)
{
	paviBase = NULL;
	hshfile = 0;
	lpFormat = NULL;
	cbFormat = 0;
	lpData = NULL;
	cbData = 0;
	extra.lp = NULL;
        extra.cb = 0;
        psx = NULL;
	lPal = 0;
	pb = NULL;
	fInit = FALSE;

	if (pUnknownOuter) {
	    DPF("(S) Being aggregated!\n");
	    m_pUnknownOuter = pUnknownOuter;
	}
	else
		m_pUnknownOuter = &m_Unknown;
	*ppUnknown = &m_Unknown;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIStream::~CAVIStream()
{
    if (lpFormat)
	GlobalFreePtr(lpFormat);

    if (lpData)
	GlobalFreePtr(lpData);

    if (extra.lp) {
	DPF2("Freeing %ld bytes of extra stream data.\n", extra.cb);
	GlobalFreePtr(extra.lp);
    }

    if (paviBase)
	AVIStreamClose(paviBase);
}

/*	-	-	-	-	-	-	-	-	*/

CAVIStream::CUnknownImpl::CUnknownImpl(
	CAVIStream FAR*	pAVIStream)
{
	m_pAVIStream = pAVIStream;
	m_refs = 0;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIStream::CUnknownImpl::QueryInterface(
	const IID FAR&	iid,
	void FAR* FAR*	ppv)
{
	if (iid == IID_IUnknown
#ifdef CUSTOMMARSHAL
		|| iid == CLSID_AVISimpleUnMarshal
#endif
	)
		*ppv = &m_pAVIStream->m_Unknown;
	else if (iid == IID_IAVIStream)
		*ppv = &m_pAVIStream->m_AVIStream;
	else if (iid == IID_IAVIStreaming)
		*ppv = &m_pAVIStream->m_Streaming;
#ifdef CUSTOMMARSHAL
	else if (iid == IID_IMarshal) {
		DPF("(S) QueryInterface (IMarshal)\n");
		*ppv = &m_pAVIStream->m_Marshal;
	}
#endif
	else {
		*ppv = NULL;
		return ResultFromScode(E_NOINTERFACE);
	}
	AddRef();
	return NULL;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIStream::CUnknownImpl::AddRef()
{
	uUseCount++;
	if (m_pAVIStream->hshfile)
	    shfileAddRef(m_pAVIStream->hshfile);
	if (m_refs < 20) {
	    DPF2("Stream %p: Usage++=%lx\n", (DWORD_PTR) (LPVOID) this, m_refs + 1);
	}
	
	return ++m_refs;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIStream::CAVIStreamImpl::CAVIStreamImpl(
	CAVIStream FAR*	pAVIStream)
{
	m_pAVIStream = pAVIStream;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIStream::CAVIStreamImpl::~CAVIStreamImpl()
{
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIStream::CAVIStreamImpl::QueryInterface(
	const IID FAR&	iid,
	void FAR* FAR*	ppv)
{
	return m_pAVIStream->m_pUnknownOuter->QueryInterface(iid, ppv);
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIStream::CAVIStreamImpl::AddRef()
{
	return m_pAVIStream->m_pUnknownOuter->AddRef();
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIStream::CAVIStreamImpl::Release()
{
	return m_pAVIStream->m_pUnknownOuter->Release();
}

/*	-	-	-	-	-	-	-	-	*/

CAVIStream::CStreamingImpl::CStreamingImpl(
	CAVIStream   FAR*	pAVIStream)
{
	m_pAVIStream = pAVIStream;
}

/*	-	-	-	-	-	-	-	-	*/

CAVIStream::CStreamingImpl::~CStreamingImpl()
{
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP CAVIStream::CStreamingImpl::QueryInterface(
	const IID FAR&	iid,
	void FAR* FAR*	ppv)
{
	return m_pAVIStream->m_pUnknownOuter->QueryInterface(iid, ppv);
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIStream::CStreamingImpl::AddRef()
{
	return m_pAVIStream->m_pUnknownOuter->AddRef();
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CAVIStream::CStreamingImpl::Release()
{
	return m_pAVIStream->m_pUnknownOuter->Release();
}

/*	-	-	-	-	-	-	-	-	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\directio.cpp ===
/****************************************************************************
 *
 *  DIRECTIO.CPP
 *
 *  routines for reading Standard AVI files
 *
 *  Copyright (c) 1992 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *
 * implementation of a disk i/o class designed to optimise
 * sequential reading and writing to disk by using overlapped i/o (for read
 * ahead and write behind) and using large buffers written with no buffering.
 *
 ***************************************************************************/
#include <windows.h>
#include <win32.h>
#include "debug.h"

#include "directio.h"

#ifdef USE_DIRECTIO

//
// implementation of a disk i/o class designed to optimise
// sequential reading and writing to disk by using overlapped i/o (for read
// ahead and write behind) and using large buffers written with no buffering.



// -- CFileStream class methods ---------------------------------------


// initialise to known (invalid) state
CFileStream::CFileStream()
{
        m_State = Invalid;
        m_Position = 0;
        m_hFile = INVALID_HANDLE_VALUE;
#ifdef CHICAGO
        ZeroMemory(&m_qio, sizeof(m_qio));
#endif
}


BOOL
CFileStream::Open(LPTSTR file, BOOL bWrite, BOOL bTruncate)
{
    if (m_State != Invalid) {
        return FALSE;
    }


    // remember this for default streaming mode
    m_bWrite = bWrite;

    DWORD dwAccess = GENERIC_READ;
    if (bWrite) {
        dwAccess |= GENERIC_WRITE;
    }


    // open the file. Always get read access. exclusive open if we
    // are writing the file, otherwise deny other write opens.

    // never truncate the file, since the file may be de-fragmented.

   #ifdef CHICAGO
    DWORD dwFlags = FILE_FLAG_NO_BUFFERING;
   #else
    DWORD dwFlags = FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING;
   #endif

    m_hFile = CreateFile(file,
                dwAccess,
                (bWrite ? 0 : FILE_SHARE_READ),
                NULL,
                OPEN_ALWAYS,
                dwFlags,
                0);

    if (m_hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

   #ifdef CHICAGO
    if ( ! QioInitialize(&m_qio, m_hFile, THREAD_PRIORITY_HIGHEST)) {
        CloseHandle (m_hFile);
        return FALSE;
    }
   #endif

    // find the bytes per sector that we have to round to for this file
    // -requires finding the 'root path' for this file.
    TCHAR ch[MAX_PATH];
    LPTSTR ptmp;    //required arg

    GetFullPathName(file, sizeof(ch)/sizeof(ch[0]), ch, &ptmp);

    // truncate this to the name of the root directory
    if ((ch[0] == TEXT('\\')) && (ch[1] == TEXT('\\'))) {

        // path begins with  \\server\share\path so skip the first
        // three backslashes
        ptmp = &ch[2];
        while (*ptmp && (*ptmp != TEXT('\\'))) {
            ptmp++;
        }
        if (*ptmp) {
            // advance past the third backslash
            ptmp++;
        }
    } else {
        // path must be drv:\path
        ptmp = ch;
    }

    // find next backslash and put a null after it
    while (*ptmp && (*ptmp != TEXT('\\'))) {
        ptmp++;
    }
    // found a backslash ?
    if (*ptmp) {
        // skip it and insert null
        ptmp++;
        *ptmp = TEXT('\0');
    }

    DWORD dwtmp1, dwtmp2, dwtmp3;
    if (!GetDiskFreeSpace(ch,
        	&dwtmp1,
        	&m_SectorSize,
        	&dwtmp2,
        	&dwtmp3))
	m_SectorSize = 2048;

    // sigh. now init the first buffer

    // sets the right buffer count and size for current mode
    m_State = Stopped;
    if (!EnsureBuffersValid()) {
        return FALSE;
    }
    m_Current = 0;
    m_Position = 0;

    // if asked to truncate the file, we will not actually do so, since this
    // could throw away a de-fragged file. We will however, note that the file
    // size is 0 and use this to affect reading and writing past 'eof' - eg
    // if you write 8 bytes to the beginning of a truncated file, we do not
    // need to read in the first sector beforehand.
    if (bTruncate) {
	m_Size = 0;
    } else {
	// get the current file size
	m_Size = GetFileSize(m_hFile, NULL);
    }

    // all set
    return TRUE;
}




BOOL
CFileStream::Seek(DWORD pos)
{
    // we just record this and go away
    //if (pos < m_Position) {
    //    DPF("seek back by 0x%x to 0x%x\n", m_Position - pos, pos);
    //}

    m_Position  = pos;

    return TRUE;
}

DWORD
CFileStream::GetCurrentPosition()
{
    return m_Position;
}

BOOL
CFileStream::Write(LPBYTE pData, DWORD count, DWORD * pbyteswritten)
{
    *pbyteswritten = 0;


    // error if file not opened
    if (m_State == Invalid) {
        return FALSE;
    }

    DWORD nBytes;

    while (count > 0) {


        // is our current buffer ready to write this data ?
        // (we need to tell it eof pos as well since if eof is
        // in middle of buffer but beyond valid data, ok to write.)

	if ((m_Current < 0) ||
	    (!m_Buffers[m_Current].QueryPosition(m_Position, m_Size))) {

            // commit this buffer if we have changed position beyond it
            if (m_Current >= 0) {
		if (!m_Buffers[m_Current].Commit()) {
		    // file error - abort
		    return FALSE;
		}

		// if we are streaming, then advance to next buffer while
		// current one is writing.
		if (m_State != Stopped) {
		    m_Current = NextBuffer(m_Current);
		}
	    } else {
		m_Current = 0;
	    }

            // make sure that previous operations on this buffer have completed
            if (!m_Buffers[m_Current].WaitComplete()) {
                // i/o error
                return FALSE;
            }
        }

        // we either have a buffer that has already pre-read the sector
        // we start writing to, or we have an idle buffer that
        // will do the pre-read for us
        if (!m_Buffers[m_Current].Write(m_Position, pData, count, m_Size, &nBytes)) {
            return FALSE;
        }

        count -= nBytes;
        pData += nBytes;
        m_Position += nBytes;
        *pbyteswritten += nBytes;
    }

    if (m_Position > m_Size) {
        m_Size = m_Position;
    }

    return TRUE;
}



BOOL
CFileStream::Read(LPBYTE pData, DWORD count, DWORD * pbytesread)
{

    *pbytesread = 0;

    // error if file not opened
    if (m_State == Invalid) {
        return FALSE;
    }

    // force the read to be within the file size limits
    if (m_Position >= m_Size) {
        // all done - nothing read
        return TRUE;
    } else {
        count = min(count, (m_Size - m_Position));
    }

    BOOL bDoReadAhead = FALSE;
    DWORD nBytes;

    while (count > 0) {

        // is data within current buffer
        if ((m_Current < 0) ||
	    (!m_Buffers[m_Current].QueryPosition(m_Position, m_Size))) {

	    if (m_Current >= 0) {
		// commit this buffer if we have changed position beyond it
		if (!m_Buffers[m_Current].Commit()) {
		    // file error - abort
		    return FALSE;
		}

		// advance to next buffer (if streaming)
		if (m_State == Writing) {
		    m_Current = NextBuffer(m_Current);
		} else if (m_State == Reading) {

		    // smart read-ahead strategy: try to find in existing
		    // buffers, and only issue a read-ahead if we take the
		    // highest buffer
		    int n = NextBuffer(m_Current);
		    m_Current = -1;
		    for (int i = 0; i < m_NrValid; i++) {
			if (m_Buffers[n].QueryPosition(m_Position, m_Size)) {
			    m_Current = n;
			    break;
			}
			n = NextBuffer(n);
		    }
		    if (m_Current < 0) {
			// read-ahead is messed up because we have made too big
			// a seek for the current buffer size
			// Best thing is to use the lowest buffer (should be the
			// one after the highest, and to restart readaheads with
			// this position).
			m_Current = NextBuffer(m_HighestBuffer);
			m_HighestBuffer = m_Current;
			DPF("using idle %d\n", m_Current);

		    }

		    if (m_Current == m_HighestBuffer) {
			bDoReadAhead = TRUE;
		    }
		}
	    } else {
		m_Current = 0;
		if (m_Current == m_HighestBuffer) {
		    bDoReadAhead = TRUE;
		}
	    }



            // make sure that previous operations on this buffer have completed
            if (!m_Buffers[m_Current].WaitComplete()) {
                // i/o error
                return FALSE;
            }
        }

        // now we have a buffer that either contains the data we want, or
        // is idle and ready to fetch it.
        if (!m_Buffers[m_Current].Read(m_Position, pData, count, m_Size, &nBytes)) {
            return FALSE;
        }

        count -= nBytes;
        pData += nBytes;
        m_Position += nBytes;
        *pbytesread += nBytes;

        // do read ahead now if necessary (the Read() call may have required
        // a seek and read if the data was not in the buffer, so delay the
        // read-ahead until after it has completed).
        if (bDoReadAhead) {

            // remember that this new buffer contains the highest position
            // -- we should issue another readahead when we start using this
            // buffer.

            m_HighestBuffer = NextBuffer(m_Current);

            DWORD p = m_Buffers[m_Current].GetNextPosition();

            m_Buffers[m_HighestBuffer].ReadAhead(p, m_Size);

            bDoReadAhead = FALSE;
        }
    }

    return TRUE;
}


// set the right buffer size and count for current mode
BOOL
CFileStream::EnsureBuffersValid()
{
    if (m_State == Invalid) {
        // file not opened
        return FALSE;
    }

   #ifdef CHICAGO
    if (m_State == Writing) {
        m_NrValid = 4;          // total 256k
    } else if (m_State == Reading) {
        m_NrValid = 4;		// total 256k
    } else {
        m_NrValid = 1;		// total 64k
    }

    int size = (64 * 1024);
   #else
    if (m_State == Writing) {
        m_NrValid = 2;		// total 512k
    } else if (m_State == Reading) {
        m_NrValid = 4;		// total 256k
    } else {
        m_NrValid = 1;		// total 64k
    }

    int size = (64 * 1024);
    if (m_State == Writing)
        size = (256 * 1024);
   #endif

    int i =0;

    Assert(m_NrValid <= NR_OF_BUFFERS);

    // init valid buffers
    for (; i < m_NrValid; i++) {
       #ifdef CHICAGO
        if (!m_Buffers[i].Init(m_SectorSize, size, &m_qio)) {
       #else
        if (!m_Buffers[i].Init(m_SectorSize, size, m_hFile)) {
       #endif
            return FALSE;
        }
    }

    // discard others
    for (; i < NR_OF_BUFFERS; i++) {
        m_Buffers[i].FreeMemory();
    }
    return TRUE;
}

BOOL
CFileStream::StartStreaming()
{
    if (m_bWrite) {
	return StartWriteStreaming();
    } else {
	return StartReadStreaming();
    }
}

BOOL
CFileStream::StartWriteStreaming()
{
    m_State = Writing;

    if (!EnsureBuffersValid()) {
        return FALSE;
    }

    return TRUE;
}

BOOL
CFileStream::StartReadStreaming()
{
    // commit the current buffer
    if (!m_Buffers[m_Current].Commit()) {
        return FALSE;
    }

    m_State = Reading;

    if (!EnsureBuffersValid()) {
        return FALSE;
    }

    // start read-ahead on buffer 0 - read from current position
    // (tell buffer the eof point so it won't bother reading beyond it)
    // remember that this is the highest current buffer - when we start using
    // this buffer it is time to issue the next readahead (this allows for
    // seeks backwards and forwards within the valid buffers without upsetting
    // the read-aheads).

    m_HighestBuffer = 0;
    m_Buffers[0].ReadAhead(m_Position, m_Size);

    // set m_Current invalid: this ensures that we will wait for read-ahead
    // to complete before getting data, and that when we start using it, we
    // will issue the next read-ahead.
    m_Current = -1;

    return TRUE;

}

BOOL
CFileStream::StopStreaming()
{
    // complete all i/o
    if (!CommitAndWait()) {
        return FALSE;
    }

    m_Current = 0;
    m_State = Stopped;

    // recalc buffer size/count for new mode
    if (!EnsureBuffersValid()) {
        return FALSE;
    }

    return TRUE;
}


// wait for all transfers to complete.
BOOL CFileStream::CommitAndWait()
{
    // write current buffer
    //
    if (!m_Buffers[m_Current].Commit())
        return FALSE;

   #ifdef CHICAGO
    // flush all buffers that have been queued
    //
    //QioCommit (&m_qio);
   #endif

    // wait for all buffers to complete
    for (int i = 0; i < m_NrValid; i++) {

        if (!m_Buffers[i].WaitComplete()) {
            return FALSE;
        }
    }
    // no need to reset m_Current
    return TRUE;
}


// destructor will call Commit()
CFileStream::~CFileStream()
{
    if (m_hFile != INVALID_HANDLE_VALUE) {
        CommitAndWait();

       #ifdef CHICAGO
        QioShutdown (&m_qio);
       #endif

        CloseHandle(m_hFile);
    }
}


// --- CFileBuffer methods -----------------------------------------



// initiate to an invalid (no buffer ready) state
CFileBuffer::CFileBuffer()
{
    m_pBuffer = NULL;
    m_pAllocedMem = NULL;
    m_State = Invalid;
#ifdef CHICAGO
    m_pqio = NULL;
#endif

}

// allocate memory and become idle.
BOOL
#ifdef CHICAGO
CFileBuffer::Init(DWORD nBytesPerSector, DWORD buffersize, LPQIO pqio)
#else
CFileBuffer::Init(DWORD nBytesPerSector, DWORD buffersize, HANDLE hfile)
#endif
{
    if (m_State != Invalid) {

        if ((nBytesPerSector == m_BytesPerSector) &&
            (buffersize == RoundSizeToSector(m_TotalSize))) {

                // we're there already
                return TRUE;
        }

        // discard what we have
        FreeMemory();
    }

    Assert(m_State == Invalid);

    // round up RAWIO_SIZE to a multiple of sector size
    m_BytesPerSector = nBytesPerSector;
    m_TotalSize = (DWORD) RoundSizeToSector(buffersize);

    m_DataLength = 0;
    m_State = Idle;
    m_bDirty = FALSE;

   #ifdef CHICAGO

    m_pqio = pqio;
    m_pAllocedMem = (unsigned char *)VirtualAlloc (NULL, m_TotalSize,
                              MEM_RESERVE | MEM_COMMIT,
                              PAGE_READWRITE);
    if (m_pAllocedMem == NULL)
        return FALSE;

   #else

    m_hFile = hfile;
    m_pAllocedMem = new BYTE[m_TotalSize];

    if (m_pAllocedMem == NULL)
        return FALSE;

    m_Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_Overlapped.hEvent) {
        delete[] m_pAllocedMem;
        return FALSE;
    }

   #endif

   // this is where my naming scheme falls down. RoundPos rounds down, and
   // RoundSize rounds up. to correctly align the buffer and stay within it,
   // we need to round the start address up and the size down.

   // round start address up to sector size
   m_pBuffer = (LPBYTE) RoundSizeToSector((LONG_PTR) m_pAllocedMem);
   // remove rounding from size - and round it again!
   m_TotalSize = (DWORD) RoundPosToSector(m_TotalSize - (m_pBuffer - m_pAllocedMem));



    return TRUE;
}


// revert to invalid state (eg when streaming stops)
void
CFileBuffer::FreeMemory()
{
    if (m_State == Idle) {
        Commit();
    }
    if (m_State == Busy) {
        WaitComplete();
    }

    if (m_State != Invalid) {

       #ifdef CHICAGO

        VirtualFree (m_pAllocedMem, 0, MEM_RELEASE);
        m_pBuffer = NULL;
	m_pAllocedMem = NULL;

       #else

        CloseHandle(m_Overlapped.hEvent);
        delete[] m_pAllocedMem;

       #endif

        m_State = Invalid;
    }
}

// calls commit if dirty before freeing everything.
CFileBuffer::~CFileBuffer()
{
    FreeMemory();
}


// does this position occur anywhere within the current buffer ?
// needs to know current eof for some cases (writing beyond eof
// if eof is within this buffer is ok to this buffer).
//
// we can use this buffer if:
// 1. if the buffer is empty and the write is past eof (where eof is rounded
//    to a sector boundary).
//
// 2. if the start position is within the current m_DataLength
//
// 3. if eof is within the buffer and the write is past eof
//
// all reads are limited by the caller to be within the file limits, so
// the reading case is covered by 2 above (1 and 3 will not occur).
//
// all other cases will require the read of data that is not in the buffer.
// or the (early) committing of data in the buffer
//
BOOL
CFileBuffer::QueryPosition(DWORD pos, DWORD filesize)
{

    if (m_State == Invalid) {
        return FALSE;
    }

    // round filesize to sector boundary
    filesize = (DWORD) RoundSizeToSector(filesize);

    if (pos >= filesize) {

        // write is past eof. ok if buffer empty or if buffer contains
        // eof (and has space in it)
        if ((m_DataLength == 0) ||
            ((m_Position + m_DataLength == filesize) &&
             (m_DataLength < m_TotalSize))) {
                return TRUE;
        }

        // we have data that needs to be flushed before we can do this
        return FALSE;
    } else {

        if ((pos >= m_Position) &&
            (pos < m_Position + m_DataLength)) {

                // we have this byte
                return TRUE;
        }

        // we don't have this byte of valid data. we have some other.
        //
        // you might think that if the write begins on a sector boundary, and
        // this buffer's data is not dirty you could permit this without a
        // pre-read - but we don't know yet where the write will end, and if
        // it ends mid-sector and not past current eof, we will need to
        // read that sector in.
        return FALSE;
    }
}



// write some data to buffer (must be committed separately)
// filesize parameter is the file size before this write, and is used to
// control what we do with the partial sector at beginning and end
// -if not past current eof, we need to read the current sector before
// writing to it.
BOOL
CFileBuffer::Write(
    DWORD pos,
    LPBYTE pData,
    DWORD count,
    DWORD filesize,
    DWORD * pbytesWritten)
{

    // remember for later (during commit)
    m_FileLength = filesize;

    *pbytesWritten = 0;

    if (m_State != Idle) {
        if (!WaitComplete()) {
            return FALSE;
        }
    }

    if (m_State == Invalid) {
        // naughty boy!
        return FALSE;
    }


    // do we need to commit the current contents or read anything ?

    // if there is data, and the start position is not within the valid data
    // range, then flush this lot. note that we count the region from
    // end of valid data to end of actual buffer as valid data if the eof
    // is within this buffer.
    if ((m_DataLength > 0) &&
        ((pos < m_Position) ||
        (pos >= m_Position + m_TotalSize) ||
        ((pos >= m_Position + m_DataLength) &&
         ((m_Position + m_DataLength) < filesize)))) {

            // we're not ok - need to flush current contents
            if (!Commit() || !WaitComplete()) {
                return FALSE;
            }
            m_DataLength = 0;
    }

    // if empty (or we just flushed it), we can start at the beginning
    if (m_DataLength == 0) {
        m_Position = (DWORD) RoundPosToSector(pos);

        // do we need to read the partial sector?
        if ((pos < RoundSizeToSector(filesize))  &&
            (pos % m_BytesPerSector != 0)) {

            // yes - write starts partway through a valid sector
	    m_DataLength = m_BytesPerSector;
            if (!ReadIntoBuffer(0, m_Position, m_BytesPerSector) ||
                !WaitComplete()) {
                    return FALSE;
            }
        }
    }

    // we can start the data. now what about the end?
    // if it all fits within the buffer, and it ends mid-sector and the
    // final sector is within the file length but not currently in the
    // buffer, we will need to pre-read the final buffer

    if ((pos + count) < (m_Position + m_TotalSize)) {

        if ((pos + count) % m_BytesPerSector) {

            // we have to write a partial sector - is it past eof or within
            // valid region ?
            if ((pos+count > m_Position + m_DataLength) &&
                (pos+count < filesize)) {

                    // yes need to read partial sector
                    DWORD sec = (DWORD) RoundPosToSector(pos+count);

		    // need to temporarily set m_DataLength
		    // to the amount read so that WaitComplete can check
		    // its ok
		    m_DataLength = m_BytesPerSector;

                    if (!ReadIntoBuffer(
                        sec - m_Position,       // index in buffer
                        sec,                    // position in file
                        m_BytesPerSector) ||
                        !WaitComplete()) {
                            return FALSE;
                    }
		    // set size correctly again
                    m_DataLength = (sec - m_Position) + m_BytesPerSector;
            }
        }
    }

    // now we can stuff the data in
    int index = pos - m_Position;
    *pbytesWritten = min(count,  m_TotalSize - index);

    CopyMemory(
        &m_pBuffer[index],
        pData,
        *pbytesWritten);

    // adjust data length
    if ((index + *pbytesWritten) > m_DataLength) {
	m_DataLength = (DWORD) RoundSizeToSector(index + *pbytesWritten);
    }

    m_bDirty = TRUE;

    return TRUE;
}




// read data from buffer (will seek and read if necessary first)
BOOL
CFileBuffer::Read(
    DWORD pos,
    LPBYTE pData,
    DWORD count,
    DWORD filelength,
    DWORD * pBytesRead)
{

    Assert(m_State == Idle);

    // remember this for read completion checking
    m_FileLength = filelength;

    *pBytesRead = 0;

    if ((pos < m_Position) ||
        (pos >= m_Position + m_DataLength)) {

        // not in current buffer - flush current contents if dirty
        if (!Commit() || !WaitComplete()) {
            return FALSE;
        }

        m_Position = (DWORD) RoundPosToSector(pos);

        // remember if we round the start down, we also need to increase
        // the length (as well as rounding it up at the other end)
        // force a minimum read size to avoid lots of single sectors
        m_DataLength = count + (pos - m_Position);
        m_DataLength = max(MIN_READ_SIZE, m_DataLength);

        m_DataLength = (DWORD) RoundSizeToSector(m_DataLength);

        m_DataLength = min(m_DataLength, m_TotalSize);

        if (!ReadIntoBuffer(0, m_Position, m_DataLength) ||
	    !WaitComplete()) {
            return FALSE;
        }
    }

    // we have (at least the start part of) the data in the buffer

    int offset = pos - m_Position;
    count = min(count, m_DataLength - offset);
    CopyMemory(pData, &m_pBuffer[offset], count);

    *pBytesRead = count;

    return TRUE;
}


// what is the first file position after this buffer's valid data
// ---return this even if still busy reading it
DWORD
CFileBuffer::GetNextPosition()
{
    if ((m_State == Invalid) || (m_DataLength == 0)) {
        return 0;
    } else {
        return m_Position + m_DataLength;
    }
}

// initiate a read-ahead
void
CFileBuffer::ReadAhead(DWORD start, DWORD filelength)
{
    if (m_State != Idle) {
        if (!CheckComplete()) {
            return;
        }
    }

    // we may already hold this position
    if (QueryPosition(start, filelength)) {
	return;
    }

    m_FileLength = filelength;

    if (m_bDirty) {

        // current data needs to be flushed to disk.
        // we should initiate this, but we can't wait for
        // it to complete, so we won't do the read-ahead
        Commit();
        return;
    }

    m_Position = (DWORD) RoundPosToSector(start);
    m_DataLength = min((DWORD) RoundSizeToSector(filelength - m_Position),
                        m_TotalSize);

    ReadIntoBuffer(0, m_Position, m_DataLength);
    // no wait - this is an async readahead.

}



// initiate the i/o from the buffer
BOOL
CFileBuffer::Commit()
{
    if ((m_State != Idle) || (!m_bDirty)) {
        return TRUE;
    }

#ifndef CHICAGO
    DWORD nrWritten;
#endif

   #ifdef CHICAGO

    m_State = Busy;

    m_qiobuf.dwOffset = m_Position;
    m_qiobuf.lpv = m_pBuffer;
    m_qiobuf.cb = m_DataLength;
    m_qiobuf.cbDone = 0;
    m_qiobuf.bWrite = TRUE;
    m_qiobuf.dwError = ERROR_IO_PENDING;

    QioAdd (m_pqio, &m_qiobuf);

   #else

    ResetEvent(m_Overlapped.hEvent);

    m_State = Busy;

    //start from m_Position
    m_Overlapped.Offset = m_Position;
    m_Overlapped.OffsetHigh = 0;


    if (WriteFile(m_hFile, m_pBuffer, m_DataLength,
            &nrWritten, &m_Overlapped)) {

	DPF(("instant completion"));

        // if it completed already, then sort out the new position
        if (nrWritten != m_DataLength) {
	    DPF("commit- bad length %d not %d", nrWritten, m_DataLength);
            return FALSE;
        }
        m_bDirty = FALSE;
        m_State = Idle;
    } else {
        // should be pending
        if (GetLastError() != ERROR_IO_PENDING) {

	    // no longer busy
	    m_State = Idle;

	    DPF("commit error %d", GetLastError());

            return FALSE;
        }
    }

   #endif

    // we must do this here, since WaitComplete could complete a
    // partial read that would leave the buffer dirty.
    // we are safe since the buffer will remain Busy until this is
    // actually TRUE. (if we fail to write to the disk then the
    // file state is guaranteed messed up).
    m_bDirty = FALSE;

    return TRUE;


}

// wait for any pending commit or read to complete and check for errors.
BOOL
CFileBuffer::WaitComplete()
{
    if (m_State == ErrorOccurred) {

        // the i/o has completed in error but we haven't been able to
        // report the fact yet
        m_State = Idle;
        return FALSE;
    }

    if (m_State == Busy) {
        DWORD actual;

	// no longer busy
        m_State = Idle;

       #ifdef CHICAGO
        if ( ! QioWait (m_pqio, &m_qiobuf, TRUE))
            return FALSE;
        actual = m_qiobuf.cbDone;
       #else
        if (!GetOverlappedResult(m_hFile, &m_Overlapped, &actual, TRUE)) {
	    DPF("WC: GetOverlapped failed %d", GetLastError());
            return FALSE;
        }
       #endif
        if (actual != m_DataLength) {

	    // rounding to sector size may have taken us past eof
	    if (m_Position + actual != m_FileLength) {
		DPF("WC: actual wrong (%d not %d)", actual, m_DataLength);
		return FALSE;
	    }
        }
    }

    return TRUE;

}

// non-blocking check to see if async io is complete
BOOL
CFileBuffer::CheckComplete()
{
    if (m_State == Idle) {
        return TRUE;
    }

    if (m_State != Busy) {
        return FALSE;   // invalid or error
    }

   #ifdef CHICAGO

    if (QioWait(m_pqio, &m_qiobuf, FALSE))
        return FALSE;

    else if (m_qiobuf.dwError == 0) {
        m_State = Idle;
        return TRUE;
        }

    m_State = ErrorOccurred;
    return FALSE;

   #else

    DWORD actual;

    if (GetOverlappedResult(m_hFile, &m_Overlapped, &actual, FALSE)) {

        if ((actual == m_DataLength) ||
            (actual + m_Position == m_FileLength)) {
                m_State = Idle;
                return TRUE;
        }

    } else if (GetLastError() == ERROR_IO_INCOMPLETE) {
        // still busy
        return FALSE;
    }

    // some error state occurred - this must be reported by WaitComplete()
    m_State = ErrorOccurred;
    DPF("CheckComplete error %d", GetLastError());
    return FALSE;

   #endif
}



// initiates an async read request into the buffer (can be an insertion into
// middle of buffer rather than a complete buffer fill - and so will not
// adjust m_Position or m_DataLength). reads count bytes
// offset bytes from the start of the buffer, pos bytes from the start of the
// file. Assumes necessary rounding of length and position has already happened.
BOOL
CFileBuffer::ReadIntoBuffer(int offset, DWORD pos, DWORD count)
{

    Assert(m_State == Idle);

#ifndef CHICAGO
    DWORD nrRead;
#endif

   #ifdef CHICAGO

    m_State = Busy;

    m_qiobuf.dwOffset = pos;
    m_qiobuf.lpv = (LPVOID)(m_pBuffer + offset);
    m_qiobuf.cb = count;
    m_qiobuf.cbDone = 0;
    m_qiobuf.bWrite = FALSE;
    m_qiobuf.dwError = ERROR_IO_PENDING;

    // if this read is not sector aligned, we cannot do it
    // in async in chicago, so do it right now!
    //
    if ((count & 511) || (pos & 511) || (offset & 511))
    {
        DWORD dwOff;

        m_qiobuf.bPending = FALSE;

	DPF("%s %X bytes (non-aligned) at %08X into %08X\r\n", m_qiobuf.bWrite ? "Writing" : "Reading", m_qiobuf.cb, m_qiobuf.dwOffset, m_qiobuf.lpv);
	
        dwOff = SetFilePointer (m_pqio->hFile, m_qiobuf.dwOffset, NULL, FILE_BEGIN);
        if (dwOff != m_qiobuf.dwOffset)
        {
            m_qiobuf.dwError = GetLastError();
	    DPF("avifile32 non-aligned seek error %d", m_qiobuf.dwError);
            return FALSE;
        }
        else if ( ! ReadFile (m_pqio->hFile, m_qiobuf.lpv, m_qiobuf.cb,
                              &m_qiobuf.cbDone, NULL) ||
                  (m_qiobuf.cbDone != m_qiobuf.cb))
        {
            m_qiobuf.dwError = GetLastError ();
	    DPF("avifile32 non-aligned read error %d", m_qiobuf.dwError);
            return FALSE;
        }
        m_State = Idle;
    }
    else
       return QioAdd (m_pqio, &m_qiobuf);

   #else

    ResetEvent(m_Overlapped.hEvent);

    m_State = Busy;


    //start from pos
    m_Overlapped.Offset = pos;
    m_Overlapped.OffsetHigh = 0;


    if (ReadFile(m_hFile, &m_pBuffer[offset], count,
            &nrRead, &m_Overlapped)) {

        m_State = Idle;

	DPF(("instant completion"));

        // if it completed already, then sort out the new position
        if (nrRead != count) {

	    // rounding to sector size may have taken us past eof -
	    // in this case we must still ask for the full sector, but
	    // we will be told about the actual size
	    if (m_Position + nrRead != m_FileLength) {
		DPF("ReadInto: actual wrong");
		return FALSE;
	    }
        }
    } else {
        // should be pending
        if (GetLastError() != ERROR_IO_PENDING) {
            DPF("read failed %d\n", GetLastError());

	    // no longer busy
	    m_State = Idle;
	    DPF("ReadInto failed %d", GetLastError());
            return FALSE;
        }
    }
   #endif
    return TRUE;
}


#endif // USE_DIRECTIO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\editstrm.h ===
DEFINE_AVIGUID(CLSID_EditStream,        0x0002000A, 0, 0);

struct FAR ICEditStreamInternal : public IUnknown
{
    STDMETHOD(GetInternalPointer)(LPVOID FAR * ppInternal) = 0;
};

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

typedef struct {
    PAVISTREAM	    pavi;
    LONG	    lStart;
    LONG	    lLength;
    LONG	    unused;	// pad to power of two in size....
    RECT	    rcSource;
    RECT	    rcDest;
} EDIT, FAR * LPEDIT;

class FAR CEditStream : public virtual IAVIStream,
			public virtual IAVIEditStream,
			public virtual ICEditStreamInternal
		       
#ifdef CUSTOMMARSHAL
			, public virtual IMarshal
#endif
{
public:
    static CEditStream FAR * NewEditStream(PAVISTREAM psSource);
    
    STDMETHODIMP QueryInterface(const IID FAR& riid, void FAR* FAR* ppv);	\
    STDMETHODIMP_(ULONG) AddRef();	\
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP Create      (THIS_ LPARAM lParam1, LPARAM lParam2);
    STDMETHODIMP Info        (THIS_ AVISTREAMINFOW FAR * psi, LONG lSize);
    STDMETHODIMP_(LONG)  FindSample (THIS_ LONG lPos, LONG lFlags);
    STDMETHODIMP ReadFormat  (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG FAR *cbFormat);
    STDMETHODIMP SetFormat   (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG cbFormat);
    STDMETHODIMP Read        (THIS_ LONG lStart, LONG lSamples,
			    LPVOID lpBuffer, LONG cbBuffer,
			    LONG FAR * plBytes, LONG FAR * plSamples);
    STDMETHODIMP Write       (THIS_ LONG lStart, LONG lSamples,
			      LPVOID lpBuffer, LONG cbBuffer,
			      DWORD dwFlags,
			      LONG FAR *plSampWritten,
			      LONG FAR *plBytesWritten);
    STDMETHODIMP Delete      (THIS_ LONG lStart, LONG lSamples);
    STDMETHODIMP ReadData    (THIS_ DWORD fcc, LPVOID lp, LONG FAR *lpcb);
    STDMETHODIMP WriteData   (THIS_ DWORD fcc, LPVOID lp, LONG cb);
    STDMETHODIMP Reserved1            (THIS);
    STDMETHODIMP Reserved2            (THIS);
    STDMETHODIMP Reserved3            (THIS);
    STDMETHODIMP Reserved4            (THIS);
    STDMETHODIMP Reserved5            (THIS);

    STDMETHODIMP Cut(LONG FAR *plStart, LONG FAR *plLength, PAVISTREAM FAR * ppResult);
    STDMETHODIMP Copy(LONG FAR *plStart, LONG FAR *plLength, PAVISTREAM FAR * ppResult);
    STDMETHODIMP Paste(LONG FAR *plPos, LONG FAR *plLength, PAVISTREAM pstream, LONG lStart, LONG lLength);
    STDMETHODIMP Clone(PAVISTREAM FAR *ppResult);
    STDMETHODIMP SetInfo(AVISTREAMINFOW FAR *lpInfo, LONG cbInfo);
    
    static HRESULT NewInstance(IUnknown FAR* pUnknownOuter,
			       REFIID riid,
			       LPVOID FAR* ppv);

    STDMETHODIMP GetInternalPointer(LPVOID FAR * ppv);
#ifdef CUSTOMMARSHAL
    // *** IMarshal methods ***
    BOOL CanMarshalSimply();

    STDMETHODIMP GetUnmarshalClass (THIS_ REFIID riid, LPVOID pv, 
			DWORD dwDestContext, LPVOID pvDestContext,
			DWORD mshlflags, LPCLSID pCid);
    STDMETHODIMP GetMarshalSizeMax (THIS_ REFIID riid, LPVOID pv, 
			DWORD dwDestContext, LPVOID pvDestContext,
			DWORD mshlflags, LPDWORD pSize);
    STDMETHODIMP MarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
			LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
			DWORD mshlflags);
    STDMETHODIMP UnmarshalInterface (THIS_ LPSTREAM pStm, REFIID riid,
			LPVOID FAR* ppv);
    STDMETHODIMP ReleaseMarshalData (THIS_ LPSTREAM pStm);
    STDMETHODIMP DisconnectObject (THIS_ DWORD dwReserved);
#endif	// CUSTOMMARSHAL
    
private:
    CEditStream() {
	cedits = 0;
	maxedits = 0;
	edits = NULL;
	pgf = NULL;
	psgf = NULL;
	fFullFrames = FALSE;
    };
    
    HRESULT ResolveEdits(LONG lPos,
		  PAVISTREAM FAR *ppavi, LONG FAR *plPos,
		  LONG FAR *pl, BOOL fAllowEnd);
    HRESULT PossiblyRemoveEdit(LONG l);
    HRESULT AllocEditSpace(LONG l, LONG cNew);
    LPBITMAPINFOHEADER NEAR PASCAL CEditStream::CallGetFrame(
						      PAVISTREAM p,
						      LONG l);
    void CheckEditList();
    
public:
    ULONG			ulRefCount;
    //
    // instance data
    //
    AVISTREAMINFOW		sinfo;    
    LONG    			cedits;
    LONG    			maxedits;
    BOOL			fFullFrames;
    EDIT _huge *		edits;

    //
    // cached PGETFRAME
    PGETFRAME			pgf;
    PAVISTREAM			psgf;
    LPBITMAPINFOHEADER		lpbiLast;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\enumfetc.h ===
/*************************************************************************
**
**    OLE 2 Utility Code
**
**    enumfetc.c
**
**    Private definitions, structures, types, and function prototypes for the
**    CEnumFormatEtc implementation of the IEnumFORMATETC interface.
**    This file is part of the OLE 2.0 User Interface support library.
**
**    (c) Copyright Microsoft Corp. 1990 - 1995. All Rights Reserved
**
*************************************************************************/

#ifndef __ENUMFETC_H__
#define __ENUMFETC_H__

#ifndef RC_INVOKED
#pragma message ("INCLUDING ENUMFETC.H from " __FILE__)
#endif  /* RC_INVOKED */


STDAPI_(LPENUMFORMATETC)
  OleStdEnumFmtEtc_Create(WORD wCount, LPFORMATETC lpEtc);

#endif // __ENUMFETC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\editstrm.cpp ===
/****************************************************************************
 *
 *  EDITSTRM.C
 *
 *  routines for reading Standard AVI files
 *
 *  Copyright (c) 1992  - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>
#include <vfw.h>
#ifndef DAYTONA
// The NT storage.h header file is a noop
#include <storage.h>
#endif
#include "editstrm.h"

#include <stdlib.h>

#if !defined NUMELMS
 #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

#ifdef DEBUG
    static void CDECL dprintf(LPSTR, ...);
    #define DPF dprintf
#else
    #define DPF ; / ## /
#endif

/*
 * memcopy.asm
 */
#ifdef _WIN32
#define MemCopy(dst, src, cnt) memmove(dst,src,cnt)
#else
EXTERN_C LONG FAR PASCAL MemCopy(HPSTR, HPSTR, DWORD);
#endif

extern "C" {
extern LPTSTR FAR lstrzcpy (LPTSTR pszTgt, LPCTSTR pszSrc, size_t cch);
extern LPSTR FAR lstrzcpyA (LPSTR pszTgt, LPCSTR pszSrc, size_t cch);
extern LPWSTR FAR lstrzcpyW (LPWSTR pszTgt, LPCWSTR pszSrc, size_t cch);
extern LPWSTR FAR lstrzcpyAtoW (LPWSTR pszTgt, LPCSTR pszSrc, size_t cch);
extern LPSTR FAR lstrzcpyWtoA (LPSTR pszTgt, LPCWSTR pszSrc, size_t cch);
} // extern "C"



STDAPI EditStreamCut(PAVISTREAM pavi, LONG FAR *plStart, LONG FAR *plLength, PAVISTREAM FAR * ppResult)
{
    PAVIEDITSTREAM  pedit = NULL;
    HRESULT	    hr;

    pavi->QueryInterface(IID_IAVIEditStream, (LPVOID FAR *) &pedit);
    if (!pedit)
	return ResultFromScode(E_NOINTERFACE);

    hr = pedit->Cut(plStart, plLength, ppResult);

    pedit->Release();

    return hr;
}

STDAPI EditStreamCopy(PAVISTREAM pavi, LONG FAR *plStart, LONG FAR *plLength, PAVISTREAM FAR * ppResult)
{
    PAVIEDITSTREAM  pedit = NULL;
    HRESULT	    hr;

    pavi->QueryInterface(IID_IAVIEditStream, (LPVOID FAR *) &pedit);
    if (!pedit)
	return ResultFromScode(E_NOINTERFACE);

    hr = pedit->Copy(plStart, plLength, ppResult);

    pedit->Release();

    return hr;
}

STDAPI EditStreamPaste(PAVISTREAM pavi, LONG FAR *plPos, LONG FAR *plLength, PAVISTREAM pstream, LONG lStart, LONG lLength)
{
    PAVIEDITSTREAM  pedit = NULL;
    HRESULT	    hr;

    pavi->QueryInterface(IID_IAVIEditStream, (LPVOID FAR *) &pedit);
    if (!pedit)
	return ResultFromScode(E_NOINTERFACE);

    hr = pedit->Paste(plPos, plLength, pstream, lStart, lLength);

    pedit->Release();

    return hr;
}

STDAPI EditStreamClone(PAVISTREAM pavi, PAVISTREAM FAR *ppResult)
{
    PAVIEDITSTREAM  pedit = NULL;
    HRESULT	    hr;

    pavi->QueryInterface(IID_IAVIEditStream, (LPVOID FAR *) &pedit);
    if (!pedit)
	return ResultFromScode(E_NOINTERFACE);

    hr = pedit->Clone(ppResult);

    pedit->Release();

    return hr;
}

STDAPI EditStreamSetInfoW(PAVISTREAM pavi, AVISTREAMINFOW FAR *lpInfo, LONG cbInfo)
{
    PAVIEDITSTREAM  pedit = NULL;
    HRESULT	    hr;

    pavi->QueryInterface(IID_IAVIEditStream, (LPVOID FAR *) &pedit);
    if (!pedit)
	return ResultFromScode(E_NOINTERFACE);

    hr = pedit->SetInfo(lpInfo, cbInfo);

    pedit->Release();

    return hr;
}

#ifdef _WIN32
// Ansi thunk for EditStreamSetInfo
STDAPI EditStreamSetInfoA(
    PAVISTREAM pavi,
    LPAVISTREAMINFOA lpInfo,
    LONG cbInfo
)
{
    AVISTREAMINFOW siW;

    if (cbInfo < sizeof(AVISTREAMINFOA)) {
	return ResultFromScode(AVIERR_BADSIZE);
    }

    // copy non-char fields
    siW.fccType		       = lpInfo->fccType;
    siW.fccHandler             = lpInfo->fccHandler;
    siW.dwFlags                = lpInfo->dwFlags;
    siW.dwCaps                 = lpInfo->dwCaps;
    siW.wPriority              = lpInfo->wPriority;
    siW.wLanguage              = lpInfo->wLanguage;
    siW.dwScale                = lpInfo->dwScale;
    siW.dwRate                 = lpInfo->dwRate;
    siW.dwStart                = lpInfo->dwStart;
    siW.dwLength               = lpInfo->dwLength;
    siW.dwInitialFrames        = lpInfo->dwInitialFrames;
    siW.dwSuggestedBufferSize  = lpInfo->dwSuggestedBufferSize;
    siW.dwQuality              = lpInfo->dwQuality;
    siW.dwSampleSize           = lpInfo->dwSampleSize;
    siW.rcFrame                = lpInfo->rcFrame;
    siW.dwEditCount            = lpInfo->dwEditCount;
    siW.dwFormatChangeCount    = lpInfo->dwFormatChangeCount;

    // convert the name
    MultiByteToWideChar(CP_ACP, 0, lpInfo->szName, -1, siW.szName, NUMELMS(siW.szName));

    return EditStreamSetInfoW(pavi, &siW, sizeof(siW));
}
#endif

STDAPI EditStreamSetNameW(PAVISTREAM pavi, LPCWSTR lpszName)
{
    PAVIEDITSTREAM  pedit = NULL;
    HRESULT	    hr;
    AVISTREAMINFOW   info;

    pavi->QueryInterface(IID_IAVIEditStream, (LPVOID FAR *) &pedit);
    if (!pedit)
	return ResultFromScode(E_NOINTERFACE);

    pavi->Info(&info, sizeof(info));
    lstrzcpyW(info.szName, lpszName, sizeof(info.szName)/sizeof(WCHAR));
    hr = pedit->SetInfo(&info, sizeof(info));

    pedit->Release();

    return hr;
}

#ifdef _WIN32
// ansi version of above function
STDAPI EditStreamSetNameA(PAVISTREAM pavi, LPCSTR lpszName)
{
    PAVIEDITSTREAM  pedit = NULL;
    HRESULT	    hr;
    AVISTREAMINFOW  info;

    pavi->QueryInterface(IID_IAVIEditStream, (LPVOID FAR *) &pedit);
    if (!pedit)
	return ResultFromScode(E_NOINTERFACE);

    pavi->Info(&info, sizeof(info));

    // convert the name
    lstrzcpyAtoW (info.szName, lpszName, NUMELMS(info.szName));

    hr = pedit->SetInfo(&info, sizeof(info));

    pedit->Release();

    return hr;
}
#endif

// #define EDITCHECK

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

#define USUAL_ALLOC	16
#define EXTRA_ALLOC	8
HRESULT CEditStream::AllocEditSpace(LONG l, LONG cNew)
{
    LPEDIT  p;
    LONG    size;

    if (cedits + cNew > maxedits) {
	size = maxedits + max(cNew + EXTRA_ALLOC, USUAL_ALLOC);

	p = (LPEDIT) GlobalReAllocPtr(edits, size * sizeof(EDIT), GHND | GMEM_SHARE);

	if (!p)
	    return ResultFromScode(AVIERR_MEMORY);

	edits = p;
	maxedits = size;
    }

    if (l < cedits)
	MemCopy((HPSTR) &edits[l + cNew],
		(HPSTR) &edits[l],
		(cedits - l) * sizeof(EDIT));

    cedits += cNew;

    return AVIERR_OK;
}

HRESULT CEditStream::PossiblyRemoveEdit(LONG l)
{
    if (edits[l].lLength > 0)
	return AVIERR_OK;

    if (edits[l].pavi)
	AVIStreamRelease(edits[l].pavi);

    --cedits;

    if (l < cedits)
	MemCopy((HPSTR) &edits[l],
		(HPSTR) &edits[l + 1],
		(cedits - l) * sizeof(EDIT));

    return AVIERR_OK;
}

CEditStream FAR * CEditStream::NewEditStream(PAVISTREAM psSource)
{
    CEditStream FAR * pedit;

    pedit = new CEditStream;

    if (pedit)
	(pedit->Create)((LPARAM) psSource, 0);
    // !!! error check

    return pedit;
}

STDAPI CreateEditableStream(
		PAVISTREAM FAR *	    ppsEditable,
		PAVISTREAM		    psSource)
{
    // First, check if the stream is already editable....

    if (psSource) {
	PAVIEDITSTREAM	paviedit = NULL;

	psSource->QueryInterface(IID_IAVIEditStream, (LPVOID FAR *) &paviedit);

	if (paviedit) {
	    paviedit->Clone(ppsEditable);
	    paviedit->Release();
	    return AVIERR_OK;
	}
    }

    *ppsEditable = (PAVISTREAM) CEditStream::NewEditStream(psSource);

    if (!*ppsEditable)
	return ResultFromScode(AVIERR_MEMORY);

    return AVIERR_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//  EditStreamOpen()
//
//  open a single stream of a particular type from a AVI file.
//
//  params:
//      szFile      - AVI file name
//      fccType     - stream type 0 for any type
//      iStream     - zero based stream number
//
//  returns:
//      a PAVISTREAM for the specifed stream or NULL.
//
//  example:
//
//      EditStreamOpen(pavi, "Foo.avi", 0, 0)
//
//          will open stream 0 (the first stream)
//
//      EditStreamOpen(pavi, "Foo.avi", 1)
//
//          will open stream 1
//
//      EditStreamOpenStream(pavi, "Foo.avi", 'vids', 0)
//
//          will open the first video stream
//
//      AVIOpenStream(pavi, "Foo.avi", 'auds', 0)
//
//          will open the first audio stream
//
///////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CEditStream::Create(LPARAM lParam1, LPARAM lParam2)
{
    this->edits = (LPEDIT) GlobalAllocPtr(GHND | GMEM_SHARE, USUAL_ALLOC * sizeof(EDIT));
    if (this->edits == NULL)
	return ResultFromScode(AVIERR_MEMORY);

    this->maxedits = USUAL_ALLOC;
    this->ulRefCount = 1;

    this->pgf = NULL;
    this->psgf = NULL;
    this->lpbiLast = NULL;
    this->fFullFrames = FALSE;
    this->edits[0].pavi = (PAVISTREAM)lParam1;
    _fmemset(&this->sinfo, 0, sizeof(this->sinfo));
    this->cedits = 1;
    if (this->edits[0].pavi) {
	AVIStreamAddRef(this->edits[0].pavi);
	this->edits[0].lStart = AVIStreamStart(this->edits[0].pavi);
	this->edits[0].lLength = AVIStreamLength(this->edits[0].pavi);

	AVIStreamInfoW(this->edits[0].pavi, &this->sinfo, sizeof(this->sinfo));
	
	CheckEditList();
    } else {
	this->edits[0].lStart = 0;
	this->edits[0].lLength = 0;
    }

    DPF("Edit   %p: Usage++=%lx\n", (DWORD_PTR) (LPVOID) this, 1L);

    //
    // all done return success.
    //
    return 0; // success
}

///////////////////////////////////////////////////////////////////////////
//
//  EditStreamAddRef()
//
//      increase the reference count of the stream
//
///////////////////////////////////////////////////////////////////////////

ULONG STDMETHODCALLTYPE CEditStream::AddRef()
{
    DPF("Edit   %p: Usage++=%lx\n", (DWORD_PTR) (LPVOID) this, this->ulRefCount + 1);

    return ++this->ulRefCount;
}

///////////////////////////////////////////////////////////////////////////
//
//  EditStreamRelease()
//
//      close a EditStream stream
//
///////////////////////////////////////////////////////////////////////////

ULONG STDMETHODCALLTYPE CEditStream::Release()
{
    LONG	l;

    DPF("Edit   %p: Usage--=%lx\n", (DWORD_PTR) (LPVOID) this, this->ulRefCount - 1);
    if (--this->ulRefCount)
	return this->ulRefCount;

    // free edits....
    for (l = 0; l < this->cedits; l++) {
	if (this->edits[l].pavi)
	    AVIStreamRelease(this->edits[l].pavi);
    }

    GlobalFreePtr(this->edits);

    this->edits = 0;

    if (this->pgf)
	AVIStreamGetFrameClose(this->pgf);

    delete this;

    return 0;
}

LPBITMAPINFOHEADER NEAR PASCAL CEditStream::CallGetFrame(
						      PAVISTREAM p,
						      LONG l)
{
    if (psgf != p) {
	PGETFRAME   pgfNew;
	
	pgfNew = AVIStreamGetFrameOpen(p, NULL);
	
	if (!pgfNew)
	    return NULL;

	if (pgf) {
#ifdef DEBUG
	    DPF("Trying to SetFormat %dx%dx%d '%4.4s'\n",
	    	    (int)lpbiLast->biWidth,
		    (int)lpbiLast->biHeight,
		    (int)lpbiLast->biBitCount,
		    (lpbiLast->biCompression == BI_RGB  ? (LPSTR)"None" :
		    lpbiLast->biCompression == BI_RLE8 ? (LPSTR)"Rle8" :
			lpbiLast->biCompression == BI_RLE4 ? (LPSTR)"Rle4" :
			    (LPSTR)&lpbiLast->biCompression));
#endif	

            if (pgfNew->SetFormat(lpbiLast, NULL, 0, 0, -1, -1) != AVIERR_OK) {
		DPF("Couldn't AVIStreamGetFrameSetFormat!\n");
		AVIStreamGetFrameClose(pgfNew);
		return NULL;
	    }
		
	    AVIStreamGetFrameClose(pgf);
	}

	pgf = pgfNew;
	psgf = p;

    }

    lpbiLast = (LPBITMAPINFOHEADER) AVIStreamGetFrame(pgf, l);

    if (lpbiLast)
	sinfo.dwSuggestedBufferSize = lpbiLast->biSizeImage;

#ifdef DEBUG
    DPF("EditStream: using %dx%dx%d '%4.4hs'\n",
	    (int)lpbiLast->biWidth,
	    (int)lpbiLast->biHeight,
	    (int)lpbiLast->biBitCount,
	    (lpbiLast->biCompression == BI_RGB ? (LPSTR)"None" :
		 (lpbiLast->biCompression == BI_RLE8 ? (LPSTR)"Rle8" :
		      (lpbiLast->biCompression == BI_RLE4 ? (LPSTR)"Rle4" :
			   (LPSTR)&lpbiLast->biCompression))));
#endif

    return lpbiLast;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CEditStream::ReadFormat(LONG lPos, LPVOID lpFormat, LONG FAR *lpcbFormat)
{
    PAVISTREAM	p;
    LONG	l;
    HRESULT	hr;

    if ((lPos < (LONG) sinfo.dwStart) ||
		(lPos >= (LONG) (sinfo.dwStart + sinfo.dwLength))) {
	return ResultFromScode(AVIERR_BADPARAM);
    }
	
    hr = ResolveEdits(lPos, &p, &l, NULL, FALSE);

    if (hr != 0) {
	DPF("ReadFormat: ResolveEdits failed!\n");
	return hr;
    }

    if (fFullFrames) {
	LPBITMAPINFOHEADER  lpbi;
	LONG		    lSize;

	// This isn't really right: we really need to make the formats
	// agree.  Should we just get the format from the first frame?
	
	lpbi = CallGetFrame(p, l);

	if (!lpbi) {
	    DPF("ReadFormat: GetFrame failed!\n");
	    return ResultFromScode(E_FAIL);
	}

	lSize = lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);

	if (lpFormat)
	    hmemcpy(lpFormat, lpbi, min(*lpcbFormat, lSize));

	*lpcbFormat = lSize;
	return 0;
    } else {
	return AVIStreamReadFormat(p, l, lpFormat, lpcbFormat);
    }
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CEditStream::Info(AVISTREAMINFOW FAR * psi, LONG lSize)
{

    if (psi)
	hmemcpy(psi, &sinfo, min(lSize, sizeof(sinfo)));
    return 0; // !!! sizeof(pavi->sinfo);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

LONG STDMETHODCALLTYPE CEditStream::FindSample(LONG lPos, LONG lFlags)
{
    PAVISTREAM	p;
    LONG	l;
    LONG	edit;
    LONG	lRet;
    HRESULT	hr;

#ifdef _WIN32
    if (!lPos && (lFlags & FIND_FROM_START)) {
	lPos = sinfo.dwStart;
    } else
#endif
    if ((lPos < (LONG) sinfo.dwStart) ||
		(lPos >= (LONG) (sinfo.dwStart + sinfo.dwLength))) {
	return -1;
    }
	
    hr = ResolveEdits(lPos, &p, &l, &edit, TRUE);

    if (hr != 0) {
	DPF("FindSample: error from ResolveEdits!\n");
	return -1;
    }

    if (lFlags & FIND_FORMAT) {
	// !!!!  This isn't right, obviously.
	if (lFlags & FIND_PREV)
	    return 0;
	else
	    return -1;
    }

    if (this->fFullFrames) {
	return lPos;
    }

    // !!! This won't really work, especially for searching forward.
    lRet = AVIStreamFindSample(p, l, lFlags);

#ifdef DEBUG
    if (lRet < edits[edit].lStart) {
	DPF("We were about to return a key frame before a segment: returning %ld instead of %ld.\n", edits[edit].lStart, lRet);
    }
#endif

    // DPF("FindSample: lPos = %ld, Key = %ld\n", lPos, lPos - (l - lRet));
    return lPos - (l - lRet);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CEditStream::Read(
                 LONG       lStart,
                 LONG       lSamples,
                 LPVOID     lpBuffer,
                 LONG       cbBuffer,
                 LONG FAR * plBytes,
                 LONG FAR * plSamples)
{
    PAVISTREAM	p;
    LONG	l;
    LONG	edit;
    LONG	lSamplesRead;
    LONG	lBytesRead;
    LONG	lSamplesThisTime;
    HRESULT	hr;

    if (plBytes)
	*plBytes = 0;
    if (plSamples)
	*plSamples = 0;

#ifdef TOOMUCHDEBUG
    if (lpBuffer) {
	DPF("Read %p: Start = %ld Length = %ld\n", (DWORD_PTR) (LPVOID) this, lStart, lSamples);
    }
#endif

    if ((lStart < (LONG) sinfo.dwStart) ||
		(lStart >= (LONG) (sinfo.dwStart + sinfo.dwLength))) {
	DPF("Read at position %ld, start = %lu, len = %lu\n", lStart, sinfo.dwStart, sinfo.dwStart + sinfo.dwLength);
	
	return ResultFromScode(AVIERR_BADPARAM);
    }
	
    while (lSamples) {
	hr = ResolveEdits(lStart, &p, &l, &edit, FALSE);

	if (hr != 0) {
	    DPF("Read: ResolveEdits failed!\n");
	    return ResultFromScode(E_FAIL);
	}
	
	// Don't read past the end of this edit.
	if ((l - this->edits[edit].lStart) + lSamples > this->edits[edit].lLength)
	    lSamplesThisTime = this->edits[edit].lLength - (l - this->edits[edit].lStart);
	else
	    lSamplesThisTime = lSamples;


	if (this->fFullFrames) {
	    LPBITMAPINFOHEADER  lpbi;
	    LPVOID		    lp;

	    lpbi = CallGetFrame(p, l);

	    if (!lpbi) {
		DPF("Read: GetFrame failed!\n");
		return ResultFromScode(E_FAIL);
	    }

	    //
	    // a NULL buffer means return the size buffer needed to read
	    // the given sample.
	    //
	    if (lpBuffer == NULL)
		goto exit;

	    lp = (LPBYTE) lpbi + lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);

	    if (cbBuffer >= (LONG) lpbi->biSizeImage) {
		hmemcpy(lpBuffer, lp, lpbi->biSizeImage);
    exit:
		if (plBytes)
		    *plBytes = lpbi->biSizeImage;

		if (plSamples)
		    *plSamples = 1;

		return 0;
	    }
	    if (plBytes)
		*plBytes = 0;

	    if (plSamples)
		*plSamples = 0;

	    return ResultFromScode(AVIERR_BUFFERTOOSMALL);
	} else {
	    hr = AVIStreamRead(p, l, lSamplesThisTime, lpBuffer, cbBuffer,
			       &lBytesRead, &lSamplesRead);

	    if (hr != NOERROR)
		return hr;
	
	    if (plBytes)
		*plBytes += lBytesRead;
	    if (plSamples)
		*plSamples += lSamplesRead;

	    if (lpBuffer) {
	        lpBuffer = (BYTE _huge *) lpBuffer + lBytesRead;
	        cbBuffer -= lBytesRead;
	    }
	    lStart += lSamplesThisTime;
	    lSamples -= lSamplesThisTime;

	    // If we've read up to the end of the file,
	    // stop now, rather than return an error....
	    if (lStart >= (LONG) (this->sinfo.dwLength + this->sinfo.dwStart))
		break;
	}
    }

#ifdef TOOMUCHDEBUG
    if (lpBuffer && plBytes) {
	DPF("Read %p:  Bytes Read = %ld\n", (DWORD_PTR) (LPVOID) this, *plBytes);
    }
#endif

    return 0;
}

void CEditStream::CheckEditList()
{
#ifdef EDITCHECK
    LONG    lTotal = 0;
    LONG    l;

    DPF("Edit list %p: %s\n", (DWORD_PTR) this, fFullFrames ? (LPSTR) " (Using full frames)" : (LPSTR) "");

    for (l = 0; l < cedits; l++) {
	DPF("\t\t%ld:\t%p\t%ld\t%ld\n", l, (DWORD_PTR) (LPVOID) edits[l].pavi, edits[l].lStart, edits[l].lLength);
	lTotal += edits[l].lLength;
    }

    if (lTotal != (LONG) sinfo.dwLength) {
	DPF("Total is %ld, should be %lu!!!!!\n", lTotal, sinfo.dwLength);
	// * (LPSTR) 0 = 0;
    }
#endif
}

HRESULT CEditStream::ResolveEdits(LONG lPos, PAVISTREAM FAR *ppavi,
		  LONG FAR *plPos, LONG FAR *pl, BOOL fAllowEnd)
{
    LONG    edit;

    //
    // Search edit list, get position...
    //

    if (lPos < (LONG) this->sinfo.dwStart) {
	DPF("ResolveEdits: Read at %ld, before start at %ld\n", lPos, this->sinfo.dwStart);
	return ResultFromScode(AVIERR_BADPARAM);
    }

    lPos -= (LONG) this->sinfo.dwStart;

    for (edit = 0; edit < this->cedits; edit++) {
	if (lPos < this->edits[edit].lLength) {
	    *ppavi = this->edits[edit].pavi;
	    *plPos = lPos + this->edits[edit].lStart;
	    if (pl)
		*pl = edit;
	    return 0;
	}

	lPos -= this->edits[edit].lLength;
    }

    // Normally, we don't return a position at the end of an edit--we instead
    // go to the next thing.
    if (lPos == 0 && fAllowEnd) {
	edit--;
	*ppavi = this->edits[edit].pavi;
	*plPos = this->edits[edit].lStart + this->edits[edit].lLength;
	if (pl)
	    *pl = edit;
	return 0;
    }

    *ppavi = 0;
    *plPos = 0;
    if (pl)
	*pl = 0;

    return ResultFromScode(AVIERR_BADPARAM);
}

//
// Cut:
//
// Takes start, length to cut out
//
// returns actual start, length cut, along with new stream
//
STDMETHODIMP CEditStream::Cut(LONG FAR *plStart, LONG FAR *plLength, PAVISTREAM FAR * ppResult)
{
    HRESULT	hr = AVIERR_OK;
    PAVISTREAM	p;
    LONG	l;
    LONG		edit;
    LONG	lStart, lLength;

    l = AVIStreamLength(this);

    if (ppResult)
	*ppResult = 0;

    if (!plStart || !plLength) {
	return ResultFromScode(AVIERR_BADPARAM);
    }

    if (*plStart < 0) {
	return ResultFromScode(AVIERR_BADPARAM);
    }

    if (*plLength < 0 || *plStart + *plLength > l) {
	if (*plStart >= l)
	    return ResultFromScode(AVIERR_BADPARAM);
	*plLength = l - *plStart;
    }

#ifdef KEYALWAYS
    // Make cut end at key frame
    for (l = *plStart + *plLength; l < AVIStreamLength(this); l++) {
	if (AVIStreamFindSample(this, l, 0) == l)
	    break;
    }
    *plLength = l - *plStart;
#else
    // we cut whatever they ask us to....
#endif

    // Make a copy of the section being cut out
    if (ppResult) {
	// This will make cut start at key frame if it needs to
	hr = this->Copy(plStart, plLength, ppResult);

	if (hr != AVIERR_OK)
	    return hr;
    }

    lLength = *plLength;
    lStart = *plStart;

#ifndef KEYALWAYS
    if (!this->fFullFrames &&
	lStart + lLength < AVIStreamLength(this) &&
	AVIStreamFindSample(this, lStart + lLength, 0) != lStart + lLength) {
	DPF("Cut: Converting stream to full frames\n");
	this->fFullFrames = TRUE;
	this->sinfo.dwFormatChangeCount++;
	this->sinfo.fccHandler = 0;
    }
#endif

    // Now do the actual cut
    hr = ResolveEdits(lStart, &p, &l, &edit, FALSE);

    if (hr != NOERROR)
	return hr;

    if (this->edits[edit].lStart + this->edits[edit].lLength > l + lLength) {
	// The part cut out is entirely within this edit.
	if (this->edits[edit].lStart == l) {
	    // The part cut out is the start of this edit
	    this->edits[edit].lStart = l + lLength;
	    this->edits[edit].lLength -= lLength;
	} else {
	    hr = AllocEditSpace(edit, 1);

	    if (hr == AVIERR_OK) {
		this->edits[edit] = this->edits[edit+1];
		if (this->edits[edit].pavi)
		    AVIStreamAddRef(this->edits[edit].pavi);
		this->edits[edit].lStart = this->edits[edit+1].lStart;
		this->edits[edit].lLength = l - this->edits[edit].lStart;
		this->edits[edit+1].lStart = l + lLength;
		this->edits[edit+1].lLength -= lLength +
					       this->edits[edit].lLength;
	    }
	}
    } else if (this->edits[edit].lStart + this->edits[edit].lLength == l + lLength) {
	// The part cut out is the end of this edit
	this->edits[edit].lLength = l - this->edits[edit].lStart;
    } else {
	LONG lTemp = lLength;
	LONG lRemovedEdits = 0;
	
	// We're cutting out more than this one edit.
	// First, cut out the rest of this edit.
	lTemp -= this->edits[edit].lStart + this->edits[edit].lLength - l;
	this->edits[edit].lLength = l - this->edits[edit].lStart;

	if (this->edits[edit].lLength == 0) {
	    AVIStreamRelease(this->edits[edit].pavi);
	    lRemovedEdits++;
	}
	edit++;

	// As long as subsequent edits are still shorter than the cut,
	// kill them..
	while (edit < this->cedits &&
	       this->edits[edit].lLength <= lTemp) {
	    lTemp -= this->edits[edit].lLength;
	    AVIStreamRelease(this->edits[edit].pavi);
	    edit++;
	    lRemovedEdits++;
	}

	if (edit < this->cedits) {
	    this->edits[edit].lStart += lTemp;
	    this->edits[edit].lLength -= lTemp;

	    // copy edits after the cut up in the list....
	    MemCopy((HPSTR) &edits[edit - lRemovedEdits],
		    (HPSTR) &edits[edit],
		    (this->cedits - edit) * sizeof(EDIT));
	}

	this->cedits -= lRemovedEdits;
    }

    if (hr == AVIERR_OK) {
	this->sinfo.dwLength -= lLength;
	this->sinfo.dwEditCount++;

	CheckEditList();
    } else {
	if (ppResult)
	    AVIStreamRelease(*ppResult);
    }
    return hr;
}

//
// Copy:
//
// Takes start, length to cut out
//
// returns actual start, length cut, along with new stream
//
//

STDMETHODIMP CEditStream::Copy(LONG FAR *plStart, LONG FAR *plLength, PAVISTREAM FAR * ppResult)
{
    PAVISTREAM	p1;
    LONG	l1;
    LONG	edit1;
    PAVISTREAM	p2;
    LONG	l2;
    LONG	edit2;
    LONG	l;
    CEditStream FAR *p;
    HRESULT	hr;
    LONG	lStart, lLength;

    l1 = AVIStreamLength(this);

    // If start, length < 0, pick some defaults
    if (*plStart < 0)
	*plStart = 0;

    if (*plLength < 0)
	*plLength = l1 - *plStart;

    // Make sure the start position is within range
    if (*plStart > l1) {
	if (ppResult)
	    *ppResult = 0;
	return ResultFromScode(AVIERR_BADPARAM);
    }

    // Make sure the length is within range
    if (*plStart + *plLength > l1)
	*plLength = l1 - *plStart;

#ifdef KEYALWAYS
    // Make copy start at key frame
    lStart = AVIStreamFindSample(this, *plStart, 0);
    *plLength += *plStart - lStart;
    *plStart = lStart;
#endif

    lLength = *plLength;
    lStart = *plStart;

    p = NewEditStream(NULL);
    *ppResult = (PAVISTREAM) p;
    if (!p)
	return ResultFromScode(AVIERR_MEMORY);

    hmemcpy(&p->sinfo, &this->sinfo, sizeof(p->sinfo));

    if (lLength <= 0)
	lLength = (LONG) (p->sinfo.dwLength + p->sinfo.dwStart) - lStart;

    hr = ResolveEdits(lStart, &p1, &l1, &edit1, FALSE);
    hr = ResolveEdits(lStart + lLength, &p2, &l2, &edit2, TRUE);

    if (edit1 == edit2) {
	p->edits[0].pavi = p1;
	if (p1)
	    AVIStreamAddRef(p1);
	p->edits[0].lStart = l1;
	p->edits[0].lLength = lLength;
    } else {
	hr = p->AllocEditSpace(1, edit2 - edit1);

	for (l = 0; l <= edit2 - edit1; l++) {
	    if (l == 0) {
		p->edits[l].pavi = p1;
		if (p1)
		    AVIStreamAddRef(p1);
		p->edits[l].lStart = l1;
		p->edits[l].lLength = this->edits[edit1].lStart +
				      this->edits[edit1].lLength - l1;
	    } else if (l < edit2 - edit1) {
		p->edits[l] = this->edits[l+edit1];
		if (p->edits[l].pavi)
		    AVIStreamAddRef(p->edits[l].pavi);
	    } else {
		p->edits[l] = this->edits[edit2];
		if (p->edits[l].pavi)
		    AVIStreamAddRef(p->edits[l].pavi);
		p->edits[l].lLength = l2 - p->edits[l].lStart;
	    }
	}
	
	p->PossiblyRemoveEdit(edit2 - edit1);	
	p->PossiblyRemoveEdit(0);
    }

#ifndef KEYALWAYS
    l1 = AVIStreamFindSample(p->edits[0].pavi, p->edits[0].lStart, 0);
    DPF("edit starts at %ld, key at %ld\n", p->edits[0].lStart, l1);
    if (l1 != p->edits[0].lStart) {
	p->fFullFrames = TRUE;
	DPF("Copy: Converting new stream to full frames\n");
    }
#endif

    // this overwrites the name!!!!
    // AVIStreamInfoW(this->edits[0].pavi, &p->sinfo, sizeof(p->sinfo));
    p->sinfo.dwStart = 0;
    p->sinfo.dwLength = (DWORD) lLength;
    p->sinfo.dwEditCount = 0;
    p->sinfo.dwFormatChangeCount = 0;
    if (p->fFullFrames)
	p->sinfo.fccHandler = 0;

    p->CheckEditList();
    CheckEditList();

    return AVIERR_OK;
}

/**************************************************************************
* @doc  INTERNAL DRAWDIB
*
* @api BOOL | DibEq | This function compares two dibs.
*
* @parm LPBITMAPINFOHEADER lpbi1 | Pointer to one bitmap.
*       this DIB is assumed to have the colors after the BITMAPINFOHEADER
*
* @parm LPBITMAPINFOHEADER | lpbi2 | Pointer to second bitmap.
*       this DIB is assumed to have the colors after biSize bytes.
*
* @rdesc Returns TRUE if bitmaps are identical, FALSE otherwise.
*
**************************************************************************/
static inline BOOL DibEq(LPBITMAPINFOHEADER lpbi1, LPBITMAPINFOHEADER lpbi2)
{
    return
        lpbi1->biCompression == lpbi2->biCompression   &&
        lpbi1->biSize        == lpbi2->biSize          &&
        lpbi1->biWidth       == lpbi2->biWidth         &&
        lpbi1->biHeight      == lpbi2->biHeight        &&
        lpbi1->biBitCount    == lpbi2->biBitCount;
}

BOOL AreVideoStreamsCompatible(PAVISTREAM ps1, PAVISTREAM ps2)
{
    LONG	cb1, cb2;
    BITMAPINFOHEADER	bih1, bih2;
	
    AVIStreamReadFormat(ps1, AVIStreamStart(ps1), NULL, &cb1);
    AVIStreamReadFormat(ps2, AVIStreamStart(ps2), NULL, &cb2);

    if (cb1 != cb2)
	return FALSE;

    cb1 = sizeof(bih1);
    cb2 = sizeof(bih2);
    AVIStreamReadFormat(ps1, AVIStreamStart(ps1), &bih1, &cb1);
    AVIStreamReadFormat(ps2, AVIStreamStart(ps2), &bih2, &cb2);

    if (DibEq(&bih1, &bih2))
	return TRUE;

    return FALSE;
}

BOOL AreAudioStreamsCompatible(PAVISTREAM ps1, PAVISTREAM ps2)
{
    LONG	cb1, cb2;
    LPVOID	lpf;
    BOOL	f;

    AVIStreamReadFormat(ps1, AVIStreamStart(ps1), NULL, &cb1);
    AVIStreamReadFormat(ps2, AVIStreamStart(ps2), NULL, &cb2);

    if (cb1 != cb2)
	return FALSE;

    lpf = GlobalAllocPtr(GHND, cb1 + cb2);

    if (!lpf)
	return FALSE; // !!!

    AVIStreamReadFormat(ps1, AVIStreamStart(ps1), lpf, &cb1);
    AVIStreamReadFormat(ps2, AVIStreamStart(ps2), (BYTE FAR *)lpf + cb1, &cb2);

    f = !_fmemcmp(lpf, (BYTE FAR *)lpf + cb1, (UINT) cb1);

    GlobalFreePtr(lpf);

    return f;
}

//
// Paste:
//
//     Takes stream to paste, along with start and length within that stream,
//	and also target stream and position within the stream to do the paste.
//
//	Returns position and length pasted.
//
STDMETHODIMP CEditStream::Paste(LONG FAR *plPos, LONG FAR *plLength, PAVISTREAM pstream, LONG lStart, LONG lLength)
{
    PAVISTREAM	p;
    LONG	l;
    LONG	edit;
    HRESULT	hr;
    LONG	lPos;
    ICEditStreamInternal FAR *pgetnew;
    CEditStream	FAR *pnew;
    AVISTREAMINFOW   strinfo;

    AVIStreamInfoW(pstream, &strinfo, sizeof(strinfo));

    if (this->sinfo.fccType == 0) {
	AVIStreamInfoW(pstream, &this->sinfo, sizeof(this->sinfo));
	this->sinfo.dwLength = 0;
	this->sinfo.dwStart = *plPos;
    }

    if (*plPos > (LONG) (sinfo.dwLength + sinfo.dwStart)) {
	// !!! We should handle this case....
	return ResultFromScode(AVIERR_BADPARAM);
    }


#ifdef KEYALWAYS
    // Make paste go before a key frame...
    *plPos = AVIStreamFindSample(this, *plPos, 0);
#endif
    lPos = *plPos;

    if (strinfo.fccType != this->sinfo.fccType) {
	DPF("Paste: Incompatible stream types!\n");
	return ResultFromScode(AVIERR_UNSUPPORTED);
    }

    if (lLength <= 0 || ((lStart + lLength) >
			 (LONG) (strinfo.dwStart + strinfo.dwLength))) {
	if (lStart >= (LONG) (strinfo.dwLength + strinfo.dwStart))
	    return ResultFromScode(AVIERR_BADPARAM);

	lLength = (LONG) (strinfo.dwLength + strinfo.dwStart) - lStart;
    }

    if ((DWORD) lPos + (DWORD) lLength > 0x80000000) {
	DPF("Paste result would be more than 2 billion frames!\n");
	return ResultFromScode(AVIERR_MEMORY);
    }

    // !!! What if the frame rates don't match?

#define SIZEMISMATCH(rc1, rc2) \
    (((rc1.right - rc1.left) != (rc2.right - rc2.left)) || \
     ((rc1.bottom - rc1.top) != (rc2.bottom - rc2.top)))

    if (strinfo.fccType == streamtypeVIDEO &&
		SIZEMISMATCH(strinfo.rcFrame, this->sinfo.rcFrame)) {
	// !!! It would be nice if this worked.
	DPF("Paste: Video streams are different sizes!\n");
	return ResultFromScode(AVIERR_UNSUPPORTED);
    }

    if (this->sinfo.fccType == streamtypeAUDIO) {
	if (!AreAudioStreamsCompatible((PAVISTREAM) this, pstream)) {
	    DPF("Paste: Audio streams are different formats!\n");
	    return ResultFromScode(AVIERR_UNSUPPORTED);
	}
    }

    // find out if this object is really one of our objects, by grabbing
    // a private interface.
    pgetnew = NULL;
    pnew = NULL;

    if (SUCCEEDED(pstream->QueryInterface(CLSID_EditStream, (LPVOID FAR *) &pgetnew))) {
	pgetnew->GetInternalPointer((LPVOID FAR *) &pnew);
	pgetnew->Release();
    }

#ifndef KEYALWAYS
    if (this->sinfo.fccType == streamtypeVIDEO) {
	if (!this->fFullFrames) {
	    if ((!AVIStreamIsKeyFrame(pstream, lStart) ||
		 (pnew && pnew->fFullFrames)) ||
		((lPos < (LONG) (sinfo.dwLength + sinfo.dwStart)) &&
		 !AVIStreamIsKeyFrame((PAVISTREAM) this, lPos)) ||
		!AreVideoStreamsCompatible((PAVISTREAM) this, pstream)) {

		// !!! What if we're pasting, say, an 8-bit and a 32-bit
		// movie together?  Do we have to pick a common format
		// to convert to?
		CallGetFrame(this->edits[0].pavi, this->edits[0].lStart);
		if (CallGetFrame(pstream, lStart) == NULL) {
		    DPF("Paste: Can't make a common format!\n");
		
		    return ResultFromScode(AVIERR_BADFORMAT);
		}

		this->fFullFrames = TRUE;
		sinfo.fccHandler = 0;
		DPF("Paste: Converting stream to full frames\n");
		this->sinfo.dwFormatChangeCount++;

		// ??? !!! Call get frame once, just so it's been done....
	    }
	} else {
	    if (CallGetFrame(pstream, lStart) == NULL) {
		DPF("Paste: Can't make a common format!\n");
		
		return ResultFromScode(AVIERR_BADFORMAT);
	    }
	}

	// Be suspicious: assume palette changes are a possibility
	this->sinfo.dwFlags |= AVISTREAMINFO_FORMATCHANGES;
    }
#endif

    // Find where to do the paste...
    hr = ResolveEdits(lPos, &p, &l, &edit, TRUE);

    // Report back the size of what we pasted...
    if (plLength)
	*plLength = lLength;

    if (pnew) {
	LONG	lNew;

	// The inserted stream is itself an edit list; take advantage
	// of this fact.
	hr = AllocEditSpace(edit, 1 + pnew->cedits);

	this->edits[edit].pavi = this->edits[edit + 1 + pnew->cedits].pavi;
	if (this->edits[edit].pavi)
	    AVIStreamAddRef(this->edits[edit].pavi);
	this->edits[edit].lStart = this->edits[edit + 1 + pnew->cedits].lStart;
	this->edits[edit].lLength = l - this->edits[edit].lStart;

	// !!! We're ignoring lStart and lLength!
	for (lNew = 0; lNew < pnew->cedits; lNew++) {
	    this->edits[edit + 1 + lNew] = pnew->edits[lNew];
	    AVIStreamAddRef(pnew->edits[lNew].pavi);
	}

	this->edits[edit + pnew->cedits + 1].lStart = l;
	this->edits[edit + pnew->cedits + 1].lLength -= this->edits[edit].lLength;

	// Get rid of zero-length edits....
	PossiblyRemoveEdit(edit + pnew->cedits + 1);
	
	PossiblyRemoveEdit(edit);
	
	this->sinfo.dwLength += lLength;
	pnew->CheckEditList();
    } else {
	// Just insert the stream as a blob.
	hr = AllocEditSpace(edit, 2);

	this->edits[edit].pavi = this->edits[edit+2].pavi;
	if (this->edits[edit].pavi)
	    AVIStreamAddRef(this->edits[edit].pavi);
	this->edits[edit].lStart = this->edits[edit+2].lStart;
	this->edits[edit].lLength = l - this->edits[edit+2].lStart;

	this->edits[edit+ 1].pavi = pstream;
	if (pstream)
	    AVIStreamAddRef(pstream);
	this->edits[edit + 1].lStart = lStart;
	this->edits[edit + 1].lLength = lLength;

	this->edits[edit + 2].lStart = l;
	this->edits[edit + 2].lLength -= this->edits[edit].lLength;
	// No addref here, since the edit we're splitting had a ref already
	
	this->sinfo.dwLength += lLength;

	// Get rid of zero-length edits....
	PossiblyRemoveEdit(edit + 2);
	
	PossiblyRemoveEdit(edit);
    }

    CheckEditList();
    this->sinfo.dwEditCount++;

    return AVIERR_OK;
}

STDMETHODIMP CEditStream::Clone(PAVISTREAM FAR *ppResult)
{
    CEditStream FAR *	pnew;
    HRESULT		hr;
    LONG		l;

    pnew = NewEditStream(NULL);
    *ppResult = (PAVISTREAM) pnew;
    if (!pnew)
	return ResultFromScode(AVIERR_MEMORY);

    if (this->cedits > 1) {
	hr = pnew->AllocEditSpace(1, this->cedits - 1);
	if (hr != NOERROR) {
	    // !!! Clean things up
	    return hr;
	}
    }

    for (l = 0; l < this->cedits; l++) {
	pnew->edits[l] = this->edits[l];
	if (pnew->edits[l].pavi)
	    AVIStreamAddRef(pnew->edits[l].pavi);
    }

    pnew->sinfo = this->sinfo;
    pnew->fFullFrames = this->fFullFrames;

    pnew->CheckEditList();

    return AVIERR_OK;
}

STDMETHODIMP CEditStream::SetInfo(AVISTREAMINFOW FAR * lpInfo, LONG cbInfo)
{
    if ((cbInfo < sizeof(AVISTREAMINFOW)) ||
	(IsBadReadPtr(lpInfo, sizeof(AVISTREAMINFOW))))
	return ResultFromScode(AVIERR_BADPARAM);

    // Things we don't copy:
    // fccType
    // fccHandler
    // dwFlags
    // dwCaps
    // dwLength
    // dwInitialFrames
    // dwSuggestedBufferSize
    // dwSampleSize
    // dwEditCount
    // dwFormatChangeCount

    this->sinfo.wPriority = lpInfo->wPriority;
    this->sinfo.wLanguage = lpInfo->wLanguage;
    this->sinfo.dwScale   = lpInfo->dwScale;
    this->sinfo.dwRate    = lpInfo->dwRate;
    this->sinfo.dwStart   = lpInfo->dwStart;  // !!! ???
    this->sinfo.dwQuality = lpInfo->dwQuality;
    this->sinfo.rcFrame   = lpInfo->rcFrame;

    if (lpInfo->szName[0])
	_fmemcpy(this->sinfo.szName, lpInfo->szName, sizeof(this->sinfo.szName));

    // The stream has been changed....
    ++this->sinfo.dwEditCount;

    return NOERROR;
}



//
//
//   Extra unimplemented functions.....
//
//
//
HRESULT STDMETHODCALLTYPE CEditStream::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (riid == IID_IUnknown)
	*ppvObj = ((IUnknown FAR *) (IAVIStream FAR *) this);
    else if (riid == CLSID_EditStream)
	*ppvObj = ((ICEditStreamInternal FAR *) this);
    else if (riid == IID_IAVIStream)
	*ppvObj = ((IAVIStream FAR *) this);
    else if (riid == IID_IAVIEditStream)
	*ppvObj = ((IAVIEditStream FAR *) this);
#ifdef CUSTOMMARSHAL
    else if ((riid == IID_IMarshal) && CanMarshalSimply()) // !!!! Remove once fixed!
	*ppvObj = ((IMarshal FAR *) this);
#endif

    else {                 // unsupported interface
        *ppvObj = NULL;
        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();

    return NOERROR;
}

HRESULT STDMETHODCALLTYPE CEditStream::GetInternalPointer(LPVOID FAR * ppInternal)
{
    *ppInternal = (LPVOID) this;

    return NOERROR;
}

HRESULT STDMETHODCALLTYPE CEditStream::ReadData     (DWORD fcc, LPVOID lp, LONG FAR *lpcb)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

HRESULT STDMETHODCALLTYPE CEditStream::SetFormat    (LONG lPos, LPVOID lpFormat, LONG cbFormat)
{
    // !!! We could set the whole format of the stream here, and do mapping....

    return ResultFromScode(AVIERR_UNSUPPORTED);
}

HRESULT STDMETHODCALLTYPE CEditStream::WriteData    (DWORD fcc, LPVOID lp, LONG cb)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

HRESULT STDMETHODCALLTYPE CEditStream::Write        (LONG lStart, LONG lSamples, LPVOID lpBuffer, LONG cbBuffer, DWORD dwFlags, LONG FAR *plSampWritten, LONG FAR *plBytesWritten)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

HRESULT STDMETHODCALLTYPE CEditStream::Delete       (LONG lStart, LONG lSamples)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

HRESULT CEditStream::NewInstance(IUnknown FAR* pUnknownOuter,
			       REFIID riid,
			       LPVOID FAR* ppv)
{
    CEditStream FAR *	pedit;
    HRESULT		hr;

    pedit = new CEditStream;

    if (pedit)
	(pedit->Create)(NULL, 0);
    // !!! error check

    hr = pedit->QueryInterface(riid, ppv);

    if (FAILED(GetScode(hr)))
	delete pedit;

    return hr;
}

#ifdef CUSTOMMARSHAL
BOOL CEditStream::CanMarshalSimply()
{
    LONG	l;
    LPUNKNOWN	punk;

    for (l = 0; l < this->cedits; l++) {
	punk = NULL;

	this->edits[l].pavi->QueryInterface(CLSID_AVISimpleUnMarshal,
					    (LPVOID FAR *) &punk);

	if (!punk)
	    return FALSE;
	
	punk->Release();
    }

    return TRUE;
}

STDMETHODIMP CEditStream::GetUnmarshalClass (REFIID riid, LPVOID pv,
		    DWORD dwDestContext, LPVOID pvDestContext,
		    DWORD mshlflags, LPCLSID pCid)
{
    if (dwDestContext == MSHCTX_LOCAL && CanMarshalSimply()) {
	DPF("UnMarshalClass called (simple)\n");

	*pCid = CLSID_AVISimpleUnMarshal;
	return NOERROR;
    } else {
	LPMARSHAL   pMarshal;
	HRESULT	    hr;
	DPF("Marshal context is %lu: delegating...\n", dwDestContext);

	hr = CoGetStandardMarshal(riid, (LPMARSHAL) this,
				  dwDestContext, pvDestContext,
				  mshlflags, &pMarshal);

	if (hr != NOERROR) {
	    DPF("CoGetStandardMarshal returns %lu\n", hr);
	    return hr;
	}

	hr = pMarshal->GetUnmarshalClass(riid, pv,
					 dwDestContext, pvDestContext,
					 mshlflags, pCid);

	pMarshal->Release();

	return hr;
    }
}

STDMETHODIMP CEditStream::GetMarshalSizeMax (REFIID riid, LPVOID pv,
		    DWORD dwDestContext, LPVOID pvDestContext,
		    DWORD mshlflags, LPDWORD pSize)
{
    if (dwDestContext == MSHCTX_LOCAL && CanMarshalSimply()) {
	*pSize = 4;
    } else {
	LPMARSHAL   pMarshal;
	HRESULT	    hr;

	hr = CoGetStandardMarshal(riid, (LPMARSHAL) this,
				  dwDestContext, pvDestContext,
				  mshlflags, &pMarshal);

	if (hr != NOERROR)
	    return hr;

	hr = pMarshal->GetMarshalSizeMax(riid, pv,
					 dwDestContext, pvDestContext,
					 mshlflags, pSize);

	pMarshal->Release();

	return hr;
    }
    return NOERROR;
}

STDMETHODIMP CEditStream::MarshalInterface (LPSTREAM pStm, REFIID riid,
		    LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
		    DWORD mshlflags)
{
    HRESULT	hr;

    if ((riid != IID_IAVIStream && riid != IID_IAVIFile && riid != IID_IUnknown))
        return ResultFromScode(E_INVALIDARG);

    if (dwDestContext != MSHCTX_LOCAL || !CanMarshalSimply()) {
	LPMARSHAL    pMarshal;

	DPF("Marshal context is %lu: delegating...\n", dwDestContext);

	hr = CoGetStandardMarshal(riid, (LPMARSHAL) this,
				  dwDestContext, pvDestContext,
				  mshlflags, &pMarshal);

	if (hr != NOERROR)
	    return hr;

	hr = pMarshal->MarshalInterface(pStm, riid, pv,
					dwDestContext, pvDestContext,
					mshlflags);

	pMarshal->Release();
    } else {
	LPUNKNOWN pUnk = (LPUNKNOWN) (PAVISTREAM) this;
	
	DPF("MarshalInterface called (simple): Marshalling %p\n", (DWORD_PTR) pUnk);
	if ((hr = pStm->Write(&pUnk, sizeof(pUnk), NULL)) == NOERROR)
	    AddRef();
    }

    DPF("Returns %lx\n", hr);

    return hr;
}

STDMETHODIMP CEditStream::UnmarshalInterface (LPSTREAM pStm, REFIID riid,
		    LPVOID FAR* ppv)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CEditStream::ReleaseMarshalData (LPSTREAM pStm)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CEditStream::DisconnectObject (DWORD dwReserved)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

#endif	// CUSTOMMARSHAL only


HRESULT STDMETHODCALLTYPE CEditStream::Reserved1()
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

HRESULT STDMETHODCALLTYPE CEditStream::Reserved2()
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

HRESULT STDMETHODCALLTYPE CEditStream::Reserved3()
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

HRESULT STDMETHODCALLTYPE CEditStream::Reserved4()
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

HRESULT STDMETHODCALLTYPE CEditStream::Reserved5()
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}



/*****************************************************************************
 *
 * dprintf() is called by the DPF macro if DEBUG is defined at compile time.
 *
 * The messages will be send to COM1: like any debug message. To
 * enable debug output, add the following to WIN.INI :
 *
 * [debug]
 * ICSAMPLE=1
 *
 ****************************************************************************/

#ifdef DEBUG

#define MODNAME "EditStrm"
static BOOL  fDebug = -1;

static void cdecl dprintf(LPSTR szFormat, ...)
{
    char ach[128];

#ifdef _WIN32
    va_list va;
    if (fDebug == -1)
        fDebug = GetProfileIntA("Debug",MODNAME, FALSE);

    if (!fDebug)
        return;

    va_start(va, szFormat);
    if (szFormat[0] == '!')
        ach[0]=0, szFormat++;
    else
        lstrcpyA(ach, MODNAME ": ");

    wvsprintfA(ach+lstrlenA(ach),szFormat, va);
    va_end(va);
//  lstrcatA(ach, "\r\r\n");

    OutputDebugStringA(ach);
#else
    if (fDebug == -1)
        fDebug = GetProfileInt("Debug",MODNAME, FALSE);

    if (!fDebug)
        return;

    if (szFormat[0] == '!')
        ach[0]=0, szFormat++;
    else
        lstrcpy(ach, MODNAME ": ");

    wvsprintf(ach+lstrlen(ach),szFormat,(LPSTR)(&szFormat+1));
//  lstrcat(ach, "\r\r\n");

    OutputDebugString(ach);
#endif
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\enumfetc.c ===
/*************************************************************************
**
**    OLE 2 Utility Code
**
**    enumfetc.c
**
**    This file contains a standard implementation of IEnumFormatEtc
**    interface.
**    This file is part of the OLE 2.0 User Interface support library.
**
**    (c) Copyright Microsoft Corp. 1990 - 1995.  All Rights Reserved
**
*************************************************************************/

#define STRICT  1

#include <win32.h>
#include <ole2.h>
#include "enumfetc.h"

#ifdef SHELLOLE
#ifdef _WIN32
#undef Assert
#include <shlobj.h>
#include <shellp.h>
#define CoGetMalloc(ctx, ppmalloc)  SHGetMalloc(ppmalloc)
#endif
#endif
#ifdef DAYTONA
#include "olehack.h"
#endif
STDAPI_(void) OleStdFree(LPVOID pmem);
STDAPI_(BOOL) OleStdCopyFormatEtc(LPFORMATETC petcDest, LPFORMATETC petcSrc);

typedef struct tagOleStdEnumFmtEtc {
  IEnumFORMATETCVtbl FAR* lpVtbl;
  ULONG m_dwRefs;      /* referance count */
  WORD m_wIndex;       /* current index in list */
  WORD m_wCount;       /* how many items in list */
  LPFORMATETC m_lpEtc;  /* list of formatetc */
} OLESTDENUMFMTETC, FAR* LPOLESTDENUMFMTETC;

VOID  OleStdEnumFmtEtc_Destroy(LPOLESTDENUMFMTETC pEtc);

STDMETHODIMP OleStdEnumFmtEtc_QueryInterface(
        LPENUMFORMATETC lpThis, REFIID riid, LPVOID FAR* ppobj);
STDMETHODIMP_(ULONG)  OleStdEnumFmtEtc_AddRef(LPENUMFORMATETC lpThis);
STDMETHODIMP_(ULONG)  OleStdEnumFmtEtc_Release(LPENUMFORMATETC lpThis);
STDMETHODIMP  OleStdEnumFmtEtc_Next(LPENUMFORMATETC lpThis, ULONG celt,
                                  LPFORMATETC rgelt, ULONG FAR* pceltFetched);
STDMETHODIMP  OleStdEnumFmtEtc_Skip(LPENUMFORMATETC lpThis, ULONG celt);
STDMETHODIMP  OleStdEnumFmtEtc_Reset(LPENUMFORMATETC lpThis);
STDMETHODIMP  OleStdEnumFmtEtc_Clone(LPENUMFORMATETC lpThis,
                                     LPENUMFORMATETC FAR* ppenum);

static IEnumFORMATETCVtbl g_EnumFORMATETCVtbl = {
        OleStdEnumFmtEtc_QueryInterface,
        OleStdEnumFmtEtc_AddRef,
        OleStdEnumFmtEtc_Release,
        OleStdEnumFmtEtc_Next,
        OleStdEnumFmtEtc_Skip,
        OleStdEnumFmtEtc_Reset,
        OleStdEnumFmtEtc_Clone,
};

/////////////////////////////////////////////////////////////////////////////


STDAPI_(LPENUMFORMATETC)
  OleStdEnumFmtEtc_Create(WORD wCount, LPFORMATETC lpEtc)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPMALLOC lpMalloc=NULL;
  LPOLESTDENUMFMTETC lpEF=NULL;
  DWORD dwSize;
  WORD i;
  HRESULT hRes;

  hRes = CoGetMalloc(MEMCTX_TASK, &lpMalloc);
  if (hRes != NOERROR) {
    return NULL;
  }

  lpEF = (LPOLESTDENUMFMTETC)lpMalloc->lpVtbl->Alloc(lpMalloc,
                                                 sizeof(OLESTDENUMFMTETC));
  if (lpEF == NULL) {
    goto errReturn;
  }

  lpEF->lpVtbl = &g_EnumFORMATETCVtbl;
  lpEF->m_dwRefs = 1;
  lpEF->m_wCount = wCount;
  lpEF->m_wIndex = 0;

  dwSize = sizeof(FORMATETC) * lpEF->m_wCount;

  lpEF->m_lpEtc = (LPFORMATETC)lpMalloc->lpVtbl->Alloc(lpMalloc, dwSize);
  if (lpEF->m_lpEtc == NULL) {
    goto errReturn;
  }

  for (i=0; i<wCount; i++) {
    OleStdCopyFormatEtc(
            (LPFORMATETC)&(lpEF->m_lpEtc[i]), (LPFORMATETC)&(lpEtc[i]));
  }

  return (LPENUMFORMATETC)lpEF;

errReturn:
  if (lpEF != NULL) {
    lpMalloc->lpVtbl->Free(lpMalloc, lpEF);
  }

  if (lpMalloc != NULL) {
    lpMalloc->lpVtbl->Release(lpMalloc);
  }

  return NULL;

} /* OleStdEnumFmtEtc_Create()
   */


VOID
  OleStdEnumFmtEtc_Destroy(LPOLESTDENUMFMTETC lpEF)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
    LPMALLOC lpMalloc=NULL;
    WORD i;

    if (lpEF != NULL) {

        if (CoGetMalloc(MEMCTX_TASK, &lpMalloc) == NOERROR) {

            /* OLE2NOTE: we MUST free any memory that was allocated for
            **    TARGETDEVICES contained within the FORMATETC elements.
            */
            for (i=0; i<lpEF->m_wCount; i++) {
                OleStdFree(lpEF->m_lpEtc[i].ptd);
            }

            if (lpEF->m_lpEtc != NULL) {
                lpMalloc->lpVtbl->Free(lpMalloc, lpEF->m_lpEtc);
            }

            lpMalloc->lpVtbl->Free(lpMalloc, lpEF);
            lpMalloc->lpVtbl->Release(lpMalloc);
        }
    }
} /* OleStdEnumFmtEtc_Destroy()
   */


STDMETHODIMP
  OleStdEnumFmtEtc_QueryInterface(
                LPENUMFORMATETC lpThis, REFIID riid, LPVOID FAR* ppobj)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  *ppobj = NULL;

  if (IsEqualIID(riid,&IID_IUnknown) || IsEqualIID(riid,&IID_IEnumFORMATETC)){
    *ppobj = (LPVOID)lpEF;
  }

  if (*ppobj == NULL) return ResultFromScode(S_FALSE);
  else{
    OleStdEnumFmtEtc_AddRef(lpThis);
    return NOERROR;
  }

} /* OleStdEnumFmtEtc_QueryInterface()
   */


STDMETHODIMP_(ULONG)
  OleStdEnumFmtEtc_AddRef(LPENUMFORMATETC lpThis)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  return lpEF->m_dwRefs++;

} /* OleStdEnumFmtEtc_AddRef()
   */


STDMETHODIMP_(ULONG)
  OleStdEnumFmtEtc_Release(LPENUMFORMATETC lpThis)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  DWORD dwRefs = --lpEF->m_dwRefs;

  if (dwRefs == 0)
    OleStdEnumFmtEtc_Destroy(lpEF);

  return dwRefs;

} /* OleStdEnumFmtEtc_Release()
   */


STDMETHODIMP
  OleStdEnumFmtEtc_Next(LPENUMFORMATETC lpThis, ULONG celt, LPFORMATETC rgelt,
                      ULONG FAR* pceltFetched)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  ULONG i=0;
  WORD wOffset;

  if (rgelt == NULL) {
    return ResultFromScode(E_INVALIDARG);
  }

  while (i < celt) {
    wOffset = lpEF->m_wIndex + (WORD)i;

    if (wOffset < lpEF->m_wCount) {
      OleStdCopyFormatEtc(
            (LPFORMATETC)&(rgelt[i]), (LPFORMATETC)&(lpEF->m_lpEtc[wOffset]));
      lpEF->m_wIndex ++;
      i++;
    }else{
      break;
    }
  }

  if (pceltFetched != NULL) {
    *pceltFetched = i;
  }

  if (i != celt) {
    return ResultFromScode(S_FALSE);
  }

  return NOERROR;
} /* OleStdEnumFmtEtc_Next()
   */


STDMETHODIMP
  OleStdEnumFmtEtc_Skip(LPENUMFORMATETC lpThis, ULONG celt)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  ULONG i=0;
  WORD wOffset;

  while (i < celt) {
    wOffset = lpEF->m_wIndex + (WORD)i;

    if (wOffset < lpEF->m_wCount) {
      lpEF->m_wIndex ++;
      i++;
    }else{
      break;
    }
  }

  if (i != celt) {
    return ResultFromScode(S_FALSE);
  }

  return NOERROR;
} /* OleStdEnumFmtEtc_Skip()
   */


STDMETHODIMP
  OleStdEnumFmtEtc_Reset(LPENUMFORMATETC lpThis)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  lpEF->m_wIndex = 0;

  return NOERROR;
} /* OleStdEnumFmtEtc_Reset()
   */


STDMETHODIMP
  OleStdEnumFmtEtc_Clone(LPENUMFORMATETC lpThis, LPENUMFORMATETC FAR* ppenum)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;

  if (ppenum == NULL) {
    return ResultFromScode(E_INVALIDARG);
  }

  *ppenum = OleStdEnumFmtEtc_Create(lpEF->m_wCount, lpEF->m_lpEtc);

  return (*ppenum != NULL ? NOERROR : ResultFromScode(E_OUTOFMEMORY));

} /* OleStdEnumFmtEtc_Clone()
   */



/* OleStdMalloc
** ------------
**    allocate memory using the currently active IMalloc* allocator
*/
STDAPI_(LPVOID) OleStdMalloc(ULONG ulSize)
{
    LPVOID pout;
    LPMALLOC pmalloc;

    if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != S_OK) {
//        OleDbgAssertSz(0, szAssertMemAlloc);
        return NULL;
    }

    pout = (LPVOID)pmalloc->lpVtbl->Alloc(pmalloc, ulSize);

    if (pmalloc != NULL) {
        ULONG refs = pmalloc->lpVtbl->Release(pmalloc);
    }

    return pout;
}

/*
 * OleStdCopyTargetDevice()
 *
 * Purpose:
 *  duplicate a TARGETDEVICE struct. this function allocates memory for
 *  the copy. the caller MUST free the allocated copy when done with it
 *  using the standard allocator returned from CoGetMalloc.
 *  (OleStdFree can be used to free the copy).
 *
 * Parameters:
 *  ptdSrc      pointer to source TARGETDEVICE
 *
 * Return Value:
 *    pointer to allocated copy of ptdSrc
 *    if ptdSrc==NULL then retuns NULL is returned.
 *    if ptdSrc!=NULL and memory allocation fails, then NULL is returned
 */
STDAPI_(DVTARGETDEVICE FAR*) OleStdCopyTargetDevice(DVTARGETDEVICE FAR* ptdSrc)
{
  DVTARGETDEVICE FAR* ptdDest = NULL;

  if (ptdSrc == NULL) {
    return NULL;
  }

  if ((ptdDest = (DVTARGETDEVICE FAR*)OleStdMalloc(ptdSrc->tdSize)) != NULL) {
    hmemcpy(ptdDest, ptdSrc, (size_t)ptdSrc->tdSize);
  }

  return ptdDest;
}



/*
 * OleStdCopyFormatEtc()
 *
 * Purpose:
 *  Copies the contents of a FORMATETC structure. this function takes
 *  special care to copy correctly copying the pointer to the TARGETDEVICE
 *  contained within the source FORMATETC structure.
 *  if the source FORMATETC has a non-NULL TARGETDEVICE, then a copy
 *  of the TARGETDEVICE will be allocated for the destination of the
 *  FORMATETC (petcDest).
 *
 *  OLE2NOTE: the caller MUST free the allocated copy of the TARGETDEVICE
 *  within the destination FORMATETC when done with it
 *  using the standard allocator returned from CoGetMalloc.
 *  (OleStdFree can be used to free the copy).
 *
 * Parameters:
 *  petcDest      pointer to destination FORMATETC
 *  petcSrc       pointer to source FORMATETC
 *
 * Return Value:
 *    pointer to allocated copy of ptdSrc; retuns NULL if not successful
 */
STDAPI_(BOOL) OleStdCopyFormatEtc(LPFORMATETC petcDest, LPFORMATETC petcSrc)
{
  if ((petcDest == NULL) || (petcSrc == NULL)) {
    return FALSE;
  }

  petcDest->cfFormat = petcSrc->cfFormat;
  petcDest->ptd      = OleStdCopyTargetDevice(petcSrc->ptd);
  petcDest->dwAspect = petcSrc->dwAspect;
  petcDest->lindex   = petcSrc->lindex;
  petcDest->tymed    = petcSrc->tymed;

  return TRUE;

}

/* OleStdFree
** ----------
**    free memory using the currently active IMalloc* allocator
*/
STDAPI_(void) OleStdFree(LPVOID pmem)
{
    LPMALLOC pmalloc;

    if (pmem == NULL)
        return;

    if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != S_OK) {
//        OleDbgAssertSz(0, szAssertMemAlloc);
        return;
    }

    pmalloc->lpVtbl->Free(pmalloc, pmem);

    if (pmalloc != NULL) {
        ULONG refs = pmalloc->lpVtbl->Release(pmalloc);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\debug.h ===
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifdef UNICODE
//
//  Map GetProfileInt calls to the registry
//
#include "profile.h"
#endif

#ifdef DEBUG
    void CDECL dprintf0(LPSTR, ...);
    void CDECL dprintf(LPSTR, ...);
    void CDECL dprintf2(LPSTR, ...);
    void CDECL dprintf3(LPSTR, ...);
    #define DPF0 dprintf0
    #define DPF dprintf
    #define DPF2 dprintf2
    #define DPF3 dprintf3
#else
    #define DPF0 ; / ## /
    #define DPF ; / ## /
    #define DPF2 ; / ## /
    #define DPF3 ; / ## /
#endif

#undef Assert
#undef AssertSz

#ifdef DEBUG
	/* Assert() macros */
        #define AssertSz(x,sz)           ((x) ? (void)0 : (void)_Assert(sz, __FILE__, __LINE__))
        #define Assert(expr)             AssertSz(expr, #expr)

        extern void FAR PASCAL _Assert(char *szExp, char *szFile, int iLine);
#else
	/* Assert() macros */
        #define AssertSz(x, expr)           ((void)0)
        #define Assert(expr)             ((void)0)
#endif

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\directio.h ===
//
// unbuffered rapid disk i/o class. Provides streaming write to disk using
// unbuffered, overlapped i/o via large buffers. Inter-thread sync
// must be provided elsewhere.
//

#ifndef _DIRECTIO_H_
#define _DIRECTIO_H_

#ifdef _WIN32
  #ifdef CHICAGO
  #include "disk32.h"
  #endif

// all 'tunable' constants now found in CFileStream::EnsureBuffersValid()

// maximum number of buffers that can be requested
#define NR_OF_BUFFERS   	4

// min read size
#define MIN_READ_SIZE   (12 * 1024)

// --- we use these internally ----
// unbuffered i/o handler class. requires copy of data.
// will round reads and writes to correct sector size, and
// will pre-read if start location of read or write is not in buffer.
// read or write will terminate early if insufficient space or data.
// writes must be explicitly initiated from the buffer to disk
// by calling commit. reads will be initiated by the Read function, or may
// be initiated offline using ReadAhead.

class CFileBuffer {

public:
    // initiate to an invalid (no buffer ready) state
    CFileBuffer();

    // allocate memory and become idle.
   #ifdef CHICAGO
    BOOL Init(DWORD nBytesPerSector, DWORD buffersize, LPQIO pqio);
   #else
    BOOL Init(DWORD nBytesPerSector, DWORD buffersize, HANDLE hfile);
   #endif

    // revert to invalid state (eg when streaming stops)
    void FreeMemory();


    // write some data to buffer (must be committed separately)
    // filesize parameter is the current file size before this write
    // (used to control reading of partial sectors).
    BOOL Write(DWORD pos, LPBYTE pData, DWORD count, DWORD filesize,
            DWORD * pBytesWritten);

    // read data from buffer (will seek and read if necessary first)
    BOOL Read(DWORD pos, LPBYTE pData, DWORD count,
                DWORD filelength, DWORD * pBytesRead);

    // does this position occur anywhere within the current buffer ?
    // needs to know current eof for some cases (writing beyond eof
    // if eof is within this buffer is ok to this buffer).
    BOOL QueryPosition(DWORD pos, DWORD filesize);

    // what is the first file position after this buffer's valid data
    DWORD GetNextPosition();

    // initiate a read-ahead
    void ReadAhead(DWORD start, DWORD filelength);


    // initiate the i/o from the buffer
    BOOL Commit();

    // wait for any pending commit to complete
    BOOL WaitComplete();

    // is the buffer idle - FALSE if currently busy or invalid
    BOOL IsIdle() {
        return (m_State == Idle);
    };

    // calls commit if dirty before freeing everything.
    ~CFileBuffer();

private:

    // non-blocking check to see if pending i/o is complete and ok
    BOOL CheckComplete();

    BOOL ReadIntoBuffer(int offset, DWORD pos, DWORD count);

    DWORD_PTR RoundPosToSector(DWORD_PTR pos)
    {
        // positions round down to the previous sector start
        return (pos / m_BytesPerSector) * m_BytesPerSector;
    };

    DWORD_PTR RoundSizeToSector(DWORD_PTR size)
    {
        // sizes round up to total sector count
        return ((size + m_BytesPerSector - 1) / m_BytesPerSector)
                    * m_BytesPerSector;
    }


    // buffer states
    enum BufferState { Idle, Busy, Invalid, ErrorOccurred };

    BufferState m_State;
    BOOL        m_bDirty;
    LPBYTE      m_pBuffer;	// buffer with start addr rounded
    LPBYTE	m_pAllocedMem;	// buffer before rounding
    DWORD       m_TotalSize;        // allocated buffer size
    DWORD       m_DataLength;       // bytes of valid data in buffer
    DWORD       m_Position;         // file position of start of buffer
    DWORD       m_BytesPerSector;   // sector boundaries are important
    DWORD	m_FileLength;	    // actual file size (not rounded)


   #ifdef CHICAGO
    QIOBUF      m_qiobuf;
    LPQIO       m_pqio;
   #else
    OVERLAPPED  m_Overlapped;
    HANDLE      m_hFile;
   #endif
};



class CFileStream {

public:
    CFileStream();         // does not do much (cannot return error)

    BOOL Open(LPTSTR file, BOOL bWrite, BOOL bTruncate);

    BOOL Seek(DWORD pos);

    BOOL Write(LPBYTE pData, DWORD count, DWORD * pbyteswritten);

    BOOL Read(LPBYTE pData, DWORD count, DWORD * pbytesread);

    DWORD GetCurrentPosition();

    BOOL StartStreaming();		// default (write if opened for write)
    BOOL StartWriteStreaming();
    BOOL StartReadStreaming();
    BOOL StopStreaming();

    // wait for all transfers to complete.
    BOOL CommitAndWait();

    // destructor will call Commit()
    ~CFileStream();

private:

    // enable extra buffers for streaming
    BOOL EnsureBuffersValid();

    // advance to next buffer
    int NextBuffer(int i) {
        return (i + 1) % m_NrValid;
    };


    // unbuffered i/o is only allowed in multiples of this
    DWORD m_SectorSize;

    CFileBuffer m_Buffers[NR_OF_BUFFERS];


    // how many buffers are valid ?
    int m_NrValid;

    // which is the current buffer
    int m_Current;

    // which buffer has the highest position - we will issue the
    // readahead when we start using this buffer
    int m_HighestBuffer;

    // next read/write position within file
    DWORD m_Position;

    enum StreamingState { Invalid, Stopped, Reading, Writing };
    StreamingState m_State;

    DWORD m_Size;   // current file size

    // file handle
   #ifdef CHICAGO
    QIO         m_qio;
    #define     m_hFile m_qio.hFile
   #else
    HANDLE      m_hFile;
   #endif

    // if opened for writing, then default streaming mode is write
    BOOL m_bWrite;


};



#endif //_WIN32


#endif  // _DIRECTIO_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\extra.h ===
#include "fileshar.h"

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

typedef struct {
    LPVOID	lp;
    LONG	cb;
} EXTRA, FAR * LPEXTRA;

HRESULT ReadExtra(LPEXTRA extra,
		DWORD ckid,
	       LPVOID lpData,
	       LONG FAR *lpcbData);
HRESULT WriteExtra(LPEXTRA extra,
		DWORD ckid,
		LPVOID lpData,
		LONG cbData);

HRESULT ReadIntoExtra(LPEXTRA extra,
		   HSHFILE hshfile,
		   MMCKINFO FAR *lpck);

LONG FindChunkAndKeepExtras(LPEXTRA extra, HSHFILE hshfile,
			MMCKINFO FAR* lpck, MMCKINFO FAR* lpckParent,
			UINT uFlags);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\fakefile.h ===
/*	-	-	-	-	-	-	-	-	*/

/*
**	Copyright (C) Microsoft Corporation 1993 - 1995. All rights reserved.
*/

/*	-	-	-	-	-	-	-	-	*/

/*
** _StdClassImplementations
** Defines the standard implementations for a class object.
*/

#define	_StdClassImplementations(Impl)	\
	STDMETHODIMP QueryInterface(const IID FAR& riid, void FAR* FAR* ppv);	\
	STDMETHODIMP_(ULONG) AddRef();	\
	STDMETHODIMP_(ULONG) Release()


/*	-	-	-	-	-	-	-	-	*/

class FAR CFakeFile : IAVIFile {
public:
    CFakeFile(int nStreams, PAVISTREAM FAR * papStreams);

    _StdClassImplementations(CUnknownImpl);

#ifndef _WIN32
    STDMETHODIMP Open		    (THIS_
				     LPCTSTR szFile,
				     UINT mode);
#endif
    STDMETHODIMP Info                 (THIS_
				     AVIFILEINFOW FAR * pfi,
				     LONG lSize);
    STDMETHODIMP GetStream            (THIS_
				     PAVISTREAM FAR * ppStream,
				     DWORD fccType,
				     LONG lParam);
    STDMETHODIMP CreateStream         (THIS_
				     PAVISTREAM FAR * ppStream,
				     AVISTREAMINFOW FAR * psi);
#ifndef _WIN32
    STDMETHODIMP Save                 (THIS_
				     LPCTSTR szFile,
				     AVICOMPRESSOPTIONS FAR *lpOptions,
				     AVISAVECALLBACK lpfnCallback);
#endif
    STDMETHODIMP WriteData            (THIS_
				     DWORD ckid,
				     LPVOID lpData,
				     LONG cbData);
    STDMETHODIMP ReadData             (THIS_
				     DWORD ckid,
				     LPVOID lpData,
				     LONG FAR *lpcbData);
    STDMETHODIMP EndRecord            (THIS);
#ifdef _WIN32
    STDMETHODIMP DeleteStream         (THIS_
				     DWORD fccType,
				     LONG lParam);
#else
    STDMETHODIMP Reserved1            (THIS);
    STDMETHODIMP Reserved2            (THIS);
    STDMETHODIMP Reserved3            (THIS);
    STDMETHODIMP Reserved4            (THIS);
    STDMETHODIMP Reserved5            (THIS);
#endif

public:
    IUnknown FAR*	m_pUnknownOuter;

    //
    //  AVIFile instance data
    //
    AVIFILEINFOW FARSTRUCT	avihdr;         // file info
    ULONG			m_refs;
    PAVISTREAM NEAR *		aps;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\extra.cpp ===
#include <win32.h>
#include <vfw.h>
#include "extra.h"
#include "debug.h"

#ifndef HPBYTE
#define HPBYTE BYTE huge *
#endif

HRESULT ReadExtra(LPEXTRA extra,
	       DWORD ckid,
	       LPVOID lpData,
	       LONG FAR *lpcbData)
{
#define lpdw ((DWORD UNALIGNED HUGE *) lp)
    HPBYTE lp = (HPBYTE) extra->lp;
    LONG cb = extra->cb;
    LONG cbData;

    while (cb >= 2 * sizeof(DWORD)) {
	cbData = (LONG) lpdw[1];
	if (lpdw[0] == ckid) {
	    if (lpData) {
		hmemcpy(lpData, lp + 2 * sizeof(DWORD), min(cbData, *lpcbData));
	    }

	    *lpcbData = cbData;

	    return ResultFromScode(AVIERR_OK);
	}
	
	if (cbData & 1)
	    cbData++;

	cb -= cbData + sizeof(DWORD) * 2;
	lp += cbData + sizeof(DWORD) * 2;
    }
#undef lpdw
    *lpcbData = 0;
    return ResultFromScode(AVIERR_NODATA);
}

HRESULT WriteExtra(LPEXTRA extra,
		DWORD ckid,
		LPVOID lpData,
		LONG cbData)
{
    HPBYTE lp;

    cbData += sizeof(DWORD) * 2;
    if (extra->lp) {
	lp = (HPBYTE) GlobalReAllocPtr(extra->lp, extra->cb + cbData, GMEM_MOVEABLE | GMEM_SHARE);
	DPF("Extra cb is now %ld\n", extra->cb + cbData);
    } else {
	lp = (HPBYTE) GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, cbData);
    }

    if (!lp) {
	return ResultFromScode(AVIERR_MEMORY);
    }

    // !!! Should go and get rid of other chunks with same type!

    // build RIFF chunk in block
    ((DWORD UNALIGNED HUGE *) (lp + extra->cb))[0] = ckid;
    ((DWORD UNALIGNED HUGE *) (lp + extra->cb))[1] = cbData - sizeof(DWORD) * 2;

    hmemcpy(lp + extra->cb + sizeof(DWORD) * 2,
	    lpData,
	    cbData - sizeof(DWORD) * 2);

    if (cbData & 1)
	cbData++;

    extra->lp = lp;
    extra->cb += cbData;

    return ResultFromScode(AVIERR_OK);
}

HRESULT ReadIntoExtra(LPEXTRA extra,
		   HSHFILE hshfile,
		   MMCKINFO FAR * lpck)
{
    HPBYTE lp;
    LONG    cbData = lpck->cksize + sizeof(DWORD) * 2;

    DPF("ReadIntoExtra: now %ld bytes.\n", extra->cb + cbData);
    if (extra->lp) {
	lp = (HPBYTE) GlobalReAllocPtr(extra->lp, extra->cb + cbData, GMEM_MOVEABLE | GMEM_SHARE);
    } else {
	lp = (HPBYTE) GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, cbData);
    }

    if (!lp)
	return ResultFromScode(AVIERR_MEMORY);

    extra->lp = lp;

    // build RIFF chunk in block
    ((DWORD UNALIGNED HUGE *) (lp + extra->cb))[0] = lpck->ckid;
    ((DWORD UNALIGNED HUGE *) (lp + extra->cb))[1] = lpck->cksize;

    cbData += (cbData & 1);

    shfileSeek(hshfile, lpck->dwDataOffset, SEEK_SET);
    if (shfileRead(hshfile, (HPSTR) lp + extra->cb + sizeof(DWORD) * 2, lpck->cksize) !=
		(LONG) lpck->cksize)
	return ResultFromScode(AVIERR_FILEREAD);

    extra->cb += cbData;

    return ResultFromScode(AVIERR_OK);
}


LONG FindChunkAndKeepExtras(LPEXTRA extra, HSHFILE hshfile,
			MMCKINFO FAR* lpck, MMCKINFO FAR* lpckParent,
			UINT uFlags)
{
    FOURCC		ckidFind;	// chunk ID to find (or NULL)
    FOURCC		fccTypeFind;	// form/list type to find (or NULL)
    LONG		lRet;

    /* figure out what chunk id and form/list type to search for */
    if (uFlags & MMIO_FINDCHUNK)
	ckidFind = lpck->ckid, fccTypeFind = NULL;
    else if (uFlags & MMIO_FINDRIFF)
	ckidFind = FOURCC_RIFF, fccTypeFind = lpck->fccType;
    else if (uFlags & MMIO_FINDLIST)
	ckidFind = FOURCC_LIST, fccTypeFind = lpck->fccType;
    else
	ckidFind = fccTypeFind = (FOURCC) -1; // keep looking indefinitely

    for (;;) {
	lRet = shfileDescend(hshfile, lpck, lpckParent, 0);
	if (lRet) {
	    if (uFlags == 0 && lRet == MMIOERR_CHUNKNOTFOUND)
		lRet = 0;
	    return lRet;
	}

	if ((!ckidFind || lpck->ckid == ckidFind) &&
		    (!fccTypeFind || lpck->fccType == fccTypeFind))
	    return 0;

	if (lpck->ckid != mmioFOURCC('J', 'U', 'N', 'K')) {
	    lRet = (LONG) ReadIntoExtra(extra, hshfile, lpck);
	    if (lRet != AVIERR_OK)
		return lRet;
	}

	shfileAscend(hshfile, lpck, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\fileshar.cpp ===
#include <win32.h>
#include <vfw.h>
#include "debug.h"
#include "fileshar.h"

#ifdef USE_DIRECTIO
#include "directio.h"
#endif

#define MAXTASKS    10



#ifdef _WIN32
#define CurrentProcess()    ((HANDLE) GetCurrentProcessId())
#else
#define CurrentProcess()    ((HANDLE) GetCurrentPDB())
#endif

#ifdef _WIN32
#define HSHfromPSH(psh) (HSHFILE) psh
#define PSHfromHSH(hsh) (PSHFILE) hsh
#else
#define HSHfromPSH(psh) (HSHFILE) GlobalPtrHandle(psh)
#define PSHfromHSH(hsh) (PSHFILE) GlobalLock((HGLOBAL) hsh)
#endif
//
// allow multiple processes to use the same file handle (as will happen on
// win16 and chicago when an interface pointer is simply-marshalled to another
// process that shares the same global address space).
//
// This will not happen on NT, but we retain the code structure.
//


#ifdef USE_DIRECTIO

// use unbuffered i/o direct to the disk, rather than going through
// mmio and the disk buffer. much faster for streaming reads and writes.
// open via mmio if direct io not possible (eg mmio handler installed).

#endif



typedef struct {
#ifndef DAYTONA
    TCHAR	szFile[256];
    DWORD	dwOpenFlags;
    MMIOINFO	mmioinfo;

    HANDLE	htask;
    int		i;
    LONG	lOffset;

    HANDLE	ahtask[MAXTASKS];
    HMMIO	ahmmio[MAXTASKS];
    ULONG	ulRef[MAXTASKS];
#else
    ULONG       ulRef;
#endif


    HMMIO	hmmio;

#ifdef USE_DIRECTIO
    CFileStream * pdio;
#ifndef DAYTONA
    CFileStream * adio[MAXTASKS];
#endif
#endif

} SHFILE, FAR * PSHFILE;


#ifdef DAYTONA
#define GetProperTask(psh)  (TRUE)
#else

extern "C" {
extern LPTSTR FAR lstrzcpy (LPTSTR pszTgt, LPCTSTR pszSrc, size_t cch);
extern LPSTR FAR lstrzcpyA (LPSTR pszTgt, LPCSTR pszSrc, size_t cch);
extern LPWSTR FAR lstrzcpyW (LPWSTR pszTgt, LPCWSTR pszSrc, size_t cch);
extern LPWSTR FAR lstrzcpyAtoW (LPWSTR pszTgt, LPCSTR pszSrc, size_t cch);
extern LPSTR FAR lstrzcpyWtoA (LPSTR pszTgt, LPCWSTR pszSrc, size_t cch);
} // extern "C"

BOOL GetProperTask(PSHFILE psh)
{
    HANDLE	htask = CurrentProcess();
    int		i;

    if (htask == psh->htask)
	return
#ifdef USE_DIRECTIO
        (psh->pdio != NULL) ||
#endif
		    ((psh->hmmio != 0) && (psh->hmmio != (HMMIO) -1));

    for (i = 0; i < MAXTASKS; i++) {
	if (psh->ahtask[i] == htask) {
Success:
	    psh->hmmio = psh->ahmmio[i];
	    psh->htask = htask;
	    psh->i = i;
#ifdef USE_DIRECTIO
            psh->pdio = psh->adio[i];
            if (psh->pdio != NULL) {

                psh->pdio->Seek(psh->lOffset);
                return TRUE;

            }
#endif

            mmioSeek(psh->hmmio, psh->lOffset, SEEK_SET);
	    return (psh->hmmio != 0) && (psh->hmmio != (HMMIO) -1);
	}
    }

    for (i = 0; i < MAXTASKS; i++) {
	if (psh->ahtask[i] == 0) {
	    DPF2("Re-opening handle %lx in task %x\n", psh, htask);

#ifdef USE_DIRECTIO
            psh->adio[i] = new CFileStream;
            if (!psh->adio[i]->Open(psh->szFile,
                                 (psh->dwOpenFlags & OF_READWRITE),
				 (psh->dwOpenFlags & OF_CREATE)))    {

                delete psh->adio[i];
                psh->adio[i] = NULL;
#else
            {
#endif
                psh->ahmmio[i] = mmioOpen(psh->szFile, NULL, psh->dwOpenFlags);
                psh->ahtask[i] = htask;
                if (psh->ahmmio[i] == 0) {
                    DPF("mmioOpen failed in GetProperTask!\n");
                    return FALSE;
                }
            }

	    goto Success;
	}
    }

    DPF("File handle open in too many tasks!\n");

    return FALSE;
}
#endif


HSHFILE WINAPI shfileOpen(LPTSTR szFileName, MMIOINFO FAR* lpmmioinfo,
    DWORD dwOpenFlags)
{
    PSHFILE psh = (PSHFILE) GlobalAllocPtr(GPTR | GMEM_SHARE, sizeof(SHFILE));

    if (!psh)
	return NULL;

#ifndef DAYTONA
    lstrzcpy(psh->szFile, szFileName, NUMELMS(psh->szFile));
    psh->dwOpenFlags = dwOpenFlags;
#endif


    psh->hmmio = NULL;
#ifdef USE_DIRECTIO
    if (
	// Direct I/O is broken for reading the end of files on Chicago.  Don't use it.
#ifndef DIRECTIOFORREADINGALSO
	!(dwOpenFlags & OF_CREATE) ||
#endif
	!(psh->pdio = new CFileStream) ||
	!psh->pdio->Open(
			szFileName,
			(dwOpenFlags & (OF_WRITE | OF_READWRITE)),
			(dwOpenFlags & OF_CREATE)))
    {
	if (psh->pdio)
	    delete psh->pdio;
        psh->pdio = NULL;
#else
    {
#endif
        psh->hmmio = mmioOpen(szFileName, lpmmioinfo, dwOpenFlags);

        if (psh->hmmio == 0) {
            DPF("mmioOpen failed!\n");
            GlobalFreePtr(psh);
            return NULL;
        }
    }

    //DPF("Opening handle %lx ('%s') in task %x, mode = %lx\n", psh, szFileName, CurrentProcess(), psh->dwOpenFlags);


#ifndef DAYTONA
    psh->ahmmio[0] = psh->hmmio;
    psh->ahtask[0] = psh->htask = CurrentProcess();
    psh->ulRef[0] = 1; // !!! 0?

#ifdef USE_DIRECTIO
    psh->adio[0] = psh->pdio;
#endif

#else
    psh->ulRef = 1; // !!! 0?
#endif

    return HSHfromPSH(psh);
}

UINT WINAPI shfileClose(HSHFILE hsh, UINT uFlags)
{
    PSHFILE psh = PSHfromHSH(hsh);

#ifndef DAYTONA
    int i;

    for (i = 0; i < MAXTASKS; i++) {
	if (psh->ahtask[i] && psh->ahmmio[i]) {
	    DPF("Handle %lx closed with ref count %ld in task %x\n", psh, psh->ulRef[i], psh->ahtask[i]);

#ifdef USE_DIRECTIO
            if (psh->adio[i]) {
                delete psh->adio[i];
                psh->adio[i] = NULL;
            } else
#endif
	        mmioClose(psh->ahmmio[i], 0);
	}
    }
#else
#ifdef USE_DIRECTIO
    if (psh->pdio) {
        delete psh->pdio;
        psh->pdio = NULL;
    } else
#endif
        if (psh->hmmio) {
            mmioClose(psh->hmmio, 0);
        }
#endif


    GlobalFreePtr(psh);

    return 0;
}

#ifdef USE_DIRECTIO
// if we are using direct io, we want to bypass the buffering
// schemes that are layered on top of this module. Allow them to
// determine if we are using direct io to do this.
BOOL shfileIsDirect(HSHFILE hsh)
{
    PSHFILE psh = PSHfromHSH(hsh);

    if (!GetProperTask(psh))
        return -1;

    return (psh->pdio != 0);
}

void
shfileStreamStart(HSHFILE hsh)
{
    PSHFILE psh = PSHfromHSH(hsh);

    if (!GetProperTask(psh))
        return;

    if (psh->pdio == 0) {
        return;
    }

    psh->pdio->StartStreaming();
}

void shfileStreamStop(HSHFILE hsh)
{
    PSHFILE psh = PSHfromHSH(hsh);

    if (!GetProperTask(psh))
        return;

    if (psh->pdio == 0) {
        return;
    }

    psh->pdio->StopStreaming();
}

#endif

LONG WINAPI shfileRead(HSHFILE hsh, HPSTR pch, LONG cch)
{
    PSHFILE psh = PSHfromHSH(hsh);

    if (!GetProperTask(psh))
	return -1;

#ifndef DAYTONA
    psh->lOffset += cch;
#endif

#ifdef USE_DIRECTIO
    if (psh->pdio) {
        DWORD bytes;

        if (!psh->pdio->Read((LPBYTE)pch, cch, &bytes)) {
	    return 0;
	} else {
	    return bytes;
	}
    } else
#endif
        return mmioRead(psh->hmmio, pch, cch);
}

LONG WINAPI shfileWrite(HSHFILE hsh, const char _huge* pch, LONG cch)
{
    PSHFILE psh = PSHfromHSH(hsh);

    if (!GetProperTask(psh))
	return -1;

#ifndef DAYTONA
    psh->lOffset += cch;
#endif

#ifdef USE_DIRECTIO
    if (psh->pdio) {
        DWORD bytes;

        if (!psh->pdio->Write((LPBYTE)pch, cch, &bytes)) {
	    return 0;
	} else {
	    return bytes;
	}
    } else
#endif
        return mmioWrite(psh->hmmio, pch, cch);
}

LONG WINAPI shfileSeek(HSHFILE hsh, LONG lOffset, int iOrigin)
{
    PSHFILE psh = PSHfromHSH(hsh);

    if (!GetProperTask(psh))
	return -1;

#ifdef USE_DIRECTIO
    if (psh->pdio) {

        Assert(iOrigin != SEEK_END);

        if (iOrigin == SEEK_CUR) {
            lOffset += psh->pdio->GetCurrentPosition();
        }

        psh->pdio->Seek(lOffset);

#ifndef DAYTONA
        psh->lOffset = psh->pdio->GetCurrentPosition();
        return psh->lOffset;
#else
        return psh->pdio->GetCurrentPosition();
#endif

    } else
#endif
    {

#ifdef DAYTONA
        return mmioSeek(psh->hmmio, lOffset, iOrigin);
#else
        psh->lOffset = mmioSeek(psh->hmmio, lOffset, iOrigin);

        return psh->lOffset;
#endif
    }

}

LONG WINAPI shfileZero(HSHFILE hsh, LONG lBytes)
{
    LPVOID pmem;
    LONG lToWrite = lBytes;

#define ZERO_AT_ONCE	1024
    pmem = GlobalAllocPtr(GPTR, ZERO_AT_ONCE);
    // We write out 1024 bytes at a time, with the odd bytes being written
    // in the last block.  This is probably more efficient than writing the
    // "odd" bytes first, then looping for a known number of iterations to
    // write 1024 bytes at a time.
    if (pmem) {
	LONG cbWrite = ZERO_AT_ONCE;
	while (lToWrite > 0) {
	    if (lToWrite < cbWrite) {
		cbWrite = lToWrite;
	    }
	    if (shfileWrite(hsh, (HPSTR) pmem, cbWrite) != cbWrite) {

		// The file write has failed.  This leaves the file in
		// a bad state.  It might be worth trying to position
		// the write pointer as though nothing had been written,
		// but this is problematic as there may be a serious
		// problem with the file itself.  Simply abort writing...
		lBytes = -1;
		lToWrite = 0;
		break;
	    }
	    lToWrite -= cbWrite;
	}
	GlobalFreePtr(pmem);
	return lBytes;
    } else {
	DPF("Unable to allocate 1K of zeroed memory!\n");
	shfileSeek(hsh, lBytes, SEEK_SET);
	return lBytes;
    }
}

LONG WINAPI shfileFlush(HSHFILE hsh, UINT uFlags)
{
    PSHFILE psh = PSHfromHSH(hsh);

    if (!GetProperTask(psh))
	return -1;

#ifdef USE_DIRECTIO
    if (psh->pdio) {
        if (!psh->pdio->CommitAndWait()) {
            return MMIOERR_CANNOTWRITE;
        }
    }
#endif

    return 0;
}

LONG WINAPI shfileAddRef(HSHFILE hsh)
{
    PSHFILE psh = PSHfromHSH(hsh);

    if (!GetProperTask(psh))
	return -1;
#ifdef DAYTONA
    psh->ulRef++;
#else
    ++psh->ulRef[psh->i];
    DPF2("Handle %lx in task %x: ref++ == %ld\n", psh, psh->htask, psh->ulRef[psh->i]);
#endif

    return 0;
}

LONG WINAPI shfileRelease(HSHFILE hsh)
{
    PSHFILE psh = PSHfromHSH(hsh);

    if (!GetProperTask(psh))
	return -1;

#ifdef DAYTONA
    if (--psh->ulRef <= 0)
#else
    if (--psh->ulRef[psh->i] <= 0)
#endif
    {

#ifndef DAYTONA
	DPF2("Closing handle %lx in task %x, pos = %lx\n", psh, psh->htask, psh->lOffset);
#endif

#ifdef USE_DIRECTIO
        if (psh->pdio) {
            delete psh->pdio;
            psh->pdio = 0;
        } else
#endif
        {
	    mmioClose(psh->hmmio, 0);
        }
	psh->hmmio = 0;

#ifndef DAYTONA

	psh->ahmmio[psh->i] = 0;
	psh->ahtask[psh->i] = 0;
	psh->ulRef[psh->i] = 0;
#ifdef USE_DIRECTIO
        psh->adio[psh->i] = 0;
#endif
	psh->htask = 0;
#endif


    } else {
#ifndef DAYTONA
	DPF2("Handle %lx in task %x: ref-- == %ld\n", psh, psh->htask, psh->ulRef[psh->i]);
#endif
    }


    return 0;
}

static	BYTE bPad;

MMRESULT WINAPI
shfileDescend(HSHFILE hshfile, LPMMCKINFO lpck, const LPMMCKINFO lpckParent, UINT wFlags)
{
	FOURCC		ckidFind;	// chunk ID to find (or NULL)
	FOURCC		fccTypeFind;	// form/list type to find (or NULL)

	/* figure out what chunk id and form/list type to search for */
	if (wFlags & MMIO_FINDCHUNK)
		ckidFind = lpck->ckid, fccTypeFind = 0;
	else
	if (wFlags & MMIO_FINDRIFF)
		ckidFind = FOURCC_RIFF, fccTypeFind = lpck->fccType;
	else
	if (wFlags & MMIO_FINDLIST)
		ckidFind = FOURCC_LIST, fccTypeFind = lpck->fccType;
	else
		ckidFind = fccTypeFind = 0;
	
	lpck->dwFlags = 0L;

	while (TRUE)
	{
		UINT		w;

		/* read the chunk header */
		if (shfileRead(hshfile, (HPSTR) lpck, 2 * sizeof(DWORD)) !=
		    2 * sizeof(DWORD))
			return MMIOERR_CHUNKNOTFOUND;

		/* store the offset of the data part of the chunk */
		if ((lpck->dwDataOffset = shfileSeek(hshfile, 0L, SEEK_CUR)) == -1)
			return MMIOERR_CANNOTSEEK;
		
		/* check for unreasonable chunk size */
		/* see if the chunk is within the parent chunk (if given) */
		if ((lpckParent != NULL) && ((	lpck->dwDataOffset - 8L) >=
		     (lpckParent->dwDataOffset + lpckParent->cksize)))
			return MMIOERR_CHUNKNOTFOUND;

		/* if the chunk if a 'RIFF' or 'LIST' chunk, read the
		 * form type or list type
		 */
		if ((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
		{
			if (shfileRead(hshfile, (HPSTR) &lpck->fccType,
				     sizeof(DWORD)) != sizeof(DWORD))
				return MMIOERR_CHUNKNOTFOUND;
		}
		else
			lpck->fccType = 0;

		/* if this is the chunk we're looking for, stop looking */
		if ( ((ckidFind == 0) || (ckidFind == lpck->ckid)) &&
		     ((fccTypeFind == 0) || (fccTypeFind == lpck->fccType)) )
			break;
		
		/* ascend out of the chunk and try again */
		if ((w = shfileAscend(hshfile, lpck, 0)) != 0)
			return w;
	}

	return 0;
}

MMRESULT WINAPI
shfileAscend(HSHFILE hshfile, LPMMCKINFO lpck, UINT wFlags)
{
	if (lpck->dwFlags & MMIO_DIRTY)
	{
		/* <lpck> refers to a chunk created by shfileCreateChunk();
		 * check that the chunk size that was written when
		 * shfileCreateChunk() was called is the real chunk size;
		 * if not, fix it
		 */
		DWORD		dwOffset;	// current offset in file
		DWORD		dwActualSize;	// actual size of chunk data

		if ((dwOffset = (DWORD)shfileSeek(hshfile, 0L, SEEK_CUR)) == -1)
			return MMIOERR_CANNOTSEEK;
		if ((LONG)(dwActualSize = dwOffset - lpck->dwDataOffset) < 0)
			return MMIOERR_CANNOTWRITE;

		if (LOWORD(dwActualSize) & 1)
		{
			/* chunk size is odd -- write a null pad byte */
			if (shfileWrite(hshfile, (HPSTR) &bPad, sizeof(bPad))
					!= sizeof(bPad))
				return MMIOERR_CANNOTWRITE;
			
		}

		if (lpck->cksize == (DWORD)dwActualSize)
			return 0;

		/* fix the chunk header */
		lpck->cksize = dwActualSize;
		if (shfileSeek(hshfile, lpck->dwDataOffset
				- sizeof(DWORD), SEEK_SET) == -1)
			return MMIOERR_CANNOTSEEK;
		if (shfileWrite(hshfile, (HPSTR) &lpck->cksize,
				sizeof(DWORD)) != sizeof(DWORD))
			return MMIOERR_CANNOTWRITE;
	}

	/* seek to the end of the chunk, past the null pad byte
	 * (which is only there if chunk size is odd)
	 */
	if (shfileSeek(hshfile, lpck->dwDataOffset + lpck->cksize
		+ (lpck->cksize & 1L), SEEK_SET) == -1)
		return MMIOERR_CANNOTSEEK;

	return 0;
}

MMRESULT WINAPI
shfileCreateChunk(HSHFILE hshfile, LPMMCKINFO lpck, UINT wFlags)
{
	int		iBytes;			// bytes to write
	DWORD		dwOffset;	// current offset in file

	/* store the offset of the data part of the chunk */
	if ((dwOffset = (DWORD)shfileSeek(hshfile, 0L, SEEK_CUR)) == -1)
		return MMIOERR_CANNOTSEEK;
	lpck->dwDataOffset = dwOffset + 2 * sizeof(DWORD);

	/* figure out if a form/list type needs to be written */
	if (wFlags & MMIO_CREATERIFF)
		lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
	else
	if (wFlags & MMIO_CREATELIST)
		lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
	else
		iBytes = 2 * sizeof(DWORD);

	/* write the chunk header */
	if (shfileWrite(hshfile, (HPSTR) lpck, (LONG) iBytes) != (LONG) iBytes)
		return MMIOERR_CANNOTWRITE;

	lpck->dwFlags = MMIO_DIRTY;

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\mmdebug.h ===
/*
 * johnkn's debug logging and assert macros
 *
 */
 
#ifdef __cplusplus
extern "C" {            // Assume C declarations for C++
#endif  // __cplusplus

#if !defined _INC_MMDEBUG_
#define _INC_MMDEBUG_

//
// prototypes for debug functions.
//
    #define SQUAWKNUMZ(num) #num
    #define SQUAWKNUM(num) SQUAWKNUMZ(num)
    #define SQUAWK __FILE__ "(" SQUAWKNUM(__LINE__) ") ----"
    #define DEBUGLINE __FILE__ "(" SQUAWKNUM(__LINE__) ") "
        
    #if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL

        int  WINAPI AuxDebugEx(int, LPTSTR, ...);
        VOID WINAPI AuxDebugDump (int, LPVOID, int);
        int  WINAPI DebugSetOutputLevel (int);
        LPCTSTR WINAPI AuxMMErrText (DWORD  mmr);

       #if defined DEBUG_RETAIL
        #define INLINE_BREAK
       #else
        #define INLINE_BREAK _asm {int 3}
       #endif

       #if 0
        #undef  assert
        #define assert(exp) \
            (void)((exp) ? 0 : AuxDebugEx(-2, DEBUGLINE "assert failed: " #exp "\r\n", (int)__LINE__))

        #undef  assert2
        #define assert2(exp,sz) \
            (void)((exp) ? 0 : AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (int)__LINE__))
       #else
        #undef  assert
        #define assert(exp); {\
            if (!(exp)) {\
                AuxDebugEx(-2, DEBUGLINE "assert failed: " #exp "\r\n", (int)__LINE__); \
                INLINE_BREAK;\
                }\
            }
        #undef  assert2
        #define assert2(exp,sz); {\
            if (!(exp)) {\
                AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (int)__LINE__); \
                INLINE_BREAK;\
                }\
            }
        #undef  assert3
        #define assert3(exp,sz,arg); {\
            if (!(exp)) {\
                AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (int)__LINE__, (arg)); \
                INLINE_BREAK;\
                }\
            }
       #endif

       #define AuxMMR(api,mmr) (mmr) ? AuxDebugEx(1, DEBUGLINE #api " error %d '%s'\r\n", mmr, AuxMMErrText(mmr)) : (int)0


    #else // defined(DEBUG)
                      
      #define AuxDebugEx  1 ? (void)0 :
      #define AuxDebugDump(a,b,c)
      
      #define assert(a)      ((void)0)
      #define assert2(a,b)   ((void)0)
      #define assert3(a,b,c) ((void)0)

      #define INLINE_BREAK
      #define DebugSetOutputLevel(i)
      #define AuxMMErrText(mmr)
      #define AuxMMR(api,mmr)


   #endif // defined(DEBUG)
   
   #define AuxDebug(sz) AuxDebugEx (1, DEBUGLINE sz "\r\n")
   #define AuxDebug2(sz,a) AuxDebugEx (1, DEBUGLINE sz "\r\n", (a))
   

#ifdef __cplusplus
}             // Assume C declarations for C++
#endif  // __cplusplus

#endif //_INC_MMDEBUG_

// =============================================================================

//
// include this in only one module in a DLL or APP
//   
#if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL
    #if (defined _INC_MMDEBUG_CODE_) && (_INC_MMDEBUG_CODE_ != FALSE)
    #undef _INC_MMDEBUG_CODE_
    #define _INC_MMDEBUG_CODE_ FALSE
       
    #include <stdarg.h>   

    int    debug_OutputOn = 0;

    /*+ AuxDebug - create a formatted string and output to debug terminal
     *
     *-=================================================================*/
    
    int WINAPI AuxDebugEx (
       int    iLevel,
       LPTSTR lpFormat,
       ...)
       {
       char     szBuf[1024];
       int      cb;
       va_list  va;
                
       if (debug_OutputOn >= iLevel)
          {
          va_start (va, lpFormat);
          cb = wvsprintfA (szBuf, lpFormat, va);
          va_end (va);
          OutputDebugString (szBuf);
          }
    
       return cb;
       }

    /*+ AuxDebugDump -
     *
     *-=================================================================*/
    
    VOID WINAPI AuxDebugDump (
       int    iLevel,
       LPVOID lpvData,
       int    nCount)
       {
       LPBYTE   lpData = lpvData;
       char     szBuf[128];
       char *   psz;
       int      cb;
       int      ix;
       BYTE     abRow[8];
                
       if (debug_OutputOn <= iLevel || nCount <= 0)
          return;

       do {
          cb = wsprintf (szBuf, "\t%08X: ", lpData);
          psz = szBuf + cb;

          for (ix = 0; ix < 8; ++ix)
             {
             LPBYTE lpb = lpData;

             abRow[ix] = '.';
             if (IsBadReadPtr (lpData + ix, 1))
                lstrcpy (psz, ".. ");
             else
                {
                wsprintf (psz, "%02X ", lpData[ix]);
                if (lpData[ix] >= 32 && lpData[ix] < 127)
                    abRow[ix] = lpData[ix];
                }
             psz += 3;
             }
          for (ix = 0; ix < 8; ++ix)
             *psz++ = abRow[ix];

          lstrcpy (psz, "\r\n");

          OutputDebugString (szBuf);

          } while (lpData += 8, (nCount -= 8) > 0);

       return;
       }

    /*+ AuxMMErrText
     *
     *-=================================================================*/
    
   LPCTSTR WINAPI AuxMMErrText (
      DWORD  mmr)
   {
      static struct _mmerrors {
         DWORD    mmr;
         LPCTSTR  psz;
         } aMMErr[] = {
            MMSYSERR_NOERROR      ,"Success",
            MMSYSERR_ERROR        ,"unspecified error",
            MMSYSERR_BADDEVICEID  ,"device ID out of range",
            MMSYSERR_NOTENABLED   ,"driver failed enable",
            MMSYSERR_ALLOCATED    ,"device already allocated",
            MMSYSERR_INVALHANDLE  ,"device handle is invalid",
            MMSYSERR_NODRIVER     ,"no device driver present",
            MMSYSERR_NOMEM        ,"memory allocation error",
            MMSYSERR_NOTSUPPORTED ,"function isn't supported",
            MMSYSERR_BADERRNUM    ,"error value out of range",
            MMSYSERR_INVALFLAG    ,"invalid flag passed",
            MMSYSERR_INVALPARAM   ,"invalid parameter passed",
           #if (WINVER >= 0x0400)
            MMSYSERR_HANDLEBUSY   ,"handle in use by another thread",
            MMSYSERR_INVALIDALIAS ,"specified alias not found",
            MMSYSERR_BADDB        ,"bad registry database",
            MMSYSERR_KEYNOTFOUND  ,"registry key not found",
            MMSYSERR_READERROR    ,"registry read error",
            MMSYSERR_WRITEERROR   ,"registry write error",
            MMSYSERR_DELETEERROR  ,"registry delete error",
            MMSYSERR_VALNOTFOUND  ,"registry value not found",
           #endif

            WAVERR_BADFORMAT      ,"wave:unsupported wave format",
            WAVERR_STILLPLAYING   ,"wave:still something playing",
            WAVERR_UNPREPARED     ,"wave:header not prepared",
            WAVERR_SYNC           ,"wave:device is synchronous",

            MIDIERR_UNPREPARED    ,"midi:header not prepared",
            MIDIERR_STILLPLAYING  ,"midi:still something playing",
            //MIDIERR_NOMAP         ,"midi:no configured instruments",
            MIDIERR_NOTREADY      ,"midi:hardware is still busy",
            MIDIERR_NODEVICE      ,"midi:port no longer connected",
            MIDIERR_INVALIDSETUP  ,"midi:invalid MIF",
            MIDIERR_BADOPENMODE   ,"midi:operation unsupported w/ open mode",

            TIMERR_NOCANDO        ,"timer: request not completed",
            JOYERR_PARMS          ,"joy:bad parameters",
            JOYERR_NOCANDO        ,"joy:request not completed",
            JOYERR_UNPLUGGED      ,"joystick is unplugged",

            MCIERR_INVALID_DEVICE_ID        ,"MCIERR_INVALID_DEVICE_ID",
            MCIERR_UNRECOGNIZED_KEYWORD     ,"MCIERR_UNRECOGNIZED_KEYWORD",
            MCIERR_UNRECOGNIZED_COMMAND     ,"MCIERR_UNRECOGNIZED_COMMAND",
            MCIERR_HARDWARE                 ,"MCIERR_HARDWARE",
            MCIERR_INVALID_DEVICE_NAME      ,"MCIERR_INVALID_DEVICE_NAME",
            MCIERR_OUT_OF_MEMORY            ,"MCIERR_OUT_OF_MEMORY",
            MCIERR_DEVICE_OPEN              ,"MCIERR_DEVICE_OPEN",
            MCIERR_CANNOT_LOAD_DRIVER       ,"MCIERR_CANNOT_LOAD_DRIVER",
            MCIERR_MISSING_COMMAND_STRING   ,"MCIERR_MISSING_COMMAND_STRING",
            MCIERR_PARAM_OVERFLOW           ,"MCIERR_PARAM_OVERFLOW",
            MCIERR_MISSING_STRING_ARGUMENT  ,"MCIERR_MISSING_STRING_ARGUMENT",
            MCIERR_BAD_INTEGER              ,"MCIERR_BAD_INTEGER",
            MCIERR_PARSER_INTERNAL          ,"MCIERR_PARSER_INTERNAL",
            MCIERR_DRIVER_INTERNAL          ,"MCIERR_DRIVER_INTERNAL",
            MCIERR_MISSING_PARAMETER        ,"MCIERR_MISSING_PARAMETER",
            MCIERR_UNSUPPORTED_FUNCTION     ,"MCIERR_UNSUPPORTED_FUNCTION",
            MCIERR_FILE_NOT_FOUND           ,"MCIERR_FILE_NOT_FOUND",
            MCIERR_DEVICE_NOT_READY         ,"MCIERR_DEVICE_NOT_READY",
            MCIERR_INTERNAL                 ,"MCIERR_INTERNAL",
            MCIERR_DRIVER                   ,"MCIERR_DRIVER",
            MCIERR_CANNOT_USE_ALL           ,"MCIERR_CANNOT_USE_ALL",
            MCIERR_MULTIPLE                 ,"MCIERR_MULTIPLE",
            MCIERR_EXTENSION_NOT_FOUND      ,"MCIERR_EXTENSION_NOT_FOUND",
            MCIERR_OUTOFRANGE               ,"MCIERR_OUTOFRANGE",
            MCIERR_FLAGS_NOT_COMPATIBLE     ,"MCIERR_FLAGS_NOT_COMPATIBLE",
            MCIERR_FILE_NOT_SAVED           ,"MCIERR_FILE_NOT_SAVED",
            MCIERR_DEVICE_TYPE_REQUIRED     ,"MCIERR_DEVICE_TYPE_REQUIRED",
            MCIERR_DEVICE_LOCKED            ,"MCIERR_DEVICE_LOCKED",
            MCIERR_DUPLICATE_ALIAS          ,"MCIERR_DUPLICATE_ALIAS",
            MCIERR_BAD_CONSTANT             ,"MCIERR_BAD_CONSTANT",
            MCIERR_MUST_USE_SHAREABLE       ,"MCIERR_MUST_USE_SHAREABLE",
            MCIERR_MISSING_DEVICE_NAME      ,"MCIERR_MISSING_DEVICE_NAME",
            MCIERR_BAD_TIME_FORMAT          ,"MCIERR_BAD_TIME_FORMAT",
            MCIERR_NO_CLOSING_QUOTE         ,"MCIERR_NO_CLOSING_QUOTE",
            MCIERR_DUPLICATE_FLAGS          ,"MCIERR_DUPLICATE_FLAGS",
            MCIERR_INVALID_FILE             ,"MCIERR_INVALID_FILE",
            MCIERR_NULL_PARAMETER_BLOCK     ,"MCIERR_NULL_PARAMETER_BLOCK",
            MCIERR_UNNAMED_RESOURCE         ,"MCIERR_UNNAMED_RESOURCE",
            MCIERR_NEW_REQUIRES_ALIAS       ,"MCIERR_NEW_REQUIRES_ALIAS",
            MCIERR_NOTIFY_ON_AUTO_OPEN      ,"MCIERR_NOTIFY_ON_AUTO_OPEN",
            MCIERR_NO_ELEMENT_ALLOWED       ,"MCIERR_NO_ELEMENT_ALLOWED",
            MCIERR_NONAPPLICABLE_FUNCTION   ,"MCIERR_NONAPPLICABLE_FUNCTION",
            MCIERR_ILLEGAL_FOR_AUTO_OPEN    ,"MCIERR_ILLEGAL_FOR_AUTO_OPEN",
            MCIERR_FILENAME_REQUIRED        ,"MCIERR_FILENAME_REQUIRED",
            MCIERR_EXTRA_CHARACTERS         ,"MCIERR_EXTRA_CHARACTERS",
            MCIERR_DEVICE_NOT_INSTALLED     ,"MCIERR_DEVICE_NOT_INSTALLED",
            MCIERR_GET_CD                   ,"MCIERR_GET_CD",
            MCIERR_SET_CD                   ,"MCIERR_SET_CD",
            MCIERR_SET_DRIVE                ,"MCIERR_SET_DRIVE",
            MCIERR_DEVICE_LENGTH            ,"MCIERR_DEVICE_LENGTH",
            MCIERR_DEVICE_ORD_LENGTH        ,"MCIERR_DEVICE_ORD_LENGTH",
            MCIERR_NO_INTEGER               ,"MCIERR_NO_INTEGER",
            MCIERR_WAVE_OUTPUTSINUSE        ,"MCIERR_WAVE_OUTPUTSINUSE",
            MCIERR_WAVE_SETOUTPUTINUSE      ,"MCIERR_WAVE_SETOUTPUTINUSE",
            MCIERR_WAVE_INPUTSINUSE         ,"MCIERR_WAVE_INPUTSINUSE",
            MCIERR_WAVE_SETINPUTINUSE       ,"MCIERR_WAVE_SETINPUTINUSE",
            MCIERR_WAVE_OUTPUTUNSPECIFIED   ,"MCIERR_WAVE_OUTPUTUNSPECIFIED",
            MCIERR_WAVE_INPUTUNSPECIFIED    ,"MCIERR_WAVE_INPUTUNSPECIFIED",
            MCIERR_WAVE_OUTPUTSUNSUITABLE   ,"MCIERR_WAVE_OUTPUTSUNSUITABLE",
            MCIERR_WAVE_SETOUTPUTUNSUITABLE ,"MCIERR_WAVE_SETOUTPUTUNSUITABLE",
            MCIERR_WAVE_INPUTSUNSUITABLE    ,"MCIERR_WAVE_INPUTSUNSUITABLE",
            MCIERR_WAVE_SETINPUTUNSUITABLE  ,"MCIERR_WAVE_SETINPUTUNSUITABLE",
            MCIERR_SEQ_DIV_INCOMPATIBLE     ,"MCIERR_SEQ_DIV_INCOMPATIBLE",
            MCIERR_SEQ_PORT_INUSE           ,"MCIERR_SEQ_PORT_INUSE",
            MCIERR_SEQ_PORT_NONEXISTENT     ,"MCIERR_SEQ_PORT_NONEXISTENT",
            MCIERR_SEQ_PORT_MAPNODEVICE     ,"MCIERR_SEQ_PORT_MAPNODEVICE",
            MCIERR_SEQ_PORT_MISCERROR       ,"MCIERR_SEQ_PORT_MISCERROR",
            MCIERR_SEQ_TIMER                ,"MCIERR_SEQ_TIMER",
            MCIERR_SEQ_PORTUNSPECIFIED      ,"MCIERR_SEQ_PORTUNSPECIFIED",
            MCIERR_SEQ_NOMIDIPRESENT        ,"MCIERR_SEQ_NOMIDIPRESENT",
            MCIERR_NO_WINDOW                ,"MCIERR_NO_WINDOW",
            MCIERR_CREATEWINDOW             ,"MCIERR_CREATEWINDOW",
            MCIERR_FILE_READ                ,"MCIERR_FILE_READ",
            MCIERR_FILE_WRITE               ,"MCIERR_FILE_WRITE",
            MCIERR_NO_IDENTITY              ,"MCIERR_NO_IDENTITY",

            MIXERR_INVALLINE            ,"Invalid Mixer Line",
            MIXERR_INVALCONTROL         ,"Invalid Mixer Control",
            MIXERR_INVALVALUE           ,"Invalid Mixer Value",

            MIXERR_INVALVALUE+1         , "unknown error %d"
            };

      UINT uRemain = sizeof(aMMErr)/sizeof(aMMErr[0]);
      UINT uUpper  = uRemain-1;
      UINT uLower  = 0;
      static char szTemp[50];

      if (mmr <= aMMErr[uUpper].mmr)
      {
         // binary search for mmr match, if match
         // return string pointer
         //
         while (--uRemain)
         {
            UINT ii = (uLower + uUpper) >> 1;

            if (aMMErr[ii].mmr < mmr)
            {
               if (uLower == ii)
                  break;
               uLower = ii;
            }
            else if (aMMErr[ii].mmr > mmr)
            {
               if (uUpper == ii)
                  break;
               uUpper = ii;
            }
            else
            {
               return aMMErr[ii].psz;
               break;
            }
         }

         // we can only get to here if no match was found for
         // the error id.
         //
         if ( ! uRemain)
         {
            int ix;

            INLINE_BREAK;

            for (ix = 0; ix < sizeof(aMMErr)/sizeof(aMMErr[0])-1; ++ix)
            {
                assert (aMMErr[ix].mmr < aMMErr[ix+1].mmr);
            }
            lstrcpy (szTemp, "#### Fatal Error! error table not sorted!");
            return szTemp;
         }
      }

      wsprintf (szTemp, aMMErr[uUpper].psz, mmr);
      return szTemp;
   }


    /*+ DebugSetOutputLevel
     *
     *-=================================================================*/
    
    BOOL  WINAPI DebugSetOutputLevel (
        int nLevel)
        {      
        int nOldLevel = debug_OutputOn;
        debug_OutputOn = nLevel;
        return nOldLevel;
        }

   #endif // _INC_MMDEBUG_CODE_
#endif // DEBUG || _DEBUG    

#ifdef __cplusplus
}             // Assume C declarations for C++
#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\getframe.cpp ===
/****************************************************************************
 *
 *  GETFRAME.CPP
 *
 *  this file contains the GetFrame APIs
 *
 *      AVIStreamGetFrameOpen
 *      AVIStreamGetFrameClose
 *      AVIStreamGetFrame
 *
 *  it also contains the default GetFrame implemenation
 *
 *      GetFrameDef
 *
 ***************************************************************************/

#include <win32.h>
#include <vfw.h>
#include <memory.h>             // for _fmemset

#include "debug.h"              // for good ol' DPF()


/****************************************************************************
 *
 ***************************************************************************/

//!!! ACK
#define AVISF_VIDEO_PALCHANGES          0x00010000

#define ERR_FAIL   ResultFromScode(E_FAIL)
#define ERR_MEMORY ResultFromScode(E_OUTOFMEMORY)

#define WIDTHBYTES(i)       ((UINT)((i+31)&(~31))/8)
#define DIBWIDTHBYTES(lpbi) (UINT)WIDTHBYTES((UINT)(lpbi)->biWidth * (UINT)(lpbi)->biBitCount)

/****************************************************************************
 *
 *  class for default IGetFrame
 *
 ***************************************************************************/

class FAR GetFrameDef : public IGetFrame
{
public:
    GetFrameDef(IAVIStream FAR *pavi=NULL);

public:
    // IUnknown stuff

    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IGetFrame stuff.

    STDMETHODIMP Begin              (LONG lStart, LONG lEnd, LONG lRate);
    STDMETHODIMP End                ();

    STDMETHODIMP SetFormat          (LPBITMAPINFOHEADER lpbi, LPVOID lpBits, int x, int y, int dx, int dy);

    STDMETHODIMP_(LPVOID) GetFrame  (LONG lPos);

private:
    ~GetFrameDef();
    void FreeStuff();

    // for AddRef
    ULONG   ulRefCount;

    // instance data.
    BOOL                        fBegin;         // inside of Begin/End
    BOOL                        fFmtChanges;    // file has format changes.

    PAVISTREAM			pavi;
    LONG                        lFrame;         // last frame decompressed

    LPVOID                      lpBuffer;       // read buffer.
    LONG                        cbBuffer;       // size of read buffer
    LPVOID                      lpFormat;       // stream format
    LONG                        cbFormat;       // size of format

    LPVOID                      lpFrame;        // the frame (format)
    LPVOID                      lpBits;         // the frame (bits)
    HIC                         hic;            // decompress handle

    BOOL                        fDecompressEx;  // using ICDecompressEx
    int                         x,y,dx,dy;      // where to decompress

    // to watch for the format changing.
    DWORD			dwFormatChangeCount;
    DWORD			dwEditCount;
};

/****************************************************************************

 IUnknown stuff.

 ***************************************************************************/

STDMETHODIMP GetFrameDef::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (riid == IID_IGetFrame ||
        riid == IID_IUnknown) {     //!!! should we do Unknown or pass on?

        *ppv = (LPVOID)this;
        AddRef();
        return ResultFromScode(S_OK);
    }
    else if (pavi) {
        return pavi->QueryInterface(riid, ppv);
    }
    else {
        *ppv = NULL;
        return ResultFromScode(E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG) GetFrameDef::AddRef()
{
    return ulRefCount++;
}

STDMETHODIMP_(ULONG) GetFrameDef::Release()
{
    if (--ulRefCount == 0) {
        delete this;
        return 0;
    }
    return ulRefCount;
}

/****************************************************************************
 ***************************************************************************/

GetFrameDef::GetFrameDef(IAVIStream FAR *pavi)
{
    this->pavi = pavi;

    ulRefCount = 1;

    fBegin = FALSE;
    fFmtChanges = FALSE;
    fDecompressEx = FALSE;

    lFrame = -4242;

    lpBuffer = NULL;
    lpFormat = NULL;
    cbBuffer = 0;
    cbFormat = 0;

    lpFrame = NULL;
    lpBits  = NULL;
    hic     = NULL;

    if (this->pavi == NULL)
        return;

    pavi->AddRef();
}

/****************************************************************************
 ***************************************************************************/

GetFrameDef::~GetFrameDef()
{
    FreeStuff();

    if (pavi)
        pavi->Release();
}

/****************************************************************************
 ***************************************************************************/

void GetFrameDef::FreeStuff()
{
    if (this->lpFrame && this->lpFrame != this->lpFormat) {
        GlobalFreePtr(this->lpFrame);
        this->lpFrame = 0;
    }

    if (this->lpFormat) {
        GlobalFreePtr(this->lpFormat);
        this->lpFormat = 0;
    }

    if (this->hic) {

        if (this->fDecompressEx)
            ICDecompressExEnd(this->hic);
        else
            ICDecompressEnd(this->hic);

        ICClose(this->hic);
        this->hic = 0;
    }
}

/****************************************************************************
 ***************************************************************************/

STDMETHODIMP GetFrameDef::SetFormat(LPBITMAPINFOHEADER lpbi, LPVOID lpBits, int x, int y, int dx, int dy)
{
    LPBITMAPINFOHEADER	lpbiC;
    LPBITMAPINFOHEADER	lpbiU;
    LRESULT		dw;
    DWORD		fccHandler;
    AVISTREAMINFOW      info;
    BOOL                fScreen;

    //
    // lpbi == AVIGETFRAMEF_BESTDISPLAYFMT means choose the best format for the
    // screen.
    //
    if (fScreen = (lpbi == (LPBITMAPINFOHEADER)AVIGETFRAMEF_BESTDISPLAYFMT))
        lpbi = NULL;

    //
    // get the vital stats
    //
    _fmemset(&info, 0, sizeof(info));
    pavi->Info(&info, sizeof(info));

    //
    //  is this a video stream?
    //
    if (info.fccType != streamtypeVIDEO)
        return ERR_FAIL;

    this->fBegin = FALSE;
    this->fFmtChanges = (info.dwFlags & AVISF_VIDEO_PALCHANGES) != 0;

    this->dwEditCount = info.dwEditCount;
    this->dwFormatChangeCount = info.dwFormatChangeCount;

    //
    // get the stream format
    //
    if (this->lpFormat == NULL) {

        //
        // alocate a read buffer.
        //
        this->cbBuffer = (LONG)info.dwSuggestedBufferSize;

	if (this->cbBuffer == 0)
	    this->cbBuffer = 1024;

        AVIStreamFormatSize(this->pavi,
			    AVIStreamStart(this->pavi),
                            &this->cbFormat);

        this->lpFormat = GlobalAllocPtr(GHND,this->cbFormat + this->cbBuffer);

	if (this->lpFormat == NULL)
	    goto error;

	AVIStreamReadFormat(this->pavi, AVIStreamStart(this->pavi),
			    this->lpFormat, &this->cbFormat);

	this->lpBuffer = (LPBYTE)this->lpFormat+this->cbFormat;
    }

    lpbiC = (LPBITMAPINFOHEADER)this->lpFormat;

    //
    // do standard BITMAPINFO header cleanup!
    //
    if (lpbiC->biClrUsed == 0 && lpbiC->biBitCount <= 8)
	lpbiC->biClrUsed = (1 << (int)lpbiC->biBitCount);

    if (lpbiC->biSizeImage == 0 && lpbiC->biCompression == BI_RGB)
	lpbiC->biSizeImage = DIBWIDTHBYTES(lpbiC) * lpbiC->biHeight;

    //
    // if the stream is uncompressed, we dont need a decompress buffer
    // make sure the caller hs not suggested a format first.
    //
    if (lpbiC->biCompression == 0 && lpBits == NULL) {

	if (lpbi == NULL ||
	   (lpbi->biCompression == lpbiC->biCompression &&
	    lpbi->biWidth	== lpbiC->biWidth &&
	    lpbi->biHeight	== lpbiC->biHeight &&
	    lpbi->biBitCount	== lpbiC->biBitCount)) {


	    this->lpBits = (LPBYTE)lpbiC + (int)lpbiC->biSize +
		(int)lpbiC->biClrUsed * sizeof(RGBQUAD);

	    goto done;
	}
    }

    //
    // alocate the decompress buffer.
    //
    if (this->lpFrame == NULL) {

        this->lpFrame = GlobalAllocPtr(GHND,
            sizeof(BITMAPINFOHEADER)+256*sizeof(RGBQUAD));

        if (this->lpFrame == NULL) {
	    DPF("GetFrameInit: Can't allocate frame buffer!\n");
	    goto error;
        }
    }

    lpbiC = (LPBITMAPINFOHEADER)this->lpFormat;
    lpbiU = (LPBITMAPINFOHEADER)this->lpFrame;

    if (this->hic == NULL) {

        if (lpbiC->biCompression == 0)
            fccHandler = mmioFOURCC('D','I','B',' ');
        else if (lpbiC->biCompression == BI_RLE8)
            fccHandler = mmioFOURCC('R','L','E',' ');
        else
            fccHandler = info.fccHandler;

        if (lpbi) {
            if (lpbi->biWidth == 0)
                lpbi->biWidth = lpbiC->biWidth;

            if (lpbi->biHeight == 0)
                lpbi->biHeight = lpbiC->biHeight;
        }

        this->hic = ICDecompressOpen(ICTYPE_VIDEO, /*info.fccType,*/
                                   fccHandler,lpbiC,lpbi);

        if (this->hic == NULL) {
	    DPF("GetFrameInit: Can't find decompressor!\n");
	    goto error;
        }
    }

    if (lpbi) {
        if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
            lpbi->biClrUsed = (1 << (int)lpbi->biBitCount);
	
        hmemcpy(lpbiU,lpbi,lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD));

        if (lpbi->biBitCount <= 8) {
            ICDecompressGetPalette(this->hic,lpbiC,lpbiU);
        }
    } else if (fScreen) {

        ICGetDisplayFormat(this->hic, lpbiC, lpbiU, 0, dx, dy);

    } else {
        dw = ICDecompressGetFormat(this->hic,lpbiC,lpbiU);

	if ((LONG)dw < ICERR_OK)
	    goto error;
    }

    //
    // do standard BITMAPINFO header cleanup!
    //
    if (lpbiU->biClrUsed == 0 && lpbiU->biBitCount <= 8)
        lpbiU->biClrUsed = (1 << (int)lpbiU->biBitCount);

    if (lpbiU->biSizeImage == 0 && lpbiU->biCompression == BI_RGB)
        lpbiU->biSizeImage = DIBWIDTHBYTES(lpbiU) * lpbiU->biHeight;

    //
    // if we were passed a bits pointer, use it else re-alloc lpFrame
    // to contain the bits too.
    //
    if (lpBits) {
        this->lpBits = lpBits;
    }
    else {
        this->lpFrame = GlobalReAllocPtr(this->lpFrame,lpbiU->biSize +
            lpbiU->biSizeImage +
            lpbiU->biClrUsed * sizeof(RGBQUAD), GMEM_MOVEABLE);

        if (this->lpFrame == NULL) {
            DPF("GetFrameInit: Can't resize frame buffer!\n");
	    goto error;
        }

        lpbiU = (LPBITMAPINFOHEADER)this->lpFrame;

        this->lpBits = (LPBYTE)lpbiU + (int)lpbiU->biSize +
                (int)lpbiU->biClrUsed * sizeof(RGBQUAD);
    }

    //
    // use ICDecompressEx if we need to.  we need DecompressEx if
    // we are decompressing into a smaller area of the DIB, not the
    // whole surface.
    //
    if (dx == -1)
        dx = (int)lpbiU->biWidth;

    if (dy == -1)
        dy = (int)lpbiU->biHeight;

    this->fDecompressEx = (x != 0 || y != 0 ||
        dy != (int)lpbiU->biHeight || dx != (int)lpbiU->biWidth);

    if (this->fDecompressEx) {

        this->x = x;
        this->y = y;
        this->dx = dx;
        this->dy = dy;

        dw = ICDecompressExBegin(this->hic, 0,
            lpbiC, NULL, 0, 0, lpbiC->biWidth, lpbiC->biHeight,
            lpbiU, NULL, x, y, dx, dy);
    }
    else {
        dw = ICDecompressBegin(this->hic,lpbiC,lpbiU);
    }

    if (dw != ICERR_OK) {
        DPF("GetFrameSetFormat: ICDecompressBegin failed!\n");
	goto error;
    }

done:
    this->lFrame = -4224;   // bogus value
    return AVIERR_OK;

error:
    FreeStuff();
    return ERR_FAIL;
}

/****************************************************************************
 ***************************************************************************/

STDMETHODIMP GetFrameDef::Begin(LONG lStart, LONG lEnd, LONG lRate)
{
    fBegin = TRUE;
    GetFrame(lStart);

    return AVIERR_OK;
}

/****************************************************************************
 ***************************************************************************/

STDMETHODIMP GetFrameDef::End()
{
    fBegin = FALSE;
    return AVIERR_OK;
}

/****************************************************************************
 ***************************************************************************/

STDMETHODIMP_(LPVOID) GetFrameDef::GetFrame(LONG lPos)
{
    LPBITMAPINFOHEADER	    lpbiC;
    LPBITMAPINFOHEADER	    lpbiU;
    LONG                    l;
    LONG                    lKey;
    LONG		    lBytes;
    LONG		    lSize;
    LONG		    lRead;
    LRESULT                 err;
    AVISTREAMINFOW          info;
    HRESULT		    hr;

    if (!this->pavi) {
	DPF("AVIStreamGetFrame: bad pointer\n");
	return NULL;
    }

    if (this->lpFormat == NULL) {
        return NULL;
    }

    //
    // if we are not in a Begin/End pair check for the format changing etc.
    //
    if (!this->fBegin) {

        _fmemset(&info, 0, sizeof(info));
        this->pavi->Info(&info, sizeof(info));

        if (info.dwFormatChangeCount != dwFormatChangeCount) {

            DPF("AVIStreamGetFrame: format has changed\n");

	    if (this->lpFrame) {
		BITMAPINFOHEADER bi = *((LPBITMAPINFOHEADER)this->lpFrame);

		FreeStuff();    // nuke it all.

		if (SetFormat(&bi, NULL, 0, 0, -1, -1) != 0 &&
		    SetFormat(NULL, NULL, 0, 0, -1, -1) != 0)

		    return NULL;
	    } else {
		if (SetFormat(NULL, NULL, 0, 0, -1, -1) != 0) {
		    return NULL;
		}
	    }
        }

        if (info.dwEditCount != dwEditCount) {
            DPF("AVIStreamGetFrame: stream has been edited (%lu)\n", info.dwEditCount);
            dwEditCount = info.dwEditCount;
            this->lFrame = -4224;     // Invalidate the cached frame
        }
    }

    //
    // quick check for the last frame.
    //
    if (this->lFrame == lPos)
        return this->hic ? this->lpFrame : this->lpFormat;

    //
    // locate the nearest key frame.
    //
    lKey = AVIStreamFindSample(this->pavi, lPos, FIND_KEY|FIND_PREV);

    //
    // either lPos was out of range or some internal error!
    //
    if (lKey == -1) {
	DPF("AVIStreamGetFrame: Couldn't find key frame!\n");
	return NULL;
    }

    //
    // we need to go back to the specifed key frame
    // or our current frame witch ever is closer
    //
    if (this->lFrame < lPos && this->lFrame >= lKey)
        lKey = this->lFrame + 1;

    lpbiC = (LPBITMAPINFOHEADER)this->lpFormat;
    lpbiU = (LPBITMAPINFOHEADER)this->lpFrame;

    //
    // decompress frame data from key frame to current frame.
    //
    for (l=lKey; l<=lPos; l++) {

        //
	// go read the format and call ICDecompressGetPalette() so
	// if the palette changes things will work.
	//
        if (this->fFmtChanges) {

            AVIStreamReadFormat(this->pavi, l, lpbiC, &this->cbFormat);
	
	    if (lpbiU && lpbiU->biBitCount <= 8) {
                ICDecompressGetPalette(this->hic,lpbiC,lpbiU);
	    }
	}

try_read_again:
        hr = AVIStreamRead(this->pavi, l, 1,
            this->lpBuffer, this->cbBuffer, &lBytes, &lRead);

        //
        // the read failed, mabey our buffer was too small
        // or it was a real error.
        //
        if (hr != NOERROR) {

            DPF("AVIStreamGetFrame: AVIStreamRead returns %lx\n", (DWORD) hr);

            lSize = 0;
            hr = AVIStreamSampleSize(this->pavi, l, &lSize);

            if (lSize > this->cbBuffer) {
                LPVOID lp;

                DPF("AVIStreamGetFrame: re-sizing read buffer from %ld to %ld\n", this->cbBuffer, lSize);

		lp = GlobalReAllocPtr(this->lpFormat,this->cbFormat+lSize,0);

                if (lp == NULL) {
                    DPF("AVIStreamGetFrame: Couldn't resize buffer\n");
                    return NULL;
                }

		this->lpFormat = lp;
		lpbiC = (LPBITMAPINFOHEADER)this->lpFormat;
		this->lpBuffer = (LPBYTE)lp + this->cbFormat;
                this->cbBuffer = lSize;

                goto try_read_again;
            }
	}

	if (lRead != 1) {
	    DPF("AVIStreamGetFrame: AVIStreamRead failed!\n");
	    return NULL;
	}

	if (lBytes == 0)
	    continue;

	lpbiC->biSizeImage = lBytes;

	if (this->hic == NULL) {
	    this->lFrame = lPos;
	    return this->lpFormat;
	}
	else if (this->fDecompressEx) {
            err = ICDecompressEx(this->hic,0,
                lpbiC,this->lpBuffer,
                0,0,(int)lpbiC->biWidth,(int)lpbiC->biHeight,
                lpbiU,this->lpBits,
                this->x,this->y,this->dx,this->dy);
        }
        else {
            err = ICDecompress(this->hic,0,
                lpbiC,this->lpBuffer,lpbiU,this->lpBits);
        }

        // !!! Error check?

        if (err < 0) {
	}
    }

    this->lFrame = lPos;
    return this->hic ? this->lpFrame : this->lpFormat;
}

/********************************************************************
* @doc EXTERNAL AVIStreamGetFrameOpen
*
* @api PGETFRAME | AVIStreamGetFrameOpen | This functions prepares
*      to decompress video frames from the stream specified.
*
* @parm PAVISTREAM | pavi | Specifies a pointer to the
*       stream used as the video source.
*
* @parm LPBITMAPINFOHEADER | lpbiWanted | Specifies a pointer to
*       a structure defining the desired  video format.  If this is NULL,
*       a default format is used.
*
* @rdesc Returns a GetFrame object, which can be used with
*	<f AVIStreamGetFrame>.
*
*	If the system can't find decompressor that can decompress the stream
*	to the format given, or to any RGB format, the function returns NULL.
*
* @comm The <p pavi> parameter must specify a video stream.
*
*	This is essentially just a helper function to handle a simple form
*	of decompression.
*
* @xref <f AVIStreamGetFrame> <f AVIStreamGetFrameClose>
**********************************************************************/
STDAPI_(PGETFRAME) AVIStreamGetFrameOpen(PAVISTREAM pavi, LPBITMAPINFOHEADER lpbiWanted)
{
    PGETFRAME pgf=NULL;

    //
    // first ask the IAVIStream object if it can handle IGetFrame and
    // if it can let it do it.
    //
    pavi->QueryInterface(IID_IGetFrame, (LPVOID FAR *)&pgf);

    if (pgf == NULL) {
        //
        // the stream can't do it, make our own object.
        //
        pgf = new GetFrameDef(pavi);
    }

    //
    // set the format the caller wants
    //
    if (pgf->SetFormat(lpbiWanted, NULL, 0, 0, -1, -1)) {
        DPF("AVIStreamGetFrameOpen: unable to set format\n");
        pgf->Release();
        return NULL;
    }

    return pgf;
}

/********************************************************************
* @doc EXTERNAL AVIStreamGetFrameClose
*
* @api LONG | AVIStreamGetFrameClose | This function releases resources
*	used to decompress video frames.
*
* @parm PGETFRAME | pget | Specifies a handle returned from <f AVIStreamGetFrameOpen>.
*	After calling this function, the handle is invalid.
*
* @rdesc Returns an error code.
*
* @xref <f AVIStreamGetFrameOpen> <f AVIStreamGetFrame>
**********************************************************************/
STDAPI AVIStreamGetFrameClose(PGETFRAME pgf)
{
    if (pgf)
        pgf->Release();

    return AVIERR_OK;
}

/********************************************************************
* @doc EXTERNAL AVIStreamGetFrame
*
* @api LPVOID | AVIStreamGetFrame | This function returns a pointer to
*	a decompressed frame of video.
*
* @parm PGETFRAME | pgf | Specifies a pointer to a GetFrame object.
*
* @parm LONG | lPos | Specifies the position of desired frame in samples.
*
* @rdesc Returns NULL on error; otherwise it returns a far pointer
*        to the frame data.  The returned data is a packed DIB.
*
* @comm The returned frame is valid only until the next call
*	to <f AVIStreamGetFrame> or <f AVIStreamGetFrameClose>.
*
* @xref <f AVIStreamGetFrameOpen>
**********************************************************************/
STDAPI_(LPVOID) AVIStreamGetFrame(PGETFRAME pgf, LONG lPos)
{
    if (pgf == NULL)
        return NULL;

    return pgf->GetFrame(lPos);
}

// !!! Do we need an AVIStreamGetFrameSetFormat?
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\fakefile.cpp ===
/****************************************************************************
 *
 *  FAKEFILE.C
 *
 *  routines for simulating the IAVIFile interface from a bunch of streams
 *
 *  Copyright (c) 1992  - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>
#include <vfw.h>
#include "fakefile.h"
#include "debug.h"

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

/*	-	-	-	-	-	-	-	-	*/

/**************************************************************************
* @doc EXTERNAL AVIMakeFileFromStreams
*
* @api HRESULT | AVIMakeFileFromStreams | Constructs an AVIFile interface
*	pointer out of separate streams. If <f AVIFileGetStream>
*	is called with the returned file interface pointer, it will
*  return the specified
*	streams.
*
* @parm PAVIFILE FAR * | ppfile | Specifies a pointer to the location
*       used to return the new file interface pointer.
*
* @parm int | nStreams | Specifies the number of streams in
*       the array of stream interface pointers referenced by
*       <p papStreams>.
*
* @parm PAVISTREAM FAR * | papStreams | Specifies a pointer to
*       an array of stream interface pointers.
*
* @comm Use <f AVIFileRelease> to close the file. This function is
*       useful for putting streams onto the Clipboard.
*
* @rdesc Returns zero if successful; otherwise it returns an error code.
*
* @xref <f AVIFileClose> <f AVIFileGetStream>
*
*************************************************************************/
STDAPI AVIMakeFileFromStreams(PAVIFILE FAR *	ppfile,
			       int		nStreams,
			       PAVISTREAM FAR *	papStreams)
{
    CFakeFile FAR*	pAVIFile;

    pAVIFile = new FAR CFakeFile(nStreams, papStreams);
    if (!pAVIFile)
	return ResultFromScode(E_OUTOFMEMORY);

    *ppfile = (PAVIFILE) (LPVOID) pAVIFile;

    AVIFileAddRef((PAVIFILE) (LPVOID) pAVIFile);

    return AVIERR_OK;
}

/*	-	-	-	-	-	-	-	-	*/

CFakeFile::CFakeFile(int nStreams, PAVISTREAM FAR * papStreams)
{
    int		    i;
    AVISTREAMINFOW  si;
    DWORD	    dwLength;

    m_pUnknownOuter = this;
    m_refs = 0;

    _fmemset(&avihdr, 0, sizeof(avihdr));
    aps = 0;

    avihdr.dwStreams = nStreams;

    if (nStreams > 0) {
	aps = (PAVISTREAM NEAR *) LocalAlloc(LPTR, nStreams * sizeof(PAVISTREAM));


	// make sure none of the streams go away without our consent
	for (i = 0; i < nStreams; i++) {
	    aps[i] = papStreams[i];
	    AVIStreamAddRef(aps[i]);
	    // !!! should error check here, to make sure streams are valid
	
	    aps[i]->Info(&si, sizeof(si));

	    if (i == 0) {
		avihdr.dwScale  = si.dwScale;
		avihdr.dwRate   = si.dwRate;
		if ((avihdr.dwScale == 0 || avihdr.dwRate == 0) ||
			    muldiv32(1000000, si.dwScale, si.dwRate) < 10000) {
		    avihdr.dwScale = 1;
		    avihdr.dwRate = 100;
		}
	    }


	    dwLength = muldiv32(AVIStreamSampleToTime(aps[i], si.dwLength),
				avihdr.dwRate,
				avihdr.dwScale * 1000);
			
	    avihdr.dwLength = max(avihdr.dwLength, dwLength);
	    avihdr.dwWidth  = max((DWORD) si.rcFrame.right, avihdr.dwWidth);
	    avihdr.dwHeight  = max((DWORD) si.rcFrame.bottom, avihdr.dwHeight);

	    avihdr.dwWidth  = max((DWORD) si.rcFrame.right, avihdr.dwWidth);
	    avihdr.dwHeight  = max((DWORD) si.rcFrame.bottom, avihdr.dwHeight);
	}
    }
}

STDMETHODIMP CFakeFile::QueryInterface(
	const IID FAR&	iid,
	void FAR* FAR*	ppv)
{
    if (iid == IID_IUnknown)
	*ppv = this;
    else if (iid == IID_IAVIFile)
	*ppv = this;
    else {
	*ppv = NULL;
	return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return AVIERR_OK;
}

/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP_(ULONG) CFakeFile::AddRef()
{
    DPF("Fake   %p: Usage++=%lx\n", (DWORD_PTR) (LPVOID) this, m_refs + 1);

    return ++m_refs;
}

/*	-	-	-	-	-	-	-	-	*/

#ifndef _WIN32
STDMETHODIMP CFakeFile::Open(LPCTSTR szFile, UINT mode)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}
#endif

STDMETHODIMP CFakeFile::GetStream(PAVISTREAM FAR * ppavi,
				DWORD fccType,
				LONG lParam)
{
    HRESULT		    hr;
    int			    i;

    if (fccType == 0) {
	// just return nth stream
	if (lParam < (LONG) avihdr.dwStreams) {
	    *ppavi = aps[lParam];
	    AVIStreamAddRef(*ppavi);
	    return AVIERR_OK;
	} else {
	    *ppavi = NULL;
	    return ResultFromScode(AVIERR_UNSUPPORTED);
	}
    }

    // otherwise loop through and find the one we want...
    for (i = 0; i < (int) avihdr.dwStreams; i++) {
	AVISTREAMINFO	strhdr;
	
	hr = AVIStreamInfo(aps[i], &strhdr, sizeof(strhdr));

	if (strhdr.fccType == fccType) {
	    if (lParam == 0) {
		*ppavi = aps[i];
		AVIStreamAddRef(*ppavi);
		return AVIERR_OK;
	    }

	    --lParam;
	}
    }

    // !!!
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

#ifndef _WIN32
STDMETHODIMP CFakeFile::Save(LPCTSTR szFile,
				   AVICOMPRESSOPTIONS FAR *lpOptions,
				   AVISAVECALLBACK lpfnCallback)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}
#endif

STDMETHODIMP CFakeFile::CreateStream(PAVISTREAM FAR *ppstream,
		       AVISTREAMINFOW FAR *psi)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

#if 0
STDMETHODIMP CFakeFile::AddStream(PAVISTREAM pstream,
		       PAVISTREAM FAR *ppstreamNew)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}
#endif

STDMETHODIMP CFakeFile::WriteData(DWORD ckid,
		       LPVOID lpData,
		       LONG cbData)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CFakeFile::ReadData(DWORD ckid,
		      LPVOID lpData,
		      LONG FAR *lpcbData)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CFakeFile::EndRecord(void)
{
    return ResultFromScode(AVIERR_OK);
}

#ifdef _WIN32
STDMETHODIMP CFakeFile::DeleteStream(
				DWORD fccType,
				LONG lParam)
{
    // !!!
    return ResultFromScode(AVIERR_UNSUPPORTED);
}
#endif

STDMETHODIMP CFakeFile::Info(
		  AVIFILEINFOW FAR * pfi,
		  LONG lSize)
{
    hmemcpy(pfi, &avihdr, min(lSize,sizeof(avihdr)));
//    return sizeof(avihdr);
    return 0;
}



STDMETHODIMP_(ULONG) CFakeFile::Release()
{
    int		i;

    DPF("Fake   %p: Usage--=%lx\n", (DWORD_PTR) (LPVOID) this, m_refs - 1);

    if (!--m_refs) {
	LONG lRet = AVIERR_OK;

	if (aps) {
	    // Release our hold on the sub-streams
	    for (i = 0; i < (int) avihdr.dwStreams; i++) {
		AVIStreamClose(aps[i]);
	    }

	    LocalFree((HLOCAL) aps);
	}

	delete this;
	return 0;
    }
    return m_refs;
}


#ifndef _WIN32
STDMETHODIMP CFakeFile::Reserved1(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CFakeFile::Reserved2(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CFakeFile::Reserved3(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CFakeFile::Reserved4(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP CFakeFile::Reserved5(void)
{
    return ResultFromScode(AVIERR_UNSUPPORTED);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\profile.h ===
/*
 * AVICAP32:
 *
 * utility functions to read and write values to the profile,
 * using win.ini for Win16/Win95 or current
 * the registry for Win32 NT.  (Trivial to change to registry for Win95)
 *
 * The only routine that AVICAP32 uses is GetProfileIntA
 */

#if defined(_WIN32) && defined(UNICODE)

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
UINT mmGetProfileIntA(LPCSTR appname, LPCSTR valuename, INT uDefault);

// Now map all instances of GetProfileIntA to mmGetProfileIntA
#define GetProfileIntA mmGetProfileIntA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\fileshar.h ===
#ifndef _FILESHAR_H_
#define _FILESHAR_H_

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

DECLARE_HANDLE(HSHFILE);

#ifdef _WIN32
#ifndef _huge
#define _huge
#endif
#endif

HSHFILE WINAPI shfileOpen(LPTSTR szFileName, MMIOINFO FAR* lpmmioinfo,
    DWORD dwOpenFlags);
UINT WINAPI shfileClose(HSHFILE hsh, UINT uFlags);
LONG WINAPI shfileRead(HSHFILE hsh, HPSTR pch, LONG cch);
LONG WINAPI shfileWrite(HSHFILE hsh, const char _huge* pch, LONG cch);
LONG WINAPI shfileSeek(HSHFILE hsh, LONG lOffset, int iOrigin);
LONG WINAPI shfileFlush(HSHFILE hsh, UINT uFlags);
LONG WINAPI shfileZero(HSHFILE hsh, LONG lBytes);


LONG WINAPI shfileAddRef(HSHFILE hsh);
LONG WINAPI shfileRelease(HSHFILE hsh);

#ifdef USE_DIRECTIO
BOOL shfileIsDirect(HSHFILE hsh);
void shfileStreamStart(HSHFILE hsh);
void shfileStreamStop(HSHFILE hsh);
#endif


#ifndef _MMRESULT_
#define _MMRESULT_
typedef UINT                MMRESULT;
#endif

MMRESULT WINAPI
shfileDescend(HSHFILE hshfile, LPMMCKINFO lpck, const LPMMCKINFO lpckParent, UINT wFlags);
MMRESULT WINAPI
shfileAscend(HSHFILE hshfile, LPMMCKINFO lpck, UINT wFlags);
MMRESULT WINAPI
shfileCreateChunk(HSHFILE hshfile, LPMMCKINFO lpck, UINT wFlags);


#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif // _FILESHAR_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\olehack.h ===
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

HRESULT FAR PASCAL InitOle(BOOL fForceLoad);
void FAR PASCAL TermOle(void);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\profile.c ===
/*
 * AVICAP32:
 *
 * profile.c
 *
 * win32/win16 utility functions to read and write profile items
 * for VFW
 *
 * ONLY mmGetProfileIntA is supported here
 *
 */

#if defined(_WIN32) && defined(UNICODE)
// This whole file is only used for 32 bit code.  It is the implementation
// that allows Win GetProfilexxx calls to use the registry.

#include <windows.h>
#include <windowsx.h>

#include <profile.key>
#include <win32.h>
#include <stdlib.h>  // for atoi

#include "profile.h"

static HKEY GetKeyA(LPCSTR appname, BOOL fCreate)
{
    HKEY key = 0;
    char achName[MAX_PATH];

    lstrcpyA(achName, KEYNAMEA);
    lstrcatA(achName, appname);

    if ((!fCreate && RegOpenKeyA(ROOTKEY, achName, &key) == ERROR_SUCCESS)
        || (fCreate && RegCreateKeyA(ROOTKEY, achName, &key) == ERROR_SUCCESS)) {
    }

    return(key);
}

#define GetKey GetKeyA

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
UINT
mmGetProfileIntA(LPCSTR appname, LPCSTR valuename, INT uDefault)
{
    DWORD dwType;
    INT value = uDefault;
    DWORD dwData;
    int cbData;

    HKEY key = GetKeyA(appname, FALSE);

    if (key) {

        cbData = sizeof(dwData);
        if (RegQueryValueExA(
            key,
            (LPSTR)valuename,
            NULL,
            &dwType,
            (PBYTE) &dwData,
            &cbData) == ERROR_SUCCESS) {
            if (dwType == REG_DWORD || dwType == REG_BINARY) {
                value = (INT)dwData;
            } else if (dwType == REG_SZ) {
		value = atoi((LPSTR) &dwData);
	    }
	}

        RegCloseKey(key);
    }

    return((UINT)value);
}

#endif // DAYTONA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\olepriv.h ===
//
// Major ugliness warning:
//
// These are definitions stolen from the 32-bit OLE headers and
// munged to have the word FAR in all of the right places.
//



interface IRpcProxyBuffer;
interface IRpcChannelBuffer;
interface IRpcStubBuffer;
interface IPSFactoryBuffer;

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//
//  Contents: Interface header file for IRpcProxyBuffer
//
//  History: Created by Microsoft (R) MIDL Compiler Version 1.10.85
//
//--------------------------------------------------------------------------

#ifndef __IRpcProxyBuffer__
#define __IRpcProxyBuffer__


#ifndef _ERROR_STATUS_T_DEFINED
typedef unsigned long error_status_t;
#define _ERROR_STATUS_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


EXTERN_C const IID IID_IRpcProxyBuffer;
#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */

interface IRpcProxyBuffer : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE Connect
    (
	IRpcChannelBuffer FAR *pRpcChannelBuffer
    ) = 0;

    virtual void STDMETHODCALLTYPE Disconnect
    (
        void
    ) = 0;

};

#else

/* C Language Binding */

typedef struct IRpcProxyBufferVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        IRpcProxyBuffer FAR * This,
	REFIID riid,
	void FAR * FAR *ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        IRpcProxyBuffer FAR * This
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        IRpcProxyBuffer FAR * This
    );

    HRESULT (STDMETHODCALLTYPE FAR *Connect)
    (
        IRpcProxyBuffer FAR * This,
	IRpcChannelBuffer FAR *pRpcChannelBuffer
    );

    void (STDMETHODCALLTYPE FAR *Disconnect)
    (
        IRpcProxyBuffer FAR * This
    );

} IRpcProxyBufferVtbl;

interface IRpcProxyBuffer
{
    IRpcProxyBufferVtbl FAR *lpVtbl;
} ;


#endif

#endif /*__IRpcProxyBuffer__*/


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//
//  Contents: Interface header file for IRpcChannelBuffer
//
//  History: Created by Microsoft (R) MIDL Compiler Version 1.10.85
//
//--------------------------------------------------------------------------

#ifndef __IRpcChannelBuffer__
#define __IRpcChannelBuffer__

/* Forward declaration */
// typedef interface IRpcChannelBuffer IRpcChannelBuffer;


#ifndef _ERROR_STATUS_T_DEFINED
typedef unsigned long error_status_t;
#define _ERROR_STATUS_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


typedef unsigned long RPCOLEDATAREP;

typedef enum tagRPCFLG
#if 0
  {
	RPCFLG_ASYNCHRONOUS = 1073741824,
	RPCFLG_INPUT_SYNCHRONOUS = 536870912
  }
#endif
RPCFLG;


typedef struct tagRPCOLEMESSAGE
  {
  void FAR *reserved1;
  RPCOLEDATAREP dataRepresentation;
  void FAR *Buffer;
  ULONG cbBuffer;
  ULONG iMethod;
  void FAR *reserved2[5];
  ULONG rpcFlags;
  }
RPCOLEMESSAGE;


typedef RPCOLEMESSAGE FAR *PRPCOLEMESSAGE;


EXTERN_C const IID IID_IRpcChannelBuffer;
#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */

interface IRpcChannelBuffer : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetBuffer
    (
	RPCOLEMESSAGE FAR *pMessage,
	REFIID riid
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SendReceive
    (
	RPCOLEMESSAGE FAR *pMessage,
	ULONG FAR *pStatus
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE FreeBuffer
    (
	RPCOLEMESSAGE FAR *pMessage
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetDestCtx
    (
	DWORD FAR *pdwDestContext,
	void FAR * FAR *ppvDestContext
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE IsConnected
    (
        void
    ) = 0;

};

#else

/* C Language Binding */

typedef struct IRpcChannelBufferVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        IRpcChannelBuffer FAR * This,
	REFIID riid,
	void FAR * FAR *ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        IRpcChannelBuffer FAR * This
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        IRpcChannelBuffer FAR * This
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBuffer)
    (
        IRpcChannelBuffer FAR * This,
	RPCOLEMESSAGE FAR *pMessage,
	REFIID riid
    );

    HRESULT (STDMETHODCALLTYPE FAR *SendReceive)
    (
        IRpcChannelBuffer FAR * This,
	RPCOLEMESSAGE FAR *pMessage,
	ULONG FAR *pStatus
    );

    HRESULT (STDMETHODCALLTYPE FAR *FreeBuffer)
    (
        IRpcChannelBuffer FAR * This,
	RPCOLEMESSAGE FAR *pMessage
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetDestCtx)
    (
        IRpcChannelBuffer FAR * This,
	DWORD FAR *pdwDestContext,
	void FAR * FAR *ppvDestContext
    );

    HRESULT (STDMETHODCALLTYPE FAR *IsConnected)
    (
        IRpcChannelBuffer FAR * This
    );

} IRpcChannelBufferVtbl;

interface IRpcChannelBuffer
{
    IRpcChannelBufferVtbl FAR *lpVtbl;
} ;


#endif

#endif /*__IRpcChannelBuffer__*/


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//
//  Contents: Interface header file for IRpcStubBuffer
//
//  History: Created by Microsoft (R) MIDL Compiler Version 1.10.85
//
//--------------------------------------------------------------------------

#ifndef __IRpcStubBuffer__
#define __IRpcStubBuffer__

/* Forward declaration */
// typedef interface IRpcStubBuffer IRpcStubBuffer;


#ifndef _ERROR_STATUS_T_DEFINED
typedef unsigned long error_status_t;
#define _ERROR_STATUS_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


EXTERN_C const IID IID_IRpcStubBuffer;
#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */

interface IRpcStubBuffer : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE Connect
    (
	IUnknown FAR *pUnkServer
    ) = 0;

    virtual void STDMETHODCALLTYPE Disconnect
    (
        void
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Invoke
    (
	RPCOLEMESSAGE FAR *_prpcmsg,
	IRpcChannelBuffer FAR *_pRpcChannelBuffer
    ) = 0;

    virtual IRpcStubBuffer  FAR *STDMETHODCALLTYPE IsIIDSupported
    (
	REFIID riid
    ) = 0;

    virtual ULONG STDMETHODCALLTYPE CountRefs
    (
        void
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DebugServerQueryInterface
    (
	void FAR * FAR *ppv
    ) = 0;

    virtual void STDMETHODCALLTYPE DebugServerRelease
    (
	void FAR *pv
    ) = 0;

};

#else

/* C Language Binding */

typedef struct IRpcStubBufferVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        IRpcStubBuffer FAR * This,
	REFIID riid,
	void FAR * FAR *ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        IRpcStubBuffer FAR * This
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        IRpcStubBuffer FAR * This
    );

    HRESULT (STDMETHODCALLTYPE FAR *Connect)
    (
        IRpcStubBuffer FAR * This,
	IUnknown FAR *pUnkServer
    );

    void (STDMETHODCALLTYPE FAR *Disconnect)
    (
        IRpcStubBuffer FAR * This
    );

    HRESULT (STDMETHODCALLTYPE FAR *Invoke)
    (
        IRpcStubBuffer FAR * This,
	RPCOLEMESSAGE FAR *_prpcmsg,
	IRpcChannelBuffer FAR *_pRpcChannelBuffer
    );

    IRpcStubBuffer  FAR *(STDMETHODCALLTYPE FAR *IsIIDSupported)
    (
        IRpcStubBuffer FAR * This,
	REFIID riid
    );

    ULONG (STDMETHODCALLTYPE FAR *CountRefs)
    (
        IRpcStubBuffer FAR * This
    );

    HRESULT (STDMETHODCALLTYPE FAR *DebugServerQueryInterface)
    (
        IRpcStubBuffer FAR * This,
	void FAR * FAR *ppv
    );

    void (STDMETHODCALLTYPE FAR *DebugServerRelease)
    (
        IRpcStubBuffer FAR * This,
	void FAR *pv
    );

} IRpcStubBufferVtbl;

interface IRpcStubBuffer
{
    IRpcStubBufferVtbl FAR *lpVtbl;
} ;


#endif

#endif /*__IRpcStubBuffer__*/


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//
//  Contents: Interface header file for IPSFactoryBuffer
//
//  History: Created by Microsoft (R) MIDL Compiler Version 1.10.85
//
//--------------------------------------------------------------------------

#ifndef __IPSFactoryBuffer__
#define __IPSFactoryBuffer__

/* Forward declaration */
// typedef interface IPSFactoryBuffer IPSFactoryBuffer;


#ifndef _ERROR_STATUS_T_DEFINED
typedef unsigned long error_status_t;
#define _ERROR_STATUS_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


EXTERN_C const IID IID_IPSFactoryBuffer;
#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */

interface IPSFactoryBuffer : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE CreateProxy
    (
	IUnknown FAR *pUnkOuter,
	REFIID riid,
	IRpcProxyBuffer FAR * FAR *ppProxy,
	void FAR * FAR *ppv
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateStub
    (
	REFIID riid,
	IUnknown FAR *pUnkServer,
	IRpcStubBuffer FAR * FAR *ppStub
    ) = 0;

};

#else

/* C Language Binding */

typedef struct IPSFactoryBufferVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        IPSFactoryBuffer FAR * This,
	REFIID riid,
	void FAR * FAR *ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        IPSFactoryBuffer FAR * This
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        IPSFactoryBuffer FAR * This
    );

    HRESULT (STDMETHODCALLTYPE FAR *CreateProxy)
    (
        IPSFactoryBuffer FAR * This,
	IUnknown FAR *pUnkOuter,
	REFIID riid,
	IRpcProxyBuffer FAR * FAR *ppProxy,
	void FAR * FAR *ppv
    );

    HRESULT (STDMETHODCALLTYPE FAR *CreateStub)
    (
        IPSFactoryBuffer FAR * This,
	REFIID riid,
	IUnknown FAR *pUnkServer,
	IRpcStubBuffer FAR * FAR *ppStub
    );

} IPSFactoryBufferVtbl;

interface IPSFactoryBuffer
{
    IPSFactoryBufferVtbl FAR *lpVtbl;
} ;


#endif

#endif /*__IPSFactoryBuffer__*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\wavefile.h ===
/****************************************************************************
 *
 *  WAVEFILE.H
 *
 *  header file for routines for reading WAVE files
 *
 ***************************************************************************/
/*	-	-	-	-	-	-	-	-	*/
#ifdef WIN32
#define _export // EXPORT in def file does everything necessary in WIN32
#endif

#include "avifile.rc"

extern HMODULE ghModule; // global HMODULE/HINSTANCE for resource access
/*	-	-	-	-	-	-	-	-	*/

/*
** This class is used to implement a handler for a type of file with only
** one stream.  In this case, we don't have to worry about allocating more
** than one stream object for each file object, so we can combine the
** two together in a single class.
**
*/

#ifdef __cplusplus
extern "C"             /* Assume C declarations for C++ */
#endif	/* __cplusplus */

HRESULT WaveFileCreate(
	IUnknown FAR*	pUnknownOuter,
	REFIID		riid,
	void FAR* FAR*	ppv);
/*	-	-	-	-	-	-	-	-	*/

/*
** These variables help keep track of whether the DLL is still in use,
** so that when our DllCanUnloadNow() function is called, we know what
** to say. 
*/

extern UINT	uUseCount;
extern UINT	uLockCount;

/*	-	-	-	-	-	-	-	-	*/

//
// This is our unique identifier
//
//  NOTE: If you modify this sample code to do something else, you MUST
//	    CHANGE THIS!
//
//  Run uuidgen.exe from the tools directory and get your own GUID.
//  DO NOT USE THIS ONE!
//
//
//
DEFINE_GUID(CLSID_AVIWaveFileReader, 0x00020003, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile\wavefile.c ===
/****************************************************************************
 *
 *  WAVEFILE.C
 *
 *  An implementation in C of an AVI File Handler to read standard windows
 *  WAV files as if they were an AVI file with one audio stream.
 *
 ***************************************************************************/
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/

#include <win32.h>
#ifndef _WIN32
#include <ole2.h>
#endif

#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <ctype.h>
#include <vfw.h>
#include "extra.h"
#include "wavefile.h"
// First, override the definition in media\inc\win32.h that causes strsafe to not work on Win64
#ifndef _X86_
#undef __inline
#endif // _X86_
// Then, include strsafe.h
#include <strsafe.h>

#define formtypeWAVE	mmioFOURCC('W', 'A', 'V', 'E')
#define ckidWAVEFORMAT	mmioFOURCC('f', 'm', 't', ' ')
#define ckidWAVEDATA	mmioFOURCC('d', 'a', 't', 'a')

#ifndef _WIN32
#define LPCOLESTR   LPCSTR
#define LPOLESTR    LPSTR
#endif



typedef struct {

	/*
	** This implementation of a file handler is done in C, not C++, so a few
	** things work differently than in C++.  Our structure contains Vtbls
	** (pointer to function tables) for three interfaces... Unknown, AVIStream,
	** and AVIFile, as well as our private data we need to implement the
	** handler.
	**
	*/

	IAVIStreamVtbl FAR	*AVIStream;
	IAVIFileVtbl FAR	*AVIFile;
	IUnknownVtbl FAR	*Unknown;
	IPersistFileVtbl FAR	*Persist;

	// This is our controlling object.
	IUnknown FAR*	pUnknownOuter;

	//
	// WaveFile instance data
	//
	HSHFILE			hshfile;	// file I/O

	MMCKINFO		ckData;

	LONG			refs;		// for UNKNOWN
	AVISTREAMINFOW		avistream;	// for STREAM

	LPWAVEFORMATEX		lpFormat;	// stream format
	LONG			cbFormat;
	BOOL			fDirty;
	UINT			mode;
	EXTRA			extra;
	AVIFILEINFOW		avihdr;
} WAVESTUFF, FAR *LPWAVESTUFF;

/*
** Whenever a function is called with a pointer to one of our Vtbls, we need
** to back up and get a pointer to the beginning of our structure.  Depending
** on which pointer we are passed, we need to back up a different number of
** bytes.  C++ would make this easier, by declaring backpointers.
*/

WAVESTUFF ws;
#define WAVESTUFF_FROM_UNKNOWN(pu)	(LPWAVESTUFF)((LPBYTE)(pu) - ((LPBYTE)&ws.Unknown - (LPBYTE)&ws))
#define WAVESTUFF_FROM_FILE(pf)		(LPWAVESTUFF)((LPBYTE)(pf) - ((LPBYTE)&ws.AVIFile - (LPBYTE)&ws))
#define WAVESTUFF_FROM_STREAM(ps)	(LPWAVESTUFF)((LPBYTE)(ps) - ((LPBYTE)&ws.AVIStream - (LPBYTE)&ws))
#define WAVESTUFF_FROM_PERSIST(ppf)	(LPWAVESTUFF)((LPBYTE)(ppf) - ((LPBYTE)&ws.Persist - (LPBYTE)&ws))



extern HINSTANCE	ghMod;
LPTSTR FAR FileName( LPCTSTR lszPath);
extern LPTSTR FAR lstrzcpy (LPTSTR pszTgt, LPCTSTR pszSrc, size_t cch);
extern LPSTR FAR lstrzcpyA (LPSTR pszTgt, LPCSTR pszSrc, size_t cch);
extern LPWSTR FAR lstrzcpyW (LPWSTR pszTgt, LPCWSTR pszSrc, size_t cch);
extern LPWSTR FAR lstrzcpyAtoW (LPWSTR pszTgt, LPCSTR pszSrc, size_t cch);
extern LPSTR FAR lstrzcpyWtoA (LPSTR pszTgt, LPCWSTR pszSrc, size_t cch);

//
// Function prototypes and Vtbl for the Unknown interface
//
STDMETHODIMP WaveUnknownQueryInterface(LPUNKNOWN pu, REFIID iid, void FAR* FAR* ppv);
STDMETHODIMP_(ULONG) WaveUnknownAddRef(LPUNKNOWN pu);
STDMETHODIMP_(ULONG) WaveUnknownRelease(LPUNKNOWN pu);

IUnknownVtbl UnknownVtbl = {
	WaveUnknownQueryInterface,
	WaveUnknownAddRef,
	WaveUnknownRelease
};

//
// Function prototypes and Vtbl for the AVIFile interface
//
STDMETHODIMP WaveFileQueryInterface(PAVIFILE pf, REFIID iid, void FAR* FAR* ppv);
STDMETHODIMP_(ULONG) WaveFileAddRef(PAVIFILE pf);
STDMETHODIMP_(ULONG) WaveFileRelease(PAVIFILE pf);
#ifndef _WIN32
STDMETHODIMP WaveFileOpen(PAVIFILE pf, LPCSTR szFile, UINT mode);
#endif
STDMETHODIMP WaveFileInfo(PAVIFILE pf, AVIFILEINFOW FAR * pfi, LONG lSize);
STDMETHODIMP WaveFileGetStream(PAVIFILE pf, PAVISTREAM FAR * ppavi, DWORD fccType, LONG lParam);
STDMETHODIMP WaveFileCreateStream(PAVIFILE pf, PAVISTREAM FAR *ppstream, AVISTREAMINFOW FAR *psi);
#ifndef _WIN32
STDMETHODIMP WaveFileSave(PAVIFILE pf, LPCSTR szFile, AVICOMPRESSOPTIONS FAR *lpOptions, AVISAVECALLBACK lpfnCallback);
#endif

STDMETHODIMP WaveFileWriteData(PAVIFILE pf, DWORD ckid, LPVOID lpData, LONG cbData);
STDMETHODIMP WaveFileReadData(PAVIFILE pf, DWORD ckid, LPVOID lpData, LONG FAR *lpcbData);
STDMETHODIMP WaveFileEndRecord(PAVIFILE pf);
#ifdef _WIN32
STDMETHODIMP WaveFileDeleteStream(PAVIFILE pf, DWORD fccType, LONG lParam);
#else
STDMETHODIMP WaveFileReserved(PAVIFILE pf);
#endif


IAVIFileVtbl FileVtbl = {
	WaveFileQueryInterface,
	WaveFileAddRef,
	WaveFileRelease,
#ifndef _WIN32
	WaveFileOpen,
#endif
	WaveFileInfo,
	WaveFileGetStream,
	WaveFileCreateStream,
#ifndef _WIN32
	WaveFileSave,
#endif
	WaveFileWriteData,
	WaveFileReadData,
	WaveFileEndRecord,
#ifdef _WIN32
	WaveFileDeleteStream
#else
	WaveFileReserved,
	WaveFileReserved,
	WaveFileReserved,
	WaveFileReserved,
	WaveFileReserved
#endif
};


STDMETHODIMP WavePersistQueryInterface(LPPERSISTFILE pf, REFIID iid, void FAR* FAR* ppv);
STDMETHODIMP_(ULONG) WavePersistAddRef(LPPERSISTFILE pf);
STDMETHODIMP_(ULONG) WavePersistRelease(LPPERSISTFILE pf);
STDMETHODIMP WavePersistGetClassID (LPPERSISTFILE ppf, LPCLSID lpClassID);
STDMETHODIMP WavePersistIsDirty (LPPERSISTFILE ppf);
STDMETHODIMP WavePersistLoad (LPPERSISTFILE ppf,
			      LPCOLESTR lpszFileName, DWORD grfMode);
STDMETHODIMP WavePersistSave (LPPERSISTFILE ppf,
			      LPCOLESTR lpszFileName, BOOL fRemember);
STDMETHODIMP WavePersistSaveCompleted (LPPERSISTFILE ppf,
				       LPCOLESTR lpszFileName);
STDMETHODIMP WavePersistGetCurFile (LPPERSISTFILE ppf,
				    LPOLESTR FAR * lplpszFileName);


IPersistFileVtbl PersistVtbl = {
	WavePersistQueryInterface,
	WavePersistAddRef,
	WavePersistRelease,
	WavePersistGetClassID,
	WavePersistIsDirty,
	WavePersistLoad,
	WavePersistSave,
	WavePersistSaveCompleted,
	WavePersistGetCurFile
};

//
// Function prototypes and Vtbl for the AVIStream interface
//
STDMETHODIMP WaveStreamQueryInterface(PAVISTREAM ps, REFIID riid, LPVOID FAR* ppvObj);
STDMETHODIMP WaveStreamCreate(PAVISTREAM ps, LPARAM lParam1, LPARAM lParam2);
STDMETHODIMP_(ULONG) WaveStreamAddRef(PAVISTREAM ps);
STDMETHODIMP_(ULONG) WaveStreamRelease(PAVISTREAM ps);
STDMETHODIMP WaveStreamInfo(PAVISTREAM ps, AVISTREAMINFOW FAR * psi, LONG lSize);
STDMETHODIMP_(LONG) WaveStreamFindSample(PAVISTREAM ps, LONG lPos, LONG lFlags);
STDMETHODIMP WaveStreamReadFormat(PAVISTREAM ps, LONG lPos, LPVOID lpFormat, LONG FAR *lpcbFormat);
STDMETHODIMP WaveStreamSetFormat(PAVISTREAM ps, LONG lPos, LPVOID lpFormat, LONG cbFormat);
STDMETHODIMP WaveStreamRead(PAVISTREAM ps, LONG lStart, LONG lSamples, LPVOID lpBuffer, LONG cbBuffer, LONG FAR * plBytes,LONG FAR * plSamples);
STDMETHODIMP WaveStreamWrite(PAVISTREAM ps, LONG lStart, LONG lSamples, LPVOID lpData, LONG cbData, DWORD dwFlags, LONG FAR *plSampWritten, LONG FAR *plBytesWritten);
STDMETHODIMP WaveStreamDelete(PAVISTREAM ps, LONG lStart, LONG lSamples);
STDMETHODIMP WaveStreamReadData(PAVISTREAM ps, DWORD fcc, LPVOID lp,LONG FAR *lpcb);
STDMETHODIMP WaveStreamWriteData(PAVISTREAM ps, DWORD fcc, LPVOID lp,LONG cb);
#ifdef _WIN32
STDMETHODIMP WaveStreamSetInfo(PAVISTREAM ps, AVISTREAMINFOW FAR * psi, LONG lSize);
#else
STDMETHODIMP WaveStreamReserved(PAVISTREAM ps);
#endif

IAVIStreamVtbl StreamVtbl = {
	WaveStreamQueryInterface,
	WaveStreamAddRef,
	WaveStreamRelease,
	WaveStreamCreate,
	WaveStreamInfo,
	WaveStreamFindSample,
	WaveStreamReadFormat,
	WaveStreamSetFormat,
	WaveStreamRead,
	WaveStreamWrite,
	WaveStreamDelete,
	WaveStreamReadData,
	WaveStreamWriteData,
#ifdef _WIN32
	WaveStreamSetInfo
#else
	WaveStreamReserved,
	WaveStreamReserved,
	WaveStreamReserved,
	WaveStreamReserved,
	WaveStreamReserved
#endif
};


#if defined _WIN32 && !defined UNICODE

int LoadUnicodeString(HINSTANCE hinst, UINT wID, LPWSTR lpBuffer, int cchBuffer)
{
    char    ach[256];
    int	    i;

    i = LoadString(hinst, wID, ach, NUMELMS(ach));

    if (i > 0)
	MultiByteToWideChar(CP_ACP, 0, ach, -1, lpBuffer, cchBuffer);

    return i;
}

#else
#define LoadUnicodeString   LoadString
#endif


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

/*	-	-	-	-	-	-	-	-	*/

UINT	uUseCount;	// the reference count for our objects
UINT	uLockCount;	// our lock count for LockServer

/*	-	-	-	-	-	-	-	-	*/

//
// Create a new instance.  Since this is a C implementation we have to
// allocate space for our structure ourselves.
//
HRESULT WaveFileCreate(
	IUnknown FAR*	pUnknownOuter,
	REFIID		riid,
	void FAR* FAR*	ppv)
{
	IUnknown FAR*	pUnknown;
	LPWAVESTUFF	pWaveStuff;
	HRESULT	hresult;

	// Allocate space for our structure
	pWaveStuff = (LPWAVESTUFF)GlobalAllocPtr(GMEM_MOVEABLE,
		sizeof(WAVESTUFF));
	if (!pWaveStuff)
		return ResultFromScode(E_OUTOFMEMORY);

	// Initialize the Vtbls
	pWaveStuff->AVIFile = &FileVtbl;
	pWaveStuff->AVIStream = &StreamVtbl;
	pWaveStuff->Unknown = &UnknownVtbl;
	pWaveStuff->Persist = &PersistVtbl;

	// Set up our controlling object
	pUnknown = (IUnknown FAR *)&pWaveStuff->Unknown;
	if (pUnknownOuter)
		pWaveStuff->pUnknownOuter = pUnknownOuter;
	else
		pWaveStuff->pUnknownOuter =(IUnknown FAR *)&pWaveStuff->Unknown;

	// Initial the things in our structure
	pWaveStuff->refs = 0;
	pWaveStuff->hshfile = NULL;
	pWaveStuff->lpFormat = NULL;
	pWaveStuff->cbFormat = 0L;
	pWaveStuff->fDirty = FALSE;
	pWaveStuff->extra.lp = NULL;
	pWaveStuff->extra.cb = 0L;

	// Call our Query interface to increment our ref count and get a
	// pointer to our interface to return.
	hresult = pUnknown->lpVtbl->QueryInterface(pUnknown, riid, ppv);

	if (FAILED(GetScode(hresult)))
		GlobalFreePtr(pWaveStuff);
	return hresult;
}

/*	-	-	-	-	-	-	-	-	*/

//
// Query interface from all three interfaces comes here.  We support the
// Unknown interface, AVIStream and AVIFile.
//
STDMETHODIMP WaveUnknownQueryInterface(
	LPUNKNOWN	pu,
	REFIID		iid,
	void FAR* FAR*	ppv)
{
	// Get a pointer to our structure
	LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_UNKNOWN(pu);

	if (IsEqualIID(iid, &IID_IUnknown))
		*ppv = (LPVOID)&pWaveStuff->Unknown;
	else if (IsEqualIID(iid, &IID_IAVIFile))
		*ppv = (LPVOID)&pWaveStuff->AVIFile;
	else if (IsEqualIID(iid, &IID_IAVIStream))
		*ppv = (LPVOID)&pWaveStuff->AVIStream;
	else if (IsEqualIID(iid, &IID_IPersistFile))
		*ppv = (LPVOID)&pWaveStuff->Persist;
	else
		return ResultFromScode(E_NOINTERFACE);
	pu->lpVtbl->AddRef(pu);
	return NOERROR;
}

/*	-	-	-	-	-	-	-	-	*/

//
// Increase our reference count.  AddRef for all three interfaces comes here.
//
STDMETHODIMP_(ULONG) WaveUnknownAddRef(
	LPUNKNOWN	pu)
{
	// Get a pointer to our structure
	LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_UNKNOWN(pu);

	uUseCount++;
	return ++pWaveStuff->refs;
}

/*	-	-	-	-	-	-	-	-	*/

//
// Decrease our reference count.  Release for all three interfaces comes here.
//
STDMETHODIMP_(ULONG) WaveUnknownRelease(
	LPUNKNOWN pu)
{
	// Get a pointer to our structure
	LPWAVESTUFF p = WAVESTUFF_FROM_UNKNOWN(pu);

	uUseCount--;

	//
	// Ref count is zero.  Close the file.  If we've been writing to it, it's
	// clean-up time!
	//
	if (!--p->refs) {
	LONG lRet = AVIERR_OK;
	
	if (p->fDirty) {
		MMCKINFO ckRIFF;
		MMCKINFO ck;

		shfileSeek(p->hshfile, 0, SEEK_SET);

		/* create the output file RIFF chunk of form type 'WAVE' */
		ckRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
		ckRIFF.cksize = 0L;	// let MMIO figure out ck. size
		if (shfileCreateChunk(p->hshfile, &ckRIFF, MMIO_CREATERIFF) != 0)
			goto ERROR_CANNOT_WRITE;	// cannot write file, probably

		ck.ckid = mmioFOURCC('f', 'm', 't', ' ');
		ck.cksize = p->cbFormat;		// we know the size of this ck.
		if (shfileCreateChunk(p->hshfile, &ck, 0) != 0)
		goto ERROR_CANNOT_WRITE;	// cannot write file, probably

		if (shfileWrite(p->hshfile, (HPSTR) p->lpFormat, p->cbFormat) != p->cbFormat)
		goto ERROR_CANNOT_WRITE;	// cannot write file, probably

		/* ascend out of the 'fmt' chunk, back into 'RIFF' chunk */
		if (shfileAscend(p->hshfile, &ck, 0) != 0)
		goto ERROR_CANNOT_WRITE;	// cannot write file, probably

		// If there was extra stuff here, we need to fill it!
		if (shfileSeek(p->hshfile, 0, SEEK_CUR)
			+ 2 * (LRESULT)sizeof(DWORD)
			!= (LRESULT) p->ckData.dwDataOffset) {
			/* create the 'data' chunk that holds the waveform samples */
			ck.ckid = mmioFOURCC('J', 'U', 'N', 'K');
			ck.cksize = 0;
			if (shfileCreateChunk(p->hshfile, &ck, 0) != 0)
				goto ERROR_CANNOT_WRITE;	// cannot write file, probably

			shfileSeek(p->hshfile,
				p->ckData.dwDataOffset - 2 * sizeof(DWORD),
				SEEK_SET);

			if (shfileAscend(p->hshfile, &ck, 0) != 0)
				goto ERROR_CANNOT_WRITE;	// cannot write file, probably
		}

		/* create the 'data' chunk that holds the waveform samples */
		ck.ckid = mmioFOURCC('d', 'a', 't', 'a');
		ck.cksize = p->ckData.cksize;
		if (shfileCreateChunk(p->hshfile, &ck, 0) != 0)
		goto ERROR_CANNOT_WRITE;	// cannot write file, probably

		shfileSeek(p->hshfile, p->ckData.cksize, SEEK_CUR);

		shfileAscend(p->hshfile, &ck, 0);

		if (p->extra.cb) {
		if (shfileWrite(p->hshfile, (HPSTR) p->extra.lp, p->extra.cb) != p->extra.cb)
			goto ERROR_CANNOT_WRITE;
		}

		if (shfileAscend(p->hshfile, &ckRIFF, 0) != 0)
		goto ERROR_CANNOT_WRITE;

		if (shfileFlush(p->hshfile, 0) != 0)
		goto ERROR_CANNOT_WRITE;
	}


	goto success;

	ERROR_CANNOT_WRITE:
	lRet = AVIERR_FILEWRITE;

	success:
	if (p->hshfile)
		shfileClose(p->hshfile, 0);

	if (p->lpFormat)
		GlobalFreePtr(p->lpFormat);

	// Free the memory for our structure.
	GlobalFreePtr(p);
	return 0;
	}
	return p->refs;
}


//
// Use our controlling object to call QueryInterface on Unknown
//
STDMETHODIMP WaveFileQueryInterface(
	PAVIFILE	pf,
	REFIID		iid,
	void FAR* FAR*	ppv)
{
	// Get a pointer to our structure
	LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_FILE(pf);

	return pWaveStuff->pUnknownOuter->lpVtbl->QueryInterface(
		pWaveStuff->pUnknownOuter, iid, ppv);
}

/*	-	-	-	-	-	-	-	-	*/

//
// Use our controlling object to call AddRef on Unknown
//
STDMETHODIMP_(ULONG) WaveFileAddRef(
	PAVIFILE	pf)
{
	// Get a pointer to our structure
	LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_FILE(pf);

	return pWaveStuff->pUnknownOuter->lpVtbl->AddRef(
		pWaveStuff->pUnknownOuter);
}

/*	-	-	-	-	-	-	-	-	*/

//
// Use our controlling object to call Release on Unknown
//
STDMETHODIMP_(ULONG) WaveFileRelease(
	PAVIFILE	pf)
{
	// Get a pointer to our structure
	LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_FILE(pf);

	return pWaveStuff->pUnknownOuter->lpVtbl->Release(
		pWaveStuff->pUnknownOuter);
}

/*	-	-	-	-	-	-	-	-	*/


//
// Use our controlling object to call QueryInterface on Unknown
//
STDMETHODIMP WavePersistQueryInterface(
	LPPERSISTFILE	ppf,
	REFIID		iid,
	void FAR* FAR*	ppv)
{
	// Get a pointer to our structure
	LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_PERSIST(ppf);

	return pWaveStuff->pUnknownOuter->lpVtbl->QueryInterface(
		pWaveStuff->pUnknownOuter, iid, ppv);
}

/*	-	-	-	-	-	-	-	-	*/

//
// Use our controlling object to call AddRef on Unknown
//
STDMETHODIMP_(ULONG) WavePersistAddRef(
	LPPERSISTFILE	ppf)
{
	// Get a pointer to our structure
	LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_PERSIST(ppf);

	return pWaveStuff->pUnknownOuter->lpVtbl->AddRef(
		pWaveStuff->pUnknownOuter);
}

/*	-	-	-	-	-	-	-	-	*/

//
// Use our controlling object to call Release on Unknown
//
STDMETHODIMP_(ULONG) WavePersistRelease(
	LPPERSISTFILE	ppf)
{
	// Get a pointer to our structure
	LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_PERSIST(ppf);

	return pWaveStuff->pUnknownOuter->lpVtbl->Release(
		pWaveStuff->pUnknownOuter);
}

/*	-	-	-	-	-	-	-	-	*/



//
// Use our controlling object to call QueryInterface on Unknown
//
STDMETHODIMP WaveStreamQueryInterface(
	PAVISTREAM	ps,
	REFIID		iid,
	void FAR* FAR*	ppv)
{
	// Get a pointer to our structure
	LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_STREAM(ps);

	return pWaveStuff->pUnknownOuter->lpVtbl->QueryInterface(
		pWaveStuff->pUnknownOuter, iid, ppv);
}

/*	-	-	-	-	-	-	-	-	*/

//
// Use our controlling object to call AddRef on Unknown
//
STDMETHODIMP_(ULONG) WaveStreamAddRef(
	PAVISTREAM	ps)
{
	// Get a pointer to our structure
	LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_STREAM(ps);

	return pWaveStuff->pUnknownOuter->lpVtbl->AddRef(
		pWaveStuff->pUnknownOuter);
}

/*	-	-	-	-	-	-	-	-	*/

//
// Use our controlling object to call Release on Unknown
//
STDMETHODIMP_(ULONG) WaveStreamRelease(
	PAVISTREAM	ps)
{
	// Get a pointer to our structure
	LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_STREAM(ps);

	return pWaveStuff->pUnknownOuter->lpVtbl->Release(
		pWaveStuff->pUnknownOuter);
}

/*	-	-	-	-	-	-	-	-	*/

#define SLASH(c)	((c) == TEXT('/') || (c) == TEXT('\\'))

/*--------------------------------------------------------------+
| FileName  - return a pointer to the filename part of szPath   |
|             with no preceding path.                           |
|             note:  perhaps we should use GetFullPathName      |
+--------------------------------------------------------------*/
LPTSTR FAR FileName(
	LPCTSTR lszPath)
{
	LPCTSTR lszCur;

	for (lszCur = lszPath + lstrlen(lszPath); lszCur > lszPath && !SLASH(*lszCur) && *lszCur != ':';)
	lszCur = CharPrev(lszPath, lszCur);
	if (lszCur == lszPath)
	return (LPTSTR)lszCur;
	else
	return (LPTSTR)(lszCur + 1);
}

STDMETHODIMP ParseAUFile(LPWAVESTUFF p);


/*	-	-	-	-	-	-	-	-	*/

STDMETHODIMP ParseWaveFile(LPWAVESTUFF p)
{
    MMCKINFO	ck;
    MMCKINFO	ckRIFF;
    /* Read RIFF chunk */
    if (shfileDescend(p->hshfile, &ckRIFF, NULL, 0) != 0)
	goto error;

    if (ckRIFF.ckid != FOURCC_RIFF || ckRIFF.fccType != formtypeWAVE)
	return ParseAUFile(p);

    /* Read WAVE format chunk */
    ck.ckid = ckidWAVEFORMAT;
    if (FindChunkAndKeepExtras(&p->extra, p->hshfile, &ck, &ckRIFF, MMIO_FINDCHUNK))
	goto error;

    p->cbFormat = ck.cksize;
    p->lpFormat = (LPWAVEFORMATEX) GlobalAllocPtr(GMEM_MOVEABLE, ck.cksize);

    if (p->lpFormat == NULL)
	goto error;

    if (shfileRead(p->hshfile,
	    (HPSTR) p->lpFormat,
	    (LONG)ck.cksize) != (LONG)ck.cksize)
	goto error;

    /* Ascend out of stream header */
    if (shfileAscend(p->hshfile, &ck, 0) != 0)
	goto error;

    /* Find big data chunk */
    p->ckData.ckid = ckidWAVEDATA;
    if (FindChunkAndKeepExtras(&p->extra, p->hshfile, &p->ckData, &ckRIFF, MMIO_FINDCHUNK))
	goto error;

    p->fDirty = FALSE;

    p->avistream.fccType = streamtypeAUDIO;
    p->avistream.fccHandler = 0;
    p->avistream.dwFlags = 0;
    p->avistream.wPriority = 0;
    p->avistream.wLanguage = 0;
    p->avistream.dwInitialFrames = 0;
    p->avistream.dwScale = p->lpFormat->nBlockAlign;
    p->avistream.dwRate = p->lpFormat->nAvgBytesPerSec;
    p->avistream.dwStart = 0;
    p->avistream.dwLength = p->ckData.cksize / p->lpFormat->nBlockAlign;
    p->avistream.dwSuggestedBufferSize = 0;
    p->avistream.dwSampleSize = p->lpFormat->nBlockAlign;

#ifdef FPSHACK
    p->avihdr.dwLength = muldiv32(p->avistream.dwLength,
			    p->avistream.dwScale * FPSHACK,
			    p->avistream.dwRate);
#else
    p->avihdr.dwScale = 1;
    p->avihdr.dwRate = p->lpFormat->nSamplesPerSec;
    p->avihdr.dwLength = muldiv32(p->ckData.cksize,
			    p->lpFormat->nSamplesPerSec,
			    p->lpFormat->nAvgBytesPerSec);
#endif


    shfileAscend(p->hshfile, &p->ckData, 0);

    // Read extra data at end of file....
    if (FindChunkAndKeepExtras(&p->extra, p->hshfile, &ckRIFF, &ck, 0) != AVIERR_OK)
	goto error;

    return ResultFromScode(0); // success
	
error:
    return ResultFromScode(AVIERR_FILEREAD);
}

//
// The Open Method for our File interface - Open a WAVE file
//
STDMETHODIMP WaveFileOpen(
	PAVIFILE pf,
	LPCTSTR szFile,
	UINT mode)
{
    LPWAVESTUFF p = WAVESTUFF_FROM_FILE(pf);
    UINT	ui;
    TCHAR	ach[80];
    HRESULT	hr = NOERROR;

    // !!! Assumptions about the AVIFILE.DLL (which calls us):
    // We will only see READWRITE mode, never only WRITE mode.

// if it ain't broke, don't fix it
#if 0
    // force the share flags to the 'correct' values
    // If we're writing, use Exclusive mode.  If we're reading, use DenyWrite.
    if (mode & OF_READWRITE) {
	mode = (mode & ~(MMIO_SHAREMODE)) | OF_SHARE_EXCLUSIVE;
    } else {
	mode = (mode & ~(MMIO_SHAREMODE)) | OF_SHARE_DENY_WRITE;
    }
#endif

    //
    // try to open the actual file, first with share, then without.
    // You may need to use specific flags in order to open a file
    // that's already open by somebody else.
    //

    // If the first attempt fails, no system error box, please.
    ui = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    p->hshfile = shfileOpen((LPTSTR) szFile, NULL, MMIO_ALLOCBUF | mode);
    if (!p->hshfile && ((mode & MMIO_RWMODE) == OF_READ)) {
    // if the open fails, try again without the share flags.
	mode &= ~(MMIO_SHAREMODE);
	p->hshfile = shfileOpen((LPTSTR) szFile, NULL, MMIO_ALLOCBUF | mode);
    }
    SetErrorMode(ui);

    //
    // Now set up our structure
    //

    p->mode = mode;

    if (!p->hshfile)
	goto error;

    _fmemset(&p->avistream, 0, sizeof(p->avistream));

// If this is defined, we pretend that the data is at FPSHACK "frames"
// per second in the main header, otherwise we use the sample
// rate of the audio, which looks somewhat strange in MPlayer.
#define FPSHACK	1000

    _fmemset(&p->avihdr, 0, sizeof(p->avihdr));

#ifdef FPSHACK
    //
    // Initialize our AVIFILEHEADER
    //
    p->avihdr.dwRate = FPSHACK;
    p->avihdr.dwScale = 1;
#endif

    p->avihdr.dwStreams = 1;
    LoadUnicodeString(ghMod, IDS_FILETYPE, p->avihdr.szFileType,
		      NUMELMS(p->avihdr.szFileType));

    //
    // Initialize our AVISTREAMHEADER
    //
    LoadString(ghMod, IDS_STREAMNAME, ach, NUMELMS(ach));
    {
	TCHAR   achTemp[MAX_PATH];

	// Fix: Change from wsprintf to StringCchPrintf so we don't overrun achTemp
	StringCchPrintf(achTemp, NUMELMS(achTemp), ach, FileName(szFile));

#ifdef UNICODE
	lstrzcpy (p->avistream.szName,achTemp,NUMELMS(p->avistream.szName));
#else
	lstrzcpyAtoW (p->avistream.szName,achTemp,NUMELMS(p->avistream.szName));
#endif
    }

    if (mode & OF_CREATE) {	// Brand new file
	p->avistream.fccType = streamtypeAUDIO;
	p->avistream.fccHandler = 0;
	p->avistream.dwFlags = 0;
	p->avistream.wPriority = 0;
	p->avistream.wLanguage = 0;
	p->avistream.dwInitialFrames = 0;
	p->avistream.dwScale = 0;
	p->avistream.dwRate = 0;
	p->avistream.dwStart = 0;
	p->avistream.dwLength = 0;
	p->avistream.dwSuggestedBufferSize = 0;
	p->avistream.dwSampleSize = 0;

	p->fDirty = TRUE;
    } else {		// read the existing file to get info
	hr = ParseWaveFile(p);
    }

    return hr;

error:
    return ResultFromScode(AVIERR_FILEREAD);
}

typedef struct {
    DWORD magic;               /* magic number SND_MAGIC */
    DWORD dataLocation;        /* offset or poDWORDer to the data */
    DWORD dataSize;            /* number of bytes of data */
    DWORD dataFormat;          /* the data format code */
    DWORD samplingRate;        /* the sampling rate */
    DWORD channelCount;        /* the number of channels */
    DWORD fccInfo;             /* optional text information */
} SNDSoundStruct;

#define  SND_FORMAT_MULAW_8  1 // 8-bit mu-law samples
#define  SND_FORMAT_LINEAR_8 2 // 8-bit linear samples

#define SWAP(x,y) ( (x)^=(y), (y)^=(x), (x)^=(y) )

void _inline SwapDWORD( DWORD FAR * pdw )
{
    SWAP(((BYTE FAR *)pdw)[0],((BYTE FAR *)pdw)[3]);
    SWAP(((BYTE FAR *)pdw)[1],((BYTE FAR *)pdw)[2]);
}

STDMETHODIMP ParseAUFile(LPWAVESTUFF p)
{
    SNDSoundStruct  header;

    shfileSeek(p->hshfile, 0, SEEK_SET);

    if (shfileRead(p->hshfile, (HPSTR) &header, sizeof(header)) != sizeof(header))
	goto error;

    // validate header
    // !!!
    if (header.magic != mmioFOURCC('.', 's', 'n', 'd'))
	goto error;

    SwapDWORD(&header.dataFormat);
    SwapDWORD(&header.dataLocation);
    SwapDWORD(&header.dataSize);
    SwapDWORD(&header.samplingRate);
    SwapDWORD(&header.channelCount);

    p->cbFormat = sizeof(WAVEFORMATEX);
    p->lpFormat = (LPWAVEFORMATEX) GlobalAllocPtr(GHND, p->cbFormat);

    if (p->lpFormat == NULL)
	    goto error;

    p->mode = OF_READ | OF_SHARE_DENY_WRITE;
	
    // fill in wave format fields
    if (header.dataFormat == SND_FORMAT_MULAW_8) {
	p->lpFormat->wFormatTag = WAVE_FORMAT_MULAW;
	p->lpFormat->wBitsPerSample = 8;
	
	// !!! HACK: if the sampling rate is almost 8KHz, make it be
	// exactly 8KHz, so that more sound cards will play it right.
	if (header.samplingRate > 7980 && header.samplingRate < 8020)
	    header.samplingRate = 8000;

    } else if (header.dataFormat == SND_FORMAT_LINEAR_8) {
	p->lpFormat->wFormatTag = WAVE_FORMAT_PCM;
	p->lpFormat->wBitsPerSample = 8;
	// Could support LINEAR_16, but would have to byte-swap everything....
    } else
	goto error;

    p->lpFormat->nChannels = (UINT) header.channelCount;
    p->lpFormat->nSamplesPerSec = header.samplingRate;
    p->lpFormat->nAvgBytesPerSec =  header.samplingRate * p->lpFormat->nChannels;
    p->lpFormat->nBlockAlign = 1;

    /* Tell rest of handler where data is */
    p->ckData.dwDataOffset = header.dataLocation;
    p->ckData.cksize = header.dataSize;

    p->fDirty = FALSE;

    p->avistream.fccType = streamtypeAUDIO;
    p->avistream.fccHandler = 0;
    p->avistream.dwFlags = 0;
    p->avistream.wPriority = 0;
    p->avistream.wLanguage = 0;
    p->avistream.dwInitialFrames = 0;
    p->avistream.dwScale = p->lpFormat->nBlockAlign;
    p->avistream.dwRate = p->lpFormat->nAvgBytesPerSec;
    p->avistream.dwStart = 0;
    p->avistream.dwLength = p->ckData.cksize / p->lpFormat->nBlockAlign;
    p->avistream.dwSuggestedBufferSize = 0;
    p->avistream.dwSampleSize = p->lpFormat->nBlockAlign;

#ifdef FPSHACK
    p->avihdr.dwLength = muldiv32(p->avistream.dwLength,
			    p->avistream.dwScale * FPSHACK,
			    p->avistream.dwRate);
#else
    p->avihdr.dwScale = 1;
    p->avihdr.dwRate = p->lpFormat->nSamplesPerSec;
    p->avihdr.dwLength = muldiv32(p->ckData.cksize,
			    p->lpFormat->nSamplesPerSec,
			    p->lpFormat->nAvgBytesPerSec);
#endif

    return ResultFromScode(0); // success
	
error:
    return ResultFromScode(AVIERR_FILEREAD);
}

//
// Get a stream from the file... Each WAVE file has exactly 1 audio stream.
//
STDMETHODIMP WaveFileGetStream(
	PAVIFILE pf,
	PAVISTREAM FAR * ppavi,
	DWORD fccType,
	LONG lParam)
{
	int iStreamWant;
	// Get a pointer to our structure
	LPWAVESTUFF p = WAVESTUFF_FROM_FILE(pf);

	iStreamWant = (int)lParam;

	if (p->lpFormat == NULL)
		return ResultFromScode(AVIERR_BADPARAM);
	
	// We only support one stream
	if (iStreamWant != 0)
		return ResultFromScode(AVIERR_BADPARAM);

	// We only support audio streams
	if (fccType && fccType != streamtypeAUDIO)
		return ResultFromScode(AVIERR_BADPARAM);

	// increase the reference count
	p->AVIStream->AddRef((PAVISTREAM)&p->AVIStream);
	
	// Return a pointer to our stream Vtbl
	*ppavi = (PAVISTREAM) &(p->AVIStream);
	return ResultFromScode(AVIERR_OK);
}


STDMETHODIMP WaveFileDeleteStream(PAVIFILE pf, DWORD fccType, LONG lParam)
{
	int iStreamWant;
	// Get a pointer to our structure
	LPWAVESTUFF p = WAVESTUFF_FROM_FILE(pf);

	iStreamWant = (int)lParam;

	if (p->lpFormat == NULL)
		return ResultFromScode(AVIERR_BADPARAM);
	
	// We only support one stream
	if (iStreamWant != 0)
		return ResultFromScode(AVIERR_BADPARAM);

	// We only support audio streams
	if (fccType && fccType != streamtypeAUDIO)
		return ResultFromScode(AVIERR_BADPARAM);


	GlobalFreePtr(p->lpFormat);
	p->lpFormat = NULL;

	return NOERROR;
}

//
// We don't support the Save Method of the File Interface (We don't save)
//
STDMETHODIMP WaveFileSave(
	PAVIFILE pf,
	LPCSTR szFile,
	AVICOMPRESSOPTIONS FAR *lpOptions,
	AVISAVECALLBACK lpfnCallback)
{
	return ResultFromScode(AVIERR_UNSUPPORTED);
}

//
// Method to create a stream in a WAVE file.  We only support this for blank
// WAVE files.
//
STDMETHODIMP WaveFileCreateStream(
	PAVIFILE pf,
	PAVISTREAM FAR *ppstream,
	AVISTREAMINFOW FAR *psi)
{
	// Get a pointer to our structure
	LPWAVESTUFF p = WAVESTUFF_FROM_FILE(pf);

	// We can't add a second stream to a file
	if (p->lpFormat)
		return ResultFromScode(AVIERR_UNSUPPORTED);

	// We only like audio....
	if (psi->fccType != streamtypeAUDIO)
		return ResultFromScode(AVIERR_UNSUPPORTED);
	
	// Increase our reference count.
	p->AVIStream->AddRef((PAVISTREAM)&p->AVIStream);

	p->cbFormat = 0;
	p->lpFormat = NULL;

	// Return a pointer to our stream Vtbl.
	*ppstream = (PAVISTREAM) &(p->AVIStream);
	
	return ResultFromScode(AVIERR_OK);
}

//
// The WriteData Method of the File interface
//
STDMETHODIMP WaveFileWriteData(
	PAVIFILE pf,
	DWORD ckid,
	LPVOID lpData,
	LONG cbData)
{
	// Get a pointer to our structure
	LPWAVESTUFF p = WAVESTUFF_FROM_FILE(pf);

	// Write the data in the Wave File.
	return ResultFromScode(WriteExtra(&p->extra, ckid, lpData, cbData));
}

//
// The ReadData Method of the File interface
//
STDMETHODIMP WaveFileReadData(
	PAVIFILE pf,
	DWORD ckid,
	LPVOID lpData,
	LONG FAR *lpcbData)
{
	// Get a pointer to our structure
	LPWAVESTUFF p = WAVESTUFF_FROM_FILE(pf);

	// Read the data from the file
	return ResultFromScode(ReadExtra(&p->extra, ckid, lpData, lpcbData));
}

//
// The EndRecord Method of the File interface.. this doesn't need to do
// anything.. (no concept of interleaving or packaging streams)
//
STDMETHODIMP WaveFileEndRecord(
	PAVIFILE pf)
{
	return ResultFromScode(AVIERR_OK);
}


//
// The Info Method of the File interface
//
STDMETHODIMP WaveFileInfo(
	PAVIFILE pf,
	AVIFILEINFOW FAR * pfi,
	LONG lSize)
{
	// Get a pointer to our structure
	LPWAVESTUFF p = WAVESTUFF_FROM_FILE(pf);

	// Return an AVIFILEHEADER.
	hmemcpy(pfi, &p->avihdr, min(lSize, sizeof(p->avihdr)));
	return 0;
}



//
// The Create Method of the Stream interface. We can't create streams that
// aren't attached to the file.
//
STDMETHODIMP WaveStreamCreate(
	PAVISTREAM	ps,
	LPARAM lParam1,
	LPARAM lParam2)
{
	return ResultFromScode(AVIERR_UNSUPPORTED);
}


//
// The FindSample Method of the Stream interface
//
STDMETHODIMP_(LONG) WaveStreamFindSample(
	PAVISTREAM	ps,
	LONG lPos, LONG lFlags)
{
	if (lFlags & FIND_FORMAT) {
		if ((lFlags & FIND_NEXT) && lPos > 0)
			return -1;
		else
			return 0;
	}

	return lPos;
}


//
// The ReadFormat Method of the Stream interface
//
STDMETHODIMP WaveStreamReadFormat(
	PAVISTREAM	ps,
	LONG lPos,
	LPVOID lpFormat,
	LONG FAR *lpcbFormat)
{
	// Get a pointer to our structure
	LPWAVESTUFF p = WAVESTUFF_FROM_STREAM(ps);

	// No buffer to fill in, this means return the size needed.
	if (lpFormat == NULL || *lpcbFormat == 0) {
		*lpcbFormat = p->cbFormat;
		return 0;
	}

	// Give them the WAVE format.
	hmemcpy(lpFormat, p->lpFormat, min(*lpcbFormat, p->cbFormat));

	// Our buffer is too small
	if (*lpcbFormat < p->cbFormat)
		return ResultFromScode(AVIERR_BUFFERTOOSMALL);

	*lpcbFormat = p->cbFormat;

	return 0;
}

//
// The Info Method of the Stream interface
//
STDMETHODIMP WaveStreamInfo(
	PAVISTREAM	ps,
	AVISTREAMINFOW FAR * psi,
	LONG lSize)
{
	// Get a pointer to our structure
	LPWAVESTUFF p = WAVESTUFF_FROM_STREAM(ps);

	// give them an AVISTREAMINFO
	hmemcpy(psi, &p->avistream, min(lSize, sizeof(p->avistream)));
	return 0;
}


STDMETHODIMP WaveStreamSetInfo(PAVISTREAM ps, AVISTREAMINFOW FAR * psi, LONG lSize)
{
	return ResultFromScode(AVIERR_UNSUPPORTED);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

/*
		invalid lPos return error

		if lPos + lSamples is invalid trim lSamples to fit.

		lpBuffer == NULL

			cbBuffer == 0 && lSamples > 0
				return size of lSamples sample.
			else
				return the exactly the number of bytes and sample
				you would have read if lpBuffer was not zero.

			NOTE return means fill in *plBytes and *plSamples.

		lpBuffer != NULL

			lSamples == -1      read convenient amount (just fill buffer)
			lSamples == 0       fill buffer with as many samples that will fit.
			lSamples >  0       read lSamples (or as much will fit in cbBuffer)

			fill in *plBytes   with bytes actualy read
			fill in *plSamples with samples actualy read

*/

//
// The Read Method for the Stream Interface - Read some wave data
STDMETHODIMP WaveStreamRead(
	PAVISTREAM	ps,
	LONG		lStart,
	LONG		lSamples,
	LPVOID		lpBuffer,
	LONG		cbBuffer,
	LONG FAR *	plBytes,
	LONG FAR *	plSamples)
{
	// Get a pointer to our structure
	LPWAVESTUFF p = WAVESTUFF_FROM_STREAM(ps);

	LONG	lSampleSize;
	LONG	lSeek;
	LONG	lRead;

	// Invalid position
	if (lStart < 0 || lStart > (LONG) p->avistream.dwLength) {
ack:
		if (plBytes)
			*plBytes = 0;
		if (plSamples)
			*plSamples = 0;
		return 0;
	}
	
	// Can't read quite this much data
	if (lSamples + lStart > (LONG) p->avistream.dwLength)
		lSamples = p->avistream.dwLength - lStart;
	
	lSampleSize = p->avistream.dwSampleSize;

	// We have fixed-length samples

	if (lpBuffer == NULL) {
		if (cbBuffer > 0 && lSamples > 0)
			// Trim how many samples we'd really be able to read
			lSamples = min(lSamples, cbBuffer / lSampleSize);
		else if (lSamples <= 0)
	    		// Use as many as will fit
			lSamples = cbBuffer / lSampleSize;
	} else {
		if (lSamples > 0)
			// Trim how many samples we'd really be able to read
			lSamples = min(lSamples, cbBuffer / lSampleSize);
		else
			// Use as many as will fit
			lSamples = cbBuffer / lSampleSize;
	}

	//
	// a NULL buffer means return the size buffer needed to read
	// the given sample.
	//
	if (lpBuffer == NULL || cbBuffer == 0) {
		if (plBytes)
			*plBytes = lSamples * lSampleSize;;
		if (plSamples)
			*plSamples = lSamples;
		return 0;
	}

	// Buffer too small!
	if (cbBuffer < lSampleSize)
		goto ack;

	// Seek and read

	cbBuffer = lSamples * lSampleSize;

	lSeek = p->ckData.dwDataOffset + lSampleSize * lStart;
	lRead = lSamples * lSampleSize;
	
	if (shfileSeek(p->hshfile, lSeek, SEEK_SET) != lSeek)
		goto ack;

	if (shfileRead(p->hshfile, (HPSTR) lpBuffer, lRead) != lRead)
		goto ack;
	
	//
	// success return number of bytes and number of samples read
	//
	if (plBytes)
		*plBytes = lRead;

	if (plSamples)
		*plSamples = lSamples;

	return ResultFromScode(AVIERR_OK);
}


//
// The SetFormat Method of the Stream interface	- called on an empty WAVE file
// before writing data to it.
//
STDMETHODIMP WaveStreamSetFormat(
	PAVISTREAM ps,
	LONG lPos,
	LPVOID lpFormat,
	LONG cbFormat)
{
	// Get a pointer to our structure
	LPWAVESTUFF p = WAVESTUFF_FROM_STREAM(ps);

	// We can only do this to an empty wave file
	if (p->lpFormat) {
		if (cbFormat != p->cbFormat ||
			_fmemcmp(lpFormat, p->lpFormat, (int) cbFormat))
			return ResultFromScode(AVIERR_UNSUPPORTED);
	
		return NOERROR;
	}
	
	// Go ahead and set the format!

	p->cbFormat = cbFormat;
	p->lpFormat = (LPWAVEFORMATEX) GlobalAllocPtr(GMEM_MOVEABLE, cbFormat);

	if (p->lpFormat == NULL)
		return ResultFromScode(AVIERR_MEMORY);

	hmemcpy(p->lpFormat, lpFormat, cbFormat);

	p->ckData.dwDataOffset = cbFormat + 7 * sizeof(DWORD);
	p->ckData.cksize = 0;
	p->avistream.dwScale = p->lpFormat->nBlockAlign;
	p->avistream.dwRate = p->lpFormat->nAvgBytesPerSec;
	p->avistream.dwLength = 0;
	p->avistream.dwSampleSize = p->lpFormat->nBlockAlign;

#ifndef FPSHACK
	p->avihdr.dwScale = 1;
	p->avihdr.dwRate = p->lpFormat->nSamplesPerSec;
#endif
	return ResultFromScode(AVIERR_OK);
}

//
// The Write Method of the Stream interface - write some wave data
//
STDMETHODIMP WaveStreamWrite(
	PAVISTREAM ps,
	LONG lStart,
	LONG lSamples,
	LPVOID lpData,
	LONG cbData,
	DWORD dwFlags,
	LONG FAR *plSampWritten,
	LONG FAR *plBytesWritten)
{
	// Get a pointer to our structure
	LPWAVESTUFF p = WAVESTUFF_FROM_STREAM(ps);

	if ((p->mode & (OF_WRITE | OF_READWRITE)) == 0)
		return ResultFromScode(AVIERR_READONLY);

	// < 0 means "at end"
	if (lStart < 0)
		// !!!
		lStart = p->avistream.dwStart + p->avistream.dwLength;

#if 0 // !!! don't check for too long - why not?
	if (lStart > (LONG) (p->avistream.dwStart + p->avistream.dwLength))
		return ResultFromScode(AVIERR_BADPARAM);
#endif

	p->fDirty = TRUE;

	shfileSeek(p->hshfile,
		p->ckData.dwDataOffset +
		lStart * p->avistream.dwSampleSize,
		SEEK_SET);

	if (shfileWrite(p->hshfile, (HPSTR) lpData, cbData) != cbData)
		return ResultFromScode(AVIERR_FILEWRITE);

	p->avistream.dwLength = max((LONG) p->avistream.dwLength,
					lStart + lSamples);

	p->ckData.cksize = max(p->ckData.cksize,
				lStart * p->avistream.dwSampleSize + cbData);

#ifdef FPSHACK
	p->avihdr.dwLength = muldiv32(p->avistream.dwLength * FPSHACK,
				p->avistream.dwScale,
				p->avistream.dwRate);
#else
	p->avihdr.dwLength = muldiv32(p->ckData.cksize,
				p->lpFormat->nSamplesPerSec,
				p->lpFormat->nAvgBytesPerSec);
#endif

	
	if (plSampWritten)
		*plSampWritten = lSamples;

	if (plBytesWritten)
		*plBytesWritten = cbData;
	
	return ResultFromScode(AVIERR_OK);
}

//
// The Delete Method of the Stream interface - we don't cut from wave files
//
STDMETHODIMP WaveStreamDelete(
	PAVISTREAM ps,
	LONG lStart,
	LONG lSamples)
{
	return ResultFromScode(AVIERR_UNSUPPORTED);
}


//
// We also don't support ReadData and WriteData for the Stream Interface
//

STDMETHODIMP WaveStreamReadData(
	PAVISTREAM ps,
	DWORD fcc,
	LPVOID lp,
	LONG FAR *lpcb)
{
	return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP WaveStreamWriteData(
	PAVISTREAM ps,
	DWORD fcc,
	LPVOID lp,
	LONG cb)
{
	return ResultFromScode(AVIERR_UNSUPPORTED);
}


STDMETHODIMP WaveFileReserved(
	PAVIFILE pf)
{
	return ResultFromScode(AVIERR_UNSUPPORTED);
}

STDMETHODIMP WaveStreamReserved(
	PAVISTREAM ps)
{
	return ResultFromScode(AVIERR_UNSUPPORTED);
}

/*      -       -       -       -       -       -       -       -       */

// *** IPersist methods ***
STDMETHODIMP WavePersistGetClassID (LPPERSISTFILE ppf, LPCLSID lpClassID)
{
    // Get a pointer to our structure
    LPWAVESTUFF pfile = WAVESTUFF_FROM_PERSIST(ppf);

    // hmemcpy(lpClassID, &CLSID_AVIWaveFileReader, sizeof(CLSID));
    return NOERROR;
}

// *** IPersistFile methods ***
STDMETHODIMP WavePersistIsDirty (LPPERSISTFILE ppf)
{
    // Get a pointer to our structure
    LPWAVESTUFF pfile = WAVESTUFF_FROM_PERSIST(ppf);

    return pfile->fDirty ? NOERROR : ResultFromScode(S_FALSE);
}

STDMETHODIMP WavePersistLoad (LPPERSISTFILE ppf,
			      LPCOLESTR lpszFileName, DWORD grfMode)
{
    // Get a pointer to our structure
    LPWAVESTUFF pfile = WAVESTUFF_FROM_PERSIST(ppf);


#if defined _WIN32 && !defined UNICODE
    char    achTemp[256];

    // Internally, we're using ANSI, but this interface is defined
    // to always accept UNICODE under _WIN32, so we have to convert.
    lstrzcpyWtoA (achTemp, lpszFileName, NUMELMS(achTemp));
#else
    #define achTemp	lpszFileName
#endif

    return WaveFileOpen((PAVIFILE) &pfile->AVIFile, achTemp, (UINT) grfMode);
}

STDMETHODIMP WavePersistSave (LPPERSISTFILE ppf,
			      LPCOLESTR lpszFileName, BOOL fRemember)
{
	// Get a pointer to our structure
	LPWAVESTUFF pfile = WAVESTUFF_FROM_PERSIST(ppf);


    return ResultFromScode(E_FAIL);
}

STDMETHODIMP WavePersistSaveCompleted (LPPERSISTFILE ppf,
				       LPCOLESTR lpszFileName)
{
	// Get a pointer to our structure
	LPWAVESTUFF pfile = WAVESTUFF_FROM_PERSIST(ppf);


    return NOERROR;
}

STDMETHODIMP WavePersistGetCurFile (LPPERSISTFILE ppf,
				    LPOLESTR FAR * lplpszFileName)
{
    // Get a pointer to our structure
    LPWAVESTUFF pfile = WAVESTUFF_FROM_PERSIST(ppf);

    return ResultFromScode(E_FAIL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile.16\afclip.c ===
/****************************************************************************
 *
 *  AVICLIP.C
 *
 *  Clipboard support for AVIFile
 *
 *  Copyright (c) 1992 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#include <win32.h>
#include <compobj.h>
#include <ole2.h>
#include <dvobj.h>
#include <compman.h>
#include "avifile.h"
#include "avimem.h"
#include "enumfetc.h"
#include "debug.h"

//#define TRYLINKS
#ifdef TRYLINKS
static  SZCODE aszLink[]              = "OwnerLink";
#endif

/* From avifps.h.... */
BOOL FAR TaskHasExistingProxies(void);

#define OWNER_DISPLAY   0

STDMETHODIMP AVIClipQueryInterface(LPDATAOBJECT lpd, REFIID riid, LPVOID FAR* ppvObj);
STDMETHODIMP_(ULONG) AVIClipAddRef(LPDATAOBJECT lpd);
STDMETHODIMP_(ULONG) AVIClipRelease(LPDATAOBJECT lpd);
STDMETHODIMP AVIClipGetData(LPDATAOBJECT lpd, LPFORMATETC pformatetcIn,
			LPSTGMEDIUM pmedium );
STDMETHODIMP AVIClipGetDataHere(LPDATAOBJECT lpd, LPFORMATETC pformatetc,
			LPSTGMEDIUM pmedium );
STDMETHODIMP AVIClipQueryGetData(LPDATAOBJECT lpd, LPFORMATETC pformatetc );
STDMETHODIMP AVIClipGetCanonicalFormatEtc(LPDATAOBJECT lpd, LPFORMATETC pformatetc,
			LPFORMATETC pformatetcOut);
STDMETHODIMP AVIClipSetData(LPDATAOBJECT lpd, LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
			BOOL fRelease);
STDMETHODIMP AVIClipEnumFormatEtc(LPDATAOBJECT lpd, DWORD dwDirection,
			LPENUMFORMATETC FAR* ppenumFormatEtc);
STDMETHODIMP AVIClipDAdvise(LPDATAOBJECT lpd, FORMATETC FAR* pFormatetc, DWORD advf,
		LPADVISESINK pAdvSink, DWORD FAR* pdwConnection);
STDMETHODIMP AVIClipDUnadvise(LPDATAOBJECT lpd, DWORD dwConnection);
STDMETHODIMP AVIClipEnumDAdvise(LPDATAOBJECT lpd, LPENUMSTATDATA FAR* ppenumAdvise);

HMODULE ghOLE2 = NULL; // handle to OLE2.DLL module

IDataObjectVtbl AVIClipVtbl = {
    AVIClipQueryInterface,
    AVIClipAddRef,
    AVIClipRelease,
    AVIClipGetData,
    AVIClipGetDataHere,
    AVIClipQueryGetData,
    AVIClipGetCanonicalFormatEtc,
    AVIClipSetData,
    AVIClipEnumFormatEtc,
    AVIClipDAdvise,
    AVIClipDUnadvise,
    AVIClipEnumDAdvise
};

#define N_FORMATS   (sizeof(FormatList) / sizeof(FormatList[0]))
FORMATETC FormatList[] = {
    // CF_WAVE must be first, see AVIPutFileOnClipboard
    {CF_WAVE, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    {CF_DIB, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    // CF_PALETTE must be last, see AVIPutFileOnClipboard
    {CF_PALETTE, NULL, DVASPECT_CONTENT, -1, TYMED_GDI}
};

#define AVICLIP_MAGIC   0x42424242

typedef struct {
    IDataObjectVtbl FAR * lpVtbl;
    DWORD               Magic;

    ULONG		ulRefCount;

    PAVIFILE		pf;

    WORD		wFormats;
    LPFORMATETC         lpFormats;

    //!!! what about IDataView
    //!!! what about a IGetFrame

    HWND                hwndMci;
    PGETFRAME           pgf;

} AVICLIP, FAR * LPAVICLIP;

#if OWNER_DISPLAY
static LRESULT CALLBACK _loadds ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LONG lParam);
static WNDPROC OldClipboardWindowProc;
static LPAVICLIP lpcClipboard;
#endif

#ifdef WIN32

static HRESULT STDAPICALLTYPE OleStubP(LPVOID p) {return ResultFromScode(E_FAIL);}
static HRESULT STDAPICALLTYPE OleStubV(void)     {return ResultFromScode(E_FAIL);}

HRESULT (STDAPICALLTYPE *XOleInitialize)(LPMALLOC pMalloc);
void    (STDAPICALLTYPE *XOleUninitialize)(void);
HRESULT (STDAPICALLTYPE *XOleFlushClipboard)(void);
HRESULT (STDAPICALLTYPE *XOleSetClipboard)(LPDATAOBJECT pDataObj);
HRESULT (STDAPICALLTYPE *XOleGetClipboard)(LPDATAOBJECT FAR* ppDataObj);

#define OleInitialize     XOleInitialize
#define OleUninitialize   XOleUninitialize
#define OleGetClipboard   XOleGetClipboard
#define OleSetClipboard   XOleSetClipboard
#define OleFlushClipboard XOleFlushClipboard
#endif

HRESULT NEAR PASCAL InitOle(void)
{
    UINT w;

    if (!ghOLE2) {
	DPF("Loading OLE2.DLL\n");
	w = SetErrorMode(SEM_NOOPENFILEERRORBOX);
#ifdef WIN32
	ghOLE2 = LoadLibrary("OLE2W32.DLL");
#else
	ghOLE2 = LoadLibrary("OLE2.DLL");
#endif
	SetErrorMode(w);
    }

#ifndef WIN32
    if ((UINT)ghOLE2 <= (UINT)HINSTANCE_ERROR)
    	ghOLE2 = NULL;
#endif

#ifdef WIN32
    //
    // dyna link to OLE on NT
    //
    if (ghOLE2)
    {
        (FARPROC)XOleInitialize     = GetProcAddress(ghOLE2, "OleInitialize");
        (FARPROC)XOleUninitialize   = GetProcAddress(ghOLE2, "OleUninitialize");
        (FARPROC)XOleGetClipboard   = GetProcAddress(ghOLE2, "OleGetClipboard");
        (FARPROC)XOleSetClipboard   = GetProcAddress(ghOLE2, "OleSetClipboard");
        (FARPROC)XOleFlushClipboard = GetProcAddress(ghOLE2, "OleFlushClipboard");
    }
    else
    {
        (FARPROC)XOleInitialize     = (FARPROC)OleStubP;
        (FARPROC)XOleGetClipboard   = (FARPROC)OleStubP;
        (FARPROC)XOleSetClipboard   = (FARPROC)OleStubP;
        (FARPROC)XOleUninitialize   = (FARPROC)OleStubV;
        (FARPROC)XOleFlushClipboard = (FARPROC)OleStubV;
    }    	
#endif

    return OleInitialize(NULL);
}

STDAPI AVIGetDataObject(PAVIFILE pf, LPDATAOBJECT FAR *ppDataObj)
{
    LPAVICLIP	lpc;
    PAVISTREAM	ps;

    if (pf == NULL) {
	*ppDataObj = NULL;
	return NOERROR;
    }
    
    AVIFileAddRef(pf);
    
    lpc = (LPAVICLIP) GlobalAllocPtr(GHND | GMEM_SHARE, sizeof(AVICLIP));

    if (!lpc)
	return ResultFromScode(AVIERR_MEMORY);
    
    lpc->lpVtbl = &AVIClipVtbl;
    lpc->ulRefCount = 1;
    lpc->pf = pf;

    lpc->wFormats = N_FORMATS;
    lpc->lpFormats = FormatList;
    lpc->Magic = AVICLIP_MAGIC;

    //
    // if there is no video in the file, dont offer video
    // CF_WAVE must be first.
    //
    if (AVIFileGetStream(pf, &ps, streamtypeVIDEO, 0L) != NOERROR) {
        lpc->wFormats = 1;
    }
    else {
        //
        // if the video format is higher than 8bpp dont offer a palette
        // CF_PALETTE must be last.
        //
	AVISTREAMINFO		strhdr;
	BITMAPINFOHEADER	bi;
	DWORD			dwcbFormat;

	// get the stream header
	AVIStreamInfo(ps, &strhdr, sizeof(strhdr));
	
	// now read the format of this thing
	dwcbFormat = sizeof(bi);
	AVIStreamReadFormat(ps, strhdr.dwStart, (LPVOID)&bi, (LONG FAR *)&dwcbFormat);

	// if it is true color (i.e., > 8bpp) then don't use the palette
        if (bi.biBitCount > 8) {
	    DPF("Turning off CF_PALETTE now\n");
            lpc->wFormats--;	// don't use CF_PALETTE
        }

        ps->lpVtbl->Release(ps);  
    }

    //
    // if there is no audio in the file, dont offer audio
    // CF_WAVE must be first.
    //
    if (AVIFileGetStream(pf, &ps, streamtypeAUDIO, 0L) != NOERROR) {
        lpc->wFormats--;
        lpc->lpFormats++;
    }
    else {
        ps->lpVtbl->Release(ps);
    }

    *ppDataObj = (LPDATAOBJECT) lpc;

    return 0;
}


/**************************************************************************
* @doc EXTERNAL AVIPutFileOnClipboard
*
* @api HRESULT | AVIPutFileOnClipboard | Puts a file described by the passed
*	in PAVIFILE onto the clipboard.
*
* @parm PAVIFILE | pfile | Handle representing the file to put on the clipboard.
*
* @comm 
*
* @rdesc Returns zero on success or an error code.
*
* @xref AVIPutStreamOnClipboard AVIGetFromClipboard
*
*************************************************************************/
STDAPI AVIPutFileOnClipboard(PAVIFILE pf)
{
    LPDATAOBJECT lpd;
    HRESULT	hr;

    hr = AVIGetDataObject(pf, &lpd);

    InitOle();

    hr = OleSetClipboard(lpd);

    if (lpd) {
	lpd->lpVtbl->Release(lpd);

#if OWNER_DISPLAY
	lpcClipboard = lpc;

	//
	// hook the clipboard owner so we can do OWNER_DISPLAY formats
	//
	{
	HWND hwnd = GetClipboardOwner();

	if (OldClipboardWindowProc == NULL) {

	    if (hwnd) {
		OldClipboardWindowProc = (WNDPROC)SetWindowLong(hwnd,
		    GWL_WNDPROC, (LONG)ClipboardWindowProc);
	    }
	}

	if (OpenClipboard(hwnd)) {
	    SetClipboardData(CF_OWNERDISPLAY, NULL);
	    CloseClipboard();
	}
	}
#endif
    }
    
    return hr;
}

/**************************************************************************
* @doc EXTERNAL AVIGetFromClipboard
*
* @api HRESULT | AVIGetFromClipboard | Get a file or stream off of the
*	clipboard.
*
* @parm PAVIFILE FAR * | ppfile | Pointer to a variable that can 
*
* @comm If <p ppfile> is not NULL, the function will first attempt to
*	retrieve a file from the clipboard.  Then, if <p ppstream> is not
*	NULL, it will attempt to retrieve a stream.
*
*	Any file or stream retrieved from the clipboard using this
*	function should eventually be released with <f AVIStreamClose>
*	or <f AVIFileClose>.
*
* @rdesc Returns zero on success or an error code.  If there is no suitable
*	data on the clipboard, no error code will be returned, but
*	the returned variables will be NULL.
*
* @xref AVIPutStreamOnClipboard AVIGetFromClipboard
*
*************************************************************************/
STDAPI AVIGetFromClipboard(PAVIFILE FAR * lppf)
{
    LPDATAOBJECT	lpd = NULL;
    HRESULT		hr = NOERROR;
    FORMATETC		fetc;
    STGMEDIUM		stg;

    if (!lppf)
	return ResultFromScode(E_POINTER);
	
    *lppf = NULL;

    InitOle();

    OleGetClipboard(&lpd);

    if (lpd) {
#ifdef DEBUGXX
	// Print out lots of stuff about what's on the clipboard....
	{
	    LPENUMFORMATETC	lpEnum = NULL;
	    char		achTemp[256];

	    lpd->lpVtbl->EnumFormatEtc(lpd, DATADIR_GET, &lpEnum);

	    if (lpEnum) {
		DPF("Formats available:\n");
		while(lpEnum->lpVtbl->Next(lpEnum, 1,
					   (LPFORMATETC)&fetc,
					   NULL) == NOERROR) {
		    achTemp[0] = '\0';
		    GetClipboardFormatName(fetc.cfFormat, achTemp, sizeof(achTemp));
		    DPF("\t%u\t%lu\t%s\n", fetc.cfFormat, fetc.tymed, (LPSTR) achTemp);

		    if ((fetc.cfFormat == CF_WAVE) ||
			    (fetc.cfFormat == CF_DIB) ||
			    (fetc.cfFormat == CF_RIFF) ||
			    (fetc.cfFormat == CF_METAFILEPICT) ||
			    (fetc.cfFormat == CF_BITMAP) ||
			    (fetc.cfFormat == CF_PENDATA))
			continue;
		    
		    if (fetc.tymed & TYMED_HGLOBAL) {
			fetc.tymed = TYMED_HGLOBAL;
			hr = lpd->lpVtbl->GetData(lpd, &fetc, &stg);
			if (hr == 0) {
			    LPVOID  lp = GlobalLock(stg.hGlobal);
			    DPF("%s\n", (LPSTR) lp);
			    
			    ReleaseStgMedium(&stg);
			}
		    }
		}
	    }
	}
#endif
	
	lpd->lpVtbl->QueryInterface(lpd, &IID_IAVIFile, lppf);

	// Try for IAVIStream here?

#ifdef TRYLINKS
	// See if there's a link to a type of file we can open....
	if (!*lppf) {
	    UINT        cfLink;

	    cfLink      = RegisterClipboardFormat(aszLink);

	    fetc.cfFormat = cfLink;
	    fetc.ptd = 0;
	    fetc.dwAspect = DVASPECT_CONTENT;
	    fetc.lindex = -1;
	    fetc.tymed = TYMED_HGLOBAL;

	    hr = lpd->lpVtbl->GetData(lpd, &fetc, &stg);

	    if (hr == 0) {
		LPSTR lp = GlobalLock(stg.hGlobal);
		LPSTR lpName;

		lpName = lp + lstrlen(lp) + 1;
		DPF("Got CF_LINK (%s/%s) data from clipboard...\n", lp,lpName);
		hr = AVIFileOpen(lppf, lpName, OF_READ | OF_SHARE_DENY_WRITE, NULL);

		if (hr == 0) {
		    DPF("Opened file from link!\n");

		    // !!! If the app name is "MPlayer", we could get
		    // the selection out of the data....
		}

		ReleaseStgMedium(&stg);
	    }
	}
#endif
	
	if (!*lppf) {
	    PAVISTREAM	aps[2];
	    int		cps = 0;
	    
	    fetc.cfFormat = CF_DIB;
	    fetc.ptd = 0;
	    fetc.dwAspect = DVASPECT_CONTENT;
	    fetc.lindex = -1;
	    fetc.tymed = TYMED_HGLOBAL;

	    // CF_BITMAP, CF_PALETTE?
	    
	    hr = lpd->lpVtbl->GetData(lpd, &fetc, &stg);

	    if (hr == 0) {
		DPF("Got CF_DIB data from clipboard...\n");
		hr = AVIMakeStreamFromClipboard(CF_DIB, stg.hGlobal, &aps[cps]);

		if (hr == 0) {
		    cps++;
		}

		ReleaseStgMedium(&stg);
	    }
	    
	    fetc.cfFormat = CF_WAVE;
	    fetc.ptd = 0;
	    fetc.dwAspect = DVASPECT_CONTENT;
	    fetc.lindex = -1;
	    fetc.tymed = TYMED_HGLOBAL;

	    
	    hr = lpd->lpVtbl->GetData(lpd, &fetc, &stg);

	    if (hr == 0) {
		DPF("Got CF_WAVE data from clipboard...\n");
		hr = AVIMakeStreamFromClipboard(CF_WAVE, stg.hGlobal, &aps[cps]);

		if (hr == 0) {
		    cps++;
		}

		ReleaseStgMedium(&stg);
	    }

	    if (cps) {
		hr = AVIMakeFileFromStreams(lppf, cps, aps);

		while (cps-- > 0)
		    AVIStreamClose(aps[cps]);
	    } else    
		hr = ResultFromScode(AVIERR_NODATA);
	}
	
	lpd->lpVtbl->Release(lpd);
    }

    OleUninitialize();

    return hr;
}

/**************************************************************************
* @doc EXTERNAL AVIClearClipboard
*
* @api HRESULT | AVIClearClipboard | Releases any file or stream that
*	has been put on the Clipboard. 
*
* @comm Applications should use this function before exiting if they use
*	     other Clipboard routines.  Do not use this function just to
*       clear the clipboard; it might not return until other
*       applications have finished using the data placed on the Clipboard.
*       Ideally, call this function after hiding your application's windows.
*
* @rdesc Returns zero on success or an error code.
*
* @xref AVIPutStreamOnClipboard AVIGetFromClipboard
*
*************************************************************************/
STDAPI AVIClearClipboard(void)
{
    HRESULT hr;
    
    InitOle();

    hr = OleFlushClipboard();

    while (TaskHasExistingProxies()) {
	MSG msg;

	DPF("AVIClearClipboard: Waiting while streams in use....\n");
	while(PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
	    TranslateMessage(&msg);
	    DispatchMessage(&msg);
	}
    }
    
    OleUninitialize();

    return hr;
}

typedef     LPBITMAPINFOHEADER PDIB;

#ifndef BI_BITFIELDS
	#define BI_BITFIELDS 3
#endif  

#ifndef HALFTONE
	#define HALFTONE COLORONCOLOR
#endif


#define DibCompression(lpbi)    (DWORD)(((LPBITMAPINFOHEADER)(lpbi))->biCompression)
#define DibColors(lpbi)         ((RGBQUAD FAR *)((LPBYTE)(lpbi) + (int)(lpbi)->biSize))

#define DibNumColors(lpbi)      ((lpbi)->biClrUsed == 0 && (lpbi)->biBitCount <= 8 \
                                    ? (int)(1 << (int)(lpbi)->biBitCount)          \
                                    : (int)(lpbi)->biClrUsed)


/*
 *  CreateBIPalette()
 *
 *  Given a Pointer to a BITMAPINFO struct will create a
 *  a GDI palette object from the color table.
 *
 */
HPALETTE DibCreatePalette(PDIB pdib)
{
    LOGPALETTE         *pPal;
    HPALETTE            hpal = NULL;
    int                 nNumColors;
    int                 i;
    RGBQUAD FAR *       pRgb;

    if (!pdib)
        return NULL;

    nNumColors = DibNumColors(pdib);
    
    if (nNumColors == 3 && DibCompression(pdib) == BI_BITFIELDS)
        nNumColors = 0;

    if (nNumColors > 0)
    {
        pRgb = DibColors(pdib);
        pPal = (LOGPALETTE*)LocalAlloc(LPTR,sizeof(LOGPALETTE) + nNumColors * sizeof(PALETTEENTRY));

        if (!pPal)
            goto exit;

        pPal->palNumEntries = nNumColors;
        pPal->palVersion    = 0x300;

        for (i = 0; i < nNumColors; i++)
        {
            pPal->palPalEntry[i].peRed   = pRgb->rgbRed;
            pPal->palPalEntry[i].peGreen = pRgb->rgbGreen;
            pPal->palPalEntry[i].peBlue  = pRgb->rgbBlue;
            pPal->palPalEntry[i].peFlags = (BYTE)0;

            pRgb++;
        }

        hpal = CreatePalette(pPal);
        LocalFree((HLOCAL)pPal);
    }
    else
    {
#ifdef WIN32                 
        HDC hdc = GetDC(NULL);
        hpal = CreateHalftonePalette(hdc);      
        ReleaseDC(NULL, hdc);
#endif          
    }

exit:
    return hpal;
}

STDMETHODIMP AVIClipQueryInterface(LPDATAOBJECT lpd, REFIID riid, LPVOID FAR* ppvObj)
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;
    SCODE scode;

    if (IsEqualIID(riid, &IID_IDataObject) || 
			IsEqualIID(riid, &IID_IUnknown)) {
	
	DPF2("Clip   %lx: Usage++=%lx\n", (DWORD) (LPVOID) lpd, lpc->ulRefCount + 1);
    
        ++lpc->ulRefCount;
        *ppvObj = lpd;
        scode = S_OK;
    }
    else if (lpc->pf && IsEqualIID(riid, &IID_IAVIFile)) {
	AVIFileAddRef(lpc->pf);
	*ppvObj = lpc->pf;
	scode = S_OK;
    }
    else {                 // unsupported interface
        *ppvObj = NULL;
        scode = E_NOINTERFACE;
    }

    return ResultFromScode(scode);
}

STDMETHODIMP_(ULONG) AVIClipAddRef(LPDATAOBJECT lpd) 
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;

    DPF2("Clip   %lx: Usage++=%lx\n", (DWORD) (LPVOID) lpd, lpc->ulRefCount + 1);
    
    return ++lpc->ulRefCount;    
}

STDMETHODIMP_(ULONG) AVIClipRelease(LPDATAOBJECT lpd)
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;

    DPF2("Clip   %lx: Usage--=%lx\n", (DWORD) (LPVOID) lpd, lpc->ulRefCount - 1);
    
    if (--lpc->ulRefCount)
	return lpc->ulRefCount;
    
    if (lpc->pf)
        AVIFileClose(lpc->pf);

    if (lpc->pgf)
        AVIStreamGetFrameClose(lpc->pgf);

    if (lpc->hwndMci)
        DestroyWindow(lpc->hwndMci);

#if OWNER_DISPLAY
    if (lpc == lpcClipboard)
        lpcClipboard = NULL;
#endif

    GlobalFreePtr(lpc);
    OleUninitialize();
    
    return 0;
}


// *** IDataObject METHODIMPs ***
STDMETHODIMP AVIClipGetData(LPDATAOBJECT lpd, LPFORMATETC pformatetcIn,
			LPSTGMEDIUM pmedium )
{
    LPAVICLIP		lpc = (LPAVICLIP) lpd;
    SCODE		sc = S_OK;

    LPVOID		lp;
    LPBITMAPINFOHEADER	lpbi;
    DWORD		cb;
    PGETFRAME		pgf = NULL;
    PAVISTREAM		ps = NULL;

    if (pformatetcIn->cfFormat == CF_DIB ||
	pformatetcIn->cfFormat == CF_PALETTE) {
	
	AVIFileGetStream(lpc->pf, &ps, streamtypeVIDEO, 0L);

	if (!ps) {
	    sc = E_FAIL;
	    goto error;
	}
	
	pgf = AVIStreamGetFrameOpen(ps, NULL);

	if (!pgf) {
	    DPF("AVIClipGetData: AVIStreamGetFrameOpen failed!\n");
	    sc = E_FAIL;
	    goto error;
	}
	
	lpbi = AVIStreamGetFrame(pgf, 0);
	
        if (! lpbi) {
	    DPF("AVIClipGetData: AVIStreamGetFrame failed!\n");
            sc = E_OUTOFMEMORY;
            goto error;
        }

	if (pformatetcIn->cfFormat == CF_DIB) {
	    DPF("Building CF_DIB data\n");
	    // Verify caller asked for correct medium
	    if (!(pformatetcIn->tymed & TYMED_HGLOBAL)) {
		sc = DATA_E_FORMATETC;
		goto error;
	    }

	    cb = lpbi->biSize +
		 lpbi->biClrUsed * sizeof(RGBQUAD) +
		 lpbi->biSizeImage;
	    pmedium->hGlobal = GlobalAlloc(GHND | GMEM_SHARE, cb);

	    if (!pmedium->hGlobal) {
		sc = E_OUTOFMEMORY;
		goto error;
	    }

	    lp = GlobalLock(pmedium->hGlobal);

	    hmemcpy(lp, lpbi, cb);

	    GlobalUnlock(pmedium->hGlobal);
	    
	    pmedium->tymed = TYMED_HGLOBAL;
	} else /* if (pformatetcIn->cfFormat == CF_PALETTE) */ {
	    HPALETTE	hpal;

	    // Verify caller asked for correct medium
	    if (!(pformatetcIn->tymed & TYMED_GDI)) {
		sc = DATA_E_FORMATETC;
		goto error;
	    }

	    hpal = DibCreatePalette(lpbi);

	    pmedium->hGlobal = hpal;
	    pmedium->tymed = TYMED_GDI;
	    DPF("Building CF_PALETTE data: hpal = %x\n", (UINT) hpal);
	}
    } else if (pformatetcIn->cfFormat == CF_WAVE) {
	LONG		cbFormat;
	AVISTREAMINFO	strhdr;
	DWORD _huge *	hpdw;
#define formtypeWAVE            mmioFOURCC('W', 'A', 'V', 'E')
#define ckidWAVEFORMAT          mmioFOURCC('f', 'm', 't', ' ')
#define ckidWAVEDATA	        mmioFOURCC('d', 'a', 't', 'a')
	
	DPF("Building CF_WAVE data\n");
	AVIFileGetStream(lpc->pf, &ps, streamtypeAUDIO, 0L);

	if (!ps) {
	    sc = E_FAIL;
	    goto error;
	}

	AVIStreamInfo(ps, &strhdr, sizeof(strhdr));

	AVIStreamReadFormat(ps, strhdr.dwStart, NULL, &cbFormat);
	
	cb = strhdr.dwLength * strhdr.dwSampleSize +
	     cbFormat + 5 * sizeof(DWORD) + 2 * sizeof(DWORD);
	
	pmedium->hGlobal = GlobalAlloc(GHND | GMEM_SHARE, cb);

	if (!pmedium->hGlobal) {
	    sc = E_OUTOFMEMORY;
	    goto error;
	}

	lp = GlobalLock(pmedium->hGlobal);

	hpdw = (DWORD _huge *) lp;
	
	*((DWORD _huge *)lp)++ = FOURCC_RIFF;
	*((DWORD _huge *)lp)++ = cb - 2 * sizeof(DWORD);
	*((DWORD _huge *)lp)++ = formtypeWAVE;

	*((DWORD _huge *)lp)++ = ckidWAVEFORMAT;
	*((DWORD _huge *)lp)++ = cbFormat;

	AVIStreamReadFormat(ps, strhdr.dwStart, lp, &cbFormat);

	lp = (BYTE _huge *) lp + cbFormat;

	cb = strhdr.dwLength * strhdr.dwSampleSize;
	*((DWORD _huge *)lp)++ = ckidWAVEDATA;
	*((DWORD _huge *)lp)++ = cb;

	AVIStreamRead(ps, strhdr.dwStart, strhdr.dwLength, lp, cb, NULL, NULL);
	
	GlobalUnlock(pmedium->hGlobal);
	    
	pmedium->tymed = TYMED_HGLOBAL;	
    } else {
        sc = DATA_E_FORMATETC;
	
	goto error;
    }
    
error:

    if (pgf)
	AVIStreamGetFrameClose(pgf);
    if (ps)
	AVIStreamClose(ps);

    DPF2("GetData returns %lx\n", (DWORD) sc);
    return ResultFromScode(sc);
}

STDMETHODIMP AVIClipGetDataHere(LPDATAOBJECT lpd, LPFORMATETC pformatetc,
			LPSTGMEDIUM pmedium )
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;

    return ResultFromScode(DATA_E_FORMATETC);
}

STDMETHODIMP AVIClipQueryGetData(LPDATAOBJECT lpd, LPFORMATETC pformatetc )
{
    LPAVICLIP		lpc = (LPAVICLIP) lpd;
    PAVISTREAM		ps = NULL;

    if (pformatetc->cfFormat == CF_DIB) {
	AVIFileGetStream(lpc->pf, &ps, streamtypeVIDEO, 0L);

	if (ps) {
	    ps->lpVtbl->Release(ps);
	    if (pformatetc->tymed & TYMED_HGLOBAL) {
		return NOERROR;
	    } else {
		return ResultFromScode(DATA_E_FORMATETC);
	    }
	}	
    } else if (pformatetc->cfFormat == CF_PALETTE) {
	AVIFileGetStream(lpc->pf, &ps, streamtypeVIDEO, 0L);

	if (ps) {
	    ps->lpVtbl->Release(ps);
	    if (pformatetc->tymed & TYMED_GDI) {
		return NOERROR;
	    } else {
		return ResultFromScode(DATA_E_FORMATETC);
	    }
	}
    } else if (pformatetc->cfFormat == CF_WAVE) {
	AVIFileGetStream(lpc->pf, &ps, streamtypeAUDIO, 0L);

	if (ps) {
	    ps->lpVtbl->Release(ps);
	    if (pformatetc->tymed & TYMED_HGLOBAL) {
		return NOERROR;
	    } else {
		return ResultFromScode(DATA_E_FORMATETC);
	    }
	}
    } 

    return ResultFromScode(DATA_E_FORMATETC);    
}

STDMETHODIMP AVIClipGetCanonicalFormatEtc(LPDATAOBJECT lpd, LPFORMATETC pformatetc,
			LPFORMATETC pformatetcOut)
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;

    return ResultFromScode(E_NOTIMPL);    
}

STDMETHODIMP AVIClipSetData(LPDATAOBJECT lpd, LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
			BOOL fRelease)
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;

    return ResultFromScode(E_FAIL);
}

STDMETHODIMP AVIClipEnumFormatEtc(LPDATAOBJECT lpd, DWORD dwDirection,
			LPENUMFORMATETC FAR* ppenumFormatEtc)
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;

    SCODE sc = S_OK;
    if (dwDirection == DATADIR_GET) {
	// Build an enumerator....
        *ppenumFormatEtc = OleStdEnumFmtEtc_Create(
				lpc->wFormats, lpc->lpFormats);
	
        if (*ppenumFormatEtc == NULL)
            sc = E_OUTOFMEMORY;
    } else if (dwDirection == DATADIR_SET) {
        /* OLE2NOTE: a document that is used to transfer data
        **    (either via the clipboard or drag/drop does NOT
        **    accept SetData on ANY format! 
        */
        sc = E_NOTIMPL;
        goto error;
    } else {
        sc = E_INVALIDARG;
        goto error;
    }
    
error:
    return ResultFromScode(sc);    
}


STDMETHODIMP AVIClipDAdvise(LPDATAOBJECT lpd, FORMATETC FAR* pFormatetc, DWORD advf, 
		LPADVISESINK pAdvSink, DWORD FAR* pdwConnection)
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;

    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

STDMETHODIMP AVIClipDUnadvise(LPDATAOBJECT lpd, DWORD dwConnection)
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;

    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

STDMETHODIMP AVIClipEnumDAdvise(LPDATAOBJECT lpd, LPENUMSTATDATA FAR* ppenumAdvise)
{
    LPAVICLIP	lpc = (LPAVICLIP) lpd;

    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

#if OWNER_DISPLAY

/**************************************************************************
* @doc INTERNAL AVIFILE
*
* @api ClipboardWindowProc
*
*************************************************************************/
static LRESULT CALLBACK _loadds ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LONG lParam)
{
    WNDPROC x;
    HWND hwndViewer;
    PAINTSTRUCT ps;
    RECT rc;
    LPAVICLIP lpc;

    switch (msg) {
        case WM_DESTROY:
        case WM_DESTROYCLIPBOARD:
            DPF("WM_DESTROYCLIPBOARD\n");

            x = OldClipboardWindowProc;
            SetWindowLong(hwnd, GWL_WNDPROC, (LONG)x);
            OldClipboardWindowProc = NULL;
            return (*x)(hwnd, msg, wParam, lParam);

        case WM_RENDERFORMAT:
            DPF("WM_RENDERFORMAT cf=%d\n", (int)wParam);
            break;

        case WM_PAINTCLIPBOARD:
            DPF("WM_PAINTCLIPBOARD\n");

            hwndViewer = (HWND)wParam;

            if (!lParam)
                break;

            lpc = lpcClipboard;

            if (lpc == NULL)
                break;

            ps = *(LPPAINTSTRUCT)GlobalLock((HGLOBAL)lParam);

            FillRect(ps.hdc, &ps.rcPaint, GetStockObject(DKGRAY_BRUSH));
            return 0;
            break;

        case WM_SIZECLIPBOARD:
            DPF("WM_SIZECLIPBOARD\n");

            hwndViewer = (HWND)wParam;

            lpc = lpcClipboard;

            if (lpc == NULL)
                break;

            if (lParam)
                rc = *(LPRECT)GlobalLock((HGLOBAL)lParam);
            else
                SetRectEmpty(&rc);

            if (IsRectEmpty(&rc)) {
            }
            else {
            }
            break;

        case WM_VSCROLLCLIPBOARD:
        case WM_HSCROLLCLIPBOARD:
            DPF("WM_VHSCROLLCLIPBOARD\n");
            hwndViewer = (HWND)wParam;
            break;

        case WM_ASKCBFORMATNAME:
            DPF("WM_ASKCBFORMATNAME\n");
            break;
    }

    return OldClipboardWindowProc(hwnd, msg, wParam, lParam);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\avi\avifile.16\acmstub.asm ===
page    ,132
        title   ACMS