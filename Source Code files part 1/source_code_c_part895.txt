.

    PMDC  pmdc = (PMDC)pldc->pvPMDC;
    PMR   pmrNew;

    PUTS("PlayEnhMetaFileRecord: embedding new record\n");

    if (!(pmrNew = (PMR) pmdc->pvNewRecord((pmr->nSize + 3) & ~3)))
        return(FALSE);

    // Init the record header.

    pmrNew->vInit(pmr->iType);

    // Copy the body.

    RtlCopyMemory
        (
        (PBYTE) ((PENHMETARECORD) pmrNew)->dParm,
        (PBYTE) pmr->dParm,
        pmr->nSize - sizeof(EMR)
        );

    // Update record with bounds.

    if (pmr->iType & EMR_ACCUMBOUNDS)
    {
        if (!((PERECTL) &((PENHMETABOUNDRECORD) pmrNew)->rclBounds)->bEmpty())
        {
            PMF    pmf;
            XFORM  xform;
            POINTL aptlOld[4], aptlNew[4];

            // Get metafile.

            if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
                return(FALSE);

            // Convert from old device coords to new device coords.

            xform = pmf->xformBase;

            aptlOld[0].x = ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.left;
            aptlOld[0].y = ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.top;
            aptlOld[1].x = ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.right;
            aptlOld[1].y = ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.top;
            aptlOld[2].x = ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.right;
            aptlOld[2].y = ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.bottom;
            aptlOld[3].x = ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.left;
            aptlOld[3].y = ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.bottom;

            for (int i = 0; i < 4; i++)
            {
            aptlNew[i].x = (LONG) ((FLOAT) aptlOld[i].x * xform.eM11
                         + (FLOAT) aptlOld[i].y * xform.eM21
                         + xform.eDx + 0.5f);
            aptlNew[i].y = (LONG) ((FLOAT) aptlOld[i].x * xform.eM12
                         + (FLOAT) aptlOld[i].y * xform.eM22
                         + xform.eDy + 0.5f);
            }

            // Update the device bounds.

            ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.left
            = MIN4(aptlNew[0].x,aptlNew[1].x,aptlNew[2].x,aptlNew[3].x);
            ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.right
            = MAX4(aptlNew[0].x,aptlNew[1].x,aptlNew[2].x,aptlNew[3].x);
            ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.top
            = MIN4(aptlNew[0].y,aptlNew[1].y,aptlNew[2].y,aptlNew[3].y);
            ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.bottom
            = MAX4(aptlNew[0].y,aptlNew[1].y,aptlNew[2].y,aptlNew[3].y);

            // Accumulate the new bounds.

            (void) SetBoundsRectAlt(hdc,
            (LPRECT) &((PENHMETABOUNDRECORD) pmrNew)->rclBounds,
            (UINT) (DCB_WINDOWMGR | DCB_ACCUMULATE));
        }
    }

    pmrNew->vCommit(pmdc);      // commit the record
    return(TRUE);
}

/******************************Public*Routine******************************\
* UINT APIENTRY GetEnhMetaFileBits(
*          HENHMETAFILE hemf,
*          UINT nSize,
*         LPBYTE lpData )
*
* The GetEnhMetaFileBits function returns the specified metafile as a block of
* data. The retrieved data must not be modified and is only usable by
* SetEnhMetaFileBits.
*
* Parameter  Description
* hemf       Identifies the metafile.
* nSize      Specifies the size of the buffer reserved for the data. Only this
*            many bytes will be written.
* lpData     Points to the buffer to receive the metafile data. If this
*            pointer is NULL, the function returns the size necessary to hold
*            the data.
*
* Return Value
* The return value is the size of the metafile data in bytes. If an error
* occurs, 0 is returned.
*
* Comments
* The handle used as the hemf parameter does NOT become invalid when the
* GetEnhMetaFileBits function returns.
*
* History:
*  Tue Sep 03 11:21:14 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" UINT APIENTRY GetEnhMetaFileBits(
         HENHMETAFILE hEMF,
         UINT nSize,
        LPBYTE lpData )
{
    PMF    pmf;

    PUTS("GetEnhMetaFileBits\n");

// Validate the metafile handle.

    if (!(pmf = GET_PMF(hEMF)))
        return(0);

    PENHMETAHEADER pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
        return(0);

// If lpData is NULL, return the size necessary to hold the data.

    if (!lpData)
        return(pmrmf->nBytes);

// Make sure the input buffer is large enough.

    if (nSize < pmrmf->nBytes)
    {
    GdiSetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(0);
    }

// Copy the bits.

    PBYTE pb = (PBYTE) pmf->emfc.ObtainPtr(0, pmrmf->nBytes);

    if(!pb)
        return(0);

    RtlCopyMemory(lpData, pb, pmrmf->nBytes);

    pmf->emfc.ReleasePtr(pb);

// Return the number of bytes copied.

    return(pmrmf->nBytes);
}


/******************************Public*Routine******************************\
* UINT APIENTRY GetWinMetaFileBits(
*          HENHMETAFILE hemf,
*          UINT nSize,
*         LPBYTE lpData
*         INT iMapMode,
*         HDC hdcRef)
*
* The GetWinMetaFileBits function returns the metafile records of the
* specified enhanced metafile  in the Windows 3.0 format and copies
* them into the buffer specified.
*
* Parameter  Description
* hemf       Identifies the metafile.
* nSize      Specifies the size of the buffer reserved for the data. Only this
*            many bytes will be written.
* lpData     Points to the buffer to receive the metafile data. If this
*            pointer is NULL, the function returns the size necessary to hold
*            the data.
* iMapMode   the desired mapping mode of the metafile contents to be returned
* hdcRef     defines the units of the metafile to be returned
*
* Return Value
* The return value is the size of the metafile data in bytes. If an error
* occurs, 0 is returned.
*
* Comments
* The handle used as the hemf parameter does NOT become invalid when the
* GetWinMetaFileBits function returns.
*
* History:
*  Thu Apr  8 14:22:23 1993     -by-    Hock San Lee    [hockl]
* Rewrote it.
*  02-Jan-1992     -by-    John Colleran    [johnc]
* Wrote it.
\**************************************************************************/

extern "C" UINT APIENTRY GetWinMetaFileBits
(
HENHMETAFILE hemf,
UINT         cbData16,
LPBYTE       pData16,
INT          iMapMode,
HDC          hdcRef
)
{
    static LPFNCONVERT lpConvertEmfToWmf = (LPFNCONVERT) NULL;
    PENHMETAHEADER pmrmf = NULL;

    PMF   pmf;
    UINT  fConverter = MF3216_INCLUDE_WIN32MF;
    PEMRGDICOMMENT_WINDOWS_METAFILE pemrWinMF;
    UINT  result = 0;

    PUTS("GetWinMetaFileBits\n");

// Validate mapmode.

    if ((iMapMode < MM_MIN) ||
        (iMapMode > MM_MAX) ||
        (LO_TYPE(hemf) != LO_METAFILE_TYPE))
    {
        ERROR_ASSERT(FALSE, "GetWinMetaFileBits: Bad mapmode");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

// Validate the metafile handle.

    if (!(pmf = GET_PMF(hemf)))
        goto getWinMetaFileBits_exit;

    pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
        goto getWinMetaFileBits_exit;

    pmrmf = (PENHMETAHEADER) pmf->emfc.ObtainPtr(0, pmrmf->nBytes);

    if(!pmrmf)
        goto getWinMetaFileBits_exit;

    ASSERTGDI(pmrmf->iType == EMR_HEADER, "GetWinMetaFileBits: invalid data");

// Store hemf in the handle table.

    pmf->pht->objectHandle[0] = hemf;

#ifndef DO_NOT_USE_EMBEDDED_WINDOWS_METAFILE
// See if the this was originally an old style metafile and if it has
// an encapsulated original

    if (!pmf->bValidBoundedSize(pmrmf, ((PENHMETAHEADER) pmrmf)->nSize))
    {
        EMFVALFAIL(("GetWinMetaFileBits: pmf->bValidBoundedSize(%p,%08x) failed\n",pmrmf, ((PENHMETAHEADER) pmrmf)->nSize));
        goto getWinMetaFileBits_exit;
    }

    pemrWinMF = (PEMRGDICOMMENT_WINDOWS_METAFILE)
            ((PBYTE) pmrmf + ((PENHMETAHEADER) pmrmf)->nSize);

    if (((PMRGDICOMMENT) pemrWinMF)->bIsWindowsMetaFile())
    {
    // Make sure that this is what we want and verify checksum

    if (iMapMode != MM_ANISOTROPIC)
    {
        PUTS("GetWinMetaFileBits: Requested and embedded metafile mapmodes mismatch\n");
    }
    else if ((pemrWinMF->nVersion != METAVERSION300 &&
              pemrWinMF->nVersion != METAVERSION100)
          || pemrWinMF->fFlags != 0)
    {
        // In this release, we can only handle the given metafile
        // versions.  If we return a version that we don't recognize,
        // the app will not be able to play that metafile later on!

        VERIFYGDI(FALSE, "GetWinMetaFileBits: Unrecognized Windows metafile\n");
    }
    else if (GetDWordCheckSum((UINT) pmrmf->nBytes, (PDWORD) pmrmf))
    {
        PUTS("GetWinMetaFileBits: Metafile has been modified\n");
    }
    else
    {
        PUTS("GetWinMetaFileBits: Returning embedded Windows metafile\n");

        if (pData16)
        {
            if (cbData16 < pemrWinMF->cbWinMetaFile)
            {
                ERROR_ASSERT(FALSE, "GetWinMetaFileBits: insufficient buffer");
                GdiSetLastError(ERROR_INSUFFICIENT_BUFFER);
                goto getWinMetaFileBits_exit;
            }

            RtlCopyMemory(pData16,
                      (PBYTE) &pemrWinMF[1],
                      pemrWinMF->cbWinMetaFile);
        }

        result = pemrWinMF->cbWinMetaFile;
        goto getWinMetaFileBits_exit;

    }

    // Either the enhanced metafile containing an embedded Windows
    // metafile has been modified or the embedded Windows metafile
    // is not what we want.  Since the original format is Windows
    // format, we will not embed the enhanced metafile in the
    // returned Windows metafile.

    PUTS("GetWinMetaFileBits: Skipping embedded windows metafile\n");

    fConverter &= ~MF3216_INCLUDE_WIN32MF;
    }
#endif // DO_NOT_USE_EMBEDDED_WINDOWS_METAFILE

// Load the MF3216 metafile converter if it has not been loaded for this
// process.  NOTE: the converter is unloaded when the process goes away.

    if (!lpConvertEmfToWmf)
    {
        HANDLE hModule = LoadLibraryW(L"mf3216") ;

        lpConvertEmfToWmf = (LPFNCONVERT) GetProcAddress(hModule, "ConvertEmfToWmf");
        if (!lpConvertEmfToWmf)
        {
            VERIFYGDI(FALSE, "GetWinMetaFileBits: Failed to load mf3216.dll\n");
            goto getWinMetaFileBits_exit;
        }
    }

// Tell the converter to emit the Enhanced metafile as a comment only if
// this metafile is not previously a Windows metafile

    if (fConverter & MF3216_INCLUDE_WIN32MF)
    {
        PUTS("GetWinMetaFileBits: Embedding enhanced metafile\n");
    }
    else
    {
        PUTS("GetWinMetaFileBits: No embedding of enhanced metafile\n");
    }

    result = lpConvertEmfToWmf((PVOID)pmf->pht, (PBYTE) pmrmf, cbData16, pData16,
           iMapMode, hdcRef, fConverter);

getWinMetaFileBits_exit:

    if(pmrmf)
        pmf->emfc.ReleasePtr(pmrmf);

    return(result);
}

/******************************Public*Routine******************************\
* HENHMETAFILE APIENTRY SetWinMetaFileBits(
*         UINT nSize,
*         LPBYTE lpData,
*         HDC hdcRef,
*         LPMETAFILEPICT lpMFP
*
* The SetWinMetaFileBits function creates a memory-based enhanced metafile
* from Windows 3.X metafile data.
*
* hEMF       Identifies the metafile.
* nSize      Specifies the size of the buffer
* lpData     Points to the buffer of the Win 3.x metafile data.
* hdcRef     defines the units of the metafile to be returned
* lpMFP      suggested size of metafile
*
* Return Value
* The return value is a handle to the new enhanced metafile if successful.
*
* History:
*  Thu Apr  8 14:22:23 1993     -by-    Hock San Lee    [hockl]
* Rewrote it.
*  02-Jan-1992     -by-    John Colleran    [johnc]
* Wrote it.
\**************************************************************************/

extern "C" HENHMETAFILE APIENTRY SetWinMetaFileBits
(
UINT           nSize,
CONST BYTE    *lpMeta16Data,
HDC            hdcRef,
CONST METAFILEPICT *lpMFP
)
{
    HENHMETAFILE  hemf32 = (HENHMETAFILE) 0;
    HMETAFILE     hmf16  = (HMETAFILE) 0;
    HDC           hdcT   = (HDC) 0;
    RECT          rcFrame;
    LPRECT        lprcFrame = (LPRECT)NULL;
    HDC           hdcEMF;
    INT           iMapMode;
    INT           xExtPels;
    INT           yExtPels;
    PMETA_ESCAPE_ENHANCED_METAFILE pmfeEnhMF;
    BOOL          bEmbedEmf = TRUE;
    PMDC          pmdcEMF;

    PUTS("SetWinMetaFileBits\n");

    if (lpMFP)
    {
        PUTSX("SetWinMetaFileBits: xExt:%lX  ", lpMFP->xExt);
        PUTSX("yExt:%lX\n", lpMFP->yExt);
    }
    else
        PUTS("SetWinMetaFileBits: lpMFP is NULL\n");

// Verify the input data.

    if (nSize < sizeof(METAHEADER)
     || !IsValidMetaHeader16((PMETAHEADER) lpMeta16Data))
    {
        ERROR_ASSERT(FALSE, "SetWinMetaFileBits: Bad input data\n");
        GdiSetLastError(ERROR_INVALID_DATA);
        return((HENHMETAFILE) 0);
    }

#ifndef DO_NOT_USE_EMBEDDED_ENHANCED_METAFILE
// Check if the windows metafile contains an embedded version of the
// original enhanced metafile.

    pmfeEnhMF = (PMETA_ESCAPE_ENHANCED_METAFILE) &lpMeta16Data[sizeof(METAHEADER)];
    if (IS_META_ESCAPE_ENHANCED_METAFILE(pmfeEnhMF))
    {
        PBYTE   pMetaData32 = (PBYTE) NULL;
        UINT    i;
        UINT    cbMetaData32;

        // We will not do metafile version check here.  It is verified in
        // pmfAllocMF eventually.

        if (pmfeEnhMF->fFlags != 0)
        {
            VERIFYGDI(FALSE, "SetWinMetaFileBits: Unrecognized Windows metafile\n");
            goto SWMFB_UseConverter;
        }

        // Validate checksum

        if (GetWordCheckSum(nSize, (PWORD) lpMeta16Data))
        {
            PUTS("SetWinMetaFileBits: Metafile has been modified\n");
            goto SWMFB_UseConverter;
        }

        // Unpack the data from the small chunks of metafile comment records
        // Windows 3.0 chokes on Comment Record > 8K?
        // We probably could probably just error out if out of memory but
        // lets try to convert just because the embedded comment might be bad.

        PUTS("SetWinMetaFileBits: Using embedded enhanced metafile\n");

        cbMetaData32 = (UINT) pmfeEnhMF->cbEnhMetaFile;
        if (!(pMetaData32 = (PBYTE) LocalAlloc(LMEM_FIXED, cbMetaData32)))
        {
            VERIFYGDI(FALSE, "SetWinMetaFileBits: LocalAlloc Failed");
            goto SWMFB_UseConverter;
        }

        i = 0;
        do
        {
            if (i + pmfeEnhMF->cbCurrent > cbMetaData32)
            {
                VERIFYGDI(FALSE, "SetWinMetaFileBits: Bad metafile comment");
                goto SWMFB_UseConverter;
            }

            RtlCopyMemory(&pMetaData32[i], (PBYTE) &pmfeEnhMF[1], pmfeEnhMF->cbCurrent);
            i += (UINT) pmfeEnhMF->cbCurrent;
            pmfeEnhMF = (PMETA_ESCAPE_ENHANCED_METAFILE)
                ((PWORD) pmfeEnhMF + pmfeEnhMF->rdSize);
        } while (IS_META_ESCAPE_ENHANCED_METAFILE(pmfeEnhMF));

        if (i != cbMetaData32)
        {
            VERIFYGDI(FALSE, "SetWinMetaFileBits: Insufficient metafile data");
            goto SWMFB_UseConverter;
        }

        // Set the memory directly into the enhanced metafile and return the
        // metafile.

        if (hemf32 = SetEnhMetaFileBitsAlt((HLOCAL) pMetaData32, NULL, NULL, 0))
            goto SWMFB_exit;

        VERIFYGDI(FALSE, "SetWinMetaFileBits: SetEnhMetaFileBitsAlt failed\n");

SWMFB_UseConverter:
        if (pMetaData32)
        {
            if (LocalFree((HANDLE) pMetaData32))
            {
                ASSERTGDI(FALSE, "SetWinMetaFileBits: LocalFree Failed");
            }
        }

        // The Windows metafile containing an embedded enhanced metafile has
        // been modified.  Since the original format is enhanced format, we
        // will not embed the Windows metafile in the returned enhanced
        // metafile.

        bEmbedEmf = FALSE;
    }
#endif // DO_NOT_USE_EMBEDDED_ENHANCED_METAFILE

// Create the 16 bit metafile

    if (!(hmf16 = SetMetaFileBitsEx(nSize, lpMeta16Data)))
    {
        ERROR_ASSERT(FALSE, "SetWinMetaFileBits: SetMetaFileBitsEx Failed");
        goto SWMFB_exit;
    }

// If no hdcRef is given, use the default display as reference.

    if (!hdcRef)
    {
        if (!(hdcRef = hdcT = CreateICA((LPCSTR) "DISPLAY", (LPCSTR) NULL,
                        (LPCSTR) NULL, (LPDEVMODEA) NULL)))
        {
            ERROR_ASSERT(FALSE, "SetWinMetaFileBits: CreateICA Failed");
            goto SWMFB_exit;
        }
    }

// Get the frame rect in .01mm units and extents in pel units.
// For fixed mapmodes, the extents are unnecessary.

    if (lpMFP)
    {
        iMapMode = lpMFP->mm ? (INT) lpMFP->mm : MM_ANISOTROPIC;  // zero used
        switch (iMapMode)
        {
        case MM_ISOTROPIC:
        case MM_ANISOTROPIC:
            // If the extents are negative, use the default device extents.

            if (lpMFP->xExt > 0 && lpMFP->yExt > 0)
            {
                // Convert the MetaFilePict suggested size HI-Metric into PELs

                xExtPels = MulDiv((int) lpMFP->xExt,
                          GetDeviceCaps(hdcRef, DESKTOPHORZRES),
                          GetDeviceCaps(hdcRef, HORZSIZE) * 100);
                yExtPels = MulDiv((int) lpMFP->yExt,
                          GetDeviceCaps(hdcRef, DESKTOPVERTRES),
                          GetDeviceCaps(hdcRef, VERTSIZE) * 100);
                rcFrame.left   = 0;
                rcFrame.top    = 0;
                rcFrame.right  = lpMFP->xExt;
                rcFrame.bottom = lpMFP->yExt;
                lprcFrame      = &rcFrame;
                break;
            }

            PUTS("SetWinMetaFileBits: negative extents in lpMFP\n");

            // fall through

        case MM_TEXT:
        case MM_LOMETRIC:
        case MM_HIMETRIC:
        case MM_LOENGLISH:
        case MM_HIENGLISH:
        case MM_TWIPS:
            xExtPels = GetDeviceCaps(hdcRef, DESKTOPHORZRES);
            yExtPels = GetDeviceCaps(hdcRef, DESKTOPVERTRES);
            break;

        default:
            VERIFYGDI(FALSE, "SetWinMetaFileBits: Bad mapmode in METAFILEPICT\n");
            goto SWMFB_exit;
        }
    }
    else
    {
    // If the METAFILEPICT is not given, use the MM_ANISOTROPIC mapmode
    // and the default device extents.

        iMapMode = MM_ANISOTROPIC;

        xExtPels = GetDeviceCaps(hdcRef, DESKTOPHORZRES);
        yExtPels = GetDeviceCaps(hdcRef, DESKTOPVERTRES);
    }

    PUTSX("SetWinMetaFileBits: xExtPels:%lX  ", xExtPels);
    PUTSX("yExtPels:%lX\n", yExtPels);

    // Create the new 32 bit metafile DC

    if (!(hdcEMF = CreateEnhMetaFileW(hdcRef, (LPWSTR) NULL, lprcFrame,
            (LPWSTR) NULL)))
        goto SWMFB_exit;

    // We want to preserve the original Metafile as a comment only if this
    // metafile wasn't originally an enhanced metafile as indicated by bEmbedEmf.

    PLDC pldc;
    DC_PLDC(hdcEMF,pldc,0);
    pmdcEMF = (PMDC)pldc->pvPMDC;

#ifndef DO_NOT_EMBED_WINDOWS_METAFILE
    // Embed it only if the mapmode is MM_ANISOTROPIC.

    if (bEmbedEmf && iMapMode == MM_ANISOTROPIC)
    {
        if (!MF_GdiCommentWindowsMetaFile(hdcEMF, nSize, lpMeta16Data))
        {
            HENHMETAFILE  hemfTmp;

            ERROR_ASSERT(FALSE, "SetWinMetaFileBits: GdiComment Failed!");
            if (hemfTmp = CloseEnhMetaFile(hdcEMF))
                DeleteEnhMetaFile(hemfTmp);

            goto SWMFB_exit;
        }

        pmdcEMF->fl |= MDC_CHECKSUM; // tell CloseEnhMetaFile we need a checksum
    }
#endif // DO_NOT_EMBED_WINDOWS_METAFILE

    // Play the 16 bit metafile into the new metafile DC

    if (!SetMapMode(hdcEMF, iMapMode)
     || !SetViewportExtEx(hdcEMF, (int)xExtPels, (int)yExtPels, (LPSIZE) NULL)
     || !SetWindowExtEx  (hdcEMF, (int)xExtPels, (int)yExtPels, (LPSIZE) NULL))
    {
        HENHMETAFILE  hemfTmp;

        ERROR_ASSERT(FALSE, "SetWinMetaFileBits: unable to PlayMetaFile");
        if (hemfTmp = CloseEnhMetaFile(hdcEMF))
            DeleteEnhMetaFile(hemfTmp);

        goto SWMFB_exit;
    }

    // Ignore the return value from PlayMetaFile because some existing metafiles
    // contains errors (e.g. DeleteObject for a handle that is selected) although
    // they are not fatal.

    (void) PlayMetaFile(hdcEMF, hmf16);

    // Get the 32 bit metafile by closing the 32 bit metafile DC.

    hemf32 = CloseEnhMetaFile(hdcEMF);
    VERIFYGDI(hemf32, "SetWinMetaFileBits: CloseEnhMetaFile failed\n");

SWMFB_exit:

    if (hdcT)
    {
        if (!DeleteDC(hdcT))
        {
            ASSERTGDI(FALSE, "SetWinMetaFileBits: DeleteDC Failed");
        }
    }

    if (hmf16)
    {
        if (!DeleteMetaFile(hmf16))
        {
            ASSERTGDI(FALSE, "SetWinMetaFileBits: DeleteMetaFile failed");
        }
    }

    ERROR_ASSERT(hemf32, "SetWinMetaFileBits failed");
    return(hemf32);
}

/******************************Public*Routine******************************\
* GetWordCheckSum(UINT cbData, PWORD pwData)
*
* Adds cbData/2 number of words pointed to by pwData to provide an
* additive checksum.  If the checksum is valid the sum of all the WORDs
* should be zero.
*
\**************************************************************************/

WORD GetWordCheckSum(UINT cbData, PWORD pwData)
{
    WORD   wCheckSum = 0;
    UINT   cwData = cbData / sizeof(WORD);

    ASSERTGDI(!(cbData%sizeof(WORD)), "GetWordCheckSum data not WORD multiple");
    ASSERTGDI(!((ULONG_PTR)pwData%sizeof(WORD)), "GetWordCheckSum data not WORD aligned");

    while (cwData--)
        wCheckSum += *pwData++;

    return(wCheckSum);
}

DWORD GetDWordCheckSum(UINT cbData, PDWORD pdwData)
{
    DWORD   dwCheckSum = 0;
    UINT    cdwData = cbData / sizeof(DWORD);

    ASSERTGDI(!(cbData%sizeof(DWORD)), "GetDWordCheckSum data not DWORD multiple");
    ASSERTGDI(!((ULONG_PTR)pdwData%sizeof(DWORD)), "GetDWordCheckSum data not DWORD aligned");

    while (cdwData--)
        dwCheckSum += *pdwData++;

    return(dwCheckSum);
}

/******************************Public*Routine******************************\
* HENHMETAFILE APIENTRY SetEnhMetaFileBits
* (
* UINT nSize,
* LPBYTE pb
* )
*
* The SetEnhMetaFileBits function creates a memory metafile from the data
* provided.
*
* Parameter  Description
* nSize      Specifies the size, in bytes, of the data provided.
* lpData     Points to a buffer that contains the metafile data. It is assumed
*            that the data was previously created using the GetEnhMetaFileBits
*            function.
*
* Return Value
* The return value identifies a memory metafile if the function is successful.
* Otherwise, the return value is 0.
*
* History:
*  Tue Sep 03 11:21:14 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" HENHMETAFILE APIENTRY SetEnhMetaFileBits
(
UINT nSize,
CONST BYTE * pb
)
{
    PMF     pmf;
    HENHMETAFILE hmf;

    PUTS("SetEnhMetaFileBits\n");

// Verify nSize is valid.

    if (nSize < sizeof(META_HDR_SIZE_MIN) ||
        nSize < ((PENHMETAHEADER) pb)->nBytes)
    {
        GdiSetLastError(ERROR_INVALID_DATA);
        return((HENHMETAFILE) 0);
    }

// Allocate and initialize a MF.

    if (!(pmf = pmfAllocMF(0, (PDWORD)pb, (LPWSTR) NULL, NULL, 0, 0)))
        return((HENHMETAFILE) 0);

// Allocate a local handle.

    hmf = hmfCreate(pmf);
    if (hmf == NULL)
    {
        vFreeMF(pmf);
    }

// Return the metafile handle.

    return(hmf);
}

// Similar to SetEnhMetaFileBits except that hMem is set into the metafile
// directly.  It is assumed that hMem is allocated with the LMEM_FIXED option.
// For internal use only.

extern "C" HENHMETAFILE APIENTRY SetEnhMetaFileBitsAlt(HLOCAL hMem, HANDLE hExtra, HANDLE hFile, UINT64 qwFileOffset)
{
    PMF          pmf;
    HENHMETAFILE hmf;

    PUTS("SetEnhMetaFileBitsAlt\n");

// Allocate and initialize a MF.

    if (!(pmf = pmfAllocMF(ALLOCMF_TRANSFER_BUFFER, (PDWORD) hMem, (LPWSTR) NULL, hFile, qwFileOffset, hExtra)))
        return((HENHMETAFILE) 0);

// Allocate a local handle.

    hmf = hmfCreate(pmf);
    if (hmf == NULL)
    {
        // If memory got transferred reset it to not transferred state.
        if(pmf->pvLocalCopy)
        {
            pmf->pvLocalCopy = 0;
        }
        vFreeMF(pmf);
    }

 // Return the metafile handle.

    return(hmf);
}

/******************************Public*Routine******************************\
* UINT GetEnhMetaFilePaletteEntries(hEMF, nNumEntries, lpPaletteEntries)
* HENHMETAFILE hEMF;
* UINT nNumEntries;
* LPPALETTEENTRY lpPaletteEntries;
*
* The GetEnhMetaFilePaletteEntries function retrieves the palette entries
* used in a metafile.  They include non-duplicate colors defined in
* CreatePalette and SetPaletteEntries records in a metafile.  The
* palette entries do not contain any peFlags.
*
* Parameter         Description
* hEMF              Identifies the metafile.
* nNumEntries       Specifies the number of entries in the metafile palette
*                   to be retrieved.
* lpPaletteEntries  Points to an array of PALETTEENTRY structures to receive
*                   the palette entries. The array must contain at least as
*                   many data structures as specified by the nNumEntries
*                   parameter. If this parameter is NULL, the function will
*                   return the number of entries in the metafile palette.
*
* Return Value
* The return value is the number of entries retrieved from the palette.
* If no palette is created in the metafile, 0 is returned.  If an error
* occurs, -1 is returned.
*
* History:
*  Mon Sep 23 17:41:07 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" UINT APIENTRY GetEnhMetaFilePaletteEntries
(
    HENHMETAFILE   hemf,
    UINT           nNumEntries,
    LPPALETTEENTRY lpPaletteEntries
)
{
    PMF     pmf = NULL;
    UINT    cEntries = GDI_ERROR;
    PEMREOF pmreof = NULL;
    PENHMETAHEADER pmrmf = NULL;

    PUTS("GetEnhMetaFilePaletteEntries\n");

// Validate the metafile handle.

    if (!(pmf = GET_PMF(hemf)))
        goto GetEnhMetaFilePaletteEntries_exit;

    pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
        goto GetEnhMetaFilePaletteEntries_exit;

    pmreof = pmf->emfc.ObtainEOFRecordPtr();

    if(!pmreof)
    {
        cEntries = 0; // We do not have a palette ih the metafile
        goto GetEnhMetaFilePaletteEntries_exit;
    }

// If lpPaletteEntries is NULL, return the number of entries in the metafile
// palette.

    if (!lpPaletteEntries)
    {
        cEntries = pmrmf->nPalEntries;
        goto GetEnhMetaFilePaletteEntries_exit;
    }

// Get the number of entries to copy.

    cEntries = min(nNumEntries,(UINT) pmrmf->nPalEntries);

    ASSERTGDI
    (
        pmrmf->nPalEntries == pmreof->nPalEntries,
        "GetEnhMetaFilePaletteEntries: Bad nPalEntries"
    );

// Copy the palette.

    RtlCopyMemory
    (
        (PBYTE) lpPaletteEntries,
        (PBYTE) pmreof + pmreof->offPalEntries,
        cEntries * sizeof(PALETTEENTRY)
    );

// Return the number of entries copied.

GetEnhMetaFilePaletteEntries_exit:

    if(pmreof)
        pmf->emfc.ReleaseEOFRecordPtr(pmreof);
    
    return(cEntries);
}

/******************************Public*Routine******************************\
* UINT APIENTRY GetEnhMetaFileHeader(
*         HENHMETAFILE hemf,
*         UINT nSize,
*         LPENHMETAHEADER lpEnhMetaHeader );
*
* Returns the metafile header information for hemf.
* If lpEnhMetaHeader is NULL then the size of the header is returned.
*
* This routine supports multiple versions of the metafile header by
* returning the largest version that fits in the buffer
*
* History:
*  16-Oct-1991 1991     -by-    John Colleran    [johnc]
* Wrote it.
\**************************************************************************/

extern "C" UINT APIENTRY GetEnhMetaFileHeader
(
    HENHMETAFILE hemf,
    UINT nSize,
    LPENHMETAHEADER lpEnhMetaHeader
)
{
    PMF    pmf;
    UINT   nCopySize = 0;
    PENHMETAHEADER pmrmf = NULL;

    PUTS("GetEnhMetaFileHeader\n");

// Validate the metafile handle.

    if (!(pmf = GET_PMF(hemf)))
    {
        ERROR_ASSERT(FALSE, "GetEnhMetaFileHeader invalid metafile handle");
        goto GetEnhMetaFileHeader_exit;
    }

    pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
        goto GetEnhMetaFileHeader_exit;

// Is this just a size query

    if (lpEnhMetaHeader == (LPENHMETAHEADER) NULL)
    {
        nCopySize = pmrmf->nSize;
        goto GetEnhMetaFileHeader_exit;
    }

// Header request.  The size must be large enough to include some version
// of the header

    if (nSize < META_HDR_SIZE_MIN)
    {
        ERROR_ASSERT(FALSE, "GetEnhMetaFileHeader buffer size too small");
        GdiSetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto GetEnhMetaFileHeader_exit;
    }

    // Figure out which version of the header to copy
    if (nSize < META_HDR_SIZE_VERSION_2 ||
        pmrmf->nSize == META_HDR_SIZE_VERSION_1)
    {
        nCopySize = META_HDR_SIZE_VERSION_1;
    }
    else if (nSize < META_HDR_SIZE_VERSION_3 ||
        pmrmf->nSize == META_HDR_SIZE_VERSION_2)
    {
        nCopySize = META_HDR_SIZE_VERSION_2;
    }
    else
    {
        nCopySize = META_HDR_SIZE_VERSION_3;
    }

// Copy the ENHMETAHEADER and return its size

    RtlCopyMemory(lpEnhMetaHeader, pmrmf, nCopySize);

    // If an application asks for a version two or three header
    // but the metafile only has a version one header,
    // we can still come up with a valid version two or three header
    // by NULLing out the version two or three data
    // This makes it easier to write an application that just
    // does GetEnhMetaFileHeader with sizeof(ENHMETAHEADER)
    // because it will work on both v1 and v2 and v3 metafiles
    // Same applies to app asking for version three header on a metafile
    // with a version two header
    //
    if (nCopySize == META_HDR_SIZE_VERSION_1 &&
         ((nSize == META_HDR_SIZE_VERSION_2) ||
         (nSize == META_HDR_SIZE_VERSION_3)))
    {
        nCopySize = META_HDR_SIZE_VERSION_2;
        lpEnhMetaHeader->cbPixelFormat = 0;
        lpEnhMetaHeader->offPixelFormat = 0;
        lpEnhMetaHeader->bOpenGL = FALSE;
    }

    if (nCopySize == META_HDR_SIZE_VERSION_2 &&
        nSize == META_HDR_SIZE_VERSION_3)
    {
        nCopySize = META_HDR_SIZE_VERSION_3;
        lpEnhMetaHeader->szlMicrometers.cx = 0;
        lpEnhMetaHeader->szlMicrometers.cy = 0;
    }

    lpEnhMetaHeader->nSize = nCopySize;

GetEnhMetaFileHeader_exit:

    return nCopySize;
}

/******************************Public*Routine******************************\
* UINT APIENTRY GetEnhMetaFileDescription(
*        HENHMETAFILE hemf,
*        UINT cchBuffer,
*        LPWSTR lpDescription );
*
*
* Returns: size of buffer in char count if successful
*          0 if no description
*          GDI_ERROR if an error occurs
*
* History:
*  16-Oct-1991 1991     -by-    John Colleran    [johnc]
* Wrote it.
\**************************************************************************/

extern "C" UINT APIENTRY GetEnhMetaFileDescriptionA(
        HENHMETAFILE hemf,
        UINT cchBuffer,
        LPSTR lpDescription )
{
    return(InternalGetEnhMetaFileDescription(hemf, cchBuffer, lpDescription, FALSE));
}

extern "C" UINT APIENTRY GetEnhMetaFileDescriptionW
(
    HENHMETAFILE hemf,
    UINT cchBuffer,
    LPWSTR lpDescription
)
{
    return(InternalGetEnhMetaFileDescription(hemf, cchBuffer, (LPSTR) lpDescription, TRUE));
}

UINT InternalGetEnhMetaFileDescription
(
    HENHMETAFILE  hemf,
    UINT  cchBuffer,
    LPSTR lpDescription,
    BOOL  bUnicode
)
{
    PMF             pmf;
    UINT            cchRet = GDI_ERROR;
    PENHMETAHEADER  pmrmf = NULL;
    LPWSTR          pwstr = NULL;

    PUTS("InternalGetEnhMetaFileDescription\n");

    // Validate the metafile handle.

    if (!(pmf = GET_PMF(hemf)))
    {
        ERROR_ASSERT(FALSE, "InternalGetEnhMetaFileDescription: invalid hemf");
        goto InternalGetEnhMetaFileDescription_exit;
    }

    pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
        goto InternalGetEnhMetaFileDescription_exit;

    pwstr = (LPWSTR) pmf->emfc.ObtainPtr(pmrmf->offDescription,
                                pmrmf->nDescription * sizeof(WCHAR));

    if(!pwstr)
        goto InternalGetEnhMetaFileDescription_exit;

    if (lpDescription == (LPSTR) NULL)
    {
        // Return the size if that's all they want.

        if( bUnicode )
        {
            cchRet = pmrmf->nDescription;
        }
        else
        {
            cchRet = 0;

            RtlUnicodeToMultiByteSize((ULONG*)&cchRet, pwstr, 
                                      (UINT)(pmrmf->nDescription)*sizeof(WCHAR));
        }
    }
    else
    {
        // Copy the data
        
        if (bUnicode)
        {
            cchRet = min(cchBuffer, (UINT) pmrmf->nDescription);
    
            RtlCopyMemory
            (
                (PBYTE) lpDescription,
                (PBYTE) pwstr,
                cchRet * sizeof(WCHAR)
            );
        }
        else
        {
            if (pmrmf->nDescription)
            {
                cchRet = WideCharToMultiByte(CP_ACP,
                                             0,
                                             pwstr,
                                             (UINT) pmrmf->nDescription,
                                             lpDescription,
                                             cchBuffer,
                                             NULL,
                                             NULL);
    
                if (cchRet == 0)
                {
                // Unicode to Ansi translation is failed.
    
                    cchRet = (UINT) GDI_ERROR;
                }
            }
            else
            {
            // There is no description.
    
                cchRet = 0;
            }
        }
    }

InternalGetEnhMetaFileDescription_exit:

    if(pwstr)
        pmf->emfc.ReleasePtr(pwstr);

    return(cchRet);
}

/******************************Public*Routine******************************\
*
* GetEnhMetaFilePixelFormat
*
* Retrieves the last pixel format set in the given enhanced metafile
*
* History:
*  Thu Apr 06 15:07:34 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

extern "C" UINT APIENTRY GetEnhMetaFilePixelFormat(HENHMETAFILE hemf,
                                                   UINT cbBuffer,
                                                   PIXELFORMATDESCRIPTOR *ppfd)
{
    PMF             pmf;
    UINT            cbRet = GDI_ERROR;
    PENHMETAHEADER  pmrmf = NULL;
    PBYTE           pb = NULL;

    PUTS("GetEnhMetaFilePixelFormat\n");

    // Validate the metafile handle.
    if (!(pmf = GET_PMF(hemf)))
    {
        ERROR_ASSERT(FALSE, "GetEnhMetaFilePixelFormat: invalid hemf");
        GdiSetLastError(ERROR_INVALID_HANDLE);
        goto GetEnhMetaFilePixelFormat_exit;
    }

    pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
        goto GetEnhMetaFilePixelFormat_exit;

    // Ensure that this metafile is a version which supports the
    // pixel format information
    if (pmrmf->nSize < META_HDR_SIZE_VERSION_2)
    {
        ERROR_ASSERT(FALSE, "GetEnhMetaFilePixelFormat: invalid hdr version");
        GdiSetLastError(ERROR_INVALID_HANDLE);
        goto GetEnhMetaFilePixelFormat_exit;
    }

    pb = (PBYTE) pmf->emfc.ObtainPtr(pmrmf->offPixelFormat, pmrmf->cbPixelFormat);

    if(!pb)
    {
        goto GetEnhMetaFilePixelFormat_exit;
    }

    cbRet = pmrmf->cbPixelFormat;

    // Copy the data if a buffer is provided and is large enough and
    // there is data to copy
    if (cbRet > 0 && ppfd != NULL && cbBuffer >= cbRet)
    {
        ASSERTGDI(pmrmf->offPixelFormat != 0,
                  "cbPixelFormat set but not offPixelFormat\n");

        RtlCopyMemory((PBYTE)ppfd, pb, cbRet);
    }

GetEnhMetaFilePixelFormat_exit:
    
    if(pb)
        pmf->emfc.ReleasePtr(pb);

    return cbRet;
}

/******************************Public*Routine******************************\
* BOOL APIENTRY GdiComment( HDC hDC, UINT nSize, LPBYTE lpData )
*
* Records a Comment record in a metafile if hDC is a metafile DC otherwise
* it is a no-op
*
*
* Returns: TRUE if succesful otherwise false
*
* History:
*  16-Oct-1991 1991     -by-    John Colleran    [johnc]
* Wrote it.
\**************************************************************************/

extern "C" BOOL APIENTRY GdiComment( HDC hdc, UINT nSize, CONST BYTE *lpData )
{
    BOOL bRet = TRUE;

    PUTS("GdiComment\n");

    if (LO_TYPE(hdc) == LO_ALTDC_TYPE)
    {
        PLDC pldc;
        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC)
            bRet = MF_GdiComment(hdc, nSize, lpData);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
*
* BOOL IsValidEnhMetaRecord(pht,pemr)
*  Tue Sep 03 11:21:14 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" BOOL APIENTRY IsValidEnhMetaRecord
(
    PVOID pht,
    PVOID pmrIn
)
{
    PUTS("IsValidEnhMetaRecord\n");
    CONST PENHMETARECORD pmr = (CONST PENHMETARECORD)pmrIn;

    if (pmr->iType >= EMR_MIN && pmr->iType <= EMR_MAX)
    {
        return
        (
            (((PMR) pmr)->*afnbMRCheck[((PENHMETARECORD)pmr)->iType - 1])
            (
                (PHANDLETABLE) pht
            )
        );
    }
    EMFVALFAIL(("IsValidEnhMetaFileRecord: failed\n")); 
    return(FALSE);
}

/******************************Public*Routine******************************\
*
* BOOL IsValidEnhMetaRecordOffExt(pht,pemr,Off,Ext)
*  Tue Sep 03 11:21:14 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" BOOL APIENTRY IsValidEnhMetaRecordOffExt
(
    PVOID pht,
    PVOID pmrIn,
    DWORD Off,
    DWORD Ext
)
{
    PUTS("IsValidEnhMetaRecordOffExt\n");
    CONST PENHMETARECORD pmr = (CONST PENHMETARECORD)pmrIn;

    if (pmr->iType >= EMR_MIN && pmr->iType <= EMR_MAX)
    {
        return ((PMR)pmr)->bValidOffExt((PHANDLETABLE)pht, Off, Ext);
    }
    EMFVALFAIL(("IsValidEnhMetaRecordOffExt: failed\n")); 
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\metarec.cxx ===
/******************************Module*Header*******************************\
* Module Name: metarec.cxx
*
* Metafile recording functions.
*
* Created: 12-June-1991 13:46:00
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/
#define NO_STRICT

extern "C" {
#if defined(_GDIPLUS_)
#include    <gpprefix.h>
#endif

#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <stddef.h>
#include    <windows.h>    // GDI function declarations.
#include    <winerror.h>
#include    "firewall.h"
#define __CPLUSPLUS
#include    <winspool.h>
#include    <w32gdip.h>
#include    "ntgdistr.h"
#include    "winddi.h"
#include    "icm.h"
#include    "hmgshare.h"
#include    "local.h"      // Local object support.
#include    "gdiicm.h"
#include    "font.h"
#include    "metadef.h"    // Metafile record type constants.
#include    "metarec.h"    // Metafile recording functions.
#include    "mf16.h"
#include    "nlsconv.h"
#include    "ntgdi.h"
#include    "xfflags.h"
#include "..\inc\mapfile.h"
}

#include    "rectl.hxx"
#include    "mfdc.hxx"  // Metafile DC class declarations.
#include    "mfrec.hxx" // Metafile record class declarations.
extern "C" {
#include    "mfrec16.h" // 3.x Metafile recording functions
}

extern "C" BOOL bDoFontChange(HDC hdc, WCHAR *pwsz, int c, UINT fl);
extern "C" BOOL bRecordEmbedFonts(HDC hdc);

XFORM xformIdentity = { 1.00000000f, 0.00000000f, 0.00000000f, 1.00000000f,
                        0.00000000f, 0.00000000f };

#ifdef LANGPACK
extern LONG gdwDisableMetafileRec ;
#endif

// SaveDC
// BeginPath
// EndPath
// CloseFigure
// FlattenPath
// WidenPath
// AbortPath
// SetMetaRgn
// RealizePalette

extern "C" BOOL MF_Record(HDC hdc,DWORD mrType)
{
    PMR     pmr;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_Record\n");

    if (!(pmr = (PMR) pmdc->pvNewRecord(SIZEOF_MR)))
        return(FALSE);

    pmr->vInit(mrType);
    pmr->vCommit(pmdc);
    return(TRUE);
}

// FillPath
// StrokeAndFillPath
// StrokePath

extern "C" BOOL MF_BoundRecord(HDC hdc,DWORD mrType)
{
    PMRB    pmrb;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");


    PUTS("MF_BoundRecord\n");

    if (!(pmrb = (PMRB) pmdc->pvNewRecord(SIZEOF_MRB)))
        return(FALSE);

    pmrb->vInit(mrType, pmdc);
    pmrb->vCommit(pmdc);
    return(TRUE);
}

// SetMapperFlags
// SetMapMode
// SetBkMode
// SetPolyFillMode
// SetROP2
// SetStretchBltMode
// SetTextAlign
// SetTextColor
// SetBkColor
// RestoreDC
// SetArcDirection
// SetMiterLimit
// SelectClipPath
// SetLayout

extern "C" BOOL MF_SetD(HDC hdc,DWORD d1,DWORD mrType)
{
    PMRD    pmrd;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_SetD\n");

    if( ( mrType == EMR_SETMAPMODE ) ||
        ( mrType == EMR_SETMAPPERFLAGS ) ||
        ( mrType == EMR_SETLAYOUT ) ||
        ( mrType == EMR_RESTOREDC  ) )
    {
        pldc->fl |= LDC_FONT_CHANGE;
    }

    if (!(pmrd = (PMRD) pmdc->pvNewRecord(SIZEOF_MRD)))
        return(FALSE);

    pmrd->vInit(mrType, d1);
    pmrd->vCommit(pmdc);
    return(TRUE);
}

// OffsetWindowOrgEx
// OffsetViewportOrgEx
// SetWindowExtEx
// SetWindowOrgEx
// SetViewportExtEx
// SetViewportOrgEx
// SetBrushOrgEx
// OffsetClipRgn
// MoveToEx
// LineTo
// SetTextJustification

extern "C" BOOL MF_SetDD(HDC hdc,DWORD d1,DWORD d2,DWORD mrType)
{
    PMRDD   pmrdd;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_SetDD\n");

    if( ( mrType == EMR_SETVIEWPORTEXTEX ) || ( mrType == EMR_SETWINDOWEXTEX ) )
    {
        pldc->fl |= LDC_FONT_CHANGE;
    }

    if (!(pmrdd = (PMRDD) pmdc->pvNewRecord(SIZEOF_MRDD)))
        return(FALSE);

    pmrdd->vInit(mrType, d1, d2);
    pmrdd->vCommit(pmdc);
    return(TRUE);
}

// ExcludeClipRect
// IntersectClipRect
// ScaleViewportExtEx
// ScaleWindowExtEx

extern "C" BOOL MF_SetDDDD(HDC hdc,DWORD d1,DWORD d2,DWORD d3,DWORD d4,DWORD mrType)
{
    PMRDDDD pmrdddd;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_SetDDDD\n");

    if( ( mrType == EMR_SCALEVIEWPORTEXTEX ) || ( mrType == EMR_SCALEWINDOWEXTEX ) )
    {
        pldc->fl |= LDC_FONT_CHANGE;
    }

    if (!(pmrdddd = (PMRDDDD) pmdc->pvNewRecord(SIZEOF_MRDDDD)))
        return(FALSE);

    pmrdddd->vInit(mrType, d1, d2, d3, d4);
    pmrdddd->vCommit(pmdc);
    return(TRUE);
}

// SetMetaRgn

extern "C" BOOL MF_SetMetaRgn(HDC hdc)
{
    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_SetMetaRgn\n");

// Record it first.

    if (!MF_Record(hdc,EMR_SETMETARGN))
        return(FALSE);

// We have to flush the bounds before we change the clipping region
// because the bounds are clipped to the current clipping region bounds.

    pmdc->vFlushBounds();

// Now update the clipping bounds to prepare for the next flush.

    pmdc->vSetMetaBounds();

    return(TRUE);
}

// SelectClipPath

extern "C" BOOL MF_SelectClipPath(HDC hdc,int iMode)
{
    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_SelectClipPath\n");

// Record it first.

    if (!MF_SetD(hdc, (DWORD) iMode, EMR_SELECTCLIPPATH))
        return(FALSE);

// We have to flush the bounds before we change the clipping region
// because the bounds are clipped to the current clipping region bounds.

    pmdc->vFlushBounds();

// Now mark the clipping bounds dirty.  The clipping bounds is updated
// when it is needed.

    pmdc->vMarkClipBoundsDirty();

    return(TRUE);
}

// OffsetClipRgn

extern "C" BOOL MF_OffsetClipRgn(HDC hdc,int x1,int y1)
{
    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_OffsetClipRgn\n");

// Record it first.

    if (!MF_SetDD(hdc, (DWORD) x1, (DWORD) y1, EMR_OFFSETCLIPRGN))
        return(FALSE);

// We have to flush the bounds before we change the clipping region
// because the bounds are clipped to the current clipping region bounds.

    pmdc->vFlushBounds();

// Now mark the clipping bounds dirty.  The clipping bounds is updated
// when it is needed.

    pmdc->vMarkClipBoundsDirty();

    return(TRUE);
}

// ExcludeClipRect
// IntersectClipRect

extern "C" BOOL MF_AnyClipRect(HDC hdc,int x1,int y1,int x2,int y2,DWORD mrType)
{
    BOOL    bRet = FALSE;
    HRGN    hrgnTmp;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_AnyClipRect\n");

// Record it first.

    if (!MF_SetDDDD(hdc, (DWORD) x1, (DWORD) y1, (DWORD) x2, (DWORD) y2, mrType))
        return(bRet);

// We have to flush the bounds before we change the clipping region
// because the bounds are clipped to the current clipping region bounds.

    pmdc->vFlushBounds();

// Now mark the clipping bounds dirty.  The clipping bounds is updated
// when it is needed.

    pmdc->vMarkClipBoundsDirty();

// For ExcludeClipRect and InteresectClipRect, this is a little tricky.
// If there is no initial clip region, we have to create a default clipping
// region.  Otherwise, GDI will create some random default clipping region
// for us!

// Find out if we have a clip region.

    if (!(hrgnTmp = CreateRectRgn(0, 0, 0, 0)))
        return(bRet);

    switch (GetClipRgn(hdc, hrgnTmp))
    {
    case -1:    // error
        ASSERTGDI(FALSE, "GetClipRgn failed");
        break;

    case 0:     // no initial clip region
        // We need to select in our default clipping region.
        // First, make our default clipping region.

        if (!SetRectRgn(hrgnTmp,
                        (int) (SHORT) MINSHORT,
                        (int) (SHORT) MINSHORT,
                        (int) (SHORT) MAXSHORT,
                        (int) (SHORT) MAXSHORT))
        {
            ASSERTGDI(FALSE, "SetRectRgn failed");
            break;
        }

        // Now select our default region but don't metafile the call.

        {
            INT iRet;

            iRet = NtGdiExtSelectClipRgn(hdc, hrgnTmp, RGN_COPY);

            bRet = (iRet != RGN_ERROR);

        }
        break;

    case 1:     // has initial clip region
        bRet = TRUE;
        break;
    }

    if (!DeleteObject(hrgnTmp))
    {
        ASSERTGDI(FALSE, "DeleteObject failed");
    }

    return(bRet);
}

// Always store the relative level.

extern "C" BOOL MF_RestoreDC(HDC hdc,int iLevel)
{
    int cLevel = (int) GetDCDWord(hdc,DDW_SAVEDEPTH,0);

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

// Compute the relative level.

    if (iLevel > 0)
    {
        iLevel = iLevel - cLevel;
    }

// Check bad levels.

    if ((iLevel >= 0) || (iLevel + cLevel <= 0))
        return(FALSE);

    if (!MF_SetD(hdc,(DWORD)iLevel,EMR_RESTOREDC))
        return(FALSE);

// We have to flush the bounds before we change the clipping region
// because the bounds are clipped to the current clipping region bounds.

    pmdc->vFlushBounds();

// Now mark the clipping bounds dirty.  The clipping bounds is updated
// when it is needed.

    pmdc->vMarkClipBoundsDirty();
    pmdc->vMarkMetaBoundsDirty();

    return(TRUE);
}

extern "C" BOOL MF_SetViewportExtEx(HDC hdc,int x,int y)
{
    return(MF_SetDD(hdc,(DWORD)x,(DWORD)y,EMR_SETVIEWPORTEXTEX));
}

extern "C" BOOL MF_SetViewportOrgEx(HDC hdc,int x,int y)
{
    return(MF_SetDD(hdc,(DWORD)x,(DWORD)y,EMR_SETVIEWPORTORGEX));
}

extern "C" BOOL MF_SetWindowExtEx(HDC hdc,int x,int y)
{
    return(MF_SetDD(hdc,(DWORD)x,(DWORD)y,EMR_SETWINDOWEXTEX));
}

extern "C" BOOL MF_SetWindowOrgEx(HDC hdc,int x,int y)
{
    return(MF_SetDD(hdc,(DWORD)x,(DWORD)y,EMR_SETWINDOWORGEX));
}

// Map it to SetViewportOrgEx record.

extern "C" BOOL MF_OffsetViewportOrgEx(HDC hdc,int x,int y)
{
    POINTL ptl;

    if (!GetViewportOrgEx(hdc, (LPPOINT) &ptl))
        return(FALSE);
    return
        (
        MF_SetDD
            (
            hdc,
            (DWORD)(ptl.x + (LONG) x),
            (DWORD)(ptl.y + (LONG) y),
            EMR_SETVIEWPORTORGEX
            )
        );
}

// Map it to SetWindowOrgEx record.

extern "C" BOOL MF_OffsetWindowOrgEx(HDC hdc,int x,int y)
{
    POINTL ptl;

    if (!GetWindowOrgEx(hdc, (LPPOINT) &ptl))
        return(FALSE);
    return
        (
        MF_SetDD
            (
            hdc,
            (DWORD) (ptl.x + (LONG) x),
            (DWORD) (ptl.y + (LONG) y),
            EMR_SETWINDOWORGEX
            )
        );
}

extern "C" BOOL MF_SetBrushOrgEx(HDC hdc,int x,int y)
{
    return(MF_SetDD(hdc,(DWORD)x,(DWORD)y,EMR_SETBRUSHORGEX));
}

// PolyBezier
// Polygon
// Polyline
// PolyBezierTo
// PolylineTo

extern "C" BOOL MF_Poly(HDC hdc, CONST POINT *pptl,DWORD cptl,DWORD mrType)
{
    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_Poly\n");

// Check input assumptions.

    ASSERTGDI
    (
        mrType == EMR_POLYBEZIER
     || mrType == EMR_POLYGON
     || mrType == EMR_POLYLINE
     || mrType == EMR_POLYBEZIERTO
     || mrType == EMR_POLYLINETO,
        "MF_Poly: Bad record type"
    );

    ASSERTGDI
    (
        EMR_POLYGON - EMR_POLYBEZIER == EMR_POLYGON16 - EMR_POLYBEZIER16
     && EMR_POLYLINE - EMR_POLYBEZIER == EMR_POLYLINE16 - EMR_POLYBEZIER16
     && EMR_POLYBEZIERTO - EMR_POLYBEZIER == EMR_POLYBEZIERTO16 - EMR_POLYBEZIER16
     && EMR_POLYLINETO - EMR_POLYBEZIER == EMR_POLYLINETO16 - EMR_POLYBEZIER16,
        "MF_Poly: Bad record type"
    );

// Store 16-bit record if possible.

    if (bIsPoly16((PPOINTL) pptl, cptl))
    {
        PMRBP16 pmrbp16;

        if (!(pmrbp16 = (PMRBP16) pmdc->pvNewRecord(SIZEOF_MRBP16(cptl))))
            return(FALSE);

        pmrbp16->vInit
        (
            mrType - EMR_POLYBEZIER + EMR_POLYBEZIER16,
            cptl,
            (PPOINTL) pptl,
            pmdc
        );
        pmrbp16->vCommit(pmdc);
    }
    else
    {
        PMRBP   pmrbp;

        if (!(pmrbp = (PMRBP) pmdc->pvNewRecord(SIZEOF_MRBP(cptl))))
            return(FALSE);

        pmrbp->vInit(mrType, cptl, (PPOINTL) pptl, pmdc);
        pmrbp->vCommit(pmdc);
    }
    return(TRUE);
}

// PolyPolygon
// PolyPolyline

extern "C" BOOL MF_PolyPoly(HDC hdc, CONST POINT *pptl, CONST DWORD *pc,DWORD cPoly,DWORD mrType)
{
    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_PolyPoly\n");

// Check input assumptions.

    ASSERTGDI
    (
        mrType == EMR_POLYPOLYGON
     || mrType == EMR_POLYPOLYLINE,
        "MF_PolyPoly: Bad record type"
    );

    ASSERTGDI
    (
        EMR_POLYPOLYLINE - EMR_POLYPOLYGON == EMR_POLYPOLYLINE16 - EMR_POLYPOLYGON16,
        "MF_Poly: Bad record type"
    );

// Compute the size of the PolyPoly record.

    DWORD cptl = 0;
    for (DWORD i = 0; i < cPoly; i++)
        cptl += pc[i];

// Store 16-bit record if possible.

    if (bIsPoly16((PPOINTL) pptl, cptl))
    {
        PMRBPP16 pmrbpp16;

        if (!(pmrbpp16 = (PMRBPP16) pmdc->pvNewRecord(SIZEOF_MRBPP16(cptl,cPoly))))
            return(FALSE);

        pmrbpp16->vInit
        (
            mrType - EMR_POLYPOLYGON + EMR_POLYPOLYGON16,
            cPoly,
            cptl,
            (LPDWORD) pc,
            (PPOINTL) pptl,
            pmdc
        );
        pmrbpp16->vCommit(pmdc);
    }
    else
    {
        PMRBPP   pmrbpp;

        if (!(pmrbpp = (PMRBPP) pmdc->pvNewRecord(SIZEOF_MRBPP(cptl,cPoly))))
            return(FALSE);

        pmrbpp->vInit(mrType, cPoly, cptl, (LPDWORD) pc, (PPOINTL) pptl, pmdc);
        pmrbpp->vCommit(pmdc);
    }
    return(TRUE);
}


/******************************Public*Routine******************************\
* MF_TriangleMesh
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

extern "C" BOOL
MF_GradientFill(
            HDC               hdc,
            CONST PTRIVERTEX  pVertex,
            ULONG             nVertex,
            CONST PVOID       pMesh,
            ULONG             nMesh,
            ULONG             ulMode
            )
{
    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);
    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_TriangleMesh\n");

    PMRGRADIENTFILL pmrtr;

    if (!(pmrtr = (PMRGRADIENTFILL) pmdc->pvNewRecord(SIZEOF_MRGRADIENTFILL(nVertex,nMesh))))
    {
        return(FALSE);
    }

    pmrtr->vInit(nVertex,pVertex,nMesh,pMesh,ulMode,pmdc);
    pmrtr->vCommit(pmdc);

    SET_COLOR_PAGE(pldc);

    return(TRUE);
}

// PolyDraw

extern "C" BOOL MF_PolyDraw(HDC hdc, CONST POINT *pptl, CONST BYTE *pb, DWORD cptl)
{
    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_PolyDraw\n");

// Store 16-bit record if possible.

    if (bIsPoly16((PPOINTL) pptl, cptl))
    {
        PMRPOLYDRAW16   pmrpd16;

        if (!(pmrpd16 = (PMRPOLYDRAW16) pmdc->pvNewRecord(SIZEOF_MRPOLYDRAW16(cptl))))
            return(FALSE);

        pmrpd16->vInit(pmdc, (PPOINTL) pptl, pb, cptl);
        pmrpd16->vCommit(pmdc);
    }
    else
    {
        PMRPOLYDRAW     pmrpd;

        if (!(pmrpd = (PMRPOLYDRAW) pmdc->pvNewRecord(SIZEOF_MRPOLYDRAW(cptl))))
            return(FALSE);

        pmrpd->vInit(pmdc, (PPOINTL) pptl, pb, cptl);
        pmrpd->vCommit(pmdc);
    }
    return(TRUE);
}

// InvertRgn
// PaintRgn

extern "C" BOOL MF_InvertPaintRgn(HDC hdc,HRGN hrgn,DWORD mrType)
{
    PMRBR   pmrbr;
    DWORD   cRgnData;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_InvertPaintRgn\n");

// Get the size of the region data.

    if (!(cRgnData = GetRegionData(hrgn, 0, (LPRGNDATA) NULL)))
        return(FALSE);

// Allocate dword aligned structure.

    if (!(pmrbr = (PMRBR) pmdc->pvNewRecord(SIZEOF_MRBR(cRgnData))))
        return(FALSE);

    if (!pmrbr->bInit(mrType, pmdc, hrgn, cRgnData, sizeof(MRBR)))
        return(FALSE);

    pmrbr->vCommit(pmdc);
    return(TRUE);
}

// FillRgn

extern "C" BOOL MF_FillRgn(HDC hdc,HRGN hrgn,HBRUSH hbrush)
{
    PMRFILLRGN  pmrfr;
    DWORD       cRgnData;
    DWORD       imheBrush;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_FillRgn\n");

// Create the brush first.

    if (!(imheBrush = MF_InternalCreateObject(hdc, hbrush)))
        return(FALSE);

// Get the size of the region data.

    if (!(cRgnData = GetRegionData(hrgn, 0, (LPRGNDATA) NULL)))
        return(FALSE);

// Allocate dword aligned structure.

    if (!(pmrfr = (PMRFILLRGN) pmdc->pvNewRecord(SIZEOF_MRFILLRGN(cRgnData))))
        return(FALSE);

    if (!pmrfr->bInit(pmdc, hrgn, cRgnData, imheBrush))
        return(FALSE);

    pmrfr->vCommit(pmdc);
    return(TRUE);
}

// FrameRgn

extern "C" BOOL MF_FrameRgn(HDC hdc,HRGN hrgn,HBRUSH hbrush,int cx,int cy)
{
    PMRFRAMERGN pmrfr;
    DWORD       cRgnData;
    DWORD       imheBrush;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_FrameRgn\n");

// Create the brush first.

    if (!(imheBrush = MF_InternalCreateObject(hdc, hbrush)))
        return(FALSE);

// Get the size of the region data.

    if (!(cRgnData = GetRegionData(hrgn, 0, (LPRGNDATA) NULL)))
        return(FALSE);

// Allocate dword aligned structure.

    if (!(pmrfr = (PMRFRAMERGN) pmdc->pvNewRecord(SIZEOF_MRFRAMERGN(cRgnData))))
        return(FALSE);

    if (!pmrfr->bInit(pmdc, hrgn, cRgnData, imheBrush, (LONG) cx, (LONG) cy))
        return(FALSE);

    pmrfr->vCommit(pmdc);
    return(TRUE);
}

// SelectClipRgn
// ExtSelectClipRgn
// SelectObject(hdc,hrgn)

extern "C" BOOL MF_ExtSelectClipRgn(HDC hdc,HRGN hrgn,int iMode)
{
    PMREXTSELECTCLIPRGN pmrescr;
    DWORD       cRgnData;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_ExtSelectClipRgn\n");

// Get the size of the region data.

    if (iMode == RGN_COPY && hrgn == (HRGN) 0)
        cRgnData = 0;
    else if (!(cRgnData = GetRegionData(hrgn, 0, (LPRGNDATA) NULL)))
        return(FALSE);

// Allocate dword aligned structure.

    if (!(pmrescr = (PMREXTSELECTCLIPRGN) pmdc->pvNewRecord
                        (SIZEOF_MREXTSELECTCLIPRGN(cRgnData))))
        return(FALSE);

    if (!pmrescr->bInit(hrgn, cRgnData, (DWORD) iMode))
        return(FALSE);

    pmrescr->vCommit(pmdc);

// We have to flush the bounds before we change the clipping region
// because the bounds are clipped to the current clipping region bounds.

    pmdc->vFlushBounds();

// Now mark the clipping bounds dirty.  The clipping bounds is updated
// when it is needed.

    pmdc->vMarkClipBoundsDirty();

    return(TRUE);
}

// SetPixel
// SetPixelV

extern "C" BOOL MF_SetPixelV(HDC hdc,int x,int y,COLORREF color)
{
    PMRSETPIXELV pmrspv;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_SetPixelV\n");

    if (!(pmrspv = (PMRSETPIXELV) pmdc->pvNewRecord(SIZEOF_MRSETPIXELV)))
        return(FALSE);

    pmrspv->vInit(x, y, color);
    pmrspv->vCommit(pmdc);

    CHECK_COLOR_PAGE(pldc,color);

    return(TRUE);
}

// AngleArc

extern "C" BOOL MF_AngleArc(HDC hdc,int x,int y,DWORD r,FLOAT eA,FLOAT eB)
{
    PMRANGLEARC pmraa;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_AngleArc\n");

    if (!(pmraa = (PMRANGLEARC) pmdc->pvNewRecord(SIZEOF_MRANGLEARC)))
        return(FALSE);

    pmraa->vInit(x, y, r, eA, eB);
    pmraa->vCommit(pmdc);
    return(TRUE);
}

// SetArcDirection - This is recorded only when used.


extern "C" BOOL MF_ValidateArcDirection(HDC hdc)
{
    PLDC pldc;
    BOOL bClockwiseMeta, bClockwiseAdvanced;

    DC_PLDC(hdc,pldc,FALSE);

    PUTS("MF_ValidateArcDirection\n");

// Get the current arc direction recorded in the metafile.
// The metafile is recorded in the advanced graphics mode only.

    bClockwiseMeta = (pldc->fl & LDC_META_ARCDIR_CLOCKWISE) ? TRUE : FALSE;

// Get the current arc direction in the advanced graphics mode.

    bClockwiseAdvanced = (GetArcDirection(hdc) == AD_CLOCKWISE);

    if (GetGraphicsMode(hdc) == GM_COMPATIBLE)
    {
        switch (GetMapMode(hdc))
        {
        case MM_LOMETRIC:
        case MM_HIMETRIC:
        case MM_LOENGLISH:
        case MM_HIENGLISH:
        case MM_TWIPS:
            bClockwiseAdvanced = !bClockwiseAdvanced;
            break;

        //
        // If it is MM_ANISOTROPIC and MM_ISOTROPIC
        // and negative transform, we flip the arc direction.
        // related bugs - 3026, 74010 [lingyunw]
        //
        case MM_ANISOTROPIC:
        case MM_ISOTROPIC:
            {
               PDC_ATTR pDcAttr;
               PVOID  pvUser;

               PSHARED_GET_VALIDATE(pvUser,hdc,DC_TYPE);

               if (pvUser)
               {
                  pDcAttr = (PDC_ATTR)pvUser;

                  //
                  // if the xform has changed, we call to the kernel
                  // to update it
                  //
                  if(pDcAttr->flXform &
                     (PAGE_XLATE_CHANGED | PAGE_EXTENTS_CHANGED | WORLD_XFORM_CHANGED))
                  {
                      if (!NtGdiUpdateTransform(hdc))
                          return(FALSE);
                  };

                  if (((pDcAttr->flXform & PTOD_EFM11_NEGATIVE) != 0) ^
                       ((pDcAttr->flXform & PTOD_EFM22_NEGATIVE) != 0))
                  {
                      bClockwiseAdvanced = !bClockwiseAdvanced;
                  }
               }
            }
            break;
        }
    }

// Record it only if the new arc direction differs from the recorded one.

    if (bClockwiseMeta == bClockwiseAdvanced)
        return(TRUE);

    pldc->fl ^= LDC_META_ARCDIR_CLOCKWISE;

    return
    (
        MF_SetD
        (
            hdc,
            (DWORD) (bClockwiseAdvanced ? AD_CLOCKWISE : AD_COUNTERCLOCKWISE),
            EMR_SETARCDIRECTION
        )
    );
}


// Ellipse
// Rectangle

extern "C" BOOL MF_EllipseRect(HDC hdc,int x1,int y1,int x2,int y2,DWORD mrType)
{
    PMRE  pmre;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_EllipseRect\n");

// Validate the arc direction in the metafile first.

    if (!MF_ValidateArcDirection(hdc))
        return(FALSE);

    if (!(pmre = (PMRE) pmdc->pvNewRecord(SIZEOF_MRE)))
        return(FALSE);

// If the box is empty, don't record it and return success.

    switch (pmre->iInit(mrType, hdc, x1, y1, x2, y2))
    {
    case MRI_ERROR:     return(FALSE);
    case MRI_NULLBOX:   return(TRUE);
    case MRI_OK:        break;
    default:            ASSERTGDI(FALSE, "MRE::iInit returned bad value");
                        break;
    }

    pmre->vCommit(pmdc);
    return(TRUE);
}

// RoundRect

extern "C" BOOL MF_RoundRect(HDC hdc,int x1,int y1,int x2,int y2,int x3,int y3)
{
    PMRROUNDRECT pmrrr;

    PUTS("MF_RoundRect\n");

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

// Validate the arc direction in the metafile first.

    if (!MF_ValidateArcDirection(hdc))
        return(FALSE);

    if (!(pmrrr = (PMRROUNDRECT) pmdc->pvNewRecord(SIZEOF_MRROUNDRECT)))
        return(FALSE);

// If the box is empty, don't record it and return success.

    switch (pmrrr->iInit(hdc, x1, y1, x2, y2, x3, y3))
    {
    case MRI_ERROR:     return(FALSE);
    case MRI_NULLBOX:   return(TRUE);
    case MRI_OK:        break;
    default:            ASSERTGDI(FALSE, "MRROUNDRECT::iInit returned bad value");
                        break;
    }

    pmrrr->vCommit(pmdc);
    return(TRUE);
}

// Arc
// ArcTo
// Chord
// Pie

extern "C" BOOL MF_ArcChordPie(HDC hdc,int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4,DWORD mrType)
{
    PMREPP  pmrepp;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_ArcChordPie\n");

// Validate the arc direction in the metafile first.

    if (!MF_ValidateArcDirection(hdc))
        return(FALSE);


    if (!(pmrepp = (PMREPP) pmdc->pvNewRecord(SIZEOF_MREPP)))
        return(FALSE);

// If the box is empty, don't record it and return success.

    switch (pmrepp->iInit(mrType, hdc, x1, y1, x2, y2, x3, y3, x4, y4))
    {
    case MRI_ERROR:     return(FALSE);
    case MRI_NULLBOX:   return(TRUE);
    case MRI_OK:        break;
    default:            ASSERTGDI(FALSE, "MREPP::iInit returned bad value");
                        break;
    }

    pmrepp->vCommit(pmdc);
    return(TRUE);
}

// SetWorldTransform

extern "C" BOOL MF_SetWorldTransform(HDC hdc, CONST XFORM *pxform)
{
    PMRX    pmrx;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_SetWorldTransform\n");

    pldc->fl |= LDC_FONT_CHANGE;

    if (!(pmrx = (PMRX) pmdc->pvNewRecord(SIZEOF_MRX)))
        return(FALSE);

    pmrx->vInit(EMR_SETWORLDTRANSFORM, *pxform);
    pmrx->vCommit(pmdc);
    return(TRUE);
}

// ModifyWorldTransform

extern "C" BOOL MF_ModifyWorldTransform(HDC hdc, CONST XFORM *pxform, DWORD iMode)
{
    PMRXD   pmrxd;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_ModifyWorldTransform\n");

    pldc->fl |= LDC_FONT_CHANGE;

    if (!(pmrxd = (PMRXD) pmdc->pvNewRecord(SIZEOF_MRXD)))
        return(FALSE);

// If the mode is set to identity transform, use our identity transform
// since there may not be an input transform.

    pmrxd->vInit
        (
        EMR_MODIFYWORLDTRANSFORM,
        (iMode == MWT_IDENTITY) ? xformIdentity : *pxform,
        iMode
        );
    pmrxd->vCommit(pmdc);
    return(TRUE);
}

// SelectObject
// SelectPalette

extern "C" BOOL MF_SelectAnyObject(HDC hdc,HANDLE h,DWORD mrType)
{
    DWORD   imhe;

#ifdef LANGPACK
    if(gbLpk && gdwDisableMetafileRec)   // if there is alangpack, then don't record this (since we are in the middle of an exttextout call)
    {
        ASSERTGDI(LO_TYPE(h) == LO_FONT_TYPE, "gdwDisableMetafileRec\n");

        return TRUE ;
    }
#endif

// Do not do regions.  Region call goes to ExtSelectClipRgn.
// Do not do bitmap.  Metafile DC is not a memory device.
// MF_InternalCreateObject will return an error if given a bitmap handle.

    PUTS("MF_SelectAnyObject\n");

    // we need to set the DCBrush and DCPen here if they are selected

    if ((h == ghbrDCBrush) || (h == ghbrDCPen))
    {
        PVOID p;
        PDC_ATTR pDcAttr;

        PSHARED_GET_VALIDATE(p,hdc,DC_TYPE);

        pDcAttr = (PDC_ATTR)p;

        if (pDcAttr)
        {
            if (h == ghbrDCBrush)
            {
                if (pDcAttr->ulDCBrushClr != CLR_INVALID)
                {
                // Dont know why they were creating a new brush. ghbrDCBrush is a stock object and can be used as such.
                //    h = (HANDLE) CreateSolidBrush (pDcAttr->ulDCBrushClr);
                }
                else
                {
                    return (FALSE);
                }
            }

            if (h == ghbrDCPen)
            {
                if (pDcAttr->ulDCPenClr != CLR_INVALID)
                {
                // Dont know why they were creating a new brush. ghbrDCPen is a stock object and can be used as such. 
                //    h = (HANDLE) CreatePen (PS_SOLID, 0, pDcAttr->ulDCPenClr);
                }
                else
                {
                    return (FALSE);
                }
            }

            if (h == NULL)
            {
                return (FALSE);
            }
        }
    }

    if (!(imhe = MF_InternalCreateObject(hdc, h)))
        return(FALSE);

    return(MF_SetD(hdc, imhe, mrType));
}

// CreatePen
// CreatePenIndirect
// ExtCreatePen
// CreateBrushIndirect
// CreateDIBPatternBrush
// CreateDIBPatternBrushPt
// CreateHatchBrush
// CreatePatternBrush
// CreateSolidBrush
// CreatePalette
// CreateFont
// CreateFontIndirect
// CreateColorSpace

// Create an object if it does not exist.  The object must not be a region.
// It also does not create bitmap objects since we keep them in the drawing
// records.
// Return the metafile handle index of the object.  For stock objects,
// return the special object index.
// Return 0 on error.

DWORD MF_InternalCreateObject(HDC hdc,HANDLE hobj)
{
    DWORD   imhe;
    UINT    ii;
    int     iType;
    int     iRet;
    LOGBRUSH lb;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_InternalCreateObject\n");

    if (hobj == NULL)
    {
        return(0);
    }

// Do not do bitmaps.  We don't keep bitmap handles in metafiles.

    iType = LO_TYPE(hobj);

    if ((iType == LO_BITMAP_TYPE) || (iType == LO_DIBSECTION_TYPE))
    {
        ERROR_ASSERT(FALSE,
            "MF_InternalCreateObject: Cannot select bitmap into an enhanced metafile DC");
        return(0);
    }

// Do not do regions.  Regions are stored in the drawing records.

    ASSERTGDI(iType != LO_REGION_TYPE,
        "MF_InternalCreateObject: Bad object type");

// If this is a stock object, just return a special object index.

    if (IS_STOCKOBJ(hobj))
    {
        for (ii = 0; ii <= STOCK_LAST; ii++)
        {
            if (GetStockObject(ii) == hobj)
            {
                if (iType == LO_FONT_TYPE)
                {
                    pldc->fl |= LDC_FONT_CHANGE;
                }
                break;
            }
        }
        return((DWORD) ENHMETA_STOCK_OBJECT + ii);
    }

// Check if the metafile DC knows this object.

    METALINK metalink(pmetalink16Get(hobj));

    while (metalink.bValid() && (metalink.ihdc != H_INDEX(hdc)))
        metalink.vNext();

// If the metafile DC knows this object, just return the metafile handle index.

    if (metalink.bValid())
    {
        if( iType == LO_FONT_TYPE )
        {
            pldc->fl |= LDC_FONT_CHANGE;
        }
        return((DWORD) metalink.imhe);
    }

// Create the object.

    DWORD ulRet = 0;            // Assume failure

// Allocate a metafile handle entry and update the metalink.

    if ((imhe = imheAllocMHE(hdc, hobj)) == INVALID_INDEX)
        return(ulRet);

    switch (iType)
    {
// Do brush.

    case LO_BRUSH_TYPE:

        iRet = GetObject(hobj,sizeof(lb),&lb);

        // Stock objects is handled above.

        ASSERTGDI(iRet,"MF_InternalCreateObject: Brush error");

        switch (lb.lbStyle)
        {
        case BS_HATCHED:
        case BS_SOLID:
            CHECK_COLOR_PAGE (pldc,lb.lbColor);
        case BS_HOLLOW:

            PMRCREATEBRUSHINDIRECT  pmrcbi;

            if (!(pmrcbi = (PMRCREATEBRUSHINDIRECT) pmdc->pvNewRecord
                                (SIZEOF_MRCREATEBRUSHINDIRECT)))
                break;

            pmrcbi->vInit(imhe, lb);
            pmrcbi->vCommit(pmdc);
            ulRet = imhe;
        break;

        case BS_PATTERN:
        case BS_DIBPATTERN:
        case BS_DIBPATTERNPT:

            {
                UINT    iUsage;
                HBITMAP hbmRemote;
                BMIH    bmih;
                DWORD   cbBitsInfo;
                DWORD   cbBits;
                BOOL    bMonoBrush = FALSE;

                if (!(hbmRemote = GetObjectBitmapHandle((HBRUSH)hobj, &iUsage)))
                {
                    ASSERTGDI(FALSE,
                        "MF_InternalCreateObject: GetObjectBitmapHandle failed");
                    break;
                }

            // For a pattern brush, the usage should be set to DIB_PAL_INDICES
            // if it is monochrome.  If it is color, it becomes a dib pattern
            // brush with DIB_RGB_COLORS usage.

                if (lb.lbStyle == BS_PATTERN)
                {
                    bMonoBrush = MonoBitmap(hbmRemote);

                    if (bMonoBrush)
                        iUsage = DIB_PAL_INDICES;
                    else
                        iUsage = DIB_RGB_COLORS;
                }

            // Get the bitmap info header and sizes.

                if (!bMetaGetDIBInfo(hdc, hbmRemote, &bmih,
                        &cbBitsInfo, &cbBits, iUsage, 0, FALSE))
                    break;

            // Finally create the record and get the bits.

                PMRBRUSH    pmrbr;

                if (!(pmrbr = (PMRBRUSH) pmdc->pvNewRecord
                            (SIZEOF_MRBRUSH(cbBitsInfo,cbBits))))
                    break;

                if (!pmrbr->bInit
                    (
                        bMonoBrush
                            ? EMR_CREATEMONOBRUSH
                            : EMR_CREATEDIBPATTERNBRUSHPT,
                        hdc,
                        imhe,
                        hbmRemote,
                        bmih,
                        iUsage,
                        cbBitsInfo,             // size of bitmap info
                        cbBits          // size of bits buffer
                    )
                   )
                    break;

            // Check whether this is a color brush

                if (pmrbr->fColor)
                {
                    SET_COLOR_PAGE(pldc);
                }
                pmrbr->vCommit(pmdc);

                ulRet = imhe;
            }
            break;

        default:
            ASSERTGDI(FALSE, "MF_InternalCreateObject: Brush error");
        }
        break;

// Do pen.

    case LO_PEN_TYPE:

        PMRCREATEPEN    pmrcpn;

        // Allocate dword aligned structure.

        if (!(pmrcpn = (PMRCREATEPEN) pmdc->pvNewRecord(SIZEOF_MRCREATEPEN)))
            break;

        if (!pmrcpn->bInit(hobj, imhe))
            break;

        CHECK_COLOR_PAGE (pldc,pmrcpn->GetPenColor());

        pmrcpn->vCommit(pmdc);
        ulRet = imhe;
        break;

// Do extended pen.

    case LO_EXTPEN_TYPE:

        EXTLOGPEN       elp;
        PEXTLOGPEN      pelp;
        int             cbelp,tcbelp;

        // Get the size of the ExtPen.

        if (!(cbelp = GetObjectA(hobj, 0, (LPVOID) NULL)))
            break;

        ASSERTGDI(cbelp % 4 == 0, "MF_InternalCreateObject: Bad ext pen size");

        if (cbelp <= sizeof(EXTLOGPEN))
            pelp = &elp;
        else if (!(pelp = (PEXTLOGPEN) LocalAlloc(LMEM_FIXED, (UINT) cbelp)))
            break;

        // Get the ExtPen.

        if (GetObjectA(hobj, cbelp, (LPVOID) pelp) == cbelp)
        {
            UINT        iUsage;
            HBITMAP     hbmRemote  = (HBITMAP) 0;
            BMIH        bmih;
            DWORD       cbBitsInfo = 0;
            DWORD       cbBits     = 0;
            BOOL        bMonoBrush = FALSE;


            // Use switch statement so we can use the break statement on error.
            // The following code is similiar to the brush creation code.

            switch (pelp->elpBrushStyle)
            {
            case BS_DIBPATTERN:
                pelp->elpBrushStyle = BS_DIBPATTERNPT;  // fall through
            case BS_PATTERN:
            case BS_DIBPATTERNPT:

                if (!(hbmRemote = GetObjectBitmapHandle((HBRUSH)hobj, &iUsage)))
                {
                    ASSERTGDI(FALSE,
                        "MF_InternalCreateObject: GetObjectBitmapHandle failed");
                    break;
                }

                // For a pattern brush, the usage should be set to
                // DIB_PAL_INDICES if it is monochrome.  If it is color,
                // it becomes a dib pattern brush with DIB_RGB_COLORS usage.

                if (pelp->elpBrushStyle == BS_PATTERN)
                {
                    bMonoBrush = MonoBitmap(hbmRemote);

                    if (bMonoBrush)
                        iUsage = DIB_PAL_INDICES;
                    else
                        iUsage = DIB_RGB_COLORS;
                }

                // Get the bitmap info header and sizes.

                if (!bMetaGetDIBInfo(hdc, hbmRemote, &bmih,
                        &cbBitsInfo, &cbBits, (DWORD) iUsage, 0, FALSE))
                    break;

                // Record DIB bitmap if possible.

                pelp->elpBrushStyle = bMonoBrush
                                        ? BS_PATTERN
                                        : BS_DIBPATTERNPT;
                *(PDWORD) &pelp->elpColor = (DWORD) iUsage;
                pelp->elpHatch      = 0;

                // fall through

            default:

                tcbelp = cbelp;
#if !defined(_X86_)
                // Adjust the elp to be EXTLOGPEN32 for IA64
                // We do this by shifting all DWORDS from
                // &(pelp->elpNumEntries) up by 4 bytes.
                // This is to make sure the disk format is the same
                // as the X86 compatible EXTLOGPEN32 bassed format.
                MoveMemory((PBYTE)(&pelp->elpNumEntries)-4,
                           (PBYTE)(&pelp->elpNumEntries),
                           tcbelp-FIELD_OFFSET(EXTLOGPEN,elpNumEntries));
                tcbelp -= 4;
#endif

                // Finally create the record (and get the bits).

                PMREXTCREATEPEN pmrecp;

                // Allocate dword aligned structure.

                if (!(pmrecp = (PMREXTCREATEPEN) pmdc->pvNewRecord
                            (SIZEOF_MREXTCREATEPEN(tcbelp,cbBitsInfo,cbBits))))
                    break;

                if (!pmrecp->bInit
                    (
                        hdc,
                        imhe,
                        tcbelp,
                        (PEXTLOGPEN32)pelp,
                        hbmRemote,
                        bmih,
                        cbBitsInfo,     // size of bitmap info
                        cbBits          // size of bits buffer
                    )
                   )
                    break;

                // Check for color page info

                if (pelp->elpBrushStyle == BS_SOLID || pelp->elpBrushStyle == BS_HATCHED)
                {
                    CHECK_COLOR_PAGE (pldc,pelp->elpColor);
                }
                else if (hbmRemote && pmrecp->fColor)
                {
                    SET_COLOR_PAGE(pldc);
                }
                pmrecp->vCommit(pmdc);
                ulRet = imhe;
                break;
            }
        }

        if (cbelp > sizeof(EXTLOGPEN))
        {
            if (LocalFree(pelp))
            {
                ASSERTGDI(FALSE, "MF_InternalCreateObject: LocalFree failed");
            }
        }

        break;

// Do palette.

    case LO_PALETTE_TYPE:

        PMRCREATEPALETTE  pmrcp;
        USHORT            cEntries;

        if (GetObjectA(hobj, sizeof(USHORT), (LPVOID) &cEntries) != 2)
        {
            ASSERTGDI(FALSE, "MF_InternalCreateObject: GetObjectA failed");
            break;
        }

        if (!(pmrcp = (PMRCREATEPALETTE) pmdc->pvNewRecord
                            (SIZEOF_MRCREATEPALETTE(cEntries))))
            break;

        // Also clear peFlags.

        if (!pmrcp->bInit((HPALETTE) hobj, imhe, cEntries))
            break;

        // Also update the metafile palette.

        if (!pmrcp->bCommit(pmdc))
            break;

        ulRet = imhe;
        break;

// Do font.

    case LO_FONT_TYPE:

        PMREXTCREATEFONTINDIRECTW pmecfiw;
        PLDC pldc;
        int iSize;
        ENUMLOGFONTEXDVW elfw;

        pldc = GET_PLDC(hdc);

        iSize = GetObjectW(hobj, (int)sizeof(ENUMLOGFONTEXDVW), (LPVOID)&elfw);

        if (!iSize)
            break;

        ASSERTGDI(
            ((DWORD)iSize) == (offsetof(ENUMLOGFONTEXDVW,elfDesignVector) + SIZEOFDV(elfw.elfDesignVector.dvNumAxes)),
            "sizeof enumlogfontexdvw is broken\n"
            );

        ASSERTGDI(
           sizeof(EXTLOGFONTW) < (offsetof(ENUMLOGFONTEXDVW,elfDesignVector) + SIZEOFDV(0)),
           "sizeof(EXTLOGFONTW) problem\n");

        pldc->fl |= LDC_FONT_CHANGE;

        if (!(pmecfiw = (PMREXTCREATEFONTINDIRECTW) pmdc->pvNewRecord
                            (SIZEOF_MRCREATEFONTINDIRECTEXW(iSize))))
            break;

        pmecfiw->vInit((HFONT) hobj, imhe, &elfw);

        pmecfiw->vCommit(pmdc);
        ulRet = imhe;
        break;

// Do color space.

    case LO_ICMLCS_TYPE:

        if (!MF_InternalCreateColorSpace(hdc,hobj,imhe))
        {
            break;
        }
        ulRet = imhe;
        break;

    case LO_BITMAP_TYPE:
    case LO_DIBSECTION_TYPE:
    default:

        ASSERTGDI(FALSE, "MF_InternalCreateObject: Bad object type\n");
        break;
    }

// Check for error.

    if (ulRet == 0)
    {
        ERROR_ASSERT(FALSE,
            "MF_InternalCreateObject: unable to record the object");
        vFreeMHE(hdc, imhe);
        return(ulRet);
    }

    ASSERTGDI(ulRet == imhe, "MF_InternalCreateObject: Bad return value");

// Update number of handles in the metafile header record.

    pmdc->vUpdateNHandles(imhe);

// Return the metafile handle index of the object.

    return(imhe);
}

// DeleteObject

extern "C" BOOL MF_DeleteObject(HANDLE h)
{
// We don't get called if it is a stock object.

    HDC      hdc;
    METALINK metalink;

    PUTS("MF_DeleteObject\n");

    ASSERTGDI(pmetalink16Get(h) != NULL,
        "MF_DeleteObject: No object to delete");

// Delete the object from each metafile DC which references it.

    while (TRUE)
    {
        metalink.vInit(pmetalink16Get(h));
        if (!metalink.bValid())
            break;

        hdc = hdcFromIhdc(metalink.ihdc);

    #if DBG
        ASSERTGDI(GET_PMDC(hdc)->pmhe[metalink.imhe].lhObject == h,
          "MF_DeleteObject: Bad metalink");
        ASSERTGDI(metalink.imhe != 0,           // Index zero is reserved.
          "MF_DeleteObject: Bad metalink");
    #endif

    // Send a delete object record.

        (VOID) MF_SetD(hdc, (DWORD) metalink.imhe, EMR_DELETEOBJECT);
        vFreeMHE(hdc, (ULONG) metalink.imhe);
    }
    return(TRUE);
}

// SetPaletteEntries

extern "C" BOOL MF_SetPaletteEntries
(
    HPALETTE        hpal,
    UINT            iStart,
    UINT            cEntries,
    CONST PALETTEENTRY  *pPalEntries
)
{
// We don't get called if it is a stock object.

    PUTS("MF_SetPaletteEntries\n");

// Create a record in each metafile DC which references it.
// Note that if an object has been previously selected in a metafile DC
// and currently deselected, it is still referenced by the metafile DC.

    for
    (
        METALINK metalink(pmetalink16Get(hpal));
        metalink.bValid();
        metalink.vNext()
    )
    {
        // Get a metafile DC.

        PMDC pmdc = GET_PMDC(hdcFromIhdc(metalink.ihdc));
        PMRSETPALETTEENTRIES pmrspe;

        ASSERTGDI(pmdc->pmhe[metalink.imhe].lhObject == hpal,
          "MF_SetPaletteEntries: Bad metalink");
        ASSERTGDI(metalink.imhe != 0,           // Index zero is reserved.
          "MF_SetPaletteEntries: Bad metalink");

        // Send a SetPaletteEntries record.

        if (!(pmrspe = (PMRSETPALETTEENTRIES) pmdc->pvNewRecord
                            (SIZEOF_MRSETPALETTEENTRIES(cEntries))))
            return(FALSE);

        // Also clear peFlags.

        pmrspe->vInit(metalink.imhe, iStart, cEntries, pPalEntries);

        // Also update the metafile palette.

        if (!pmrspe->bCommit(pmdc))
            return(FALSE);
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* MF_ColorCorrectPalette
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    9/23/1996 Mark Enstrom [marke]
*
\**************************************************************************/

extern "C"
BOOL
MF_ColorCorrectPalette(
    HDC      hdc,
    HPALETTE hpal,
    ULONG    FirstEntry,
    ULONG    NumberOfEntries)
{
    PMRDDDD pmrdddd;
    DWORD   imhePal;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_SetDDDD : ColorCorrectPalette\n");

    //
    // get palette
    //

    if (!(imhePal = MF_InternalCreateObject(hdc, hpal)))
    {
        return(FALSE);
    }

    if (!(pmrdddd = (PMRDDDD) pmdc->pvNewRecord(SIZEOF_MRDDDD)))
    {
        return(FALSE);
    }

    pmrdddd->vInit(EMR_COLORCORRECTPALETTE,imhePal,FirstEntry,NumberOfEntries,0);
    pmrdddd->vCommit(pmdc);
    return(TRUE);
}

// ResizePalette

extern "C" BOOL MF_ResizePalette(HPALETTE hpal,UINT c)
{
// We don't get called if it is a stock object.

    PUTS("MF_ResizePalette\n");

// Create a record in each metafile DC which references it.
// Note that if an object has been previously selected in a metafile DC
// and currently deselected, it is still referenced by the metafile DC.

    for
    (
        METALINK metalink(pmetalink16Get(hpal));
        metalink.bValid();
        metalink.vNext()
    )
    {
        HDC hdc = hdcFromIhdc(metalink.ihdc);

        ASSERTGDI(GET_PMDC(hdc)->pmhe[metalink.imhe].lhObject == hpal,
          "MF_ResizePalette: Bad metalink");
        ASSERTGDI(metalink.imhe != 0,           // Index zero is reserved.
          "MF_ResizePalette: Bad metalink");

        // Send a ResizePalette record.

        if
        (
            !MF_SetDD
            (
                hdc,
                (DWORD)metalink.imhe,
                (DWORD)c,
                EMR_RESIZEPALETTE
            )
        )
            return(FALSE);
    }
    return(TRUE);
}

// RealizePalette
//
// This function takes a hpal, not a hdc!  We want to metafile RealizePalette
// calls in other DC which affect the metafile DCs as well.  For example,
// if a palette is selected into a display DC and a metafile DC, a
// RealizePalette on the display DC will cause a record to be generated in
// the metafile DC.  The reason is applications may expect this behavior
// in Windows although we do not completely agree with this.  In any case,
// we do the right thing when they realize a palette on metafile DCs.
//
// Note that no record is generated if the stock palette is realized.  This
// is compatible with the current design for palette management in metafiles.

extern "C" BOOL MF_RealizePalette(HPALETTE hpal)
{
// We don't get called if it is a stock object.

    PUTS("MF_RealizePalette\n");

// Create a record in each metafile DC which selects it (NOT references it!).
// Note that if an object has been previously selected in a metafile DC
// and currently deselected, it is still referenced by the metafile DC.

    for
    (
        METALINK metalink(pmetalink16Get(hpal));
        metalink.bValid();
        metalink.vNext()
    )
    {
        HDC hdc = hdcFromIhdc(metalink.ihdc);

        ASSERTGDI(GET_PMDC(hdc)->pmhe[metalink.imhe].lhObject == hpal,
          "MF_RealizePalette: Bad metalink");
        ASSERTGDI(metalink.imhe != 0,           // Index zero is reserved.
          "MF_RealizePalette: Bad metalink");

        // Send a RealizePalette record.

        if (GetDCObject(hdc,LO_PALETTE_TYPE) == hpal)
            if (!MF_Record(hdc,EMR_REALIZEPALETTE))
                return(FALSE);
    }
    return(TRUE);
}

// EOF - emit an EOF metafile record.
// This function is called by CloseEnhMetaFile to emit the last metafile record.
// The EOF record includes the metafile palette if any logical palette is
// used in the metafile.

extern "C" BOOL MF_EOF(HDC hdc, ULONG cEntries, PPALETTEENTRY pPalEntries)
{
    PMREOF pmreof;
    DWORD  cbEOF;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_EOF\n");

    cbEOF = SIZEOF_MREOF(cEntries);

    if (!(pmreof = (PMREOF) pmdc->pvNewRecord(cbEOF)))
        return(FALSE);

    pmreof->vInit(cEntries, pPalEntries, cbEOF);
    pmreof->vCommit(pmdc);
    return(TRUE);
}

// GdiComment - emit a metafile comment record.

extern "C" BOOL MF_GdiComment(HDC hdc, UINT nSize, CONST BYTE *lpData)
{
    PMRGDICOMMENT  pmrc;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_GdiComment\n");

// Ignore GDICOMMENT_WINDOWS_METAFILE and other non-embeddable public comments.
// These comments are now extra baggage.

    if (nSize >= 2 * sizeof(DWORD)
     && ((PDWORD) lpData)[0] == GDICOMMENT_IDENTIFIER
     && ((PDWORD) lpData)[1] & GDICOMMENT_NOEMBED)
        return(TRUE);

    if (!(pmrc = (PMRGDICOMMENT) pmdc->pvNewRecord(SIZEOF_MRGDICOMMENT(nSize))))
        return(FALSE);

// If it is a GDICOMMENT_MULTIFORMATS or other public comments containing
// logical bounds, we need to accumulate the bounds.
// We assume that applications set up metafile palette properly before
// embedding so we do not have to accumulate the metafile palette here.
// We do the bounds after pvNewRecord so that the previous bounds is
// accounted for properly.

    if (nSize >= 2 * sizeof(DWORD)
     && ((PDWORD) lpData)[0] == GDICOMMENT_IDENTIFIER
     && ((PDWORD) lpData)[1] & GDICOMMENT_ACCUMBOUNDS)
    {
        POINT  aptBounds[4];
        RECT   rcBounds;

// The logical output rectangle follows the ident and iComment fields.

        CONST RECTL *prclOutput = (PRECTL) &lpData[2 * sizeof(DWORD)];

        aptBounds[0].x = prclOutput->left;
        aptBounds[0].y = prclOutput->top;
        aptBounds[1].x = prclOutput->right;
        aptBounds[1].y = prclOutput->top;
        aptBounds[2].x = prclOutput->right;
        aptBounds[2].y = prclOutput->bottom;
        aptBounds[3].x = prclOutput->left;
        aptBounds[3].y = prclOutput->bottom;

        if (!LPtoDP(hdc, aptBounds, 4))
            return(FALSE);

        rcBounds.left   = MIN4(aptBounds[0].x,aptBounds[1].x,aptBounds[2].x,aptBounds[3].x);
        rcBounds.right  = MAX4(aptBounds[0].x,aptBounds[1].x,aptBounds[2].x,aptBounds[3].x);
        rcBounds.top    = MIN4(aptBounds[0].y,aptBounds[1].y,aptBounds[2].y,aptBounds[3].y);
        rcBounds.bottom = MAX4(aptBounds[0].y,aptBounds[1].y,aptBounds[2].y,aptBounds[3].y);

        (void) SetBoundsRectAlt(hdc, &rcBounds, (UINT) (DCB_WINDOWMGR | DCB_ACCUMULATE));
    }

    pmrc->vInit(nSize, lpData);
    pmrc->vCommit(pmdc);
    return(TRUE);
}

//
// Emit a EMF comment record which contains embedded font information
//

BOOL
WriteFontDataAsEMFComment(
    PLDC    pldc,
    DWORD   ulID,
    PVOID   buf1,
    DWORD   size1,
    PVOID   buf2,
    DWORD   size2
    )

{
    static struct {
        DWORD   reserved;
        DWORD   signature;
    } FontCommentHeader = { 0, 'TONF' };

    EMFITEMHEADER emfi = { ulID, size1+size2 };

    COMMENTDATABUF databuf[4] = {
        { sizeof(FontCommentHeader), &FontCommentHeader },
        { sizeof(emfi), &emfi },
        { size1, buf1 },
        { size2, buf2 }
    };

    PMRGDICOMMENT pmrc;
    UINT n;
    PMDC pmdc = (PMDC) pldc->pvPMDC;
    BOOL result;

    if (!pmdc || !pmdc->bIsEMFSpool())
    {
        ASSERTGDI(FALSE, "WriteFontDataAsEMFComment: pmdc is NULL\n");
        return FALSE;
    }

    //
    // Record the font data as EMF comment and remember
    // its location in the EMF spool file.
    //

    n = sizeof(FontCommentHeader) + sizeof(emfi) + size1 + size2;

    if (!(pmrc = (PMRGDICOMMENT) pmdc->pvNewRecord(SIZEOF_MRGDICOMMENT(n))))
        return FALSE;

    n = SIZEOF_MRGDICOMMENT(0) + sizeof(FontCommentHeader);
    result = pmdc->SaveFontCommentOffset(ulID, n);

    pmrc->vInit(4, databuf);
    pmrc->vCommit(pmdc);
    return result;
}

// Emit a metafile comment record for embedded windows metafile.

extern "C" BOOL MF_GdiCommentWindowsMetaFile(HDC hdc, UINT nSize, CONST BYTE *lpData)
{
    PMRGDICOMMENT  pmrc;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_GdiCommentWindowsMetaFile\n");

    if (!(pmrc = (PMRGDICOMMENT) pmdc->pvNewRecord(SIZEOF_MRGDICOMMENT_WINDOWS_METAFILE(nSize))))
        return(FALSE);

    pmrc->vInitWindowsMetaFile(nSize, lpData);
    pmrc->vCommit(pmdc);
    return(TRUE);
}

// Emit a metafile comment record for begin group.  This is used to identify
// the beginning of an embedded enhanced metafile.

extern "C" BOOL MF_GdiCommentBeginGroupEMF(HDC hdc, PENHMETAHEADER pemfHeader)
{
    PMRGDICOMMENT  pmrc;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_GdiCommentBeginGroupEMF\n");

    if (!(pmrc = (PMRGDICOMMENT) pmdc->pvNewRecord(SIZEOF_MRGDICOMMENT_BEGINGROUP(pemfHeader->nDescription))))
        return(FALSE);

    pmrc->vInitBeginGroupEMF(pemfHeader);
    pmrc->vCommit(pmdc);
    return(TRUE);
}

// Emit a metafile comment record for end group.  This is used to identify
// the end of an embedded enhanced metafile.

extern "C" BOOL MF_GdiCommentEndGroupEMF(HDC hdc)
{
    DWORD  ad[2];

    PUTS("MF_GdiCommentEndGroupEMF\n");

    ad[0] = GDICOMMENT_IDENTIFIER;      // ident
    ad[1] = GDICOMMENT_ENDGROUP;        // iComment

    return(MF_GdiComment(hdc, (UINT) sizeof(ad), (LPBYTE) &ad));
}

// MF_AnyBitBlt helper.

extern "C" BOOL MF_DoBitBlt
(
    PMDC     pmdcDst,
    int      xDst,
    int      yDst,
    int      cxDst,
    int      cyDst,
    DWORD    rop,
    int      xSrc          = 0,
    int      ySrc          = 0,
    PXFORM   pxformSrc = &xformIdentity,
    COLORREF clrBkSrc      = 0,
    PBMIH    pbmihSrc      = (PBMIH) NULL,
    HBITMAP  hbmSrc        = (HBITMAP) 0,
    DWORD    cbBitsInfoSrc = 0,
    DWORD    cbBitsSrc     = 0
)
{
    PMRBB pmrbb;

    if (!(pmrbb = (PMRBB) pmdcDst->pvNewRecord
                    (SIZEOF_MRBB(cbBitsInfoSrc,cbBitsSrc))))
        return(FALSE);

    // Use compression option

    if (!pmrbb->bInit
        (
            EMR_BITBLT,
            pmdcDst,                    // pmdcDst
            xDst,                       // xDst
            yDst,                       // yDst
            cxDst,                      // cxDst
            cyDst,                      // cyDst
            rop,                        // rop
            xSrc,                       // xSrc
            ySrc,                       // ySrc
            pxformSrc,                  // source DC transform
            clrBkSrc,                   // source DC BkColor
            pbmihSrc,                   // source bitmap info header
            hbmSrc,                     // source bitmap to save
            hbmSrc ? sizeof(MRBB) : 0,  // offset to bitmap info
            cbBitsInfoSrc,              // size of bitmap info
            hbmSrc ? sizeof(MRBB) + cbBitsInfoSrc : 0,// offset to bits
            cbBitsSrc                   // size of bits buffer
        )
       )
        return(FALSE);

    pmrbb->vCommit(pmdcDst);
    return(TRUE);
}

/******************************Public*Routine******************************\
* MF_DoAlphaBlend
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

extern "C" BOOL MF_DoAlphaBlend
(
    PMDC     pmdcDst,
    int      xDst,
    int      yDst,
    int      cxDst,
    int      cyDst,
    DWORD    Blend,
    int      xSrc,
    int      ySrc,
    int      cxSrc,
    int      cySrc,
    PXFORM   pxformSrc,
    COLORREF clrBkSrc,
    PBMIH    pbmihSrc,
    HBITMAP  hbmSrc,
    DWORD    cbBitsInfoSrc,
    DWORD    cbBitsSrc
)
{
    PMRALPHABLEND pmrai;

// We always have a source bitmap here.  AlphaImage without a source is not valid

    ASSERTGDI(hbmSrc != (HBITMAP) 0, "MF_DoAlphaBlend: Bad hbmSrc");

    if (!(pmrai = (PMRALPHABLEND) pmdcDst->pvNewRecord
                    (SIZEOF_MRALPHABLEND(cbBitsInfoSrc,cbBitsSrc))))
        return(FALSE);

    // Use compression option

    if (!pmrai->bInit
        (
            pmdcDst,            // pmdcDst
            xDst,               // xDst
            yDst,               // yDst
            cxDst,              // cxDst
            cyDst,              // cyDst
            Blend,              // replaves rop
            xSrc,               // xSrc
            ySrc,               // ySrc
            cxSrc,              // cxSrc
            cySrc,              // cySrc
            pxformSrc,          // source DC transform
            clrBkSrc,           // source DC BkColor
            pbmihSrc,           // source bitmap info header
            hbmSrc,             // source bitmap to save
            sizeof(MRALPHABLEND),// offset to bitmap info
            cbBitsInfoSrc,      // size of bitmap info
            sizeof(MRALPHABLEND) + cbBitsInfoSrc,// offset to bits
            cbBitsSrc           // size of bits buffer
        )
       )
        return(FALSE);

    pmrai->vCommit(pmdcDst);
    return(TRUE);
}

/******************************Public*Routine******************************\
* MF_DoTransparentBlt
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

extern "C" BOOL MF_DoTransparentBlt
(
    PMDC     pmdcDst,
    int      xDst,
    int      yDst,
    int      cxDst,
    int      cyDst,
    DWORD    Blend,
    int      xSrc,
    int      ySrc,
    int      cxSrc,
    int      cySrc,
    PXFORM   pxformSrc,
    COLORREF clrBkSrc,
    PBMIH    pbmihSrc,
    HBITMAP  hbmSrc,
    DWORD    cbBitsInfoSrc,
    DWORD    cbBitsSrc
)
{
    PMRTRANSPARENTBLT pmrai;

// We always have a source bitmap here.  TransparentImage without a source is not valid

    ASSERTGDI(hbmSrc != (HBITMAP) 0, "MF_DoTransparentImage: Bad hbmSrc");

    if (!(pmrai = (PMRTRANSPARENTBLT) pmdcDst->pvNewRecord
                    (SIZEOF_MRTRANSPARENTBLT(cbBitsInfoSrc,cbBitsSrc))))
        return(FALSE);

    // Use compression option

    if (!pmrai->bInit
        (
            pmdcDst,            // pmdcDst
            xDst,               // xDst
            yDst,               // yDst
            cxDst,              // cxDst
            cyDst,              // cyDst
            Blend,              // color
            xSrc,               // xSrc
            ySrc,               // ySrc
            cxSrc,
            cySrc,
            pxformSrc,          // source DC transform
            clrBkSrc,           // source DC BkColor
            pbmihSrc,           // source bitmap info header
            hbmSrc,             // source bitmap to save
            sizeof(MRTRANSPARENTBLT),// offset to bitmap info
            cbBitsInfoSrc,      // size of bitmap info
            sizeof(MRTRANSPARENTBLT) + cbBitsInfoSrc,// offset to bits
            cbBitsSrc           // size of bits buffer
        )
       )
        return(FALSE);

    pmrai->vCommit(pmdcDst);
    return(TRUE);
}


// MF_AnyBitBlt helper.

extern "C" BOOL MF_DoStretchBlt
(
    PMDC     pmdcDst,
    int      xDst,
    int      yDst,
    int      cxDst,
    int      cyDst,
    DWORD    rop,
    int      xSrc,
    int      ySrc,
    int      cxSrc,
    int      cySrc,
    PXFORM   pxformSrc,
    COLORREF clrBkSrc,
    PBMIH    pbmihSrc,
    HBITMAP  hbmSrc,
    DWORD    cbBitsInfoSrc,
    DWORD    cbBitsSrc
)
{
    PMRSTRETCHBLT pmrsb;

// We always have a source bitmap here.  StretchBlt without a source is
// recorded as BitBlt.

    ASSERTGDI(hbmSrc != (HBITMAP) 0, "MF_DoStretchBlt: Bad hbmSrc");

    if (!(pmrsb = (PMRSTRETCHBLT) pmdcDst->pvNewRecord
                    (SIZEOF_MRSTRETCHBLT(cbBitsInfoSrc,cbBitsSrc))))
        return(FALSE);

    // Use compression option

    if (!pmrsb->bInit
        (
            pmdcDst,            // pmdcDst
            xDst,               // xDst
            yDst,               // yDst
            cxDst,              // cxDst
            cyDst,              // cyDst
            rop,                // rop
            xSrc,               // xSrc
            ySrc,               // ySrc
            cxSrc,              // cxSrc
            cySrc,              // cySrc
            pxformSrc,          // source DC transform
            clrBkSrc,           // source DC BkColor
            pbmihSrc,           // source bitmap info header
            hbmSrc,             // source bitmap to save
            sizeof(MRSTRETCHBLT),// offset to bitmap info
            cbBitsInfoSrc,      // size of bitmap info
            sizeof(MRSTRETCHBLT) + cbBitsInfoSrc,// offset to bits
            cbBitsSrc           // size of bits buffer
        )
       )
        return(FALSE);

    pmrsb->vCommit(pmdcDst);
    return(TRUE);
}

// MF_AnyBitBlt helper.

extern "C" BOOL MF_DoMaskBlt
(
    PMDC     pmdcDst,
    int      xDst,
    int      yDst,
    int      cxDst,
    int      cyDst,
    DWORD    rop3,
    PBMIH    pbmihMask,
    HBITMAP  hbmMask,
    DWORD    cbBitsInfoMask,
    DWORD    cbBitsMask,
    int      xMask,
    int      yMask,
    int      xSrc,
    int      ySrc,
    PXFORM   pxformSrc,
    COLORREF clrBkSrc      = 0,
    PBMIH    pbmihSrc      = (PBMIH) NULL,
    HBITMAP  hbmSrc        = (HBITMAP) 0,
    DWORD    cbBitsInfoSrc = 0,
    DWORD    cbBitsSrc     = 0
)
{
    PMRMASKBLT pmrmb;
    DWORD      offBase          = sizeof(MRMASKBLT);
    DWORD      offBitsInfoSrc   = 0;
    DWORD      offBitsSrc       = 0;
    DWORD      offBitsInfoMask  = 0;
    DWORD      offBitsMask      = 0;

    if (hbmSrc)
    {
        offBitsInfoSrc = offBase;
        offBitsSrc     = offBitsInfoSrc + cbBitsInfoSrc;
        offBase        = offBitsSrc + cbBitsSrc;
    }

    if (hbmMask)
    {
        offBitsInfoMask = offBase;
        offBitsMask     = offBitsInfoMask + cbBitsInfoMask;
    }

    // Now create the record.

    if (!(pmrmb = (PMRMASKBLT) pmdcDst->pvNewRecord
                    (SIZEOF_MRMASKBLT(cbBitsInfoSrc,cbBitsSrc,cbBitsInfoMask,cbBitsMask))))
        return(FALSE);

    // Use compression option

    if (!pmrmb->bInit
        (
            pmdcDst,                    // pmdcDst
            xDst,                       // xDst
            yDst,                       // yDst
            cxDst,                      // cxDst
            cyDst,                      // cyDst
            rop3,                       // rop3
            xSrc,                       // xSrc
            ySrc,                       // ySrc
            pxformSrc,                  // source DC transform
            clrBkSrc,                   // source DC BkColor
            pbmihSrc,                   // source bitmap info header
            hbmSrc,                     // source bitmap to save
            offBitsInfoSrc,             // offset to bitmap info
            cbBitsInfoSrc,              // size of bitmap info
            offBitsSrc,                 // offset to bits
            cbBitsSrc,                  // size of bits buffer
            xMask,                      // xMask
            yMask,                      // yMask
            pbmihMask,                  // mask bitmap info header
            hbmMask,                    // mask bitmap
            offBitsInfoMask,            // offset to mask bitmap info
            cbBitsInfoMask,             // size of mask bitmap info
            offBitsMask,                // offset to mask bits
            cbBitsMask                  // size of mask bits buffer
        )
       )
        return(FALSE);

    pmrmb->vCommit(pmdcDst);
    return(TRUE);
}

// MF_AnyBitBlt helper.

extern "C" BOOL MF_DoPlgBlt
(
    PMDC     pmdcDst,
    CONST POINT *pptDst,
    PBMIH    pbmihMask,
    HBITMAP  hbmMask,
    DWORD    cbBitsInfoMask,
    DWORD    cbBitsMask,
    int      xMask,
    int      yMask,
    int      xSrc,
    int      ySrc,
    int      cxSrc,
    int      cySrc,
    PXFORM   pxformSrc,
    COLORREF clrBkSrc,
    PBMIH    pbmihSrc,
    HBITMAP  hbmSrc,
    DWORD    cbBitsInfoSrc,
    DWORD    cbBitsSrc
)
{
    PMRPLGBLT  pmrpb;

// We always have a source bitmap here.  Destination to destination PlgBlt
// is not allowed.

    ASSERTGDI(hbmSrc != (HBITMAP) 0, "MF_DoPlgBlt: Bad hbmSrc");

    // Now create the record.

    if (!(pmrpb = (PMRPLGBLT) pmdcDst->pvNewRecord
                    (SIZEOF_MRPLGBLT(cbBitsInfoSrc,cbBitsSrc,cbBitsInfoMask,cbBitsMask))))
        return(FALSE);

    // Use compression option

    if (!pmrpb->bInit
        (
            pmdcDst,                    // pmdcDst
            pptDst,                     // pptDst
            xSrc,                       // xSrc
            ySrc,                       // ySrc
            cxSrc,                      // cxSrc
            cySrc,                      // cySrc
            pxformSrc,                  // source DC transform
            clrBkSrc,                   // source DC BkColor
            pbmihSrc,                   // source bitmap info header
            hbmSrc,                     // source bitmap to save
            sizeof(MRPLGBLT),           // offset to bitmap info
            cbBitsInfoSrc,              // size of bitmap info
            sizeof(MRPLGBLT) + cbBitsInfoSrc,// offset to bits
            cbBitsSrc,                  // size of bits buffer
            xMask,                      // xMask
            yMask,                      // yMask
            pbmihMask,                  // mask bitmap info header
            hbmMask,                    // mask bitmap
            hbmMask                     // offset to mask bitmap info
                ? sizeof(MRPLGBLT) + cbBitsInfoSrc + cbBitsSrc
                : 0,
            cbBitsInfoMask,             // size of mask bitmap info
            hbmMask                     // offset to mask bits
                ? sizeof(MRPLGBLT) + cbBitsInfoSrc + cbBitsSrc + cbBitsInfoMask
                : 0,
            cbBitsMask                  // size of mask bits buffer
        )
       )
        return(FALSE);

    pmrpb->vCommit(pmdcDst);
    return(TRUE);
}

// bMetaGetDIBInfo
//
// Gets the bitmap info header and sizes.
//
// If hbm or hbmRemote is given, it queries the bitmap info header and
// fills in the BITMAPINFOHERADER structure at pBmih.  A hdc is required
// if iUsage is DIB_PAL_COLORS.
//
// If no hbm or hbmRemote is given, it assumes that it is called by
// SetDIBitsToDevice or StretchDIBits and pBmih already points to a
// bitmap info header (BITMAPINFOHEADER) or core header (BITMAPCOREHEADER).
//
// In any case, the size for bitmap info (BITMAPINFO) with color table
// and the size for the bitmap bits is returned in pcbBmi and pcbBits
// respectively.  We do not store BITMAPCOREINFO structure in the metafiles.
//
// If cScans is non zero, only the size for the bitmap bits of this many
// scans is given.  The callers in this case are SetDIBitsToDevice or
// StretchDIBits.
//
// This function is called in many places and any modifications have to
// be verified carefully!  It should be kept current with the
// cjBitmapSize and cjBitmapBitsSize functions.
//
// Returns TRUE if successful, FALSE otherwise.

BOOL bMetaGetDIBInfo
(
    HDC     hdc,
    HBITMAP hbm,
    PBMIH   pBmih,
    PDWORD  pcbBmi,
    PDWORD  pcbBits,
    DWORD   iUsage,
    LONG    cScans,
    BOOL    bMeta16
)
{
    DWORD   cjClr;
    DWORD   cbBmi;
    DWORD   cbBits;

    PUTS("bMetaGetDIBInfo\n");

    if (pBmih == NULL)
        return(FALSE);

// If hbm is given, we need to get the bitmap info header.
// Otherwise, pBmih already has the bitmap info header.

    if (hbm)
    {
        pBmih->biSize = sizeof(BMIH);
        pBmih->biBitCount = 0;          // don't fill in color table
        pBmih->biCompression = BI_RGB;
        if (!GetDIBits(hdc, hbm, 0, 0, (LPBYTE) NULL,
                   (LPBITMAPINFO) pBmih, (UINT) iUsage))
        {
            ASSERTGDI(FALSE, "bMetaGetDIBInfo: InternalGetDIBits failed");
            return(FALSE);
        }

// Windows always zeros the clrUsed and clrImportant fields.
// 16-bit metafiles also do not support 16/32bpp bitmaps.

        if (bMeta16)
        {
            pBmih->biClrUsed      = 0;
            pBmih->biClrImportant = 0;
            if (pBmih->biPlanes != 1
             || pBmih->biBitCount == 16 || pBmih->biBitCount == 32)
            {
                pBmih->biPlanes      = 1;
                pBmih->biBitCount    = 24;
                pBmih->biCompression = BI_RGB;
                pBmih->biSizeImage   = 0;
                iUsage = DIB_RGB_COLORS;
            }

        }
    }

// Compute size of a color entry.

    switch (iUsage)
    {
    case DIB_RGB_COLORS:
        cjClr = sizeof(RGBQUAD);
        break;
    case DIB_PAL_COLORS:
        cjClr = sizeof(WORD);
        ASSERTGDI(sizeof(WORD) == 2, "bMetaGetDIBInfo: Bad size");
        break;
    case DIB_PAL_INDICES:
        cjClr = 0;
        break;
    default:
        ASSERTGDI(FALSE, "bMetaGetDIBInfo: Bad iUsage");
        return(FALSE);
    }

// Compute size of the bitmap info (with color table) and bitmap bits buffer.
// We will store only BITMAPINFO in the record only.  The BITMAPCOREINFO
// structure will be stored as BITMAPINFO in the metafile.

    if (pBmih->biSize > sizeof(BMIH))
    {
        cbBmi = pBmih->biSize;
    }
    else
    {
        cbBmi = sizeof(BMIH);
    }

    if (pBmih->biSize == sizeof(BMCH))
    {
        if (((LPBMCH) pBmih)->bcBitCount == 16 || ((LPBMCH) pBmih)->bcBitCount == 32)
        {
            ASSERTGDI(FALSE, "bMetaGetDIBInfo: 16/32bpp bitmap not allowed in core bitmap info");
            return(FALSE);
        }

        if (((LPBMCH) pBmih)->bcBitCount < 16)
            cbBmi += (1 << ((LPBMCH) pBmih)->bcBitCount) * cjClr;

        cbBits = CJSCAN(((LPBMCH) pBmih)->bcWidth,
                        ((LPBMCH) pBmih)->bcPlanes,
                        ((LPBMCH) pBmih)->bcBitCount)
               * (cScans ? cScans : (DWORD) ((LPBMCH) pBmih)->bcHeight);
    }
    else
    {
        if (pBmih->biBitCount == 16 || pBmih->biBitCount == 32)
        {
            if (pBmih->biCompression == BI_BITFIELDS)
                cbBmi += 3 * sizeof(DWORD);
        }
        else if (pBmih->biBitCount == 24)
        {
            // BI_BITFIELDS not allowed
        }
        else if ((pBmih->biCompression == BI_JPEG) ||
                 (pBmih->biCompression == BI_PNG))
        {
            // No color table for JPEG and PNG images
        }
        else if (pBmih->biClrUsed)
            cbBmi += pBmih->biClrUsed * cjClr;
        else if (pBmih->biBitCount < 16)
            cbBmi += (1 << pBmih->biBitCount) * cjClr;

    // compute cbBits.  We first do the computation and then use biSizeImage
    // if it is smaller than cbBits.

        cbBits = CJSCAN(pBmih->biWidth, pBmih->biPlanes, pBmih->biBitCount)
                 * (cScans ? cScans : ABS(pBmih->biHeight));

        if (((pBmih->biSizeImage > 0) &&
             (pBmih->biSizeImage < cbBits ||
              pBmih->biCompression == BI_RLE8 ||
              pBmih->biCompression == BI_RLE4))  ||
            (pBmih->biCompression == BI_PNG) ||
            (pBmih->biCompression == BI_JPEG))
            cbBits = pBmih->biSizeImage;
    }

    *pcbBmi  = cbBmi;
    *pcbBits = cbBits;
    return(TRUE);
}

// BitBlt
// PatBlt
// StretchBlt
// MaskBlt
// PlgBlt

extern "C" BOOL MF_AnyBitBlt
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    CONST POINT *pptDst,
    HDC     hdcSrc,
    int     xSrc,
    int     ySrc,
    int     cxSrc,
    int     cySrc,
    HBITMAP hbmMask,
    int     xMask,
    int     yMask,
    DWORD   rop,                        // For MaskBlt, this is rop3!
                                        // For PlgBlt, this must be 0xCCAA0000!
    DWORD   mrType
)
{
    DWORD   cbBitsInfoMask = 0;
    DWORD   cbBitsMask     = 0;
    BMIH    bmihMask;
    PBMIH   pbmihMask      = (PBMIH) NULL;
    XFORM   xformSrc;

    PLDC pldc;
    DC_PLDC(hdcDst,pldc,FALSE);

    PMDC pmdcDst = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdcDst,"no pmdc\n");

    PUTS("MF_AnyBitBlt\n");

    ASSERTGDI(mrType == EMR_BITBLT
           || mrType == EMR_STRETCHBLT
           || mrType == EMR_MASKBLT
           || mrType == EMR_PLGBLT
           || mrType == EMR_ALPHABLEND
           || mrType == EMR_TRANSPARENTBLT,
        "MF_AnyBitBlt: Bad mrType");

// Do mask first.

    if (hbmMask)
    {
        // Get the mask's bitmap info header and sizes.

        pbmihMask = &bmihMask;
        if (!bMetaGetDIBInfo(hdcDst, hbmMask, &bmihMask,
                &cbBitsInfoMask, &cbBitsMask, DIB_PAL_INDICES, 0, FALSE))
            return(FALSE);

        // Make sure that it is monochrome.

        if (bmihMask.biPlanes != 1 && bmihMask.biBitCount != 1)
            return(FALSE);
    }

// These two checks are needed to make sure that the following rop test works.

    if ((mrType == EMR_BITBLT || mrType == EMR_STRETCHBLT)
     && (rop & (0xff000000 & ~NOMIRRORBITMAP)) != 0)
    {
        WARNING("MF_AnyBitBlt: Bad BitBlt/StretchBlt rop");
        return(FALSE);
    }

    ASSERTGDI(mrType != EMR_PLGBLT || rop == 0xCCAA0000,
        "MF_AnyBitBlt: Bad PlgBlt rop");

// Get the source transform if a source is required by the rop.
// For MaskBlt, we always need the source transform.

    if (
         ISSOURCEINROP3(rop)                ||
         (mrType == EMR_MASKBLT)            ||
         (mrType == EMR_ALPHABLEND)         ||
         (mrType == EMR_TRANSPARENTBLT)
       )
    {
    // Get source transform.

        if (!GetTransform(hdcSrc, XFORM_WORLD_TO_DEVICE, &xformSrc))
            return(FALSE);

    // Make sure that it is a scale.

        if (xformSrc.eM12 != 0.0f || xformSrc.eM21 != 0.0f)
            return(FALSE);

    // Set color page flag
        SET_COLOR_PAGE(pldc);
    }

// Do blts with a source.  The source must allow bit query operation.

    if (
         ISSOURCEINROP3(rop) ||
         (mrType == EMR_TRANSPARENTBLT) ||
         (mrType == EMR_ALPHABLEND)
       )
    {
        COLORREF clrBkSrc;
        BOOL     bRet = FALSE;          // assume failure

    // We need to record the source bitmap.  The source DC must be a memory
    // DC or a direct DC that allows bits to be retrieved.  As a result, the
    // source DC cannot be an enhanced metafile DC.  That is, destination
    // to destination blts are not allowed in an enhanced metafile!

        if (IS_ALTDC_TYPE(hdcSrc))
        {
            PLDC pldcSrc;
            DC_PLDC(hdcSrc,pldcSrc,FALSE);

            if (pldcSrc->iType == LO_METADC)
                return(FALSE);
        }

    // Get source bk color.

        if ((clrBkSrc = GetNearestColor(hdcSrc, GetBkColor(hdcSrc)))
            == CLR_INVALID)
        {
            return(FALSE);
        }

    // Compute the area of the source bitmap to save in the metafile.
    // First we find the coordinates of the source rectange in the
    // device/bitmap units.  Then we expand the rectangle by one pixel
    // unit to account for possible rounding errors.  Finally we map
    // the rectangle to the playback bitmap origin by modifying the
    // translation elements in the source transform.
    // Verify pdev

        LONG    lWidthSrc, lHeightSrc;
        RECTL   rclSrc;
        RECTL   rclBitmap;
        DWORD   cbBitsInfoCompat;
        DWORD   cbBitsCompat;
        HBITMAP hbmTmp     = 0;
        HBITMAP hbmCompat  = 0;
        HDC     hdcCompat  = 0;
        int     iSaveState = 0;
        BMIH    bmihCompat;

        // Get source rectangle in device/bitmap coordinates.  Since the
        // source transform is a scale, we can simply convert the endpoints
        // of the source rectangle.

        ASSERTGDI((mrType != EMR_BITBLT && mrType != EMR_MASKBLT)
               || (cxDst == cxSrc && cyDst == cySrc),
            "MF_AnyBitBlt: Bad width and height in BitBlt/MaskBlt");
        ASSERTGDI(sizeof(RECTL) == sizeof(POINT)*2, "MF_AnyBitBlt: Bad size");

        ((PERECTL) &rclSrc)->vInit(xSrc, ySrc, xSrc + cxSrc, ySrc + cySrc);
        if (!LPtoDP(hdcSrc, (LPPOINT) &rclSrc, 2))
            return(FALSE);

        // Order the result.  We assume it to be inclusive-inclusive.

        ((PERECTL) &rclSrc)->vOrder();

        // Expand it by one pixel.

        rclSrc.left--;
        rclSrc.top--;
        rclSrc.right++;
        rclSrc.bottom++;

        // Map it to the playback bitmap origin.

        xformSrc.eDx -= (FLOAT) rclSrc.left;
        xformSrc.eDy -= (FLOAT) rclSrc.top;

        // We now have the rectangle which defines the size of the playback
        // bitmap.  But we still need to clip it to the source device/bitmap
        // limits.  This is done by reducing the size of the rectangle and
        // translating its origin.

        ((PERECTL) &rclBitmap)->vInit
            (0, 0, rclSrc.right - rclSrc.left, rclSrc.bottom - rclSrc.top);

        // Get source width and height
        // WINBUG #82866 2-7-2000 bhouse Investigate possible bug in MfAnyBitBlt
        // Old Comment:
        //   - if it is a direct DC, we really want to fall through to the
        //     second case.  Will either the GetDCObject or GetObject fail?

        HBITMAP hbm = (HBITMAP)GetDCObject(hdcSrc, LO_BITMAP_TYPE);
        BITMAP bmSrc;

        if (hbm && GetObjectA((HANDLE)hbm,sizeof(BITMAP),(LPVOID) &bmSrc))
        {
            lWidthSrc  = bmSrc.bmWidth;
            lHeightSrc = bmSrc.bmHeight;
        }
        else
        {
            lWidthSrc  = GetDeviceCaps(hdcDst, DESKTOPHORZRES);
            lHeightSrc = GetDeviceCaps(hdcDst, DESKTOPVERTRES);
        }

        // Clip the source rectangle to the source device/bitmap limits.
        // Adjust the playback bitmap size and source transform at the
        // same time.

        if (rclSrc.left < 0)                // Shift and clip the left edge.
        {
            rclBitmap.right += rclSrc.left;
            xformSrc.eDx    += (FLOAT) rclSrc.left;
            rclSrc.left      = 0;
        }
        if (rclSrc.right >= lWidthSrc)      // Clip the right edge.
        {
            rclBitmap.right -= (rclSrc.right - lWidthSrc + 1);
            rclSrc.right    -= (rclSrc.right - lWidthSrc + 1);
        }
        if (rclSrc.top < 0)                 // Shift and clip the top edge.
        {
            rclBitmap.bottom += rclSrc.top;
            xformSrc.eDy     += (FLOAT) rclSrc.top;
            rclSrc.top        = 0;
        }
        if (rclSrc.bottom >= lHeightSrc)   // Clip the bottom edge.
        {
            rclBitmap.bottom -= (rclSrc.bottom - lHeightSrc + 1);
            rclSrc.bottom    -= (rclSrc.bottom - lHeightSrc + 1);
        }

        // If the rectangle is completely clipped, there is no playback
        // bitmap and nothing to blt.

        if (rclBitmap.right < 0 || rclBitmap.bottom < 0)
            return(TRUE);

    // We now have the size of the playback bitmap.  We will create a bitmap
    // compatible to the source, copy the bits to the compatible bitmap
    // and finally retrieve and store the bits in the metafile record.

        // Create a compatible DC.

        if (!(hdcCompat = CreateCompatibleDC(hdcSrc)))
            goto mfbb_src_exit;

        // Create a compatible bitmap.

        if (!(hbmCompat = CreateCompatibleBitmap
                            (
                                hdcSrc,
                                (int) rclBitmap.right  + 1,
                                (int) rclBitmap.bottom + 1
                            )
              )
            )
            goto mfbb_src_exit;

        // Select the bitmap.

        if (!(hbmTmp = (HBITMAP)SelectObject(hdcCompat, (HANDLE)hbmCompat)))
            goto mfbb_src_exit;

        // Set up the source DC to have the same identity transform as the
        // compatible DC so that the following bitblt call will not scale.

        if (!(iSaveState = SaveDC(hdcSrc)))
            goto mfbb_src_exit;

        // Must be in the advanced graphics mode to modify the world transform.

        SetGraphicsMode(hdcSrc, GM_ADVANCED);

        if (!SetMapMode(hdcSrc, MM_TEXT)
         || !ModifyWorldTransform(hdcSrc, (LPXFORM) NULL, MWT_IDENTITY)
         || !SetWindowOrgEx(hdcSrc, 0, 0, (LPPOINT) NULL)
         || !SetViewportOrgEx(hdcSrc, 0, 0, (LPPOINT) NULL))
            goto mfbb_src_exit;

        // Copy the source bits into the compatible bitmap.

        if (!BitBlt(hdcCompat,                  // Dest dc
                    0,                          // Dest x
                    0,                          // Dest y
                    (int) rclBitmap.right  + 1, // Width
                    (int) rclBitmap.bottom + 1, // Height
                    hdcSrc,                     // Src dc
                    (int) rclSrc.left,          // Src x
                    (int) rclSrc.top,           // Src y
                    SRCCOPY))                   // Rop
            goto mfbb_src_exit;

        // Retrieve the bitmap info header.

        SelectObject(hdcCompat, hbmTmp);
        hbmTmp = 0;                     // don't deselect it again later.

        // Get the bitmap info header and sizes.

        if (!bMetaGetDIBInfo(hdcCompat, hbmCompat, &bmihCompat,
                &cbBitsInfoCompat, &cbBitsCompat, DIB_RGB_COLORS, 0, FALSE))
            goto mfbb_src_exit;

        // Finally create the record and get the bits.

        pmdcDst->hdcSrc = hdcSrc;

        switch (mrType)
        {
        case EMR_BITBLT:
            bRet = MF_DoBitBlt
                    (
                        pmdcDst,                // pmdcDst
                        xDst,                   // xDst
                        yDst,                   // yDst
                        cxDst,                  // cxDst
                        cyDst,                  // cyDst
                        rop,                    // rop
                        xSrc,                   // xSrc
                        ySrc,                   // ySrc
                        &xformSrc,              // source DC transform
                        clrBkSrc,               // source DC BkColor
                        &bmihCompat,            // source bitmap info header
                        hbmCompat,              // source bitmap to save
                        cbBitsInfoCompat,       // size of bitmap info
                        cbBitsCompat            // size of bits buffer
                    );
            break;

        case EMR_STRETCHBLT:
            bRet = MF_DoStretchBlt
                    (
                        pmdcDst,                // pmdcDst
                        xDst,                   // xDst
                        yDst,                   // yDst
                        cxDst,                  // cxDst
                        cyDst,                  // cyDst
                        rop,                    // rop
                        xSrc,                   // xSrc
                        ySrc,                   // ySrc
                        cxSrc,                  // cxSrc
                        cySrc,                  // cySrc
                        &xformSrc,              // source DC transform
                        clrBkSrc,               // source DC BkColor
                        &bmihCompat,            // source bitmap info header
                        hbmCompat,              // source bitmap to save
                        cbBitsInfoCompat,       // size of bitmap info
                        cbBitsCompat            // size of bits buffer
                    );
            break;

        case EMR_MASKBLT:
            bRet = MF_DoMaskBlt
                    (
                        pmdcDst,                // pmdcDst
                        xDst,                   // xDst
                        yDst,                   // yDst
                        cxDst,                  // cxDst
                        cyDst,                  // cyDst
                        rop,                    // rop
                        pbmihMask,              // mask bitmap info header
                        hbmMask,                // hbmMask
                        cbBitsInfoMask,         // size of mask bitmap info
                        cbBitsMask,             // size of mask bits buffer
                        xMask,                  // xMask
                        yMask,                  // yMask
                        xSrc,                   // xSrc
                        ySrc,                   // ySrc
                        &xformSrc,              // source DC transform
                        clrBkSrc,               // source DC BkColor
                        &bmihCompat,            // source bitmap info header
                        hbmCompat,              // source bitmap to save
                        cbBitsInfoCompat,       // size of bitmap info
                        cbBitsCompat            // size of bits buffer
                    );
            break;

        case EMR_PLGBLT:
            bRet = MF_DoPlgBlt
                    (
                        pmdcDst,                // pmdcDst
                        pptDst,                 // pptDst
                        pbmihMask,              // mask bitmap info header
                        hbmMask,                // hbmMask
                        cbBitsInfoMask,         // size of mask bitmap info
                        cbBitsMask,             // size of mask bits buffer
                        xMask,                  // xMask
                        yMask,                  // yMask
                        xSrc,                   // xSrc
                        ySrc,                   // ySrc
                        cxSrc,                  // cxSrc
                        cySrc,                  // cySrc
                        &xformSrc,              // source DC transform
                        clrBkSrc,               // source DC BkColor
                        &bmihCompat,            // source bitmap info header
                        hbmCompat,              // source bitmap to save
                        cbBitsInfoCompat,       // size of bitmap info
                        cbBitsCompat            // size of bits buffer
                    );
            break;
        case EMR_ALPHABLEND:
            bRet = MF_DoAlphaBlend(
                                   pmdcDst,                // pmdcDst
                                   xDst,                   // xDst
                                   yDst,                   // yDst
                                   cxDst,                  // cxDst
                                   cyDst,                  // cyDst
                                   rop,                    // rop
                                   xSrc,                   // xSrc
                                   ySrc,                   // ySrc
                                   cxSrc,                  // cxSrc
                                   cySrc,                  // cySrc
                                   &xformSrc,              // source DC transform
                                   clrBkSrc,               // source DC BkColor
                                   &bmihCompat,            // source bitmap info header
                                   hbmCompat,              // source bitmap to save
                                   cbBitsInfoCompat,       // size of bitmap info
                                   cbBitsCompat            // size of bits buffer
                       );
            break;
        case EMR_TRANSPARENTBLT:
            bRet = MF_DoTransparentBlt(
                                         pmdcDst,                // pmdcDst
                                         xDst,                   // xDst
                                         yDst,                   // yDst
                                         cxDst,                  // cxDst
                                         cyDst,                  // cyDst
                                         rop,                    // rop
                                         xSrc,                   // xSrc
                                         ySrc,                   // ySrc
                                         cxSrc,
                                         cySrc,
                                         &xformSrc,              // source DC transform
                                         clrBkSrc,               // source DC BkColor
                                         &bmihCompat,            // source bitmap info header
                                         hbmCompat,              // source bitmap to save
                                         cbBitsInfoCompat,       // size of bitmap info
                                         cbBitsCompat            // size of bits buffer
                       );
            break;
        }

    mfbb_src_exit:

        // Clean up and go home.

        if (iSaveState)
        {
            if (!RestoreDC(hdcSrc, -1))
            {
                ASSERTGDI(FALSE, "MF_AnyBitBlt: RestoreDC failed");
            }
        }

        if (hbmTmp)
        {
            if (!SelectObject(hdcCompat, hbmTmp))
            {
                ASSERTGDI(FALSE, "MF_AnyBitBlt: SelectObject failed");
            }
        }

        if (hbmCompat)
        {
            if (!DeleteObject(hbmCompat))
            {
                ASSERTGDI(FALSE, "MF_AnyBitBlt: DeleteObject failed");
            }
        }

        if (hdcCompat)
        {
            if (!DeleteDC(hdcCompat))
            {
                ASSERTGDI(FALSE, "MF_AnyBitBlt: DeleteDC failed");
            }
        }

        return(bRet);
    }

// It requires no source DC.

    switch (mrType)
    {
// StretchBlt is just a BitBlt here.

    case EMR_BITBLT:
    case EMR_STRETCHBLT:
        return
        (
            MF_DoBitBlt
            (
                pmdcDst,
                xDst,
                yDst,
                cxDst,
                cyDst,
                rop
            )
        );

    case EMR_MASKBLT:

        return
        (
            MF_DoMaskBlt
            (
                pmdcDst,
                xDst,
                yDst,
                cxDst,
                cyDst,
                rop,
                pbmihMask,
                hbmMask,
                cbBitsInfoMask,
                cbBitsMask,
                xMask,
                yMask,
                xSrc,
                ySrc,
                &xformSrc
            )
        );

// PlgBlt requires a source.

    case EMR_PLGBLT:
        ASSERTGDI(FALSE, "MF_AnyBitBlt: Source needed in PlgBlt");
        return(FALSE);
    }
    return FALSE;
}

// SetDIBitsToDevice (for both 16- and 32-bit metafiles)
// StretchDIBits (for both 16- and 32-bit metafiles)

extern "C" BOOL MF_AnyDIBits
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    int     xDib,
    int     yDib,
    int     cxDib,
    int     cyDib,
    DWORD   iStartScan,
    DWORD   cScans,
    CONST VOID * pBitsDib,
    CONST BITMAPINFO *pBitsInfoDib,
    DWORD   iUsageDib,
    DWORD   rop,
    DWORD   mrType
)
{
    DWORD       cbBitsInfoDib = 0;
    DWORD       cbBitsDib     = 0;
    DWORD       cbProfData    = 0;
    VOID       *pProfData     = NULL;

    PUTS("MF_AnyDIBits\n");

    ASSERTGDI(mrType == EMR_SETDIBITSTODEVICE || mrType == EMR_STRETCHDIBITS
           || mrType == META_SETDIBTODEV || mrType == META_STRETCHDIB,
        "MF_AnyDIBits: Bad mrType");


    ASSERTGDI(mrType == EMR_STRETCHDIBITS || mrType == META_STRETCHDIB
           || rop == SRCCOPY,
        "MF_AnyDIBits: Bad rop");

    if (ISSOURCEINROP3(rop))
    {
        // Get the bitmap sizes.
        // We will store only BITMAPINFO in the record only.  The
        // BITMAPCOREINFO structure will be converted and stored as
        // BITMAPINFO in the metafile.

        // If it is a SetDIBitsToDevice, cScans cannot be zero.
        // If it is a StretchDIBits, cScans must be zero.
        if (mrType == EMR_SETDIBITSTODEVICE || mrType == META_SETDIBTODEV)
            if (!cScans)
                return(FALSE);

        if (!bMetaGetDIBInfo(hdcDst, (HBITMAP) 0, (PBMIH) pBitsInfoDib,
                &cbBitsInfoDib, &cbBitsDib, iUsageDib, cScans, FALSE))
            return(FALSE);

        // If there is any attached color space data, get pointer to that.
        // (only for BITMAPV5 headers.

        if (pBitsInfoDib->bmiHeader.biSize == sizeof(BITMAPV5HEADER))
        {
            PBITMAPV5HEADER pBmih5 = (PBITMAPV5HEADER)pBitsInfoDib;

            // if there is any attached profile data, count it on.

            if (((pBmih5->bV5CSType == PROFILE_EMBEDDED) ||
                 (pBmih5->bV5CSType == PROFILE_LINKED))
                  &&
                (pBmih5->bV5ProfileData != 0))
            {
                ICMMSG(("MF_AnyDIBits(): Metafiling attached color profile data\n"));

                pProfData  = (BYTE *)pBmih5 + pBmih5->bV5ProfileData;
                cbProfData = pBmih5->bV5ProfileSize;
            }
        }
    }

    switch (mrType)
    {
    case EMR_SETDIBITSTODEVICE:
        {
            PMRSETDIBITSTODEVICE pmrsdb;

            PLDC pldc;
            DC_PLDC(hdcDst,pldc,FALSE);

            PMDC pmdcDst = (PMDC)pldc->pvPMDC;
            ASSERTGDI(pmdcDst,"no pmdc\n");

            if (!(pmrsdb = (PMRSETDIBITSTODEVICE) pmdcDst->pvNewRecord
                        (SIZEOF_MRSETDIBITSTODEVICE(cbBitsInfoDib,cbBitsDib,cbProfData))))
                return(FALSE);

            pmrsdb->vInit
            (
                pmdcDst,        // pmdcDst
                (LONG) xDst,    // xDst
                (LONG) yDst,    // yDst
                (LONG) xDib,    // xDib
                (LONG) yDib,    // yDib
                (DWORD) cxDib,  // cxDib
                (DWORD) cyDib,  // cyDib
                iStartScan,     // iStartScan
                cScans,         // cScans
                cbBitsDib,      // size of bits buffer
                pBitsDib,       // dib bits
                cbBitsInfoDib,  // size of bitmap info
                pBitsInfoDib,   // dib info
                cbProfData,     // size of color profile data (if BITMAPV5)
                pProfData,      // color profile data
                iUsageDib       // dib info usage
            );
            pmrsdb->vCommit(pmdcDst);
            SET_COLOR_PAGE(pldc);
        }
        break;

    case EMR_STRETCHDIBITS:
        {
            PMRSTRETCHDIBITS pmrstrdb;

            PLDC pldc;
            DC_PLDC(hdcDst,pldc,FALSE);

            PMDC pmdcDst = (PMDC)pldc->pvPMDC;
            ASSERTGDI(pmdcDst,"no pmdc\n");

            if (!(pmrstrdb = (PMRSTRETCHDIBITS) pmdcDst->pvNewRecord
                        (SIZEOF_MRSTRETCHDIBITS(cbBitsInfoDib,cbBitsDib,cbProfData))))
                return(FALSE);

            pmrstrdb->vInit
            (
                pmdcDst,        // pmdcDst
                (LONG) xDst,    // xDst
                (LONG) yDst,    // yDst
                (LONG) cxDst,   // cxDst
                (LONG) cyDst,   // cyDst
                (LONG) xDib,    // xDib
                (LONG) yDib - iStartScan,    // yDib
                (LONG) cxDib,   // cxDib
                (LONG) cyDib,   // cyDib
                cScans,         // cScans
                cbBitsDib,      // size of bits buffer
                cScans ? ((PBYTE)pBitsDib) +
                         CJSCAN(pBitsInfoDib->bmiHeader.biWidth,pBitsInfoDib->bmiHeader.biPlanes,
                         pBitsInfoDib->bmiHeader.biBitCount)* iStartScan
                         : pBitsDib,    // dib bits
                cbBitsInfoDib,  // size of bitmap info
                pBitsInfoDib,   // dib info
                iUsageDib,      // dib info usage
                cbProfData,     // size of color profile data (if BITMAPV5)
                pProfData,      // color profile data
                rop             // rop
            );
            pmrstrdb->vCommit(pmdcDst);
            SET_COLOR_PAGE(pldc);
        }
        break;

    case META_SETDIBTODEV:
    case META_STRETCHDIB:
        {
            // Do not handle DIB_PAL_INDICES because there is no palette
            // information available.

            if (cbBitsInfoDib != 0 && iUsageDib == DIB_PAL_INDICES)
                return(FALSE);

            // Convert new bitmap formats to win3 bitmap formats

            if (cbBitsInfoDib != 0
             && (pBitsInfoDib->bmiHeader.biSize == sizeof(BMIH))
             && (pBitsInfoDib->bmiHeader.biPlanes != 1
               ||pBitsInfoDib->bmiHeader.biBitCount == 16
               ||pBitsInfoDib->bmiHeader.biBitCount == 32))
            {
                BOOL    b       = FALSE;
                HDC     hdc     = (HDC) 0;
                HBITMAP hbm     = (HBITMAP) 0;
                PBYTE   pBits24 = (PBYTE) NULL;
                DWORD   cbBits24;
                BMIH    bmih;

                if (iUsageDib == DIB_PAL_COLORS)
                    return(FALSE);      // illegal usage

                hdc = CreateCompatibleDC((HDC) 0);

                if (!(hbm = CreateDIBitmap(hdc,
                                (LPBITMAPINFOHEADER) pBitsInfoDib,
                                CBM_CREATEDIB, (LPBYTE) NULL, pBitsInfoDib, DIB_RGB_COLORS)))
                    goto error_exit;

                if (!SetDIBits(hdc, hbm,
                    cScans ? (UINT) iStartScan : 0,
                    cScans ? (UINT) cScans : (UINT) pBitsInfoDib->bmiHeader.biHeight,
                    (CONST VOID *) pBitsDib, pBitsInfoDib, (UINT) iUsageDib))
                    goto error_exit;

                bmih = *(PBITMAPINFOHEADER) pBitsInfoDib;
                bmih.biPlanes       = 1;
                bmih.biBitCount     = 24;
                bmih.biCompression  = BI_RGB;
                bmih.biSizeImage    = 0;
                bmih.biClrUsed      = 0;
                bmih.biClrImportant = 0;

                cbBits24 = CJSCAN(bmih.biWidth,bmih.biPlanes,bmih.biBitCount)
                            * (cScans ? cScans : ABS(bmih.biHeight));

                pBits24 = (LPBYTE) LocalAlloc(LMEM_FIXED, (UINT) cbBits24);
                if (pBits24 == (LPBYTE) NULL)
                    goto error_exit;

                // Get bitmap info and bits in 24bpp.

                if (!GetDIBits(hdc,
                       hbm,
                       cScans ? (UINT) iStartScan : 0,
                       cScans ? (UINT) cScans : (UINT) bmih.biHeight,
                       (LPVOID) pBits24,
                       (LPBITMAPINFO) &bmih,
                       DIB_RGB_COLORS))
                    goto error_exit;

                b = MF16_RecordDIBits
                    (
                        hdcDst,
                        xDst,
                        yDst,
                        cxDst,
                        cyDst,
                        xDib,
                        yDib,
                        cxDib,
                        cyDib,
                        iStartScan,
                        cScans,
                        cbBits24,
                        pBits24,
                        sizeof(bmih),
                        (LPBMI) &bmih,
                        DIB_RGB_COLORS,
                        rop,
                        mrType
                    );

            error_exit:
                if (hdc)
                    DeleteDC(hdc);
                if (hbm)
                    DeleteObject(hbm);
                if (pBits24)
                    LocalFree((HANDLE) pBits24);
                return(b);
            }
            else
            {
                return
                (
                    MF16_RecordDIBits
                    (
                        hdcDst,
                        xDst,
                        yDst,
                        cxDst,
                        cyDst,
                        xDib,
                        yDib,
                        cxDib,
                        cyDib,
                        iStartScan,
                        cScans,
                        cbBitsDib,
                        pBitsDib,
                        cbBitsInfoDib,
                        pBitsInfoDib,
                        iUsageDib,
                        rop,
                        mrType
                    )
                );
            }
        }
    }

    return(TRUE);
}

// SetFontXform
// This function is called only by the metafile playback code.
// If hdc is an enhanced metafile DC, we need to remember the scales
// so that we can metafile it in the compatible ExtTextOut or PolyTextOut
// record that follows.

extern "C" BOOL MF_SetFontXform(HDC hdc,FLOAT exScale,FLOAT eyScale)
{
    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    pmdc->exFontScale(exScale);
    pmdc->eyFontScale(eyScale);

    return(TRUE);
}

// TextOutA
// TextOutW
// ExtTextOutA
// ExtTextOutW

extern "C" BOOL MF_ExtTextOut(
    HDC hdc
  , int x
  , int y
  , UINT fl
  , CONST RECT *prcl
  , LPCSTR psz
  , int c
  , CONST INT *pdx
  , DWORD mrType
  )
{
#define BUFCOUNT 256
    WCHAR         awc[BUFCOUNT];
    WCHAR        *pwsz;
    PLDC          pldc;
    int           bAlloc = 0;
    BOOL          bRet = TRUE;
    DWORD         dwCP;
    INT           pDxCaptureBuffer[BUFCOUNT * 2]; // just in case there is pdy
    INT           cSave;
    PVOID	      pDCAttr;

    switch (mrType)
    {
    case EMR_EXTTEXTOUTW:

        pwsz = (WCHAR*) psz;
        break;

    case EMR_EXTTEXTOUTA:

        if (c < BUFCOUNT)
        {
            // if the multi byte string is small enough then use
            // the buffer on the frame

            pwsz = awc;
        }
        else
        {
            if (!(pwsz = (WCHAR*) LOCALALLOC((c+1) * (sizeof(WCHAR)+
            ((fl & ETO_PDY) ? (sizeof(INT) * 2) : sizeof(INT))))))
            {
                WARNING("MF_ExtTextOut: failed memory allocation\n");
                return(FALSE);
            }
            bAlloc = 1;
        }

        dwCP = GetCodePage(hdc);

        if(fFontAssocStatus)
        {
            dwCP = FontAssocHack(dwCP,(char*)psz,c);
        }

        cSave = c;

        c = MultiByteToWideChar(dwCP, 0, psz, c, pwsz, c*sizeof(WCHAR));
        break;

    default:

        WARNING("MF_ExtTextOut: Bad record type");
        return(FALSE);

    }

    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_ExtTextOut\n");

    pldc = GET_PLDC( hdc );

    if (pldc == NULL)
    {
    WARNING("MF_ExtTextOut: unable to retrieve pldc\n");
    if (bAlloc)
    {
        LOCALFREE((void*) pwsz);
    }

    return(FALSE);
    }

    if( (pldc->fl & (LDC_FONT_CHANGE | LDC_FONT_SUBSET | LDC_LINKED_FONTS)) &&
        (pldc->fl & (LDC_DOWNLOAD_FONTS | LDC_FORCE_MAPPING )) )
    {
        bDoFontChange(hdc, pwsz, c, fl);
        pldc->fl &= ~LDC_FONT_CHANGE;
    }
    else if (!(pldc->fl & (LDC_DOWNLOAD_FONTS | LDC_FORCE_MAPPING)) &&            // local printing
             (pldc->fl & LDC_EMBED_FONTS))                                      // current process has embedded fonts
    {
        bRecordEmbedFonts(hdc);
    }

    PSHARED_GET_VALIDATE(pDCAttr,hdc,DC_TYPE);

    // optimization for printing.  If there is no pdx array, lTextExtra, lBreakExtra and cBreak, don't record pdx

    if((pldc->fl & LDC_META_PRINT) && (pdx == NULL) && ( ((PDC_ATTR)pDCAttr)->lTextExtra == 0 ) && 
    	( ((PDC_ATTR)pDCAttr)->lBreakExtra == 0 ) && ( ((PDC_ATTR)pDCAttr)->cBreak == 0) )
    {
        PMRSMALLTEXTOUT pmrsto;
        BOOL bSmallGlyphs = TRUE;
        int cGlyphs;
        UINT cSize;

        for( cGlyphs = 0; cGlyphs < c; cGlyphs++ )
        {
            if( pwsz[cGlyphs] & 0xFF00 )
            {
                bSmallGlyphs = FALSE;
                break;
            }
        }

        cSize = sizeof(MRSMALLTEXTOUT);
        cSize += c * ( ( bSmallGlyphs ) ? sizeof(char) : sizeof(WCHAR) );
        cSize += ( prcl == NULL ) ? 0 : sizeof(RECT);
        cSize = ( cSize + 3 ) & ~3;

        if( !(pmrsto = (PMRSMALLTEXTOUT) pmdc->pvNewRecord(cSize)) )
        {
            bRet = FALSE;
        }
        else
        {
            pmrsto->vInit(hdc,
                          pmdc,
                          EMR_SMALLTEXTOUT,
                          x,
                          y,
                          fl,
                          (RECT*) prcl,
                          c,
                          pwsz,
                          bSmallGlyphs );

            pmrsto->vCommit(pmdc);
        }
    }
    else
    {
        PMREXTTEXTOUT pmreto;
        UINT cjCh = sizeof(WCHAR);

        INT *pDxCapt = (INT *)pdx;

        if((mrType == EMR_EXTTEXTOUTA) && (pdx != NULL))
        {
            if (IS_ANY_DBCS_CODEPAGE(dwCP))
            {
                pDxCapt = (bAlloc) ? (INT*) &pwsz[(cSave+1)&~1] : pDxCaptureBuffer;

                ConvertDxArray(dwCP,
                               (char*) psz,
                               (int*) pdx,
                               cSave,
                               pDxCapt,
                               (BOOL)(fl & ETO_PDY)
                               );
            }
            else
            {
                pDxCapt = (INT *)pdx;
            }
        }

        if(!(pmreto=(PMREXTTEXTOUT)pmdc->pvNewRecord(SIZEOF_MREXTTEXTOUT(c,cjCh,(fl & ETO_PDY)))) ||
           !pmreto->bInit(EMR_EXTTEXTOUTW,pmdc,hdc,x,y,fl,prcl,(LPCSTR)pwsz,
                          c,(CONST INT *)pDxCapt,cjCh))
        {
            bRet = FALSE;
        }
        else
        {
            pmreto->vCommit(pmdc);
        }
    }

    if (bAlloc)
        LOCALFREE((void*) pwsz);

    return(bRet);
#undef BUFCOUNT
}

// PolyTextOutA
// PolyTextOutW

extern "C" BOOL MF_PolyTextOut(HDC hdc, CONST POLYTEXTA *ppta, int c, DWORD mrType)
{
    DWORD mrTypeT;
    BOOL b;
    CONST POLYTEXTA *pptaT;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_PolyTextOut\n");

    // [kirko] 19-Apr-94
    //
    // I have changed this routine to call off to MF_ExtTextOut for each member
    // of the POLYTEXT? array. This is a little sleazy in that we are recording
    // a different function than what was sent down by the application. On the
    // other hand, it works and it is not incompatible with Chicago since they
    // don't support a PolyTextOut function. You may be concerned that we are losing
    // speed since we no longer call off to the spiffy fase PolyTextOut routine.
    // But, if you look in GDI you will find that that PolyTextOut just calls off
    // to ExtTextOut in a loop. We have just moved the loop to the Metafile recording.
    // If PolyTextOut is ever made fast again, the Metafile code should then be
    // modified to record those calls directly.

    switch (mrType)
    {
    case EMR_POLYTEXTOUTA:
        mrTypeT = EMR_EXTTEXTOUTA;
        break;
    case EMR_POLYTEXTOUTW:
        mrTypeT = EMR_EXTTEXTOUTW;
        break;
    default:
        WARNING("MF_PolyTextOut -- bad mrType");
        return(FALSE);
    }

    for (b = TRUE, pptaT = ppta + c; ppta < pptaT && b; ppta++)
    {
        b = MF_ExtTextOut(hdc, ppta->x, ppta->y, ppta->uiFlags, &(ppta->rcl)
                                      , ppta->lpstr, ppta->n, ppta->pdx, mrTypeT);
    }
    return(b);
}

extern "C" BOOL MF_ExtFloodFill(HDC hdc,int x,int y,COLORREF color,DWORD iMode)
{
    PMREXTFLOODFILL pmreff;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_ExtFloodFill\n");

    if (!(pmreff = (PMREXTFLOODFILL) pmdc->pvNewRecord(SIZEOF_MREXTFLOODFILL)))
        return(FALSE);

    pmreff->vInit(x, y, color, iMode);
    pmreff->vCommit(pmdc);
    return(TRUE);
}

// SetColorAdjustment

extern "C" BOOL MF_SetColorAdjustment(HDC hdc, CONST COLORADJUSTMENT *pca)
{
    PMRSETCOLORADJUSTMENT pmrsca;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_SetColorAdjustment\n");

    if (!(pmrsca = (PMRSETCOLORADJUSTMENT) pmdc->pvNewRecord(SIZEOF_MRSETCOLORADJUSTMENT(pca))))
        return(FALSE);

    pmrsca->vInit(pca);
    pmrsca->vCommit(pmdc);
    return(TRUE);
}



extern "C" BOOL MF_WriteEscape(HDC hdc, int nEscape, int nCount, LPCSTR lpInData, int type )
{
    PMRESCAPE   pmre;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    MFD2("Recording escape %d\n", nEscape );

    // just in case some one (pagemaker) passes in NULL with non 0 count!

    if (lpInData == NULL)
        nCount = 0;

    if (!(pmre = (PMRESCAPE) pmdc->pvNewRecord((sizeof(MRESCAPE)+nCount+3)&~3)))
    {
        WARNING("MF_WriteEscape: failed memory allocation\n");
        return(FALSE);
    }

    pmre->vInit(type, nEscape, nCount, lpInData);
    pmre->vCommit(pmdc);

    if (type == EMR_DRAWESCAPE ||
        nEscape == PASSTHROUGH ||
        nEscape == POSTSCRIPT_DATA ||
        nEscape == POSTSCRIPT_PASSTHROUGH ||
        nEscape == ENCAPSULATED_POSTSCRIPT)
    {
        SET_COLOR_PAGE (pldc);
    }

    return(TRUE);
}


extern "C" BOOL MF_WriteNamedEscape(
    HDC hdc,
    LPWSTR pwszDriver,
    int nEscape,
    int nCount,
    LPCSTR lpInData)
{
    PMRNAMEDESCAPE   pmre;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    MFD2("Recording named escape %d\n", nEscape );

    INT cjSizeOfRecord = (sizeof(MRNAMEDESCAPE) + nCount +
      ((wcslen(pwszDriver)+1) * sizeof(WCHAR)) +3)&~3;

    if(!(pmre = (PMRNAMEDESCAPE) pmdc->pvNewRecord(cjSizeOfRecord)))
    {
        WARNING("MF_WriteEscape: failed memory allocation\n");
        return(FALSE);
    }

    pmre->vInit(EMR_NAMEDESCAPE, nEscape, pwszDriver, lpInData, nCount);
    pmre->vCommit(pmdc);

    return(TRUE);
}


extern "C" BOOL MF_StartDoc(HDC hdc, CONST DOCINFOW *pDocInfo )
{
    PMRSTARTDOC pmrs;
    DWORD       cj;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    MFD1( "Recording MF_StartDocW\n" );

    cj = sizeof(MRSTARTDOC);

    if( pDocInfo->lpszDocName != NULL )
    {
        cj += (lstrlenW( pDocInfo->lpszDocName ) + 1) * sizeof(WCHAR);
        cj = (cj+3) & ~(0x3);
    }

    if( pDocInfo->lpszOutput != NULL )
    {
        cj += (lstrlenW( pDocInfo->lpszOutput ) + 1) * sizeof(WCHAR);
    }

    cj = (cj+3) & ~(0x3); // make things DWORD alligned


    if (!(pmrs = (PMRSTARTDOC) pmdc->pvNewRecord( cj+40 )))
    {
        WARNING("MF_StartDoc: failed memory allocation\n");
        return(FALSE);
    }

    pmrs->vInit(EMR_STARTDOC, pDocInfo);
    pmrs->vCommit(pmdc);

    return(TRUE);
}


extern "C" BOOL MF_ForceUFIMapping(HDC hdc, PUNIVERSAL_FONT_ID pufi )
{
    PMRFORCEUFIMAPPING   pmre;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    MFD1("Recording forced mapping\n");

    if (!(pmre = (PMRFORCEUFIMAPPING) pmdc->pvNewRecord(sizeof(MRFORCEUFIMAPPING))))
    {
        WARNING("MF_ForceUFIMapping: failed memory allocation\n");
        return(FALSE);
    }

    pmre->vInit(EMR_FORCEUFIMAPPING, pufi);
    pmre->vCommit(pmdc);

    return(TRUE);
}

extern "C" BOOL MF_SetLinkedUFIs(HDC hdc, PUNIVERSAL_FONT_ID pufi,UINT uNumLinkedUFIs )
{
    PMRSETLINKEDUFIS pmre;
    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    MFD1("Recording SetLinkedUFIs\n");

    UINT AllocationSize = sizeof(MRSETLINKEDUFIS) + sizeof(UNIVERSAL_FONT_ID) *
      uNumLinkedUFIs;

    if(!(pmre = (PMRSETLINKEDUFIS) pmdc->pvNewRecord(AllocationSize)))
    {
        WARNING("MF_orceUFIMapping: failed memory allocation\n");
        return(FALSE);
    }

    pmre->vInit(uNumLinkedUFIs, pufi);
    pmre->vCommit(pmdc);

    return(TRUE);
}

// OpenGL metafile records


BOOL APIENTRY GdiAddGlsRecord(HDC hdc, DWORD cb, BYTE *pb, LPRECTL prclBounds)
{
    PMRGLSRECORD pmrgr;
    PMRGLSBOUNDEDRECORD pmrgbr;

    PLDC pldc;
    DC_PLDC(hdc, pldc, FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc, "no pmdc\n");

    if (prclBounds == NULL)
    {
        pmrgr = (PMRGLSRECORD)pmdc->pvNewRecord(SIZEOF_MRGLSRECORD(cb));
        if (pmrgr == NULL)
        {
            return FALSE;
        }

        pmrgr->vInit(cb, pb);
        pmrgr->vCommit(pmdc);
    }
    else
    {
        pmrgbr = (PMRGLSBOUNDEDRECORD)
            pmdc->pvNewRecord(SIZEOF_MRGLSBOUNDEDRECORD(cb));
        if (pmrgbr == NULL)
        {
            return FALSE;
        }

        pmrgbr->vInit(cb, pb, prclBounds);
        pmrgbr->vCommit(pmdc);
    }

    // Mark the metafile as containing OpenGL records
    pmdc->mrmf.bOpenGL = TRUE;

    // NTFIXED #34919(old RaidDB 423900) 02-07-2000 pravins OPENGL PRINT: Prints
    // to many color printers in black an white only.
    // This page can be a color.
    SET_COLOR_PAGE(pldc);

    return TRUE;
}



extern "C" BOOL APIENTRY GdiAddGlsBounds(HDC hdc, LPRECTL prclBounds)
{
    // Bounds are given as a well-ordered rectangle in
    // device coordinates
    return SetBoundsRectAlt(hdc, (RECT *)prclBounds,
                            (UINT)(DCB_WINDOWMGR | DCB_ACCUMULATE)) != 0;
}



extern "C" BOOL APIENTRY MF_SetPixelFormat(HDC hdc,
                                           int iPixelFormat,
                                           CONST PIXELFORMATDESCRIPTOR *ppfd)
{
    PMRPIXELFORMAT pmrpf;

    PLDC pldc;
    DC_PLDC(hdc, pldc, FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc, "no pmdc\n");

    pmrpf = (PMRPIXELFORMAT)pmdc->pvNewRecord(SIZEOF_MRPIXELFORMAT);
    if (pmrpf == NULL)
    {
        return FALSE;
    }

    pmrpf->vInit(ppfd);
    pmrpf->vCommit(pmdc);

    // Fix up the pixel format offset in the header
    // This only allows one pixel format to be
    // described in the header.  This doesn't seem too bad
    // but we don't really need the pixel format offset in the
    // header since there should always be a pixel format record
    // in the metafile (as long as a pixel format is set)
    pmdc->mrmf.cbPixelFormat = sizeof(PIXELFORMATDESCRIPTOR);
    pmdc->mrmf.offPixelFormat = pmdc->iMem-sizeof(MRPIXELFORMAT)+
        FIELD_OFFSET(MRPIXELFORMAT, pfd);

    return TRUE;
}



extern "C" BOOL APIENTRY MF_SetICMProfile(HDC hdc, LPBYTE lpFile, PVOID pvColorSpace, DWORD dwRecordType)
{
    BOOL bRet = TRUE;

    PMRSETICMPROFILE pmsip;
    WCHAR UnicFileName[MAX_PATH];
    WCHAR PathFileName[MAX_PATH+1];

    PCACHED_COLORSPACE pColorSpace = (PCACHED_COLORSPACE) pvColorSpace;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PUTS("MF_SetICMProfile\n");

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc, "no pmdc\n");

    ASSERTGDI((dwRecordType == EMR_SETICMPROFILEA) ||
              (dwRecordType == EMR_SETICMPROFILEW), "Invalid Record Type\n");

    CLIENT_SIDE_FILEVIEW MappedProfile;

    DWORD  dwFlags = 0;

    DWORD  dwNameLength = 0;
    DWORD  dwDataLength = 0;
    LPBYTE lpName = NULL;
    LPBYTE lpData = NULL;

#if DBG
    BOOL   bDownload = ((pldc->fl & LDC_DOWNLOAD_PROFILES) || (DbgIcm & DBG_ICM_METAFILE));
#else
    BOOL   bDownload = (pldc->fl & LDC_DOWNLOAD_PROFILES);
#endif

    if (pColorSpace)
    {
        ICMMSG(("MF_SetICMProfile[A|W]():Metafiling by color space\n"));

        //
        // Get profile name from CACHED_COLORSPACE.
        //
        lpName = (PBYTE)&(pColorSpace->LogColorSpace.lcsFilename[0]);

        //
        // Unicode record.
        //
        dwRecordType = EMR_SETICMPROFILEW;
    }
    else if (lpFile)
    {
        ICMMSG(("MF_SetICMProfile[A|W]():Metafiling by file name\n"));

        //
        // If ansi API, the lpName is ansi based string, Convert the string to Unicode.
        //
        if (bDownload && (dwRecordType == EMR_SETICMPROFILEA))
        {
            //
            // Convert ANSI to Unicode.
            //
            vToUnicodeN(UnicFileName,MAX_PATH,(char *)lpFile,strlen((char *)lpFile)+1);
            lpName = (LPBYTE) UnicFileName;

            //
            // And this is download, which means only EMF-spooling case comes here.
            // so this record is only play back on NT. thus we are safe to convert
            // record this as Unicode.
            //
            dwRecordType = EMR_SETICMPROFILEW;
        }
        else
        {
            lpName = lpFile;
        }
    }
    else
    {
        return FALSE;
    }

    //
    // We must have color profile (since this is destination color space).
    //
    if (dwRecordType == EMR_SETICMPROFILEW)
    {
        ICMMSG(("MF_SetICMProfileW():Metafiling - %ws\n",lpName));

        if (*(WCHAR *)lpName == UNICODE_NULL)
        {
            ICMMSG(("MF_SetICMProfile() ANSI: no profile name is given\n"));
            return FALSE;
        }
    }
    else
    {
        ICMMSG(("MF_SetICMProfileA():Metafiling - %s\n",lpName));

        if (*(char *)lpName == NULL)
        {
            ICMMSG(("MF_SetICMProfile() UNICODE: no profile name is given\n"));
            return FALSE;
        }
    }

    RtlZeroMemory(&MappedProfile,sizeof(CLIENT_SIDE_FILEVIEW));

    if (bDownload)
    {
        //
        // We are in profile attached mode.
        //
        dwFlags = SETICMPROFILE_EMBEDED;

        //
        // Normalize ICC profile path
        //
        BuildIcmProfilePath((WCHAR *)lpName, PathFileName, MAX_PATH);

        //
        // Check we already attached this or not.
        //
        if (pmdc->bExistColorProfile(PathFileName))
        {
            ICMMSG(("MF_SetICMProfile():Exist in metafile FileImage - %ws\n",PathFileName));
        }
        else
        {
            ICMMSG(("MF_SetICMProfile():Attaching in metafile FileImage - %ws\n",PathFileName));

            if (pColorSpace && (pColorSpace->ColorProfile.dwType == PROFILE_MEMBUFFER))
            {
                lpData = (PBYTE)(pColorSpace->ColorProfile.pProfileData);
                dwDataLength = pColorSpace->ColorProfile.cbDataSize;
            }
            else
            {
                if (!bMapFileUNICODEClideSide(PathFileName,&MappedProfile,FALSE))
                {
                    return FALSE;
                }

                lpData = (PBYTE) MappedProfile.pvView;
                dwDataLength = MappedProfile.cjView;
            }

            // Mark we attach this profile into metafile
            //
            pmdc->vInsertColorProfile((WCHAR *)PathFileName);
        }

        // WINBUG 365045 4-10-2001 pravins Possible work item in MF_SetICMProfile
        //
        // Old Comment:
        //     [THIS PART NEED TO BE RE-CONSIDERRED]
        //
        //     Only record filename, not full path. (when we attach profile)
        //
        lpName = (LPBYTE) GetFileNameFromPath((WCHAR *)PathFileName);
    }

    if (dwRecordType == EMR_SETICMPROFILEA)
    {
        //
        // Compute the data length (string is ansi)
        //
        dwNameLength = strlen((CHAR *)lpName) + 1;
    }
    else
    {
        //
        // Compute the data length (string is unicode)
        //
        dwNameLength = (wcslen((WCHAR *)lpName) + 1) * sizeof(WCHAR);
    }

    pmsip = (PMRSETICMPROFILE)pmdc->pvNewRecord(SIZEOF_MRSETICMPROFILE(dwNameLength+dwDataLength));

    if (pmsip == NULL)
    {
        bRet = FALSE;
    }
    else
    {
        pmsip->vInit(dwRecordType,dwFlags,dwNameLength,lpName,dwDataLength,lpData);
        pmsip->vCommit(pmdc);
    }

    if (MappedProfile.hSection)
    {
        vUnmapFileClideSide(&MappedProfile);
    }

    return bRet;
}



extern "C" BOOL APIENTRY MF_ColorMatchToTarget(HDC hdc, DWORD dwAction, PVOID pvColorSpace, DWORD dwRecordType)
{
    BOOL bRet = TRUE;

    PMRCOLORMATCHTOTARGET pmcmt;
    WCHAR PathFileName[MAX_PATH+1];

    PCACHED_COLORSPACE pColorSpace = (PCACHED_COLORSPACE) pvColorSpace;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PUTS("MF_ColorMatchToTarget\n");

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc, "no pmdc\n");

    ASSERTGDI(dwRecordType == EMR_COLORMATCHTOTARGETW, "Invalid Record Type\n");

    DWORD  dwFlags = 0;

    DWORD  dwNameLength = 0;
    DWORD  dwDataLength = 0;
    LPBYTE lpName = NULL;
    LPBYTE lpData = NULL;

    CLIENT_SIDE_FILEVIEW MappedProfile;

    RtlZeroMemory(&MappedProfile,sizeof(CLIENT_SIDE_FILEVIEW));

    if (dwAction == CS_ENABLE)
    {
        //
        // Get profile name from CACHED_COLORSPACE.
        //
        lpName = (PBYTE)&(pColorSpace->LogColorSpace.lcsFilename[0]);

        //
        // We must have color profile (since this is target color space).
        //
        if (*(WCHAR *)lpName == UNICODE_NULL)
        {
            ICMMSG(("MF_ColorMatchToTarget():no profile name in LOGCOLORSPACE\n"));
            return FALSE;
        }

        ICMMSG(("MF_ColorMatchToTarget():Metafiling - %ws\n",lpName));

    #if DBG
        if ((pldc->fl & LDC_DOWNLOAD_PROFILES) || (DbgIcm & DBG_ICM_METAFILE))
    #else
        if (pldc->fl & LDC_DOWNLOAD_PROFILES)
    #endif
        {
            //
            // We are in profile attached mode.
            //
            dwFlags = COLORMATCHTOTARGET_EMBEDED;

            //
            // Normalize ICC profile path
            //
            BuildIcmProfilePath((WCHAR *)lpName, PathFileName, MAX_PATH);

            //
            // Check we already attached this or not.
            //
            if (pmdc->bExistColorProfile((WCHAR *)PathFileName))
            {
                ICMMSG(("MF_ColorMatchToTarget():Exist in metafile FileImage - %ws\n",PathFileName));
            }
            else
            {
                ICMMSG(("MF_ColorMatchToTarget():Attaching in metafile FileImage - %ws\n",PathFileName));

                if (pColorSpace->ColorProfile.dwType == PROFILE_MEMBUFFER)
                {
                    lpData = (PBYTE)(pColorSpace->ColorProfile.pProfileData);
                    dwDataLength = pColorSpace->ColorProfile.cbDataSize;
                }
                else
                {
                    if (!bMapFileUNICODEClideSide(PathFileName,&MappedProfile,FALSE))
                    {
                        return FALSE;
                    }

                    lpData = (PBYTE) MappedProfile.pvView;
                    dwDataLength = MappedProfile.cjView;
                }

                // Mark we attach this profile into metafile
                //
                pmdc->vInsertColorProfile((WCHAR *)PathFileName);
            }

            // WINBUG 365045 4-10-2001 pravins Possible work item in MF_SetICMProfile
            //
            // Old Comment:
            //     [THIS PART NEED TO BE RE-CONSIDERRED]
            //
            //     Only record filename, not full path. (when we attach profile)
            //
            lpName = (LPBYTE) GetFileNameFromPath((WCHAR *)PathFileName);
        }

        //
        // Compute the data length (string is unicode)
        //
        dwNameLength = (wcslen((WCHAR *)lpName) + 1) * sizeof(WCHAR);
    }
    else
    {
        ICMMSG(("MF_ColorMatchToTarget():Metafiling - %d",dwAction));
    }

    pmcmt = (PMRCOLORMATCHTOTARGET)pmdc->pvNewRecord(SIZEOF_MRCOLORMATCHTOTARGET(dwNameLength+dwDataLength));

    if (pmcmt == NULL)
    {
        bRet = FALSE;
    }
    else
    {
        pmcmt->vInit(dwRecordType,dwAction,dwFlags,dwNameLength,lpName,dwDataLength,lpData);
        pmcmt->vCommit(pmdc);
    }

    if (MappedProfile.hSection)
    {
        vUnmapFileClideSide(&MappedProfile);
    }

    return bRet;
}


extern "C" BOOL APIENTRY MF_CreateColorSpaceA(PMDC pmdc, HGDIOBJ hobj, DWORD imhe)
{
    BOOL bRet = TRUE;

    PMRCREATECOLORSPACE pmColorSpaceA;

    PUTS("MF_CreateColorSpaceA\n");

    LOGCOLORSPACEA LogColorSpaceA;

    if (!GetLogColorSpaceA((HCOLORSPACE)hobj,&LogColorSpaceA,sizeof(LOGCOLORSPACEA)))
    {
        ICMMSG(("MF_CreateColorSpaceA():Failed on GetLogColorSpaceW()\n"));
        return FALSE;
    }

#if DBG
    if (LogColorSpaceA.lcsFilename[0] != NULL)
    {
        ICMMSG(("MF_CreateColorSpaceA():Metafiling - %s\n",LogColorSpaceA.lcsFilename));
    }
#endif

    pmColorSpaceA = (PMRCREATECOLORSPACE) pmdc->pvNewRecord(SIZEOF_MRCREATECOLORSPACE);

    if (pmColorSpaceA == NULL)
    {
        bRet = FALSE;
    }
    else
    {
        pmColorSpaceA->vInit((ULONG)imhe,LogColorSpaceA);
        pmColorSpaceA->vCommit(pmdc);
    }

    return bRet;
}

extern "C" BOOL APIENTRY MF_CreateColorSpaceW(
    PMDC pmdc, PLOGCOLORSPACEEXW pLogColorSpaceExW, DWORD imhe, BOOL bDownload)
{
    BOOL bRet = TRUE;

    PMRCREATECOLORSPACEW pmColorSpaceW;
    WCHAR PathFileName[MAX_PATH];

    PUTS("MF_CreateColorSpaceW\n");

    DWORD  dwFlags = 0;

    DWORD  dwDataLength = 0;
    LPBYTE lpData = NULL;

    CLIENT_SIDE_FILEVIEW MappedProfile;

    RtlZeroMemory(&MappedProfile,sizeof(CLIENT_SIDE_FILEVIEW));

    //
    // Check LOGCOLORSPACE has color profile.
    //
    if (pLogColorSpaceExW->lcsColorSpace.lcsFilename[0] != NULL)
    {
        ICMMSG(("MF_CreateColorSpaceW():Metafiling - %ws\n",
                 pLogColorSpaceExW->lcsColorSpace.lcsFilename));
    }

    pmColorSpaceW = (PMRCREATECOLORSPACEW)pmdc->pvNewRecord(SIZEOF_MRCREATECOLORSPACEW(dwDataLength));

    if (pmColorSpaceW == NULL)
    {
        bRet = FALSE;
    }
    else
    {
        pmColorSpaceW->vInit((ULONG)imhe,pLogColorSpaceExW->lcsColorSpace,dwFlags,dwDataLength,lpData);
        pmColorSpaceW->vCommit(pmdc);
    }

    return bRet;
}

extern "C" BOOL APIENTRY MF_InternalCreateColorSpace(HDC hdc,HGDIOBJ hobj,DWORD imhe)
{
    BOOL bRet = TRUE;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PUTS("MF_InternalCreateColorSpace\n");

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc, "no pmdc\n");

    LOGCOLORSPACEEXW LogColorSpaceExW;

    //
    // Obtain LOGCOLORSPACEEX from handle.
    //
    if (!NtGdiExtGetObjectW((HCOLORSPACE)hobj,sizeof(LOGCOLORSPACEEXW),&LogColorSpaceExW))
    {
        ICMMSG(("MF_InternalCreateColorSpace():Failed on NtGdiExtGetObject()\n"));
        return (FALSE);
    }

#if DBG
    BOOL bDownload = ((pldc->fl & LDC_DOWNLOAD_PROFILES) || (DbgIcm & DBG_ICM_METAFILE));
#else
    BOOL bDownload = (pldc->fl & LDC_DOWNLOAD_PROFILES);
#endif

    ICMMSG(("MF_InternalCreateColorSpace():dwFlags = %x, bDownload = %d\n",
             LogColorSpaceExW.dwFlags,bDownload));

    //
    // If we are EMF spooling (profile attach case), or color space is created by CreateColorSpaceW(),
    // use Unicode version of record to keep in metafile.
    //

    if ((LogColorSpaceExW.dwFlags & LCSEX_ANSICREATED) && (!bDownload))
    {
        //
        // Create Win9x compatible ANSI record.
        //
        bRet = MF_CreateColorSpaceA(pmdc,hobj,imhe);
    }
    else
    {
        //
        // Create Unicode record.
        //
        bRet = MF_CreateColorSpaceW(pmdc,&LogColorSpaceExW,imhe,bDownload);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\metasup.cxx ===
/******************************Module*Header*******************************\
* Module Name: metasup.cxx
*
* Includes metafile support functions.
*
* Created: 17-July-1991 10:10:36
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#define NO_STRICT

extern "C" {
#if defined(_GDIPLUS_)
#include    <gpprefix.h>
#endif

#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <stddef.h>
#include    <windows.h>    // GDI function declarations.
#include    <winerror.h>
#include    "firewall.h"
#define __CPLUSPLUS
#include    <winspool.h>
#include    <w32gdip.h>
#include    "ntgdistr.h"
#include    "winddi.h"
#include    "hmgshare.h"
#include    "icm.h"
#include    "local.h"      // Local object support.
#include    "gdiicm.h"
#include    "metadef.h"    // Metafile record type constants.
#include    "mf16.h"
#include    "ntgdi.h"
}

#include    "rectl.hxx"
#include    "mfdc.hxx"  // Metafile DC class declarations.
#include    "mfrec.hxx" // Metafile record class declarations.

extern "C" {
HANDLE InternalCreateLocalMetaFile(HANDLE hSrv, DWORD iTypeReq);
DWORD SetMapperFlagsInternal(HDC hdc,DWORD fl);
}


PLINK aplHash[LINK_HASH_SIZE] = {0};


/******************************Public*Routine******************************\
* pmdcAllocMDC(hdcRef, pszFilename, pwszDescription)
*
* This routine allocates memory for an MDC and initializes it.  It creates
* a disk file if necessary.  Returns a pointer to the new MDC.  On error
* returns NULL.
*
* This routine is called by API level DC allocation routines CreateEnhMetaFile.
*
* History:
*  Tue Jul 02 13:43:18 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

PMDC pmdcAllocMDC(HDC hdcRef, LPCWSTR pwszFilename, LPCWSTR pwszDescription, HANDLE hEMFSpool)
{
    PMDC  pmdc, pmdcRc = (PMDC) NULL;
    ULONG       ii;

    PUTS("pmdcAllocMDC\n");

// Allocate a new MDC.

    if (!(pmdc = (PMDC) LocalAlloc(LMEM_FIXED, sizeof(MDC))))
        goto pmdcAllocMDC_cleanup;

// Initialize it.

    pmdc->ident     = MDC_IDENTIFIER;
    pmdc->hFile     = INVALID_HANDLE_VALUE;
    pmdc->hData     = NULL;
    pmdc->nMem      = MF_BUFSIZE_INIT;
    pmdc->iMem      = 0L;
    pmdc->fl        = 0L;
    pmdc->pmhe      = (PMHE) NULL;
    pmdc->cPalEntries = 0L;
    pmdc->iPalEntries = 0L;
    pmdc->pPalEntries = (PPALETTEENTRY) NULL;   // allocate as needed
    pmdc->erclMetaBounds = rclInfinity;     // default clipping bounds
    pmdc->erclClipBounds = rclInfinity;
    pmdc->hdcRef      = hdcRef;
    pmdc->exFontScale(0.0f);
    pmdc->eyFontScale(0.0f);
    pmdc->vInitColorProfileList();

// Create a disk file if given.  The filename is given in unicode.

    if (pwszFilename)
    {
        LPWSTR  pwszFilePart;           // not used

        // Convert the filename to a fully qualified pathname.

        DWORD cPathname = GetFullPathNameW(pwszFilename,
                                          MAX_PATH,
                                          pmdc->wszPathname,
                                          &pwszFilePart);

        if (!cPathname || cPathname > MAX_PATH)
        {
            ERROR_ASSERT(FALSE, "GetFullPathName failed");
            if (cPathname > MAX_PATH)
                GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
            goto pmdcAllocMDC_cleanup;
        }
        pmdc->wszPathname[cPathname] = 0;

        // Create the file.

        if ((pmdc->hFile = CreateFileW(pmdc->wszPathname,       // Filename
                                    GENERIC_WRITE,              // Write access
                                    0L,                         // Non-shared
                    (LPSECURITY_ATTRIBUTES) NULL, // No security
                                    CREATE_ALWAYS,              // Always create
                                    FILE_ATTRIBUTE_NORMAL,      // normal attributes
                                    (HANDLE) 0))                // no template file
            == INVALID_HANDLE_VALUE)
        {
            ERROR_ASSERT(FALSE, "CreateFile failed");
            goto pmdcAllocMDC_cleanup;
        }
        pmdc->fl |= MDC_DISKFILE;       // this must be last!  See vFreeMDC.

    }

// Allocate memory for metafile.
//   For disk metafile, it is used as a buffer.
//   For memory metafile, it is the storage for the metafile.

    if (hEMFSpool != NULL)
    {
        // Recording EMF data during EMF spooling

        pmdc->fl |= MDC_EMFSPOOL;
        pmdc->hData = hEMFSpool;

        if(!((EMFSpoolData *) hEMFSpool)->GetEMFData(pmdc))
            goto pmdcAllocMDC_cleanup;

    }
    else
    {
        if (!(pmdc->hData = LocalAlloc(LMEM_FIXED, MF_BUFSIZE_INIT)))
            goto pmdcAllocMDC_cleanup;

    }

// Allocate memory for metafile handle table.

    if (!(pmdc->pmhe = (PMHE) LocalAlloc(LMEM_FIXED, MHT_HANDLE_SIZE * sizeof(MHE))))
        goto pmdcAllocMDC_cleanup;

// Initialize the new handles.
// The first entry is reserved and unused.

    pmdc->pmhe[0].lhObject   = (HANDLE) 0;
    pmdc->pmhe[0].metalink.vInit(INVALID_INDEX);

    ii = pmdc->imheFree = 1L;
    pmdc->cmhe = MHT_HANDLE_SIZE;
    for ( ; ii < MHT_HANDLE_SIZE; ii++)
    {
        pmdc->pmhe[ii].lhObject = (HANDLE) 0;
        pmdc->pmhe[ii].metalink.vInit(ii+1);
    }
    pmdc->pmhe[ii-1].metalink.vInit(INVALID_INDEX);

// Create the first metafile record.
// The description string is part of the header record.

    // Get the length of the description string including the NULLs.

    PMRMETAFILE pmrmf;
    UINT cwszDescription;

    if (pwszDescription != (LPWSTR) NULL)
    {
       for
       (
           cwszDescription = 0;
           pwszDescription[cwszDescription] != (WCHAR) 0
           || pwszDescription[cwszDescription + 1] != (WCHAR) 0;
           cwszDescription++
       )
           ;               // NULL expression
       cwszDescription += 2;       // add terminating nulls
       if (cwszDescription > 512)
       {
           WARNING("pmdcAllocMDC: Description string is > 512 chars\n");
       }
    }
    else
    cwszDescription = 0;

    // Allocate dword aligned structure.

    if (!(pmrmf = (PMRMETAFILE) pmdc->pvNewRecord
            (SIZEOF_MRMETAFILE(cwszDescription))))
        goto pmdcAllocMDC_cleanup;

    pmrmf->vInit(hdcRef, pwszDescription, cwszDescription);

// Save a copy of it in the metafile DC.

    pmdc->mrmf = *(PENHMETAHEADER) pmrmf;

// Commit it.

    pmrmf->vCommit(pmdc);


    // If the reference DC has a pixel format selected, record
    // it in the metafile
    int iPixelFormat;

    if ((iPixelFormat = GetPixelFormat(hdcRef)) != 0)
    {
        PMRPIXELFORMAT pmrpf;
        PIXELFORMATDESCRIPTOR pfd;

        if (!DescribePixelFormat(hdcRef, iPixelFormat, sizeof(pfd), &pfd))
        {
            goto pmdcAllocMDC_cleanup;
        }

        pmrpf = (PMRPIXELFORMAT)pmdc->pvNewRecord(SIZEOF_MRPIXELFORMAT);
        if (pmrpf == NULL)
        {
            goto pmdcAllocMDC_cleanup;
        }

        pmrpf->vInit(&pfd);
        pmrpf->vCommit(pmdc);
    }

    pmdcRc = pmdc;

// Cleanup and go home.

pmdcAllocMDC_cleanup:

    if (!pmdcRc)
        if (pmdc)
        {
            pmdc->fl |= MDC_FATALERROR; // set to delete the disk metafile
            vFreeMDC(pmdc);
        }

    ERROR_ASSERT(pmdcRc, "pmdcAllocMDC failed");
    return(pmdcRc);
}

/******************************Public*Routine******************************\
* vFreeMDC (pmdc)
*
* This is a low level routine which frees the resouces in the MDC.
*
* This function is intended to be called from the routine CloseEnhMetaFile.
*
* Arguments:
*   pmdc    - The MDC to be freed.
*
* History:
*  Tue Jul 02 13:43:18 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID vFreeMDC(PMDC pmdc)
{
    ULONG   ii;

    PUTS("vFreeMDC\n");

    ASSERTGDI(pmdc->ident == MDC_IDENTIFIER, "Bad MDC");

// Free the resources.

    if (pmdc->pPalEntries)
    {
        if (LocalFree(pmdc->pPalEntries))
        {
            ASSERTGDI(FALSE, "LocalFree failed");
        }
    }

    // Cleanup objects and metalinks.

    pmdc->vFreeColorProfileList();

    if (pmdc->pmhe)
    {
        // The first entry is reserved and unused.

        for (ii = 1 ; ii < pmdc->cmhe; ii++)
        {
            if (pmdc->pmhe[ii].lhObject != (HANDLE) 0)
                vFreeMHE(pmdc->hdcRef, ii);
        }
        if (LocalFree(pmdc->pmhe))
        {
            ASSERTGDI(FALSE, "LocalFree failed");
        }
    }
    if (pmdc->hData)
    {
        if (pmdc->bIsEMFSpool())
        {
            pmdc->CompleteEMFData(FALSE);
        }
        else
        {
            if (LocalFree(pmdc->hData))
            {
                ASSERTGDI(FALSE, "LocalFree failed");
            }
        }
    }

    if (pmdc->hFile != INVALID_HANDLE_VALUE)
    {
        if (!CloseHandle(pmdc->hFile))
        {
            ASSERTGDI(FALSE, "CloseHandle failed");
        }
    }

// Delete the disk metafile we created if we encountered any fatal error.

    if (pmdc->bIsDiskFile() && pmdc->bFatalError())
    {

        #if DBG
        SetLastError(0);
        #endif

        if (!DeleteFileW(pmdc->wszPathname))
        {
            #if DBG
            DbgPrint("vFreeMDC: DeleteFile failed with error code %ld\n",
                     GetLastError());
            #endif

            //
            // There are certain conditions causing fatal errors accessing
            // files that equally prevent the deletion of the file
            // (such as out of quota or pool)
            // If we can't delete the file, we can't do anything about it
            // anyway - let's not force an ASSERT even on checked builds unless
            // we set the debug flags. We will make do with an error message
            // and appropriate error code above.
            //

            ERROR_ASSERT(FALSE, "vFreeMDC: DeleteFile failed");
        }
    }

// Smash the identifier.

    pmdc->ident = 0;

// Free the memory.

    if (LocalFree(pmdc))
    {
        ASSERTGDI(FALSE, "LocalFree failed");
    }
}

/******************************Public*Routine******************************\
* pmfAllocMF(fl, pb, pwszFilename)
*
* This routine allocates memory for an MF and initializes it.
* Returns a pointer to the new MF.  On error returns NULL.
* It accepts only enhanced metafiles.
*
* This routine is called by API level MF allocation routines CloseEnhMetaFile,
* GetEnhMetaFile, SetEnhMetaFileBits and CopyEnhMetaFile.
*
* Arguments:
*   fl           - ALLOCMF_TRANSFER_BUFFER is set if storage for memory metafile
*                  is to be set directly into MF.  Otherwise, a copy of the
*                  memory metafile is duplicated.
*   pb           - Pointer to a memory metafile if non-null.
*   pwszFilename - Filename of a disk metafile if non-null.
*
* History:
*  Tue Jul 02 13:43:18 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

PMF pmfAllocMF(ULONG fl, CONST UNALIGNED DWORD *pb, LPCWSTR pwszFilename, HANDLE hFile, UINT64 fileOffset, HANDLE hExtra)
{
    PMF             pmf = NULL;
    PMF             pmfRc = (PMF) NULL;
    PENHMETAHEADER  pmrmf = NULL;

    PUTS("pmfAllocMF\n");

    ASSERTGDI(!(fl & ~ALLOCMF_TRANSFER_BUFFER), "pmfAllocMF: Invalid fl");

// Allocate a new MF.

    if (!(pmf = (PMF) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(MF))))
        goto pmfAllocMF_cleanup;

// Initialize it.

    pmf->ident      = MF_IDENTIFIER;
    pmf->hFile      = INVALID_HANDLE_VALUE;
    pmf->hFileMap   = NULL;
    pmf->pvFileMapping = NULL;
    pmf->pvLocalCopy = NULL;
    pmf->pEMFSpool  = hExtra ? (EMFSpoolData*) hExtra : NULL;
    pmf->iMem       = 0L;
    pmf->pht        = (PHANDLETABLE) NULL;
    pmf->fl         = 0L;
    pmf->hdcXform   = 0;


// Memory mapped the disk file if given.

    if (pwszFilename)
    {
        pmf->fl |= MF_DISKFILE;         // this must be first!  See vFreeMF.

        LPWSTR          pwszFilePart;           // not used
        UINT64          fileSize;

        // Convert the filename to a fully qualified pathname.

        DWORD cPathname = GetFullPathNameW(pwszFilename,
                                          MAX_PATH,
                                          pmf->wszPathname,
                                          &pwszFilePart);

        if (!cPathname || cPathname > MAX_PATH)
        {
            ERROR_ASSERT(FALSE, "GetFullPathName failed");
            if (cPathname > MAX_PATH)
                GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
            goto pmfAllocMF_cleanup;
        }
        pmf->wszPathname[cPathname] = 0;

        if ((pmf->hFile = CreateFileW(pmf->wszPathname,         // Filename
                                     GENERIC_READ,              // Read access
                                     FILE_SHARE_READ,           // Share read
                                     (LPSECURITY_ATTRIBUTES) 0L,// No security
                                     OPEN_EXISTING,             // Re-open
                                     0,                         // file attributes ignored
                                     (HANDLE) 0))               // no template file
            == INVALID_HANDLE_VALUE)
        {
            ERROR_ASSERT(FALSE, "CreateFile failed");
            goto pmfAllocMF_cleanup;
        }

        if(!GetFileSizeEx(pmf->hFile, (PLARGE_INTEGER) &fileSize))
        {
            ERROR_ASSERT(FALSE, "GetFileSizeEx failed");
            goto pmfAllocMF_cleanup;
        }

        if(fileSize > (UINT64) 0xFFFFFFFF)
        {
            ERROR_ASSERT(FALSE, "EMF File too large\n");
            goto pmfAllocMF_cleanup;
        }

        if (!(pmf->hFileMap = CreateFileMappingW(pmf->hFile,
                                                (LPSECURITY_ATTRIBUTES) 0L,
                                                PAGE_READONLY,
                                                0L,
                                                0L,
                                                (LPWSTR) NULL)))
        {
            ERROR_ASSERT(FALSE, "CreateFileMapping failed");
            goto pmfAllocMF_cleanup;
        }

        if (!(pmf->pvFileMapping = (PENHMETAHEADER) MapViewOfFile(pmf->hFileMap, FILE_MAP_READ, 0, 0, 0)))
        {
            ERROR_ASSERT(FALSE, "MapViewOfFile failed");
            goto pmfAllocMF_cleanup;
        }

        pmf->emfc.Init((PENHMETAHEADER) pmf->pvFileMapping, (UINT32) fileSize);

    }
    else if (fl & ALLOCMF_TRANSFER_BUFFER)
    {
// If this is our memory metafile from MDC, transfer it to MF.

        if(pb)
        {
            pmf->emfc.Init((PENHMETAHEADER) pb, ((PENHMETAHEADER) pb)->nBytes);

            // We now own the reference which we must free

            pmf->pvLocalCopy = (PVOID) pb;
        }
        else if(hFile)
        {
            pmf->emfc.Init(hFile, fileOffset, 0);

            // We now own the reference which we must now Close

            pmf->hFile = hFile;
        }
        else
        {
            ERROR_ASSERT(hFile != NULL, "pmfAllocMF: exepect hHandle or pb to be non-null\n");
            goto pmfAllocMF_cleanup;
        }

    }
    else
    {
// Otherwise, make a copy of memory metafile.

        if (!(pmf->pvLocalCopy = (PENHMETAHEADER) LocalAlloc(LMEM_FIXED, (UINT) ((PENHMETAHEADER) pb)->nBytes)))
            goto pmfAllocMF_cleanup;

        RtlCopyMemory((PBYTE) pmf->pvLocalCopy, pb, ((PENHMETAHEADER) pb)->nBytes);

        pmf->emfc.Init((PENHMETAHEADER) pmf->pvLocalCopy, ((PENHMETAHEADER) pb)->nBytes);

    }

// Verify metafile header

    pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
    {
        WARNING("pmfAllocMF: failed to get emf header\n");
        goto pmfAllocMF_cleanup;
    }

    if (!((PMRMETAFILE) pmrmf)->bValid())
    {
        ERROR_ASSERT(FALSE,
                "pmfAllocMF: Metafile has an invalid header; Failing\n");
        goto pmfAllocMF_cleanup;
    }

// Allocate and initialize the playback object handle table.
// The first entry of pht is initialized to hemf in PlayEnhMetaFile
// and EnumEnhMetaFile.

    if (!(pmf->pht
          = (PHANDLETABLE) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                      pmrmf->nHandles * sizeof(HANDLE))))
        goto pmfAllocMF_cleanup;

// Allocate a virtual device for transform computation.

    if (!(pmf->hdcXform = CreateICA((LPCSTR) "DISPLAY",
                                   (LPCSTR) NULL,
                                   (LPCSTR) NULL,
                                   (LPDEVMODEA) NULL)))
    {
        ERROR_ASSERT(FALSE, "CreateICA failed");
        goto pmfAllocMF_cleanup;
    }

// The transform DC must be in the advanced graphics mode.
// The world transform can only be set in the advanced graphics mode.

    if (!SetGraphicsMode(pmf->hdcXform, GM_ADVANCED))
        goto pmfAllocMF_cleanup;

// Everything is golden.

    pmfRc = pmf;

// Cleanup and go home.

pmfAllocMF_cleanup:

    if (!pmfRc)
        if (pmf)
        {
            if (fl & ALLOCMF_TRANSFER_BUFFER)
                pmf->pvLocalCopy = 0;    // let caller free the buffer.
            vFreeMF(pmf);
        }

    ERROR_ASSERT(pmfRc, "pmfAllocMF failed");
    return(pmfRc);
}

/******************************Public*Routine******************************\
* vFreeMF (pmf)
*
* This is a low level routine which frees the resouces in the MF.
*
* This function is intended to be called from the routines CloseEnhMetaFile
* and DeleteEnhMetaFile.
*
* Arguments:
*   pmf    - The MF to be freed.
*
* History:
*  Tue Jul 02 13:43:18 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID vFreeMF(PMF pmf)
{
    PUTS("vFreeMF\n");

    ASSERTGDI(pmf->ident == MF_IDENTIFIER, "Bad MF");

// Free the resources.

    if (pmf->hdcXform)
        DeleteDC(pmf->hdcXform);

    pmf->emfc.Term();

    if (pmf->pht)
    {
        // Objects created during play are freed in PlayEnhMetaFile and
        // EnumEnhMetaFile.

        PENHMETAHEADER pmrmf = pmf->emfc.GetEMFHeader();

        if (pmrmf)
        {
            for (WORD ii = 1; ii < pmrmf->nHandles; ii++)
            {
                ASSERTGDI(!pmf->pht->objectHandle[ii],
                "vFreeMF: Handle table not empty");
            }
        }

        if (LocalFree(pmf->pht))
        {
            ASSERTGDI(FALSE, "LocalFree failed");
        }
    }

    if (!pmf->bIsDiskFile())
    {
// Free memory metafile.

        if (pmf->pvLocalCopy && LocalFree(pmf->pvLocalCopy))
        {
            ASSERTGDI(FALSE, "LocalFree failed");
        }

        // If we are spooling, then the spooler needs to deal
        // with closing the file handle, otherwise we own it
        // and need to close it.

        if(!pmf->bIsEMFSpool())
        {
            if (pmf->hFile != INVALID_HANDLE_VALUE)
            {
                if (!CloseHandle(pmf->hFile))
                {
                    ASSERTGDI(FALSE, "CloseHandle failed");
                }
                else
                {
                    pmf->hFile = NULL;
                }
            }
        }
    }
    else
    {
// Unmap disk file.

        if (pmf->pvFileMapping && !UnmapViewOfFile(pmf->pvFileMapping))
        {
            ASSERTGDI(FALSE, "UmmapViewOfFile failed");
        }

        if (pmf->hFileMap)
        {
            if (!CloseHandle(pmf->hFileMap))
            {
                ASSERTGDI(FALSE, "CloseHandle failed");
            }
            else
            {
                pmf->hFileMap = NULL;
            }
        }

        if (pmf->hFile != INVALID_HANDLE_VALUE)
        {
            if (!CloseHandle(pmf->hFile))
            {
                ASSERTGDI(FALSE, "CloseHandle failed");
            }
            else
            {
                pmf->hFile = NULL;
            }
        }

    }

// Smash the identifier.

    pmf->ident = 0;

// Free the memory.

    if (LocalFree(pmf))
    {
        ASSERTGDI(FALSE, "LocalFree failed");
    }
}

/******************************Public*Routine******************************\
* vFreeMFAlt (pmf, bAllocBuffer)
*
* This is a low level routine which frees the resouces in the MF.
*
* This function is intended to be called from the routines InternalDeleteEnhMetaFile
*
* Arguments:
*   pmf    - The MF to be freed.
*   bAllocBuffer -  flag to free buffer
*
\**************************************************************************/

VOID vFreeMFAlt(PMF pmf, BOOL bAllocBuffer)
{
    PUTS("vFreeMF\n");

    ASSERTGDI(pmf->ident == MF_IDENTIFIER, "Bad MF");

    // Free the resources.

    if (pmf->hdcXform)
        DeleteDC(pmf->hdcXform);

    pmf->emfc.Term();

    if (pmf->pht)
    {
        // Objects created during play are freed in PlayEnhMetaFile and
        // EnumEnhMetaFile.

        PENHMETAHEADER pmrmf = pmf->emfc.GetEMFHeader();

        if (pmrmf)
        {
           for (WORD ii = 1; ii < pmrmf->nHandles; ii++)
           {
               ASSERTGDI(!pmf->pht->objectHandle[ii],
               "vFreeMF: Handle table not empty");
           }
        }

        if (LocalFree(pmf->pht))
        {
            ASSERTGDI(FALSE, "LocalFree failed");
        }
    }

    if (bAllocBuffer)
    {
       if (!pmf->bIsDiskFile())
       {
           // Free memory metafile.

           if (pmf->pvLocalCopy && LocalFree(pmf->pvLocalCopy))
           {
               ASSERTGDI(FALSE, "LocalFree failed");
           }

           if(!pmf->bIsEMFSpool())
           {
               // If we are spooling, then the spooler needs to deal
               // with closing the file handle, otherwise we own it
               // and need to close it.

               if (pmf->hFile != INVALID_HANDLE_VALUE)
               {
                   if (!CloseHandle(pmf->hFile))
                   {
                       ASSERTGDI(FALSE, "CloseHandle failed");
                   }
                   else
                   {
                       pmf->hFile = NULL;
                   }
               }
           }
       }
       else
       {
           // Unmap disk file.

           if (pmf->pvFileMapping && !UnmapViewOfFile(pmf->pvFileMapping))
           {
               ASSERTGDI(FALSE, "UmmapViewOfFile failed");
           }

           if (pmf->hFileMap)
           {
               if (!CloseHandle(pmf->hFileMap))
               {
                   ASSERTGDI(FALSE, "CloseHandle failed");
               }
               else
               {
                   pmf->hFileMap = NULL;
               }
           }
           
           if (pmf->hFile != INVALID_HANDLE_VALUE)
           {
               if (!CloseHandle(pmf->hFile))
               {
                   ASSERTGDI(FALSE, "CloseHandle failed");
               }
               else
               {
                   pmf->hFile = NULL;
               }
           }
       }

    }
    // Smash the identifier.

    pmf->ident = 0;

    // Free the memory.

    if (LocalFree(pmf))
    {
        ASSERTGDI(FALSE, "LocalFree failed");
    }
}

/******************************Public*Routine******************************\
* bMetaResetDC (hdc)
*
* Initialize the destination DC before playing a metafile to that DC.
*
* History:
*  Fri Nov 01 15:02:58 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL bMetaResetDC(HDC hdc)
{
// Make sure we do everything
// If the destination is a metafile DC, we want to embed
// the calls made in this function.

    POINT ptOrg;
    FLOAT eMiterLimit;

// Reset to default objects.

    SelectObject(hdc, GetStockObject(WHITE_BRUSH));
    SelectObject(hdc, GetStockObject(BLACK_PEN));
    SelectObject(hdc, GetStockObject(DEVICE_DEFAULT_FONT));
    SelectPalette(hdc,GetStockObject(DEFAULT_PALETTE),TRUE);

// Attributes cache.

    SetBkColor(hdc, 0xffffff);
    SetTextColor(hdc, 0);
    SetTextCharacterExtra(hdc, 0);
    SetBkMode(hdc, OPAQUE);

    SetPolyFillMode(hdc, ALTERNATE);
    SetROP2(hdc, R2_COPYPEN);
    SetStretchBltMode(hdc, BLACKONWHITE);
    SetTextAlign(hdc, 0);

// Reset server attributes.

    // Mapper flags.
    // Metafile it only if the previous mapper flags is not default.
    if (SetMapperFlagsInternal(hdc, 0) != 0)      // if the previous flags is
    {
        if (SetMapperFlags(hdc, 0) == GDI_ERROR)  // not default, set to default
        {
            ASSERTGDI(FALSE, "SetMapperFlags failed");
        }
    }

    SetBrushOrgEx(hdc, 0, 0, (LPPOINT) NULL);
    SetMiterLimit(hdc, 10.0f, (PFLOAT) NULL);
    SetTextJustification(hdc, 0, 0);
    SetArcDirection(hdc, AD_COUNTERCLOCKWISE);
    MoveToEx(hdc, 0, 0, (LPPOINT) NULL);

    return(TRUE);
}

/******************************Public*Routine******************************\
* bIsPoly16(pptl, cptl)
*
* Return TRUE if all the points in the poly array are 16-bit signed integers.
* Otherwise, it is FALSE.
*
* History:
*  Sat Mar 07 17:07:33 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL bIsPoly16(PPOINTL pptl, DWORD cptl)
{
    while (cptl--)
    {
    if
    (
        pptl->x < (LONG) (SHORT) MINSHORT
     || pptl->x > (LONG) (SHORT) MAXSHORT
     || pptl->y < (LONG) (SHORT) MINSHORT
     || pptl->y > (LONG) (SHORT) MAXSHORT
    )
        return(FALSE);
    pptl++;
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* imheAllocMHE(hdc, lhObject)
*
* Allocates a MHE from the Metafile Handle Table in the metafile DC,
* initializes fields in the MHE, and updates the object's metalink.
* Returns the MHE index or INVALID_INDEX on error.
*
* Since the first entry is reserved, index zero is never returned.
*
* When a object's metalink is first created, a 16-bit metafile object-link
* should be added to the begining of the metafile link as necessary.  The
* 16-bit metafile object-link should be removed as necessary when the last
* metalink is deleted.
*
* History:
*  Tue Aug 06 15:41:52 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

ULONG imheAllocMHE(HDC hdc, HANDLE lhObject)
{
    PMDC    pmdc = GET_PMDC(hdc);
    ULONG   imhe = INVALID_INDEX;
    ULONG   ii;
    PMHE    pmhe;

// Get critical for handle allocation.

    ENTERCRITICALSECTION(&semLocal);

// Make sure a handle is available.

    if (pmdc->imheFree == INVALID_INDEX)
    {
        // Allocate more handles up to the max size.

        PMHE    pmhe1;
        UINT    cmhe1;

        if (pmdc->cmhe == MHT_MAX_HANDLE_SIZE)
        {
            ERROR_ASSERT(FALSE, "imheAllocMHE: max handle table size reached");
            goto imheAllocMHE_exit;
        }

        cmhe1 = min((UINT) pmdc->cmhe + MHT_HANDLE_SIZE,
            (UINT) MHT_MAX_HANDLE_SIZE);

        if (!(pmhe1 = (PMHE) LocalReAlloc
                                (
                                pmdc->pmhe,
                                cmhe1 * sizeof(MHE),
                                LMEM_MOVEABLE
                                )
             )
           )
        {
            ERROR_ASSERT(FALSE, "LocalReAlloc failed");
            goto imheAllocMHE_exit;
        }

        pmdc->pmhe = pmhe1;

        // Initialize the new handles.

        ii = pmdc->imheFree = pmdc->cmhe;
        pmdc->cmhe = cmhe1;
        for ( ; ii < pmdc->cmhe; ii++)
        {
            pmdc->pmhe[ii].lhObject = (HANDLE) 0;
            pmdc->pmhe[ii].metalink.vInit(ii+1);
        }
        pmdc->pmhe[ii-1].metalink.vInit(INVALID_INDEX);
    }


    // First, make sure the object has a 16-bit metafile object-link.
    // we have this in brackets to reduce scope of pmetalink16
    {
        METALINK16 *pmetalink16 = pmetalink16Get(lhObject);

        if (pmetalink16 == NULL)
        {
            pmetalink16 = pmetalink16Create(lhObject);

            if (pmetalink16 == NULL)
            {
                ERROR_ASSERT(FALSE, "LocalAlloc failed");
                goto imheAllocMHE_exit;
            }

            ASSERTGDI
            (
                pmetalink16->metalink == 0
                 && pmetalink16->cMetaDC16 == 0
                 && pmetalink16->ahMetaDC16[0] == (HDC) 0,
                "imheAllocMHE: METALINK16 not initialized properly"
            );
        }

        imhe = pmdc->imheFree;
        pmhe = pmdc->pmhe + imhe;
        pmdc->imheFree = (ULONG) pmhe->metalink;

        ASSERTGDI(imhe != 0, "imheAllocMHE: index zero is reserved");
        ASSERTGDI(pmhe->lhObject == (HANDLE) 0, "imheAllocMHE: imheFree in use");

    // Update and add the metalink to the link list.

        pmhe->lhObject = lhObject;
        pmhe->metalink.vInit(pmetalink16->metalink);
        ((PMETALINK) &pmetalink16->metalink)->vInit((USHORT) imhe, H_INDEX(hdc));
    }

imheAllocMHE_exit:

// Leave the critical section.

    LEAVECRITICALSECTION(&semLocal);
    return(imhe);
}

/******************************Public*Routine******************************\
* vFreeMHE(hdc, imhe)
*
* Free up a MHE and insert it into the Metafile Handle Table free list.
* It also updates the object's metalink.
*
* When the last metalink is removed, the 16-bit metafile object-link should
* also be removed if it is not used.
*
* History:
*  Tue Aug 06 15:41:52 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID vFreeMHE(HDC hdc, ULONG imhe)
{
    PMETALINK16 pmetalink16;
    PMDC    pmdc = GET_PMDC(hdc);
    HANDLE  hobj;

    ASSERTGDI(imhe != 0, "vFreeMHE: index zero is reserved");

// Get critical for handle deallocation.

    ENTERCRITICALSECTION(&semLocal);

// Remove it from the object metalink friend list.

    hobj = pmdc->pmhe[imhe].lhObject;
    pmetalink16 = pmetalink16Get(hobj);

    ASSERTGDI(pmetalink16, "vFreeMHE: pmetalink16 Invalid");

    METALINK metalink(pmetalink16);

    ASSERTGDI(metalink.bValid(), "vFreeMHE: Invalid imhe");

    if (metalink.bEqual((USHORT) imhe, H_INDEX(hdc)))
    {
        pmetalink16->metalink = (ULONG) pmdc->pmhe[imhe].metalink;
    }
    else
    {
        while (!(metalink.pmetalinkNext())->bEqual((USHORT) imhe, H_INDEX(hdc)))
        {
            metalink.vNext();
            ASSERTGDI(metalink.bValid(), "vFreeMHE: Invalid imhe");
        }

        *(metalink.pmetalinkNext()) = pmdc->pmhe[imhe].metalink;
    }

// Add the handle to the free list.

    pmdc->pmhe[imhe].lhObject = (HANDLE) 0;
    pmdc->pmhe[imhe].metalink.vInit(pmdc->imheFree);
    pmdc->imheFree = imhe;

// If there is no more metalink, remove the 16-bit metafile object-link
// if it's not used.

    if (!pmetalink16->metalink
     && !pmetalink16->cMetaDC16)
    {
        if (!bDeleteMetalink16(hobj))
        {
            ASSERTGDI(FALSE, "LocalFree failed");
        }
    }

// Leave the critical section.

    LEAVECRITICALSECTION(&semLocal);
}

/******************************Public*Routine******************************\
* GdiConvertMetaFilePict
* GdiConvertEnhMetaFile
*
* A server handle is created that is an exact copy of the client
* MetaFilePict or EnhMetaFile data.  The caller (clipbrd) is responsible
* for deleting both the client and server copies when they are no longer
* needed.
*
* A MetaFilePict is a structure containing a metafile size and a handle
* to a metafile.  Both MetaFilePict and EnhMetaFile are used primarily by
* the clipboard interface.  When an app puts a MetaFilePict or an
* EnhMetaFile in the clipboard we have to create a server copy because
* the app can terminate and another application can still query the
* clipboard data.
*
* The format for the client-server data is as follows:
*
*   DWORD iType     MFEN_IDENTIFIER or MFPICT_IDENTIFIER
*   DWORD mm        used by MetaFilePict only
*   DWORD xExt      used by MetaFilePict only
*   DWORD yExt      used by MetaFilePict only
*   DWORD nBytes    number of bytes in pClientData
*   PBYTE pClientData   contains the metafile bits
*
* Returns a server handle that is a copy of the metafile data.
* Returns zero if an error occurs.
*
* History:
*  Wed Sep 16 09:42:22 1992     -by-    Hock San Lee    [hockl]
* Rewrote it.
*  28-Oct-1991   -by-    John Colleran    [johnc]
* Wrote it.
\**************************************************************************/

HANDLE GdiConvertMetaFilePict(HANDLE hmem)
{
    HANDLE      hRet = (HANDLE) 0;
    PMETAFILE16 pmf16;
    LPMETAFILEPICT lpmfp;

    PUTS("GdiConvertMetaFilePict\n");

// Get the METAFILEPICT

    lpmfp = (LPMETAFILEPICT) GlobalLock(hmem);
    if (!lpmfp)
    {
        WARNING("GdiConvertMetaFilePict GlobalLock(hmem) Failed\n");
        return((HANDLE) 0);
    }

    pmf16 = GET_PMF16(lpmfp->hMF);

// Validate the hmf field of the METAFILEPICT

    if (pmf16 == NULL)
    {
        WARNING("GdiConvertMetaFilePict invalid handle\n");
        GdiSetLastError(ERROR_INVALID_HANDLE);
        goto GCMFP_Exit;
    }

// Get the size of the metafile.

    ASSERTGDI(IsValidMetaHeader16(&pmf16->metaHeader),
    "GdiConvertMetaFilePict: Bad metafile");

    hRet = NtGdiCreateServerMetaFile(MFPICT_IDENTIFIER,
        pmf16->metaHeader.mtSize * sizeof(WORD), (PBYTE) pmf16->hMem,
        lpmfp->mm, lpmfp->xExt, lpmfp->yExt);

GCMFP_Exit:
    GlobalUnlock(hmem);
    ERROR_ASSERT(hRet, "GdiConvertMetaFilePict failed\n");
    return(hRet);
}


HANDLE GdiConvertEnhMetaFile(HENHMETAFILE hemf)
{
    HANDLE hRet;
    PMF    pmf;

    PUTS("GdiConvertEnhMetaFile\n");

    if (!(pmf = GET_PMF(hemf)))
    {
        WARNING("GdiConvertEnhMetaFile: bad hemf\n");
        return((HMETAFILE) 0);
    }

    PENHMETAHEADER pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
    {
        WARNING("GdiConvertEnhMetaFile: failed getting header\n");
        return((HMETAFILE) 0);
    }

    PBYTE pb = (PBYTE) pmf->emfc.ObtainPtr(0, pmrmf->nBytes);

    if(!pb)
    {
        WARNING("GdiConvertEnhMetaFile: failed getting data\n");
        return((HMETAFILE) 0);
    }

    hRet = NtGdiCreateServerMetaFile(MFEN_IDENTIFIER, pmrmf->nBytes,
            pb, 0, 0, 0);

    pmf->emfc.ReleasePtr(pb);

    ERROR_ASSERT(hRet, "GdiConvertEnhMetaFile failed");
    return((HMETAFILE) hRet);
}


/******************************Public*Routine******************************\
* GdiCreateLocalMetaFilePict
* GdiCreateLocalEnhMetaFile
*
* Creates a local MetaFilePict or EnhMetaFile handle that is a copy of
* the server handle.  The server handle can be either a standard metafile
* or an enhanced metafile.  The functions will perform metafile conversion
* to the requested format (MetaFilePict or EnhMetaFile) if necessary.
*
* The caller is responsible for deleting the local handle when it is no
* longer needed.  By Windows convention the app that recieves the
* MetaFilePict will delete it by first deleting the metafile and then
* freeing the global handle
*
* The format for the client-server data is as follows:
*
*   HANDLE hSrv         server handle (can be standard or enhanced metafile)
*   DWORD  iType        return MFPICT_IDENTIFIER or MFEN_IDENTIFIER
*   DWORD  mm           return by MetaFilePict only
*   DWORD  xExt         return by MetaFilePict only
*   DWORD  yExt         return by MetaFilePict only
*   DWORD  nBytes       zero to query size of metafile bits in pClientData.
*           otherwise it is the size of pClientData that is to
*           receive the metafile bits.
*   PBYTE  pClientData  to receive the metafile bits
*
* Returns a client MetaFilePict or EnhMetaFile handle that is a copy of
* the server metafile.  Returns zero if an error occurs
*
* History:
*  Wed Sep 16 09:42:22 1992     -by-    Hock San Lee    [hockl]
* Rewrote it.
*  28-Oct-1991   -by-    John Colleran    [johnc]
* Wrote it.
\**************************************************************************/


HANDLE GdiCreateLocalMetaFilePict(HANDLE hSrv)
{
    return(InternalCreateLocalMetaFile(hSrv, MFPICT_IDENTIFIER));
}


HENHMETAFILE GdiCreateLocalEnhMetaFile(HANDLE hSrv)
{
    return((HENHMETAFILE) InternalCreateLocalMetaFile((HANDLE) hSrv, MFEN_IDENTIFIER));
}


ULONG GetServerMetaFileBits(HANDLE hSrv, DWORD nBytes, PBYTE pMFBits,
    PDWORD piType, PDWORD pmm, PDWORD pxExt, PDWORD pyExt)
{
    ULONG cRet = 0;

    PUTS("GetServerMetaFileBits\n");

    cRet = NtGdiGetServerMetaFileBits(
                                      hSrv,
                                      (ULONG)nBytes,
                                      (LPBYTE)pMFBits,
                                      piType,
                                      pmm,
                                      pxExt,
                                      pyExt);

    return(cRet);
}


HANDLE InternalCreateLocalMetaFile(HANDLE hSrv, DWORD iTypeReq)
{
    DWORD  iTypeSrv;
    DWORD  mm;
    DWORD  xExt;
    DWORD  yExt;
    ULONG  cbData;
    PBYTE          pData = (PBYTE) NULL;
    LPMETAFILEPICT lpmfp = (LPMETAFILEPICT) NULL;
    HANDLE     hRet  = (HANDLE) 0;

    ASSERTGDI(iTypeReq == MFEN_IDENTIFIER || iTypeReq == MFPICT_IDENTIFIER,
    "InternalCreateLocalMetaFile: bad metafile type\n");

    if (!hSrv)
    {
        VERIFYGDI(FALSE, "InternalCreateLocalMetaFile: hSrv is 0");
        return((HANDLE) 0);
    }

// Get the size of the server metafile bits.

    cbData = GetServerMetaFileBits(hSrv, 0, (PBYTE) NULL, (PDWORD) NULL,
                                   (PDWORD) NULL, (PDWORD) NULL, (PDWORD) NULL);
    if (!cbData)
    {
        ASSERTGDI(FALSE, "InternalCreateLocalMetaFile: size query failed");
        return((HANDLE) 0);
    }

// Allocate a buffer to retrieve the metafile bits.

    pData = (PBYTE) LocalAlloc(LMEM_FIXED, (UINT) cbData);
    if (!pData)
        return((HANDLE) 0);

// Retrieve the server metafile bits.

    if (GetServerMetaFileBits(hSrv, cbData, pData, &iTypeSrv, &mm, &xExt, &yExt)
    != cbData)
    {
        ASSERTGDI(FALSE, "InternalCreateLocalMetaFile: not all data returned");
        goto ICLMF_exit;
    }

// Allocate the MetaFilePict structure if necessary.

    if (iTypeReq == MFPICT_IDENTIFIER)
    {
    lpmfp = (LPMETAFILEPICT) GlobalAlloc(GMEM_FIXED, sizeof(METAFILEPICT));
    if (!lpmfp)
    {
        VERIFYGDI(FALSE, "InternalCreateLocalMetaFile: GlobalAlloc failed\n");
        goto ICLMF_exit;
    }
    }

// Create the same type of metafile as requested.

    switch (iTypeSrv)
    {
    case MFEN_IDENTIFIER:
        if (iTypeReq == MFPICT_IDENTIFIER)
        {
            UINT   cbMeta16;
            LPBYTE lpMeta16;
            HDC    hdcICScreen;
            HENHMETAFILE   hemf;
            PENHMETAHEADER pEMH = (PENHMETAHEADER) pData;

            PUTS("InternalCreateLocalMetaFile: EMF -> MFPICT\n");

            lpmfp->mm   = MM_ANISOTROPIC;
            lpmfp->xExt = (DWORD) (pEMH->rclFrame.right  - pEMH->rclFrame.left);
            lpmfp->yExt = (DWORD) (pEMH->rclFrame.bottom - pEMH->rclFrame.top );

            if (hemf = SetEnhMetaFileBitsAlt((HLOCAL) pData, NULL, NULL, 0))
                pData = (PBYTE) NULL;   // pData has been moved to the metafile
            else
                VERIFYGDI(hemf, "InternalCreateLocalMetaFile: SetEnhMetaFileBitsAlt failed");

            hdcICScreen = CreateICA((LPCSTR)"DISPLAY", (LPCSTR)NULL,
                                    (LPCSTR)NULL, (LPDEVMODEA)NULL);
            VERIFYGDI(hdcICScreen, "InternalCreateLocalMetaFile: CreateICA failed");

            cbMeta16 = GetWinMetaFileBits(hemf, 0, (LPBYTE) NULL,
            MM_ANISOTROPIC, hdcICScreen);
            if (cbMeta16)
            {
                lpMeta16 = (PBYTE) LocalAlloc(LMEM_FIXED, cbMeta16);

                if (lpMeta16)
                {
                    if ((GetWinMetaFileBits(hemf, cbMeta16, lpMeta16, MM_ANISOTROPIC, hdcICScreen)
                        != cbMeta16)
                        // use the memory handle for the metafile!
                        || !(lpmfp->hMF = SetMetaFileBitsAlt((HLOCAL) lpMeta16)))
                    {
                        VERIFYGDI(FALSE, "InternalCreateLocalMetaFile: SetMetaFileBitsAlt failed");
                        LocalFree((HANDLE) lpMeta16);
                    }
                    else
                        hRet = (HANDLE) lpmfp;
                }
            }

            DeleteEnhMetaFile(hemf);
                DeleteDC(hdcICScreen);
        }
        else
        {
            PUTS("InternalCreateLocalMetaFile: EMF -> EMF\n");

            if (hRet = (HANDLE) SetEnhMetaFileBitsAlt((HLOCAL) pData, NULL, NULL, 0))
                pData = (PBYTE) NULL;   // pData has been moved to the metafile
            else
            {
                VERIFYGDI(FALSE, "InternalCreateLocalMetaFile: SetEnhMetaFileBitsAlt failed");
            }
        }
        break;

    case MFPICT_IDENTIFIER:
        if (iTypeReq == MFPICT_IDENTIFIER)
        {
            PUTS("InternalCreateLocalMetaFile: MFPICT -> MFPICT\n");

            lpmfp->mm   = mm;
            lpmfp->xExt = xExt;
            lpmfp->yExt = yExt;

            if (lpmfp->hMF = SetMetaFileBitsAlt((HLOCAL) pData))
            {
                pData = (PBYTE) NULL;   // pData has been moved to the metafile
                hRet  = (HANDLE) lpmfp;
            }
            else
                VERIFYGDI(FALSE, "InternalCreateLocalMetaFile: SetMetaFileBitsAlt failed");
        }
        else
        {
            METAFILEPICT mfp;

            PUTS("InternalCreateLocalMetaFile: MFPICT -> EMF\n");

            mfp.mm   = mm;
            mfp.xExt = xExt;
            mfp.yExt = yExt;
            mfp.hMF  = (HMETAFILE) 0;

            hRet = (HANDLE) SetWinMetaFileBits((UINT) cbData, pData, (HDC) 0, &mfp);
            VERIFYGDI(hRet, "InternalCreateLocalMetaFile: SetWinMetaFileBits failed");
        }
        break;

    default:
        ASSERTGDI(FALSE, "InternalCreateLocalMetaFile unknown metafile type\n");
        break;
    }

// Cleanup if we failed

ICLMF_exit:
    if (!hRet && lpmfp)
    {
        if (GlobalFree((HANDLE) lpmfp))
        {
            ASSERTGDI(FALSE, "InternalCreateLocalMetaFile: GlobalFree failed");
        }
    }

    if (pData)
    {
        LocalFree((HANDLE) pData);
    }

    ERROR_ASSERT(hRet, "InternalCreateLocalMetaFile failed");
    return(hRet);
}

/******************************Public*Routine******************************\
* GetRandomRgnBounds
*
* Wrote it.
*  Fri Jul 24 09:35:24 1992     -by-    Hock San Lee    [hockl]
\**************************************************************************/

BOOL APIENTRY GetRandomRgnBounds(HDC hdc,PRECTL prcl,INT iType)
{
    BOOL  bRet = FALSE;
    HRGN  hrgnTmp;

// We should be able to get the region handle without creating a copy!
// Make a copy of the specified clip region.

    if (!(hrgnTmp = CreateRectRgn(0, 0, 0, 0)))
        return(bRet);

    switch (GetRandomRgn(hdc, hrgnTmp, (int) iType))
    {
    case -1:    // error
        WARNING("GetRandomRgn failed");
        break;

    case 0: // no initial clip region
        *prcl = rclInfinity;
        bRet = TRUE;
        break;

    case 1: // has initial clip region
        bRet = (GetRgnBox(hrgnTmp, (LPRECT) prcl) != RGN_ERROR);
        break;
    }

    if (!DeleteObject(hrgnTmp))
    {
        ASSERTGDI(FALSE, "DeleteObject failed");
    }

    return(bRet);
}

/**************************************************************************\
 *
 * misc statistics
 *
\**************************************************************************/

#if DBG

    ULONG gcMetalinks    = 0;
    ULONG gcQueries      = 0;
    ULONG gcQueriesExtra = 0;
    ULONG gcHits         = 0;

    #define INC_QUERIES  (++gcQueries)
    #define INC_QUERIESX (++gcQueries)
    #define INC_HITS     (++gcHits)
    #define INC_LINKS    (++gcMetalinks)
    #define DEC_LINKS    (--gcMetalinks,++gcHits)

    BOOL  gbdbgml = 0;
#else
    #define gbdbgml FALSE

    #define INC_QUERIES
    #define INC_QUERIESX
    #define INC_HITS
    #define INC_LINKS
    #define DEC_LINKS
#endif

/******************************Public*Routine******************************\
* PLINK plinkGet()
*
*   This routine locks semLocal critical section while traversing the table.
*
* History:
*  14-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PLINK plinkGet(
    HANDLE h
    )
{
    PLINK plink = NULL;

// see if we need to search.  We do a quick test before entering the critical
// section to see if the cache entry is empty.  For cases where the entry is
// not in the cache, the entry will usualy be empty.  We need to recheck the
// value once we are in the critical section to make sure it hasn't gone away

    if (h && aplHash[LINK_HASH_INDEX(h)])
    {
        INC_QUERIES;

        ENTERCRITICALSECTION(&semLocal);

        plink = aplHash[LINK_HASH_INDEX(h)];

        while (plink && DIFFHANDLE(plink->hobj,h))
        {
            INC_QUERIESX;

            plink = plink->plinkNext;
        }

        LEAVECRITICALSECTION(&semLocal);

        if (plink)
        {
            INC_HITS;
        }
    }

#if DBG
    if (gbdbgml)
        DbgPrint("plinkGet(%p) = %p, ihash = %ld\n",
             h,plink,
             LINK_HASH_INDEX(h));
#endif
    return(plink);
}

/******************************Public*Routine******************************\
* PLINK plinkCreate()
*
*   Note that this does not need to grab semLocal.  All callers must already
*   have done that.
*
* History:
*  14-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PLINK plinkCreate(
    HANDLE h,
    ULONG  ulSize
    )
{
    PLINK plink = (PLINK)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,ulSize);

    if (plink)
    {
        INC_LINKS;

        plink->plinkNext = aplHash[LINK_HASH_INDEX(h)];
        plink->hobj      = h;

        aplHash[LINK_HASH_INDEX(h)] = plink;
    }

#if DBG
    if (gbdbgml)
        DbgPrint("plinkCreate(%p) = %p, ihash = %ld\n",
             h,plink,
             LINK_HASH_INDEX(h));
#endif

    return(plink);
}

/******************************Public*Routine******************************\
* BOOL bDeletelink()
*
*   This routine locks semLocal critical section while traversing the table.
*
* History:
*  14-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL bDeleteLink(
    HANDLE h
    )
{
    BOOL  bSuccess = FALSE;
    PLINK plink    = NULL;

    if (h)
    {
        ENTERCRITICALSECTION(&semLocal);

        plink = aplHash[LINK_HASH_INDEX(h)];

        if (plink)
        {
            INC_QUERIES;

        // see if it is the first on the list.

            if (SAMEHANDLE(plink->hobj,h))
            {
                aplHash[LINK_HASH_INDEX(h)] = plink->plinkNext;
                bSuccess = TRUE;
                DEC_LINKS;
            }
            else
            {
            // it isn't the first so lets run the list.  We know pmetalink16 is
            // valid and that it is not the element

                while (plink->plinkNext)
                {
                    INC_QUERIESX;

                    if (SAMEHANDLE(plink->plinkNext->hobj,h))
                    {
                        PLINK plinkDel   = plink->plinkNext;
                        plink->plinkNext = plinkDel->plinkNext;

                        plink = plinkDel;  // so we can delete it.
                        bSuccess = TRUE;

                        DEC_LINKS;
                        break;
                    }

                    plink = plink->plinkNext;
                }
            }

        }

        LEAVECRITICALSECTION(&semLocal);

        if (bSuccess)
            LocalFree(plink);
    }
#if DBG
    if (gbdbgml)
        DbgPrint("bDeleteLink(%p) = %p, ihash = %ld\n",
             h,plink,
             LINK_HASH_INDEX(h));
#endif
    return(bSuccess);
}


/******************************Public*Routine******************************\
* PMETALINK16 pmetalink16Resize()
*
*   This routine locks semLocal critical section while traversing the table.
*
* History:
*  14-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PMETALINK16 pmetalink16Resize(
    HANDLE h,
    int    cObj
    )
{
    PMETALINK16 pmetalink16 = NULL;
    int cj = sizeof(METALINK16) + sizeof(HDC) * (cObj-1);

    if (h)
    {
        ENTERCRITICALSECTION(&semLocal);

        pmetalink16 = (PMETALINK16)aplHash[LINK_HASH_INDEX(h)];

        if (pmetalink16)
        {
            INC_QUERIES;

        // see if it is the first on the list.

            if (SAMEHANDLE(pmetalink16->hobj,h))
            {
                pmetalink16 = (PMETALINK16)LocalReAlloc(pmetalink16,cj,LMEM_MOVEABLE);
                if (pmetalink16)
                    aplHash[LINK_HASH_INDEX(h)] = (PLINK)pmetalink16;
            }
            else
            {
            // it isn't the first so lets run the list.  We know pmetalink16 is
            // valid and that it is not the element

                while (pmetalink16->pmetalink16Next)
                {
                    INC_QUERIESX;

                    if (SAMEHANDLE(pmetalink16->pmetalink16Next->hobj,h))
                    {
                        PMETALINK16 ptmpmetalink16;

                        ptmpmetalink16 = (PMETALINK16)LocalReAlloc(
                                    pmetalink16->pmetalink16Next,cj,LMEM_MOVEABLE);

                        if (ptmpmetalink16)
                        {
                            pmetalink16->pmetalink16Next = ptmpmetalink16;
                            pmetalink16 = pmetalink16->pmetalink16Next;
                        }
                        else
                        {
                            pmetalink16 = ptmpmetalink16;
                        }
                        break;
                    }

                    pmetalink16 = pmetalink16->pmetalink16Next;
                }
            }
        }

        LEAVECRITICALSECTION(&semLocal);
    }

#if DBG
    if (gbdbgml)
        DbgPrint("pmetalink16Resize(%p) = %p, ihash = %ld\n",
             h,pmetalink16,
             aplHash[LINK_HASH_INDEX(h)]);
#endif
    return(pmetalink16);
}

/******************************Public*Routine******************************\
*
* History:
*  03-Aug-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PMDC pmdcGetFromHdc(
    HDC hdc)
{
    PLDC pldc = pldcGet(hdc);

    return((PMDC)(pldc ? pldc->pvPMDC : NULL));
}

/******************************Public*Routine******************************\
* HANDLE hCreateClientObjLink()
*
*   ClientObjLinks are just associations of a server handle with a client pointer.
*
* History:
*  17-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HANDLE hCreateClientObjLink(
    PVOID pv,
    ULONG ulType)
{
    HANDLE h = CreateClientObj(ulType);

    if (h)
    {
        PLINK plink;

        ENTERCRITICALSECTION(&semLocal);

        plink = plinkCreate(h,sizeof(LINK));

        LEAVECRITICALSECTION(&semLocal);

        if (plink)
        {
            plink->pv = pv;
        }
        else
        {
            DeleteClientObj(h);
            h = NULL;
        }
    }

#if DBG
    if (gbdbgml)
        DbgPrint("hCreateClientObjLink = %p\n",h);
#endif
    return(h);
}

/******************************Public*Routine******************************\
* PVOID pvClientObjGet()
*
*   Given a handle, find the client pv field of the client object.  The GRE
*   type of the handle will be CLIENTOBJ_TYPE.
*
* History:
*  18-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PVOID pvClientObjGet(
    HANDLE h,
    DWORD  dwLoType)
{
    if (LO_TYPE(h) == dwLoType)
    {
        PLINK plink = plinkGet(h);

    #if DBG
        if (gbdbgml)
            DbgPrint("pvClientObjGet(%p) = %p\n",h,plink ? plink->pv : NULL);
    #endif

        if (plink)
        {
            return(plink->pv);
        }
    }
    else
    {
        WARNING1("pvClientObjGet (metafile stuff) - invalid handle\n");
    }

    GdiSetLastError(ERROR_INVALID_HANDLE);
    return(NULL);
}

/******************************Public*Routine******************************\
* BOOL bDeleteClientObjLink()
*
*
* History:
*  18-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL bDeleteClientObjLink(
    HANDLE h)
{
#if DBG
    if (gbdbgml)
        DbgPrint("bDeleteClientObjLink = %p\n",h);
#endif

    if (bDeleteLink(h))
    {
        DeleteClientObj(h);
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\mfdc.cxx ===
/*************************************************************************\
* Module Name: mfdc.cxx
*
* This file contains the member functions for metafile DC class defined
* in mfdc.hxx.
*
* Created: 12-June-1991 13:46:00
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\*************************************************************************/

#define NO_STRICT

extern "C" {
#if defined(_GDIPLUS_)
#include    <gpprefix.h>
#endif

#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <stddef.h>
#include    <windows.h>    // GDI function declarations.
#include    <winerror.h>
#include    "firewall.h"
#define __CPLUSPLUS
#include    <winspool.h>
#include    <wingdip.h>
#include    "ntgdistr.h"
#include    "winddi.h"
#include    "hmgshare.h"
#include    "icm.h"
#include    "local.h"   // Local object support.
#include    "gdiicm.h"
#include    "metadef.h" // Metafile record type constants.

}

#include    "rectl.hxx"
#include    "mfdc.hxx"  // Metafile DC class declarations.

extern RECTL rclNull;   // METAFILE.CXX

#define MF_CHECK_RECORDMEMORY_LIMIT 0x00010000

 
VOID METALINK::vInit(ULONG metalink)
{
    imhe = ((METALINK *) &metalink)->imhe;
    ihdc = ((METALINK *) &metalink)->ihdc;
}


/******************************Public*Routine******************************\
* void * MDC::pvNewRecord(nSize)
*
* Allocate a metafile record from memory buffer.
* Also set the size field in the metafile record.  If a fatal error
* has occurred, do not allocate new record.
*
* History:
*  Thu Jul 18 11:19:20 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

void * MDC::pvNewRecord(DWORD nSize)
{
#if DBG
    static DWORD cRcd = 0;

    PUTSX("MDC::pvNewRecord %ld \n", cRcd++);
#endif

// If a fatal error has occurred, do not allocate any more.

    if (fl & MDC_FATALERROR)
        return((void *) 0);

// Before we allocate a new record, commit the previous bounds record
// if necessary.

    if (fl & MDC_DELAYCOMMIT)
    {
        // Clear the flag.

        fl &= ~MDC_DELAYCOMMIT;

        PENHMETABOUNDRECORD pmrb = (PENHMETABOUNDRECORD) GetNextRecordPtr(sizeof(ENHMETABOUNDRECORD));

        if(pmrb)
        {
            // Get and reset bounds.
            // See also MDC::vFlushBounds.

            if (GetBoundsRectAlt(hdcRef, (LPRECT) &pmrb->rclBounds, (UINT) (DCB_RESET | DCB_WINDOWMGR))
                == DCB_SET)
            {
                // Need to intersect bounds with current clipping region first

                *((PERECTL) &pmrb->rclBounds) *= *perclMetaBoundsGet();
                *((PERECTL) &pmrb->rclBounds) *= *perclClipBoundsGet();

                // Make it inclusive-inclusive.

                pmrb->rclBounds.right--;
                pmrb->rclBounds.bottom--;

                // Accumulate bounds to the metafile header.

                if (!((PERECTL) &pmrb->rclBounds)->bEmpty())
                    *((PERECTL) &mrmf.rclBounds) += pmrb->rclBounds;
                else
                    pmrb->rclBounds = rclNull;
            }
            else
            {
                pmrb->rclBounds = rclNull;
            }

            vCommit(*(PENHMETARECORD) pmrb);

            ASSERTGDI(!(fl & MDC_FATALERROR),
                "MDC::pvNewRecord: Fatal error has occurred");

            ReleasePtr(pmrb);
        }
        else
        {
            WARNING("MDC::pvNewRecord() failed to get new record\n");
            return(NULL);
        }
    }

// If there is enough free buffer space, use it.

    if (iMem + nSize > nMem)
    {
    // Not enough free buffer space.  Flush the filled buffer if it is
    // a disk metafile.

        if (bIsDiskFile())
            if (!bFlush())
                return((void *) 0);

    // Realloc memory buffer if the free buffer is still too small.

        if (iMem + nSize > nMem)
        {
            ULONG nMemNew, sizeNeeded, sizeExtra;

            sizeNeeded = (nSize + MF_BUFSIZE_INC - 1) / MF_BUFSIZE_INC * MF_BUFSIZE_INC;

            if (!bIsEMFSpool())
            {
                //
                // When not EMF spooling, use the following heuristics:
                //  If current size <= 64K, enlarge the buffer by extra 16K 
                //  Else, enlarge the buffer by extra 25%
                //

                sizeExtra = (nMem > 0x10000) ? (nMem >> 2) : MF_BUFSIZE_INC;

                nMemNew = nMem + sizeExtra + sizeNeeded;
            }
            else
            {
                //
                // When EMF spooling, use the more aggressive heuristics:
                //  If current size <= 1MB, double the buffer
                //  Else, enlarge the buffer by 50% with a cap of 4MB

                if (nMem > 0x100000)
                {
                    sizeExtra = nMem >> 1;

                    if (sizeExtra > 0x400000)
                        sizeExtra = 0x400000;
                }
                else
                    sizeExtra = nMem;
                    
                nMemNew = nMem + max(sizeNeeded, sizeExtra);
            }

            if (!ReallocMem(nMemNew))
            {
                ERROR_ASSERT(FALSE, "ReallocMem failed\n");
                return NULL;
            }
        }
    }

// Zero the last dword.  If the record does not use up all bytes in the
// last dword, the unused bytes will be zeros.

    PVOID pvRecord = GetNextRecordPtr(nSize);

    if(pvRecord)
    {
        ((PDWORD) pvRecord)[nSize / 4 - 1] = 0;

    // Set the size field and return the pointer to the new record.

        ((PENHMETARECORD) pvRecord)->nSize = nSize;

        // WINBUG 365051 4-10-2001 pravins Need to modify usage of pvNewRecord() to release ptr
        // We should not be doing the release here.  We should have users of pvNewRecord()
        // call ReleasePtr when they are done.  This requires a bunch of edits in metarec.cxx
        // and mestsup.cxx.

        ReleasePtr(pvRecord);
    }
    else
    {
        WARNING("MDC::pvNewRecord() failed to get next record ptr\n");
    }

    return pvRecord;
}


BOOL
MDC::ReallocMem(
    ULONG newsize
    )

/*++

Routine Description:

    Resize the memory buffer used to hold EMF data

Arguments:

    newsize - new size of EMF memory buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    if (bIsEMFSpool())
    {
        ENHMETAHEADER  *pNewHeader;

        if(!((EMFSpoolData *) hData)->ResizeEMFData(newsize))
            return FALSE;

    }
    else
    {
        HANDLE hMemNew;

        if ((hMemNew = LocalReAlloc(hData, newsize, LMEM_MOVEABLE)) == NULL)
        {
            ERROR_ASSERT(FALSE, "LocalReAlloc failed");
            return FALSE;
        }

        hData = hMemNew;
    }

    nMem = newsize;
    return TRUE;
}


/******************************Public*Routine******************************\
* BOOL MDC::bFlush()
*
* Flush the filled memory buffer to disk.
*
* History:
*  Thu Jul 18 11:19:20 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MDC::bFlush()
{
    ULONG   nWritten ;

    PUTS("MDC::bFlush\n");
    PUTSX("\tnFlushSize  = %ld\n", (ULONG)iMem);
    PUTSX("\tnBufferSize = %ld\n", (ULONG)nMem);

    ASSERTGDI(bIsDiskFile(), "MDC::bFlush: Not a disk metafile");
    ASSERTGDI(!(fl & MDC_FATALERROR), "MDC::bFlush: Fatal error has occurred");

// WriteFile handles a null write correctly.

    if (!WriteFile(hFile, hData, iMem, &nWritten, (LPOVERLAPPED) NULL)
     || nWritten != iMem)
    {
// The write error here is fatal since we are doing record buffering and
// have no way of recovering to a previous state.

        ERROR_ASSERT(FALSE, "MDC::bFlush failed");
        fl |= MDC_FATALERROR;
        return(FALSE);
    }
    iMem = 0L;
    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID MDC::vAddToMetaFilePalette(cEntries, pPalEntriesNew)
*
* Add new palette entries to the metafile palette.
*
* When new palette entries are added to a metafile in CreatePalette or
* SetPaletteEntries, they are also accumulated to the metafile palette.
* The palette is later returned in GetEnhMetaFilePaletteEntries when an
* application queries it.  It assumes that the peFlags of the palette entries
* are zeroes.
*
* A palette color is added to the metafile palette only if it is not a
* duplicate.  It uses a simple linear search algorithm to determine if
* a duplicate palette exists.
*
* History:
*  Mon Sep 23 14:27:25 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID MDC::vAddToMetaFilePalette(UINT cEntries, PPALETTEENTRY pPalEntriesNew)
{
    UINT  ii;

    PUTS("vAddToMetaFilePalette\n");

    while (cEntries--)
    {
        ASSERTGDI(pPalEntriesNew->peFlags == 0,
            "MDC::vAddToMetaFilePalette: peFlags not zero");

        // Look for duplicate.

        for (ii = 0; ii < iPalEntries; ii++)
        {
            ASSERTGDI(sizeof(PALETTEENTRY) == sizeof(DWORD),
                "MDC::vAddToMetaFilePalette: Bad size");

            if (*(PDWORD) &pPalEntries[ii] == *(PDWORD) pPalEntriesNew)
                break;
        }

        // Add to the metafile palette if not a duplicate.

        if (ii >= iPalEntries)
        {
            pPalEntries[iPalEntries] = *pPalEntriesNew;
            iPalEntries++;              // Advance iPalEntries for next loop!
        }

        pPalEntriesNew++;
    }
}

/******************************Public*Routine******************************\
* VOID METALINK::vNext()
*
* Update *this to the next metalink.
*
* History:
*  Wed Aug 07 09:28:54 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID METALINK::vNext()
{
    PUTS("METALINK::vNext\n");
    ASSERTGDI(bValid(), "METALINK::vNext: Invalid metalink");

    PMDC pmdc = pmdcGetFromIhdc(ihdc);
    ASSERTGDI(pmdc,"METALINK::vNext - invalid pmdc\n");

    if (pmdc == NULL)
        ZeroMemory(this,sizeof(*this)); // Make it invalid so bValid will fail
    else
        *this = pmdc->pmhe[imhe].metalink;
}

/******************************Public*Routine******************************\
* METALINK * METALINK::pmetalinkNext()
*
* Return the pointer to the next metalink.
*
* History:
*  Wed Aug 07 09:28:54 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

METALINK * METALINK::pmetalinkNext()
{
    PUTS("METALINK::pmetalinkNext\n");
    ASSERTGDI(bValid(), "METALINK::pmetalinkNext: Invalid metalink");

    PMDC pmdc = pmdcGetFromIhdc(ihdc);
    ASSERTGDI(pmdc,"METALINK::vNext - invalid pmdc\n");

    return(&pmdc->pmhe[imhe].metalink);
}

VOID EMFContainer::Init(ENHMETAHEADER * inHdr, UINT32 dataSize)
{
    dwRefCount = 0;

    pemfhdr = inHdr;
    dwHdrSize = dataSize;

    pvWindow = NULL;
    dwWindowOffset = 0;
    dwWindowSize = 0;

    hFile = NULL;
}

BOOL EMFContainer::Init(HANDLE inFile, UINT64 inHdrOffset, UINT64 inFileSize)
{
    BOOL bResult = FALSE;

    dwRefCount = 0;

    pemfhdr = NULL;
    dwHdrSize = 0;

    pvWindow = NULL;
    dwWindowOffset = 0;
    dwWindowSize = 0;

    hFile = inFile;
    hFileMapping = NULL;
    pvHdr = NULL;

    qwHdrOffset = inHdrOffset;
    qwFileSize = inFileSize;

    if(qwFileSize != 0 || GetFileSizeEx(hFile, (LARGE_INTEGER *)  &qwFileSize))
    {
        hFileMapping = CreateFileMappingW(hFile,
                                     NULL,
                                     PAGE_READWRITE,
                                     HIDWORD(qwFileSize),
                                     LODWORD(qwFileSize),
                                     NULL);

        if(hFileMapping != NULL)
        {
            UINT64  qwOffset = qwHdrOffset;
            UINT32   dwSize = sizeof(ENHMETAHEADER);

            pvHdr = pvMapView(&qwOffset, &dwSize);

            if(pvHdr)
            {
                UINT32 dwViewOffset = (UINT32) (qwHdrOffset - qwOffset);

                pemfhdr = (PENHMETAHEADER) ((PBYTE) pvHdr + dwViewOffset);
                dwHdrSize = dwSize - dwViewOffset;

                bResult = TRUE;
            }
        }

    }

    if(!bResult)
        Term();

    return bResult;

}

VOID EMFContainer::Term()
{
    // Free any locally allocated resources

    if(hFile)
    {
        // We were using mapped views of the file

        if(hFileMapping)
        {
            if(!CloseHandle(hFileMapping))
            {
                WARNING("EMFContainer::Term() failed to close file mapping\n");
            }
            hFileMapping = NULL;
        }

        if(pvHdr != NULL)
        {
            if(!UnmapViewOfFile(pvHdr))
            {
                WARNING("EMFContainer::Term() Failed to unmap header view\n");
            }
            pvHdr = NULL;
        }

        if(pvWindow != NULL)
        {
            if(!UnmapViewOfFile(pvWindow))
            {
                WARNING("EMFContainer::Term() Failed to unmap window view\n");
            }
            pvWindow = NULL;
        }

        hFile = NULL;

    }

    pemfhdr = NULL;
    dwHdrSize = 0;

}

BOOL bProbeAndPageInAddressRange(BYTE *pb, UINT inSize)
{
    BOOL bRet = TRUE;

    if (inSize == 0)
        return bRet;

    __try
    {
        DWORD dwPagesize = GetSystemPageSize( );
        BYTE bData;
        BYTE *pbLoc = pb;
        BYTE *pbEnd = pbLoc + ( (inSize < MF_CHECK_RECORDMEMORY_LIMIT) ? inSize : MF_CHECK_RECORDMEMORY_LIMIT );

        while (pbLoc < pbEnd)
        {
            bData = *pbLoc;
            pbLoc += dwPagesize;
        }
        pbEnd--;
        bData = *pbEnd;
    }
    __except( GetExceptionCode() == STATUS_IN_PAGE_ERROR ||
              GetExceptionCode() == STATUS_ACCESS_VIOLATION) 
    {
        EMFVALFAIL(("bProbeAndPageInAddressRange:  (%p) [%08x] Failed\n", pb, inSize));
        bRet = FALSE;
    }
    return bRet;
}

PVOID EMFContainer::ObtainPtr(UINT inOffset, UINT inSize)
{
    if(dwRefCount > 1)
    {
        WARNING("Obtaining record with non-zero ref count\n");
        return NULL;
    }

    dwRefCount++;

    if(inOffset < dwHdrSize && inSize <= (dwHdrSize - inOffset))
    {
        if (bProbeAndPageInAddressRange((PBYTE) pemfhdr + inOffset, inSize))
            return (PVOID) ((PBYTE) pemfhdr + inOffset);
        else
        {
            --dwRefCount;
            return NULL;
        }
    }

    if(!hFile)
    {
        WARNING("EMFContainer::ObtainPtr() Attempt to obtain ptr past end of memory EMF\n");
        dwRefCount--;
        return NULL;
    }

    if(inOffset < dwWindowOffset ||
       (inOffset + inSize) > (dwWindowOffset + dwWindowSize))
    {

        if(pvWindow && !UnmapViewOfFile(pvWindow))
        {
            WARNING("EMFContainer::ObtainPtr() failed to unmap window view\n");
        }

        UINT64 qwOffset = qwHdrOffset + inOffset;

        dwWindowSize = inSize;

        pvWindow = pvMapView(&qwOffset, &dwWindowSize);

        if(!pvWindow)
        {
            WARNING("EMFContainer::ObtainPtr() failed to map window view\n");
            dwRefCount--;
            return NULL;
        }

        if(qwOffset < qwHdrOffset)
        {
            dwWindowUnusable = (UINT32) (qwHdrOffset -  qwOffset);

            ASSERTGDI(dwWindowUnusable < dwWindowSize, "EMFContainer::ObtainPtr() Unexpected dwUnusable value\n");

            dwWindowSize -= dwWindowUnusable;
            dwWindowOffset = 0;

        }
        else
        {
            dwWindowUnusable = 0;
            dwWindowOffset = (UINT32) (qwOffset - qwHdrOffset);
        }

        if(inOffset < dwWindowOffset ||
           (inOffset + inSize) > (dwWindowOffset + dwWindowSize))
        {
            WARNING("EMFContainer::ObtainPtr() something went really wrong\n");
            dwRefCount--;
            return NULL;
        }

    }

    BYTE *pbRet = (BYTE *)pvWindow + inOffset - dwWindowOffset + dwWindowUnusable;
    if (bProbeAndPageInAddressRange(pbRet, inSize))
        return (PVOID)pbRet;
    else
        return NULL;
}

PENHMETARECORD EMFContainer::ObtainRecordPtr(UINT inOffset)
{
    ENHMETARECORD *pemr = NULL;
   
    ENHMETARECORD *pemrTemp = (ENHMETARECORD *) ObtainPtr(inOffset, sizeof(ENHMETARECORD));

    if (pemrTemp != NULL)
    {
        UINT size = pemrTemp->nSize;

        ReleasePtr(pemrTemp);

        pemrTemp = (ENHMETARECORD *) ObtainPtr(inOffset, size);

        if (pemrTemp != NULL)
        {
            pemr = pemrTemp;
        }
    }
    return pemr;
}

PEMREOF EMFContainer::ObtainEOFRecordPtr()
{
    PEMREOF         pmreof = NULL;
    ENHMETAHEADER * pmrmf = GetEMFHeader();

    if(pmrmf)
    {
        PDWORD pdw = (PDWORD) ObtainPtr(pmrmf->nBytes - sizeof(DWORD),
                                        sizeof(DWORD));

        if(pdw)
        {
            DWORD  dwOffset = pmrmf->nBytes - *pdw;

            ReleasePtr(pdw);

            pmreof = (PEMREOF) ObtainRecordPtr(dwOffset);
        }

    }

    return pmreof;


}

PVOID  EMFContainer::pvMapView(UINT64 * ioOffset, UINT32 * ioSize)
{
    UINT64   qwMappingAlignment = GetFileMappingAlignment();
    UINT64   qwMappingMask = ~(qwMappingAlignment - 1);
    UINT64   qwRecordStart = *ioOffset;
    UINT64   qwRecordEnd = qwRecordStart + *ioSize;
    UINT64   qwViewStart;
    UINT64   qwViewEnd;
    PVOID    pvView;

    qwViewStart = qwRecordStart & qwMappingMask;

    qwViewEnd = qwViewStart + qwMappingAlignment;

    if(qwViewEnd < qwRecordEnd)
    {
        qwViewEnd = qwRecordEnd;
    }

    qwViewEnd = (qwViewEnd + (qwMappingAlignment - 1)) & qwMappingMask;

    if(qwViewEnd > qwFileSize)
    {
        qwViewEnd = qwFileSize;
    }

    DWORD dwViewSize = (DWORD) (qwViewEnd - qwViewStart);

    pvView = MapViewOfFile(hFileMapping,
                            FILE_MAP_WRITE,
                            HIDWORD(qwViewStart),
                            LODWORD(qwViewStart),
                            dwViewSize);

    if(pvView)
    {
        *ioOffset = qwViewStart;
        *ioSize = dwViewSize;
    }
    else
    {
        ioOffset = 0;
        ioSize = 0;
    }

    return pvView;

}

BOOL EMFContainer::bBounded(BYTE *p, DWORD dwSize)
{
    BYTE *pBh = 0, *pEh = 0;
    BYTE *pBw = 0, *pEw = 0;
    BYTE *pBt = 0, *pEt = 0;

    if (pvWindow)
    {
        pBw = (PBYTE)pvWindow;
        pEw = pBw + dwWindowSize;
    }

    if (pemfhdr)
    {
        pBh = (PBYTE)pemfhdr;
        pEh = pBh + dwHdrSize;
    }

    pBt = p;
    pEt = p + dwSize - 1;

    // The pointer/extent is bounded if the address range they represent are
    // bounded between the address ranges represented by the header range or
    // the window range.

    if (((pBt >= pBw && pBt < pEw) && (pEt >= pBw && pEt < pEw)) ||
        ((pBt >= pBh && pBt < pEh) && (pEt >= pBh && pEt < pEh)))
        return TRUE;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\metarec.h ===
/******************************Module*Header*******************************\
* Module Name: metarec.h
*
* Metafile recording functions.
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

BOOL MF_GdiComment(HDC hdc, UINT nSize, CONST BYTE *lpData);
BOOL MF_GdiCommentWindowsMetaFile(HDC hdc, UINT nSize, CONST BYTE *lpData);
BOOL MF_GdiCommentBeginGroupEMF(HDC hdc, PENHMETAHEADER pemfHeader);
BOOL MF_GdiCommentEndGroupEMF(HDC hdc);

// SaveDC
// BeginPath
// EndPath
// CloseFigure
// FlattenPath
// WidenPath
// AbortPath

BOOL MF_Record(HDC hdc,DWORD mrType);

// FillPath
// StrokeAndFillPath
// StrokePath

BOOL MF_BoundRecord(HDC hdc,DWORD mrType);

// PolyBezier
// Polygon
// Polyline
// PolyBezierTo
// PolylineTo

BOOL MF_Poly(HDC hdc, CONST POINT *pptl, DWORD cptl, DWORD mrType);

// PolyPolygon
// PolyPolyline

BOOL MF_PolyPoly(HDC hdc, CONST POINT *pptl, CONST DWORD *pc, DWORD cPoly, DWORD mrType);

BOOL MF_PolyDraw(HDC hdc, CONST POINT *pptl, CONST BYTE *pb, DWORD cptl);

// SetMapperFlags
// SetMapMode
// SetBkMode
// SetPolyFillMode
// SetROP2
// SetStretchBltMode
// SetTextAlign
// SetTextColor
// SetBkColor
// RestoreDC
// SetArcDirection
// SetMiterLimit

BOOL MF_SetD(HDC hdc,DWORD d1,DWORD mrType);

// OffsetWindowOrgEx
// OffsetViewportOrgEx
// SetWindowExtEx
// SetWindowOrgEx
// SetViewportExtEx
// SetViewportOrgEx
// SetBrushOrgEx
// MoveToEx
// LineTo

BOOL MF_SetDD(HDC hdc,DWORD d1,DWORD d2,DWORD mrType);

// ScaleViewportExtEx
// ScaleWindowExtEx

BOOL MF_SetDDDD(HDC hdc,DWORD d1,DWORD d2,DWORD d3,DWORD d4,DWORD mrType);

BOOL MF_RestoreDC(HDC hdc,int iLevel);
BOOL MF_SetViewportExtEx(HDC hdc,int x,int y);
BOOL MF_SetViewportOrgEx(HDC hdc,int x,int y);
BOOL MF_SetWindowExtEx(HDC hdc,int x,int y);
BOOL MF_SetWindowOrgEx(HDC hdc,int x,int y);
BOOL MF_OffsetViewportOrgEx(HDC hdc,int x,int y);
BOOL MF_OffsetWindowOrgEx(HDC hdc,int x,int y);
BOOL MF_SetBrushOrgEx(HDC hdc,int x,int y);

// ExcludeClipRect
// IntersectClipRect

BOOL MF_AnyClipRect(HDC hdc,int x1,int y1,int x2,int y2,DWORD mrType);

// SetMetaRgn

BOOL MF_SetMetaRgn(HDC hdc);

// SelectClipPath

BOOL MF_SelectClipPath(HDC hdc,int iMode);

// OffsetClipRgn

BOOL MF_OffsetClipRgn(HDC hdc,int x1,int y1);

// SetPixel
// SetPixelV

BOOL MF_SetPixelV(HDC hdc,int x,int y,COLORREF color);

// CloseEnhMetaFile

BOOL MF_EOF(HDC hdc, ULONG cEntries, PPALETTEENTRY pPalEntries);

BOOL MF_SetWorldTransform(HDC hdc, CONST XFORM *pxform);
BOOL MF_ModifyWorldTransform(HDC hdc, CONST XFORM *pxform, DWORD iMode);

// SelectObject
// SelectPalette

BOOL MF_SelectAnyObject(HDC hdc,HANDLE h,DWORD mrType);

BOOL MF_DeleteObject(HANDLE h);

DWORD MF_InternalCreateObject(HDC hdc,HANDLE h);

BOOL MF_AngleArc(HDC hdc,int x,int y,DWORD r,FLOAT eA,FLOAT eB);

// SetArcDirection

BOOL MF_ValidateArcDirection(HDC hdc);

// Ellipse
// Rectangle

BOOL MF_EllipseRect(HDC hdc,int x1,int y1,int x2,int y2,DWORD mrType);

BOOL MF_RoundRect(HDC hdc,int x1,int y1,int x2,int y2,int x3,int y3);

// Arc
// ArcTo
// Chord
// Pie

BOOL MF_ArcChordPie(HDC hdc,int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4,DWORD mrType);

BOOL MF_ResizePalette(HPALETTE hpal,UINT c);
BOOL MF_RealizePalette(HPALETTE hpal);
BOOL MF_SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, CONST PALETTEENTRY *pPalEntries);
BOOL MF_ColorCorrectPalette(HDC hdc,HPALETTE hpal,ULONG FirstEntry,ULONG NumberOfEntries);

// InvertRgn
// PaintRgn

BOOL MF_InvertPaintRgn(HDC hdc,HRGN hrgn,DWORD mrType);

BOOL MF_FillRgn(HDC hdc,HRGN hrgn,HBRUSH hbrush);
BOOL MF_FrameRgn(HDC hdc,HRGN hrgn,HBRUSH hbrush,int cx,int cy);

// SelectClipRgn
// ExtSelectClipRgn
// SelectObject(hdc,hrgn)

BOOL MF_ExtSelectClipRgn(HDC hdc,HRGN hrgn,int iMode);

// BitBlt
// PatBlt
// StretchBlt
// MaskBlt
// PlgBlt

BOOL MF_AnyBitBlt(HDC hdcDst,int xDst,int yDst,int cxDst,int cyDst,
    CONST POINT *pptDst, HDC hdcSrc,int xSrc,int ySrc,int cxSrc,int cySrc,
    HBITMAP hbmMask,int xMask,int yMask,DWORD rop,DWORD mrType);

// SetDIBitsToDevice
// StretchDIBits

BOOL MF_AnyDIBits(HDC hdcDst,int xDst,int yDst,int cxDst,int cyDst,
    int xDib,int yDib,int cxDib,int cyDib,DWORD iStartScan,DWORD cScans,
    CONST VOID * pBitsDib, CONST BITMAPINFO *pBitsInfoDib,DWORD iUsageDib,DWORD rop,DWORD mrType);

// TextOutA
// TextOutW
// ExtTextOutA
// ExtTextOutW

BOOL MF_ExtTextOut(HDC hdc,int x,int y,UINT fl,CONST RECT *prcl,LPCSTR psz,int c, CONST INT *pdx,DWORD mrType);

// PolyTextOutA
// PolyTextOutW

BOOL MF_PolyTextOut(HDC hdc,CONST POLYTEXTA *ppta,int c,DWORD mrType);

// ExtFloodFill
// FloodFill

BOOL MF_ExtFloodFill(HDC hdc,int x,int y,COLORREF color,DWORD iMode);

// SetColorAdjustment

BOOL MF_SetColorAdjustment(HDC hdc, CONST COLORADJUSTMENT *pca);

// SetFontXform

BOOL MF_SetFontXform(HDC hdc,FLOAT exScale,FLOAT eyScale);


// EMF Spooling Stuff
BOOL MF_StartDoc(HDC hdc, CONST DOCINFOW *pDocInfo );
BOOL MF_EndPage(HDC hdc);
BOOL MF_StartPage(HDC hdc);
BOOL MF_WriteEscape(HDC hdc, int nEscape, int nCount, LPCSTR lpInData, int type );
BOOL MF_ForceUFIMapping(HDC hdc, PUNIVERSAL_FONT_ID pufi );
BOOL MF_SetLinkedUFIs(HDC hdc, PUNIVERSAL_FONT_ID pufi, UINT uNumLinkedUFIs );


// SetPixelFormat
BOOL MF_SetPixelFormat(HDC hdc,
                       int iPixelFormat,
                       CONST PIXELFORMATDESCRIPTOR *ppfd);

BOOL MF_WriteNamedEscape(HDC hdc, LPWSTR pwszDriver, int nEscape, int nCount,
                         LPCSTR lpInData);

// SetICMProfile
BOOL MF_SetICMProfile(HDC hdc,LPBYTE lpData,PVOID pColorSpace,DWORD dwRecord);

// ColorMatchToTarget
BOOL MF_ColorMatchToTarget(HDC hdc, DWORD uiAction, PVOID pColorSpace, DWORD dwRecord);

// CreateColorSpace
BOOL MF_InternalCreateColorSpace(HDC hdc,HGDIOBJ h,DWORD imhe);

// Image APIs
BOOL MF_AlphaBlend(HDC,LONG,LONG,LONG,LONG,HDC,LONG,LONG,LONG,LONG,BLENDFUNCTION);
BOOL MF_GradientFill(HDC,CONST PTRIVERTEX,ULONG, CONST PVOID,ULONG,ULONG);
BOOL MF_TransparentImage(HDC,LONG,LONG,LONG,LONG,HDC,LONG,LONG,LONG,LONG,ULONG,ULONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\mfrec.cxx ===
/*************************************************************************\
* Module Name: mfrec.cxx
*
* This file contains the member functions for the metafile record
* classes defined in mfrec.hxx.
*
* Created: 12-June-1991 13:46:00
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\*************************************************************************/

#define NO_STRICT

extern "C" {
#if defined(_GDIPLUS_)
#include    <gpprefix.h>
#endif

#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <stddef.h>
#include    <windows.h> // GDI function declarations.
#include    <winerror.h>
#include    "firewall.h"
#define __CPLUSPLUS
#include    <winspool.h>
#include    <w32gdip.h>
#include    "ntgdistr.h"
#include    "winddi.h"
#include    "hmgshare.h"
#include    "icm.h"
#include    "local.h"   // Local object support.
#include    "gdiicm.h"
#include    "metadef.h" // Metafile record type constants.
#include    "metarec.h" // Metafile recording functions.
#include    "mf16.h"
#include    "ntgdi.h"
#include    "nlsconv.h" // Ansi - Unicode conversions.
}

#include    "rectl.hxx"
#include    "mfdc.hxx"  // Metafile DC class declarations.
#include    "mfrec.hxx" // Metafile record class declarations.

#ifdef LANGPACK
LONG gdwDisableMetafileRec=0 ;
#endif


// Max number of pointl's allowed on stack before explicit memory allocation.

#define MAX_STACK_POINTL        128

#define STOCK_IMHE(imhe)                                             \
        (                                                            \
            ((imhe) & ENHMETA_STOCK_OBJECT) &&                       \
            (((imhe) & ~ENHMETA_STOCK_OBJECT) <= PRIV_STOCK_LAST)    \
        )

#define VALID_IMHE(imhe,cht)                                    \
        (                                                       \
            (((UINT) (imhe)) < ((UINT) (cht))) &&               \
            ((imhe) != 0)                                       \
        )

// FNBMRPLAY afnbMRPlay[EMR_MAX-EMR_MIN+1]
typedef BOOL (MR::*MRPFN)(HDC, PHANDLETABLE, UINT);
//BOOL (MR::*afnbMRPlay[EMR_MAX-EMR_MIN+1])(HDC, PHANDLETABLE, UINT) = {
MRPFN afnbMRPlay[EMR_MAX-EMR_MIN+1] = {
    (MRPFN)&MRMETAFILE::bPlay,
    (MRPFN)&MRPOLYBEZIER::bPlay,
    (MRPFN)&MRPOLYGON::bPlay,
    (MRPFN)&MRPOLYLINE::bPlay,
    (MRPFN)&MRPOLYBEZIERTO::bPlay,
    (MRPFN)&MRPOLYLINETO::bPlay,
    (MRPFN)&MRPOLYPOLYLINE::bPlay,
    (MRPFN)&MRPOLYPOLYGON::bPlay,
    (MRPFN)&MRSETWINDOWEXTEX::bPlay,
    (MRPFN)&MRSETWINDOWORGEX::bPlay,    // EMR_SETWINDOWORGEX    10
    (MRPFN)&MRSETVIEWPORTEXTEX::bPlay,
    (MRPFN)&MRSETVIEWPORTORGEX::bPlay,
    (MRPFN)&MRSETBRUSHORGEX::bPlay,
    (MRPFN)&MREOF::bPlay,
    (MRPFN)&MRSETPIXELV::bPlay,
    (MRPFN)&MRSETMAPPERFLAGS::bPlay,
    (MRPFN)&MRSETMAPMODE::bPlay,
    (MRPFN)&MRSETBKMODE::bPlay,
    (MRPFN)&MRSETPOLYFILLMODE::bPlay,
    (MRPFN)&MRSETROP2::bPlay,           // EMR_SETROP2           20
    (MRPFN)&MRSETSTRETCHBLTMODE::bPlay,
    (MRPFN)&MRSETTEXTALIGN::bPlay,
    (MRPFN)&MRSETCOLORADJUSTMENT::bPlay,
    (MRPFN)&MRSETTEXTCOLOR::bPlay,
    (MRPFN)&MRSETBKCOLOR::bPlay,
    (MRPFN)&MROFFSETCLIPRGN::bPlay,
    (MRPFN)&MRMOVETOEX::bPlay,
    (MRPFN)&MRSETMETARGN::bPlay,
    (MRPFN)&MREXCLUDECLIPRECT::bPlay,
    (MRPFN)&MRINTERSECTCLIPRECT::bPlay, // EMR_INTERSECTCLIPRECT 30
    (MRPFN)&MRSCALEVIEWPORTEXTEX::bPlay,
    (MRPFN)&MRSCALEWINDOWEXTEX::bPlay,
    (MRPFN)&MRSAVEDC::bPlay,
    (MRPFN)&MRRESTOREDC::bPlay,
    (MRPFN)&MRSETWORLDTRANSFORM::bPlay,
    (MRPFN)&MRMODIFYWORLDTRANSFORM::bPlay,
    (MRPFN)&MRSELECTOBJECT::bPlay,
    (MRPFN)&MRCREATEPEN::bPlay,
    (MRPFN)&MRCREATEBRUSHINDIRECT::bPlay,
    (MRPFN)&MRDELETEOBJECT::bPlay,      // EMR_DELETEOBJECT      40
    (MRPFN)&MRANGLEARC::bPlay,
    (MRPFN)&MRELLIPSE::bPlay,
    (MRPFN)&MRRECTANGLE::bPlay,
    (MRPFN)&MRROUNDRECT::bPlay,
    (MRPFN)&MRARC::bPlay,
    (MRPFN)&MRCHORD::bPlay,
    (MRPFN)&MRPIE::bPlay,
    (MRPFN)&MRSELECTPALETTE::bPlay,
    (MRPFN)&MRCREATEPALETTE::bPlay,
    (MRPFN)&MRSETPALETTEENTRIES::bPlay, // EMR_SETPALETTEENTRIES 50
    (MRPFN)&MRRESIZEPALETTE::bPlay,
    (MRPFN)&MRREALIZEPALETTE::bPlay,
    (MRPFN)&MREXTFLOODFILL::bPlay,
    (MRPFN)&MRLINETO::bPlay,
    (MRPFN)&MRARCTO::bPlay,
    (MRPFN)&MRPOLYDRAW::bPlay,
    (MRPFN)&MRSETARCDIRECTION::bPlay,
    (MRPFN)&MRSETMITERLIMIT::bPlay,
    (MRPFN)&MRBEGINPATH::bPlay,
    (MRPFN)&MRENDPATH::bPlay,          // EMR_ENDPATH            60
    (MRPFN)&MRCLOSEFIGURE::bPlay,
    (MRPFN)&MRFILLPATH::bPlay,
    (MRPFN)&MRSTROKEANDFILLPATH::bPlay,
    (MRPFN)&MRSTROKEPATH::bPlay,
    (MRPFN)&MRFLATTENPATH::bPlay,
    (MRPFN)&MRWIDENPATH::bPlay,
    (MRPFN)&MRSELECTCLIPPATH::bPlay,
    (MRPFN)&MRABORTPATH::bPlay,
    (MRPFN)&MR::bPlay,                 // not used
    (MRPFN)&MRGDICOMMENT::bPlay,       // EMR_GDICOMMENT         70
    (MRPFN)&MRFILLRGN::bPlay,
    (MRPFN)&MRFRAMERGN::bPlay,
    (MRPFN)&MRINVERTRGN::bPlay,
    (MRPFN)&MRPAINTRGN::bPlay,
    (MRPFN)&MREXTSELECTCLIPRGN::bPlay,
    (MRPFN)&MRBITBLT::bPlay,
    (MRPFN)&MRSTRETCHBLT::bPlay,
    (MRPFN)&MRMASKBLT::bPlay,
    (MRPFN)&MRPLGBLT::bPlay,
    (MRPFN)&MRSETDIBITSTODEVICE::bPlay, // EMR_SETDIBITSTODEVICE 80
    (MRPFN)&MRSTRETCHDIBITS::bPlay,
    (MRPFN)&MREXTCREATEFONTINDIRECTW::bPlay,
    (MRPFN)&MREXTTEXTOUT::bPlay,        // EMR_EXTTEXTOUTA
    (MRPFN)&MREXTTEXTOUT::bPlay,        // EMR_EXTTEXTOUTW
    (MRPFN)&MRBP16::bPlay,              // EMR_POLYBEZIER16
    (MRPFN)&MRBP16::bPlay,              // EMR_POLYGON16
    (MRPFN)&MRBP16::bPlay,              // EMR_POLYLINE16
    (MRPFN)&MRBP16::bPlay,              // EMR_POLYBEZIERTO16
    (MRPFN)&MRBP16::bPlay,              // EMR_POLYLINETO16
    (MRPFN)&MRBPP16::bPlay,             // EMR_POLYPOLYLINE16    90
    (MRPFN)&MRBPP16::bPlay,             // EMR_POLYPOLYGON16
    (MRPFN)&MRPOLYDRAW16::bPlay,
    (MRPFN)&MRCREATEMONOBRUSH::bPlay,
    (MRPFN)&MRCREATEDIBPATTERNBRUSHPT::bPlay,
    (MRPFN)&MREXTCREATEPEN::bPlay,
    (MRPFN)&MRPOLYTEXTOUT::bPlay,       // EMR_POLYTEXTOUTA
    (MRPFN)&MRPOLYTEXTOUT::bPlay,       // EMR_POLYTEXTOUTW

    (MRPFN)&MRSETICMMODE::bPlay,
    (MRPFN)&MRCREATECOLORSPACE::bPlay,  // EMR_CREATECOLORSPACE (ansi)
    (MRPFN)&MRSETCOLORSPACE::bPlay,     // EMR_SETCOLORSPACE    100
    (MRPFN)&MRDELETECOLORSPACE::bPlay,

    (MRPFN)&MRGLSRECORD::bPlay,         // EMR_GLSRECORD
    (MRPFN)&MRGLSBOUNDEDRECORD::bPlay,  // EMR_GLSBOUNDEDRECORD
    (MRPFN)&MRPIXELFORMAT::bPlay,       // EMR_PIXELFORMAT


    (MRPFN)&MRESCAPE::bPlay,            // EMR_DRAWESCAPE
    (MRPFN)&MRESCAPE::bPlay,            // EMR_EXTESCAPE
    (MRPFN)&MRSTARTDOC::bPlay,
    (MRPFN)&MRSMALLTEXTOUT::bPlay,
    (MRPFN)&MRFORCEUFIMAPPING::bPlay,
    (MRPFN)&MRNAMEDESCAPE::bPlay,       // EMR_NAMEDESCAPE      110

    (MRPFN)&MRCOLORCORRECTPALETTE::bPlay,
    (MRPFN)&MRSETICMPROFILE::bPlay,     // EMR_SETICMPROFILEA
    (MRPFN)&MRSETICMPROFILE::bPlay,     // EMR_SETICMPROFILEW

    (MRPFN)&MRALPHABLEND::bPlay,
    (MRPFN)&MRSETLAYOUT::bPlay,         // EMR_SETLAYOUT
    (MRPFN)&MRTRANSPARENTBLT::bPlay,
    (MRPFN)&MR::bPlay,                  // not used
    (MRPFN)&MRGRADIENTFILL::bPlay,
    (MRPFN)&MRSETLINKEDUFIS::bPlay,
    (MRPFN)&MRSETTEXTJUSTIFICATION::bPlay, //                   120
    (MRPFN)&MRCOLORMATCHTOTARGET::bPlay,   // EMF_COLORMATCHTOTARGET
    (MRPFN)&MRCREATECOLORSPACEW::bPlay,    // EMR_CREATECOLORSPACEW (unicode)
};

// FNBMRCHECK afnbMRCheck[EMR_MAX-EMR_MIN+1]
typedef BOOL (MR::*MRCHKPFN)(PHANDLETABLE);
//BOOL (MR::*afnbMRCheck[EMR_MAX-EMR_MIN+1])(PHANDLETABLE) = {
MRCHKPFN afnbMRCheck[EMR_MAX-EMR_MIN+1] = {
    (MRCHKPFN)&MRMETAFILE::bCheckRecord,
    (MRCHKPFN)&MRPOLYBEZIER::bCheckRecord,
    (MRCHKPFN)&MRPOLYGON::bCheckRecord,
    (MRCHKPFN)&MRPOLYLINE::bCheckRecord,
    (MRCHKPFN)&MRPOLYBEZIERTO::bCheckRecord,
    (MRCHKPFN)&MRPOLYLINETO::bCheckRecord,
    (MRCHKPFN)&MRPOLYPOLYLINE::bCheckRecord,
    (MRCHKPFN)&MRPOLYPOLYGON::bCheckRecord,
    (MRCHKPFN)&MRSETWINDOWEXTEX::bCheckRecord,
    (MRCHKPFN)&MRSETWINDOWORGEX::bCheckRecord,    // EMR_SETWINDOWORGEX    10
    (MRCHKPFN)&MRSETVIEWPORTEXTEX::bCheckRecord,
    (MRCHKPFN)&MRSETVIEWPORTORGEX::bCheckRecord,
    (MRCHKPFN)&MRSETBRUSHORGEX::bCheckRecord,
    (MRCHKPFN)&MREOF::bCheckRecord,
    (MRCHKPFN)&MRSETPIXELV::bCheckRecord,
    (MRCHKPFN)&MRSETMAPPERFLAGS::bCheckRecord,
    (MRCHKPFN)&MRSETMAPMODE::bCheckRecord,
    (MRCHKPFN)&MRSETBKMODE::bCheckRecord,
    (MRCHKPFN)&MRSETPOLYFILLMODE::bCheckRecord,
    (MRCHKPFN)&MRSETROP2::bCheckRecord,           // EMR_SETROP2           20
    (MRCHKPFN)&MRSETSTRETCHBLTMODE::bCheckRecord,
    (MRCHKPFN)&MRSETTEXTALIGN::bCheckRecord,
    (MRCHKPFN)&MRSETCOLORADJUSTMENT::bCheckRecord,
    (MRCHKPFN)&MRSETTEXTCOLOR::bCheckRecord,
    (MRCHKPFN)&MRSETBKCOLOR::bCheckRecord,
    (MRCHKPFN)&MROFFSETCLIPRGN::bCheckRecord,
    (MRCHKPFN)&MRMOVETOEX::bCheckRecord,
    (MRCHKPFN)&MRSETMETARGN::bCheckRecord,
    (MRCHKPFN)&MREXCLUDECLIPRECT::bCheckRecord,
    (MRCHKPFN)&MRINTERSECTCLIPRECT::bCheckRecord, // EMR_INTERSECTCLIPRECT 30
    (MRCHKPFN)&MRSCALEVIEWPORTEXTEX::bCheckRecord,
    (MRCHKPFN)&MRSCALEWINDOWEXTEX::bCheckRecord,
    (MRCHKPFN)&MRSAVEDC::bCheckRecord,
    (MRCHKPFN)&MRRESTOREDC::bCheckRecord,
    (MRCHKPFN)&MRSETWORLDTRANSFORM::bCheckRecord,
    (MRCHKPFN)&MRMODIFYWORLDTRANSFORM::bCheckRecord,
    (MRCHKPFN)&MRSELECTOBJECT::bCheckRecord,
    (MRCHKPFN)&MRCREATEPEN::bCheckRecord,
    (MRCHKPFN)&MRCREATEBRUSHINDIRECT::bCheckRecord,
    (MRCHKPFN)&MRDELETEOBJECT::bCheckRecord,      // EMR_DELETEOBJECT      40
    (MRCHKPFN)&MRANGLEARC::bCheckRecord,
    (MRCHKPFN)&MRELLIPSE::bCheckRecord,
    (MRCHKPFN)&MRRECTANGLE::bCheckRecord,
    (MRCHKPFN)&MRROUNDRECT::bCheckRecord,
    (MRCHKPFN)&MRARC::bCheckRecord,
    (MRCHKPFN)&MRCHORD::bCheckRecord,
    (MRCHKPFN)&MRPIE::bCheckRecord,
    (MRCHKPFN)&MRSELECTPALETTE::bCheckRecord,
    (MRCHKPFN)&MRCREATEPALETTE::bCheckRecord,
    (MRCHKPFN)&MRSETPALETTEENTRIES::bCheckRecord, // EMR_SETPALETTEENTRIES 50
    (MRCHKPFN)&MRRESIZEPALETTE::bCheckRecord,
    (MRCHKPFN)&MRREALIZEPALETTE::bCheckRecord,
    (MRCHKPFN)&MREXTFLOODFILL::bCheckRecord,
    (MRCHKPFN)&MRLINETO::bCheckRecord,
    (MRCHKPFN)&MRARCTO::bCheckRecord,
    (MRCHKPFN)&MRPOLYDRAW::bCheckRecord,
    (MRCHKPFN)&MRSETARCDIRECTION::bCheckRecord,
    (MRCHKPFN)&MRSETMITERLIMIT::bCheckRecord,
    (MRCHKPFN)&MRBEGINPATH::bCheckRecord,
    (MRCHKPFN)&MRENDPATH::bCheckRecord,          // EMR_ENDPATH            60
    (MRCHKPFN)&MRCLOSEFIGURE::bCheckRecord,
    (MRCHKPFN)&MRFILLPATH::bCheckRecord,
    (MRCHKPFN)&MRSTROKEANDFILLPATH::bCheckRecord,
    (MRCHKPFN)&MRSTROKEPATH::bCheckRecord,
    (MRCHKPFN)&MRFLATTENPATH::bCheckRecord,
    (MRCHKPFN)&MRWIDENPATH::bCheckRecord,
    (MRCHKPFN)&MRSELECTCLIPPATH::bCheckRecord,
    (MRCHKPFN)&MRABORTPATH::bCheckRecord,
    (MRCHKPFN)&MR::bCheckRecord,                 // not used
    (MRCHKPFN)&MRGDICOMMENT::bCheckRecord,       // EMR_GDICOMMENT         70
    (MRCHKPFN)&MRFILLRGN::bCheckRecord,
    (MRCHKPFN)&MRFRAMERGN::bCheckRecord,
    (MRCHKPFN)&MRINVERTRGN::bCheckRecord,
    (MRCHKPFN)&MRPAINTRGN::bCheckRecord,
    (MRCHKPFN)&MREXTSELECTCLIPRGN::bCheckRecord,
    (MRCHKPFN)&MRBITBLT::bCheckRecord,
    (MRCHKPFN)&MRSTRETCHBLT::bCheckRecord,
    (MRCHKPFN)&MRMASKBLT::bCheckRecord,
    (MRCHKPFN)&MRPLGBLT::bCheckRecord,
    (MRCHKPFN)&MRSETDIBITSTODEVICE::bCheckRecord, // EMR_SETDIBITSTODEVICE 80
    (MRCHKPFN)&MRSTRETCHDIBITS::bCheckRecord,
    (MRCHKPFN)&MREXTCREATEFONTINDIRECTW::bCheckRecord,
    (MRCHKPFN)&MREXTTEXTOUT::bCheckRecord,        // EMR_EXTTEXTOUTA
    (MRCHKPFN)&MREXTTEXTOUT::bCheckRecord,        // EMR_EXTTEXTOUTW
    (MRCHKPFN)&MRBP16::bCheckRecord,              // EMR_POLYBEZIER16
    (MRCHKPFN)&MRBP16::bCheckRecord,              // EMR_POLYGON16
    (MRCHKPFN)&MRBP16::bCheckRecord,              // EMR_POLYLINE16
    (MRCHKPFN)&MRBP16::bCheckRecord,              // EMR_POLYBEZIERTO16
    (MRCHKPFN)&MRBP16::bCheckRecord,              // EMR_POLYLINETO16
    (MRCHKPFN)&MRBPP16::bCheckRecord,             // EMR_POLYPOLYLINE16    90
    (MRCHKPFN)&MRBPP16::bCheckRecord,             // EMR_POLYPOLYGON16
    (MRCHKPFN)&MRPOLYDRAW16::bCheckRecord,
    (MRCHKPFN)&MRCREATEMONOBRUSH::bCheckRecord,
    (MRCHKPFN)&MRCREATEDIBPATTERNBRUSHPT::bCheckRecord,
    (MRCHKPFN)&MREXTCREATEPEN::bCheckRecord,
    (MRCHKPFN)&MRPOLYTEXTOUT::bCheckRecord,       // EMR_POLYTEXTOUTA
    (MRCHKPFN)&MRPOLYTEXTOUT::bCheckRecord,       // EMR_POLYTEXTOUTW

    (MRCHKPFN)&MRSETICMMODE::bCheckRecord,
    (MRCHKPFN)&MRCREATECOLORSPACE::bCheckRecord,  // EMR_CREATECOLORSPACE (ansi)
    (MRCHKPFN)&MRSETCOLORSPACE::bCheckRecord,     // EMR_SETCOLORSPACE    100
    (MRCHKPFN)&MRDELETECOLORSPACE::bCheckRecord,

    (MRCHKPFN)&MRGLSRECORD::bCheckRecord,         // EMR_GLSRECORD
    (MRCHKPFN)&MRGLSBOUNDEDRECORD::bCheckRecord,  // EMR_GLSBOUNDEDRECORD
    (MRCHKPFN)&MRPIXELFORMAT::bCheckRecord,       // EMR_PIXELFORMAT


    (MRCHKPFN)&MRESCAPE::bCheckRecord,            // EMR_DRAWESCAPE
    (MRCHKPFN)&MRESCAPE::bCheckRecord,            // EMR_EXTESCAPE
    (MRCHKPFN)&MRSTARTDOC::bCheckRecord,
    (MRCHKPFN)&MRSMALLTEXTOUT::bCheckRecord,
    (MRCHKPFN)&MRFORCEUFIMAPPING::bCheckRecord,
    (MRCHKPFN)&MRNAMEDESCAPE::bCheckRecord,       // EMR_NAMEDESCAPE      110

    (MRCHKPFN)&MRCOLORCORRECTPALETTE::bCheckRecord,
    (MRCHKPFN)&MRSETICMPROFILE::bCheckRecord,     // EMR_SETICMPROFILEA
    (MRCHKPFN)&MRSETICMPROFILE::bCheckRecord,     // EMR_SETICMPROFILEW

    (MRCHKPFN)&MRALPHABLEND::bCheckRecord,
    (MRCHKPFN)&MRSETLAYOUT::bCheckRecord,         // EMR_SETLAYOUT
    (MRCHKPFN)&MRTRANSPARENTBLT::bCheckRecord,
    (MRCHKPFN)&MR::bCheckRecord,                  // not used
    (MRCHKPFN)&MRGRADIENTFILL::bCheckRecord,
    (MRCHKPFN)&MRSETLINKEDUFIS::bCheckRecord,
    (MRCHKPFN)&MRSETTEXTJUSTIFICATION::bCheckRecord, //                   120
    (MRCHKPFN)&MRCOLORMATCHTOTARGET::bCheckRecord,   // EMF_COLORMATCHTOTARGET
    (MRCHKPFN)&MRCREATECOLORSPACEW::bCheckRecord,    // EMR_CREATECOLORSPACEW (unicode)
};
/******************************Public*Routine******************************\
* CreateMonoDib
*
* This is the same as CreateBitmap except that the bits are assumed
* to be DWORD aligned and that the scans start from the bottom of the bitmap.
*
* This routine is temporary until CreateDIBitmap supports monochrome bitmaps!
*
* History:
*  Sun Jun 14 12:22:11 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" HBITMAP CreateMonoDib
(
    LPBITMAPINFO pbmi,
    CONST BYTE * pjBits,
    UINT         iUsage
)
{
    HBITMAP hbm;

    ASSERTGDI(pbmi->bmiHeader.biPlanes == 1, "CreateMonoDib: bad biPlanes value");
    ASSERTGDI(pbmi->bmiHeader.biBitCount == 1, "CreateMonoDib: bad biBitCount value");

    hbm = CreateBitmap((int)  pbmi->bmiHeader.biWidth,
                       (int)  pbmi->bmiHeader.biHeight,
                       (UINT) 1,
                       (UINT) 1,
                       (CONST VOID *) NULL);
    if (!hbm)
        return(hbm);

    SetDIBits((HDC) 0, hbm, 0, (UINT) pbmi->bmiHeader.biHeight,
              (CONST VOID *) pjBits, pbmi, iUsage);

    return(hbm);
}

/******************************Public*Routine******************************\
* CreateCompatibleDCAdvanced
*
* Create a compatible DC in the advanced graphics mode.  The advanced
* graphics mode is required to modify the world transform.
*
* History:
*  Wed Nov 4 14:21:00 1992      -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" HDC CreateCompatibleDCAdvanced(HDC hdc)
{
    HDC hdcRet;

    hdcRet = CreateCompatibleDC(hdc);

    SetGraphicsMode(hdcRet, GM_ADVANCED);

    return(hdcRet);
}

/******************************Public*Routine******************************\
* GetBrushBits
*
* This function is really a hack.  In the current implementation,
* gdisrv keeps the original brush color table for both DIB_PAL_COLORS
* and DIB_RGB_COLORS usages.  The size of the table is
* sizeof(RGBQUAD) * nEntries in both cases.  In order to get the
* bits and bitmap info using GetDIBits, it requires that the usage
* be DIB_RGB_COLORS in the case of DIB_PAL_COLORS to prevent
* color translation.  But it actually returns the original palette
* indices stored in the brush color table.
*
* History:
*  Mon Feb 1 10:22:23 1993      -by-    Hock San Lee    [hockl]
* Wrote it.
\******************************Public*Routine******************************/

extern "C" int GetBrushBits
(
    HDC      hdc,
    HBITMAP  hbm,
    UINT     iUsage,
    DWORD    cbBmi,
    LPVOID   pBits,
    LPBITMAPINFO pBmi
)
{
    if (iUsage == DIB_PAL_COLORS)
    {
        LPBITMAPINFO pBmiTmp;
        int          iRet;
        DWORD        cEntries;

        ASSERTGDI((cbBmi - sizeof(BMIH)) % 2 == 0, "GetBrushBits: Bad cbBmi\n");
        cEntries = (cbBmi - sizeof(BMIH)) / sizeof(WORD);

        // Allocate bitmap info to accommodate RGBQUADs.
        if (!(pBmiTmp = (PBMI) LocalAlloc(LMEM_FIXED,
                (UINT) (cEntries * sizeof(RGBQUAD) + sizeof(BMIH)))))
            return(0);

        *(PBMIH) pBmiTmp = *(PBMIH) pBmi;

        // Get bitmap info and bits.
        iRet = GetDIBits(hdc, hbm,
                   0, (UINT) pBmi->bmiHeader.biHeight,
                   pBits, pBmiTmp, DIB_RGB_COLORS);

        // Get the bitmap info header and palette indexes.
        RtlCopyMemory((PBYTE) pBmi, (PBYTE) pBmiTmp, cbBmi);

        // Free the temporary bitmap info.
        if (LocalFree(pBmiTmp))
        {
            ASSERTGDI(FALSE, "GetBrushBits: LocalFree failed\n");
        }

        return(iRet);
    }
    else
    {
        // Get bitmap info and bits.

        return(GetDIBits(hdc, hbm,
                   0, (UINT) pBmi->bmiHeader.biHeight,
                   pBits, pBmi, iUsage));
    }
}

/******************************Public*Routine******************************\
* VOID MRBP::vInit(iType1, cptl1, aptl1, pmdc)
*
* Initializers -- Initialize the metafile Poly(To) record.
*
* History:
*  Thu Jul 18 11:19:20 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID MRBP::vInit(DWORD iType1, DWORD cptl1, CONST POINTL *aptl1, PMDC pmdc)
{
    PUTS("MRBP::vInit\n");

    MRB::vInit(iType1, pmdc);

    cptl = cptl1;
    RtlCopyMemory((PBYTE) aptl, (PBYTE) aptl1, cptl1 * sizeof(POINTL));
}

/******************************Public*Routine******************************\
* VOID MRBP16::vInit(iType1, cptl1, aptl1, pmdc)
*
* Initializers -- Initialize the metafile Poly(To)16 record.
*
* History:
*  Sat Mar 07 15:06:16 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID MRBP16::vInit(DWORD iType1, DWORD cptl1, CONST POINTL *aptl1, PMDC pmdc)
{
    PUTS("MRBP16::vInit\n");

    MRB::vInit(iType1, pmdc);

    cpts = cptl1;
    POINTL_TO_POINTS(apts, aptl1, cptl1);
}

/******************************Public*Routine******************************\
* VOID MRBPP::vInit(iType1, cPoly1, cptl1, ac1, aptl1, pmdc)
*
* Initializers -- Initialize the metafile PolyPoly record.
*
* History:
*  Thu Jul 18 11:19:20 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID MRBPP::vInit
(
    DWORD       iType1,
    DWORD       cPoly1,
    DWORD       cptl1,
    CONST DWORD *ac1,
    CONST POINTL *aptl1,
    PMDC        pmdc
)
{
    PUTS("MRBPP::vInit\n");

    MRB::vInit(iType1, pmdc);

    cPoly = cPoly1;
    cptl  = cptl1;
    RtlCopyMemory((PBYTE) &ac, (PBYTE) ac1, cPoly1 * sizeof(DWORD));
    RtlCopyMemory((PBYTE) &ac[cPoly1], (PBYTE) aptl1, cptl1 * sizeof(POINTL));
}

/******************************Public*Routine******************************\
* VOID MRBPP16::vInit(iType1, cPoly1, cptl, ac1, aptl1, pmdc)
*
* Initializers -- Initialize the metafile PolyPoly16 record.
*
* History:
*  Sat Mar 07 15:06:16 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID MRBPP16::vInit
(
    DWORD       iType1,
    DWORD       cPoly1,
    DWORD       cptl1,
    CONST DWORD *ac1,
    CONST POINTL *aptl1,
    PMDC        pmdc
)
{
    PUTS("MRBPP16::vInit\n");

    MRB::vInit(iType1, pmdc);

    cPoly = cPoly1;
    cpts  = cptl1;
    RtlCopyMemory((PBYTE) &ac, (PBYTE) ac1, cPoly1 * sizeof(DWORD));
    POINTL_TO_POINTS((PPOINTS) &ac[cPoly1], aptl1, cptl1);
}

/******************************Public*Routine******************************\
* VOID MRPOLYDRAW::vInit(pmdc, aptl1, ab1, cptl1)
*
* Initializers -- Initialize the metafile MRPOLYDRAW record.
*
* History:
*  Thu Oct 17 14:11:36 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID MRPOLYDRAW::vInit(PMDC pmdc, CONST POINTL *aptl1, CONST BYTE *ab1, DWORD cptl1)
{
    PUTS("MRPOLYDRAW::vInit\n");

    MRB::vInit(EMR_POLYDRAW, pmdc);

    cptl = cptl1;
    RtlCopyMemory((PBYTE) aptl, (PBYTE) aptl1, cptl1 * sizeof(POINTL));
    RtlCopyMemory((PBYTE) &aptl[cptl1], ab1, cptl1 * sizeof(BYTE));
}

/******************************Public*Routine******************************\
* VOID MRPOLYDRAW16::vInit(pmdc, aptl1, ab1, cptl1)
*
* Initializers -- Initialize the metafile MRPOLYDRAW16 record.
*
* History:
*  Sat Mar 07 15:06:16 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID MRPOLYDRAW16::vInit(PMDC pmdc, CONST POINTL *aptl1, CONST BYTE *ab1, DWORD cptl1)
{
    PUTS("MRPOLYDRAW16::vInit\n");

    MRB::vInit(EMR_POLYDRAW16, pmdc);

    cpts = cptl1;
    POINTL_TO_POINTS(apts, aptl1, cptl1);
    RtlCopyMemory((PBYTE) &apts[cptl1], ab1, cptl1 * sizeof(BYTE));
}

/******************************Public*Routine******************************\
* VOID MRTRIANGLEMESH::bInit
*
* Initializers -- Initialize the metafile MRTRIANGLEMESH
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID MRGRADIENTFILL::vInit(DWORD nVer1, CONST TRIVERTEX *pVer1, DWORD nTri1,CONST PVOID pTri1,ULONG ulMode1,PMDC pmdc)
{
    PUTS("MRGRADIENTFILL::vInit\n");

    MRB::vInit(EMR_GRADIENTFILL, pmdc);

    nVer   = nVer1;
    nTri   = nTri1;
    ulMode = ulMode1;

    RtlCopyMemory((PBYTE) &Ver[0],pVer1,nVer * sizeof(TRIVERTEX));

    if (ulMode & GRADIENT_FILL_TRIANGLE)
    {
         RtlCopyMemory((PBYTE) &Ver[nVer],pTri1,nTri * sizeof(GRADIENT_TRIANGLE));
    }
    else
    {
         RtlCopyMemory((PBYTE) &Ver[nVer],pTri1,nTri * sizeof(GRADIENT_RECT));
    }
}

/******************************Public*Routine******************************\
* BOOL MRMETAFILE::bValid()
*
* bValid -- Is this a valid record?
*
* History:
*  Tue Aug 20 18:19:38 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRMETAFILE::bValid()
{
    PUTS("MRMETAFILE::bValid\n");

// We do not check the version.  We will try to play a future version of
// enhanced metafile.

    if (dSignature != ENHMETA_SIGNATURE // check signature
     || iType != EMR_HEADER             // check record type
     || nHandles == 0                   // must have at least a reserved handle
     || nBytes % 4)                     // nBytes must be dword multiples
        return (FALSE);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL MRCREATEPALETTE::bInit(hpal_, imhe_, cEntries_)
*
* Initializers -- Initialize the metafile MRCREATEPALETTE record.
* It sets the peFlags in the palette entries to zeroes.
*
* History:
*  Sun Sep 22 16:34:36 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRCREATEPALETTE::bInit(HPALETTE hpal_, ULONG imhe_, USHORT cEntries_)
{
    PUTS("MRCREATEPALETTE::bInit\n");

    MR::vInit(EMR_CREATEPALETTE);
    imhe = imhe_;
    logpal.palVersion = 0x300;
    logpal.palNumEntries = cEntries_;

    if (GetPaletteEntries(hpal_, 0, (UINT) cEntries_, logpal.palPalEntry)
        != (UINT) cEntries_)
        return(FALSE);

    for (USHORT ii = 0; ii < cEntries_; ii++)
    {
        // Since we don't support PC_EXPLICIT, we set it to black.  This will
        // prevent us from adding meaningless colors to the metafile palette.

        ASSERTGDI(sizeof(PALETTEENTRY) == sizeof(DWORD), "Bad size");

        if (logpal.palPalEntry[ii].peFlags & PC_EXPLICIT)
            *((PDWORD) &logpal.palPalEntry[ii]) = RGB(0,0,0);
        else
            logpal.palPalEntry[ii].peFlags = 0;
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID MRSETPALETTEENTRIES::vInit(imhe_, iStart_, cEntries_, pPalEntries_)
*
* Initializers -- Initialize the metafile MRSETPALETTEENTRIES record.
* It sets the peFlags in the palette entries to zeroes.
*
* History:
*  Sun Sep 22 16:34:36 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID MRSETPALETTEENTRIES::vInit
(
    ULONG imhe_,
    UINT  iStart_,
    UINT  cEntries_,
    CONST PALETTEENTRY *pPalEntries_
)
{
    PUTS("MRSETPALETTEENTRIES::bInit\n");

    MR::vInit(EMR_SETPALETTEENTRIES);
    imhe     = imhe_;
    iStart   = iStart_;
    cEntries = cEntries_;

    for (UINT ii = 0; ii < cEntries_; ii++)
    {
        aPalEntry[ii] = pPalEntries_[ii];

        // Since we don't support PC_EXPLICIT, we set it to black.  This will
        // prevent us from adding meaningless colors to the metafile palette.

        ASSERTGDI(sizeof(PALETTEENTRY) == sizeof(DWORD), "Bad size");

        if (aPalEntry[ii].peFlags & PC_EXPLICIT)
            *((PDWORD) &aPalEntry[ii]) = RGB(0,0,0);
        else
            aPalEntry[ii].peFlags = 0;
    }
}

/******************************Public*Routine******************************\
* BOOL MTEXT::bInit(hdc1, x1, y1, fl1, prc1, pString1, cchString1, pdx1,
*                   pMR1, offString1, cjCh1)
*
* Initializers -- Initialize the base record for all textout metafile records.
*
* History:
*  Thu Aug 24 15:20:33 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MTEXT::bInit
(
    HDC    hdc1,
    int    x1,
    int    y1,
    UINT   fl1,
    CONST RECT *prc1,
    LPCSTR pString1,
    int    cchString1,
    CONST INT *pdx1,
    PMR    pMR1,
    DWORD  offString1,          // dword-aligned aDx follows the string
    int    cjCh1                // size of a character in bytes
)
{
    int    i;
    SIZEL  szl;

    PUTS("MTEXT::bInit\n");

    ASSERTGDI(cjCh1 == sizeof(CHAR) || cjCh1 == sizeof(WCHAR),
        "MTEXT::bInit: bad char size");

    eptlRef.vInit((LONG) x1, (LONG) y1);

    fOptions  = (DWORD) fl1;

    if (fl1 & (ETO_CLIPPED | ETO_OPAQUE))
        ercl.vInit(*(PRECTL) prc1);
    else
        ercl.vInit(rclNull);

    // Copy the string.

    cchString = cchString1;
    offString = offString1;
    RtlCopyMemory((PBYTE) pMR1 + offString1, (PBYTE) pString1, cchString1 * cjCh1);

    // Initialize the Dx array.  If it is not given, we will make one up
    // since we always need one by design!

    offaDx = offString1 + (cchString1 * cjCh1 + 3) / 4 * 4;  // make it dword-aligned
    PLONG aDx = (PLONG) ((PBYTE) pMR1 + offaDx);

    if (pdx1 != (CONST INT *)NULL)
    {
        RtlCopyMemory((PBYTE) aDx, (PBYTE) pdx1,
            cchString1 * (sizeof(LONG) * ((fOptions & ETO_PDY) ? 2 : 1)));
    }
    else if (cchString1 != 0)
    {
        if (cjCh1 == sizeof(CHAR))
        {
            // szl and nMaxExtent are needed by the function!

            if (!GetTextExtentExPointA
                 (
                    hdc1,
                    pString1,
                    cchString1,
                    MAXLONG,
                    (LPINT) NULL,
                    (LPINT) aDx,
                    (LPSIZE) &szl
                 )
               )
            return(FALSE);
        }
        else
        {
            // szl and nMaxExtent are needed by the function!

#ifdef LANGPACK
        // [bodind], I think this is non optimal solution
        //           this should be done more elegantly

            if (gbLpk)     // check if there is an LPK
            {
              BOOL bTmp;
              InterlockedIncrement( &gdwDisableMetafileRec ) ;
              bTmp = GetTextExtentExPointW
                     (
                      hdc1,
                      (LPWSTR) pString1,
                      cchString1,
                      (ULONG)0xffffffff,
                      NULL,
                      (PINT) aDx,
                      (LPSIZE) &szl
                     );
              InterlockedDecrement( &gdwDisableMetafileRec ) ;

              if (!bTmp)
              {
                return FALSE ;
              }
            }
            else
#endif
            {
                if (!NtGdiGetTextExtentExW
                     (
                        hdc1,
                        (LPWSTR) pString1,
                        cchString1,
                        (ULONG)0xffffffff,
                        NULL,
                        (PULONG) aDx,
                        (LPSIZE) &szl, 0
                     )
                   )
                return(FALSE);
            }
        }

        // Convert partial widths to individual widths.

        for (i = cchString1 - 1; i > 0; i--)
            aDx[i] -= aDx[i - 1];
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL MRMETAFILE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRMETAFILE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRMETAFILE::bPlay\n");
    ASSERTGDI(iType == EMR_HEADER, "Bad record type");

    USE(cht);

// If we are embedding the metafile, emit the public begin group comment.

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;
        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC)
        {
            PMF   pmf;

            // Get metafile.

            if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
                return(FALSE);

            // Indicate we have emitted the begin group public comment for embedding this
            // enhanced metafile.

            pmf->bBeginGroup = TRUE;
            return(MF_GdiCommentBeginGroupEMF(hdc, (PENHMETAHEADER) this));
        }
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL MRPOLYBEZIER::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYBEZIER::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRPOLYBEZIER::bPlay\n");
    ASSERTGDI(iType == EMR_POLYBEZIER, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(PolyBezier(hdc, (LPPOINT) aptl, cptl));
}

/******************************Public*Routine******************************\
* BOOL MRPOLYGON::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYGON::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRPOLYGON::bPlay\n");
    ASSERTGDI(iType == EMR_POLYGON, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(Polygon(hdc, (LPPOINT) aptl, (int) cptl));
}

/******************************Public*Routine******************************\
* BOOL MRPOLYLINE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYLINE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRPOLYLINE::bPlay\n");
    ASSERTGDI(iType == EMR_POLYLINE, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(Polyline(hdc, (LPPOINT) aptl, (int) cptl));
}

/******************************Public*Routine******************************\
* BOOL MRGRADIENTFILL::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL MRGRADIENTFILL::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRGRADIENTFILL::bPlay\n");
    ASSERTGDI(iType == EMR_GRADIENTFILL, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(GdiGradientFill(hdc,&Ver[0],nVer,(PUSHORT)(&Ver[nVer]),nTri,ulMode));
}

/******************************Public*Routine******************************\
* BOOL MRPOLYBEZIERTO::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYBEZIERTO::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRPOLYBEZIERTO::bPlay\n");
    ASSERTGDI(iType == EMR_POLYBEZIERTO, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(PolyBezierTo(hdc, (LPPOINT) aptl, cptl));
}

/******************************Public*Routine******************************\
* BOOL MRPOLYLINETO::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYLINETO::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRPOLYLINETO::bPlay\n");
    ASSERTGDI(iType == EMR_POLYLINETO, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(PolylineTo(hdc, (LPPOINT) aptl, cptl));
}

/******************************Public*Routine******************************\
* BOOL MRBP16::bPlay(hdc, pht, cht)
*
* Play the 16-bit metafile records PolyBezier, Polygon, Polyline, PolyBezierTo
* and PolylineTo.
*
* History:
*  Sat Mar 07 15:06:16 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRBP16::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    BOOL    bRet = FALSE;
    POINTL  aptl[MAX_STACK_POINTL];
    PPOINTL pptl;

    PUTS("MRBP16::bPlay\n");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(bRet);

    if (cpts <= MAX_STACK_POINTL)
        pptl = aptl;
    else if (!(pptl = (PPOINTL) LocalAlloc(LMEM_FIXED, (UINT) cpts * sizeof(POINTL))))
        return(bRet);

    POINTS_TO_POINTL(pptl, apts, cpts);

    switch (iType)
    {
    case EMR_POLYBEZIER16:
        bRet = PolyBezier(hdc, (LPPOINT) pptl, cpts);
        break;
    case EMR_POLYGON16:
        bRet = Polygon(hdc, (LPPOINT) pptl, (int) cpts);
        break;
    case EMR_POLYLINE16:
        bRet = Polyline(hdc, (LPPOINT) pptl, (int) cpts);
        break;
    case EMR_POLYBEZIERTO16:
        bRet = PolyBezierTo(hdc, (LPPOINT) pptl, cpts);
        break;
    case EMR_POLYLINETO16:
        bRet = PolylineTo(hdc, (LPPOINT) pptl, cpts);
        break;
    default:
        ASSERTGDI(FALSE, "Bad record type");
        break;
    }

    if (cpts > MAX_STACK_POINTL)
    {
        if (LocalFree(pptl))
        {
            ASSERTGDI(FALSE, "MRBP16::bPlay: LocalFree failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRPOLYPOLYLINE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYPOLYLINE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRPOLYPOLYLINE::bPlay\n");
    ASSERTGDI(iType == EMR_POLYPOLYLINE, "Bad record type");

    USE(pht);
    USE(cht);
    if(!bCheckRecord(pht))
        return(FALSE);
    return(PolyPolyline(hdc, (LPPOINT) &ac[cPoly], ac, cPoly));
}

/******************************Public*Routine******************************\
* BOOL MRPOLYPOLYGON::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYPOLYGON::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRPOLYPOLYGON::bPlay\n");
    ASSERTGDI(iType == EMR_POLYPOLYGON, "Bad record type");

    USE(pht);
    USE(cht);
    if(!bCheckRecord(pht))
        return(FALSE);
    return(PolyPolygon(hdc, (LPPOINT) &ac[cPoly], (LPINT) ac, (int) cPoly));
}

/******************************Public*Routine******************************\
* BOOL MRBPP16::bPlay(hdc, pht, cht)
*
* Play the 16-bit metafile records PolyPolyline, PolyPolygon.
*
* History:
*  Sat Mar 07 15:06:16 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRBPP16::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    BOOL    bRet = FALSE;
    PPOINTL pptl;
    POINTL  aptl[MAX_STACK_POINTL];

    PUTS("MRBPP16::bPlay\n");

    USE(pht);
    USE(cht);

    if(!bCheckRecord(pht))
        return(FALSE);
    if (cpts <= MAX_STACK_POINTL)
        pptl = aptl;
    else if (!(pptl = (PPOINTL) LocalAlloc(LMEM_FIXED, (UINT) cpts * sizeof(POINTL))))
        return(bRet);

    POINTS_TO_POINTL(pptl, (PPOINTS) &ac[cPoly], cpts);

    switch (iType)
    {
    case EMR_POLYPOLYLINE16:
        bRet = PolyPolyline(hdc, (LPPOINT) pptl, ac, cPoly);
        break;
    case EMR_POLYPOLYGON16:
        bRet = PolyPolygon(hdc, (LPPOINT) pptl, (LPINT) ac, (int) cPoly);
        break;
    default:
        ASSERTGDI(FALSE, "Bad record type");
        break;
    }

    if (cpts > MAX_STACK_POINTL)
    {
        if (LocalFree(pptl))
        {
            ASSERTGDI(FALSE, "MRBPP16::bPlay: LocalFree failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRPOLYDRAW::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 14:06:04 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYDRAW::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRPOLYDRAW::bPlay\n");
    ASSERTGDI(iType == EMR_POLYDRAW, "Bad record type");

    USE(pht);
    USE(cht);
    if(!bCheckRecord(pht))
        return(FALSE);
    return(PolyDraw(hdc, (LPPOINT) aptl, (LPBYTE) &aptl[cptl], (int) cptl));
}

/******************************Public*Routine******************************\
* BOOL MRPOLYDRAW16::bPlay(hdc, pht, cht)
*
* Play the 16-bit metafile record.
*
* History:
*  Sat Mar 07 15:06:16 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYDRAW16::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    BOOL    bRet = FALSE;
    POINTL  aptl[MAX_STACK_POINTL];
    PPOINTL pptl;

    PUTS("MRPOLYDRAW16::bPlay\n");
    ASSERTGDI(iType == EMR_POLYDRAW16, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);

    if (cpts <= MAX_STACK_POINTL)
        pptl = aptl;
    else if (!(pptl = (PPOINTL) LocalAlloc(LMEM_FIXED, (UINT) cpts * sizeof(POINTL))))
        return(bRet);

    POINTS_TO_POINTL(pptl, apts, cpts);

    bRet = PolyDraw(hdc, (LPPOINT) pptl, (LPBYTE) &apts[cpts], (int) cpts);

    if (cpts > MAX_STACK_POINTL)
    {
        if (LocalFree(pptl))
        {
            ASSERTGDI(FALSE, "MRPOLYDRAW16::bPlay: LocalFree failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRSETWINDOWEXTEX::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETWINDOWEXTEX::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSETWINDOWEXTEX::bPlay\n");
    ASSERTGDI(iType == EMR_SETWINDOWEXTEX, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);

// Cannot change extent in fixed scale mapping mode.

    if (GetMapMode(pmf->hdcXform) <= MM_MAX_FIXEDSCALE)
        return(TRUE);

// Play it to the virtual DC.

    if (!SetWindowExtEx(pmf->hdcXform, (int) d1, (int) d2, (LPSIZE) NULL))
        return(FALSE);

// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSETWINDOWORGEX::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETWINDOWORGEX::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSETWINDOWORGEX::bPlay\n");
    ASSERTGDI(iType == EMR_SETWINDOWORGEX, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);

// Play it to the virtual DC.

    if (!SetWindowOrgEx(pmf->hdcXform, (int) d1, (int) d2, (LPPOINT) NULL))
        return(FALSE);

// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSETVIEWPORTEXTEX::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETVIEWPORTEXTEX::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSETVIEWPORTEXTEX::bPlay\n");
    ASSERTGDI(iType == EMR_SETVIEWPORTEXTEX, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);

// Cannot change extent in fixed scale mapping mode.

    if (GetMapMode(pmf->hdcXform) <= MM_MAX_FIXEDSCALE)
        return(TRUE);

// Play it to the virtual DC.

    if (!SetViewportExtEx(pmf->hdcXform, (int) d1, (int) d2, (LPSIZE) NULL))
        return(FALSE);

// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSETVIEWPORTORGEX::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETVIEWPORTORGEX::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSETVIEWPORTORGEX::bPlay\n");
    ASSERTGDI(iType == EMR_SETVIEWPORTORGEX, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);

// Play it to the virtual DC.

    if (!SetViewportOrgEx(pmf->hdcXform, (int) d1, (int) d2, (LPPOINT) NULL))
        return(FALSE);

// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSETBRUSHORGEX::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETBRUSHORGEX::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSETBRUSHORGEX::bPlay\n");
    ASSERTGDI(iType == EMR_SETBRUSHORGEX, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);

// Since we do not scale brush patterns, we set the brush origin is in
// the original device units.

   return(SetBrushOrgEx(hdc, (int) d1, (int) d2, (LPPOINT) NULL));
}

/******************************Public*Routine******************************\
* BOOL MREOF::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MREOF::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MREOF::bPlay\n");
    ASSERTGDI(iType == EMR_EOF, "Bad record type");

    USE(cht);

// If we emitted the begin group public comment earlier, emit the corresponding
// end group comment now.

// If we are embedding the metafile, emit the public end group comment.

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC)
        {
            PMF   pmf;

            // Get metafile.

            if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
                return(FALSE);

            if (!bCheckRecord(pht))
                return(FALSE);

            if (pmf->bBeginGroup)
            {
                pmf->bBeginGroup = FALSE;
                return(MF_GdiCommentEndGroupEMF(hdc));
            }
        }
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL MRGDICOMMENT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Wed Apr 28 10:43:12 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRGDICOMMENT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRGDICOMMENT::bPlay\n");
    ASSERTGDI(iType == EMR_GDICOMMENT, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);

// Handle private comments first.

    if (!bIsPublicComment())
        return(GdiComment(hdc, (UINT) cb, abComment));

// Handle public comments.

    switch (((PEMRGDICOMMENT_PUBLIC) this)->iComment)
    {
    case GDICOMMENT_UNICODE_STRING:
    case GDICOMMENT_UNICODE_END:
       return (TRUE);

    case GDICOMMENT_WINDOWS_METAFILE:
    case GDICOMMENT_BEGINGROUP:
    case GDICOMMENT_ENDGROUP:
    default:
        return(GdiComment(hdc, (UINT) cb, abComment));

    case GDICOMMENT_MULTIFORMATS:
        {
            HENHMETAFILE hemf;
            BOOL         bRet;
            int          nEscape;
            PEMRGDICOMMENT_MULTIFORMATS pemrcmf;

        // Do embedding.

            if (IS_ALTDC_TYPE(hdc))
            {
                PLDC pldc;

                DC_PLDC(hdc,pldc,FALSE);

                if (pldc->iType == LO_METADC)
                    return(GdiComment(hdc, (UINT) cb, abComment));
            }

        // Playback the first recognizable format.

            pemrcmf = (PEMRGDICOMMENT_MULTIFORMATS) this;
            for (DWORD i = 0; i < pemrcmf->nFormats; i++)
            {
                switch (pemrcmf->aemrformat[i].dSignature)
                {
                case ENHMETA_SIGNATURE:
                    if (pemrcmf->aemrformat[i].nVersion <= META_FORMAT_ENHANCED)
                    {
                        hemf = SetEnhMetaFileBits(
                                (UINT) pemrcmf->aemrformat[i].cbData,
                                &abComment[pemrcmf->aemrformat[i].offData]);
                        bRet = PlayEnhMetaFile(hdc, hemf,
                                (LPRECT) &pemrcmf->rclOutput);
                        DeleteEnhMetaFile(hemf);
                        return(bRet);
                    }
                    break;

                case EPS_SIGNATURE:
                    nEscape = ENCAPSULATED_POSTSCRIPT;
                    if (DrawEscape(hdc, QUERYESCSUPPORT,
                        sizeof(nEscape), (LPCSTR) &nEscape) > 0)
                    {
                        int        iRet;
                        DWORD      cbEpsData;
                        PEPSDATA   pEpsData;
                        POINT      aptl3[3];

                        cbEpsData = sizeof(EPSDATA)
                                     + pemrcmf->aemrformat[i].cbData;
                        pEpsData = (PEPSDATA) LocalAlloc(LMEM_FIXED,
                                       (UINT) cbEpsData);
                        if (!pEpsData)
                            break;      // try the next format

                        aptl3[0].x = pemrcmf->rclOutput.left;
                        aptl3[0].y = pemrcmf->rclOutput.top;
                        aptl3[1].x = pemrcmf->rclOutput.right;
                        aptl3[1].y = pemrcmf->rclOutput.top;
                        aptl3[2].x = pemrcmf->rclOutput.left;
                        aptl3[2].y = pemrcmf->rclOutput.bottom;
                        if (!NtGdiTransformPoints(hdc,aptl3,pEpsData->aptl,3,XFP_LPTODPFX))
                        {
                            LocalFree((HLOCAL) pEpsData);
                            return(FALSE);
                        }

                        pEpsData->cbData   = cbEpsData;
                        pEpsData->nVersion = pemrcmf->aemrformat[i].nVersion;
                        RtlCopyMemory
                        (
                            (PBYTE) &pEpsData[1],
                            &abComment[pemrcmf->aemrformat[i].offData],
                            pemrcmf->aemrformat[i].cbData
                        );

                        iRet = DrawEscape(hdc, nEscape, (int) cbEpsData,
                                (LPCSTR) pEpsData);

                        if (LocalFree((HLOCAL) pEpsData))
                        {
                            ASSERTGDI(FALSE, "LocalFree failed");
                        }

                        // DrawEscape returns ERROR_NOT_SUPPORTED if it cannot
                        // draw this EPS data.  For example, the EPS data
                        // may be level 2 but the driver supports only level 1.

                        if (iRet <= 0 && GetLastError() == ERROR_NOT_SUPPORTED)
                            break;      // try the next format

                        return(iRet > 0);
                    }
                    break;
                }
            }

            VERIFYGDI(FALSE, "MRGDICOMMENT::bPlay: No recognized format in GDICOMMENT_MULTIFORMATS public comments\n");
            return(FALSE);       // no format found!
        }
        break;
    } // switch (((PEMRGDICOMMENT_PUBLIC) this)->iComment)

// Should not get here!

    ASSERTGDI(FALSE, "MRGDICOMMENT::bPlay: unexpected error");
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL MRSETPIXELV::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETPIXELV::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETPIXELV::bPlay\n");
    ASSERTGDI(iType == EMR_SETPIXELV, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(SetPixelV(hdc, (int) eptl.x, (int) eptl.y, crColor));
}

/******************************Public*Routine******************************\
* BOOL MRSETMAPPERFLAGS::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETMAPPERFLAGS::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETMAPPERFLAGS::bPlay\n");
    ASSERTGDI(iType == EMR_SETMAPPERFLAGS, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(SetMapperFlags(hdc, d1) != GDI_ERROR);
}

/******************************Public*Routine******************************\
* BOOL MRSETMAPMODE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETMAPMODE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;
    int   iMapModeOld;

    PUTS("MRSETMAPMODE::bPlay\n");
    ASSERTGDI(iType == EMR_SETMAPMODE, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);

// Play it to the virtual DC.

    if (!(iMapModeOld = SetMapMode(pmf->hdcXform, (int) d1)))
        return(FALSE);

// No need to recompute transform if there is no change in mapping mode
// AND it is not MM_ISOTROPIC.

    if (iMapModeOld == (int) d1 && iMapModeOld != MM_ISOTROPIC)
        return(TRUE);

// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSETLAYOUT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETLAYOUT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;
    DWORD dwOrientationOld;

    PUTS("MRSETLAYOUT::bPlay\n");
    ASSERTGDI(iType == EMR_SETLAYOUT, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);

// Play it to the virtual DC.

    if ((dwOrientationOld = SetLayout(pmf->hdcXform, (DWORD) d1)) == GDI_ERROR)
        return(FALSE);

// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSETBKMODE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETBKMODE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETBKMODE::bPlay\n");
    ASSERTGDI(iType == EMR_SETBKMODE, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(SetBkMode(hdc, (int) d1) != 0);
}

/******************************Public*Routine******************************\
* BOOL MRSETPOLYFILLMODE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETPOLYFILLMODE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETPOLYFILLMODE::bPlay\n");
    ASSERTGDI(iType == EMR_SETPOLYFILLMODE, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(SetPolyFillMode(hdc, (int) d1) != 0);
}

/******************************Public*Routine******************************\
* BOOL MRSETROP2::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETROP2::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETROP2::bPlay\n");
    ASSERTGDI(iType == EMR_SETROP2, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(SetROP2(hdc, (int) d1) != 0);
}

/******************************Public*Routine******************************\
* BOOL MRSETSTRETCHBLTMODE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETSTRETCHBLTMODE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETSTRETCHBLTMODE::bPlay\n");
    ASSERTGDI(iType == EMR_SETSTRETCHBLTMODE, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(SetStretchBltMode(hdc, (int) d1) != 0);
}

/******************************Public*Routine******************************\
* BOOL MRSETTEXTALIGN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETTEXTALIGN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETTEXTALIGN::bPlay\n");
    ASSERTGDI(iType == EMR_SETTEXTALIGN, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(SetTextAlign(hdc, (UINT) d1) != GDI_ERROR);
}

/******************************Public*Routine******************************\
* BOOL MRSETTEXTCOLOR::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETTEXTCOLOR::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETTEXTCOLOR::bPlay\n");
    ASSERTGDI(iType == EMR_SETTEXTCOLOR, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(SetTextColor(hdc, (COLORREF) d1) != CLR_INVALID);
}

/******************************Public*Routine******************************\
* BOOL MRSETBKCOLOR::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETBKCOLOR::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETBKCOLOR::bPlay\n");
    ASSERTGDI(iType == EMR_SETBKCOLOR, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(SetBkColor(hdc, (COLORREF) d1) != CLR_INVALID);
}

/******************************Public*Routine******************************\
* BOOL MRSETICMMODE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*
*    9/19/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL MRSETICMMODE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETICMMODE::bPlay\n");
    ASSERTGDI(iType == EMR_SETICMMODE, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return((SetICMMode(hdc, (int) d1) != 0));
}

/******************************Public*Routine******************************\
* BOOL MRSETCOLORSPACE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*
*    9/19/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL MRSETCOLORSPACE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    HCOLORSPACE hColorSpace;
    PUTS("MRSETCOLORSPACE::bPlay\n");
    ASSERTGDI(iType == EMR_SETCOLORSPACE, "Bad record type");

    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);
    if(STOCK_IMHE(d1))
    {
        hColorSpace = (HCOLORSPACE) GetStockObject(d1 & ~ENHMETA_STOCK_OBJECT);
    }
    else
    {
        hColorSpace = (HCOLORSPACE) pht->objectHandle[d1];
    }

    return((SetColorSpace(hdc, hColorSpace) != 0));
}

/******************************Public*Routine******************************\
* BOOL MRCREATECOLORSPACE::bPlay(hdc, pht, cht)
*
* Play the metafile record (Windows 98 compatible record)
*
* History:
*
*    7/15/1998 Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

BOOL MRCREATECOLORSPACE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRCREATECOLORSPACE::bPlay\n");
    ASSERTGDI(iType == EMR_CREATECOLORSPACE, "Bad record type");

    USE(hdc);

    if (!bCheckRecord(pht))
        return(FALSE);
// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

    pht->objectHandle[imhe] = CreateColorSpaceA(&lcsp);
    return(pht->objectHandle[imhe] != 0);
}

/******************************Public*Routine******************************\
* BOOL MRDELETECOLORSPACE::bPlay(hdc, pht, cht)
*
* Play the metafile record - stub for deletecolorspace
*
* History:
*
*    9/19/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL MRDELETECOLORSPACE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRDELETECOLORSPACE::bPlay\n");
    ASSERTGDI(iType == EMR_DELETECOLORSPACE, "Bad record type");

    USE(hdc);
    USE(pht);
    USE(cht);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL MRSETARCDIRECTION::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 16:46:33 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETARCDIRECTION::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETARCDIRECTION::bPlay\n");
    ASSERTGDI(iType == EMR_SETARCDIRECTION, "Bad record type");

    USE(pht);
    USE(cht);

// Arc direction is recorded in the advanced graphics mode.  Make sure we have
// set the advanced graphics mode.

    ASSERTGDI
    (
        GetGraphicsMode(hdc) == GM_ADVANCED,
        "MR::bPlay: Not in advanced graphics mode"
    );

    if (!bCheckRecord(pht))
        return(FALSE);
    return(SetArcDirection(hdc, (int) d1) != 0);
}

/******************************Public*Routine******************************\
* BOOL MRSETMITERLIMIT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 16:46:33 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETMITERLIMIT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETMITERLIMIT::bPlay\n");
    ASSERTGDI(iType == EMR_SETMITERLIMIT, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(SetMiterLimit(hdc, (FLOAT) d1, (PFLOAT) NULL) != GDI_ERROR);
}

/******************************Public*Routine******************************\
* BOOL MRMOVETOEX::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRMOVETOEX::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRMOVETOEX::bPlay\n");
    ASSERTGDI(iType == EMR_MOVETOEX, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(MoveToEx(hdc, (int) d1, (int) d2, (LPPOINT) NULL));
}

/******************************Public*Routine******************************\
* BOOL MRLINETO::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Wed Oct 02 10:30:36 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRLINETO::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRLINETO::bPlay\n");
    ASSERTGDI(iType == EMR_LINETO, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(LineTo(hdc, (int) d1, (int) d2));
}

/******************************Public*Routine******************************\
* BOOL MREXCLUDECLIPRECT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MREXCLUDECLIPRECT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MREXCLUDECLIPRECT::bPlay\n");
    ASSERTGDI(iType == EMR_EXCLUDECLIPRECT, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);
    return
    (
        ExcludeClipRect
        (
            hdc,
            (int) d1,
            (int) d2,
            (int) d3,
            (int) d4
        )
        != RGN_ERROR
    );
}

/******************************Public*Routine******************************\
* BOOL MRINTERSECTCLIPRECT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRINTERSECTCLIPRECT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRINTERSECTCLIPRECT::bPlay\n");
    ASSERTGDI(iType == EMR_INTERSECTCLIPRECT, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);
    return
    (
        IntersectClipRect
        (
            hdc,
            (int) d1,
            (int) d2,
            (int) d3,
            (int) d4
        )
        != RGN_ERROR
    );
}

/******************************Public*Routine******************************\
* BOOL MRINVERTRGN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Tue Oct 29 13:44:38 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRINVERTRGN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;
    BOOL  bRet;
    HRGN  hrgn;

    PUTS("MRINVERTRGN::bPlay\n");
    ASSERTGDI(iType == EMR_INVERTRGN, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);
// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Create the region.

    if (!(hrgn = ExtCreateRegion((LPXFORM) NULL, cRgnData, (LPRGNDATA) &this[1])))
        return(FALSE);

    bRet = InvertRgn(hdc, hrgn);

    if (!DeleteObject(hrgn))
    {
        ASSERTGDI(FALSE, "DeleteObject failed");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRPAINTRGN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Tue Oct 29 13:44:38 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPAINTRGN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;
    BOOL  bRet;
    HRGN  hrgn;

    PUTS("MRPAINTRGN::bPlay\n");
    ASSERTGDI(iType == EMR_PAINTRGN, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);
// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Create the region.

    if (!(hrgn = ExtCreateRegion((LPXFORM) NULL, cRgnData, (LPRGNDATA) &this[1])))
        return(FALSE);

    bRet = PaintRgn(hdc, hrgn);

    if (!DeleteObject(hrgn))
    {
        ASSERTGDI(FALSE, "DeleteObject failed");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRFILLRGN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Tue Oct 29 13:44:38 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRFILLRGN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF    pmf;
    BOOL   bRet;
    HRGN   hrgn;
    HBRUSH hbr;

    PUTS("MRFILLRGN::bPlay\n");
    ASSERTGDI(iType == EMR_FILLRGN, "Bad record type");

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);
// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Get the brush handle.

    if (STOCK_IMHE(imheBrush))
    {
        // Stock brush.

        hbr = (HBRUSH) GetStockObject(imheBrush & ~ENHMETA_STOCK_OBJECT);
    }
    else
    {
        // Make sure the handle is in the table.

        if (!VALID_IMHE(imheBrush, cht))
            return(FALSE);

        // If brush creation failed earlier, hbr is 0 and FillRgn will
        // just return an error.

        hbr = (HBRUSH) pht->objectHandle[imheBrush];
    }

// Create the region.

    if (!(hrgn = ExtCreateRegion((LPXFORM) NULL, cRgnData, (LPRGNDATA) &this[1])))
        return(FALSE);

    bRet = FillRgn(hdc, hrgn, hbr);

    if (!DeleteObject(hrgn))
    {
        ASSERTGDI(FALSE, "DeleteObject failed");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRFRAMERGN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Tue Oct 29 13:44:38 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRFRAMERGN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF    pmf;
    BOOL   bRet;
    HRGN   hrgn;
    HBRUSH hbr;

    PUTS("MRFRAMERGN::bPlay\n");
    ASSERTGDI(iType == EMR_FRAMERGN, "Bad record type");

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);
// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Get the brush handle.

    if (STOCK_IMHE(imheBrush))
    {
        // Stock brush.

        hbr = (HBRUSH) GetStockObject(imheBrush & ~ENHMETA_STOCK_OBJECT);
    }
    else
    {
        // Make sure the handle is in the table.

        if (!VALID_IMHE(imheBrush, cht))
            return(FALSE);

        // If brush creation failed earlier, hbr is 0 and FrameRgn will
        // just return an error.

        hbr = (HBRUSH) pht->objectHandle[imheBrush];
    }

// Create the region.

    if (!(hrgn = ExtCreateRegion((LPXFORM) NULL, cRgnData, (LPRGNDATA) &this[1])))
        return(FALSE);

    bRet = FrameRgn(hdc, hrgn, hbr, (int) nWidth, (int) nHeight);

    if (!DeleteObject(hrgn))
    {
        ASSERTGDI(FALSE, "DeleteObject failed");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MROFFSETCLIPRGN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Tue Oct 29 13:44:38 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MROFFSETCLIPRGN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MROFFSETCLIPRGN::bPlay\n");
    ASSERTGDI(iType == EMR_OFFSETCLIPRGN, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);
// Since we have moved the initial destination clip region into the meta
// region (hrgnMeta), the offset will not affect the initial clip region.

    return(OffsetClipRgn(hdc, (int) d1, (int) d2) != RGN_ERROR);
}

/******************************Public*Routine******************************\
* BOOL MREXTSELECTCLIPRGN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Tue Oct 29 13:44:38 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MREXTSELECTCLIPRGN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;
    BOOL  bRet;
    HRGN  hrgn;

    PUTS("MREXTSELECTCLIPRGN::bPlay\n");
    ASSERTGDI(iType == EMR_EXTSELECTCLIPRGN, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);
// Create the region if necessary.
// The region will be created in the destination units.

    if (cRgnData == 0)          // default region
    {
        ASSERTGDI(iMode == RGN_COPY,
            "MREXTSELECTCLIPRGN::bPlay: No region data");
        hrgn = (HRGN) 0;
    }
    else if (!(hrgn = ExtCreateRegion(&pmf->xformBase,
                                                // this happens to be xformBase
                                      cRgnData,
                                      (LPRGNDATA) &this[1])))
        return(FALSE);

// Since we have moved the initial destination clip region into the meta
// region (hrgnMeta), the select will not affect the initial clip region.

    bRet = ExtSelectClipRgn(hdc, hrgn, (int) iMode) != RGN_ERROR;

    if (hrgn)
    {
        if (!DeleteObject(hrgn))
        {
            ASSERTGDI(FALSE, "DeleteObject failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRSETMETARGN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Tue Apr 07 17:59:25 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETMETARGN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETMETARGN::bPlay\n");
    ASSERTGDI(iType == EMR_SETMETARGN, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);
    return(SetMetaRgn(hdc) != RGN_ERROR);
}

/******************************Public*Routine******************************\
* BOOL MRSCALEVIEWPORTEXTEX::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSCALEVIEWPORTEXTEX::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSCALEVIEWPORTEXTEX::bPlay\n");
    ASSERTGDI(iType == EMR_SCALEVIEWPORTEXTEX, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Cannot change extent in fixed scale mapping mode.

    if (GetMapMode(pmf->hdcXform) <= MM_MAX_FIXEDSCALE)
        return(TRUE);

    if (!bCheckRecord(pht))
        return(FALSE);
// Play it to the virtual DC.

    if (!ScaleViewportExtEx(pmf->hdcXform,
                          (int) d1,
                          (int) d2,
                          (int) d3,
                          (int) d4,
                          (LPSIZE) NULL))
        return(FALSE);

// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSCALEWINDOWEXTEX::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSCALEWINDOWEXTEX::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSCALEWINDOWEXTEX::bPlay\n");
    ASSERTGDI(iType == EMR_SCALEWINDOWEXTEX, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Cannot change extent in fixed scale mapping mode.

    if (GetMapMode(pmf->hdcXform) <= MM_MAX_FIXEDSCALE)
        return(TRUE);

    if (!bCheckRecord(pht))
        return(FALSE);
// Play it to the virtual DC.

    if (!ScaleWindowExtEx(pmf->hdcXform,
                        (int) d1,
                        (int) d2,
                        (int) d3,
                        (int) d4,
                        (LPSIZE) NULL))
        return(FALSE);

// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSAVEDC::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSAVEDC::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSAVEDC::bPlay\n");
    ASSERTGDI(iType == EMR_SAVEDC, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);
// Save the virtual DC used for transform computation.

    if (!SaveDC(pmf->hdcXform))
        return(FALSE);

// We may need to save the MF data structure here.  Luckily there is no
// other data in the MF structure that requires us to do this.
// Save the target DC.

    if (SaveDC(hdc) == 0)
    {
        RestoreDC(pmf->hdcXform, -1);
        return(FALSE);
    }

    pmf->cLevel++;
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL MRRESTOREDC::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRRESTOREDC::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRRESTOREDC::bPlay\n");
    ASSERTGDI(iType == EMR_RESTOREDC, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);
// No absolute level restore is allowed.

    if ((int) d1 > 0)
        return(FALSE);

// Restore the virtual DC used for transform computation.
// If we can restore the virtual DC, we know that it is a balanced restore.
// Otherwise, we return an error.

    if (!RestoreDC(pmf->hdcXform, (int) d1))
        return(FALSE);

// Restore the target DC.

    pmf->cLevel += d1;
    return(RestoreDC(hdc, (int) d1));
}

/******************************Public*Routine******************************\
* BOOL MRSETWORLDTRANSFORM::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETWORLDTRANSFORM::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSETWORLDTRANSFORM::bPlay\n");
    ASSERTGDI(iType == EMR_SETWORLDTRANSFORM, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);
// Play it to the virtual DC.

    if (!SetWorldTransform(pmf->hdcXform, &xform))
        return(FALSE);

// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRMODIFYWORLDTRANSFORM::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRMODIFYWORLDTRANSFORM::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRMODIFYWORLDTRANSFORM::bPlay\n");
    ASSERTGDI(iType == EMR_MODIFYWORLDTRANSFORM, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);
// Play it to the virtual DC.

    if (!ModifyWorldTransform(pmf->hdcXform, &xform, d1))
        return(FALSE);

// Do the easy case of left multiply.

    if (d1 == MWT_LEFTMULTIPLY)
        return(ModifyWorldTransform(hdc, &xform, d1));

// Recompute transform in the other two cases.
// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSELECTOBJECT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSELECTOBJECT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSELECTOBJECT::bPlay\n");
    ASSERTGDI(iType == EMR_SELECTOBJECT, "Bad record type");

    if (!bCheckRecord(pht))
        return(FALSE);
// Do stock objects first.

    if (STOCK_IMHE(d1))
        return
        (
            SelectObject(hdc, GetStockObject(d1 & ~ENHMETA_STOCK_OBJECT))
            != 0
        );

// Make sure the handle is in the table.

    if (!VALID_IMHE(d1, cht))
        return(FALSE);

// If object creation failed earlier, object handle is 0 and SelectObject
// will just return an error.

    return(SelectObject(hdc, pht->objectHandle[d1]) != 0);
}

/******************************Public*Routine******************************\
* BOOL MRSELECTPALETTE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
* The palette is always selected as a background palette.
*
* History:
*  Sun Sep 22 16:53:24 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSELECTPALETTE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSELECTPALETTE::bPlay\n");
    ASSERTGDI(iType == EMR_SELECTPALETTE, "Bad record type");

    if (!bCheckRecord(pht))
        return(FALSE);
// Do stock palette first.

    if (d1 == (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
        return
        (
            SelectPalette(hdc, (HPALETTE) GetStockObject(DEFAULT_PALETTE), TRUE)
            != 0
        );

// Make sure the handle is in the table.

    if (!VALID_IMHE(d1, cht))
        return(FALSE);

// If palette creation failed earlier, hpal is 0 and SelectPalette will
// just return an error.

    return(SelectPalette(hdc, (HPALETTE) pht->objectHandle[d1], TRUE) != 0);
}

/******************************Public*Routine******************************\
* BOOL MRCOLORCORRECTPALETTE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
\**************************************************************************/

BOOL MRCOLORCORRECTPALETTE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRCOLORCORRECTPALETTE::bPlay\n");
    ASSERTGDI(iType == EMR_COLORCORRECTPALETTE, "Bad record type");

    if (!bCheckRecord(pht))
        return(FALSE);
// Make sure the handle is in the table.

    if (!VALID_IMHE(d1, cht))
        return(FALSE);

    return(ColorCorrectPalette(hdc, (HPALETTE) pht->objectHandle[d1], d2, d3) != 0);
}

/******************************Public*Routine******************************\
* BOOL MRCREATEPEN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRCREATEPEN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRCREATEPEN::bPlay\n");
    ASSERTGDI(iType == EMR_CREATEPEN, "Bad record type");

    USE(hdc);

    if (!bCheckRecord(pht))
        return(FALSE);
// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

// Create the pen and store it in the table.

    pht->objectHandle[imhe] = CreatePenIndirect(&logpen);
    return(pht->objectHandle[imhe] != 0);
}

/******************************Public*Routine******************************\
* BOOL MREXTCREATEPEN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Mon Mar 16 18:20:11 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MREXTCREATEPEN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    LOGBRUSH lb;
    HBITMAP  hbm = (HBITMAP) 0;

    PUTS("MREXTCREATEPEN::bPlay\n");
    ASSERTGDI(iType == EMR_EXTCREATEPEN, "Bad record type");

    USE(hdc);

    if (!bCheckRecord(pht))
        return(FALSE);
// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

// Create the brush if any.

    lb.lbStyle = elp.elpBrushStyle;
    lb.lbColor = elp.elpColor;
    lb.lbHatch = (ULONG_PTR)(elp.elpHatch);

    if (elp.elpBrushStyle == BS_PATTERN)
    {
        if (!bValidOff(pht, offBitsInfo) || !bValidOff(pht, offBits))
        {
            EMFVALFAIL(("MREXTCREATEPEN::bPlay: bValidOff offBitsInfo = %08x, offBits = %08x Failed\n", offBitsInfo, offBits));
            goto mecp_exit;
        }

        // Mono bitmap.
        if (!(hbm = CreateMonoDib
                    (
                        (PBMI) ((PBYTE) this + offBitsInfo),
                        (CONST BYTE *) ((PBYTE) this + offBits),
                        *(PUINT) &elp.elpColor
                    )
             )
           )
            goto mecp_exit;

        lb.lbHatch = (ULONG_PTR)hbm;
    }
    else if (elp.elpBrushStyle == BS_DIBPATTERNPT
          || elp.elpBrushStyle == BS_DIBPATTERN)
    {
        // DIB bitmap.
        if (!bValidOff(pht, offBitsInfo))
        {
            EMFVALFAIL(("MREXTCREATEPEN::bPlay: bValidOff offBitsInfo = %08x Failed\n", offBitsInfo));
            goto mecp_exit;
        }

        lb.lbStyle = BS_DIBPATTERNPT;
        lb.lbHatch = (ULONG_PTR)((PBYTE) this + offBitsInfo);
    }

// Create the pen and store it in the table.

    pht->objectHandle[imhe] = ExtCreatePen
                              (
                                (DWORD) elp.elpPenStyle,
                                (DWORD) elp.elpWidth,
                                &lb,
                                elp.elpNumEntries,
                                elp.elpNumEntries
                                    ? elp.elpStyleEntry
                                    : (LPDWORD) NULL
                              );
mecp_exit:

    if (hbm)
    {
        if (!DeleteObject(hbm))
        {
            ASSERTGDI(FALSE, "MREXTCREATEPEN::bPlay: DeleteObject failed");
        }
    }

    return(pht->objectHandle[imhe] != 0);
}

/******************************Public*Routine******************************\
* BOOL MRCREATEPALETTE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Sun Sep 22 15:07:56 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRCREATEPALETTE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRCREATEPALETTE::bPlay\n");
    ASSERTGDI(iType == EMR_CREATEPALETTE, "Bad record type");

    USE(hdc);

    if (!bCheckRecord(pht))
        return(FALSE);
// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

// Create the palette and store it in the table.

    pht->objectHandle[imhe] = CreatePalette(&logpal);
    return(pht->objectHandle[imhe] != 0);
}

/******************************Public*Routine******************************\
* BOOL MRCREATEBRUSHINDIRECT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRCREATEBRUSHINDIRECT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    LOGBRUSH lbNew;

    PUTS("MRCREATEBRUSHINDIRECT::bPlay\n");
    ASSERTGDI(iType == EMR_CREATEBRUSHINDIRECT, "Bad record type");

    USE(hdc);

    if (!bCheckRecord(pht))
        return(FALSE);
// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

// Create the brush and store it in the table.

    if (lb.lbStyle != BS_SOLID
     && lb.lbStyle != BS_HATCHED
     && lb.lbStyle != BS_HOLLOW)
        return(FALSE);

    lbNew.lbStyle = lb.lbStyle;
    lbNew.lbColor = lb.lbColor;
    lbNew.lbHatch = (UINT_PTR)lb.lbHatch;

    pht->objectHandle[imhe] = CreateBrushIndirect(&lbNew);
    return(pht->objectHandle[imhe] != 0);
}

/******************************Public*Routine******************************\
* BOOL MRCREATEMONOBRUSH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Mar 12 17:13:53 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRCREATEMONOBRUSH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    HBITMAP hbm;

    PUTS("MRCREATEMONOBRUSH::bPlay\n");
    ASSERTGDI(iType == EMR_CREATEMONOBRUSH, "Bad record type");

    USE(hdc);

    if (!bCheckRecord(pht))
        return(FALSE);
// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

    if (!bValidOff(pht, offBitsInfo) || !bValidOff(pht, offBits))
    {
        EMFVALFAIL(("MRCREATEMONOBRUSH::bPlay: bValidOff offBitsInfo = %08x, offBits = %08x Failed\n", offBitsInfo, offBits));
        return(FALSE);
    }
// Create the brush and store it in the table.

    if (!(hbm = CreateMonoDib
                (
                    (PBMI) ((PBYTE) this + offBitsInfo),
                    (CONST BYTE *) ((PBYTE) this + offBits),
                    (UINT) iUsage
                )
         )
       )
        return(FALSE);

    pht->objectHandle[imhe] = CreatePatternBrush(hbm);

    if (!DeleteObject(hbm))
    {
        ASSERTGDI(FALSE, "MRCREATEMONOBRUSH::bPlay: DeleteObject failed");
    }

    return(pht->objectHandle[imhe] != 0);
}

/******************************Public*Routine******************************\
* BOOL MRCREATEDIBPATTERNBRUSHPT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Mar 12 17:13:53 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRCREATEDIBPATTERNBRUSHPT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRCREATEDIBPATTERNBRUSHPT::bPlay\n");
    ASSERTGDI(iType == EMR_CREATEDIBPATTERNBRUSHPT, "Bad record type");

    USE(hdc);

    if (!bCheckRecord(pht))
        return(FALSE);
// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

    if (!bValidOff(pht, offBitsInfo))
    {
        EMFVALFAIL(("EMR_CREATEDIBPATTERNBRUSHPT::bPlay: bValidOff offBitsInfo = %08x Failed\n", offBitsInfo));
        return(FALSE);
    }
// Create the brush and store it in the table.

    pht->objectHandle[imhe] = CreateDIBPatternBrushPt
                              (
                                (LPBITMAPINFO) ((PBYTE) this + offBitsInfo),
                                (UINT) iUsage
                              );
    return(pht->objectHandle[imhe] != 0);
}


/******************************Public*Routine******************************\
* BOOL MREXTCREATEFONTINDIRECTW::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Tue Jan 14 14:10:43 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MREXTCREATEFONTINDIRECTW::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MREXTCREATEFONTINDIRECTW::bPlay\n");
    ASSERTGDI(iType == EMR_EXTCREATEFONTINDIRECTW, "Bad record type");

    USE(hdc);

    if (!bCheckRecord(pht))
        return(FALSE);

// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

// As of NT 5.0 we only record records that contain ENUMLOGFONTEXDVW,
// but we still need to be able to play records that contain EXTLOGFONT
// that may have been recorded on win9x or pre NT 5.0 system

    if (nSize <= sizeof(MREXTCREATEFONTINDIRECTW))
    {
    // the old type structure, contains only EXTLOGFONT or even only LOGFONTW

        pht->objectHandle[imhe] = CreateFontIndirectW((CONST LOGFONTW *) &elfw);
    }
    else
    {
    // this record contains ENUMLOGFONTEXDVW structure

        pht->objectHandle[imhe] = CreateFontIndirectExW((CONST ENUMLOGFONTEXDVW*) &elfw);
    }
    return(pht->objectHandle[imhe] != 0);
}



/******************************Public*Routine******************************\
* BOOL MRDELETEOBJECT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRDELETEOBJECT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    BOOL  bRet;

    PUTS("MRDELETEOBJECT::bPlay\n");
    ASSERTGDI(iType == EMR_DELETEOBJECT, "Bad record type");

    USE(hdc);

    if (!bCheckRecord(pht))
        return(FALSE);
// Our metafile driver never emits delete stock object records.
// Handle it anyway.

    if (STOCK_IMHE(d1))
    {
        ERROR_ASSERT(FALSE, "MRDELETEOBJECT::bPlay: Deleting a stock object");
        return(TRUE);                   // see DeleteObject
    }

// Make sure the handle is in the table.

    if (!VALID_IMHE(d1, cht))
        return(FALSE);

// Delete the object and remove it from the table.

    bRet = DeleteObject(pht->objectHandle[d1]);
    pht->objectHandle[d1] = 0;
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRANGLEARC::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Sep 13 17:54:00 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRANGLEARC::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRANGLEARC::bPlay\n");
    ASSERTGDI(iType == EMR_ANGLEARC, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);
    return(AngleArc(hdc, (int) eptl.x, (int) eptl.y, nRadius, eStartAngle, eSweepAngle));
}

/******************************Public*Routine******************************\
* BOOL MRELLIPSE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Sep 13 17:54:00 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRELLIPSE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRELLIPSE::bPlay\n");
    ASSERTGDI(iType == EMR_ELLIPSE, "Bad record type");

    USE(pht);
    USE(cht);

// erclBox is inclusive-inclusive.  Make sure we have set the advanced
// graphics mode.

    ASSERTGDI
    (
        GetGraphicsMode(hdc) == GM_ADVANCED,
        "MR::bPlay: Not in advanced graphics mode"
    );

    if (!bCheckRecord(pht))
        return(FALSE);
    return
    (
        Ellipse
        (
            hdc,
            (int) erclBox.left,
            (int) erclBox.top,
            (int) erclBox.right,
            (int) erclBox.bottom
        )
    );
}

/******************************Public*Routine******************************\
* BOOL MRRECTANGLE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Sep 13 17:54:00 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRRECTANGLE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRRECTANGLE::bPlay\n");
    ASSERTGDI(iType == EMR_RECTANGLE, "Bad record type");

    USE(pht);
    USE(cht);

// erclBox is inclusive-inclusive.  Make sure we have set the advanced
// graphics mode.

    ASSERTGDI
    (
        GetGraphicsMode(hdc) == GM_ADVANCED,
        "MR::bPlay: Not in advanced graphics mode"
    );

    if (!bCheckRecord(pht))
        return(FALSE);
    return
    (
        Rectangle
        (
            hdc,
            (int) erclBox.left,
            (int) erclBox.top,
            (int) erclBox.right,
            (int) erclBox.bottom
        )
    );
}

/******************************Public*Routine******************************\
* BOOL MRROUNDRECT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Sep 13 17:54:00 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRROUNDRECT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRROUNDRECT::bPlay\n");
    ASSERTGDI(iType == EMR_ROUNDRECT, "Bad record type");

    USE(pht);
    USE(cht);

// erclBox is inclusive-inclusive.  Make sure we have set the advanced
// graphics mode.

    ASSERTGDI
    (
        GetGraphicsMode(hdc) == GM_ADVANCED,
        "MR::bPlay: Not in advanced graphics mode"
    );

    if (!bCheckRecord(pht))
        return(FALSE);
    return
    (
        RoundRect
        (
            hdc,
            (int) erclBox.left,
            (int) erclBox.top,
            (int) erclBox.right,
            (int) erclBox.bottom,
            (int) szlEllipse.cx,
            (int) szlEllipse.cy
        )
    );
}

/******************************Public*Routine******************************\
* BOOL MRARC::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Sep 13 17:54:00 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRARC::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRARC::bPlay\n");
    ASSERTGDI(iType == EMR_ARC, "Bad record type");

    USE(pht);
    USE(cht);

// erclBox is inclusive-inclusive.  Make sure we have set the advanced
// graphics mode.

    ASSERTGDI
    (
        GetGraphicsMode(hdc) == GM_ADVANCED,
        "MR::bPlay: Not in advanced graphics mode"
    );

    if (!bCheckRecord(pht))
        return(FALSE);
    return
    (
        Arc
        (
            hdc,
            (int) erclBox.left,
            (int) erclBox.top,
            (int) erclBox.right,
            (int) erclBox.bottom,
            (int) eptlStart.x,
            (int) eptlStart.y,
            (int) eptlEnd.x,
            (int) eptlEnd.y
        )
    );
}

/******************************Public*Routine******************************\
* BOOL MRARCTO::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Wed Oct 02 10:44:31 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRARCTO::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRARCTO::bPlay\n");
    ASSERTGDI(iType == EMR_ARCTO, "Bad record type");

    USE(pht);
    USE(cht);

// erclBox is inclusive-inclusive.  Make sure we have set the advanced
// graphics mode.

    ASSERTGDI
    (
        GetGraphicsMode(hdc) == GM_ADVANCED,
        "MR::bPlay: Not in advanced graphics mode"
    );

    if (!bCheckRecord(pht))
        return(FALSE);

    return
    (
        ArcTo
        (
            hdc,
            (int) erclBox.left,
            (int) erclBox.top,
            (int) erclBox.right,
            (int) erclBox.bottom,
            (int) eptlStart.x,
            (int) eptlStart.y,
            (int) eptlEnd.x,
            (int) eptlEnd.y
        )
    );
}

/******************************Public*Routine******************************\
* BOOL MRCHORD::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Sep 13 17:54:00 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRCHORD::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRCHORD::bPlay\n");
    ASSERTGDI(iType == EMR_CHORD, "Bad record type");

    USE(pht);
    USE(cht);

// erclBox is inclusive-inclusive.  Make sure we have set the advanced
// graphics mode.

    ASSERTGDI
    (
        GetGraphicsMode(hdc) == GM_ADVANCED,
        "MR::bPlay: Not in advanced graphics mode"
    );

    if (!bCheckRecord(pht))
        return(FALSE);

    return
    (
        Chord
        (
            hdc,
            (int) erclBox.left,
            (int) erclBox.top,
            (int) erclBox.right,
            (int) erclBox.bottom,
            (int) eptlStart.x,
            (int) eptlStart.y,
            (int) eptlEnd.x,
            (int) eptlEnd.y
        )
    );
}

/******************************Public*Routine******************************\
* BOOL MRPIE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Sep 13 17:54:00 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPIE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRPIE::bPlay\n");
    ASSERTGDI(iType == EMR_PIE, "Bad record type");

    USE(pht);
    USE(cht);

// erclBox is inclusive-inclusive.  Make sure we have set the advanced
// graphics mode.

    ASSERTGDI
    (
        GetGraphicsMode(hdc) == GM_ADVANCED,
        "MR::bPlay: Not in advanced graphics mode"
    );

    if (!bCheckRecord(pht))
        return(FALSE);

    return
    (
        Pie
        (
            hdc,
            (int) erclBox.left,
            (int) erclBox.top,
            (int) erclBox.right,
            (int) erclBox.bottom,
            (int) eptlStart.x,
            (int) eptlStart.y,
            (int) eptlEnd.x,
            (int) eptlEnd.y
        )
    );
}

/******************************Public*Routine******************************\
* BOOL MRSETPALETTEENTRIES::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Sun Sep 22 16:34:36 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETPALETTEENTRIES::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETPALETTEENTRIES::bPlay\n");
    ASSERTGDI(iType == EMR_SETPALETTEENTRIES, "Bad record type");

    USE(hdc);

// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

// If palette creation failed earlier, hpal is 0 and SetPaletteEntries
// will just return an error.

    if (!bCheckRecord(pht))
        return(FALSE);

    return
    (
        SetPaletteEntries
        (
            (HPALETTE) pht->objectHandle[imhe],
            (UINT) iStart,
            (UINT) cEntries,
            aPalEntry
        )
        != 0
    );
}

/******************************Public*Routine******************************\
* BOOL MRRESIZEPALETTE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Sun Sep 22 16:34:36 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRRESIZEPALETTE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRRESIZEPALETTE::bPlay\n");
    ASSERTGDI(iType == EMR_RESIZEPALETTE, "Bad record type");

    USE(hdc);

// Make sure the handle is in the table.

    if (!VALID_IMHE(d1, cht))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);

// If palette creation failed earlier, hpal is 0 and ResizePalette will
// just return an error.

    return(ResizePalette((HPALETTE) pht->objectHandle[d1], (UINT) d2));
}

/******************************Public*Routine******************************\
* BOOL MRREALIZEPALETTE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Mon Sep 23 17:41:46 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRREALIZEPALETTE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRREALIZEPALETTE::bPlay\n");
    ASSERTGDI(iType == EMR_REALIZEPALETTE, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);

    return(RealizePalette(hdc) != -1);
}

/******************************Public*Routine******************************\
* BOOL MREXTFLOODFILL::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Sep 13 17:54:00 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MREXTFLOODFILL::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    BOOL            bRet = FALSE;
    PMF             pmf;
    HRGN            hrgn = (HRGN) 0;
    POINTL          ptlRef;
    PENHMETAHEADER  pmrmf = NULL;

    PUTS("MREXTFLOODFILL::bPlay\n");
    ASSERTGDI(iType == EMR_EXTFLOODFILL, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);

// Save the DC.

    if (!SaveDC(hdc))
        return(FALSE);

// We are going to use the picture frame to set up the clipping before
// flood fill.  This is to make sure that the fill will not flood beyond
// the picture.  We first convert the picture frame to the source device
// coordinates and set up the transform such that the source world to
// device transform is identity.  Then we intersect the picture
// frame using the IntersecClipRect function.  Note that the reference
// point is also converted to source device coordinates.

// Convert the reference point to the device units on the source device.

    ptlRef.x = eptl.x;
    ptlRef.y = eptl.y;
    if (!LPtoDP(pmf->hdcXform, (LPPOINT) &ptlRef, 1))
        goto mreff_exit;

// Reset source transform to identity.
// We simply set the total transform to the xformBase.

    if (!SetWorldTransform(hdc, &pmf->xformBase))
        goto mreff_exit;

// Compute the picture frame in the source device coordinates.

    RECTL   rclSrc;

    pmrmf = pmf->emfc.GetEMFHeader();

    rclSrc.left   = MulDiv((int) pmrmf->rclFrame.left,
                           (int) pmrmf->szlDevice.cx,
                           (int) (100 * pmrmf->szlMillimeters.cx));
    rclSrc.right  = MulDiv((int) pmrmf->rclFrame.right,
                           (int) pmrmf->szlDevice.cx,
                           (int) (100 * pmrmf->szlMillimeters.cx));
    rclSrc.top    = MulDiv((int) pmrmf->rclFrame.top,
                           (int) pmrmf->szlDevice.cy,
                           (int) (100 * pmrmf->szlMillimeters.cy));
    rclSrc.bottom = MulDiv((int) pmrmf->rclFrame.bottom,
                           (int) pmrmf->szlDevice.cy,
                           (int) (100 * pmrmf->szlMillimeters.cy));

// Intersect the clip region with the size of the picture bounds.

    if (IntersectClipRect(hdc,
                          (int) rclSrc.left,
                          (int) rclSrc.top,
                          (int) rclSrc.right + 1,
                          (int) rclSrc.bottom + 1)
        == ERROR)
        goto mreff_exit;

// Finally, do the flood fill.

    bRet = ExtFloodFill(hdc, (int) ptlRef.x, (int) ptlRef.y, clrRef, (UINT) iMode);

// Clean up.

mreff_exit:

    if (!RestoreDC(hdc, -1))
    {
        ASSERTGDI(FALSE, "MREXTFLOODFILL::bPlay: RestoreDC failed");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRBEGINPATH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 17:10:02 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRBEGINPATH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRBEGINPATH::bPlay\n");
    ASSERTGDI(iType == EMR_BEGINPATH, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);

    return(BeginPath(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRENDPATH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 17:10:02 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRENDPATH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRENDPATH::bPlay\n");
    ASSERTGDI(iType == EMR_ENDPATH, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);

    return(EndPath(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRCLOSEFIGURE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 17:10:02 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRCLOSEFIGURE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRCLOSEFIGURE::bPlay\n");
    ASSERTGDI(iType == EMR_CLOSEFIGURE, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);

    return(CloseFigure(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRFLATTENPATH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 17:10:02 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRFLATTENPATH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRFLATTENPATH::bPlay\n");
    ASSERTGDI(iType == EMR_FLATTENPATH, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);

    return(FlattenPath(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRWIDENPATH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 17:10:02 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRWIDENPATH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRWIDENPATH::bPlay\n");
    ASSERTGDI(iType == EMR_WIDENPATH, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);

    return(WidenPath(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRFILLPATH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 17:10:02 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRFILLPATH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRFILLPATH::bPlay\n");
    ASSERTGDI(iType == EMR_FILLPATH, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);

    return(FillPath(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSTROKEANDFILLPATH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 17:10:02 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSTROKEANDFILLPATH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSTROKEANDFILLPATH::bPlay\n");
    ASSERTGDI(iType == EMR_STROKEANDFILLPATH, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);

    return(StrokeAndFillPath(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSTROKEPATH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 17:10:02 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSTROKEPATH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSTROKEPATH::bPlay\n");
    ASSERTGDI(iType == EMR_STROKEPATH, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);

    return(StrokePath(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSELECTCLIPPATH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Oct 18 11:33:05 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSELECTCLIPPATH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSELECTCLIPPATH::bPlay\n");
    ASSERTGDI(iType == EMR_SELECTCLIPPATH, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);

// Since we have moved the initial destination clip region into the meta
// region (hrgnMeta), this function should not affect the initial clip region.

    return(SelectClipPath(hdc, (int) d1));
}

/******************************Public*Routine******************************\
* BOOL MRABORTPATH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 17:10:02 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRABORTPATH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRABORTPATH::bPlay\n");
    ASSERTGDI(iType == EMR_ABORTPATH, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);

// This call is recorded in place of PathToRegion in metafiles.
// See comments in PathToRegion for more information.

    return(AbortPath(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRBITBLT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Nov 22 18:30:27 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRBITBLT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF     pmf;
    BOOL    bRet   = FALSE;
    HBITMAP hbmSrc = (HBITMAP) 0;
    HBITMAP hbmTmp = (HBITMAP) 0;
    HDC     hdcSrc = (HDC) 0;

    PUTS("MRBITBLT::bPlay\n");
    ASSERTGDI(iType == EMR_BITBLT, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Handle bitblt with no source DC.

    if (!ISSOURCEINROP3(rop))
        return
        (
            BitBlt
            (
                hdc,
                (int) xDst,
                (int) yDst,
                (int) cxDst,
                (int) cyDst,
                (HDC) 0,
                (int) xSrc,
                (int) ySrc,
                rop
            )
        );

// Handle bitblt with a source bitmap.
// Create a compatible source DC.

    if (!(hdcSrc = CreateCompatibleDCAdvanced(hdc)))
        goto mrbb_exit;

// Create the source bitmap.

    if (!bValidOff(pht, offBitsInfoSrc) || !bValidOff(pht, offBitsSrc))
    {
        EMFVALFAIL(("MRBITBLT::bPlay: bValidOff offBitsInfoSrc = %08x, offBitsSrc = %08x Failed\n", offBitsInfoSrc, offBitsSrc));
        goto mrbb_exit;
    }
        
    if (!(hbmSrc = CreateDIBitmap
                    (
                        hdcSrc,
                        (LPBITMAPINFOHEADER) ((PBYTE) this + offBitsInfoSrc),
                        CBM_INIT | CBM_CREATEDIB,
                        (LPBYTE) ((PBYTE) this + offBitsSrc),
                        (LPBITMAPINFO) ((PBYTE) this + offBitsInfoSrc),
                        (UINT) iUsageSrc
                    )
          )
       )
        goto mrbb_exit;

// Select the bitmap.

    if (!(hbmTmp = (HBITMAP)SelectObject(hdcSrc, hbmSrc)))
        goto mrbb_exit;

// Set up source DC transform and background color.

    if (!SetWorldTransform(hdcSrc, &xformSrc))
        goto mrbb_exit;

    if (SetBkColor(hdcSrc, clrBkSrc) == CLR_INVALID)
        goto mrbb_exit;

// Do the blt.

    bRet = BitBlt
           (
               hdc,
               (int) xDst,
               (int) yDst,
               (int) cxDst,
               (int) cyDst,
               hdcSrc,
               (int) xSrc,
               (int) ySrc,
               rop
           );

mrbb_exit:
    if (hbmTmp)
    {
        if (!SelectObject(hdcSrc, hbmTmp))
        {
            ASSERTGDI(FALSE, "MRBITBLT::bPlay: SelectObject failed");
        }
    }

    if (hbmSrc)
    {
        if (!DeleteObject(hbmSrc))
        {
            ASSERTGDI(FALSE, "MRBITBLT::bPlay: DeleteObject failed");
        }
    }

    if (hdcSrc)
    {
        if (!DeleteDC(hdcSrc))
        {
            ASSERTGDI(FALSE, "MRBITBLT::bPlay: DeleteDC failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRSTRETCHBLT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Nov 22 18:30:27 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSTRETCHBLT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF     pmf;
    BOOL    bRet   = FALSE;
    HBITMAP hbmSrc = (HBITMAP) 0;
    HBITMAP hbmTmp = (HBITMAP) 0;
    HDC     hdcSrc = (HDC) 0;

    PUTS("MRSTRETCHBLT::bPlay\n");
    ASSERTGDI(iType == EMR_STRETCHBLT, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Handle stretchblt with no source DC.

    if (!ISSOURCEINROP3(rop))
        return
        (
            StretchBlt
            (
                hdc,
                (int) xDst,
                (int) yDst,
                (int) cxDst,
                (int) cyDst,
                (HDC) 0,
                (int) xSrc,
                (int) ySrc,
                (int) cxSrc,
                (int) cySrc,
                rop
            )
        );

// Handle stretchblt with a source bitmap.
// Create a compatible source DC.

    if (!(hdcSrc = CreateCompatibleDCAdvanced(hdc)))
        goto mrsb_exit;

    if (!bValidOff(pht, offBitsInfoSrc) || !bValidOff(pht, offBitsSrc))
    {
        EMFVALFAIL(("MRSTRCHBLT::bPlay: bValidOff offBitsInfoSrc = %08x, offBitsSrc = %08x Failed\n", offBitsInfoSrc, offBitsSrc));
        goto mrsb_exit;
    }

// Create the source bitmap.

    if (!(hbmSrc = CreateDIBitmap
                    (
                        hdcSrc,
                        (LPBITMAPINFOHEADER) ((PBYTE) this + offBitsInfoSrc),
                        CBM_INIT | CBM_CREATEDIB,
                        (LPBYTE) ((PBYTE) this + offBitsSrc),
                        (LPBITMAPINFO) ((PBYTE) this + offBitsInfoSrc),
                        (UINT) iUsageSrc
                    )
          )
       )
        goto mrsb_exit;

// Select the bitmap.

    if (!(hbmTmp = (HBITMAP)SelectObject(hdcSrc, hbmSrc)))
        goto mrsb_exit;

// Set up source DC transform and background color.

    if (!SetWorldTransform(hdcSrc, &xformSrc))
        goto mrsb_exit;

    if (SetBkColor(hdcSrc, clrBkSrc) == CLR_INVALID)
        goto mrsb_exit;

// Do the blt.

    bRet = StretchBlt
           (
               hdc,
               (int) xDst,
               (int) yDst,
               (int) cxDst,
               (int) cyDst,
               hdcSrc,
               (int) xSrc,
               (int) ySrc,
               (int) cxSrc,
               (int) cySrc,
               rop
           );

mrsb_exit:
    if (hbmTmp)
    {
        if (!SelectObject(hdcSrc, hbmTmp))
        {
            ASSERTGDI(FALSE, "MRSTRETCHBLT::bPlay: SelectObject failed");
        }
    }

    if (hbmSrc)
    {
        if (!DeleteObject(hbmSrc))
        {
            ASSERTGDI(FALSE, "MRSTRETCHBLT::bPlay: DeleteObject failed");
        }
    }

    if (hdcSrc)
    {
        if (!DeleteDC(hdcSrc))
        {
            ASSERTGDI(FALSE, "MRSTRETCHBLT::bPlay: DeleteDC failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRALPHABLEND::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL MRALPHABLEND::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF     pmf;
    BOOL    bRet   = FALSE;
    HBITMAP hbmSrc = (HBITMAP) 0;
    HBITMAP hbmTmp = (HBITMAP) 0;
    HDC     hdcSrc = (HDC) 0;

    PUTS("MRALPHABLEND::bPlay\n");
    ASSERTGDI(iType == EMR_ALPHABLEND, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Create a compatible source DC.

    if (!(hdcSrc = CreateCompatibleDCAdvanced(hdc)))
        goto mrai_exit;

    if (!bValidOff(pht, offBitsInfoSrc) || !bValidOff(pht, offBitsSrc))
    {
        EMFVALFAIL(("MRALPHABLEND::bPlay: bValidOff offBitsInfoSrc = %08x, offBitsSrc = %08x Failed\n", offBitsInfoSrc, offBitsSrc));
        goto mrai_exit;
    }
// Create the source bitmap.

    if (!(hbmSrc = CreateDIBitmap
                    (
                        hdcSrc,
                        (LPBITMAPINFOHEADER) ((PBYTE) this + offBitsInfoSrc),
                        CBM_INIT | CBM_CREATEDIB,
                        (LPBYTE) ((PBYTE) this + offBitsSrc),
                        (LPBITMAPINFO) ((PBYTE) this + offBitsInfoSrc),
                        (UINT) iUsageSrc
                    )
          )
       )
        goto mrai_exit;

// Select the bitmap.

    if (!(hbmTmp = (HBITMAP)SelectObject(hdcSrc, hbmSrc)))
        goto mrai_exit;

// Set up source DC transform and background color.

    if (!SetWorldTransform(hdcSrc, &xformSrc))
        goto mrai_exit;

    if (SetBkColor(hdcSrc, clrBkSrc) == CLR_INVALID)
        goto mrai_exit;

// Do the blt.

    BLENDULONG Blend;

    Blend.ul = rop;

    bRet = GdiAlphaBlend
           (
               hdc,
               (int) xDst,
               (int) yDst,
               (int) cxDst,
               (int) cyDst,
               hdcSrc,
               (int) xSrc,
               (int) ySrc,
               (int) cxSrc,
               (int) cySrc,
               Blend.Blend
           );

mrai_exit:
    if (hbmTmp)
    {
        if (!SelectObject(hdcSrc, hbmTmp))
        {
            ASSERTGDI(FALSE, "MRALPHABLEND::bPlay: SelectObject failed");
        }
    }

    if (hbmSrc)
    {
        if (!DeleteObject(hbmSrc))
        {
            ASSERTGDI(FALSE, "MRALPHABLEND::bPlay: DeleteObject failed");
        }
    }

    if (hdcSrc)
    {
        if (!DeleteDC(hdcSrc))
        {
            ASSERTGDI(FALSE, "MRALPHABLEND::bPlay: DeleteDC failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRTRANSPARENTIMAGE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL MRTRANSPARENTBLT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF     pmf;
    BOOL    bRet   = FALSE;
    HBITMAP hbmSrc = (HBITMAP) 0;
    HBITMAP hbmTmp = (HBITMAP) 0;
    HDC     hdcSrc = (HDC) 0;

    PUTS("MRTRANSPARENTBLT::bPlay\n");
    ASSERTGDI(iType == EMR_TRANSPARENTBLT, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Create a compatible source DC.

    if (!(hdcSrc = CreateCompatibleDCAdvanced(hdc)))
        goto mrti_exit;

    if (!bValidOff(pht, offBitsInfoSrc) || !bValidOff(pht, offBitsSrc))
    {
        EMFVALFAIL(("MRTRANSPARENTBLT::bPlay: bValidOff offBitsInfoSrc = %08x, offBitsSrc = %08x Failed\n", offBitsInfoSrc, offBitsSrc));
        goto mrti_exit;
    }
// Create the source bitmap.

    if (!(hbmSrc = CreateDIBitmap
                    (
                        hdcSrc,
                        (LPBITMAPINFOHEADER) ((PBYTE) this + offBitsInfoSrc),
                        CBM_INIT | CBM_CREATEDIB,
                        (LPBYTE) ((PBYTE) this + offBitsSrc),
                        (LPBITMAPINFO) ((PBYTE) this + offBitsInfoSrc),
                        (UINT) iUsageSrc
                    )
          )
       )
        goto mrti_exit;

// Select the bitmap.

    if (!(hbmTmp = (HBITMAP)SelectObject(hdcSrc, hbmSrc)))
        goto mrti_exit;

// Set up source DC transform and background color.

    if (!SetWorldTransform(hdcSrc, &xformSrc))
        goto mrti_exit;

    if (SetBkColor(hdcSrc, clrBkSrc) == CLR_INVALID)
        goto mrti_exit;

// Do the blt.

    bRet = GdiTransparentBlt
           (
               hdc,
               (int) xDst,
               (int) yDst,
               (int) cxDst,
               (int) cyDst,
               hdcSrc,
               (int) xSrc,
               (int) ySrc,
               (int) cxSrc,
               (int) cySrc,
               rop  //color
           );

mrti_exit:
    if (hbmTmp)
    {
        if (!SelectObject(hdcSrc, hbmTmp))
        {
            ASSERTGDI(FALSE, "MRSTRETCHBLT::bPlay: SelectObject failed");
        }
    }

    if (hbmSrc)
    {
        if (!DeleteObject(hbmSrc))
        {
            ASSERTGDI(FALSE, "MRSTRETCHBLT::bPlay: DeleteObject failed");
        }
    }

    if (hdcSrc)
    {
        if (!DeleteDC(hdcSrc))
        {
            ASSERTGDI(FALSE, "MRSTRETCHBLT::bPlay: DeleteDC failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRMASKBLT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Nov 22 18:30:27 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRMASKBLT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF     pmf;
    BOOL    bRet    = FALSE;
    HBITMAP hbmSrc  = (HBITMAP) 0;
    HBITMAP hbmTmp  = (HBITMAP) 0;
    HBITMAP hbmMask = (HBITMAP) 0;
    HDC     hdcSrc  = (HDC) 0;

    PUTS("MRMASKBLT::bPlay\n");
    ASSERTGDI(iType == EMR_MASKBLT, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Create the mask bitmap if it exists.

    if (cbBitsInfoMask)
    {
        if (!bValidOff(pht, offBitsInfoMask) || !bValidOff(pht, offBitsMask))
        {
            EMFVALFAIL(("MRMASKBLT::bPlay: bValidOff offBitsInfoMask = %08x, offBitsMask = %08x Failed\n", offBitsInfoMask, offBitsMask));
            return(FALSE);
        }

        if (!(hbmMask = CreateMonoDib
                        (
                            (LPBITMAPINFO) ((PBYTE) this + offBitsInfoMask),
                            (CONST BYTE *) ((PBYTE) this + offBitsMask),
                            (UINT) iUsageMask
                        )
             )
           )
            return(FALSE);
    }

// Create a compatible source DC.  This is needed even if the rop does not
// require a source.

    if (!(hdcSrc = CreateCompatibleDCAdvanced(hdc)))
        goto mrmb_exit;

// Set up source DC transform.

    if (!SetWorldTransform(hdcSrc, &xformSrc))
        goto mrmb_exit;

// Handle maskblt with no source bitmap.

    if (!ISSOURCEINROP3(rop))
    {
        bRet = MaskBlt
                (
                    hdc,
                    (int) xDst,
                    (int) yDst,
                    (int) cxDst,
                    (int) cyDst,
                    (HDC) hdcSrc,
                    (int) xSrc,
                    (int) ySrc,
                    hbmMask,
                    (int) xMask,
                    (int) yMask,
                    rop
                );
        goto mrmb_exit;
    }

    if (!bValidOff(pht, offBitsInfoSrc) || !bValidOff(pht, offBitsSrc))
    {
        EMFVALFAIL(("MRMASKBLT::bPlay: bValidOff offBitsInfoSrc = %08x, offBitsSrc = %08x Failed\n", offBitsInfoSrc, offBitsSrc));
        goto mrmb_exit;
    }
// Handle maskblt with a source bitmap.
// Create the source bitmap.

    if (!(hbmSrc = CreateDIBitmap
                    (
                        hdcSrc,
                        (LPBITMAPINFOHEADER) ((PBYTE) this + offBitsInfoSrc),
                        CBM_INIT | CBM_CREATEDIB,
                        (LPBYTE) ((PBYTE) this + offBitsSrc),
                        (LPBITMAPINFO) ((PBYTE) this + offBitsInfoSrc),
                        (UINT) iUsageSrc
                    )
          )
       )
        goto mrmb_exit;

// Select the bitmap.

    if (!(hbmTmp = (HBITMAP)SelectObject(hdcSrc, hbmSrc)))
        goto mrmb_exit;

// Set up source DC background color.

    if (SetBkColor(hdcSrc, clrBkSrc) == CLR_INVALID)
        goto mrmb_exit;

// Do the blt.

    bRet = MaskBlt
           (
               hdc,
               (int) xDst,
               (int) yDst,
               (int) cxDst,
               (int) cyDst,
               hdcSrc,
               (int) xSrc,
               (int) ySrc,
               hbmMask,
               (int) xMask,
               (int) yMask,
               rop
           );

mrmb_exit:
    if (hbmTmp)
    {
        if (!SelectObject(hdcSrc, hbmTmp))
        {
            ASSERTGDI(FALSE, "MRMASKBLT::bPlay: SelectObject failed");
        }
    }

    if (hbmSrc)
    {
        if (!DeleteObject(hbmSrc))
        {
            ASSERTGDI(FALSE, "MRMASKBLT::bPlay: DeleteObject failed");
        }
    }

    if (hdcSrc)
    {
        if (!DeleteDC(hdcSrc))
        {
            ASSERTGDI(FALSE, "MRMASKBLT::bPlay: DeleteDC failed");
        }
    }

    if (hbmMask)
    {
        if (!DeleteObject(hbmMask))
        {
            ASSERTGDI(FALSE, "MRMASKBLT::bPlay: DeleteObject failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRPLGBLT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Nov 22 18:30:27 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPLGBLT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF     pmf;
    BOOL    bRet    = FALSE;
    HBITMAP hbmSrc  = (HBITMAP) 0;
    HBITMAP hbmTmp  = (HBITMAP) 0;
    HBITMAP hbmMask = (HBITMAP) 0;
    HDC     hdcSrc  = (HDC) 0;

    PUTS("MRPLGBLT::bPlay\n");
    ASSERTGDI(iType == EMR_PLGBLT, "Bad record type");

    USE(cht);

// There must be a source DC in this call

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Create the mask bitmap if it exists.

    if (cbBitsInfoMask)
    {
        if (!bValidOff(pht, offBitsInfoMask) || !bValidOff(pht, offBitsMask))
        {
            EMFVALFAIL(("MRPLGBLT::bPlay: bValidOff offBitsInfoMask = %08x, offBitsMask = %08x Failed\n", offBitsInfoMask, offBitsMask));
            return(FALSE);
        }

        if (!(hbmMask = CreateMonoDib
                        (
                            (LPBITMAPINFO) ((PBYTE) this + offBitsInfoMask),
                            (CONST BYTE *) ((PBYTE) this + offBitsMask),
                            (UINT) iUsageMask
                        )
             )
           )
            return(FALSE);
    }

// Handle plgblt with a source bitmap.
// Create a compatible source DC.

    if (!(hdcSrc = CreateCompatibleDCAdvanced(hdc)))
        goto mrpb_exit;

    if (!bValidOff(pht, offBitsInfoSrc) || !bValidOff(pht, offBitsSrc))
    {
        EMFVALFAIL(("MRPLGBLT::bPlay: bValidOff offBitsInfoSrc = %08x, offBitsSrc = %08x Failed\n", offBitsInfoSrc, offBitsSrc));
        goto mrpb_exit;
    }
// Create the source bitmap.

    if (!(hbmSrc = CreateDIBitmap
                    (
                        hdcSrc,
                        (LPBITMAPINFOHEADER) ((PBYTE) this + offBitsInfoSrc),
                        CBM_INIT | CBM_CREATEDIB,
                        (LPBYTE) ((PBYTE) this + offBitsSrc),
                        (LPBITMAPINFO) ((PBYTE) this + offBitsInfoSrc),
                        (UINT) iUsageSrc
                    )
          )
       )
        goto mrpb_exit;

// Select the bitmap.

    if (!(hbmTmp = (HBITMAP)SelectObject(hdcSrc, hbmSrc)))
        goto mrpb_exit;

// Set up source DC transform and background color.

    if (!SetWorldTransform(hdcSrc, &xformSrc))
        goto mrpb_exit;

    if (SetBkColor(hdcSrc, clrBkSrc) == CLR_INVALID)
        goto mrpb_exit;

// Do the blt.

    bRet = PlgBlt
           (
               hdc,
               (LPPOINT) aptlDst,
               hdcSrc,
               (int) xSrc,
               (int) ySrc,
               (int) cxSrc,
               (int) cySrc,
               hbmMask,
               (int) xMask,
               (int) yMask
           );

mrpb_exit:
    if (hbmTmp)
    {
        if (!SelectObject(hdcSrc, hbmTmp))
        {
            ASSERTGDI(FALSE, "MRPLGBLT::bPlay: SelectObject failed");
        }
    }

    if (hbmSrc)
    {
        if (!DeleteObject(hbmSrc))
        {
            ASSERTGDI(FALSE, "MRPLGBLT::bPlay: DeleteObject failed");
        }
    }

    if (hdcSrc)
    {
        if (!DeleteDC(hdcSrc))
        {
            ASSERTGDI(FALSE, "MRPLGBLT::bPlay: DeleteDC failed");
        }
    }

    if (hbmMask)
    {
        if (!DeleteObject(hbmMask))
        {
            ASSERTGDI(FALSE, "MRPLGBLT::bPlay: DeleteObject failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRSETDIBITSTODEVICE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Nov 22 18:30:27 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETDIBITSTODEVICE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;
    BOOL  bRet = FALSE;
    POINT ptDst;
    PBMI  pBitsInfoDib;

    PUTS("MRSETDIBITSTODEVICE::bPlay\n");
    ASSERTGDI(iType == EMR_SETDIBITSTODEVICE, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Do the simple case where xformBase is identity
// Since there may be a non identity xformBase, we cannot simply
// call SetDIBitsToDevice directly.  Instead, we will convert it to a
// StretchDIBits call.  There is one catch here: in SetDIBitsToDevice,
// the destination width and height are in device units but in StretchDIBits,
// they are in world units.  We have to replace the original transform
// in the metafile with a identity transform before calling StretchDIBits.

// Convert the destination origin to the device units on the original device.

    ptDst.x = (long) xDst;
    ptDst.y = (long) yDst;
    if (!LPtoDP(pmf->hdcXform, &ptDst, 1))
        return(FALSE);

// Reset original destination transform to identity.
// We simply set the total transform to the xformBase.

    if (!SetWorldTransform(hdc, &pmf->xformBase))
        return(FALSE);

// Check arithmetic overflow and Validate offsets
    if (!bValidOffExt(pht, offBitsInfoDib, cbBitsInfoDib))
    {
        EMFVALFAIL(("MRSETDIBITSTODEVICE::bPlay: bValidOffExt offBitsInfoDib = %08x cbBitsInfoDib = %08x Failed\n", offBitsInfoDib, cbBitsInfoDib));
        return(FALSE);
    }
// Since StretchDIBits takes a full dib, we have to adjust the source dib info.

    if (!(pBitsInfoDib = (PBMI) LocalAlloc(LMEM_FIXED, (UINT) cbBitsInfoDib)))
        goto mrsdb_exit;

    RtlCopyMemory((PBYTE) pBitsInfoDib, (PBYTE) this + offBitsInfoDib, cbBitsInfoDib);

    if (pBitsInfoDib->bmiHeader.biHeight > 0)
    {
        pBitsInfoDib->bmiHeader.biHeight    = cScans;
    }
    else
    {
        // top-down
        pBitsInfoDib->bmiHeader.biHeight    = cScans;
        pBitsInfoDib->bmiHeader.biHeight = -pBitsInfoDib->bmiHeader.biHeight;

    }
    pBitsInfoDib->bmiHeader.biSizeImage = cbBitsDib;

    if (cbBitsDib)
    {
        if (!bValidOffExt(pht, offBitsDib, cbBitsDib))
        {
            EMFVALFAIL(("MRSETDIBITSTODEVICE::bPlay: bValidOffExt offBitsDib = %08x cbBitsDib = %08x,\n",offBitsDib, cbBitsDib));
            goto mrsdb_exit;
        }
    }
// Do the blt.

    bRet = StretchDIBits
           (
               hdc,
               (int) ptDst.x,
               (int) ptDst.y,
               (int) cxDib,
               (int) cyDib,
               (int) xDib,
               (int) yDib - (int) iStartScan,
               (int) cxDib,
               (int) cyDib,
               cbBitsDib
                   ? (LPBYTE) ((PBYTE) this + offBitsDib)
                   : (LPBYTE) NULL,
               pBitsInfoDib,
               (UINT) iUsageDib,
               SRCCOPY
           ) != 0;

    if (LocalFree(pBitsInfoDib))
    {
        ASSERTGDI(FALSE, "MRSETDIBITSTODEVICE::bPlay: LocalFree failed");
    }

mrsdb_exit:
// Restore current transform.

    if (!pmf->bSetTransform(hdc))
    {
        WARNING("MRSETDIBITSTODEVICE::bPlay: Restore xform failed");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRSTRETCHDIBITS::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Nov 22 18:30:27 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSTRETCHDIBITS::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF     pmf;

    PUTS("MRSTRETCHDIBITS::bPlay\n");
    ASSERTGDI(iType == EMR_STRETCHDIBITS, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

    if (!bCheckRecord(pht))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

    if (cbBitsDib)
    {
        if (!bValidOffExt(pht, offBitsDib, cbBitsDib))
        {
            EMFVALFAIL(("MESTRETCHDIBITS::bPlay: bValidOffExt offBitsDib = %08x, cbBitsDib = %08x Failed\n", offBitsDib, cbBitsDib));
            return(FALSE);
        }
    }

    if (cbBitsInfoDib)
    {
        if (!bValidOffExt(pht, offBitsInfoDib, cbBitsInfoDib))
        {
            EMFVALFAIL(("MESTRETCHDIBITS::bPlay: bValidOffExt offBitsInfoDib = %08x cbBitsInfoDib = %08x Failed\n", offBitsInfoDib, cbBitsInfoDib));
            return(FALSE);
        }
    }
// Do the blt.

    return
    (
        StretchDIBits
        (
            hdc,
            (int) xDst,
            (int) yDst,
            (int) cxDst,
            (int) cyDst,
            (int) xDib,
            (int) yDib,
            (int) cxDib,
            (int) cyDib,
            cbBitsDib
                ? (LPBYTE) ((PBYTE) this + offBitsDib)
                : (LPBYTE) NULL,
            cbBitsInfoDib
                ? (LPBITMAPINFO) ((PBYTE) this + offBitsInfoDib)
                : (LPBITMAPINFO) NULL,
            (UINT) iUsageDib,
            rop
        ) != 0
    );
}

/******************************Public*Routine******************************\
* BOOL MREXTTEXTOUT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 24 15:20:33 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MREXTTEXTOUT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    BOOL  bRet;

    PUTS("MREXTTEXTOUT::bPlay\n");
    ASSERTGDI(iType == EMR_EXTTEXTOUTA || iType == EMR_EXTTEXTOUTW,
        "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);

    if (mtext.cchString && (
        !bValidOff(pht, mtext.offString) ||
        !bValidOff(pht, mtext.offaDx)))
    {
        EMFVALFAIL(("MREXTTEXTOUT::bPlay: bValidOff mtext.offString = %08x, mtext.offaDx = %08x Failed\n", mtext.offString, mtext.offaDx));
        return(FALSE);
    }
// Set the graphics mode if necessary.
// The metafile playback is always in the advanced graphics mode.

    if (iGraphicsMode != GM_ADVANCED)
    {
        if (!SetGraphicsMode(hdc, iGraphicsMode))
            return(FALSE);
        if (!SetFontXform(hdc, exScale, eyScale))
            return(FALSE);
    }

    if (iType == EMR_EXTTEXTOUTA)
        bRet = ExtTextOutA
                (
                    hdc,
                    (int) mtext.eptlRef.x,
                    (int) mtext.eptlRef.y,
                    (UINT) mtext.fOptions,
                    (LPRECT) &mtext.ercl,
                    (LPSTR) ((PBYTE) this + mtext.offString),
                    (int) mtext.cchString,
                    (LPINT) (mtext.offaDx ? ((PBYTE) this + mtext.offaDx) : 0)
                );
    else
        bRet = ExtTextOutW
                (
                    hdc,
                    (int) mtext.eptlRef.x,
                    (int) mtext.eptlRef.y,
                    (UINT) mtext.fOptions,
                    (LPRECT) &mtext.ercl,
                    (LPWSTR) ((PBYTE) this + mtext.offString),
                    (int) mtext.cchString,
                    (LPINT) (mtext.offaDx ? ((PBYTE) this + mtext.offaDx) : 0)
                );

// Restore the graphics mode.

    if (iGraphicsMode != GM_ADVANCED)
    {
        if (!SetGraphicsMode(hdc, GM_ADVANCED))
            return(FALSE);
        if (!SetFontXform(hdc, 0.0f, 0.0f))
            return(FALSE);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRPOLYTEXTOUT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 24 15:20:33 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYTEXTOUT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    POLYTEXTA * ppta;
    BOOL        bRet = FALSE;
    LONG        i;

    PUTS("MRPOLYTEXTOUT::bPlay\n");
    ASSERTGDI(iType == EMR_POLYTEXTOUTA || iType == EMR_POLYTEXTOUTW,
        "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);

// Set the graphics mode if necessary.
// The metafile playback is always in the advanced graphics mode.

    if (iGraphicsMode != GM_ADVANCED)
    {
        if (!SetGraphicsMode(hdc, (int) iGraphicsMode))
            return(FALSE);
        if (!SetFontXform(hdc, exScale, eyScale))
            return(FALSE);
    }

// Allocate a POLYTEXTA array.

    if (!(ppta = (POLYTEXTA *) LocalAlloc(LMEM_FIXED, (UINT) cmtext * sizeof(POLYTEXTA))))
        goto mpto_exit;

// Copy the POLYTEXTA array.

    ASSERTGDI(sizeof(MTEXT) == sizeof(POLYTEXTA)
           && offsetof(MTEXT,eptlRef.x) == offsetof(POLYTEXTA,x)
           && offsetof(MTEXT,eptlRef.y) == offsetof(POLYTEXTA,y)
           && offsetof(MTEXT,cchString) == offsetof(POLYTEXTA,n)
           && offsetof(MTEXT,offString) == offsetof(POLYTEXTA,lpstr)
           && offsetof(MTEXT,fOptions)  == offsetof(POLYTEXTA,uiFlags)
           && offsetof(MTEXT,ercl)      == offsetof(POLYTEXTA,rcl)
           && offsetof(MTEXT,offaDx)    == offsetof(POLYTEXTA,pdx),
        "MRPOLYTEXTOUT::bPlay: structures different");

    RtlCopyMemory((PBYTE) ppta, (PBYTE) &amtext[0], cmtext * sizeof(POLYTEXTA));

// Update the pointers.

    for (i = 0; i < cmtext; i++)
    {
        if (!bValidOff(pht, amtext[i].offString) || !bValidOff(pht, amtext[i].offaDx))
        {
            EMFVALFAIL(("MRPOLYTEXTOUT::bPlay() amtext[%d].offString = %08x amtext[%d].offaDx = %08x\n", i, amtext[i].offString, i , amtext[i].offaDx));
            goto mpto_free_and_exit;
        }
        ppta[i].lpstr = (PCSTR) ((PBYTE) this + amtext[i].offString);
        ppta[i].pdx   = (int *) ((PBYTE) this + amtext[i].offaDx);
    }

// Make the call.

    if (iType == EMR_POLYTEXTOUTA)
        bRet = PolyTextOutA(hdc, ppta, (int) cmtext);
    else
        bRet = PolyTextOutW(hdc, (POLYTEXTW *) ppta, (int) cmtext);

mpto_free_and_exit:

    if (LocalFree((HANDLE) ppta))
    {
        ASSERTGDI(FALSE, "MRPOLYTEXTOUT::bPlay: LocalFree failed");
    }

mpto_exit:

// Restore the graphics mode.

    if (iGraphicsMode != GM_ADVANCED)
    {
        if (!SetGraphicsMode(hdc, GM_ADVANCED))
            return(FALSE);
        if (!SetFontXform(hdc, 0.0f, 0.0f))
            return(FALSE);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRSETCOLORADJUSTMENT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Tue Oct 27 09:59:28 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETCOLORADJUSTMENT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETCOLORADJUSTMENT::bPlay\n");
    ASSERTGDI(iType == EMR_SETCOLORADJUSTMENT, "Bad record type");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return(SetColorAdjustment(hdc, &ColorAdjustment));
}


BOOL MRESCAPE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    if (!bCheckRecord(pht))
        return(FALSE);

    switch( iType )
    {
    case EMR_DRAWESCAPE:
//        MFD2("Playing Meta DrawEscape %d\n", iEscape);
        DrawEscape( hdc, iEscape, cjIn, (const char*) ((PBYTE) this + sizeof(MRESCAPE)) );
        break;
    case EMR_EXTESCAPE:
//        MFD2("Playing Meta ExtEscape %d\n", iEscape);

        ExtEscape( hdc, iEscape, cjIn,
                   (const char*) ((PBYTE) this + sizeof(MRESCAPE)), 0,
                   (LPSTR) NULL );
        break;
    default:
        ASSERTGDI((FALSE), "MRESCAPE::bPlay invalid type\n");
        break;
    }

    USE(pht);
    USE(cht);
    return(TRUE);
}


BOOL MRNAMEDESCAPE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{

    if (!bCheckRecord(pht))
        return(FALSE);

    NamedEscape(hdc,
                (LPWSTR) ((PBYTE) this + sizeof(MRNAMEDESCAPE)),
                iEscape,
                 cjIn,
                (const char*) (PBYTE) this + sizeof(MRNAMEDESCAPE) + cjDriver,
                0,
                NULL);

    USE(pht);
    USE(cht);
    return(TRUE);
}


BOOL MRSTARTDOC::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PBYTE pj = (PBYTE) this+sizeof(MRSTARTDOC);
    PBYTE pjEnd = (PBYTE) this + nSize;
    ASSERTGDI(iType == EMR_STARTDOC, "Bad record type");
    DOCINFOW doi1;

// nothing for now


    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);

    *(&doi1) = *(&doi);

    if( doi1.lpszDocName != NULL )
    {
        doi1.lpszDocName = (LPWSTR) pj;
        SIZE_T len;
        if(FAILED(StringCbLengthW((CONST WCHAR*)pj,(SIZE_T)(pjEnd-pj),(size_t*)&len)))
        {
            EMFVALFAIL(("MRSTARTDOC::bPlay StringCbLenth failed\n"));
            return(FALSE);
        }
        len = ((len+1)* sizeof(WCHAR) + 4) & ~(0x3);
        if (!bValidOff(pht,(DWORD)len))
        {
            EMFVALFAIL(("MRSTARTDOC::bPlay bValidOff(%08x) failed\n", len));
            return(FALSE);
        }
        pj += len;
    }

    if( doi1.lpszOutput != NULL )
    {
        doi1.lpszOutput = (LPWSTR) pj;
    }

    MFD3("Playing StartDocA %s %s\n", doi1.lpszDocName, doi1.lpszOutput);

    return( StartDocW( hdc, &doi1 ) );
}


#define QUICK_BUF_SIZE  120

BOOL MRSMALLTEXTOUT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    RECT *pRect = NULL;
    BYTE *pjThis = (PBYTE) this + sizeof(MRSMALLTEXTOUT);
    WCHAR wcQuickBuf[QUICK_BUF_SIZE],*pwc;
    BOOL bRet;

    if (!bCheckRecord(pht))
        return(FALSE);

    if (iGraphicsMode != GM_ADVANCED)
    {
        if (!SetGraphicsMode(hdc, iGraphicsMode))
          return(FALSE);
         if (!SetFontXform(hdc, exScale, eyScale))
           return(FALSE);
    }

    if( !(fuOptions & ETO_NO_RECT) )
    {
        pRect = (RECT*) pjThis;
        pjThis += sizeof(RECT);
    }

    if( fuOptions & ETO_SMALL_CHARS )
    {
        INT c;
        WCHAR *pwc1;


        if( cChars > QUICK_BUF_SIZE )
        {
            pwc = (WCHAR*) LocalAlloc( LMEM_FIXED, sizeof(WCHAR) * cChars );

            if( pwc == NULL )
            {
                WARNING("MRSMALLTEXTOUT::bPlay -- out of memory\n" );
                return(FALSE);
            }
        }
        else
        {
            pwc = wcQuickBuf;
        }

        for( pwc1 = pwc, c = cChars; c > 0 ; c-- )
        {
            *pwc1++ = (WCHAR) *pjThis++;
        }
    }
    else
    {
        pwc = (WCHAR*) pjThis;
    }

    bRet = ExtTextOutW( hdc,
                        x,
                        y,
                        fuOptions & ~(ETO_NO_RECT|ETO_SMALL_CHARS),
                        pRect,
                        pwc,
                        cChars,
                        NULL );

    if( (pwc != wcQuickBuf ) && ( pwc != (WCHAR*) pjThis ) )
    {
        LocalFree( pwc );
    }

    if(iGraphicsMode != GM_ADVANCED)
    {

        if (!SetGraphicsMode(hdc, GM_ADVANCED))
          return(FALSE);

        if (!SetFontXform(hdc, 0.0f, 0.0f))
          return(FALSE);
    }

    return(bRet);

}


BOOL MRFORCEUFIMAPPING::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    ASSERTGDI(iType == EMR_FORCEUFIMAPPING, "Bad record type");

// nothing for now

    USE(pht);
    USE(cht);

    MFD1("Playing ForceUFIMapping\n");
    if (!bCheckRecord(pht))
        return(FALSE);
    return NtGdiForceUFIMapping(hdc, &ufi);
}


BOOL MRSETLINKEDUFIS::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    ASSERTGDI(iType == EMR_SETLINKEDUFIS, "Bad record type");

// nothing for now

    USE(pht);
    USE(cht);

    MFD1("Playing SetLinkedUFIs\n");
    if (!bCheckRecord(pht))
        return(FALSE);
    return(NtGdiSetLinkedUFIs(hdc, pufiList, uNumLinkedUFIs));
}

/******************************Public*Routine******************************\
*
* MRGLSRECORD::bPlay(hdc, pht, cht)
*
* Play the metafile record
*
* History:
*  Thu Feb 23 14:41:41 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/


BOOL MRGLSRECORD::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRGLSRECORD::bPlay\n");
    ASSERTGDI(iType == EMR_GLSRECORD, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);
    return GlmfPlayGlsRecord(hdc, cb, abRecord, NULL);
}

/******************************Public*Routine******************************\
*
* MRGLSBOUNDEDRECORD::bPlay(hdc, pht, cht)
*
* Play the metafile record
*
* History:
*  Thu Feb 23 14:41:41 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/


BOOL MRGLSBOUNDEDRECORD::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRGLSBOUNDEDRECORD::bPlay\n");
    ASSERTGDI(iType == EMR_GLSBOUNDEDRECORD, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);
    return GlmfPlayGlsRecord(hdc, cb, abRecord, &rclBounds);
}


/******************************Public*Routine******************************\
*
* MRPIXELFORMAT::bPlay(hdc, pht, cht)
*
* Play the metafile record
*
* History:
*  Mon Mar 27 14:41:41 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/


BOOL MRPIXELFORMAT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    int iPixelFormat;

    PUTS("MRPIXELFORMAT::bPlay\n");
    ASSERTGDI(iType == EMR_PIXELFORMAT, "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);
    iPixelFormat = ChoosePixelFormat(hdc, &pfd);
    if (iPixelFormat == 0)
    {
        return FALSE;
    }
    else
    {
        // Ignore errors from this call because the metafile player
        // may have already set up a pixel format and it can't
        // be set twice
        //
        // The check alone isn't sufficient because of race conditions,
        // it just cuts down on debug messages from OpenGL warning
        // about duplicate sets
        if (GetPixelFormat(hdc) == 0)
        {
            SetPixelFormat(hdc, iPixelFormat, &pfd);
        }

        return TRUE;
    }
}


/******************************Public*Routine******************************\
*
* MRSETICMPROFILE::bPlay(hdc, pht, cht)
*
* Play the metafile record
*
* History:
*  Wed May 07 17:38:00 1997     -by-    Hideyuki Nagase [hideyukn]
*   Created
*
\**************************************************************************/

BOOL MRSETICMPROFILE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETICMPROFILE::bPlay\n");

    ASSERTGDI((iType == EMR_SETICMPROFILEA) || (iType == EMR_SETICMPROFILEW),
              "Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);

    BOOL bRet = FALSE;

    PCACHED_COLORSPACE pCachedColorSpace;

    if (dwFlags & SETICMPROFILE_EMBEDED)
    {
        LOGCOLORSPACEW LogColorSpaceW;
        PROFILE        Profile;

        //
        // ICC Profile is attched into Metafile,
        //
        RtlZeroMemory(&LogColorSpaceW,sizeof(LOGCOLORSPACEW));

        //
        // Build fake LOGCOLORSPACEW for this color space.
        //
        LogColorSpaceW.lcsSignature = LCS_SIGNATURE;
        LogColorSpaceW.lcsVersion   = 0x400;
        LogColorSpaceW.lcsSize      = sizeof(LOGCOLORSPACEW);
        LogColorSpaceW.lcsCSType    = LCS_CALIBRATED_RGB;
        LogColorSpaceW.lcsIntent    = LCS_DEFAULT_INTENT;

        if (iType == EMR_SETICMPROFILEW)
        {
            //
            // Copy desired filename in Unicode.
            //
            BuildIcmProfilePath((WCHAR *)Data,LogColorSpaceW.lcsFilename,MAX_PATH);
        }
        else
        {
            WCHAR TempFile[MAX_PATH];

            //
            // Data is ansi based string, Convert the string to Unicode.
            //
            vToUnicodeN(TempFile,MAX_PATH,(char *)Data,strlen((char *)Data)+1);

            //
            // Copy desired filename in Unicode.
            //
            BuildIcmProfilePath(TempFile,LogColorSpaceW.lcsFilename,MAX_PATH);
        }

        //
        // Make PROFILE structure pointing color profile in metafile.
        //
        Profile.dwType = PROFILE_MEMBUFFER;
        Profile.pProfileData = Data+cbName;
        Profile.cbDataSize = cbData;

        //
        // Search this color space from cache.
        //
        pCachedColorSpace = IcmGetColorSpaceByColorSpace(
                                hdc, &LogColorSpaceW, &Profile,
                                (METAFILE_COLORSPACE | ON_MEMORY_PROFILE));

        if (pCachedColorSpace == NULL)
        {
            pCachedColorSpace = IcmCreateColorSpaceByColorSpace(
                                    hdc, &LogColorSpaceW, &Profile,
                                    (METAFILE_COLORSPACE | ON_MEMORY_PROFILE));
        }

        if (pCachedColorSpace)
        {
            bRet = SetICMProfileInternalW(hdc,NULL,pCachedColorSpace,0);

            // - if bRet is TRUE.
            //
            // SetICMProfileInternal increments ref. count of colorspace.
            // but we have done it by Icm[Get|Create]ColorSpaceByName, so
            // decrement ref count of color space here.
            //
            // - if bRet is FALSE.
            //
            // we failed to select to this color space to target, so we should
            // decrement ref count which done by Icm[Get|Create]ColorSpace
            //
            IcmReleaseColorSpace(NULL,pCachedColorSpace,FALSE);
        }
    }
    else
    {
        //
        // The record only has profile filename in Data.
        //
        if (iType == EMR_SETICMPROFILEA)
        {
            bRet = SetICMProfileInternalA(hdc,(LPSTR)Data,NULL,METAFILE_COLORSPACE);
        }
        else
        {
            bRet = SetICMProfileInternalW(hdc,(LPWSTR)Data,NULL,METAFILE_COLORSPACE);
        }
    }

    return bRet;
}


/******************************Public*Routine******************************\
*
* MRCOLORMATCHTOTARGET::bPlay(hdc, pht, cht)
*
* Play the metafile record
*
* History:
*  Wed Jun 23 12:00:00 1998     -by-    Hideyuki Nagase [hideyukn]
*   Created
*
\**************************************************************************/

BOOL MRCOLORMATCHTOTARGET::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRCOLORMATCHTOTARGET::bPlay\n");

    ASSERTGDI(iType == EMR_COLORMATCHTOTARGETW,"Bad record type");

    USE(pht);
    USE(cht);

    if (!bCheckRecord(pht))
        return(FALSE);
    BOOL bRet = TRUE;

    if (dwAction == CS_ENABLE)
    {
        PCACHED_COLORSPACE pCachedColorSpace;

        if (dwFlags & COLORMATCHTOTARGET_EMBEDED)
        {
            LOGCOLORSPACEW LogColorSpaceW;
            PROFILE        Profile;

            //
            // ICC Profile is attched into Metafile,
            //
            RtlZeroMemory(&LogColorSpaceW,sizeof(LOGCOLORSPACEW));

            //
            // Build fake LOGCOLORSPACEW for this color space.
            //
            LogColorSpaceW.lcsSignature = LCS_SIGNATURE;
            LogColorSpaceW.lcsVersion   = 0x400;
            LogColorSpaceW.lcsSize      = sizeof(LOGCOLORSPACEW);
            LogColorSpaceW.lcsCSType    = LCS_CALIBRATED_RGB;
            LogColorSpaceW.lcsIntent    = LCS_DEFAULT_INTENT;

            //
            // Copy desired filename in Unicode.
            //
            BuildIcmProfilePath((WCHAR *)Data,LogColorSpaceW.lcsFilename,MAX_PATH);

            //
            // Make PROFILE structure pointing color profile in metafile.
            //
            Profile.dwType = PROFILE_MEMBUFFER;
            Profile.pProfileData = Data+cbName;
            Profile.cbDataSize = cbData;

            //
            // Search this color space from cache.
            //
            pCachedColorSpace = IcmGetColorSpaceByColorSpace(
                                    hdc, &LogColorSpaceW, &Profile,
                                    (METAFILE_COLORSPACE | ON_MEMORY_PROFILE));

            if (pCachedColorSpace == NULL)
            {
                pCachedColorSpace = IcmCreateColorSpaceByColorSpace(
                                        hdc, &LogColorSpaceW, &Profile,
                                        (METAFILE_COLORSPACE | ON_MEMORY_PROFILE));
            }
        }
        else
        {
            //
            // The record only has profile filename in Data.
            //
            pCachedColorSpace = IcmGetColorSpaceByName(
                                    hdc,(LPWSTR)Data,
                                    LCS_DEFAULT_INTENT,
                                    METAFILE_COLORSPACE);

            if (pCachedColorSpace == NULL)
            {
                pCachedColorSpace = IcmCreateColorSpaceByName(
                                        hdc,(LPWSTR)Data,
                                        LCS_DEFAULT_INTENT,
                                        METAFILE_COLORSPACE);
            }
        }

        if (pCachedColorSpace)
        {
            bRet = ColorMatchToTargetInternal(hdc,pCachedColorSpace,dwAction);

            // - if bRet is TRUE.
            //
            // ColorMatchToTargetInternal increments ref. count of colorspace.
            // but we have done it by Icm[Get|Create]ColorSpaceByName, so
            // decrement ref count of color space here.
            //
            // - if bRet is FALSE.
            //
            // we failed to select to this color space to target, so we should
            // decrement ref count which done by Icm[Get|Create]ColorSpace
            //
            IcmReleaseColorSpace(NULL,pCachedColorSpace,FALSE);
        }
    }
    else
    {
        //
        // Reset Target color space
        //
        bRet = ColorMatchToTargetInternal(hdc,NULL,dwAction);
    }

    return bRet;
}

/******************************Public*Routine******************************\
*
* MRCREATECOLORSPACEW::bPlay(hdc, pht, cht)
*
* Play the metafile record
*
* History:
*  Wed Jun 23 12:00:00 1998     -by-    Hideyuki Nagase [hideyukn]
*   Created
*
\**************************************************************************/

BOOL MRCREATECOLORSPACEW::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRCREATECOLORSPACEW::bPlay\n");

    ASSERTGDI(iType == EMR_CREATECOLORSPACEW, "Bad record type");

    USE(hdc);

    if (!bCheckRecord(pht))
        return(FALSE);
// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

    pht->objectHandle[imhe] = CreateColorSpaceW(&lcsp);
    return(pht->objectHandle[imhe] != 0);
}

/****************************Public*Routine**************************\
*
* MRSETTEXTJUSTIFICATION::bPlay(hdc, pht, cht)
*
* Play the metafile record of SetTextJustification
*
* History:
*  07-May-1997  -by-    Xudong Wu [Tessiew]
* Wrote it.
\*********************************************************************/

BOOL MRSETTEXTJUSTIFICATION::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETTEXTJUSTIFICATION::bPlay\n");
    ASSERTGDI(iType == EMR_SETTEXTJUSTIFICATION, "MRSETTEXTJUSTIFICATION Bad record type\n");

    USE(pht);
    USE(cht);
    if (!bCheckRecord(pht))
        return(FALSE);
    return (SetTextJustification(hdc, (int)d1, (int)d2));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\mf16.h ===
/******************************Module*Header*******************************\
* Module Name: mf16.h                                                      *
*									   
* Definitions needed for 3.x Metafile functions                            *
*									   
* Created: 01-Jul-1991                                                     *
* Author: John Colleran (johnc)                                            *
*									   
* Copyright (c) 1991-1999 Microsoft Corporation				   
\**************************************************************************/

// Windows 3.x structures

#pragma pack(2)

#define SIZEOF_METARECORDHEADER (sizeof(DWORD)+sizeof(WORD))

typedef struct _RECT16 {
    SHORT   left;
    SHORT   top;
    SHORT   right;
    SHORT   bottom;
} RECT16;
typedef RECT16 UNALIGNED *PRECT16;

typedef struct _BITMAP16 {
    SHORT   bmType;
    SHORT   bmWidth;
    SHORT   bmHeight;
    SHORT   bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    LPBYTE  bmBits;
} BITMAP16;
typedef BITMAP16 UNALIGNED *PBITMAP16;

typedef struct _LOGBRUSH16 {
    WORD     lbStyle;
    COLORREF lbColor;
    SHORT    lbHatch;
} LOGBRUSH16;
typedef LOGBRUSH16 UNALIGNED *PLOGBRUSH16;

typedef struct tagLOGFONT16
{
    SHORT     lfHeight;
    SHORT     lfWidth;
    SHORT     lfEscapement;
    SHORT     lfOrientation;
    SHORT     lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    BYTE      lfFaceName[LF_FACESIZE];
} LOGFONT16;
typedef LOGFONT16 UNALIGNED *PLOGFONT16;

typedef struct _LOGPEN16 {
    WORD     lopnStyle;
    POINTS   lopnWidth;
    COLORREF lopnColor;
} LOGPEN16;
typedef LOGPEN16 UNALIGNED *PLOGPEN16;

#pragma pack()


// Macros for converting 32 bit objects to 16 bit equivalents

#define INT32FROMINT16(lp32, lp16, c)                           \
{                                                               \
    UINT    ii;                                                 \
                                                                \
    for(ii=0; ii<(c); ii++)                                     \
        ((LPINT)(lp32))[ii] = ((PSHORT)(lp16))[ii];             \
}

#define BITMAP32FROMBITMAP16(lpBitmap, lpBitmap16)              \
{                                                               \
    (lpBitmap)->bmType       = (LONG)(lpBitmap16)->bmType;      \
    (lpBitmap)->bmWidth      = (LONG)(lpBitmap16)->bmWidth;     \
    (lpBitmap)->bmHeight     = (LONG)(lpBitmap16)->bmHeight;    \
    (lpBitmap)->bmWidthBytes = (LONG)(lpBitmap16)->bmWidthBytes;\
    (lpBitmap)->bmPlanes     = (WORD)(lpBitmap16)->bmPlanes;    \
    (lpBitmap)->bmBitsPixel  = (WORD)(lpBitmap16)->bmBitsPixel; \
    (lpBitmap)->bmBits       = (lpBitmap16)->bmBits;            \
}

#define LOGBRUSH32FROMLOGBRUSH16(lpLogBrush, lpLogBrush16)      \
{                                                               \
    (lpLogBrush)->lbStyle = (UINT) (lpLogBrush16)->lbStyle;     \
    (lpLogBrush)->lbColor = (lpLogBrush16)->lbColor;            \
    (lpLogBrush)->lbHatch = (LONG)  (lpLogBrush16)->lbHatch;    \
}

#define LOGFONT32FROMLOGFONT16(lpLogFont, lpLogFont16)          \
{                                                               \
    ASSERTGDI((sizeof(LOGFONTA) == (sizeof(LOGFONT16)+sizeof(WORD)*5)), \
            "MF16.h: LOGFONT(32) and LOGFONT(16) changed!");            \
    (lpLogFont)->lfHeight      = (LONG) (lpLogFont16)->lfHeight;           \
    (lpLogFont)->lfWidth       = (LONG) (lpLogFont16)->lfWidth;            \
    (lpLogFont)->lfEscapement  = (LONG) (lpLogFont16)->lfEscapement;       \
    (lpLogFont)->lfOrientation = (LONG) (lpLogFont16)->lfOrientation;      \
    (lpLogFont)->lfWeight      = (LONG) (lpLogFont16)->lfWeight;           \
    /* [ntbug #129231 - Access97 occurs an application error.]             \
       Access 97 does not padded rest of facename arrary if the length of  \
       face name is less than LF_FACESIZE. Win9x only access until null,   \
       so that they are safe, we also did same.                         */ \
    (lpLogFont)->lfItalic      =        (lpLogFont16)->lfItalic;           \
    (lpLogFont)->lfUnderline   =        (lpLogFont16)->lfUnderline;        \
    (lpLogFont)->lfStrikeOut   =        (lpLogFont16)->lfStrikeOut;        \
    (lpLogFont)->lfCharSet     =        (lpLogFont16)->lfCharSet;          \
    (lpLogFont)->lfOutPrecision =       (lpLogFont16)->lfOutPrecision;     \
    (lpLogFont)->lfClipPrecision =      (lpLogFont16)->lfClipPrecision;    \
    (lpLogFont)->lfQuality     =        (lpLogFont16)->lfQuality;          \
    (lpLogFont)->lfPitchAndFamily =     (lpLogFont16)->lfPitchAndFamily;   \
    strncpy((lpLogFont)->lfFaceName,(lpLogFont16)->lfFaceName,LF_FACESIZE);\
}

#define LOGPEN32FROMLOGPEN16(pLogPen, pLogPen16)                \
{                                                               \
    (pLogPen)->lopnStyle   = (pLogPen16)->lopnStyle;            \
    (pLogPen)->lopnWidth.x = (pLogPen16)->lopnWidth.x;          \
    (pLogPen)->lopnWidth.y = (pLogPen16)->lopnWidth.y;          \
    (pLogPen)->lopnColor   = (pLogPen16)->lopnColor;            \
}


// Macros for convert 16 bit objects to 32 bit equivalents

#define BITMAP16FROMBITMAP32(pBitmap16,pBitmap)                 \
{                                                               \
    (pBitmap16)->bmType      = (SHORT)(pBitmap)->bmType;        \
    (pBitmap16)->bmWidth     = (SHORT)(pBitmap)->bmWidth;       \
    (pBitmap16)->bmHeight    = (SHORT)(pBitmap)->bmHeight;      \
    (pBitmap16)->bmWidthBytes= (SHORT)(pBitmap)->bmWidthBytes;  \
    (pBitmap16)->bmPlanes    = (BYTE)(pBitmap)->bmPlanes;       \
    (pBitmap16)->bmBitsPixel = (BYTE)(pBitmap)->bmBitsPixel;    \
    (pBitmap16)->bmBits      = (pBitmap)->bmBits;               \
}

#define LOGBRUSH16FROMLOGBRUSH32(pLogBrush16,pLogBrush)         \
{                                                               \
    (pLogBrush16)->lbStyle = (WORD)(pLogBrush)->lbStyle;        \
    ASSERTGDI((pLogBrush16)->lbStyle == BS_SOLID		\
	   || (pLogBrush16)->lbStyle == BS_HATCHED		\
	   || (pLogBrush16)->lbStyle == BS_HOLLOW,		\
	"LOGBRUSH16FROMLOGBRUSH32: unexpected lbStyle");	\
    (pLogBrush16)->lbColor = (pLogBrush)->lbColor;              \
    (pLogBrush16)->lbHatch = (SHORT)(pLogBrush)->lbHatch;       \
}

#define LOGPEN16FROMLOGPEN32(pLogPen16,pLogPen)                 \
{                                                               \
    (pLogPen16)->lopnStyle   = (WORD)(pLogPen)->lopnStyle;      \
    (pLogPen16)->lopnWidth.x = (SHORT)(pLogPen)->lopnWidth.x;   \
    (pLogPen16)->lopnWidth.y = (SHORT)(pLogPen)->lopnWidth.y;   \
    (pLogPen16)->lopnColor   = (pLogPen)->lopnColor;            \
}

#define LOGFONT16FROMLOGFONT32(pLogFont16,pLogFont)             \
{                                                               \
    ASSERTGDI((sizeof(LOGFONTA) == (sizeof(LOGFONT16)+sizeof(WORD)*5)),  \
            "MF16.h: LOGFONT(32) and LOGFONT(16) changed!");            \
    (pLogFont16)->lfHeight      = (SHORT)(pLogFont)->lfHeight;  \
    (pLogFont16)->lfWidth       = (SHORT)(pLogFont)->lfWidth;   \
    (pLogFont16)->lfEscapement  = (SHORT)(pLogFont)->lfEscapement;   \
    (pLogFont16)->lfOrientation = (SHORT)(pLogFont)->lfOrientation;  \
    (pLogFont16)->lfWeight      = (SHORT)(pLogFont)->lfWeight;       \
    RtlCopyMemory((PVOID)&(pLogFont16)->lfItalic,                  \
                  (CONST VOID *)&(pLogFont)->lfItalic,             \
                  sizeof(LOGFONTA)-sizeof(LONG)*5); \
}


/*** MetaFile Internal Constants and Macros ***/

#define METAVERSION300      0x0300
#define METAVERSION100      0x0100

// Metafile constants not in Windows.h

#define MEMORYMETAFILE      1
#define DISKMETAFILE        2

#define METAFILEFAILURE     1               // Flags denoting metafile is aborted

#define MF16_BUFSIZE_INIT   (16*1024)       // Metafile memory buffer size
#define MF16_BUFSIZE_INC    (16*1024)       // Metafile buffer increment size

#define ID_METADC16         0x444D          // "MD"
#define MF16_IDENTIFIER     0x3631464D      // "MF16"

#define MF3216_INCLUDE_WIN32MF     0x0001

// Constants for MFCOMMENT Escape

#define MFCOMMENT_IDENTIFIER           0x43464D57
#define MFCOMMENT_ENHANCED_METAFILE    1

// pmf16AllocMF16 flags

#define ALLOCMF16_TRANSFER_BUFFER	0x1

// METAFILE16 flags

#define MF16_DISKFILE		0x0001	// Disk or memory metafile.

// *** MetaFile Internal TypeDefs ***

typedef struct _METAFILE16 {
    DWORD       ident;
    METAHEADER  metaHeader;
    HANDLE      hFile;
    HANDLE      hFileMap;
    HANDLE      hMem;
    DWORD       iMem;
    HANDLE      hMetaFileRecord;
    DWORD       fl;
    WCHAR       wszFullPathName[MAX_PATH+1];
} METAFILE16,* PMETAFILE16;

#define MIN_OBJ_TYPE    OBJ_PEN
#define MAX_OBJ_TYPE    OBJ_ENHMETAFILE

typedef struct _MFRECORDER16 {

    HANDLE      hMem;                       // handle to the data (or buffer)
    HANDLE      hFile;                      // handle to the disk file
    DWORD       cbBuffer;                   // current size of hMem
    DWORD       ibBuffer;                   // current position in buffer
    METAHEADER  metaHeader;
    WORD        recFlags;
    HANDLE      hObjectTable;
    HANDLE      recCurObjects[MAX_OBJ_TYPE];// Current Selected Object
    UINT        iPalVer;                    // index of palette metafile synced to
    WCHAR       wszFullPathName[MAX_PATH+1];
} MFRECORDER16, * PMFRECORDER16;

typedef struct _OBJECTTABLE {
    HANDLE      CurHandle;
    BOOL        fPreDeleted;
} OBJECTTABLE, * POBJECTTABLE;

#pragma pack(2)
typedef struct _SCAN  {
    WORD        scnPntCnt;                  // Scan point count
    WORD        scnPntTop;                  // Top of scan
    WORD        scnPntBottom;               // Bottom of scan
    WORD        scnPntsX[2];                // Start of points in scan
    WORD        scnPtCntToo;                // Point count-- to allow UP travel
} SCAN;
typedef SCAN UNALIGNED *PSCAN;

typedef struct _WIN3REGION {
    WORD        nextInChain;                // Not used should be zero
    WORD        ObjType;                    // Must always be 6 (Windows OBJ_RGN)
    DWORD       ObjCount;                   // Not used
    WORD        cbRegion;                   // size of following region struct
    WORD        cScans;
    WORD        maxScan;
    RECT16      rcBounding;
    SCAN        aScans[1];
} WIN3REGION;
typedef WIN3REGION UNALIGNED *PWIN3REGION;

typedef struct _META_ESCAPE_ENHANCED_METAFILE {
    DWORD       rdSize;             // Size of the record in words
    WORD        rdFunction;         // META_ESCAPE
    WORD        wEscape;            // MFCOMMENT
    WORD        wCount;             // Size of the following data + emf in bytes
    DWORD       ident;              // MFCOMMENT_IDENTIFIER
    DWORD       iComment;           // MFCOMMENT_ENHANCED_METAFILE
    DWORD       nVersion;           // Enhanced metafile version 0x10000
    WORD        wChecksum;          // Checksum - used by 1st record only
    DWORD       fFlags;             // Compression etc - used by 1st record only
    DWORD       nCommentRecords;    // Number of records making up the emf
    DWORD       cbCurrent;          // Size of emf data in this record in bytes
    DWORD       cbRemainder;        // Size of remainder in following records
    DWORD       cbEnhMetaFile;      // Size of enhanced metafile in bytes
				    // The enhanced metafile data follows here
} META_ESCAPE_ENHANCED_METAFILE;
typedef META_ESCAPE_ENHANCED_METAFILE UNALIGNED *PMETA_ESCAPE_ENHANCED_METAFILE;
#pragma pack()

// Macro to check that it is a meta_escape embedded enhanced metafile record.

#define IS_META_ESCAPE_ENHANCED_METAFILE(pmfeEnhMF)			      \
	((pmfeEnhMF)->rdFunction == META_ESCAPE				      \
      && (pmfeEnhMF)->rdSize     >  sizeof(META_ESCAPE_ENHANCED_METAFILE) / 2 \
      && (pmfeEnhMF)->wEscape    == MFCOMMENT				      \
      && (pmfeEnhMF)->ident      == MFCOMMENT_IDENTIFIER		      \
      && (pmfeEnhMF)->iComment   == MFCOMMENT_ENHANCED_METAFILE)

// Internal Function Declarations

PMETARECORD   GetEvent(PMETAFILE16 pmf,PMETARECORD pmr);
DWORD         GetObject16AndType(HANDLE hObj, LPVOID lpObjectBuf);
BOOL          IsValidMetaHeader16(PMETAHEADER pMetaHeader);
WORD          RecordObject(HDC hdc, HANDLE hObject);
BOOL          RecordParms(HDC hDC, DWORD magic, DWORD cw, CONST WORD *lpParm);
UINT          ConvertEmfToWmf(PVOID pht, PBYTE pMeta32, UINT cbMeta16, PBYTE pMeta16, INT mm, HDC hdc, UINT f);
PMETAFILE16   pmf16AllocMF16(DWORD fl, DWORD cb, CONST UNALIGNED DWORD *pb, LPCWSTR pwszFilename);
VOID          vFreeMF16(PMETAFILE16 pmf16);
BOOL	      bMetaGetDIBInfo(HDC hdc, HBITMAP hbm,
                    PBITMAPINFOHEADER pBmih, PDWORD pcbBmi, PDWORD pcbBits,
                    DWORD iUsage, LONG cScans, BOOL bMeta16);
BOOL APIENTRY IsValidEnhMetaRecord(PVOID pht, PVOID pmr);
BOOL APIENTRY IsValidEnhMetaRecordOffExt(PVOID pht, PVOID pmr, DWORD Off, DWORD Ext);


#define hmf16Create(pmf16)   hCreateClientObjLink((PVOID)pmf16,LO_METAFILE16_TYPE)
#define bDeleteHmf16(hmf)    bDeleteClientObjLink((HANDLE)hmf)
#define GET_PMF16(hmf)       ((PMETAFILE16)pvClientObjGet((HANDLE)hmf,LO_METAFILE16_TYPE))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\mfrec16.c ===
/****************************** Module Header ******************************\
* Module Name: MfRec16.c
*
* Copyright (c) 1991-1999 Microsoft Corporation
*
* DESCRIPTIVE NAME:   Metafile Recorder
*
* FUNCTION:   Records GDI functions in memory and disk metafiles.
*
* PUBLIC ENTRY POINTS:
*   CloseMetaFile
*   CopyMetaFile
*   CreateMetaFile
*   GetMetaFileBitsEx
*   SetMetaFileBitsEx
* PRIVATE ENTRY POINTS:
*   RecordParms
*   AttemptWrite
*   MarkMetaFile
*   RecordObject
*   ProbeSize
*   AddObjectToDCTable
*
* History:
*  02-Jul-1991 -by-  John Colleran [johnc]
* Combined From Win 3.1 and WLO 1.0 sources
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "mf16.h"



UINT    AddObjectToDCTable(HDC hdc, HANDLE hObject, PUINT piPosition, BOOL bRealAdd);
BOOL    AddDCToObjectMetaList16(HDC hMeta16DC, HANDLE hObject);
BOOL    AttemptWrite(PMFRECORDER16 pMFRec, DWORD dwBytes, LPBYTE lpData);
VOID    MarkMetaFile(PMFRECORDER16 pMFRec);
BOOL    MakeLogPalette(HDC hdc, HANDLE hPal, WORD magic);
HANDLE  ProbeSize(PMFRECORDER16 pMF, DWORD dwLength);
BOOL    RecordCommonBitBlt(HDC hdcDest, INT x, INT y, INT nWidth, INT nHeight,
                HDC hdcSrc, INT xSrc, INT ySrc, INT nSrcWidth, INT nSrcHeight,
                DWORD rop, WORD wFunc);
BOOL    UnlistObjects(HDC hMetaDC);
BOOL    MF16_DeleteRgn(HDC hdc, HANDLE hrgn);


// Metafile Logging stubs for 3.x Metafiles

/******************************Public*Routine******************************\
* XXX_RecordParms
*
* These routines package up the parameters of an NT GDI call and send
* them to a general purpose recording routine that validates the metafile
* DC and records the parameters.
*
* Returns
*    TRUE iff successful
*
* Warnings
*    Windows 3.x metafile behavior is that when a function is being metafiled
*    the routine itself is not called; eg SetPixel does not call GreSetPixel
*    but (GDI) SetPixel intercepts the calls and records the parameters and
*    returns without taking further action
*
* History:
*   24-Nov-1991  -by-    John Colleran  [johnc]
* Wrote it.
\**************************************************************************/

BOOL MF16_RecordParms1(HDC hdc, WORD Func)
{
    return RecordParms(hdc, Func, 0, (LPWORD)NULL);
}

BOOL MF16_RecordParms2(HDC hdc, INT parm2, WORD Func)
{
    return RecordParms(hdc, Func, 1, (LPWORD)&parm2);
}

BOOL MF16_RecordParms3(HDC hdc, INT parm2, INT parm3, WORD Func)
{
    WORD    aw[2];

    aw[0] = (WORD)parm3;
    aw[1] = (WORD)parm2;
    return RecordParms(hdc, Func, 2, aw);
}

BOOL MF16_RecordParms5(HDC hdc, INT parm2, INT parm3, INT parm4, INT parm5, WORD Func)
{
    WORD    aw[4];

    aw[0] = (WORD)parm5;
    aw[1] = (WORD)parm4;
    aw[2] = (WORD)parm3;
    aw[3] = (WORD)parm2;
    return RecordParms(hdc, Func, 4, aw);
}

BOOL MF16_RecordParms7(HDC hdc, INT parm2, INT parm3, INT parm4, INT parm5, INT parm6, INT parm7, WORD Func)
{
    WORD    aw[6];

    aw[0] = (WORD)parm7;
    aw[1] = (WORD)parm6;
    aw[2] = (WORD)parm5;
    aw[3] = (WORD)parm4;
    aw[4] = (WORD)parm3;
    aw[5] = (WORD)parm2;
    return RecordParms(hdc, Func, 6, aw);
}

BOOL MF16_RecordParms9(HDC hdc, INT parm2, INT parm3, INT parm4, INT parm5,
        INT parm6, INT parm7, INT parm8, INT parm9, WORD Func)
{
    WORD    aw[8];

    aw[0] = (WORD)parm9;
    aw[1] = (WORD)parm8;
    aw[2] = (WORD)parm7;
    aw[3] = (WORD)parm6;
    aw[4] = (WORD)parm5;
    aw[5] = (WORD)parm4;
    aw[6] = (WORD)parm3;
    aw[7] = (WORD)parm2;
    return RecordParms(hdc, Func, 8, aw);
}

BOOL MF16_RecordParmsD(HDC hdc, DWORD d1, WORD Func)
{
    return RecordParms(hdc, Func, 2, (LPWORD) &d1);
}

BOOL MF16_RecordParmsWWD(HDC hdc, WORD w1, WORD w2, DWORD d3, WORD Func)
{
    WORD    aw[4];

    aw[0] = LOWORD(d3);
    aw[1] = HIWORD(d3);
    aw[2] = w2;
    aw[3] = w1;
    return RecordParms(hdc, Func, 4, aw);
}

BOOL MF16_RecordParmsWWDW(HDC hdc, WORD w1, WORD w2, DWORD d3, WORD w4, WORD Func)
{
    WORD    aw[5];

    aw[0] = w4;
    aw[1] = LOWORD(d3);
    aw[2] = HIWORD(d3);
    aw[3] = w2;
    aw[4] = w1;
    return RecordParms(hdc, Func, 5, aw);
}

BOOL MF16_RecordParmsWWWWD(HDC hdc, WORD w1, WORD w2, WORD w3, WORD w4, DWORD d5, WORD Func)
{
    WORD    aw[6];

    aw[0] = LOWORD(d5);
    aw[1] = HIWORD(d5);
    aw[2] = w4;
    aw[3] = w3;
    aw[4] = w2;
    aw[5] = w1;
    return RecordParms(hdc, Func, 6, aw);
}

BOOL MF16_RecordParmsPoly(HDC hdc, LPPOINT lpPoint, INT nCount, WORD Func)
{
    BOOL        fRet;
    LPWORD      lpW,lpT;
    DWORD       cw;
    INT         ii;

    cw = (nCount*sizeof(POINTS)/sizeof(WORD))+1;
    lpT = lpW = (LPWORD)LocalAlloc(LMEM_FIXED, cw*sizeof(WORD));
    if (!lpW)
        return(FALSE);

    *lpW++ = (WORD)nCount;

    for(ii=0; ii<nCount; ii++)
    {
        *lpW++ = (WORD)lpPoint[ii].x;
        *lpW++ = (WORD)lpPoint[ii].y;
    }

    fRet = RecordParms(hdc, Func, cw, lpT);

    if (LocalFree((HANDLE)lpT))
        ASSERTGDI(FALSE, "MF16_RecordParmsPoly: LocalFree Failed\n");

    return (fRet);
}

// SetDIBitsToDevice
// StretchDIBits

BOOL MF16_RecordDIBits
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    int     xDib,
    int     yDib,
    int     cxDib,
    int     cyDib,
    DWORD   iStartScan,
    DWORD   cScans,
    DWORD   cbBitsDib,
    CONST VOID * pBitsDib,
    DWORD   cbBitsInfoDib,
    CONST BITMAPINFO *pBitsInfoDib,
    DWORD   iUsageDib,
    DWORD   rop,
    DWORD   mrType
)
{
    BOOL        fRet;
    LPWORD      lpW;
    LPWORD      lpWStart;
    WORD        cwParms;
    PBMIH       lpDIBInfoHeader;

    PUTS("MF16_RecrodDIBits\n");

    ASSERTGDI(mrType == META_SETDIBTODEV || mrType == META_STRETCHDIB,
        "MF16_RecrodDIBits: Bad mrType");

// Get the number of parameters to save.

    cwParms = (WORD) ((mrType == META_SETDIBTODEV) ? 9 : 11);   // in words

// Allocate space for DIB plus parameters.

    lpWStart = lpW = (LPWORD) LocalAlloc(LMEM_FIXED,
                cbBitsInfoDib + (cbBitsDib + 1) / 2 * 2 + cwParms*sizeof(WORD));
    if (!lpW)
    {
        ERROR_ASSERT(FALSE, "MF16_RecordDIBits: out of memory\n");
        return(FALSE);
    }

// Copy the parameters.

    if (mrType == META_SETDIBTODEV)
    {
        *lpW++ = (WORD) iUsageDib;
        *lpW++ = (WORD) cScans;
        *lpW++ = (WORD) iStartScan;
        *lpW++ = (WORD) yDib;
        *lpW++ = (WORD) xDib;
        *lpW++ = (WORD) cyDib;
        *lpW++ = (WORD) cxDib;
        *lpW++ = (WORD) yDst;
        *lpW++ = (WORD) xDst;
    }
    else
    {
        *lpW++ = (WORD) LOWORD(rop);
        *lpW++ = (WORD) HIWORD(rop);
        *lpW++ = (WORD) iUsageDib;
        *lpW++ = (WORD) cyDib;
        *lpW++ = (WORD) cxDib;
        *lpW++ = (WORD) yDib;
        *lpW++ = (WORD) xDib;
        *lpW++ = (WORD) cyDst;
        *lpW++ = (WORD) cxDst;
        *lpW++ = (WORD) yDst;
        *lpW++ = (WORD) xDst;
    }

// Save the start of the bitmap info header field.

    lpDIBInfoHeader = (LPBITMAPINFOHEADER) lpW;

// cbBitsInfoDib must be word sized

    ASSERTGDI(cbBitsInfoDib % 2 == 0,
        "MF16_RecordDIBits: cbBitsInfoDib is not word aligned");

// Copy dib info if given.

    if (cbBitsInfoDib)
    {
        if (pBitsInfoDib->bmiHeader.biSize == sizeof(BMCH))
        {
            CopyCoreToInfoHeader
            (
                lpDIBInfoHeader,
                (LPBITMAPCOREHEADER) pBitsInfoDib
            );

            if (iUsageDib == DIB_RGB_COLORS)
            {
                RGBQUAD   *prgbq;
                RGBTRIPLE *prgbt;
                UINT      ui;

                prgbq = ((PBMI) lpDIBInfoHeader)->bmiColors;
                prgbt = ((PBMC) pBitsInfoDib)->bmciColors;

                ASSERTGDI(cbBitsInfoDib >= sizeof(BMIH),
                    "MF16_RecordDIBits: Bad cbBitsInfoDib size");

                for
                (
                    ui = (UINT) (cbBitsInfoDib - sizeof(BMIH))
                                / sizeof(RGBQUAD);
                    ui;
                    ui--
                )
                {
                    prgbq->rgbBlue     = prgbt->rgbtBlue;
                    prgbq->rgbGreen    = prgbt->rgbtGreen;
                    prgbq->rgbRed      = prgbt->rgbtRed;
                    prgbq->rgbReserved = 0;
                    prgbq++; prgbt++;
                }
            }
            else
            {
                RtlCopyMemory
                (
                    (PBYTE) lpDIBInfoHeader + sizeof(BMIH),
                    (PBYTE) pBitsInfoDib + sizeof(BMCH),
                    cbBitsInfoDib - sizeof(BMIH)
                );
            }
        }
        else
        {
            RtlCopyMemory
            (
                (PBYTE) lpDIBInfoHeader,
                (PBYTE) pBitsInfoDib,
                cbBitsInfoDib
            );

            if (pBitsInfoDib->bmiHeader.biBitCount >= 16)
            {
                DWORD UNALIGNED *pClrUsed = (DWORD UNALIGNED *)&lpDIBInfoHeader->biClrUsed;
                *pClrUsed = 0;
            }

        }
    }

// Copy dib bits.

    RtlCopyMemory((PBYTE) lpDIBInfoHeader + cbBitsInfoDib, pBitsDib, cbBitsDib);

// Finally record the parameters into the file.

    fRet = RecordParms(hdcDst, mrType,
                   cwParms + (cbBitsInfoDib + cbBitsDib + 1) / sizeof(WORD),
                   lpWStart);

    if (lpWStart)
        if (LocalFree((HANDLE) lpWStart))
            ASSERTGDI(FALSE, "MF16_RecordDIBits: LocalFree Failed\n");

    return(fRet);
}

BOOL MF16_BitBlt(HDC hdcDest, INT x, INT y, INT nWidth, INT nHeight,
        HDC hdcSrc, INT xSrc, INT ySrc, DWORD rop)
{
    WORD        aw[9];

// This is how windows works but really it should look at the ROP
    if (hdcDest == hdcSrc || hdcSrc == NULL)
    {
        aw[0] = (WORD)LOWORD(rop);
        aw[1] = (WORD)HIWORD(rop);
        aw[2] = (WORD)ySrc;
        aw[3] = (WORD)xSrc;
        aw[4] = (WORD)0;            // No DC necessary
        aw[5] = (WORD)nHeight;
        aw[6] = (WORD)nWidth;
        aw[7] = (WORD)y;
        aw[8] = (WORD)x;

        return(RecordParms(hdcDest, META_DIBBITBLT, 9, aw));
    }
    else
        return(RecordCommonBitBlt(hdcDest,x,y,nWidth,nHeight,hdcSrc,
                xSrc,ySrc,nWidth,nHeight,rop,META_DIBBITBLT));
}

BOOL MF16_StretchBlt(HDC hdcDest, INT x, INT y, INT nWidth, INT nHeight,
        HDC hdcSrc, INT xSrc, INT ySrc, INT nSrcWidth, INT nSrcHeight, DWORD rop)
{
    WORD    aw[11];

// This is how windows works but really it should look at the ROP
    if (hdcDest == hdcSrc || hdcSrc == NULL)
    {
        aw[0]  = (WORD)LOWORD(rop);
        aw[1]  = (WORD)HIWORD(rop);
        aw[2]  = (WORD)nSrcHeight;
        aw[3]  = (WORD)nSrcWidth;
        aw[4]  = (WORD)ySrc;
        aw[5]  = (WORD)xSrc;
        aw[6]  = (WORD)0;            // No DC necessary
        aw[7]  = (WORD)nHeight;
        aw[8]  = (WORD)nWidth;
        aw[9]  = (WORD)y;
        aw[10] = (WORD)x;

        return(RecordParms(hdcDest, META_DIBSTRETCHBLT, 11, aw));
    }
    else
        return(RecordCommonBitBlt(hdcDest,x,y,nWidth,nHeight,hdcSrc,
                xSrc,ySrc,nSrcWidth,nSrcHeight,rop,META_DIBSTRETCHBLT));
}

BOOL RecordCommonBitBlt(HDC hdcDest, INT x, INT y, INT nWidth, INT nHeight,
       HDC hdcSrc, INT xSrc, INT ySrc, INT nSrcWidth, INT nSrcHeight, DWORD rop,
       WORD wFunc)
{
    BOOL        fRet = FALSE;
    HBITMAP     hBitmap;
    LPWORD      lpW;
    LPWORD      lpWStart = (LPWORD) NULL;
    WORD        cwParms;
    BMIH        bmih;
    DWORD       cbBitsInfo;
    DWORD       cbBits;
    PBMIH       lpDIBInfoHeader;

// hdcSrc must be a memory DC.

    if (GetObjectType((HANDLE)hdcSrc) != OBJ_MEMDC)
    {
        ERROR_ASSERT(FALSE, "RecordCommonBitblt hdcSrc must be MEMDC\n");
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Retrieve the source bitmap.

    hBitmap = SelectObject(hdcSrc, GetStockObject(PRIV_STOCK_BITMAP));
    ERROR_ASSERT(hBitmap, "RecordCommonBitblt: SelectObject1 failed\n");

// Get the bitmap info header and sizes.

    if (!bMetaGetDIBInfo(hdcSrc, hBitmap, &bmih,
            &cbBitsInfo, &cbBits, DIB_RGB_COLORS, 0, TRUE))
        goto RecordCommonBitBlt_exit;

// Get the number of parameters to save.

    cwParms = (WORD) ((wFunc == META_DIBSTRETCHBLT) ? 10 : 8);  // in words

// Allocate space for DIB plus parameters.

    lpWStart = lpW = (LPWORD) LocalAlloc(LMEM_FIXED,
                        cbBitsInfo + cbBits + cwParms*sizeof(WORD));
    if (!lpW)
    {
        ERROR_ASSERT(FALSE, "RecordCommonBitblt: out of memory\n");
        goto RecordCommonBitBlt_exit;
    }

// Copy the parameters.

    *lpW++ = (WORD)LOWORD(rop);
    *lpW++ = (WORD)HIWORD(rop);

    if (wFunc == META_DIBSTRETCHBLT)
    {
        *lpW++ = (WORD)nSrcHeight;
        *lpW++ = (WORD)nSrcWidth;
    }

    *lpW++ = (WORD)ySrc;
    *lpW++ = (WORD)xSrc;
    *lpW++ = (WORD)nHeight;
    *lpW++ = (WORD)nWidth;
    *lpW++ = (WORD)y;
    *lpW++ = (WORD)x;

// Save the start of the bitmap info header field.

    lpDIBInfoHeader = (LPBITMAPINFOHEADER) lpW;

// Copy the bitmap info header.

    *lpDIBInfoHeader = bmih;

// Get bitmap info and bits.

    if (!GetDIBits(hdcSrc,
                   hBitmap,
                   0,
                   (UINT) bmih.biHeight,
                   (LPBYTE) ((PBYTE) lpW + cbBitsInfo),
                   (LPBITMAPINFO) lpDIBInfoHeader,
                   DIB_RGB_COLORS))
    {
        ERROR_ASSERT(FALSE, "RecordCommonBitBlt: GetDIBits2 failed\n");
        goto RecordCommonBitBlt_exit;
    }

// Finally record the parameters into the file.

    fRet = RecordParms(hdcDest, wFunc,
                   cwParms + (cbBitsInfo + cbBits) / sizeof(WORD),
                   lpWStart);

RecordCommonBitBlt_exit:

    if (lpWStart)
        if (LocalFree((HANDLE)lpWStart))
            ASSERTGDI(FALSE, "RecordCommonBitBlt: LocalFree Failed\n");

    if (!SelectObject(hdcSrc, hBitmap))
        ASSERTGDI(FALSE, "RecordCommonBitblt: SelectObject2 failed\n");

    return(fRet);
}

BOOL MF16_DeleteRgn(HDC hdc, HANDLE hrgn)
{
    UINT    pos;

    if (AddObjectToDCTable(hdc, hrgn, &pos, FALSE) != 1)
        ASSERTGDI(FALSE, "MF16_DeleteRgn: AddObjectToDCTable failed");

    return(RecordParms(hdc, META_DELETEOBJECT, 1, (LPWORD)&pos));
}

BOOL MF16_DeleteObject(HANDLE hObject)
{
    INT     iCurDC;
    UINT    pos;
    UINT    iObjType;
    PMFRECORDER16   pMFRec;
    PMETALINK16     pml16;

    pml16 = pmetalink16Get(hObject);
    ASSERTGDI(pml16, "MF16_DeleteObject: Metalink is NULL\n");

    iObjType = GetObjectType(hObject);
    ASSERTGDI(iObjType != OBJ_REGION, "MF16_DeleteObject: region unexpected");

// Delete the object from each metafile DC which references it.

    for(iCurDC = pml16->cMetaDC16 - 1; iCurDC >= 0; iCurDC--)
    {
        // Send a DeleteObject record to each metafile

        HDC hdc16 = pml16->ahMetaDC16[iCurDC];

        if (!IS_METADC16_TYPE(hdc16))
        {
            RIP("MF16_DELETEOBJECT: invalid metaDC16\n");
            continue;
        }

        // If the object is not selected then delete it, if it is then mark as predeleted

        GET_PMFRECORDER16(pMFRec,hdc16);

        if (pMFRec->recCurObjects[iObjType - MIN_OBJ_TYPE] != hObject)
        {
            if (AddObjectToDCTable(hdc16, hObject, &pos, FALSE) == 1)
                RecordParms(hdc16, META_DELETEOBJECT, 1, (LPWORD)&pos);
            else
                RIP("MF16_DeleteObject Metalink16 and metadc table not in sync\n");
        }
        else
        {
            if (pMFRec->metaHeader.mtNoObjects)
            {
                UINT    ii;
                POBJECTTABLE   pobjt;

                pobjt = (POBJECTTABLE) pMFRec->hObjectTable;

                for (ii=0; ii < (UINT) pMFRec->metaHeader.mtNoObjects; ii++)
                {
                    if (pobjt[ii].CurHandle == hObject)
                    {
                        pobjt[ii].fPreDeleted = TRUE;
                        break;
                    }
                }
            }
        }
    }

// This Object has been freed from all 3.x metafiles so free its MetaList16
// if the metalink field is in use resize METALINK16

    if (pml16->metalink)
    {
        if (pml16->cMetaDC16 > 1)
            pml16 = pmetalink16Resize(hObject,1);

        if (pml16 == NULL)
        {
            ASSERTGDI(FALSE, "MF16_DeleteObject LocalReAlloc failed\n");
            return (FALSE);
        }

        pml16->cMetaDC16     = 0;
        pml16->ahMetaDC16[0] = (HDC) 0;
    }
    else
    {
        if (!bDeleteMetalink16(hObject))
            ASSERTGDI(FALSE, "MF16_DeleteObject LocalFree failed\n");
    }

    return(TRUE);
}

BOOL MF16_RealizePalette(HDC hdc)
{
    HPALETTE        hpal;
    PMFRECORDER16   pMFRec;
    PMETALINK16     pml16;

    ASSERTGDI(IS_METADC16_TYPE(hdc),"MF16_RealizePalette - invalid handle\n");

    GET_PMFRECORDER16(pMFRec,hdc);

    hpal = pMFRec->recCurObjects[OBJ_PAL - MIN_OBJ_TYPE];
    ASSERTGDI(hpal, "MF16_RealizePalette: bad hpal\n");

// emit the palette again only if the palette is dirty.

    pml16 = pmetalink16Get(hpal);

    ASSERTGDI(IS_STOCKOBJ(hpal) || pml16,"MF16_RealizePalette - pml16 == NULL\n");

    if (pml16)
    {
        if (PtrToUlong(pml16->pv) != pMFRec->iPalVer)
            if (!MakeLogPalette(hdc, hpal, META_SETPALENTRIES))
                return(FALSE);

    // record which version of the palette the metafile is synced to.

        pMFRec->iPalVer = PtrToUlong(pml16->pv);
    }

    return(RecordParms(hdc, META_REALIZEPALETTE, 0, (LPWORD)NULL));
}

BOOL MF16_AnimatePalette
(
    HPALETTE hpal,
    UINT iStart,
    UINT cEntries,
    CONST PALETTEENTRY *pPalEntries
)
{
    INT           iCurDC;
    PMETALINK16   pml16;
    LPWORD        lpW,lpT;
    DWORD         cw;
    UINT          ii;
    PMFRECORDER16 pMFRec;

    if (!(pml16 = pmetalink16Get(hpal)))
        return(FALSE);

    cw  = (cEntries * sizeof(PALETTEENTRY) / sizeof(WORD)) + 2;
    lpT = lpW = (LPWORD) LocalAlloc(LMEM_FIXED, cw * sizeof(WORD));

    if (!lpW)
        return(FALSE);

    *lpW++ = (WORD) iStart;
    *lpW++ = (WORD) cEntries;

    for (ii = 0; ii < cEntries; ii++)
        ((PPALETTEENTRY) lpW)[ii] = pPalEntries[ii];

// Send a AnimatePalette record to each associated metafile that has the
// palette selected.

    for (iCurDC = pml16->cMetaDC16 - 1; iCurDC >= 0; iCurDC--)
    {
        HDC hdc16 = pml16->ahMetaDC16[iCurDC];

        if (!IS_METADC16_TYPE(hdc16))
        {
            ASSERTGDI(FALSE, "MF16_AnimatePalette: invalid metaDC16\n");
            continue;
        }

        GET_PMFRECORDER16(pMFRec,hdc16);
        if (pMFRec->recCurObjects[OBJ_PAL - MIN_OBJ_TYPE] == hpal)
            if (!RecordParms(pml16->ahMetaDC16[iCurDC], META_ANIMATEPALETTE, cw, lpT))
                ASSERTGDI(FALSE, "MF16_AnimatePalette: RecordParms Failed\n");
    }

    if (LocalFree((HANDLE) lpT))
        ASSERTGDI(FALSE, "MF16_AnimatePalette: LocalFree Failed\n");

    return(TRUE);
}

BOOL MF16_ResizePalette(HPALETTE hpal, UINT nCount)
{
    INT           iCurDC;
    PMETALINK16   pml16;
    PMFRECORDER16 pMFRec;

    if (!(pml16 = pmetalink16Get(hpal)))
        return(FALSE);

// Send a ResizePalette record to each associated metafile that has the
// palette selected.

    for (iCurDC = pml16->cMetaDC16 - 1; iCurDC >= 0; iCurDC--)
    {
        HDC hdc16 = pml16->ahMetaDC16[iCurDC];

        if (!IS_METADC16_TYPE(hdc16))
        {
            ASSERTGDI(FALSE, "MF16_ResizePalette: invalid metaDC16\n");
            continue;
        }

        GET_PMFRECORDER16(pMFRec,hdc16);

        if (pMFRec->recCurObjects[OBJ_PAL - MIN_OBJ_TYPE] == hpal)
            if (!RecordParms(pml16->ahMetaDC16[iCurDC], META_RESIZEPALETTE, 1, (LPWORD) &nCount))
                ASSERTGDI(FALSE, "MF16_ResizePalette: RecordParms Failed\n");
    }
    return(TRUE);
}

BOOL MF16_DrawRgn(HDC hdc, HRGN hrgn, HBRUSH hBrush, INT cx, INT cy, WORD Func)
{
    WORD    aw[4];
    BOOL    bRet;

    // Each region function has at least a region to record
    aw[0] = (WORD)RecordObject(hdc, hrgn);

    switch(Func)
    {
    case META_PAINTREGION:
    case META_INVERTREGION:
        bRet = RecordParms(hdc, Func, 1, aw);
        break;

    case META_FILLREGION:
        aw[1] = (WORD)RecordObject(hdc, hBrush);
        bRet = RecordParms(hdc, Func, 2, aw);
        break;

    case META_FRAMEREGION:
        aw[1] = (WORD)RecordObject(hdc, hBrush);
        aw[2] = (WORD)cy;
        aw[3] = (WORD)cx;
        bRet = RecordParms(hdc, Func, 4, aw);
        break;

    default:
        ASSERTGDI(FALSE, "MF16_DrawRgn: Bad Func\n");
        bRet = FALSE;
        break;
    }

// Delete the metafile region handle in the metafile after use!
// The reason is that a region can be modified (e.g. SetRectRgn)
// between each use and we have to re-record it each time it is used
// unless we use a dirty flag.

    if (!MF16_DeleteRgn(hdc, hrgn))
        ASSERTGDI(FALSE, "MF16_DrawRgn: MF16_DeleteRgn failed\n");

    return(bRet);
}

BOOL MF16_PolyPolygon(HDC hdc, CONST POINT *lpPoint, CONST INT *lpPolyCount, INT nCount)
{
    BOOL        fRet;
    LPWORD      lpW,lpT;
    DWORD       cw;
    INT         cPt = 0;
    INT         ii;

    for(ii=0; ii<nCount; ii++)
        cPt += lpPolyCount[ii];

    cw = 1+nCount+(cPt*sizeof(POINTS)/sizeof(WORD));
    lpT = lpW = (LPWORD)LocalAlloc(LMEM_FIXED, cw*sizeof(WORD));
    if (!lpW)
        return(FALSE);

    // first is the count
    *lpW++ = (WORD)nCount;

    // second is the list of poly counts
    for(ii=0; ii<nCount; ii++)
        *lpW++ = (WORD)lpPolyCount[ii];

    // third is the list of points
    for(ii=0; ii<cPt; ii++)
    {
        *lpW++ = (WORD)lpPoint[ii].x;
        *lpW++ = (WORD)lpPoint[ii].y;
    }

    fRet = RecordParms(hdc, META_POLYPOLYGON, cw, lpT);

    if(LocalFree((HANDLE)lpT))
        ASSERTGDI(FALSE, "MF16_PolyPolygon: LocalFree Failed\n");

    return (fRet);
}

BOOL MF16_SelectClipRgn(HDC hdc, HRGN hrgn, int iMode)
{
    PMFRECORDER16 pMFRec;

    if (!IS_METADC16_TYPE(hdc))
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    PUTS("MF16_SelectClipRgn\n");

    GET_PMFRECORDER16(pMFRec,hdc);

    if (iMode != RGN_COPY)
        return(FALSE);

// We will emit SelectObject record for clip region just like Windows.
// However, a null region cannot be recorded in the SelectObject call since
// the handle does not identify the object type.  This is a bug in Win 3.1!
//
// BUG 8419 winproj 4 has a bug where it counts on this bug.  Chicago
// also has this bug so we will have this bug.

    if (hrgn == (HRGN) 0)
    {
#ifdef RECORD_SELECTCLIPRGN_NULL
        BOOL    fRet;

        fRet = MF16_RecordParms2(hdc, 0, META_SELECTCLIPREGION);

        // maintain the new selection in the CurObject table

        pMFRec->recCurObjects[OBJ_REGION - MIN_OBJ_TYPE] = 0;

        return(fRet);
#else
        return TRUE;
#endif
    }
    else
        return(MF16_SelectObject(hdc, hrgn) ? TRUE : FALSE);
}

// SelectObject returns previous object! - new in win3.1

HANDLE MF16_SelectObject(HDC hdc, HANDLE h)
{
    HANDLE        hOldObject;
    WORD          position;
    PMFRECORDER16 pMFRec;
    UINT          iType;


    PUTS("MF16_SelectObject\n");

    GET_PMFRECORDER16(pMFRec,hdc);

    if (!IS_METADC16_TYPE(hdc) || !pMFRec)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(0);
    }

    iType = GetObjectType(h);

    if ((iType == 0) || !h || (position = (WORD) RecordObject(hdc, h)) == (WORD) -1)
        return((HANDLE) 0);
    else
    {
        if (!RecordParms(hdc, META_SELECTOBJECT, 1, &position))
            return((HANDLE) 0);

        // maintain the new selection in the CurObject table

        ASSERTGDI(iType <= MAX_OBJ_TYPE && iType >= MIN_OBJ_TYPE,
            "MF16_SelectObject type > max\n");

        hOldObject = pMFRec->recCurObjects[iType - MIN_OBJ_TYPE];
        pMFRec->recCurObjects[iType - MIN_OBJ_TYPE] = h;

        // return the previously selected object or 1 if it is a region
        // (for compatibility) - new in win3.1

        if (iType == OBJ_REGION)
        {
            // We also delete the region handle here!
            // The reason is that a region can be modified (e.g. SetRectRgn)
            // between each use and we have to re-record it each time it is used
            // unless we use a dirty flag.  This is a bug in win3.1

            return(MF16_DeleteRgn(hdc, h) ? (HANDLE) 1 : (HANDLE) 0);
        }
        else
        {
            return(hOldObject);
        }
    }
}

BOOL MF16_SelectPalette(HDC hdc, HPALETTE hpal)
{
    WORD          position;
    PMFRECORDER16 pMFRec;

    GET_PMFRECORDER16(pMFRec,hdc);

    if (!IS_METADC16_TYPE(hdc) || !pMFRec)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(0);
    }

    if (!hpal || (position = (WORD) RecordObject(hdc, (HANDLE) hpal)) == (WORD) -1)
        return(FALSE);
    else
    {
        PMETALINK16 pml16;

        if (!RecordParms(hdc, META_SELECTPALETTE, 1, &position))
            return(FALSE);

        // maintain the new selection in the CurObject table
        pMFRec->recCurObjects[OBJ_PAL - MIN_OBJ_TYPE] = hpal;

        // Also record which version of the palette we are synced with
        // so we know whether to emit a new palette when RealizePalette
        // is called

        pml16 = pmetalink16Get(hpal);
        ASSERTGDI(IS_STOCKOBJ(hpal) || pml16,"MF16_RealizePalette - pml16 == NULL\n");

        if (pml16)
           pMFRec->iPalVer = PtrToUlong(pml16->pv);

        return(TRUE);
    }
}

BOOL MF16_TextOut(HDC hdc, INT x, INT y, LPCSTR lpString, INT nCount, BOOL bUnicode)
{
    BOOL    fRet;
    LPWORD  lpw, lpT;
    DWORD   cw;

    cw  = (nCount + 1)/sizeof(WORD) + 3;     // word-aligned character string
    lpT = lpw = (LPWORD) LocalAlloc(LMEM_FIXED, cw*sizeof(WORD));

    if (!lpw)
        return(FALSE);

    *lpw++ = (WORD)nCount;

    // Copy the string

    if (!bUnicode)
    {
        RtlCopyMemory(lpw, lpString, nCount);
    }
    else
    {
        (void) bToASCII_N((LPSTR) lpw, nCount, (LPWSTR) lpString, nCount);
    }

    lpw += (nCount+1)/sizeof(WORD);   // keep word aligned

    *lpw++ = (WORD)y;
    *lpw++ = (WORD)x;

    fRet = RecordParms(hdc, META_TEXTOUT, cw, lpT);

    if(LocalFree((HANDLE)lpT))
        ASSERTGDI(FALSE, "MF16_TextOut: LocalFree Failed\n");
    return (fRet);
}

BOOL MF16_PolyTextOut(HDC hdc, CONST POLYTEXTA *ppta, int cpta, BOOL bUnicode)
{
    int     i;

    for (i = 0; i < cpta; i++)
    {
        if (!MF16_ExtTextOut(hdc, ppta[i].x, ppta[i].y, ppta[i].uiFlags,
                        &ppta[i].rcl, (LPCSTR) ppta[i].lpstr, (INT) ppta[i].n,
                        (LPINT) ppta[i].pdx, bUnicode))
            return(FALSE);
    }

    return(TRUE);
}

BOOL MF16_ExtTextOut(HDC hdc, INT x, INT y, UINT flOptions, CONST RECT *lpRect,
    LPCSTR lpString, INT nCount, CONST INT *lpDX, BOOL bUnicode)
{
    BOOL    fRet;
    LPWORD  lpw, lpT;
    DWORD cw = 0;
    INT nUnicodeCount = nCount;
    char *pjAnsiString = NULL;

    if(bUnicode)
    {
    // compute the real count of characters in the string

        RtlUnicodeToMultiByteSize((PULONG) &nCount, (PWCH) lpString,
                                  nCount * sizeof(WCHAR));
    }

    // Compute buffer space needed
    //   room for the char string
    //   room for the 4 words that are the fixed parms
    //   if there is a dx array, we need room for it
    //   if the rectangle is being used, we need room for it
    //   and we need extra byte for eventual word roundoff
    //

    if (flOptions & ETO_PDY)
        return FALSE;

    cw += (lpDX) ? nCount : 0;       // DX array
    cw += (flOptions & (ETO_OPAQUE | ETO_CLIPPED)) ? 4 : 0;  // sizeof RECTS
    cw += 4;  // x,y,options and count
    cw += (nCount + 1)/sizeof(WORD);

    lpT = lpw = (LPWORD) LocalAlloc(LMEM_FIXED, cw*sizeof(WORD));
    if (!lpw)
        return(FALSE);

    *lpw++ = (WORD)y;
    *lpw++ = (WORD)x;
    *lpw++ = (WORD)nCount;
    *lpw++ = (WORD)flOptions;

    // Copy the rect if present
    if (flOptions & (ETO_OPAQUE | ETO_CLIPPED))
    {
        ERROR_ASSERT(lpRect, "MF16_ExtTextOut: expect valid lpRect\n");
        *lpw++ = (WORD)lpRect->left;
        *lpw++ = (WORD)lpRect->top;
        *lpw++ = (WORD)lpRect->right;
        *lpw++ = (WORD)lpRect->bottom;
    }

    // Copy the string
    if (!bUnicode)
    {
        RtlCopyMemory(lpw, lpString, nCount);
    }
    else
    {
        (void) bToASCII_N((LPSTR) lpw, nCount, (LPWSTR) lpString, nUnicodeCount);
        pjAnsiString = (char*) lpw;
    }

    lpw += (nCount+1)/sizeof(WORD);   // keep word aligned

    if (lpDX)
    {
        INT ii;

        if(nCount != nUnicodeCount)
        {
            INT jj;

            for(ii=0,jj=0; ii < nCount; ii++,jj++)
            {
                *lpw++ = (WORD)lpDX[jj];

                if(IsDBCSLeadByte(pjAnsiString[ii]))
                {
                    *lpw++ = 0;
                    ii++;
                }
            }
        }
        else
        {
            for(ii=0; ii<nCount; ii++)
              *lpw++ = (WORD)lpDX[ii];
        }

    }

    fRet = RecordParms(hdc, META_EXTTEXTOUT, cw, lpT);

    if (LocalFree((HANDLE)lpT))
        ASSERTGDI(FALSE, "MF16_ExtTextOut: LocalFree Failed\n");

    return (fRet);
}

BOOL MF16_Escape(HDC hdc, int nEscape, int nCount, LPCSTR lpInData, LPVOID lpOutData)
{
    BOOL        fRet;
    LPWORD      lpW,lpT;
    DWORD       cw;

// If a metafile is retrieved from GetWinMetaFileBits, it may contain
// an embedded enhanced metafile.  Do not include the enhanced metafile
// if we are playing the metafile to another metafile.

    if (nEscape == MFCOMMENT
     && nCount > sizeof(META_ESCAPE_ENHANCED_METAFILE) - sizeof(DWORD) - 3 * sizeof(WORD)
     && ((DWORD UNALIGNED *) lpInData)[0] == MFCOMMENT_IDENTIFIER
     && ((DWORD UNALIGNED *) lpInData)[1] == MFCOMMENT_ENHANCED_METAFILE)
    {
        return(TRUE);
    }

// Some wow apps (e.g. amipro) use metafiles for printing.  As a result,
// we need to record these printing escapes.

    cw = 2 + ((nCount + 1) / sizeof(WORD));
    lpT = lpW = (LPWORD) LocalAlloc(LMEM_FIXED, cw * sizeof(WORD));
    if (!lpW)
        return(FALSE);

    *lpW++ = (WORD) nEscape;    // escape number
    *lpW++ = (WORD) nCount;     // count of input data buffer

    RtlCopyMemory(lpW, lpInData, nCount);

    fRet = RecordParms(hdc, META_ESCAPE, cw, lpT);

    if (LocalFree((HANDLE) lpT))
        ASSERTGDI(FALSE, "MF16_Escape: LocalFree Failed\n");

    return(fRet);
}

/****************************************************************************
*                                                                           *
* RecordParms                                                               *
*                                                                           *
* Parameters: 1.hMF handle to a metafile header.                            *
*             2.The magic number of the function being recorded.            *
*             3.The number of parmmeter of the function (size of lpParm     *
*                 in words)                                                 *
*             4.A long pointer to parameters stored in reverse order        *
*                                                                           *
* Warning call only once per function because max record is updated.        *
*                                                                           *
****************************************************************************/

BOOL RecordParms(HDC hdc, DWORD magic, DWORD cw, CONST WORD *lpParm)
{
    PMFRECORDER16 pMFRec;
    METARECORD    MFRecord;

    PUTSX("RecordParms %lX\n", (ULONG)magic);
    ASSERTGDI(HIWORD(magic) == 0, "RecordParms: bad magic\n");

    GET_PMFRECORDER16(pMFRec,hdc);

    if (!IS_METADC16_TYPE(hdc) || !pMFRec)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Make sure the Metafile hasn't died before we continue

    if (!(pMFRec->recFlags & METAFILEFAILURE))
    {
        MFRecord.rdSize     = SIZEOF_METARECORDHEADER/sizeof(WORD) + cw;
        MFRecord.rdFunction = (WORD)magic;

        // Write the header

        if (!AttemptWrite(pMFRec, SIZEOF_METARECORDHEADER, (LPBYTE)&MFRecord))
            return(FALSE);

        // Write the data

        if (!AttemptWrite(pMFRec, cw*sizeof(WORD), (LPBYTE)lpParm))
            return(FALSE);

        // Update max record size

        if (MFRecord.rdSize > pMFRec->metaHeader.mtMaxRecord)
            pMFRec->metaHeader.mtMaxRecord = MFRecord.rdSize;
    }
    return (TRUE);      // Win 3.1 returns true even if METAFAILEFAILURE is on!
}

/***************************** Internal Function ***************************\
* AttemptWrite
*
* Tries to write data to a metafile disk file
*
* dwBytes is the byte count of lpData.
*
* Returns TRUE iff the write was sucessful
*
*
\***************************************************************************/

BOOL AttemptWrite(PMFRECORDER16 pMFRec, DWORD dwBytes, LPBYTE lpData)
{
    DWORD cbWritten;
    BOOL  fRet;

    PUTS("AttemptWrite\n");

    ASSERTGDI(dwBytes % 2 == 0, "AttemptWrite: bad dwBytes\n"); // must be even
    ASSERTGDI(!(pMFRec->recFlags & METAFILEFAILURE),
        "AttemptWrite: Bad recording\n");

// Handle disk file.

    if (pMFRec->metaHeader.mtType == DISKMETAFILE)
    {
        // Flush the buffer if it's not large enough.

        if (dwBytes + pMFRec->ibBuffer > pMFRec->cbBuffer)
        {
            fRet = WriteFile(pMFRec->hFile, (LPBYTE)pMFRec->hMem,
                    pMFRec->ibBuffer, &cbWritten, (LPOVERLAPPED)NULL);
            if (!fRet || (cbWritten != pMFRec->ibBuffer))
            {
                ERROR_ASSERT(FALSE, "AttemptWrite: Write1 failed\n");
                goto AttemptWrite_Error;
            }
            pMFRec->ibBuffer = 0;       // reset buffer info
        }

        // If the data is still too large, write it out to disk directly.

        if (dwBytes + pMFRec->ibBuffer > pMFRec->cbBuffer)
        {
            fRet = WriteFile(pMFRec->hFile, lpData,
                    dwBytes, &cbWritten, (LPOVERLAPPED)NULL);
            if (!fRet || (cbWritten != dwBytes))
            {
                ERROR_ASSERT(FALSE, "AttemptWrite: Write2 failed\n");
                goto AttemptWrite_Error;
            }
        }
        else
        {
            // Store data in the buffer.

            RtlCopyMemory((LPBYTE)pMFRec->hMem + pMFRec->ibBuffer, lpData, dwBytes);
            pMFRec->ibBuffer += dwBytes;
        }
    }
    else
    {
    // Handle memory file.

        // Grow the buffer if necessary.

        if (dwBytes + pMFRec->ibBuffer > pMFRec->cbBuffer)
        {
            DWORD   cbNewSize;
            HANDLE  hMem;

            cbNewSize = pMFRec->cbBuffer + MF16_BUFSIZE_INC
                            + dwBytes / MF16_BUFSIZE_INC * MF16_BUFSIZE_INC;

            hMem = LocalReAlloc(pMFRec->hMem, cbNewSize, LMEM_MOVEABLE);
            if (hMem == NULL)
            {
                ERROR_ASSERT(FALSE, "AttemptWrite: out of memory\n");
                goto AttemptWrite_Error;
            }
            pMFRec->hMem = hMem;
            pMFRec->cbBuffer = cbNewSize;
        }

        // Record the data.

        RtlCopyMemory((LPBYTE)pMFRec->hMem + pMFRec->ibBuffer, lpData, dwBytes);
        pMFRec->ibBuffer += dwBytes;
    }

    // Update the header size.

    pMFRec->metaHeader.mtSize += dwBytes/sizeof(WORD);

    return(TRUE);

AttemptWrite_Error:

    MarkMetaFile(pMFRec);
    return(FALSE);
}


/***************************** Internal Function ***************************\
* VOID MarkMetaFile
*
* Marks a metafile as failed
*
* Effects:
*   Frees the metafile resources
*
\***************************************************************************/

VOID MarkMetaFile(PMFRECORDER16 pMFRec)
{
// Clean up is done in CloseMetaFile.

    PUTS("MarkMetaFile\n");

    pMFRec->recFlags |= METAFILEFAILURE;
}

/***************************** Internal Function **************************\
* MakeLogPalette
*
* Records either CreatePalette or SetPaletteEntries
*
* Returns TRUE iff sucessful
*
*
\***************************************************************************/

BOOL MakeLogPalette(HDC hdc, HANDLE hPal, WORD magic)
{
    WORD        cPalEntries;
    BOOL        fStatus = FALSE;
    DWORD       cbPalette;
    LPLOGPALETTE lpPalette;

    PUTS("MakeLogPalette\n");

    if (!GetObject(hPal, sizeof(WORD), &cPalEntries))
    {
        ERROR_ASSERT(FALSE, "MakeLogPalette: GetObject Failed\n");
        return(fStatus);
    }

// alloc memory and get the palette entries

    if (lpPalette = (LPLOGPALETTE)LocalAlloc(LMEM_FIXED,
            cbPalette = sizeof(LOGPALETTE)-sizeof(PALETTEENTRY)+sizeof(PALETTEENTRY)*cPalEntries))
    {
        lpPalette->palNumEntries = cPalEntries;

        GetPaletteEntries(hPal, 0, cPalEntries, lpPalette->palPalEntry);

        if (magic == (META_CREATEPALETTE & 255))
        {
            lpPalette->palVersion = 0x300;
            magic = META_CREATEPALETTE;
        }
        else if (magic == (META_SETPALENTRIES & 255))
        {
            lpPalette->palVersion = 0;   /* really "starting index" */
            magic = META_SETPALENTRIES;
        }

        fStatus = RecordParms(hdc, magic, (DWORD)cbPalette >> 1, (LPWORD)lpPalette);

        if (LocalFree((HANDLE)lpPalette))
            ASSERTGDI(FALSE, "MakeLogPalette: LocalFree Failed\n");
    }

    return(fStatus);
}


/***************************** Internal Function ***************************\
* RecordObject
*
* Records the use of an object by creating the object
*
* Returns: index of object in table
*          -1 if error
*
\***************************************************************************/

WIN3REGION w3rgnEmpty =
{
    0,              // nextInChain
    6,              // ObjType
    0x2F6,          // ObjCount
    sizeof(WIN3REGION) - sizeof(SCAN) + 2,
                    // cbRegion
    0,              // cScans
    0,              // maxScan
    {0,0,0,0},      // rcBounding
    {0,0,0,{0,0},0} // aScans[]
};

WORD RecordObject(HDC hdc, HANDLE hObject)
{
    UINT        status;
    UINT        iPosition;
    HDC         hdcScreen = (HDC) 0;
    int         iType;
    UINT    iUsage;

    PUTS("RecordObject\n");

// Validate the object.

    iType = LO_TYPE(hObject);

    if (iType != LO_PEN_TYPE &&
        iType != LO_BRUSH_TYPE &&
        iType != LO_FONT_TYPE &&
        iType != LO_REGION_TYPE &&
        iType != LO_PALETTE_TYPE
        )
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return((WORD) -1);
    }

// Add the object to the metafiles list.

    status = AddObjectToDCTable(hdc, hObject, &iPosition, TRUE);

// An error occurred.

    if (status == (UINT) -1)
        return((WORD) -1);

// Object already exists.

    if (status == 1)
        return((WORD) iPosition);

    ASSERTGDI(!status, "RecordObject: Bad return code from AddObjectToDCTable\n");

// Object does not exist, record it.

    if (iType != LO_REGION_TYPE)       // don't add regions to the metalist!
        if (!AddDCToObjectMetaList16(hdc,hObject))
            return((WORD) -1);

    switch (iType)
    {
    case LO_PEN_TYPE:
    {
        LOGPEN16 logpen16;

        GetObject16AndType(hObject, (LPVOID)&logpen16);
        status = (UINT) RecordParms(hdc, (WORD)META_CREATEPENINDIRECT,
                          (DWORD)((sizeof(LOGPEN16) + 1) >> 1),
                          (LPWORD)&logpen16);
        break;
    }

    case LO_FONT_TYPE:
    {
        LOGFONT16 logfont16;

        GetObject16AndType(hObject, (LPVOID)&logfont16);

        /* size of LOGFONT adjusted based on the length of the facename */
        status = (UINT) RecordParms(hdc, META_CREATEFONTINDIRECT,
                          (DWORD)((sizeof(LOGFONT16) + 1) >> 1),
                          (LPWORD) &logfont16);
        break;
    }

    /*
     * in win2, METACREATEREGION records contained an entire region object,
     * including the full header.  this header changed in win3.
     *
     * to remain compatible, the region records will be saved with the
     * win2 header.  here we save our region with a win2 header.
     */
    case LO_REGION_TYPE:
    {
        PWIN3REGION lpw3rgn;
        DWORD       cbNTRgnData;
        DWORD       curRectl;
        WORD        cScans;
        WORD        maxScanEntry;
        WORD        curScanEntry;
        DWORD       cbw3data;
        PRGNDATA    lprgn;
        LPRECT      lprc;
        PSCAN       lpScan;

        ASSERTGDI(!status, "RecordObject: bad status\n");

        // Get the NT Region Data
        cbNTRgnData = GetRegionData(hObject, 0, NULL);
        if (cbNTRgnData == 0)
            break;

        lprgn = (PRGNDATA) LocalAlloc(LMEM_FIXED, cbNTRgnData);
        if (!lprgn)
            break;

        cbNTRgnData = GetRegionData(hObject, cbNTRgnData, lprgn);
        if (cbNTRgnData == 0)
        {
            LocalFree((HANDLE) lprgn);
            break;
        }

        // Handle the empty region.

        if (!lprgn->rdh.nCount)
        {
            status = (UINT) RecordParms(hdc, META_CREATEREGION,
                        (sizeof(WIN3REGION) - sizeof(SCAN)) >> 1,  // Convert to count of words
                        (LPWORD) &w3rgnEmpty);

            LocalFree((HANDLE)lprgn);
            break;
        }

        lprc = (LPRECT)lprgn->Buffer;

        // Create the Windows 3.x equivalent

        // worst case is one scan for each rect
        cbw3data = 2*sizeof(WIN3REGION) + (WORD)lprgn->rdh.nCount*sizeof(SCAN);

        lpw3rgn = (PWIN3REGION)LocalAlloc(LMEM_FIXED, cbw3data);
        if (!lpw3rgn)
        {
            LocalFree((HANDLE) lprgn);
            break;
        }

        // Grab the bounding rect.
        lpw3rgn->rcBounding.left   = (SHORT)lprgn->rdh.rcBound.left;
        lpw3rgn->rcBounding.right  = (SHORT)lprgn->rdh.rcBound.right;
        lpw3rgn->rcBounding.top    = (SHORT)lprgn->rdh.rcBound.top;
        lpw3rgn->rcBounding.bottom = (SHORT)lprgn->rdh.rcBound.bottom;

        cbw3data = sizeof(WIN3REGION) - sizeof(SCAN) + 2;

        // visit all the rects
        curRectl     = 0;
        cScans       = 0;
        maxScanEntry = 0;
        lpScan       = lpw3rgn->aScans;

        while(curRectl < lprgn->rdh.nCount)
        {
            LPWORD  lpXEntry;
            DWORD   cbScan;

            curScanEntry = 0;       // Current X pair in this scan

            lpScan->scnPntTop    = (WORD)lprc[curRectl].top;
            lpScan->scnPntBottom = (WORD)lprc[curRectl].bottom;

            lpXEntry = (LPWORD) lpScan->scnPntsX;

            // handle rects on this scan
            do
            {
                lpXEntry[curScanEntry + 0] = (WORD)lprc[curRectl].left;
                lpXEntry[curScanEntry + 1] = (WORD)lprc[curRectl].right;
                curScanEntry += 2;
                curRectl++;
            } while ((curRectl < lprgn->rdh.nCount)
                    && (lprc[curRectl-1].top    == lprc[curRectl].top)
                    && (lprc[curRectl-1].bottom == lprc[curRectl].bottom)
                   );

            lpScan->scnPntCnt      = curScanEntry;
            lpXEntry[curScanEntry] = curScanEntry;  // Count also follows Xs
            cScans++;

            if (curScanEntry > maxScanEntry)
                maxScanEntry = curScanEntry;

            // account for each new scan + each X1 X2 Entry but the first
            cbScan = sizeof(SCAN)-(sizeof(WORD)*2) + (curScanEntry*sizeof(WORD));
            cbw3data += cbScan;
            lpScan = (PSCAN)(((LPBYTE)lpScan) + cbScan);
        }

        // Initialize the header
        lpw3rgn->nextInChain = 0;
        lpw3rgn->ObjType = 6;           // old Windows OBJ_RGN identifier
        lpw3rgn->ObjCount= 0x2F6;       // any non-zero number
        lpw3rgn->cbRegion = (WORD)cbw3data;   // don't count type and next
        lpw3rgn->cScans = cScans;
        lpw3rgn->maxScan = maxScanEntry;

        status = (UINT) RecordParms(hdc, META_CREATEREGION,
                (cbw3data-2) >> 1,  // Convert to count of words
                (LPWORD) lpw3rgn);

        if (LocalFree((HANDLE)lprgn))
            ASSERTGDI(FALSE, "RecordObject: LocalFree(lprgn) Failed\n");
        if (LocalFree((HANDLE)lpw3rgn))
            ASSERTGDI(FALSE, "RecordObject: LocalFree(lpw3rgn) Failed\n");

        break;
    }

    case LO_BRUSH_TYPE:
    {
        LOGBRUSH  lb;

        if (!GetObjectA(hObject, sizeof(LOGBRUSH), &lb))
            break;

        switch (lb.lbStyle)
        {
        case BS_HATCHED:
        case BS_HOLLOW:
        case BS_SOLID:
            {
            LOGBRUSH16 lb16;

            LOGBRUSH16FROMLOGBRUSH32(&lb16, &lb);

            // non-pattern brush
            status = (UINT) RecordParms(hdc, META_CREATEBRUSHINDIRECT,
                              (DWORD) ((sizeof(LOGBRUSH16) + 1) >> 1),
                              (LPWORD) &lb16);
            break;
            }

        case BS_PATTERN:
        case BS_DIBPATTERN:
        case BS_DIBPATTERNPT:
            {
            HBITMAP hbmRemote;
            BMIH    bmih;
            DWORD   cbBitsInfo;
            DWORD   cbBits;
            LPWORD  lpWStart, lpW;
            DWORD   lbStyle = BS_DIBPATTERN;
            PBMIH   lpDIBInfoHeader;

            if (!(hbmRemote = GetObjectBitmapHandle((HBRUSH) hObject, &iUsage)))
            {
                ASSERTGDI(FALSE, "RecordObject: GetObjectBitmapHandle failed");
                break;
            }

            // For a pattern brush, if it is color, it is recorded as a
            // DIB pattern brush with BS_DIBPATTERN style.  If it is
            // monochrome, it is recorded as a DIB pattern brush with
            // BS_PATTERN style.  The playback code has a special
            // case to deal with monochrome brushes.

            if (lb.lbStyle == BS_PATTERN)
            {
                iUsage     = DIB_RGB_COLORS;
                if (MonoBitmap(hbmRemote))
                    lbStyle = BS_PATTERN;
            }

            hdcScreen = CreateCompatibleDC((HDC) 0);        // freed below

            // Get the bitmap info header and sizes.

            if (!bMetaGetDIBInfo(hdcScreen, hbmRemote, &bmih,
                    &cbBitsInfo, &cbBits, iUsage, 0, TRUE))
                break;

            // Make sure that cbBitsInfo is dword aligned

            // If we have converted the bitmap format in bMetaGetDIBInfo,
            // modify the iUsage to match the new format.

            if (bmih.biBitCount == 24)
                iUsage = DIB_RGB_COLORS;

            // Allocate space for DIB plus parameters.

            lpWStart = lpW = (LPWORD) LocalAlloc(LMEM_FIXED,
                                cbBitsInfo + cbBits + 2*sizeof(WORD));
            if (!lpW)
            {
                ERROR_ASSERT(FALSE, "RecordObject: out of memory\n");
                break;
            }

            *lpW++ = (WORD) lbStyle;        // BS_PATTERN or BS_DIBPATTERN
            *lpW++ = (WORD) iUsage;         // usage word

            // Save the start of the bitmap info header field.

            lpDIBInfoHeader = (LPBITMAPINFOHEADER) lpW;

            // Copy the bitmap info header.

            *lpDIBInfoHeader = bmih;

            // Get bitmap info and bits.

            if (GetBrushBits(hdcScreen,
                        hbmRemote,
                        (UINT) iUsage,
                        cbBitsInfo,
                        (LPVOID) ((PBYTE) lpW + cbBitsInfo),
                        (LPBITMAPINFO) lpDIBInfoHeader))
            {
            // Finally record the parameters into the file.

                status = (UINT) RecordParms(hdc, META_DIBCREATEPATTERNBRUSH,
                               2 + (cbBitsInfo + cbBits) / sizeof(WORD),
                               (LPWORD) lpWStart);
            }

            if (LocalFree((HANDLE) lpWStart))
                ASSERTGDI(FALSE, "RecordObject: LocalFree Failed\n");

            break;
            }

        default:
            {
            ASSERTGDI(FALSE, "RecordObject: Bad brush style");
            break;
            }
        }   // switch(lb.lbStyle)
        break;
    }   // case LO_BRUSH

    case LO_PALETTE_TYPE:
        status = (UINT) MakeLogPalette(hdc, hObject, META_CREATEPALETTE);
        break;

    default:
        ERROR_ASSERT(FALSE, "unknown case RecordObject");
        break;
    }

// Free the DC created in the brush case.

    if (hdcScreen)
        if (!DeleteDC(hdcScreen))
            ASSERTGDI(FALSE, "RecordObject: DeleteDC Failed\n");

    ASSERTGDI(status == TRUE, "RecordObject: Failing\n");
    return ((WORD) (status == TRUE ? iPosition : -1));
} /* RecordObject */


BOOL AddDCToObjectMetaList16(HDC hMetaDC16, HANDLE hObject)
{
    ULONG   cMetaDC16New;
    PMETALINK16 pml16;

    ASSERTGDI(LO_TYPE(hObject) != LO_REGION_TYPE,
        "AddDCToObjectMetaList16: unexpected region object");

// If the object is a stock object there is no work to do

    if (IS_STOCKOBJ(hObject))
        return(TRUE);

// If the Object's MetaList16 is NULL create allocate one

    pml16 = pmetalink16Get(hObject);

    if (!pml16)
    {
        ENTERCRITICALSECTION(&semLocal);
        pml16 = pmetalink16Create(hObject);
        LEAVECRITICALSECTION(&semLocal);

        if (pml16)
        {
            pml16->metalink = 0;
            pml16->cMetaDC16 = 1;
            pml16->ahMetaDC16[0] = hMetaDC16;
        }
        else
        {
            ASSERTGDI(FALSE, "AddDCToObjectMetaList16: Out of Memory 1");
            return(FALSE);
        }
    }
    else
    {
        int cj;

        cMetaDC16New = pml16->cMetaDC16 + 1;

        if (pml16 = pmetalink16Resize(hObject,cMetaDC16New))
        {
            pml16->ahMetaDC16[pml16->cMetaDC16++] = hMetaDC16;
        }
        else
        {
            ASSERTGDI(FALSE, "AddDCToObjectMetaList16: Out of Memory 2");
            return(FALSE);
        }
    }

    return(TRUE);
}

/***************************** Internal Function ***************************\
* AddObjectToDCTable
*
* Add an object (brush, pen...) to a list of objects associated with the
* metafile.
*
*
*
* Returns: 1 if object is already in table
*          0 if object was just added to table
*          -1 if failure
*
* Remarks
*   bAdd is TRUE iff the object is being added otherwise it is being deleted
*
\***************************************************************************/

UINT AddObjectToDCTable(HDC hdc, HANDLE hObject, PUINT pPosition, BOOL bAdd)
{
    UINT            iEmptySpace = (UINT) -1;
    UINT            i;
    UINT            status = (UINT) -1;
    POBJECTTABLE    pHandleTable;
    PMFRECORDER16   pMFRec;

    PUTS("AddObjectToDCTable\n");

    GET_PMFRECORDER16(pMFRec,hdc);

    if (!IS_METADC16_TYPE(hdc) || !pMFRec)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return((UINT)-1);
    }

// if the Object table already exists search it for the object

    if (pHandleTable = (POBJECTTABLE)pMFRec->hObjectTable)
    {
        for (i=0; i < (UINT) pMFRec->metaHeader.mtNoObjects; ++i)
        {
            if (hObject == pHandleTable[i].CurHandle)
            {
                *pPosition = i;
                status = 1;             // the object exists in the table

                // if we are doing a METADELETEOBJECT.
                //  delete object from table

                if (!bAdd)
                {
                    pHandleTable[i].fPreDeleted = FALSE;
                    pHandleTable[i].CurHandle = (HANDLE)NULL;
                }
                goto AddObjectToTable10;
            }
            else if ((pHandleTable[i].CurHandle == 0) && (iEmptySpace == (UINT) -1))
            {
                // if the entry has been deleted, we want to add a new object
                // in its place.  iEmptySpace will tell us where that place is.

                iEmptySpace = i;
            }
        } // for
    }

    if (bAdd)
    {
        // If there is no object table for this MetaFile then Allocate one.

        if (pHandleTable == (POBJECTTABLE)NULL)
        {
            pHandleTable = (POBJECTTABLE) LocalAlloc(LMEM_FIXED, sizeof(OBJECTTABLE));
            pMFRec->hObjectTable = (HANDLE) pHandleTable;
        }
        else if (iEmptySpace == (UINT) -1)
        {
            pHandleTable = (POBJECTTABLE) LocalReAlloc(pMFRec->hObjectTable,
                    (pMFRec->metaHeader.mtNoObjects + 1) * sizeof(OBJECTTABLE),
                    LMEM_MOVEABLE);
            if (pHandleTable)
                pMFRec->hObjectTable = (HANDLE) pHandleTable;
        }

        if (pHandleTable)
        {
            if (iEmptySpace == (UINT) -1)
                *pPosition = pMFRec->metaHeader.mtNoObjects++;
            else
                *pPosition = iEmptySpace;

            pHandleTable[*pPosition].fPreDeleted = FALSE;
            pHandleTable[*pPosition].CurHandle = hObject;

            status = 0;                 // the object is added to the table
        }
    }
AddObjectToTable10:

    ERROR_ASSERT(status != (UINT) -1, "AddObjectToTable: Failing\n");
    return(status);
}

/***************************** Internal Function **************************\
* HDC WINAPI CreateMetaFileW
*
* Creates a MetaFile DC
*
* The internal format for a MetaFileRecorder has two formats one
* for a memory MetaFile and one for a disk based MetaFile
*
\***************************************************************************/

HDC WINAPI CreateMetaFileA(LPCSTR pszFileName)
{
    UINT  cch;
    WCHAR awch[MAX_PATH];

    if (pszFileName)
    {
        cch = strlen(pszFileName)+1;

        if (cch > MAX_PATH)
        {
            ERROR_ASSERT(FALSE, "CreateMetaFileA filename too long");
            GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
            return((HDC) 0);
        }
        vToUnicodeN(awch, MAX_PATH, pszFileName, cch);

        return (CreateMetaFileW(awch));
    }
    else
        return (CreateMetaFileW((LPWSTR)NULL));
}


HDC WINAPI CreateMetaFileW(LPCWSTR pwszFileName)
{
    PMFRECORDER16   pMFRec;
    HDC             hdc;

    PUTS("CreateMetaFileW\n");

    if (!(pMFRec = (PMFRECORDER16) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                              sizeof(MFRECORDER16))))
        goto CreateMetaFileW_error;

//  pMFRec->ident           = ID_METADC16;
//  pMFRec->hMem            = 0;
    pMFRec->hFile           = INVALID_HANDLE_VALUE;
    pMFRec->cbBuffer        = MF16_BUFSIZE_INIT;
//  pMFRec->ibBuffer        = 0;
    pMFRec->metaHeader.mtHeaderSize   = sizeof(METAHEADER)/sizeof(WORD);
    pMFRec->metaHeader.mtVersion      = METAVERSION300;
//  pMFRec->metaHeader.mtSize         = 0;
//  pMFRec->metaHeader.mtNoObjects    = 0;
//  pMFRec->metaHeader.mtMaxRecord    = 0;
//  pMFRec->metaHeader.mtNoParameters = 0;
//  pMFRec->recFlags        = 0;
//  pMFRec->recCurObjects[] = 0;
    pMFRec->recCurObjects[OBJ_PEN - MIN_OBJ_TYPE]
                                        = GetStockObject(BLACK_PEN);
    pMFRec->recCurObjects[OBJ_BRUSH - MIN_OBJ_TYPE]
                                        = GetStockObject(WHITE_BRUSH);
    pMFRec->recCurObjects[OBJ_FONT - MIN_OBJ_TYPE]
                                        = GetStockObject(DEVICE_DEFAULT_FONT);
    pMFRec->recCurObjects[OBJ_BITMAP - MIN_OBJ_TYPE]
                                        = GetStockObject(PRIV_STOCK_BITMAP);
    pMFRec->recCurObjects[OBJ_REGION - MIN_OBJ_TYPE]
                                        = (HANDLE) NULL;
    pMFRec->recCurObjects[OBJ_PAL - MIN_OBJ_TYPE]
                                        = GetStockObject(DEFAULT_PALETTE);
//  pMFRec->iPalVer         = 0;

// Create a disk file if given.  The filename is given in unicode.

    if (pwszFileName)
    {
        LPWSTR  pwszFilePart;           // not used
        DWORD   cPathname;

        // Convert the filename to a fully qualified pathname.

        cPathname = GetFullPathNameW(pwszFileName,
                                     MAX_PATH,
                                     pMFRec->wszFullPathName,
                                     &pwszFilePart);

        if (!cPathname || cPathname > MAX_PATH)
        {
            ERROR_ASSERT(FALSE, "GetFullPathName failed");
            if (cPathname > MAX_PATH)
                GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
            goto CreateMetaFileW_error;
        }
        pMFRec->wszFullPathName[cPathname] = 0;

        // Create the file.

        if ((pMFRec->hFile = CreateFileW(pMFRec->wszFullPathName,// Filename
                                    GENERIC_WRITE,              // Write access
                                    0L,                         // Non-shared
                                    (LPSECURITY_ATTRIBUTES) NULL, // No security
                                    CREATE_ALWAYS,              // Always create
                                    FILE_ATTRIBUTE_NORMAL,      // normal attributes
                                    (HANDLE) 0))                // no template file
            == INVALID_HANDLE_VALUE)
        {
            // Milestones, Etc. 3.1 creates the file for read/write access when
            // it calls CreateMetaFile.  This causes the above CreateFile to
            // fail.  However, we do not want to modify the above call since
            // it provides serialization and access to the metafile.  Instead,
            // we add in this hack for Milestones.  The only difference is
            // that the metafile is shared for read/write access.

            if ((pMFRec->hFile = CreateFileW(pMFRec->wszFullPathName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        (LPSECURITY_ATTRIBUTES) NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) 0))
                == INVALID_HANDLE_VALUE)
            {
                ERROR_ASSERT(FALSE, "CreateFile failed");
                goto CreateMetaFileW_error;
            }

            WARNING("CreateMetaFileW: Creating metafile with read/write share\n");
        }
        pMFRec->metaHeader.mtType = DISKMETAFILE;
    }
    else
    {
        pMFRec->metaHeader.mtType = MEMORYMETAFILE;
    }

// Allocate memory for metafile.
//   For disk metafile, it is used as a buffer.
//   For memory metafile, it is the storage for the metafile.

    if (!(pMFRec->hMem = LocalAlloc(LMEM_FIXED, MF16_BUFSIZE_INIT)))
        goto CreateMetaFileW_error;

// Write the header.

    if (!AttemptWrite(pMFRec, sizeof(METAHEADER), (LPBYTE)&pMFRec->metaHeader))
        goto CreateMetaFileW_error;

// Finally, allocate a local handle for the metafile DC.  It references
// the metafile recorder info.

    hdc = hCreateClientObjLink(pMFRec,LO_METADC16_TYPE);

    if (!hdc)
    {
        ERROR_ASSERT(FALSE, "CreateMetaFileW: iAllocHandle failed\n");
        goto CreateMetaFileW_error;
    }

    return(hdc);

CreateMetaFileW_error:

    if (pMFRec)
    {
        if (pMFRec->hFile != INVALID_HANDLE_VALUE)
        {
            if (!CloseHandle(pMFRec->hFile))
                ASSERTGDI(FALSE, "CloseHandle failed\n");

            if (!DeleteFileW(pMFRec->wszFullPathName))
                WARNING("CreateMetaFileW: DeleteFile failed\n");
        }

        if (pMFRec->hMem)
            if (LocalFree(pMFRec->hMem))
                ASSERTGDI(FALSE, "LocalFree failed");

        if (LocalFree((HANDLE) pMFRec))
            ASSERTGDI(FALSE, "CreateMetaFileW: LocalFree failed\n");
    }

    ERROR_ASSERT(FALSE, "CreateMetaFileW failed\n");
    return((HDC) 0);
}

/***************************** Internal Function **************************\
* HMETAFILE WINAPI CloseMetaFile
*
* The CloseMetaFile function closes the metafile device context and creates a
* metafile handle that can be used to play the metafile by using the
* PlayMetaFile function.
*
* The internal format for a MetaFile has two formats one
* for a memory MetaFile and one for a disk based MetaFile
*
* Effects:
*
\***************************************************************************/

HMETAFILE WINAPI CloseMetaFile(HDC hdc)
{
    PMFRECORDER16   pmfRec;
    HMETAFILE       hmf = (HMETAFILE) 0;

    PUTS("CloseMetaFile\n");

    GET_PMFRECORDER16(pmfRec,hdc);

    ASSERTGDI(pmfRec, "CloseMetaFile: pmfRec is NULL!");

    if (!IS_METADC16_TYPE(hdc) || !pmfRec)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(hmf);
    }

// If the metafile was aborted then free the MetaDC handle memory and go home.

    if (pmfRec->recFlags & METAFILEFAILURE)
        goto CLM_Cleanup;

// Write the terminate Record

    if (!RecordParms(hdc, 0, 0, (LPWORD)NULL))
        goto CLM_Cleanup;

// Flush the buffer and update the header record.

    if (pmfRec->metaHeader.mtType == DISKMETAFILE)
    {
        BOOL  fRet;
        DWORD dwT;

        ASSERTGDI(pmfRec->metaHeader.mtType == DISKMETAFILE,
            "CloseMetaFile: unknown metafile type");

        // Flush the memory buffer

        fRet = WriteFile(pmfRec->hFile, (LPBYTE)pmfRec->hMem,
                pmfRec->ibBuffer, &dwT, (LPOVERLAPPED)NULL);
        if (!fRet || (dwT != pmfRec->ibBuffer))
        {
            ERROR_ASSERT(FALSE, "CloseMetaFile: Write1 failed\n");
            goto CLM_Cleanup;
        }

        // Rewind the file and write the header out

        if (SetFilePointer(pmfRec->hFile, 0, (LPLONG)NULL, FILE_BEGIN) != 0)
        {
            ERROR_ASSERT(FALSE, "CloseMetaFile: SetFilePointer failed\n");
            goto CLM_Cleanup;
        }

        // Fix up data written to disk as a memory metafile

        pmfRec->metaHeader.mtType = MEMORYMETAFILE;
        fRet = WriteFile(pmfRec->hFile, (LPBYTE)& pmfRec->metaHeader,
                sizeof(METAHEADER), &dwT, (LPOVERLAPPED)NULL);
        pmfRec->metaHeader.mtType = DISKMETAFILE;       // restore it

        if (!fRet || (dwT != sizeof(METAHEADER)))
        {
            ERROR_ASSERT(FALSE, "CloseMetaFile: Write2 failed\n");
            goto CLM_Cleanup;
        }

        // Close the file.

        if (!CloseHandle(pmfRec->hFile))
            ASSERTGDI(FALSE, "CloseMetaFile: FileError\n");

        pmfRec->hFile = INVALID_HANDLE_VALUE;   // don't close it again below
    }
    else
    {
        HANDLE hMemNew;

        // Flush the header record.

        *(PMETAHEADER) pmfRec->hMem = pmfRec->metaHeader;

        // Realloc memory metafile to exact size

        hMemNew = LocalReAlloc(pmfRec->hMem, pmfRec->metaHeader.mtSize * sizeof(WORD), LMEM_MOVEABLE);

        if (!hMemNew)
        {
            ASSERTGDI(FALSE, "LocalReAlloc failed");
            goto CLM_Cleanup;
        }

        pmfRec->hMem = hMemNew;
    }

// Allocate and initialize a metafile.

    if (pmfRec->metaHeader.mtType == DISKMETAFILE)
    {
        hmf = GetMetaFileW(pmfRec->wszFullPathName);
    }
    else
    {
        hmf = SetMetaFileBitsAlt((HLOCAL) pmfRec->hMem);
        if (hmf)
            pmfRec->hMem = 0; // don't free it below because it has been transfered
    }

CLM_Cleanup:

// Remove the MetaFile from the list of active metafiles

    if (pmfRec->hObjectTable)
    {
        UnlistObjects(hdc);
        if (LocalFree((HANDLE) pmfRec->hObjectTable))
            ASSERTGDI( FALSE, "CloseMetaFile: LocalFree object table failed\n");
    }

// If the file handle exists at this time, we have an error.

    if (pmfRec->hFile != INVALID_HANDLE_VALUE)
    {
        if (!CloseHandle(pmfRec->hFile))
            ASSERTGDI(FALSE, "CloseHandle failed\n");

        if (!DeleteFileW(pmfRec->wszFullPathName))
            WARNING("CloseMetaFile: DeleteFile failed\n");
    }

// Free the cache buffer.

    if (pmfRec->hMem)
        if (LocalFree(pmfRec->hMem))
            ASSERTGDI(FALSE, "LocalFree failed");

// Free the memory for the metafile DC.

    if (LocalFree((HANDLE) pmfRec))
        ASSERTGDI(FALSE, "CloseMetaFile: LocalFree failed\n");

// Free the handle for the metafile DC.

    if (!bDeleteClientObjLink(hdc))
        RIP("CloseMetaFile - failed bDeleteClientObjLink\n");

    ERROR_ASSERT(hmf != (HMETAFILE) 0, "CloseMetaFile failed\n");
    return(hmf);
}

/***************************** Internal Function **************************\
* CopyMetaFile(hSrcMF, lpFileName)
*
*    Copies the metafile (hSrcMF) to a new metafile with name lpFileName. The
*    function then returns a handle to this new metafile if the function was
*    successful.
*
* Retuns      a handle to a new metafile, 0 iff failure
*
* IMPLEMENTATION:
*     The source and target metafiles are checked to see if they are both memory
*     metafile and if so a piece of Local memory is allocated and the metafile
*     is simply copied.
*     If this is not the case CreateMetaFile is called with lpFileName and then
*     records are pulled out of the source metafile (using GetEvent) and written
*     into the destination metafile one at a time (using RecordParms).
*
*     Lock the source
*     if source is a memory metafile and the destination is a memory metafile
*         alloc the same size Local memory as the source
*         copy the bits directly
*     else
*         get a metafile handle by calling CreateMetaFile
*         while GetEvent returns records form the source
*             record the record in the new metafile
*
*         close the metafile
*
*     return the new metafile handle
*
\***************************************************************************/

HMETAFILE WINAPI CopyMetaFileA(HMETAFILE hmf, LPCSTR psz)
{
    UINT  cch;
    WCHAR awch[MAX_PATH];

    if (psz != (LPSTR)NULL)
    {
        cch = strlen(psz)+1;

        if (cch > MAX_PATH)
        {
            ERROR_ASSERT(FALSE, "CopyMetaFileA filename too long");
            GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
            return((HMETAFILE)0);
        }

        vToUnicodeN(awch, MAX_PATH, psz, cch);

        return (CopyMetaFileW(hmf, awch));
    }
    else
        return (CopyMetaFileW(hmf, (LPWSTR)NULL));
}

HMETAFILE WINAPI CopyMetaFileW(HMETAFILE hSrcMF, LPCWSTR pwszFileName)
{
    PMETAFILE16     pMFSource;
    HMETAFILE       hMFDest = (HMETAFILE) 0;
    HDC             hMDCDest;
    UINT            state;

    PUTS("CopyMetaFile\n");

    pMFSource = GET_PMF16(hSrcMF);
    if (pMFSource == NULL)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(hMFDest);
    }

    state = (pMFSource->fl & MF16_DISKFILE) ? 2 : 0;
    state |= (pwszFileName) ? 1 : 0;

    switch (state)
    {
    case 0: /* memory -> memory */
        hMFDest = SetMetaFileBitsEx
                  (
                    pMFSource->metaHeader.mtSize * sizeof(WORD),
                    (LPBYTE) pMFSource->hMem
                  );
        break;

    case 3: /* disk -> disk */
        hMFDest = CopyFileW(pMFSource->wszFullPathName,
                         pwszFileName, FALSE)
                    ? GetMetaFileW(pwszFileName) : 0;

        ERROR_ASSERT(hMFDest, "CopyMetaFileW: GetMetaFile Failed\n");
        break;

    case 1:
    case 2:
        if (hMDCDest = CreateMetaFileW(pwszFileName))
        {
            PMFRECORDER16   pMFRecDest;
            PMETARECORD     lpMR = NULL;

            GET_PMFRECORDER16(pMFRecDest,hMDCDest);

            while (lpMR = GetEvent(pMFSource, lpMR))
                if ((lpMR == (PMETARECORD) -1)
                 || !RecordParms(hMDCDest, (DWORD)lpMR->rdFunction,
                              (DWORD)lpMR->rdSize - 3,
                              (LPWORD) lpMR->rdParm))
                {
                    HMETAFILE     hmfT;

                    MarkMetaFile(pMFRecDest);

                    if (hmfT = CloseMetaFile(hMDCDest))
                        DeleteMetaFile(hmfT);
                    return((HMETAFILE) 0);
                }

            // touch up the destination metafile header before we close
            // the metafile!

            pMFRecDest->metaHeader.mtNoObjects
                = pMFSource->metaHeader.mtNoObjects;
            ASSERTGDI(sizeof(METAHEADER) == 18, "CopyMetaFile: METAHEADER has changed!");

            hMFDest = CloseMetaFile(hMDCDest);
        }
        break;
    }

    ERROR_ASSERT(hMFDest, "CopyMetaFileW Failing\n");
    return(hMFDest);
}

/***************************** Internal Function ***************************\
* HANDLE WINAPI GetMetaFileBitsEx
*
* The GetMetaFileBits function returns a handle to a Windows metafile that
* contains the specified data describing the metafile.
*
* It does not invalidate the metafile handle like Windows!
*
* Effects:
*
\***************************************************************************/

UINT WINAPI GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData)
{
    DWORD       cbHave;
    PMETAFILE16 pmf16;

    PUTS("GetMetaFileBitsEx\n");

    pmf16 = GET_PMF16(hMF);
    if (pmf16 == NULL)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(0);
    }

    cbHave = pmf16->metaHeader.mtSize * sizeof(WORD);

// If lpData is NULL, return the size necessary to hold the data.

    if (!lpData)
        return(cbHave);

// Make sure the input buffer is large enough.

    if (cbBuffer < cbHave)
        return(0);

// Copy the bits.  Win3.1 returns the bits for memory metafile only!
// We will do the right thing here.

    RtlCopyMemory(lpData, (PBYTE) pmf16->hMem, cbHave);

// Return the number of bytes copied.

    return(cbHave);
}

/***************************** Internal Function **************************\
* HMETAFILE WINAPI SetMetaFileBitsEx
*
* Creates a memory based Windows 3.X metafile from the data provided
*
* Returns:  HMETAFILE iff succesful.
*
* Effects:
*
\***************************************************************************/

HMETAFILE WINAPI SetMetaFileBitsEx(UINT cbBuffer, CONST BYTE *lpData)
{
    PMETAFILE16 pmf16;
    HMETAFILE   hmf;

    PUTS("SetMetaFileBitsEx\n");

// Verify the input data.

    if (cbBuffer < sizeof(METAHEADER)
     || !IsValidMetaHeader16((PMETAHEADER) lpData))
    {
        ERROR_ASSERT(FALSE, "SetMetaFileBitsEx: Bad input data\n");
        GdiSetLastError(ERROR_INVALID_DATA);
        return((HMETAFILE) 0);
    }

    ERROR_ASSERT(((PMETAHEADER) lpData)->mtType == MEMORYMETAFILE,
        "SetMetaFileBitsEx: Bad mtType\n");

// Allocate and initialize a metafile.
// Some Windows metafiles contain bad values in mtSize.  As a result,
// we have to verify and fix the mtSize if neccessary.  This is fixed
// in the following call.

    if (!(pmf16 = pmf16AllocMF16(0, (DWORD) cbBuffer, (PDWORD)lpData, (LPWSTR) NULL)))
        return((HMETAFILE) 0);

    ASSERTGDI(pmf16->metaHeader.mtType == MEMORYMETAFILE,
        "SetMetaFileBitsEx: Bad mtType\n");
    ((PMETAHEADER) pmf16->hMem)->mtType = MEMORYMETAFILE;  // just in case

// Allocate a local handle.


    hmf = hmf16Create(pmf16);
    if (hmf == NULL)
    {
        vFreeMF16(pmf16);
    }

// Return the metafile handle.

    return(hmf);
}

// Similar to Win3.x SetMetaFileBits.
// It is assumed that hMem is allocated with the LMEM_FIXED option.
// For internal use only.

HMETAFILE WINAPI SetMetaFileBitsAlt(HLOCAL hMem)
{
    PMETAFILE16 pmf16;
    HMETAFILE   hmf;

    PUTS("SetMetaFileBitsAlt\n");

// Allocate and initialize a metafile.

    if (!(pmf16 = pmf16AllocMF16(ALLOCMF16_TRANSFER_BUFFER, 0, (PDWORD) hMem, (LPWSTR) NULL)))
        return((HMETAFILE) 0);

    ASSERTGDI(pmf16->metaHeader.mtType == MEMORYMETAFILE,
        "SetMetaFileBitsAlt: Bad mtType\n");
    ((PMETAHEADER) pmf16->hMem)->mtType = MEMORYMETAFILE;  // just in case

// Allocate a local handle.

    hmf = hmf16Create(pmf16);

    if (hmf == NULL)
    {
        pmf16->hMem = NULL;       // let caller free the buffer!
        vFreeMF16(pmf16);
    }

// Return the metafile handle.

    return(hmf);
}

/***************************** Internal Function **************************\
* GetObject16AndType
*
* Returns the object type, eg OBJ_FONT, as well as a the LogObject
* in Windows 3.x Format
*
\***************************************************************************/

#define MAXOBJECTSIZE sizeof(LOGFONT)

DWORD GetObject16AndType(HANDLE hObj, LPVOID lpObjBuf16)
{
    BYTE    objBuf32[MAXOBJECTSIZE];
    int     iObj;

    PUTS("GetObjectAndType\n");

    ASSERTGDI(MAXOBJECTSIZE >= sizeof(LOGPEN),
        "GetObject16AndType MAXOBJECTSIZE wrong\n");

    if (!GetObject(hObj, MAXOBJECTSIZE, &objBuf32))
    {
        ERROR_ASSERT(FALSE, "GetObject16AndType GetObject Failed\n");
        return(0);
    }

    switch(iObj = GetObjectType(hObj))
    {
    case OBJ_PEN:
        LOGPEN16FROMLOGPEN32((PLOGPEN16)lpObjBuf16,(LPLOGPEN)objBuf32);
        break;

    case OBJ_FONT:
        LOGFONT16FROMLOGFONT32((PLOGFONT16)lpObjBuf16,(LPLOGFONT)objBuf32);
        break;

    default:
        ASSERTGDI(FALSE, "GetObject16AndType unknown object type\n");
        return(0);
        break;
    }

    return((DWORD) iObj);
}

/***************************** Internal Function **************************\
* BOOL  UnlistObjects(hMetaDC)
*
* Each object has a list of metafiles the object is associated with.
* UnlistObjects removes hMetaDC from all of its object's metafile lists
*
* Effects:
*
\***************************************************************************/

BOOL UnlistObjects(HDC hMetaDC)
{
    PMETALINK16     pml16;
    UINT            iCurObject;
    UINT            iCurMetaListEntry;
    POBJECTTABLE    pht;
    PMFRECORDER16   pMFRec;

    PUTS("UnlistObjects\n");

    GET_PMFRECORDER16(pMFRec,hMetaDC);

    if (!IS_METADC16_TYPE(hMetaDC) || !pMFRec)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return((UINT)-1);
    }

    if (pMFRec->metaHeader.mtNoObjects)
    {
        pht = (POBJECTTABLE) pMFRec->hObjectTable;
        ASSERTGDI(pht, "UnlistObject: called even with no handle table");

    // Loop through the objects and unlink this metafile

        for (iCurObject=0; iCurObject < (UINT) pMFRec->metaHeader.mtNoObjects; iCurObject++)
        {
            HANDLE hObj;

            if( (hObj = pht[iCurObject].CurHandle)
                && (!pht[iCurObject].fPreDeleted))
            {
                if (IS_STOCKOBJ(hObj))
                    continue;

                ASSERTGDI(LO_TYPE(hObj) != LO_REGION_TYPE,
                    "UnlistObjects: unexpected region object");

                pml16 = pmetalink16Get(hObj);

                // It cannot be a empty list.

                ASSERTGDI(pml16, "UnlistObject: pml16 is NULL");

                if (!pml16 || pml16->cMetaDC16 == 0)
                    continue;

            // Find the metafile in the objects MetaLink16 list

                for (iCurMetaListEntry=0;
                     iCurMetaListEntry<pml16->cMetaDC16;
                     iCurMetaListEntry++)
                {
                    if(pml16->ahMetaDC16[iCurMetaListEntry] == hMetaDC)
                        break;
                }

                ASSERTGDI(iCurMetaListEntry < pml16->cMetaDC16,
                    "UnlistObject: Metafile not found");

            // Slide the rest of the metafiles in the list "up"

                for(; iCurMetaListEntry < (pml16->cMetaDC16-1); iCurMetaListEntry++)
                    pml16->ahMetaDC16[iCurMetaListEntry] = pml16->ahMetaDC16[iCurMetaListEntry+1];

                pml16->cMetaDC16--;             // just got rid of one

                if (pml16->cMetaDC16 == 0)
                {
                // We can only free the METALINK16 if the metalink field is not being used

                    if (pml16->metalink)
                    {
                        pml16->cMetaDC16 = 0;
                        pml16->ahMetaDC16[0] = (HDC)NULL;
                    }
                    else
                    {
                        if (!bDeleteMetalink16(hObj))
                            ASSERTGDI(FALSE,"UnlistObjects: LocalFree Failed\n");
                    }
                }
                else
                {
                    pml16 = pmetalink16Resize(hObj,pml16->cMetaDC16);

                    if (pml16 == NULL)
                    {
                        ASSERTGDI(FALSE,"UnlistObjects: LocalReAlloc Failed\n");
                        return (FALSE);
                    }
                }
            }
        } // for
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* pmf16AllocMF16(fl, cb, pb, pwszFilename)
*
* This routine allocates memory for an METAFILE16 and initializes it.
* Returns a pointer to the new METAFILE16.  On error returns NULL.
* It accepts only windows metafiles.
*
* This routine is called by API level METAFILE16 allocation routines
* CloseMetaFile, GetMetaFile, SetMetaFileBitsEx.
*
* Arguments:
*   fl           - ALLOCMF16_TRANSFER_BUFFER is set if storage for memory
*                  metafile is to be set directly into METAFILE16.  Otherwise,
*                  a copy of the memory metafile is duplicated.
*   cb           - Size of pb in bytes if given.  This parameter is given
*                  by SetMetaFileBitsEx only.  It is used to compare and
*                  fixup bad mtSize if necessary.
*   pb           - Pointer to a memory metafile if non-null.
*   pwszFilename - Filename of a disk metafile if non-null.
*
* History:
*  Fri May 15 14:11:22 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

PMETAFILE16 pmf16AllocMF16(DWORD fl, DWORD cb, CONST UNALIGNED DWORD *pb, LPCWSTR pwszFilename)
{
    PMETAFILE16  pmf16, pmf16Rc = (PMETAFILE16) NULL;

    PUTS("pmf16AllocMF16\n");

    ASSERTGDI(!(fl & ~ALLOCMF16_TRANSFER_BUFFER), "pmf16AllocMF16: Invalid fl");

// Allocate a new METAFILE16.

    if (!(pmf16 = (PMETAFILE16) LocalAlloc(LMEM_FIXED, sizeof(METAFILE16))))
        goto pmf16AllocMF16_cleanup;

// Initialize it.

    pmf16->ident           = MF16_IDENTIFIER;
    pmf16->hFile           = INVALID_HANDLE_VALUE;
    pmf16->hFileMap        = (HANDLE) 0;
    pmf16->hMem            = (HANDLE) 0;
    pmf16->iMem            = 0;
    pmf16->hMetaFileRecord = (HANDLE) 0;
    pmf16->fl              = 0L;

// Memory mapped the disk file if given.

    if (pwszFilename)
    {
        LPWSTR  pwszFilePart;           // not used
        DWORD   cPathname;

        pmf16->fl |= MF16_DISKFILE;     // this must be first!  See vFreeMF16.

        // Convert the filename to a fully qualified pathname.

        cPathname = GetFullPathNameW(pwszFilename,
                                     MAX_PATH,
                                     pmf16->wszFullPathName,
                                     &pwszFilePart);

        if (!cPathname || cPathname > MAX_PATH)
        {
            ERROR_ASSERT(FALSE, "GetFullPathName failed");
            if (cPathname > MAX_PATH)
                GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
            goto pmf16AllocMF16_cleanup;
        }
        pmf16->wszFullPathName[cPathname] = 0;

        if ((pmf16->hFile = CreateFileW(pmf16->wszFullPathName, // Filename
                                     GENERIC_READ,              // Read access
                                     FILE_SHARE_READ,           // Share read
                                     (LPSECURITY_ATTRIBUTES) 0L,// No security
                                     OPEN_EXISTING,             // Re-open
                                     0,                         // file attributes ignored
                                     (HANDLE) 0))               // no template file
            == INVALID_HANDLE_VALUE)
        {
        // See the comment for Milestones in CreateMetaFileW.

        if ((pmf16->hFile = CreateFileW(pmf16->wszFullPathName,
                     GENERIC_READ,
                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                     (LPSECURITY_ATTRIBUTES) 0L,
                     OPEN_EXISTING,
                     0,
                     (HANDLE) 0))
        == INVALID_HANDLE_VALUE)
        {
        ERROR_ASSERT(FALSE, "CreateFile failed");
        goto pmf16AllocMF16_cleanup;
        }
        WARNING("pmf16AllocMF16: Opening metafile with read/write share\n");
        }

        if (!(pmf16->hFileMap = CreateFileMappingW(pmf16->hFile,
                                                (LPSECURITY_ATTRIBUTES) 0L,
                                                PAGE_READONLY,
                                                0L,
                                                0L,
                                                (LPWSTR) NULL)))
        {
            ERROR_ASSERT(FALSE, "CreateFileMapping failed");
            goto pmf16AllocMF16_cleanup;
        }

        if (!(pmf16->hMem = MapViewOfFile(pmf16->hFileMap, FILE_MAP_READ, 0, 0, 0)))
        {
            ERROR_ASSERT(FALSE, "MapViewOfFile failed");
            goto pmf16AllocMF16_cleanup;
        }
    }
    else if (fl & ALLOCMF16_TRANSFER_BUFFER)
    {
// If this is our memory metafile from MDC, transfer it to METAFILE16.

        pmf16->hMem = (BYTE *) pb;
    }
    else
    {
// Otherwise, make a copy of memory metafile.
// We get here only if the caller is SetMetaFileBitsEx.  Since some metafiles
// may contain a bad mtSize that is different than the actual file size, we
// need to fix it up if necessary!

        DWORD mtSize = ((PMETAHEADER) pb)->mtSize;

        if ((mtSize * 2 > cb)                   // mtSize greater than filesize
         || (((PWORD) pb)[mtSize - 3] != 3)     // EOF record should be 3,0,0
         || (((PWORD) pb)[mtSize - 2] != 0)
         || (((PWORD) pb)[mtSize - 1] != 0))
        {
            // Compute the correct mtSize!

            PMETARECORD pMR;
            DWORD       mtSizeMax;

            PUTS("pmf16AllocMF16: verifying mtSize\n");

            mtSize = ((PMETAHEADER) pb)->mtHeaderSize;
            pMR    = (PMETARECORD) ((PWORD) pb + ((PMETAHEADER) pb)->mtHeaderSize);
            mtSizeMax = cb / 2 - 3;     // max mtSize not counting EOF record

            while (mtSize <= mtSizeMax && pMR->rdFunction != 0)
            {
                mtSize += pMR->rdSize;
                pMR = (PMETARECORD) ((PWORD) pMR + pMR->rdSize);
            }

            if (mtSize > mtSizeMax)
            {
                ERROR_ASSERT(FALSE, "pmf16AllocMF16: incomplete metafile\n");
                goto pmf16AllocMF16_cleanup;
            }

// Powerpnt uses 0,0,0 for the EOF record!  We will change it to 3,0,0 below.

            mtSize += 3;    // include EOF record (pMR->rdSize may not be valid)

            if (((PMETAHEADER) pb)->mtSize != mtSize)
            {
                ERROR_ASSERT(FALSE, "pmf16AllocMF16: fixing up bad mtSize\n");
            }
        }

        if (!(pmf16->hMem = LocalAlloc(LMEM_FIXED, mtSize * sizeof(WORD))))
            goto pmf16AllocMF16_cleanup;
        RtlCopyMemory((PBYTE) pmf16->hMem, (PBYTE)pb, mtSize * sizeof(WORD));
        ((PMETAHEADER) pmf16->hMem)->mtSize = mtSize;   // update mtSize

    VERIFYGDI(((PWORD) pmf16->hMem)[mtSize - 3] == 3
           && ((PWORD) pmf16->hMem)[mtSize - 2] == 0
           && ((PWORD) pmf16->hMem)[mtSize - 1] == 0,
        "pmf16AllocMF16: fixing up bad EOF metafile record\n");

        ((PWORD) pmf16->hMem)[mtSize - 3] = 3;      // update EOF record
        ((PWORD) pmf16->hMem)[mtSize - 2] = 0;
        ((PWORD) pmf16->hMem)[mtSize - 1] = 0;
    }

// Make a copy of the metafile header.

    pmf16->metaHeader = *(PMETAHEADER) pmf16->hMem;
    pmf16->metaHeader.mtType = (pmf16->fl & MF16_DISKFILE)
                                ? DISKMETAFILE
                                : MEMORYMETAFILE;

// Verify metafile header

    if (!IsValidMetaHeader16(&pmf16->metaHeader))
    {
        ERROR_ASSERT(FALSE,
                "pmf16AllocMF16: Metafile has an invalid header; Failing\n");
        goto pmf16AllocMF16_cleanup;
    }

// Everything is golden.

    pmf16Rc = pmf16;

// Cleanup and go home.

pmf16AllocMF16_cleanup:

    if (!pmf16Rc)
        if (pmf16)
        {
            if (fl & ALLOCMF16_TRANSFER_BUFFER)
                pmf16->hMem = NULL;       // let caller free the buffer!
            vFreeMF16(pmf16);
        }

    ERROR_ASSERT(pmf16Rc, "pmf16AllocMF16 failed");
    return(pmf16Rc);
}

/******************************Public*Routine******************************\
* vFreeMF16 (pmf16)
*
* This is a low level routine which frees the resouces in the METAFILE16.
*
* This function is intended to be called from the routines CloseMetaFile
* and DeleteMetaFile.
*
* Arguments:
*   pmf16    - The METAFILE16 to be freed.
*
* History:
*  Fri May 15 14:11:22 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID vFreeMF16(PMETAFILE16 pmf16)
{
    PUTS("vFreeMF16\n");

    ASSERTGDI(pmf16->ident == MF16_IDENTIFIER, "Bad METAFILE16");

// Free the resources.

    if (!(pmf16->fl & MF16_DISKFILE))
    {
    // Free memory metafile.

        if (pmf16->hMem)
            if (LocalFree(pmf16->hMem))
                ASSERTGDI(FALSE, "LocalFree failed");
    }
    else
    {
    // Unmap disk file.

        if (pmf16->hMem)
            if (!UnmapViewOfFile((LPVOID) pmf16->hMem))
                ASSERTGDI(FALSE, "UmmapViewOfFile failed");

        if (pmf16->hFileMap)
            if (!CloseHandle(pmf16->hFileMap))
                ASSERTGDI(FALSE, "CloseHandle failed");

        if (pmf16->hFile != INVALID_HANDLE_VALUE)
            if (!CloseHandle(pmf16->hFile))
                ASSERTGDI(FALSE, "CloseHandle failed");
    }

// Smash the identifier.

    pmf16->ident = 0;

// Free the memory.

    if (LocalFree(pmf16))
        ASSERTGDI(FALSE, "LocalFree failed");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\mfplay16.c ===
/****************************** Module Header ******************************\
* Module Name: MfPlay16.c
*
* This file contains the routines for playing the GDI metafile.  Most of these
* routines are adopted from windows gdi code. Most of the code is from
* win3.0 except for the GetEvent code which is taken from win2.1
*
* Created: 11-Oct-1989
*
* Copyright (c) 1985-1999  Microsoft Corporation
*
*
* Public Functions:
*   PlayMetaFile
*   PlayMetaFileRecord
*   GetMetaFile
*   DeleteMetaFile
* Private Functions:
*   GetEvent
*   IsDIBBlackAndWhite
*
* History:
*  02-Jul-1991 -by-  John Colleran [johnc]
* Combined From Win 3.1 and WLO 1.0 sources
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "mf16.h"


BOOL    AddToHandleTable(LPHANDLETABLE lpHandleTable, HANDLE hObject, UINT noObjs);
BOOL    CommonEnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM lpData);
HANDLE  CreateBitmapForDC (HDC hMemDC, LPBITMAPINFOHEADER lpDIBInfo);
WORD    GetSizeOfColorTable (LPBITMAPINFOHEADER lpDIBInfo);
BOOL    IsDIBBlackAndWhite(LPBITMAPINFOHEADER lpDIBInfo);
BOOL    PlayIntoAMetafile(LPMETARECORD lpMR, HDC hdcDest);

 #if DBG
UINT    curRecord;      // debuging helpers
UINT    iBreakRecord = 0xFFFFFFFF;
#endif

/***************************** Public Function ****************************\
* BOOL  APIENTRY PlayMetaFile(hdc, hmf)
* HDC           hDC;
* HMETAFILE     hMF;
*
* Play a windows metafile.
*
* History:
*   02-Jul-1991 -by-  John Colleran [johnc]
* Ported from Windows and WLO
\***************************************************************************/

BOOL APIENTRY PlayMetaFile(HDC hdc, HMETAFILE hmf)
{
    return (CommonEnumMetaFile(hdc, hmf, (MFENUMPROC)NULL, (LPARAM)0));
}

/******************************** Public Function **************************\
* BOOL EnumMetaFile(hmf)
*
* The EnumMetaFile function enumerates the GDI calls within the metafile
* identified by the hMF parameter. The EnumMetaFile function retrieves each
* GDI call within the metafile and passes it to the function pointed to by the
* pCallbackFunc parameter. This callback function, an application-supplied
* function, can process each GDI call as desired. Enumeration continues until
* there are no more GDI calls or the callback function returns zero.
*
*
* Effects:
*
\***************************************************************************/

BOOL EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC pCallBackFunction, LPARAM pClientData)
{
// Make sure that the callback function is given.  CommonEnumMetaFile expects
// it to be given in EnumMetaFile.

    if (!pCallBackFunction)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER );
        return(FALSE);
    }

    return (CommonEnumMetaFile(hdc, hmf, pCallBackFunction, pClientData));
}

BOOL CommonEnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC pCallBack, LPARAM pClientData)
{
    BOOL            fStatus    = FALSE;        // assume it fails
    UINT            ii;
    UINT            noObjs;
    PMETAFILE16     pMF;
    INT             oldMapMode = -1;
    PMETARECORD     pMR        = (PMETARECORD) NULL;
    LPHANDLETABLE   pht        = (LPHANDLETABLE) NULL;
    HFONT           hLFont;
    HBRUSH          hLBrush;
    HPALETTE        hLPal;
    HPEN            hLPen;
    HRGN            hClipRgn   = (HRGN)NULL;
    SIZE            sizeOldWndExt;
    SIZE            sizeOldVprtExt;
    PDC_ATTR        pDcAttr;
    PLDC            pldc;
    int             iGraphicsModeOld;
    BOOL            bMetaDC16 = FALSE;
    FLONG           flPlayMetaFile = (FLONG) 0;

// First validate the DC type and note whether or not we
// are playing into a 16bit metafile.Null hdc is allowed
// in win3.0 but disallowed in win3.1.


    if(LO_TYPE(hdc) == LO_METADC16_TYPE)
    {
        bMetaDC16 = TRUE;
    }
    else if ((hdc == NULL) && pCallBack)
    {
       // Actually win9x can take NULL hdc.  There are some image filter
       // that actually pass in us NULL hdc.  Only let NULL hdc thru if there is a
       // callback routine. [bug 102767]

       bMetaDC16 = TRUE;
    }
    else
    if((LO_TYPE(hdc) != LO_DC_TYPE ) &&
       (LO_TYPE(hdc) != LO_ALTDC_TYPE))
    {
        WARNING("CommonEnumMetaFile: bogus DC\n");
        return(FALSE);
    }

// need a pointer to pDcAttr for DC_PLAYMETAFILE flag

    PSHARED_GET_VALIDATE((PVOID)pDcAttr,hdc,DC_TYPE);

    if(!bMetaDC16 && !pDcAttr) {
        WARNING("CommonEnumMetaFile: Couldn't Validate DC\n");
        return(FALSE);
    }

// we still need to PLDC in the case that we are printing and there is
// an abort proc

    pldc = GET_PLDC(hdc);

    PUTS("CommonEnumMetaFile\n");

#if DBG
    curRecord = 0;
#endif

// Validate the 16 bit MetaFile

    pMF = GET_PMF16(hmf);
    if (pMF == NULL)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Allocate memory for the handle table.

    if ((noObjs = pMF->metaHeader.mtNoObjects) > 0)
        if (!(pht = (LPHANDLETABLE) LocalAlloc(
                                LMEM_FIXED | LMEM_ZEROINIT,
                                sizeof(HANDLE) * pMF->metaHeader.mtNoObjects
                                     + sizeof(WORD))))  // need extra word?
            return(FALSE);

// Save the old objects so we can put them back if this is not a metafile.
// Only do object save/reselect for real DC's.

    if( !bMetaDC16 )
    {
        hLBrush  = (HBRUSH)   GetDCObject(hdc, LO_BRUSH_TYPE);
        hLFont   = (HFONT)    GetDCObject(hdc, LO_FONT_TYPE);
        hLPal    = (HPALETTE) GetDCObject(hdc, LO_PALETTE_TYPE);
        hLPen    = (HPEN)     GetDCObject(hdc, LO_PEN_TYPE);

    // Set a bit in the DC to indicate that we are playing the metafile.
    // This bit is cleared by CancelDC() to stop playing the metafile.
    // At the same time, remember the previous DC_PLAYMETAFILE bit.

        try
        {
            flPlayMetaFile = pDcAttr->ulDirty_ & DC_PLAYMETAFILE;
            if (flPlayMetaFile)
            {
                PUTS("CommonEnumMetaFile: DC_PLAYMETAFILE bit is set!\n");
            }
            pDcAttr->ulDirty_ |= DC_PLAYMETAFILE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("except in SetBkMode\n");
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

    // Create a region in case there is a clip region to receive from GetClipRgn

        if (!(hClipRgn = CreateRectRgn(0,0,0,0)))
            goto pmf_cleanup;

        switch (GetClipRgn(hdc, hClipRgn))
        {
        case -1:        // error
            ASSERTGDI(FALSE, "GetClipRgn failed");
            goto pmf_cleanup;
        case 0:         // no initial clip region
            if (!DeleteObject(hClipRgn))
                ASSERTGDI(FALSE, "CommonEnumMetaFile: Detele region failed\n");
            hClipRgn = (HRGN) 0;
            break;
        case 1:         // has initial clip region
            break;
        }

// The metafile is to be played in the compatible graphics mode only.

        iGraphicsModeOld = GetGraphicsMode(hdc);
        if (iGraphicsModeOld != GM_COMPATIBLE)
            SetGraphicsMode(hdc, GM_COMPATIBLE);
    }

// Are we doing an EnumMetaFile or PlayMetaFile

    if (pCallBack)
    {
        fStatus = TRUE;         // assume success

// EnumMetaFile

        while (pMR = (PMETARECORD) GetEvent(pMF, pMR))
        {
            if (pMR == (PMETARECORD) -1)
            {
                fStatus = FALSE;
                break;
            }

            if (!bMetaDC16 && !( pDcAttr->ulDirty_ & DC_PLAYMETAFILE))
            {
                WARNING("CommonEnumMetaFile: CancelDC called\n");
                fStatus = FALSE;
                break;
            }

            if (!(fStatus = (*pCallBack)(hdc, pht, (METARECORD FAR *) pMR,
                                (int) noObjs, pClientData)))
                break;

        #if DBG
            curRecord++;
            if (curRecord == iBreakRecord)
                ASSERTGDI(FALSE, "CommonEnumMetaFile: iBreakRecord reached\n");
        #endif
        }
    }
    else
    {
// PlayMetaFile

        fStatus = TRUE;         // assume success

        while (pMR = (PMETARECORD) GetEvent(pMF, pMR))
        {
            if (pMR == (PMETARECORD) -1)
            {
                fStatus = FALSE;
                break;
            }

            if (!bMetaDC16 && !( pDcAttr->ulDirty_ & DC_PLAYMETAFILE))
            {
                WARNING("CommonEnumMetaFile: CancelDC called\n");
                fStatus = FALSE;
                break;
            }

            if (pldc && pldc->pfnAbort != NULL)
            {
                if (!(*pldc->pfnAbort)(hdc, 0))
                {
                    fStatus = FALSE;
                        break;
                }
            }

        // For win3.1 compatability, ignore the return value from PlayMetaFileRecord

            PlayMetaFileRecord(hdc, pht, pMR, noObjs);

        #if DBG
            curRecord++;
            if (curRecord == iBreakRecord)
                ASSERTGDI(FALSE, "CommonEnumMetaFile: iBreakRecord reached\n");
        #endif
        }
    }

    // if we fail restoring an object, we need to select some
    // default object so that we can DeleteObject any Metafile-
    // selected objects

    if( !bMetaDC16 )
    {
        if (iGraphicsModeOld != GM_COMPATIBLE)
            SetGraphicsMode(hdc, iGraphicsModeOld);

        if (!SelectObject(hdc,hLPen))
            SelectObject(hdc,GetStockObject(BLACK_PEN));

        if (!SelectObject(hdc,hLBrush))
            SelectObject(hdc,GetStockObject(BLACK_BRUSH));

        if (!SelectPalette(hdc, hLPal, FALSE))
            SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);

        if (hLFont != (HFONT) GetDCObject(hdc, LO_FONT_TYPE))
        {
            if (!SelectObject(hdc,hLFont))
            {
                // if we cannot select the original font back in, we
                // select the system font.  this will allow us to delete
                // the metafile font selected.  to insure that the system
                // font gets selected, we reset the DC's transform to
                // default.  after the selection, we restore this stuff
                //

                GetWindowExtEx(hdc, &sizeOldWndExt);
                GetViewportExtEx(hdc, &sizeOldVprtExt);
                oldMapMode = SetMapMode(hdc, MM_TEXT);

                SelectObject(hdc,GetStockObject(SYSTEM_FONT));

                SetMapMode(hdc,oldMapMode);
                SetWindowExtEx( hdc, sizeOldWndExt.cx,  sizeOldWndExt.cy,  NULL);
                SetViewportExtEx(hdc, sizeOldVprtExt.cx, sizeOldVprtExt.cy, NULL);
            }
        }

        if (SelectClipRgn(hdc, hClipRgn) == RGN_ERROR)
            SelectClipRgn(hdc, (HRGN) 0);
    }

    // Cleanup all created objects

    for (ii = 0; ii < noObjs; ii++)
    {
        if (pht->objectHandle[ii])
            if (!DeleteObject(pht->objectHandle[ii]))
                ERROR_ASSERT(FALSE,
                    "CommonEnumMetaFile: DeleteObject(objectHandle) failed\n");
    }

    // if we fiddled with the map mode because we could not
    // restore the original font, then maybe we can restore the
    // font now

    if (oldMapMode > 0)
        SelectObject(hdc,hLFont);

pmf_cleanup:

    if (pldc)
    {
        // Preserve the DC_PLAYMETAFILE bit.
        // If we hit a CancelDC, then we will leave the bit clear.

        ASSERTGDI(!(flPlayMetaFile & ~DC_PLAYMETAFILE),
            "CommonEnumMetaFile: bad flPlayMetaFile\n");

        if (!bMetaDC16 && !( pDcAttr->ulDirty_ & DC_PLAYMETAFILE) )
        {
            pDcAttr->ulDirty_ &= ~DC_PLAYMETAFILE;
            pDcAttr->ulDirty_ |= flPlayMetaFile; // restore the original flag
        }
    }

    if (hClipRgn)
        if (!DeleteObject(hClipRgn))
            ASSERTGDI(FALSE, "CommonEnumMetaFile: Delete region 2 failed\n");

    if (pht)
        if (LocalFree((HANDLE) pht))
            ASSERTGDI(FALSE, "CommonEnumMetaFile: LocalFree failed\n");

    return(fStatus);
}

/***************************** Internal Function **************************\
* BOOL NEAR PASCAL IsDIBBlackAndWhite
*
* Check to see if this DIB is a black and white DIB (and should be
* converted into a mono bitmap as opposed to a color bitmap).
*
* Returns: TRUE         it is a B&W bitmap
*          FALSE        this is for color
*
* Effects: ?
*
* Warnings: ?
*
* History:
\***************************************************************************/

BOOL IsDIBBlackAndWhite(LPBITMAPINFOHEADER lpDIBInfo)
{
    LPDWORD lpRGB;

    PUTS("IsDIBBlackAndWhite\n");

    ASSERTGDI(!((ULONG_PTR) lpDIBInfo & 0x3), "IsDIBBlackAndWhite: dword alignment error\n");

    /* pointer color table */
    lpRGB = (LPDWORD)((LPBITMAPINFO)lpDIBInfo)->bmiColors;

    return (lpDIBInfo->biBitCount == 1
         && lpDIBInfo->biPlanes == 1
         && lpRGB[0] == (DWORD) 0
         && lpRGB[1] == (DWORD) 0xFFFFFF);
}

/***************************** Internal Function **************************\
* UseStretchDIBits
*
* set this directly to the device using StretchDIBits.
* if DIB is black&white, don't do this.
*
* Returns:
*               TRUE --- operation successful
*               FALSE -- decided not to use StretchDIBits
*
* History:
\***************************************************************************/

BOOL UseStretchDIB(HDC hDC, WORD magic, LPMETARECORD lpMR)
{
    LPBITMAPINFOHEADER lpDIBInfo;
    INT sExtX, sExtY;
    INT sSrcX, sSrcY;
    INT DstX, DstY, DstXE, DstYE;

    if (magic == META_DIBBITBLT)
    {
        lpDIBInfo = (LPBITMAPINFOHEADER)&lpMR->rdParm[8];

        DstX  = (INT) (SHORT) lpMR->rdParm[7];
        DstY  = (INT) (SHORT) lpMR->rdParm[6];
        sSrcX = (INT) (SHORT) lpMR->rdParm[3];
        sSrcY = (INT) (SHORT) lpMR->rdParm[2];
        DstXE = sExtX = (INT) (SHORT) lpMR->rdParm[5];
        DstYE = sExtY = (INT) (SHORT) lpMR->rdParm[4];
    }
    else
    {
        lpDIBInfo = (LPBITMAPINFOHEADER)&lpMR->rdParm[10];

        DstX  = (INT) (SHORT) lpMR->rdParm[9];
        DstY  = (INT) (SHORT) lpMR->rdParm[8];
        DstXE = (INT) (SHORT) lpMR->rdParm[7];
        DstYE = (INT) (SHORT) lpMR->rdParm[6];
        sSrcX = (INT) (SHORT) lpMR->rdParm[5];
        sSrcY = (INT) (SHORT) lpMR->rdParm[4];
        sExtX = (INT) (SHORT) lpMR->rdParm[3];
        sExtY = (INT) (SHORT) lpMR->rdParm[2];
    }

    ASSERTGDI(!((ULONG_PTR) lpDIBInfo & 0x3), "UseStretchDIB: dword alignment error\n");

    /* if DIB is black&white, we don't really want to do this */
    if (IsDIBBlackAndWhite(lpDIBInfo))
        return(FALSE);

// Need to flip the source y coordinates to call StretchDIBits.

    sSrcY = ABS(lpDIBInfo->biHeight) - sSrcY - sExtY;

    StretchDIBits(hDC, DstX, DstY, DstXE, DstYE,
                        sSrcX, sSrcY, sExtX, sExtY,
                        (LPBYTE)((LPSTR)lpDIBInfo + lpDIBInfo->biSize
                                + GetSizeOfColorTable(lpDIBInfo)),
                        (LPBITMAPINFO)lpDIBInfo, DIB_RGB_COLORS,
                        (MAKELONG(lpMR->rdParm[0], lpMR->rdParm[1])));
    return(TRUE);
}

BOOL
bValidExtent(PMETAFILE16 pmf16, LPMETARECORD lpMR, DWORD cbSize)
{
#if 0 
    // No absolute pointer validations as the records can be copied and played back.
    BYTE *pB = (BYTE*)pmf16->hMem;
    BYTE *pE = (BYTE*)lpMR + cbSize;
#endif
    if (pmf16->fl & MF16_DISKFILE)
    {
        UINT64 fileSize;
        if (!GetFileSizeEx(pmf16->hFile, (PLARGE_INTEGER)&fileSize))
        {
            EMFVALFAIL(("GetFileSize(%p) failed\n", pmf16->hFile));
            return(FALSE);
        }

        if (cbSize > fileSize)
        {
            EMFVALFAIL(("Record Size (%d) larger than file size (%d)!\n", cbSize, (UINT32)fileSize));
            return(FALSE);
        }
    }
    else
    {
        if (cbSize > (((PMETAHEADER)pmf16->hMem)->mtSize * sizeof(WORD)))
        {
            EMFVALFAIL(("Record Size (%d) larger than file size (%d)!\n", cbSize, (UINT32)(((PMETAHEADER)pmf16->hMem)->mtSize * sizeof(WORD))));
            return(FALSE);
        }
    }

#if 0
    // No absolute pointer validations as the records can be copied and played back.
    if (pE < pB)
    {
        EMFVALFAIL(("End pointer(%p) is less than Begin pointer (%p). Arithmetic wrap around!\n", pE, pB));
        return(FALSE);
    }
#endif
    return (TRUE);
}

/***************************** Internal Function **************************\
* GetEvent
*
* This routine will now open a disk metafile in READ_ONLY mode. This will
* allow us to play read-only metafiles or to share such file.
*
* To start the enumeration, the first lpMR must be NULL.
* It does not enumerate the first (header) and last (terminator) records.
*
* Returns:  Next MetaFile Record to be played
*           NULL if the next metafile record is the EOF record
*           -1   if an error occurs.
*
\***************************************************************************/

PMETARECORD GetEvent(PMETAFILE16 pmf16, PMETARECORD lpMR)
{
    PMETARECORD lpMRNext;

    PUTS("GetEvent\n");

    if (lpMR == (PMETARECORD) NULL)
    {
        if (!bValidExtent(pmf16, (PMETARECORD)pmf16, sizeof(METAHEADER)))
        {
            EMFVALFAIL(("GetEvent: bValidExtent(%p) (%p) (%08x) failed\n", pmf16, pmf16, sizeof(METAHEADER)));
            return((PMETARECORD) -1);
        }
        pmf16->iMem = sizeof(METAHEADER);
    }
    else
    {
        if (lpMR->rdSize * sizeof(WORD) < lpMR->rdSize)
        {
             EMFVALFAIL(("GetEvent: arithmetic overflow\n"));
             return((PMETARECORD) -1);
        }
        if (lpMR->rdSize == 0 || !bValidExtent(pmf16, lpMR, lpMR->rdSize * sizeof(WORD)))
        {
             EMFVALFAIL(("GetEvent: bValidExtent(%p) (%p) (%08x) failed\n", pmf16, lpMR, lpMR->rdSize * sizeof(WORD)));
             return((PMETARECORD) -1);
        }
        pmf16->iMem += (lpMR->rdSize * sizeof(WORD));
    }
// Make sure that we don't read past the EOF.  A minimal record includes
// rdSize (DWORD) and rdFunction (WORD).

    if (pmf16->iMem > pmf16->metaHeader.mtSize * sizeof(WORD) - sizeof(DWORD) - sizeof(WORD))
    {
        VERIFYGDI(FALSE, "GetEvent: Metafile contains bad data\n");
        return((PMETARECORD) -1);
    }

    lpMRNext = (PMETARECORD) ((LPBYTE) pmf16->hMem + pmf16->iMem);

// If we are at the end of the metafile then return NULL.

    if (lpMRNext->rdFunction == 0)
        return((PMETARECORD) NULL);

    return(lpMRNext);
}

/***************************** Internal Function **************************\
* BOOL GDIENTRY PlayMetaFileRecord
*
* Plays a metafile record by executing the GDI function call contained
* withing the metafile record
*
* Effects:
*
\***************************************************************************/

//LPSTR lpZapfDingbats = "ZAPFDINGBATS";
//LPSTR lpZapf_Dingbats = "ZAPF DINGBATS";
//LPSTR lpSymbol = "SYMBOL";
//LPSTR lpTmsRmn = "TMS RMN";
//LPSTR lpHelv = "HELV";

#define PITCH_MASK  ( FIXED_PITCH | VARIABLE_PITCH )

BOOL
APIENTRY PlayMetaFileRecord(
    HDC             hdc,
    LPHANDLETABLE   lpHandleTable,
    LPMETARECORD    lpMR,
    UINT            noObjs
   )
{
    BOOL         fStatus = FALSE;
    LPMETARECORD lpMRdup = (LPMETARECORD) NULL;
    WORD    magic;
    HANDLE  hObject;
    HANDLE  hOldObject;
    HBRUSH  hBrush;
    HRGN    hRgn;
    HANDLE  hPal;

    PUTSX("PlayMetaFileRecord 0x%p\n", lpMR);

    magic = lpMR->rdFunction;

    switch (magic & 255)
    {
        case (META_BITBLT & 255):
        case (META_STRETCHBLT & 255):
        {
            HDC         hSDC;
            HANDLE      hBitmap;
            PBITMAP16   lpBitmap16;
            INT         delta = 0;
            DWORD       rop;

            WARNING("PlayMetaFileRecord: obsolete META_BITBLT/META_STRETCHBLT record\n");

            /* if playing into another Metafile, do direct copy */
            if (PlayIntoAMetafile(lpMR, hdc))
            {
                fStatus = TRUE;
                break;
            }

            if ((lpMR->rdSize - 3) == ((DWORD) magic >> 8))
            {
                hSDC = hdc;
                delta = 1;
            }
            else
            {
                LPMETARECORD lpMRtmp;

                // Make the bitmap bits dword aligned.  To do this,
                // lpMR has to fall on a dword aligned even address so that
                // the bitmap bits (&lpMR->rdParm[8+5] or &lpMR->rdParm[10+5])
                // will fall on the dword aligned addresses.

                if (!(lpMRdup = (LPMETARECORD) LocalAlloc(LMEM_FIXED,
                        (UINT) lpMR->rdSize * sizeof(WORD))))
                    break;
                lpMRtmp = lpMRdup;
                RtlCopyMemory((PBYTE) lpMRtmp,
                              (PBYTE) lpMR,
                              (UINT)  lpMR->rdSize * sizeof(WORD));

                if (hSDC = CreateCompatibleDC(hdc))
                {
                    if (magic == META_BITBLT)
                        lpBitmap16 = (PBITMAP16) &lpMRtmp->rdParm[8];
                    else
                        lpBitmap16 = (PBITMAP16) &lpMRtmp->rdParm[10];

                    if (hBitmap  = CreateBitmap(lpBitmap16->bmWidth,
                                                lpBitmap16->bmHeight,
                                                lpBitmap16->bmPlanes,
                                                lpBitmap16->bmBitsPixel,
                                                (LPBYTE)&lpBitmap16->bmBits))
                        hOldObject = SelectObject(hSDC, hBitmap);
                    else
                        goto PMFR_BitBlt_cleanup;
                }
                else
                    break;
            }

            rop = MAKELONG(lpMR->rdParm[0], lpMR->rdParm[1]);

            if (magic == META_BITBLT)
                fStatus = BitBlt(hdc,
                                (int) (SHORT) lpMR->rdParm[7 + delta],
                                (int) (SHORT) lpMR->rdParm[6 + delta],
                                (int) (SHORT) lpMR->rdParm[5 + delta],
                                (int) (SHORT) lpMR->rdParm[4 + delta],
                                (delta && !ISSOURCEINROP3(rop)) ? 0 : hSDC,
                                (int) (SHORT) lpMR->rdParm[3],
                                (int) (SHORT) lpMR->rdParm[2],
                                rop);
            else
                fStatus = StretchBlt(hdc,
                                (int) (SHORT) lpMR->rdParm[9 + delta],
                                (int) (SHORT) lpMR->rdParm[8 + delta],
                                (int) (SHORT) lpMR->rdParm[7 + delta],
                                (int) (SHORT) lpMR->rdParm[6 + delta],
                                (delta && !ISSOURCEINROP3(rop)) ? 0 : hSDC,
                                (int) (SHORT) lpMR->rdParm[5],
                                (int) (SHORT) lpMR->rdParm[4],
                                (int) (SHORT) lpMR->rdParm[3],
                                (int) (SHORT) lpMR->rdParm[2],
                                rop);

            if (hSDC != hdc)
            {
                if (!SelectObject(hSDC, hOldObject))
                    ASSERTGDI(FALSE, "PlayMetaFileRecord: SelectObject Bitblt Failed\n");
                if (!DeleteObject(hBitmap))
                    ASSERTGDI(FALSE, "PlayMetaFileRecord: DeleteObject Bitblt Failed\n");
PMFR_BitBlt_cleanup:
                if (!DeleteDC(hSDC))
                    ASSERTGDI(FALSE, "PlayMetaFileRecord: DeleteDC BitBlt Failed\n");
            }
        }
        break;

        case (META_DIBBITBLT & 255):
        case (META_DIBSTRETCHBLT & 255):
        {
            HDC         hSDC;
            HANDLE      hBitmap;
            LPBITMAPINFOHEADER lpDIBInfo ;
            INT         delta = 0;
            HANDLE      hOldPal;

            /* if playing into another metafile, do direct copy */
            if (PlayIntoAMetafile(lpMR, hdc))
            {
                fStatus = TRUE;
                break;
            }

            if ((lpMR->rdSize - 3) == ((DWORD) magic >> 8))
            {
                hSDC = hdc;
                delta = 1;
            }
            else
            {
                LPMETARECORD lpMRtmp;

                // Make the bitmap info and bits dword aligned.  To do this,
                // lpMR has to fall on a non dword aligned even address so that
                // the bitmap info (&lpMR->rdParm[8] or &lpMR->rdParm[10]) and
                // the bitmap bits will fall on the dword aligned addresses.
                // Note that the size of the bitmap info is always a multiple
                // of 4.

                if (!(lpMRdup = (LPMETARECORD) LocalAlloc(LMEM_FIXED,
                        (UINT) lpMR->rdSize * sizeof(WORD) + sizeof(WORD))))
                    break;
                lpMRtmp = (LPMETARECORD) &((PWORD) lpMRdup)[1];
                RtlCopyMemory((PBYTE) lpMRtmp,
                              (PBYTE) lpMR,
                              (UINT)  lpMR->rdSize * sizeof(WORD));

                if (UseStretchDIB(hdc, magic, lpMRtmp))
                {
                    fStatus = TRUE;
                    break;
                }

                if (hSDC = CreateCompatibleDC(hdc))
                {
                    /* set up the memDC to have the same palette */
                    hOldPal = SelectPalette(hSDC, GetCurrentObject(hdc,OBJ_PAL), TRUE);

                    if (magic == META_DIBBITBLT)
                        lpDIBInfo = (LPBITMAPINFOHEADER)&lpMRtmp->rdParm[8];
                    else
                        lpDIBInfo = (LPBITMAPINFOHEADER)&lpMRtmp->rdParm[10];

                    /* now create the bitmap for the MemDC and fill in the bits */
                    /* the processing for old and new format of metafiles is
                            different here (till hBitmap is obtained) */

                    /* new metafile version */
                    hBitmap = CreateBitmapForDC (hdc,lpDIBInfo);

                    if (hBitmap)
                        hOldObject = SelectObject (hSDC, hBitmap) ;
                    else
                        goto PMFR_DIBBITBLT_cleanup;
                }
                else
                    break;
            }

            if (magic == META_DIBBITBLT)
                fStatus = BitBlt(hdc,
                            (int) (SHORT) lpMR->rdParm[7 + delta],
                            (int) (SHORT) lpMR->rdParm[6 + delta],
                            (int) (SHORT) lpMR->rdParm[5 + delta],
                            (int) (SHORT) lpMR->rdParm[4 + delta],
                            delta ? 0 : hSDC,
                            (int) (SHORT) lpMR->rdParm[3],
                            (int) (SHORT) lpMR->rdParm[2],
                            MAKELONG(lpMR->rdParm[0], lpMR->rdParm[1]));
            else
                fStatus = StretchBlt(hdc,
                            (int) (SHORT) lpMR->rdParm[9 + delta],
                            (int) (SHORT) lpMR->rdParm[8 + delta],
                            (int) (SHORT) lpMR->rdParm[7 + delta],
                            (int) (SHORT) lpMR->rdParm[6 + delta],
                            delta ? 0 : hSDC,
                            (int) (SHORT) lpMR->rdParm[5],
                            (int) (SHORT) lpMR->rdParm[4],
                            (int) (SHORT) lpMR->rdParm[3],
                            (int) (SHORT) lpMR->rdParm[2],
                            MAKELONG(lpMR->rdParm[0], lpMR->rdParm[1]));

            if (hSDC != hdc)
            {
                /* Deselect hDC's palette from memDC */
                SelectPalette(hSDC, hOldPal, TRUE);
                if (!SelectObject(hSDC, hOldObject))
                    ASSERTGDI(FALSE, "PlayMetaFileRecord: SelectObject DIBBitBlt Failed\n");
                if (!DeleteObject(hBitmap))
                    ASSERTGDI(FALSE, "PlayMetaFileRecord: DeleteObject(hBitmap) DIBBitBlt Failed\n");
PMFR_DIBBITBLT_cleanup:
                if (!DeleteDC(hSDC))
                    ASSERTGDI(FALSE, "PlayMetaFileRecord DeleteDC DIBBitblt failed\n");
            }
        }
        break;

        case (META_SELECTOBJECT & 255):
        {
            if (hObject = lpHandleTable->objectHandle[lpMR->rdParm[0]])
            {
                fStatus = SelectObject(hdc, hObject) != (HANDLE)0;

                // new in win3.1
                if (!fStatus)
                {
                    switch (GetObjectType(hObject))
                    {
                    case OBJ_PAL:
                        SelectObject(hdc, (HGDIOBJ) GetStockObject(DEFAULT_PALETTE));
                        break;
                    case OBJ_BRUSH:
                        SelectObject(hdc, (HGDIOBJ) GetStockObject(WHITE_BRUSH));
                        break;
                    case OBJ_PEN:
                        SelectObject(hdc, (HGDIOBJ) GetStockObject(BLACK_PEN));
                        break;
                    case OBJ_FONT:
                        SelectObject(hdc, (HGDIOBJ) GetStockObject(DEVICE_DEFAULT_FONT));
                        break;
                    case OBJ_REGION:
                        SelectClipRgn(hdc, 0);
                        break;
                    default:
                        ASSERTGDI(FALSE,
                            "PlayMetaFileRecord:SELECTOBJECT unknown object\n");
                        break;
                    }
                }
            }
        }
        break;

        case (META_CREATEPENINDIRECT & 255):
        {
            LOGPEN lp;

            LOGPEN32FROMLOGPEN16(&lp, (PLOGPEN16) &lpMR->rdParm[0]);
            if (hObject = CreatePenIndirect(&lp))
                fStatus = AddToHandleTable(lpHandleTable, hObject, noObjs);
        }
        break;

        case (META_CREATEFONTINDIRECT & 255):
        {
            LOGFONTA     lf;
            PLOGFONT16  plf16 = (PLOGFONT16) &lpMR->rdParm[0];
            CHAR        achCapString[LF_FACESIZE];

            LOGFONT32FROMLOGFONT16(&lf, (PLOGFONT16) &lpMR->rdParm[0]);

        // Capitalize the string for faster compares.

            lstrcpynA(achCapString, lf.lfFaceName, LF_FACESIZE);
            CharUpperBuffA(achCapString, LF_FACESIZE);

        // Here we are going to implement a bunch of Win 3.1 hacks rather
        // than contaminate the 32-bit engine.  These same hacks can be found
        // in WOW (in the CreateFont/CreateFontIndirect code).
        //
        // These hacks are keyed off the facename in the LOGFONTA.  String
        // comparisons have been unrolled for maximal performance.

        // Win 3.1 facename-based hack.  Some apps, like
        // Publisher, create a "Helv" font but have the lfPitchAndFamily
        // set to specify FIXED_PITCH.  To work around this, we will patch
        // the pitch field for a "Helv" font to be variable.

            // if ( !lstrcmp(achCapString, lpHelv) )

            if ( ((achCapString[0]  == 'H') &&
                  (achCapString[1]  == 'E') &&
                  (achCapString[2]  == 'L') &&
                  (achCapString[3]  == 'V') &&
                  (achCapString[4]  == '\0')) )
            {
                lf.lfPitchAndFamily |= ( (lf.lfPitchAndFamily & ~PITCH_MASK) | VARIABLE_PITCH );
            }
            else
            {
            // Win 3.1 hack for Legacy 2.0.  When a printer does not enumerate
            // a "Tms Rmn" font, the app enumerates and gets the LOGFONTA for
            // "Script" and then create a font with the name "Tms Rmn" but with
            // the lfCharSet and lfPitchAndFamily taken from the LOGFONTA for
            // "Script".  Here we will over the lfCharSet to be ANSI_CHARSET.

                // if ( !lstrcmp(achCapString, lpTmsRmn) )

                if ( ((achCapString[0]  == 'T') &&
                      (achCapString[1]  == 'M') &&
                      (achCapString[2]  == 'S') &&
                      (achCapString[3]  == ' ') &&
                      (achCapString[4]  == 'R') &&
                      (achCapString[5]  == 'M') &&
                      (achCapString[6]  == 'N') &&
                      (achCapString[7]  == '\0')) )
                {
                    lf.lfCharSet = ANSI_CHARSET;
                }
                else
                {
                // If the lfFaceName is "Symbol", "Zapf Dingbats", or "ZapfDingbats",
                // enforce lfCharSet to be SYMBOL_CHARSET.  Some apps (like Excel) ask
                // for a "Symbol" font but have the char set set to ANSI.  PowerPoint
                // has the same problem with "Zapf Dingbats".

                    //if ( !lstrcmp(achCapString, lpSymbol) ||
                    //     !lstrcmp(achCapString, lpZapfDingbats) ||
                    //     !lstrcmp(achCapString, lpZapf_Dingbats) )

                    if ( ((achCapString[0]  == 'S') &&
                          (achCapString[1]  == 'Y') &&
                          (achCapString[2]  == 'M') &&
                          (achCapString[3]  == 'B') &&
                          (achCapString[4]  == 'O') &&
                          (achCapString[5]  == 'L') &&
                          (achCapString[6]  == '\0')) ||

                         ((achCapString[0]  == 'Z') &&
                          (achCapString[1]  == 'A') &&
                          (achCapString[2]  == 'P') &&
                          (achCapString[3]  == 'F') &&
                          (achCapString[4]  == 'D') &&
                          (achCapString[5]  == 'I') &&
                          (achCapString[6]  == 'N') &&
                          (achCapString[7]  == 'G') &&
                          (achCapString[8]  == 'B') &&
                          (achCapString[9]  == 'A') &&
                          (achCapString[10] == 'T') &&
                          (achCapString[11] == 'S') &&
                          (achCapString[12] == '\0')) ||

                         ((achCapString[0]  == 'Z') &&
                          (achCapString[1]  == 'A') &&
                          (achCapString[2]  == 'P') &&
                          (achCapString[3]  == 'F') &&
                          (achCapString[4]  == ' ') &&
                          (achCapString[5]  == 'D') &&
                          (achCapString[6]  == 'I') &&
                          (achCapString[7]  == 'N') &&
                          (achCapString[8]  == 'G') &&
                          (achCapString[9]  == 'B') &&
                          (achCapString[10] == 'A') &&
                          (achCapString[11] == 'T') &&
                          (achCapString[12] == 'S') &&
                          (achCapString[13] == '\0')) )
                    {
                        lf.lfCharSet = SYMBOL_CHARSET;
                    }
                }
            }

            if (hObject = CreateFontIndirectA(&lf))
            {
                fStatus = AddToHandleTable(lpHandleTable, hObject, noObjs);
            }
        }
        break;

        case (META_CREATEPATTERNBRUSH & 255):
        {
            HANDLE       hBitmap;
            BITMAP       Bitmap;
            LPMETARECORD lpMRtmp;

            WARNING("PlayMetaFileRecord: obsolete META_CREATEPATTERNBRUSH record\n");

            // Make the bitmap bits dword aligned.  To do this,
            // lpMR has to fall on a non dword aligned even address so that
            // the bitmap bits (bmBits) will fall on the dword aligned address.

            if (!(lpMRdup = (LPMETARECORD) LocalAlloc(LMEM_FIXED,
                        (UINT) lpMR->rdSize * sizeof(WORD) + sizeof(WORD))))
                break;
            lpMRtmp = (LPMETARECORD) &((PWORD) lpMRdup)[1];
            RtlCopyMemory((PBYTE) lpMRtmp,
                          (PBYTE) lpMR,
                          (UINT)  lpMR->rdSize * sizeof(WORD));

            BITMAP32FROMBITMAP16(&Bitmap, (PBITMAP16) &lpMRtmp->rdParm[0]);
            // The magic number 18 is based on the IPBITMAP structure in win3.1
            Bitmap.bmBits = (PBYTE) &lpMRtmp->rdParm + sizeof(BITMAP16) + 18;

            if (hBitmap = CreateBitmapIndirect(&Bitmap))
            {
                if (hObject = CreatePatternBrush(hBitmap))
                    fStatus = AddToHandleTable(lpHandleTable, hObject, noObjs);

                if (!DeleteObject(hBitmap))
                    ASSERTGDI(FALSE, "PlayMetaFileRecord: DeleteObject(hBitmap) CreatePatternBrush Failed\n");
            }
        }
        break;

        case (META_DIBCREATEPATTERNBRUSH & 255):
        {
            HDC         hMemDC ;
            HANDLE      hBitmap;
            LPBITMAPINFOHEADER lpDIBInfo ;
            LPMETARECORD lpMRtmp;

            // Make the bitmap info and bits dword aligned.  To do this,
            // lpMR has to fall on a non dword aligned even address so that
            // the bitmap info (&lpMR->rdParm[2]) and
            // the bitmap bits will fall on the dword aligned addresses.
            // Note that the size of the bitmap info is always a multiple
            // of 4.

            if (!(lpMRdup = (LPMETARECORD) LocalAlloc(LMEM_FIXED,
                        (UINT) lpMR->rdSize * sizeof(WORD) + sizeof(WORD))))
                break;
            lpMRtmp = (LPMETARECORD) &((PWORD) lpMRdup)[1];
            RtlCopyMemory((PBYTE) lpMRtmp,
                          (PBYTE) lpMR,
                          (UINT)  lpMR->rdSize * sizeof(WORD));


            if (lpMRtmp->rdParm[0] == BS_PATTERN)
            {
                /* the address of the second paramter is the address of the DIB
                   header, extract it */
                lpDIBInfo = (LPBITMAPINFOHEADER) &lpMRtmp->rdParm[2];

                /* now create a device dependend bitmap compatible to the default
                   screen DC - hScreenDC and extract the bits from the DIB into it.
                    The following function does all these, and returns a HANDLE
                    to the device dependent BItmap. */

                /* we will use a dummy memory DC compatible to the screen DC */
                hMemDC = CreateCompatibleDC((HDC)NULL);

                if (!hMemDC)
                {
                    ERROR_ASSERT(FALSE, "PlayMetaRecord: CreateCompDC Failed\n");
                    break;
                }

                hBitmap = CreateBitmapForDC(hMemDC,lpDIBInfo);

                if (hBitmap)
                {
                    if (hObject = CreatePatternBrush(hBitmap))
                        fStatus = AddToHandleTable(lpHandleTable, hObject, noObjs);

                    if (!DeleteObject(hBitmap))
                        ASSERTGDI(FALSE, "PlayMetaFileRecord: DeleteObject(hBitmap) DIBCreatePatternBrush Failed\n");
                }

                /* delete the dummy memory DC for new version Metafiles*/
                if (!DeleteDC (hMemDC))
                    ASSERTGDI(FALSE, "PlayMetaRecord: DeleteDC DIBCreatePatternBrush Failed\n");
            }

            /* this is a DIBPattern brush */
            else
            {
                if (hObject = CreateDIBPatternBrushPt((LPVOID)&lpMRtmp->rdParm[2],
                                                      (DWORD) lpMRtmp->rdParm[1]))
                    fStatus = AddToHandleTable(lpHandleTable, hObject, noObjs);

            }
        }
        break;

        case (META_CREATEBRUSHINDIRECT & 255):
        {
            LOGBRUSH lb;

            LOGBRUSH32FROMLOGBRUSH16(&lb, (PLOGBRUSH16) &lpMR->rdParm[0]);
            if (hObject = CreateBrushIndirect(&lb))
                fStatus = AddToHandleTable(lpHandleTable, hObject, noObjs);
        }
        break;

        case (META_POLYLINE & 255):
        case (META_POLYGON & 255):
        {
            PPOINTL pptl;
            UINT    cpts = lpMR->rdParm[0];

            if (!(pptl = (PPOINTL) LocalAlloc
                                (LMEM_FIXED, (UINT) cpts * sizeof(POINTL))))
                break;

            INT32FROMINT16(pptl, &lpMR->rdParm[1], cpts * 2);

            switch (magic)
            {
            case META_POLYGON:
                fStatus = Polygon(hdc, (LPPOINT) pptl, (int) cpts);
                break;
            case META_POLYLINE:
                fStatus = Polyline(hdc, (LPPOINT) pptl, (int) cpts);
                break;
            default:
                ASSERTGDI(FALSE, "Bad record type");
                break;
            }

            if (LocalFree(pptl))
                ASSERTGDI(FALSE, "PlayMetaRecord: LocalFree failed\n");
        }
        break;

        case (META_POLYPOLYGON & 255):
        {
            PPOINTL pptl;
            LPINT   lpPolyCount;
            PBYTE   pb;
            UINT    ii;
            UINT    cpts  = 0;
            UINT    cPoly = lpMR->rdParm[0];

            for (ii = 0; ii < cPoly; ii++)
                cpts += ((LPWORD)&lpMR->rdParm[1])[ii];

            if (!(pb = (PBYTE) LocalAlloc
                        (
                            LMEM_FIXED,
                            cPoly * sizeof(INT) + cpts * sizeof(POINTL)
                        )
                 )
               )
                break;

            lpPolyCount = (LPINT) pb;
            pptl        = (PPOINTL) (pb + cPoly * sizeof(INT));

            for (ii = 0; ii < cPoly; ii++)
                lpPolyCount[ii] = (INT) (UINT) ((LPWORD)&lpMR->rdParm[1])[ii];

            INT32FROMINT16(pptl, &lpMR->rdParm[1] + cPoly, cpts * 2);

            fStatus = PolyPolygon(hdc, (LPPOINT) pptl, lpPolyCount, (int) cPoly);

            if (LocalFree((HANDLE) pb))
                ASSERTGDI(FALSE, "PlayMetaRecord: LocalFree failed\n");
        }
        break;

        case (META_EXTTEXTOUT & 255):
        {
            PSHORT      lpdx16;
            LPINT       lpdx;
            LPSTR       lpch;
            RECT        rc;
            LPRECT      lprc;

            lprc = (lpMR->rdParm[3] & (ETO_OPAQUE|ETO_CLIPPED))
                   ? (LPRECT) &lpMR->rdParm[4]
                   : (LPRECT) NULL;

            if (lprc)
            {
                rc.left   = ((PRECT16)lprc)->left;
                rc.right  = ((PRECT16)lprc)->right;
                rc.top    = ((PRECT16)lprc)->top;
                rc.bottom = ((PRECT16)lprc)->bottom;
                lprc = &rc;
            }

            lpch = (LPSTR)&lpMR->rdParm[4] + ((lprc) ?  sizeof(RECT16) : 0);

            /* dx array starts at next word boundary after char string */
            lpdx16 = (PSHORT) (lpch + ((lpMR->rdParm[2] + 1) / 2 * 2));

            /* check to see if there is a Dx array by seeing if
               structure ends after the string itself
            */
            if (((DWORD)((LPWORD)lpdx16 - (LPWORD)(lpMR))) >= lpMR->rdSize)
                lpdx = NULL;
            else
            {
                lpdx = (LPINT)LocalAlloc(LMEM_FIXED, lpMR->rdParm[2]*sizeof(INT));
                if (!lpdx)
                {
                    ERROR_ASSERT(FALSE, "PlayMetaFileRecord: out of memory exttextout");
                    break;
                }
                INT32FROMINT16(lpdx, lpdx16, (UINT) lpMR->rdParm[2]);
            }

            // Mask off bit 0x80 that an old Excel used to add to its
            // Metafiles and the GDI errors on.
            fStatus = ExtTextOutA(hdc,
                                  (int) (SHORT) lpMR->rdParm[1],
                                  (int) (SHORT) lpMR->rdParm[0],
                                  gbLpk ?
                                  ((UINT) lpMR->rdParm[3]) :
                                  ((UINT) lpMR->rdParm[3] & ~ETO_RTLREADING),
                                  lprc,
                                  lpch,
                                  (UINT) lpMR->rdParm[2],
                                  lpdx);

            if (lpdx)
                if (LocalFree((HANDLE)lpdx))
                    ASSERTGDI(FALSE, "PlayMetaRecord: LocalFree failed\n");
            break;
        }

        case (META_TEXTOUT & 255):
            fStatus = TextOutA(hdc,
                               (int) (SHORT) lpMR->rdParm[lpMR->rdSize-4],
                               (int) (SHORT) lpMR->rdParm[lpMR->rdSize-5],
                               (LPSTR) &lpMR->rdParm[1],
                               (int) (UINT) lpMR->rdParm[0]);
            break;

        case (META_ESCAPE & 255):
            if (!(fStatus = PlayIntoAMetafile(lpMR, hdc)))
            {
                if ((int)(UINT)lpMR->rdParm[0] != MFCOMMENT)
                {
                    fStatus = Escape(hdc,
                        (int) (UINT) lpMR->rdParm[0],
                            (int) (UINT) lpMR->rdParm[1],
                        (LPCSTR) &lpMR->rdParm[2],
                        (LPVOID) NULL) != 0;
                }
                else
                {
                    fStatus = TRUE;
                }
        }
            break;

        case (META_FRAMEREGION & 255):
            if ((hRgn = lpHandleTable->objectHandle[lpMR->rdParm[0]])
            && (hBrush = lpHandleTable->objectHandle[lpMR->rdParm[1]]))
                fStatus = FrameRgn(hdc,
                                   hRgn,
                                   hBrush,
                                   (int) (SHORT) lpMR->rdParm[3],
                                   (int) (SHORT) lpMR->rdParm[2]);
            break;

        case (META_PAINTREGION & 255):
            if (hRgn = lpHandleTable->objectHandle[lpMR->rdParm[0]])
                fStatus = PaintRgn(hdc, hRgn);
            break;

        case (META_INVERTREGION & 255):
            if (hRgn = lpHandleTable->objectHandle[lpMR->rdParm[0]])
                fStatus = InvertRgn(hdc, hRgn);
            break;

        case (META_FILLREGION & 255):
            if ((hRgn = lpHandleTable->objectHandle[lpMR->rdParm[0]])
            && (hBrush = lpHandleTable->objectHandle[lpMR->rdParm[1]]))
                fStatus = FillRgn(hdc, hRgn, hBrush);
            break;

/*
*** in win2, METACREATEREGION records contained an entire region object,
*** including the full header.  this header changed in win3.
***
*** to remain compatible, the region records will be saved with the
*** win2 header.  here we read a win2 header with region, and actually
*** create a win3 header with same region internals
*/

        case (META_CREATEREGION & 255):
        {
            HRGN        hrgn;
            PSHORT      pXs;
            PWIN3REGION pW3Rgn = (PWIN3REGION) lpMR->rdParm;
            UINT        ii, jj;
            UINT        cscn;
            PSCAN       pscn;
            DWORD       nrcl;
            PRECTL      prcl;
            UINT        cRgnData;
            PRGNDATA    pRgnData;

            cscn = (UINT) pW3Rgn->cScans;

            // Handle the empty region.

            if (!cscn)
            {
                hrgn = CreateRectRgn(0, 0, 0, 0);
                fStatus = AddToHandleTable(lpHandleTable, hrgn, noObjs);
                break;
            }

            // Count the number of rectangles in the region.

            nrcl = 0;
            pscn = pW3Rgn->aScans;
            for (ii = 0; ii < cscn; ii++)
            {
                nrcl += pscn->scnPntCnt / 2;
                pscn = (PSCAN) ((PBYTE) pscn
                                + sizeof(SCAN)
                                - 2 * sizeof(WORD)
                                + (int) (UINT) pscn->scnPntCnt * sizeof(WORD));
            }

            cRgnData = sizeof(RGNDATAHEADER) + nrcl * sizeof(RECTL);
            if (!(pRgnData = (PRGNDATA) LocalAlloc(LMEM_FIXED, cRgnData)))
                break;

            pRgnData->rdh.dwSize = sizeof(RGNDATAHEADER);
            pRgnData->rdh.iType  = RDH_RECTANGLES;
            pRgnData->rdh.nCount = nrcl;
            pRgnData->rdh.nRgnSize = 0;
            pRgnData->rdh.rcBound.left   = (LONG) pW3Rgn->rcBounding.left   ;
            pRgnData->rdh.rcBound.top    = (LONG) pW3Rgn->rcBounding.top    ;
            pRgnData->rdh.rcBound.right  = (LONG) pW3Rgn->rcBounding.right  ;
            pRgnData->rdh.rcBound.bottom = (LONG) pW3Rgn->rcBounding.bottom ;

            prcl = (PRECTL) pRgnData->Buffer;
            pscn = pW3Rgn->aScans;
            for (ii = 0; ii < cscn; ii++)
            {
                pXs = (PSHORT) pscn->scnPntsX;
                for (jj = pscn->scnPntCnt / 2; jj; jj--)
                {
                    prcl->left   = (LONG) (*pXs++);
                    prcl->top    = (LONG) (SHORT) pscn->scnPntTop;
                    prcl->right  = (LONG) (*pXs++);
                    prcl->bottom = (LONG) (SHORT) pscn->scnPntBottom;
                    prcl++;
                }
                pscn = (PSCAN) ((PBYTE) pscn
                                + sizeof(SCAN)
                                - 2 * sizeof(WORD)
                                + (int) (UINT) pscn->scnPntCnt * sizeof(WORD));
            }

            hrgn = ExtCreateRegion((LPXFORM) NULL, cRgnData, pRgnData);
            fStatus = AddToHandleTable(lpHandleTable, hrgn, noObjs);

            if (LocalFree((HANDLE) pRgnData))
                ASSERTGDI(FALSE, "PlayMetaRecord: LocalFree failed\n");
        }
        break;

        case (META_DELETEOBJECT & 255):
        {
            HANDLE h;

            if (h = lpHandleTable->objectHandle[lpMR->rdParm[0]])
            {
                if (!(fStatus = DeleteObject(h)))
                    ERROR_ASSERT(FALSE, "PlayMetaFileRecord: DeleteObject(h) Failed\n");
                lpHandleTable->objectHandle[lpMR->rdParm[0]] = NULL;
            }
        }
        break;

        case (META_CREATEPALETTE & 255):
        {
            LPMETARECORD lpMRtmp;

            // Make the logical palette dword aligned.  To do this,
            // lpMR has to fall on a non dword aligned even address so that
            // the logical palette (&lpMR->rdParm[0]) will fall on the
            // dword aligned address.

            if (!(lpMRdup = (LPMETARECORD) LocalAlloc(LMEM_FIXED,
                        (UINT) lpMR->rdSize * sizeof(WORD) + sizeof(WORD))))
                break;
            lpMRtmp = (LPMETARECORD) &((PWORD) lpMRdup)[1];
            RtlCopyMemory((PBYTE) lpMRtmp,
                          (PBYTE) lpMR,
                          (UINT)  lpMR->rdSize * sizeof(WORD));

            if (hObject = CreatePalette((LPLOGPALETTE)&lpMRtmp->rdParm[0]))
                fStatus = AddToHandleTable(lpHandleTable, hObject, noObjs);
        }
        break;

        case (META_SELECTPALETTE & 255):
            if (hPal = lpHandleTable->objectHandle[lpMR->rdParm[0]])
                fStatus = SelectPalette(hdc, hPal, 0) != 0;
            break;

        case (META_REALIZEPALETTE & 255):
            fStatus = RealizePalette(hdc) != -1;
            break;

        case (META_SETPALENTRIES & 255):
        case (META_ANIMATEPALETTE & 255):
        {
            LPMETARECORD lpMRtmp;

            // Make the palette entry array dword aligned.  To do this,
            // lpMR has to fall on a non dword aligned even address so that
            // the palette entry array (&lpMR->rdParm[2]) will fall on the
            // dword aligned address.

            if (!(lpMRdup = (LPMETARECORD) LocalAlloc(LMEM_FIXED,
                        (UINT) lpMR->rdSize * sizeof(WORD) + sizeof(WORD))))
                break;
            lpMRtmp = (LPMETARECORD) &((PWORD) lpMRdup)[1];
            RtlCopyMemory((PBYTE) lpMRtmp,
                          (PBYTE) lpMR,
                          (UINT)  lpMR->rdSize * sizeof(WORD));

            // we know the palette being set is the current palette
            if (magic == META_SETPALENTRIES)
                fStatus = SetPaletteEntries(GetCurrentObject(hdc,OBJ_PAL),
                                            (UINT) lpMRtmp->rdParm[0],
                                            (UINT) lpMRtmp->rdParm[1],
                                            (LPPALETTEENTRY)&lpMRtmp->rdParm[2]
                                           ) != 0;
            else
                fStatus = AnimatePalette(GetCurrentObject(hdc,OBJ_PAL),
                                         (UINT) lpMR->rdParm[0],
                                         (UINT) lpMR->rdParm[1],
                                         (LPPALETTEENTRY)&lpMR->rdParm[2]);
        }
        break;

        case (META_RESIZEPALETTE & 255):
            fStatus = ResizePalette(GetCurrentObject(hdc,OBJ_PAL),
                                    (UINT) lpMR->rdParm[0]);
            break;

        case (META_SETDIBTODEV & 255):
        {
            LPBITMAPINFOHEADER lpBitmapInfo;
            DWORD              ColorSize;
            LPMETARECORD       lpMRtmp;

            /* if playing into another metafile, do direct copy */
            if (PlayIntoAMetafile(lpMR, hdc))
            {
                fStatus = TRUE;
                break;
            }

            // Make the bitmap info and bits dword aligned.  To do this,
            // lpMR has to fall on a dword aligned address so that
            // the bitmap info (&lpMR->rdParm[9]) and
            // the bitmap bits will fall on the dword aligned addresses.
            // Note that the size of the bitmap info is always a multiple
            // of 4.

            if (!(lpMRdup = (LPMETARECORD) LocalAlloc(LMEM_FIXED,
                        (UINT) lpMR->rdSize * sizeof(WORD))))
                break;
            lpMRtmp = lpMRdup;
            RtlCopyMemory((PBYTE) lpMRtmp,
                          (PBYTE) lpMR,
                          (UINT)  lpMR->rdSize * sizeof(WORD));

            lpBitmapInfo = (LPBITMAPINFOHEADER)&(lpMRtmp->rdParm[9]);

            if (lpBitmapInfo->biBitCount == 16 || lpBitmapInfo->biBitCount == 32)
                ColorSize = 3 * sizeof(DWORD);
            else if (lpBitmapInfo->biClrUsed)
                ColorSize = lpBitmapInfo->biClrUsed *
                             (DWORD)(lpMRtmp->rdParm[0] == DIB_RGB_COLORS ?
                                    sizeof(RGBQUAD) :
                                    sizeof(WORD));
            else if (lpBitmapInfo->biBitCount == 24)
                ColorSize = 0;
            else
                ColorSize = (DWORD)(1 << lpBitmapInfo->biBitCount) *
                             (DWORD)(lpMRtmp->rdParm[0] == DIB_RGB_COLORS ?
                                    sizeof(RGBQUAD) :
                                    sizeof(WORD));
            ColorSize = (ColorSize + 3) / 4 * 4;  // make sure it is aligned

            ColorSize += lpBitmapInfo->biSize;

            fStatus = SetDIBitsToDevice(hdc,
                                        (int) (SHORT) lpMRtmp->rdParm[8],
                                        (int) (SHORT) lpMRtmp->rdParm[7],
                                        (DWORD) (int) (SHORT)lpMRtmp->rdParm[6],
                                        (DWORD) (int) (SHORT)lpMRtmp->rdParm[5],
                                        (int) (SHORT) lpMRtmp->rdParm[4],
                                        (int) (SHORT) lpMRtmp->rdParm[3],
                                        (UINT) lpMRtmp->rdParm[2],
                                        (UINT) lpMRtmp->rdParm[1],
                                        (PBYTE)(((PBYTE)lpBitmapInfo) + ColorSize),
                                        (LPBITMAPINFO) lpBitmapInfo,
                                        (DWORD) lpMRtmp->rdParm[0]
                                       ) != 0;
        }
        break;

        case (META_STRETCHDIB & 255):
        {
            LPBITMAPINFOHEADER lpBitmapInfo;
            DWORD              ColorSize;
            LPMETARECORD       lpMRtmp;

            /* if playing into another metafile, do direct copy */
            if (PlayIntoAMetafile(lpMR, hdc))
            {
                fStatus = TRUE;
                break;
            }

            // Make the bitmap info and bits dword aligned.  To do this,
            // lpMR has to fall on a dword aligned address so that
            // the bitmap info (&lpMR->rdParm[11]) and
            // the bitmap bits will fall on the dword aligned addresses.
            // Note that the size of the bitmap info is always a multiple
            // of 4.

            if (!(lpMRdup = (LPMETARECORD) LocalAlloc(LMEM_FIXED,
                        (UINT) lpMR->rdSize * sizeof(WORD))))
                break;
            lpMRtmp = lpMRdup;
            RtlCopyMemory((PBYTE) lpMRtmp,
                          (PBYTE) lpMR,
                          (UINT)  lpMR->rdSize * sizeof(WORD));

            //
            // rdsize is SIZEOF_METARECORDHEADER/sizeof(WORD) + cw;
            // where cw is from MF16_RecordDIBits (11)
            //
            if (lpMR->rdSize > SIZEOF_METARECORDHEADER/sizeof(WORD) + 11)
            {
               lpBitmapInfo = (LPBITMAPINFOHEADER)&(lpMRtmp->rdParm[11]);

               if (lpBitmapInfo->biBitCount == 16 || lpBitmapInfo->biBitCount == 32)
                   ColorSize = 3 * sizeof(DWORD);
               else if (lpBitmapInfo->biClrUsed)
                   ColorSize = lpBitmapInfo->biClrUsed *
                                (DWORD)(lpMRtmp->rdParm[2] == DIB_RGB_COLORS ?
                                       sizeof(RGBQUAD) :
                                       sizeof(WORD));
               else if (lpBitmapInfo->biBitCount == 24)
                   ColorSize = 0;
               else
                   ColorSize = (DWORD)(1 << lpBitmapInfo->biBitCount) *
                                (DWORD)(lpMRtmp->rdParm[2] == DIB_RGB_COLORS ?
                                       sizeof(RGBQUAD) :
                                       sizeof(WORD));
               ColorSize = (ColorSize + 3) / 4 * 4;  // make sure it is aligned

               ColorSize += lpBitmapInfo->biSize;

            }
            else
            {
               lpBitmapInfo = NULL;
            }

            fStatus = StretchDIBits(hdc,
                                    (int) (SHORT) lpMRtmp->rdParm[10],
                                    (int) (SHORT) lpMRtmp->rdParm[9],
                                    (int) (SHORT) lpMRtmp->rdParm[8],
                                    (int) (SHORT) lpMRtmp->rdParm[7],
                                    (int) (SHORT) lpMRtmp->rdParm[6],
                                    (int) (SHORT) lpMRtmp->rdParm[5],
                                    (int) (SHORT) lpMRtmp->rdParm[4],
                                    (int) (SHORT) lpMRtmp->rdParm[3],
                                    lpBitmapInfo ? (LPBYTE)(((PBYTE)lpBitmapInfo) + ColorSize) : NULL,
                                    (LPBITMAPINFO) lpBitmapInfo,
                                    (DWORD) lpMRtmp->rdParm[2],
                                    MAKELONG(lpMRtmp->rdParm[0], lpMRtmp->rdParm[1])
                                   ) != ERROR;
        }
        break;

// Function that have new parameters on WIN32
// Or have DWORDs that stayed DWORDs; all other INTs to DWORDs

        case (META_PATBLT & 255):
            fStatus = PatBlt(hdc,
                             (int) (SHORT) lpMR->rdParm[5],
                             (int) (SHORT) lpMR->rdParm[4],
                             (int) (SHORT) lpMR->rdParm[3],
                             (int) (SHORT) lpMR->rdParm[2],
                             MAKELONG(lpMR->rdParm[0], lpMR->rdParm[1]));
            break;

        case (META_MOVETO & 255):
            fStatus = MoveToEx(hdc, (int)(SHORT)lpMR->rdParm[1], (int)(SHORT)lpMR->rdParm[0], NULL);
            break;

        case (META_RESTOREDC & 255):
            fStatus = RestoreDC(hdc, (int)(SHORT)lpMR->rdParm[0]);
            break;

        case (META_SETBKCOLOR & 255):
            fStatus = SetBkColor(hdc, *(COLORREF UNALIGNED *)lpMR->rdParm) != CLR_INVALID;
            break;

        case (META_SETTEXTCOLOR & 255):
            fStatus = SetTextColor(hdc, *(COLORREF UNALIGNED *)lpMR->rdParm) != CLR_INVALID;
            break;

        case (META_SETPIXEL & 255):
            fStatus = SetPixel(hdc,
                               (int) (SHORT) lpMR->rdParm[3],
                               (int) (SHORT) lpMR->rdParm[2],
                               *(COLORREF UNALIGNED *) lpMR->rdParm
                              ) != CLR_INVALID;
            break;

        case (META_SETMAPPERFLAGS & 255):
            fStatus = SetMapperFlags(hdc, *(DWORD UNALIGNED *)lpMR->rdParm) != GDI_ERROR;
            break;

        case (META_FLOODFILL & 255):
            fStatus = FloodFill(hdc,
                                (int) (SHORT) lpMR->rdParm[3],
                                (int) (SHORT) lpMR->rdParm[2],
                                *(COLORREF UNALIGNED *) lpMR->rdParm);
            break;

        case (META_EXTFLOODFILL & 255):
            fStatus = ExtFloodFill(hdc,
                                   (int) (SHORT) lpMR->rdParm[4],
                                   (int) (SHORT) lpMR->rdParm[3],
                                   *(COLORREF UNALIGNED *) &lpMR->rdParm[1],
                                   (UINT) lpMR->rdParm[0]);
            break;

        case (META_SCALEWINDOWEXT & 255):
            fStatus = ScaleWindowExtEx(hdc,
                                       (int)(SHORT)lpMR->rdParm[3],
                                       (int)(SHORT)lpMR->rdParm[2],
                                       (int)(SHORT)lpMR->rdParm[1],
                                       (int)(SHORT)lpMR->rdParm[0],
                                       NULL);
            break;

        case (META_SCALEVIEWPORTEXT & 255):
            fStatus = ScaleViewportExtEx(hdc,
                                         (int)(SHORT)lpMR->rdParm[3],
                                         (int)(SHORT)lpMR->rdParm[2],
                                         (int)(SHORT)lpMR->rdParm[1],
                                         (int)(SHORT)lpMR->rdParm[0],
                                         NULL);
            break;

        case (META_SETWINDOWORG & 255):
            fStatus = SetWindowOrgEx(hdc,
                                     (int)(SHORT)lpMR->rdParm[1],
                                     (int)(SHORT)lpMR->rdParm[0],
                                     (LPPOINT) NULL);
            break;

        case (META_SETWINDOWEXT & 255):
            fStatus = SetWindowExtEx(hdc,
                                     (int)(SHORT)lpMR->rdParm[1],
                                     (int)(SHORT)lpMR->rdParm[0],
                                     (LPSIZE) NULL);
            break;

        case (META_SETVIEWPORTORG & 255):
            fStatus = SetViewportOrgEx(hdc,
                                       (int)(SHORT)lpMR->rdParm[1],
                                       (int)(SHORT)lpMR->rdParm[0],
                                       (LPPOINT) NULL);
            break;

        case (META_SETVIEWPORTEXT & 255):
            fStatus = SetViewportExtEx(hdc,
                                       (int)(SHORT)lpMR->rdParm[1],
                                       (int)(SHORT)lpMR->rdParm[0],
                                       (LPSIZE) NULL);
            break;

        case (META_OFFSETWINDOWORG & 255):
            fStatus = OffsetWindowOrgEx(hdc,
                                        (int)(SHORT)lpMR->rdParm[1],
                                        (int)(SHORT)lpMR->rdParm[0],
                                        (LPPOINT) NULL);
            break;

        case (META_OFFSETVIEWPORTORG & 255):
            fStatus = OffsetViewportOrgEx(hdc,
                                          (int)(SHORT)lpMR->rdParm[1],
                                          (int)(SHORT)lpMR->rdParm[0],
                                          (LPPOINT) NULL);
            break;

        case (META_SETTEXTCHAREXTRA & 255):
            fStatus = SetTextCharacterExtra(hdc, (int)(SHORT)lpMR->rdParm[0]) != 0x80000000;
            break;

        case (META_SETTEXTALIGN & 255):
            fStatus = SetTextAlign(hdc, (UINT)lpMR->rdParm[0]) != GDI_ERROR;
            break;

        case (META_SAVEDC & 255):
            fStatus = (SaveDC(hdc) != 0);
            break;

        case (META_SELECTCLIPREGION & 255):
            // Win3.1 has never got this right except when the handle is 0.
            hObject =  (lpMR->rdParm[0] == 0)
                        ? 0
                        : lpHandleTable->objectHandle[lpMR->rdParm[0]];
            fStatus = (SelectClipRgn(hdc, hObject) != RGN_ERROR);
            break;

        case (META_SETBKMODE & 255):
            fStatus = (SetBkMode(hdc, (int)(SHORT)lpMR->rdParm[0]) != 0);
            break;

        case (META_SETMAPMODE & 255):
            fStatus = (SetMapMode(hdc, (int)(SHORT)lpMR->rdParm[0]) != 0);
            break;

        case (META_SETLAYOUT & 255):
            fStatus = (SetLayout(hdc, (DWORD)lpMR->rdParm[0]) != GDI_ERROR);
            break;

        case (META_SETPOLYFILLMODE & 255):
            fStatus = (SetPolyFillMode(hdc, (int)(SHORT)lpMR->rdParm[0]) != 0);
            break;

        case (META_SETROP2 & 255):
            fStatus = (SetROP2(hdc, (int)(SHORT)lpMR->rdParm[0]) != 0);
            break;

        case (META_SETSTRETCHBLTMODE & 255):
            fStatus = (SetStretchBltMode(hdc, (int)(SHORT)lpMR->rdParm[0]) != 0);
            break;

        case (META_LINETO & 255):
            fStatus = LineTo(hdc,
                             (int)(SHORT)lpMR->rdParm[1],
                             (int)(SHORT)lpMR->rdParm[0]);
            break;

        case (META_OFFSETCLIPRGN & 255):
            fStatus = OffsetClipRgn(hdc,
                                    (int)(SHORT)lpMR->rdParm[1],
                                    (int)(SHORT)lpMR->rdParm[0]
                                   ) != RGN_ERROR;
            break;

        case (META_SETTEXTJUSTIFICATION & 255):
            fStatus = SetTextJustification(hdc,
                                           (int)(SHORT)lpMR->rdParm[1],
                                           (int)(SHORT)lpMR->rdParm[0]);
            break;

        case (META_ELLIPSE & 255):
            fStatus = Ellipse(hdc,
                              (int)(SHORT)lpMR->rdParm[3],
                              (int)(SHORT)lpMR->rdParm[2],
                              (int)(SHORT)lpMR->rdParm[1],
                              (int)(SHORT)lpMR->rdParm[0]);
            break;

        case (META_RECTANGLE & 255):
            fStatus = Rectangle(hdc,
                                (int)(SHORT)lpMR->rdParm[3],
                                (int)(SHORT)lpMR->rdParm[2],
                                (int)(SHORT)lpMR->rdParm[1],
                                (int)(SHORT)lpMR->rdParm[0]);
            break;

        case (META_EXCLUDECLIPRECT & 255):
            fStatus = ExcludeClipRect(hdc,
                                      (int)(SHORT)lpMR->rdParm[3],
                                      (int)(SHORT)lpMR->rdParm[2],
                                      (int)(SHORT)lpMR->rdParm[1],
                                      (int)(SHORT)lpMR->rdParm[0]
                                     ) != RGN_ERROR;
            break;

        case (META_INTERSECTCLIPRECT & 255):
            fStatus = IntersectClipRect(hdc,
                                        (int)(SHORT)lpMR->rdParm[3],
                                        (int)(SHORT)lpMR->rdParm[2],
                                        (int)(SHORT)lpMR->rdParm[1],
                                        (int)(SHORT)lpMR->rdParm[0]
                                       ) != RGN_ERROR;
            break;

        case (META_ROUNDRECT & 255):
            fStatus = RoundRect(hdc,
                                (int)(SHORT)lpMR->rdParm[5],
                                (int)(SHORT)lpMR->rdParm[4],
                                (int)(SHORT)lpMR->rdParm[3],
                                (int)(SHORT)lpMR->rdParm[2],
                                (int)(SHORT)lpMR->rdParm[1],
                                (int)(SHORT)lpMR->rdParm[0]
                               );
            break;

        case (META_ARC & 255):
            fStatus = Arc(hdc,
                          (int)(SHORT)lpMR->rdParm[7],
                          (int)(SHORT)lpMR->rdParm[6],
                          (int)(SHORT)lpMR->rdParm[5],
                          (int)(SHORT)lpMR->rdParm[4],
                          (int)(SHORT)lpMR->rdParm[3],
                          (int)(SHORT)lpMR->rdParm[2],
                          (int)(SHORT)lpMR->rdParm[1],
                          (int)(SHORT)lpMR->rdParm[0]
                         );
            break;

        case (META_CHORD & 255):
            fStatus = Chord(hdc,
                            (int)(SHORT)lpMR->rdParm[7],
                            (int)(SHORT)lpMR->rdParm[6],
                            (int)(SHORT)lpMR->rdParm[5],
                            (int)(SHORT)lpMR->rdParm[4],
                            (int)(SHORT)lpMR->rdParm[3],
                            (int)(SHORT)lpMR->rdParm[2],
                            (int)(SHORT)lpMR->rdParm[1],
                            (int)(SHORT)lpMR->rdParm[0]
                           );
            break;

        case (META_PIE & 255):
            fStatus = Pie(hdc,
                          (int)(SHORT)lpMR->rdParm[7],
                          (int)(SHORT)lpMR->rdParm[6],
                          (int)(SHORT)lpMR->rdParm[5],
                          (int)(SHORT)lpMR->rdParm[4],
                          (int)(SHORT)lpMR->rdParm[3],
                          (int)(SHORT)lpMR->rdParm[2],
                          (int)(SHORT)lpMR->rdParm[1],
                          (int)(SHORT)lpMR->rdParm[0]
                         );
            break;

        case (META_SETRELABS & 255):
            ERROR_ASSERT(FALSE, "PlayMetaFileRecord: unsupported META_SETRELABS record\n");
            fStatus = TRUE;
            break;

#if 0
        case (META_CREATEBITMAP & 255):
        case (META_CREATEBITMAPINDIRECT & 255):
        case (META_CREATEBRUSH & 255):
        case (META_ABORTDOC & 255):
        case (META_ENDPAGE & 255):
        case (META_ENDDOC & 255):
        case (META_RESETDC & 255):
        case (META_STARTDOC & 255):
        case (META_STARTPAGE & 255):
            // not created or playbacked on Win3.1!
            ASSERTGDI(FALSE, "PlayMetaFileRecord: unsupported record\n");
            fStatus = TRUE;
            break;
#endif // 0

    case 0:         // End of metafile record
        fStatus = TRUE;
            break;

        default:
            VERIFYGDI(FALSE, "PlayMetaFileRecord: unknown record\n");
 #if DBG
        DbgPrint("Record %lx pMFRecord %p magic %X\n", curRecord, lpMR, magic);
#endif
            fStatus = TRUE;
            break;

    } // switch (magic & 255)

    if (lpMRdup)
        if (LocalFree((HANDLE) lpMRdup))
            ASSERTGDI(FALSE, "LocalFree failed");

#if DBG
    if (!fStatus)
    {
        DbgPrint("PlayMetaFileRecord Record %lx pMFRecord %p magic %X\n", curRecord, lpMR, magic);
        ERROR_ASSERT(FALSE, "PlayMetaFileRecord Failing\n");
    }
#endif

    return(fStatus);
}

/****************************** Internal Function **************************\
* AddToHandleTable
*
* Adds an object to the metafile table of objects
*
*
\***************************************************************************/

BOOL AddToHandleTable(LPHANDLETABLE lpHandleTable, HANDLE hObject, UINT noObjs)
{
    UINT    ii;

    PUTS("AddToHandleTable\n");

    if (lpHandleTable == (LPHANDLETABLE) NULL)
    {
        ASSERTGDI(FALSE, "AddToHandleTable: lpHT is NULL\n");
        return(FALSE);
    }

    /* linear search through table for first open slot */
    for (ii = 0; ((lpHandleTable->objectHandle[ii] != NULL) && (ii < noObjs));
            ++ii);

    if (ii < noObjs)                     /* ok index */
    {
        lpHandleTable->objectHandle[ii] = hObject;
        return (TRUE);
    }
    else
    {
        ASSERTGDI(FALSE, "AddToHandleTable: Too many objects in table\n");
        return(FALSE);
    }
}

BOOL IsValidMetaHeader16(PMETAHEADER pMetaHeader)
{
    BOOL            status;

    PUTS("IsValidMetaHeader16\n");

    status = (
               (pMetaHeader->mtType == MEMORYMETAFILE ||
                pMetaHeader->mtType == DISKMETAFILE) &&
               (pMetaHeader->mtHeaderSize == (sizeof(METAHEADER)/sizeof(WORD))) &&
               ((pMetaHeader->mtVersion == METAVERSION300) ||
                   (pMetaHeader->mtVersion ==METAVERSION100))
             );

    ERROR_ASSERT(status, "IsValidMetaHeader16 is failing\n");

    return status;
}

/****************************** Internal Function **************************\
* CreateBitmapForDC (HDC hMemDC, LPBITMAPINFOHEADER lpDIBInfo)
*
* This routine takes a memory device context and a DIB bitmap, creates a
* compatible bitmap for the DC and fills it with the bits from the DIB
* converting to the device dependent format). The pointer to the DIB bits
* start immediately after the color table in the INFO header.
*
* The routine returns the handle to the bitmap with the bits filled in if
* everything goes well else it returns NULL.
\***************************************************************************/

HANDLE CreateBitmapForDC (HDC hMemDC, LPBITMAPINFOHEADER lpDIBInfo)
{
    HBITMAP hBitmap ;
    LPBYTE  lpDIBits ;

    PUTS("CreateBitmapForDC\n");

    ASSERTGDI(!((ULONG_PTR) lpDIBInfo & 0x3), "CreateBitmapForDC: dword alignment error\n");

    /* preserve monochrome if it started out as monochrome
    ** and check for REAL Black&white monochrome as opposed
    ** to a 2-color DIB
    */
    if (IsDIBBlackAndWhite(lpDIBInfo))
        hBitmap = CreateBitmap ((WORD)lpDIBInfo->biWidth,
                        (WORD)lpDIBInfo->biHeight,
                        1, 1, (LPBYTE) NULL);
    else
    /* otherwise, make a compatible bitmap */
        hBitmap = CreateCompatibleBitmap (hMemDC,
                    (WORD)lpDIBInfo->biWidth,
                    (WORD)lpDIBInfo->biHeight);

    if (!hBitmap)
        goto CreateBitmapForDCErr ;

    /* take a pointer past the header of the DIB, to the start of the color
       table */
    lpDIBits = (LPBYTE) lpDIBInfo + lpDIBInfo->biSize;

    /* take the pointer past the color table */
    lpDIBits += GetSizeOfColorTable (lpDIBInfo) ;

    /* get the bits from the DIB into the Bitmap */
    if (!SetDIBits (hMemDC, hBitmap, 0, (WORD)lpDIBInfo->biHeight,
                    lpDIBits, (LPBITMAPINFO)lpDIBInfo, DIB_RGB_COLORS))
    {
        if (!DeleteObject(hBitmap))
            ASSERTGDI(FALSE, "CreateBitmapForDC: DeleteObject(hBitmap) Failed\n");
        goto CreateBitmapForDCErr ;
    }

   /* return success */
   return (hBitmap) ;

CreateBitmapForDCErr:

   /* returm failure for function */
   return (NULL);
}


/****************************** Internal Function **************************\
* GetSizeOfColorTable (LPBITMAPINFOHEADER lpDIBInfo)
*
* Returns the number of bytes in the color table for the giving info header
*
\***************************************************************************/

WORD GetSizeOfColorTable (LPBITMAPINFOHEADER lpDIBInfo)
{
    PUTS("GetSizeOfColorTable\n");

    ASSERTGDI(!((ULONG_PTR) lpDIBInfo & 0x3), "GetSizeOfColorTable: dword alignment error\n");

    if (lpDIBInfo->biBitCount == 16 || lpDIBInfo->biBitCount == 32)
        return(3 * sizeof(DWORD));

    if (lpDIBInfo->biClrUsed)
        return((WORD)lpDIBInfo->biClrUsed * (WORD)sizeof(RGBQUAD));

    if (lpDIBInfo->biBitCount < 16)
        return((1 << lpDIBInfo->biBitCount) * sizeof(RGBQUAD));
    else
        return(0);
}

/***************************** Public Function ****************************\
* BOOL APIENTRY DeleteMetaFile(hmf)
*
* Frees a metafile handle.
*
* Effects:
*
\***************************************************************************/

BOOL APIENTRY DeleteMetaFile(HMETAFILE hmf)
{
    PMETAFILE16 pmf16;

    PUTS("DeleteMetaFile\n");

    pmf16 = GET_PMF16(hmf);
    if (pmf16 == NULL)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Free the metafile and its handle.

    vFreeMF16(pmf16);
    bDeleteHmf16(hmf);
    return(TRUE);
}

/***************************** Public Function ****************************\
* HMETAFILE APIENTRY GetMetaFileW(pszwFilename)
*
* Returns a metafile handle for a disk based metafile.
*
* Effects:
*
* History:
*  Fri May 15 14:11:22 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\***************************************************************************/

HMETAFILE GetMetaFileA(LPCSTR pszFileName)
{
    UINT  cch;
    WCHAR awch[MAX_PATH];

    cch = strlen(pszFileName)+1;

    if (cch > MAX_PATH)
    {
        ERROR_ASSERT(FALSE, "GetMetaFileA filename too long");
        GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
        return ((HMETAFILE)0);
    }
    vToUnicodeN(awch, MAX_PATH, pszFileName, cch);

    return (GetMetaFileW(awch));
}

HMETAFILE APIENTRY GetMetaFileW(LPCWSTR pwszFileName)
{
    PMETAFILE16 pmf16;
    HMETAFILE   hmf;

    PUTS("GetMetaFileW\n");

// Allocate and initialize a metafile.

    if (!(pmf16 = pmf16AllocMF16(0, 0, (PDWORD) NULL, (LPWSTR) pwszFileName)))
        return((HMETAFILE) 0);

    ASSERTGDI(pmf16->metaHeader.mtType == DISKMETAFILE,
        "GetMetaFileW: Bad mtType\n");

// Allocate a local handle.

    hmf = hmf16Create(pmf16);
    if (!hmf)
    {
        vFreeMF16(pmf16);
    }

// Return the metafile handle.

    return(hmf);
}

/***************************** Internal Function **************************\
* BOOL FAR PASCAL PlayIntoAMetafile
*
* if this record is being played into another metafile, simply record
* it into that metafile, without hassling with a real playing.
*
* Returns: TRUE if record was played (copied) into another metafile
*          FALSE if destination DC was a real (non-meta) DC
*
* Effects: ?
*
* Warnings: ?
*
\***************************************************************************/

BOOL PlayIntoAMetafile(LPMETARECORD lpMR, HDC hdcDest)
{
    PUTS("PlayIntoAMetafile\n");

    if (LO_TYPE(hdcDest) != LO_METADC16_TYPE)
        return(FALSE);

// If a metafile is retrieved with GetWinMetaFileBits, it may contain
// an embedded enhanced metafile.  Do not include the enhanced metafile
// if we are playing the metafile to another metafile.

    if (IS_META_ESCAPE_ENHANCED_METAFILE((PMETA_ESCAPE_ENHANCED_METAFILE) lpMR))
        return(TRUE);

    // the size is the same minus 3 words for the record header
    return(RecordParms(hdcDest, (DWORD)lpMR->rdFunction, (DWORD)lpMR->rdSize - 3,
            (LPWORD)&(lpMR->rdParm[0])));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\mfrec16.h ===
/******************************Module*Header*******************************\
* Module Name: MfRec16.h                                                   *
*									   *
* Definitions needed for client side recording of 16 bit metafiles.        *
*									   *
* Created: 14-Nov-1991                                                     *
* Author: John Colleran [johnc]                                            *
*									   *
* Copyright (c) 1991-1999 Microsoft Corporation				   *
\**************************************************************************/

BOOL MF16_RecordParms1(HDC hdc, WORD Func);
BOOL MF16_RecordParms2(HDC hdc, int parm2, WORD Func);
BOOL MF16_RecordParms3(HDC hdc, int parm2, int parm3, WORD Func);
BOOL MF16_RecordParms5(HDC hdc, int parm2, int parm3, int parm4, int parm5, WORD Func);
BOOL MF16_RecordParms7(HDC hdc, int parm2, int parm3, int parm4, int parm5, int parm6, int parm7, WORD Func);
BOOL MF16_RecordParms9(HDC hdc, int parm2, int parm3, int parm4, int parm5,
        int parm6, int parm7, int parm8, int parm9, WORD Func);

BOOL MF16_RecordParmsD(HDC hdc, DWORD d1, WORD Func);
BOOL MF16_RecordParmsWWD(HDC hdc, WORD w1, WORD w2, DWORD d3, WORD Func);
BOOL MF16_RecordParmsWWDW(HDC hdc, WORD w1, WORD w2, DWORD d3, WORD w4, WORD Func);
BOOL MF16_RecordParmsWWWWD(HDC hdc, WORD w1, WORD w2, WORD w3, WORD w4, DWORD d5, WORD Func);
BOOL MF16_RecordParmsPoly(HDC hdc, LPPOINT lpPoint, INT nCount, WORD Func);
BOOL MF16_DrawRgn(HDC hdc, HRGN hrgn, HBRUSH hBrush, INT cx, INT cy, WORD Func);

BOOL MF16_BitBlt(HDC hdcDest, int x, int y, int nWidth, int nHeight,
        HDC hdcSrc, int xSrc, int ySrc, DWORD rop);
BOOL MF16_DeleteObject(HANDLE h);
BOOL MF16_ExtTextOut(HDC hdc, INT x, INT y, UINT flOptions, CONST RECT *lpRect,
        LPCSTR lpString, INT nCount, CONST INT *lpDX, BOOL bUnicode);
BOOL MF16_PolyTextOut(HDC hdc, CONST POLYTEXTA *ppta, int cpta, BOOL bUnicode);
BOOL MF16_PolyPolygon(HDC hdc, CONST POINT *lpPoint, CONST INT *lpPolyCount, int nCount);
BOOL MF16_RealizePalette(HDC hdc);
BOOL MF16_ResizePalette(HPALETTE hPal, UINT nCount);
BOOL MF16_AnimatePalette(HPALETTE hpal, UINT iStart, UINT cEntries, CONST PALETTEENTRY *pPalEntries);
HANDLE MF16_SelectObject(HDC hdc, HANDLE h);
BOOL MF16_SelectClipRgn(HDC hdc, HRGN hrgn, int iMode);
BOOL MF16_SelectPalette(HDC hdc, HPALETTE hpal);
BOOL MF16_StretchBlt(HDC hdcDest, int x, int y, int nWidth, int nHeight,
        HDC hdcSrc, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, DWORD rop);
BOOL MF16_TextOut(HDC hdc, INT x, INT y, LPCSTR lpString, int nCount, BOOL bUnicode);
BOOL MF16_RecordDIBits(HDC hdcDst, int xDst, int yDst, int cxDst, int cyDst,
    int xDib, int yDib, int cxDib, int cyDib, DWORD iStartScan, DWORD cScans,
    DWORD cbBitsDib, CONST VOID * pBitsDib, DWORD cbBitsInfoDib, CONST BITMAPINFO *pBitsInfoDib, 
    DWORD iUsageDib, DWORD rop, DWORD mrType);
BOOL MF16_Escape(HDC hdc, int nEscape, int nCount, LPCSTR lpInData, LPVOID lpOutData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\nlsconv.h ===
/******************************Module*Header*******************************\
* Module Name: nlsconv.h
*
* Created: 08-Sep-1991 14:01:23
* Author: Bodin Dresevic [BodinD]
* 02-Feb-1993 00:32:35
* Copyright (c) 1991-1999 Microsoft Corporation.
*
* (General description of its use)
*
\**************************************************************************/


#include "winuserp.h"   // nls conversion routines
#include <crt\stdlib.h>      // c rtl library include file off of nt\public\sdk\inc

/******************************Public*Macro******************************\
* bToASCIIN(pszDst, cch, pwszSrc, cwch)
*
* Calls the Rtl function that convert multi-byte ANSI to Unicode via
* the current codepage.  Note that this macro does not guarantee a
* terminating NULL for the destination.
*
* Returns:
*   TRUE if converted successfully, FALSE otherwise.
*
\**************************************************************************/

#define bToASCII_N(pszDst, cch, pwszSrc, cwch)                          \
    (                                                                   \
        NT_SUCCESS(RtlUnicodeToMultiByteN((PCH)(pszDst), (ULONG)(cch),  \
              (PULONG)NULL,(PWSZ)(pwszSrc), (ULONG)((cwch)*sizeof(WCHAR))))     \
    )


/******************************Public*Macro******************************\
* vToUnicodeN(awchDst, cwchDst, achSrc, cchSrc)
*
* Calls the Rtl function that convert Unicode to multi-byte ANSI via
* the current codepage.  Note that this macro does not guarantee a
* terminating NULL for the destination.
*
* Returns:
*   Nothing.  Should not be able to fail.
*
\**************************************************************************/

#if DBG
#define vToUnicodeN( awchDst, cwchDst, achSrc, cchSrc )                 \
    {                                                                   \
        NTSTATUS st =                                                   \
        RtlMultiByteToUnicodeN(                                         \
            (PWSZ)(awchDst),(ULONG)((cwchDst)*sizeof(WCHAR)),           \
            (PULONG)NULL,(PSZ)(achSrc),(ULONG)(cchSrc));                        \
                                                                        \
        ASSERTGDI(NT_SUCCESS(st),                                       \
            "gdi32!vToUnicodeN(MACRO): Rtl func. failed\n");            \
    }
#else
#define vToUnicodeN( awchDst, cwchDst, achSrc, cchSrc )                 \
    {                                                                   \
        RtlMultiByteToUnicodeN(                                         \
            (PWSZ)(awchDst),(ULONG)((cwchDst)*sizeof(WCHAR)),           \
            (PULONG)NULL,(PSZ)(achSrc),(ULONG)(cchSrc));                        \
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\nlsconv.c ===
/******************************Module*Header*******************************\
* Module Name: nlsconv.c                                                   *
*                                                                          *
* NLS conversion routines.                                                 *
*                                                                          *
* Created: 08-Sep-1991 15:56:30                                            *
* Author: Bodin Dresevic [BodinD]                                          *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

/******************************Public*Routine******************************\
* bGetANSISetMap                                                           *
*                                                                          *
* Tries to get a simple translation table from ANSI to UNICODE.  Returns   *
* TRUE on success.  Sets the gbDBCSCodePage flag if it thinks the char set *
* MIGHT be DBCS.                                                           *
*                                                                          *
*                                                                          *
*  Mon 11-Jan-1993 14:13:34 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.  I'm clearly assuming that by the time this is called, the     *
* char set is well defined, and will not change.                           *
\**************************************************************************/

WCHAR *gpwcANSICharSet = NULL;
WCHAR *gpwcDBCSCharSet = NULL;

BOOL bGetANSISetMap()
{
    CHAR     ch[256];
    ULONG    *pul;
    ULONG    ii,jj;
    NTSTATUS st;
    ULONG    cjResult;
    WCHAR   *pwc;
    WCHAR    *pwcSBC;

// See if we know the answers already.  (The client should not have called!)

    if (gpwcANSICharSet != (WCHAR *) NULL)
        return(TRUE);

// Create a mapping.

// Make an ANSI source char set.  This funny way of initialization takes
// about 180 instructions to execute rather than over 1000.

    pul = (ULONG *) ch;

    for (ii=0x03020100L,jj=0; jj<64; jj+=4)
    {
        pul[jj+0] = ii;
        ii += 0x04040404L;
        pul[jj+1] = ii;
        ii += 0x04040404L;
        pul[jj+2] = ii;
        ii += 0x04040404L;
        pul[jj+3] = ii;
        ii += 0x04040404L;
    }

// Allocate the UNICODE buffer but don't write the pointer in until the
// table is valid, in case we're racing another thread.

    pwc = LOCALALLOC(512 * sizeof(WCHAR));
    pwcSBC = &pwc[256];
    
    if (pwc == (WCHAR *) NULL)
        return(FALSE);

// Convert the characters.

    pwc[0] = 0;
    st = RtlMultiByteToUnicodeN
         (
            &pwc[1],                // OUT PWCH UnicodeString
            255 * sizeof(WCHAR),    // IN ULONG MaxBytesInUnicodeString
            &cjResult,              // OUT PULONG BytesInUnicodeString
            &ch[1],                 // IN PCH MultiByteString
            255                     // IN ULONG BytesInMultiByteString
         );

    if( !NT_SUCCESS(st) )
    {
    // Clean up and forget about accelerations.

        WARNING("GDI32: RtlMultiByteToUnicodeN error.");
        LOCALFREE(pwc);
        return(FALSE);
    }

    if( cjResult != 255 * sizeof(WCHAR) )
    {
    // There must be a DBCS code page so gpwcANSIMap takes on new meaning.
    // It is used for fonts with ANSI,OEM, and SYMBOL charsets.  Also,
    // another table, gpwcDBCS is constructed that is used to map the SBCS
    // of SHIFT-JIS fonts.

        WARNING("GDI32:Assuming DBCS code page.\n");

        st = MultiByteToWideChar
             (
                1252,       // code page to use
                0,          // flags
                &ch[1],     // characters to translate
                255,        // number of multibyte characters
                &pwc[1],    // unicode values of characters
                255         // number of wide characters
             );

        if( !NT_SUCCESS(st) )
        {
        // Clean up and forget about accelerations.

            WARNING("GDI32: MultiByteToWideChar error.");
            LOCALFREE(pwc);
            return(FALSE);
        }

    // Okay now make a table for SBC bytes.  Mark DBCS lead bytes
    // with 0xFFFF.

        for( jj = 0; jj < 256; jj++ )
        {
            if( IsDBCSLeadByte( (UCHAR)jj ))
            {
                pwcSBC[jj] = (WCHAR) 0xFFFF;
            }
            else
            {
                st = RtlMultiByteToUnicodeN
                     (
                        &pwcSBC[jj],
                        sizeof(WCHAR),
                        &cjResult,
                        &ch[jj],
                        1
                     );

                if( !NT_SUCCESS(st) )
                {
                    WARNING("GDI32: RtlMultByteToUnicodeN error.");
                    LOCALFREE(pwc);
                    return(FALSE);
                }

            }
        }

    }

// The table is good, jam it in.  Watch out for another thread running this
// routine simultaneously.

    ENTERCRITICALSECTION(&semLocal);
    {
        if (gpwcANSICharSet == (WCHAR *) NULL)
        {
            gpwcANSICharSet = pwc;
            gpwcDBCSCharSet = pwcSBC;
            pwc = (WCHAR *) NULL;
        }
    }
    LEAVECRITICALSECTION(&semLocal);

// If we collided with another thread, clean up our extra space.

    if (pwc != (WCHAR *) NULL)
        LOCALFREE(pwc);

// At this point we have a valid mapping.

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\object.c ===
/******************************Module*Header*******************************\
* Module Name: object.c                                                    *
*                                                                          *
* GDI client side stubs which deal with object creation and deletion.      *
*                                                                          *
* Created: 30-May-1991 21:56:51                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

extern PGDIHANDLECACHE pGdiHandleCache;

ULONG gLoHandleType[GDI_CACHED_HADNLE_TYPES] = {
                LO_BRUSH_TYPE  ,
                LO_PEN_TYPE    ,
                LO_REGION_TYPE ,
                LO_FONT_TYPE
                };

ULONG gHandleCacheSize[GDI_CACHED_HADNLE_TYPES] = {
                CACHE_BRUSH_ENTRIES ,
                CACHE_PEN_ENTRIES   ,
                CACHE_REGION_ENTRIES,
                CACHE_LFONT_ENTRIES
                };

ULONG gCacheHandleOffsets[GDI_CACHED_HADNLE_TYPES] = {
                                                        0,
                                                        CACHE_BRUSH_ENTRIES,
                                                        (
                                                            CACHE_BRUSH_ENTRIES +
                                                            CACHE_PEN_ENTRIES
                                                        ),
                                                        (
                                                            CACHE_BRUSH_ENTRIES +
                                                            CACHE_PEN_ENTRIES   +
                                                            CACHE_PEN_ENTRIES
                                                        )
                                                      };

/******************************Public*Routine******************************\
* hGetPEBHandle
*
*   Try to allocate a handle from the PEB handle cache
*
* Aruguments:
*
*   HandleType - type of cached handle to allocate
*
* Return Value:
*
*   handle or NULL if none available
*
* History:
*
*    31-Jan-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

HANDLE
hGetPEBHandle(
   HANDLECACHETYPE HandleType,
   ULONG           lbColor
   )
{
    HANDLE     hret = NULL;
    BOOL       bStatus;
    PBRUSHATTR pBrushattr;
    OBJTYPE    ObjType = BRUSH_TYPE;

#if !defined(_GDIPLUS_)

    ASSERTGDI(
               (
                (HandleType == BrushHandle) ||
                (HandleType == PenHandle) ||
                (HandleType == RegionHandle) ||
                (HandleType == LFontHandle)
               ),
               "hGetPEBHandle: illegal handle type");


    if (HandleType == RegionHandle)
    {
        ObjType = RGN_TYPE;
    }

    LOCK_HANDLE_CACHE(pGdiHandleCache,NtCurrentTeb(),bStatus);

    if (bStatus)
    {
        //
        // is a handle of the requested type available
        //

        if (pGdiHandleCache->ulNumHandles[HandleType] > 0)
        {
            ULONG   Index = gCacheHandleOffsets[HandleType];
            KHANDLE *pHandle,*pMaxHandle;

            //
            // calc starting index of handle type in PEB,
            // convert to address for faster linear search
            //

            pHandle = &(pGdiHandleCache->Handle[Index]);
            pMaxHandle = pHandle + gHandleCacheSize[HandleType];

            //
            // search PEB for non-NULL handle of th correct type
            //

            while (pHandle != pMaxHandle)
            {
                if (*pHandle != NULL)
                {
                    hret = *pHandle;

                    ASSERTGDI((gLoHandleType[HandleType] == LO_TYPE((ULONG_PTR)hret)),
                               "hGetPEBHandle: handle LO_TYPE mismatch");

                    *pHandle = NULL;
                    pGdiHandleCache->ulNumHandles[HandleType]--;

                    PSHARED_GET_VALIDATE(pBrushattr,hret,ObjType);

                    //
                    // setup the fields
                    //

                    if (
                        (pBrushattr) &&
                        ((pBrushattr->AttrFlags & (ATTR_CACHED | ATTR_TO_BE_DELETED | ATTR_CANT_SELECT))
                         == ATTR_CACHED)
                       )
                    {
                        //
                        // set brush flag which indicates this brush
                        // has never been selected into a dc. if this flag
                        // is still set in deleteobject then it is ok to
                        // put the brush on the teb.
                        //

                        pBrushattr->AttrFlags &= ~ATTR_CACHED;

                        if ((HandleType == BrushHandle) && (pBrushattr->lbColor != lbColor))
                        {
                            pBrushattr->AttrFlags |= ATTR_NEW_COLOR;
                            pBrushattr->lbColor = lbColor;
                        }
                    }
                    else
                    {
                        //
                        // Bad brush on PEB
                        //

                        WARNING ("pBrushattr == NULL, bad handle on TEB/PEB! \n");

                        //DeleteObject(hbr);

                        hret = NULL;
                    }

                    break;
                }

                pHandle++;
            }
        }

        UNLOCK_HANDLE_CACHE(pGdiHandleCache);
    }

#endif

    return(hret);
}

/******************************Public*Routine******************************\
* GdiPlayJournal
*
* Plays a journal file to an hdc.
*
* History:
*  31-Mar-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL WINAPI GdiPlayJournal
(
HDC hDC,
LPWSTR pwszName,
DWORD iStart,
DWORD iEnd,
int   iDeltaPriority
)
{
    WARNING("GdiPlayJournalCalled but no longer implemented\n");
    return(FALSE);
}


/******************************Public*Routine******************************\
* gdiPlaySpoolStream
*
* Stub of Chicago version of GdiPlayJournal
*
* History:
*  4-29-95 Gerrit van Wingerden
* Wrote it.
\**************************************************************************/


HDC gdiPlaySpoolStream(
   LPSTR lpszDevice,
   LPSTR lpszOutput,
   LPSTR lpszSpoolFile,
   DWORD JobId,
   LPDWORD lpcbBuf,
   HDC hDC )
{
    USE(lpszDevice);
    USE(lpszOutput);
    USE(lpszSpoolFile);
    USE(JobId);
    USE(lpcbBuf);
    USE(hDC);

    GdiSetLastError(ERROR_CALL_NOT_IMPLEMENTED);

    return(hDC);

}

/******************************Public*Routine******************************\
*
* History:
*  08-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

NTSTATUS
PrinterQueryRoutine
(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
)
{
    //
    // If the context value is NULL, then store the length of the value.
    // Otherwise, copy the value to the specified memory.
    //

    if (Context == NULL)
    {
        *(PULONG)EntryContext = ValueLength;
    }
    else
    {
        RtlCopyMemory(Context, ValueData, (int)ValueLength);
    }

    return(STATUS_SUCCESS);
}


/******************************Public*Routine******************************\
* pdmwGetDefaultDevMode()
*
* History:
*  08-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PDEVMODEW pdmwGetDefaultDevMode(
    HANDLE          hSpooler,
    PUNICODE_STRING pustrDevice,    // device name
    PVOID          *ppvFree         // *ppvFree must be freed by the caller
    )
{
    PDEVMODEW pdmw = NULL;
    int       cj;
    PWSZ      pwszDevice = pustrDevice ? pustrDevice->Buffer : NULL;

// see if we found it in the registry.  If not, we need to get the default from
// the spooler.

    cj = 0;

    (*fpGetPrinterW)(hSpooler,2,NULL,0,&cj);

    if (cj && (*ppvFree = LOCALALLOC(cj)))
    {
    // we've loaded the spooler, gotten a spooler handle, gotten the size,
    // and allocated the buffer.  Now lets get the data.

        if ((*fpGetPrinterW)(hSpooler,2,*ppvFree,cj,&cj))
        {
            pdmw = ((PRINTER_INFO_2W *)*ppvFree)->pDevMode;
        }
        else
        {
            LOCALFREE(*ppvFree);
            *ppvFree = NULL;
        }
    }

    return(pdmw);
}


/******************************Public*Routine******************************\
* hdcCreateDCW                                                             *
*                                                                          *
* Client side stub.  Allocates a client side LDC as well.                  *
*                                                                          *
* Note that it calls the server only after all client side stuff has       *
* succeeded, we don't want to ask the server to clean up.                  *
*                                                                          *
* History:                                                                 *
*  Sat 01-Jun-1991 16:13:22 -by- Charles Whitmer [chuckwh]                 *
*  8-18-92 Unicode enabled and combined with CreateIC                      *
* Wrote it.                                                                *
\**************************************************************************/

HDC hdcCreateDCW(
    PUNICODE_STRING pustrDevice,
    PUNICODE_STRING pustrPort,
    CONST DEVMODEW *pdm,
    BOOL            bDisplay,
    BOOL            bIC
)
{
    HDC       hdc      = NULL;
    PLDC      pldc     = NULL;
    PVOID     pvFree   = NULL;
    PWSZ      pwszPort = NULL;
    HANDLE    hSpooler = NULL;
    PUMPD     pUMPD    = NULL;
    PDEVMODEW pdmAlt   = NULL;
    PRINTER_DEFAULTSW defaults;
    KERNEL_PUMDHPDEV pUMdhpdev = NULL;
    BOOL      bDocEvent = FALSE;

    //
    // if it is not the display...
    //

    if (!bDisplay)
    {
        //
        // quick out if pustrDevice is NULL
        //

        if (pustrDevice == (PUNICODE_STRING)NULL)
        {
            return((HDC)NULL);
        }

        // Load the spooler and get a spool handle

        if (BLOADSPOOLER)
        {

            // Open the printer with the default data type.  When we do
            // a StartDoc we will then try to to a StartDocPrinter with data type
            // EMF if that suceeds will will mark the DC as an EMF dc.  Othewise
            // we will try again, this time doing a StartDocPrinter with data type
            // raw

            defaults.pDevMode = (LPDEVMODEW) pdm;
            defaults.DesiredAccess = PRINTER_ACCESS_USE;
            defaults.pDatatype = L"RAW";

            // open the spooler and note if it is spooled or not

            (*fpOpenPrinterW)((LPWSTR)pustrDevice->Buffer,&hSpooler,&defaults);

            if (hSpooler)
            {
                // Load user-mode printer driver, if applicable

                if (! LoadUserModePrinterDriver(hSpooler,  (LPWSTR) pustrDevice->Buffer, &pUMPD, &defaults))
                    goto MSGERROR;

                // and we don't have a devmode yet, try to get one.

                if (pdm == NULL)
                {
                    pdm = pdmwGetDefaultDevMode(hSpooler,pustrDevice,&pvFree);
                }


                // now see if we need to call DocumentEvent

                if (fpDocumentEvent)
                {
                    int      iDocEventRet;
                    DOCEVENT_CREATEDCPRE    docEvent;

                    docEvent.pszDriver = 0;
                    docEvent.pszDevice = pustrDevice->Buffer;
                    docEvent.pdm = (PDEVMODEW)pdm;
                    docEvent.bIC = bIC;

                    iDocEventRet = DocumentEventEx(pUMPD,
                                                   hSpooler,
                                                   0,
                                                   DOCUMENTEVENT_CREATEDCPRE,
                                                   sizeof(docEvent),
                                                   (PVOID)&docEvent,
                                                   sizeof(pdmAlt),
                                                   (PVOID)&pdmAlt);
                    
                    if (iDocEventRet == DOCUMENTEVENT_FAILURE)
                    {
                        goto MSGERROR;
                    }
                    
                    bDocEvent = TRUE;

                    if (pdmAlt)
                        pdm = pdmAlt;
                }
            }
        }
    }

    hdc = NtGdiOpenDCW(pustrDevice,
                       (PDEVMODEW)pdm,
                       pustrPort,
                       (ULONG)bIC ? DCTYPE_INFO : DCTYPE_DIRECT,
                       (pUMPD == NULL) ? NULL : hSpooler,
                       (pUMPD == NULL) ? NULL : pUMPD->pDriverInfo2,
                       &pUMdhpdev);

    if (hdc)
    {
        //
        // The only way it could be an ALTDC at this point is to be a
        // printer DC
        //

        if (IS_ALTDC_TYPE(hdc) && hSpooler)
        {
            pldc = pldcCreate(hdc,LO_DC);

            if (!pldc)
            {
                goto MSGERROR;
            }

            // Need to save DEVMODE in client side for later use.

            if (pdm)
            {
                ULONG cjDevMode = pdm->dmSize + pdm->dmDriverExtra;

                pldc->pDevMode = (DEVMODEW*) LOCALALLOC(cjDevMode);

                if (pldc->pDevMode == NULL)
                {
                    goto MSGERROR;
                }

                // Validate DEVMMODE, then copy to buffer.

                if ((pdm->dmSize >= offsetof(DEVMODEW,dmDuplex)) &&
                    (pdm->dmFields & DM_COLOR) &&
                    (pdm->dmColor == DMCOLOR_MONOCHROME))
                {
                    // if devmode says, this is monochrome mode, we don't need to
                    // validate devmode since this validation is for ICM which
                    // only needs for color case. Just copy whatever apps gives us.

                    RtlCopyMemory( (PBYTE) pldc->pDevMode, (PBYTE) pdm, cjDevMode );
                }
                else if ((*fpDocumentPropertiesW)
                            (NULL,hSpooler,
                             (LPWSTR) pdm->dmDeviceName,
                             pldc->pDevMode,  // output devmode
                             (PDEVMODEW) pdm, // input devmode
                             DM_IN_BUFFER |
                             DM_OUT_BUFFER) != IDOK)
                {
                    // if error, just copy original

                    RtlCopyMemory( (PBYTE) pldc->pDevMode, (PBYTE) pdm, cjDevMode );
                }
            }

            pldc->hSpooler = hSpooler;
            pldc->pUMPD = pUMPD;
            pldc->pUMdhpdev = pUMdhpdev;

            //
            // if the UMPD driver is first loaded
            // and no one has set either the METAFILE_DRIVER nor the NON_METAFILE_DRIVER flag,
            // set it here
            //

            if (pUMPD)
            {
               if (!(pldc->pUMPD->dwFlags & UMPDFLAG_NON_METAFILE_DRIVER)
                   && !(pldc->pUMPD->dwFlags & UMPDFLAG_METAFILE_DRIVER))
               {
                  ULONG InData = METAFILE_DRIVER;

                  if (ExtEscape(hdc,QUERYESCSUPPORT,sizeof(ULONG),(LPCSTR)&InData,0,NULL))
                  {
                     pldc->pUMPD->dwFlags |= UMPDFLAG_METAFILE_DRIVER;
                  }
                  else
                  {
                     pldc->pUMPD->dwFlags |= UMPDFLAG_NON_METAFILE_DRIVER;
                  }
               }
            }

            // remember if it is an IC

            if (bIC)
                pldc->fl |= LDC_INFO;

            // Initialize ICM stuff for this DC.
            //
            // (if pdem is substituted by DrvDocumentEvent,
            //  use the substituted devmode).

            IcmInitLocalDC(hdc,hSpooler,pdm,FALSE);

            // got to save the port name for StartDoc();

            if (pustrPort)
            {
                int cj = pustrPort->Length + sizeof(WCHAR);

                pldc->pwszPort = (LPWSTR)LOCALALLOC(cj);

                if (pldc->pwszPort)
                    memcpy(pldc->pwszPort,pustrPort->Buffer,cj);
            }

            // we need to do the CREATEDCPOST document event

            DocumentEventEx(pldc->pUMPD,
                    hSpooler,
                    hdc,
                    DOCUMENTEVENT_CREATEDCPOST,
                    sizeof(pdmAlt),
                    (PVOID)&pdmAlt,
                    0,
                    NULL);
        }
        else
        {
            // Initialize ICM stuff for this DC.

            IcmInitLocalDC(hdc,NULL,pdm,FALSE);

            if (pwszPort)
                LOCALFREE(pwszPort);
        }

    }
    else
    {
    // Handle errors.

    MSGERROR:
        if (hSpooler)
        {
            if (bDocEvent)
            {
                DocumentEventEx(pUMPD,
                                hSpooler,
                                0,
                                DOCUMENTEVENT_CREATEDCPOST,
                                sizeof(pdmAlt),
                                (PVOID)&pdmAlt,
                                0,
                                NULL);

            }

            if (pUMPD)
                UnloadUserModePrinterDriver(pUMPD, TRUE, hSpooler);

            (*fpClosePrinter)(hSpooler);
        }

        if (pwszPort)
            LOCALFREE(pwszPort);

        if (pldc)
            bDeleteLDC(pldc);

        if (hdc)
            NtGdiDeleteObjectApp(hdc);

        hdc = (HDC)0;
    }

    if (pvFree != NULL)
    {
        LOCALFREE(pvFree);
    }

    return(hdc);
}

/******************************Public*Routine******************************\
* bCreateDCW                                                               *
*                                                                          *
* Client side stub.  Allocates a client side LDC as well.                  *
*                                                                          *
* Note that it calls the server only after all client side stuff has       *
* succeeded, we don't want to ask the server to clean up.                  *
*                                                                          *
* History:                                                                 *
*  Sat 01-Jun-1991 16:13:22 -by- Charles Whitmer [chuckwh]                 *
*  8-18-92 Unicode enabled and combined with CreateIC                      *
* Wrote it.                                                                *
\**************************************************************************/

CONST WCHAR gwszDisplayDevice[] = L"\\\\.\\DISPLAY";

HDC bCreateDCW
(
    LPCWSTR     pszDriver,
    LPCWSTR     pszDevice,
    LPCWSTR     pszPort  ,
    CONST DEVMODEW *pdm,
    BOOL       bIC
)
{
    UNICODE_STRING ustrDevice;
    UNICODE_STRING ustrPort;

    PUNICODE_STRING pustrDevice = NULL;
    PUNICODE_STRING pustrPort   = NULL;

    BOOL            bDisplay = FALSE;

// check for multi-monitor cases, first.

    if (pszDevice != NULL)
    {
        if (_wcsnicmp(pszDevice,
                      gwszDisplayDevice,
                      ((sizeof(gwszDisplayDevice)/sizeof(WCHAR))-1)) == 0)
        {
        // CreateDC(?, L"\\.\DISPLAY?",...);
        // (this case, we don't care whatever passed into pszDriver)
        //
        // if apps call, CreateDC("DISPLAY","\\.\DISPLAY?",...);,
        // we handle this as multi-monitor case. that's why
        // we check multi-monitor case first.

            bDisplay = TRUE;
        }
    }

// check for most typical case to create display DC

    if (!bDisplay && (pszDriver != NULL))
    {
        if (_wcsicmp(pszDriver,(LPWSTR)L"DISPLAY") == 0)
        {
        // CreateDC(L"DISPLAY",?,...);
        //
        // Comments Win9x [gdi\dcman1.asm]
        //
        //    This fix is for people who called CreateDC/IC with
        //    ("Display","Display", xxxxx) rather than ("Display",
        //    NULL, NULL) which it was supposed to.
        //
        // NULL to pszDevice.

            pszDevice = NULL;
            bDisplay = TRUE;
        }
    }

// check for memphis compatibility

    if (!bDisplay && (pszDriver != NULL))
    {
    // The comment and code from Memphis.
    //
    // // the normal syntax apps will use is
    // //
    // //  CreateDC(NULL, "\\.\DisplayX", ...)
    // //
    // // but USER uses this syntax, so we will support it too.
    // //
    // //  CreateDC("\\.\DisplayX", NULL, ...)
    // //
    // if (lpDriverName != NULL && *(DWORD FAR *)lpDriverName == 0x5C2E5C5C)
    // {
    //    lpDeviceName = lpDriverName;
    //    lpDriverName = NULL;
    // }
        if (_wcsnicmp(pszDriver,
                      gwszDisplayDevice,
                      ((sizeof(gwszDisplayDevice)/sizeof(WCHAR))-1)) == 0)
        {
            pszDevice = pszDriver;
            bDisplay = TRUE;
        }
    }

// convert the strings

    if (pszDevice)
    {
        RtlInitUnicodeString(&ustrDevice,pszDevice);
        pustrDevice = &ustrDevice;
    }

    if (pszPort)
    {
        RtlInitUnicodeString(&ustrPort,pszPort);
        pustrPort = &ustrPort;
    }

// call the common stub

    return(hdcCreateDCW(pustrDevice,pustrPort,pdm,bDisplay,bIC));
}


/******************************Public*Routine******************************\
* bCreateDCA
*
* Client side stub.  Allocates a client side LDC as well.
*
*
* Note that it calls the server only after all client side stuff has
* succeeded, we don't want to ask the server to clean up.
*
* History:
*  8-18-92 Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

CONST CHAR gszDisplayDevice[] = "\\\\.\\DISPLAY";

HDC bCreateDCA
(
    LPCSTR     pszDriver,
    LPCSTR     pszDevice,
    LPCSTR     pszPort  ,
    LPDEVMODEA pdm,
    BOOL       bIC
)
{
    HDC             hdcRet = 0;

    UNICODE_STRING  ustrDevice;
    UNICODE_STRING  ustrPort;

    PUNICODE_STRING pustrDevice = NULL;
    PUNICODE_STRING pustrPort   = NULL;

    DEVMODEW       *pdmw = NULL;

    BOOL            bDisplay = FALSE;

// check for multi-monitor cases, first.

    if (pszDevice != NULL)
    {
        if (_strnicmp(pszDevice,
                      gszDisplayDevice,
                      ((sizeof(gszDisplayDevice)/sizeof(CHAR))-1)) == 0)
        {
        // CreateDC(?,"\\.\DISPLAY?",...);
        // (this case, we don't care whatever passed into pszDriver)
        //
        // if apps call, CreateDC("DISPLAY","\\.\DISPLAY?",...);,
        // we handle this as multi-monitor case. that's why
        // we check multi-monitor case first.

            bDisplay = TRUE;
        }
    }

// check for most typical case to create display DC

    if (!bDisplay && (pszDriver != NULL))
    {
        if (_stricmp(pszDriver,"DISPLAY") == 0)
        {
        // CreateDC("DISPLAY",?,...);
        //
        // Comments Win9x [gdi\dcman1.asm]
        //
        //    This fix is for people who called CreateDC/IC with
        //    ("Display","Display", xxxxx) rather than ("Display",
        //    NULL, NULL) which it was supposed to.
        //
        // NULL to pszDevice.

            pszDevice = NULL;
            bDisplay = TRUE;
        }
    }

// check for memphis compatibility

    if (!bDisplay && (pszDriver != NULL))
    {
    // The comment and code from Memphis.
    //
    // // the normal syntax apps will use is
    // //
    // //  CreateDC(NULL, "\\.\DisplayX", ...)
    // //
    // // but USER uses this syntax, so we will support it too.
    // //
    // //  CreateDC("\\.\DisplayX", NULL, ...)
    // //
    // if (lpDriverName != NULL && *(DWORD FAR *)lpDriverName == 0x5C2E5C5C)
    // {
    //    lpDeviceName = lpDriverName;
    //    lpDriverName = NULL;
    // }
        if (_strnicmp(pszDriver,
                      gszDisplayDevice,
                      ((sizeof(gszDisplayDevice)/sizeof(CHAR))-1)) == 0)
        {
            pszDevice = pszDriver;
            bDisplay = TRUE;
        }
    }

// convert the strings

    if (pszDevice)
    {

    // [NOTE:]
    //   RtlCreateUnicodeStringFromAsciiz() returns boolean, NOT NTSTATUS !

        if (!RtlCreateUnicodeStringFromAsciiz(&ustrDevice,pszDevice))
        {
            goto MSGERROR;
        }
        pustrDevice = &ustrDevice;
    }

    if (pszPort)
    {

    // [NOTE:]
    //   RtlCreateUnicodeStringFromAsciiz() returns boolean, NOT NTSTATUS !

        if (!RtlCreateUnicodeStringFromAsciiz(&ustrPort,pszPort))
        {
            goto MSGERROR;
        }

        pustrPort = &ustrPort;
    }

// if it is a display, don't use the devmode if the dmDeviceName is empty

    if (pdm != NULL)
    {
        if (!bDisplay || (pdm->dmDeviceName[0] != 0))
        {
            pdmw = GdiConvertToDevmodeW(pdm);

            if( pdmw == NULL )
                goto MSGERROR;

        }
    }

// call the common stub

    hdcRet = hdcCreateDCW(pustrDevice,pustrPort,pdmw,bDisplay,bIC);

// clean up

    MSGERROR:

    if (pustrDevice)
        RtlFreeUnicodeString(pustrDevice);

    if (pustrPort)
        RtlFreeUnicodeString(pustrPort);

    if(pdmw != NULL)
        LOCALFREE(pdmw);

    return(hdcRet);
}


/******************************Public*Routine******************************\
* CreateICW
*
* wrapper for bCreateDCW
*
* History:
*  8-18-92 Gerrit van Wingerden
* Wrote it.
\**************************************************************************/


HDC WINAPI CreateICW
(
    LPCWSTR     pwszDriver,
    LPCWSTR     pwszDevice,
    LPCWSTR     pwszPort,
    CONST DEVMODEW *pdm
)
{
    return bCreateDCW( pwszDriver, pwszDevice, pwszPort, pdm, TRUE );
}


/******************************Public*Routine******************************\
* CreateICA
*
* wrapper for bCreateICA
*
* History:
*  8-18-92 Gerrit van Wingerden
* Wrote it.
\**************************************************************************/


HDC WINAPI CreateICA
(
    LPCSTR     pszDriver,
    LPCSTR     pszDevice,
    LPCSTR     pszPort,
    CONST DEVMODEA *pdm
)
{

    return bCreateDCA( pszDriver, pszDevice, pszPort, (LPDEVMODEA)pdm, TRUE );
}


/******************************Public*Routine******************************\
* CreateDCW
*
* wrapper for bCreateDCA
*
* History:
*  8-18-92 Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

HDC WINAPI CreateDCA
(
    LPCSTR     pszDriver,
    LPCSTR     pszDevice,
    LPCSTR     pszPort,
    CONST DEVMODEA *pdm
)
{
    return bCreateDCA( pszDriver, pszDevice, pszPort, (LPDEVMODEA)pdm, FALSE );
}

/******************************Public*Routine******************************\
* CreateDCW
*
* wrapper for bCreateDCW
*
* History:
*  8-18-92 Gerrit van Wingerden
* Wrote it.
\**************************************************************************/


HDC WINAPI CreateDCW
(
    LPCWSTR     pwszDriver,
    LPCWSTR     pwszDevice,
    LPCWSTR     pwszPort  ,
    CONST DEVMODEW *pdm
)
{
    return bCreateDCW( pwszDriver, pwszDevice, pwszPort, pdm, FALSE );
}


/******************************Public*Routine******************************\
* GdiConvertToDevmodeW
*
* Converts a DEVMODEA to a DEVMODEW structure
*
* History:
*  09-08-1995 Andre Vachon
* Wrote it.
\**************************************************************************/

LPDEVMODEW
GdiConvertToDevmodeW(
    LPDEVMODEA pdma
)
{
    DWORD cj;
    LPDEVMODEW pdmw;

    // Sanity check.  We should have at least up to and including the
    // dmDriverExtra field of the DEVMODE structure.
    //
    // NOTE dmSize CAN be greater than the size of the DEVMODE
    // structure (not counting driver specific data, of course) because this
    // structure grows from version to version.
    //

    if (pdma->dmSize <= (offsetof(DEVMODEA,dmDriverExtra)))
    {
        ASSERTGDI(FALSE, "GdiConvertToDevmodeW: DevMode.dmSize bad or corrupt\n");
        return(NULL);
    }

    pdmw = (DEVMODEW *) LOCALALLOC(sizeof(DEVMODEW) + pdma->dmDriverExtra);

    if (pdmw)
    {
        //
        // If we get to here, we know we have at least up to and including
        // the dmDriverExtra field.
        //

        vToUnicodeN(pdmw->dmDeviceName,
                    CCHDEVICENAME,
                    pdma->dmDeviceName,
                    CCHDEVICENAME);

        pdmw->dmSpecVersion = pdma->dmSpecVersion ;
        pdmw->dmDriverVersion = pdma->dmDriverVersion;
        pdmw->dmSize = pdma->dmSize + CCHDEVICENAME;
        pdmw->dmDriverExtra = pdma->dmDriverExtra;

        //
        // Anything left in the pdma buffer?  Copy any data between the dmDriverExtra
        // field and the dmFormName, truncating the amount to the size of the
        // pdma buffer (as specified by dmSize), of course.
        //

        cj = MIN(pdma->dmSize - offsetof(DEVMODEA,dmFields),
                 offsetof(DEVMODEA,dmFormName) - offsetof(DEVMODEA,dmFields));

        RtlCopyMemory(&pdmw->dmFields,
                      &pdma->dmFields,
                      cj);

        //
        // Is there a dmFormName field present in the pdma buffer?  If not, bail out.
        // Otherwise, convert to Unicode.
        //

        if (pdma->dmSize >= (offsetof(DEVMODEA,dmFormName)+32))
        {
            vToUnicodeN(pdmw->dmFormName,
                        CCHFORMNAME,
                        pdma->dmFormName,
                        CCHFORMNAME);

            pdmw->dmSize += CCHFORMNAME;

            //
            // Lets adjust the size of the DEVMODE in case the DEVMODE passed in
            // is from a future, larger version of the DEVMODE.
            //

            pdmw->dmSize = min(pdmw->dmSize, sizeof(DEVMODEW));

            //
            // Copy data from dmBitsPerPel to the end of the input buffer
            // (as specified by dmSize).
            //

            RtlCopyMemory(&pdmw->dmLogPixels,
                          &pdma->dmLogPixels,
                          MIN(pdma->dmSize - offsetof(DEVMODEA,dmLogPixels),
                              pdmw->dmSize - offsetof(DEVMODEW,dmLogPixels)) );

            //
            // Copy any driver specific data indicated by the dmDriverExtra field.
            //

            RtlCopyMemory((PBYTE) pdmw + pdmw->dmSize,
                          (PBYTE) pdma + pdma->dmSize,
                          pdma->dmDriverExtra );
        }
    }

    return pdmw;
}



/******************************Public*Routine******************************\
* CreateCompatibleDC                                                       *
*                                                                          *
* Client side stub.  Allocates a client side LDC as well.                  *
*                                                                          *
* Note that it calls the server only after all client side stuff has       *
* succeeded, we don't want to ask the server to clean up.                  *
*                                                                          *
* History:                                                                 *
*  Wed 24-Jul-1991 15:38:41 -by- Wendy Wu [wendywu]                        *
* Should allow hdc to be NULL.                                             *
*                                                                          *
*  Mon 03-Jun-1991 23:13:28 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HDC WINAPI CreateCompatibleDC(HDC hdc)
{
    HDC hdcNew = NULL;

    FIXUP_HANDLEZ(hdc);

    hdcNew = NtGdiCreateCompatibleDC(hdc);

    // [Windows 98 compatibility]
    //
    // if source DC has some ICM information, compatible DC should
    // inherit those information.
    //
    // Is this what Memphis does, but Win95 does not.
    //
    if (hdc && hdcNew)
    {
        PDC_ATTR pdca;

        PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

        if (pdca && BEXIST_ICMINFO(pdca))
        {
            IcmEnableForCompatibleDC(hdcNew,hdc,pdca);
        }
    }

    return(hdcNew);
}

/******************************Public*Routine******************************\
* DeleteDC                                                                 *
*                                                                          *
* Client side stub.  Deletes the client side LDC as well.                  *
*                                                                          *
* Note that we give the server a chance to fail the call before destroying *
* our client side data.                                                    *
*                                                                          *
* History:                                                                 *
*  Sat 01-Jun-1991 16:16:24 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI DeleteDC(HDC hdc)
{
    FIXUP_HANDLE(hdc);
    return(InternalDeleteDC(hdc,LO_DC_TYPE));
}

BOOL InternalDeleteDC(HDC hdc,ULONG iType)
{
    ULONG bRet = FALSE;
    PLDC pldc  = NULL;
    BOOL unloadUMPD = FALSE;
    PDC_ATTR pDcAttr;
    HANDLE hSpooler = 0;

    if (IS_ALTDC_TYPE(hdc))
    {
        DC_PLDC(hdc,pldc,bRet);

    // In case a document is still open.

        if (pldc->fl & LDC_DOC_STARTED)
            AbortDoc(hdc);

    // if this was a metafiled print job, AbortDoc should have converted back

        ASSERTGDI(!(pldc->fl & LDC_META_PRINT), "InternalDeleteDC - LDC_META_PRINT\n");

    // if we have an open spooler handle

        if (pldc->hSpooler)
        {
            // now call the drivers UI portion

            DocumentEventEx(pldc->pUMPD,
                    pldc->hSpooler,
                    hdc,
                    DOCUMENTEVENT_DELETEDC,
                    0,
                    NULL,
                    0,
                    NULL);

            //
            // Remember to unload user-mode printer driver module later
            //

            unloadUMPD = (pldc->pUMPD != NULL);

            ASSERTGDI(ghSpooler != NULL,"Trying to close printer that was never opened\n");

            //
            // remember hspooler, for not printer dcs, hspooler may not be initialized
            //
            hSpooler = pldc->hSpooler;

            pldc->hSpooler = 0;
        }

    // delete the port name if it was created

        if (pldc->pwszPort != NULL)
        {
            LOCALFREE(pldc->pwszPort);
            pldc->pwszPort = NULL;
        }

    // delete UFI hash tables if they exist

        vFreeUFIHashTable( pldc->ppUFIHash, 0 );
        vFreeUFIHashTable( pldc->ppDVUFIHash, 0 );
        vFreeUFIHashTable( pldc->ppSubUFIHash, FL_UFI_SUBSET);
        if (pldc->ppUFIHash)
        {
        // client side situation: all three ppXXX tables allocated

            LOCALFREE(pldc->ppUFIHash);
        }
        else
        {
        // server side situation: possibly only ppSubUFIHash tables allocated

            ASSERTGDI(!pldc->ppDVUFIHash, "server side pldc->ppDVUFIHash not null\n");
            if (pldc->ppSubUFIHash)
                LOCALFREE(pldc->ppSubUFIHash);
        }
    }
    else
    {
        pldc = GET_PLDC(hdc);
    }

    // save the old brush, so we can DEC its counter later

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        if (ghICM || BEXIST_ICMINFO(pDcAttr))
        {
            //
            // Delete ICM stuff in this DC. (should be delete this BEFORE hdc is gone)
            //
            IcmDeleteLocalDC(hdc,pDcAttr,NULL);
        }

        bRet = NtGdiDeleteObjectApp(hdc);

        if (hSpooler)
        {
           (*fpClosePrinter)(hSpooler);
        }
    }

    // delete the client piece only if the server is successfully deleted.
    // othewise it will be orphaned.

    if (bRet && pldc)
    {
        if (unloadUMPD)
        {
            UnloadUserModePrinterDriver(pldc->pUMPD, TRUE, hSpooler);
            pldc->pUMPD = NULL;
        }

        bRet = bDeleteLDC(pldc);
        ASSERTGDI(bRet,"InteranlDeleteDC - couldn't delete LDC\n");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GdiReleaseDC
*
*   Free user mode ICM resources saved in DC
*
* Arguments:
*
*   hdc
*
* Return Value:
*
*    status
*
* History:
*
* Rewrite it for ICM.
*     2.Feb.1997 Hideyuki Nagase [hideyukn]
* Write it:
*    10/10/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
GdiReleaseDC(
    HDC hdc
    )
{
    PLDC     pldc;
    PDC_ATTR pDcAttr;
    BOOL bRet = TRUE;

    pldc = GET_PLDC(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr && (ghICM || BEXIST_ICMINFO(pDcAttr)))
    {
        //
        // Delete ICM stuff in this DC.
        //
        IcmDeleteLocalDC(hdc,pDcAttr,NULL);
    }

    if (pldc)
    {
        //
        // PLDC has been allocated. free it.
        //
        // Put null-PLDC into DC_ATTR.
        //
        vSetPldc(hdc,NULL);
        //
        // And, then delete PLDC.
        //
        bRet = bDeleteLDC(pldc);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SaveDC                                                                   *
*                                                                          *
* Client side stub.  Saves the LDC on the client side as well.             *
*                                                                          *
* History:                                                                 *
*  Sat 01-Jun-1991 16:17:43 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

int WINAPI SaveDC(HDC hdc)
{
    int   iRet = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms1(hdc, META_SAVEDC));

        DC_PLDC(hdc,pldc,iRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_Record(hdc,EMR_SAVEDC))
                return(iRet);
        }
    }

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        PGDI_ICMINFO pIcmInfo = GET_ICMINFO(pDcAttr);

        //
        // If DC doesn't have ICMINFO, just call kernel.
        // If DC has ICMINFO, save ICMINFO first in client side, then call kernel.
        //
        if ((pIcmInfo == NULL) || (IcmSaveDC(hdc,pDcAttr,pIcmInfo)))
        {
            //
            // Call kernel to save DC.
            //
            iRet = NtGdiSaveDC(hdc);

            if ((iRet == 0) && (pIcmInfo))
            {
                //
                // if fail, restore client too.
                //
                IcmRestoreDC(pDcAttr,-1,pIcmInfo);
            }
        }

    }

    return(iRet);
}

/******************************Public*Routine******************************\
* RestoreDC                                                                *
*                                                                          *
* Client side stub.  Restores the client side LDC as well.                 *
*                                                                          *
* History:                                                                 *
*  Sat 01-Jun-1991 16:18:50 -by- Charles Whitmer [chuckwh]                 *
* Wrote it. (We could make this batchable some day.)                       *
\**************************************************************************/

BOOL WINAPI RestoreDC(HDC hdc,int iLevel)
{
    BOOL  bRet = FALSE;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    // Metafile the call.

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms2(hdc, iLevel, META_RESTOREDC));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_RestoreDC(hdc,iLevel))
                return(bRet);

        // zero out UFI since it will no longer be valid

            UFI_CLEAR_ID(&(pldc->ufi));
        }
    }

    // save the old brush, so we can DEC it's count later

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        //
        // Keep current ICMINFO, before restore it
        //
        PGDI_ICMINFO pIcmInfoOld = GET_ICMINFO(pDcAttr);

        if (pIcmInfoOld)
        {
            //
            // And mark the ICMINFO unreuseable since  under restoring DC.
            //
            IcmMarkInUseIcmInfo(pIcmInfoOld,TRUE);
        }

        //
        // Call kernel to do retore DC.
        //
        bRet = NtGdiRestoreDC(hdc,iLevel);

        if (bRet)
        {
            PGDI_ICMINFO pIcmInfo = GET_ICMINFO(pDcAttr);

            if (pIcmInfoOld && (pIcmInfo == NULL))
            {
                //
                // Delete ICM stuffs associated the DC before Restore.
                // beccause Restored DC does not have any ICMINFO.
                //
                // - This will delete pIcmInfoOld.
                //
                IcmDeleteLocalDC(hdc,pDcAttr,pIcmInfoOld);

                pIcmInfoOld = NULL;
            }
            else if (pIcmInfoOld == pIcmInfo)
            {
                //
                // Restore DC in client side.
                //
                IcmRestoreDC(pDcAttr,iLevel,pIcmInfo);
            }
        }

        if (pIcmInfoOld)
        {
            //
            // Unmark unreusable flags.
            //
            IcmMarkInUseIcmInfo(pIcmInfoOld,FALSE);
        }

        CLEAR_CACHED_TEXT(pDcAttr);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* ResetDCWInternal
*
* This internal version version of ResetDC implments the functionality of
* ResetDCW, but, through the addition of a third parameter, pbBanding, handles
* ResetDC for the Printing metafile playback code.  When pbBanding is non-NULL
* ResetDCWInternal is being called by GdiPlayEMFSpoolfile. In this case
* the only thing that needs to be done is to imform the the caller whether or
* not the new surface is a banding surface.
*
*
* History:
*  13-Mar-1995 Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

HDC WINAPI ResetDCWInternal(HDC hdc, CONST DEVMODEW *pdm, BOOL *pbBanding)
{
    HDC hdcRet = NULL;
    PLDC pldc = NULL;
    PDEVMODEW pdmAlt = NULL;
    KERNEL_PUMDHPDEV pUMdhpdev = NULL;
    BOOL bDocEvent = FALSE;

    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        PDC_ATTR pdcattr;
        BOOL  bBanding;
        PUMPD pUMPD;
        PGDI_ICMINFO pIcmInfoOld = NULL;
        int iEventRet;

        DC_PLDC(hdc,pldc,(HDC) 0);
        PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

        // Do nothing if we are in the middle of a page.

        if (pldc->fl & LDC_PAGE_STARTED)
            return((HDC)0);

        // see if the driver is intercepting document events

        if (pldc->hSpooler)
        {
            iEventRet = DocumentEventEx(pldc->pUMPD,
                                        pldc->hSpooler,
                                        hdc,
                                        DOCUMENTEVENT_RESETDCPRE,
                                        sizeof(pdm),
                                        (PVOID)&pdm,
                                        sizeof(pdmAlt),
                                        (PVOID)&pdmAlt);
            
            if (iEventRet == DOCUMENTEVENT_FAILURE)
            {
                return((HDC)0);
            }
            
            bDocEvent = TRUE;
            
            if (pdmAlt)
                pdm = pdmAlt;
        }

        pUMPD = pldc->pUMPD;

        if (pdcattr)
        {
            // Keep current ICMINFO, before reset it.

            pIcmInfoOld = GET_ICMINFO(pdcattr);

            if (pIcmInfoOld)
            {
                // And mark the ICMINFO unreuseable since  under restoring DC.

                IcmMarkInUseIcmInfo(pIcmInfoOld,TRUE);
            }
        }

        if (NtGdiResetDC(hdc,(PDEVMODEW)pdm,&bBanding,
                        (pUMPD == NULL)? NULL : pUMPD->pDriverInfo2, &pUMdhpdev))
        {
            PDC_ATTR pdca;

            PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

            // make sure we update the pldc in the dcattr before continuing

            vSetPldc(hdc,pldc);
#if 0
// EngQueryEMFInfo junk
            if (pUMdhpdev)
            {
               pUMdhpdev->hdc = hdc;
            }
#endif

            pldc->pUMdhpdev = pUMdhpdev;

            // clear cached DEVCAPS

            pldc->fl &= ~LDC_CACHED_DEVCAPS;

            // clear cached TM

            if (pdca)
            {
                CLEAR_CACHED_TEXT(pdca);
            }

            // update the devmode we store in the DC

            if (pldc->pDevMode)
            {
                LOCALFREE(pldc->pDevMode);
                pldc->pDevMode = NULL;
            }

            if (pdm != (DEVMODEW*) NULL)
            {
                ULONG cjDevMode = pdm->dmSize + pdm->dmDriverExtra;

                pldc->pDevMode = (DEVMODEW*) LOCALALLOC(cjDevMode);

                if (pldc->pDevMode == NULL)
                {
                    WARNING("MFP_ResetDCW unable to allocate memory\n");
                    goto ERROREXIT;
                }

                // Validate DEVMMODE, then copy to buffer.

                if ((pdm->dmSize >= offsetof(DEVMODEW,dmDuplex)) &&
                    (pdm->dmFields & DM_COLOR) &&
                    (pdm->dmColor == DMCOLOR_MONOCHROME))
                {
                    // if devmode says, this is monochrome mode, we don't need to
                    // validate devmode since this validation is for ICM which
                    // only needs for color case. Just copy whatever apps gives us.

                    RtlCopyMemory( (PBYTE) pldc->pDevMode, (PBYTE) pdm, cjDevMode );
                }
                else if ((*fpDocumentPropertiesW)
                            (NULL,pldc->hSpooler,
                             (LPWSTR) pdm->dmDeviceName,
                             pldc->pDevMode,  // output devmode
                             (PDEVMODEW) pdm, // input devmode
                             DM_IN_BUFFER |
                             DM_OUT_BUFFER) != IDOK)
                {
                    // if error, just copy original

                    RtlCopyMemory( (PBYTE) pldc->pDevMode, (PBYTE) pdm, cjDevMode );
                }
            }

            // make sure we update the pvICM in the dcattr before continuing

            if (pdca)
            {
                // This old ICM info will be deleted when we re-initialize ICM
                // status based on new DEVMODE.

                pdca->pvICM = pIcmInfoOld;
                pIcmInfoOld = NULL;

                // Re-initialize ICM stuff with new DEVMODE

                IcmInitLocalDC(hdc,pldc->hSpooler,pdm,TRUE);
            }

            // got to tell the spooler things have changed

            if (pldc->hSpooler)
            {
                PRINTER_DEFAULTSW prnDefaults;

                prnDefaults.pDatatype     = NULL;
                prnDefaults.pDevMode      = (PDEVMODEW)pdm;
                prnDefaults.DesiredAccess = PRINTER_ACCESS_USE;

                ResetPrinterWEx(pldc, &prnDefaults);
            }

            // now deal with the specific mode

            if( ( pldc->fl & LDC_META_PRINT ) &&
               !( pldc->fl & LDC_BANDING ) )
            {
                if( !MFP_ResetDCW( hdc, (DEVMODEW*) pdm ) )
                {
                    goto ERROREXIT;
                }

            }
            else if( pbBanding == NULL  )
            {
                if( !MFP_ResetBanding( hdc, bBanding ) )
                {
                    goto ERROREXIT;
                }
            }

            if (pbBanding)
            {
                *pbBanding = bBanding;
            }

            // need to make sure it is a direct DC

            pldc->fl &= ~LDC_INFO;

            hdcRet = hdc;
        }

        if (pIcmInfoOld)
        {
            IcmMarkInUseIcmInfo(pIcmInfoOld,FALSE);
        }
    }

ERROREXIT:    

    // see if the driver is intercepting document events
        
    if (bDocEvent)
    {
        DocumentEventEx(pldc->pUMPD,
                pldc->hSpooler,
                hdc,
                DOCUMENTEVENT_RESETDCPOST,
                sizeof(pdmAlt),
                (PVOID)&pdmAlt,
                0,
                NULL);
    }
    
    return(hdcRet);

}

/******************************Public*Routine******************************\
* ResetDCW
*
* Client side stub.  Resets the client side LDC as well.
*
* History:
*  31-Dec-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

HDC WINAPI ResetDCW(HDC hdc, CONST DEVMODEW *pdm)
{
    FIXUP_HANDLE(hdc);

    return(ResetDCWInternal( hdc, pdm, NULL ) );
}

/******************************Public*Routine******************************\
* ResetDCA
*
* Client side stub.  Resets the client side LDC as well.
*
* History:
*  31-Dec-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

HDC WINAPI ResetDCA(HDC hdc, CONST DEVMODEA *pdm)
{
    DEVMODEW   *pdmw = NULL;
    HDC         hdcRet = 0;

    FIXUP_HANDLE(hdc);

    // convert to unicode

    if ((pdm != NULL) && (pdm->dmDeviceName[0] != 0))
    {
        pdmw = GdiConvertToDevmodeW((LPDEVMODEA) pdm);

        if (pdmw == NULL)
        {
            goto MSGERROR;
        }
    }

    hdcRet = ResetDCWInternal(hdc,pdmw,NULL);

MSGERROR:

    // Clean up the conversion buffer

    if (pdmw != NULL)
        LOCALFREE(pdmw);

    return (hdcRet);
}

/******************************Public*Routine******************************\
* CreateBrush                                                              *
*                                                                          *
* A single routine which creates any brush.  Any extra data needed is      *
* assumed to be at pv.  The size of the data must be cj.  The data is      *
* appended to the LOGBRUSH.                                                *
*                                                                          *
* History:                                                                 *
*  Tue 04-Jun-1991 00:03:24 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HBRUSH CreateBrush
(
    ULONG lbStyle,
    ULONG lbColor,
    ULONG_PTR lbHatch,
    ULONG_PTR lbSaveHatch,
    PVOID pv
)
{
    HBRUSH hbrush = NULL;

    if (lbStyle == BS_SOLID)
    {
        //
        // look for a cached brush on the PEB
        //

        HBRUSH hbr = (HBRUSH)hGetPEBHandle(BrushHandle,lbColor);

        if (hbr == NULL)
        {
            hbr = NtGdiCreateSolidBrush(lbColor, 0);
        }

        return(hbr);
    }

    //
    // call into kernel to create other styles of brush
    //

    switch(lbStyle)
    {
    case BS_HOLLOW:
        return(GetStockObject(NULL_BRUSH));

    case BS_HATCHED:
        //
        // lbHatch is overloaded, actually is HS style
        // we are safe to truncate it here
        //
        return (NtGdiCreateHatchBrushInternal
               ((ULONG)(lbHatch),
                lbColor,
                FALSE));

    case BS_PATTERN:
        return (NtGdiCreatePatternBrushInternal((HBITMAP)lbHatch,FALSE,FALSE));

    case BS_PATTERN8X8:
        return (NtGdiCreatePatternBrushInternal((HBITMAP)lbHatch,FALSE,TRUE));

    case BS_DIBPATTERN:
    case BS_DIBPATTERNPT:
    case BS_DIBPATTERN8X8:
    {
        INT cj;
        HBRUSH hbr;

        PVOID pbmiDIB;

        pbmiDIB = (PVOID)pbmiConvertInfo((BITMAPINFO *) pv,lbColor, &cj, TRUE);

        if (pbmiDIB)
        {
            hbr = NtGdiCreateDIBBrush(
                            (PVOID)pbmiDIB,
                            lbColor,
                            cj,
                            (lbStyle == BS_DIBPATTERN8X8),
                            FALSE,
                            (PVOID)pv);

            if (pbmiDIB != pv)
            {
                LOCALFREE (pbmiDIB);
            }
        }
        else
        {
            hbr = 0;
        }
        return (hbr);
    }
    default:
        WARNING("GreCreateBrushIndirect failed - invalid type\n");
        return((HBRUSH)0);
    }
}

/******************************Public*Routine******************************\
* CreateHatchBrush                                                         *
*                                                                          *
* Client side stub.  Maps to the single brush creation routine.            *
*                                                                          *
* History:
*  Mon 03-Jun-1991 23:42:07 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HBRUSH WINAPI CreateHatchBrush(int iHatch,COLORREF color)
{
    return(CreateBrush(BS_HATCHED,(ULONG) color,iHatch,iHatch,NULL));
}

/******************************Public*Routine******************************\
* CreatePatternBrush                                                       *
*                                                                          *
* Client side stub.  Maps to the single brush creation routine.            *
*                                                                          *
* History:                                                                 *
*  Mon 03-Jun-1991 23:42:07 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HBRUSH WINAPI CreatePatternBrush(HBITMAP hbm_)
{
    FIXUP_HANDLE (hbm_);

    return(CreateBrush(BS_PATTERN,0,(ULONG_PTR)hbm_,(ULONG_PTR)hbm_,NULL));
}

/******************************Public*Routine******************************\
* CreateSolidBrush                                                         *
*                                                                          *
* Client side stub.  Maps to the single brush creation routine.            *
*                                                                          *
* History:                                                                 *
*  Mon 03-Jun-1991 23:42:07 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HBRUSH WINAPI CreateSolidBrush(COLORREF color)
{
    return(CreateBrush(BS_SOLID,(ULONG) color,0,0,NULL));
}

/******************************Public*Routine******************************\
* CreateBrushIndirect                                                      *
*                                                                          *
* Client side stub.  Maps to the simplest brush creation routine.          *
*                                                                          *
* History:                                                                 *
*  Tue 04-Jun-1991 00:40:27 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HBRUSH WINAPI CreateBrushIndirect(CONST LOGBRUSH * plbrush)
{
    switch (plbrush->lbStyle)
    {
    case BS_SOLID:
    case BS_HOLLOW:
    case BS_HATCHED:
        return(CreateBrush(plbrush->lbStyle,
                           plbrush->lbColor,
                           plbrush->lbHatch,
                           plbrush->lbHatch,
                           NULL));
    case BS_PATTERN:
    case BS_PATTERN8X8:
        {
            return(CreateBrush(
                        plbrush->lbStyle,
                        0,
                        plbrush->lbHatch,
                        plbrush->lbHatch,
                        NULL));
        }

    case BS_DIBPATTERNPT:
    case BS_DIBPATTERN8X8:
        {
            BITMAPINFOHEADER *pbmi = (BITMAPINFOHEADER *) plbrush->lbHatch;

            return (CreateBrush(plbrush->lbStyle,
                               plbrush->lbColor,
                               0,
                               plbrush->lbHatch,
                               pbmi));
        }
    case BS_DIBPATTERN:
        {
            BITMAPINFOHEADER *pbmi;
            HBRUSH hbrush;

            pbmi = (BITMAPINFOHEADER *) GlobalLock((HANDLE) plbrush->lbHatch);

            if (pbmi == (BITMAPINFOHEADER *) NULL)
                return((HBRUSH) 0);

            hbrush =
              CreateBrush
              (
                plbrush->lbStyle,
                plbrush->lbColor,
                0,
                plbrush->lbHatch,
                pbmi
               );

            GlobalUnlock ((HANDLE)plbrush->lbHatch);
            return (hbrush);
        }
    default:
        return((HBRUSH) 0);
    }


}

/******************************Public*Routine******************************\
* CreateDIBPatternBrush                                                    *
*                                                                          *
* Client side stub.  Maps to the single brush creation routine.            *
*                                                                          *
* History:                                                                 *
*  Mon 03-Jun-1991 23:42:07 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HBRUSH WINAPI CreateDIBPatternBrush(HGLOBAL h,UINT iUsage)
{
    BITMAPINFOHEADER *pbmi;
    HBRUSH    hbrush;

    pbmi = (BITMAPINFOHEADER *) GlobalLock(h);

    if (pbmi == (BITMAPINFOHEADER *) NULL)
        return((HBRUSH) 0);

    hbrush =
      CreateBrush
      (
        BS_DIBPATTERN,
        iUsage,
        0,
        (ULONG_PTR) h,
        pbmi
      );

    GlobalUnlock(h);

    return(hbrush);
}

/******************************Public*Routine******************************\
* CreateDIBPatternBrushPt                                                  *
*                                                                          *
* Client side stub.  Maps to the single brush creation routine.            *
*                                                                          *
* History:                                                                 *
*  Mon 03-Jun-1991 23:42:07 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HBRUSH WINAPI CreateDIBPatternBrushPt(CONST VOID *pbmi,UINT iUsage)
{
    if (pbmi == (LPVOID) NULL)
        return((HBRUSH) 0);

    return
      CreateBrush
      (
        BS_DIBPATTERNPT,
        iUsage,
        0,
        (ULONG_PTR)pbmi,
        (BITMAPINFOHEADER *)pbmi
      );
}

/******************************Public*Routine******************************\
* CreatePen                                                                *
*                                                                          *
* Stub to get the server to create a standard pen.                         *
*                                                                          *
* History:                                                                 *
*  Tue 04-Jun-1991 16:20:58 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/


HPEN WINAPI CreatePen(
    int      iStyle,
    int      cWidth,
    COLORREF color
)
{
    HPEN hpen;

    switch(iStyle)
    {
    case PS_NULL:
        return(GetStockObject(NULL_PEN));

    case PS_SOLID:
    case PS_DASH:
    case PS_DOT:
    case PS_DASHDOT:
    case PS_DASHDOTDOT:
    case PS_INSIDEFRAME:
        break;

    default:
        // Bug 195478:  objects created with illegal styles should be of style PS_SOLID to
        // maintain Memphis compatibility.

        iStyle = PS_SOLID;
        break;
    }

    // try to get local cached pen

    if ((cWidth == 0) && (iStyle == PS_SOLID))
    {
        hpen = (HPEN)hGetPEBHandle(PenHandle,0);

        if (hpen)
        {
            PBRUSHATTR pBrushattr;

            PSHARED_GET_VALIDATE(pBrushattr,hpen,BRUSH_TYPE);

            //
            // setup the fields
            //

            if (pBrushattr)
            {
                ASSERTGDI (!(pBrushattr->AttrFlags & ATTR_TO_BE_DELETED),"createbrush : how come del flag is on?\n");

                //
                // clear cahced flag, set new style and color
                //

                if (pBrushattr->lbColor != color)
                {
                    pBrushattr->AttrFlags |= ATTR_NEW_COLOR;
                    pBrushattr->lbColor = color;
                }

                return(hpen);
            }
            else
            {
                WARNING ("pBrushattr == NULL, bad handle on TEB/PEB! \n");
                DeleteObject(hpen);
            }
        }
    }

    //
    // validate
    //

    return(NtGdiCreatePen(iStyle,cWidth,color,(HBRUSH)NULL));
}

/******************************Public*Routine******************************\
* ExtCreatePen
*
* Client side stub.  The style array is appended to the end of the
* EXTLOGPEN structure, and if the call requires a DIBitmap it is appended
* at the end of this.
*
* History:
*  Wed 22-Jan-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HPEN WINAPI ExtCreatePen
(
    DWORD       iPenStyle,
    DWORD       cWidth,
    CONST LOGBRUSH *plbrush,
    DWORD       cStyle,
    CONST DWORD *pstyle
)
{
    HANDLE            hRet;
    ULONG             cjStyle;
    ULONG             cjBitmap = 0;
    ULONG_PTR          lNewHatch;
    BITMAPINFOHEADER* pbmi = (BITMAPINFOHEADER*) NULL;
    UINT              uiBrushStyle = plbrush->lbStyle;
    PVOID             pbmiDIB = NULL;

    if ((iPenStyle & PS_STYLE_MASK) == PS_USERSTYLE)
    {
        if (pstyle == (LPDWORD) NULL)
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return((HPEN) 0);
        }
    }
    else
    {
    // Make sure style array is empty if PS_USERSTYLE not specified:

        if (cStyle != 0 || pstyle != (LPDWORD) NULL)
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return((HPEN) 0);
        }
    }

    switch(uiBrushStyle)
    {
    case BS_SOLID:
    case BS_HOLLOW:
    case BS_HATCHED:
        lNewHatch = plbrush->lbHatch;
        break;

    case BS_PATTERN:
        lNewHatch = plbrush->lbHatch;
        if (lNewHatch == 0)
            return((HPEN) 0);
        break;

    case BS_DIBPATTERNPT:
        pbmi = (BITMAPINFOHEADER *) plbrush->lbHatch;
        pbmiDIB = (PVOID) pbmiConvertInfo ((BITMAPINFO *) pbmi, plbrush->lbColor, &cjBitmap, TRUE);
        lNewHatch = (ULONG_PTR)pbmiDIB;
        break;

    case BS_DIBPATTERN:
        // Convert BS_DIBPATTERN to a BS_DIBPATTERNPT call:

        uiBrushStyle = BS_DIBPATTERNPT;
        pbmi = (BITMAPINFOHEADER *) GlobalLock((HANDLE) plbrush->lbHatch);
        if (pbmi == (BITMAPINFOHEADER *) NULL)
            return((HPEN) 0);

        pbmiDIB = (PVOID) pbmiConvertInfo ((BITMAPINFO *) pbmi, plbrush->lbColor, &cjBitmap, TRUE);
        lNewHatch = (ULONG_PTR)pbmiDIB;

        break;
    }

// Ask the server to create the pen:

    cjStyle = cStyle * sizeof(DWORD);

    hRet = NtGdiExtCreatePen(
                        iPenStyle,
                        cWidth,
                        uiBrushStyle,
                        plbrush->lbColor,
                        plbrush->lbHatch,
                        lNewHatch,
                        cStyle,
                        (DWORD*)pstyle,
                        cjBitmap,
                        FALSE,
                        0);

    if (hRet)
    {
        ASSERTGDI(((LO_TYPE (hRet) == LO_PEN_TYPE) ||
                   (LO_TYPE (hRet) == LO_EXTPEN_TYPE)), "EXTCreatePen - type wrong\n");
    }

    if (plbrush->lbStyle == BS_DIBPATTERN)
        GlobalUnlock((HANDLE) plbrush->lbHatch);

    if (pbmiDIB && (pbmiDIB != (PVOID)pbmi))
        LOCALFREE(pbmiDIB);

    return((HPEN) hRet);
}

/******************************Public*Routine******************************\
* CreatePenIndirect                                                        *
*                                                                          *
* Client side stub.  Maps to the single pen creation routine.              *
*                                                                          *
* History:                                                                 *
*  Tue 04-Jun-1991 16:21:56 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HPEN WINAPI CreatePenIndirect(CONST LOGPEN *plpen)
{

    return
      CreatePen
      (
        plpen->lopnStyle,
        plpen->lopnWidth.x,
        plpen->lopnColor
      );
}

/******************************Public*Routine******************************\
* CreateCompatibleBitmap                                                   *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Tue 04-Jun-1991 16:35:51 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bDIBSectionSelected(
    PDC_ATTR pdca
    )
{
    BOOL bRet = FALSE;

    if ((pdca != NULL) && ((pdca->ulDirty_ & DC_DIBSECTION)))
    {
        bRet = TRUE;
    }

    return(bRet);
}


HBITMAP WINAPI CreateCompatibleBitmap
(
    HDC   hdc,
    int cx,
    int cy
)
{
    HBITMAP hbm;

    //
    // validate hdc
    //

    PDC_ATTR pdca;

    FIXUP_HANDLEZ(hdc);

    PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

    if (pdca)
    {
        ULONG  ulRet;
        DWORD  bmi[(sizeof(DIBSECTION)+256*sizeof(RGBQUAD))/sizeof(DWORD)];

    // check if it is an empty bitmap

        if ((cx == 0) || (cy == 0))
        {
            return(GetStockObject(PRIV_STOCK_BITMAP));
        }

        if (bDIBSectionSelected(pdca))
        {
            if (GetObject((HBITMAP)GetDCObject(hdc, LO_BITMAP_TYPE), sizeof(DIBSECTION),
                          &bmi) != (int)sizeof(DIBSECTION))
            {
                WARNING("CreateCompatibleBitmap: GetObject failed\n");
                return((HBITMAP) 0);
            }

            if (((DIBSECTION *)&bmi)->dsBm.bmBitsPixel <= 8)
                GetDIBColorTable(hdc, 0, 256,
                                 (RGBQUAD *)&((DIBSECTION *)&bmi)->dsBitfields[0]);

            ((DIBSECTION *)&bmi)->dsBmih.biWidth = cx;
            ((DIBSECTION *)&bmi)->dsBmih.biHeight = cy;

            return(CreateDIBSection(hdc, (BITMAPINFO *)&((DIBSECTION *)&bmi)->dsBmih,
                                    DIB_RGB_COLORS, NULL, 0, 0));
        }

        hbm = NtGdiCreateCompatibleBitmap(hdc,cx,cy);

#if TRACE_SURFACE_ALLOCS
        {
            PULONG  pUserAlloc;

            PSHARED_GET_VALIDATE(pUserAlloc, hbm, SURF_TYPE);

            if (pUserAlloc != NULL)
            {
                pUserAlloc[1] = RtlWalkFrameChain((PVOID *)&pUserAlloc[2], pUserAlloc[0], 0);
            }
        }
#endif

        return(hbm);
    }

    return(NULL);
}

/******************************Public*Routine******************************\
* CreateDiscardableBitmap                                                  *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Tue 04-Jun-1991 16:35:51 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HBITMAP WINAPI CreateDiscardableBitmap
(
    HDC   hdc,
    int   cx,
    int   cy
)
{
    return CreateCompatibleBitmap(hdc, cx, cy);
}

/******************************Public*Routine******************************\
* CreateEllipticRgn                                                        *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Tue 04-Jun-1991 16:58:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HRGN WINAPI CreateEllipticRgn(int x1,int y1,int x2,int y2)
{
    return(NtGdiCreateEllipticRgn(x1,y1,x2,y2));
}

/******************************Public*Routine******************************\
* CreateEllipticRgnIndirect                                                *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Tue 04-Jun-1991 16:58:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HRGN WINAPI CreateEllipticRgnIndirect(CONST RECT *prcl)
{
    return
      CreateEllipticRgn
      (
        prcl->left,
        prcl->top,
        prcl->right,
        prcl->bottom
      );
}

/******************************Public*Routine******************************\
* CreateRoundRectRgn                                                       *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Tue 04-Jun-1991 17:23:16 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HRGN WINAPI CreateRoundRectRgn
(
    int x1,
    int y1,
    int x2,
    int y2,
    int cx,
    int cy
)
{
    return(NtGdiCreateRoundRectRgn(x1,y1,x2,y2,cx,cy));
}

/******************************Public*Routine******************************\
* CreatePalette                                                            *
*                                                                          *
* Simple client side stub.                                                 *
*                                                                          *
* Warning:                                                                 *
*   The pv field of a palette's lhe is used to determine if a palette      *
*   has been modified since it was last realized.  SetPaletteEntries       *
*   and ResizePalette will increment this field after they have            *
*   modified the palette.  It is only updated for metafiled palettes       *
*                                                                          *
*  Tue 04-Jun-1991 20:43:39 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HPALETTE WINAPI CreatePalette(CONST LOGPALETTE *plpal)
{

    return(NtGdiCreatePaletteInternal((LOGPALETTE*)plpal,plpal->palNumEntries));

}

/******************************Public*Routine******************************\
* CreateFontIndirectExW                                                    *
*                                                                          *
* Client Side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  7-12-94 -by- Lingyun Wang [lingyunw] removed LOCALFONT                  *
*  Sun 10-Jan-1993 04:08:33 -by- Charles Whitmer [chuckwh]                 *
* Restructured for best tail merging.  Added creation of the LOCALFONT.    *
*                                                                          *
*  Thu 15-Aug-1991 08:40:26 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

HFONT WINAPI CreateFontIndirectExW(CONST ENUMLOGFONTEXDVW *pelfw)
{
    LOCALFONT *plf;
    FLONG  fl = 0;
    HFONT hfRet = (HFONT) 0;

    if (pelfw->elfEnumLogfontEx.elfLogFont.lfEscapement | pelfw->elfEnumLogfontEx.elfLogFont.lfOrientation)
    {
        fl = LF_HARDWAY;
    }

    ENTERCRITICALSECTION(&semLocal);
    plf = plfCreateLOCALFONT(fl);
    LEAVECRITICALSECTION(&semLocal);

    if( plf != NULL )
    {
        if (pelfw->elfDesignVector.dvNumAxes <= MM_MAX_NUMAXES)
        {
            ULONG cjElfw = offsetof(ENUMLOGFONTEXDVW,elfDesignVector) +
                           SIZEOFDV(pelfw->elfDesignVector.dvNumAxes) ;
            hfRet = NtGdiHfontCreate((ENUMLOGFONTEXDVW *)pelfw, cjElfw, LF_TYPE_USER, 0, (PVOID) plf);
        }
    }

    if( !hfRet && plf )
    {
        vDeleteLOCALFONT( plf );
    }

    return(hfRet);
}


/******************************Public*Routine******************************\
* CreateFontIndirect                                                       *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Fri 16-Aug-1991 12:35:17 by Kirk Olynyk [kirko]                         *                          *
* Now uses CreateFontIndirectExW().                                       *
*                                                                          *
*  Tue 04-Jun-1991 21:06:44 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HFONT WINAPI CreateFontIndirectA(CONST LOGFONTA *plf)
{
    ENUMLOGFONTEXDVW elfw;

    if (plf == (LPLOGFONTA) NULL)
        return ((HFONT) 0);

    vConvertLogFont(&elfw,(LOGFONTA *) plf);

    if (GetAppCompatFlags2(VER40) & GACF2_DEFAULTCHARSET)
    {
        if (!_wcsicmp(elfw.elfEnumLogfontEx.elfLogFont.lfFaceName, L"OCR-A"))
            elfw.elfEnumLogfontEx.elfLogFont.lfCharSet = (BYTE) DEFAULT_CHARSET;
    }

    return(CreateFontIndirectExW(&elfw));
}

/******************************Public*Routine******************************\
* CreateFont                                                               *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Tue 04-Jun-1991 21:06:44 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HFONT WINAPI
CreateFontA(
    int      cHeight,
    int      cWidth,
    int      cEscapement,
    int      cOrientation,
    int      cWeight,
    DWORD    bItalic,
    DWORD    bUnderline,
    DWORD    bStrikeOut,
    DWORD    iCharSet,
    DWORD    iOutPrecision,
    DWORD    iClipPrecision,
    DWORD    iQuality,
    DWORD    iPitchAndFamily,
    LPCSTR   pszFaceName
    )
{
    LOGFONTA lf;

    lf.lfHeight             = (LONG)  cHeight;
    lf.lfWidth              = (LONG)  cWidth;
    lf.lfEscapement         = (LONG)  cEscapement;
    lf.lfOrientation        = (LONG)  cOrientation;
    lf.lfWeight             = (LONG)  cWeight;
    lf.lfItalic             = (BYTE)  bItalic;
    lf.lfUnderline          = (BYTE)  bUnderline;
    lf.lfStrikeOut          = (BYTE)  bStrikeOut;
    lf.lfCharSet            = (BYTE)  iCharSet;
    lf.lfOutPrecision       = (BYTE)  iOutPrecision;
    lf.lfClipPrecision      = (BYTE)  iClipPrecision;
    lf.lfQuality            = (BYTE)  iQuality;
    lf.lfPitchAndFamily     = (BYTE)  iPitchAndFamily;
    {
        INT jj;

    // Copy the facename if pointer not NULL.

        if (pszFaceName != (LPSTR) NULL)
        {
            for (jj=0; jj<LF_FACESIZE; jj++)
            {
                if( ( lf.lfFaceName[jj] = pszFaceName[jj] ) == 0 )
                {
                    break;
                }
            }
        }
        else
        {
            // If NULL pointer, substitute a NULL string.

            lf.lfFaceName[0] = '\0';
        }
    }

    return(CreateFontIndirectA(&lf));
}

/******************************Public*Routine******************************\
* HFONT WINAPI CreateFontIndirectW(LPLOGFONTW plfw)                        *
*                                                                          *
* History:                                                                 *
*  Fri 16-Aug-1991 14:12:44 by Kirk Olynyk [kirko]                         *
* Now uses CreateFontIndirectExW().                                       *
*                                                                          *
*  13-Aug-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/

HFONT WINAPI CreateFontIndirectW(CONST LOGFONTW *plfw)
{
    ENUMLOGFONTEXDVW elfw;

    if (plfw == (LPLOGFONTW) NULL)
        return ((HFONT) 0);

    vConvertLogFontW(&elfw,(LOGFONTW *)plfw);

    if (GetAppCompatFlags2(VER40) & GACF2_DEFAULTCHARSET)
    {
        if (!_wcsicmp(elfw.elfEnumLogfontEx.elfLogFont.lfFaceName, L"OCR-A"))
            elfw.elfEnumLogfontEx.elfLogFont.lfCharSet = (BYTE) DEFAULT_CHARSET;
    }

    return(CreateFontIndirectExW(&elfw));
}

/******************************Public*Routine******************************\
* HFONT WINAPI CreateFontW, UNICODE version of CreateFont                  *
*                                                                          *
* History:                                                                 *
*  13-Aug-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/

HFONT WINAPI CreateFontW
(
    int      cHeight,
    int      cWidth,
    int      cEscapement,
    int      cOrientation,
    int      cWeight,
    DWORD    bItalic,
    DWORD    bUnderline,
    DWORD    bStrikeOut,
    DWORD    iCharSet,
    DWORD    iOutPrecision,
    DWORD    iClipPrecision,
    DWORD    iQuality,
    DWORD    iPitchAndFamily,
    LPCWSTR  pwszFaceName
)
{
    LOGFONTW lfw;

    lfw.lfHeight             = (LONG)  cHeight;
    lfw.lfWidth              = (LONG)  cWidth;
    lfw.lfEscapement         = (LONG)  cEscapement;
    lfw.lfOrientation        = (LONG)  cOrientation;
    lfw.lfWeight             = (LONG)  cWeight;
    lfw.lfItalic             = (BYTE)  bItalic;
    lfw.lfUnderline          = (BYTE)  bUnderline;
    lfw.lfStrikeOut          = (BYTE)  bStrikeOut;
    lfw.lfCharSet            = (BYTE)  iCharSet;
    lfw.lfOutPrecision       = (BYTE)  iOutPrecision;
    lfw.lfClipPrecision      = (BYTE)  iClipPrecision;
    lfw.lfQuality            = (BYTE)  iQuality;
    lfw.lfPitchAndFamily     = (BYTE)  iPitchAndFamily;
    {
        INT jj;

    // Copy the facename if pointer not NULL.

        if (pwszFaceName != (LPWSTR) NULL)
        {
            for (jj=0; jj<LF_FACESIZE; jj++)
            {
                if( ( lfw.lfFaceName[jj] = pwszFaceName[jj] ) == (WCHAR) 0 )
                {
                    break;
                }
            }
        }
        else
        {
            // If NULL pointer, substitute a NULL string.

            lfw.lfFaceName[0] = L'\0';
        }
    }

    return(CreateFontIndirectW(&lfw));
}

/******************************Public*Routine******************************\
* CreateFontIndirectExA                                                   *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  31-Jan-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

HFONT WINAPI CreateFontIndirectExA(CONST ENUMLOGFONTEXDVA *pelf)
{
    ENUMLOGFONTEXDVW elfw;

    if (!pelf)
        return ((HFONT) 0);

    vConvertEnumLogFontExDvAtoW(&elfw, (ENUMLOGFONTEXDVA *)pelf);

    if (GetAppCompatFlags2(VER40) & GACF2_DEFAULTCHARSET)
    {
        if (!_wcsicmp(elfw.elfEnumLogfontEx.elfLogFont.lfFaceName, L"OCR-A"))
            elfw.elfEnumLogfontEx.elfLogFont.lfCharSet = (BYTE) DEFAULT_CHARSET;
    }

    return(CreateFontIndirectExW(&elfw));
}

/******************************Public*Routine******************************\
* UnrealizeObject
*
* This nukes the realization for a object.
*
* History:
*  16-May-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL WINAPI UnrealizeObject(HANDLE h)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(h);

// Validate the object.  Only need to handle palettes.

    if (LO_TYPE(h) == LO_BRUSH_TYPE)
    {
        bRet = TRUE;
    }
    else
    {
        bRet = NtGdiUnrealizeObject(h);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* DeleteObject()
*
\**************************************************************************/

BOOL META DeleteObject (HANDLE h)
{
    BOOL bRet = TRUE;
    INT iType = GRE_TYPE(h);
    BOOL bValidate;
    BOOL bDynamicNonStock;
    LOCALFONT *plf = NULL;    // essental initialization

    FIXUP_HANDLEZ(h);

    VALIDATE_HANDLE_AND_STOCK (bValidate, h, iType, bDynamicNonStock);
    if (!bValidate)
    {
        if (!bValidate)
            return (0);
    }

        if (iType != DC_TYPE)
        {
            if ((LO_TYPE(h) == LO_METAFILE16_TYPE) || (LO_TYPE(h) == LO_METAFILE_TYPE))
            {
                return(FALSE);
            }
            else if (LO_TYPE(h) == LO_REGION_TYPE)
            {
                return(DeleteRegion(h));
            }
            else if (LO_TYPE(h) == LO_ICMLCS_TYPE)
            {
            // ATTENTION: Win95 does not allow delete ColorSpace by DeleteObject()
            // This might causes imcompatibility... but keep consistant 
            // with other GDI objects                                   

                return(DeleteColorSpace(h));
            }
            else if (IS_STOCKOBJ(h))
            {
            // Don't delete a stock object, just return TRUE for 3.1 compatibility.

                return(TRUE);
            }
            else
            {
            // Inform the metafile if it knows this object.

                if (pmetalink16Get(h) != NULL)
                {
                // must recheck the metalink because MF_DeleteObject might delete it

                    if (!MF_DeleteObject(h) ||
                        (pmetalink16Get(h) && !MF16_DeleteObject(h)))
                    {
                        return(FALSE);
                    }
                }

            // handle delete LogFont

                if (LO_TYPE(h) == LO_FONT_TYPE)
                {
                    PSHARED_GET_VALIDATE(plf,h,LFONT_TYPE);

                    if (plf)
                    {
                    // we always force deletion of the client side memory even if
                    // the font is still selected in some dc's. All that means is that
                    // text api's will have to go through the slow code paths in this
                    // pathological case.

                        vDeleteLOCALFONT(plf);
                    }
                }

                if (bDynamicNonStock)
                    h = (HANDLE)((ULONG_PTR)h|GDISTOCKOBJ);

            // handle deletebrush

                if (
                     (LO_TYPE(h) == LO_BRUSH_TYPE) ||
                     (LO_TYPE(h) == LO_PEN_TYPE)
                   )
                {
                    PBRUSHATTR pBrushattr;

                    PSHARED_GET_VALIDATE(pBrushattr,h,BRUSH_TYPE);

                    if (
                         (bDynamicNonStock) ||
                         ((pBrushattr) &&
                         (!(pBrushattr->AttrFlags & (ATTR_CACHED|ATTR_TO_BE_DELETED|ATTR_CANT_SELECT))))
                       )
                    {
                        BEGIN_BATCH(BatchTypeDeleteBrush,BATCHDELETEBRUSH);

                            if (!bDynamicNonStock)
                                pBrushattr->AttrFlags |= ATTR_CANT_SELECT;
                            pBatch->Type    = BatchTypeDeleteBrush;
                            pBatch->Length  = sizeof(BATCHDELETEBRUSH);
                            pBatch->hbrush  = h;

                        COMPLETE_BATCH_COMMAND();

                        return(TRUE);
                    }

                }

            // handle delete bitmap

                if (LO_TYPE(h) == LO_BITMAP_TYPE)
                {
                    // PCACHED_COLORSPACE pColorSpace;
                    //
                    // if this bitmap has thier own color space delete it, too.
                    //
                    // [NOTE:] Only DIB section can has a thier own color space,
                    // then, if we can identify this is DIB section or not from
                    // client side, we can optimize this call for non-DIB section case.
                    //
                    // pColorSpace = IcmGetColorSpaceforBitmap(h);
                    //
                    // if (pColorSpace)
                    // {
                    //     IcmReleaseColorSpace((HGDIOBJ)h,pColorSpace,TRUE);
                    // }
                    //

                    //
                    // Release any color space associated to this bitmap.
                    //
                    IcmReleaseCachedColorSpace((HGDIOBJ)h);
                }
            }

UNBATCHED_COMMAND:

            bRet = NtGdiDeleteObjectApp(h);

            #if DBG
                if (bRet && (LO_TYPE(h) == LO_FONT_TYPE))
                {
                    PSHARED_GET_VALIDATE(plf,h,LFONT_TYPE);
                    ASSERTGDI(plf == NULL, "DeleteFont: plf nonzero after deletion\n");
                }
            #endif
        }
        else
        {
            bRet = DeleteDC(h);
        }

    return(bRet);
}

/**************************************************************************\
* SelectObject
*
*  Thu 06-Jun-1991 00:58:46 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

HANDLE META SelectObject(HDC hdc,HANDLE h)
{
    HANDLE hRet = 0;
    HDC  *phdc;
    FLONG fl;
    INT   iType;
    PDC_ATTR pdcattr = NULL;
    BOOL bValid;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE_NOW(h);

    VALIDATE_HANDLE(bValid, h, GRE_TYPE(h));

    if (!bValid)
    {
       return (HANDLE)0;
    }

    iType = LO_TYPE(h);

    // Palettes isn't allowed

    if (iType == LO_PALETTE_TYPE)
    {
        SetLastError(ERROR_INVALID_FUNCTION);
        return (HANDLE)0;
    }

    // Do region first so that it is not metafiled twice.

    if (iType == LO_REGION_TYPE)
    {
        LONG_PTR iRet = ExtSelectClipRgn(hdc,h,RGN_COPY);
        return((HANDLE)iRet);
    }
    else if (iType == LO_ICMLCS_TYPE)
    {
        return(SetColorSpace(hdc,h));
    }

    //
    // Metafile the call.
    //

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_SelectObject(hdc, h));

        DC_PLDC(hdc,pldc,0);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SelectAnyObject(hdc,h,EMR_SELECTOBJECT))
                return((HANDLE) 0);
        }
    }

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        switch (iType)
        {
        case LO_EXTPEN_TYPE:

            if (bNeedTranslateColor(pdcattr))
            {
                return(IcmSelectExtPen(hdc,pdcattr,h));
            }

            //hRet = NtGdiSelectPen(hdc,(HPEN)h);
            pdcattr->ulDirty_ |= DC_PEN_DIRTY;
            hRet = pdcattr->hpen;
            pdcattr->hpen = h;

            break;

        case LO_PEN_TYPE:

            if (bNeedTranslateColor(pdcattr))
            {
                return(IcmSelectPen(hdc,pdcattr,h));
            }

            //
            // Always set the dirty flag to
            // make sure the brush is checked in
            // the kernel. For example, NEW_COLOR, might be set.
            //

            pdcattr->ulDirty_ |= DC_PEN_DIRTY;
            hRet = pdcattr->hpen;
            pdcattr->hpen = h;

            break;

        case LO_BRUSH_TYPE:

            if (bNeedTranslateColor(pdcattr))
            {
                return(IcmSelectBrush(hdc,pdcattr,h));
            }

            //
            // Always set the dirty flag to
            // make sure the brush is checked in
            // the kernel. For example, NEW_COLOR, might be set.
            //

            pdcattr->ulDirty_ |= DC_BRUSH_DIRTY;
            hRet = pdcattr->hbrush;
            pdcattr->hbrush = h;

            break;

        case LO_BITMAP_TYPE:
            {
                BOOL bDIBSelected;

                //
                // Currently DIB section is selected ?
                //
                bDIBSelected = bDIBSectionSelected(pdcattr);

                //
                // Select bitmap into DC.
                //

                hRet = NtGdiSelectBitmap(hdc,(HBITMAP)h);

                if (hRet)
                {
                    //
                    // DDB to DDB case, color space never has been changed.
                    //
                    if (bDIBSelected || bDIBSectionSelected(pdcattr))
                    {
                        //
                        // Marks the color space might be changed.
                        //
                        pdcattr->ulDirty_ |= (DIRTY_COLORSPACE|DIRTY_COLORTRANSFORM);

                        //
                        // if ICM is currently turned-ON, update now.
                        //
                        if (IS_ICM_INSIDEDC(pdcattr->lIcmMode))
                        {
                            //
                            // Destination bitmap surface has been changed,
                            // then need to update destination color space and
                            // color transform.
                            //
                            IcmUpdateDCColorInfo(hdc,pdcattr);
                        }
                    }
                }
            }

            break;

        case LO_FONT_TYPE:
            {
                UINT uiIndex = HANDLE_TO_INDEX(h);
                PENTRY pentry = NULL;

                pentry = &pGdiSharedHandleTable[uiIndex];

                if (pentry->Flags & HMGR_ENTRY_LAZY_DEL)
                {
                   hRet = 0;
                }
                else
                {
                   hRet = pdcattr->hlfntNew;

                   if (DIFFHANDLE(hRet, h))
                   {
                      pdcattr->ulDirty_ |= DIRTY_CHARSET;
                      pdcattr->ulDirty_ &= ~SLOW_WIDTHS;

                      pdcattr->hlfntNew = h;

                      //
                      // batch selectfont, to ensure ref count is correct when
                      // deletefont comes in
                      // we have to allow lazy deletion.
                      //
                      BEGIN_BATCH_HDC(hdc,pdcattr,BatchTypeSelectFont,BATCHSELECTFONT);

                          pBatch->hFont  = h;

                      COMPLETE_BATCH_COMMAND();
                          return ((HANDLE)hRet);

                      UNBATCHED_COMMAND:
                          return(NtGdiSelectFont(hdc,h));

                   }

                }
            }
            break;

        default:
            break;
        }
    }
    else
    {
        WARNING("Bad DC passed to SelectObject\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        hRet = 0;
    }


    return((HANDLE) hRet);
}

/******************************Public*Routine******************************\
* GetCurrentObject                                                         *
*                                                                          *
* Client side routine.                                                     *
*                                                                          *
*  03-Oct-1991 00:58:46 -by- John Colleran [johnc]                         *
* Wrote it.                                                                *
\**************************************************************************/

HANDLE WINAPI GetCurrentObject(HDC hdc, UINT iObjectType)
{
    HANDLE hRet;

    FIXUP_HANDLE(hdc);

    switch (iObjectType)
    {
    case OBJ_BRUSH:
        iObjectType = LO_BRUSH_TYPE;
        break;

    case OBJ_PEN:
    case OBJ_EXTPEN:
        iObjectType = LO_PEN_TYPE;
        break;

    case OBJ_FONT:
        iObjectType = LO_FONT_TYPE;
        break;

    case OBJ_PAL:
        iObjectType = LO_PALETTE_TYPE;
        break;

    case OBJ_BITMAP:
        iObjectType = LO_BITMAP_TYPE;
        break;

    case OBJ_COLORSPACE:
        iObjectType = LO_ICMLCS_TYPE;
        break;

    default:
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return((HANDLE) 0);
    }

    hRet = GetDCObject(hdc, iObjectType);

    return(hRet);
}

/******************************Public*Routine******************************\
* GetStockObject                                                           *
*                                                                          *
* A simple function which looks the object up in a table.                  *
*                                                                          *
\**************************************************************************/

HANDLE
GetStockObject(
    int iObject)
{
    //
    // if it is in range, 0 - PRIV_STOCK_LAST, and we have gotten the stock
    // objects, return the handle.  Otherwise fail.
    //

    //
    // WINBUG #82871 2-7-2000 bhouse Possible bug in GetStockObject
    // Old Comment:
    //     - what about our private stock bitmap ??
    //
    // NOTE we should make this table part of the shared section since it is
    // used by all applications.
    //

    if ((ULONG)iObject <= PRIV_STOCK_LAST)
    {
        if ((HANDLE) ahStockObjects[iObject] == NULL)
        {
            //
            // If the kernel transition fails, the return value
            // may actually an NTSTATUS return value such as
            // STATUS_INVALID_SYSTEM_SERVICE (this has happened
            // under rare stress scenarios).
            //
            // If we return the occasional bad handle under stress,
            // so be it, but we shouldn't cache these bad handles
            // in gdi32.dll.  So do validation before accepting
            // the handle.
            //

            HANDLE h = NtGdiGetStockObject(iObject);
            BOOL bValid;

            VALIDATE_HANDLE(bValid, h, GRE_TYPE(h));

            if (bValid)
            {
                ahStockObjects[iObject] = (ULONG_PTR) h;
            }
        }
        return((HANDLE) ahStockObjects[iObject]);
    }
    else
    {
        return((HANDLE)0);
    }
}

/******************************Public*Routine******************************\
* EqualRgn                                                                 *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Thu 06-Jun-1991 00:58:46 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI EqualRgn(HRGN hrgnA,HRGN hrgnB)
{
    FIXUP_HANDLE(hrgnA);
    FIXUP_HANDLE(hrgnB);

    return(NtGdiEqualRgn(hrgnA,hrgnB));
}

/******************************Public*Routine******************************\
* GetBitmapDimensionEx                                                       *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Thu 06-Jun-1991 00:58:46 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI GetBitmapDimensionEx(HBITMAP hbm,LPSIZE psizl)
{
    FIXUP_HANDLE(hbm);

    return(NtGdiGetBitmapDimension(hbm, psizl));
}

/******************************Public*Routine******************************\
* GetNearestPaletteIndex
*
* Client side stub.
*
*  Sat 31-Aug-1991 -by- Patrick Haluptzok [patrickh]
* Change to UINT
*
*  Thu 06-Jun-1991 00:58:46 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

UINT WINAPI GetNearestPaletteIndex(HPALETTE hpal,COLORREF color)
{
    FIXUP_HANDLE(hpal);

    return(NtGdiGetNearestPaletteIndex(hpal,color));
}

/******************************Public*Routine******************************\
* ULONG cchCutOffStrLen(PSZ pwsz, ULONG cCutOff)
*
* search for terminating zero but make sure not to slipp off the edge,
* return value counts in the term. zero if one is found
*
*
* History:
*  22-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

ULONG cchCutOffStrLen(PSZ psz, ULONG cCutOff)
{
    ULONG cch;

    for(cch = 0; cch < cCutOff; cch++)
    {
        if (*psz++ == 0)
            return(cch);        // terminating NULL is NOT included in count!
    }

    return(cCutOff);
}

/******************************Public*Routine******************************\
* ULONG cwcCutOffStrLen(PWSZ pwsz, ULONG cCutOff)
*
* search for terminating zero but make sure not to slipp off the edge,
* return value counts in the term. zero if one is found
*
*
* History:
*  22-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

ULONG cwcCutOffStrLen(PWSZ pwsz, ULONG cCutOff)
{
    ULONG cwc;

    for(cwc = 0; cwc < cCutOff; cwc++)
    {
        if (*pwsz++ == 0)
            return(cwc + 1);  // include the terminating NULL
    }

    return(cCutOff);
}

/******************************Public*Routine******************************\
* int cjGetNonFontObject()
*
* Does a GetObject on all objects that are not fonts.
*
* History:
*  19-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

int cjGetNonFontObject(HANDLE h, int c, LPVOID pv)
{
    int cRet = 0;
    int cGet = c;
    int iType;

    iType = LO_TYPE(h);

    ASSERTGDI(iType != LO_FONT_TYPE, "Can't handle fonts");

    if (iType == LO_REGION_TYPE)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(cRet);
    }

    if (pv == NULL)
    {
        if (iType == LO_BRUSH_TYPE)
        {
            return(sizeof(LOGBRUSH));
        }
        else if (iType == LO_PEN_TYPE)
        {
            return(sizeof(LOGPEN));
        }
    }

    FIXUP_HANDLE_NOW (h);

    cRet = NtGdiExtGetObjectW(h,c,pv);

    return(cRet);
}

/******************************Public*Routine******************************\
* int WINAPI GetObjectW(HANDLE h,int c,LPVOID pv)
*
* History:
*  07-Dec-1994 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

int  WINAPI GetObjectW(HANDLE h,int c,LPVOID pv)
{
    int cRet = 0;

    FIXUP_HANDLEZ(h);

    switch (LO_TYPE(h))
    {
    case LO_ALTDC_TYPE:
    case LO_DC_TYPE:
    case LO_METAFILE16_TYPE:
    case LO_METAFILE_TYPE:
        GdiSetLastError(ERROR_INVALID_HANDLE);
        cRet = 0;
        break;

    case LO_FONT_TYPE:
        if (pv == (LPVOID) NULL)
        {
            return(sizeof(LOGFONTW));
        }

        if (c > (int)sizeof(ENUMLOGFONTEXDVW))
            c = (int)sizeof(ENUMLOGFONTEXDVW);

        cRet = NtGdiExtGetObjectW(h,c,pv);

        break;

    case LO_ICMLCS_TYPE:
        if (GetLogColorSpaceW(h,pv,c))
        {
            cRet = sizeof(LOGCOLORSPACEW);
        }
        break;

    default:
        cRet = cjGetNonFontObject(h,c,pv);
        break;
    }

    return(cRet);
}

/******************************Public*Routine******************************\
* int WINAPI GetObjectA(HANDLE h,int c,LPVOID pv)
*
* History:
*  07-Dec-1994 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

int  WINAPI GetObjectA(HANDLE h,int c,LPVOID pv)
{
    int  cRet = 0;

    FIXUP_HANDLEZ(h);

    switch (LO_TYPE(h))
    {
    case LO_ALTDC_TYPE:
    case LO_DC_TYPE:
    case LO_METAFILE16_TYPE:
    case LO_METAFILE_TYPE:
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(0);

    case LO_FONT_TYPE:
        break;

    case LO_ICMLCS_TYPE:
        if (GetLogColorSpaceA(h,pv,c))
        {
            cRet = sizeof(LOGCOLORSPACEW);
        }
        break;

    default:
        return(cjGetNonFontObject(h,c,pv));
    }

// Now handle only font objects:

    if (pv)
    {
        ENUMLOGFONTEXDVW elfw;

        cRet = NtGdiExtGetObjectW(h,sizeof(ENUMLOGFONTEXDVW),&elfw);

        if (cRet)
        {
        // we shall optimize usual cases when the caller is asking the whole thing

            //
            // Hack, Hack:Office ME 97 call GetObjectA with a pointer to LOGFONTA and
            // specify c = sizeof(LOGFONTW) by mistake, But it use to work under NT 4
            // Then what we do here is check this case and still return the sizeof(LOGFONTA)
            //

            if ((c == sizeof(LOGFONTA)) || (c == sizeof(LOGFONTW)))
            {
                if (bConvertLogFontWToLogFontA((LOGFONTA *)pv,
                                               &elfw.elfEnumLogfontEx.elfLogFont))
                {
                    cRet = sizeof(LOGFONTA);
                }
                else
                {
                    cRet = 0;
                }
            }
            else if (c == sizeof(ENUMLOGFONTEXA))
            {
                if (bConvertEnumLogFontExWToEnumLogFontExA((ENUMLOGFONTEXA*)pv, &elfw.elfEnumLogfontEx))
                {
                    cRet = c;
                }
                else
                {
                    cRet = 0;
                }
            }
            else if (c == sizeof(ENUMLOGFONTEXDVA))
            {
                if (bConvertEnumLogFontExWToEnumLogFontExA((ENUMLOGFONTEXA*)pv, &elfw.elfEnumLogfontEx))
                {
                // copy out design vector

                    RtlMoveMemory(&((ENUMLOGFONTEXDVA*)pv)->elfDesignVector,
                                  &elfw.elfDesignVector,
                                  SIZEOFDV(elfw.elfDesignVector.dvNumAxes));

                    cRet = c;
                }
                else
                {
                    cRet = 0;
                }
            }
            else // general case
            {
                ENUMLOGFONTEXDVA elfa;
                c = min(c,sizeof(ENUMLOGFONTEXDVA));

                if (bConvertEnumLogFontExWToEnumLogFontExA(&elfa.elfEnumLogfontEx,
                                                           &elfw.elfEnumLogfontEx))
                {

                // copy out design vector

                    RtlMoveMemory(&elfa.elfDesignVector,
                                  &elfw.elfDesignVector,
                                  SIZEOFDV(elfw.elfDesignVector.dvNumAxes));

                    cRet = c;
                    RtlMoveMemory(pv,&elfa,cRet);
                }
                else
                {
                    cRet = 0;
                }
            }
        }
    }
    else
    {
        cRet = sizeof(LOGFONTA);
    }

    return(cRet);
}


/******************************Public*Routine******************************\
* GetObjectType(HANDLE)
*
* History:
*  25-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

DWORD alPublicTypes[] =
{
    0,              // LO_NULL,
    OBJ_DC,         // LO_DC,
    OBJ_ENHMETADC   // LO_METADC,
};

DWORD GetObjectType(HGDIOBJ h)
{
    DWORD dwRet = 0;
    UINT uiIndex;

    FIXUP_HANDLE(h);

    uiIndex = HANDLE_TO_INDEX(h);

    if (uiIndex < MAX_HANDLE_COUNT)
    {
        PENTRY pentry = &pGdiSharedHandleTable[uiIndex];

        if (
             (pentry->FullUnique == (USHORT)((ULONG_PTR)h >> 16)) &&
             ((OBJECTOWNER_PID(pentry->ObjectOwner) == gW32PID) ||
              (OBJECTOWNER_PID(pentry->ObjectOwner) == 0))
              )
        {
            switch (LO_TYPE(h))
            {
            case LO_BRUSH_TYPE:
                dwRet = OBJ_BRUSH;
                break;

            case LO_REGION_TYPE:
                dwRet = OBJ_REGION;
                break;

            case LO_PEN_TYPE:
                dwRet = OBJ_PEN;
                break;

            case LO_EXTPEN_TYPE:
                dwRet = OBJ_EXTPEN;
                break;

            case LO_FONT_TYPE:
                dwRet = OBJ_FONT;
                break;

            case LO_BITMAP_TYPE:
                dwRet = OBJ_BITMAP;
                break;

            case LO_PALETTE_TYPE:
                dwRet = OBJ_PAL;
                break;

            case LO_METAFILE16_TYPE:
                dwRet = OBJ_METAFILE;
                break;

            case LO_METAFILE_TYPE:
                dwRet = OBJ_ENHMETAFILE;
                break;

            case LO_METADC16_TYPE:
                dwRet = OBJ_METADC;
                break;

            case LO_DC_TYPE:

                if( GetDCDWord( h, DDW_ISMEMDC, FALSE ) )
                {
                    dwRet = OBJ_MEMDC;
                }
                else
                {
                    dwRet = OBJ_DC;
                }
                break;

            case LO_ALTDC_TYPE:
                {
                    PLDC pldc;
                    DC_PLDC(h,pldc,0);

                    if (pldc->fl & LDC_META_PRINT)
                    {
                        //
                        // While we are doing EMF spooling, we lie to
                        // application to the HDC is real DC, not metafile
                        // DC, even it is actually metafile DC.
                        //
                        // This resolve the problem with Office97 + WordArt.
                        //
                        // (Raid #98810: WordArt doesn't print correctly to PS
                        //               printers when EMF spooling is turned on)
                        //

                        dwRet = OBJ_DC;
                    }
                    else
                    {
                        dwRet = alPublicTypes[pldc->iType];
                    }
                }
                break;

            case LO_ICMLCS_TYPE:
                dwRet = OBJ_COLORSPACE;
                break;

            default:
                GdiSetLastError(ERROR_INVALID_HANDLE);
                break;
            }
        }
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* ResizePalette                                                            *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* Warning:                                                                 *
*   The pv field of a palette's LHE is used to determine if a palette      *
*   has been modified since it was last realized.  SetPaletteEntries       *
*   and ResizePalette will increment this field after they have            *
*   modified the palette.  It is only updated for metafiled palettes       *
*                                                                          *
*  Thu 06-Jun-1991 00:58:46 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI ResizePalette(HPALETTE hpal,UINT c)
{
    ULONG bRet = FALSE;
    PMETALINK16 pml16;

    FIXUP_HANDLE(hpal);

// Inform the metafile if it knows this object.

    if (pml16 = pmetalink16Get(hpal))
    {
        if (LO_TYPE(hpal) != LO_PALETTE_TYPE)
            return(bRet);

        if (!MF_ResizePalette(hpal,c))
            return(bRet);

        if (!MF16_ResizePalette(hpal,c))
           return(bRet);

        // Mark the palette as changed (for 16-bit metafile tracking)

        pml16->pv = (PVOID)(((ULONG_PTR)pml16->pv)++);
    }

    return(NtGdiResizePalette(hpal,c));
}

/******************************Public*Routine******************************\
* SetBitmapDimensionEx                                                       *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Thu 06-Jun-1991 00:58:46 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI SetBitmapDimensionEx
(
    HBITMAP    hbm,
    int        cx,
    int        cy,
    LPSIZE psizl
)
{
    FIXUP_HANDLE(hbm);

    return(NtGdiSetBitmapDimension(hbm, cx, cy, psizl));

}

/******************************Public*Routine******************************\
* GetMetaRgn                                                               *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Fri Apr 10 10:12:36 1992     -by-    Hock San Lee    [hockl]            *
* Wrote it.                                                                *
\**************************************************************************/

int WINAPI GetMetaRgn(HDC hdc,HRGN hrgn)
{
    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hrgn);

    return(GetRandomRgn(hdc, hrgn, 2));         // hrgnMeta
}

/******************************Private*Routine******************************\
* GdiSetLastError                                                          *
*                                                                          *
* Client side private function.                                            *
*                                                                          *
\**************************************************************************/

VOID GdiSetLastError(ULONG iError)
{
#if DBG_X
    PSZ psz;
    switch (iError)
    {
    case ERROR_INVALID_HANDLE:
        psz = "ERROR_INVALID_HANDLE";
        break;

    case ERROR_NOT_ENOUGH_MEMORY:
        psz = "ERROR_NOT_ENOUGH_MEMORY";
        break;

    case ERROR_INVALID_PARAMETER:
        psz = "ERROR_INVALID_PARAMETER";
        break;

    case ERROR_BUSY:
        psz = "ERROR_BUSY";
        break;

    default:
        psz = "unknown error code";
        break;
    }

    KdPrint(( "GDI Err: %s = 0x%04X\n",psz,(USHORT) iError ));
#endif

    NtCurrentTeb()->LastErrorValue = iError;
}

/******************************Public*Routine******************************\
* ExtCreateRegion
*
* Upload a region to the server
*
* History:
*  29-Oct-1991 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

HRGN WINAPI ExtCreateRegion(
CONST XFORM * lpXform,
DWORD     nCount,
CONST RGNDATA * lpRgnData)
{

    ULONG   ulRet;

    if (lpRgnData == (LPRGNDATA) NULL)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return((HRGN) 0);
    }

    //
    // Perf: use CreateRectRgn when possible
    //
    if ((lpXform == NULL) && (lpRgnData->rdh.nCount == 1))
    {
       RECT * prcl = (RECT *)(lpRgnData->Buffer);

       return (CreateRectRgn(prcl->left, prcl->top, prcl->right, prcl->bottom));
    }
    else
    {
        return(NtGdiExtCreateRegion((LPXFORM)lpXform, nCount, (LPRGNDATA)lpRgnData));
    }

}

/******************************Public*Routine******************************\
* MonoBitmap(hbr)
*
* Test if a brush is monochrome
*
* History:
*  09-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL MonoBitmap(HBITMAP hbm)
{
    return(NtGdiMonoBitmap(hbm));
}

/******************************Public*Routine******************************\
* GetObjectBitmapHandle(hbr)
*
* Get the SERVER handle of the bitmap used to create the brush or pen.
*
* History:
*  09-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

HBITMAP GetObjectBitmapHandle(
HBRUSH  hbr,
UINT   *piUsage)
{
    FIXUP_HANDLE(hbr);

    return(NtGdiGetObjectBitmapHandle(hbr,piUsage));
}

/******************************Public*Routine******************************\
* EnumObjects
*
* Calls the NtGdiEnumObjects function twice: once to determine the number of
* objects to be enumerated, and a second time to fill a buffer with the
* objects.
*
* The callback function is called for each of the objects in the buffer.
* The enumeration will be prematurely terminated if the callback function
* returns 0.
*
* Returns:
*   The last callback return value.  Meaning is user defined.  ERROR if
*   an error occurs.
*
* History:
*  25-Mar-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int EnumObjects (
    HDC             hdc,
    int             iObjectType,
    GOBJENUMPROC    lpObjectFunc,
#ifdef STRICT
    LPARAM          lpData
#else
    LPVOID          lpData
#endif
    )
{
    int     iRet = ERROR;
    ULONG   cjObject;       // size of a single object
    ULONG   cObjects;       // number of objects to process
    ULONG   cjBuf;          // size of buffer (in BYTEs)
    PVOID   pvBuf;          // object buffer; do callbacks with pointers into this buffer
    PBYTE   pjObj, pjObjEnd;// pointers into callback buffer

    FIXUP_HANDLE(hdc);

// Determine size of object.

    switch (iObjectType)
    {
    case OBJ_PEN:
        cjObject = sizeof(LOGPEN);
        break;

    case OBJ_BRUSH:
        cjObject = sizeof(LOGBRUSH);
        break;

    default:
        WARNING1("gdi!EnumObjects(): bad object type\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);

        return iRet;
    }

// Call NtGdiEnumObjects to determine number of objects.

    if ( (cObjects = NtGdiEnumObjects(hdc, iObjectType, 0, (PVOID) NULL)) == 0 )
    {
        WARNING("gdi!EnumObjects(): error, no objects\n");
        return iRet;
    }

// Allocate buffer for callbacks.

    cjBuf = cObjects * cjObject;

    if ( (pvBuf = (PVOID) LOCALALLOC(cjBuf)) == (PVOID) NULL )
    {
        WARNING("gdi!EnumObjects(): error allocating callback buffer\n");
        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);

        return iRet;
    }

// Call NtGdiEnumObjects to fill buffer.

// Note: while NtGdiEnumObjects will never return a count more than the size of
// the buffer (this would be an ERROR condition), it might return less.

    if ( (cObjects = NtGdiEnumObjects(hdc, iObjectType, cjBuf, pvBuf)) == 0 )
    {
        WARNING("gdi!EnumObjects(): error filling callback buffer\n");
        LOCALFREE(pvBuf);

        return iRet;
    }

// Process callbacks.

    pjObj    = (PBYTE) pvBuf;
    pjObjEnd = (PBYTE) pvBuf + cjBuf;

    for (; pjObj < pjObjEnd; pjObj += cjObject)
    {
    // Terminate early if callback returns 0.

        if ( (iRet = (*lpObjectFunc)((LPVOID) pjObj, lpData)) == 0 )
            break;
    }

// Release callback buffer.

    LOCALFREE(pvBuf);

// Return last callback return value.

    return iRet;
}

/**********************************************************************\
* GetDCObject                                                         *
* Get Server side DC objects                                          *
*                                                                     *
* 14-11-94 -by- Lingyun Wang [lingyunw]                               *
* Wrote it                                                            *
\**********************************************************************/

HANDLE GetDCObject (HDC hdc, int iType)
{
    if (
         (iType == LO_BRUSH_TYPE)  ||
         (iType == LO_PEN_TYPE)    ||
         (iType == LO_EXTPEN_TYPE) ||
         (iType == LO_ICMLCS_TYPE)
       )
    {
        PDC_ATTR pdca;
        HANDLE      iret = 0;

        PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

        if (pdca != NULL)
        {
            switch (iType)
            {
            case LO_BRUSH_TYPE:
                iret = pdca->hbrush;
                break;

            case LO_PEN_TYPE:
            case LO_EXTPEN_TYPE:
                iret = pdca->hpen;
                break;

            case LO_ICMLCS_TYPE:
                iret = pdca->hColorSpace;
                break;
            }
        }

        return(iret);
    }
    else
    {
        return(NtGdiGetDCObject(hdc,iType));
    }
}


/******************************Public*Routine******************************\
* HANDLE CreateClientObj()
*
* History:
*  18-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HANDLE CreateClientObj(
    ULONG ulType)
{
    return(NtGdiCreateClientObj(ulType));
}

/******************************Public*Routine******************************\
* BOOL DeleteClientObj()
*
* History:
*  18-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL DeleteClientObj(
    HANDLE h)
{
    return(NtGdiDeleteClientObj(h));
}

/******************************Public*Routine******************************\
* BOOL MakeInfoDC()
*
*   Temporarily make a printer DC a INFO DC.  This is used to be able to
*   associate a metafile with a printer DC.
*
*   bSet = TRUE  - set as info
*          FALSE - restore
*
* History:
*  19-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL MakeInfoDC(
    HDC hdc,
    BOOL bSet)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiMakeInfoDC(hdc,bSet));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\output.c ===
/******************************Module*Header*******************************\
* Module Name: output.c                                                    *
*                                                                          *
* Client side stubs for graphics output calls.                             *
*                                                                          *
* Created: 05-Jun-1991 01:41:18                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

// 2 seconds is way way too long for either non-preemptive wow apps or
// an input-synchronized journal situation (like w/mstest). 1/20 a second
// is much better - scottlu
//#define CALLBACK_INTERVAL   2000

// Even better - 1/4 a second
// scottlu
#define CALLBACK_INTERVAL   250

extern BOOL MF_WriteEscape(HDC hdc, int nEscape, int nCount, LPCSTR lpInData, int type );

//
// WINBUG #82877 2-7-2000 bhouse Need to move definition of ETO_NULL_PRCL
//

#define ETO_NULL_PRCL 0x80000000

ULONG GdiBatchLimit = 20;

const XFORM xformIdentity = { 1.00000000f, 0.00000000f, 0.00000000f, 1.00000000f,
                        0.00000000f, 0.00000000f };

/******************************Public*Routine******************************\
* AngleArc                                                                 *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI AngleArc(
    HDC hdc,
    int x,
    int y,
    DWORD r,
    FLOAT eA,
    FLOAT eB
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_AngleArc(hdc,x,y,r,eA,eB)
           )
            return(bRet);

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiAngleArc(hdc,x,y,r,FLOATARG(eA),FLOATARG(eB)));
}

/******************************Public*Routine******************************\
* Arc                                                                      *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI Arc
(
    HDC hdc,
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms9(hdc,x1,y1,x2,y2,x3,y3,x4,y4,META_ARC));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_ArcChordPie(hdc,x1,y1,x2,y2,x3,y3,x4,y4,EMR_ARC))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiArcInternal(ARCTYPE_ARC,hdc,x1,y1,x2,y2,x3,y3,x4,y4));

}

/******************************Public*Routine******************************\
* ArcTo                                                                    *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]                           *
* Wrote it.  Cloned it from Arc.                                           *
\**************************************************************************/

BOOL META WINAPI ArcTo(
    HDC hdc,
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_ArcChordPie(hdc,x1,y1,x2,y2,x3,y3,x4,y4,EMR_ARCTO))
        {
            return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiArcInternal(ARCTYPE_ARCTO,hdc,x1,y1,x2,y2,x3,y3,x4,y4));

}

/******************************Public*Routine******************************\
* LineTo                                                                   *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI LineTo(HDC hdc,int x,int y)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms3(hdc,x,y,META_LINETO));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetDD(hdc,(DWORD)x,(DWORD)y,EMR_LINETO))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiLineTo(hdc,x,y));

}

/******************************Public*Routine******************************\
* Chord                                                                    *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI Chord(
    HDC hdc,
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms9(hdc,x1,y1,x2,y2,x3,y3,x4,y4,META_CHORD));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_ArcChordPie(hdc,x1,y1,x2,y2,x3,y3,x4,y4,EMR_CHORD))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiArcInternal(ARCTYPE_CHORD,hdc,x1,y1,x2,y2,x3,y3,x4,y4));

}

/******************************Public*Routine******************************\
* Ellipse                                                                  *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI Ellipse(HDC hdc,int x1,int y1,int x2,int y2)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms5(hdc,x1,y1,x2,y2,META_ELLIPSE));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_EllipseRect(hdc,x1,y1,x2,y2,EMR_ELLIPSE))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiEllipse(hdc,x1,y1,x2,y2));

}

/******************************Public*Routine******************************\
* Pie                                                                      *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI Pie(
    HDC hdc,
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms9(hdc,x1,y1,x2,y2,x3,y3,x4,y4,META_PIE));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_ArcChordPie(hdc,x1,y1,x2,y2,x3,y3,x4,y4,EMR_PIE))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiArcInternal(ARCTYPE_PIE,hdc,x1,y1,x2,y2,x3,y3,x4,y4));

}

/******************************Public*Routine******************************\
* Rectangle                                                                *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI Rectangle(HDC hdc,int x1,int y1,int x2,int y2)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms5(hdc,x1,y1,x2,y2,META_RECTANGLE));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_EllipseRect(hdc,x1,y1,x2,y2,EMR_RECTANGLE))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiRectangle(hdc,x1,y1,x2,y2));

}

/******************************Public*Routine******************************\
* RoundRect                                                                *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI RoundRect(
    HDC hdc,
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms7(hdc,x1,y1,x2,y2,x3,y3,META_ROUNDRECT));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_RoundRect(hdc,x1,y1,x2,y2,x3,y3))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiRoundRect(hdc,x1,y1,x2,y2,x3,y3));

}

/******************************Public*Routine******************************\
* PatBlt                                                                   *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI PatBlt(
    HDC hdc,
    int x,
    int y,
    int cx,
    int cy,
    DWORD rop
)
{
    BOOL bRet = FALSE;
    PDC_ATTR pdca;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsWWWWD(hdc,(WORD)x,(WORD)y,(WORD)cx,(WORD)cy,rop,META_PATBLT));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_AnyBitBlt(hdc,x,y,cx,cy,(LPPOINT)NULL,(HDC)NULL,0,0,0,0,(HBITMAP)NULL,0,0,rop,EMR_BITBLT))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

    BEGIN_BATCH_HDC(hdc,pdca,BatchTypePatBlt,BATCHPATBLT);

        //
        // check DC to see if call can be batched, all DCs in use
        // by the client must have a valid dc_attr
        //

        pBatch->rop4            = rop;
        pBatch->x               = x;
        pBatch->y               = y;
        pBatch->cx              = cx;
        pBatch->cy              = cy;
        pBatch->hbr             = pdca->hbrush;
        pBatch->TextColor       = (ULONG)pdca->crForegroundClr;
        pBatch->BackColor       = (ULONG)pdca->crBackgroundClr;
        pBatch->DCBrushColor    = (ULONG)pdca->crDCBrushClr;
        pBatch->IcmBrushColor   = (ULONG)pdca->IcmBrushColor;
        pBatch->ptlViewportOrg  = pdca->ptlViewportOrg;
        pBatch->ulTextColor       = pdca->ulForegroundClr;
        pBatch->ulBackColor       = pdca->ulBackgroundClr;
        pBatch->ulDCBrushColor    = pdca->ulDCBrushClr;

    COMPLETE_BATCH_COMMAND();

    return(TRUE);

UNBATCHED_COMMAND:

    return(NtGdiPatBlt(hdc,x,y,cx,cy,rop));
}

/******************************Public*Routine******************************\
* PolyPatBlt
*
* Arguments:
*
*  hdc   - dest DC
*  rop   - ROP for all patblt elements
*  pPoly - pointer to array of PPOLYPATBLT structures
*  Count - number of polypatblts
*  Mode  - mode for all polypatblts
*
* Return Value:
*
*   BOOL Status
*
\**************************************************************************/

BOOL
META WINAPI
PolyPatBlt(
    HDC         hdc,
    DWORD       rop,
    PPOLYPATBLT pPoly,
    DWORD       Count,
    DWORD       Mode
    )
{
    BOOL bRet = FALSE;
    PDC_ATTR pdca;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

    // If ICM is enabled, we need to select the brush onto the DC in
    // client side, so that ICM can translate brush color to DC color
    // space. thus we can not use Batch, here. because Batch will selet
    // the brush onto the DC in kernel side. so, there is no chance to
    // ICM will be invoked.

    if (IS_ALTDC_TYPE(hdc) || (pdca && IS_ICM_INSIDEDC(pdca->lIcmMode)))
    {
        ULONG Index;
        HBRUSH hOld = 0;

        for (Index=0;Index<Count;Index++)
        {
            //
            // select brush, save first to restore
            //

            if (Index == 0)
            {
                hOld = SelectObject(hdc,(HBRUSH)pPoly[0].BrClr.hbr);
            }
            else
            {
                SelectObject(hdc,(HBRUSH)pPoly[Index].BrClr.hbr);
            }

            bRet = PatBlt(hdc,
                          pPoly[Index].x,
                          pPoly[Index].y,
                          pPoly[Index].cx,
                          pPoly[Index].cy,
                          rop
                         );
        }

        //
        // restore brush if needed
        //

        if (hOld)
        {
            SelectObject(hdc,hOld);
        }
    }
    else
    {
        RESETUSERPOLLCOUNT();

        if ((Count != 0) && (pPoly != NULL) && (Mode == PPB_BRUSH))
        {
            USHORT uSize;

            if (Count > (MAXUSHORT / sizeof(POLYPATBLT)))
                goto UNBATCHED_COMMAND;

            //
            // size of batched structure
            //
            uSize = (USHORT)(Count * sizeof(POLYPATBLT));

            uSize += (USHORT)sizeof(BATCHPOLYPATBLT);

            if (uSize < (USHORT)sizeof(BATCHPOLYPATBLT))
                goto UNBATCHED_COMMAND;
                
            BEGIN_BATCH_HDC_SIZE(hdc,pdca,BatchTypePolyPatBlt,BATCHPOLYPATBLT,uSize);

                pBatch->rop4    = rop;
                pBatch->Count   = Count;
                pBatch->Mode    = Mode;
                pBatch->TextColor  = (ULONG)pdca->crForegroundClr;
                pBatch->BackColor  = (ULONG)pdca->crBackgroundClr;
                pBatch->DCBrushColor  = (ULONG)pdca->crDCBrushClr;
                pBatch->ptlViewportOrg  = pdca->ptlViewportOrg;
                pBatch->ulTextColor  = pdca->ulForegroundClr;
                pBatch->ulBackColor  = pdca->ulBackgroundClr;
                pBatch->ulDCBrushColor  = pdca->ulDCBrushClr;

                memcpy(&pBatch->ulBuffer[0],pPoly,Count*sizeof(POLYPATBLT));

                //
                // if the first hbr entry is NULL, copy in current hbr so
                // it is remembered.
                //

                if (((PPOLYPATBLT)(&pBatch->ulBuffer[0]))->BrClr.hbr == NULL)
                {
                    ((PPOLYPATBLT)(&pBatch->ulBuffer[0]))->BrClr.hbr = pdca->hbrush;
                }

                bRet = TRUE;

            COMPLETE_BATCH_COMMAND();

        UNBATCHED_COMMAND:

            if (!bRet)
            {
                bRet = NtGdiPolyPatBlt(hdc,rop,pPoly,Count,Mode);
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BitBlt                                                                   *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI BitBlt(
    HDC hdc,
    int x,
    int y,
    int cx,
    int cy,
    HDC hdcSrc,
    int x1,
    int y1,
    DWORD rop
)
{
    BOOL     bRet = FALSE;

    //
    // if this call redueces to PatBlt, then let PatBlt
    // do the metafile and/or output.
    //

    if ((((rop << 2) ^ rop) & 0x00CC0000) == 0)
    {
        return(PatBlt(hdc,x,y,cx,cy,rop));
    }

    //
    // Src is required by ROP, do bitblt
    //

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hdcSrc);

    if (gbICMEnabledOnceBefore)
    {
        PDC_ATTR pdcattr, pdcattrSrc;

        PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);
        PSHARED_GET_VALIDATE(pdcattrSrc,hdcSrc,DC_TYPE);

        //
        // if source DC has DIB section, and destination DC is ICM turned on
        // do ICM-aware BitBlt.
        //
        if (pdcattr && pdcattrSrc)
        {
            if (IS_ICM_INSIDEDC(pdcattr->lIcmMode) &&
                (bDIBSectionSelected(pdcattrSrc) ||
                 (IS_ICM_LAZY_CORRECTION(pdcattrSrc->lIcmMode) && (GetDCDWord(hdc,DDW_ISMEMDC,FALSE) == FALSE))))
            {
                if (IcmStretchBlt(hdc,x,y,cx,cy,hdcSrc,x1,y1,cx,cy,rop,pdcattr,pdcattrSrc))
                {
                    return (TRUE);
                }
            }
        }
    }

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_BitBlt(hdc,x,y,cx,cy,hdcSrc,x1,y1,rop));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_AnyBitBlt(hdc,x,y,cx,cy,(LPPOINT)NULL,hdcSrc,x1,y1,cx,cy,(HBITMAP)NULL,0,0,rop,EMR_BITBLT))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

//
// Define _WINDOWBLT_NOTIFICATION_ to turn on Window BLT notification.
// This notification will set a special flag in the SURFOBJ passed to
// drivers when the DrvCopyBits operation is called to move a window.
//
// See also:
//      ntgdi\gre\maskblt.cxx
//
#ifdef _WINDOWBLT_NOTIFICATION_
    return(NtGdiBitBlt(hdc,x,y,cx,cy,hdcSrc,x1,y1,rop,(COLORREF)-1,0));
#else
    return(NtGdiBitBlt(hdc,x,y,cx,cy,hdcSrc,x1,y1,rop,(COLORREF)-1));
#endif
}

/******************************Public*Routine******************************\
* StretchBlt                                                               *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI StretchBlt(
    HDC   hdc,
    int   x,
    int   y,
    int   cx,
    int   cy,
    HDC   hdcSrc,
    int   x1,
    int   y1,
    int   cx1,
    int   cy1,
    DWORD rop
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLEZ(hdcSrc);

    if (gbICMEnabledOnceBefore)
    {
        PDC_ATTR pdcattr, pdcattrSrc;

        PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);
        PSHARED_GET_VALIDATE(pdcattrSrc,hdcSrc,DC_TYPE);

        //
        // if source DC has DIB section, and destination DC is ICM turned on
        // do ICM-aware BitBlt.
        //
        if (pdcattr && pdcattrSrc)
        {
            if (IS_ICM_INSIDEDC(pdcattr->lIcmMode) &&
                (bDIBSectionSelected(pdcattrSrc) ||
                 (IS_ICM_LAZY_CORRECTION(pdcattrSrc->lIcmMode) && (GetDCDWord(hdc,DDW_ISMEMDC,FALSE) == FALSE))))
            {
                if (IcmStretchBlt(hdc,x,y,cx,cy,hdcSrc,x1,y1,cx1,cy1,rop,pdcattr,pdcattrSrc))
                {
                    return (TRUE);
                }
            }
        }
    }

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_StretchBlt(hdc,x,y,cx,cy,hdcSrc,x1,y1,cx1,cy1,rop));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_AnyBitBlt(hdc,x,y,cx,cy,(LPPOINT)NULL,hdcSrc,x1,y1,cx1,cy1,(HBITMAP)NULL,0,0,rop,EMR_STRETCHBLT))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiStretchBlt(hdc,x,y,cx,cy,hdcSrc,x1,y1,cx1,cy1,rop,(COLORREF)-1));
}

/******************************Public*Routine******************************\
* PlgBlt                                                                   *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI PlgBlt(
    HDC        hdc,
    CONST POINT *pptl,
    HDC        hdcSrc,
    int        x1,
    int        y1,
    int        x2,
    int        y2,
    HBITMAP    hbm,
    int        xMask,
    int        yMask
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLEZ(hdcSrc);
    FIXUP_HANDLEZ(hbm);

// Check out the source DC and the mask(OPTIONAL).

    if (!hdcSrc || IS_METADC16_TYPE(hdcSrc))
        return(FALSE);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(FALSE);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_AnyBitBlt(hdc,0,0,0,0,pptl,hdcSrc,x1,y1,x2,y2,hbm,xMask,yMask,0xCCAA0000,EMR_PLGBLT))
        {
            return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiPlgBlt(hdc,(POINT *)pptl,hdcSrc,x1,y1,x2,y2,hbm,xMask,yMask,
                       GetBkColor(hdcSrc)));

}

/******************************Public*Routine******************************\
* MaskBlt                                                                  *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI MaskBlt(
    HDC     hdc,
    int     x,
    int     y,
    int     cx,
    int     cy,
    HDC     hdcSrc,
    int     x1,
    int     y1,
    HBITMAP hbm,
    int     x2,
    int     y2,
    DWORD   rop
)
{
    BOOL bRet = FALSE;
    ULONG crBackColor;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLEZ(hdcSrc);
    FIXUP_HANDLEZ(hbm);

// Check out the source DC and the mask(OPTIONAL).

    if (!hdcSrc || IS_METADC16_TYPE(hdcSrc))
        return(FALSE);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(FALSE);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_AnyBitBlt(hdc,x,y,cx,cy,(LPPOINT)NULL,hdcSrc,x1,y1,cx,cy,hbm,x2,y2,rop,EMR_MASKBLT))
        {
            return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    crBackColor = GetBkColor(hdcSrc);

    RESETUSERPOLLCOUNT();

    // WINBUG #82879 2-7-2000 bhouse Possible bug in MaskBlt
    // Old Comment:
    //    - GetBkColor should be performed in the kernel
    // Not a problem. GetBkColor() picks up the color from the PEB DCattr cache.

    return(NtGdiMaskBlt(hdc,x,y,cx,cy,hdcSrc,x1,y1,hbm,x2,y2,rop,crBackColor));
}

/******************************Public*Routine******************************\
* ExtFloodFill                                                             *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI ExtFloodFill(
    HDC      hdc,
    int      x,
    int      y,
    COLORREF color,
    UINT     iMode
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsWWDW(hdc,(WORD)x,(WORD)y,(DWORD)color,(WORD)iMode,META_EXTFLOODFILL));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_ExtFloodFill(hdc,x,y,color,iMode))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    //
    // if the specified COLORREF is not palette index,
    // we need to do color conversion, when ICM is enabled.
    //

    if (!(color & 0x01000000))
    {
        PDC_ATTR pdcattr;

        PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

        if (pdcattr && bNeedTranslateColor(pdcattr))
        {
            COLORREF NewColor;

            if (IcmTranslateCOLORREF(hdc,pdcattr,color,&NewColor,ICM_FORWARD))
            {
                color = NewColor;
            }
        }
    }

    return(NtGdiExtFloodFill(hdc,x,y,color,iMode));
}

/******************************Public*Routine******************************\
* FloodFill                                                                *
*                                                                          *
* Just passes the call to the more general ExtFloodFill.                   *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI FloodFill(HDC hdc,int x,int y,COLORREF color)
{
    return(ExtFloodFill(hdc,x,y,color,FLOODFILLBORDER));
}

/******************************Public*Routine******************************\
* PaintRgn                                                                 *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
* 23-11-94 -by- Lingyun Wang [lingyunw]
* Now hrgn is server side handle
*
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI PaintRgn(HDC hdc,HRGN hrgn)
{
    BOOL  bRet = FALSE;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hrgn);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_DrawRgn(hdc,hrgn,(HBRUSH)0,0,0,META_PAINTREGION));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_InvertPaintRgn(hdc,hrgn,EMR_PAINTRGN))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiFillRgn(hdc,hrgn,(HBRUSH)GetDCObject(hdc,LO_BRUSH_TYPE)));

}


/******************************Public*Routine******************************\
* bBatchTextOut
*
*   Attempt to batch a textout call on TEB
*
* Arguments:
*
*
*
* Return Value:
*
*   TRUE means call is batched, FALSE means call could not be batched
*
*    18-Oct-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

//
// full DWORDS!
//

#define MAX_BATCH_CCHAR  ((GDI_BATCH_SIZE - sizeof(BATCHTEXTOUT)) & 0xfffffff0)
#define MAX_BATCH_WCHAR  MAX_BATCH_CCHAR / 2

BOOL
bBatchTextOut(
    HDC         hdc,
    LONG        x,
    LONG        y,
    UINT        fl,
    CONST RECT *prcl,
    LPCWSTR     pwsz,
    CONST INT  *pdx,
    UINT        UnicodeCharCount,
    UINT        ByteCount,
    DWORD       dwCodePage
    )
{
    BOOL     bRet = FALSE;
    ULONG    AlignedByteCount;
    USHORT   usSize;
    ULONG    cjPdx;
    PDC_ATTR pdca;

    AlignedByteCount =
        (ByteCount + sizeof(PVOID) - 1) & ~(sizeof(PVOID)-1);
    if( AlignedByteCount < ByteCount )
        goto UNBATCHED_COMMAND;  // arithmetic overflow

    //
    // account for pdx space if needed
    //

    if (pdx != NULL)
    {
        cjPdx = UnicodeCharCount * sizeof(INT);
        if (fl & ETO_PDY)
            cjPdx *= 2;
        if ((AlignedByteCount+cjPdx) < AlignedByteCount
                || BALLOC_OVERFLOW1(UnicodeCharCount,INT))
            goto UNBATCHED_COMMAND;  // arithmetic overflow
        AlignedByteCount += cjPdx;
    }

    usSize = (USHORT)(sizeof(BATCHTEXTOUT) + AlignedByteCount);
    if (usSize < AlignedByteCount)
        goto UNBATCHED_COMMAND;  // arithmetic overflow

    PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

    BEGIN_BATCH_HDC_SIZE(hdc,pdca,BatchTypeTextOut,BATCHTEXTOUT,usSize);

        if (pdca->lTextAlign & TA_UPDATECP)
        {
            goto UNBATCHED_COMMAND;
        }

        pBatch->TextColor  = (ULONG)pdca->crForegroundClr;
        pBatch->BackColor  = (ULONG)pdca->crBackgroundClr;
        pBatch->BackMode   = (ULONG)((pdca->lBkMode == OPAQUE) ? OPAQUE : TRANSPARENT);
        pBatch->ulTextColor  = pdca->ulForegroundClr;
        pBatch->ulBackColor  = pdca->ulBackgroundClr;
        pBatch->x          = x;
        pBatch->y          = y;
        pBatch->fl         = fl;
        pBatch->cChar      = UnicodeCharCount;
        pBatch->PdxOffset  = 0;
        pBatch->dwCodePage = dwCodePage;
        pBatch->hlfntNew   = pdca->hlfntNew;
        pBatch->flTextAlign = pdca->flTextAlign;
        pBatch->ptlViewportOrg = pdca->ptlViewportOrg;

        //
        // copy output RECT if needed
        //

        if (prcl != NULL)
        {
            pBatch->rcl.left   = prcl->left;
            pBatch->rcl.top    = prcl->top;
            pBatch->rcl.right  = prcl->right;
            pBatch->rcl.bottom = prcl->bottom;
        }
        else
        {
            pBatch->fl |= ETO_NULL_PRCL;
        }

        //
        // copy characters
        //

        if (ByteCount)
        {
            RtlCopyMemory((PUCHAR)&pBatch->ulBuffer[0],(PUCHAR)pwsz,ByteCount);
        }

        //
        // copy pdx array
        //

        if (pdx != NULL)
        {
           //
           // start pdx at INT aligned offset after WCAHR data
           //

           pBatch->PdxOffset = (ByteCount + 3) & 0xfffffffc;

           RtlCopyMemory((PUCHAR)&pBatch->ulBuffer[0] + pBatch->PdxOffset,
                         (PUCHAR)pdx,
                         cjPdx);
        }

        bRet = TRUE;

    COMPLETE_BATCH_COMMAND();

UNBATCHED_COMMAND:

    return(bRet);
}

/******************************Public*Routine******************************\
*
* BOOL META WINAPI ExtTextOutW
*
* similar to traditional ExtTextOut, except that it takes UNICODE string
*
* History:
*  Thu 28-Apr-1994 -by- Patrick Haluptzok [patrickh]
* Special Case 0 char case for Winbench4.0
*
*  05-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI ExtTextOutW(
    HDC        hdc,
    int        x,
    int        y,
    UINT       fl,
    CONST RECT *prcl,
    LPCWSTR    pwsz,
    UINT       c,      // count of bytes = 2 * (# of WCHAR's)
    CONST INT *pdx
)
{
    BOOL bRet = FALSE;
    BOOL bEMFDriverComment = FALSE;

    if ((fl & ETO_PDY) && !pdx)
        return FALSE;

// if we do not know what to do with the rectangle, ignore it.

    if (prcl && !(fl & (ETO_OPAQUE | ETO_CLIPPED)))
    {
        prcl = NULL;
    }
    if (!prcl)
    {
        fl &= ~(ETO_CLIPPED | ETO_OPAQUE); // ignore flags if no rect, win95 compat
    }

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_ExtTextOut(hdc,x,y,fl,prcl,(LPCSTR)pwsz,c,pdx,TRUE));

        DC_PLDC(hdc,pldc,bRet);



    // if we are EMF spooling then metafile glyph index calls, otherwise don't

// if we are EMF spooling then metafile glyph index calls, otherwise don't
/*
   LDC_META_PRINT       ETO_GLYPH_INDEX      ETO_IGNORELANGUAGE      gbLpk    MetaFileTheCall
        0                     0                      0                 0            1
        0                     0                      0                 1            1
        0                     0                      1                 0            1
Case1   0                     0                      1                 1            0

Case2   0                     1                      0                 0            0
        0                     1                      0                 1            1     <-Win95 Compatability
Case2   0                     1                      1                 0            0
        0                     1                      1                 1            1     <-Win95 Compatability

        1                     0                      0                 0            1
Case3   1                     0                      0                 1            0
        1                     0                      1                 0            1
        1                     0                      1                 1            1

        1                     1                      0                 0            1
        1                     1                      0                 1            1
        1                     1                      1                 0            1
        1                     1                      1                 1            1

*/
// Now we will metafile the glyph index call (i.e. with ETO_GLYPH_INDEX) for ExtTextOutW.
// This is to support MS OutLook-97/BiDi, since it DEPENDS on this feature!!. Win95/BiDi allowed
// metafiling of GIs on ETOW, but rejects GIs metafiling calls to ETOA.
// This is not neat, but we have to do it to support our Apps.

        if (pldc->iType == LO_METADC)
        {
            BOOL bPrintToEMFDriver = pldc->pUMPD ? pldc->pUMPD->dwFlags & UMPDFLAG_METAFILE_DRIVER : FALSE;

            BOOL bLpkEmfCase1 = !(pldc->fl & LDC_META_PRINT) &&
                                !(fl & ETO_GLYPH_INDEX) &&
                                (fl & ETO_IGNORELANGUAGE) &&
                                gbLpk;

            BOOL bLpkEmfCase2 = !(pldc->fl & LDC_META_PRINT) &&
                                (fl & ETO_GLYPH_INDEX) &&
                                !gbLpk;

            BOOL bLpkEmfCase3 = (pldc->fl & LDC_META_PRINT) &&
                                !(fl & ETO_GLYPH_INDEX) &&
                                !(fl & ETO_IGNORELANGUAGE) &&
                                gbLpk;




            // Record a special comment containing the original
            // Unicode string for the ExtTextOutW call

            if (bLpkEmfCase3 && bPrintToEMFDriver)
            {
                ULONG nSize = 3*sizeof(DWORD) + c*sizeof(WCHAR);
                DWORD *lpData; 

                // double check that we didn't have an arithmetic overflow
                // in the calculation of nSize -- if so, lpData can have
                // a buffer overflow
                if( c >= (MAXIMUM_POOL_ALLOC - 3*sizeof(DWORD) - 3)/sizeof(WCHAR))
                {
                    GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }
                lpData = LOCALALLOC(ROUNDUP_DWORDALIGN(nSize));

                if (lpData)
                {
                   lpData[0] = GDICOMMENT_IDENTIFIER;
                   lpData[1] = GDICOMMENT_UNICODE_STRING;
                   lpData[2] = c; // number of wchars in the unicode string

                   RtlCopyMemory((PBYTE)(lpData+3), pwsz, c*sizeof(WCHAR));

                   if (!MF_GdiComment(hdc,nSize,(PBYTE)lpData))
                   {
                       LOCALFREE(lpData);
                       return bRet;
                   }

                   LOCALFREE(lpData);

                   bEMFDriverComment = TRUE;
                }
            }

            if (!bLpkEmfCase1 && !bLpkEmfCase2 && !bLpkEmfCase3 &&
                !MF_ExtTextOut(hdc,x,y,fl,prcl,(LPCSTR) pwsz,c,pdx,EMR_EXTTEXTOUTW))
            {
                return(bRet);
            }

        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

#ifdef LANGPACK
    if(gbLpk && !(fl & ETO_GLYPH_INDEX) && !(fl & ETO_IGNORELANGUAGE))
    {
        bRet = ((*fpLpkExtTextOut)(hdc, x, y, fl, prcl, pwsz, c, pdx, -1));

        if (bEMFDriverComment)
        {
             DWORD lpData[2];

             lpData[0] = GDICOMMENT_IDENTIFIER;
             lpData[1] = GDICOMMENT_UNICODE_END;

             bRet = MF_GdiComment(hdc,2*sizeof(DWORD),(PBYTE)lpData);

             ASSERTGDI(bRet, "failed to write the GDICOMMENT_UNICODE_END comment\n");
        }

        return(bRet);
    }
#endif

    bRet = FALSE;

    if (c <= MAX_BATCH_WCHAR)
    {
        if ((c == 0) && (prcl != NULL))
        {
            if (fl & ETO_OPAQUE)
            {
                //
                // attempt to batch the text out rect
                //

                PDC_ATTR pdca;

                PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

                if ((pdca != NULL) && !(pdca->lTextAlign & TA_UPDATECP))
                {
                    BEGIN_BATCH_HDC(hdc,pdca,BatchTypeTextOutRect,BATCHTEXTOUTRECT);

                        pBatch->BackColor  = pdca->crBackgroundClr;
                        pBatch->fl         = fl;
                        pBatch->rcl.left   = prcl->left;
                        pBatch->rcl.top    = prcl->top;
                        pBatch->rcl.right  = prcl->right;
                        pBatch->rcl.bottom = prcl->bottom;
                        pBatch->ptlViewportOrg = pdca->ptlViewportOrg;
                        pBatch->ulBackColor = pdca->ulBackgroundClr;

                        bRet = TRUE;

                    COMPLETE_BATCH_COMMAND();
                }
            }
            else
            {
                bRet = TRUE;
            }
        }
        else
        {
            bRet = bBatchTextOut(hdc,
                                 x,
                                 y,
                                 fl,
                                 (LPRECT)prcl,
                                 (LPWSTR)pwsz,
                                 pdx,
                                 c,
                                 2 * c,
                                 0);
        }
    }

UNBATCHED_COMMAND:

    if (!bRet)
    {
        bRet = NtGdiExtTextOutW(hdc,
                                x,
                                y,
                                fl,
                                (LPRECT)prcl,
                                (LPWSTR)pwsz,
                                c,
                                (LPINT)pdx,
                                0);
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* PolyTextOutW
*
* Arguments:
*
*     hdc      - handle to device context
*     ppt      - pointer to array of POLYTEXTW
*     nstrings - length of POLYTEXTW array
*
* Return Value:
*
*     status
*
* History:
*  7/31/92 -by- Paul Butzi and Eric Kutter
*
\**************************************************************************/

BOOL META WINAPI PolyTextOutW(HDC hdc,CONST POLYTEXTW *ppt,INT nstrings)
{

    BOOL bRet = FALSE;
    CONST POLYTEXTW *pp;

    FIXUP_HANDLE(hdc);

    if (nstrings == 0)
    {
       bRet = TRUE;
    }
    else if (nstrings < 0)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
    else
    {

        //
        // Search for error case with string with non-0 length but sting == NULL
        //

        for ( pp = ppt; pp < (ppt + nstrings); pp += 1 )
        {
            if ( pp->lpstr == NULL)
            {
                //
                // return failure if they have a non 0 length string with NULL
                //

                if (pp->n != 0)
                {
                    GdiSetLastError(ERROR_INVALID_PARAMETER);
                    return(FALSE);
                }
            }
        }

        //
        // If we need to metafile, or print
        //

        if (IS_ALTDC_TYPE(hdc))
        {
            PLDC pldc;

            if (IS_METADC16_TYPE(hdc))
            {
                return (
                    MF16_PolyTextOut(
                            hdc,
                            (CONST POLYTEXTA*) ppt,
                            nstrings,
                            TRUE                        //  mrType == EMR_POLYTEXTOUTW
                            )
                       );
            }

            DC_PLDC(hdc,pldc,bRet);

            if (pldc->iType == LO_METADC)
            {
                if
                (
                    !MF_PolyTextOut(
                            hdc,
                            (CONST POLYTEXTA*) ppt,
                            nstrings,
                            EMR_POLYTEXTOUTW
                            )
                )
                    return(bRet);
            }

            if (pldc->fl & LDC_SAP_CALLBACK)
            {
                vSAPCallback(pldc);
            }

            if (pldc->fl & LDC_DOC_CANCELLED)
            {
                return(bRet);
            }

            if (pldc->fl & LDC_CALL_STARTPAGE)
            {
                StartPage(hdc);
            }
        }

        bRet = NtGdiPolyTextOutW(hdc,(POLYTEXTW *)ppt,nstrings, 0);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* PolyTextOutA
*
* Arguments:
*
*     hdc      - handle to device context
*     ppt      - pointer to array of POLYTEXTA
*     nstrings - length of POLYTEXTA array
*
* Return Value:
*
*     status
*
* History:
*  7/31/92 -by- Paul Butzi and Eric Kutter
*
\**************************************************************************/

BOOL META WINAPI PolyTextOutA(HDC hdc, CONST POLYTEXTA *ppt, INT nstrings)
{

    //
    // Convert text to UNICODE and make call
    //

    POLYTEXTW *pp, *pPolyTextW;


    UINT szTotal = 0;
    INT cjdx;
    BOOL bRet = FALSE;
    BOOL bDBCSCodePage;
    int i;
    PVOID pCharBuffer;
    PBYTE pj;
    DWORD   dwCodePage;

    FIXUP_HANDLE(hdc);

    if (nstrings == 0)
    {
        return(TRUE);
    }

    if (nstrings < 0)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Figure out the size needed
    //

    pPolyTextW = (POLYTEXTW*) ppt;

    if( BALLOC_OVERFLOW1(nstrings,POLYTEXTW) )
    {
        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    szTotal = sizeof(POLYTEXTW) * nstrings;

    for ( pp = pPolyTextW; pp < (pPolyTextW + nstrings); pp ++)
    {
        if (pp->lpstr != NULL)
        {
            if( BALLOC_OVERFLOW1(pp->n,WCHAR)
                    ||  (szTotal + pp->n*sizeof(WCHAR)) < szTotal )
            {
                GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
            szTotal += pp->n * sizeof(WCHAR);

            if ( pp->pdx != NULL )
            {
                cjdx = pp->n * sizeof(int);
                if (pp->uiFlags & ETO_PDY)
                    cjdx *= 2;

                if( (szTotal + cjdx) < szTotal )
                {
                    GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }
                szTotal += cjdx;
            }
        }
        else
        {
            //
            // return failure if they have a non 0 length string with NULL
            //

            if (pp->n != 0)
            {
                GdiSetLastError(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }
        }
    }

    //
    // If we need to metafile, or print
    //

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
        {
            return (
                MF16_PolyTextOut(
                        hdc,
                        (CONST POLYTEXTA*) pPolyTextW,
                        nstrings,
                        FALSE
                  )
                );
        }

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if
            (
                !MF_PolyTextOut(
                        hdc,
                        (CONST POLYTEXTA*) pPolyTextW,
                        nstrings,
                        EMR_POLYTEXTOUTA
                  )
            )
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
        {
            vSAPCallback(pldc);
        }

        if (pldc->fl & LDC_DOC_CANCELLED)
        {
            return(bRet);
        }

        if (pldc->fl & LDC_CALL_STARTPAGE)
        {
            StartPage(hdc);
        }
    }

    //
    // alloc memory for WHCAR structures
    //

    pCharBuffer = LOCALALLOC(szTotal);

    if (pCharBuffer == NULL)
    {
        return(FALSE);
    }

    RtlCopyMemory(pCharBuffer, (PBYTE) pPolyTextW, nstrings*sizeof(POLYTEXTW));
    pp = (POLYTEXTW *)pCharBuffer;

    //
    // now copy the stuff into the buffer
    //

    pj = (PBYTE)pCharBuffer + nstrings*sizeof(POLYTEXTW);

    dwCodePage = GetCodePage(hdc);

    bDBCSCodePage = IS_ANY_DBCS_CODEPAGE(dwCodePage);

    for ( i = 0; i < nstrings; i += 1 )
    {
        if ((pp[i].pdx != NULL) && (pp[i].lpstr != NULL))
        {
            // patch pdx

             cjdx = pp[i].n * sizeof(INT);
             if (pp[i].uiFlags & ETO_PDY)
                cjdx *= 2;

             if(bDBCSCodePage)
             {
                 ConvertDxArray(dwCodePage,
                                (char*) pp[i].lpstr,
                                pp[i].pdx,
                                pp[i].n,
                                (int*) pj,
                                pp[i].uiFlags & ETO_PDY
                                );
             }
             else
             {
                 RtlCopyMemory(pj,pp[i].pdx,cjdx);
             }

             pp[i].pdx = (int *)pj;

             pj += cjdx;
         }
     }


    for ( i = 0; i < nstrings; i += 1 )
    {
        if ( pp[i].lpstr != NULL )
        {
            pp[i].n = MultiByteToWideChar(dwCodePage,
                                          0,
                                          (LPSTR) pp[i].lpstr,
                                          pp[i].n, (LPWSTR) pj,
                                           pp[i].n*sizeof(WCHAR));

            // patch lpstr

            pp[i].lpstr = (LPWSTR)pj;

            pj += pp[i].n * sizeof(WCHAR);
        }
    }

    //
    // send off the message and cleanup
    //

    bRet = NtGdiPolyTextOutW(hdc,(POLYTEXTW *)pCharBuffer,nstrings,dwCodePage);

    LOCALFREE(pCharBuffer);

    return(bRet);
}

/******************************Public*Routine******************************\
*
* BOOL META WINAPI TextOutW
*
*
*
* History:
*  07-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI TextOutW(
    HDC        hdc,
    int        x,
    int        y,
    LPCWSTR  pwsz,
    int        c
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if ((c <= 0) || (pwsz == (LPCWSTR) NULL))
    {
        if (c == 0)
            return(TRUE);

        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_TextOut(hdc,x,y,(LPCSTR) pwsz,c,TRUE));

        DC_PLDC(hdc,pldc,bRet);

        if((pldc->iType == LO_METADC) &&
           (!(pldc->fl & LDC_META_PRINT) || !gbLpk))
        {

            if (!MF_ExtTextOut(hdc,x,y,0,(LPRECT)NULL,(LPCSTR) pwsz,c,(LPINT)NULL,EMR_EXTTEXTOUTW))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

#ifdef LANGPACK
    if(gbLpk)
    {
        return((*fpLpkExtTextOut)(hdc, x, y, 0, NULL, pwsz, c, 0, -1));
    }
#endif

    if ((c <= MAX_BATCH_WCHAR) && (GdiBatchLimit > 1))
    {
        bRet = bBatchTextOut(hdc,
                             x,
                             y,
                             0,
                             (LPRECT)NULL,
                             (LPWSTR)pwsz,
                             NULL,
                             c,
                             2 *c,
                             0);
    }

    if (!bRet)
    {
        bRet = NtGdiExtTextOutW(hdc,
                                x,
                                y,
                                0,
                                0,
                                (LPWSTR)pwsz,
                                c,
                                0,
                                0);
    }

    return(bRet);

}


/******************************Public*Routine******************************\
*
* DWORD   GetCodePage(HDC hdc)
*
* Effects: returns the code page of the font selected in the dc
*
* History:
*  23-May-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

DWORD   GetCodePage(HDC hdc)
{
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {

        if (!(pDcAttr->ulDirty_ & DIRTY_CHARSET))
            return (0x0000ffff & pDcAttr->iCS_CP);   // mask charset
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return guintAcp; // reasonable default;
    }

// we end up here if the code page attributes are dirty so that
// we have to call to the kernel, force the mapping and retrieve
// the code page and char set of the font selected in the dc:

    return (0x0000ffff & NtGdiGetCharSet(hdc)); // mask charset
}



/******************************Public*Routine******************************\
*
* BOOL META WINAPI ExtTextOutA
* History:
*  07-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define CAPTURE_STRING_SIZE 130

// not in kernel, it is ok to do this much on the stack

BOOL META WINAPI ExtTextOutInternalA(
    HDC        hdc,
    int        x,
    int        y,
    UINT       fl,
    CONST RECT *prcl,
    LPCSTR     psz,
    UINT       c,
    CONST INT  *pdx,
    BOOL       bFromTextOut
)
{
    BOOL bRet = FALSE;
    DWORD   dwCodePage;
    BOOL bDBCSCodePage;

    if ((fl & ETO_PDY) && !pdx)
        return FALSE;

// if we do not know what to do with the rectangle, ignore it.

    if (prcl && !(fl & (ETO_OPAQUE | ETO_CLIPPED)))
    {
        prcl = NULL;
    }
    if (!prcl)
    {
        fl &= ~(ETO_CLIPPED | ETO_OPAQUE); // ignore flags if no rect, win95 compat
    }

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
        {
            if(bFromTextOut)
            {
            // yes this matters, some apps rely on TextOutA being metafiled at
            // TextOut and not ExtTextOutA

                return(MF16_TextOut(hdc,x,y,psz,c,FALSE));
            }
            else
            {
                return (MF16_ExtTextOut(hdc,x,y,fl,prcl,psz,c,pdx,FALSE));
            }
        }

        DC_PLDC(hdc,pldc,bRet);

    // if we are EMF spooling then metafile glyph index calls, otherwise don't

        if((pldc->iType == LO_METADC) &&
           (!((!(pldc->fl & LDC_META_PRINT) && (fl & ETO_GLYPH_INDEX)) ||
             ((pldc->fl & LDC_META_PRINT) && !(fl & ETO_GLYPH_INDEX) && (gbLpk) && !(fl & ETO_IGNORELANGUAGE) && c)) ||
             (!(pldc->fl & LDC_META_PRINT) && (!(fl & ETO_GLYPH_INDEX)) && (fl & ETO_IGNORELANGUAGE) && (gbLpk))
           )
          )
        {
            DWORD mrType = (fl & ETO_GLYPH_INDEX) ?
                           EMR_EXTTEXTOUTW        :
                           EMR_EXTTEXTOUTA        ;

            if (!MF_ExtTextOut(hdc,x,y,fl,prcl,psz,c, pdx, mrType))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
                        vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    if (fl & ETO_GLYPH_INDEX)
    {

        bRet = FALSE;

        if ((c <= MAX_BATCH_WCHAR) && (GdiBatchLimit > 1))
        {

            bRet = bBatchTextOut(hdc,
                                 x,
                                 y,
                                 fl,
                                 (LPRECT)prcl,
                                 (LPWSTR)psz,
                                 pdx,
                                 c,
                                 2*c,
                                 0);
        }

        if (!bRet)
        {
            bRet = NtGdiExtTextOutW(hdc,
                                    x,y,
                                    fl, (LPRECT)prcl,
                                    (LPWSTR)psz, (int)c,
                                    (LPINT)pdx, 0);
        }

        return(bRet);
    }

    // Get code page

    dwCodePage = GetCodePage(hdc);

    if(fFontAssocStatus)
    {
        dwCodePage = FontAssocHack(dwCodePage,(char*)psz,c);
    }

    bDBCSCodePage = IS_ANY_DBCS_CODEPAGE(dwCodePage);

    if (c)
    {
    // get the code page of the font selected in the dc

        WCHAR awcCaptureBuffer[CAPTURE_STRING_SIZE];
        PWSZ  pwszCapt;
        INT aiDxCaptureBuffer[CAPTURE_STRING_SIZE*2]; // times 2 for pdy
        INT *pDxCapture;

    // Allocate the string buffer

        if (c <= CAPTURE_STRING_SIZE)
        {
            pwszCapt = awcCaptureBuffer;
        }
        else
        {
            if(bDBCSCodePage)
            {
                pwszCapt = 
                    ((c+1) >= MAXIMUM_POOL_ALLOC/(sizeof(WCHAR)+2*sizeof(INT)))
                    ? (PWSZ) 0
                         : LOCALALLOC((c+1) * (sizeof(WCHAR)+ 2 * sizeof(INT)));
                pDxCapture = (INT*) &pwszCapt[(c+1)&~1];  //  ^
            }                                             //  |
            else                                          // for pdy, just in case
            {
                pwszCapt = BALLOC_OVERFLOW1(c,WCHAR)
                    ? ((PWSZ) 0) : LOCALALLOC(c * sizeof(WCHAR));
            }
        }

        if (pwszCapt)
        {
            UINT u;

            if(bDBCSCodePage && pdx)
            {
                if(c <= CAPTURE_STRING_SIZE)
                {
                    pDxCapture = aiDxCaptureBuffer;
                }

                ConvertDxArray(dwCodePage,(char*) psz,(int*) pdx,c,pDxCapture, fl & ETO_PDY);
            }
            else
            {
                pDxCapture = (int*) pdx;
            }

            u = MultiByteToWideChar(
                dwCodePage, 0,
                psz,c,
                pwszCapt, c*sizeof(WCHAR));

            if (u)
            {
                bRet = FALSE;

#ifdef LANGPACK
                if (gbLpk && !(fl & ETO_IGNORELANGUAGE))
                {
                    bRet = ((*fpLpkExtTextOut)(hdc, x, y, fl, prcl, pwszCapt,
                                               u, pDxCapture, 0));

                    if (pwszCapt != awcCaptureBuffer)
                        LOCALFREE(pwszCapt);

                    return bRet;
                }
#endif

                if ((c <= MAX_BATCH_WCHAR) && (GdiBatchLimit > 1))
                {
                    bRet = bBatchTextOut(hdc,
                                         x,
                                         y,
                                         fl,
                                         (LPRECT)prcl,
                                         (LPWSTR)pwszCapt,
                                         pDxCapture,
                                         u,
                                         2 * u,
                                         dwCodePage
                                         );
                }

                if (!bRet)
                {
                    bRet = NtGdiExtTextOutW(
                                    hdc,
                                    x,y,
                                    fl, (LPRECT)prcl,
                                    (LPWSTR)pwszCapt,(int)u,
                                    pDxCapture,
                                    dwCodePage);
                }

            }

            if (pwszCapt != awcCaptureBuffer)
                LOCALFREE(pwszCapt);
        }
        else
        {
            GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }
    else
    {

        bRet = FALSE;

        if ((prcl != NULL) && (fl & ETO_OPAQUE))
        {
            //
            // try to batch text out rect
            //

            PDC_ATTR pdca;

            PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

            if ((pdca != NULL) && !(pdca->lTextAlign & TA_UPDATECP))
            {
                BEGIN_BATCH_HDC(hdc,pdca,BatchTypeTextOutRect,BATCHTEXTOUTRECT);

                    pBatch->BackColor  = pdca->crBackgroundClr;
                    pBatch->fl         = fl;
                    pBatch->rcl.left   = prcl->left;
                    pBatch->rcl.top    = prcl->top;
                    pBatch->rcl.right  = prcl->right;
                    pBatch->rcl.bottom = prcl->bottom;
                    pBatch->ptlViewportOrg = pdca->ptlViewportOrg;

                    bRet = TRUE;

                COMPLETE_BATCH_COMMAND();
            }
        }

UNBATCHED_COMMAND:

        if (!bRet)
        {
            bRet = NtGdiExtTextOutW(hdc,
                                    x,y,
                                    fl,
                                    (LPRECT)prcl,
                                    NULL,0,NULL,dwCodePage);
        }
    }

    return(bRet);
}

BOOL META WINAPI ExtTextOutA(
    HDC        hdc,
    int        x,
    int        y,
    UINT       fl,
    CONST RECT *prcl,
    LPCSTR     psz,
    UINT       c,
    CONST INT  *pdx
)
{
    return(ExtTextOutInternalA(hdc,x,y,fl,prcl,psz,c,pdx,FALSE));
}


/******************************Public*Routine******************************\
*
* BOOL META WINAPI TextOut
*
* History:
*  07-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI TextOutA(
    HDC        hdc,
    int        x,
    int        y,
    LPCSTR   psz,
    int        c
    )
{
    BOOL bRet = FALSE;

    if ((c <= 0) || (psz == (LPCSTR) NULL))
    {
        if (c == 0)
            return(TRUE);

        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    return ExtTextOutInternalA(hdc, x, y, 0, NULL, psz, c, NULL, TRUE);
}

/******************************Public*Routine******************************\
* FillRgn                                                                  *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI FillRgn(HDC hdc,HRGN hrgn,HBRUSH hbrush)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hrgn);
    FIXUP_HANDLE(hbrush);

// validate the region and brush.
    if (!hrgn || !hbrush)
        return(bRet);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_DrawRgn(hdc,hrgn,hbrush,0,0,META_FILLREGION));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_FillRgn(hdc,hrgn,hbrush))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiFillRgn(hdc,hrgn,hbrush));
}

/******************************Public*Routine******************************\
* FrameRgn                                                                 *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*
*  23-11-94 -by- Lingyun Wang [lingyunw]
* Now hrgn and hbrush are server side handles
*
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI FrameRgn(
    HDC    hdc,
    HRGN   hrgn,
    HBRUSH hbrush,
    int    cx,
    int    cy
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hrgn);
    FIXUP_HANDLE(hbrush);

    if (!hrgn || !hbrush)
        return(FALSE);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_DrawRgn(hdc,hrgn,hbrush,cx,cy,META_FRAMEREGION));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_FrameRgn(hdc,hrgn,hbrush,cx,cy))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiFrameRgn(hdc,hrgn,hbrush,cx,cy));
}

/******************************Public*Routine******************************\
* InvertRgn                                                                *
*                                                                          *
* Client side stub.                                                        *
*
* 23-11-94 -by- Lingyun Wang [lingyunw]
* Now hrgn is server side handle
*
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI InvertRgn(HDC hdc,HRGN hrgn)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hrgn);

    if (!hrgn)
        return(FALSE);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_DrawRgn(hdc,hrgn,(HBRUSH)0,0,0,META_INVERTREGION));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_InvertPaintRgn(hdc,hrgn,EMR_INVERTRGN))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiInvertRgn(hdc,hrgn));
}

/******************************Public*Routine******************************\
* SetPixelV                                                                *
*                                                                          *
* Client side stub.  This is a version of SetPixel that does not return a  *
* value.  This one can be batched for better performance.                  *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI SetPixelV(HDC hdc,int x,int y,COLORREF color)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsWWD(hdc,(WORD)x,(WORD)y,(DWORD)color,META_SETPIXEL));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetPixelV(hdc,x,y,color))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    //
    // ICM conversion (only happen for non-palette index color)
    //

    if (!(color & 0x01000000))
    {
        PDC_ATTR pdca;

        PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

        if (pdca && bNeedTranslateColor(pdca))
        {
            COLORREF NewColor;

            if (IcmTranslateCOLORREF(hdc,pdca,color,&NewColor,ICM_FORWARD))
            {
                color = NewColor;
            }
        }
    }

    return(NtGdiSetPixel(hdc,x,y,color) != CLR_INVALID);
}

/******************************Public*Routine******************************\
* SetPixel                                                                 *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

COLORREF META WINAPI SetPixel(HDC hdc,int x,int y,COLORREF color)
{
    ULONG    iRet = CLR_INVALID;
    COLORREF ColorRet = CLR_INVALID;
    COLORREF NewColor;
    BOOL     bStatus;
    PDC_ATTR pdca;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsWWD(hdc,(WORD)x,(WORD)y,(DWORD)color,META_SETPIXEL));

        DC_PLDC(hdc,pldc,iRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetPixelV(hdc,x,y,color))
                return(iRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(iRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

    if (pdca)
    {
        //
        // if the color is not a PaletteIndex and ICM is on then translate
        //

        if (!(color & 0x01000000) && bNeedTranslateColor(pdca))
        {
            bStatus = IcmTranslateCOLORREF(hdc,
                                           pdca,
                                           color,
                                           &NewColor,
                                           ICM_FORWARD);
            if (bStatus)
            {
                color = NewColor;
            }
        }

        ColorRet = NtGdiSetPixel(hdc,x,y,color);

        if ( bNeedTranslateColor(pdca)
               &&
             ( IS_32BITS_COLOR(pdca->lIcmMode)
                        ||
               ((ColorRet != CLR_INVALID) &&
                 !(ColorRet & 0x01000000))
             )
           )
        {
            //
            // Translate back to original color
            //

            bStatus = IcmTranslateCOLORREF(hdc,
                                           pdca,
                                           ColorRet,
                                           &NewColor,
                                           ICM_BACKWARD);
            if (bStatus)
            {
                ColorRet = NewColor;
            }
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(ColorRet);
}

/******************************Public*Routine******************************\
* UpdateColors                                                             *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI UpdateColors(HDC hdc)
{
    BOOL  bRet = FALSE;

    FIXUP_HANDLE(hdc);

    RESETUSERPOLLCOUNT();

    return(NtGdiUpdateColors(hdc));
}

/******************************Public*Routine******************************\
* GdiFlush                                                                 *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Wed 26-Jun-1991 13:58:00 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI GdiFlush(VOID)
{

    NtGdiFlush();
    return(TRUE);
}

/******************************Public*Routine******************************\
* GdiSetBatchLimit
*
*
* History:
*  31-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

DWORD WINAPI
GdiSetBatchLimit(
    DWORD dwNewBatchLimit
    )
{
    DWORD OldLimit = 0;

    //
    // set batch limit (as long as it is (1 <= l <= 20))
    // return old limit if successful. A new batch limit of 0
    // means set to default (20)
    //

    if (dwNewBatchLimit == 0)
    {
        dwNewBatchLimit = 20;
    }

    if ((dwNewBatchLimit > 0 ) && (dwNewBatchLimit <= 20))
    {
        GdiFlush();
        OldLimit = GdiBatchLimit;
        GdiBatchLimit = dwNewBatchLimit;
    }

    return(OldLimit);
}

/******************************Public*Routine******************************\
* GdiGetBatchLimit
*
* History:
*  7-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD WINAPI GdiGetBatchLimit()
{
    return(GdiBatchLimit);
}

/******************************Public*Routine******************************\
* EndPage
*
* Client side stub.
*
* History:
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]
* Wrote it.
*  9/16/97 - Ramananthan N. Venkatpathy [RamanV]
* Parameterized End Page to handle Form Pages.
\**************************************************************************/

int InternalEndPage(HDC hdc,
                    DWORD dwPageType)
{
    int  iRet = SP_ERROR;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,iRet);

        //
        // If the EndPage() is already called from
        // Escape(NEXTBAND), Just return TRUE here.
        //
        // This will fixed ...
        //
        // + The KB Q118873 "PRB: EndPage() Returns -1 When Banding"
        // + NTRaid #90099 "T1R: Visio 4.1, 16-bit can't print".
        //
        if( pldc->fl & LDC_CALLED_ENDPAGE )
        {
            pldc->fl &= ~LDC_CALLED_ENDPAGE;
            return((int)TRUE);
        }

        if( pldc->fl & LDC_META_PRINT )
        {
            if (dwPageType == NORMAL_PAGE) {
                return(MFP_EndPage( hdc ));
            } else if (dwPageType == FORM_PAGE) {
                return(MFP_EndFormPage( hdc ));;
            }
        }


        if ((pldc->fl & LDC_DOC_CANCELLED) ||
            ((pldc->fl & LDC_PAGE_STARTED) == 0))
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return(iRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        pldc->fl &= ~LDC_PAGE_STARTED;

    // now call the drivers UI portion

        DocumentEventEx(pldc->pUMPD,
                pldc->hSpooler,
                hdc,
                DOCUMENTEVENT_ENDPAGE,
                0,
                NULL,
                0,
                NULL);

        RESETUSERPOLLCOUNT();

        iRet = NtGdiEndPage(hdc);

        // if user mode printer, call EndPagePrinter from user mode

        if (iRet && pldc->pUMPD)
            iRet = EndPagePrinterEx(pldc->pUMPD, pldc->hSpooler);

        // For Win31 compatibility, return SP_ERROR for error.

        if (!iRet)
            iRet = SP_ERROR;
        else
            pldc->fl |= LDC_CALL_STARTPAGE;

#if PRINT_TIMER
        if( bPrintTimer )
        {
            DWORD tc;
            tc = GetTickCount();
            DbgPrint("Page took %d.%d seconds to print\n",
                     (tc - pldc->msStartPage) / 1000,
                     (tc - pldc->msStartPage) % 1000 );

        }
#endif
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
    }

    return(iRet);
}

int WINAPI EndPage(HDC hdc)
{
    return InternalEndPage(hdc, NORMAL_PAGE);
}

int WINAPI EndFormPage(HDC hdc)
{
    return InternalEndPage(hdc, FORM_PAGE);
}

/******************************Public*Routine******************************\
* StartPage
*
* Client side stub.
*
* History:
*  31-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int WINAPI StartPage(HDC hdc)
{
    int iRet = SP_ERROR;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,iRet);

#if PRINT_TIMER
        pldc->msStartPage = GetTickCount();
#endif

        if( pldc->fl & LDC_META_PRINT )
            return(MFP_StartPage( hdc ));

        pldc->fl &= ~LDC_CALL_STARTPAGE;
        pldc->fl &= ~LDC_CALLED_ENDPAGE;

        // Do nothing if page has already been started.

        if (pldc->fl & LDC_PAGE_STARTED)
            return(1);

    // now call the drivers UI portion

        if (pldc->hSpooler)
        {
            if (DocumentEventEx(pldc->pUMPD,
                    pldc->hSpooler,
                    hdc,
                    DOCUMENTEVENT_STARTPAGE,
                    0,
                    NULL,
                    0,
                    NULL) == -1)
            {
                return(iRet);
            }
        }

        pldc->fl |= LDC_PAGE_STARTED;

        RESETUSERPOLLCOUNT();

   // If it is UMPD, call StartPagePrinter from user mode

        if (pldc->pUMPD)
            iRet = StartPagePrinterEx(pldc->pUMPD, pldc->hSpooler);

        if (iRet)
        {
            iRet = NtGdiStartPage(hdc);
        }

    // For Win31 compatibility, return SP_ERROR for error.

        if (!iRet)
        {
            pldc->fl &= ~LDC_PAGE_STARTED;
            EndDoc(hdc);
            iRet = SP_ERROR;
            SetLastError(ERROR_INVALID_HANDLE);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* StartFormPage
*
* This interface has been added to support watermarks and forms.
*
* History:
*     7/1/97 -- Ramanathan Venkatapathy [RamanV]
*
\**************************************************************************/

int WINAPI StartFormPage(HDC hdc)
{
    // Call StartPage. Recording required for watermarks is done in EndFormPage

    return StartPage(hdc);
}

/******************************Public*Routine******************************\
* EndDoc
*
* If a thread is created at StartDoc(), terminate it here.
*
* History:
*  31-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int WINAPI EndDoc(HDC hdc)
{
    int  iRet = SP_ERROR;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,iRet);

        if( pldc->fl & LDC_META_PRINT )
            return(MFP_EndDoc( hdc ));

#if PRINT_TIMER
        if( bPrintTimer )
        {
            DWORD tc;
            tc = GetTickCount();
            DbgPrint("Document took %d.%d seconds to print\n",
                     (tc - pldc->msStartDoc) / 1000,
                     (tc - pldc->msStartDoc) % 1000 );

            DbgPrint("Peak temporary spool buffer size: %d\n", PeakTempSpoolBuf);
        }
#endif

        if ((pldc->fl & LDC_DOC_STARTED) == 0)
            return(1);

        // Call EndPage if the page has been started.

        if (pldc->fl & LDC_PAGE_STARTED)
            EndPage(hdc);

        // now call the drivers UI portion

        DocumentEventEx(pldc->pUMPD,
                pldc->hSpooler,
                hdc,
                DOCUMENTEVENT_ENDDOCPRE,
                0,
                NULL,
                0,
                NULL);

        RESETUSERPOLLCOUNT();

        iRet = NtGdiEndDoc(hdc);

        //
        // call EndDocPrinter from user mode if it is a User Mode Printer
        //
        if (pldc->pUMPD)
            iRet = EndDocPrinterEx(pldc->pUMPD, pldc->hSpooler);

        // For Win31 compatibility, return SP_ERROR for error.

        if (!iRet)
        {
            iRet = SP_ERROR;
        }
        else
        {
            DocumentEventEx(pldc->pUMPD,
                    pldc->hSpooler,
                    hdc,
                    DOCUMENTEVENT_ENDDOCPOST,
                    0,
                    NULL,
                    0,
                    NULL);
        }

        pldc->fl &= ~(LDC_DOC_STARTED  | LDC_CALL_STARTPAGE |
                      LDC_SAP_CALLBACK | LDC_CALLED_ENDPAGE);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* AbortDoc
*
* Client side stub.
*
* History:
*  02-Apr-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

int WINAPI AbortDoc(HDC hdc)
{
    int iRet = SP_ERROR;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,iRet);

        if (!(pldc->fl & LDC_DOC_STARTED))
            return(1);

    // now call the drivers UI portion

        DocumentEventEx(pldc->pUMPD,
                pldc->hSpooler,
                hdc,
                DOCUMENTEVENT_ABORTDOC,
                0,
                NULL,
                0,
                NULL);

        RESETUSERPOLLCOUNT();

        if( pldc->fl & LDC_META_PRINT )
        {
            DeleteEnhMetaFile(UnassociateEnhMetaFile( hdc, FALSE ));
            DeleteEMFSpoolData(pldc);

            //
            // bug 150446: calling fpAbortPrinter before deleting the
            // EMF file might cause EMF file leak.
            //

            iRet = (*fpAbortPrinter)( pldc->hSpooler );
        }
        else
        {

            iRet = NtGdiAbortDoc(hdc);

            // call AbortPrinter from user mode if it is UMPD

            if (iRet && pldc->pUMPD)
                iRet = AbortPrinterEx(pldc, FALSE);
        }

    // For Win31 compatibility, return SP_ERROR for error.

        if (!iRet)
            iRet = SP_ERROR;

    // turn off the flags

        pldc->fl &= ~(LDC_DOC_STARTED  | LDC_PAGE_STARTED | LDC_CALL_STARTPAGE |
                      LDC_SAP_CALLBACK | LDC_META_PRINT   | LDC_CALLED_ENDPAGE);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* StartDocA
*
* Client side stub.
*
* History:
*
*  21-Mar-1995 -by- Mark Enstrom [marke]
* Change to call StartDocW for kmode
*
*  31-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

ULONG  ulToASCII_N(LPSTR psz, DWORD cbAnsi, LPWSTR pwsz, DWORD c);

int WINAPI StartDocA(HDC hdc, CONST DOCINFOA * pDocInfo)
{


    DOCINFOW DocInfoW;
    WCHAR    wDocName[MAX_PATH];
    WCHAR    wOutput[MAX_PATH];
    WCHAR    wDataType[MAX_PATH];
    int      Length;

    DocInfoW.cbSize = sizeof(DOCINFOW);
    DocInfoW.lpszDocName  = NULL;
    DocInfoW.lpszOutput   = NULL;
    DocInfoW.lpszDatatype = NULL;
    DocInfoW.fwType       = 0;

    if (pDocInfo)
    {
        if (pDocInfo->lpszDocName)
        {
            Length = strlen(pDocInfo->lpszDocName)+1;

            if (Length > MAX_PATH)
            {
                ERROR_ASSERT(FALSE, "StartDocA lpszDocName Too long");
                GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
                return(SP_ERROR);
            }

            DocInfoW.lpszDocName = &wDocName[0];
            vToUnicodeN(DocInfoW.lpszDocName,MAX_PATH,pDocInfo->lpszDocName,Length);
        }

        if (pDocInfo->lpszOutput)
        {
            Length = strlen(pDocInfo->lpszOutput)+1;

            if (Length > MAX_PATH)
            {
                ERROR_ASSERT(FALSE, "StartDocA lpszOutput Too long");
                GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
                return(SP_ERROR);
            }

            DocInfoW.lpszOutput = &wOutput[0];
            vToUnicodeN(DocInfoW.lpszOutput,MAX_PATH,pDocInfo->lpszOutput,Length);
        }

        // if the datatype is specified to be raw, and the size is the size of
        // the new expanded DOCINFO, make it raw.
        // we also verify that the fwType is valid.  Otherwise, chances are
        // the app left the two new fields unitialized.

        try
        {
            if ((pDocInfo->cbSize == sizeof(DOCINFO)) &&
                pDocInfo->lpszDatatype &&
                (pDocInfo->fwType <= 1))

            {

                if (!_stricmp("emf",pDocInfo->lpszDatatype))
                {
                    DocInfoW.lpszDatatype = L"EMF";
                }
                else
                {
                    Length = strlen(pDocInfo->lpszDatatype)+1;
                    vToUnicodeN(wDataType,MAX_PATH,pDocInfo->lpszDatatype,Length);
                    DocInfoW.lpszDatatype = wDataType;
                }
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("StartDocA an app passed a new DOCINFO structure without initializing it\n");
        }
    }

    return(StartDocW(hdc,&DocInfoW));
}

/******************************Public*Routine******************************\
* StartDocW
*
* Client side stub.
*
* History:
*  31-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int WINAPI StartDocW(HDC hdc, CONST DOCINFOW * pDocInfo)
{
    int iRet = SP_ERROR;
    PWSTR pwstr = NULL;
    DOCINFOW dio;
    BOOL bForceRaw = FALSE;
    BOOL bSendStartDocPost = FALSE;
    BOOL bCallAbortPrinter = TRUE;
    BOOL bEMF = FALSE;
    INT iJob;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        BOOL bBanding;
        PLDC pldc;

        DC_PLDC(hdc,pldc,iRet);

        // don't allow StartDoc's on info dc's

        if (pldc->fl & LDC_INFO)
        {
            SetLastError(ERROR_INVALID_HANDLE);
            return iRet;
        }

        pldc->fl &= ~LDC_DOC_CANCELLED;

        #if PRINT_TIMER
        {
            DbgPrint("StartDocW: Print Timer is on\n");
            pldc->msStartDoc = GetTickCount();
        }
        #endif

        if( pDocInfo )
        {
            dio = *pDocInfo;

            if (dio.cbSize != offsetof(DOCINFOW,lpszDatatype))
            {
                dio.cbSize       = sizeof(DOCINFOW);
                dio.lpszDatatype = NULL;
                dio.fwType       = 0;

                try
                {
                    // if it is not NULL and not "emf", go raw
                    // we also verify that the fwType is valid.  Otherwise, chances are
                    // the app left the two new fields unitialized.

                    if ((pDocInfo->cbSize == sizeof(DOCINFOW)) &&
                        pDocInfo->lpszDatatype           &&
                        (pDocInfo->fwType <= 1)          &&
                        _wcsicmp(L"emf",pDocInfo->lpszDatatype))
                    {
                        // the app requested non emf

                        bForceRaw = TRUE;
                        dio.lpszDatatype = pDocInfo->lpszDatatype;
                    }
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNING("StartDocW an app passed a new DOCINFO structure without initializing it\n");
                }
            }
        }
        else
        {
            dio.cbSize = sizeof(DOCINFOW);
            dio.lpszDatatype = NULL;
            dio.lpszOutput   = NULL;
            dio.lpszDocName  = NULL;
            dio.fwType       = 0;
        }

        // if no output port is specified but a port was specified at createDC, use
        // that port now

        if ((dio.lpszOutput == NULL) && (pldc->pwszPort != NULL))
        {
            dio.lpszOutput = pldc->pwszPort;
        }

        // StartDocDlgW returns -1 for error
        //                      -2 for user cancelled
        //                      NULL if there is no string to copy (not file port)
        //                      Non NULL if there is a valid string

        if(pldc->hSpooler != (HANDLE)0)
        {
            ASSERTGDI(ghSpooler,"non null hSpooler with unloaded WINSPOOL W\n");

            pwstr = (*fpStartDocDlgW)(pldc->hSpooler, &dio);

            if((LONG_PTR)pwstr == -2)
            {
                pldc->fl |= LDC_DOC_CANCELLED;
                return(iRet);
            }
            if((LONG_PTR)pwstr == -1)
                return(iRet);

            if(pwstr != NULL)
            {
                dio.lpszOutput = pwstr;
            }
        }

        // now call the drivers UI portion

        if (pldc->hSpooler)
        {
            PVOID pv = (PVOID)&dio;

            iRet = DocumentEventEx(pldc->pUMPD,
                    pldc->hSpooler,
                    hdc,
                    DOCUMENTEVENT_STARTDOCPRE,
                    sizeof(pv),
                    (PVOID)&pv,
                    0,
                    NULL);

            if (iRet == -1)
            {
                bCallAbortPrinter = FALSE;
                goto KMMSGERROR;
            }
            if(iRet == -2)
            {
                pldc->fl |= LDC_DOC_CANCELLED;
                goto MSGEXIT;
            }

        }

        //
        // Check application compatibility
        //
        if (GetAppCompatFlags(NULL) & GACF_NOEMFSPOOLING)
        {
            ULONG InData = POSTSCRIPT_PASSTHROUGH;

            //
            // Disable EMF spooling for postscript printer driver.
            //
            // Several PS-centric application could not work with EMF spooling.
            // This problem is introduced, because application developed for win95
            // reley on that win95 does not do EMF spooling with postscript, but
            // NT does.
            //
            if (ExtEscape(hdc,QUERYESCSUPPORT,sizeof(ULONG),(LPCSTR)&InData,0,NULL))
            {
                bForceRaw = TRUE;
            }
        }

        // Unless the driver has explicitly told us not to spool, we will first try
        // to StartDoc with datatype EMF

        // we also force to go to EMF if METAFILE_DRIVER is supported by the driver

        if ((!bForceRaw && GetDCDWord(hdc, DDW_JOURNAL, 0) &&
            RemoteRasterizerCompatible(pldc->hSpooler)) ||
             ((pldc->pUMPD) && (pldc->pUMPD->dwFlags & UMPDFLAG_METAFILE_DRIVER)))
        {
            DOC_INFO_3W    DocInfo;

            DocInfo.pDocName    = (LPWSTR) dio.lpszDocName;
            DocInfo.pOutputFile = (LPWSTR) dio.lpszOutput;
            DocInfo.pDatatype   = (LPWSTR) L"NT EMF 1.008";
            DocInfo.dwFlags = DI_MEMORYMAP_WRITE;

            iJob = (*fpStartDocPrinterW)(pldc->hSpooler, 3, (LPBYTE) &DocInfo);

            if( iJob <= 0 )
            {
                if( GetLastError() != ERROR_INVALID_DATATYPE )
                {
                    WARNING("StartDocW: StartDocPrinter failed w/ error other \
                             than INVALID_DATA_TYPE\n");
                    bCallAbortPrinter = FALSE;
                    goto KMMSGERROR;
                }
                else
                {
                    // we are going raw so just fall through
                }
            }
            else
            {
                // the spooler likes the EMF data type so let start metafiling

                MFD1("StartDocW calling MFP_StartDocW to do EMF printing\n");

                if(MFP_StartDocW( hdc, &dio, FALSE))
                {
                    iRet = iJob;
                    bSendStartDocPost = TRUE;

                    goto MSGEXIT;
                }
                else
                {
                    WARNING("StartDocW: error calling MFP_StartDocW\n");
                    bEMF = TRUE;
                    goto KMMSGERROR;
                }
            }
        }


        // if it is a UMPD driver, call StartDocPrinter at the client side

        if (pldc->pUMPD)
        {

            DOC_INFO_1W    DocInfo;

            #define MAX_DOCINFO_DATA_TYPE 80
            WCHAR awchDatatype[MAX_DOCINFO_DATA_TYPE];
            PFN pfn;

            DocInfo.pDocName    = (LPWSTR) dio.lpszDocName;
            DocInfo.pOutputFile = (LPWSTR) dio.lpszOutput;
            DocInfo.pDatatype   = NULL;


            if (pfn = pldc->pUMPD->apfn[INDEX_DrvQuerySpoolType])
            {
                awchDatatype[0] = 0;

                // did the app specify a data type and will it fit in our buffer

                if (dio.lpszDatatype)
                {
                    int cjStr = (wcslen(dio.lpszDatatype) + 1) * sizeof(WCHAR);

                    if (cjStr < (MAX_DOCINFO_DATA_TYPE * sizeof(WCHAR)))
                    {
                        RtlCopyMemory((PVOID)awchDatatype,(PVOID)dio.lpszDatatype,cjStr);
                    }
                }

                if (pfn(((PUMDHPDEV)pldc->pUMdhpdev)->dhpdev, awchDatatype))
                {
                    DocInfo.pDatatype = awchDatatype;
                }

            }

            iJob = StartDocPrinterWEx(pldc->pUMPD, pldc->hSpooler, 1, (LPBYTE) &DocInfo);

        }

        // If we got here it means we are going raw.  Mark the DC as type direct

        if (pldc->pUMPD && (pldc->pUMPD->dwFlags & UMPDFLAG_METAFILE_DRIVER))
        {
           // we have to go EMF if METAFILE_DRIVER is on

           WARNING("StartDocW failed because EMF failed and METAFILE_DRIVER is on\n");
           goto KMMSGERROR;
        }

        pldc->fl |= LDC_PRINT_DIRECT;

        iRet = NtGdiStartDoc(hdc,&dio,&bBanding, iJob);

        if (iRet)
        {
            if (pldc->pfnAbort != NULL)
            {
                vSAPCallback(pldc);

                if (pldc->fl & LDC_DOC_CANCELLED)
                    goto KMMSGERROR;

                pldc->fl |= LDC_SAP_CALLBACK;
                pldc->ulLastCallBack = GetTickCount();
            }

            pldc->fl |= LDC_DOC_STARTED;

            if (bBanding)
            {
                MFD1("StartDocW calling MFP_StartDocW to do banding\n");
                iRet = MFP_StartDocW( hdc, NULL, TRUE )  ? iRet : SP_ERROR;
            }
            else
            {
                // Only set this when we are not banding since the system will
                // get confused and try to call StartPage while playing the
                // metafile back during banding.

                pldc->fl |= LDC_CALL_STARTPAGE;
            }

            bSendStartDocPost = TRUE;
        }
        else
        {
KMMSGERROR:
            iRet = SP_ERROR;

            if (bCallAbortPrinter && pldc->pUMPD)
            {
                AbortPrinterEx(pldc, bEMF);
            }
        }

MSGEXIT:
        if (bSendStartDocPost)
        {
            // now see if we need to call the drivers UI portion

            {
                if (DocumentEventEx(pldc->pUMPD,
                        pldc->hSpooler,
                        hdc,
                        DOCUMENTEVENT_STARTDOCPOST,
                        sizeof(iRet),
                        (PVOID)&iRet,
                        0,
                        NULL) == -1)
                {
                    AbortDoc(hdc);
                    iRet = SP_ERROR;
                }
            }
        }
    }

    if (pwstr != NULL)
    {
        LocalFree(pwstr);
    }

    return(iRet);
}


/******************************Public*Routine******************************\
* StartDocEMF
*
* Special version of StartDoc used by the EMF playback code.
*
* History:
*  31-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int WINAPI StartDocEMF(HDC hdc, CONST DOCINFOW * pDocInfo, BOOL *pbBanding )
{
    int iRet = SP_ERROR;
    DOCINFOW dio;
    INT  iJob = 0;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        BOOL bBanding;
        PLDC pldc;

        DC_PLDC(hdc,pldc,iRet);

#if PRINT_TIMER
        {
            DbgPrint("StartDocW: Print Timer is on\n");
            pldc->msStartDoc = GetTickCount();
        }
#endif

        // if no output port is specified but a port was specified at createDC, use that port now

        if (pDocInfo)
        {
            dio = *pDocInfo;

            if (dio.lpszOutput == NULL && pldc->pwszPort != NULL)
                dio.lpszOutput = pldc->pwszPort;
        }
        else
        {
            ZeroMemory(&dio, sizeof(dio));
            dio.cbSize = sizeof(dio);
        }

        // if it is a UMPD driver, call StartDocPrinter at the client side

        if (pldc->pUMPD)
        {
            DOC_INFO_3W    DocInfo;

            DocInfo.pDocName    = (LPWSTR) dio.lpszDocName;
            DocInfo.pOutputFile = (LPWSTR) dio.lpszOutput;
            DocInfo.pDatatype   = NULL;
            DocInfo.dwFlags = DI_MEMORYMAP_WRITE;

            iJob = (*fpStartDocPrinterW)( pldc->hSpooler, 3, (LPBYTE) &DocInfo );
        }

        iRet = NtGdiStartDoc(hdc,(DOCINFOW *)&dio, pbBanding, iJob);

        if (iRet)
        {
            pldc->fl |= LDC_DOC_STARTED;
            pldc->fl |= LDC_CALL_STARTPAGE;
        }
        else
        {
        // For Win31 compatibility, return SP_ERROR for error.

            iRet = SP_ERROR;

            if (pldc->pUMPD)
            {
                (*fpAbortPrinter)(pldc->hSpooler);
            }
        }
    }

    return(iRet);
}



/******************************Private*Function****************************\
* vSAPCallback
*
*  Call back to applications abort proc.
*
* History:
*  02-May-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID vSAPCallback(PLDC pldc)
{
    ULONG ulCurr = GetTickCount();

    if (ulCurr - pldc->ulLastCallBack >= CALLBACK_INTERVAL)
    {
        pldc->ulLastCallBack = ulCurr;
        if (!(*pldc->pfnAbort)(pldc->hdc, 0))
        {
            CancelDC(pldc->hdc);
            AbortDoc(pldc->hdc);
        }
    }
}

/******************************Public*Routine******************************\
* SetAbortProc
*
* Save the application-supplied abort function in the LDC struct.
*
* History:
*  02-Apr-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

int WINAPI SetAbortProc(HDC hdc, ABORTPROC pfnAbort)
{
    int iRet = SP_ERROR;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,iRet);

        if (pfnAbort != (ABORTPROC)NULL)
        {
            // PageMaker calls SetAbortProc after StartDoc.

            if (pldc->fl & LDC_DOC_STARTED)
            {
                pldc->fl |= LDC_SAP_CALLBACK;
                pldc->ulLastCallBack = GetTickCount();
            }
        }
        else
        {
            pldc->fl &= ~LDC_SAP_CALLBACK;
        }

        pldc->pfnAbort = pfnAbort;

        iRet = 1;
    }

    return(iRet);
}


/******************************Public*Routine******************************\
*
* GetPairKernTable
*
* support for GETPAIRKERNTABLE escape, basically reroute the call
* the the regular API
*
* History:
*  17-Jun-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

DWORD GetPairKernTable (
    HDC        hdc,
    DWORD      cjSize,  // size of buffer in bytes
    KERNPAIR * pkp
    )
{
    DWORD dwRet = GetKerningPairsA(hdc, 0, NULL);
    DWORD dwRet1, ikp;

    if (pkp && dwRet)
    {
    // pointer to receiving buffer

        KERNINGPAIR *pKernPair = LOCALALLOC(dwRet * sizeof(KERNINGPAIR));
        if (pKernPair)
        {
            dwRet1 = GetKerningPairsA(hdc, dwRet, pKernPair);
            if (dwRet1 == dwRet)  // paranoid check
            {
            // now we can copy the data out, get the number of pairs
            // that the buffer can hold:

                dwRet = cjSize / sizeof (KERNPAIR);
                if (dwRet > dwRet1)
                    dwRet = dwRet1;

                for (ikp = 0; ikp < dwRet; ikp++)
                {
                    pkp[ikp].sAmount = (SHORT)pKernPair[ikp].iKernAmount;
                    pkp[ikp].wBoth = (WORD)
                                     ((BYTE)pKernPair[ikp].wFirst |
                                     (BYTE)pKernPair[ikp].wSecond << 8);
                }
            }
            else
            {
                dwRet = 0;
            }
            LOCALFREE(pKernPair);
        }
        else
        {
            dwRet = 0;
        }
    }

    return dwRet;
}






/******************************Public*Routine******************************\
* Escape                                                                   *
*                                                                          *
* Compatibility support for the old 16 bit Escape call.                    *
*                                                                          *
* Note that there are some rules to follow here:                           *
*                                                                          *
* 1) WOW should map a selected set of old Escape calls to ExtEscape.       *
*    These should be the calls that we want to support under NT (i.e. the  *
*    ones we are forced to support), and that make sense (i.e. have well   *
*    defined output structures, where NULL is well defined).  In this      *
*    mapping, WOW insures 32 bit alignment.  It maps directly to ExtEscape *
*    just for efficiency.                                                  *
*                                                                          *
* 2) GDI should map ALL the same calls that WOW does.  Thus when a 16 bit  *
*    app that works under WOW gets ported to 32 bits, it will keep         *
*    working, even if it still calls Escape.  (I'm basically assuming that *
*    Chicago will also allow this.  On the other hand if Chicago forces    *
*    apps to migrate to ExtEscape, then we can too.  But we can't force    *
*    them by ourselves!)                                                   *
*                                                                          *
* 3) Any data structures passed to Escape must get passed unchanged to     *
*    ExtEscape.  This includes the 16 bit WORD in POSTSCRIPT_PASSTHROUGH.  *
*    Remember, we *want* Chicago to be able to easily support our          *
*    ExtEscapes.  If we remove that WORD, it will be hard for then         *
*    to put it back.  It's pretty easy for our driver to ignore it.        *
*                                                                          *
* 4) Our Escape entry point should handle QUERYESCSUPPORT in the           *
*    following way.  a) It should require an nCount of 2, not the          *
*    present 4.  b) It should return TRUE for those functions that it      *
*    handles by mapping onto APIs.  c) For any function that it would pass *
*    on to ExtEscape, it should also pass the QUERYESCSUPPORT on.  (For    *
*    example, this function can't answer for the support of                *
*    POSTSCRIPT_PASSTHROUGH.)  However, the QUERYESCSUPPORT in ExtEscape   *
*    *should* expect a DWORD.  (It is after all a 32 bit function.)  This  *
*    should not inconvenience Chicago.  They can simply reject function    *
*    numbers >64K.                                                         *
*                                         [chuckwh - 5/8/93]               *
*                                                                          *
* History:                                                                 *
*  Mon May 17 13:49:32 1993     -by-    Hock San Lee    [hockl]            *
* Made ENCAPSULATED_POSTSCRIPT call DrawEscape.                            *
*                                                                          *
*  Sat 08-May-1993 00:03:06 -by- Charles Whitmer [chuckwh]                 *
* Added support for POSTSCRIPT_PASSTHROUGH, OPENCHANNEL, CLOSECHANNEL,     *
* DOWNLOADHEADER, DOWNLOADFACE, GETFACENAME, ENCAPSULATED_POSTSCRIPT.      *
* Cleaned up the code and conventions a bit.                               *
*                                                                          *
*  02-Apr-1992 -by- Wendy Wu [wendywu]                                     *
* Modified to call the client side GDI functions.                          *
*                                                                          *
*  01-Aug-1991 -by- Eric Kutter [erick]                                    *
* Wrote it.                                                                *
\**************************************************************************/

int WINAPI Escape(
    HDC    hdc,     //  Identifies the device context.
    int    iEscape, //  Specifies the escape function to be performed.
    int    cjIn,    //  Number of bytes of data pointed to by pvIn.
    LPCSTR pvIn,    //  Points to the input data.
    LPVOID pvOut    //  Points to the structure to receive output.
)
{
    int      iRet = 0;
    DOCINFOA DocInfo;
    PLDC     pldc;
    ULONG    iQuery;
    BOOL     bFixUp;

    FIXUP_HANDLE(hdc);

// Metafile the call.

    if(IS_METADC16_TYPE(hdc))
        return((int) MF16_Escape(hdc,iEscape,cjIn,pvIn,pvOut));

// handle escapes that don't require a printer

    switch (iEscape)
    {
    case QUERYESCSUPPORT:
        switch(*((UNALIGNED USHORT *) pvIn))
        {
        // Respond OK to the calls we handle inline below.

        case QUERYESCSUPPORT:
        case PASSTHROUGH:
        case STARTDOC:
        case ENDDOC:
        case NEWFRAME:
        case ABORTDOC:
        case SETABORTPROC:
        case GETPHYSPAGESIZE:
        case GETPRINTINGOFFSET:
        case GETSCALINGFACTOR:
        case NEXTBAND:
        case GETCOLORTABLE:
        case OPENCHANNEL:
        case CLOSECHANNEL:
        case DOWNLOADHEADER:
            iRet = (IS_ALTDC_TYPE(hdc) ? 1 : 0);
            break;

        case GETEXTENDEDTEXTMETRICS:
            iRet = 1;
            break;

        // Ask the driver about the few calls we allow to pass through.

        case SETCOPYCOUNT:
        case GETDEVICEUNITS:
        case POSTSCRIPT_PASSTHROUGH:
        case POSTSCRIPT_DATA:
        case POSTSCRIPT_IGNORE:
        case POSTSCRIPT_IDENTIFY:
        case POSTSCRIPT_INJECTION:
        case DOWNLOADFACE:
        case BEGIN_PATH:
        case END_PATH:
        case CLIP_TO_PATH:
        case DRAWPATTERNRECT:

           iQuery = (ULONG) (*((UNALIGNED USHORT *) pvIn));

           iRet =
           (
                ExtEscape
                (
                    hdc,
                    (ULONG) ((USHORT) iEscape),
                    4,
                    (LPCSTR) &iQuery,
                    0,
                    (LPSTR) NULL
                )
           );
           break;



        case ENCAPSULATED_POSTSCRIPT:
            iQuery = (ULONG) (*((UNALIGNED USHORT *) pvIn));

            iRet =
            (
                DrawEscape
                (
                    hdc,
                    (int) (ULONG) ((USHORT) iEscape),
                    4,
                    (LPCSTR) &iQuery
                )
            );
            break;

        case QUERYDIBSUPPORT:
            iRet = 1;
            break;

        // Otherwise it's no deal.  Sorry.  If we answer "yes" to some
        // call we don't know *everything* about, we may find ourselves
        // actually rejecting the call later when the app actually calls
        // with some non-NULL pvOut.  This would get the app all excited
        // about our support for no reason.  It would take a path that
        // is doomed to failure. [chuckwh]

        default:
            iRet = 0;
            break;
        }
        return(iRet);

    case GETCOLORTABLE:

        iRet = GetSystemPaletteEntries(hdc,*((UNALIGNED SHORT *)pvIn),1,pvOut);

        if (iRet == 0)
            iRet = -1;
        return(iRet);

    case QUERYDIBSUPPORT:
        if ((pvOut != NULL) && (cjIn >= sizeof(BITMAPINFOHEADER)))
        {
        *((UNALIGNED LONG *)pvOut) = 0;

            switch (((UNALIGNED BITMAPINFOHEADER *)pvIn)->biCompression)
            {
            case BI_RGB:
                switch (((UNALIGNED BITMAPINFOHEADER *)pvIn)->biBitCount)
                {
                case 1:
                case 4:
                case 8:
                case 16:
                case 24:
                case 32:
            *((UNALIGNED LONG *)pvOut) = (QDI_SETDIBITS|QDI_GETDIBITS|
                                                 QDI_DIBTOSCREEN|QDI_STRETCHDIB);
                    break;
                default:
                    break;
                }

            case BI_RLE4:
                if (((UNALIGNED BITMAPINFOHEADER *)pvIn)->biBitCount == 4)
                {
            *((UNALIGNED LONG *)pvOut) = (QDI_SETDIBITS|QDI_GETDIBITS|
                                                 QDI_DIBTOSCREEN|QDI_STRETCHDIB);
                }
                break;

            case BI_RLE8:
                if (((UNALIGNED BITMAPINFOHEADER *)pvIn)->biBitCount == 8)
                {
            *((UNALIGNED LONG *)pvOut) = (QDI_SETDIBITS|QDI_GETDIBITS|
                                                 QDI_DIBTOSCREEN|QDI_STRETCHDIB);
                }
                break;

            case BI_BITFIELDS:
                switch (((UNALIGNED BITMAPINFOHEADER *)pvIn)->biBitCount)
                {
                case 16:
                case 32:
            *((UNALIGNED LONG *)pvOut) = (QDI_SETDIBITS|QDI_GETDIBITS|
                                                 QDI_DIBTOSCREEN|QDI_STRETCHDIB);
                    break;
                default:
                    break;
                }

            default:
                break;
            }
            return 1;
        }

    case GETEXTENDEDTEXTMETRICS:
        return( GetETM( hdc, pvOut ) ? 1 : 0 );

    }

// OK, ones that are related to printing and need the LDC

    if (IS_ALTDC_TYPE(hdc))
    {
        BOOL bFixUp = FALSE;
        PLDC pldc;

        DC_PLDC(hdc,pldc,iRet);

    // Call the appropriate client side APIs.

        switch (iEscape)
        {
        case CLOSECHANNEL:
        case ENDDOC:
            iRet = EndDoc(hdc);
            break;

        case ABORTDOC:
            iRet = AbortDoc(hdc);
            break;

        case SETABORTPROC:
            iRet = SetAbortProc(hdc, (ABORTPROC)pvIn);
            break;

        case GETSCALINGFACTOR:
            if (pvOut)
            {
                ((UNALIGNED POINT *)pvOut)->x = GetDeviceCaps(hdc, SCALINGFACTORX);
                ((UNALIGNED POINT *)pvOut)->y = GetDeviceCaps(hdc, SCALINGFACTORY);
            }
            iRet = 1;

            break;

        case SETCOPYCOUNT:
            iRet =
            (
                ExtEscape
                (
                    hdc,
                    (ULONG) ((USHORT) iEscape),
                    cjIn,
                    pvIn,
                    pvOut ? sizeof(int) : 0,
                    (LPSTR) pvOut
                )
            );
            break;

        case GETDEVICEUNITS:
            iRet =
            (
                ExtEscape
                (
                    hdc,
                    GETDEVICEUNITS,
                    cjIn,
                    pvIn,
                    16,
                    pvOut
                )
            );
            break;

        case POSTSCRIPT_PASSTHROUGH:
            iRet =
            (
                ExtEscape
                (
                    hdc,
                    POSTSCRIPT_PASSTHROUGH,
                    (int) (*((UNALIGNED USHORT *) pvIn))+2,
                    pvIn,
                    0,
                    (LPSTR) NULL
                )
            );
            break;

        case OPENCHANNEL:
            DocInfo.lpszDocName = (LPSTR) NULL;
            DocInfo.lpszOutput  = (LPSTR) NULL;
            DocInfo.lpszDatatype= (LPSTR) "RAW";
            DocInfo.fwType      = 0;
            iRet = StartDocA(hdc,&DocInfo);
            break;

        case DOWNLOADHEADER:
            iRet = 1;
            break;

        case POSTSCRIPT_DATA:
        case POSTSCRIPT_IGNORE:
        case POSTSCRIPT_IDENTIFY:
        case POSTSCRIPT_INJECTION:
        case DOWNLOADFACE:
        case BEGIN_PATH:
        case END_PATH:
        case CLIP_TO_PATH:
        case DRAWPATTERNRECT:
            iRet =
            (
                ExtEscape
                (
                    hdc,
                    (ULONG) ((USHORT) iEscape),
                    cjIn,
                    pvIn,
                    0,
                    (LPSTR) NULL
                )
            );
            break;



        case ENCAPSULATED_POSTSCRIPT:
            iRet =
            (
                DrawEscape
                (
                    hdc,
                    (int) (ULONG) ((USHORT) iEscape),
                    cjIn,
                    pvIn
                )
            );
            break;

        case GETPHYSPAGESIZE:
            if (pvOut)
            {
                ((UNALIGNED POINT *)pvOut)->x = GetDeviceCaps(hdc, PHYSICALWIDTH);
                ((UNALIGNED POINT *)pvOut)->y = GetDeviceCaps(hdc, PHYSICALHEIGHT);
            }
            iRet = 1;
            break;

        case GETPRINTINGOFFSET:
            if (pvOut)
            {
                ((UNALIGNED POINT *)pvOut)->x = GetDeviceCaps(hdc, PHYSICALOFFSETX);
                ((UNALIGNED POINT *)pvOut)->y = GetDeviceCaps(hdc, PHYSICALOFFSETY);
            }
            iRet = 1;
            break;

        case STARTDOC:
            DocInfo.lpszDocName = (LPSTR)pvIn;
            DocInfo.lpszOutput  = (LPSTR)NULL;
            DocInfo.lpszDatatype= (LPSTR) NULL;
            DocInfo.fwType      = 0;

            iRet = StartDocA(hdc, &DocInfo);
            bFixUp = TRUE;
            break;

        case PASSTHROUGH:

            #if (PASSTHROUGH != DEVICEDATA)
                #error PASSTHROUGH != DEVICEDATA
            #endif

            iRet = ExtEscape
                   (
                     hdc,
                     PASSTHROUGH,
                     (int) (*((UNALIGNED USHORT *) pvIn))+sizeof(WORD),
                     pvIn,
                     0,
                     (LPSTR) NULL
                   );
            bFixUp = TRUE;
            break;

        case NEWFRAME:
            if (pldc->fl & LDC_CALL_STARTPAGE)
                StartPage(hdc);

        // If no error occured in EndPage, call StartPage next time.

            if ((iRet = EndPage(hdc)) > 0)
                pldc->fl |= LDC_CALL_STARTPAGE;

            bFixUp = TRUE;
            break;

        case NEXTBAND:
        // Win31 compatibility flags.
        // GACF_MULTIPLEBANDS: Freelance thinks the first full-page band is
        //                     a text-only band.  So it ignores it and waits
        //                     for the next band to print graphics.  We'll
        //                     return the full-page band twice for each page.
        //                     The first band will be ignored while the second
        //                     band really contains graphics to print.
        //                     This flag only affects dotmatrix on win31.
        // GACF_FORCETEXTBAND: World Perfect and Freelance both have assumptions
        //                     on whether a band is text-only or not.  They
        //                     print text and graphics in different bands.
        //                     We'll return two full-page bands for each page.
        //                     One for text and the other for graphics.
        //                     This flag only affects laser jet on win31.

            if (pldc->fl & LDC_NEXTBAND)
            {
                if (GetAppCompatFlags(NULL) & (GACF_FORCETEXTBAND|GACF_MULTIPLEBANDS))
                {
                    if (pldc->fl & LDC_EMPTYBAND)
                    {
                        pldc->fl &= ~LDC_EMPTYBAND;
                    }
                    else
                    {
                        pldc->fl |= LDC_EMPTYBAND;
                        goto FULLPAGEBAND;
                    }
                }

                ((UNALIGNED RECT *)pvOut)->left = ((UNALIGNED RECT *)pvOut)->top =
                ((UNALIGNED RECT *)pvOut)->right = ((UNALIGNED RECT *)pvOut)->bottom = 0;

                pldc->fl &= ~LDC_NEXTBAND;  // Clear NextBand flag.

                if (pldc->fl & LDC_CALL_STARTPAGE)
                    StartPage(hdc);

                if ((iRet = EndPage(hdc)) > 0)
                {
                    pldc->fl |= LDC_CALL_STARTPAGE;

                //
                // Marks application is doing banding by themselves,
                // then EndPage() is called when there is no more band.
                //
                    pldc->fl |= LDC_CALLED_ENDPAGE;
                }

                bFixUp = TRUE;
            }
            else
            {
    FULLPAGEBAND:
                ((UNALIGNED RECT *)pvOut)->left = ((UNALIGNED RECT *)pvOut)->top = 0;
                ((UNALIGNED RECT *)pvOut)->right = GetDeviceCaps(hdc, HORZRES);
                ((UNALIGNED RECT *)pvOut)->bottom = GetDeviceCaps(hdc, VERTRES);

                pldc->fl |= LDC_NEXTBAND;   // Set NextBand flag.
                iRet = 1;
            }
            break;

        default:
            iRet = 0;
            break;
        }

    // Fix up the return values for STARTDOC and PASSTHROUGH so we're
    // win31 compatible.

        if (bFixUp && (iRet < 0))
        {
            if (pldc->fl & LDC_DOC_CANCELLED)
            {
                iRet = SP_APPABORT;
            }
            else
            {
                switch(GetLastError())
                {
                case ERROR_PRINT_CANCELLED:
                    iRet = SP_USERABORT;
                    break;

                case ERROR_NOT_ENOUGH_MEMORY:
                    iRet = SP_OUTOFMEMORY;
                    break;

                case ERROR_DISK_FULL:
                    iRet = SP_OUTOFDISK;
                    break;

                default:
                    iRet = SP_ERROR;
                    break;
                }
            }
        }
    }
    else
    {
        // We don't support this escape on this DC, but CorelDRAW expects
        // some non-random values back anyway. Zero the output buffer to
        // keep it happy.

        if ((iEscape == GETSCALINGFACTOR) && pvOut)
        {
            RtlZeroMemory(pvOut, sizeof(POINT));
        }
    }
    return(iRet);
}

/******************************Public*Routine******************************\
* ExtEscape                                                                *
*                                                                          *
* History:                                                                 *
*  14-Feb-1992 -by- Dave Snipp [DaveSn]                                    *
* Wrote it.                                                                *
\**************************************************************************/

#define BUFSIZE 520


int WINAPI ExtEscape(
    HDC    hdc,         //  Identifies the device context.
    int    iEscape,     //  Specifies the escape function to be performed.
    int    cjInput,     //  Number of bytes of data pointed to by lpInData
    LPCSTR lpInData,    //  Points to the input structure required
    int    cjOutput,    //  Number of bytes of data pointed to by lpOutData
    LPSTR  lpOutData    //  Points to the structure to receive output from
)                       //   this escape.
{
    int iRet = 0;
    int cjIn, cjOut, cjData;
    PLDC pldc;
    XFORM xf;

// We need some extra buffer space for at least one call.  I'm going to
// hard code it here.  The slickest thing would be to have a separate
// routine that knows how to alloc this space out of the memory window,
// but that would be more complex.  I'm rushed.  Sorry.  [chuckwh]

    BYTE jBuffer[BUFSIZE];

// We want to make this escape work just like it does in Windows which means
// that if there is a TrueType font in the DC GDI will compute it otherwise
// we'll pass the escape to the driver.  So we call off to GetETM here because
// it does just that.

    FIXUP_HANDLE(hdc);

    if( iEscape == GETEXTENDEDTEXTMETRICS )
    {
        if( GetETM( hdc, (EXTTEXTMETRIC*) jBuffer ) )
        {
            RtlCopyMemory( lpOutData, jBuffer, MIN(cjOutput,sizeof(EXTTEXTMETRIC)) );
            return(1);
        }
        else
        {
            return(0);
        }
    }
    else if (iEscape == DRAWPATTERNRECT)
    {
        if (GetAppCompatFlags2(VER40) & GACF2_NODRAWPATRECT)
        {
            // GACF_NODRAWPATRECT -
            //
            // Some of application does not work with DrawPatRect escape,
            // so that we behave as we don't support it.
            //
            return (0);
        }

        if (!cjInput)
        {
            //
            // work around 32 bits Excel (with Ofiice 97) bug.
            //
            cjInput = sizeof(DRAWPATRECT);
        }
    }
    else if (iEscape == QUERYESCSUPPORT)
    {
        if (*(ULONG*)lpInData == GETPAIRKERNTABLE)
        {
            // intercept GETPAIRKERNTABLE escape on the client side where all the work is done
            // It is interesting that this "api" works on win95 not only for device fonts but
            // also for engine fonts. Therefore this needs to be outside of
            // the IS_ALTDC_TYPE(hdc) clause below

            return (1);
        }
        else if (*(ULONG*)lpInData == DRAWPATTERNRECT)
        {
            if (GetAppCompatFlags2(VER40) & GACF2_NODRAWPATRECT)
            {
                // GACF_NODRAWPATRECT -
                //
                // Some of application does not work with DrawPatRect escape,
                // so that we behave as we don't support it.
                //
                return (0);
            }
        }
    }
    else if (iEscape == GETPAIRKERNTABLE)
    {
        return GetPairKernTable(hdc, (DWORD)cjOutput, (KERNPAIR *)lpOutData);
    }

// printer specific stuff

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        // don't allow them 16bit metafiles

        if (IS_METADC16_TYPE(hdc))
            return (0);

        DC_PLDC(hdc,pldc,iRet);

        MFD2("ExtEscapeCalled %d\n", iEscape );

        if (pldc->fl & (LDC_DOC_CANCELLED|LDC_SAP_CALLBACK))
        {
            if (pldc->fl & LDC_SAP_CALLBACK)
                vSAPCallback(pldc);

            if (pldc->fl & LDC_DOC_CANCELLED)
                return(0);
        }

        // if it is an output call that requires no return results, better make sure
        // we do a start page.

        if (( iEscape == DOWNLOADFACE ) ||
            ( iEscape == GETFACENAME ) ||
            ( iEscape == POSTSCRIPT_DATA ) ||
            ( iEscape == BEGIN_PATH ) ||
            ( iEscape == END_PATH ) ||
            ( iEscape == CLIP_TO_PATH ) ||
            ( iEscape == PASSTHROUGH ) ||
            ( iEscape == DOWNLOADHEADER ))
        {
            if (pldc->fl & LDC_CALL_STARTPAGE)
                StartPage(hdc);
        }

        if ((pldc->iType == LO_METADC) && (pldc->fl & LDC_META_PRINT))
        {
            // These two escapes should be called *before* StartDoc, any these escape
            // called *after* StartDoc will be failed when EMF is used (see SDK)

            if ((iEscape == POSTSCRIPT_IDENTIFY) || (iEscape == POSTSCRIPT_INJECTION))
            {
                WARNING("GDI32: ExtEscape() PSInjection after StartDoc with EMF, is ignored\n");

                SetLastError(ERROR_INVALID_PARAMETER);
                return (0);
            }

            // These escapes will not be recorded into metafile
            //
            // SETCOPYCOUNT - will be handled in kernel for EMF spooling case.
            //                and this will be recorded in DEVMODE.dmCopies.
            //
            // QUERYSUPPORT - will be handled in driver even EMF spooling case,
            //                since only driver knows which escape support it.
            //                and this is nothing for drawing, so not nessesary
            //                to record it.
            //
            // CHECKJPEGFORMAT & CHECKPNGFORMAT
            //              - query escapes that do not need to be reocorded
            //                into metafile.
            //

            if ((iEscape != SETCOPYCOUNT) && (iEscape != QUERYESCSUPPORT) &&
                (iEscape != CHECKJPEGFORMAT) && (iEscape != CHECKPNGFORMAT))
            {
                BOOL bSetXform = FALSE;

                // Write this escape to metafile.

                //
                // If there's transform set in the hdc by the app
                // at the time of DRAWPATRECT, select identity transform in
                // once the escape is recorded, select back the original transform
                //
                if (GetWorldTransform(hdc, &xf))
                {
                   if ((xf.eM11 != 1.0f) || (xf.eM22 != 1.0f) ||
                           (xf.eM12 != 0.0f) || (xf.eM21 != 0.0f))
                   {
                       bSetXform = TRUE;
                       MF_ModifyWorldTransform(hdc,&xformIdentity,MWT_SET);
                   }
                }

                MF_WriteEscape( hdc, iEscape, cjInput, lpInData, EMR_EXTESCAPE );

                if (bSetXform)
                {
                   MF_ModifyWorldTransform(hdc,&xf,MWT_SET);
                }

                if ((lpOutData == (LPSTR) NULL) || (cjOutput == 0))
                {
                    if ((iEscape == PASSTHROUGH) ||
                        (iEscape == POSTSCRIPT_PASSTHROUGH) ||
                        (iEscape == POSTSCRIPT_DATA))
                    {
                        if ((cjInput < (int)sizeof(WORD)) ||
                            (cjInput < (int)sizeof(WORD) + *((LPWORD) lpInData)))
                        {
                            SetLastError(ERROR_INVALID_PARAMETER);
                            return -1;
                        }

                        cjInput = *((LPWORD) lpInData);
                    }

                    return(MAX(cjInput,1));
                }
            }

            MFD2("ExtEscape goes to gre/driver Escape(%d) with EMF printing\n", iEscape);
        }

        if ((iEscape == DOWNLOADFACE) || (iEscape == GETFACENAME))
        {
            if (iEscape == DOWNLOADFACE)
            {
            // Adjust the buffer for the DOWNLOADFACE case.  Note that lpOutData
            // points at an input word for the mode.

                if ((gpwcANSICharSet == (WCHAR *) NULL) && !bGetANSISetMap())
                {
                    return(0);
                }

                RtlMoveMemory
                (
                    jBuffer + sizeof(WCHAR),
                    (BYTE *) &gpwcANSICharSet[0],
                    256*sizeof(WCHAR)
                );

                if (lpOutData)
                    *(WCHAR *) jBuffer = *(UNALIGNED WORD *) lpOutData;
                else
                    *(WCHAR *) jBuffer = 0;

                cjInput = 257 * sizeof(WCHAR);
                lpInData = (LPCSTR) jBuffer;

                ASSERTGDI(BUFSIZE >= cjInput,"Buffer too small.\n");
            }
        }

        if ((iEscape == POSTSCRIPT_INJECTION) || (iEscape == POSTSCRIPT_IDENTIFY))
        {
            // Remember escape data for EMF spooling case. (only BEFORE StartDoc)

            if (!(pldc->fl & LDC_DOC_STARTED))
            {
                PPS_INJECTION_DATA pPSInjection;
                ULONG cjCellSize;

                if( BROUNDUP_DWORDALIGN_OVERFLOW(
                            (sizeof(PS_INJECTION_DATA)-1)+cjInput) )
                        return 0;

                cjCellSize = 
                    ROUNDUP_DWORDALIGN((sizeof(PS_INJECTION_DATA)-1)+cjInput);

                MFD2("ExtEscape records this Escape(%d) temporary then write EMF later\n",iEscape);

                if ((pPSInjection = LOCALALLOC(cjCellSize)) != NULL)
                {
                    cjCellSize -= offsetof(PS_INJECTION_DATA,EmfData);

                    // Fill up Injection Data.

                    pPSInjection->EmfData.cjSize  = cjCellSize;
                    pPSInjection->EmfData.nEscape = iEscape;
                    pPSInjection->EmfData.cjInput = cjInput;
                    RtlCopyMemory(pPSInjection->EmfData.EscapeData,lpInData,cjInput);

                    // Put this on list.

                    InsertTailList(&(pldc->PSDataList),&(pPSInjection->ListEntry));

                    // Update total data size.

                    pldc->dwSizeOfPSDataToRecord += cjCellSize;
                }
                else
                {
                    WARNING("ExtEscape: Failed on LOCALALLOC for POSTSCRIPT_xxxxx\n");
                    GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return (0);
                }
            }
        }

    // now call the drivers UI portion

        if (pldc->hSpooler)
        {
            DOCEVENT_ESCAPE  docEvent;

            docEvent.iEscape = iEscape;
            docEvent.cjInput = cjInput;
            docEvent.pvInData = (PVOID)lpInData;

            DocumentEventEx(pldc->pUMPD,
                    pldc->hSpooler,
                    hdc,
                    DOCUMENTEVENT_ESCAPE,
                    sizeof(docEvent),
                    (PVOID)&docEvent,
                    cjOutput,
                    (PVOID)lpOutData);
        }
    }

    cjIn  = (lpInData == NULL) ? 0 : cjInput;
    cjOut = (lpOutData == NULL) ? 0 : cjOutput;

    iRet = NtGdiExtEscape(hdc,NULL,0,iEscape,cjIn,(LPSTR)lpInData,cjOut,lpOutData);

    return(iRet);
}

/******************************Public*Routine******************************\
* NamedEscape
*
* History:
*  5-Mar-1996 -by- Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

#define BUFSIZE 520

int WINAPI NamedEscape(
    HDC    hdc,         //  Identifies the device context for EMF spooling
    LPWSTR pwszDriver,  //  Identfies the driver
    int    iEscape,     //  Specifies the escape function to be performed.
    int    cjInput,     //  Number of bytes of data pointed to by lpInData
    LPCSTR lpInData,    //  Points to the input structure required
    int    cjOutput,    //  Number of bytes of data pointed to by lpOutData
    LPSTR  lpOutData    //  Points to the structure to receive output from
)                       //   this escape.
{
    int iRet = 0;
    int cjIn, cjOut, cjData;
    PLDC pldc;

    if(hdc)
    {
        FIXUP_HANDLE(hdc);

    // if we are EMF spooling then we need to record the call here

        if (IS_ALTDC_TYPE(hdc))
        {
            PLDC pldc;

            // don't allow them in 16bit metafiles

            if (IS_METADC16_TYPE(hdc))
              return(0);

            DC_PLDC(hdc,pldc,iRet);

            MFD2("NamedEscapeCalled %d\n", iEscape );

            if (pldc->fl & (LDC_DOC_CANCELLED|LDC_SAP_CALLBACK))
            {
                if (pldc->fl & LDC_SAP_CALLBACK)
                  vSAPCallback(pldc);

                if (pldc->fl & LDC_DOC_CANCELLED)
                  return(0);
            }

            if (pldc->iType == LO_METADC)
            {
                if(!MF_WriteNamedEscape(hdc,
                                        pwszDriver,
                                        iEscape,
                                        cjInput,
                                        lpInData))
                {
                    WARNING("Error metafiling NameEscape\n");
                    return(0);
                }
            }
        }
    }

    cjIn  = (lpInData == NULL) ? 0 : cjInput;
    cjOut = (lpOutData == NULL) ? 0 : cjOutput;

    iRet = NtGdiExtEscape((HDC) 0,
                          pwszDriver,
                          wcslen(pwszDriver),
                          iEscape,cjIn,
                          (LPSTR)lpInData,
                          cjOut,lpOutData);

    return(iRet);
}



/******************************Public*Routine******************************\
* DrawEscape                                                               *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  02-Apr-1992 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

int WINAPI DrawEscape(
    HDC    hdc,         //  Identifies the device context.
    int    iEscape,     //  Specifies the escape function to be performed.
    int    cjIn,        //  Number of bytes of data pointed to by lpIn.
    LPCSTR lpIn         //  Points to the input data.
)
{
    int  iRet = 0;
    int  cjInput;

    FIXUP_HANDLE(hdc);

// printer specific stuff

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        // don't allow them 16bit metafiles

        if (IS_METADC16_TYPE(hdc))
            return(0);

        DC_PLDC(hdc,pldc,iRet);

        MFD2("Calling DrawEscape %d\n", iEscape );

        if( ( pldc->fl & LDC_META_PRINT ) && ( iEscape != QUERYESCSUPPORT ) )
        {
            MF_WriteEscape( hdc, iEscape, cjIn, lpIn, EMR_DRAWESCAPE );
        }
    }

// Compute the buffer size we need.  Since the in and out buffers
// get rounded up to multiples of 4 bytes, we need to simulate that
// here.

    cjInput = (lpIn == NULL) ? 0 : ((cjIn+3)&-4);

    iRet = NtGdiDrawEscape(hdc,iEscape,cjIn,(LPSTR)lpIn);

    return(iRet);
}

/******************************Public*Routine******************************\
* DeviceCapabilitiesExA
*
* This never got implemented.  The spooler suports DeviceCapabilities.
*
* History:
*  01-Aug-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int WINAPI DeviceCapabilitiesExA(
    LPCSTR     pszDriver,
    LPCSTR     pszDevice,
    LPCSTR     pszPort,
    int        iIndex,
    LPCSTR     pb,
    CONST DEVMODEA *pdm)
{
    return(GDI_ERROR);

    pszDriver;
    pszDevice;
    pszPort;
    iIndex;
    pb;
    pdm;
}

/**************************************************************************\
 *
 * New to be implemented Api's for Windows95.
 *
\**************************************************************************/

#if 0
WINGDIAPI int WINAPI GetTextCharsetInfo(
    HDC hdc,
    LPFONTSIGNATURE lpSig,
    DWORD dwFlags)
{
    return NtGdiGetTextCharsetInfo(hdc, lpSig, dwFlags);
}
#endif

WINGDIAPI int WINAPI GetTextCharset(
    HDC hdc)
{
    return NtGdiGetTextCharsetInfo(hdc, NULL, 0);
}



/******************************Public*Routine******************************\
*
* WINGDIAPI  BOOL WINAPI TranslateCharsetInfo(
*
* client side stub
*
* History:
*  06-Jan-1995 -by- Bodin Dresevic [BodinD]
* Wrote it
\**************************************************************************/

// the definition of this variable is in ntgdi\inc\hmgshare.h

CHARSET_ARRAYS



WINGDIAPI  BOOL WINAPI TranslateCharsetInfo(
    DWORD  *lpSrc,
    LPCHARSETINFO lpCs,
    DWORD dwFlags)
{
    UINT    i;
    int     index;
    CHARSETINFO cs;
    BOOL    bRet = 0;

    if (!lpCs)
        return 0;

//
// zero these out, we dont support them here.
//

    cs.fs.fsUsb[0] =
    cs.fs.fsUsb[1] =
    cs.fs.fsUsb[2] =
    cs.fs.fsUsb[3] =
    cs.fs.fsCsb[1] = 0;

    switch (dwFlags )
    {
    case TCI_SRCCHARSET :
        {
            WORD    src ;

            src = LOWORD(PtrToUlong(lpSrc));
            for ( i=0; i<NCHARSETS; i++ )
            {
                if ( charsets[i] == src )
                {
                    cs.ciACP      = codepages[i];
                    cs.ciCharset  = src;
                    cs.fs.fsCsb[0] = fs[i];
                    bRet = 1;
                    break;
                }
            }
        }
        break;

    case TCI_SRCCODEPAGE :
        {
            WORD    src ;

            src = LOWORD(PtrToUlong(lpSrc));

            for ( i=0; i<NCHARSETS; i++ )
            {
                if ( codepages[i] == src )
                {
                    cs.ciACP      = src ;
                    cs.ciCharset  = charsets[i] ;
                    cs.fs.fsCsb[0] = fs[i];
                    bRet = 1;
                    break;
                }
            }
        }
        break;

    case TCI_SRCLOCALE :
        {
        // should only come from USER.  It's used to find the charset of a
        // keyboard layout, and the fonts that it can be used with (fontsigs).
        // It is also used to obtain the fontsignature of the system font.
        // Used in WM_INPUTLANGCHANGE message, and to determine wParam low-bit
        // in WM_INPUTLANGCHANGEREQUEST message.

            LOCALESIGNATURE ls;
            int iRet;

            iRet = GetLocaleInfoW((DWORD)(LOWORD(PtrToUlong(lpSrc))),
                               LOCALE_FONTSIGNATURE,
                               (LPWSTR)&ls,
                               0);

            if (GetLocaleInfoW((DWORD)(LOWORD(PtrToUlong(lpSrc))),
                               LOCALE_FONTSIGNATURE,
                               (LPWSTR)&ls,
                               iRet)
            )
            {
                for ( i=0; i<NCHARSETS; i++ )
                {
                    if (fs[i] == ls.lsCsbDefault[0])
                    {
                        cs.ciACP       = codepages[i];
                        cs.ciCharset   = charsets[i] ;
                        cs.fs.fsCsb[0] = fs[i];                // a single fontsig
                        cs.fs.fsCsb[1] = ls.lsCsbSupported[0]; // mask of fontsigs
                        bRet = 1;
                        break;
                    }
                }
            }
        }
        break;

    case TCI_SRCFONTSIG :
        {
        DWORD src;

        //if(IsBadReadPtr(lpSrc, 8))
        //        return 0;
            try
            {
                if (!(*(lpSrc+1)))
                {
                // we dont recognise ANY of the OEM code pages here!

                    src = *lpSrc;

                    for ( i=0; i<NCHARSETS; i++ )
                    {
                        if ( fs[i] == src )
                        {
                            cs.ciACP      = codepages[i];
                            cs.ciCharset  = charsets[i] ;
                            cs.fs.fsCsb[0] = src;
                            bRet = 1;
                            break;
                        }
                    }
                }
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
            }
        }
        break;

    default:
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        break;
    }

    if (bRet)
    {
        try
        {
            *lpCs = cs; // copy out
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\pal.c ===
/******************************Module*Header*******************************\
* Module Name: pal.c                                                       *
*                                                                          *
* C/S support for palette routines.                                        *
*                                                                          *
* Created: 29-May-1991 14:24:06                                            *
* Author: Eric Kutter [erick]                                              *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


/**************************************************************************\
 * gajFakeHalftone
 *
 * Copy of the pal666 hardcoded halftone palette from Win9x source code
 * (win\core\gdi\palette.asm).  Actually, we're hacking a little so
 * we'll only use the top and bottom 10 entries.
 *
\**************************************************************************/

static const ULONG gaulFakeHalftone[] = {
    0x00000000,   // 0 Sys Black      gray 0
    0x00000080,   // 1 Sys Dk Red
    0x00008000,   // 2 Sys Dk Green
    0x00008080,   // 3 Sys Dk Yellow
    0x00800000,   // 4 Sys Dk Blue
    0x00800080,   // 5 Sys Dk Violet
    0x00808000,   // 6 Sys Dk Cyan
    0x00c0c0c0,   // 7 Sys Lt Grey    gray 192
    0x00c0dcc0,   // 8 Sys 8
    0x00f0caa6,   // 9 Sys 9 (the first 10 are fixed by Windows)

    0x00f0fbff,   // 246 Sys Reserved
    0x00a4a0a0,   // 247 Sys Reserved
    0x00808080,   // 248 Sys Lt Gray  gray 128
    0x000000ff,   // 249 Sys Red
    0x0000ff00,   // 250 Sys Green
    0x0000ffff,   // 251 Sys Yellow
    0x00ff0000,   // 252 Sys Blue
    0x00ff00ff,   // 253 Sys Violet
    0x00ffff00,   // 254 Sys Cyan
    0x00ffffff    // 255 Sys White     gray 255
};

/******************************Public*Routine******************************\
* AnimatePalette                                                           *
* SetPaletteEntries                                                        *
* GetPaletteEntries                                                        *
* GetSystemPaletteEntries                                                  *
* SetDIBColorTable                                                         *
* GetDIBColorTable                                                         *
*                                                                          *
* These entry points just pass the call on to DoPalette.                   *
*                                                                          *
* Warning:                                                                 *
*   The pv field of a palette's LHE is used to determine if a palette      *
*   has been modified since it was last realized.  SetPaletteEntries       *
*   and ResizePalette will increment this field after they have            *
*   modified the palette.  It is only updated for metafiled palettes       *
*                                                                          *
*                                                                          *
* History:                                                                 *
*  Thu 20-Jun-1991 00:46:15 -by- Charles Whitmer [chuckwh]                 *
* Added handle translation.  (And filled in the comment block.)            *
*                                                                          *
*  29-May-1991 -by- Eric Kutter [erick]                                    *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI AnimatePalette
(
    HPALETTE hpal,
    UINT iStart,
    UINT cEntries,
    CONST PALETTEENTRY *pPalEntries
)
{
    FIXUP_HANDLE(hpal);

// Inform the 16-bit metafile if it knows this object.
// This is not recorded by the 32-bit metafiles.

    if (pmetalink16Get(hpal))
        if (!MF16_AnimatePalette(hpal, iStart, cEntries, pPalEntries))
            return(FALSE);

    return
      !!NtGdiDoPalette
        (
          hpal,
          (WORD)iStart,
          (WORD)cEntries,
          (PALETTEENTRY*)pPalEntries,
          I_ANIMATEPALETTE,
          TRUE
        );

}

UINT WINAPI SetPaletteEntries
(
    HPALETTE hpal,
    UINT iStart,
    UINT cEntries,
    CONST PALETTEENTRY *pPalEntries
)
{
    PMETALINK16 pml16;

    FIXUP_HANDLE(hpal);

    // Inform the metafile if it knows this object.

    if (pml16 = pmetalink16Get(hpal))
    {
        if (!MF_SetPaletteEntries(hpal, iStart, cEntries, pPalEntries))
            return(0);

        // Mark the palette as changed (for 16-bit metafile tracking)

        pml16->pv = (PVOID)(((ULONG_PTR)pml16->pv)++);
    }

    return
      NtGdiDoPalette
      (
        hpal,
        (WORD)iStart,
        (WORD)cEntries,
        (PALETTEENTRY*)pPalEntries,
        I_SETPALETTEENTRIES,
        TRUE
      );

}

UINT WINAPI GetPaletteEntries
(
    HPALETTE hpal,
    UINT iStart,
    UINT cEntries,
    LPPALETTEENTRY pPalEntries
)
{
    FIXUP_HANDLE(hpal);

    return
      NtGdiDoPalette
      (
        hpal,
        (WORD)iStart,
        (WORD)cEntries,
        pPalEntries,
        I_GETPALETTEENTRIES,
        FALSE
      );

}

UINT WINAPI GetSystemPaletteEntries
(
    HDC  hdc,
    UINT iStart,
    UINT cEntries,
    LPPALETTEENTRY pPalEntries
)
{
    LONG lRet = 0;

    FIXUP_HANDLE(hdc);

    //
    // There's an app out there that sometimes calls us with a -1
    // and then whines that we overwrote some of its memory.  Win9x clamps
    // this value, so we can too.
    //

    if ((LONG)cEntries < 0)
        return (UINT) lRet;

    //
    // GreGetSystemPaletteEntries will only succeed on palettized devices.
    //

    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
        lRet =
          NtGdiDoPalette
          (
            (HPALETTE) hdc,
            (WORD)iStart,
            (WORD)cEntries,
            pPalEntries,
            I_GETSYSTEMPALETTEENTRIES,
            FALSE
          );
    }
    else
    {
        //
        // Win9x compatibility: Unlike NT, GetSystemPaletteEntries does
        // not fail on non-palettized devices, it returns the halftone
        // palette (hardcoded in win\core\gdi\palette.asm in the
        // Win9x source code).
        //
        // However, Macromedia Directory (which is used by Encarta 99)
        // relies on GetSystemPaletteEntries failing on NT.  Luckily, the
        // only apps found so far that rely on GetSystemPaletteEntries
        // returning the halftone palette on non-palettized devices
        // also ignore the return value.  This makes sense in that any
        // app that *did* check the return value also would likely have
        // code to handle the failure in the first place.
        //
        // So, attemp to satisfy both camps by filling in the return
        // buffer *and* returning failure for this case.
        //

        if (pPalEntries != NULL)
        {
            ULONG aulFake[256];
            UINT uiNumCopy;

            //
            // More cheating: to avoid having to have the whole fake
            // halftone palette taking up space in our binary (even if
            // it is const data), we can get away with just returning
            // the first and last 10 since the apps that use this on
            // non-palettized displays really just want the 20 system
            // colors and will fill in the middle 236 with their own data.
            //
            // Also, it's less code to waste 40 bytes in const data than
            // to fetch the default palette and split it into into the top
            // and bottom halves (not to mention that we don't want the
            // real magic colors in 8, 9, 246, and 247).  This is also
            // the same motivation for creating the aulFake array then
            // copying it into the return buffer.  Not worth the extra code
            // to handle copying directly into return buffer.
            //

            RtlCopyMemory(&aulFake[0], &gaulFakeHalftone[0], 10*sizeof(ULONG));
            RtlCopyMemory(&aulFake[246], &gaulFakeHalftone[10], 10*sizeof(ULONG));
            RtlZeroMemory(&aulFake[10], 236*sizeof(ULONG));

            //
            // Copy requested portion of palette.
            //

            if (iStart < 256)
            {
                uiNumCopy = min((256 - iStart), cEntries);
                RtlCopyMemory(pPalEntries, &aulFake[iStart],
                              uiNumCopy * sizeof(ULONG));
            }

            //
            // Want to return failure, so *do not* set lRet to non-zero.
            //
        }
    }

    return (UINT) lRet;
}

/******************************Public*Routine******************************\
* GetDIBColorTable
*
* Get the color table of the DIB section currently selected into the
* given hdc.  If the surface is not a DIB section, this function
* will fail.
*
* History:
*
*  03-Sep-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

UINT WINAPI GetDIBColorTable
(
    HDC  hdc,
    UINT iStart,
    UINT cEntries,
    RGBQUAD *prgbq
)
{
    FIXUP_HANDLE(hdc);

    if (cEntries == 0)
        return(0);

    return
      NtGdiDoPalette
      (
        (HPALETTE) hdc,
        (WORD)iStart,
        (WORD)cEntries,
        (PALETTEENTRY *)prgbq,
        I_GETDIBCOLORTABLE,
        FALSE
      );
}

/******************************Public*Routine******************************\
* SetDIBColorTable
*
* Set the color table of the DIB section currently selected into the
* given hdc.  If the surface is not a DIB section, this function
* will fail.
*
* History:
*
*  03-Sep-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

UINT WINAPI SetDIBColorTable
(
    HDC  hdc,
    UINT iStart,
    UINT cEntries,
    CONST RGBQUAD *prgbq
)
{
    FIXUP_HANDLE(hdc);

    if (cEntries == 0)
        return(0);

    return( NtGdiDoPalette(
                (HPALETTE) hdc,
                (WORD)iStart,
                (WORD)cEntries,
                (PALETTEENTRY *)prgbq,
                I_SETDIBCOLORTABLE,
                TRUE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\path.c ===
/******************************Module*Header*******************************\
* Module Name: path.c
*
* Client side stubs for graphics path calls.
*
* Created: 13-Sep-1991
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

/******************************Public*Routine******************************\
* AbortPath
*
* Client side stub.
*
* History:
*  20-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI AbortPath(HDC hdc)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_Record(hdc,EMR_ABORTPATH))
        {
            return(bRet);
        }
    }

    return(NtGdiAbortPath(hdc));
}

/******************************Public*Routine******************************\
* BeginPath
*
* Client side stub.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI BeginPath(HDC hdc)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_Record(hdc,EMR_BEGINPATH))
        {
            return(bRet);
        }
    }

    return(NtGdiBeginPath(hdc));

}

/******************************Public*Routine******************************\
* SelectClipPath
*
* Client side stub.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI SelectClipPath(HDC hdc, int iMode)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_SelectClipPath(hdc,iMode))
        {
            return(bRet);
        }
    }

    return(NtGdiSelectClipPath(hdc,iMode));
}

/******************************Public*Routine******************************\
* CloseFigure
*
* Client side stub.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI CloseFigure(HDC hdc)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE (hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_Record(hdc,EMR_CLOSEFIGURE))
        {
            return(bRet);
        }
    }

    return(NtGdiCloseFigure(hdc));

}

/******************************Public*Routine******************************\
* EndPath
*
* Client side stub.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI EndPath(HDC hdc)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_Record(hdc,EMR_ENDPATH))
        {
            return(bRet);
        }
    }


    return(NtGdiEndPath(hdc));

}

/******************************Public*Routine******************************\
* FlattenPath
*
* Client side stub.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI FlattenPath(HDC hdc)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_Record(hdc,EMR_FLATTENPATH))
        {
            return(bRet);
        }
    }


    return(NtGdiFlattenPath(hdc));

}

/******************************Public*Routine******************************\
* StrokeAndFillPath
*
* Client side stub.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI StrokeAndFillPath(HDC hdc)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_BoundRecord(hdc,EMR_STROKEANDFILLPATH))
        {
            return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiStrokeAndFillPath(hdc));

}

/******************************Public*Routine******************************\
* StrokePath
*
* Client side stub.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI StrokePath(HDC hdc)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE (hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_BoundRecord(hdc,EMR_STROKEPATH))
        {
            return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();


    return(NtGdiStrokePath(hdc));

}

/******************************Public*Routine******************************\
* FillPath
*
* Client side stub.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI FillPath(HDC hdc)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE (hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_BoundRecord(hdc,EMR_FILLPATH))
        {
            return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiFillPath(hdc));

}

/******************************Public*Routine******************************\
* WidenPath
*
* Client side stub.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI WidenPath(HDC hdc)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE (hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_Record(hdc,EMR_WIDENPATH))
        {
            return(bRet);
        }
    }

    return(NtGdiWidenPath(hdc));

}

/******************************Public*Routine******************************\
* PathToRegion
*
* Client side stub.
*
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HRGN META WINAPI PathToRegion(HDC hdc)
{
    HRGN hrgn = (HRGN)0;

    FIXUP_HANDLE (hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(hrgn);

        DC_PLDC(hdc,pldc,hrgn);

        // Metafile the call.
        // Note that since PathToRegion returns region in device coordinates, we
        // cannot record it in a metafile which can be played to different devices.
        // Instead, we will treat the returned region the same as the other regions
        // created in other region calls.  However, we still need to discard the
        // path definition in the metafile.

        if ((pldc->iType == LO_METADC) &&
            !MF_Record(hdc,EMR_ABORTPATH))
        {
            return(hrgn);
        }
    }

    hrgn = NtGdiPathToRegion(hdc);

    if (hrgn && MIRRORED_HDC(hdc)) {
        MirrorRgnDC(hdc, hrgn, NULL);
    }        

    return(hrgn);
}

/******************************Public*Routine******************************\
* GetPath
*
* GetPath client side stub.
*
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

int WINAPI GetPath(HDC hdc,LPPOINT apt,LPBYTE aj,int cpt)
{
    FIXUP_HANDLE(hdc);

    // Check to make sure we don't have an unreasonable number of points or bad handle

    if (IS_METADC16_TYPE(hdc))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(-1);
    }

    return(NtGdiGetPath(hdc, apt, aj, cpt));

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\precomp.h ===
/******************************Module*Header*******************************\
* Module Name: precomp.h                                                   *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/

#if defined(_GDIPLUS_)
    #include <gpprefix.h>
#endif    

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <windows.h>
#include <winspool.h>
#include <limits.h>
#include <string.h>
#include <nlsconv.h>
#include <w32gdip.h>
#include <icmpriv.h>

#include "ddrawp.h"
#include "winddi.h"

#include "firewall.h"
#include "ntgdistr.h"
#include "ntgdi.h"

// TMP
#include "xfflags.h"
#include "hmgshare.h"

#include "local.h"
#include "gdiicm.h"
#include "metarec.h"
#include "mfrec16.h"
#include "metadef.h"

#include "font.h"

#include "winfont.h"
#include "..\inc\mapfile.h"

#if defined(_GDIPLUS_)
    #include "usermode.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\proxyport.h ===
#ifndef __PROXYPORT__
#define __PROXYPORT__

typedef KPBYTE SERVERPTR;
typedef KPBYTE CLIENTPTR;

typedef struct _PROXYMSG {
    PORT_MESSAGE    h;
    ULONG           cjIn;
    SERVERPTR       pvIn;
    ULONG           cjOut;
    SERVERPTR       pvOut;
} PROXYMSG, *PPROXYMSG;

typedef struct
{
    UMPDTHDR            umpdthdr;
    KERNEL_PVOID        umpdCookie;
    DWORD               clientPid;
    DWORD               hPrinter32;
} UMPDSIMPLEINPUT, *PUMPDSIMPLEINPUT;

//
// XXXX_UMPD must match the definition in winspool.h.
// The only difference is the pointers are widened.
//
typedef struct _DRIVER_INFO_5W_UMPD {
    DWORD cVersion;
    KLPWSTR pName;
    KLPWSTR pEnvironment;
    KLPWSTR pDriverPath;
    KLPWSTR pDataFile;
    KLPWSTR pConfigFile;
    DWORD   dwDriverAttributes;
    DWORD   dwConfigVersion;
    DWORD   dwDriverVersion;
} DRIVER_INFO_5W_UMPD, *PDRIVER_INFO_5W_UMPD, *LPDRIVER_INFO_5W_UMPD;

typedef struct
{
    KLPWSTR         pDatatype;
    KPBYTE          pDevMode;
    ACCESS_MASK     DesiredAccess;
} PRINTERDEFSW_UMPD, *PPRINTERDEFSW_UMPD;

typedef struct
{
    UMPDTHDR                    umpdthdr;
    DRIVER_INFO_5W_UMPD         driverInfo;
    KLPWSTR                     pPrinterName;
    PRINTERDEFSW_UMPD           defaults;
    DWORD                       clientPid;
    DWORD                       hPrinter32;
} LOADDRIVERINPUT, *PLOADDRIVERINPUT;

typedef struct
{
    UMPDTHDR            umpdthdr;
    KERNEL_PVOID        umpdCookie;
    DWORD               clientPid;
    DWORD               hPrinter32;
    BOOL                bNotifySpooler;
} UNLOADDRIVERINPUT, *PUNLOADDRIVERINPUT;

typedef struct _DOCEVENT_CREATEDCPRE_UMPD
{
    KPBYTE      pszDriver;
    KPBYTE      pszDevice;
    KPBYTE      pdm;
    BOOL        bIC;
} DOCEVENT_CREATEDCPRE_UMPD, *PDOCEVENT_CREATEDCPRE_UMPD;

typedef struct _DOCEVENT_ESCAPE_UMPD
{
    int         iEscape;
    int         cjInput;
    KPBYTE      pvInData;
} DOCEVENT_ESCAPE_UMPD, *PDOCEVENT_ESCAPE_UMPD;

typedef struct
{
    UMPDTHDR            umpdthdr;
    KERNEL_PVOID        umpdCookie;
    DWORD               clientPid;
    DWORD               hPrinter32;
    KHDC                hdc;
    INT                 iEsc;
    ULONG               cjIn;
    KPBYTE              pvIn;
    ULONG               cjOut;
    KPBYTE              pvOut;
    KPBYTE              pdmCopy;
} DOCUMENTEVENTINPUT, *PDOCUMENTEVENTINPUT;


//
// XXXX_UMPD must match the definition in winspool.h.
// The only difference is the pointers are widened.
//
typedef struct _DOC_INFO_3W_UMPD {
    KLPWSTR     pDocName;
    KLPWSTR     pOutputFile;
    KLPWSTR     pDatatype;
    DWORD       dwFlags;
} DOC_INFO_3W_UMPD, *PDOC_INFO_3W_UMPD, *LPDOC_INFO_3W_UMPD;

typedef struct
{
    UMPDTHDR            umpdthdr;
    KERNEL_PVOID        umpdCookie;
    DWORD               clientPid;
    DWORD               hPrinter32;
    DWORD               level;
    DOC_INFO_3W_UMPD    docInfo;
    ULONG               lastError;
} STARTDOCPRINTERWINPUT, *PSTARTDOCPRINTERWINPUT;

//
// XXXX_UMPD must match the definition in wingdi.h.
// The only difference is the pointers are widened.
//
typedef struct _DOCINFOW_UMPD {
    int         cbSize;
    KLPWSTR     lpszDocName;
    KLPWSTR     lpszOutput;
    KLPWSTR     lpszDatatype;
    DWORD       fwType;
} DOCINFOW_UMPD, *LPDOCINFOW_UMPD;

typedef struct
{
    UMPDTHDR        umpdthdr;
    KERNEL_PVOID    umpdCookie;
    DWORD           clientPid;
    DWORD           hPrinter32;
    DOCINFOW_UMPD   docInfo;
    KLPWSTR         lpwstr;
} STARTDOCDLGWINPUT, *PSTARTDOCDLGWINPUT;

//
// XXXX_UMPD must match the definition in winspool.h.
// The only difference is the pointers are widened.
//

typedef struct
{
    UMPDTHDR            umpdthdr;
    KERNEL_PVOID        umpdCookie;
    DWORD               clientPid;
    DWORD               hPrinter32;
    PRINTERDEFSW_UMPD   ptrDef;
} RESETPRINTERWINPUT, *PRESETPRINTERWINPUT;

typedef struct
{
    UMPDTHDR        umpdthdr;
    KERNEL_PVOID    umpdCookie;
    DWORD           clientPid;
    DWORD           hPrinter32;
    DEVMODEW*       pDevMode;
    ULONG           ulQueryMode;
    PVOID           pvProfileData;
    ULONG           cjProfileSize;
    FLONG           flProfileFlag;
    ULONG               lastError;
} QUERYCOLORPROFILEINPUT, *PQUERYCOLORPROFILEINPUT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\poly.c ===
/******************************Module*Header*******************************\
* Module Name: poly.c                                                      *
*                                                                          *
* Chunks large data to the server.                                         *
*                                                                          *
* Created: 30-May-1991 14:22:40                                            *
* Author: Eric Kutter [erick]                                              *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

/******************************Public*Routine******************************\
* PolyPolygon                                                              *
* PolyPolyline                                                             *
* Polygon                                                                  *
* Polyline                                                                 *
* PolyBezier                                                               *
* PolylineTo                                                               *
* PolyBezierTo                                                             *
*                                                                          *
* Output routines that call PolyPolyDraw to do the work.                   *
*                                                                          *
* History:                                                                 *
*  Thu 20-Jun-1991 01:08:40 -by- Charles Whitmer [chuckwh]                 *
* Added metafiling, handle translation, and the attribute cache.           *
*                                                                          *
*  04-Jun-1991 -by- Eric Kutter [erick]                                    *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI PolyPolygon(HDC hdc, CONST POINT *apt, CONST INT *asz, int csz)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_PolyPolygon(hdc, apt, asz, csz));

        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_PolyPoly(hdc, apt, asz, (DWORD) csz,EMR_POLYPOLYGON))
                return(FALSE);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(FALSE);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    return (BOOL)
      NtGdiPolyPolyDraw
      (
        hdc,
        (PPOINT)apt,
        (LPINT)asz,
        csz,
        I_POLYPOLYGON
      );

}

BOOL WINAPI PolyPolyline(HDC hdc, CONST POINT *apt, CONST DWORD *asz, DWORD csz)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(FALSE);

        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC && !MF_PolyPoly(hdc,apt, asz, csz, EMR_POLYPOLYLINE))
            return(FALSE);

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(FALSE);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    return (BOOL)
      NtGdiPolyPolyDraw
      (
        hdc,
        (PPOINT)apt,
        (LPINT)asz,
        csz,
        I_POLYPOLYLINE
      );
}

BOOL WINAPI Polygon(HDC hdc, CONST POINT *apt,int cpt)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsPoly(hdc,(LPPOINT)apt,(INT)cpt,META_POLYGON));

        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_Poly(hdc,apt,cpt,EMR_POLYGON))
                return(FALSE);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(FALSE);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    return (BOOL)
      NtGdiPolyPolyDraw
      (
        hdc,
        (PPOINT)apt,
        &cpt,
        1,
        I_POLYPOLYGON
      );
}

BOOL WINAPI Polyline(HDC hdc, CONST POINT *apt,int cpt)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsPoly(hdc,(LPPOINT)apt,cpt,META_POLYLINE));

        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_Poly(hdc,apt,cpt,EMR_POLYLINE))
                return(FALSE);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(FALSE);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    return (BOOL)
      NtGdiPolyPolyDraw
      (
        hdc,
        (PPOINT)apt,
        &cpt,
        1,
        I_POLYPOLYLINE
      );

}

BOOL WINAPI PolyBezier(HDC hdc, CONST POINT * apt,DWORD cpt)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(FALSE);

        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC && !MF_Poly(hdc,apt,cpt,EMR_POLYBEZIER))
            return(FALSE);

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(FALSE);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    return (BOOL)
      NtGdiPolyPolyDraw
      (
        hdc,
        (PPOINT)apt,
        (LPINT)&cpt,
        1,
        I_POLYBEZIER
      );
}

BOOL WINAPI PolylineTo(HDC hdc, CONST POINT * apt,DWORD cpt)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(FALSE);

        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC && !MF_Poly(hdc,apt,cpt,EMR_POLYLINETO))
            return(FALSE);

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(FALSE);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    return (BOOL)
      NtGdiPolyPolyDraw
      (
        hdc,
        (PPOINT)apt,
        (LPINT)&cpt,
        1,
        I_POLYLINETO
      );

}

BOOL WINAPI PolyBezierTo(HDC hdc, CONST POINT * apt,DWORD cpt)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(FALSE);

        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC && !MF_Poly(hdc,apt,cpt,EMR_POLYBEZIERTO))
            return(FALSE);

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(FALSE);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    return (BOOL)
      NtGdiPolyPolyDraw
      (
        hdc,
        (PPOINT)apt,
        (LPINT)&cpt,
        1,
        I_POLYBEZIERTO
      );
}

/******************************Public*Routine******************************\
* CreatePolygonRgn                                                         *
*                                                                          *
* Client side stub.  Creates a local region handle, calls PolyPolyDraw to  *
* pass the call to the server.                                             *
*                                                                          *
*  Tue 04-Jun-1991 17:39:51 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HRGN WINAPI CreatePolygonRgn
(
    CONST POINT *pptl,
    int        cPoint,
    int        iMode
)
{
    LONG_PTR Mode = iMode;

    return((HRGN)
      NtGdiPolyPolyDraw
      (
        (HDC)Mode,
        (PPOINT)pptl,
        &cPoint,
        1,
        I_POLYPOLYRGN
      ));
}

/******************************Public*Routine******************************\
* CreatePolyPolygonRgn                                                     *
*                                                                          *
* Client side stub.  Creates a local region handle, calls PolyPolyDraw to  *
* pass the call to the server.                                             *
*                                                                          *
*  Tue 04-Jun-1991 17:39:51 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HRGN WINAPI CreatePolyPolygonRgn
(
    CONST POINT *pptl,
    CONST INT   *pc,
    int        cPoly,
    int        iMode
)
{
    LONG_PTR Mode = iMode;

    return((HRGN)
      NtGdiPolyPolyDraw
      (
        (HDC)Mode,
        (PPOINT)pptl,
        (LPINT)pc,
        cPoly,
        I_POLYPOLYRGN
      ));

}

/******************************Public*Routine******************************\
* PolyDraw
*
* The real PolyDraw client side stub.
*
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL WINAPI PolyDraw(HDC hdc, CONST POINT * apt, CONST BYTE * aj, int cpt)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(FALSE);

        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC && !MF_PolyDraw(hdc,apt,aj,cpt))
            return(FALSE);

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(FALSE);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    return((BOOL)NtGdiPolyDraw(hdc,(PPOINT)apt,(PBYTE)aj,cpt));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\region.c ===
/******************************Module*Header*******************************\
* Module Name: region.c
*
*   Client region support
*
* Created: 15-Jun-1995
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

void OrderRects(LPRECT lpR, int nRects)
{
    RECT R;
    int i,j;

//Sort Left to right
    for (i=0; i<nRects; i++){
        for (j=i+1; (j<nRects) && ((lpR+j)->top == (lpR+i)->top); j++){
            if (((lpR+j)->left < (lpR+i)->left)) {
                R = *(lpR+i);
                *(lpR+i) = *(lpR+j);
                *(lpR+j) = R;
            }
        }
    }

}

/******************************Public*Routine******************************\
* MirrorRgnByWidth
*  Mirror a region (hrgn) according a specific width (cx)
*  hrgn  : region to get mirrored.
*  cx    : width used to mirror the region.
*  phrgn : If it is not NULL the hrgn will not be touched and the new mirrored 
             region will be returned in phrgn
*          But if it is NULL the mirrored region will be copied to hrgn.
*
* WORRNING:
*          if phrng is not NULL it is the caller responsibility to free *phrgn latter.
*           
* returns:
*  TRUE  : if the region get mirrored
*  FALSE : otherwise.   
*  See the comment about phrng.
*
\**************************************************************************/
BOOL MirrorRgnByWidth(HRGN hrgn, int cx, HRGN *phrgn)
{
    int        nRects, i, nDataSize;
    HRGN       hrgn2 = NULL;
    RECT       *lpR;
    int        Saveleft;
    RGNDATA    *lpRgnData;
    BOOL       bRet = FALSE;

    nDataSize = GetRegionData(hrgn, 0, NULL);
    if (nDataSize && (lpRgnData = (RGNDATA *)LocalAlloc(0, nDataSize * sizeof(DWORD)))) {
        if (GetRegionData(hrgn, nDataSize, lpRgnData)) {
            nRects       = lpRgnData->rdh.nCount;
            lpR          = (RECT *)lpRgnData->Buffer;

            Saveleft                     = lpRgnData->rdh.rcBound.left;
            lpRgnData->rdh.rcBound.left  = cx - lpRgnData->rdh.rcBound.right;
            lpRgnData->rdh.rcBound.right = cx - Saveleft;


            for (i=0; i<nRects; i++){
                Saveleft   = lpR->left;
                lpR->left  = cx - lpR->right;
                lpR->right = cx - Saveleft;

                lpR++;
            }

            OrderRects((RECT *)lpRgnData->Buffer, nRects);
            hrgn2 = ExtCreateRegion(NULL, nDataSize, lpRgnData);
            if (hrgn2) {
                if (phrgn == NULL) {
                    CombineRgn(hrgn, hrgn2, NULL, RGN_COPY);
                    DeleteObject((HGDIOBJ)hrgn2);
                } else {
                    *phrgn = hrgn2;
                }

                bRet = TRUE;
            }
        }

        //Free mem.
        LocalFree(lpRgnData);
    }
    return bRet;
}

BOOL
WINAPI
MirrorRgn(HWND hwnd, HRGN hrgn)
{
    RECT       rc;

    GetWindowRect(hwnd, &rc);
    rc.right -= rc.left;
    return MirrorRgnByWidth(hrgn, rc.right, NULL);
}

BOOL
MirrorRgnDC(HDC hdc, HRGN hrgn, HRGN *phrgn)
{
    FIXUP_HANDLE(hdc);
    if(!IS_ALTDC_TYPE(hdc))
    {
        PDC_ATTR pdcattr;
        PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

        if (pdcattr) {
            return MirrorRgnByWidth(hrgn, NtGdiGetDeviceWidth(hdc), phrgn);
        }
    }
    return FALSE;
}

/******************************Public*Routine******************************\
* iRectRelation
*
* returns:
*   CONTAINS where  prcl1 contains prcl2
*   CONTAINED where prcl1 contained by prcl2
*   0 - otherwise
*
* History:
*  19-Nov-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
iRectRelation(
    PRECTL prcl1,
    PRECTL prcl2
    )
{
    int iRet = 0;

    if ((prcl1->left   <= prcl2->left)  &&
        (prcl1->right  >= prcl2->right) &&
        (prcl1->top    <= prcl2->top)   &&
        (prcl1->bottom >= prcl2->bottom))
    {
        iRet = CONTAINS;
    }
    else if (
        (prcl2->left   <= prcl1->left)  &&
        (prcl2->right  >= prcl1->right) &&
        (prcl2->top    <= prcl1->top)   &&
        (prcl2->bottom >= prcl1->bottom))
    {
        iRet = CONTAINED;
    }
    else if (
        (prcl1->left   >= prcl2->right)  ||
        (prcl1->right  <= prcl2->left)   ||
        (prcl1->top    >= prcl2->bottom) ||
        (prcl1->bottom <= prcl2->top))
    {
        iRet = DISJOINT;
    }
    return(iRet);
}

/******************************Public*Routine******************************\
*
*  CreateRectRgn gets an hrgn with user-mode PRGNATTR pointer and
*  sets the type to SIMPLEREGION.
*
* Arguments:
*
*  x1
*  y1
*  x2
*  y2
*
* Return Value:
*
*  HRGN or NULL
*
* History:
*
*    15-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define MIN_REGION_COORD    ((LONG) 0xF8000000)
#define MAX_REGION_COORD    ((LONG) 0x07FFFFFF)

HRGN
WINAPI
CreateRectRgn(
    int x1,
    int y1,
    int x2,
    int y2
    )
{
    //
    // get a region handle, allocate memory for the
    // region and associate handle with memory
    //

    PRGNATTR prRegion;
    HRGN hrgn;

    //
    // rectangle must be ordered
    //

    #if NOREORDER_RGN

        if ((x1 > x2) || (y1 > y2))
        {
            WARNING("CreateRectRgn called with badly ordered region");

            x1 = 0;
            x2 = 0;
            y1 = 0;
            y2 = 0;
        }

    #else

        if (x1 > x2)
        {
            int t = x1;
            x1 = x2;
            x2 = t;
        }

        if (y1 > y2)
        {
            int t = y1;
            y1 = y2;
            y2 = t;
        }

    #endif

    //
    // make sure ordered coordinates are legal
    //

    if ((x1 < MIN_REGION_COORD) ||
        (y1 < MIN_REGION_COORD) ||
        (x2 > MAX_REGION_COORD) ||
        (y2 > MAX_REGION_COORD))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return((HRGN) 0);
    }

    //
    // get a handle for the new region
    //

    hrgn = (HRGN)hGetPEBHandle(RegionHandle,0);

    if (hrgn == NULL)
    {
        hrgn = NtGdiCreateRectRgn(0,0,1,1);
    }

    PSHARED_GET_VALIDATE(prRegion,hrgn,RGN_TYPE);

    if (prRegion)
    {
        if ((x1 == x2) || (y1 == y2))
        {
            prRegion->Flags = NULLREGION;

            prRegion->Rect.left   = 0;
            prRegion->Rect.top    = 0;
            prRegion->Rect.right  = 0;
            prRegion->Rect.bottom = 0;
        }
        else
        {
            prRegion->Flags = SIMPLEREGION;

            //
            // assign region rectangle
            //

            prRegion->Rect.left   = x1;
            prRegion->Rect.top    = y1;
            prRegion->Rect.right  = x2;
            prRegion->Rect.bottom = y2;
        }

        //
        // mark user-mode region as valid, not cached
        //

        prRegion->AttrFlags = ATTR_RGN_VALID | ATTR_RGN_DIRTY;
    }
    else
    {
        if (hrgn != NULL)
        {
            WARNING("Shared hrgn handle has no valid PRGNATTR");
            DeleteRegion(hrgn);
            hrgn = NULL;
        }
    }

    return(hrgn);
}

/******************************Public*Routine******************************\
* CreateRectRgnIndirect                                                    *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Tue 04-Jun-1991 16:58:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HRGN WINAPI CreateRectRgnIndirect(CONST RECT *prcl)
{
    return
      CreateRectRgn
      (
        prcl->left,
        prcl->top,
        prcl->right,
        prcl->bottom
      );
}

/******************************Public*Routine******************************\
*
*   The PtInRegion function determines whether the specified point is
*   inside the specified region.
*
* Arguments:
*
*   hrgn - app region handle
*   x    - point x
*   y    - point y
*
* Return Value:
*
*   If the specified point is in the region, the return value is TRUE.
*   If the function fails, the return value is FALSE.
*
* History:
*
*    21-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
WINAPI
PtInRegion(
    HRGN hrgn,
    int x,
    int y
    )
{
    BOOL  bRet = FALSE;
    BOOL  bUserMode = FALSE;
    PRECTL prcl;
    PRGNATTR prRegion;

    FIXUP_HANDLE(hrgn);

    PSHARED_GET_VALIDATE(prRegion,hrgn,RGN_TYPE);

    if (prRegion != NULL)
    {
        if (prRegion->Flags == NULLREGION)
        {
            bRet      = FALSE;
            bUserMode = TRUE;
        }
        else if (prRegion->Flags == SIMPLEREGION)
        {
            prcl = &prRegion->Rect;

            if ((x >= prcl->left) && (x < prcl->right) &&
                (y >= prcl->top)  && (y < prcl->bottom))
            {
                bRet = TRUE;
            }

            bUserMode = TRUE;
        }
    }

    if (!bUserMode)
    {
        bRet = NtGdiPtInRegion(hrgn,x,y);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
*
* The RectInRegion function determines whether any part of the specified
* rectangle is within the boundaries of a region.
*
* Arguments:
*
*   hrgn - app region handle
*   prcl - app rectangle
*
* Return Value:
*
*   If any part of the specified rectangle lies within the boundaries
*   of the region, the return value is TRUE.
*
*   If the function fails, the return value is FALSE.
*
* History:
*
*    21-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
WINAPI
RectInRegion(
    HRGN hrgn,
    CONST RECT *prcl
    )
{
    PRGNATTR prRegion;
    BOOL  bRet = FALSE;
    RECTL TempRect;
    LONG  iRelation;
    BOOL  bUserMode = FALSE;

    FIXUP_HANDLE(hrgn);

    PSHARED_GET_VALIDATE(prRegion,hrgn,RGN_TYPE);

    if (prRegion != NULL)
    {
        if (prRegion->Flags == NULLREGION)
        {
            bRet      = FALSE;
            bUserMode = TRUE;
        }
        else if (prRegion->Flags == SIMPLEREGION)
        {
            TempRect = *((PRECTL)prcl);
            ORDER_PRECTL((&TempRect));

            iRelation = iRectRelation(&prRegion->Rect,&TempRect);

            if (iRelation != DISJOINT)
            {
                bRet = TRUE;
            }

            bUserMode = TRUE;
        }
    }

    if (!bUserMode)
    {
        bRet = NtGdiRectInRegion(hrgn, (PRECT)prcl);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
*
* The CombineRgn function combines two regions and stores the result in
* a third region. The two regions are combined according to the specified
* mode.
*
* Arguments:
*
*   hrgnDst  -   destination region
*   hrgnSrc1 -   source region
*   hrgnSrc2 -   source region
*   iMode    -   destination region
*
* Return Value:
*
*   The resulting type of region or ERROR
*
* History:
*
*    21-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/


int
WINAPI
CombineRgn(
    HRGN hrgnDst,
    HRGN hrgnSrc1,
    HRGN hrgnSrc2,
    int  iMode
    )
{

    LONG ResultComplexity = COMPLEXREGION;
    int  iRet             = ERROR;

    //
    // Check if this operation can be completed in user-mode.
    // hrgnDst must have a user mode RGNATTR. hrgnSrc1 must
    // also have a user mode RGNATTR. If iMode is not RGN_COPY
    // then hrgnSrc2 must have a user mode RGNATTR except for certain
    // combinations.
    //

    PRGNATTR    prRegionDst;
    PRGNATTR    prRegionSrc1;
    PRGNATTR    prRegionSrc2;
    PRECTL      prclRes;
    PRECTL      prclSrc1;
    PRECTL      prclSrc2;
    LONG        ComplexSrc1;
    LONG        ComplexSrc2;

    FIXUP_HANDLE(hrgnDst);
    FIXUP_HANDLE(hrgnSrc1);
    FIXUP_HANDLEZ(hrgnSrc2);

    PSHARED_GET_VALIDATE(prRegionDst,hrgnDst,RGN_TYPE);
    PSHARED_GET_VALIDATE(prRegionSrc1,hrgnSrc1,RGN_TYPE);

    if ((prRegionDst != (PRGNATTR)NULL) &&
        (prRegionSrc1 != (PRGNATTR)NULL))
    {

        //
        // region Src1 must me NULL or SIMPLE for current
        // user-mode optimizations. If Rect is the region
        // bounding box, then it will be possible for
        // some combinations with regionC to become
        // SIMPLE or NULL.
        //

        prclSrc1    = &prRegionSrc1->Rect;
        ComplexSrc1 = prRegionSrc1->Flags;

        if (ComplexSrc1 > SIMPLEREGION)
        {
            goto CombineRgnKernelMode;
        }

        if (iMode == RGN_COPY)
        {
            prclRes = prclSrc1;
            ResultComplexity = ComplexSrc1;
        }
        else
        {
            LONG iRelation;

            //
            // validate regionSrc2
            //

            PSHARED_GET_VALIDATE(prRegionSrc2,hrgnSrc2,RGN_TYPE);

            if (
                 (prRegionSrc2 == (PRGNATTR)NULL) ||
                 (prRegionSrc2->Flags > SIMPLEREGION)
               )
            {
                goto CombineRgnKernelMode;
            }

            prclSrc2    = &prRegionSrc2->Rect;
            ComplexSrc2 = prRegionSrc2->Flags;

            switch (iMode)
            {
            case RGN_AND:

                //
                // Creates the intersection of the two
                // combined regions.
                //

                if ((ComplexSrc1 == NULLREGION) ||
                    (ComplexSrc2 == NULLREGION))
                {
                    //
                    // intersection with NULL is NULL
                    //

                    ResultComplexity = NULLREGION;
                }
                else
                {
                    iRelation = iRectRelation(prclSrc1,prclSrc2);

                    if (iRelation == DISJOINT)
                    {
                        ResultComplexity = NULLREGION;
                    }
                    else if (iRelation == CONTAINED)
                    {
                        //
                        // Src1 is contained in Src2
                        //

                        ResultComplexity = SIMPLEREGION;
                        prclRes = prclSrc1;
                    }
                    else if (iRelation == CONTAINS)
                    {
                        //
                        // Src1 is contains Src2
                        //

                        ResultComplexity = SIMPLEREGION;
                        prclRes = prclSrc2;
                    }
                }

                break;

            case RGN_OR:
            case RGN_XOR:

                //
                // RGN_OR:  Creates the union of two combined regions.
                // RGN_XOR:     Creates the union of two combined regions
                //            except for any overlapping areas.
                //


                if (ComplexSrc1 == NULLREGION)
                {
                    if (ComplexSrc2 == NULLREGION)
                    {
                        ResultComplexity = NULLREGION;
                    }
                    else
                    {
                        ResultComplexity = SIMPLEREGION;
                        prclRes = prclSrc2;
                    }
                }
                else if (ComplexSrc2 == NULLREGION)
                {
                    ResultComplexity = SIMPLEREGION;
                    prclRes = prclSrc1;
                }
                else if (iMode == RGN_OR)
                {
                    iRelation = iRectRelation(prclSrc1,prclSrc2);

                    if (iRelation == CONTAINED)
                    {
                        //
                        // Src1 contained in Src2
                        //

                        ResultComplexity = SIMPLEREGION;
                        prclRes = prclSrc2;
                    }
                    else if (iRelation == CONTAINS)
                    {
                        //
                        // Src1 contains Src2
                        //

                        ResultComplexity = SIMPLEREGION;
                        prclRes = prclSrc1;
                    }
                }

                break;

            case RGN_DIFF:

                //
                // Combines the parts of hrgnSrc1 that are not
                // part of hrgnSrc2.
                //

                if (ComplexSrc1 == NULLREGION)
                {
                    ResultComplexity = NULLREGION;
                }
                else if (ComplexSrc2 == NULLREGION)
                {
                    ResultComplexity = SIMPLEREGION;
                    prclRes = prclSrc1;
                }
                else
                {
                    iRelation = iRectRelation(prclSrc1,prclSrc2);

                    if (iRelation == DISJOINT)
                    {
                        //
                        // don't intersect so don't subtract anything
                        //

                        ResultComplexity = SIMPLEREGION;
                        prclRes  = prclSrc1;
                    }
                    else if (iRelation == CONTAINED)
                    {
                        ResultComplexity = NULLREGION;
                    }
                }

                break;
            }
        }

        //
        // try to combine
        //

        if (ResultComplexity == NULLREGION)
        {
            if (SetRectRgn(hrgnDst,0,0,0,0))
            {
               iRet = NULLREGION;
            }
        }
        else if (ResultComplexity == SIMPLEREGION)
        {
            if (SetRectRgn(hrgnDst,
                           prclRes->left,
                           prclRes->top,
                           prclRes->right,
                           prclRes->bottom))
            {
                iRet = SIMPLEREGION;
            }
        }

    }

    if (ResultComplexity != COMPLEXREGION)
    {
        prRegionDst->AttrFlags |= ATTR_RGN_DIRTY;
    }

CombineRgnKernelMode:

    if (ResultComplexity == COMPLEXREGION)
    {
        iRet = NtGdiCombineRgn(hrgnDst,hrgnSrc1,hrgnSrc2,iMode);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
*
* OffsetRgn checks for user-mode region data, if it exits the the
* rectregio is offset, otherwise the kernel is called
*
* Arguments:
*
*   hrgn - app region handle
*   x    - offset in x
*   y    - offset in y
*
* Return Value:
*
*
*
* History:
*
*    21-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

int
WINAPI
OffsetRgn(
    HRGN hrgn,
    int x,
    int y
    )
{
    int  iRet;
    BOOL bClientRegion = FALSE;

    PRGNATTR prRegion;

    FIXUP_HANDLE(hrgn);

    PSHARED_GET_VALIDATE(prRegion,hrgn,RGN_TYPE);

    if (prRegion != NULL)
    {
        iRet = prRegion->Flags;

        if (iRet == NULLREGION)
        {
            bClientRegion = TRUE;
        }
        else if (iRet == SIMPLEREGION)
        {
            RECTL rcl     = prRegion->Rect;

            bClientRegion = TRUE;

            //
            // try to offset the region, check for overflow
            //

            if ( !((rcl.left >= rcl.right) ||
                   (rcl.top >= rcl.bottom)))
            {
                rcl.left   += x;
                rcl.top    += y;
                rcl.right  += x;
                rcl.bottom += y;

                if (VALID_SCRRC(rcl))
                {
                    prRegion->Rect = rcl;
                    prRegion->AttrFlags |= ATTR_RGN_DIRTY;
                }
                else
                {
                    //
                    // over/underflow
                    //

                    iRet = ERROR;
                }
            }
        }
    }

    if (!bClientRegion)
    {
        iRet = NtGdiOffsetRgn(hrgn,x,y);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
*
* GetRgnBox tries to return user-mode rectregion data, otherwies
* make kernel mode transition to get region data.
*
* Arguments:
*
*    hrgn   - app region handle
*    prcl   - app rect pointer
*
* Return Value:
*
*   region complexity, if the hrgn parameter does not identify a
*   valid region, the return value is zero.
*
* History:
*
*    21-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

int
WINAPI
GetRgnBox(
    HRGN hrgn,
    LPRECT prcl
    )
{
    int  iRet;
    BOOL bClientRegion = FALSE;

    //
    // check for user-mode region data
    //

    PRGNATTR prRegion;

    FIXUP_HANDLE(hrgn);

    PSHARED_GET_VALIDATE(prRegion,hrgn,RGN_TYPE);

    if (prRegion != NULL)
    {
        iRet = prRegion->Flags;

        if (iRet == NULLREGION)
        {
            bClientRegion = TRUE;
            prcl->left    = 0;
            prcl->top     = 0;
            prcl->right   = 0;
            prcl->bottom  = 0;
        }
        else if (iRet == SIMPLEREGION)
        {
            bClientRegion = TRUE;
            prcl->left    = prRegion->Rect.left;
            prcl->top     = prRegion->Rect.top;
            prcl->right   = prRegion->Rect.right;
            prcl->bottom  = prRegion->Rect.bottom;
        }
    }

    if (!bClientRegion)
    {
        iRet = NtGdiGetRgnBox(hrgn, prcl);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* PtVisible                                                                *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Thu 06-Jun-1991 00:58:46 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL
WINAPI
PtVisible(
    HDC hdc,
    int x,
    int y
    )
{
    FIXUP_HANDLE(hdc);

    return(NtGdiPtVisible(hdc,x,y));
}

/******************************Public*Routine******************************\
* RectVisible                                                              *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Thu 06-Jun-1991 00:58:46 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL
WINAPI
RectVisible(
    HDC hdc,
    CONST RECT *prcl
    )
{
    FIXUP_HANDLE(hdc);

    return(NtGdiRectVisible(hdc,(LPRECT)prcl));
}

/******************************Public*Routine******************************\
*
* SetRectRgn checks for a user-mode portion of the region. If the
* User-mode data is valid, the region is set to rect locally, otherwise
* a kernel mode call is made to set the region
*
* Arguments:
*
*   hrgn         - app region handle
*   x1,y1,x2,y2  - app region data
*
* Return Value:
*
*   BOOL status
*
\**************************************************************************/

BOOL
WINAPI
SetRectRgn(
    HRGN hrgn,
    int x1,
    int y1,
    int x2,
    int y2
    )
{
    BOOL bStatus;
    PRGNATTR prRegion;

    //
    // if hrgn has a user-mode rectregion, then set
    //

    FIXUP_HANDLE(hrgn);

    PSHARED_GET_VALIDATE(prRegion,hrgn,RGN_TYPE);

    if (prRegion != NULL)
    {
        PRECTL prcl = &prRegion->Rect;

        if ((x1 == x2) || (y1 == y2))
        {
            prRegion->Flags = NULLREGION;

            prcl->left   = 0;
            prcl->top    = 0;
            prcl->right  = 0;
            prcl->bottom = 0;
        }
        else
        {
            //
            // assign and order rectangle
            //


            prcl->left   = x1;
            prcl->top    = y1;
            prcl->right  = x2;
            prcl->bottom = y2;

            ORDER_PRECTL(prcl);

            //
            // set region flag
            //

            prRegion->Flags = SIMPLEREGION;
        }
        prRegion->AttrFlags |= ATTR_RGN_DIRTY;

        bStatus = TRUE;
    }
    else
    {
        bStatus = NtGdiSetRectRgn(hrgn,x1,y1,x2,y2);
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* GetRandomRgn
*
* Client side stub.
*
*  10-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

int APIENTRY GetRandomRgn(HDC hdc,HRGN hrgn,int iNum)
{
    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hrgn);

    return(NtGdiGetRandomRgn(hdc,hrgn,iNum));

}

/******************************Public*Routine******************************\
* GetClipRgn                                                               *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Sat 08-Jun-1991 17:38:18 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

int WINAPI GetClipRgn(HDC hdc,HRGN hrgn)
{
    BOOL bRet;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hrgn);

    bRet = NtGdiGetRandomRgn(hdc, hrgn, 1);

    if (hrgn && MIRRORED_HDC(hdc)) {
        MirrorRgnDC(hdc, hrgn, NULL);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GetRegionData
*
* Download a region from the server
*
* History:
*  29-Oct-1991 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
GetRegionData(
    HRGN      hrgn,
    DWORD     nCount,
    LPRGNDATA lpRgnData
    )
{
    DWORD   iRet;

    FIXUP_HANDLE(hrgn);

    //
    // If this is just an inquiry, pass over dummy parameters.
    //

    if (lpRgnData == (LPRGNDATA) NULL)
    {
        nCount = 0;
    }

    return(NtGdiGetRegionData(hrgn,nCount,lpRgnData));
}

/******************************Public*Routine******************************\
*
* Try to cache regions with user-mode rectregion defined
*
* Arguments:
*
*    h - region handle
*
* Return Value:
*
*   BOOL
*
* History:
*
*    21-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
DeleteRegion(
    HRGN hRgn
    )
{
    PRGNATTR pRgnattr = NULL;
    BOOL     bRet = FALSE;

    BEGIN_BATCH(BatchTypeDeleteRegion,BATCHDELETEREGION);

    PSHARED_GET_VALIDATE(pRgnattr,hRgn,RGN_TYPE);

        if (pRgnattr)
        {
            pBatch->hregion = hRgn;
            bRet = TRUE;
        }
        else
        {
            goto UNBATCHED_COMMAND;
        }

    COMPLETE_BATCH_COMMAND();

UNBATCHED_COMMAND:

    //
    // All other cases
    //

    if (!bRet)
    {
        bRet = NtGdiDeleteObjectApp(hRgn);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SelectClipRgn
*
* Client side stub.
*
* History:
*  01-Nov-1991 12:53:47 -by- Donald Sidoroff [donalds]
* Now just call ExtSelectClipRgn
\**************************************************************************/

int META WINAPI SelectClipRgn(HDC hdc,HRGN hrgn)
{
    return(ExtSelectClipRgn(hdc, hrgn, RGN_COPY));
}

/******************************Public*Routine******************************\
*
*   The ExtSelectClipRgn function combines the specified region with the
*   current clipping region by using the specified mode.
*
* Arguments:
*
*   hdc   - app DC handle
*   hrgn  - app region handle
*   iMode - Select mode
*
* Return Value:
*
*   If the function succeeds, the return value specifies the new clipping
*   region's complexity and can be any one of the following values:
*
*   Value           Meaning
*   NULLREGION      Region is empty.
*   SIMPLEREGION    Region is a single rectangle.
*   COMPLEXREGION   Region is more than one rectangle.
*   ERROR           An error occurred
*
* History:
*
*    21-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

int
META
WINAPI
ExtSelectClipRgn(
    HDC hdc,
    HRGN hrgn,
    int iMode
    )
{
    int iRet = RGN_ERROR;
    HRGN hrgnMirror = NULL;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLEZ(hrgn);

    //
    // Check Metafile
    //

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
        {
            return(MF16_SelectClipRgn(hdc,hrgn,iMode));
        }

        DC_PLDC(hdc,pldc,iRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_ExtSelectClipRgn(hdc,hrgn,iMode))
            {
                return(iRet);
            }
        }
    }

    //
    // Attempt to batch ExtSelectClipRgn:
    //
    //  The DC_ATTR structure has a copy of the current vis region
    //  bounding rectangle, and the handle table has a flag indicating
    //  whether this region is valid.
    //
    //  Calls can be batched when the iMode is RGN_COPY and either
    //  hrgn is NULL, or hrgn complexity is SIMPLE. (and the DC is not
    //  a DIBSECTION DC)
    //
    //
    //  FUTURE PERF:
    //
    //  A check is made to determine if the region being selected
    //  is the same as the last selected region. In this case, only the
    //  correct return value needs to be calculated, no region changes
    //  are needed.
    //
    //
    if (hrgn && MIRRORED_HDC(hdc)) {
        if (MirrorRgnDC(hdc, hrgn, &hrgnMirror) && hrgnMirror) {
            hrgn = hrgnMirror;
        }
    }

    if (iMode == RGN_COPY)
    {
        //
        // validate DC
        //

        BOOL        bBatch = FALSE;
        PRGNATTR    prRegion = NULL;
        PDC_ATTR    pdca;
        PENTRY      pDCEntry;

        PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

        //
        // check if call can be batched. DC must be valid,non-dibsection
        // DC and there must be room on the batch and same batch DC
        //

        BEGIN_BATCH_HDC(hdc,pdca,BatchTypeSelectClip,BATCHSELECTCLIP);

            pDCEntry = &pGdiSharedHandleTable[HANDLE_TO_INDEX(hdc)];
            ASSERTGDI(pDCEntry,"pDCEntry must be valid when pdcattr is valid");

            if (hrgn == NULL)
            {
                //
                // deleting the clip region, so the return complexity
                // will be the vis rgn complexity. Just batch the call.
                //

                if (!(pDCEntry->Flags & HMGR_ENTRY_INVALID_VIS))
                {
                    bBatch = TRUE;
                    iRet   = pdca->VisRectRegion.Flags;
                }
            }
            else
            {
                PSHARED_GET_VALIDATE(prRegion,hrgn,RGN_TYPE);

                //
                // pDCEntry must be valid because pdcattr is valid.
                // In order to batch, the user-mode RectRegion must
                // be valid and the complexity must be simple
                //

                if (
                     (prRegion)                                &&
                     (prRegion->Flags == SIMPLEREGION)         &&
                     (!(prRegion->AttrFlags & ATTR_CACHED))
                      &&
                      !(pDCEntry->Flags & HMGR_ENTRY_INVALID_VIS)
                   )
                {
                    //
                    // Batch the call.
                    //

                    bBatch = TRUE;

                    //
                    // if the new clip region intersects the DC vis region, the
                    // return value is SIMPLEREGION, otherwise it is NULLREGION
                    //

                    iRet = SIMPLEREGION;

                    if (
                        (pdca->VisRectRegion.Rect.left   >= prRegion->Rect.right)  ||
                        (pdca->VisRectRegion.Rect.top    >= prRegion->Rect.bottom) ||
                        (pdca->VisRectRegion.Rect.right  <= prRegion->Rect.left)   ||
                        (pdca->VisRectRegion.Rect.bottom <= prRegion->Rect.top)
                       )
                    {
                        iRet = NULLREGION;
                    }

                }
            }

            //
            // if the call is to be batched, add to the batch
            // and return
            //

            if (!bBatch)
            {
                goto UNBATCHED_COMMAND;
            }

            if (hrgn == NULL)
            {
                iMode |= REGION_NULL_HRGN;
            }
            else
            {
                pBatch->rclClip.left   = prRegion->Rect.left;
                pBatch->rclClip.top    = prRegion->Rect.top;
                pBatch->rclClip.right  = prRegion->Rect.right;
                pBatch->rclClip.bottom = prRegion->Rect.bottom;
            }

            pBatch->iMode          = iMode;

        COMPLETE_BATCH_COMMAND();

        goto BATCHED_COMMAND;
    }

    //
    // call kernel on fall-through and error cases
    //

UNBATCHED_COMMAND:

    iRet = NtGdiExtSelectClipRgn(hdc,hrgn,iMode);

BATCHED_COMMAND:
    if (hrgnMirror) {
        DeleteObject((HGDIOBJ)hrgnMirror);
    }
    return(iRet);
}

/******************************Public*Routine******************************\
* ExcludeClipRect                                                          *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

int
META WINAPI
ExcludeClipRect(
    HDC hdc,
    int x1,
    int y1,
    int x2,
    int y2
    )
{
    int  iRet = RGN_ERROR;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParms5(hdc,x1,y1,x2,y2,META_EXCLUDECLIPRECT));

        DC_PLDC(hdc,pldc,iRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_AnyClipRect(hdc,x1,y1,x2,y2,EMR_EXCLUDECLIPRECT))
                return(iRet);
        }
    }

    return(NtGdiExcludeClipRect(hdc,x1,y1,x2,y2));

}

/******************************Public*Routine******************************\
* IntersectClipRect                                                        *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

int
META WINAPI
IntersectClipRect(
    HDC hdc,
    int x1,
    int y1,
    int x2,
    int y2
    )
{
    int  iRet = RGN_ERROR;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParms5(hdc,x1,y1,x2,y2,META_INTERSECTCLIPRECT));

        DC_PLDC(hdc,pldc,iRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_AnyClipRect(hdc,x1,y1,x2,y2,EMR_INTERSECTCLIPRECT))
                return(iRet);
        }
    }

    return(NtGdiIntersectClipRect(hdc,x1,y1,x2,y2));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\script.c ===
/******************************Module*Header*******************************\
* Module Name: script.c
*
* (Brief description)
*
* Created: 13-Mar-1992 09:57:12
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
* (General description of its use)
*
* Dependencies:
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

/******************************Member*Function*****************************\
* GdiPlayScript()
*
* History:
*  13-Mar-1992 Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL GdiPlayScript(
    PULONG pulScript,
    ULONG  cjScript,
    PULONG pulEnv,
    ULONG  cjEnv,
    PULONG pulOutput,
    ULONG  cjOutput,
    ULONG  cLimit)
{
    pulScript;
    cjScript;
    pulEnv;
    cjEnv;
    pulOutput;
    cjOutput;
    cLimit;

    return(FALSE);
}

/******************************Public*Routine******************************\
* OpenRemoteGdi()
*
* History:
*  13-Mar-1992 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL GdiPlayDCScript(
    HDC    hdc,
    PULONG pulScript,
    ULONG  cjScript,
    PULONG pulOutput,
    ULONG  cjOutput,
    ULONG  cLimit)
{
    hdc;
    pulScript;
    cjScript;
    pulOutput;
    cjOutput;
    cLimit;

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\print.c ===
/******************************Module*Header*******************************\
* Module Name: print.c
*
* Created: 10-Feb-1995 07:42:16
* Author:  Gerrit van Wingerden [gerritv]
*
* Copyright (c) 1993-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "glsup.h"

#if DBG
int gerritv = 0;
#endif

#if DBG
BOOL gbDownloadFonts = FALSE;
BOOL gbForceUFIMapping = FALSE;
#endif

#if PRINT_TIMER
BOOL bPrintTimer = TRUE;
#endif

#ifdef  DBGSUBSET
//Timing code
FILETIME    startPageTime, midPageTime, endPageTime;
#endif

int StartDocEMF(HDC hdc, CONST DOCINFOW * pDocInfo, BOOL *pbBanding); // output.c

/****************************************************************************
 * int PutDCStateInMetafile( HDC hdcMeta, HDC hdcSrc )
 *
 * Captures state of a DC into a metafile.
 *
 *
 * History
 *
 * Clear the UFI in LDC so we can set the force mapping for the next metafile
 * Feb-07-1997  Xudong Wu   [tessiew]
 *
 * This routine captures the states of a DC into a METAFILE.   This is important
 * because we would like each page of the spooled metafile to be completely self
 * contained.  In order to do this it must complete capture the original state
 * of the DC in which it was recorded.
 *
 *  Gerrit van Wingerden [gerritv]
 *
 *  11-7-94 10:00:00
 *
 *****************************************************************************/

BOOL PutDCStateInMetafile( HDC hdcMeta )
{
    PLDC pldc;
    POINT ptlPos;
    ULONG ul;

//    DC_PLDC(hdcMeta,pldc,0);

    pldc = GET_PLDC(hdcMeta);

    if (!pldc)
        return FALSE;

    MFD1("Selecting pen into mf\n");
    SelectObject( hdcMeta, (HGDIOBJ) GetDCObject(hdcMeta, LO_PEN_TYPE) );

    MFD1("Selecting brush into mf\n");
    SelectObject( hdcMeta, (HGDIOBJ) GetDCObject(hdcMeta, LO_BRUSH_TYPE) );

    UFI_CLEAR_ID(&pldc->ufi);

    MFD1("Selecting logfont into mf\n");
    SelectObject( hdcMeta, (HGDIOBJ) GetDCObject(hdcMeta, LO_FONT_TYPE) );

    // DON'T TRY THIS AT HOME.  We need to record the current state of the
    // dc in the metafile.  We have optimizations however, that keep us from
    // setting the same attribute if it was just set.

    if( GetBkColor( hdcMeta ) != 0xffffff )
    {
        MFD1("Changing backround color in mf\n");
        SetBkColor( hdcMeta, GetBkColor( hdcMeta ) );
    }

    if( GetTextColor( hdcMeta ) != 0 )
    {
        MFD1("Changing text color in mf\n");
        SetTextColor( hdcMeta, GetTextColor( hdcMeta ) );
    }

    if( GetBkMode( hdcMeta ) != OPAQUE )
    {
        MFD1("Changing Background Mode in mf\n");
        SetBkMode( hdcMeta, GetBkMode( hdcMeta ) );
    }

    if( GetPolyFillMode( hdcMeta ) != ALTERNATE )
    {
        MFD1("Changing PolyFill mode in mf\n");
        SetPolyFillMode( hdcMeta, GetPolyFillMode( hdcMeta ) );
    }

    if( GetROP2( hdcMeta ) != R2_COPYPEN )
    {
        MFD1("Changing ROP2 in mf\n");
        SetROP2( hdcMeta, GetROP2( hdcMeta ) );
    }

    if( GetStretchBltMode( hdcMeta ) != BLACKONWHITE )
    {
        MFD1("Changing StrechBltMode in mf\n");
        SetStretchBltMode( hdcMeta, GetStretchBltMode( hdcMeta ) );
    }

    if( GetTextAlign( hdcMeta ) != 0 )
    {
        MFD1("Changing TextAlign in mf\n");
        SetTextAlign( hdcMeta, GetTextAlign( hdcMeta ) );
    }

    if( ( GetBreakExtra( hdcMeta ) != 0 )|| ( GetcBreak( hdcMeta ) != 0 ) )
    {
        MFD1("Setting Text Justification in mf\n");
        SetTextJustification( hdcMeta, GetBreakExtra( hdcMeta ), GetcBreak( hdcMeta ) );
    }

    if( GetMapMode( hdcMeta ) != MM_TEXT )
    {
        INT iMapMode = GetMapMode( hdcMeta );
        POINT ptlWindowOrg, ptlViewportOrg;
        SIZEL WndExt, ViewExt;

        // get these before we set the map mode to MM_TEXT

        GetViewportExtEx( hdcMeta, &ViewExt );
        GetWindowExtEx( hdcMeta, &WndExt );

        GetWindowOrgEx( hdcMeta, &ptlWindowOrg );
        GetViewportOrgEx( hdcMeta, &ptlViewportOrg );

        // set it to MM_TEXT so it doesn't get optimized out

        SetMapMode(hdcMeta,MM_TEXT);

        MFD1("Setting ANISOTROPIC or ISOTROPIC mode in mf\n");

        SetMapMode( hdcMeta, iMapMode );

        if( iMapMode == MM_ANISOTROPIC || iMapMode == MM_ISOTROPIC )
        {
            SetWindowExtEx( hdcMeta, WndExt.cx, WndExt.cy, NULL );
            SetViewportExtEx( hdcMeta, ViewExt.cx, ViewExt.cy, NULL );
        }

        SetWindowOrgEx( hdcMeta,
                        ptlWindowOrg.x,
                        ptlWindowOrg.y,
                        NULL );

        SetViewportOrgEx( hdcMeta,
                          ptlViewportOrg.x,
                          ptlViewportOrg.y,
                          NULL );
    }

    if( GetCurrentPositionEx( hdcMeta, &ptlPos ) )
    {
        MFD1("Set CurPos in mf\n");
        MoveToEx( hdcMeta, ptlPos.x, ptlPos.y, NULL );
    }

    if( GetBrushOrgEx( hdcMeta, &ptlPos ) )
    {
        MFD1("Set BrushOrg in mf\n");
        SetBrushOrgEx( hdcMeta, ptlPos.x, ptlPos.y, &ptlPos );
    }

    if( SetICMMode( hdcMeta, ICM_QUERY ) )
    {
        MFD1("Set ICM mode in mf\n");
        SetICMMode( hdcMeta, SetICMMode(hdcMeta,ICM_QUERY) );
    }

    if( GetColorSpace( hdcMeta ) != NULL )
    {
        MFD1("Set ColorSpace in mf\n");
        SetColorSpace( hdcMeta, GetColorSpace(hdcMeta) );
    }

    if(!NtGdiAnyLinkedFonts())
    {
    // tell the machine to turn off linking

        MF_SetLinkedUFIs(hdcMeta, NULL, 0);
    }

    return TRUE;
}

/****************************************************************************
 * int MFP_StartDocW( HDC hdc, CONST DOCINFOW * pDocInfo )
 *
 *  Gerrit van Wingerden [gerritv]
 *
 *  11-7-94 10:00:00
 *
 ****************************************************************************/

//! this needs to be moved to a spooler header file

#define QSM_DOWNLOADFONTS   0x000000001

BOOL MFP_StartDocW( HDC hdc, CONST DOCINFOW * pDocInfo, BOOL bBanding )
{
    BOOL   bRet    = FALSE;
    PWSTR  pstr    = NULL;
    BOOL   bEpsPrinting;
    PLDC   pldc;
    UINT   cjEMFSH;
    FLONG  flSpoolMode;
    HANDLE hSpooler;
    DWORD  dwSessionId = 0;

    EMFSPOOLHEADER *pemfsh = NULL;

    MFD1("Entering StartDocW\n");

    if (!IS_ALTDC_TYPE(hdc))
        return(bRet);

    DC_PLDC(hdc,pldc,bRet);

    //
    // Create a new EMFSpoolData object to use during EMF recording
    //

    if (!AllocEMFSpoolData(pldc, bBanding))
    {
        WARNING("MFP_StartDocW: AllocEMFSpoolData failed\n");
        return bRet;
    }

    if( !bBanding )
    {
        hSpooler = pldc->hSpooler;
        cjEMFSH = sizeof(EMFSPOOLHEADER);

        if( pDocInfo->lpszDocName != NULL )
        {
            cjEMFSH += ( wcslen( pDocInfo->lpszDocName ) + 1 ) * sizeof(WCHAR);
        }

        if( pDocInfo->lpszOutput != NULL )
        {
            cjEMFSH += ( wcslen( pDocInfo->lpszOutput ) + 1 ) * sizeof(WCHAR);
        }

        cjEMFSH = ROUNDUP_DWORDALIGN(cjEMFSH);

        pemfsh = (EMFSPOOLHEADER*) LocalAlloc( LMEM_FIXED, cjEMFSH );

        if( pemfsh == NULL )
        {
            WARNING("MFP_StartDOCW: out of memory.\n");
            goto FREEPORT;
        }

        pemfsh->cjSize = cjEMFSH;

        cjEMFSH = 0;

        if( ( pDocInfo->lpszDocName ) != NULL )
        {
            pemfsh->dpszDocName = sizeof(EMFSPOOLHEADER);
            wcscpy( (WCHAR*) (pemfsh+1), pDocInfo->lpszDocName );
            cjEMFSH += ( wcslen( pDocInfo->lpszDocName ) + 1 ) * sizeof(WCHAR);
        }
        else
        {
            pemfsh->dpszDocName = 0;
        }

        if( pDocInfo->lpszOutput != NULL )
        {
            pemfsh->dpszOutput = sizeof(EMFSPOOLHEADER) + cjEMFSH;
            wcscpy((WCHAR*)(((BYTE*) pemfsh ) + pemfsh->dpszOutput),
                   pDocInfo->lpszOutput);
        }
        else
        {
            pemfsh->dpszOutput = 0;
        }

        ASSERTGDI(ghSpooler,"non null hSpooler with unloaded WINSPOOL\n");

        if( !(*fpQuerySpoolMode)( hSpooler, &flSpoolMode, &(pemfsh->dwVersion)))
        {
            WARNING("MFP_StartDoc: QuerySpoolMode failed\n");
            goto FREEPORT;
        }

        //
        // In the scenario of a TS session or a console session that is non zero,
        // (due to FastUserSwitching) the font is added using AddFontResource to the win32k.sys 
        // of one of the clients and the printing is done with the win32k.sys of the console.
        // Those are separate win32k.sys that have their own data. The win32k.sys of the console
        // cannot access the font that is in the data of a different win32k.sys. In this case 
        // we need to force the font to be embedded in the EMF stream.
        //
        if (!ProcessIdToSessionId(GetCurrentProcessId(), &dwSessionId) || dwSessionId != 0)
        {
            flSpoolMode |= QSM_DOWNLOADFONTS;           
        }

        ASSERTGDI((pemfsh->dwVersion == 0x00010000),
                  "QuerySpoolMode version doesn't equal 1.0\n");

        if( !WriteEMFSpoolData(pldc, pemfsh, pemfsh->cjSize))
        {
            WARNING("MFP_StartDOC: WriteData failed\n");
            goto FREEPORT;
        }
        else
        {
            MFD1("Wrote EMFSPOOLHEADER to the spooler\n");
        }

        //
        // Write PostScript Injection data.
        //
        // ATTENTION: THIS MUST BE RIGHT AFTER EMFSPOOLHEADER RECORD
        //
        if (pldc->dwSizeOfPSDataToRecord)
        {
            BOOL          bError = FALSE;
            EMFITEMHEADER emfi;
            PLIST_ENTRY   p = pldc->PSDataList.Flink;

            // Write the header to spooler.

            emfi.ulID   = EMRI_PS_JOB_DATA;
            emfi.cjSize = pldc->dwSizeOfPSDataToRecord;

            if (!WriteEMFSpoolData(pldc, &emfi, sizeof(emfi)))
            {
                WARNING("MFP_StartPage: Write printer failed for PS_JOB_DATA header\n");
                goto FREEPORT;
            }
            else
            {
                MFD1("Wrote EMRI_PS_JOB_DATA header to the spooler\n");
            }

            // Record EMFITEMPSINJECTIONDATA

            while(p != &(pldc->PSDataList))
            {
                PPS_INJECTION_DATA pPSData;

                // get pointer to this cell.

                pPSData = CONTAINING_RECORD(p,PS_INJECTION_DATA,ListEntry);

                // record this escape to EMF.

                if (!bError && !WriteEMFSpoolData(pldc, &(pPSData->EmfData), pPSData->EmfData.cjSize))
                {
                    WARNING("MFP_StartPage: Write printer failed for PS_JOB_DATA escape data\n");
                    bError = TRUE;
                }

                // get pointer to next cell.

                p = p->Flink;

                // no longer needs this cell.

                LOCALFREE(pPSData);
            }

            // mark as data already freed.

            pldc->dwSizeOfPSDataToRecord = 0;
            InitializeListHead(&(pldc->PSDataList));

            if (bError)
            {
                goto FREEPORT;
            }
        }

#if DBG
        if( gbDownloadFonts )
        {
            flSpoolMode |= QSM_DOWNLOADFONTS;
        }
#endif

        if (flSpoolMode & QSM_DOWNLOADFONTS)
        {
        // Now, QMS_DOWNLOADFONTS bit are on when print on remote print server,
        // then I just use this bit to determine attach ICM profile to metafile
        // or not. - hideyukn [May-08-1997]

            pldc->fl |= LDC_DOWNLOAD_PROFILES;

        // Configure to download fonts

            pldc->fl |= LDC_DOWNLOAD_FONTS;
            pldc->ppUFIHash = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                          sizeof( PUFIHASH ) * 3 * UFI_HASH_SIZE );

            if( pldc->ppUFIHash == NULL)
            {
                WARNING("MFP_StartDocW: unable to allocate UFI hash tables\n");
                goto FREEPORT;
            }

        // do not want to allocate memory twice

            pldc->ppDVUFIHash = &pldc->ppUFIHash[UFI_HASH_SIZE];
            pldc->ppSubUFIHash = &pldc->ppDVUFIHash[UFI_HASH_SIZE];

            pldc->fl |= LDC_FORCE_MAPPING;
            pldc->ufi.Index = 0xFFFFFFFF;
        }
        else
        {
            ULONG cEmbedFonts;

            pldc->ppUFIHash = pldc->ppDVUFIHash = pldc->ppSubUFIHash = NULL;
            if ((cEmbedFonts = NtGdiGetEmbedFonts()) && cEmbedFonts != 0xFFFFFFFF)
            {
                pldc->fl |= LDC_EMBED_FONTS;
                pldc->ppUFIHash = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(PUFIHASH) * UFI_HASH_SIZE);

                if (pldc->ppUFIHash == NULL)
                {
                    WARNING("MFP_StartDocW: unable to allocate UFI has table for embed fonts\n");
                    goto FREEPORT;
                }
            }
        }

#if DBG
        // If gbDownloadFonts is set then force all fonts to be downloaded.  Even
        // ones on the remote machine.

        if( (flSpoolMode & QSM_DOWNLOADFONTS) && !gbDownloadFonts )
#else
        if( flSpoolMode & QSM_DOWNLOADFONTS )
#endif
        {
        // query the spooler to get the list of fonts is has available

            INT nBufferSize = 0;
            PUNIVERSAL_FONT_ID pufi;

            nBufferSize = (*fpQueryRemoteFonts)( pldc->hSpooler, NULL, 0 );

            if( nBufferSize != -1 )
            {
                pufi = LocalAlloc( LMEM_FIXED, sizeof(UNIVERSAL_FONT_ID) * nBufferSize );

                if( pufi )
                {
                    INT nNewBufferSize = (*fpQueryRemoteFonts)( pldc->hSpooler,
                                                                pufi,
                                                                nBufferSize );

                    //
                    // This fixes bug 420136. We have three cases according to the result
                    // of QueryRemoteFonts. If it returns -1, nBufferSize will be set to
                    // -1 in the if statement. If nNewBufferSize is larger than what we
                    // allocated, then we use the buffer that we allocated (nBufferSize) 
                    // If nNewBufferSize is less than what we allocated, then we set
                    // nBufferSize to a lower value then the one previously held. This means
                    // we access only a part of the buffer we allocated.
                    //
                    if (nNewBufferSize < nBufferSize) 
                    {
                        nBufferSize = nNewBufferSize;
                    }

                    MFD2("Found %d fonts\n", nBufferSize );
    
                    if (nBufferSize > 0)
                    {
                        // next add all these fonts to UFI has table so we don't
                        //include them in the spool file.
    
                        while( nBufferSize-- )
                        {
                            pufihAddUFIEntry(pldc->ppUFIHash, &pufi[nBufferSize], 0, 0, 0);
                            MFD2("%x\n", pufi[nBufferSize].CheckSum );
                        }
                    }
                    LocalFree( pufi );
                }
            }
            else
            {
                WARNING("QueryRemoteFonts failed.  We will be including all fonts in \
                         the EMF spoolfile\n");
            }
        }

#if DBG
        if( gbForceUFIMapping )
        {
            pldc->fl |= LDC_FORCE_MAPPING;
        }
#endif

    }

    // we now need to create an EMF DC for this document

    if (!AssociateEnhMetaFile(hdc))
    {
        WARNING("Failed to create spool metafile");
        goto FREEPORT;
    }

    if (bBanding)
    {
        pldc->fl |= LDC_BANDING;
        
        // remove the LDC_PRINT_DIRECT which
        // was set in StartDocW before NtGdiStartDoc call.

        pldc->fl &= ~LDC_PRINT_DIRECT;
    }

    // set the data for this lhe to that of the meta file

    pldc->fl |= (LDC_DOC_STARTED|LDC_META_PRINT|LDC_CALL_STARTPAGE|LDC_FONT_CHANGE);

    // clear color page flag

    CLEAR_COLOR_PAGE(pldc);

    if (pldc->pfnAbort != NULL)
    {
        pldc->fl |= LDC_SAP_CALLBACK;
        pldc->ulLastCallBack = GetTickCount();
    }

    bRet = TRUE;

FREEPORT:

    if( pemfsh != NULL )
    {
        LOCALFREE(pemfsh);
    }

    return(bRet);
}

/****************************************************************************
 * int WINAPI MFP_EndDoc(HDC hdc)
 *
 * Gerrit van Wingerden [gerritv]
 *
 * 11-7-94 10:00:00
 *
 *****************************************************************************/

int WINAPI MFP_EndDoc(HDC hdc)
{
    int            iRet = 1;
    PLDC           pldc;
    HENHMETAFILE   hmeta;

    if (!IS_ALTDC_TYPE(hdc))
        return(iRet);

    DC_PLDC(hdc,pldc,0);

    MFD1("MFP_EndDoc\n");

    if ((pldc->fl & LDC_DOC_STARTED) == 0)
        return(1);

    if (pldc->fl & LDC_PAGE_STARTED)
    {
        MFP_EndPage(hdc);
    }

    ASSERTGDI(pldc->fl & LDC_META_PRINT,
              "DetachPrintMetafile not called on metafile D.C.\n" );

// completely detach the metafile from the original printer DC

    hmeta = UnassociateEnhMetaFile( hdc, FALSE );
    DeleteEnhMetaFile( hmeta );

    DeleteEMFSpoolData(pldc);

// Clear the LDC_SAP_CALLBACK flag.
// Also clear the META_PRINT and DOC_STARTED flags

    pldc->fl &= ~(LDC_SAP_CALLBACK | LDC_META_PRINT);

    RESETUSERPOLLCOUNT();

    MFD1("Caling spooler to end doc\n");

    if( pldc->fl & LDC_BANDING )
    {
        pldc->fl &= ~LDC_BANDING;
        EndDoc( hdc );
    }
    else
    {
        pldc->fl &= ~LDC_DOC_STARTED;
        (*fpEndDocPrinter)(pldc->hSpooler);
    }

#if PRINT_TIMER
    if( bPrintTimer )
    {
        DWORD tc;

        tc = GetTickCount();

        DbgPrint("Document took %d.%d seconds to spool\n",
                 (tc - pldc->msStartDoc) / 1000,
                 (tc - pldc->msStartDoc) % 1000 );

    }
#endif

    return(iRet);
}

/****************************************************************************
 * int WINAPI MFP_StartPage(HDC hdc)
 *
 * Gerrit van Wingerden [gerritv]
 *
 * 11-7-94 10:00:00
 *
 *****************************************************************************/

int MFP_StartPage( HDC hdc )
{
    PLDC     pldc;
    int iRet = 1;

//Timing code
#ifdef  DBGSUBSET
    if (gflSubset & FL_SS_PAGETIME)
    {
        GetSystemTimeAsFileTime(&startPageTime);
    }
#endif

    if (!IS_ALTDC_TYPE(hdc))
        return(0);

    DC_PLDC(hdc,pldc,0);

    MFD1("Entering MFP_StartPage\n");

    pldc->fl &= ~LDC_CALL_STARTPAGE;
    pldc->fl &= ~LDC_CALLED_ENDPAGE;

    pldc->fl &= ~LDC_META_ARCDIR_CLOCKWISE;

// Do nothing if page has already been started.

    if (pldc->fl & LDC_PAGE_STARTED)
        return(1);

    pldc->fl |= LDC_PAGE_STARTED;

    RESETUSERPOLLCOUNT();

    if( pldc->fl & LDC_BANDING )
    {
        iRet = SP_ERROR;

        // ATTENTION: maybe we can delay the call here and do it right before we start
        // banding.

        MakeInfoDC( hdc, FALSE );

        iRet = NtGdiStartPage(hdc);

        MakeInfoDC( hdc, TRUE );
    }
    else
    {
        ULONG               ulCopyCount;
        EMFITEMHEADER       emfi;
        EMFITEMPRESTARTPAGE emfiPre;

    // If application calls Escape(SETCOPYCOUNT), we will over-write copy count in
    // devmode and save it into metafile.

        NtGdiGetAndSetDCDword(
            hdc,
            GASDDW_COPYCOUNT,
            (DWORD) -1,
            &ulCopyCount);

        if (ulCopyCount != (ULONG) -1)
        {
            if (pldc->pDevMode)
            {
            // Set copy count into devmode.
            // No driver call happen here, since this is EMF spooling...

                pldc->pDevMode->dmFields |= DM_COPIES;
                pldc->pDevMode->dmCopies = (short) ulCopyCount;

            // Fill up EMF record for devmode.

                emfi.ulID = EMRI_DEVMODE;
                emfi.cjSize = pldc->pDevMode->dmSize + pldc->pDevMode->dmDriverExtra;

            // Force devmode data to be DWORD aligned

                emfi.cjSize = ROUNDUP_DWORDALIGN(emfi.cjSize);

                if (!WriteEMFSpoolData(pldc, &emfi, sizeof(emfi)) ||
                    !WriteEMFSpoolData(pldc, pldc->pDevMode, emfi.cjSize))
                {
                    WARNING("MFP_StartPage: Write printer failed for DEVMODE\n");
                    return(SP_ERROR);
                }
            }
        }

    // before the start page, we need to see if the EPS mode has
    // changed since the start doc.

        NtGdiGetAndSetDCDword(
            hdc,
            GASDDW_EPSPRINTESCCALLED,
            (DWORD) FALSE,
            &emfiPre.bEPS);

        if (emfiPre.bEPS)
        {
            int i;
            EMFITEMHEADER emfiHeader;

            // make sure it is true or false

            emfiPre.bEPS = !!emfiPre.bEPS;

            // This was ulCopyCount.
            // Just set -1 for keep compatibility. -1 means "up to devmode".

            emfiPre.ulUnused = -1;

            // is there anything we will need to do?  If so record the record

            emfiHeader.ulID   = EMRI_PRESTARTPAGE;
            emfiHeader.cjSize = sizeof(emfiPre);

            if (!WriteEMFSpoolData(pldc, &emfiHeader, sizeof(emfiHeader)) ||
                !WriteEMFSpoolData(pldc, &emfiPre, sizeof(emfiPre)))
            {
                WARNING("MFP_StartPage: Write printer failed for PRESTARTPAGE\n");
                return(SP_ERROR);
            }
        }

    // Metafile the start page call.  Now all the play journal code has to do is
    // play back the metafile and the StartPage call will happen automatically
    // at the right place in the metafile.

        if( !(*fpStartPagePrinter)( pldc->hSpooler ) )
        {
            WARNING("MFP_StarPage: StartPagePrinter failed\n");
            return(SP_ERROR);
        }
    }

    return(iRet);
}

/****************************************************************************
 * BOOL StartBanding( HDC hdc, POINTL *pptl )
 *
 * Tells the printer driver to get ready for banding and asks for the origin
 * of the first band.
 *
 *
 * Gerrit van Wingerden [gerritv]
 *
 * 1-7-95 10:00:00
 *
 *****************************************************************************/

BOOL StartBanding( HDC hdc, POINTL *pptl, SIZE *pSize )
{
    return (NtGdiDoBanding(hdc, TRUE, pptl, pSize));
}

/****************************************************************************
 * BOOL NextBand( HDC hdc, POINTL *pptl )
 *
 * Tells the driver to realize the image accumlated in the DC and then
 * asks for the origin of the next band.  If the origin is (-1,-1) the
 * driver is through banding.
 *
 *
 * Gerrit van Wingerden [gerritv]
 *
 * 1-7-95 10:00:00
 *
 *****************************************************************************/

BOOL NextBand( HDC hdc, POINTL *pptl )
{
    BOOL bRet=FALSE;
    SIZE szScratch;

    bRet = NtGdiDoBanding(hdc, FALSE, pptl, &szScratch);

// reset the page started flag if this is the next band

    if( bRet && ( pptl->x == -1 ) )
    {
        PLDC pldc;
        DC_PLDC(hdc,pldc,0);

        pldc->fl &= ~LDC_PAGE_STARTED;
    }

    return(bRet);
}

/****************************************************************************\
 * VOID PrintBand()
 *
 * History:
 *
 *  1-05-97 Hideyuki Nagase [hideyukn]
 * Wrote it.
 *  3-23-98 Ramanathan Venkatapathy [ramanv]
 * Fixed Scaling bugs
 *  6-26-98 Ramanathan Venkatapathy [ramanv]
 * Added pClip to correct the clipping when Xforms are applied on the
 * DC. ANDing Banding region with prect incorrectly clips off regions when
 * prect is yet to be transformed.
 *  8-24-99 Steve Kiraly [steveki]
 * Add code to not play on the DC if there is no intersection with the
 * clipping rectangle and the banding rectangle.  Fix n-up bug when the
 * imageable area of the document is larger that the physical page. The
 * solution consisted of setting up the clipping region to stay within
 * either the banding rectangle or the clipping rectangle.  See bug 377434
 * for more information.
 *
 * An illustration of the problem.
 *
 * We are printing a document that is larger than the imageable area of the page
 * thus it must print on 2 pages and we are printing 2-up with banding enabled
 * because this is a 24 bpp document.
 *
 * The printable region rectagle is (0,0) (2114,3066)
 * Page one has a clipping rectangle of (216,46) (2114,1510)
 * Page two has a clipping rectangle of (216,1601) (2114,3066)
 *
 * GDI will print using 4 bands each 784 high.
 *
 * Band 1 pptl = 0,0        pszlBand = 2400,784
 * Band 2 pptl = 0,784      pszlBand = 2400,784
 * Band 3 pptl = 0,1568     pszlBand = 2400,784
 * Band 4 pptl = 0,2352     pszlBand = 2400,784
 *
 *        0,0
 *
 * 0,0    +-----------------------------------------------------------------+
 *        | 216,46                                                          |
 *        |                                                                 |
 *        |                                                                 |
 * 0,784  |                                                                 |
 *        |                                                                 |
 *        |          [========================================]             |
 *        |          [                                        ]             |
 *        |          [                                        ]             |
 *        |          [                                        ]   2114,1510 |
 *        |-----------------------------------------------------------------|
 *        | 216,1601 [                                        ]             |
 * 0,1568 |          [                                        ]             |
 *        |          [                                        ]             |
 *        |          [                                        ]             |
 * 0,2352 |          [                                        ]             |
 *        |          [                                        ]             |
 *        |          [========================================]             |
 *        |                                                                 |
 *        |                                                       2114,3066 |
 *        +-----------------------------------------------------------------+
 *
 *                                                                  2114,3066
 *
 * Band 1 clipping region is (216,0) (2401,785)
 * Band 2 clipping region is (216,784) (2114,726)
 * Band 3 clipping region is (216,33) (2114,785)
 * Band 4 clipping region is (216,0) (2114,714)
 *
 * Band 2 and 3 are the most interesting cases.  Band 2 the clipping
 * bottom right corner is the size of the clipping rectangle rather than the
 * band size as the code orignally was.  Band 3 on the other hand has the
 * top left corner of the region adjusted to the clipping rectangle.
 *
 ****************************************************************************/

VOID
PrintBand(
    HDC            hdc,
    HENHMETAFILE   hmeta,
    POINTL        *pptl,     // Offsets from top of page for this band.
    RECT          *prect,    // Rectangle for printable reagion of this page.
    SIZEL         *pszlBand, // Size of band.
    RECT          *pClip     // Clipping rectangle, non null when n-up.
)
{
    ULONG       ulRet;
    PERBANDINFO pbi;

    MFD3("gdi32:PrintBand Print offset x,y = %d,%d\n", pptl->x, pptl->y);
    MFD3("gdi32:PrintBand Printable region top = %d, bottom = %d\n", prect->top, prect->bottom);
    MFD3("gdi32:PrintBand Printable region left = %d, right = %d\n", prect->left, prect->right);
    MFD3("gdi32:PrintBand Band size x,y = %d,%d\n",pszlBand->cx, pszlBand->cy);

    do
    {
        RECT rectPage = *prect;
        HRGN hRgnBand = NULL;
        HRGN hRgnCurrent = NULL;
        BOOL bSaveDC = FALSE;
        ULONG ulXRes, ulYRes;
        BOOL  bUsePerBandInfo = FALSE;

        // Updates view origin in specified coords.

        SetViewportOrgEx( hdc, -(pptl->x), -(pptl->y), NULL );

        // Initialize with current resolution.

        ulXRes = (ULONG)  prect->right - prect->left;
        ulYRes = (ULONG)  prect->bottom - prect->top;

        pbi.bRepeatThisBand = FALSE;
        pbi.ulHorzRes = ulXRes;
        pbi.ulVertRes = ulYRes;
        pbi.szlBand.cx = pszlBand->cx;
        pbi.szlBand.cy = pszlBand->cy;

        MFD1("GDI32:PrintBand() querying band information\n");

        // Query band information.

        ulRet = NtGdiGetPerBandInfo(hdc,&pbi);

        if (ulRet != GDI_ERROR)
        {
            SIZEL  szlClip;
            POINTL pptlMove;

            bUsePerBandInfo = (ulRet != 0);

            // If return value is 0, we will draw without scaling.

            if (bUsePerBandInfo &&
                ((ulXRes != pbi.ulHorzRes) ||
                 (ulYRes != pbi.ulVertRes)))
            {
                FLOAT  sx,sy;

                MFD1("GDI PlayEMF band information was specified\n");

                // Compute scaling ratio.

                //
                // This code has rounding errors due to
                // float to long truncation. The correct code
                // should use a LONGLONG to store the numerator and do
                // all of the computation in integer math.
                //
                // See StretchDIBits
                //
                // The fix is coded below in comments because we can't check it
                // in till someone figures out how to break the original version.
                //

                sx = (FLOAT) ulXRes / (FLOAT) pbi.ulHorzRes;
                sy = (FLOAT) ulYRes / (FLOAT) pbi.ulVertRes;

                // Shrink/Stretch drawing frame.

                //rectPage.left = (LONG)  ((LONGLONG)rectPage.left*pbi.ulHorizRes)/ulXRes;
                //rectPage.top  = (LONG) ((LONGLONG)rectPage.top*pbi.ulVertRes)/ulYRes;
                //rectPage.right = (LONG) ((LONGLONG)rectPage.right*pbi.ulHorizRes)/ulXRes;
                //rectPage.bottom  = (LONG) ((LONGLONG)rectPage.bottom*pbi.ulVertRes)/ulYRes;

                rectPage.left = (LONG) ((FLOAT) rectPage.left / sx);
                rectPage.top  = (LONG) ((FLOAT) rectPage.top / sy);
                rectPage.right = (LONG) ((FLOAT) rectPage.right / sx);
                rectPage.bottom  = (LONG) ((FLOAT) rectPage.bottom / sy);

                // Compute view origin.

                //pptlMove.x = (LONG) ((LONGLONG)pptl->x*pbi.ulHorizRes)/ulXRes;
                //pptlMove.y = (LONG) ((LONGLONG)pptl->y*pbi.ulVertRes)/ulYRes;

                pptlMove.x = (LONG) ((FLOAT) pptl->x / sx);
                pptlMove.y = (LONG) ((FLOAT) pptl->y / sy);

                // Updates view origin in specified coords.

                SetViewportOrgEx( hdc, -pptlMove.x, -pptlMove.y, NULL );

                // Set clip region size.


                //szlClip.cx = (ULONG) ((LONGLONG)pbi.szlBand.cx*pbi.ulHorizRes)/ulXRes;
                //szlClip.cy = (ULONG) ((LONGLONG)pbi.szlBand.cy*pbi.ulVertRes)/ulYRes;

                szlClip.cx = (ULONG) ((FLOAT) pbi.szlBand.cx / sx);
                szlClip.cy = (ULONG) ((FLOAT) pbi.szlBand.cy / sy);

                // Create clip region for banding.

                hRgnBand = CreateRectRgn(0,0,szlClip.cx,szlClip.cy);
            }
            else
            {
                SIZEL  szlPage      = {0,0};
                SIZEL  szlAdjust    = {0,0};

                if(!bUsePerBandInfo)
                {
                    // Set back to default values in case driver mucked with them

                    pbi.bRepeatThisBand = FALSE;
                    pbi.ulHorzRes = ulXRes;
                    pbi.ulVertRes = ulYRes;
                    pbi.szlBand.cx = pszlBand->cx;
                    pbi.szlBand.cy = pszlBand->cy;
                }

                pptlMove.x = pptl->x;
                pptlMove.y = pptl->y;

                MFD1("gdi32:PrintBand(): GetPerBandInfo NO SCALING is requested\n");

                // Page size
                if (pClip) {

                    RECT rcBand;
                    RECT rcIntersect;

                    MFD3("gdi32:PrintBand(): Clipping Rectangle top = %d, bottom = %d\n", pClip->top, pClip->bottom);
                    MFD3("gdi32:PrintBand(): Clipping Rectangle left = %d, right = %d\n", pClip->left, pClip->right);

                    rcBand.left     = pptlMove.x;
                    rcBand.top      = pptlMove.y;
                    rcBand.right    = pptlMove.x + pbi.szlBand.cx;
                    rcBand.bottom   = pptlMove.y + pbi.szlBand.cy;

                    //
                    // If the banding rect does not instersect the clip rect
                    // not much to do, just continue.
                    //
                    if (!IntersectRect(&rcIntersect, pClip, &rcBand))
                    {
                        MFD1("gdi32:PrintBand(): No intersection with band rect and pClip\n");
                        continue;
                    }

                    szlPage.cx = pClip->right;
                    szlPage.cy = pClip->bottom;

                    //
                    // The adjust point it neccessary to move the clipping
                    // region's upper or left edge.  The szlClip is used to
                    // move the clipping region's height and width.
                    //
                    if (pClip->left > pptlMove.x)
                    {
                        szlAdjust.cx = pClip->left - pptlMove.x;
                    }

                    if (pClip->top > pptlMove.y)
                    {
                        szlAdjust.cy = pClip->top - pptlMove.y;
                    }

                } else {

                    szlPage.cx = prect->right;
                    szlPage.cy = prect->bottom;
                }

                //
                // Set clip region size (clip by band size)
                //
                // if band rect over page rect, adjust it.
                //

                if ((pptlMove.x + pbi.szlBand.cx) > szlPage.cx)
                {
                    szlClip.cx = szlPage.cx - pptlMove.x;
                }
                else
                {
                    szlClip.cx = pbi.szlBand.cx;
                }

                if ((pptlMove.y + pbi.szlBand.cy) > szlPage.cy)
                {
                    szlClip.cy = szlPage.cy - pptlMove.y;
                }
                else
                {
                    szlClip.cy = pbi.szlBand.cy;
                }

                MFD3("Print offset x,y = %d,%d\n",pptlMove.x,pptlMove.y);
                MFD3("Page size x,y = %d,%d\n",szlPage.cx,szlPage.cy);
                MFD3("Band size x,y = %d,%d\n",pbi.szlBand.cx,pbi.szlBand.cy);
                MFD3("Clip size x,y = %d,%d\n",szlClip.cx,szlClip.cy);
                MFD3("Adjust size x,y = %d,%d\n",szlAdjust.cx,szlAdjust.cy);

                // Create clip region for banding.

                hRgnBand = CreateRectRgn(szlAdjust.cx,szlAdjust.cy,szlClip.cx,szlClip.cy);
            }

            if (hRgnBand)
            {
                int iRet;
                RECT rectCurrentClip;

                // Get clip box currently selected in DC.

                iRet = GetClipBox(hdc,&rectCurrentClip);

                if ((iRet == NULLREGION) || (iRet == ERROR))
                {
                    // Select simple band region as clip region.

                    SelectClipRgn(hdc, hRgnBand);
                }
                else
                {
                    MFD1("GDI PrintBand: Some region already exists\n");
                    MFD3("Clip Box top = %d, bottom = %d\n",
                          rectCurrentClip.top,rectCurrentClip.bottom);
                    MFD3("Clip Box left = %d, right = %d\n",
                          rectCurrentClip.left,rectCurrentClip.right);
                    
                    // Save currect DC to restore current clip region later.

                    SaveDC(hdc);

                    // Move to the clip reagion to proper place.

                    OffsetClipRgn(hdc,-pptlMove.x,-pptlMove.y);

                    // Some clip region already defined. we need to combine those.

                    ExtSelectClipRgn(hdc, hRgnBand, RGN_AND);

                    // Mark as we saved DC.

                    bSaveDC = TRUE;
                }
            }

            // Play metafile.

            PlayEnhMetaFile( hdc, hmeta, &rectPage );

            if (hRgnBand)
            {
                if (bSaveDC)
                {
                    RestoreDC(hdc,-1);
                }
                else
                {

                    // Set back it to NULL region.

                    SelectClipRgn(hdc,NULL);
                }

                // Reset the clip region.

                DeleteObject(hRgnBand);
            }
        }
        else
        {
            MFD1("GDI PrintBand: Got error from kernel/driver, this band will be skipped\n");

            // There is something error, Terminate printing for this band.

            return;
        }

    // Repeat this until the driver says "no".

    } while (pbi.bRepeatThisBand);
}

/****************************************************************************
 * int MFP_InternalEndPage(HDC hdc, DWORD dwEMFITEMID)
 *
 * Closes the EMF attached to the DC and writes it to the spooler.  Then
 * it creates a new metafile and binds it to the DC.
 *
 * Gerrit van Wingerden [gerritv]
 *
 * 11-7-94 10:00:00
 *
 *****************************************************************************/

int MFP_InternalEndPage(HDC hdc,
                        DWORD dwEMFITEMID)
{
    PLDC pldc;
    HENHMETAFILE hmeta;
    BOOL bOk;
    int iRet = SP_ERROR;

    MFD1("Entering MFP_EndPage\n");

    if (!IS_ALTDC_TYPE(hdc))
        return(0);

    DC_PLDC(hdc,pldc,0);

    if ((pldc->fl & LDC_DOC_CANCELLED) ||
        ((pldc->fl & LDC_PAGE_STARTED) == 0))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(SP_ERROR);
    }
    //  Need to change the dwEMFITEMID here if mono page
    if (!(pldc->fl & LDC_COLOR_PAGE)) {
       dwEMFITEMID = (dwEMFITEMID == EMRI_METAFILE) ? EMRI_BW_METAFILE
                                                    : EMRI_BW_FORM_METAFILE;
    }
    DESIGNATE_COLOR_PAGE(pldc);

    if (pldc->fl & LDC_SAP_CALLBACK)
        vSAPCallback(pldc);

    pldc->fl &= ~LDC_PAGE_STARTED;

//tessiew
#ifdef  DBGSUBSET
    if (gflSubset & FL_SS_PAGETIME)
    {
        GetSystemTimeAsFileTime(&midPageTime);
        DbgPrint("\t%ld", (midPageTime.dwLowDateTime-startPageTime.dwLowDateTime) / 10000);
    }
#endif

// We need to write the subset font into the spool
// file first for remote printing

    if ((pldc->fl & (LDC_DOWNLOAD_FONTS | LDC_FORCE_MAPPING)) && (pldc->fl & LDC_FONT_SUBSET))
    {
        PUFIHASH  pBucket, pBucketNext;
        PUCHAR puchDestBuff;
        ULONG index, ulDestSize, ulBytesWritten;

        for (index=0; index < UFI_HASH_SIZE; index++)
        {
            pBucketNext = pldc->ppSubUFIHash[index];

            while(pBucketNext)
            {
                // We might fail on bDoFontSubset() thus pBucket would be deleted from the hash table
                // in function WriteSubFontToSpoolFile(). Need to update pBucketNext first.

                pBucket = pBucketNext;
                pBucketNext = pBucket->pNext;

                if ((pBucket->fs1 & FLUFI_DELTA) && (pBucket->u.ssi.cDeltaGlyphs == 0))
                {
                    // No delta, skip
                    if (pBucket->u.ssi.pjDelta)
                    {
                        LocalFree(pBucket->u.ssi.pjDelta);
                        pBucket->u.ssi.pjDelta = NULL;
                    }
                }
                else // first page or page with nonzero delta
                {
                 // pBucket->fs1 will change for the first page after bDoFontSubset() call,
                 // thus we can't use pBucket->fs1 & FLUFI_DELTA in WriteSubFontToSpoolFile() call.
                    BOOL  bDelta = pBucket->fs1 & FLUFI_DELTA;

                    if
                    (
                        !bDoFontSubset(pBucket, &puchDestBuff, &ulDestSize, &ulBytesWritten) ||
                        !WriteSubFontToSpoolFile(pldc, puchDestBuff, ulBytesWritten, &pBucket->ufi, bDelta)
                    )
                    {
                    // if font subsetting failed, we need to write the whole font file to the spool file
                    // and clean up the UFI entry in the ldc

                        if (!bAddUFIandWriteSpool(hdc, &pBucket->ufi, TRUE, pBucket->fs2))
                        {
                            WARNING("bAddUFIandWriteSpool failed\n");
                            return SP_ERROR;
                        }
                    }
                }
            }
        }
    }

// Metafile the EndPage call.

    MFD1("MFP_EndPage: Closing metafile\n");

    hmeta = UnassociateEnhMetaFile(hdc, TRUE);

    if( hmeta == NULL )
    {
        WARNING("MFP_InternalEndPage() Closing the Enhanced Metafile Failed\n");
        return(SP_ERROR);
    }

// now write the metafile to the spooler

    if( pldc->fl & LDC_BANDING )
    {
    // play back the metafile in bands

        RECT rect;
        POINTL ptlOrigin;
        POINT  ptlKeep;
        POINT  ptlWindowOrg;
        SIZE   szWindowExt;
        SIZE   szViewportExt;
        SIZE   szSurface;    // for open gl printing optimization
        XFORM  xf;
        ULONG  ulMapMode;

    // get bounding rectangle

        rect.left = rect.top = 0;
        rect.right = GetDeviceCaps(hdc, DESKTOPHORZRES);
        rect.bottom = GetDeviceCaps(hdc, DESKTOPVERTRES);

    #if DBG
        DbgPrint("Playing banding metafile\n");
    #endif

    // temporarily reset LDC_META_PRINT flag so we don't try to record
    // during playback

        pldc->fl &= ~LDC_META_PRINT;

        bOk = StartBanding( hdc, &ptlOrigin, &szSurface );

    // we need to clear the transform during this operation

        GetViewportOrgEx(hdc, &ptlKeep);
        GetWindowOrgEx(hdc,&ptlWindowOrg);
        GetWindowExtEx(hdc,&szWindowExt);
        GetViewportExtEx(hdc,&szViewportExt);
        GetWorldTransform(hdc,&xf);

        ulMapMode = SetMapMode(hdc,MM_TEXT);
        SetWindowOrgEx(hdc,0,0,NULL);
        ModifyWorldTransform(hdc,NULL,MWT_IDENTITY);

        if( bOk )
        {
            do
            {
            // Print this band.

                PrintBand( hdc, hmeta, &ptlOrigin, &rect, &szSurface, NULL );

            // Move down to next band.

                bOk = NextBand( hdc, &ptlOrigin );
            } while( ptlOrigin.x != -1 && bOk );
        }

        if (pldc->pUMPD && bOk && (ptlOrigin.x == -1))
        {
           //
           // if UMPD and last band
           //
           if( !(*fpEndPagePrinter)( pldc->hSpooler ) )
           {
               WARNING("MFP_StarPage: EndPagePrinter failed\n");
               iRet = SP_ERROR;
           }
        }

        SetMapMode(hdc,ulMapMode);

        SetWorldTransform(hdc,&xf);
        SetWindowOrgEx(hdc,ptlWindowOrg.x,ptlWindowOrg.y,NULL);
        SetWindowExtEx(hdc,szWindowExt.cx,szWindowExt.cy,NULL);
        SetViewportExtEx(hdc,szViewportExt.cx,szViewportExt.cy,NULL);
        SetViewportOrgEx(hdc,ptlKeep.x, ptlKeep.y, NULL);

    // reset the flag for the next page

        pldc->fl |= LDC_META_PRINT;

        if( !bOk )
        {
            WARNING("MFP_EndPage: Error doing banding\n");
        }
        else
        {
        // if we got here we suceeded
            iRet = 1;
        }

    #if DBG
        DbgPrint("Done playing banding metafile\n");
    #endif
    }
    else
    {
    //  if ResetDC was called record the devmode in the metafile stream

        bOk = TRUE;

        if( pldc->fl & LDC_RESETDC_CALLED )
        {
            EMFITEMHEADER emfi;

            emfi.ulID = EMRI_DEVMODE;
            emfi.cjSize = ( pldc->pDevMode ) ?
                            pldc->pDevMode->dmSize + pldc->pDevMode->dmDriverExtra : 0 ;

            // Force devmode data to be DWORD aligned

            emfi.cjSize = ROUNDUP_DWORDALIGN(emfi.cjSize);

            if (!WriteEMFSpoolData(pldc, &emfi, sizeof(emfi)) ||
                !WriteEMFSpoolData(pldc, pldc->pDevMode, emfi.cjSize))
            {
                WARNING("Writing DEVMODE to spooler failed.\n");
                bOk = FALSE;
            }

            pldc->fl &= ~(LDC_RESETDC_CALLED);
        }

        if (bOk)
            iRet = 1;
    }

// At this point if we suceede iRet should be 1 otherwise it should be SP_ERROR
// even if we encountered an error we still want to try to associate a new
// metafile with this DC.  That whether the app calls EndPage, AbortDoc, or
// EndDoc next, things will happend more smoothly.

    DeleteEnhMetaFile(hmeta);

//
// flush the content of the current page to spooler
// and write out a new EndPage record
//

// next create a new metafile for the next page

    if (!FlushEMFSpoolData(pldc, dwEMFITEMID) || !AssociateEnhMetaFile(hdc))
    {
        WARNING("StartPage: error creating metafile\n");
        iRet = SP_ERROR;
    }

// reset user's poll count so it counts this as output

    RESETUSERPOLLCOUNT();

    if( !(pldc->fl & LDC_BANDING ) )
    {
        if( !(*fpEndPagePrinter)( pldc->hSpooler ) )
        {
            WARNING("MFP_StarPage: EndPagePrinter failed\n");
            iRet = SP_ERROR;
        }
    }

    pldc->fl |= LDC_CALL_STARTPAGE;

#if PRINT_TIMER
    if( bPrintTimer )
    {
        DWORD tc;
        tc = GetTickCount();
        DbgPrint("Page took %d.%d seconds to print\n",
                 (tc - pldc->msStartPage) / 1000,
                 (tc - pldc->msStartPage) % 1000 );

    }
#endif

#ifdef  DBGSUBSET
    if (gflSubset & FL_SS_PAGETIME)
    {
        GetSystemTimeAsFileTime(&endPageTime);
        DbgPrint("\t%ld\n", (endPageTime.dwLowDateTime-startPageTime.dwLowDateTime) / 10000);
    }
#endif

    return(iRet);
}


/****************************************************************************
 * int WINAPI MFP_EndPage(HDC hdc)
 *
 * Closes the EMF attached to the DC and writes it to the spooler.  Then
 * it creates a new metafile and binds it to the DC.
 *
 * Gerrit van Wingerden [gerritv]
 *
 * 11-7-94 10:00:00
 *
 *****************************************************************************/

int WINAPI MFP_EndPage(HDC hdc) {

   // Call MFP_InternalEndPage with EMRI_METAFILE
   return MFP_InternalEndPage(hdc, EMRI_METAFILE);

}

/****************************************************************************
 * int WINAPI MFP_EndFormPage(HDC hdc)
 *
 * Closes the EMF attached to the DC and writes it to the spooler.  Then
 * it creates a new metafile and binds it to the DC. Saves the EMF Item as a
 * watermark file which is played on each physical page.
 *
 * Ramanathan Venkatapathy [RamanV]
 *
 * 7/1/97
 *
 *****************************************************************************/

int WINAPI MFP_EndFormPage(HDC hdc) {

   // Call MFP_InternalEndPage with EMRI_FORM_METAFILE
   return MFP_InternalEndPage(hdc, EMRI_FORM_METAFILE);

}

BOOL MFP_ResetDCW( HDC hdc, DEVMODEW *pdmw )
{
    PLDC pldc;
    HENHMETAFILE hmeta;
    ULONG   cjDevMode;

    DC_PLDC(hdc,pldc,0);

    MFD1("MFP_ResetDCW Called\n");

    pldc->fl |= LDC_RESETDC_CALLED;

// finally associate a new metafile since call to ResetDC could have changed
// the dimensions of the DC

    hmeta = UnassociateEnhMetaFile( hdc, FALSE );
    DeleteEnhMetaFile( hmeta );

    if( !AssociateEnhMetaFile( hdc ) )
    {
        WARNING("MFP_ResetDCW is unable to associate a new metafile\n");
        return(FALSE);
    }

    return(TRUE);
}

BOOL MFP_ResetBanding( HDC hdc, BOOL bBanding )
{
    PLDC           pldc;
    HENHMETAFILE   hmeta;
    DC_PLDC(hdc,pldc,0);

    if( pldc->fl & LDC_BANDING )
    {
    // we were banding before so we must remove the old metafile from the DC
    // since we might not be banding any more or the surface dimenstions could
    // have changed requiring us to have a new metafile

        hmeta = UnassociateEnhMetaFile( hdc, FALSE );
        DeleteEnhMetaFile( hmeta );

        pldc->fl &= ~(LDC_BANDING|LDC_META_PRINT);

        MFD1("Remove old banding metafile\n");

    }

    if( bBanding )
    {
    // if we are banding after the ResetDC then we must attach a new metafile

        if( !AssociateEnhMetaFile(hdc) )
        {
            WARNING("MFP_ResetBanding: Failed to attach banding metafile spool metafile");
            return(FALSE);
        }

        pldc->fl |= LDC_BANDING|LDC_META_PRINT;

        MFD1("Adding new banding metafile\n");
    }

    return(TRUE);
}

/****************************************************************************
*  BOOL MyReadPrinter( HANDLE hPrinter, BYTE *pjBuf, ULONG cjBuf )
*
*   Read a requested number of bytes from the spooler.
*
*  History:
*   5/12/1995 by Gerrit van Wingerden [gerritv]  - Author
*
*   5/1/1997 by Ramanathan N Venkatapathy [ramanv]
*                 Modified to synchronously wait during Print while spooling.
*                 SeekPrinter sets last error when spool file isn't big enough.
*****************************************************************************/

BOOL MyReadPrinter( HANDLE hPrinter, BYTE *pjBuf, ULONG cjBuf )
{
    ULONG          cjRead;
    LARGE_INTEGER  liOffset;

    ASSERTGDI(ghSpooler,"non null hSpooler with unloaded WINSPOOL\n");

    // Wait till enough bytes have been written.
    liOffset.QuadPart = cjBuf;
    if (!(*fpSeekPrinter) (hPrinter, liOffset, NULL, FILE_CURRENT, FALSE)) {
        return FALSE;
    }

    // Seek back to the original position in the spoolfile.
    liOffset.QuadPart = -liOffset.QuadPart;
    if (!(*fpSeekPrinter) (hPrinter, liOffset, NULL, FILE_CURRENT, FALSE)) {
        return FALSE;
    }

    while( cjBuf )
    {
        if(!(*fpReadPrinter)( hPrinter, pjBuf, cjBuf, &cjRead ) )
        {
            WARNING("MyReadPrinter: Read printer failed\n");
            return(FALSE);
        }

        if( cjRead == 0 )
        {
            return(FALSE);
        }

        pjBuf += cjRead;
        cjBuf -= cjRead;

    }
    return(TRUE);
}

BOOL MemMapReadPrinter(
    HANDLE  hPrinter,
    LPBYTE  *pBuf,
    ULONG   cbBuf
)
{
   LARGE_INTEGER  liOffset;

   ASSERTGDI(ghSpooler,"non null hSpooler with unloaded WINSPOOL\n");

   // Memory mapped ReadPrinter not exported.
   if (!fpSplReadPrinter) {
       return FALSE;
   }

   // Wait till enough bytes have been written.
   liOffset.QuadPart = cbBuf;
   if (!(*fpSeekPrinter) (hPrinter, liOffset, NULL, FILE_CURRENT, FALSE)) {
       return FALSE;
   }

   // Seek back to the original position in the spoolfile.
   liOffset.QuadPart = -liOffset.QuadPart;
   if (!(*fpSeekPrinter) (hPrinter, liOffset, NULL, FILE_CURRENT, FALSE)) {
       return FALSE;
   }

   if(!(*fpSplReadPrinter) (hPrinter, pBuf, (DWORD) cbBuf)) {
       WARNING("MemMapReadPrinter: Read printer failed\n");
       return FALSE;
   }

   return TRUE;
}

BOOL WINAPI GdiPlayEMF(
    LPWSTR     pwszPrinterName,
    LPDEVMODEW pDevmode,
    LPWSTR     pwszDocName,
    EMFPLAYPROC pfnEMFPlayFn,
    HANDLE     hPageQuery
)
/*++
Function Description:
         GdiPlayEMF is the old playback function. It has been replaced by a
         bunch of new GDI interfaces which give more flexibility to the print
         processor on placing and reordering the pages of the print job. This
         function has been rewritten to use these new interfaces (for backward
         compatibility and maintainance)

Parameters:

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         8/15/1997 by Ramanathan N Venkatapathy [ramanv]

--*/
{
    HANDLE     hSpoolHandle, hEMF;
    HDC        hPrinterDC;
    BOOL       bReturn = FALSE;
    DOCINFOW   DocInfo;
    DWORD      dwPageType, dwPageNumber = 1;
    RECT       rectDocument;
    LPDEVMODEW pCurrDM, pLastDM;

    if (!(hSpoolHandle = GdiGetSpoolFileHandle(pwszPrinterName,
                                               pDevmode,
                                               pwszDocName))    ||
        !(hPrinterDC   = GdiGetDC(hSpoolHandle))) {

         goto CleanUp;
    }

    DocInfo.cbSize = sizeof(DOCINFOW);
    DocInfo.lpszDocName  = pwszDocName;
    DocInfo.lpszOutput   = NULL;
    DocInfo.lpszDatatype = NULL;

    rectDocument.left = rectDocument.top = 0;
    rectDocument.right  = GetDeviceCaps(hPrinterDC, DESKTOPHORZRES);
    rectDocument.bottom = GetDeviceCaps(hPrinterDC, DESKTOPVERTRES);

    if (!GdiStartDocEMF(hSpoolHandle, &DocInfo)) {
         goto CleanUp;
    }

    while (1) {

       hEMF = GdiGetPageHandle(hSpoolHandle,
                               dwPageNumber,
                               &dwPageType);

       if (!hEMF) {
          if (GetLastError() == ERROR_NO_MORE_ITEMS) {
             break;
          } else {
             goto CleanUp;
          }
       }

       if (!GdiGetDevmodeForPage(hSpoolHandle, dwPageNumber,
                                 &pCurrDM, &pLastDM)) {
             goto CleanUp;
       }

       if ((pCurrDM != pLastDM) && !GdiResetDCEMF(hSpoolHandle,
                                                  pCurrDM)) {
             goto CleanUp;
       }

       if (!SetGraphicsMode(hPrinterDC, GM_ADVANCED)) {

           goto CleanUp;
       }

       if (!GdiStartPageEMF(hSpoolHandle) ||
           !GdiPlayPageEMF(hSpoolHandle, hEMF, &rectDocument, NULL, NULL) ||
           !GdiEndPageEMF(hSpoolHandle, 0)) {

             goto CleanUp;
       }

       ++dwPageNumber;
    }

    GdiEndDocEMF(hSpoolHandle);

    bReturn = TRUE;

CleanUp:

    if (hSpoolHandle) {
        GdiDeleteSpoolFileHandle(hSpoolHandle);
    }

    return bReturn;
}


BOOL WINAPI GdiDeleteSpoolFileHandle(
    HANDLE SpoolFileHandle)

/*
Function Description:
         GdiDeleteSpoolFileHandle frees all the resources allocated by GDI for printing
         the corresponding job. This function should be called by the print processor just
         before it returns.

Parameters:
         SpoolFileHandle - Handle returned by GdiGetSpoolFileHandle.

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/12/1995 by Gerrit van Wingerden [gerritv] - Author

         5/15/1997 by Ramanathan N Venkatapathy [ramanv] -
              Freed more resources associated with the SpoolFileHandle
*/

{
    SPOOL_FILE_HANDLE   *pSpoolFileHandle;
    LPDEVMODEW          pLastDevmode;
    UINT                PageCount;
    PRECORD_INFO_STRUCT pRecordInfo = NULL, pRecordInfoFree = NULL;
    DWORD               dwIndex;
    PEMF_HANDLE         pTemp;

    pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

    // first check to see if this is a valid handle by checking for the tag

    try
    {
        if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
        {
            WARNING("GdiDeleteSpoolFileHandle: invalid handle\n");
            return(FALSE);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("GdiDeleteSpoolFileHandle: exception accessing handle\n");
        return(FALSE);
    }

    // Loop through all the page records, find the last page on which each DEVMODE is used
    // and free it.  The first DEVMODE is always allocated along with the memory for
    // the spool file handle so never free that one. All DEVMODEs different than the original one
    // must be non-NULL since they appear in the spool file.

    for(PageCount = 0, pLastDevmode = pSpoolFileHandle->pOriginalDevmode;
        PageCount < pSpoolFileHandle->MaxPageProcessed;
        PageCount += 1 )
    {
        if(pSpoolFileHandle->pPageInfo[PageCount].pDevmode != pLastDevmode)
        {
            if(pLastDevmode != pSpoolFileHandle->pOriginalDevmode)
            {
                LocalFree(pLastDevmode);
            }

            pLastDevmode = pSpoolFileHandle->pPageInfo[PageCount].pDevmode;
        }
    }

    // free the last DEVMODE used if it is not the original DEVMODE

    if(pLastDevmode != pSpoolFileHandle->pOriginalDevmode)
    {
        LocalFree(pLastDevmode);
    }

    // free the PAGE_INFO_STRUCT array and lists held in them

    if (pSpoolFileHandle->pPageInfo) {

       for (dwIndex = pSpoolFileHandle->MaxPageProcessed; dwIndex; --dwIndex) {

           pRecordInfo = pSpoolFileHandle->pPageInfo[dwIndex-1].pRecordInfo;

           while (pRecordInfoFree = pRecordInfo) {
              pRecordInfo = pRecordInfo->pNext;
              LocalFree(pRecordInfoFree);
           }

       }
       LocalFree(pSpoolFileHandle->pPageInfo);
    }

    // free the list of EMF_HANDLEs returned to the print processor

    while (pTemp = pSpoolFileHandle->pEMFHandle) {
       pSpoolFileHandle->pEMFHandle = (pSpoolFileHandle->pEMFHandle)->pNext;
       if (pTemp->hemf) {
          InternalDeleteEnhMetaFile(pTemp->hemf, pTemp->bAllocBuffer);
       }
       LocalFree(pTemp);
    }

    // free the DC

    DeleteDC(pSpoolFileHandle->hdc);

    // then the spooler's spool handle

    (*fpClosePrinter)(pSpoolFileHandle->hSpooler);

    // finally free the data associated with this handle

    LocalFree(pSpoolFileHandle);

    return(TRUE);
}


HANDLE WINAPI GdiGetSpoolFileHandle(
    LPWSTR pwszPrinterName,
    LPDEVMODEW pDevmode,
    LPWSTR pwszDocName)
/*
Function Description:
         GdiGetSpoolFileHandle is the first function that should be called by the
         print processor. It returns a handle that will be needed for all the
         subsequent calls. The function performs initializations of opening the
         printer, creating a device context and allocating memory for the handle.

Parameters:
         pwszPrinterName - Identifies the printer on which the job is to printed.
         pDevmode - Pointer to a DEVMODE structure.
         pwszDocName - Identifies the document name of job.

Return Values:
         If the function succeeds, the return value is a valid HANDLE;
         otherwise the result is NULL.

History:
         5/12/1995 by Gerrit van Wingerden [gerritv] - Author

         5/15/1997 by Ramanathan N Venkatapathy [ramanv] -
              Handled NULL devmode case.
*/
{
    SPOOL_FILE_HANDLE *pHandle;

    if( !BLOADSPOOLER )
    {
        WARNING("GdiGetSpoolFileHandle: Unable to load spooler\n");
        return(FALSE);
    }

    if(pHandle = LOCALALLOC(sizeof(SPOOL_FILE_HANDLE) +
                            ((pDevmode != NULL) ? pDevmode->dmSize+pDevmode->dmDriverExtra
                                                : 0 )))
    {
        // Zero out the SPOOL_FILE_HANDLE
        RtlZeroMemory(pHandle , sizeof(SPOOL_FILE_HANDLE) +
                                  ((pDevmode != NULL) ? pDevmode->dmSize+pDevmode->dmDriverExtra
                                                      : 0));

        if((*fpOpenPrinterW)(pwszDocName, &pHandle->hSpooler,
                             (LPPRINTER_DEFAULTSW) NULL ) &&
           pHandle->hSpooler)
        {
            if(pHandle->hdc = CreateDCW(L"", pwszPrinterName, L"", pDevmode))
            {
                pHandle->PageInfoBufferSize = 20;

                if(pHandle->pPageInfo = LOCALALLOC(sizeof(PAGE_INFO_STRUCT) *
                                                   pHandle->PageInfoBufferSize))
                {
                    pHandle->tag = SPOOL_FILE_HANDLE_TAG;

                    if (pDevmode) {
                        pHandle->pOriginalDevmode = (LPDEVMODEW) (pHandle + 1);
                        memcpy(pHandle->pOriginalDevmode, pDevmode,pDevmode->dmSize+pDevmode->dmDriverExtra);
                    } else {
                        pHandle->pOriginalDevmode = NULL;
                    }

                    pHandle->pLastDevmode = pHandle->pOriginalDevmode;
                    pHandle->MaxPageProcessed = 0;
                    pHandle->pEMFHandle = NULL;
                    RtlZeroMemory(pHandle->pPageInfo,
                                  sizeof(PAGE_INFO_STRUCT) * pHandle->PageInfoBufferSize);

                    pHandle->dwPlayBackStatus = EMF_PLAY_FORCE_MONOCHROME;
                    if (pHandle->pLastDevmode &&
                        (pHandle->pLastDevmode->dmFields & DM_COLOR) &&
                        (pHandle->pLastDevmode->dmColor == DMCOLOR_COLOR)) {

                        pHandle->dwPlayBackStatus = EMF_PLAY_COLOR;
                    }
                    pHandle->bUseMemMap = TRUE;

                    return((HANDLE) pHandle);
                }
                else
                {
                    WARNING("GdiGetSpoolFileHandle: OutOfMemory\n");
                }

                DeleteDC(pHandle->hdc);
            }
            else
            {
                WARNING("GdiGetSpoolHandle: CreateDCW failed\n");
            }

            (*fpClosePrinter)(pHandle->hSpooler);
        }

        LocalFree(pHandle);
    }

    return((HANDLE) NULL);
}

BOOL ProcessJob(
    SPOOL_FILE_HANDLE *pSpoolFileHandle
)
{
    LARGE_INTEGER      LargeInt;
    EMFSPOOLHEADER     emsh;
    EMFITEMHEADER      emfi;

// Seek to offset 0.

    LargeInt.QuadPart = 0;
    if (!((*fpSeekPrinter)(pSpoolFileHandle->hSpooler, LargeInt, NULL, 0,FALSE)))
    {
        WARNING("GDI32 ProcessJob: seek printer to 0 failed\n");
        return(FALSE);
    }

// Read EMFSPOOLHEADER

    if(!MyReadPrinter(pSpoolFileHandle->hSpooler, (BYTE*) &emsh, sizeof(emsh)))
    {
        WARNING("GDI32 ProcessJob: MyReadPrinter to read EMFSPOOLHEADER failed\n");
        return(FALSE);
    }

// Move Offset to next record.

    LargeInt.QuadPart = emsh.cjSize;
    if (!((*fpSeekPrinter)(pSpoolFileHandle->hSpooler, LargeInt, NULL, 0,FALSE)))
    {
        WARNING("GDI32 ProcessPages: seek printer failed\n");
        return(FALSE);
    }

// Read next EMFITEMHEADER

    if(!MyReadPrinter(pSpoolFileHandle->hSpooler, (BYTE*) &emfi, sizeof(emfi)))
    {
        WARNING("GDI32 ProcessJob: MyReadPrinter to read EMFSPOOLHEADER failed\n");
        return(FALSE);
    }

// If this is EMRI_PS_JOB_DATA, process this record.

    if (emfi.ulID == EMRI_PS_JOB_DATA)
    {
        PBYTE pPSBuffer = LOCALALLOC(emfi.cjSize);

        if (pPSBuffer)
        {
            if (MyReadPrinter(pSpoolFileHandle->hSpooler, pPSBuffer, emfi.cjSize))
            {
                DWORD cjSizeProcessed = 0;
                PEMFITEMPSINJECTIONDATA pPSData = (PEMFITEMPSINJECTIONDATA) pPSBuffer;

                while (cjSizeProcessed < emfi.cjSize)
                {
                    ExtEscape(pSpoolFileHandle->hdc,
                              pPSData->nEscape,
                              pPSData->cjInput,
                              (PVOID)&(pPSData->EscapeData),
                              0, NULL);

                    cjSizeProcessed += pPSData->cjSize;

                    // Move to next record.

                    pPSData = (PEMFITEMPSINJECTIONDATA) ((PBYTE)pPSData + pPSData->cjSize);
                }
            }
            else
            {
                WARNING("GDI32 ProcessJob: MyReadPrinter to read EMFSPOOLHEADER failed\n");
                LOCALFREE(pPSBuffer);
                return(FALSE);
            }

            LOCALFREE(pPSBuffer);
        }
        else
        {
            WARNING("GDI32 ProcessJob: failed on LOCALALLOC\n");
            return(FALSE);
        }
    }

// Seek back to offset 0.

    LargeInt.QuadPart = 0;
    (*fpSeekPrinter)(pSpoolFileHandle->hSpooler, LargeInt, NULL, 0,FALSE);

    return (TRUE);
}

BOOL ProcessPages(
    SPOOL_FILE_HANDLE *pSpoolFileHandle,
    UINT LastPage
)
/*
Function Description:
         ProcessPages parses the spool file and processes the EMF records until the
         required page.

Parameters:
         SpoolFileHandle - Handle returned by GdiGetSpoolFileHandle.
         LastPage - Page number to process.

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/12/1995 by Gerrit van Wingerden [gerritv] - Author

         5/15/1997 by Ramanathan N Venkatapathy [ramanv] -
                Added code to handle DELTA_FONT, SUBSET_FONT, DESIGN_VECTOR
                and PRESTARTPAGE.

         1/28/1998 by Ramanathan N Venkatapathy [ramanv] -
                Process EXT records
*/
{
    LARGE_INTEGER      LargeInt;
    LONGLONG           CurrentOffset, EMFOffset;
    ULONG              CurrentPage;
    LPDEVMODEW         pLastDevmode = NULL;
    EMFITEMHEADER      emfi, emfiExt;
    BYTE               *pTmpBuffer = NULL;
    UNIVERSAL_FONT_ID  ufi;
    ULONG              ulBytesWritten;
    PVOID              pvMergeBuf;
    PRECORD_INFO_STRUCT pRecordInfo;
    BOOL               bReadPrinter = FALSE;
    INT64              iOffset;
    DWORD              dwSize;
    BOOL               bLastDevmodeAllocated = FALSE;

// early exit if we've already processed the requested number of pages

    if(pSpoolFileHandle->MaxPageProcessed >= LastPage)
    {
    	//When a document is being printed back-to-front and is restarted in 
    	//the middle of the job, we won't detect the error in the normal way.  
    	//So we call SeekPrinter with NOOP arguments to check for the 
    	//ERROR_PRINT_CANCELLED return value.

    	BOOL fSeekResult;
    	LargeInt.QuadPart = 0;
    	fSeekResult = ((*fpSeekPrinter)(pSpoolFileHandle->hSpooler, LargeInt, 
    		NULL, FILE_CURRENT, FALSE));
    	return fSeekResult || GetLastError() != ERROR_PRINT_CANCELLED;
    }

// allocate memory to store info for all pages if the existing buffer isn't large
// enough

    if(LastPage > pSpoolFileHandle->PageInfoBufferSize)
    {
        PAGE_INFO_STRUCT *pTemp;

        if(pTemp = LOCALALLOC(sizeof(PAGE_INFO_STRUCT) * LastPage))
        {
            RtlZeroMemory(pTemp, sizeof(PAGE_INFO_STRUCT) * LastPage);
            memcpy(pTemp,
                   pSpoolFileHandle->pPageInfo,
                   sizeof(PAGE_INFO_STRUCT) * pSpoolFileHandle->MaxPageProcessed);

            pSpoolFileHandle->PageInfoBufferSize = LastPage;
            LocalFree(pSpoolFileHandle->pPageInfo);
            pSpoolFileHandle->pPageInfo = pTemp;
        }
        else
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            WARNING("GDI32 ProcessPages: out of memory\n");
            return(FALSE);
        }
    }

// if we've already processed some pages then start with the last page processed

    if(pSpoolFileHandle->MaxPageProcessed)
    {
        CurrentOffset =
          pSpoolFileHandle->pPageInfo[pSpoolFileHandle->MaxPageProcessed-1].SeekOffset;

        pLastDevmode =
          pSpoolFileHandle->pPageInfo[pSpoolFileHandle->MaxPageProcessed-1].pDevmode;
    }
    else
    {
        EMFSPOOLHEADER emsh;

        LargeInt.QuadPart = 0;
        if (!((*fpSeekPrinter)(pSpoolFileHandle->hSpooler, LargeInt, NULL, 0,FALSE)))
        {
            WARNING("GDI32 ProcessPages: seek printer to 0 failed\n");
            return(FALSE);
        }

        if(!MyReadPrinter(pSpoolFileHandle->hSpooler, (BYTE*) &emsh, sizeof(emsh)))
        {
            WARNING("GDI32 ProcessPages: MyReadPrinter failed\n");
            return(FALSE);
        }

        CurrentOffset = emsh.cjSize;
        pLastDevmode = pSpoolFileHandle->pOriginalDevmode;
    }

    LargeInt.QuadPart = CurrentOffset;

    if (!((*fpSeekPrinter)(pSpoolFileHandle->hSpooler,
                          LargeInt, NULL,
                          0,FALSE)))
    {
        WARNING("GDI32 ProcessPages: seek printer failed\n");
        return(FALSE);
    }

    CurrentPage = pSpoolFileHandle->MaxPageProcessed;

    while ((CurrentPage < LastPage)    &&
            MyReadPrinter(pSpoolFileHandle->hSpooler, (BYTE*) &emfi, sizeof(emfi))) {

        CurrentOffset += sizeof(emfi);

        if (emfi.cjSize == 0)
        {
            continue;
        }

        bReadPrinter = FALSE;

        // For records to be processed now, read into a buffer

        if ((emfi.ulID == EMRI_DEVMODE)       ||
            (emfi.ulID == EMRI_ENGINE_FONT)   ||
            (emfi.ulID == EMRI_TYPE1_FONT)    ||
            (emfi.ulID == EMRI_SUBSET_FONT)   ||
            (emfi.ulID == EMRI_DELTA_FONT)    ||
            (emfi.ulID == EMRI_DESIGNVECTOR)) {

             if (pTmpBuffer = (BYTE*) LOCALALLOC(emfi.cjSize)) {

                 if(MyReadPrinter(pSpoolFileHandle->hSpooler,
                                  pTmpBuffer, emfi.cjSize)) {

                     bReadPrinter = TRUE;
                     dwSize = emfi.cjSize;

                 } else {

                     WARNING("Gdi32: Process Pages error reading font or devmode\n");
                     goto exit;
                 }

             } else {

                 WARNING("Out of memory in ProcessPages\n");
                 goto exit;
             }

        } else if ((emfi.ulID == EMRI_ENGINE_FONT_EXT)   ||
                   (emfi.ulID == EMRI_TYPE1_FONT_EXT)    ||
                   (emfi.ulID == EMRI_SUBSET_FONT_EXT)   ||
                   (emfi.ulID == EMRI_DELTA_FONT_EXT)    ||
                   (emfi.ulID == EMRI_DESIGNVECTOR_EXT)  ||
                   (emfi.ulID == EMRI_EMBED_FONT_EXT)) {

             // For EXT records get the buffer from an offset

             if (emfi.cjSize < sizeof(INT64)) {
                 WARNING("Ext Record bad size\n");
                 goto exit;
             }

             if (MyReadPrinter(pSpoolFileHandle->hSpooler, (PBYTE) &iOffset, sizeof(INT64)) &&
                 (iOffset > 0)) {

                 LargeInt.QuadPart = -1 * (iOffset + sizeof(emfi) + sizeof(INT64));

                 if ((*fpSeekPrinter)(pSpoolFileHandle->hSpooler,
                                      LargeInt, NULL, FILE_CURRENT, FALSE) &&
                     MyReadPrinter(pSpoolFileHandle->hSpooler, (BYTE*) &emfiExt,
                                   sizeof(emfiExt))) {

                     if (pTmpBuffer = (BYTE*) LOCALALLOC(emfiExt.cjSize)) {

                         if (!MyReadPrinter(pSpoolFileHandle->hSpooler,
                                            pTmpBuffer, emfiExt.cjSize)) {

                             WARNING("Gdi32: Process Pages error reading font or devmode\n");
                             goto exit;
                         }

                         dwSize = emfiExt.cjSize;

                     } else {

                         WARNING("Out of memory in ProcessPages\n");
                         goto exit;
                     }

                     // We will seek back to the correct position after the switch
                 } else {
                     WARNING("SeekPrinter or MyReadPrinter fail in ProcessPages\n");
                     goto exit;
                 }
             } else {
                 WARNING("MyReadPrinter fails in ProcessPages\n");
                 goto exit;
             }

        }

        switch (emfi.ulID)
        {
        case EMRI_METAFILE:
        case EMRI_FORM_METAFILE:
        case EMRI_BW_METAFILE:
        case EMRI_BW_FORM_METAFILE:

            // it's a metafile so setup an entry for it

            pSpoolFileHandle->pPageInfo[CurrentPage].pDevmode = pLastDevmode;
            pSpoolFileHandle->pPageInfo[CurrentPage].EMFOffset = CurrentOffset;
            pSpoolFileHandle->pPageInfo[CurrentPage].SeekOffset = CurrentOffset + emfi.cjSize;
            pSpoolFileHandle->pPageInfo[CurrentPage].EMFSize = emfi.cjSize;
            pSpoolFileHandle->pPageInfo[CurrentPage].ulID = emfi.ulID;
            pSpoolFileHandle->MaxPageProcessed += 1;
            bLastDevmodeAllocated = FALSE;

            CurrentPage += 1;
            break;

        case EMRI_METAFILE_EXT:
        case EMRI_BW_METAFILE_EXT:

            // it's a metafile at an offset

            if (emfi.cjSize < sizeof(INT64)) {
                WARNING("Ext Record bad size\n");
                goto exit;
            }

            if (MyReadPrinter(pSpoolFileHandle->hSpooler, (PBYTE) &iOffset, sizeof(INT64)) &&
                (iOffset > 0)) {

                LargeInt.QuadPart = -1 * (iOffset + sizeof(emfi) + sizeof(INT64));

                if ((*fpSeekPrinter)(pSpoolFileHandle->hSpooler,
                                     LargeInt, NULL, FILE_CURRENT, FALSE) &&
                    MyReadPrinter(pSpoolFileHandle->hSpooler, (BYTE*) &emfiExt,
                                  sizeof(emfiExt))) {

                    pSpoolFileHandle->pPageInfo[CurrentPage].pDevmode = pLastDevmode;
                    bLastDevmodeAllocated = FALSE;

                    EMFOffset = CurrentOffset - (LONGLONG) iOffset;
                    if (EMFOffset) {
                        pSpoolFileHandle->pPageInfo[CurrentPage].EMFOffset = EMFOffset;
                    } else {
                        WARNING("Bad Ext Record\n");
                        goto exit;
                    }
                    pSpoolFileHandle->pPageInfo[CurrentPage].SeekOffset =
                                                               CurrentOffset + emfi.cjSize;
                    pSpoolFileHandle->pPageInfo[CurrentPage].EMFSize = emfiExt.cjSize;
                    pSpoolFileHandle->pPageInfo[CurrentPage].ulID =
                                  (emfi.ulID == EMRI_METAFILE_EXT) ? EMRI_METAFILE
                                                                   : EMRI_BW_METAFILE;
                    pSpoolFileHandle->MaxPageProcessed += 1;

                    CurrentPage += 1;
                    break;

                    // We will seek back to the correct position after the switch
                }
            }

            WARNING("ReadPrinter or SeekPrinter failed\n");
            goto exit;

        case EMRI_DEVMODE:

            if (!(*fpIsValidDevmodeW)((LPDEVMODEW) pTmpBuffer, dwSize))
            {
                EMFVALFAIL(("ProcessPages: fpIsValidDevmodeW failed\n"));
                goto exit;
            }

            pLastDevmode = (LPDEVMODEW) pTmpBuffer;
            pTmpBuffer = NULL;
            bLastDevmodeAllocated = TRUE;
            break;

        case EMRI_METAFILE_DATA:

            // Start of EMF data. Wait till EMRI_(BW_)METAFILE_EXT so that fonts can
            // be correctly processed
            break;

        case EMRI_ENGINE_FONT:
        case EMRI_ENGINE_FONT_EXT:
        case EMRI_TYPE1_FONT:
        case EMRI_TYPE1_FONT_EXT:

            if (!NtGdiAddRemoteFontToDC(pSpoolFileHandle->hdc,
                                        pTmpBuffer, dwSize , NULL))
            {
                WARNING("Error adding remote font\n");
                goto exit;
            }

            if ((emfi.ulID == EMRI_TYPE1_FONT) ||
                (emfi.ulID == EMRI_TYPE1_FONT_EXT))
            {
                // force ResetDC so Type1 fonts get loaded
                pSpoolFileHandle->pLastDevmode = NULL;
            }

            break;

        case EMRI_SUBSET_FONT:
        case EMRI_SUBSET_FONT_EXT:

            if (bMergeSubsetFont(pSpoolFileHandle->hdc, pTmpBuffer, dwSize,
                                 &pvMergeBuf, &ulBytesWritten, FALSE, &ufi)) {

                 if (!NtGdiAddRemoteFontToDC(pSpoolFileHandle->hdc, pvMergeBuf,
                                             ulBytesWritten, &ufi)) {
                    WARNING("Error adding subsetted font\n");
                 }

            } else {

                 WARNING("Error merging subsetted fonts\n");
            }

            break;

        case EMRI_DELTA_FONT:
        case EMRI_DELTA_FONT_EXT:

            if (bMergeSubsetFont(pSpoolFileHandle->hdc, pTmpBuffer, dwSize,
                                 &pvMergeBuf, &ulBytesWritten, TRUE, &ufi)) {

               if (NtGdiRemoveMergeFont(pSpoolFileHandle->hdc, &ufi)) {

                   if (!NtGdiAddRemoteFontToDC(pSpoolFileHandle->hdc, pvMergeBuf,
                                               ulBytesWritten, &ufi)) {

                       WARNING("Error adding subsetted font\n");

                   }

               } else {

                   WARNING("Error removing merged font\n");
               }

            } else {

               WARNING("Error merging subsetted fonts\n");
            }

            break;

        case EMRI_DESIGNVECTOR:
        case EMRI_DESIGNVECTOR_EXT:

            MFD1("Unpackaging designvector \n");

            if (!NtGdiAddRemoteMMInstanceToDC(pSpoolFileHandle->hdc,
                                              (DOWNLOADDESIGNVECTOR *) pTmpBuffer,
                                              dwSize)) {

                WARNING("Error adding remote mm instance font\n");

            }

            break;

        case EMRI_EMBED_FONT_EXT:
            
            MFD1("Unpackaging embed fonts\n");

            if (!NtGdiAddEmbFontToDC(pSpoolFileHandle->hdc,(VOID **) pTmpBuffer))
            {
                WARNING("Error adding embed font to DC\n");
            }

            break;

        case EMRI_PRESTARTPAGE:

            if (!(pRecordInfo =
                    (PRECORD_INFO_STRUCT) LOCALALLOC(sizeof(RECORD_INFO_STRUCT)))) {

                WARNING("Out of memory in ProcessPages\n");
                goto exit;
            }

            pRecordInfo->pNext = pSpoolFileHandle->pPageInfo[CurrentPage].pRecordInfo;
            pSpoolFileHandle->pPageInfo[CurrentPage].pRecordInfo = pRecordInfo;

            pRecordInfo->RecordID = emfi.ulID;
            pRecordInfo->RecordSize = emfi.cjSize;
            pRecordInfo->RecordOffset = CurrentOffset;

            break;

        case EMRI_PS_JOB_DATA:

            // Already processed at GdiStartDocEMF().

            break;

        default:

            WARNING("GDI32: ProcessPages: Unknown ITEM record\n");
            goto exit;
            break;
        }

        if (emfi.ulID == EMRI_METAFILE || emfi.ulID == EMRI_FORM_METAFILE)
        {
            ENHMETAHEADER *pemrh = ( ENHMETAHEADER *)&emfi;
            CurrentOffset += pemrh->nBytes - sizeof(emfi);
        }
        else
        {
            CurrentOffset += emfi.cjSize;
        }
        LargeInt.QuadPart = CurrentOffset;

        if(!bReadPrinter && !(*fpSeekPrinter)(pSpoolFileHandle->hSpooler,
                                              LargeInt, NULL, 0, FALSE))
        {
            WARNING("GDI32 Process Pages: seekprinter failed\n");
            goto exit;
        }

        //
        // Release temp buffer each time through the loop.
        //
        if(pTmpBuffer)
        {
            LocalFree(pTmpBuffer);
            pTmpBuffer = NULL;
        }
    }

exit:

    //
    // Release the temp buffer, it is a temp so it should not
    // live beyond this subroutine.
    //
    if(pTmpBuffer)
    {
        LocalFree(pTmpBuffer);
    }

    //
    // Only release the last devmode pointer if one was allocated.
    //
    if(pLastDevmode && bLastDevmodeAllocated)
    {
        LocalFree(pLastDevmode);
    }

    return(CurrentPage >= LastPage);
}

HDC WINAPI GdiGetDC(
    HANDLE SpoolFileHandle)

/*
Function Description:
         GdiGetDC returns a handle to the device context of the printer.
         This handle can be used to apply transformations (translation, rotation, scaling etc)
         before playing any page at the printer

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle

Return Values:
         If the function succeeds, the return value is a valid HANDLE;
         otherwise the result is NULL.

History:
         5/12/1995 by Gerrit van Wingerden [gerritv] - Author
*/

{
    SPOOL_FILE_HANDLE *pSpoolFileHandle;
    pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

    // first check to see if this is a valid handle by checking for the tag

    try
    {
        if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
        {
            WARNING("GdiGetDC: invalid handle\n");
            return(NULL);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("GdiGetDC: exception accessing handle\n");
        return(NULL);
    }

    return(pSpoolFileHandle->hdc);
}


DWORD WINAPI GdiGetPageCount(
     HANDLE SpoolFileHandle)

/*
Function Description:
         GdiGetPageCount returns the number of pages in the print job. If print
         while spooling option is used, GdiGetPageCount synchronously waits till
         the job is completely spooled and then returns the page count.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle

Return Values:
         If the function succeeds, the return value is the page count
         otherwise the result is 0.

History:
         5/12/1995 by Gerrit van Wingerden [gerritv] - Author
*/

{
    UINT Page = 10;
    LARGE_INTEGER LargeInt;
    SPOOL_FILE_HANDLE *pSpoolFileHandle;

    pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

    // first check to see if this is a valid handle by checking for the tag

    try
    {
        if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
        {
            WARNING("GdiGetPageCount: invalid handle\n");
            return 0;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("GdiGetPageCount: exception accessing handle\n");
        return 0;
    }


    while(ProcessPages(pSpoolFileHandle, Page))
    {
        Page += 10;
    }

    LargeInt.QuadPart = 0;

    if(!(*fpSeekPrinter)(pSpoolFileHandle->hSpooler, LargeInt, NULL, 0,
                         FALSE))
    {
        WARNING("GDI32 GdiGetPageCount: seek failed\n");
        return 0;
    }

    return ((DWORD) pSpoolFileHandle->MaxPageProcessed);
}


HANDLE WINAPI GdiGetPageHandle(
    HANDLE SpoolFileHandle,
    DWORD Page,
    LPDWORD pdwPageType)

/*
Function Description:
         GdiGetPageHandle returns a handle to contents of the required page.
         This handle should be used while playing the page at the printer. If the
         spool file is not sufficiently large, the last error is set to ERROR_NO_MORE_ITEMS.
         If print while spooling is supported, the print processor will have to examine
         for this error code to determine the end of the print job. Using GdiGetPageCount
         will stall the processing till the entire print job is spooled.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle
         Page               -- number of the page required
         pdwPageType        -- pointer to store the type of the page (Normal/Watermark)

Return Values:
         If the function succeeds, the return value is a valid HANDLE;
         otherwise the result is NULL.

History:
         5/12/1995 by Gerrit van Wingerden [gerritv] - Author

         5/15/1997 by Ramanathan N Venkatapathy [ramanv] -
             Changed the return value to a HANDLE that contains the page number along
             with the handle to the EMF file
*/

{
    SPOOL_FILE_HANDLE *pSpoolFileHandle;
    PEMF_HANDLE  pEMF = NULL;

    pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

    // first check to see if this is a valid handle by checking for the tag

    try
    {
        if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
        {
            WARNING("GdiGetPageHandle: invalid handle\n");
            return(FALSE);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("GdiGetPageHandle: exception accessing handle\n");
        return(NULL);
    }

    if(!ProcessPages(pSpoolFileHandle, (UINT) Page))
    {
        return(NULL);
    }

    if (pEMF = (PEMF_HANDLE) LOCALALLOC(sizeof(EMF_HANDLE))) {

         pEMF->tag = EMF_HANDLE_TAG;
         pEMF->hemf = NULL;
         pEMF->bAllocBuffer = FALSE;
         pEMF->dwPageNumber = Page;

         if (pdwPageType) {
            switch (pSpoolFileHandle->pPageInfo[Page-1].ulID) {

            case EMRI_METAFILE:
            case EMRI_BW_METAFILE:

                 *pdwPageType = EMF_PP_NORMAL;
                 break;

            case EMRI_FORM_METAFILE:
            case EMRI_BW_FORM_METAFILE:

                 *pdwPageType = EMF_PP_FORM;
                 break;

            default:
                 // should not occur
                 *pdwPageType = 0;
                 break;
            }
         }

         // Save the handle in spoolfilehandle to be freed later
         pEMF->pNext = pSpoolFileHandle->pEMFHandle;
         pSpoolFileHandle->pEMFHandle = pEMF;

    } else {
         WARNING("GDI32 GdiGetPageHandle: out of memory\n");
    }

    return ((HANDLE) pEMF);
}

BOOL WINAPI GdiStartDocEMF(
    HANDLE      SpoolFileHandle,
    DOCINFOW    *pDocInfo)

/*
Function Description:
         GdiStartDocEMF performs the initializations required for before printing
         a document. It calls StartDoc and allocates memory to store data about the
         page layout. It also sets up the banding field in the SpoolFileHandle.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle
         pDocInfo           -- pointer to DOCINFOW struct containing information of
                               the job. This struct is required for StartDoc.

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
   SPOOL_FILE_HANDLE *pSpoolFileHandle;

   pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

   // first check to see if this is a valid handle by checking for the tag

   try
   {
       if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
       {
           WARNING("GdiStartDocEMF: invalid handle\n");
           return(FALSE);
       }
   }
   except(EXCEPTION_EXECUTE_HANDLER)
   {
       WARNING("GdiStartDocEMF: exception accessing handle\n");
       return(FALSE);
   }

   // Process Job data (before StartDoc)
   if (!ProcessJob(pSpoolFileHandle))
   {
        WARNING("StartDocW failed at ProcessJob\n");
        return(FALSE);
   }

   // StartDoc and get banding information
   if (StartDocEMF(pSpoolFileHandle->hdc,
                   pDocInfo,
                   &(pSpoolFileHandle->bBanding)) == SP_ERROR) {
        WARNING("StartDocW failed at StartDocEMF\n");
        return(FALSE);
   }

   pSpoolFileHandle->dwNumberOfPagesInCurrSide = 0;
   pSpoolFileHandle->dwNumberOfPagesAllocated = SPOOL_FILE_MAX_NUMBER_OF_PAGES_PER_SIDE;

   // Allocate memory for page layout
   if (!(pSpoolFileHandle->pPageLayout = LOCALALLOC(sizeof(PAGE_LAYOUT_STRUCT) *
                                              pSpoolFileHandle->dwNumberOfPagesAllocated))) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        WARNING("GDI32 GdiStartDocEMF: out of memory\n");
        return(FALSE);
   }

   return(TRUE);

}

BOOL WINAPI GdiStartPageEMF(
    HANDLE       SpoolFileHandle)

/*
Function Description:
         GdiStartPageEMF performs the initializations required before printing
         a page.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
   SPOOL_FILE_HANDLE *pSpoolFileHandle;

   pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

   // first check to see if this is a valid handle by checking for the tag
   try
   {
       if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
       {
           WARNING("GdiStartPageEMF: invalid handle\n");
           return(FALSE);
       }
   }
   except(EXCEPTION_EXECUTE_HANDLER)
   {
       WARNING("GdiStartPageEMF: exception accessing handle\n");
       return(FALSE);
   }

   return(TRUE);
}

BOOL WINAPI GdiPlayPageEMF(
    HANDLE       SpoolFileHandle,
    HANDLE       hEMF,
    RECT         *prectDocument,
    RECT         *prectBorder,
    RECT         *prectClip)

/*
Function Description:
         GdiPlayPageEMF allows the print processor to play any EMF page inside a
         specified rectangle. It also draws a border around the page, if one is specified.
         GdiPlayPageEMF saves all the information required for playing the page in the
         SpoolFileHandle. When GdiEndPageEMF is called to eject the current physical page,
         all the logical pages are played in the correct positions and the page is ejected.
         This delayed printing operation is used to enable n-up printing with banding.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle
         hEMF               -- handle returned by GdiGetEMFFromSpoolHandle
         prectDocument      -- pointer to the RECT containing coordinates where
                               the page is to be played
         prectBorder        -- pointer to the RECT containing coordinates where
                               the border (if any) is to be drawn
         prectClip          -- pointer to the RECT containing coordinates where
                               the page is to clipped

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
   SPOOL_FILE_HANDLE  *pSpoolFileHandle;
   PAGE_LAYOUT_STRUCT *pPageLayout;
   PEMF_HANDLE         pEMF;
   LPBYTE              pBuffer = NULL;
   HANDLE              hFile = NULL;
   BOOL                bAllocBuffer = FALSE;
   ULONG               Size;
   LARGE_INTEGER       Offset;
   HENHMETAFILE        hEMFPage = NULL;
   DWORD               dwPageNumber;

   pEMF = (PEMF_HANDLE) hEMF;

   pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

   // first check to see if this is a valid handle by checking for the tag

   try
   {
       if ((pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG) ||
           (pEMF->tag != EMF_HANDLE_TAG))
       {
           WARNING("GdiPlayPageEMF: invalid handle\n");
           return(FALSE);
       }

   }
   except(EXCEPTION_EXECUTE_HANDLER)
   {
       WARNING("GdiPlayPageEMF: exception accessing handle\n");
       return(FALSE);
   }

   dwPageNumber = pEMF->dwPageNumber;

   if (pEMF->hemf == NULL) {

       // Allocate the EMF handle
       Size = pSpoolFileHandle->pPageInfo[dwPageNumber-1].EMFSize;
       Offset.QuadPart = pSpoolFileHandle->pPageInfo[dwPageNumber-1].EMFOffset;

       // Use memory mapped read first and buffered next
       if (pSpoolFileHandle->bUseMemMap) {

          if ((*fpSeekPrinter) (pSpoolFileHandle->hSpooler, Offset, NULL, 0, FALSE) &&
              MemMapReadPrinter(pSpoolFileHandle->hSpooler, &pBuffer, Size)) {

               hEMFPage = SetEnhMetaFileBitsAlt((HLOCAL)pBuffer, NULL, NULL, 0);
          }
          else
          {
              WARNING("GdiPlayPageEMF() Failed to get memory map pointer to EMF\n");
          }
       }

       #define kTempSpoolFileThreshold  0x100000
       #define kScratchBufferSize       0x10000
       
       if (hEMFPage == NULL && Size > kTempSpoolFileThreshold) {

           // if larger then a meg, attempt create a temporary spool file
           // and copy the page to the spool file

           WARNING("GdiPlayPageEMF() Page size is large using temporary spool file\n");

           // If memory mapped read didnt work, dont try it again

           pSpoolFileHandle->bUseMemMap = FALSE;

           hFile = CreateTempSpoolFile();

           if(hFile != INVALID_HANDLE_VALUE)
           {
               if(fpSeekPrinter(pSpoolFileHandle->hSpooler, Offset, NULL, 0, FALSE))
               {
                   PVOID pvScratch = LocalAlloc(LMEM_FIXED, kScratchBufferSize);

                   if(pvScratch)
                   {
                       ULONG dwOffset = 0;
                       
                       while(dwOffset < Size)
                       {
                           ULONG    dwSize = MIN(kScratchBufferSize, (Size - dwOffset));
                           ULONG    dwBytesWritten;

                           if(!MyReadPrinter(pSpoolFileHandle->hSpooler, pvScratch, dwSize))
                           {
                               WARNING("GdiPlayPageEMF() Failed reading from spooler\n");
                               break;
                           }

                           if(!WriteFile(hFile, pvScratch, dwSize, &dwBytesWritten, NULL))
                           {
                               WARNING("GdiPlayPageEMF() Failed writing to temp spool file\n");
                               break;
                           }

                           if(dwBytesWritten != dwSize)
                           {
                               WARNING("GdiPlayPageEMF() Unexpected mismatch between attempted write size and actual\n");
                               break;
                           }

                           dwOffset += dwBytesWritten;
                       }

                       if(dwOffset == Size)
                       {
                           hEMFPage = SetEnhMetaFileBitsAlt(NULL, NULL, hFile, 0);

                           if(!hEMFPage)
                           {
                               WARNING("GdiPlayPageEMF() Failed creating EMF handle\n");
                           }
                       }

                       LocalFree(pvScratch);
                   }
                   else
                   {
                       WARNING("GdiPlayPageEMF() Failed creating scratch buffer\n");
                   }
               }
               else
               {
                   WARNING("GdiPlayPageEMF() Failed seeking spooler\n");
               }
                
               pBuffer = NULL;
               bAllocBuffer = TRUE;

               if (hEMFPage == NULL)
               {
                   if (!CloseHandle(hFile))
                   {
                       WARNING("GdiPlayPageEMF() Failed closing temp spool file handle\n");
                   }
                   else
                   {
                       hFile = INVALID_HANDLE_VALUE;
                   }
               }

           }

       }

       if (hEMFPage == NULL) {
           // If memory mapped read didnt work, dont try it again

           pSpoolFileHandle->bUseMemMap = FALSE;

           if ((pBuffer = (BYTE*) LocalAlloc(LMEM_FIXED, Size)) &&
               (*fpSeekPrinter)(pSpoolFileHandle->hSpooler, Offset, NULL, 0, FALSE) &&
               MyReadPrinter(pSpoolFileHandle->hSpooler, pBuffer, Size)) {

                hEMFPage = SetEnhMetaFileBitsAlt((HLOCAL)pBuffer, NULL, NULL, 0);
           }

           bAllocBuffer = TRUE;
       }
       
       // Check if the handle was created
       if (hEMFPage == NULL) {

          // Free resources and quit
          if (pBuffer && bAllocBuffer) {
             LocalFree(pBuffer);
          }

          if(hFile != INVALID_HANDLE_VALUE)
          {
              if(!CloseHandle(hFile))
              {
                  WARNING("GdiPlayPageEMF() Failed closing temp spool file handle\n");
              }
          }

          WARNING("GdiPlayPageEMF: Failed to Create EMF Handle\n");
          return FALSE;

       } else {

          // Save hEMFPage in pEMF struct for future calls to GdiPlayPageEMF
          pEMF->hemf = hEMFPage;
          pEMF->bAllocBuffer = bAllocBuffer;
       }
   }

   if (pSpoolFileHandle->dwNumberOfPagesInCurrSide >=
                     pSpoolFileHandle->dwNumberOfPagesAllocated) {

        PAGE_LAYOUT_STRUCT  *pTemp;

        if (pTemp = LOCALALLOC(sizeof(PAGE_LAYOUT_STRUCT) *
                               (pSpoolFileHandle->dwNumberOfPagesAllocated +
                                SPOOL_FILE_MAX_NUMBER_OF_PAGES_PER_SIDE))) {

           memcpy(pTemp,
                  pSpoolFileHandle->pPageLayout,
                  sizeof(PAGE_LAYOUT_STRUCT) * pSpoolFileHandle->dwNumberOfPagesAllocated);
           LocalFree(pSpoolFileHandle->pPageLayout);
           pSpoolFileHandle->pPageLayout = pTemp;
           pSpoolFileHandle->dwNumberOfPagesAllocated += SPOOL_FILE_MAX_NUMBER_OF_PAGES_PER_SIDE;

        } else {

           SetLastError(ERROR_NOT_ENOUGH_MEMORY);
           WARNING("GdiPlayPageEMF: out of memory\n");
           return(FALSE);
        }
   }

   // update the fields
   pPageLayout = &(pSpoolFileHandle->pPageLayout[pSpoolFileHandle->dwNumberOfPagesInCurrSide]);
   pPageLayout->hemf = pEMF->hemf;
   pPageLayout->bAllocBuffer = pEMF->bAllocBuffer;
   pPageLayout->dwPageNumber = pEMF->dwPageNumber;

   pPageLayout->rectDocument.top    = prectDocument->top;
   pPageLayout->rectDocument.bottom = prectDocument->bottom;
   pPageLayout->rectDocument.left   = prectDocument->left;
   pPageLayout->rectDocument.right  = prectDocument->right;

   // Set the border
   if (prectBorder) {
      pPageLayout->rectBorder.top    = prectBorder->top;
      pPageLayout->rectBorder.bottom = prectBorder->bottom;
      pPageLayout->rectBorder.left   = prectBorder->left;
      pPageLayout->rectBorder.right  = prectBorder->right;
   } else {
      pPageLayout->rectBorder.top    = -1; //invalid coordinates
      pPageLayout->rectBorder.bottom = -1; //invalid coordinates
      pPageLayout->rectBorder.left   = -1; //invalid coordinates
      pPageLayout->rectBorder.right  = -1; //invalid coordinates
   }

   // Set the clipping rectangle
   if (prectClip) {
      pPageLayout->rectClip.top    = prectClip->top;
      pPageLayout->rectClip.bottom = prectClip->bottom;
      pPageLayout->rectClip.left   = prectClip->left;
      pPageLayout->rectClip.right  = prectClip->right;
   } else {
      pPageLayout->rectClip.top    = -1; //invalid coordinates
      pPageLayout->rectClip.bottom = -1; //invalid coordinates
      pPageLayout->rectClip.left   = -1; //invalid coordinates
      pPageLayout->rectClip.right  = -1; //invalid coordinates
   }

   // Save the current transformation at the DC
   if (!GetWorldTransform(pSpoolFileHandle->hdc, &(pPageLayout->XFormDC))) {
       WARNING("GdiPlayPageEMF: GetWorldTransform failed\n");
       return(FALSE);
   }

   // increment the number of pages
   pSpoolFileHandle->dwNumberOfPagesInCurrSide += 1;

   return(TRUE);
}

BOOL WINAPI GdiPlayPrivatePageEMF(
    HANDLE       SpoolFileHandle,
    HENHMETAFILE hEnhMetaFile,
    RECT         *prectDocument)

/*
Function Description:
         GdiPlayPrivatePageEMF allows the print processor to play EMF pages other than the
         ones present in the spool file (like watermarks) inside a specified rectangle.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle
         hEnhMetaFile       -- handle to an EMF which is to be played on the current physical
                               page
         prectDocument      -- pointer to the RECT containing coordinates where
                               the page is to be played

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         6/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
    EMF_HANDLE   hRecord;

    hRecord.tag          = EMF_HANDLE_TAG;
    hRecord.hemf         = hEnhMetaFile;
    hRecord.dwPageNumber = 0;                 // Invalid value
    hRecord.bAllocBuffer = FALSE;

    return GdiPlayPageEMF(SpoolFileHandle,
                          (HANDLE) &hRecord,
                          prectDocument,
                          NULL,
                          NULL);
}

BOOL InternalProcessEMFRecord(
     SPOOL_FILE_HANDLE    *pSpoolFileHandle,
     DWORD                dwPageNumber)

/*
Function Description:
         InternalProcessEMFRecord processes any EMF records that appear before the given
         EMF page which should be processed immediately before playing the page.

Parameters:
         pSpoolFileHandle  -- pointer to the SPOOL_FILE_HANDLE struct for the job.
         dwPageNumber      -- number of the page being played

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
     PRECORD_INFO_STRUCT  pRecordInfo;
     BYTE                 *pTmpBuffer = NULL;
     LARGE_INTEGER        liOffset;
     BOOL                 bReturn = FALSE;
     PEMFITEMPRESTARTPAGE pemfiPre;


     pRecordInfo = pSpoolFileHandle->pPageInfo[dwPageNumber-1].pRecordInfo;

     // loop thru all the records seen before the page
     while (pRecordInfo) {

        liOffset.QuadPart = pRecordInfo->RecordOffset;

        if (pTmpBuffer = (BYTE*) LOCALALLOC(pRecordInfo->RecordSize)) {

           if (!(*fpSeekPrinter) (pSpoolFileHandle->hSpooler,
                                  liOffset,
                                  NULL,
                                  FILE_BEGIN,
                                  FALSE)      ||
               !MyReadPrinter(pSpoolFileHandle->hSpooler,
                              pTmpBuffer,
                              pRecordInfo->RecordSize)) {

                WARNING("Gdi32:  error reading record\n");
                goto exit;
           }

        } else {

             WARNING("Out of memory in InternalProcessEMFRecord\n");
             goto exit;
        }

        switch (pRecordInfo->RecordID) {

        case EMRI_PRESTARTPAGE:

            MFD1("pre start page commands\n");

            pemfiPre = (PEMFITEMPRESTARTPAGE) pTmpBuffer;

            if (pemfiPre->bEPS & 1) {

                SHORT b = 1;

                MFD1("MFP_StartDocW calling bEpsPrinting\n");
                ExtEscape(pSpoolFileHandle->hdc, EPSPRINTING, sizeof(b),
                          (LPCSTR) &b, 0 , NULL );
            }

            break;

        // add cases for new records that must be processed before the page is played

        default:

            WARNING("unknown ITEM record\n");
            break;
        }

        LocalFree(pTmpBuffer);
        pTmpBuffer = NULL;
        pRecordInfo = pRecordInfo->pNext;
     }

     bReturn = TRUE;

exit:

     if (pTmpBuffer) {
         LocalFree(pTmpBuffer);
     }
     return bReturn;
}

BOOL InternalGdiPlayPageEMF(
     SPOOL_FILE_HANDLE    *pSpoolFileHandle,
     PAGE_LAYOUT_STRUCT   *pPageLayout,
     POINTL               *pptlOrigin,
     SIZE                 *pszSurface,
     BOOL                 bBanding)

/*
Function Description:
         InternalGdiPlayPageEMF plays the EMF file on the page and draws borders, if
         specified. It also performs initialization for GL records that may present in
         EMF file.

Parameters:
         pSpoolFileHandle  -- pointer to the SPOOL_FILE_HANDLE struct for the job
         pPageLayout       -- pointer to PAGE_LAYOUT_STRUCT which contains information
                              about playing the page
         pptlOrigin        -- pointer to a POINTL structure used for banding
         pszSurface        -- pointer to a SIZE structure used for banding
         bBanding          -- flag to indicate if banding is being used

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author

*/

{
     BOOL         bPrintGl, bReturn = FALSE;
     XFORM        OldXForm;
     POINTL       ptlOrigin;
     SIZE         szSurface;
     GLPRINTSTATE gps;
     HDC          hPrinterDC = pSpoolFileHandle->hdc;
     RECT         *rectBorder = &(pPageLayout->rectBorder);
     RECT         *rectClip   = &(pPageLayout->rectClip);
     RECT         *rectBand = NULL;
     HRGN         hClipRgn = NULL;
     INT          indexDC = 0;

     if (bBanding) {
        // New structs created so that each page is played for the same band
        ptlOrigin.x = pptlOrigin->x;
        ptlOrigin.y = pptlOrigin->y;
        szSurface.cx = pszSurface->cx;
        szSurface.cy = pszSurface->cy;

        // Print only on the correct band
        SetViewportOrgEx(hPrinterDC, -ptlOrigin.x, -ptlOrigin.y, NULL);
     }

     // Process any PRESTARTPAGE records that appear immediately before this page
     if (pPageLayout->dwPageNumber > 0) {
        InternalProcessEMFRecord(pSpoolFileHandle, pPageLayout->dwPageNumber);
     }

     // Draw Page borders (if any)
     if (!((rectBorder->top    == -1) &&
           (rectBorder->bottom == -1) &&
           (rectBorder->right  == -1) &&
           (rectBorder->left   == -1)) &&
         ModifyWorldTransform(hPrinterDC, NULL, MWT_IDENTITY)) {
          HRGN hBandRgn = NULL;
          if (bBanding && !IsMetafileWithGl(pPageLayout->hemf))
          {
             ULONG ulRet,ulXRes,ulYRes;
             PERBANDINFO pbi;
             RECT *prect = &(pPageLayout->rectDocument);
             ulXRes = (ULONG)  prect->right - prect->left;
             ulYRes = (ULONG)  prect->bottom - prect->top;

             pbi.bRepeatThisBand = FALSE;
             pbi.ulHorzRes = ulXRes;
             pbi.ulVertRes = ulYRes;
             pbi.szlBand.cx = szSurface.cx;
             pbi.szlBand.cy = szSurface.cy;

             ulRet = NtGdiGetPerBandInfo(hPrinterDC,&pbi);

             if (ulRet && ulRet != GDI_ERROR && 
                  pbi.ulHorzRes == ulXRes && pbi.ulVertRes == ulYRes) 
             {
                hBandRgn = CreateRectRgn(0,0,pbi.szlBand.cx,pbi.szlBand.cy);
                if (hBandRgn)
                    SelectClipRgn(hPrinterDC, hBandRgn);
             }
          }

          MoveToEx(hPrinterDC, rectBorder->left, rectBorder->top, NULL);
          LineTo(hPrinterDC, rectBorder->right, rectBorder->top);
          MoveToEx(hPrinterDC, rectBorder->right, rectBorder->top, NULL);
          LineTo(hPrinterDC, rectBorder->right, rectBorder->bottom);
          MoveToEx(hPrinterDC, rectBorder->right, rectBorder->bottom, NULL);
          LineTo(hPrinterDC, rectBorder->left, rectBorder->bottom);
          MoveToEx(hPrinterDC, rectBorder->left, rectBorder->bottom, NULL);
          LineTo(hPrinterDC, rectBorder->left, rectBorder->top);
          if (hBandRgn)
          {
             SelectClipRgn(hPrinterDC,NULL);
             DeleteObject(hBandRgn);
          }
     }

     // Save the old transformation
     if (!GetWorldTransform(hPrinterDC, &OldXForm)) {
         WARNING("InternalGdiPlayEMFPage: GetWorldTransform failed\n");
         return FALSE;
     }

     // Set the new transformation
     if (!SetWorldTransform(hPrinterDC, &(pPageLayout->XFormDC))) {
         WARNING("InternalGdiPlayEMFPage: SetWorldTransform failed\n");
         goto CleanUp;
     }

     if (!((rectClip->top    == -1) &&
           (rectClip->bottom == -1) &&
           (rectClip->right  == -1) &&
           (rectClip->left   == -1))) {

         rectBand = rectClip;

         if (!bBanding) {

             // Set the clipping rectangle
             hClipRgn = CreateRectRgn(rectClip->left, rectClip->top,
                                      rectClip->right, rectClip->bottom);

             indexDC = SaveDC(hPrinterDC);

             if (!hClipRgn || !indexDC ||
                 (SelectClipRgn(hPrinterDC, hClipRgn) == ERROR)) {

                  WARNING("InternalGdiPlayEMFPage: SelectClipRgn failed\n");
                  goto CleanUp;
             }
         }
     }

     // Perform GL initialization if necessary
     bPrintGl = IsMetafileWithGl(pPageLayout->hemf);
     if (bPrintGl) {
        if (!InitGlPrinting(pPageLayout->hemf,
                            hPrinterDC,
                            &(pPageLayout->rectDocument),
                            pSpoolFileHandle->pLastDevmode,
                            &gps)) {

             WARNING("InternalGdiPlayEMFPage: InitGlPrinting failed\n");
             goto CleanUp;
        }
     }

     if (bBanding) {
        // call printing functions for banding case
        if (bPrintGl) {

            SetViewportOrgEx(hPrinterDC, -ptlOrigin.x, -ptlOrigin.y, NULL);
            PrintMfWithGl(pPageLayout->hemf, &gps, &ptlOrigin, &szSurface);
            EndGlPrinting(&gps);

        } else {


           PrintBand( hPrinterDC,
                      pPageLayout->hemf,
                      &ptlOrigin,
                      &(pPageLayout->rectDocument),
                      &szSurface,
                      rectBand );
        }

     } else {

        // call priting functions for non-banding case
        if (bPrintGl) {
            PrintMfWithGl(pPageLayout->hemf, &gps, NULL, NULL);
            EndGlPrinting(&gps);
        } else {
            PlayEnhMetaFile( hPrinterDC, pPageLayout->hemf, &(pPageLayout->rectDocument) );
        }

     }

     bReturn = TRUE;

CleanUp:

     // Restore the old clipping region
     if (indexDC) {
         RestoreDC(hPrinterDC, indexDC);
     }

     // Reset the world transformation
     if (!SetWorldTransform(hPrinterDC, &OldXForm)) {
         WARNING("InternalGdiPlayEMFPage: SetWorldTransform failed\n");
         bReturn = FALSE;
     }

     // Delete the clipping region
     if (hClipRgn) {
         DeleteObject(hClipRgn);
     }

     return bReturn;
}


BOOL AddTempNode(
    PEMF_LIST     *ppHead,
    HENHMETAFILE  hemf,
    BOOL          bAllocBuffer)

/*
Function Description:
         AddTempNode adds a EMF handle to a list that does not contain duplicates.
         This list is used for deleting the handles later.

Parameters:
         ppHead  - pointer to the start of the list
         hemf    - handle to EMF to be added to the list
         bAllocBuffer - flag indicating if buffer was allocated for hemf

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         7/7/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
    BOOL      bReturn = FALSE;
    PEMF_LIST pTemp;

    for (pTemp = *ppHead; pTemp; ppHead = &(pTemp->pNext), pTemp = *ppHead) {
       if (pTemp->hemf == hemf) {
          return TRUE;
       }
    }

    if (!(pTemp = (PEMF_LIST) LOCALALLOC(sizeof(EMF_LIST)))) {
       return FALSE;
    }

    pTemp->hemf = hemf;
    pTemp->bAllocBuffer = bAllocBuffer;
    pTemp->pNext = NULL;
    *ppHead = pTemp;

    return TRUE;
}

VOID RemoveFromSpoolFileHandle(
    SPOOL_FILE_HANDLE  *pSpoolFileHandle,
    HENHMETAFILE hemf)

/*
Function Description:
         The EMF handles that are played get deleted at the end of the page (GdiEndPageEMF).
         The rest of the handles are deleted in the cleanup routine (GdiDeleteSpoolFileHandle).
         These are handles are listed in pSpoolFileHandle->pEMFHandle. RemoveFromSpoolFileHandle
         removes deleted handles from this list, to avoid freeing the handles twice.

Parameters:
         pSpoolFileHandle   -- pointer to the SPOOL_FILE_HANDLE
         hemf               -- Handle to EMF that is going to be deleted

Return Values:
         NONE

History:
         9/18/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/
{
    PEMF_HANDLE pTemp;

    for (pTemp = pSpoolFileHandle->pEMFHandle; pTemp; pTemp = pTemp->pNext) {
         if (pTemp->hemf == hemf) {
             pTemp->hemf = NULL;
         }
    }

    return;
}

BOOL SetColorOptimization(
    SPOOL_FILE_HANDLE  *pSpoolFileHandle,
    DWORD              dwOptimization)

/*
Function Description:
         SetColorOptimization examines the page types on the next physical page and
         sets the device context to take advantage of monochrome pages.

Parameters:
         pSpoolFileHandle   -- pointer to the SPOOL_FILE_HANDLE
         dwOptimization     -- flag indicating optimizations to be performed

Return Values:
         TRUE if successful; FALSE otherwise

History:
         9/23/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
    BOOL   bReturn = TRUE, bFoundColor = FALSE, bReset;
    short  dmColor;
    DWORD  dmFields, dwIndex, dwPageNumber, dwRecordID;
    PAGE_LAYOUT_STRUCT *pPageLayout;

    // Dont process for monochrome detection if the optimization is not
    // applied
    if (!(dwOptimization & EMF_PP_COLOR_OPTIMIZATION)) {
        return TRUE;
    }

    // Search for color in the pages on the current physical page
    for (dwIndex = 0, pPageLayout = pSpoolFileHandle->pPageLayout;
         dwIndex < pSpoolFileHandle->dwNumberOfPagesInCurrSide;
         ++dwIndex, ++pPageLayout)
    {
        dwPageNumber = pPageLayout->dwPageNumber;
        dwRecordID = pSpoolFileHandle->pPageInfo[dwPageNumber-1].ulID;

        if ((dwRecordID == EMRI_METAFILE) ||
            (dwRecordID == EMRI_FORM_METAFILE)) {

            bFoundColor = TRUE;
            break;
        }
    }

    // Determine if the status has to changed
    bReset = (bFoundColor && (pSpoolFileHandle->dwPlayBackStatus == EMF_PLAY_MONOCHROME)) ||
             (!bFoundColor && (pSpoolFileHandle->dwPlayBackStatus == EMF_PLAY_COLOR));

    if (bReset) {
        // Save the old settings
        dmFields = pSpoolFileHandle->pLastDevmode->dmFields;
        dmColor  = pSpoolFileHandle->pLastDevmode->dmColor;

        pSpoolFileHandle->pLastDevmode->dmFields |= DM_COLOR;
        pSpoolFileHandle->pLastDevmode->dmColor  = bFoundColor ? DMCOLOR_COLOR
                                                               : DMCOLOR_MONOCHROME;

        // Reset the DC and set graphics mode
        bReturn = ResetDCWInternal(pSpoolFileHandle->hdc,
                                   pSpoolFileHandle->pLastDevmode,
                                   &(pSpoolFileHandle->bBanding))      &&
                  SetGraphicsMode(pSpoolFileHandle->hdc, GM_ADVANCED);

        // Restore old settings and update status
        pSpoolFileHandle->pLastDevmode->dmFields = dmFields;
        pSpoolFileHandle->pLastDevmode->dmColor = dmColor;
        pSpoolFileHandle->dwPlayBackStatus = bFoundColor ? EMF_PLAY_COLOR
                                                         : EMF_PLAY_MONOCHROME;
    }

    return bReturn;
}

BOOL WINAPI GdiEndPageEMF(
    HANDLE     SpoolFileHandle,
    DWORD      dwOptimization)

/*
Function Description:
         GdiEndPageEMF completes printing on the current page and ejects it. It
         loops thru the different bands while printing the page. GdiEndPageEMF also
         frees up the buffers allocated for the emf handle.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle
         dwOptimization     -- flag color optimizations. To be extended for copies

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
   SPOOL_FILE_HANDLE  *pSpoolFileHandle;
   DWORD              dwIndex;
   PAGE_LAYOUT_STRUCT *pPageLayout;
   BOOL               bReturn = FALSE;
   PEMF_LIST          pTemp, pHead = NULL;

   pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

   // first check to see if this is a valid handle by checking for the tag
   try
   {
       if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
       {
           WARNING("GdiEndPageEMF: invalid handle\n");
           return(FALSE);
       }
   }
   except(EXCEPTION_EXECUTE_HANDLER)
   {
       WARNING("GdiEndPageEMF: exception accessing handle\n");
       return(FALSE);
   }

   if (!SetColorOptimization(pSpoolFileHandle, dwOptimization)) {
       WARNING("GdiEndPageEMF: Color optimizations failed\n");
   }

   if (!StartPage(pSpoolFileHandle->hdc)) {
       WARNING("GdiEndPageEMF: StartPage failed\n");
       return(FALSE);
   }

   if (pSpoolFileHandle->bBanding) {

        // for opengl optimization
        POINTL ptlOrigin;
        SIZE szSurface;

        // initialize for banding
        if (!StartBanding( pSpoolFileHandle->hdc, &ptlOrigin, &szSurface )) {
           goto CleanUp;
        }

        // loop till all the bands are printed
        do {
           for (dwIndex = 0, pPageLayout = pSpoolFileHandle->pPageLayout;
                dwIndex < pSpoolFileHandle->dwNumberOfPagesInCurrSide;
                ++dwIndex, ++pPageLayout) {

               if (!InternalGdiPlayPageEMF(pSpoolFileHandle,
                                           pPageLayout,
                                           &ptlOrigin,
                                           &szSurface,
                                           TRUE)) {
                   WARNING("GdiEndPageEMF: InternalGdiPlayEMFPage failed");
                   goto CleanUp;
               }
           }

           if (!NextBand(pSpoolFileHandle->hdc, &ptlOrigin)) {
               WARNING("GdiEndPageEMF: NextBand failed\n");
               goto CleanUp;
           }

        } while (ptlOrigin.x != -1);

   } else {
        for (dwIndex = 0, pPageLayout = pSpoolFileHandle->pPageLayout;
             dwIndex < pSpoolFileHandle->dwNumberOfPagesInCurrSide;
             ++dwIndex, ++pPageLayout) {

               if (!InternalGdiPlayPageEMF(pSpoolFileHandle,
                                           pPageLayout,
                                           NULL,
                                           NULL,
                                           FALSE)) {
                   WARNING("GdiEndPageEMF: InternalGdiPlayEMFPage failed");
                   goto CleanUp;
               }
        }
   }

   bReturn = TRUE;

CleanUp:

   // eject the current page
   if (!EndPage(pSpoolFileHandle->hdc)) {
       WARNING("GdiEndPageEMF: EndPage failed\n");
       bReturn = FALSE;
   }

   // free the emf handles
   for (dwIndex = 0, pPageLayout = pSpoolFileHandle->pPageLayout;
        dwIndex < pSpoolFileHandle->dwNumberOfPagesInCurrSide;
        ++dwIndex, ++pPageLayout) {

         AddTempNode(&pHead, pPageLayout->hemf, pPageLayout->bAllocBuffer);
   }

   while (pTemp = pHead) {
      pHead = pHead->pNext;
      RemoveFromSpoolFileHandle(pSpoolFileHandle, pTemp->hemf);
      InternalDeleteEnhMetaFile(pTemp->hemf, pTemp->bAllocBuffer);
      LocalFree(pTemp);
   }

   // reset the number of logical pages for the next physical page
   pSpoolFileHandle->dwNumberOfPagesInCurrSide = 0;

   return bReturn;
}

BOOL WINAPI GdiEndDocEMF(
    HANDLE SpoolFileHandle)

/*
Function Description:
         GdiEndDocEMF completes printing the current document. GdiEndPageEMF is called
         if the last physical page was not ejected. Some of the resources associated with
         printing of the document are released.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
   SPOOL_FILE_HANDLE *pSpoolFileHandle;

   pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

   // first check to see if this is a valid handle by checking for the tag

   try
   {
       if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
       {
           WARNING("GdiEndDocEMF: invalid handle\n");
           return(FALSE);
       }
   }
   except(EXCEPTION_EXECUTE_HANDLER)
   {
       WARNING("GdiEndDocEMF: exception accessing handle\n");
       return(FALSE);
   }

   // call GdiEndPageEMF if the last physical page was not ejected
   if (pSpoolFileHandle->dwNumberOfPagesInCurrSide) {
      GdiEndPageEMF(SpoolFileHandle,0);
   }

   EndDoc(pSpoolFileHandle->hdc);

   // free the memory used for saving the page layouts
   LOCALFREE(pSpoolFileHandle->pPageLayout);
   pSpoolFileHandle->pPageLayout = NULL;

   return TRUE;
}

BOOL WINAPI GdiGetDevmodeForPage(
    HANDLE     SpoolFileHandle,
    DWORD      dwPageNumber,
    PDEVMODEW  *pCurrDM,
    PDEVMODEW  *pLastDM)

/*
Function Description:
         GdiGetDevmodeForPage allows the print processor to retrieve the last devmode
         set at the printer device context and the last devmode that appears before
         any given page. If the 2 devmodes are different the print processor has to
         call GdiResetDCEMF with the current devmode. However since ResetDC can be called
         only at page boundaries, the print processor must end printing on the current
         page before calling GdiResetDCEMF. GdiEndPageEMF allows the print processor to
         complete printing on the current physical page.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle
         dwPageNumber       -- page number for which the devmode is sought
         *pCurrDM           -- buffer to store the pointer to the devmode for the page
         *pLastDM           -- buffer to store the pointer to the last devmode used in
                               ResetDC

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
   SPOOL_FILE_HANDLE *pSpoolFileHandle;

   pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

   // first check to see if this is a valid handle by checking for the tag

   try
   {
      if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
      {
         WARNING("GdiGetDevmodeForPage: invalid handle\n");
         return(FALSE);
      }
   }
   except(EXCEPTION_EXECUTE_HANDLER)
   {
      WARNING("GdiGetDevmodeForPage: exception accessing handle\n");
      return(FALSE);
   }

   // process the spool file till the required page is found
   if(!ProcessPages(pSpoolFileHandle, (UINT)dwPageNumber))
   {
       WARNING("GdiGetDevmodeForPage: ProcessPages failed\n");
       return(FALSE);
   }

   // return the pointers in the buffers
   if (pCurrDM) {
      *pCurrDM = pSpoolFileHandle->pPageInfo[dwPageNumber-1].pDevmode;
   }
   if (pLastDM) {
      *pLastDM = pSpoolFileHandle->pLastDevmode;
   }
   return(TRUE);

}

BOOL WINAPI GdiResetDCEMF(
    HANDLE    SpoolFileHandle,
    PDEVMODEW pCurrDM)

/*
Function Description:
         GdiResetDCEMF should be use to reset the printer device context with a new
         devmode. The memory for the devmode will be released by GDI.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle
         pCurrDM            -- pointer to the devmode that was used in the last ResetDC
                               call by the print processor

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
   SPOOL_FILE_HANDLE *pSpoolFileHandle;
   BOOL  bReturn;

   pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

   // first check to see if this is a valid handle by checking for the tag
   try
   {
       if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
       {
           WARNING("GdiResetDCEMF: invalid handle\n");
           return(FALSE);
       }
   }
   except(EXCEPTION_EXECUTE_HANDLER)
   {
       WARNING("GdiResetDCEMF: exception accessing handle\n");
       return(FALSE);
   }

   if (pCurrDM && 
       ResetDCWInternal(pSpoolFileHandle->hdc,
                        pCurrDM,
                        &(pSpoolFileHandle->bBanding)))
   {
        // set the last devmode in the SpoolFileHandle
        pSpoolFileHandle->pLastDevmode = pCurrDM;
        bReturn = TRUE;
   }
   else
   {
        bReturn = FALSE;
   }

   if (pCurrDM && (pCurrDM->dmFields & DM_COLOR)) {

       if (pCurrDM->dmColor == DMCOLOR_COLOR) {
           pSpoolFileHandle->dwPlayBackStatus = EMF_PLAY_COLOR;
       } else {
           pSpoolFileHandle->dwPlayBackStatus = EMF_PLAY_FORCE_MONOCHROME;
       }
   }

   return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\sources.inc ===
MAJORCOMP=windows
MINORCOMP=GDI

TARGETNAME=gdi32
TARGETNAMEP=gdi32p
TARGETTYPE=DYNLINK

TARGETPATH=$(_OBJ_DIR)
UMPDDDILIB=$(NTGDI_PATH)\client\$(ALT_PROJECT)\$(O)\umpdddi.lib
WINPPILIB=$(NTGDI_PATH)\client\$(ALT_PROJECT)\$(O)\winppi.lib
NTGDIH=$(NTGDI_PATH)\inc\ntgdi.h

PASS1_PUBLISH=\
    {$(DYNLINK_LIB)=$(SDK_LIB_DEST)\$(DYNLINK_LIBDIR)} \
    {$(DYNLINK_LIBP)=$(WINDOWS_LIB_DEST)\$(DYNLINK_LIBPDIR)} \
    {$(UMPDDDILIB)=$(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\umpdddi.lib} \
    {$(WINPPILIB)=$(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\winppi.lib} \
    {$(UMPDDDILIB)=$(DDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\umpdddi.lib} \
    {$(WINPPILIB)=$(DDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\winppi.lib} \
    {$(NTGDIH)=$(SDK_INC_PATH)\ntgdi.h}

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib                               \
           $(WUMODE_PATH)\$(ALT_PROJECT)\$(O)\w32umode.lib \
           $(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\user32p.lib    \
           $(NTGDI_PATH)\math\$(ALT_PROJECT)\$(O)\efloat.lib          \
           $(SDK_LIB_PATH)\ntdll.lib                                  \
           $(SDK_LIB_PATH)\advapi32.lib                               \
           $(SDK_LIB_PATH)\psapi.lib

LINKLIBS= $(WUMODE_PATH)\$(ALT_PROJECT)\$(O)\w32umode.lib

NTTARGETFILES= $(SDK_LIB_DEST)\$(DYNLINK_LIBDIR)  \
               $(WINDOWS_LIB_DEST)\$(DYNLINK_LIBPDIR) \
               $(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\umpdddi.lib   \
               $(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\winppi.lib   \
               ..\$(TARGETNAME).def

NTTARGETFILE1=$(DYNLINK_LIBP) $(UMPDDDILIB) $(WINPPILIB)

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=..;                                   \
         ..\..\inc;                            \
         $(WINCORE_PATH)\w32inc;                      \
         ..\..\direct\ddraw\main;              \
         ..\..\icm\inc;                        \
         $(BASE_INC_PATH); \
         $(MULTIMEDIA_INC_PATH);               \
         $(DDK_INC_PATH)

C_DEFINES=$(C_DEFINES) -D_GDI32_ -DGL_METAFILE -DFE_SB -DLANGPACK -DINTEL -DDS_ENABLE_OLD_STUFF=0

USE_NTDLL=1

DLLDEF=..\$(TARGETNAME).def
DLLORDER=..\$(TARGETNAME).prf

SOURCES= ..\cfont.c        \
         ..\csxobj.cxx     \
         ..\bitmap.c       \
         ..\xform.c        \
         ..\d3d.c          \
         ..\dllinit.c      \
         ..\dcmod.c        \
         ..\dcquery.c      \
         ..\ddraw.c        \
         ..\emfspool.cxx   \
         ..\font.c         \
         ..\icm.c          \
         ..\image.c        \
         ..\ldc.c          \
         ..\linedda.c      \
         ..\local.c        \
         ..\metafile.cxx   \
         ..\metarec.cxx    \
         ..\metasup.cxx    \
         ..\mem.c          \
         ..\mfdc.cxx       \
         ..\mfplay16.c     \
         ..\mfrec.cxx      \
         ..\mfrec16.c      \
         ..\nlsconv.c      \
         ..\object.c       \
         ..\output.c       \
         ..\pal.c          \
         ..\path.c         \
         ..\pixelfmt.c     \
         ..\poly.c         \
         ..\region.c       \
         ..\script.c       \
         ..\fareast.c      \
         ..\print.c        \
         ..\ufi.c          \
         ..\glsup.c        \
         ..\umpd.cxx       \
         ..\umpdeng.c      \
         ..\umpddrv.c      \
         ..\drawstream.c   \
         ..\gdi.rc

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\pixelfmt.c ===
/******************************Module*Header*******************************\
* Module Name: pixelfmt.c
*
* Client side stubs for pixel format functions.
*
* Created: 17-Sep-1993
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1993-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

static char szOpenGL[] = "OPENGL32";

typedef int  (WINAPI *PFN1)(HDC, CONST PIXELFORMATDESCRIPTOR *);
typedef int  (WINAPI *PFN2)(HDC, int, UINT, LPPIXELFORMATDESCRIPTOR);
typedef int  (WINAPI *PFN3)(HDC);
typedef BOOL (WINAPI *PFN4)(HDC, int, CONST PIXELFORMATDESCRIPTOR *);
typedef BOOL (WINAPI *PFN5)(HDC);

BOOL gbSetPixelFormatCalled = FALSE;

// In these routines the assumption is that OpenGL is already loaded
// For that case, the LoadLibrary/FreeLibrary calls will simply
// increment and decrement the reference count of the DLL, so they
// won't be too expensive
//
// In the case where OpenGL is not loaded the DLL will be brought in
// for the duration of the call only

/***********************************************************************/

__inline FARPROC GetAPI(char *szDll, char *szAPI, HMODULE *phDll)
{
    *phDll = LoadLibraryA(szDll);

    if (*phDll == NULL)
    {
        return NULL;
    }

    return GetProcAddress(*phDll, szAPI);
}

/***********************************************************************/

int WINAPI ChoosePixelFormat(HDC hdc, CONST PIXELFORMATDESCRIPTOR *ppfd)
{
    HMODULE hDll;
    PFN1    pfn = (PFN1)GetAPI(szOpenGL, "wglChoosePixelFormat", &hDll);
    int     ipfd = 0;

    if (pfn)
    {
        ipfd = (*pfn)(hdc, ppfd);
    }

    if (hDll)
    {
        FreeLibrary(hDll);
    }
        
    return ipfd;
}

/***********************************************************************/

int WINAPI DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes,
                               LPPIXELFORMATDESCRIPTOR ppfd)
{
    HMODULE hDll;
    PFN2    pfn = (PFN2)GetAPI(szOpenGL, "wglDescribePixelFormat", &hDll);
    int     ipfd = 0;

    if (pfn)
    {
        ipfd = (*pfn)(hdc, iPixelFormat, nBytes, ppfd);
    }

    if (hDll)
    {
        FreeLibrary(hDll);
    }
        
    return ipfd;
}

/***********************************************************************/

int WINAPI GetPixelFormat(HDC hdc)
{
    int     ipfd = 0;

    if (gbSetPixelFormatCalled)
    {
        HMODULE hDll;
        PFN3    pfn = (PFN3)GetAPI(szOpenGL, "wglGetPixelFormat", &hDll);

        if (pfn)
        {
            ipfd = (*pfn)(hdc);
        }

        if (hDll)
        {
            FreeLibrary(hDll);
        }
    }

    return ipfd;
}

/***********************************************************************/

BOOL WINAPI SetPixelFormat(HDC hdc, int iPixelFormat,
                           CONST PIXELFORMATDESCRIPTOR *ppfd)
{
    HMODULE hDll;
    PFN4    pfn = (PFN4)GetAPI(szOpenGL, "wglSetPixelFormat", &hDll);
    BOOL    bRet = FALSE;

    gbSetPixelFormatCalled = TRUE;

    if (pfn)
    {
        bRet = (*pfn)(hdc, iPixelFormat, ppfd);

        // Metafile if necessary
        if (bRet)
        {
            if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
            {
                PLDC pldc;

                DC_PLDC(hdc, pldc, FALSE);

                if (pldc->iType == LO_METADC)
                {
                    if (!MF_SetPixelFormat(hdc, iPixelFormat, ppfd))
                    {
                        bRet = FALSE;
                    }
                }
            }
        }
    }

    if (hDll)
    {
        FreeLibrary(hDll);
    }

    return bRet;
}

/***********************************************************************/

BOOL WINAPI SwapBuffers(HDC hdc)
{
    HMODULE hDll;
    PFN5    pfn = (PFN5)GetAPI(szOpenGL, "wglSwapBuffers", &hDll);
    BOOL    bRet = FALSE;

    if (pfn)
    {
        bRet = (*pfn)(hdc);
    }
    
    if (hDll)
    {
        FreeLibrary(hDll);
    }
        
    return bRet;
}

/***********************************************************************/

// These stubs are for the cases where OpenGL cannot handle the pixel
// format request itself because it involves device-specific information
// In that case OpenGL asks GDI to go ask the display driver in kernel
// mode

int APIENTRY GdiDescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes,
                                    LPPIXELFORMATDESCRIPTOR ppfd)
{
    return NtGdiDescribePixelFormat(hdc, iPixelFormat, nBytes, ppfd);
}

BOOL APIENTRY GdiSetPixelFormat(HDC hdc, int iPixelFormat)
{
    return NtGdiSetPixelFormat(hdc, iPixelFormat);
}

BOOL APIENTRY GdiSwapBuffers(HDC hdc)
{
    return NtGdiSwapBuffers(hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\gdiplus\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\ufi.c ===
/******************************Module*Header*******************************\
* Module Name: ufi.c
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

FPCREATEFONTPACKAGE gfpCreateFontPackage= (FPCREATEFONTPACKAGE)NULL;
FPMERGEFONTPACKAGE  gfpMergeFontPackage = (FPMERGEFONTPACKAGE)NULL;

ULONG   gulMaxCig = 3000;

#ifdef  DBGSUBSET
FLONG    gflSubset = 0;
#endif //  DBGSUBSET


/***********************************************************
* BOOL bAddGlyphIndices(HDC, PUFIHASH, WCHAR, int, BOOL)
*
* Adds distinct glyph indices into UFI hash bucket
*
* History
*   Dec-13-96 Xudong Wu [tessiew]
* Wrote it.
*
************************************************************/

#define MAX_STACK_STRING 80


BOOL bAddGlyphIndices(HDC hdc, PUFIHASH pBucket, WCHAR *pwsz, int c, UINT flETO)
{
    BOOL     bDelta = pBucket->fs1 & FLUFI_DELTA;
    WCHAR   *pwc=pwsz;
    WORD    *pgi, *pgiTmp, *pgiEnd;
    PBYTE    pb, pbDelta;
    WORD     agi[MAX_STACK_STRING];
    BOOL     bRet = FALSE;

    if (c && pwsz)
    {
        if (bDelta && (pBucket->u.ssi.pjDelta == NULL))
        {
             pBucket->u.ssi.cDeltaGlyphs = 0;

             pBucket->u.ssi.pjDelta = (PBYTE)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, pBucket->u.ssi.cjBits);

             if (pBucket->u.ssi.pjDelta == NULL)
             {
                 WARNING("bAddGlyphIndices: unable to allocate mem for delta glyph indices\n");
                 return FALSE;
             }
        }

        if (c > MAX_STACK_STRING)
        {
            pgi = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, c * sizeof(WORD));
        }
        else
        {
            pgi = agi;
        }
        
        if (pgi)
        {
            if (flETO & ETO_GLYPH_INDEX)
            {
                RtlCopyMemory((PBYTE)pgi, (PBYTE)pwsz, c*sizeof(WORD));
            }

			pgiTmp = pgi;
			if ((flETO & ETO_GLYPH_INDEX) ||
                (NtGdiGetGlyphIndicesWInternal(hdc, pwc, c, pgi, 0, TRUE) != GDI_ERROR))
            {
                for (pgiEnd = pgiTmp + c ; pgi < pgiEnd; pgi++)
                {
                    BYTE jTmp;

                    pb = pBucket->u.ssi.pjBits + (*pgi >> 3);
                    pbDelta = pBucket->u.ssi.pjDelta + (*pgi >> 3);

                // map to the u.ssi.pjBits  and u.ssi.pjDelta if bDelta

                    jTmp = (BYTE)(1 << (*pgi & 7));

                    if (!(*pb & jTmp))
                    {
                        *pb |= jTmp;
                        pBucket->u.ssi.cGlyphsSoFar++;

                    // if this gi is not found in pjBits, it certainly
                    // will not be found in pjDelta

                        if (bDelta)
                        {
                            ASSERTGDI((*pbDelta & jTmp) == 0,
                                "pbDelta contains the gi\n");
                            *pbDelta |= jTmp;
                            pBucket->u.ssi.cDeltaGlyphs++;
                        }
                    }
                }

                bRet = TRUE;
            }
            if (pgiTmp != agi)
                LocalFree(pgiTmp);
        }
        #if DBG
        else
        {
            WARNING("bAddGlyphIndices unable to allocate mem for pgi\n");
        }
        #endif
    }
    else
    {
        bRet = TRUE;
    }

    return bRet;
}


/******************************************************************
* BOOL  bGetDistGlyphIndices(PUFIHASH, USHORT*, BOOL)
*
* Get distinct glyph indices from pjMemory in the ufi hash bucket
* Reverse of bAddGlyphIndices
* Clean up the u.ssi.pjDelta and u.ssi.cDeltaGlyphs before it return.
*
* History
*   Dec-17-96 Xudong Wu [tessiew]
* Wrote it.
*
*******************************************************************/

BOOL bGetDistGlyphIndices(PUFIHASH pBucket, USHORT *pusSubsetKeepList, BOOL bDelta)
{
    ULONG  ulBytes;
    PBYTE  pb;
    USHORT gi, index;
    USHORT *pNextGlyph;

    ulBytes = pBucket->u.ssi.cjBits;
    pb = (bDelta ? pBucket->u.ssi.pjDelta : pBucket->u.ssi.pjBits);

    for(index = 0, pNextGlyph = pusSubsetKeepList; index < ulBytes; index++, pb++)
    {
        if (*pb)
        {
            gi = index << 3;

            if (*pb & 0x01)
            {
                *pNextGlyph ++= gi;
            }
            if (*pb & 0x02)
            {
                *pNextGlyph ++= gi+1;
            }
            if (*pb & 0x04)
            {
                *pNextGlyph ++= gi+2;
            }
            if (*pb & 0x08)
            {
                *pNextGlyph ++= gi+3;
            }
            if (*pb & 0x10)
            {
                *pNextGlyph ++= gi+4;
            }
            if (*pb & 0x20)
            {
                *pNextGlyph ++= gi+5;
            }
            if (*pb & 0x40)
            {
                *pNextGlyph ++= gi+6;
            }
            if (*pb & 0x80)
            {
                *pNextGlyph ++= gi+7;
            }
        }

    }

    return TRUE;
}


/********************************************************************************
* BOOL bWriteUFItoDC(PUFIHASH*, PUNIVERSAL_FONT_ID, PUFIHASH, PVOID, ULONG)
*
* Write merge font image into the UFI hash table on the print server side.
* pBucketIn == NULL, indicates a new font subsetting.
* This is only called on print server
*
* History
* Jan-28-1997   Xudong Wu   [tessiew]
* Wrote it.
*
*********************************************************************************/

BOOL bWriteUFItoDC(
    PUFIHASH          *ppHashBase,
    PUNIVERSAL_FONT_ID pufi,
    PUFIHASH           pBucketIn,// NULL=>First page, else
    PVOID              pvBuffer, // points to the merged font image preceeded with DOWNLOADFONTHEADER
    ULONG              ulBytes
)
{
    PUFIHASH pBucket = pBucketIn;
    ULONG index, ulHeaderSize;

    ASSERTGDI(pvBuffer != NULL, "pWriteUFItoDC attempts to add an NULL ufi\n");

// First page for font subset

    if (!pBucketIn)
    {
        index = UFI_HASH_VALUE(pufi) % UFI_HASH_SIZE;
        pBucket = LOCALALLOC (offsetof(UFIHASH,u.mvw) + sizeof(MERGEDVIEW));

        if (pBucket == NULL)
        {
            WARNING("pWriteUFItoDC: unable to allocate mem for glyph indices\n");
            return FALSE;
        }

        pBucket->ufi = *pufi;
        pBucket->pNext = ppHashBase[index];
        pBucket->fs1 = FLUFI_SERVER; // server side hash bucket

        ppHashBase[index] = pBucket;
    }
    else
    {
    // pjMemory contains the image of the font subsetted up unil
    // the page preceeding this one. Other info in pBucket is ok.

        LocalFree(pBucket->u.mvw.pjMem);
    }

// pvBuffer includes the DOWNLOADFONTHEADER information

    pBucket->u.mvw.pjMem = (PBYTE)pvBuffer;
    pBucket->u.mvw.cjMem = ulBytes;

    return TRUE;
}


/**************************************************************************
*
* Adds an entry to the UFI hash table, this routine only executes
* on a print client machine.
*
* History
*   Dec-16-96 Xudong Wu [tessiew]
* Modify to return the bucket pointer.
*   1-27-95 Gerrit van Wingerden [gerritv]
* Wrote it.
*
***************************************************************************/

PUFIHASH pufihAddUFIEntry(
    PUFIHASH *ppHashBase,
    PUNIVERSAL_FONT_ID pufi,
    ULONG  ulCig,
    FLONG  fl,
    FLONG  fs2)
{
    PUFIHASH pBucket;
    ULONG index;
    ULONG cjGlyphBitfield = (ulCig + 7) / 8;

    index = UFI_HASH_VALUE(pufi) % UFI_HASH_SIZE;
    pBucket = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                 (fl & FL_UFI_SUBSET)                ?
                 (offsetof(UFIHASH,u.ssi) + sizeof(SSINFO) + cjGlyphBitfield) :
                  offsetof(UFIHASH,u)
                 );

    if (pBucket == NULL)
    {
        WARNING("pufihAddUFIEntry: unable to allocate mem for glyph indices\n");
        return NULL;
    }

// these fields are always there

    pBucket->ufi = *pufi;
    pBucket->pNext = ppHashBase[index];
    pBucket->fs1 = 0;
    pBucket->fs2 = (FSHORT)fs2;
    ppHashBase[index] = pBucket;

// these fields are there only for subsetting case

    if (fl & FL_UFI_SUBSET)
    {
    // all other fields are zero initialized by LocalAlloc

        ASSERTGDI (ulCig, "no font subsetting for ulCig == 0\n");
        pBucket->u.ssi.cjBits = cjGlyphBitfield; // bitfield size
        pBucket->u.ssi.pjBits = (PBYTE)pBucket + offsetof(UFIHASH,u.ssi) + sizeof(SSINFO);
    }

    return(pBucket);
}

/**************************************************************************
*
* Checks to see if an entry is in the UFI table.
*
* History
*   Dec-13-96  Xudong Wu [tessiew]
* Changed its return value from BOOL to PUFIHASH.
*   1-27-95 Gerrit van Wingerden [gerritv]
* Wrote it.
*
***************************************************************************/


PUFIHASH pufihFindUFIEntry(PUFIHASH *ppHashBase, PUNIVERSAL_FONT_ID pufi, BOOL SubsetHashBase)
{
    PUFIHASH pBucket;
    ULONG index;

    index = UFI_HASH_VALUE(pufi) %  UFI_HASH_SIZE;

    pBucket = ppHashBase[index];

    if( pBucket == NULL )
    {
        return(NULL);
    }

    do
    {
        if (UFI_SAME_FILE(&pBucket->ufi,pufi))
        {
            if (SubsetHashBase)
            {
                if ((pBucket->ufi.Index -1)/2 == (pufi->Index -1)/2)
                {
                    return (pBucket);
                }
            }
            else
            {
                return(pBucket);
            }
        }

        pBucket = pBucket->pNext;
    } while( pBucket != NULL );

    return(NULL);
}


/************************************************************
* VOID vRemoveUFIEntry(PUFIHASH*, PUNIVERSAL_FONT_ID)
*
* Remove a UFI entry from the UFI hash list
* Function returns TRUE if UFI doesn't exist in the table.
* This is happening on the print client, typically when subsetter failed
* we call this to remove the bucket from ppSubUFIHash table (and then later
* add it to the ppUFIHash, ie hash table of fonts that are going to be shipped
* over without subsetting.
*
* History
*   Feb-03-97  Xudong Wu [tessiew]
* Wrote it.
*
***************************************************************************/
VOID vRemoveUFIEntry(PUFIHASH *ppHashBase, PUNIVERSAL_FONT_ID pufi)
{
    PUFIHASH pBucket, pPrev;
    ULONG index;

    index = UFI_HASH_VALUE(pufi) %  UFI_HASH_SIZE;
    pPrev = pBucket = ppHashBase[index];

    while(pBucket)
    {
        if (UFI_SAME_FILE(&pBucket->ufi, pufi) &&
           ((pBucket->ufi.Index - 1)/2 == (pufi->Index - 1)/2))
        {
            break;
        }
        else
        {
            pPrev = pBucket;
            pBucket = pBucket->pNext;
        }
    }

    if (pBucket != NULL)
    {
        if (pPrev == pBucket)
        {
            ppHashBase[index] = pBucket->pNext;
        }
        else
        {
            pPrev->pNext = pBucket->pNext;
        }

    // this is only happening for subsetting ufi hash list => u.ssi.pjDelta exists

        if (pBucket->u.ssi.pjDelta)
        {
            LocalFree(pBucket->u.ssi.pjDelta);
        }

        LocalFree(pBucket);
    }
}


/**************************************************************************
* VOID vFreeUFIHashTable( PUFIHASH *ppHashTable )
*
* Frees all the memory allocated for the UFI has table.
*
* History
*   1-27-95 Gerrit van Wingerden [gerritv]
* Wrote it.
*
***************************************************************************/


VOID vFreeUFIHashTable(PUFIHASH *ppHashTable, FLONG fl)
{
    PUFIHASH pBucket, *ppHashEnd, pBucketTmp, *ppTableBase;

    if( ppHashTable == NULL )
    {
        return;
    }

    ppTableBase = ppHashTable;  // save ptr to the base so we can free it later

// Next loop through the whole table looking for buckets lists

    for( ppHashEnd = ppHashTable + UFI_HASH_SIZE;
         ppHashTable < ppHashEnd;
         ppHashTable += 1 )
    {
        pBucket = *ppHashTable;

        while( pBucket != NULL )
        {
            pBucketTmp = pBucket;
            pBucket = pBucket->pNext;

        // subsetting hash table

            if (fl & FL_UFI_SUBSET)
            {
                if (pBucketTmp->fs1 & FLUFI_SERVER)  // server, clean the merged font image
                {
                    if (pBucketTmp->u.mvw.pjMem)
                    {
                        LocalFree(pBucketTmp->u.mvw.pjMem);
                    }
                }
                else    // client, clean the glyph indices list
                {
                    if (pBucketTmp->u.ssi.pjDelta)
                    {
                        LocalFree(pBucketTmp->u.ssi.pjDelta);
                    }
                }
            }

            LocalFree (pBucketTmp);
        }
    }
}



ULONG GetRecdEmbedFonts(PUFIHASH *ppHashTable)
{
    PUFIHASH pBucket, *ppHashEnd;
    ULONG cEmbedFonts = 0;

    if( ppHashTable == NULL )
        return 0;

    for( ppHashEnd = ppHashTable + UFI_HASH_SIZE;
         ppHashTable < ppHashEnd;
         ppHashTable += 1 )
    {
        pBucket = *ppHashTable;

        while( pBucket != NULL )
        {
            cEmbedFonts++;
            pBucket = pBucket->pNext;
        }
    }
    return cEmbedFonts;
}


typedef union _DLHEADER
{
    DOWNLOADFONTHEADER dfh;
    double             f;    // to achieve max alignment
} DLHEADER;

BOOL WriteFontToSpoolFile(PLDC pldc, PUNIVERSAL_FONT_ID pufi, FLONG fl)
{
    BOOL bRet = FALSE;

    ULONG cwcPathname, cNumFiles;
    WCHAR  *pwszFile = NULL;
    WCHAR   pwszPathname[MAX_PATH * 3];
    CLIENT_SIDE_FILEVIEW    fvw;
    DLHEADER dlh;
    ULONG   cjView;
    PVOID   pvView = NULL;
    BOOL    bMemFont = FALSE, bMapOK = TRUE;

#ifdef  DBGSUBSET
    FILETIME    fileTimeStart, fileTimeEnd;
    DbgPrint("\nWriteFontToSpoolFile called\n");

    if (gflSubset & FL_SS_SPOOLTIME)
    {
        GetSystemTimeAsFileTime(&fileTimeStart);
    }
#endif

    RtlZeroMemory(&dlh, sizeof(DLHEADER));

    if (NtGdiGetUFIPathname(pufi,
                            &cwcPathname,
                            pwszPathname,
                            &cNumFiles,
                            fl,
                            &bMemFont,
                            &cjView,
                            NULL,
                            NULL,
                            NULL))
    {
        if (cNumFiles == 1)
        {
            ASSERTGDI(cwcPathname <= MAX_PATH, "WriteFontToSpoolFile:  cwcPathname\n");

            if (!bMemFont)
            {
                if (!bMapFileUNICODEClideSide(pwszPathname, &fvw, TRUE))
                {
                    bMapOK = FALSE;
                    WARNING("WriteFontToSpooler: error map the font file\n");
                }
            }
            else
            {
            // must allocate memory and call again to get the bits:

                pvView = LocalAlloc( LMEM_FIXED, cjView ) ;
                if (!pvView)
                {
                    bMapOK = FALSE;
                    WARNING("WriteFontToSpooler: error allocating mem for mem font\n");
                }

            // Write the bits into the buffer

                if (!NtGdiGetUFIPathname(pufi,NULL,NULL,NULL,fl,
                                         NULL,NULL,pvView,NULL,NULL))
                {
                    bMapOK = FALSE;
                    LocalFree(pvView);
                    pvView = NULL;
                    WARNING("WriteFontToSpooler: could not get mem bits\n");
                }
            }

            if (bMapOK)
            {
                DOWNLOADFONTHEADER*  pdfh = &dlh.dfh;

                pdfh->Type1ID = 0;
                pdfh->NumFiles = cNumFiles;

                if (!bMemFont)
                {
                    cjView = fvw.cjView;
                    pvView = fvw.pvView;
                }

                pdfh->FileOffsets[0] = cjView;

                if (WriteFontDataAsEMFComment(
                            pldc,
                            EMRI_ENGINE_FONT,
                            pdfh,
                            sizeof(DLHEADER),
                            pvView,
                            cjView))
                {
                    MFD1("Done writing UFI to printer\n");
                    bRet = TRUE;
                }
                else
                {
                    WARNING("WriteFontToSpooler: error writing to printer\n");
                }

                if (bMemFont)
                {
                    if (pvView) { LocalFree(pvView);}
                }
                else
                {
                    vUnmapFileClideSide(&fvw);
                }
            }
        }
        else
        {
            CLIENT_SIDE_FILEVIEW    afvw[3];
            ULONG   iFile;
            ULONG   cjdh;

            if (cNumFiles > 3)
                return FALSE;

            ASSERTGDI(cwcPathname <= (cNumFiles * MAX_PATH), "cwcPathname too big\n");
            ASSERTGDI(!bMemFont, "there can not be memory type1 font\n");

            pwszFile = pwszPathname;

            bMapOK = TRUE;

            cjView = 0;

            for (iFile = 0; iFile < cNumFiles; iFile++)
            {
                if (!bMapFileUNICODEClideSide(pwszFile, &afvw[iFile], TRUE))
                {
                    ULONG   iFile2;
                    bMapOK = FALSE;
                    WARNING("WriteFontToSpooler: error mapping the font file\n");

                    for (iFile2 = 0; iFile2 < cNumFiles; iFile2++)
                    {
                        vUnmapFileClideSide(&afvw[iFile2]);
                    }

                    break;
                }

            // advance to the path name of the next font file

                while (*pwszFile++);
                cjView += ALIGN4(afvw[iFile].cjView);
            }

            if (bMapOK)
            {
                cjdh = ALIGN8(offsetof(DOWNLOADFONTHEADER, FileOffsets) + cNumFiles * sizeof(ULONG));

                pvView = LocalAlloc(LMEM_FIXED, cjdh + cjView);
                if (pvView)
                {
                    DOWNLOADFONTHEADER*  pdfh = (DOWNLOADFONTHEADER *) pvView;
                    ULONG dpFile;
                    BYTE *pjFile = (BYTE *)pvView + cjdh;

                    RtlZeroMemory(pvView, cjdh); // zero out top portion of the buffer only

                    for (dpFile = 0, iFile = 0; iFile < cNumFiles; iFile++)
                    {
                    // first offset is implicit at cjdh, the second offset is
                    // at ALIGN4(cjView) of the first file etc.

                        dpFile += ALIGN4(afvw[iFile].cjView);
                        pdfh->FileOffsets[iFile] = dpFile;

                        RtlCopyMemory(pjFile, afvw[iFile].pvView, afvw[iFile].cjView);
                        pjFile += ALIGN4(afvw[iFile].cjView);
                    }

                    pdfh->Type1ID = 0; // is this correct?
                    pdfh->NumFiles = cNumFiles;

                    if (WriteFontDataAsEMFComment(
                                pldc,
                                EMRI_TYPE1_FONT,
                                pdfh,
                                cjdh,
                                (BYTE *)pvView + cjdh,
                                cjView))
                    {
                        MFD1("Done writing UFI to printer\n");
                        bRet = TRUE;
                    }
                    else
                    {
                        WARNING("WriteFontToSpooler: error writing to printer\n");
                    }

                    LocalFree(pvView);
                }

                // clean up

                for (iFile = 0; iFile < cNumFiles; iFile++)
                {
                    vUnmapFileClideSide(&afvw[iFile]);
                }
            }
        }
    }
    else
    {
        WARNING("NtGdiGetUFIPathname failed\n");
    }

//timing code
#ifdef  DBGSUBSET
    if (gflSubset & FL_SS_SPOOLTIME)
    {
        GetSystemTimeAsFileTime(&fileTimeEnd);
        DbgPrint("WriteFontToSpoolfile(millisec):   %ld\n", (fileTimeEnd.dwLowDateTime - fileTimeStart.dwLowDateTime) / 10000);
    }
#endif
    return(bRet);
}


/******************************Public*Routine******************************\
*
*
*
* Effects:
*
* Warnings:
*
* History:
*  16-Jan-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL WriteDesignVectorToSpoolFile (
    PLDC               pldc,
    UNIVERSAL_FONT_ID *pufiBase,
    DESIGNVECTOR      *pdv,
    ULONG              cjDV
)
{
    BOOL                 bRet = FALSE;
    DOWNLOADDESIGNVECTOR ddv;

    ddv.ufiBase = *pufiBase;
    RtlCopyMemory(&ddv.dv, pdv, cjDV); // small copy

    if (WriteFontDataAsEMFComment(
            pldc,
            EMRI_DESIGNVECTOR,
            &ddv,
            offsetof(DOWNLOADDESIGNVECTOR,dv) + cjDV,
            NULL,
            0))
    {
        MFD1("Done writing DesignVector to spool file\n");
        bRet = TRUE;
    }
    else
    {
        WARNING("WriteDesignVectorToSpooler: spooling error\n");
    }

    return(bRet);
}


/***********************************************************
* BOOL bAddUFIandWriteSpool(HDC,PUNIVERSAL_FONT_ID,BOOL)
* Called only on the print client when subsetter failed
* or when we could not write a subsetted font to the spool file.
*
* History
*   Feb-03-1997  Xudong Wu  [tessiew]
* Wrote it.
************************************************************/
BOOL bAddUFIandWriteSpool(
    HDC                hdc,
    PUNIVERSAL_FONT_ID pufi,
    BOOL               bSubset,
    FLONG              fl
)
{
    PLDC  pldc;
    UNIVERSAL_FONT_ID  ufi = *pufi;

    pldc = GET_PLDC(hdc);

    if (pldc == NULL)
    {
        return (FALSE);
    }

    if(bSubset)
    {
        vRemoveUFIEntry(pldc->ppSubUFIHash, pufi);
    }

    // We might have freed the bucket entry,
    // which means that pufi pointer might not be valid anymore.
    // That is why we saved it above before calling vRemoveUFIEntry.

    if (!pufihAddUFIEntry(pldc->ppUFIHash, &ufi, 0, 0, fl) ||
        !WriteFontToSpoolFile(pldc, &ufi, fl))
    {
        return FALSE;
    }

    return TRUE;
}


#define QUICK_UFIS 8

/**************************************************************************
 * BOOL bDoFontChange( HDC hdc )
 *
 * Called everytime the font changes in the DC.  This routines checks to
 * see if the font has already been packaged in the spool file and if not
 * gets the raw bits for it and packages it into the spool file.
 *
 * History
 *   Dec-12-96  Xudong Wu  [tessiew]
 * Modify it so it can handle the font subsetting.
 *   1-27-95 Gerrit van Wingerden [gerritv]
 * Wrote it.
 *
 ***************************************************************************/

BOOL bDoFontChange( HDC hdc, WCHAR *pwsz, int c, UINT flETO )
{
    PLDC pldc;
    BOOL bRet = FALSE;
    UNIVERSAL_FONT_ID ufi;
    UNIVERSAL_FONT_ID ufiBase;
    DESIGNVECTOR dv;
    ULONG        cjDV = 0;
    ULONG        ulBaseCheckSum;
    FLONG       fl = 0; // initialization essential

    pldc = GET_PLDC( hdc );
    
    if (pldc == NULL)
    {
    WARNING("bDoFontChange: unable to retrieve pldc\n");
    return(FALSE);
    }

    pldc->fl &= ~LDC_FONT_CHANGE;

    if (!NtGdiGetUFI(hdc, &ufi, &dv, &cjDV, &ulBaseCheckSum, &fl))
    {
        WARNING("bDoFontChange: call to GetUFI failed\n");
        return(FALSE);
    }

// if the UFI to which we are forcing mapping does not match the new UFI then
// set forced mapping to the new UFI

    if((pldc->fl & LDC_FORCE_MAPPING) &&
       (!UFI_SAME_FACE(&pldc->ufi,&ufi) || (pldc->fl & LDC_LINKED_FONTS)))
    {
        INT NumLinkedUFIs;

        if (!UFI_SAME_FACE(&pldc->ufi, &ufi))
        {
            if(!MF_ForceUFIMapping(hdc, &ufi))
            {
                WARNING("bDoFontChange: call to MF_ForceUFIMapping failed\n");
                return(FALSE);
            }
            pldc->ufi = ufi;
        }

        if(NtGdiAnyLinkedFonts())
        {
            UNIVERSAL_FONT_ID QuickLinks[QUICK_UFIS];
            PUNIVERSAL_FONT_ID pUFIs = NULL;

            NumLinkedUFIs = NtGdiGetLinkedUFIs(hdc, NULL, 0);

            if (NumLinkedUFIs > 0)
            {
                pldc->fl |= LDC_LINKED_FONTS;

                if(NumLinkedUFIs <= QUICK_UFIS)
                {
                    pUFIs = QuickLinks;
                }
                else
                {
                    pUFIs = LocalAlloc(LMEM_FIXED, NumLinkedUFIs * sizeof(UNIVERSAL_FONT_ID));
                }
            }

            if (pUFIs)
            {
                if(NumLinkedUFIs = NtGdiGetLinkedUFIs(hdc,pUFIs,NumLinkedUFIs))
                {
                    INT u;
                    WORD    *pgi = NULL, agi[MAX_STACK_STRING];
                    BOOL    bNeedLinkFont = FALSE;

                    bRet = TRUE;

                    if((pldc->fl & LDC_DOWNLOAD_FONTS) &&
                        c && pwsz && !(flETO & ETO_GLYPH_INDEX))
                    {
                        if (c > MAX_STACK_STRING)
                        {
                            pgi = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, c * sizeof(WORD));
                        }
                        else
                        {
                            pgi = agi;
                        }
                        
                        // check whether there are glyphs from linked font

                        if (pgi &&
                            NtGdiGetGlyphIndicesW(hdc, pwsz, c, pgi, GGI_MARK_NONEXISTING_GLYPHS) != GDI_ERROR)
                        {
                            for (u = 0; u < c; u++)
                            {
                                if (pgi[u] == 0xffff)
                                {
                                    bNeedLinkFont = TRUE;
                                    break;
                                }
                            }
                        }
                        else
                        {
                            bNeedLinkFont = TRUE; // ship them, just in case
                        }
                        
                        if (bNeedLinkFont)
                        {
                            for(u = 0; u < NumLinkedUFIs; u++)
                            {                            
                                if(pufihFindUFIEntry(pldc->ppUFIHash, &pUFIs[u], FALSE))
                                {
                                // already in spool file or on remote machine so skip it
                                    continue;
                                }
    
                                #if DBG
                                DbgPrint("Writing link to spooler\n");
                                #endif
    
                            // WHAT IS fs2 flag that should be passed to these 2 functions ???
    
                                if(!pufihAddUFIEntry(pldc->ppUFIHash, &pUFIs[u], 0, 0, 0) ||
                                   !WriteFontToSpoolFile(pldc,&pUFIs[u], 0))
                                {
                                    WARNING("GDI32:error writing linked font to spooler\n");
                                    bRet = FALSE;
                                }
                            }
                            if (bRet)
                            {
                                pldc->fl &= ~LDC_LINKED_FONTS;
                            }
                        }
                    }

                    if (pgi && (pgi != agi))
                    {
                        LocalFree(pgi);
                    }
                }

                if(bRet)
                {
                // If there are no linked UFI's we still need to metafile the call
                // so that the server knows to turn off linking.

                    bRet = MF_SetLinkedUFIs(hdc, pUFIs, (UINT)NumLinkedUFIs);
                }

                if(pUFIs != QuickLinks)
                {
                    LocalFree(pUFIs);
                }

                if(!bRet)
                {
                    return(FALSE);
                }
            }
        }
    }


    if( UFI_DEVICE_FONT(&ufi)  ||
       !(pldc->fl & LDC_DOWNLOAD_FONTS) )
    {
        return(TRUE);
    }

// now comes the interesting part:
// If this is a mm instance, we send the base font first (if not sent already)
// and then we send the design vector with the ufi of the base font.

    ufiBase = ufi;

    if (fl & FL_UFI_DESIGNVECTOR_PFF)
    {
    // little bit dirty, we should not know what is in ufi

        ufiBase.CheckSum = ulBaseCheckSum;
    }

    // pldc->ppUFIHash is used to remember all remote fonts which have been
    // copied into the spool file without subset. Once it is in spool file,
    // there is no need to copy again.

    if (pufihFindUFIEntry(pldc->ppUFIHash, &ufiBase, FALSE) == NULL)
    {

        if (fl & FL_UFI_DESIGNVECTOR_PFF)
        {
            pufihAddUFIEntry(pldc->ppUFIHash, &ufiBase,0, 0, fl);
            bRet = WriteFontToSpoolFile(pldc, &ufiBase, fl);

        // now since this is a mm instance, write a design vector object in the spool file
        // if we have not done it already

            if (bRet)
            {
                if (!pufihFindUFIEntry(pldc->ppDVUFIHash, &ufi, FALSE))
                {
                    pufihAddUFIEntry(pldc->ppDVUFIHash, &ufi,0, 0, fl);
                    bRet = WriteDesignVectorToSpoolFile(pldc, &ufiBase, &dv, cjDV);
                }
            }
        }
        else
        {
            BOOL  bFontSubset = TRUE, bSubsetFail = FALSE;
            PUFIHASH pBucket;

        // Check the ppSubUFIHash to see whether ufi already exists

            if ((pBucket = pufihFindUFIEntry(pldc->ppSubUFIHash, &ufi, TRUE)) == NULL)
            {
                ULONG ulCig = NtGdiGetGlyphIndicesW(hdc, NULL, 0, NULL, 0);
                DWORD cjGlyf = NtGdiGetFontData(hdc, 'fylg', 0, NULL, 0);

            // Subset only if ulCig > gulMaxCig AND this is a tt font, not OTF,
            // Which we test by making sure the font has 'glyf' table. ('fylg',)

                if (bFontSubset = ((ulCig != GDI_ERROR) && (ulCig > gulMaxCig) && (cjGlyf != GDI_ERROR) && cjGlyf))
                {
                    #ifdef DBGSUBSET
                    DbgPrint("bDoFontChange  cig= %lx\n", ulCig);
                    #endif

                    if (!(pBucket = pufihAddUFIEntry(pldc->ppSubUFIHash, &ufi, ulCig, FL_UFI_SUBSET, fl)) ||
                        !(bRet = bAddGlyphIndices(hdc, pBucket, pwsz, c, flETO)))  
                    {
                        bSubsetFail = TRUE;
                    }
                }
            }
            else
            {
                if (!(bRet = bAddGlyphIndices(hdc, pBucket, pwsz, c, flETO)))
                {
                    bSubsetFail = TRUE;
                }
            }

            if (bFontSubset && !bSubsetFail)
            {
                pldc->fl |= LDC_FONT_SUBSET;
            }
            else
            {
                bRet = bAddUFIandWriteSpool(hdc, &ufi, bFontSubset,fl);
            }
        }
    }

    return(bRet);
}


BOOL bRecordEmbedFonts(HDC hdc)
{
    ULONG   cEmbedFonts;
    UNIVERSAL_FONT_ID   ufi;
    DESIGNVECTOR dv;
    ULONG        cjDV = 0;
    ULONG        ulBaseCheckSum;
    KERNEL_PVOID embFontID;
    FLONG       fl = 0;
    PLDC pldc;

    if (!NtGdiGetEmbUFI(hdc, &ufi, &dv, &cjDV, &ulBaseCheckSum, &fl, &embFontID))      // get UFI
        return FALSE;

    if ((fl & (FL_UFI_PRIVATEFONT | FL_UFI_MEMORYFONT)) && embFontID )
    {
        if ((pldc = GET_PLDC(hdc)) == NULL)
            return FALSE;
        
        if (!pufihFindUFIEntry(pldc->ppUFIHash, &ufi, FALSE))               // new UFI
        {
            if(!pufihAddUFIEntry(pldc->ppUFIHash, &ufi, 0, 0, 0))
                return FALSE;
            else
            {
                if (!NtGdiChangeGhostFont(&embFontID, TRUE))
                {
                    vRemoveUFIEntry(pldc->ppUFIHash, &ufi);
                    return FALSE;
                }
    
                if (!WriteFontDataAsEMFComment(
                            pldc,
                            EMRI_EMBED_FONT_EXT,
                            &embFontID,
                            sizeof(VOID *),
                            NULL,
                            0))
                {
                    NtGdiChangeGhostFont(&embFontID, FALSE);                  // Can't record it into the spool file
                    return FALSE;
                }
                
                // check to see whether it gets all of the embedded fonts
            
                cEmbedFonts = NtGdiGetEmbedFonts();
            
                if (cEmbedFonts != 0xFFFFFFFF &&
                    (cEmbedFonts == 1 || cEmbedFonts == GetRecdEmbedFonts(pldc->ppUFIHash)))
                {
                    pldc->fl &= ~LDC_EMBED_FONTS;
                }        
            }
        }
    }

    return TRUE;
}

/**************************************************************************
* BOOL RemoteRasterizerCompatible()
*
* This routine is used if we are about to print using remote EMF.  If a
* Type 1 font rasterizer has been installed on the client machine, we need
* to query the remote machine to make sure that it has a rasterizer that is
* compatable with the local version.  If it isn't, we will return false
* telling the caller that we should go RAW.
*
* History
*   6-4-96 Gerrit van Wingerden [gerritv]
* Wrote it.
*
***************************************************************************/

BOOL gbQueriedRasterizerVersion = FALSE;
UNIVERSAL_FONT_ID gufiLocalType1Rasterizer;

BOOL RemoteRasterizerCompatible(HANDLE hSpooler)
{
// if we haven't queried the rasterizer for the version yet do so first

    UNIVERSAL_FONT_ID ufi;
    LARGE_INTEGER TimeStamp;

    if(!gbQueriedRasterizerVersion)
    {
    // we have a contract with NtGdiQueryFonts (the routine called by the spooler
    // on the remote machine) that if a Type1 rasterizer is installed, the UFI
    // for it will always be first in the UFI list returned.  So we can call
    // NtGdiQueryFonts

        if(!NtGdiQueryFonts(&gufiLocalType1Rasterizer, 1, &TimeStamp))
        {
            WARNING("Unable to get local Type1 information\n");
            return(FALSE);
        }

        gbQueriedRasterizerVersion = TRUE;
    }

    if(!UFI_TYPE1_RASTERIZER(&gufiLocalType1Rasterizer))
    {
    // no need to disable remote printing if there is no ATM driver installed
        return(TRUE);
    }

// Since we made it this far there must be a Type1 rasterizer on the local machine.
// Let's find out the version number of the Type1 rasterizer (if one is installed)
// on the print server.


    if((*fpQueryRemoteFonts)(hSpooler, &ufi, 1 ) &&
       (UFI_SAME_RASTERIZER_VERSION(&gufiLocalType1Rasterizer,&ufi)))
    {
        return(TRUE);
    }
    else
    {
        WARNING("Remote Type1 rasterizer missing or wrong version. Going RAW\n");
        return(FALSE);
    }
}


/****************************************************************
* VOID* AllocCallback(VOID* pvBuffer, size_t size)
*
* Passed to CreateFontPackage() to allocate or reallocate memory
*
* History
*  Jan-07-97 Xudong Wu [tessiew]
* Wrote it.
*****************************************************************/
void* WINAPIV AllocCallback(void* pvBuffer, size_t size)
{
    if (size == 0)
    {
        return (void*)NULL;
    }
    else
    {
        return ((void*)(LocalAlloc(LMEM_FIXED, size)));
    }
}


/****************************************************************
* VOID* ReAllocCallback(VOID* pvBuffer, size_t size)
*
* Passed to CreateFontPackage() to allocate or reallocate memory
*
* History
*  Jan-07-97 Xudong Wu [tessiew]
* Wrote it.
*****************************************************************/
void* WINAPIV ReAllocCallback(void* pvBuffer, size_t size)
{
    if (size == 0)
    {
        return (void*)NULL;
    }
    else if (pvBuffer == (void*)NULL)
    {
        return ((void*)(LocalAlloc(LMEM_FIXED, size)));
    }
    else
    {
        return ((void*)(LocalReAlloc(pvBuffer, size, LMEM_MOVEABLE)));
    }
}


/*******************************************************
* VOID* FreeCallback(VOID* pvBuffer)
*
* Passed to CreateFontPackage() to free memory
*
* History
*  Jan-07-97 Xudong Wu [tessiew]
* Wrote it.
********************************************************/
void WINAPIV FreeCallback(void* pvBuffer)
{
    if (pvBuffer)
    {
        if (LocalFree(pvBuffer))
        {
            WARNING("FreeCallback(): Can't free the local memory\n");
        }
    }
}

/*****************************************************************************
* BOOL bInitSubsetterFunctionPointer(PVOID *ppfn)
*
* the name says it all
*
* History
*   Dec-18-96 Xudong Wu [tessiew]
* Wrote it.
*
******************************************************************************/


BOOL bInitSubsetterFunctionPointer(PVOID *ppfn)
{
    BOOL bRet = TRUE;

    if (*ppfn == NULL)
    {
        HANDLE hFontSubset = LoadLibraryW(L"fontsub.dll");

        if (hFontSubset)
        {
            *ppfn = (PVOID)GetProcAddress(hFontSubset,
                                         (ppfn == (PVOID *)&gfpCreateFontPackage) ?
                                         "CreateFontPackage" : "MergeFontPackage");

            if (*ppfn == NULL)
            {
                FreeLibrary(hFontSubset);
                WARNING("GetProcAddress(fontsub.dll) failed\n");
                bRet = FALSE;
            }
        }
        else
        {
            WARNING("LoadLibrary(fontsub.dll) failed\n");
            bRet = FALSE;
        }
    }
    return bRet;
}

/*****************************************************************************
* BOOL bDoFontSubset
*
* Called everytime we need to subset a font. This routine converts the bit
* fields of pjMemory/u.ssi.pjDelta in pBucket into a glyph index list and call the
* font subsetting functions to generate subset/delta font.
*
* History
*   Dec-18-96 Xudong Wu [tessiew]
* Wrote it.
*
******************************************************************************/

BOOL bDoFontSubset(PUFIHASH pBucket,
    PUCHAR* ppuchDestBuff, // output: buffer will contain the subsetted image or delta
    ULONG* pulDestSize,    // output: size of the buffer above, may be more than needed
    ULONG* pulBytesWritten // output: bytes written into the buffer above
)
{
    BOOL     bDelta = pBucket->fs1 & FLUFI_DELTA;
    USHORT  *pusSubsetKeepList = NULL;
    ULONG   cSubset; // number of glyphs to be subsetted
    BOOL    bRet = FALSE;

#ifdef  DBGSUBSET
    FILETIME    fileTimeStart, fileTimeEnd;
    if (gflSubset & FL_SS_SUBSETTIME)
    {
        GetSystemTimeAsFileTime(&fileTimeStart);
    }
#endif

    ENTERCRITICALSECTION(&semLocal);
    bRet = bInitSubsetterFunctionPointer((PVOID *)&gfpCreateFontPackage);
    LEAVECRITICALSECTION(&semLocal);

    if (!bRet)
        return FALSE;
    bRet = FALSE;

    cSubset = bDelta ? pBucket->u.ssi.cDeltaGlyphs : pBucket->u.ssi.cGlyphsSoFar;

#ifdef  DBGSUBSET
    if (gflSubset & FL_SS_KEEPLIST)
    {
        DbgPrint("\t%ld", cSubset);
    }
#endif //  DBGSUBSET

    pusSubsetKeepList = (USHORT*)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(USHORT) * cSubset);

    if (pusSubsetKeepList == NULL)
    {
        WARNING("bDoFontSubset unable to allocate memory for pusSubsetKeepList\n");
        return FALSE;
    }

// transfer appropriate bit field into glyph indices

    if (bGetDistGlyphIndices(pBucket, pusSubsetKeepList, bDelta))
    {
        WCHAR    pwszPathname[MAX_PATH * 3];
        ULONG    cwcPathname, cNumFiles;
        BOOL     bMemFont = FALSE, bMapOK = TRUE;
        ULONG    cjView;
        PVOID    pvView = NULL;
        BOOL     bTTC = FALSE;
        ULONG    iTTC = 0;

        if (NtGdiGetUFIPathname(&pBucket->ufi,
                                &cwcPathname,
                                pwszPathname,
                                &cNumFiles,
                                pBucket->fs2,
                                &bMemFont,
                                &cjView,
                                NULL,
                                &bTTC,
                                &iTTC))

        {
            PVOID   pvSrcBuff;
            ULONG   ulSrcSize;
            CLIENT_SIDE_FILEVIEW  fvw;

            if (!bMemFont)
            {
                ASSERTGDI(cNumFiles == 1, "bDoFontSubset:  cNumFiles != 1\n");

                if (bMapOK = bMapFileUNICODEClideSide(pwszPathname, &fvw, TRUE))
                {
                    pvSrcBuff = (PVOID)fvw.pvView;
                    ulSrcSize = fvw.cjView;
                }
            }
            else
            {
                pvView = LocalAlloc(LMEM_FIXED, cjView);
                if (pvView)
                {
                    if (NtGdiGetUFIPathname(&pBucket->ufi,NULL,NULL,NULL,
                        pBucket->fs2,NULL,NULL,pvView,NULL,NULL))
                    {
                        bMapOK = TRUE;
                        pvSrcBuff = (PVOID)pvView;
                        ulSrcSize = cjView;
                    }
                    else
                    {
                        LocalFree(pvView);
                    }
                }
            }

            if (bMapOK)
            {
            // font subsetting

                ASSERTGDI(gfpCreateFontPackage != NULL, "fonsub.dll is not load\n");

                if ((*gfpCreateFontPackage)((PUCHAR)pvSrcBuff,
                                             ulSrcSize,
                                             ppuchDestBuff,
                                             pulDestSize,
                                             pulBytesWritten,
                                             (USHORT)(bTTC ? 0x000d : 0x0009),      // TTFCFP_FLAGS_SUBSET | TTFCFP_FLAGS_GLYPHLIST
                                             (USHORT)iTTC,                // usTTCIndex
                                             (USHORT)(bDelta ? 2 : 1),    // usSubsetFormat
                                             0,                           // usSubsetLanguage
                                             3,                           // usSubsetPlatform  TTFCFP_MS_PLATFORMID
                                             0xFFFF,                      // usSubsetEncoding  TTFCFP_DONT_CARE
                                             pusSubsetKeepList,
                                             (USHORT)cSubset,
                                             (CFP_ALLOCPROC)AllocCallback,
                                             (CFP_REALLOCPROC)ReAllocCallback,
                                             (CFP_FREEPROC)FreeCallback,
                                             NULL)  != 0)
                {
                    WARNING("bDofontSubset failed on gfpCreateFontPackage\n");
                }
                else
                {
                    if (bDelta)      // clean up the u.ssi.pjDelta and u.ssi.cDeltaGlyphs
                    {
                        LocalFree(pBucket->u.ssi.pjDelta);
                        pBucket->u.ssi.pjDelta = NULL;
                        pBucket->u.ssi.cDeltaGlyphs = 0;
                    }
                    else    // set fs1 to prepare for the next page.
                    {
                        pBucket->fs1 = FLUFI_DELTA;
                    }

                    bRet = TRUE;
                }

                if (bMemFont)
                {
                    LocalFree(pvView);
                }
                else
                {
                    vUnmapFileClideSide(&fvw);
                }
            }
            else
            {
                WARNING("bDoFontSubset: failed on bMapFileUNICODEClideSide()\n");
            }
        }
        else
        {
            WARNING("bDoFontSubset: failed on NtGdiGetUFIPathname()\n");
        }
    }
    else
    {
        WARNING("bDoFontSubset: failed on bGetDistGlyphIndices()\n");
    }

    LocalFree(pusSubsetKeepList);

//Timing code
#ifdef  DBGSUBSET
    if (gflSubset & FL_SS_SUBSETTIME)
    {
        GetSystemTimeAsFileTime(&fileTimeEnd);
        DbgPrint("\t%ld",
            (fileTimeEnd.dwLowDateTime - fileTimeStart.dwLowDateTime) / 10000);
    }
#endif

    return bRet;
}

/************************************************************************************
* BOOL WriteSubFontToSpoolFile(HANDLE, PUCHAR, ULONG, UNIVERSAL_FONT_ID, BOOL)
*
* Write subsetted font or a delta in the print spool file.
*
* History
*   Jan-09-97 Xudong Wu [tessiew]
* Wrote it.
*
*************************************************************************************/
BOOL  WriteSubFontToSpoolFile(
    PLDC               pldc,
    PUCHAR             puchBuff,         // image pointer
    ULONG              ulBytesWritten,   // bytes to be written to spool file
    UNIVERSAL_FONT_ID *pufi,             // ufi of the original font file
    BOOL               bDelta            // delta or first page
)
{
    BOOL bRet = FALSE;

#ifdef  DBGSUBSET
    FILETIME    fileTimeStart, fileTimeEnd;
    if (gflSubset & FL_SS_SPOOLTIME)
    {
        GetSystemTimeAsFileTime(&fileTimeStart);
    }
#endif

    if (ulBytesWritten)
    {
        DWORD ulID = bDelta ? EMRI_DELTA_FONT : EMRI_SUBSET_FONT;

    #ifdef  DBGSUBSET
        if (gflSubset & FL_SS_BUFFSIZE)
        {
            DbgPrint("\t%ld\n", ulBytesWritten);
        }
    #endif // DBGSUBSET

        if (WriteFontDataAsEMFComment(
                    pldc,
                    ulID,
                    pufi,
                    sizeof(UNIVERSAL_FONT_ID),
                    puchBuff,
                    ulBytesWritten))
        {
            bRet = TRUE;
        }
        else
        {
            WARNING("WriteSubFontToSpooler: error writing to printer\n");
        }

        LocalFree(puchBuff);
    }
    else
    {
        WARNING("WriteSubFontToSpooler: input ulBytesWritten == 0\n");
    }

//timing code
#ifdef  DBGSUBSET
    if (gflSubset & FL_SS_SPOOLTIME)
    {
        GetSystemTimeAsFileTime(&fileTimeEnd);
        DbgPrint("\t%ld", (fileTimeEnd.dwLowDateTime - fileTimeStart.dwLowDateTime) / 10000);
    }
#endif
    return(bRet);
}


/************************************************************************************
* BOOL bMergeSubsetFont(HDC, PVOID, ULONG, PVOID*, ULONG*, BOOL, UNIVERSAL_FONT_ID*)
*
* Merge the font delta into a working font containing pages up to this one.
* This routine is only called on print server
*
* History
*   Jan-12-97 Xudong Wu [tessiew]
* Wrote it.
*
*************************************************************************************/
BOOL bMergeSubsetFont(
    HDC    hdc,
    PVOID  pvBuf,
    ULONG  ulBuf,
    PVOID* ppvOutBuf,
    ULONG* pulOutSize,
    BOOL   bDelta,
    UNIVERSAL_FONT_ID *pufi)
{
    PLDC   pldc;
    PBYTE  pjBase;
    ULONG  ulMergeBuf, ulBytesWritten, ulBaseFontSize = 0;
    PVOID  pvMergeBuf, pvBaseFont = NULL;
    UFIHASH  *pBucket = NULL;
    BOOL    bRet = FALSE;

#define SZDLHEADER    ((sizeof(DOWNLOADFONTHEADER) + 7)&~7)

    ENTERCRITICALSECTION(&semLocal);
    bRet = bInitSubsetterFunctionPointer((PVOID *)&gfpMergeFontPackage);
    LEAVECRITICALSECTION(&semLocal);

    if (!bRet)
        return FALSE;

// get the orignal UFI

    *pufi = *(PUNIVERSAL_FONT_ID) pvBuf;

    pjBase = (PBYTE)pvBuf + sizeof(UNIVERSAL_FONT_ID);
    ulBuf -= sizeof(UNIVERSAL_FONT_ID);

    pldc = GET_PLDC(hdc);

    if (pldc == NULL)
    {
    WARNING("bMergeSubsetFont: unable to retrieve pldc\n");
    return FALSE;
    }

    ASSERTGDI(!pldc->ppUFIHash, "printer server side ppUFIHash != NULL\n");
    ASSERTGDI(!pldc->ppDVUFIHash,"printer server side ppDVUFIHash != NULL\n");

// init the hash table if needed

    if (pldc->ppSubUFIHash == NULL)
    {
        pldc->ppSubUFIHash = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(PUFIHASH) * UFI_HASH_SIZE);

        if(pldc->ppSubUFIHash == NULL)
        {
            WARNING("bMergeSubsetFont: unable to allocate UFI hash table2\n");
            return FALSE;
        }
    }

// for delta merge, get the font image from pBucket->u.mvw.pjMem

    if (bDelta)
    {
        pBucket = pufihFindUFIEntry(pldc->ppSubUFIHash, pufi, TRUE);

        if (!pBucket)
            return FALSE;
            
    // We need to exclude the DOWNLOADFONTHEADER
    // information from the pBucket->u.mvw.pjMem

        pvBaseFont = pBucket->u.mvw.pjMem + SZDLHEADER;
        ulBaseFontSize = pBucket->u.mvw.cjMem - SZDLHEADER;
    }

    if ((*gfpMergeFontPackage)((UCHAR*)pvBaseFont, ulBaseFontSize,
                                   (PUCHAR)pjBase, ulBuf,
                                   (PUCHAR*)&pvMergeBuf, &ulMergeBuf, &ulBytesWritten,
                                   (USHORT) (bDelta ? 2 : 1),     //usMode 1=generate font; 2=delta merge
                                   (CFP_ALLOCPROC)AllocCallback,
                                   (CFP_REALLOCPROC)ReAllocCallback,
                                   (CFP_FREEPROC)FreeCallback,
                                   NULL) != 0)
    {
        WARNING("MergeSubsetFont failed on funsub!MergeFontPackage\n");
    }
    else
    {
    // In order to use FreeFileView when we delete the font after printing,
    // we need a fake DOWNLOADFONTHEADER
    // before we pass the buffer into kenerl for NtGdiAddRemoteFontToDC call.

        *pulOutSize = SZDLHEADER + ulBytesWritten;
        *ppvOutBuf = (PVOID*)LocalAlloc(LMEM_FIXED, *pulOutSize);

        if (*ppvOutBuf == NULL)
        {
            WARNING("bMergeSubsetFont failed to alloc memory\n");
        }
        else
        {
            DOWNLOADFONTHEADER  *pdfh;

            pdfh = (DOWNLOADFONTHEADER*)*ppvOutBuf;
            pdfh->Type1ID = 0;
            pdfh->NumFiles = 1;
            pdfh->FileOffsets[0] = ulBytesWritten;

            RtlCopyMemory((PVOID)((PBYTE)*ppvOutBuf + SZDLHEADER), pvMergeBuf, ulBytesWritten);

            if (bWriteUFItoDC(pldc->ppSubUFIHash, pufi, pBucket, *ppvOutBuf, *pulOutSize))
            {
                bRet = TRUE;
            }
            else
            {
                LocalFree(*ppvOutBuf);
                WARNING("bMergeSubsetFont failed on bWriteUFItoDC\n");
            }
        }

// pvMergeBuf comes from the merge routine which uses LMEM_MOVEABLE
// for memory allocation Needs to be freed by the handle.

        LocalFree(pvMergeBuf);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\xform.c ===
/******************************Module*Header*******************************\
* Module Name: xform.c
*
* Created: 01-Dec-1994 09:58:41
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1993-1999 Microsoft Corporation
*
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop


/******************************Macro***************************************\
*
* Transform macros
*
*
*
*
*
*
*
* History:
*
*    16-Jan-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/


#define DCA_PAGE_EXTENTS_CHANGED(pdcattr)               \
{                                                       \
    CLEAR_CACHED_TEXT(pdcattr);                         \
    pdcattr->flXform |= (INVALIDATE_ATTRIBUTES    |     \
                         PAGE_EXTENTS_CHANGED     |     \
                         DEVICE_TO_WORLD_INVALID);      \
}

#define DCA_PAGE_XLATE_CHANGED(pdcattr)                 \
{                                                       \
    pdcattr->flXform |=  (PAGE_XLATE_CHANGED |          \
                          DEVICE_TO_WORLD_INVALID);     \
}


#define GET_LOGICAL_WINDOW_ORG_X(pdcattr, pptl)         \
{                                                       \
    pptl->x  = pdcattr->lWindowOrgx;                    \
}

#define SET_LOGICAL_WINDOW_ORG_X(pdcattr, x)            \
{                                                       \
    pdcattr->lWindowOrgx = x;                           \
}

#define MIRROR_WINDOW_ORG(hdc, pdcAttr)                 \
{                                                       \
    if (pdcAttr->dwLayout & LAYOUT_RTL) {               \
        NtGdiMirrorWindowOrg(hdc);                      \
    }                                                   \
}

#define MIRROR_X(pdcAttr, x)                            \
{                                                       \
    if (pdcAttr->dwLayout & LAYOUT_RTL)                 \
        x = -x;                                         \
}

DWORD APIENTRY
SetLayoutWidth(HDC hdc, LONG wox, DWORD dwLayout)
{

    DWORD dwRet = GDI_ERROR;

    FIXUP_HANDLE(hdc);
    if(!IS_ALTDC_TYPE(hdc))
    {
        PDC_ATTR pdcattr;
        PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

        if (pdcattr) {
            dwRet = NtGdiSetLayout(hdc, wox, dwLayout);
        } else {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }

    return dwRet;
}

DWORD APIENTRY
SetLayout(HDC hdc, DWORD dwLayout)
{
    PDC_ATTR pdcattr;
    DWORD dwRet = GDI_ERROR;

    FIXUP_HANDLE(hdc);
    if(IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsD(hdc,dwLayout,META_SETLAYOUT));

        DC_PLDC(hdc,pldc,dwRet)

        if (pldc->iType == LO_METADC) {
            if (!MF_SetD(hdc,dwLayout,EMR_SETLAYOUT)) {
                return dwRet;
            }
        }
    }

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr) {
        dwRet = NtGdiSetLayout(hdc, -1, dwLayout);
    } else {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return dwRet;
}

DWORD APIENTRY
GetLayout(HDC hdc)
{
    DWORD dwRet = GDI_ERROR;

    FIXUP_HANDLE(hdc);

    if(!IS_METADC16_TYPE(hdc)) {
        PDC_ATTR pdcattr;
        PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

        if (pdcattr) {
            dwRet = pdcattr->dwLayout;
        } else {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }
    return dwRet;
}
/******************************Public*Routine******************************\
* GetMapMode                                                               *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Fri 07-Jun-1991 18:01:50 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

int APIENTRY GetMapMode(HDC hdc)
{
    int iRet = 0;

    FIXUP_HANDLE(hdc);

    if (!IS_METADC16_TYPE(hdc))
    {
        PDC_ATTR pdcattr;
        PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

        if (pdcattr)
        {
            iRet = pdcattr->iMapMode;
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* SetMapMode                                                               *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
*                                                                          *
*  Mon 22-May-1993 -by- Paul Butzi                                         *
* Converted to Size measured in micrometers.                               *
\**************************************************************************/

int META WINAPI SetMapMode(HDC hdc,int iMode)
{
    int iRet = 0;

    FIXUP_HANDLE(hdc);

    if (IS_METADC16_TYPE(hdc))
    {
        iRet = MF16_RecordParms2(hdc,iMode,META_SETMAPMODE);
    }
    else
    {
        PDC_ATTR pdcattr;
        PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

        if (pdcattr)
        {

            iRet = pdcattr->iMapMode;

            if ((iMode != pdcattr->iMapMode) || (iMode == MM_ISOTROPIC))
            {

               CLEAR_CACHED_TEXT(pdcattr);

               iRet =(int) GetAndSetDCDWord(
                                         hdc,
                                         GASDDW_MAPMODE,
                                         iMode,
                                         EMR_SETMAPMODE,
                                         0,
                                         0);
            }
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }

    return(iRet);
}

/******************************Public*Function*****************************\
* GetWindowExtEx
* GetViewportOrgEx
* GetWindowOrgEx
*
* Client side stub.
*
* History:
*
*  11-Jan-1996 -by- Mark Enstrom [marke]
* User dcattr for ext and org data
*  09-Dec-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetViewportExtEx(HDC hdc,LPSIZE psizl)
{
    BOOL bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        if (psizl != (PSIZEL) NULL)
        {
            if ((pdcattr->flXform & PAGE_EXTENTS_CHANGED) &&
                (pdcattr->iMapMode == MM_ISOTROPIC))
            {
                NtGdiGetDCPoint (hdc, DCPT_VPEXT, (PPOINTL)psizl);
            }
            else
            {
                *psizl = pdcattr->szlViewportExt;
            }

            bRet = TRUE;
        }
    }

    return(bRet);

}

BOOL APIENTRY GetWindowExtEx(HDC hdc,LPSIZE psizl)
{
   BOOL bRet = FALSE;
   PDC_ATTR pdcattr;

   FIXUP_HANDLE(hdc);

   PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

   if (pdcattr)
   {
       if (psizl != (PSIZEL) NULL)
       {
           *psizl = pdcattr->szlWindowExt;
           MIRROR_X(pdcattr, psizl->cx);
           bRet = TRUE;
       }
   }

   return(bRet);

}

BOOL APIENTRY GetViewportOrgEx(HDC hdc,LPPOINT pptl)
{
    BOOL bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);
    //
    // get DCATTR
    //

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {

        if (pptl != (LPPOINT) NULL)
        {
            *pptl = *((LPPOINT)&pdcattr->ptlViewportOrg);
            MIRROR_X(pdcattr, pptl->x);
            bRet = TRUE;
        }
    }

    return(bRet);

}

BOOL APIENTRY GetWindowOrgEx(HDC hdc,LPPOINT pptl)
{
    BOOL bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    //
    // get DCATTR
    //

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {

        if (pptl != (LPPOINT) NULL)
        {
            *pptl = *((LPPOINT)&pdcattr->ptlWindowOrg);
            GET_LOGICAL_WINDOW_ORG_X(pdcattr, pptl);
            bRet = TRUE;
        }
    }

    return(bRet);

}

/******************************Public*Routine******************************\
* SetViewportExtEx                                                         *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI SetViewportExtEx(HDC hdc,int x,int y,LPSIZE psizl)
{
    BOOL bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParms3(hdc,x,y,META_SETVIEWPORTEXT));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetViewportExtEx(hdc,x,y))
                return(bRet);
        }
    }

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        //
        // if psizl is supplied, return old viewport ext
        //

        if (psizl != (PSIZEL) NULL)
        {
            *psizl = pdcattr->szlViewportExt;
        }

        //
        // if fixed scale and new exts equal old exts then no work needs
        // to be done
        //

        if (
             (pdcattr->iMapMode <= MM_MAX_FIXEDSCALE) ||
             (
               (pdcattr->szlViewportExt.cx == x) &&
               (pdcattr->szlViewportExt.cy == y)
             )
           )
        {
            return(TRUE);
        }

        //
        // Can't set to zero extents.
        //

        if ((x == 0) || (y == 0))
        {
            return(TRUE);
        }

        //
        // update extents and flags
        //
        CHECK_AND_FLUSH(hdc, pdcattr);

        pdcattr->szlViewportExt.cx = x;
        pdcattr->szlViewportExt.cy = y;
        MIRROR_WINDOW_ORG(hdc, pdcattr);

        DCA_PAGE_EXTENTS_CHANGED(pdcattr);

        return(TRUE);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SetViewportOrgEx                                                         *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI SetViewportOrgEx(HDC hdc,int x,int y,LPPOINT pptl)
{
    POINT pt;
    BOOL bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParms3(hdc,x,y,META_SETVIEWPORTORG));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetViewportOrgEx(hdc,x,y))
                return(bRet);
        }
    }

    //
    // get DCATTR
    //

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        bRet = TRUE;
        MIRROR_X(pdcattr, x);

        if (pptl != (LPPOINT) NULL)
        {
            *pptl = *((LPPOINT)&pdcattr->ptlViewportOrg);
            MIRROR_X(pdcattr, pptl->x);
        }

        if (!
             ((pdcattr->ptlViewportOrg.x == x) && (pdcattr->ptlViewportOrg.y == y))
           )
        {
             pdcattr->ptlViewportOrg.x = x;
             pdcattr->ptlViewportOrg.y = y;

             DCA_PAGE_XLATE_CHANGED(pdcattr);
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SetWindowExtEx                                                           *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI SetWindowExtEx(HDC hdc,int x,int y,LPSIZE psizl)
{
    BOOL bRet = FALSE;
    PDC_ATTR pdcattr;

#if DBG_XFORM
    DbgPrint("SetWindowExtEx: hdc = %p, (%lx, %lx)\n", hdc, x, y);
#endif

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParms3(hdc,x,y,META_SETWINDOWEXT));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetWindowExtEx(hdc,x,y))
                return(bRet);
        }
    }

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        bRet = TRUE;

        //
        // Get old extents and return if either of these is true
        // 1) Fixed scale mapping mode.  (Can't change extent)
        // 2) Set to the same size.
        //
        MIRROR_X(pdcattr, x);

        if (psizl != (PSIZEL) NULL)
        {
            *psizl = pdcattr->szlWindowExt;
            MIRROR_X(pdcattr, psizl->cx);
        }

        if (
             (pdcattr->iMapMode <= MM_MAX_FIXEDSCALE) ||
             ((pdcattr->szlWindowExt.cx == x) && (pdcattr->szlWindowExt.cy == y))
           )
        {
            return(TRUE);
        }

        //
        // Can't set to zero.
        //

        if (x == 0 || y == 0)
        {
            return(FALSE);
        }

        CHECK_AND_FLUSH(hdc,pdcattr);

        pdcattr->szlWindowExt.cx = x;
        pdcattr->szlWindowExt.cy = y;
        MIRROR_WINDOW_ORG(hdc, pdcattr);

        DCA_PAGE_EXTENTS_CHANGED(pdcattr);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SetWindowOrgEx                                                           *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI SetWindowOrgEx(HDC hdc,int x,int y,LPPOINT pptl)
{
    BOOL bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParms3(hdc,x,y,META_SETWINDOWORG));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetWindowOrgEx(hdc,x,y))
                return(bRet);
        }
    }

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {

        bRet = TRUE;

        if (pptl != (LPPOINT) NULL)
        {
            *pptl = *((LPPOINT)&pdcattr->ptlWindowOrg);
            GET_LOGICAL_WINDOW_ORG_X(pdcattr, pptl);
        }

        if (
            !((pdcattr->ptlWindowOrg.x == x) && (pdcattr->ptlWindowOrg.y == y))
           )
        {
            CHECK_AND_FLUSH(hdc,pdcattr);

            pdcattr->ptlWindowOrg.x = x;
            pdcattr->ptlWindowOrg.y = y;
            SET_LOGICAL_WINDOW_ORG_X(pdcattr, x);
            MIRROR_WINDOW_ORG(hdc, pdcattr);

            DCA_PAGE_XLATE_CHANGED(pdcattr);
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* OffsetViewportOrgEx                                                      *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI OffsetViewportOrgEx(HDC hdc,int x,int y,LPPOINT pptl)
{
    POINT pt;
    BOOL bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParms3(hdc,x,y,META_OFFSETVIEWPORTORG));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_OffsetViewportOrgEx(hdc,x,y))
                return(bRet);
        }
    }

    //
    // get DCATTR
    //

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        bRet = TRUE;
        MIRROR_X(pdcattr, x);

        if (pptl != (LPPOINT) NULL)
        {
            *pptl = *((LPPOINT)&pdcattr->ptlViewportOrg);
            MIRROR_X(pdcattr, pptl->x);
        }

        if ((x != 0) || (y != 0))
        {
            CHECK_AND_FLUSH(hdc, pdcattr);

            pdcattr->ptlViewportOrg.x+=x;
            pdcattr->ptlViewportOrg.y+=y;

            DCA_PAGE_XLATE_CHANGED(pdcattr);
        }

    }

    return(bRet);
}

/******************************Public*Routine******************************\
* OffsetWindowOrgEx                                                        *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI OffsetWindowOrgEx(HDC hdc,int x,int y,LPPOINT pptl)
{
    BOOL bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParms3(hdc,x,y,META_OFFSETWINDOWORG));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_OffsetWindowOrgEx(hdc,x,y))
                return(bRet);
        }
    }

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {

        bRet = TRUE;

        if (pptl != (LPPOINT) NULL)
        {
            *pptl = *((LPPOINT)&pdcattr->ptlWindowOrg);
            GET_LOGICAL_WINDOW_ORG_X(pdcattr, pptl);
        }

        if ((x != 0) || (y != 0))
        {
            CHECK_AND_FLUSH(hdc,pdcattr);

            pdcattr->ptlWindowOrg.x+=x;
            pdcattr->ptlWindowOrg.y+=y;
            pdcattr->lWindowOrgx   +=x;
            DCA_PAGE_XLATE_CHANGED(pdcattr);
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
*
* int SetGraphicsMode(HDC hdc,int iMode)
*
* the same as SetGraphicsMode, except it does not do any checks
*
* History:
*  3-Nov-1994 -by- Lingyun Wang [lingyunw]
* moved client side attr to server side
*  02-Dec-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int META APIENTRY SetGraphicsMode(HDC hdc,int iMode)
{
    int iRet = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE((PVOID)pDcAttr,hdc,DC_TYPE);

    if (pDcAttr &&
        ((iMode == GM_COMPATIBLE) || (iMode == GM_ADVANCED)))

    {
        if (iMode == pDcAttr->iGraphicsMode)
            return iMode;

        CLEAR_CACHED_TEXT(pDcAttr);

        iRet = pDcAttr->iGraphicsMode;

        CHECK_AND_FLUSH(hdc,pDcAttr);

        pDcAttr->iGraphicsMode = iMode;


    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* ScaleViewportExtEx                                                         *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI ScaleViewportExtEx
(
    HDC hdc,
    int xNum,
    int xDenom,
    int yNum,
    int yDenom,
    LPSIZE psizl
)
{
    BOOL bRet = FALSE;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms5(hdc,xNum,xDenom,yNum,
                                      yDenom,META_SCALEVIEWPORTEXT));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetDDDD(hdc,(DWORD)xNum,(DWORD)xDenom,
                            (DWORD)yNum,(DWORD)yDenom,EMR_SCALEVIEWPORTEXTEX))
                return(bRet);
        }
    }

    PSHARED_GET_VALIDATE((PVOID)pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        CLEAR_CACHED_TEXT(pDcAttr);
        bRet = NtGdiScaleViewportExtEx(hdc,xNum,xDenom,yNum,yDenom,psizl);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* ScaleWindowExtEx                                                         *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI ScaleWindowExtEx
(
    HDC hdc,
    int xNum,
    int xDenom,
    int yNum,
    int yDenom,
    LPSIZE psizl
)
{
    BOOL  bRet = FALSE;

    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms5(hdc,xNum,xDenom,yNum,yDenom,META_SCALEWINDOWEXT));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetDDDD(hdc,(DWORD)xNum,(DWORD)xDenom,(DWORD)yNum,(DWORD)yDenom,EMR_SCALEWINDOWEXTEX))
                return(bRet);
        }
    }

    PSHARED_GET_VALIDATE((PVOID)pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        CLEAR_CACHED_TEXT(pDcAttr);
        bRet = NtGdiScaleWindowExtEx(hdc,xNum,xDenom,yNum,yDenom,psizl);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SetVirtualResolution                                                     *
*                                                                          *
* Client side stub.  This is a private api for metafile component.         *
*                                                                          *
* Set the virtual resolution of the specified dc.                          *
* The virtual resolution is used to compute transform matrix in metafiles. *
* Otherwise, we will need to duplicate server transform code here.         *
*                                                                          *
* If the virtual units are all zeros, the default physical units are used. *
* Otherwise, non of the units can be zero.                                 *
*                                                                          *
* Currently used by metafile component only.                               *
*                                                                          *
* History:                                                                 *
*  Tue Aug 27 16:55:36 1991     -by-    Hock San Lee    [hockl]            *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI SetVirtualResolution
(
    HDC    hdc,
    int    cxVirtualDevicePixel,     // Width of the device in pels
    int    cyVirtualDevicePixel,     // Height of the device in pels
    int    cxVirtualDeviceMm,        // Width of the device in millimeters
    int    cyVirtualDeviceMm         // Height of the device in millimeters
)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiSetVirtualResolution(
                hdc,
                cxVirtualDevicePixel,
                cyVirtualDevicePixel,
                cxVirtualDeviceMm,
                cyVirtualDeviceMm
                ));
}

/******************************Public*Routine******************************\
* SetSizeDevice                                                            *
*                                                                          *
* Client side stub.  This is a private api for metafile component.         *
*                                                                          *
* This is to fix rounding error in vMakeIso in xformgdi.cxx                *
* The cx/yVirtualDeviceMm set in SetVirtualResoltion could result in slight*
* rounding error which will cause problem when accumulated                 *
*                                                                          *
* Currently used by metafile component only.                               *
*                                                                          *
* History:                                                                 *
*  5/17/99     -by-    Lingyun Wang    [lingyunw]                          *
* Wrote it.                                                                *
\**************************************************************************/
BOOL SetSizeDevice
(
    HDC    hdc,
    int    cxVirtualDevice,        // Width of the device in micrometers
    int    cyVirtualDevice         // Height of the device in micrometers
)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiSetSizeDevice(
                hdc,
                cxVirtualDevice,
                cyVirtualDevice
                ));
}


/******************************Public*Routine******************************\
* GetTransform()
*
* History:
*  30-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetTransform(
    HDC     hdc,
    ULONG   iXform,
    PXFORM  pxf)
{
    FIXUP_HANDLE(hdc);
    return(NtGdiGetTransform(hdc,iXform,pxf));
}

/******************************Public*Routine******************************\
* GetWorldTransform                                                        *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Fri 07-Jun-1991 18:01:50 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL APIENTRY GetWorldTransform(HDC hdc,LPXFORM pxform)
{
    FIXUP_HANDLE(hdc);
    return(GetTransform(hdc,XFORM_WORLD_TO_PAGE,pxform));
}

/******************************Public*Routine******************************\
* ModifyTransform()
*
* History:
*  30-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI ModifyWorldTransform(
    HDC          hdc,
    CONST XFORM *pxf,
    DWORD        iMode)
{
    BOOL bRet = FALSE;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(FALSE);

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (((iMode == MWT_SET) && !MF_SetWorldTransform(hdc,pxf)) ||
                !MF_ModifyWorldTransform(hdc,pxf,iMode))
            {
                return(FALSE);
            }
        }
    }

    PSHARED_GET_VALIDATE((PVOID)pDcAttr,hdc,DC_TYPE);
    if (pDcAttr)
    {
        if (pDcAttr->iGraphicsMode == GM_ADVANCED)
        {
            CLEAR_CACHED_TEXT(pDcAttr);
            bRet = NtGdiModifyWorldTransform(hdc,(PXFORM)pxf,iMode);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }
    return(bRet);
}

/******************************Public*Routine******************************\
* SetWorldTransform                                                        *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI SetWorldTransform(HDC hdc, CONST XFORM * pxform)
{
    return(ModifyWorldTransform(hdc,pxform,MWT_SET));
}

/******************************Public*Routine******************************\
* CombineTransform                                                         *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 30-Jan-1992 16:10:09 -by- Wendy Wu [wendywu]                        *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI CombineTransform
(
     LPXFORM pxformDst,
     CONST XFORM * pxformSrc1,
     CONST XFORM * pxformSrc2
)
{
    return(NtGdiCombineTransform(pxformDst,(PXFORM)pxformSrc1,(PXFORM)pxformSrc2));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\gdiplus\gpprefix.h ===
/**************************************************************************
*                                                                         
* gpprefix.h -- GDI+ header file which prepends all of the GDI+ exports
*               with a 'Gp' prefix.
*                                                                    
* Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.           
*                                                                    
**************************************************************************/

#if defined(_GDIPLUS_)

#define GetTextFaceAliasW               GpGetTextFaceAliasW	  	
#define AbortDoc                        GpAbortDoc
#define AddFontResourceA                GpAddFontResourceA
#define AddFontResourceW                GpAddFontResourceW
#define AddFontResourceExA              GpAddFontResourceExA
#define AddFontResourceExW              GpAddFontResourceExW
#define AddFontMemResourceEx            GpAddFontMemResourceEx
#define AngleArc                        GpAngleArc
#define Arc                             GpArc
#define BitBlt                          GpBitBlt
#define CancelDC                        GpCancelDC
#define ChoosePixelFormat               GpChoosePixelFormat
#define Chord                           GpChord
#define CloseMetaFile                   GpCloseMetaFile
#define CloseEnhMetaFile                GpCloseEnhMetaFile
#define CombineRgn                      GpCombineRgn
#define CombineTransform                GpCombineTransform
#define CopyMetaFileA                   GpCopyMetaFileA
#define CopyMetaFileW                   GpCopyMetaFileW
#define CopyEnhMetaFileA                GpCopyEnhMetaFileA
#define CopyEnhMetaFileW                GpCopyEnhMetaFileW
#define CreateCompatibleBitmap          GpCreateCompatibleBitmap
#define CreateCompatibleDC              GpCreateCompatibleDC
#define CreateDCA                       GpCreateDCA
#define CreateDCW                       GpCreateDCW
#define CreateDiscardableBitmap         GpCreateDiscardableBitmap
#define CreateEllipticRgn               GpCreateEllipticRgn
#define CreateEllipticRgnIndirect       GpCreateEllipticRgnIndirect
#define CreateFontA                     GpCreateFontA
#define CreateFontW                     GpCreateFontW
#define CreateFontIndirectA             GpCreateFontIndirectA
#define CreateFontIndirectW             GpCreateFontIndirectW
#define CreateFontIndirectExA           GpCreateFontIndirectExA
#define CreateFontIndirectExW           GpCreateFontIndirectExW
#define CreateHatchBrush                GpCreateHatchBrush
#define CreateICA                       GpCreateICA
#define CreateICW                       GpCreateICW
#define CreateMetaFileA                 GpCreateMetaFileA
#define CreateMetaFileW                 GpCreateMetaFileW
#define CreateEnhMetaFileA              GpCreateEnhMetaFileA
#define CreateEnhMetaFileW              GpCreateEnhMetaFileW
#define CreatePatternBrush              GpCreatePatternBrush
#define CreatePen                       GpCreatePen
#define ExtCreatePen                    GpExtCreatePen
#define CreatePenIndirect               GpCreatePenIndirect
#define CreateRectRgn                   GpCreateRectRgn
#define CreateRectRgnIndirect           GpCreateRectRgnIndirect
#define CreateRoundRectRgn              GpCreateRoundRectRgn
#define CreateScalableFontResourceA     GpCreateScalableFontResourceA
#define CreateScalableFontResourceW     GpCreateScalableFontResourceW
#define CreateSolidBrush                GpCreateSolidBrush
#define DeleteDC                        GpDeleteDC
#define DeleteMetaFile                  GpDeleteMetaFile
#define DeleteEnhMetaFile               GpDeleteEnhMetaFile
#define DeleteObject                    GpDeleteObject
#define DescribePixelFormat             GpDescribePixelFormat
#define DeviceCapabilitiesExA           GpDeviceCapabilitiesExA
#define DeviceCapabilitiesExW           GpDeviceCapabilitiesExW 
#define DrawEscape                      GpDrawEscape
#define EndDoc                          GpEndDoc
#define EndPage                         GpEndPage
#define EndFormPage                     GpEndFormPage
#define EnumFontFamiliesA               GpEnumFontFamiliesA
#define EnumFontFamiliesW               GpEnumFontFamiliesW
#define EnumFontsA                      GpEnumFontsA
#define EnumFontsW                      GpEnumFontsW
#define EnumObjects                     GpEnumObjects
#define Ellipse                         GpEllipse
#define EqualRgn                        GpEqualRgn
#define Escape                          GpEscape
#define ExtEscape                       GpExtEscape
#define ExcludeClipRect                 GpExcludeClipRect
#define ExtFloodFill                    GpExtFloodFill
#define ExtCreateRegion                 GpExtCreateRegion
#define ExtSelectClipRgn                GpExtSelectClipRgn
#define FillRgn                         GpFillRgn
#define FloodFill                       GpFloodFill
#define FrameRgn                        GpFrameRgn
#define GdiComment                      GpGdiComment
#define GdiFlush                        GpGdiFlush
#define GdiPlayScript                   GpGdiPlayScript
#define GdiPlayDCScript                 GpGdiPlayDCScript
#define GdiPlayJournal                  GpGdiPlayJournal
#define GdiGetBatchLimit                GpGdiGetBatchLimit
#define GdiSetBatchLimit                GpGdiSetBatchLimit
#define GetAspectRatioFilterEx          GpGetAspectRatioFilterEx
#define GetBitmapDimensionEx            GpGetBitmapDimensionEx
#define GetBkColor                      GpGetBkColor
#define GetBkMode                       GpGetBkMode
#define GetBrushOrgEx                   GpGetBrushOrgEx
#define GetCharABCWidthsA               GpGetCharABCWidthsA
#define GetCharABCWidthsW               GpGetCharABCWidthsW
#define GetCharABCWidthsFloatA          GpGetCharABCWidthsFloatA
#define GetCharABCWidthsFloatW          GpGetCharABCWidthsFloatW
#define GetCharABCWidthsI               GpGetCharABCWidthsI
#define GetClipBox                      GpGetClipBox
#define GetClipRgn                      GpGetClipRgn
#define GetColorAdjustment              GpGetColorAdjustment
#define GetCurrentObject                GpGetCurrentObject
#define GetCurrentPositionEx            GpGetCurrentPositionEx
#define GetDeviceCaps                   GpGetDeviceCaps
#define GetFontResourceInfoW            GpGetFontResourceInfoW
#define GetFontUnicodeRanges            GpGetFontUnicodeRanges 
#define GetGlyphIndicesA                GpGetGlyphIndicesA
#define GetGlyphIndicesW                GpGetGlyphIndicesW 
#define GetGraphicsMode                 GpGetGraphicsMode
#define GetMapMode                      GpGetMapMode
#define GetMetaFileA                    GpGetMetaFileA
#define GetMetaFileW                    GpGetMetaFileW
#define GetMetaRgn                      GpGetMetaRgn
#define GetEnhMetaFileA                 GpGetEnhMetaFileA
#define GetEnhMetaFileW                 GpGetEnhMetaFileW
#define GetEnhMetaFileDescriptionA      GpGetEnhMetaFileDescriptionA
#define GetEnhMetaFileDescriptionW      GpGetEnhMetaFileDescriptionW
#define GetEnhMetaFileHeader            GpGetEnhMetaFileHeader
#define GetEnhMetaFilePaletteEntries    GpGetEnhMetaFilePaletteEntries
#define GetEnhMetaFilePixelFormat       GpGetEnhMetaFilePixelFormat
#define GetFontData                     GpGetFontData
#define GetGlyphOutlineA                GpGetGlyphOutlineA
#define GetGlyphOutlineW                GpGetGlyphOutlineW
#define GetKerningPairsA                GpGetKerningPairsA
#define GetKerningPairsW                GpGetKerningPairsW
#define GetNearestColor                 GpGetNearestColor
#define GetNearestPaletteIndex          GpGetNearestPaletteIndex
#define GetOutlineTextMetricsA          GpGetOutlineTextMetricsA
#define GetOutlineTextMetricsW          GpGetOutlineTextMetricsW
#define GetPixel                        GpGetPixel
#define GetPixelFormat                  GpGetPixelFormat
#define GetPolyFillMode                 GpGetPolyFillMode
#define GetRasterizerCaps               GpGetRasterizerCaps
#define GetRandomRgn                    GpGetRandomRgn
#define GetRegionData                   GpGetRegionData
#define GetRelAbs                       GpGetRelAbs
#define GetRgnBox                       GpGetRgnBox
#define GetROP2                         GpGetROP2
#define GetStockObject                  GpGetStockObject
#define GetStretchBltMode               GpGetStretchBltMode
#define GetSystemPaletteUse             GpGetSystemPaletteUse
#define GetTextAlign                    GpGetTextAlign
#define GetTextCharacterExtra           GpGetTextCharacterExtra
#define GetTextColor                    GpGetTextColor
#define GetDCBrushColor                 GpGetDCBrushColor
#define GetDCPenColor                   GpGetDCPenColor
#define GetTextExtentPointA             GpGetTextExtentPointA
#define GetTextExtentPointW             GpGetTextExtentPointW
#define GetTextExtentPoint32A           GpGetTextExtentPoint32A
#define GetTextExtentPoint32W           GpGetTextExtentPoint32W
#define GetTextExtentExPointA           GpGetTextExtentExPointA
#define GetTextExtentExPointW           GpGetTextExtentExPointW
#define GetTextExtentPointI             GpGetTextExtentPointI
#define GetTextExtentExPointI           GpGetTextExtentExPointI
#define GetTextFaceA                    GpGetTextFaceA
#define GetTextFaceW                    GpGetTextFaceW
#define GetTextMetricsA                 GpGetTextMetricsA
#define GetTextMetricsW                 GpGetTextMetricsW
#define GetViewportExtEx                GpGetViewportExtEx
#define GetViewportOrgEx                GpGetViewportOrgEx
#define GetWindowExtEx                  GpGetWindowExtEx
#define GetWindowOrgEx                  GpGetWindowOrgEx
#define GetWorldTransform               GpGetWorldTransform
#define IntersectClipRect               GpIntersectClipRect
#define InvertRgn                       GpInvertRgn
#define LineDDA                         GpLineDDA
#define LineTo                          GpLineTo
#define MaskBlt                         GpMaskBlt
#define ModifyWorldTransform            GpModifyWorldTransform
#define MoveToEx                        GpMoveToEx
#define OffsetClipRgn                   GpOffsetClipRgn
#define OffsetRgn                       GpOffsetRgn
#define OffsetViewportOrgEx             GpOffsetViewportOrgEx
#define OffsetWindowOrgEx               GpOffsetWindowOrgEx
#define PaintRgn                        GpPaintRgn
#define PatBlt                          GpPatBlt
#define PolyPatBlt                      GpPolyPatBlt
#define Pie                             GpPie
#define PlayMetaFile                    GpPlayMetaFile
#define PlayEnhMetaFile                 GpPlayEnhMetaFile
#define PlgBlt                          GpPlgBlt
#define PtInRegion                      GpPtInRegion
#define PtVisible                       GpPtVisible
#define RealizePalette                  GpRealizePalette
#define Rectangle                       GpRectangle
#define RectInRegion                    GpRectInRegion
#define RectVisible                     GpRectVisible
#define RemoveFontResourceA             GpRemoveFontResourceA
#define RemoveFontResourceW             GpRemoveFontResourceW
#define RemoveFontResourceExA           GpRemoveFontResourceExA
#define RemoveFontResourceExW           GpRemoveFontResourceExW
#define RemoveFontMemResourceEx         GpRemoveFontMemResourceEx
#define ResizePalette                   GpResizePalette
#define RestoreDC                       GpRestoreDC
#define RoundRect                       GpRoundRect
#define SaveDC                          GpSaveDC
#define ScaleViewportExtEx              GpScaleViewportExtEx
#define ScaleWindowExtEx                GpScaleWindowExtEx
#define SelectClipRgn                   GpSelectClipRgn
#define SelectObject                    GpSelectObject
#define SelectBrushLocal                GpSelectBrushLocal
#define SelectFontLocal                 GpSelectFontLocal
#define SelectPalette                   GpSelectPalette
#define SetBitmapDimensionEx            GpSetBitmapDimensionEx
#define SetBkColor                      GpSetBkColor
#define SetBkMode                       GpSetBkMode
#define SetBrushOrgEx                   GpSetBrushOrgEx
#define SetColorAdjustment              GpSetColorAdjustment
#define SetFontEnumeration              GpSetFontEnumeration
#define SetGraphicsMode                 GpSetGraphicsMode
#define SetMapMode                      GpSetMapMode
#define SetMapperFlags                  GpSetMapperFlags
#define SetPixel                        GpSetPixel
#define SetPixelFormat                  GpSetPixelFormat
#define SetPixelV                       GpSetPixelV
#define SetPolyFillMode                 GpSetPolyFillMode
#define SetRectRgn                      GpSetRectRgn
#define SetRelAbs                       GpSetRelAbs
#define SetROP2                         GpSetROP2
#define SetStretchBltMode               GpSetStretchBltMode
#define SetSystemPaletteUse             GpSetSystemPaletteUse
#define SetTextAlign                    GpSetTextAlign
#define SetTextCharacterExtra           GpSetTextCharacterExtra
#define SetTextColor                    GpSetTextColor
#define SetDCBrushColor                 GpSetDCBrushColor
#define SetDCPenColor                   GpSetDCPenColor
#define SetTextJustification            GpSetTextJustification
#define SetLayout                       GpSetLayout
#define GetLayout                       GpGetLayout
#define SetLayoutWidth                  GpSetLayoutWidth            
#define MirrorRgn                       GpMirrorRgn                 
#define SetViewportExtEx                GpSetViewportExtEx
#define SetViewportOrgEx                GpSetViewportOrgEx
#define SetWindowExtEx                  GpSetWindowExtEx
#define SetWindowOrgEx                  GpSetWindowOrgEx
#define SetWorldTransform               GpSetWorldTransform
#define StartDocA                       GpStartDocA
#define StartDocW                       GpStartDocW
#define StartPage                       GpStartPage
#define StartFormPage                   GpStartFormPage
#define StretchBlt                      GpStretchBlt
#define SwapBuffers                     GpSwapBuffers
#define TextOutA                        GpTextOutA
#define TextOutW                        GpTextOutW
#define UpdateColors                    GpUpdateColors
#define UnrealizeObject                 GpUnrealizeObject
#define FixBrushOrgEx                   GpFixBrushOrgEx
#define GetDCOrgEx                      GpGetDCOrgEx
#define AnimatePalette                  GpAnimatePalette
#define ArcTo                           GpArcTo
#define BeginPath                       GpBeginPath
#define CloseFigure                     GpCloseFigure
#define CreateBitmap                    GpCreateBitmap
#define CreateBitmapIndirect            GpCreateBitmapIndirect
#define CreateBrushIndirect             GpCreateBrushIndirect
#define CreateDIBitmap                  GpCreateDIBitmap
#define CreateDIBPatternBrush           GpCreateDIBPatternBrush
#define CreateDIBPatternBrushPt         GpCreateDIBPatternBrushPt
#define CreateDIBSection                GpCreateDIBSection
#define CreateHalftonePalette           GpCreateHalftonePalette    
#define CreatePalette                   GpCreatePalette
#define CreatePolygonRgn                GpCreatePolygonRgn
#define CreatePolyPolygonRgn            GpCreatePolyPolygonRgn
#define DPtoLP                          GpDPtoLP
#define EndPath                         GpEndPath
#define EnumMetaFile                    GpEnumMetaFile
#define EnumEnhMetaFile                 GpEnumEnhMetaFile
#define ExtTextOutA                     GpExtTextOutA
#define ExtTextOutW                     GpExtTextOutW
#define PolyTextOutA                    GpPolyTextOutA
#define PolyTextOutW                    GpPolyTextOutW
#define FillPath                        GpFillPath
#define FlattenPath                     GpFlattenPath
#define GetArcDirection                 GpGetArcDirection
#define GetBitmapBits                   GpGetBitmapBits
#define GetCharWidthA                   GpGetCharWidthA
#define GetCharWidthW                   GpGetCharWidthW
#define GetCharWidth32A                 GpGetCharWidth32A
#define GetCharWidth32W                 GpGetCharWidth32W
#define GetCharWidthFloatA              GpGetCharWidthFloatA
#define GetCharWidthFloatW              GpGetCharWidthFloatW
#define GetCharWidthI                   GpGetCharWidthI
#define GetDIBColorTable                GpGetDIBColorTable
#define GetDIBits                       GpGetDIBits
#define GetMetaFileBitsEx               GpGetMetaFileBitsEx
#define GetMiterLimit                   GpGetMiterLimit
#define GetEnhMetaFileBits              GpGetEnhMetaFileBits
#define GetObjectA                      GpGetObjectA
#define GetObjectW                      GpGetObjectW
#define GetObjectType                   GpGetObjectType
#define GetPaletteEntries               GpGetPaletteEntries
#define GetPath                         GpGetPath
#define GetSystemPaletteEntries         GpGetSystemPaletteEntries
#define GetWinMetaFileBits              GpGetWinMetaFileBits
#define LPtoDP                          GpLPtoDP
#define PathToRegion                    GpPathToRegion
#define PlayMetaFileRecord              GpPlayMetaFileRecord
#define PlayEnhMetaFileRecord           GpPlayEnhMetaFileRecord
#define PolyBezier                      GpPolyBezier
#define PolyBezierTo                    GpPolyBezierTo
#define PolyDraw                        GpPolyDraw
#define Polygon                         GpPolygon
#define Polyline                        GpPolyline
#define PolylineTo                      GpPolylineTo
#define PolyPolygon                     GpPolyPolygon
#define PolyPolyline                    GpPolyPolyline
#define ResetDCA                        GpResetDCA
#define ResetDCW                        GpResetDCW
#define SelectClipPath                  GpSelectClipPath
#define SetAbortProc                    GpSetAbortProc
#define SetBitmapBits                   GpSetBitmapBits
#define SetDIBColorTable                GpSetDIBColorTable
#define SetDIBits                       GpSetDIBits
#define SetDIBitsToDevice               GpSetDIBitsToDevice
#define SetMetaFileBitsEx               GpSetMetaFileBitsEx
#define SetEnhMetaFileBits              GpSetEnhMetaFileBits
#define SetMiterLimit                   GpSetMiterLimit
#define SetPaletteEntries               GpSetPaletteEntries
#define SetWinMetaFileBits              GpSetWinMetaFileBits
#define StretchDIBits                   GpStretchDIBits
#define StrokeAndFillPath               GpStrokeAndFillPath
#define StrokePath                      GpStrokePath
#define WidenPath                       GpWidenPath
#define AbortPath                       GpAbortPath
#define SetArcDirection                 GpSetArcDirection
#define SetMetaRgn                      GpSetMetaRgn
#define GetBoundsRect                   GpGetBoundsRect
#define SetBoundsRect                   GpSetBoundsRect
#define SetICMMode                      GpSetICMMode
#define EnumICMProfilesA                GpEnumICMProfilesA
#define EnumICMProfilesW                GpEnumICMProfilesW
#define CheckColorsInGamut              GpCheckColorsInGamut
#define GetColorSpace                   GpGetColorSpace
#define GetLogColorSpaceA               GpGetLogColorSpaceA
#define GetLogColorSpaceW               GpGetLogColorSpaceW
#define CreateColorSpaceA               GpCreateColorSpaceA
#define CreateColorSpaceW               GpCreateColorSpaceW
#define SetColorSpace                   GpSetColorSpace
#define DeleteColorSpace                GpDeleteColorSpace
#define GetICMProfileA                  GpGetICMProfileA
#define GetICMProfileW                  GpGetICMProfileW
#define SetICMProfileA                  GpSetICMProfileA
#define SetICMProfileW                  GpSetICMProfileW
#define GetDeviceGammaRamp              GpGetDeviceGammaRamp
#define SetDeviceGammaRamp              GpSetDeviceGammaRamp
#define ColorMatchToTarget              GpColorMatchToTarget
#define UpdateICMRegKeyA                GpUpdateICMRegKeyA
#define UpdateICMRegKeyW                GpUpdateICMRegKeyW
#define ColorCorrectPalette             GpColorCorrectPalette
#define gdiPlaySpoolStream              GpgdiPlaySpoolStream
#define EnumFontFamiliesExA             GpEnumFontFamiliesExA
#define EnumFontFamiliesExW             GpEnumFontFamiliesExW
#define GetCharacterPlacementA          GpGetCharacterPlacementA
#define GetCharacterPlacementW          GpGetCharacterPlacementW
#define GetFontLanguageInfo             GpGetFontLanguageInfo
#define TranslateCharsetInfo            GpTranslateCharsetInfo
#define GetTextCharsetInfo              GpGetTextCharsetInfo 
#define GetTextCharset                  GpGetTextCharset
#define SetMagicColors                  GpSetMagicColors 
#define EnableEUDC                      GpEnableEUDC 
#define EudcLoadLinkW                   GpEudcLoadLinkW
#define EudcUnloadLinkW                 GpEudcUnloadLinkW
#define GetEUDCTimeStamp                GpGetEUDCTimeStamp       
#define GetEUDCTimeStampExW             GpGetEUDCTimeStampExW    
#define GetStringBitmapA                GpGetStringBitmapA       
#define GetStringBitmapW                GpGetStringBitmapW       
#define QueryFontAssocStatus            GpQueryFontAssocStatus   
#define GetFontAssocStatus              GpGetFontAssocStatus
#define GdiGetPageCount                 GpGdiGetPageCount
#define GdiGetDC                        GpGdiGetDC
#define GdiDeleteSpoolFileHandle        GpGdiDeleteSpoolFileHandle
#define GdiGetPageHandle                GpGdiGetPageHandle
#define GdiGetSpoolFileHandle           GpGdiGetSpoolFileHandle
#define GdiPlayEMF                      GpGdiPlayEMF
#define GdiStartDocEMF                  GpGdiStartDocEMF
#define GdiStartPageEMF                 GpGdiStartPageEMF
#define GdiPlayPageEMF                  GpGdiPlayPageEMF
#define GdiPlayPageEMF                  GpGdiPlayPageEMF
#define GdiEndPageEMF                   GpGdiEndPageEMF
#define GdiEndDocEMF                    GpGdiEndDocEMF
#define GdiGetDevmodeForPage            GpGdiGetDevmodeForPage
#define GdiResetDCEMF                   GpGdiResetDCEMF

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\wow6432\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\gdiplus\usermode.c ===
/******************************Module*Header*******************************\
* Module Name: usermode.c
*
* Client side stubs for any user-mode GDI-Plus thunks.
*
* Created: 2-May-1998
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1998-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOLEAN GdiProcessSetup();
BOOL InitializeGre();

/******************************Public*Routine******************************\
* GdiPlusDllInitialize                                                         
*                                                                          
* DLL initialization routine to initialize GRE and CLIENT for user-mode
* GDI+.                                                     
*                                                                          
*  02-May-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.                                                                
\**************************************************************************/

BOOL 
GdiPlusDllInitialize(
PVOID       pvDllHandle,
ULONG       ulReason,
PCONTEXT    pcontext)
{
    NTSTATUS status = 0;
    INT i;
    PTEB pteb = NtCurrentTeb();
    BOOLEAN bRet = TRUE;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(pvDllHandle);

        bRet = (InitializeGre() && GdiProcessSetup());

        ghbrDCBrush = GetStockObject (DC_BRUSH);
        ghbrDCPen = GetStockObject (DC_PEN);
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtUserSelectPalette                                                         
*                                                                          
* Fake stub to allow user-mode GDI+ to link.
*                                                                          
*  02-May-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.                                                                
\**************************************************************************/

HPALETTE
NtUserSelectPalette(
    HDC hdc,
    HPALETTE hpalette,
    BOOL fForceBackground)
{
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\gdiplus\usermode.h ===
/******************************Module*Header*******************************\
* Module Name: usermode.h
*
* Client side stubs for any user-mode GDI-Plus thunks.
*
* Created: 2-May-1998
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1998-1999 Microsoft Corporation
\**************************************************************************/

#define InitializeLpkHooks(a)

#if DBG
    VOID DoRip(PSZ psz);
    #define PLUSRIP DoRip
#else
    #define PLUSRIP
#endif

#define GetDC(a) \
    (PLUSRIP("GetDC"), 0)
#define ReleaseDC(a, b) \
    (PLUSRIP("ReleaseDC"), 0)
#define UserRealizePalette(a) \
    (PLUSRIP("UserRealizePalette"), 0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\umpd.cxx ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    umpd.c

Abstract:

    User-mode printer driver support

Environment:

        Windows NT 5.0

Revision History:

        06/30/97 -davidx-
                Created it.

    09/17/97 -davidx-
        Clean up km-um thunking.

--*/

extern "C"
{
#include "precomp.h"
#include "winddi.h"
#include "psapi.h"
#include "proxyport.h"

static PUMPD gCachedUMPDList = NULL;           // cached list of user-mode printer drivers
}

#include "umpd.hxx"

#define IA64_PAGE_SIZE              0x2000
#define PP_SHAREDSECTION_SIZE       IA64_PAGE_SIZE

PVOID
MyGetPrinterDriver(
    HANDLE  hPrinter,
    DWORD   dwLevel
    )

/*++

Routine Description:

    Wrapper function for spooler's GetPrinterDriver API

Arguments:

    hPrinter - Handle to the printer
    dwLevel - Level of DRIVER_INFO_x structure the caller is interested in

Return Value:

    Pointer to a DRIVER_INFO_x structure, NULL if there is an error

--*/

{
    DWORD   cbNeeded;
    PVOID   pv;
    INT     retries = 0;

    //
    // Start with a default buffer size to avoid always
    // having to call GetPrinterDriver twice.
    //

    cbNeeded = 2 * MAX_PATH * sizeof(WCHAR);

    while (retries++ < 2)
    {
        if (! (pv = LOCALALLOC(cbNeeded)))
        {
            WARNING("Memory allocation failed.\n");
            return NULL;
        }

        if (fpGetPrinterDriverW(hPrinter, NULL, dwLevel, (LPBYTE)pv, cbNeeded, &cbNeeded))
            return pv;

        //
        // If GetPrinterDriver failed not for insufficient buffer,
        // skip the retry
        //

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            retries++;

        LOCALFREE(pv);
    }

    WARNING("GetPrinterDriver failed.\n");
    return NULL;
}


PWSTR
DuplicateString(
    PCWSTR  pSrc
    )

/*++

Routine Description:

    Allocate memory and make a duplicate of the source string

Arguments:

    pSrc - String to be duplicated

Return Value:

    Pointer to the duplicated string
    NULL if there is an error

--*/

{
    PWSTR   pDest;
    INT     cb;

    ASSERTGDI(pSrc != NULL, "Duplicate NULL string!\n");

    cb = (wcslen(pSrc) + 1) * sizeof(WCHAR);

    if (pDest = (PWSTR) LOCALALLOC(cb))
    {
        CopyMemory(pDest, pSrc, cb);
        return pDest;
    }
    else
    {
        WARNING("DuplicateString: out-of-memory.\n");
        return NULL;
    }
}

PDRIVER_INFO_5W
DuplicateDriverInfo5W(PDRIVER_INFO_5W inDriverInfo)
{
    ULONG               size = sizeof(DRIVER_INFO_5W);
    PDRIVER_INFO_5W     pDriverInfo;
    PWSTR               pStr;
    ULONG               len;

    size += (inDriverInfo->pName == NULL ? 0 : (wcslen(inDriverInfo->pName) + 1) * sizeof(WCHAR));
    size += (inDriverInfo->pEnvironment == NULL ? 0 : (wcslen(inDriverInfo->pEnvironment) + 1) * sizeof(WCHAR));
    size += (inDriverInfo->pDriverPath == NULL ? 0 : (wcslen(inDriverInfo->pDriverPath) + 1) * sizeof(WCHAR));
    size += (inDriverInfo->pDataFile == NULL ? 0 : (wcslen(inDriverInfo->pDataFile) + 1) * sizeof(WCHAR));
    size += (inDriverInfo->pConfigFile == NULL ? 0 : (wcslen(inDriverInfo->pConfigFile) + 1) * sizeof(WCHAR));

    if(pDriverInfo = (PDRIVER_INFO_5W) LOCALALLOC(size))
    {
        *pDriverInfo = *inDriverInfo;

        pStr = (PWSTR) (pDriverInfo + 1);

        if(pDriverInfo->pName)
        {
            len = wcslen(pDriverInfo->pName) + 1;
            RtlCopyMemory(pStr, pDriverInfo->pName, len * sizeof(WCHAR));
            pDriverInfo->pName = pStr;
            pStr += len;
        }
    
        if(pDriverInfo->pEnvironment)
        {
            len = wcslen(pDriverInfo->pEnvironment) + 1;
            RtlCopyMemory(pStr, pDriverInfo->pEnvironment, len * sizeof(WCHAR));
            pDriverInfo->pEnvironment = pStr;
            pStr += len;
        }
    
        if(pDriverInfo->pDriverPath)
        {
            len = wcslen(pDriverInfo->pDriverPath) + 1;
            RtlCopyMemory(pStr, pDriverInfo->pDriverPath, len * sizeof(WCHAR));
            pDriverInfo->pDriverPath = pStr;
            pStr += len;
        }
    
        if(pDriverInfo->pDataFile)
        {
            len = wcslen(pDriverInfo->pDataFile) + 1;
            RtlCopyMemory(pStr, pDriverInfo->pDataFile, len * sizeof(WCHAR));
            pDriverInfo->pDataFile = pStr;
            pStr += len;
        }
        
        if(pDriverInfo->pConfigFile)
        {
            len = wcslen(pDriverInfo->pConfigFile) + 1;
            RtlCopyMemory(pStr, pDriverInfo->pConfigFile, len * sizeof(WCHAR));
            pDriverInfo->pConfigFile = pStr;
            pStr += len;
        }
    }

    return pDriverInfo;
}

PUMPD
FindUserModePrinterDriver(
    PCWSTR  pDriverDllName,
    DWORD   dwDriverVersion,
    BOOL    bUseVersion
    )

/*++

Routine Description:

    Search the cached list of user-mode printer drivers and
    see if the specified driver is found

Arguments:

    pDriverDllName - Specifies the name of the driver DLL to be found
    dwDriverVersion - Current version number of the driver
    bUseVersion - Flag for using the version check

Return Value:

    Pointer to the UMPD structure corresponding to the specified driver
    NULL if the specified driver is not in the cached list

Note:

    This function must be called inside a critical section:

        ENTERCRITICALSECTION(&semUMPD);
        ...
        LEAVECRITICALSECTION(&semUMPD);

--*/

{
    PUMPD   pUMPD = gCachedUMPDList;

    while (pUMPD != NULL &&
           pUMPD->pDriverInfo2 != NULL &&
           _wcsicmp(pDriverDllName, pUMPD->pDriverInfo2->pDriverPath) != 0)
    {
        pUMPD = pUMPD->pNext;
    }

    // Do the version check if neccesary
    if (bUseVersion && pUMPD)
    {
        if (dwDriverVersion != pUMPD->dwDriverVersion)
        {
            // We have a version mismatch. Remove artificial increments on this
            // driver.
            if (pUMPD->bArtificialIncrement)
            {
                pUMPD->bArtificialIncrement = FALSE;

                if (UnloadUserModePrinterDriver(pUMPD, FALSE, 0))
                {
                    pUMPD = NULL;
                }
            }
        }
    }

    return pUMPD;
}

BOOL
GdiArtificialDecrementDriver(
    LPWSTR pDriverDllName,
    DWORD  dwDriverAttributes
    )

/*++

Routine Description:

    Remove the artificial increment on the driver, if any.

Arguments:

    pDriverDllName - Specifies the name of the driver DLL to be found
    dwDriverAttributes - User/Kernel mode printer driver

Return Value:

    TRUE if the driver file is no longer loaded in the spooler
    FALSE otherwise

--*/

{
    PUMPD   pUMPD;
    BOOL    bReturn = FALSE;

    if (!pDriverDllName || !*pDriverDllName)
    {
       // Nothing to unload
       return bReturn;
    }

    if (dwDriverAttributes & DRIVER_KERNELMODE)
    {
       // Unload kernel mode driver
       return NtGdiUnloadPrinterDriver(pDriverDllName,
                                       (wcslen(pDriverDllName) + 1) * sizeof(WCHAR));
    }

    ENTERCRITICALSECTION(&semUMPD);

    pUMPD = gCachedUMPDList;

    while (pUMPD != NULL &&
           _wcsicmp(pDriverDllName, pUMPD->pDriverInfo2->pDriverPath) != 0)
    {
        pUMPD = pUMPD->pNext;
    }

    if (pUMPD)
    {
        if (pUMPD->bArtificialIncrement)
        {
            pUMPD->bArtificialIncrement = FALSE;
            bReturn = UnloadUserModePrinterDriver(pUMPD, FALSE, 0);
        }
    }
    else
    {
        bReturn = TRUE;
    }

    LEAVECRITICALSECTION(&semUMPD);

    return bReturn;
}


BOOL
LoadUserModePrinterDriverEx(
    PDRIVER_INFO_5W  pDriverInfo5,
    LPWSTR           pwstrPrinterName,
    PUMPD           *ppUMPD,
    PRINTER_DEFAULTSW  *pdefaults,
    HANDLE            hPrinter
    )
{
    PDRIVER_INFO_2W pDriverInfo2;
    HINSTANCE       hInst = NULL;
    BOOL            bResult = FALSE;
    PUMPD           pUMPD = NULL;
    ProxyPort *     pp = NULL;
    KERNEL_PVOID    umpdCookie = NULL;
    BOOL            bFreeDriverInfo2 = TRUE;

    if ((pDriverInfo2 = (PDRIVER_INFO_2W) DuplicateDriverInfo5W(pDriverInfo5)) == NULL)
        return FALSE;
 
    //
    // Check the list of cached user-mode printer drivers
    // and see if the requested printer driver is already loaded
    //

    ENTERCRITICALSECTION(&semUMPD);

    if (*ppUMPD = FindUserModePrinterDriver(pDriverInfo5->pDriverPath,
                                            pDriverInfo5->dwDriverVersion,
                                            TRUE))
    {
        if (gbWOW64)
        {
            pUMPD = *ppUMPD;

            ASSERTGDI(pUMPD->pp, "LoadUserModePrinterDriver NULL proxyport\n");
            
            PROXYPORT  proxyport(pUMPD->pp);

            if (proxyport.bValid())
            {
                umpdCookie = proxyport.LoadDriver(pDriverInfo5, pwstrPrinterName, pdefaults, hPrinter);

                if (pUMPD->umpdCookie == umpdCookie)
                {
                    // 64-bit UMPD matches the 32-bit one
                    
                    bResult = TRUE;
                }
                else
                {
                    WARNING("LoadUserModePrinterDriveEx: umpdCookie doesn't match\n");
                }
            }
            else
                WARNING("LoadUserModePrinterDriverEx: invalid proxyport\n");
        }
        else
        {
            // x86 or native ia64 printing, don't need to anything

            bResult = TRUE;
        }
    }
    else
    {
        // Can't find UMPD, first time load the printer driver
    
        if (gbWOW64)
        {
            PROXYPORT proxyport(PP_SHAREDSECTION_SIZE);
    
            if (pp = proxyport.GetPort())
            {
                umpdCookie = proxyport.LoadDriver(pDriverInfo5, pwstrPrinterName, pdefaults, hPrinter);
            }
        }
        else
        {
            hInst = LoadLibraryExW(pDriverInfo2->pDriverPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
        }
        
        if (hInst || umpdCookie)
        {
            if (pUMPD = (PUMPD) LOCALALLOC(sizeof(UMPD)))
            {
                ZeroMemory(pUMPD, sizeof(UMPD));
    
                pUMPD->dwSignature = UMPD_SIGNATURE;
                pUMPD->hInst = hInst;
                pUMPD->pDriverInfo2 = pDriverInfo2;
                pUMPD->bArtificialIncrement = TRUE;
                pUMPD->dwDriverVersion = pDriverInfo5->dwDriverVersion;
                pUMPD->iRefCount = 1;           // aritficial ref count to keep the printer driver around
                                                // till the process goes away
                pUMPD->pp = pp;
                pUMPD->umpdCookie = umpdCookie;
    
                *ppUMPD = pUMPD;
                bResult = TRUE;
    
                bFreeDriverInfo2 = FALSE;
    
                //
                // Add the newly loaded driver to the list of
                // cached user-mode printer drivers
                //
    
                pUMPD->pNext = gCachedUMPDList;
                gCachedUMPDList = pUMPD;
            }
        }    
        
        if (!bResult)
        {
            if (pp)
            {
                PROXYPORT  proxyport(pp);
    
                if (umpdCookie)
                    proxyport.UnloadDriver(umpdCookie, 0, FALSE);
                
                proxyport.Close();            
            }
    
            if (hInst)
                FreeLibrary(hInst);
        }
    }

    if (bResult)
        (*ppUMPD)->iRefCount++;        

    LEAVECRITICALSECTION(&semUMPD);

    if (bFreeDriverInfo2)
        LOCALFREE(pDriverInfo2);

    if (!bResult)
    {
        WARNING("LoadUserModePrinterDriverEx failed\n");
    }

    return bResult;
}


BOOL
LoadUserModePrinterDriver(
    HANDLE  hPrinter,
    LPWSTR  pwstrPrinterName,
    PUMPD  *ppUMPD,
    PRINTER_DEFAULTSW  *pdefaults
    )

/*++

Routine Description:

    Load user-mode printer driver DLL

Arguments:

    hPrinter - Handle to the current printer
    ppUMPD - Return a pointer to a UMPD structure

Return Value:

    TRUE if successful, FALSE if there is an error

    If the printer uses a user-mode printer driver, *ppUMPD will be a pointer
    to a UMPD structure. If the printer uses a kernel-mode printer driver,
    *ppUMPD will be NULL.

--*/

{
    PDRIVER_INFO_5W pDriverInfo5;
    BOOL    bResult;
    HMODULE hModule;
    WCHAR   moduleName[256];

    *ppUMPD = NULL;

    //
    // Get printer driver information
    //

    if ((pDriverInfo5 = (PDRIVER_INFO_5W)MyGetPrinterDriver(hPrinter, 5)) == NULL)
        return FALSE;

    if (pDriverInfo5->dwDriverAttributes & DRIVER_KERNELMODE)
    {
        LOCALFREE(pDriverInfo5);
        return TRUE;
    }

    bResult = LoadUserModePrinterDriverEx(pDriverInfo5, pwstrPrinterName, ppUMPD, pdefaults, hPrinter);
    
    LOCALFREE(pDriverInfo5);

    return bResult;
}

BOOL
UnloadUserModePrinterDriver(
    PUMPD   pUMPD,
    BOOL    bNotifySpooler,
    HANDLE  hPrinter
    )

/*++

Routine Description:

    Unload user-mode printer driver module and notify the spooler if necessary

Arguments:

    pUMPD - Pointer to user-mode printer driver information
    bNotifySpooler - Call into the spooler to notify driver unloading

Return Value:

    TRUE if the driver instance was freed (i.e ref cnt == 0)
    FALSE otherwise

--*/

{
    PUMPD  *ppStartUMPD;

    ASSERTGDI(VALID_UMPD(pUMPD), "Corrupted UMPD structure.\n");
    ASSERTGDI(pUMPD->iRefCount > 0, "Bad UMPD reference count.\n");

    if (gbWOW64)
    {
        PROXYPORT proxyport(pUMPD->pp);
    
        if (proxyport.bValid())
        {            
            proxyport.UnloadDriver(pUMPD->umpdCookie, hPrinter, bNotifySpooler);
        }
    }
    
    ENTERCRITICALSECTION(&semUMPD);
    
    if (pUMPD->iRefCount > 0)
    {
        pUMPD->iRefCount--;
    }
    
    if (pUMPD->iRefCount != 0 || pUMPD->pHandleList != NULL)
    {
        LEAVECRITICALSECTION(&semUMPD);
        return FALSE;
    }

    // Remove the UMPD node from umpd cache list
    
    for (ppStartUMPD = &gCachedUMPDList;
         *ppStartUMPD;
         ppStartUMPD = &((*ppStartUMPD)->pNext))
    {
        if (*ppStartUMPD == pUMPD)
        {
            *ppStartUMPD = pUMPD->pNext;
            break;
        }
    }
    
    LEAVECRITICALSECTION(&semUMPD);
    
    if (gbWOW64)
    {
        PROXYPORT proxyport(pUMPD->pp);

        if (proxyport.bValid())
            proxyport.Close();
    }
    else
    {
        PFN       pfn = pUMPD->apfn[INDEX_DrvDisableDriver];

        if (pfn)
        {
           pfn();
        }

        FreeLibrary(pUMPD->hInst);
    }

    if (bNotifySpooler && pUMPD->pDriverInfo2->pDriverPath)
    {
        (*fpSplDriverUnloadComplete)(pUMPD->pDriverInfo2->pDriverPath);
    }
    
    LOCALFREE(pUMPD->pDriverInfo2);
    LOCALFREE(pUMPD);

    return TRUE;
}

PUMPD
UMPDDrvEnableDriver(
    PWSTR           pDriverDllName,
    ULONG           iEngineVersion
    )

/*++

Routine Description:

    Client-side stub for DrvEnableDriver

Arguments:

    iDriverDllName - Name of the user-mode printer driver DLL
    iEngineVersion - Same parameter as that for DrvEnableDriver

Return Value:

    Pointer to the UMPD structure corresponding to the specified driver
    NULL if there is an error

Note:

    The pointer value returned by this function will be passed back from
    the kernel-mode side to the user-mode side for each subsequent DDI call.

--*/

{
    PUMPD           pUMPD;
    DRVENABLEDATA   ded;

    ENTERCRITICALSECTION(&semUMPD);

    //
    // Find the specified user-mode printer driver
    //

    pUMPD = FindUserModePrinterDriver(pDriverDllName, 0, FALSE);

    if(pUMPD == NULL)
    {
        WARNING("failed to find printer driver\n");
        return NULL;
    }

    if(pUMPD->hInst == NULL)
    {
        WARNING("driver library not loaded\n");
        return NULL;
    }

    ASSERTGDI(pUMPD != NULL, "Non-existent user-mode printer driver.\n");

    if (! (pUMPD->dwFlags & UMPDFLAG_DRVENABLEDRIVER_CALLED))
    {
        PFN_DrvEnableDriver pfn;

        //
        // If we haven't called DrvEnableDriver for this driver, do it now
        //

        if ((pfn = (PFN_DrvEnableDriver) GetProcAddress(pUMPD->hInst, "DrvEnableDriver")) &&
            pfn(iEngineVersion, sizeof(ded), &ded))
        {
            PDRVFN  pdrvfn;
            ULONG   count;

            //
            // Convert driver entrypoint function table to a more convenient format
            //

            for (pdrvfn = ded.pdrvfn, count = ded.c; count--; pdrvfn++)
            {
                if (pdrvfn->iFunc < INDEX_LAST)
                    pUMPD->apfn[pdrvfn->iFunc] = pdrvfn->pfn;
                else
                {
                    WARNING("Unrecognized DDI entrypoint index.\n");
                }
            }

            pUMPD->dwFlags |= UMPDFLAG_DRVENABLEDRIVER_CALLED;
        }
        else
        {
            WARNING("DrvEnableDriver failed.\n");
            pUMPD = NULL;
        }
    }

    LEAVECRITICALSECTION(&semUMPD);

    return pUMPD;
}

extern "C"
int DocumentEventEx(
    PUMPD       pUMPD,
    HANDLE      hPrinter,
    HDC         hdc,
    int         iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
)
{
    int iRet;

    if (WOW64PRINTING(pUMPD))
    {
        PROXYPORT  proxyport(pUMPD->pp);

        iRet = proxyport.DocumentEvent(pUMPD->umpdCookie, hPrinter,
                                       hdc, iEsc, cjIn, pvIn, cjOut, pvOut);
    }
    else
    {
        iRet = (*fpDocumentEvent)(hPrinter, hdc, iEsc, cjIn, pvIn, cjOut, pvOut);
    }

    return iRet;
}

extern "C"
DWORD StartDocPrinterWEx(
    PUMPD   pUMPD,
    HANDLE  hPrinter,
    DWORD   level,
    LPBYTE  pDocInfo)
 {
    if (WOW64PRINTING(pUMPD) && level == 1)
    {
        PROXYPORT proxyport(pUMPD->pp);
        
        return proxyport.StartDocPrinterW(pUMPD->umpdCookie,hPrinter, level, pDocInfo);
    }
    else
        return (*fpStartDocPrinterW)(hPrinter, level, pDocInfo);
}

extern "C"
BOOL  EndDocPrinterEx(PUMPD pUMPD, HANDLE hPrinter)
{
    if (WOW64PRINTING(pUMPD))
    {
        PROXYPORT proxyport(pUMPD->pp);

        return proxyport.EndDocPrinter(pUMPD->umpdCookie, hPrinter);
    }
    else
        return (*fpEndDocPrinter)(hPrinter);
}

extern "C"
BOOL  StartPagePrinterEx(PUMPD pUMPD, HANDLE hPrinter)
{
    if (WOW64PRINTING(pUMPD))
    {
        PROXYPORT proxyport(pUMPD->pp);

        return proxyport.StartPagePrinter(pUMPD->umpdCookie, hPrinter);
    }
    else
        return (*fpStartPagePrinter)(hPrinter); 
}

extern "C"
BOOL  EndPagePrinterEx(PUMPD pUMPD, HANDLE hPrinter)
{
    if (WOW64PRINTING(pUMPD))
    {
        PROXYPORT proxyport(pUMPD->pp);

        return proxyport.EndPagePrinter(pUMPD->umpdCookie, hPrinter);
    }
    else
        return (*fpEndPagePrinter)(hPrinter);
}

extern "C"
BOOL  AbortPrinterEx(PLDC pldc, BOOL bEMF)
{
    if (!bEMF && WOW64PRINTING(pldc->pUMPD))
    {
        PROXYPORT proxyport(pldc->pUMPD->pp);

        return proxyport.AbortPrinter(pldc->pUMPD->umpdCookie, pldc->hSpooler);
    }
    else
        return (*fpAbortPrinter)(pldc->hSpooler); 
}

extern "C"
BOOL  ResetPrinterWEx(PLDC pldc, PRINTER_DEFAULTSW *pPtrDef)
{
    BOOL bRet = TRUE;

    if (WOW64PRINTING(pldc->pUMPD))
    {
        if (!(pldc->fl & LDC_META_PRINT))
        {
            // either RAW printing or
            // ResetDC called before StartDoc, don't know
            // whether it is going RAW or EMF yet

            PROXYPORT proxyport(pldc->pUMPD->pp);
    
            bRet = proxyport.ResetPrinterW(pldc->pUMPD->umpdCookie, pldc->hSpooler, pPtrDef);

        }

        if (bRet && !(pldc->fl & LDC_PRINT_DIRECT))
        {
            // either EMF printing or
            // ResetDC called before StartDoc, we need to
            // call ResetPrinter on both 32-bit and 64-bit
            // printer handles.

            bRet = (*fpResetPrinterW)(pldc->hSpooler, pPtrDef);
        }

    }       
    else
    {
        bRet = (*fpResetPrinterW)(pldc->hSpooler, pPtrDef);
    }

    return bRet;
}

extern "C"
BOOL
QueryColorProfileEx(
    PLDC    pldc,
    PDEVMODEW pDevMode,
    ULONG   ulQueryMode,
    PVOID   pvProfileData,
    ULONG * pcjProfileSize,
    FLONG * pflProfileFlag)
{
    if (!(pldc->fl & LDC_META_PRINT) && WOW64PRINTING(pldc->pUMPD))
    {
        PROXYPORT proxyport(pldc->pUMPD->pp);

        return proxyport.QueryColorProfile(pldc->pUMPD->umpdCookie,
                                           pldc->hSpooler,
                                           pDevMode,
                                           ulQueryMode,
                                           pvProfileData,
                                           pcjProfileSize,
                                           pflProfileFlag);
    }
    else
        return (*fpQueryColorProfile)(pldc->hSpooler,
                                      pDevMode,
                                      ulQueryMode,
                                      pvProfileData,
                                      pcjProfileSize,
                                      pflProfileFlag);
}


PPORT_MESSAGE
PROXYPORT::InitMsg(
    PPROXYMSG       Msg,
    SERVERPTR       pvIn,
    ULONG           cjIn,
    SERVERPTR       pvOut,
    ULONG           cjOut
    )
{
    Msg->h.u1.s1.DataLength = (short) (sizeof(*Msg) - sizeof(Msg->h));
    Msg->h.u1.s1.TotalLength = (short) (sizeof(*Msg));

    Msg->h.u2.ZeroInit = 0;

    if(pvOut == 0) cjOut = 0;

    Msg->cjIn = cjIn;
    Msg->pvIn = pvIn;
    
    Msg->cjOut = cjOut;
    Msg->pvOut = pvOut;

    return( (PPORT_MESSAGE)Msg );
}

BOOL
PROXYPORT::CheckMsg(
    NTSTATUS        Status,
    PPROXYMSG       Msg,
    SERVERPTR       pvOut,
    ULONG           cjOut
    )
{
    ULONG       cbData = Msg->h.u1.s1.DataLength;

    if (cbData == (sizeof(*Msg) - sizeof(Msg->h)))
    {
        if(pvOut != Msg->pvOut)
        {
            return(FALSE);
        }

        if(cjOut != Msg->cjOut)
        {
            return(FALSE);
        }

        // do nothing

    }
    else
    {
        return(FALSE);
    }

    return( TRUE );
}

NTSTATUS
PROXYPORT::SendRequest(
    SERVERPTR       pvIn,
    ULONG           cjIn,
    SERVERPTR       pvOut,
    ULONG           cjOut
    )
{
    NTSTATUS        Status;
    PROXYMSG        Request;
    PROXYMSG        Reply;

    InitMsg( &Request, pvIn, cjIn, pvOut, cjOut );
    
    Status = NtRequestWaitReplyPort( pp->PortHandle,
                                     (PPORT_MESSAGE)&Request,
                                     (PPORT_MESSAGE)&Reply
                                   );

    if (!NT_SUCCESS( Status ))
    {
        return( Status );
    }

    if (Reply.h.u2.s2.Type == LPC_REPLY)
    {
        if (!CheckMsg( Status, &Reply, pvOut, cjOut ))
        {
            return(STATUS_UNSUCCESSFUL);
        }
    }
    else
    {
        return(STATUS_UNSUCCESSFUL);
    }

    return( Status );
}


#define ALIGN_UMPD_BUFFER(cj)   (((cj) + (sizeof(KERNEL_PVOID) -1)) & ~(sizeof(KERNEL_PVOID)-1))

SERVERPTR
PROXYPORT::HeapAlloc(ULONG inSize)
{
    KPBYTE ptr;

    if(pp->ClientMemoryAllocSize + ALIGN_UMPD_BUFFER(inSize) > pp->ClientMemorySize)
        return 0;

    ptr = pp->ClientMemoryBase + pp->ClientMemoryAllocSize + pp->ServerMemoryDelta;

    pp->ClientMemoryAllocSize += ALIGN_UMPD_BUFFER(inSize);

    return (SERVERPTR) ptr;
}


PROXYPORT::PROXYPORT(ULONGLONG inMaxSize)
{
    NTSTATUS                        Status;
    PORT_VIEW                       ClientView;
    ULONG                           MaxMessageLength;
    LARGE_INTEGER                   MaximumSize;
    UNICODE_STRING                  PortName;
    SECURITY_QUALITY_OF_SERVICE     DynamicQos;
    WCHAR                           awcPortName[MAX_PATH] = {0};
    DWORD                           CurrSessionId;
    DWORD                           CurrProcessId = GetCurrentProcessId();
    
    ProcessIdToSessionId(CurrProcessId,&CurrSessionId);
    wsprintfW(awcPortName, L"%s_%x", L"\\RPC Control\\UmpdProxy", CurrSessionId);
     
    DynamicQos.Length = 0;
    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;

    
    if ((pp = (ProxyPort *) LOCALALLOC(sizeof(ProxyPort))) == NULL ||
        !NT_SUCCESS((NTSTATUS)INITIALIZECRITICALSECTION(&pp->semPort)))
    {
        WARNING("PROXYPORT::PROXYPORT mem alloc OR critical section init failed\n");
        
        if (pp)
            LOCALFREE(pp);
        
        pp = NULL;
        return;
    }

    pp->ClientMemoryBase = 0;
    pp->ClientMemorySize = 0;
    pp->ClientMemoryAllocSize = 0;
    pp->PortHandle = NULL;
    pp->ServerMemoryBase = 0;
    pp->ServerMemoryDelta = 0;

    Status = STATUS_SUCCESS;

    RtlInitUnicodeString( &PortName, awcPortName );

    MaximumSize.QuadPart = inMaxSize;

    ZeroMemory(&ClientView.SectionHandle, sizeof(ClientView.SectionHandle));

    Status = NtCreateSection( (PHANDLE)&ClientView.SectionHandle,
                              SECTION_MAP_READ | SECTION_MAP_WRITE,
                              NULL,
                              &MaximumSize,
                              PAGE_READWRITE,
                              SEC_COMMIT,
                              NULL
                            );

    if (NT_SUCCESS( Status ))
    {
        ClientView.Length = sizeof( ClientView );
        ClientView.SectionOffset = 0;
        ClientView.ViewSize = (LPC_SIZE_T) inMaxSize;
        ClientView.ViewBase = 0;
        ClientView.ViewRemoteBase = 0;

        if (BLOADSPOOLER &&
            (*fpLoadSplWow64)(NULL) == ERROR_SUCCESS)
        {
            Status = NtConnectPort( &pp->PortHandle,
                                    &PortName,
                                    &DynamicQos,
                                    &ClientView,
                                    NULL,
                                    (PULONG)&MaxMessageLength,
                                    NULL,
                                    0
                                  );

            if (NT_SUCCESS( Status ))
            {
                pp->SectionHandle = (HANDLE)ClientView.SectionHandle;
                pp->ClientMemoryBase = (KPBYTE)ClientView.ViewBase;
                pp->ClientMemorySize = (SIZE_T)inMaxSize;
                pp->ServerMemoryBase = (KPBYTE)ClientView.ViewRemoteBase;
                pp->ServerMemoryDelta = pp->ServerMemoryBase - 
                                        pp->ClientMemoryBase;

                NtRegisterThreadTerminatePort(pp->PortHandle);
            }
            else
            {
                WARNING("PROXYPORT::PROXYPORT: NtConnectPort failed\n");
            }
        }
        else
        {
            Status = STATUS_UNSUCCESSFUL;
            WARNING("PROXYPORT::PROXYPORT failed to load spooler or splwow64\n");
        }
    }
    else
    {
        WARNING("PROXYPORT::PROXYPORT: failed to create section\n");
    }

    if(!NT_SUCCESS( Status ))
    {
        if ((HANDLE)ClientView.SectionHandle)
        {
            NtClose((HANDLE)ClientView.SectionHandle);
        }
        
        DELETECRITICALSECTION(&pp->semPort);
        LOCALFREE(pp);
        
        pp = NULL;
    }
    else
    {
        // grab port access

        ENTERCRITICALSECTION(&pp->semPort);
    }
}

void
PROXYPORT::Close()
{
    if (pp->SectionHandle)
    {
        if (!CloseHandle(pp->SectionHandle))
        {
            WARNING("PROXYPORT::Close failed to close the section handle\n");
        }
    }

    if (pp->PortHandle != NULL)
    {
        if (!CloseHandle( pp->PortHandle ))
        {
            WARNING("PROXYPORT::Close failed to close the port handle\n");
        }
    }

    LEAVECRITICALSECTION(&pp->semPort);
    DELETECRITICALSECTION(&pp->semPort);
    LOCALFREE(pp);

    pp = NULL;
}

void vUMPDWow64Shutdown()
{
    PUMPD pUMPD = gCachedUMPDList;

    while(pUMPD)
    {
        if (pUMPD->pp)
        {
            PROXYPORT   proxyPort(pUMPD->pp);

            proxyPort.Shutdown();
        }
        pUMPD = pUMPD->pNext;
    }
}

BOOL
PROXYPORT::ThunkMemBlock(
    KPBYTE *            ptr,
    ULONG               size)
{
    BOOL  bRet = TRUE;

    if (*ptr)
    {
        SERVERPTR           sp = HeapAlloc(size);
        CLIENTPTR           cp = ServerToClientPtr(sp);
    
        if (cp)
        {
            RtlCopyMemory((PVOID)cp, (PVOID)*ptr, size);
            *ptr = sp;
        }
        else
            bRet = FALSE;
    }

    return bRet;
}

BOOL
PROXYPORT::ThunkStr(LPWSTR * ioLpstr)
{
    BOOL bRet = TRUE;

    if(*ioLpstr != NULL)
    {
        bRet = ThunkMemBlock((KPBYTE *) ioLpstr, (wcslen(*ioLpstr) + 1) * sizeof(WCHAR));
    }
    
    return bRet;
}

KERNEL_PVOID
PROXYPORT::LoadDriver(
    PDRIVER_INFO_5W     pDriverInfo,
    LPWSTR              pwstrPrinterName,
    PRINTER_DEFAULTSW*  pdefaults,
    HANDLE              hPrinter32
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    SERVERPTR           spInput;
    SERVERPTR           spOutput;
    LOADDRIVERINPUT*    pInput;
    KERNEL_PVOID        umpdCookie = NULL;

    HeapInit();

    if (!(spInput = HeapAlloc(sizeof(LOADDRIVERINPUT))) ||
        !(spOutput = HeapAlloc(sizeof(KERNEL_PVOID))))
        return NULL;

    pInput = (LOADDRIVERINPUT *) ServerToClientPtr(spInput);

    pInput->driverInfo.cVersion = pDriverInfo->cVersion; 
    pInput->driverInfo.pName = (KLPWSTR)pDriverInfo->pName;
    pInput->driverInfo.pEnvironment = (KLPWSTR)pDriverInfo->pEnvironment;
    pInput->driverInfo.pDriverPath = (KLPWSTR)pDriverInfo->pDriverPath;
    pInput->driverInfo.pDataFile = (KLPWSTR)pDriverInfo->pDataFile;
    pInput->driverInfo.pConfigFile = (KLPWSTR)pDriverInfo->pConfigFile;
    pInput->driverInfo.dwDriverAttributes = pDriverInfo->dwDriverAttributes;
    pInput->driverInfo.dwConfigVersion = pDriverInfo->dwConfigVersion;
    pInput->driverInfo.dwDriverVersion = pDriverInfo->dwDriverVersion;
    pInput->clientPid = GetCurrentProcessId();
    pInput->hPrinter32 = HandleToUlong(hPrinter32);

    pInput->pPrinterName = (KLPWSTR)pwstrPrinterName;

    pInput->defaults.pDatatype = (KLPWSTR)pdefaults->pDatatype;
    pInput->defaults.pDevMode = (KPBYTE)pdefaults->pDevMode;
    pInput->defaults.DesiredAccess = pdefaults->DesiredAccess;

    if (!ThunkStr((LPWSTR *)&pInput->driverInfo.pName)           ||
        !ThunkStr((LPWSTR *)&pInput->driverInfo.pEnvironment)    ||
        !ThunkStr((LPWSTR *)&pInput->driverInfo.pDriverPath)     ||
        !ThunkStr((LPWSTR *)&pInput->driverInfo.pDataFile)       ||
        !ThunkStr((LPWSTR *)&pInput->driverInfo.pConfigFile)     ||
        !ThunkStr((LPWSTR *)&pInput->pPrinterName)               ||
        !ThunkStr((LPWSTR *)&pInput->defaults.pDatatype)         ||
        !ThunkMemBlock(&pInput->defaults.pDevMode, sizeof(DEVMODEW))
       )
       return NULL;

    pInput->umpdthdr.umthdr.ulType = INDEX_LoadUMPrinterDrv;

    Status = SendRequest(spInput, sizeof(LOADDRIVERINPUT),
                                   spOutput, sizeof(KERNEL_PVOID));

    if (NT_SUCCESS( Status ))
    {
        umpdCookie = *((KERNEL_PVOID *) ServerToClientPtr(spOutput));
    }

    return umpdCookie;
}

void
PROXYPORT::UnloadDriver(
    KERNEL_PVOID    umpdCookie,
    HANDLE          hPrinter32,
    BOOL            bNotifySpooler
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SERVERPTR               spInput;
    UNLOADDRIVERINPUT *     pInput;

    HeapInit();

    if (spInput = HeapAlloc(sizeof(UNLOADDRIVERINPUT)))
    {
        pInput = (UNLOADDRIVERINPUT *) ServerToClientPtr(spInput);
    
        pInput->umpdCookie = umpdCookie;
        pInput->clientPid = GetCurrentProcessId();
        pInput->hPrinter32 = HandleToUlong(hPrinter32);
        pInput->bNotifySpooler = bNotifySpooler;
    
        pInput->umpdthdr.umthdr.ulType = INDEX_UnloadUMPrinterDrv;
    
        Status = SendRequest(spInput, sizeof(spInput), 0, 0);
    }
}

int
PROXYPORT::DocumentEvent(
    KERNEL_PVOID    umpdCookie,
    HANDLE          hPrinter32,
    HDC             hdc,
    INT             iEsc,
    ULONG           cjIn,
    PVOID           pvIn,
    ULONG           cjOut,
    PVOID           pvOut
)
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SERVERPTR               spInput;
    SERVERPTR               spOutput;
    DOCUMENTEVENTINPUT*     pInput;
    CLIENTPTR               cppvIn = NULL;
    INT                     iRet = DOCUMENTEVENT_FAILURE;
    ULONG                   cjAlloc = 0;
    DEVMODEW                *pdmCopy = NULL;

    HeapInit();

    if (!(spInput = HeapAlloc(sizeof(DOCUMENTEVENTINPUT)))                ||
        !(pInput = (DOCUMENTEVENTINPUT *) ServerToClientPtr(spInput))     ||
        !(spOutput = HeapAlloc(sizeof(int))))
    {
        return DOCUMENTEVENT_FAILURE;
    }

    pInput->umpdthdr.umthdr.ulType = INDEX_DocumentEvent;
    pInput->umpdthdr.umthdr.cjSize = sizeof(*pInput);
    pInput->umpdCookie = umpdCookie;
    pInput->clientPid = GetCurrentProcessId();
    pInput->hPrinter32 = HandleToUlong(hPrinter32);
    pInput->hdc = (KHDC)hdc;
    pInput->iEsc = iEsc;
    pInput->cjIn = cjIn;
    pInput->pvIn = NULL;
    pInput->cjOut = cjOut;
    pInput->pvOut = NULL;
    pInput->pdmCopy = NULL;
    
    // thunk input data
    
    if (cjIn && pvIn)
    {
        if (iEsc == DOCUMENTEVENT_CREATEDCPRE)
        {
            cjAlloc = sizeof(DOCEVENT_CREATEDCPRE_UMPD);
        }
        else if (iEsc == DOCUMENTEVENT_CREATEDCPOST ||
                 iEsc == DOCUMENTEVENT_RESETDCPRE   ||
                 iEsc == DOCUMENTEVENT_RESETDCPOST  ||
                 iEsc == DOCUMENTEVENT_STARTDOCPRE)
        {
            cjAlloc = sizeof(KPBYTE);
        }
        else if (iEsc == DOCUMENTEVENT_ESCAPE)
        {
            cjAlloc = sizeof(DOCEVENT_ESCAPE_UMPD);
        }

        // allocate heap

        if (cjAlloc)
        {
            if (!(pInput->pvIn = HeapAlloc(cjAlloc)))
            {
                return DOCUMENTEVENT_FAILURE;
            }

            pInput->cjIn = cjAlloc;
            cppvIn = ServerToClientPtr(pInput->pvIn);
        }

        switch (iEsc)
        {
        case DOCUMENTEVENT_CREATEDCPRE:
            {
                DOCEVENT_CREATEDCPRE_UMPD  *pDocEvent = (DOCEVENT_CREATEDCPRE_UMPD*)cppvIn;
                DOCEVENT_CREATEDCPRE       *pDocEventIn = (DOCEVENT_CREATEDCPRE*)pvIn;
                
                pDocEvent->pszDriver = (KPBYTE)0;
                pDocEvent->pszDevice = (KPBYTE)pDocEventIn->pszDevice;
                pDocEvent->pdm = (KPBYTE)pDocEventIn->pdm;
                pDocEvent->bIC = pDocEventIn->bIC;
    
                if (!ThunkStr((LPWSTR*)&pDocEvent->pszDevice)    ||
                    !ThunkMemBlock(&pDocEvent->pdm, sizeof(DEVMODEW)))
                {
                    return DOCUMENTEVENT_FAILURE;
                }
            }
            break;

        case DOCUMENTEVENT_RESETDCPRE:
            {
                *((KPBYTE*)cppvIn) = (KPBYTE)(*((DEVMODEW**)pvIn));
                
                if (!ThunkMemBlock((KPBYTE*)cppvIn, sizeof(DEVMODEW)))
                    return DOCUMENTEVENT_FAILURE;                
            }
            break;

        case DOCUMENTEVENT_STARTDOCPRE:
            {
                SERVERPTR       spTemp;
                DOCINFOW_UMPD   *pDocInfo;
                DOCINFOW        *pDocInfoIn = *((DOCINFOW**)pvIn);

                if (!(spTemp = HeapAlloc(sizeof(DOCINFOW_UMPD))))
                    return DOCUMENTEVENT_FAILURE;
                
                *((KPBYTE*)cppvIn) = spTemp;
                pDocInfo = (DOCINFOW_UMPD*)ServerToClientPtr(spTemp);

                pDocInfo->cbSize        = pDocInfoIn->cbSize;
                pDocInfo->lpszDocName   = (KLPWSTR)pDocInfoIn->lpszDocName;
                pDocInfo->lpszOutput    = (KLPWSTR)pDocInfoIn->lpszOutput;
                pDocInfo->lpszDatatype  = (KLPWSTR)pDocInfoIn->lpszDatatype;
                pDocInfo->fwType        = pDocInfoIn->fwType;
    
                if (!ThunkStr((LPWSTR*)&pDocInfo->lpszDocName)    ||
                    !ThunkStr((LPWSTR*)&pDocInfo->lpszOutput)     ||
                    !ThunkStr((LPWSTR*)&pDocInfo->lpszDatatype))
                {
                    return DOCUMENTEVENT_FAILURE;                                
                }
            }
            break;
        
        case DOCUMENTEVENT_CREATEDCPOST:
        case DOCUMENTEVENT_RESETDCPOST:
            {
                if (*((PDEVMODEW *)pvIn))
                {
                    KPBYTE *ppdmDrv = (KPBYTE*)(*((PBYTE*)pvIn) + sizeof(DEVMODEW));

                    *((KPBYTE*)cppvIn) = *ppdmDrv;
                    
                    LOCALFREE(*(PBYTE*)pvIn);
                }
                else 
                {
                    *((KPBYTE*)cppvIn) = NULL;
                }

            }
            break;

        case DOCUMENTEVENT_STARTDOCPOST:
            {
                pInput->pvIn = (KPBYTE)pvIn;
                
                if (!ThunkMemBlock(&pInput->pvIn, sizeof(LONG)))
                    return DOCUMENTEVENT_FAILURE;
            }
            break;

        case DOCUMENTEVENT_ESCAPE:
            {
                DOCEVENT_ESCAPE_UMPD    *pEscape = (DOCEVENT_ESCAPE_UMPD*)cppvIn;
                DOCEVENT_ESCAPE         *pEscapeIn = (DOCEVENT_ESCAPE*)pvIn;

                pEscape->iEscape = pEscapeIn->iEscape;
                pEscape->cjInput = pEscapeIn->cjInput;
                pEscape->pvInData = (KPBYTE)pEscapeIn->pvInData;
    
                if (!ThunkMemBlock(&pEscape->pvInData, (ULONG)pEscapeIn->cjInput))
                    return DOCUMENTEVENT_FAILURE;
            }
            break;

        default:
            return DOCUMENTEVENT_FAILURE;
        }
    }

    if (cjOut && pvOut)
    {
        if (iEsc == DOCUMENTEVENT_CREATEDCPRE || iEsc == DOCUMENTEVENT_RESETDCPRE)
        {
            if (!(pInput->pvOut = HeapAlloc(sizeof(KPBYTE))) ||
                !(pInput->pdmCopy = HeapAlloc(sizeof(DEVMODEW))) ||
                !(pdmCopy = (DEVMODEW*)LOCALALLOC(sizeof(DEVMODEW) + sizeof(KPBYTE))))
            {
                return DOCUMENTEVENT_FAILURE;
            }

            *((KPBYTE*)ServerToClientPtr(pInput->pvOut)) = 0;
            pInput->cjOut = sizeof(KPBYTE);
        }
        else if (iEsc == DOCUMENTEVENT_ESCAPE)
        {
            if (!(pInput->pvOut = HeapAlloc(cjOut)))
                return DOCUMENTEVENT_FAILURE;
        }
    }
        
    Status = SendRequest(spInput, sizeof(DOCUMENTEVENTINPUT), spOutput, sizeof(int));

    if (NT_SUCCESS( Status ))
    {
        iRet = *((int *) ServerToClientPtr(spOutput));
        
        if (iRet != DOCUMENTEVENT_FAILURE)
        {
            if (iEsc == DOCUMENTEVENT_CREATEDCPRE || iEsc == DOCUMENTEVENT_RESETDCPRE)
            {
                PDEVMODEW   *ppvOut = (PDEVMODEW*)pvOut;
                KPBYTE      kpdm = *((KPBYTE*)ServerToClientPtr(pInput->pvOut));

                ASSERTGDI(pvOut, "ProxyPort::DocumentEvent pvOut NULL\n");
                
                *ppvOut = kpdm ? pdmCopy : NULL;

                if (kpdm)
                {
                    RtlCopyMemory(pdmCopy, (PVOID)ServerToClientPtr(pInput->pdmCopy), sizeof(DEVMODEW));
                    
                    KPBYTE      *ppdmDrv = (KPBYTE*)((PBYTE)pdmCopy + sizeof(DEVMODEW));
                    
                    *ppdmDrv = kpdm;                     
                }
                else
                {
                    LOCALFREE(pdmCopy);
                }
            }
            else if (iEsc == DOCUMENTEVENT_ESCAPE)
            {
                if (cjOut && pvOut)
                    RtlCopyMemory(pvOut, (PVOID)ServerToClientPtr(pInput->pvOut), cjOut);
            }
        }
        else
        {
            WARNING("DocumentEvent failed \n");
        }
    }

    if (iRet == DOCUMENTEVENT_FAILURE && pdmCopy)
    {
        LOCALFREE(pdmCopy);
    }

    return iRet;
}


DWORD
PROXYPORT::StartDocPrinterW(
    KERNEL_PVOID    umpdCookie,
    HANDLE          hPrinter32,
    DWORD           level,
    LPBYTE          pDocInfo
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SERVERPTR               spInput;
    SERVERPTR               spOutput;
    STARTDOCPRINTERWINPUT*  pInput;
    CLIENTPTR               cppDocInfo;

    HeapInit();

    if (!(spInput = HeapAlloc(sizeof(STARTDOCPRINTERWINPUT))) ||
        !(spOutput = HeapAlloc(sizeof(DWORD))))
        return 0;

    pInput = (STARTDOCPRINTERWINPUT *) ServerToClientPtr(spInput);

    pInput->umpdthdr.umthdr.ulType = INDEX_StartDocPrinterW;
    pInput->umpdthdr.umthdr.cjSize = sizeof(*pInput);
    pInput->umpdCookie = umpdCookie;
    pInput->clientPid = GetCurrentProcessId();
    pInput->hPrinter32 = HandleToUlong(hPrinter32);
    pInput->level = level;
    pInput->lastError = 0;
    pInput->docInfo.pDocName = (KLPWSTR)((DOC_INFO_1W*)pDocInfo)->pDocName;
    pInput->docInfo.pOutputFile = (KLPWSTR)((DOC_INFO_1W*)pDocInfo)->pOutputFile;
    pInput->docInfo.pDatatype = (KLPWSTR)((DOC_INFO_1W*)pDocInfo)->pDatatype;
    
    // GDI only uses level 1 and level 3
    if (level == 3)
        pInput->docInfo.dwFlags = ((DOC_INFO_3W*)pDocInfo)->dwFlags;
    else
        pInput->docInfo.dwFlags = 0;
        
    if (!ThunkStr((LPWSTR *)&pInput->docInfo.pDocName)      ||
        !ThunkStr((LPWSTR *)&pInput->docInfo.pOutputFile)   ||
        !ThunkStr((LPWSTR *)&pInput->docInfo.pDatatype))
        return 0;
    
    Status = SendRequest(spInput, sizeof(STARTDOCPRINTERWINPUT), spOutput, sizeof(DWORD));

    if (!NT_SUCCESS( Status ))
         return 0;
    else
    {
        if (pInput->lastError)
            GdiSetLastError(pInput->lastError);
        return (*((DWORD *) ServerToClientPtr(spOutput)));
    }
}


BOOL
PROXYPORT::StartPagePrinter(KERNEL_PVOID umpdCookie, HANDLE hPrinter32)
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SERVERPTR               spInput;
    SERVERPTR               spOutput;
    UMPDSIMPLEINPUT*        pInput;

    HeapInit();

    if (!(spInput = HeapAlloc(sizeof(UMPDSIMPLEINPUT)))   ||
        !(spOutput = HeapAlloc(sizeof(BOOL))))
        return FALSE;

    pInput = (UMPDSIMPLEINPUT *) ServerToClientPtr(spInput);

    pInput->umpdthdr.umthdr.ulType = INDEX_StartPagePrinter;
    pInput->umpdthdr.umthdr.cjSize = sizeof(UMPDSIMPLEINPUT);
    pInput->umpdCookie = umpdCookie;
    pInput->clientPid = GetCurrentProcessId();
    pInput->hPrinter32 = HandleToUlong(hPrinter32);

    Status = SendRequest(spInput, sizeof(UMPDSIMPLEINPUT), spOutput, sizeof(BOOL));

    if (!NT_SUCCESS( Status ))
         return FALSE;
    
    return (*((BOOL*)ServerToClientPtr(spOutput)));        
}

BOOL
PROXYPORT::EndPagePrinter(KERNEL_PVOID umpdCookie, HANDLE hPrinter32)
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SERVERPTR               spInput;
    SERVERPTR               spOutput;
    UMPDSIMPLEINPUT*        pInput;

    HeapInit();

    if (!(spInput = HeapAlloc(sizeof(UMPDSIMPLEINPUT)))   ||
        !(spOutput = HeapAlloc(sizeof(BOOL))))
        return FALSE;

    pInput = (UMPDSIMPLEINPUT *) ServerToClientPtr(spInput);

    pInput->umpdthdr.umthdr.ulType = INDEX_EndPagePrinter;
    pInput->umpdthdr.umthdr.cjSize = sizeof(UMPDSIMPLEINPUT);
    pInput->umpdCookie = umpdCookie;
    pInput->clientPid = GetCurrentProcessId();
    pInput->hPrinter32 = HandleToUlong(hPrinter32);

    Status = SendRequest(spInput, sizeof(UMPDSIMPLEINPUT), spOutput, sizeof(BOOL));

    if (!NT_SUCCESS( Status ))
         return FALSE;
    
    return (*((BOOL*)ServerToClientPtr(spOutput)));        
}

BOOL
PROXYPORT::EndDocPrinter(KERNEL_PVOID umpdCookie, HANDLE hPrinter32)
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SERVERPTR               spInput;
    SERVERPTR               spOutput;
    UMPDSIMPLEINPUT*        pInput;

    HeapInit();

    if (!(spInput = HeapAlloc(sizeof(UMPDSIMPLEINPUT)))   ||
        !(spOutput = HeapAlloc(sizeof(BOOL))))
        return FALSE;

    pInput = (UMPDSIMPLEINPUT *) ServerToClientPtr(spInput);

    pInput->umpdthdr.umthdr.ulType = INDEX_EndDocPrinter;
    pInput->umpdthdr.umthdr.cjSize = sizeof(UMPDSIMPLEINPUT);
    pInput->umpdCookie = umpdCookie;
    pInput->clientPid = GetCurrentProcessId();
    pInput->hPrinter32 = HandleToUlong(hPrinter32);

    Status = SendRequest(spInput, sizeof(UMPDSIMPLEINPUT), spOutput, sizeof(BOOL));

    if (!NT_SUCCESS( Status ))
         return FALSE;
    
    return (*((BOOL*)ServerToClientPtr(spOutput)));        
}


BOOL
PROXYPORT::AbortPrinter(KERNEL_PVOID umpdCookie, HANDLE hPrinter32)
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SERVERPTR               spInput;
    SERVERPTR               spOutput;
    UMPDSIMPLEINPUT*        pInput;

    HeapInit();

    if (!(spInput = HeapAlloc(sizeof(UMPDSIMPLEINPUT)))   ||
        !(spOutput = HeapAlloc(sizeof(BOOL))))
        return FALSE;

    pInput = (UMPDSIMPLEINPUT *) ServerToClientPtr(spInput);

    pInput->umpdthdr.umthdr.ulType = INDEX_AbortPrinter;
    pInput->umpdthdr.umthdr.cjSize = sizeof(UMPDSIMPLEINPUT);
    pInput->umpdCookie = umpdCookie;
    pInput->clientPid = GetCurrentProcessId();
    pInput->hPrinter32 = HandleToUlong(hPrinter32);

    Status = SendRequest(spInput, sizeof(UMPDSIMPLEINPUT), spOutput, sizeof(BOOL));

    if (!NT_SUCCESS( Status ))
         return FALSE;
    
    return (*((BOOL*)ServerToClientPtr(spOutput)));        
}

BOOL
PROXYPORT::ResetPrinterW(KERNEL_PVOID umpdCookie, HANDLE hPrinter32, PRINTER_DEFAULTSW *pPtrDef)
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SERVERPTR               spInput;
    SERVERPTR               spOutput;
    RESETPRINTERWINPUT*     pInput;

    HeapInit();

    if (!(spInput = HeapAlloc(sizeof(RESETPRINTERWINPUT)))    ||
        !(spOutput = HeapAlloc(sizeof(BOOL))))
        return FALSE;

    pInput = (RESETPRINTERWINPUT *) ServerToClientPtr(spInput);

    pInput->umpdthdr.umthdr.ulType = INDEX_ResetPrinterW;
    pInput->umpdthdr.umthdr.cjSize = sizeof(RESETPRINTERWINPUT);
    pInput->umpdCookie = umpdCookie;
    pInput->clientPid = GetCurrentProcessId();
    pInput->hPrinter32 = HandleToUlong(hPrinter32);
    
    pInput->ptrDef.pDatatype = (KLPWSTR)pPtrDef->pDatatype;
    pInput->ptrDef.pDevMode = (KPBYTE)pPtrDef->pDevMode;
    pInput->ptrDef.DesiredAccess = pPtrDef->DesiredAccess;

    if (!ThunkStr((LPWSTR *)&pInput->ptrDef.pDatatype)  ||
        !ThunkMemBlock(&pInput->ptrDef.pDevMode, sizeof(DEVMODEW)))
        return FALSE;

    Status = SendRequest(spInput, sizeof(RESETPRINTERWINPUT), spOutput, sizeof(BOOL));

    if (!NT_SUCCESS( Status ))
         return FALSE;
    
    return (*((BOOL*)ServerToClientPtr(spOutput)));     
}

BOOL
PROXYPORT::QueryColorProfile(
    KERNEL_PVOID umpdCookie,
    HANDLE hPrinter32,
    PDEVMODEW pDevMode,
    ULONG ulQueryMode,
    PVOID pvProfileData,
    ULONG* pcjProfileSize,
    FLONG* pflProfileFlag
)
{   
    NTSTATUS                Status = STATUS_SUCCESS;
    SERVERPTR               spInput;
    SERVERPTR               spOutput;
    QUERYCOLORPROFILEINPUT*     pInput;

    HeapInit();

    if (!(spInput = HeapAlloc(sizeof(QUERYCOLORPROFILEINPUT)))    ||
        !(spOutput = HeapAlloc(sizeof(BOOL))))
        return -1;

    pInput = (QUERYCOLORPROFILEINPUT*) ServerToClientPtr(spInput);

    pInput->umpdthdr.umthdr.ulType = INDEX_QueryColorProfile;
    pInput->umpdthdr.umthdr.cjSize = sizeof(QUERYCOLORPROFILEINPUT);
    pInput->umpdCookie = umpdCookie;
    pInput->clientPid = GetCurrentProcessId();
    pInput->hPrinter32 = HandleToUlong(hPrinter32);
        
    pInput->pDevMode = pDevMode;
    pInput->ulQueryMode = ulQueryMode;
    pInput->cjProfileSize = *pcjProfileSize;
    pInput->flProfileFlag = *pflProfileFlag;
    pInput->lastError = 0;

    if (!(pInput->pvProfileData = HeapAlloc(*pcjProfileSize)) ||
        !ThunkMemBlock((KPBYTE*)&pInput->pDevMode, sizeof(DEVMODEW)))
        return -1;

    Status = SendRequest(spInput, sizeof(QUERYCOLORPROFILEINPUT), spOutput, sizeof(BOOL));

    if (!NT_SUCCESS( Status ))
         return -1;
    else
    {
        if (pInput->lastError)
            GdiSetLastError(pInput->lastError);
        return (*((BOOL*)ServerToClientPtr(spOutput)));     
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\umpddrv.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    umpddrv.c

Abstract:

    User-mode printer driver stubs for Drv callback functions

Environment:

        Windows NT 5.0

Revision History:

        09/30/97 -lingyunw-
                Created it by moving GdiPrinterThunk out of umpd.c.

--*/

#include "precomp.h"
#pragma hdrstop

RTL_CRITICAL_SECTION semUMPD;   // Critical section for user-mode printer driver

#if !defined(_GDIPLUS_)

#include "winddi.h"
#include "proxyport.h"

/*
#if DBG
#define DBG_TRACE(x) DbgPrint("UMPD: "#x"\n")
#else
#define DBG_TRACE(x)
#endif
*/

//
// Adjust user mode printer driver DHPDEV field in a SURFOBJ
//

__inline PUMDHPDEV
AdjustUMdhpdev(
    SURFOBJ *pso
    )

{
    PUMDHPDEV   pUMdhpdev = (PUMDHPDEV) pso->dhpdev;

    pso->dhpdev = pUMdhpdev->dhpdev;
    return pUMdhpdev;
}
  

BOOL
GdiCopyFD_GLYPHSET(
    FD_GLYPHSET *dst,
    FD_GLYPHSET *src,
    ULONG       cjSize
    )

{
    ULONG   index, offset, size;
    PBYTE   phg, pbMax;
    
    size = offsetof(FD_GLYPHSET, awcrun) + src->cRuns * sizeof(WCRUN);
    RtlCopyMemory(dst, src, size);

    dst->cjThis = cjSize;
    pbMax = (PBYTE)dst + cjSize;
    phg = (PBYTE)dst + size;
        
    //
    // Patch up memory pointers in each WCRUN structure
    //

    for (index=0; index < src->cRuns; index++)
    {
        if (src->awcrun[index].phg != NULL)
        {
            size = src->awcrun[index].cGlyphs * sizeof(HGLYPH);

            if (phg + size <= pbMax)
            {
                RtlCopyMemory(phg, src->awcrun[index].phg, size);
                dst->awcrun[index].phg = (HGLYPH*) phg;
                phg += size;
            }
            else
                return FALSE;
        }
    }

    return TRUE;
}

BOOL  bAddPrinterHandle(PUMPD pUMPD, DWORD clientPid, DWORD hPrinter32, HANDLE hPrinter64)
{
    PHPRINTERLIST pPtrList;
    BOOL bRet = FALSE;
    
    if (pPtrList = LOCALALLOC(sizeof(HPRINTERLIST)))
    {
        pPtrList->clientPid = clientPid;
        pPtrList->hPrinter32 = hPrinter32;
        pPtrList->hPrinter64 = hPrinter64;
        
        ENTERCRITICALSECTION(&semUMPD);
        
        pPtrList->pNext = pUMPD->pHandleList;
        pUMPD->pHandleList = pPtrList;
        
        bRet = TRUE;

        LEAVECRITICALSECTION(&semUMPD);
    }
    
    return bRet;
}

PHPRINTERLIST FindPrinterHandle(PUMPD pUMPD, DWORD clientPid, DWORD hPrinter32)
{
    PHPRINTERLIST pList;
    
    ENTERCRITICALSECTION(&semUMPD);
    
    pList = pUMPD->pHandleList;

    while(pList)
    {
        if (pList->clientPid == clientPid && pList->hPrinter32 == hPrinter32)
        {
            break;
        }
        pList = pList->pNext;
    }
    
    LEAVECRITICALSECTION(&semUMPD);
    
    return pList;                 
}

VOID  DeletePrinterHandle(PUMPD pUMPD, PHPRINTERLIST pNode)
{
    PHPRINTERLIST  pList;

    ENTERCRITICALSECTION(&semUMPD);

    pList = pUMPD->pHandleList;

    if (pList == pNode)
    {
        pUMPD->pHandleList = pNode->pNext;
    }
    else
    {
        while(pList && pList->pNext != pNode)
        {
            pList = pList->pNext;
        }
        
        if (pList)
        {
            pList->pNext = pNode->pNext;
        }
    }

    LEAVECRITICALSECTION(&semUMPD);

    if (pList)
    {
        LOCALFREE(pNode);
    }
}

//
// KERNEL_PVOID  UMPDAllocUserMem
//
// WOW64 printing only
//

KERNEL_PVOID UMPDAllocUserMem(ULONG cjSize)
{
    return ((KERNEL_PVOID) LOCALALLOC(cjSize));
}


//
//  KERNEL_PVOID  UMPDCopyMemory
//
//  WOW64 printing only
//
//  pvSrc
//        source
//
//  pvDest
//       dest
//
//  cjBits
//          size to copy
// 

KERNEL_PVOID UMPDCopyMemory(
    KERNEL_PVOID  pvSrc,
    KERNEL_PVOID  pvDest,
    ULONG         cjBits
)
{
    if (pvDest != NULL)
        RtlCopyMemory(pvDest, pvSrc, cjBits);
    
    return pvDest;
}

//
//  BOOL UMPDFreeMemory
//
//  WOW64 only
//

BOOL UMPDFreeMemory(
    KERNEL_PVOID pv1,
    KERNEL_PVOID pv2,
    KERNEL_PVOID pv3
)
{
    if (pv1)
        LOCALFREE(pv1);
    
    if (pv2)
       LOCALFREE(pv2);

    if (pv3)
       LOCALFREE(pv3);

    return TRUE;
}


/******************************Public*Routine******************************\
* GdiPrinterThunk function
*
* GDI callback for user-mode printer drivers.
*
* Parameters    pumth
*                   Pointer to input buffer.  Buffer has UMTHDR at
*                   beginning.
*
*               pvOut
*                   Output buffer.
*
*               cjOut
*                   Size of output buffer.
*
* Return Value
*
*   The function returns GPT_ERROR if an error occurs.  Otherwise, the
*   return value is dependent on the command specified by pumth->ulType.
*
* History:
*  7/17/97     -by- Lingyun Wang [lingyunw] Added giant body to
*                  Make it do the real work
*  30-Jun-1997 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

extern PUMPD
FindUserModePrinterDriver(
    PCWSTR  pDriverDllName,
    DWORD   dwDriverVersion,
    BOOL    bUseVersion
    );

WINGDIAPI
ULONG
WINAPI
GdiPrinterThunk (
    UMTHDR *    pvIn,
    PVOID       pvOut,
    ULONG       cjOut
    )
{
    INT         iRet = 1;
    UMPDTHDR *  pumpdthdr = (UMPDTHDR *) pvIn;
    HUMPD       hSaved;
    BOOL        bWOW64 = FALSE, bSetPUMPD = FALSE;
    ULONG       ulType = pvIn->ulType;
    
    //
    //  Call NtGdiSetPUMPDOBJ to set the W32THREAD.pUMPDObj pointer
    //  only if this is a DDI thunk
    //

    if (ulType <= INDEX_LAST+1)
    {
        if (!(bSetPUMPD = NtGdiSetPUMPDOBJ(pumpdthdr->humpd, TRUE, &hSaved, &bWOW64)))
        {
            WARNING ("NtGdiSetPUMPDOBJ failed\n");
            return GPT_ERROR;
        }
    }

    switch (ulType)
    {
        case INDEX_LoadUMPrinterDrv:
            {
                PLOADDRIVERINPUT    pInput = (PLOADDRIVERINPUT) pvIn;
                PUMPD               pUMPD = NULL;
                HANDLE              hPrinter = NULL;

                *((PUMPD *)pvOut) = NULL;
                
                if(BLOADSPOOLER)
                {
                    (*fpOpenPrinterW)(pInput->pPrinterName, &hPrinter, (LPPRINTER_DEFAULTSW)&pInput->defaults);

                    if(hPrinter)
                    {
                        if(LoadUserModePrinterDriverEx((PDRIVER_INFO_5W)&pInput->driverInfo, NULL, &pUMPD, NULL, 0) &&
                           bAddPrinterHandle(pUMPD, pInput->clientPid, pInput->hPrinter32, hPrinter))
                        {
                            *((PUMPD *) pvOut) = pUMPD;
                        }
                        else
                        {
                            if (pUMPD)
                                UnloadUserModePrinterDriver(pUMPD, TRUE, 0);
                            
                            (*fpClosePrinter)(hPrinter);
                            
                            WARNING("GdiPrinterThunk: failed to load umpd or add printer handles\n");
                        }
                    }
                    else
                    {
                        WARNING(("failed opening printer '%ls' on proxy\n", (PCH)pInput->pPrinterName));
                    }
                }
                else
                {
                    WARNING("GdiPrinterThunk: failed loading spooler\n");
                }
            }
            break;
    
        case INDEX_UnloadUMPrinterDrv:
            {
                PUNLOADDRIVERINPUT    pInput = (PUNLOADDRIVERINPUT) pvIn;
                PUMPD                 pUMPD = (PUMPD) pInput->umpdCookie;
                PHPRINTERLIST         pList;
                
                if (pInput->hPrinter32 &&
                    (pList = FindPrinterHandle(pUMPD, pInput->clientPid, pInput->hPrinter32)))
                {
                    (*fpClosePrinter)(pList->hPrinter64);
                    DeletePrinterHandle(pUMPD, pList);
                }
 
                UnloadUserModePrinterDriver(pUMPD, pInput->bNotifySpooler, 0);
            }
        break;

        case INDEX_UMDriverFN:
            {
                PDRVDRIVERFNINPUT pInput = (PDRVDRIVERFNINPUT) pvIn;
                PUMPD pUMPD = (PUMPD) pInput->cookie;
                BOOL * pbDrvFn = (BOOL *) pvOut;
                int index;

                if(pUMPD)
                {
                    for(index = 0; index < INDEX_LAST; index++)
                        pbDrvFn[index] = (pUMPD->apfn[index] != NULL ? TRUE : FALSE);
                }
                else
                {
                    RtlZeroMemory(pvOut, sizeof(BOOL) * INDEX_LAST);
                }
            }
        break;

        case INDEX_DocumentEvent:
            {
                PDOCUMENTEVENTINPUT  pInput = (PDOCUMENTEVENTINPUT) pvIn;
                PHPRINTERLIST  pList = FindPrinterHandle((PUMPD)pInput->umpdCookie, pInput->clientPid, pInput->hPrinter32);                
                
                if (pList)
                {
                    *((int*)pvOut) = (*fpDocumentEvent)(pList->hPrinter64,
                                                        pInput->hdc,
                                                        pInput->iEsc,
                                                        pInput->cjIn,
                                                        (PVOID)pInput->pvIn,
                                                        pInput->cjOut,
                                                        (PVOID)pInput->pvOut);
    
                    if (pInput->iEsc == DOCUMENTEVENT_CREATEDCPRE || pInput->iEsc == DOCUMENTEVENT_RESETDCPRE)
                    {
                        if ((*((int*)pvOut) != DOCUMENTEVENT_FAILURE) &&
                            *((DEVMODEW**)pInput->pvOut))
                        {
                            RtlCopyMemory(pInput->pdmCopy, *((DEVMODEW**)pInput->pvOut), sizeof(DEVMODEW));
                        }
                    }
                }
                else
                    *((int*)pvOut) = DOCUMENTEVENT_FAILURE;
            }
        break;

        case INDEX_StartDocPrinterW:
            {
                PSTARTDOCPRINTERWINPUT pInput = (PSTARTDOCPRINTERWINPUT) pvIn;
                PHPRINTERLIST  pList = FindPrinterHandle((PUMPD)pInput->umpdCookie, pInput->clientPid, pInput->hPrinter32);                

                if (pList)
                {
                    *((DWORD*)pvOut) = (*fpStartDocPrinterW)(pList->hPrinter64,
                                                            pInput->level,
                                                            (LPBYTE)&pInput->docInfo);
    
                    pInput->lastError = GetLastError();
                }
                else
                    *((DWORD*)pvOut) = 0; 
            }
        break;
        
        case INDEX_StartPagePrinter:
            {
                PUMPDSIMPLEINPUT    pInput = (PUMPDSIMPLEINPUT) pvIn;
                PHPRINTERLIST       pList = FindPrinterHandle((PUMPD)pInput->umpdCookie, pInput->clientPid, pInput->hPrinter32);                

                if (pList)
                    *((BOOL*)pvOut) = (*fpStartPagePrinter)(pList->hPrinter64);
                else
                    *((BOOL*)pvOut) = FALSE;
            }                
        break;
        
        case INDEX_EndPagePrinter:
            {
                PUMPDSIMPLEINPUT    pInput = (PUMPDSIMPLEINPUT) pvIn;
                PHPRINTERLIST       pList = FindPrinterHandle((PUMPD)pInput->umpdCookie, pInput->clientPid, pInput->hPrinter32);                

                if (pList)
                {
                    *((BOOL*)pvOut) = (*fpEndPagePrinter)(pList->hPrinter64);
                }
                else
                {
                    *((BOOL*)pvOut) = FALSE;
                }
            }                
        break;

        case INDEX_EndDocPrinter:
            {
                PUMPDSIMPLEINPUT    pInput = (PUMPDSIMPLEINPUT) pvIn;
                PHPRINTERLIST       pList = FindPrinterHandle((PUMPD)pInput->umpdCookie, pInput->clientPid, pInput->hPrinter32);                

                if (pList)
                    *((BOOL*)pvOut) = (*fpEndDocPrinter)(pList->hPrinter64);
                else
                    *((BOOL*)pvOut) = FALSE;
            }                
        break;

        case INDEX_AbortPrinter:
            {
                PUMPDSIMPLEINPUT    pInput = (PUMPDSIMPLEINPUT) pvIn;
                PHPRINTERLIST       pList = FindPrinterHandle((PUMPD)pInput->umpdCookie, pInput->clientPid, pInput->hPrinter32);                

                if (pList)
                    *((BOOL*)pvOut) = (*fpAbortPrinter)(pList->hPrinter64);
                else
                    *((BOOL*)pvOut) = FALSE;
            }                
        break;

        case INDEX_ResetPrinterW:
            {
                PRESETPRINTERWINPUT    pInput = (PRESETPRINTERWINPUT) pvIn;
                PHPRINTERLIST          pList = FindPrinterHandle((PUMPD)pInput->umpdCookie, pInput->clientPid, pInput->hPrinter32);                

                if (pList)
                {
                    *((BOOL*)pvOut) = (*fpResetPrinterW)(pList->hPrinter64,
                                                         (PRINTER_DEFAULTSW*)&pInput->ptrDef);
                }
                else
                    *((BOOL*)pvOut) = FALSE;                    
            }                
        break;
        
        case INDEX_QueryColorProfile:
            {
                PQUERYCOLORPROFILEINPUT    pInput = (PQUERYCOLORPROFILEINPUT) pvIn;
                ULONG                      cjProfileSizeOld = pInput->cjProfileSize;
                PHPRINTERLIST              pList = FindPrinterHandle((PUMPD)pInput->umpdCookie, pInput->clientPid, pInput->hPrinter32);                

                if (pList)
                {
                    *((BOOL*)pvOut) = (*fpQueryColorProfile)(pList->hPrinter64,
                                                             pInput->pDevMode,
                                                             pInput->ulQueryMode,
                                                             pInput->pvProfileData,
                                                             &pInput->cjProfileSize,
                                                             &pInput->flProfileFlag);
                    if ((*(INT*)pvOut) == 0 &&
                        pInput->cjProfileSize > cjProfileSizeOld &&
                        (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
                    {
                        pInput->lastError = GetLastError();
                    }
                }
                else
                    *((BOOL*)pvOut) = FALSE;                    
            }                
        break;
        
        case INDEX_UMPDDrvEnableDriver:  // special index for DrvEnableDriver
           {
                PDRVENABLEDRIVERINPUT pInput = (PDRVENABLEDRIVERINPUT) pvIn;
                *((PUMPD *) pvOut) = UMPDDrvEnableDriver(pInput->pwszDriver, DDI_DRIVER_VERSION_NT5_01_SP1);
           }
        break;

        case INDEX_DrvEnablePDEV:
           {
                PDRVENABLEPDEVINPUT pInput = (PDRVENABLEPDEVINPUT) pvIn;
                PUMPD               pUMPD = (PUMPD) pInput->umpdCookie;
                PFN                 pfn = pUMPD->apfn[INDEX_DrvEnablePDEV];
                PUMDHPDEV           pUMdhpdev;
                HANDLE              hPrinter = NULL;
                PHPRINTERLIST       pList;

                // If we have a local hPrinter use it

                if (pInput->bWOW64 &&
                    (pList = FindPrinterHandle((PUMPD)pInput->umpdCookie, pInput->clientPid, HandleToUlong(pInput->hPrinter))))
                {
                    hPrinter = pList->hPrinter64;
                }
                else
                {
                    hPrinter = pInput->hPrinter;
                }
                    
                if (pUMdhpdev = (PUMDHPDEV) LOCALALLOC(sizeof(UMDHPDEV)))
                {
                   ZeroMemory(pUMdhpdev, sizeof(UMDHPDEV));
                   pUMdhpdev->pUMPD = pUMPD;

                   pUMdhpdev->dhpdev = (DHPDEV) pfn(
                                         pInput->pdm,
                                         pInput->pLogAddress,
                                         pInput->cPatterns,
                                         pInput->phsurfPatterns,
                                         pInput->cjCaps,
                                         pInput->pdevcaps,
                                         pInput->cjDevInfo,
                                         pInput->pDevInfo,
                                         pInput->hdev,
                                         pInput->pDeviceName,
                                         hPrinter);


                   if (pUMdhpdev->dhpdev == NULL)
                   {
                       WARNING ("Driver's DrvEnablePDEV failed\n");

                       LOCALFREE(pUMdhpdev);
                       pUMdhpdev = NULL;
                   }
#if defined(_WIN64)
                   else
                   {
                       if (pInput->bWOW64 && pInput->pdevcaps)
                       {
                           GDIINFO *pGdiInfo = (GDIINFO*)pInput->pdevcaps;

                           if (pGdiInfo->ulHTPatternSize == HT_PATSIZE_USER &&
                               pGdiInfo->cxHTPat <= HT_USERPAT_CX_MAX &&
                               pGdiInfo->cyHTPat <= HT_USERPAT_CY_MAX)
                           {
                               pInput->cxHTPat = pGdiInfo->cxHTPat;
                               pInput->cyHTPat = pGdiInfo->cyHTPat;
                               pInput->bHTPatA = pGdiInfo->pHTPatA ? TRUE : FALSE;
                               pInput->bHTPatB = pGdiInfo->pHTPatB ? TRUE : FALSE;
                               pInput->bHTPatC = pGdiInfo->pHTPatC ? TRUE : FALSE;

                               if (pInput->bHTPatA)
                               {
                                   RtlCopyMemory(pInput->pHTPatA,
                                                 pGdiInfo->pHTPatA,
                                                 pInput->cxHTPat*
                                                 pInput->cyHTPat);
                               }

                               if (pInput->bHTPatB)
                               {             
                                   RtlCopyMemory(pInput->pHTPatB,
                                                 pGdiInfo->pHTPatB,
                                                 pInput->cxHTPat*
                                                 pInput->cyHTPat);
                               }

                               if (pInput->bHTPatC)
                               {
                                   RtlCopyMemory(pInput->pHTPatC,
                                                 pGdiInfo->pHTPatC,
                                                 pInput->cxHTPat*
                                                 pInput->cyHTPat);
                               }
                           }
                       }
                   }
#endif
                }
                else
                {
                    WARNING ("umEnablePDEV failed memory allocation \n");
                }

                *((DHPDEV *) pvOut) = (DHPDEV) pUMdhpdev;
           }
        break;

        case INDEX_DrvCompletePDEV:
            {
                PDRVCOMPLETEPDEVINPUT pInput = (PDRVCOMPLETEPDEVINPUT) pvIn;
                PUMDHPDEV             pUMdhpdev = (PUMDHPDEV) pInput->dhpdev;
                PUMPD                 pUMPD = pUMdhpdev->pUMPD;
                PFN                   pfn = pUMPD->apfn[INDEX_DrvCompletePDEV];

                pfn(pUMdhpdev->dhpdev, pInput->hdev);
            }
        break;

        case INDEX_DrvFree:
            {
                PDRVFREEINPUT pInput = (PDRVFREEINPUT) pvIn;
                PUMDHPDEV             pUMdhpdev = (PUMDHPDEV) pInput->dhpdev;
                PUMPD                 pUMPD = pUMdhpdev->pUMPD;
                PFN                   pfn = pUMPD->apfn[INDEX_DrvFree];
                
                if (pfn)
                    pfn(pInput->pv, pInput->id);
            }
        break;

        case INDEX_DrvResetPDEV:
            {
                PDRVRESETPDEVINPUT  pInput = (PDRVRESETPDEVINPUT) pvIn;
                PUMDHPDEV           pUMdhpdevOld= (PUMDHPDEV) pInput->dhpdevOld;
                PUMDHPDEV           pUMdhpdevNew= (PUMDHPDEV) pInput->dhpdevNew;
                PUMPD               pUMPDNew = pUMdhpdevNew->pUMPD;
                PFN                 pfn = pUMPDNew->apfn[INDEX_DrvResetPDEV];
                
                *((BOOL *) pvOut) = (BOOL)pfn(pUMdhpdevOld->dhpdev, pUMdhpdevNew->dhpdev);
            }
        break;

        case INDEX_DrvDisablePDEV:
             {
                PUMDHPDEV pUMdhpdev = (PUMDHPDEV)((PDHPDEVINPUT)pvIn)->dhpdev;
                PUMPD     pUMPD = pUMdhpdev->pUMPD;
                PFN       pfn = pUMPD->apfn[INDEX_DrvDisablePDEV];
                
                pfn(pUMdhpdev->dhpdev);

                // free up memory allocated for user mode printer drivers

                if (pUMdhpdev)
                {
                    LOCALFREE (pUMdhpdev);
                }
             }
        break;

        case INDEX_DrvEnableSurface:
            {
                PUMDHPDEV pUMdhpdev = (PUMDHPDEV)((PDHPDEVINPUT)pvIn)->dhpdev;
                PUMPD     pUMPD = pUMdhpdev->pUMPD;
                PFN       pfn = pUMPD->apfn[INDEX_DrvEnableSurface];
                
                *((HSURF *) pvOut) = (HSURF) pfn(pUMdhpdev->dhpdev);
            }
        break;

        case INDEX_DrvDisableSurface:
            {
                PUMDHPDEV pUMdhpdev = (PUMDHPDEV)((PDHPDEVINPUT)pvIn)->dhpdev;
                PUMPD     pUMPD = pUMdhpdev->pUMPD;
                PFN       pfn = pUMPD->apfn[INDEX_DrvDisableSurface];
                
                pfn(pUMdhpdev->dhpdev);
            }
        break;

        case INDEX_DrvStartDoc:
            {
                PDRVSTARTDOCINPUT  pInput = (PDRVSTARTDOCINPUT)pvIn;
                PUMDHPDEV          pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                //
                // check to make sure we have a dhpdev in the surface
                // neither Unidrv or Pscript checks if EngAssociateSurface is
                // successful or not
                //
                if (pUMdhpdev)
                {
                    PUMPD              pUMPD = pUMdhpdev->pUMPD;
                    PFN                pfn = pUMPD->apfn[INDEX_DrvStartDoc];

                    *((BOOL *) pvOut) = (BOOL)pfn(pInput->pso, pInput->pwszDocName, pInput->dwJobId);
                }
                else
                    *(BOOL *)pvOut = FALSE;
            }
        break;

        case INDEX_DrvEndDoc:
           {
                PDRVENDDOCINPUT pInput = (PDRVENDDOCINPUT)pvIn;
                PUMDHPDEV       pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD           pUMPD = pUMdhpdev->pUMPD;
                PFN             pfn = pUMPD->apfn[INDEX_DrvEndDoc];
                
                *((BOOL *) pvOut) = (BOOL)pfn(pInput->pso, pInput->fl );
           }
        break;

        case INDEX_DrvStartPage:
            {
                PSURFOBJINPUT  pInput = (PSURFOBJINPUT)pvIn;
                PUMDHPDEV      pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD          pUMPD = pUMdhpdev->pUMPD;
                PFN            pfn = pUMPD->apfn[INDEX_DrvStartPage];
                
                *((BOOL *) pvOut) = (BOOL)pfn(pInput->pso);
            }
        break;

        case INDEX_DrvSendPage:
            {
                PSURFOBJINPUT  pInput = (PSURFOBJINPUT)pvIn;
                PUMDHPDEV      pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD          pUMPD = pUMdhpdev->pUMPD;
                PFN            pfn = pUMPD->apfn[INDEX_DrvSendPage];
                
                *((BOOL *) pvOut) = (BOOL)pfn(pInput->pso);
            }
        break;

        case INDEX_DrvEscape:
            {
                PDRVESCAPEINPUT pInput = (PDRVESCAPEINPUT) pvIn;
                PUMDHPDEV       pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD           pUMPD = pUMdhpdev->pUMPD;
                PFN             pfn = pUMPD->apfn[INDEX_DrvEscape];
                
                *((ULONG *) pvOut) = (ULONG) pfn(pInput->pso,
                                         pInput->iEsc,
                                         pInput->cjIn,
                                         pInput->pvIn,
                                         pInput->cjOut,
                                         pInput->pvOut);
            }
        break;

        case INDEX_DrvDrawEscape:
            {
                PDRVDRAWESCAPEINPUT pInput = (PDRVDRAWESCAPEINPUT) pvIn;
                PUMDHPDEV       pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD           pUMPD = pUMdhpdev->pUMPD;
                PFN             pfn = pUMPD->apfn[INDEX_DrvDrawEscape];
                
                *((ULONG *) pvOut) = (ULONG) pfn(pInput->pso,
                                         pInput->iEsc,
                                         pInput->pco,
                                         pInput->prcl,
                                         pInput->cjIn,
                                         pInput->pvIn);
            }
        break;

        case INDEX_DrvStartBanding:
            {
                PDRVBANDINGINPUT    pInput = (PDRVBANDINGINPUT)pvIn;
                PUMDHPDEV           pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD               pUMPD = pUMdhpdev->pUMPD;
                PFN                 pfn = pUMPD->apfn[INDEX_DrvStartBanding];
                
                *((BOOL *) pvOut) = (BOOL)pfn(pInput->pso, pInput->pptl);
            }
        break;

        case INDEX_DrvQueryPerBandInfo:
            {
                PDRVPERBANDINPUT    pInput = (PDRVPERBANDINPUT)pvIn;
                PUMDHPDEV           pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD               pUMPD = pUMdhpdev->pUMPD;
                PFN                 pfn = pUMPD->apfn[INDEX_DrvQueryPerBandInfo];
                
                *((BOOL *) pvOut) = (BOOL) pfn(pInput->pso, pInput->pbi);
            }
        break;


        case INDEX_DrvNextBand:
            {
                PDRVBANDINGINPUT    pInput = (PDRVBANDINGINPUT)pvIn;
                PUMDHPDEV           pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD               pUMPD = pUMdhpdev->pUMPD;
                PFN                 pfn = pUMPD->apfn[INDEX_DrvNextBand];
                
                *((BOOL *) pvOut) = (BOOL)pfn(pInput->pso, pInput->pptl);
            }
        break;

        case INDEX_DrvBitBlt:
            {
                PDRVBITBLTINPUT  pInput = (PDRVBITBLTINPUT)pvIn;
                PUMDHPDEV        pUMdhpdev = AdjustUMdhpdev(pInput->psoTrg);
                PUMPD            pUMPD = pUMdhpdev->pUMPD;
                PFN              pfn = pUMPD->apfn[INDEX_DrvBitBlt];

                *((BOOL *) pvOut) = (BOOL) pfn(pInput->psoTrg,
                                        pInput->psoSrc,
                                        pInput->psoMask,
                                        pInput->pco,
                                        pInput->pxlo,
                                        pInput->prclTrg,
                                        pInput->pptlSrc,
                                        pInput->pptlMask,
                                        pInput->pbo,
                                        pInput->pptlBrush,
                                        pInput->rop4);

                if (bWOW64 && pInput->pbo)
                {
                    NtGdiBRUSHOBJ_DeleteRbrush(pInput->pbo, NULL);
                }
            }
        break;

        case INDEX_DrvStretchBlt:
            {
                PDRVSTRETCHBLTINPUT  pInput = (PDRVSTRETCHBLTINPUT)pvIn;
                PUMDHPDEV            pUMdhpdev = AdjustUMdhpdev(pInput->psoTrg);
                PUMPD                pUMPD = pUMdhpdev->pUMPD;
                PFN                  pfn = pUMPD->apfn[INDEX_DrvStretchBlt];
                
                *((BOOL *) pvOut) = (BOOL) pfn (pInput->psoTrg,
                                         pInput->psoSrc,
                                         pInput->psoMask,
                                         pInput->pco,
                                         pInput->pxlo,
                                         pInput->pca,
                                         pInput->pptlHTOrg,
                                         pInput->prclTrg,
                                         pInput->prclSrc,
                                         pInput->pptlMask,
                                         pInput->iMode);
            }
        break;

        case INDEX_DrvStretchBltROP:
            {
                PDRVSTRETCHBLTINPUT  pInput = (PDRVSTRETCHBLTINPUT)pvIn;
                PUMDHPDEV            pUMdhpdev = AdjustUMdhpdev(pInput->psoTrg);
                PUMPD                pUMPD = pUMdhpdev->pUMPD;
                PFN                  pfn = pUMPD->apfn[INDEX_DrvStretchBltROP];

                *((BOOL *) pvOut) = (BOOL) pfn (pInput->psoTrg,
                                         pInput->psoSrc,
                                         pInput->psoMask,
                                         pInput->pco,
                                         pInput->pxlo,
                                         pInput->pca,
                                         pInput->pptlHTOrg,
                                         pInput->prclTrg,
                                         pInput->prclSrc,
                                         pInput->pptlMask,
                                         pInput->iMode,
                                         pInput->pbo,
                                         pInput->rop4);

                if (bWOW64 && pInput->pbo)
                {
                    NtGdiBRUSHOBJ_DeleteRbrush(pInput->pbo, NULL);
                }                
            }
        break;

        case INDEX_DrvPlgBlt:
           {
                PDRVPLGBLTINPUT      pInput = (PDRVPLGBLTINPUT)pvIn;
                PUMDHPDEV            pUMdhpdev = AdjustUMdhpdev(pInput->psoTrg);
                PUMPD                pUMPD = pUMdhpdev->pUMPD;
                PFN                  pfn = pUMPD->apfn[INDEX_DrvPlgBlt];
                
                *((BOOL *) pvOut) = (BOOL) pfn(pInput->psoTrg,
                                        pInput->psoSrc,
                                        pInput->psoMask,
                                        pInput->pco,
                                        pInput->pxlo,
                                        pInput->pca,
                                        pInput->pptlBrushOrg,
                                        pInput->pptfx,
                                        pInput->prcl,
                                        pInput->pptl,
                                        pInput->iMode);
           }
        break;

        case INDEX_DrvCopyBits:
            {
                PDRVCOPYBITSINPUT  pInput = (PDRVCOPYBITSINPUT) pvIn;
                PUMDHPDEV          pUMdhpdev;
                PUMPD              pUMPD;
                PFN                pfn;
                SURFOBJ           *pso;
                
                //
                // Special case when psoSrc is a device surface and
                // psoTrg is a bitmap surface. This is used by the engine
                // during simulation of certain drawing calls.
                //

                pso = (pInput->psoTrg->iType == STYPE_BITMAP &&
                       pInput->psoTrg->dhpdev == NULL) ?
                            pInput->psoSrc :
                            pInput->psoTrg;

                if (pso && (pUMdhpdev = AdjustUMdhpdev(pso)))
                {
                    pUMPD = pUMdhpdev->pUMPD;
                    pfn = pUMPD->apfn[INDEX_DrvCopyBits];

                    *((BOOL *) pvOut) = (BOOL) pfn(pInput->psoTrg,
                                            pInput->psoSrc,
                                            pInput->pco,
                                            pInput->pxlo,
                                            pInput->prclTrg,
                                            pInput->pptlSrc);
                }
                else
                {
                    *((BOOL *) pvOut) = FALSE;
                }
            }
        break;

        case INDEX_DrvRealizeBrush:
           {
                PDRVREALIZEBRUSHINPUT  pInput = (PDRVREALIZEBRUSHINPUT)pvIn;
                PUMDHPDEV              pUMdhpdev = AdjustUMdhpdev(pInput->psoTrg);
                PUMPD                  pUMPD = pUMdhpdev->pUMPD;
                PFN                    pfn = pUMPD->apfn[INDEX_DrvRealizeBrush];

                *((BOOL *) pvOut) = (BOOL) pfn(pInput->pbo,
                                        pInput->psoTrg,
                                        pInput->psoPat,
                                        pInput->psoMsk,
                                        pInput->pxlo,
                                        pInput->iHatch);
           }
        break;

        case INDEX_DrvLineTo:
           {
                PDRVLINETOINPUT pInput = (PDRVLINETOINPUT)pvIn;
                PUMDHPDEV       pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD           pUMPD = pUMdhpdev->pUMPD;
                PFN             pfn = pUMPD->apfn[INDEX_DrvLineTo];

                *((BOOL *) pvOut) = (BOOL) pfn (pInput->pso,
                                         pInput->pco,
                                         pInput->pbo,
                                         pInput->x1,
                                         pInput->y1,
                                         pInput->x2,
                                         pInput->y2,
                                         pInput->prclBounds,
                                         pInput->mix);
                
                if (bWOW64 && pInput->pbo)
                {
                    NtGdiBRUSHOBJ_DeleteRbrush(pInput->pbo, NULL);
                }
           }
        break;

        case INDEX_DrvStrokePath:
           {
                PSTROKEANDFILLINPUT pInput = (PSTROKEANDFILLINPUT)pvIn;
                PUMDHPDEV           pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD               pUMPD = pUMdhpdev->pUMPD;
                PFN                 pfn = pUMPD->apfn[INDEX_DrvStrokePath];

                *((BOOL *) pvOut) = (BOOL) pfn(pInput->pso,
                                        pInput->ppo,
                                        pInput->pco,
                                        pInput->pxo,
                                        pInput->pbo,
                                        pInput->pptlBrushOrg,
                                        pInput->plineattrs,
                                        pInput->mix);

                if (bWOW64 && pInput->pbo)
                {
                    NtGdiBRUSHOBJ_DeleteRbrush(pInput->pbo, NULL);
                }
           }
        break;

        case INDEX_DrvFillPath:
           {
                PSTROKEANDFILLINPUT pInput = (PSTROKEANDFILLINPUT)pvIn;
                PUMDHPDEV           pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD               pUMPD = pUMdhpdev->pUMPD;
                PFN                 pfn = pUMPD->apfn[INDEX_DrvFillPath];

                *((BOOL *) pvOut) = (BOOL) pfn(pInput->pso,
                                        pInput->ppo,
                                        pInput->pco,
                                        pInput->pbo,
                                        pInput->pptlBrushOrg,
                                        pInput->mix,
                                        pInput->flOptions);

                if (bWOW64 && pInput->pbo)
                {
                    NtGdiBRUSHOBJ_DeleteRbrush(pInput->pbo, NULL);
                }
           }
        break;

        case INDEX_DrvStrokeAndFillPath:
          {
                PSTROKEANDFILLINPUT pInput = (PSTROKEANDFILLINPUT)pvIn;
                PUMDHPDEV           pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD               pUMPD = pUMdhpdev->pUMPD;
                PFN                 pfn = pUMPD->apfn[INDEX_DrvStrokeAndFillPath];

                *((BOOL *) pvOut) = (BOOL) pfn(pInput->pso,
                                        pInput->ppo,
                                        pInput->pco,
                                        pInput->pxo,
                                        pInput->pbo,
                                        pInput->plineattrs,
                                        pInput->pboFill,
                                        pInput->pptlBrushOrg,
                                        pInput->mix,
                                        pInput->flOptions);

                if (bWOW64 && (pInput->pbo || pInput->pboFill))
                {
                    NtGdiBRUSHOBJ_DeleteRbrush(pInput->pbo, pInput->pboFill);
                }
          }
        break;

        case INDEX_DrvPaint:
          {
                PSTROKEANDFILLINPUT pInput = (PSTROKEANDFILLINPUT)pvIn;
                PUMDHPDEV           pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD               pUMPD = pUMdhpdev->pUMPD;
                PFN                 pfn = pUMPD->apfn[INDEX_DrvPaint];

                *((BOOL *) pvOut) = (BOOL) pfn(pInput->pso,
                                        pInput->pco,
                                        pInput->pbo,
                                        pInput->pptlBrushOrg,
                                        pInput->mix);

                if (bWOW64 && pInput->pbo)
                {
                    NtGdiBRUSHOBJ_DeleteRbrush(pInput->pbo, NULL);
                }
          }
        break;

        case INDEX_DrvGradientFill:
          {
                PGRADIENTINPUT      pInput = (PGRADIENTINPUT)pvIn;
                PUMDHPDEV           pUMdhpdev = AdjustUMdhpdev(pInput->psoTrg);
                PUMPD               pUMPD = pUMdhpdev->pUMPD;
                PFN                 pfn = pUMPD->apfn[INDEX_DrvGradientFill];

                *((BOOL *) pvOut) = (BOOL) pfn(pInput->psoTrg,
                                        pInput->pco,
                                        pInput->pxlo,
                                        pInput->pVertex,
                                        pInput->nVertex,
                                        pInput->pMesh,
                                        pInput->nMesh,
                                        pInput->prclExtents,
                                        pInput->pptlDitherOrg,
                                        pInput->ulMode);
          }
        break;

        case INDEX_DrvAlphaBlend:
          {
                PALPHAINPUT      pInput = (PALPHAINPUT)pvIn;
                PUMDHPDEV        pUMdhpdev = AdjustUMdhpdev(pInput->psoTrg);
                PUMPD            pUMPD = pUMdhpdev->pUMPD;
                PFN              pfn = pUMPD->apfn[INDEX_DrvAlphaBlend];
                
                *((BOOL *) pvOut) = (BOOL) pfn(pInput->psoTrg,
                                        pInput->psoSrc,
                                        pInput->pco,
                                        pInput->pxlo,
                                        pInput->prclDest,
                                        pInput->prclSrc,
                                        pInput->pBlendObj);
          }
        break;

        case INDEX_DrvTransparentBlt:
            {
                PTRANSPARENTINPUT      pInput = (PTRANSPARENTINPUT)pvIn;
                PUMDHPDEV              pUMdhpdev = AdjustUMdhpdev(pInput->psoTrg);
                PUMPD                  pUMPD = pUMdhpdev->pUMPD;
                PFN                    pfn = pUMPD->apfn[INDEX_DrvTransparentBlt];
                
                *((BOOL *) pvOut) = (BOOL) pfn(pInput->psoTrg,
                                        pInput->psoSrc,
                                        pInput->pco,
                                        pInput->pxlo,
                                        pInput->prclDst,
                                        pInput->prclSrc,
                                        pInput->TransColor,
                                        pInput->ulReserved);
            }
            break;

        case INDEX_DrvTextOut:
            {
                PTEXTOUTINPUT    pInput = (PTEXTOUTINPUT)pvIn;
                PUMDHPDEV        pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD            pUMPD = pUMdhpdev->pUMPD;
                PFN              pfn = pUMPD->apfn[INDEX_DrvTextOut];

                *((BOOL *) pvOut) = (BOOL) pfn(pInput->pso,
                                        pInput->pstro,
                                        pInput->pfo,
                                        pInput->pco,
                                        pInput->prclExtra,
                                        pInput->prclOpaque,
                                        pInput->pboFore,
                                        pInput->pboOpaque,
                                        pInput->pptlOrg,
                                        pInput->mix);

                if (bWOW64 && (pInput->pboFore || pInput->pboOpaque))
                {
                    NtGdiBRUSHOBJ_DeleteRbrush(pInput->pboFore, pInput->pboOpaque);
                }
            }
            break;

        case INDEX_DrvQueryFont:
            {
                PQUERYFONTINPUT    pInput = (PQUERYFONTINPUT)pvIn;
                PUMDHPDEV          pUMdhpdev = (PUMDHPDEV)(pInput->dhpdev);
                PUMPD              pUMPD = pUMdhpdev->pUMPD;
                PFN                pfn = pUMPD->apfn[INDEX_DrvQueryFont];
                
                *((PIFIMETRICS *) pvOut) = (PIFIMETRICS) pfn(
                                                pUMdhpdev->dhpdev,
                                                pInput->iFile,
                                                pInput->iFace,
                                                pInput->pid);

                if (pInput->iFace && *((PIFIMETRICS*)pvOut) && pInput->pv)
                {
                    ASSERTGDI(pInput->cjMaxData >= (*(PIFIMETRICS*)pvOut)->cjThis, "gdi32!GdiPrinterThunk: not enough buffer for ifimetrics\n");
                    if (pInput->cjMaxData >= (*(PIFIMETRICS*)pvOut)->cjThis) 
                    {
                        RtlCopyMemory(pInput->pv, (PBYTE)(*(PIFIMETRICS*)pvOut), (*(PIFIMETRICS*)pvOut)->cjThis);
                    }
                    else
                    {
                        iRet = -1;
                        WARNING(("Not enough buffer for ifimetrics  cjMaxData: 0x%lx  cjSize: 0x%lx pInput.pv %lp pvOut %lp\n",
                                 pInput->cjMaxData, (*(PIFIMETRICS*)pvOut)->cjThis, pInput->pv, pvOut));
                        pInput->cjMaxData = 0;
                    }
                }
            }
        break;

        case INDEX_DrvQueryFontTree:
            {
                PQUERYFONTINPUT    pInput = (PQUERYFONTINPUT)pvIn;
                PUMDHPDEV          pUMdhpdev = (PUMDHPDEV)(pInput->dhpdev);
                PUMPD              pUMPD = pUMdhpdev->pUMPD;
                PFN                pfn = pUMPD->apfn[INDEX_DrvQueryFontTree];
                ULONG              cjSize = 0;
                FD_GLYPHSET*       pfdg;

                *((PVOID *) pvOut) = (PVOID) pfn (pUMdhpdev->dhpdev,
                                                  pInput->iFile,
                                                  pInput->iFace,
                                                  pInput->iMode,
                                                  pInput->pid);

                if (pInput->iMode == QFT_GLYPHSET && *((FD_GLYPHSET**)pvOut) && pInput->pv)
                {
                    pfdg = *((FD_GLYPHSET**)pvOut);
                    cjSize = offsetof(FD_GLYPHSET, awcrun) + pfdg->cRuns * sizeof(WCRUN) + pfdg->cGlyphsSupported * sizeof(HGLYPH);

                    ASSERTGDI(pInput->cjMaxData >= cjSize, "gdi32!GdiPrinterThunk: not enough buffer for glyphset\n");

                    if ((pInput->cjMaxData < cjSize) || 
                        !GdiCopyFD_GLYPHSET((FD_GLYPHSET*)pInput->pv, pfdg, cjSize))
                    {
                            WARNING("GDI32: Not enough bufer or error copying FD_GLYPHSET\n");
                            pInput->cjMaxData = 0;
                            iRet = -1;
                    }
                }
                else if (pInput->iMode == QFT_KERNPAIRS && *(FD_KERNINGPAIR **)pvOut && pInput->pv) 
                {
                    FD_KERNINGPAIR *pkpEnd = *(FD_KERNINGPAIR **)pvOut;
                    
                    while ((pkpEnd->wcFirst) || (pkpEnd->wcSecond) || (pkpEnd->fwdKern))
                    {
                        pkpEnd += 1;
                        cjSize++;
                    }

                    cjSize = (cjSize + 1) * sizeof(FD_KERNINGPAIR);

                    ASSERTGDI(pInput->cjMaxData >= cjSize, "gdi32!GdiPrinterThunk: not enough buffer for Kerningpairs\n");
                    if (pInput->cjMaxData >= cjSize) 
                    {
                        RtlCopyMemory(pInput->pv, (PBYTE)(*(FD_KERNINGPAIR **)pvOut), cjSize);
                    }
                    else
                    {
                        WARNING(("Not enough buffer forkerningpair  cjMaxData: 0x%lx  cjSize: 0x%lx pInput.pv %lp pvOut %lp\n",
                                 pInput->cjMaxData, cjSize, pInput->pv, pvOut));
                        pInput->cjMaxData = 0;
                        iRet = -1;
                    }
                }

            }
        break;


        case INDEX_DrvQueryFontData:
            {
                PQUERYFONTDATAINPUT    pInput = (PQUERYFONTDATAINPUT)pvIn;
                PUMDHPDEV              pUMdhpdev = (PUMDHPDEV)(pInput->dhpdev);
                PUMPD                  pUMPD = pUMdhpdev->pUMPD;
                PFN                    pfn = pUMPD->apfn[INDEX_DrvQueryFontData];
                
                *((ULONG *) pvOut) = (ULONG)pfn (pUMdhpdev->dhpdev,
                                          pInput->pfo,
                                          pInput->iMode,
                                          pInput->hg,
                                          pInput->pgd,
                                          pInput->pv,
                                          pInput->cjSize);
            }
            break;

        case INDEX_DrvQueryAdvanceWidths:
            {
                PQUERYADVWIDTHSINPUT   pInput = (PQUERYADVWIDTHSINPUT)pvIn;
                PUMDHPDEV              pUMdhpdev = (PUMDHPDEV)(pInput->dhpdev);
                PUMPD                  pUMPD = pUMdhpdev->pUMPD;
                PFN                    pfn = pUMPD->apfn[INDEX_DrvQueryAdvanceWidths];
                
                *((BOOL *) pvOut) = (BOOL)pfn (pUMdhpdev->dhpdev,
                                         pInput->pfo,
                                         pInput->iMode,
                                         pInput->phg,
                                         pInput->pvWidths,
                                         pInput->cGlyphs);
            }
            break;

       case INDEX_DrvGetGlyphMode:
            {
                PQUERYFONTDATAINPUT    pInput = (PQUERYFONTDATAINPUT)pvIn;
                PUMDHPDEV              pUMdhpdev = (PUMDHPDEV)(pInput->dhpdev);
                PUMPD                  pUMPD = pUMdhpdev->pUMPD;
                PFN                    pfn = pUMPD->apfn[INDEX_DrvGetGlyphMode];
                
                *((ULONG *) pvOut) = (ULONG) pfn (pUMdhpdev->dhpdev, pInput->pfo);
            }
            break;

       case INDEX_DrvFontManagement:
            {
                PFONTMANAGEMENTINPUT   pInput = (PFONTMANAGEMENTINPUT)pvIn;
                PUMDHPDEV              pUMdhpdev;
                PUMPD                  pUMPD;
                PFN                    pfn;
                
                if (pInput->iMode == QUERYESCSUPPORT)
                    pUMdhpdev = (PUMDHPDEV) pInput->dhpdev;
                else
                    pUMdhpdev = AdjustUMdhpdev(pInput->pso);

                pUMPD = pUMdhpdev->pUMPD;
                pfn = pUMPD->apfn[INDEX_DrvFontManagement];

                *((ULONG *) pvOut) = (ULONG)pfn(pInput->pso,
                                         pInput->pfo,
                                         pInput->iMode,
                                         pInput->cjIn,
                                         pInput->pvIn,
                                         pInput->cjOut,
                                         pInput->pvOut);
           }
           break;

        case INDEX_DrvDitherColor:
             {
                PDRVDITHERCOLORINPUT pInput = (PDRVDITHERCOLORINPUT)pvIn;
                PUMDHPDEV pUMdhpdev = (PUMDHPDEV)pInput->dhpdev;
                PUMPD     pUMPD = pUMdhpdev->pUMPD;
                PFN       pfn = pUMPD->apfn[INDEX_DrvDitherColor];
                
                *((ULONG *) pvOut) = (ULONG)pfn(pUMdhpdev->dhpdev,
                                         pInput->iMode,
                                         pInput->rgb,
                                         pInput->pul);
             }
        break;

        case INDEX_DrvDeleteDeviceBitmap:
            {
                PDRVDELETEDEVBITMAP   pInput = (PDRVDELETEDEVBITMAP) pvIn;
                PUMDHPDEV             pUMdhpdev = (PUMDHPDEV) pInput->dhpdev;
                PUMPD                 pUMPD = pUMdhpdev->pUMPD;
                PFN                   pfn = pUMPD->apfn[INDEX_DrvDeleteDeviceBitmap];
                
                pfn(pUMdhpdev->dhpdev, pInput->dhsurf);
            }
        break;

        case INDEX_DrvIcmDeleteColorTransform:
            {
                PDRVICMDELETECOLOR    pInput = (PDRVICMDELETECOLOR)pvIn;
                PUMDHPDEV             pUMdhpdev = (PUMDHPDEV) pInput->dhpdev;
                PUMPD                 pUMPD = pUMdhpdev->pUMPD;
                PFN                   pfn = pUMPD->apfn[INDEX_DrvIcmDeleteColorTransform];
                
                *((BOOL *) pvOut) = (BOOL)pfn(pUMdhpdev->dhpdev, pInput->hcmXform);
            }
        break;

        case INDEX_DrvIcmCreateColorTransform:
            {
                PDRVICMCREATECOLORINPUT    pInput = (PDRVICMCREATECOLORINPUT) pvIn;
                PUMDHPDEV             pUMdhpdev = (PUMDHPDEV) pInput->dhpdev;
                PUMPD                 pUMPD = pUMdhpdev->pUMPD;
                PFN                   pfn = pUMPD->apfn[INDEX_DrvIcmCreateColorTransform];
                
                *((HANDLE *) pvOut) = (HANDLE)pfn(pUMdhpdev->dhpdev,
                                          pInput->pLogColorSpace,
                                          pInput->pvSourceProfile,
                                          pInput->cjSourceProfile,
                                          pInput->pvDestProfile,
                                          pInput->cjDestProfile,
                                          pInput->pvTargetProfile,
                                          pInput->cjTargetProfile,
                                          pInput->dwReserved);
            }
        break;

        case INDEX_DrvIcmCheckBitmapBits:
            {
                PDRVICMCHECKBITMAPINPUT   pInput = (PDRVICMCHECKBITMAPINPUT) pvIn;
                PUMDHPDEV                 pUMdhpdev = (PUMDHPDEV) pInput->dhpdev;
                PUMPD                     pUMPD = pUMdhpdev->pUMPD;
                PFN                       pfn = pUMPD->apfn[INDEX_DrvIcmCheckBitmapBits];
                
                pfn(pUMdhpdev->dhpdev,
                    pInput->hColorTransform,
                    pInput->pso,
                    pInput->paResults);
            }
        break;

        case INDEX_DrvQueryDeviceSupport:
            {
                PDRVQUERYDEVICEINPUT pInput = (PDRVQUERYDEVICEINPUT) pvIn;
                PUMDHPDEV            pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD                pUMPD = pUMdhpdev->pUMPD;
                PFN                  pfn = pUMPD->apfn[INDEX_DrvQueryDeviceSupport];
                
                *((ULONG *) pvOut) = (ULONG) pfn(pInput->pso,
                                         pInput->pxlo,
                                         pInput->pxo,
                                         pInput->iType,
                                         pInput->cjIn,
                                         pInput->pvIn,
                                         pInput->cjOut,
                                         pInput->pvOut);
            }
        break;

        case INDEX_UMPDAllocUserMem:
            {
                PUMPDALLOCUSERMEMINPUT pInput = (PUMPDALLOCUSERMEMINPUT) pvIn;

                ASSERTGDI(bWOW64, "Calling INDEX_UMPDAllocUserMem during NONE wow64 printing\n");

                *((KERNEL_PVOID*)pvOut) = UMPDAllocUserMem(pInput->cjSize);
            }
        break;

        case INDEX_UMPDCopyMemory:
            {
                PUMPDCOPYMEMINPUT pInput = (PUMPDCOPYMEMINPUT) pvIn;
            
                ASSERTGDI(bWOW64, "Calling INDEX_UMPDCopyMemory during NONE wow64 printing\n");
            
                *((KERNEL_PVOID*)pvOut) = UMPDCopyMemory(pInput->pvSrc,
                                                         pInput->pvDest,
                                                         pInput->cjSize);
            }
        break;

        case INDEX_UMPDFreeMemory:
            {
                PUMPDFREEMEMINPUT  pInput = (PUMPDFREEMEMINPUT) pvIn;

                ASSERTGDI(bWOW64, "Calling INDEX_UMPDFreeMemory during NONE wow64 printing\n");

                *((BOOL*)pvOut) = UMPDFreeMemory(pInput->pvTrg,
                                                 pInput->pvSrc,
                                                 pInput->pvMsk);
            }
        break;

        case  INDEX_UMPDEngFreeUserMem:
            {
                PUMPDFREEMEMINPUT   pInput = (PUMPDFREEMEMINPUT) pvIn;

                if (bWOW64)
                {
                    *((BOOL*)pvOut) = NtGdiUMPDEngFreeUserMem(&pInput->pvTrg);
                }
            }
        break;

      default:

         WARNING ("Drv call is not supported\n");
         iRet = GPT_ERROR;
         break;
    }

    if (bSetPUMPD)
    {
        NtGdiSetPUMPDOBJ(hSaved, FALSE, &pumpdthdr->humpd, NULL);
    }

    return (iRet);
}

#endif // !_GDIPLUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\umpdeng.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    umpdeng.c

Abstract:

    User-mode printer driver stubs for Eng callback functions

Environment:

    Windows NT 5.0

Revision History:

    07/23/97 -lingyunw-
        Created it.

   10/28/97 -davidx-
        Combine umpdeng.c and ddiglue.c into a single file.

   10/28/97 -lingyunw-
        Move straight Eng to NtGdiEng calls etc to gdi32.def.

--*/

#include "precomp.h"
#pragma hdrstop
#include "winddi.h"

#if !defined(_GDIPLUS_)

//
// Functions to get information about driver DLLs
//
// anyway, before we return back from DrvEnablePDEV, our
// pdev->dhpdev points to pUMPD, only after returning, we
// ppdev->dhpdev points to pUMdhpdev
//

LPWSTR
EngGetPrinterDataFileName(
    HDEV hdev
    )

{
    PUMPD pUMPD;

    if ((pUMPD = (PUMPD) NtGdiGetDhpdev(hdev)) == NULL)
        return NULL;

    if (pUMPD->dwSignature != UMPD_SIGNATURE)
        pUMPD = ((PUMDHPDEV) pUMPD)->pUMPD;

    return pUMPD->pDriverInfo2->pDataFile;
}


LPWSTR
EngGetDriverName(
    HDEV hdev
    )
{
    PUMPD pUMPD;

    if ((pUMPD = (PUMPD) NtGdiGetDhpdev(hdev)) == NULL)
        return NULL;

    if (pUMPD->dwSignature != UMPD_SIGNATURE)
        pUMPD = ((PUMDHPDEV) pUMPD)->pUMPD;

    return pUMPD->pDriverInfo2->pDriverPath;
}

PULONG APIENTRY XLATEOBJ_piVector(
    IN XLATEOBJ  *pxlo
   )
{
    return ((ULONG *)pxlo->pulXlate);
}

//
// Simulate kernel-mode file mapping functions
//

HANDLE
EngLoadModule(
    LPWSTR pwsz
    )

{
    return LoadLibraryExW(pwsz, NULL, LOAD_LIBRARY_AS_DATAFILE);
}


PVOID
EngFindResource(
    HANDLE h,
    INT    iName,
    INT    iType,
    PULONG pulSize
    )

{
    HRSRC   hrsrc;
    HGLOBAL hmem;
    PVOID   p = NULL;
    DWORD   size = 0;

    hrsrc = FindResourceW(h, MAKEINTRESOURCEW(iName), MAKEINTRESOURCEW(iType));

    if (hrsrc != NULL &&
        (size = SizeofResource(h, hrsrc)) != 0 &&
        (hmem = LoadResource(h, hrsrc)) != NULL)
    {
        p = LockResource(hmem);
    }

    *pulSize = size;
    return p;
}

VOID
EngFreeModule(
    HANDLE h
    )

{
    FreeLibrary(h);
}


//
// Unicode <=> MultiByte conversion functions
//

VOID
EngMultiByteToUnicodeN(
    PWSTR UnicodeString,
    ULONG MaxBytesInUnicodeString,
    PULONG BytesInUnicodeString,
    PCHAR MultiByteString,
    ULONG BytesInMultiByteString
    )

{

    RtlMultiByteToUnicodeN(UnicodeString,
                           MaxBytesInUnicodeString,
                           BytesInUnicodeString,
                           MultiByteString,
                           BytesInMultiByteString);
}

VOID
EngUnicodeToMultiByteN(
    PCHAR MultiByteString,
    ULONG MaxBytesInMultiByteString,
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    )

{
    RtlUnicodeToMultiByteN(MultiByteString,
                           MaxBytesInMultiByteString,
                           BytesInMultiByteString,
                           UnicodeString,
                           BytesInUnicodeString);
}


INT
EngMultiByteToWideChar(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString
    )

{
    return MultiByteToWideChar(CodePage,
                               0,
                               MultiByteString,
                               BytesInMultiByteString,
                               WideCharString,
                               BytesInWideCharString / sizeof(WCHAR));
}


INT
EngWideCharToMultiByte(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString
    )

{
    return WideCharToMultiByte(CodePage,
                               0,
                               WideCharString,
                               BytesInWideCharString / sizeof(WCHAR),
                               MultiByteString,
                               BytesInMultiByteString,
                               NULL,
                               NULL);
}


VOID
EngGetCurrentCodePage(
    PUSHORT OemCodePage,
    PUSHORT AnsiCodePage
    )

{
    *AnsiCodePage = (USHORT) GetACP();
    *OemCodePage =  (USHORT) GetOEMCP();
}


//
// Copy FD_GLYPHSET information
//
// IMPORTANT!!
//  We assume FD_GLYPHSET information is stored in one contiguous block
//  of memory and FD_GLYPHSET.cjThis field is the size of the entire block.
//  HGLYPH arrays in each WCRUN are part of the block, placed just after
//  FD_GLYPHSET structure itself.
//

BOOL
CopyFD_GLYPHSET(
    FD_GLYPHSET *dst,
    FD_GLYPHSET *src,
    ULONG       cjSize
    )

{
    ULONG   index, offset;

    RtlCopyMemory(dst, src, cjSize);

    //
    // Patch up memory pointers in each WCRUN structure
    //

    for (index=0; index < src->cRuns; index++)
    {
        if (src->awcrun[index].phg != NULL)
        {
            offset = (ULONG) ((PBYTE) src->awcrun[index].phg - (PBYTE) src);

            if (offset >= cjSize)
            {
                WARNING("GreCopyFD_GLYPHSET failed.\n");
                return FALSE;
            }

            dst->awcrun[index].phg = (HGLYPH*) ((PBYTE) dst + offset);
        }
    }

    return TRUE;
}

FD_GLYPHSET*
EngComputeGlyphSet(
    INT nCodePage,
    INT nFirstChar,
    INT cChars
    )

{
    FD_GLYPHSET *pGlyphSet, *pGlyphSetTmp = NULL;
    ULONG       cjSize;

    //
    // The driver will always call EngFreeMem after done using pGlyphSet
    // We have to provide them a user mode pointer here
    //

    if ((pGlyphSet = NtGdiEngComputeGlyphSet(nCodePage, nFirstChar, cChars)) &&
        (cjSize = pGlyphSet->cjThis) &&
        (pGlyphSetTmp = (FD_GLYPHSET *) GlobalAlloc(GMEM_FIXED, cjSize)))
    {
        if (!CopyFD_GLYPHSET(pGlyphSetTmp, pGlyphSet, cjSize))
        {
            GlobalFree((HGLOBAL) pGlyphSetTmp);
            pGlyphSetTmp = NULL;
        }
    }

    //
    // the user memory allocated from the kernel (pGlyphSet)
    // will be gone after the call is finished
    //

    return (pGlyphSetTmp);
}

//
// Query current local time
//

VOID
EngQueryLocalTime(
    PENG_TIME_FIELDS    ptf
    )

{
    SYSTEMTIME  localtime;

    GetLocalTime(&localtime);

    ptf->usYear         = localtime.wYear;
    ptf->usMonth        = localtime.wMonth;
    ptf->usDay          = localtime.wDay;
    ptf->usHour         = localtime.wHour;
    ptf->usMinute       = localtime.wMinute;
    ptf->usSecond       = localtime.wSecond;
    ptf->usMilliseconds = localtime.wMilliseconds;
    ptf->usWeekday      = localtime.wDayOfWeek;
}


//
// Simulate Eng-semaphore functions
//

HSEMAPHORE
EngCreateSemaphore(
    VOID
    )

{
    LPCRITICAL_SECTION pcs;

    if (pcs = (LPCRITICAL_SECTION) LOCALALLOC(sizeof(CRITICAL_SECTION)))
    {
        InitializeCriticalSection(pcs);
    }
    else
    {
        WARNING("Memory allocation failed.\n");
    }

    return (HSEMAPHORE) pcs;
}


VOID
EngAcquireSemaphore(
    HSEMAPHORE hsem
    )

{
    EnterCriticalSection((LPCRITICAL_SECTION) hsem);
}


VOID
EngReleaseSemaphore(
    HSEMAPHORE hsem
    )

{
    LeaveCriticalSection((LPCRITICAL_SECTION) hsem);
}


VOID
EngDeleteSemaphore(
    HSEMAPHORE hsem
    )

{
    LPCRITICAL_SECTION pcs = (LPCRITICAL_SECTION) hsem;

    if (pcs != NULL)
    {
        DeleteCriticalSection(pcs);
        LOCALFREE(pcs);
    }
}

BOOL APIENTRY
EngQueryEMFInfo(
    HDEV               hdev,
    EMFINFO           *pEMFInfo)
{
   WARNING("EngQueryEMFInfo no longer supported\n");
   return FALSE;
}

#endif // !_GDIPLUS_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\dciman\dllinit.c ===
/******************************Module*Header*******************************\
* Module Name: dllinit.c                                                   *
*                                                                          *
* Contains the DCI library initialization routines.                        *
*                                                                          *
* Created: 23-Sep-1994                                                     *
* Author: Andre Vachon [andreva]                                           *
*                                                                          *
* Copyright (c) 1990,1994 Microsoft Corporation                            *
\**************************************************************************/

#include <windows.h>

extern CRITICAL_SECTION gcsWinWatchLock;

/******************************Public*Routine******************************\
* DciDllInitialize                                                         *
*                                                                          *
* This is the init procedure for DCIMAN32.dll, which is called each time a *
* new process links to it.                                                 *
*                                                                          *
\**************************************************************************/

BOOLEAN DciDllInitialize(
    PVOID pvDllHandle,
    ULONG ulReason,
    PCONTEXT pcontext)
{
    //
    // Suppress compiler warnings.
    //

    pvDllHandle;
    pcontext;

    //
    // Do appropriate attach/detach processing.
    //

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:

        //
        // On process attach, initialize the global semaphore.
        //

        InitializeCriticalSection(&gcsWinWatchLock);
        break;

    case DLL_PROCESS_DETACH:

        //
        // On process detach, initialize the global semaphore.
        //

        DeleteCriticalSection(&gcsWinWatchLock);
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

        //
        // Nothing to do yet for thread attach/detach.
        //

        break;

    default:
        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\debug\gdiview\debug.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Abstract:
*
*   Debugging routines
*
* Revision History:
*
*   09/07/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include <windows.h>
#include <stdio.h>

#include "debug.h"

#if DBG

// _debugLevel is used to control the amount/severity of debugging messages
// that are actually output.

INT _debugLevel = DBG_VERBOSE;

/**************************************************************************\
*
* Function Description:
*
*   Removes the path portion of a pathname
*
* Arguments:
*
*   [IN] str - pathname to strip
*
* Return Value:
*
*   A pointer to the filename portion of the pathname
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

const CHAR*
StripDirPrefix(
    const CHAR* str
    )

{
    const CHAR* p;

    p = strrchr(str, '\\');
    return p ? p+1 : str;
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs to the debugger
*
* Arguments:
*
*   [IN] format - printf-like format string and variable arguments
*
* Return Value:
*
*   Zero. This is to conform to NTDLL's definition of DbgPrint.
*
* Notes:
*
*   There will be no output if a debugger is not connected.
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

ULONG _cdecl
DbgPrint(
    const CHAR* format,
    ...
    )

{
    va_list arglist;
    va_start(arglist, format);
    
    const int BUFSIZE=1024;
    
    char buf[BUFSIZE];
    
    _vsnprintf(buf, BUFSIZE, format, arglist);
    buf[BUFSIZE-1]=0;
        
    OutputDebugStringA(buf);
    
    va_end(arglist);
    return 0;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\wow6432\i386\cmpexch.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) 1989-1999  Microsoft Corporation
;
; Module Name:
;
;    cmpexch.asm
;
; Abstract:
;
;    This module implements InterlockedCompareExchangeKernelPointer.
;
; Author:
;
;    mzoran  1-Jan-99
;
; Environment:
;
;    User-mode.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING   

;++
;
; KERNEL_PVOID
; InterlockedCompareExchangeKernelPointer (
;    IN OUT KERNEL_PVOID *Destination,
;    IN KERNEL_PVOID Exchange,
;    IN KERNEL_PVOID Comperand,
;    )
;
; Routine Description:
;
; 	Performs an atomin comparison of the value pointed to by Destination and Compare.
;  	The function exchanges the values based on the comparison.
;
;
; Arguments:
;
;    (esp+4) Destination - Supplies a pointer to the destination variable.
;
;    (esp+8) Exchange - Supplies the exchange value.
;
;    (esp+16) Comperand - Supplies the comperand value.
;
;
; Return Value:
;
;    The current destination value is returned as the function value.
;
;--

cPublicProc _InterlockedCompareExchangeKernelPointer ,5
cPublicFpo 5,2
      
        push ebp                        ; save nonvolatile registers
        push ebx                 

        mov     ebp, [esp] + 12         ; get destination address
        mov     ebx, [esp] + 16         ; get exchange value
        mov     ecx, [esp] + 20         ;
        mov     eax, [esp] + 24         ; get comperand value
        mov     edx, [esp] + 28         ;       

.586
        lock cmpxchg8b qword ptr [ebp]  ; compare and exchange
.386

;
; Restore nonvolatile registers and return result in edx:eax.
;

        pop     ebx                     ; restore nonvolatile registers
        pop     ebp        
 
        stdRET    _InterlockedCompareExchangeKernelPointer

stdENDP _InterlockedCompareExchangeKernelPointer

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\dciman\dciman.c ===
/******************************Module*Header*******************************\
* Module Name: dciman.c                                                    *
*                                                                          *
* Client side stubs for DCIMAN functions.                                  *
*                                                                          *
* Created: 07-Sep-1994                                                     *
* Author: Andre Vachon [andreva]                                           *
*                                                                          *
* Copyright (c) 1994-1998 Microsoft Corporation                            *
\**************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <windows.h>
#include <winspool.h>
#include <wingdip.h>
#include <ddrawp.h>
#include <winddi.h>
#include "dciddi.h"
#include "dciman.h"
#include <ddrawi.h>
#include <ddrawgdi.h>

#if DBG

#define RIP(x) {DbgPrint(x); DbgBreakPoint();}
#define ASSERTGDI(x,y) if(!(x)) RIP(y)
#define WARNING(x) {DbgPrint(x);}

#else

#define ASSERTGDI(x,y)
#define WARNING(x)

#endif

typedef struct _WINWATCH *PWINWATCH;

typedef struct _WINWATCH {

    PWINWATCH         pWinWatchNext;
    HWND              hwnd;
    BOOL              changed;
    ULONG             lprgndataSize;
    LPRGNDATA         lprgndata;

} WINWATCH, *PWINWATCH;

//
// The following structure incorporates the DirectDraw structures required
// to identify a surface.  It is allocated before the start of the
// DCISURFACEINFO structure.
//

typedef struct _DCIMAN_SURF
{
    BOOL                     SurfaceLost;       // True if the surface can no
                                                //   longer be accessed because
                                                //   a mode change occured
    DDRAWI_DIRECTDRAW_GBL    DirectDrawGlobal;  // Identifies device
    DDRAWI_DDRAWSURFACE_GBL  SurfaceGlobal;     // Identifies surface
    DDRAWI_DDRAWSURFACE_LCL  SurfaceLocal;      // Identifies surface
    DDHAL_DDCALLBACKS        DDCallbacks;       // Contains address of CreateSurface
                                                //   call for BeginAccess
    DDHAL_DDSURFACECALLBACKS DDSurfaceCallbacks;// Contains addresses of Lock, Unlock,
                                                //   and DestroySurface calls for
                                                //   BeginAccess and EndAccess
} DCIMAN_SURF, *PDCIMAN_SURF;

//
// We maintain a linked list of all winwatch's so that we can notify their
// owners whenever we notice that the clippping has changed.  The list may
// be accessed only while holding the gcsWinWatchLock critical section.
//

CRITICAL_SECTION gcsWinWatchLock;

PWINWATCH gpWinWatchList = NULL;

/******************************Private*Routine*****************************\
* dciCreateSurface
*
* History:  1-Aug-1998 Jerry Van Aken [jvanaken] wrote it.
\**************************************************************************/

static BOOL bCreateSurface(PDCIMAN_SURF pPrivate)
{
    DDSURFACEDESC ddsd;
    DDHAL_CREATESURFACEDATA csd;
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal = &pPrivate->SurfaceLocal;

    //
    // Fill in DDSURFACEDESC struct for CreateSurface call.
    //

    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_CAPS;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE;

    //
    // Fill in DDHAL_CREATESURFACEDATA struct for CreateSurface call.
    //

    csd.lpDD = pPrivate->SurfaceGlobal.lpDD;
    csd.lpDDSurfaceDesc = &ddsd;
    csd.lplpSList = &pSurfaceLocal;
    csd.dwSCnt = 1;
    csd.ddRVal = DDERR_GENERIC;
    csd.CreateSurface = pPrivate->DDCallbacks.CreateSurface;

    if ((pPrivate->DDCallbacks.dwFlags & DDHAL_CB32_CREATESURFACE) &&
	(csd.CreateSurface != NULL) &&
	((*csd.CreateSurface)(&csd) == DDHAL_DRIVER_HANDLED) &&
	(csd.ddRVal == DD_OK))
    {
    	return TRUE;
    }
    return FALSE;
}

/******************************Private*Routine*****************************\
* dciCreateSurface
*
* History:  1-Aug-1998 Jerry Van Aken [jvanaken] wrote it.
\**************************************************************************/

static BOOL bDestroySurface(PDCIMAN_SURF pPrivate)
{
    DDHAL_DESTROYSURFACEDATA dsd;

    dsd.lpDD = pPrivate->SurfaceGlobal.lpDD;
    dsd.lpDDSurface = &pPrivate->SurfaceLocal;
    dsd.ddRVal = DDERR_GENERIC;
    dsd.DestroySurface = pPrivate->DDSurfaceCallbacks.DestroySurface;

    if ((pPrivate->DDSurfaceCallbacks.dwFlags & DDHAL_SURFCB32_DESTROYSURFACE) &&
	(dsd.DestroySurface != NULL) &&
	((*dsd.DestroySurface)(&dsd) == DDHAL_DRIVER_HANDLED) &&
	(dsd.ddRVal == DD_OK))
    {
    	return TRUE;
    }
    return FALSE;
}

/******************************Public*Routine******************************\
* DciOpenProvider
*
* History:  1-Aug-1998 Jerry Van Aken [jvanaken] added multimon support.
\**************************************************************************/

HDC
WINAPI
DCIOpenProvider(
    void
)
{
    HANDLE h;
    DWORD iDevice;
    BOOL (WINAPI *pfnEnum)(LPVOID, DWORD, DISPLAY_DEVICEW *, DWORD);
    int cMonitors = GetSystemMetrics(SM_CMONITORS);

    if (cMonitors <= 1)
    {
	//
	// This is a single-monitor system.
	//

	return CreateDCW(L"Display", NULL, NULL, NULL);
    }

    //
    // This is a multimon system.  Get the DC for the primary monitor.
    //

    h = GetModuleHandle("user32.dll");

    (FARPROC)pfnEnum = GetProcAddress(h, "EnumDisplayDevicesW");

    if (pfnEnum == NULL)
    {
	return NULL;
    }

    for (iDevice = 0; iDevice < (DWORD)cMonitors; ++iDevice)
    {
        DISPLAY_DEVICEW dd;

	ZeroMemory(&dd, sizeof(dd));
	dd.cb = sizeof(dd);

	if (!(*pfnEnum)(NULL, iDevice, &dd, 0))
	{
    	    return NULL;
	}

	if (dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
	{
	    //
            // Return the DC for the primary monitor.
	    //

	    return CreateDCW(NULL, dd.DeviceName, NULL, NULL);
	}
    }

    return NULL;
}

/******************************Public*Routine******************************\
* DciCloseProvider
*
* History:
\**************************************************************************/

void
WINAPI
DCICloseProvider(
    HDC hdc
)
{
    DeleteDC(hdc);
}

/******************************Public*Routine******************************\
* DciEnum
*
* History:
\**************************************************************************/

int
WINAPI
DCIEnum(
    HDC hdc,
    LPRECT lprDst,
    LPRECT lprSrc,
    LPVOID lpFnCallback,
    LPVOID lpContext
)
{
    return DCI_FAIL_UNSUPPORTED;
}

/******************************Public*Routine******************************\
* DciCreatePrimarySurface
*
* History:
\**************************************************************************/

int
WINAPI
DCICreatePrimary(
    HDC hdc,
    LPDCISURFACEINFO *lplpSurface
)
{
    int iRet;
    LPDCISURFACEINFO lpSurface;
    PDCIMAN_SURF pPrivate;
    DDHALINFO HalInfo;
    DDHAL_DDCALLBACKS DDCallbacks;
    DDHAL_DDPALETTECALLBACKS DDPaletteCallbacks;
    BOOL NewMode;

    *lplpSurface = NULL;
    iRet = DCI_FAIL_GENERIC;

    pPrivate = (PDCIMAN_SURF) LocalAlloc(LMEM_ZEROINIT, sizeof(DCIMAN_SURF)
                                                      + sizeof(DCISURFACEINFO));
    if (pPrivate != NULL)
    {
        //
        // We store private DCIMAN information in the DCIMAN_SURF structure
        // that immediately preceeds the DCISURFACEINFO structure we'll give
        // out.
        //

        lpSurface = (LPDCISURFACEINFO) (pPrivate + 1);

        if (DdCreateDirectDrawObject(&pPrivate->DirectDrawGlobal, hdc))
        {
            if (DdReenableDirectDrawObject(&pPrivate->DirectDrawGlobal, &NewMode) &&
                DdQueryDirectDrawObject(&pPrivate->DirectDrawGlobal,
                                        &HalInfo,
                                        &pPrivate->DDCallbacks,
                                        &pPrivate->DDSurfaceCallbacks,
                                        &DDPaletteCallbacks,
                                        NULL, NULL, NULL, NULL,
                                        NULL,
                                        NULL))
            {
		//
                // Build the required DirectDraw links for the 'global' and
                // 'local' surfaces.
                //

                pPrivate->SurfaceLost              = FALSE;
                pPrivate->DirectDrawGlobal.vmiData = HalInfo.vmiData;
                pPrivate->SurfaceLocal.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
                pPrivate->SurfaceLocal.lpGbl       = &pPrivate->SurfaceGlobal;
                pPrivate->SurfaceLocal.hDDSurface  = 0;
                pPrivate->SurfaceGlobal.lpDD       = &pPrivate->DirectDrawGlobal;
                pPrivate->SurfaceGlobal.wHeight    = (WORD) HalInfo.vmiData.dwDisplayHeight;
		pPrivate->SurfaceGlobal.wWidth     = (WORD) HalInfo.vmiData.dwDisplayWidth;
		pPrivate->SurfaceGlobal.lPitch     = HalInfo.vmiData.lDisplayPitch;

		if (bCreateSurface(pPrivate))
                {
                    //
                    // Associate an hwnd of '-1' with this surface to let the
                    // kernel know that the application may be drawing to any
                    // window, so Visrgn notifications should happen when any
                    // window changes.
                    //

                    if (DdResetVisrgn(&pPrivate->SurfaceLocal, (HWND) -1))
                    {
                        lpSurface->dwSize = sizeof(DCISURFACEINFO);

                        if (HalInfo.vmiData.ddpfDisplay.dwRGBBitCount <= 8)
                        {
                            lpSurface->dwCompression = BI_RGB;
                        }
                        else
                        {
                            lpSurface->dwCompression = BI_BITFIELDS;
                        }

                        lpSurface->dwDCICaps      = DCI_PRIMARY | DCI_VISIBLE;
                        lpSurface->dwMask[0]      = HalInfo.vmiData.ddpfDisplay.dwRBitMask;
                        lpSurface->dwMask[1]      = HalInfo.vmiData.ddpfDisplay.dwGBitMask;
                        lpSurface->dwMask[2]      = HalInfo.vmiData.ddpfDisplay.dwBBitMask;
                        lpSurface->dwWidth        = HalInfo.vmiData.dwDisplayWidth;
                        lpSurface->dwHeight       = HalInfo.vmiData.dwDisplayHeight;
                        lpSurface->lStride        = HalInfo.vmiData.lDisplayPitch;
                        lpSurface->dwBitCount     = HalInfo.vmiData.ddpfDisplay.dwRGBBitCount;
                        lpSurface->dwOffSurface   = 0;
                        lpSurface->wSelSurface    = 0;
                        lpSurface->wReserved      = 0;
                        lpSurface->dwReserved1    = 0;
                        lpSurface->dwReserved2    = 0;
                        lpSurface->dwReserved3    = 0;
                        lpSurface->BeginAccess    = NULL;
                        lpSurface->EndAccess      = NULL;
                        lpSurface->DestroySurface = NULL;

                        *lplpSurface = lpSurface;
                        return(DCI_OK);
                    }

		    //
		    // The call to DdResetVisrgn failed.
		    //

		    bDestroySurface(pPrivate);
                }
            }
            else
            {
                //
                // DirectDraw is not supported on this device.
                //

                iRet = DCI_FAIL_UNSUPPORTED;
            }

            DdDeleteDirectDrawObject(&pPrivate->DirectDrawGlobal);
        }
        else
        {
            //
            // DirectDraw is not supported on this device.
            //

            iRet = DCI_FAIL_UNSUPPORTED;
        }

        LocalFree(pPrivate);
    }
    else
    {
	//
	// Can't allocate memory for PDCIMAN_SURF struct.
	//

	iRet = DCI_ERR_OUTOFMEMORY;
    }

    *lplpSurface = NULL;

    return iRet;
}



/******************************Public*Routine******************************\
* GdiDciCreateOffscreenSurface
*
* Stub to call CreateOffscreenSurface
*
* History:
\**************************************************************************/

int
WINAPI
DCICreateOffscreen(
    HDC hdc,
    DWORD dwCompression,
    DWORD dwRedMask,
    DWORD dwGreenMask,
    DWORD dwBlueMask,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwDCICaps,
    DWORD dwBitCount,
    LPDCIOFFSCREEN *lplpSurface
)
{
    return DCI_FAIL_UNSUPPORTED;
}


/******************************Public*Routine******************************\
* DciCreateOverlay
*
* History:
\**************************************************************************/

int
WINAPI
DCICreateOverlay(
    HDC hdc,
    LPVOID lpOffscreenSurf,
    LPDCIOVERLAY FAR *lplpSurface
)
{
    return DCI_FAIL_UNSUPPORTED;
}


/******************************Public*Routine******************************\
* WinWatchOpen
*
* History:
\**************************************************************************/

HWINWATCH
WINAPI
WinWatchOpen(
    HWND hwnd
)
{
    HDC hdc;
    PWINWATCH pwatch;

    EnterCriticalSection(&gcsWinWatchLock);

    pwatch = (PWINWATCH) LocalAlloc(LPTR, sizeof(WINWATCH));

    if (pwatch)
    {
        pwatch->hwnd          = hwnd;
        pwatch->changed       = FALSE;
        pwatch->lprgndataSize = 0;
        pwatch->lprgndata     = NULL;

        //
        // Add this to the head of the list.
        //

        pwatch->pWinWatchNext = gpWinWatchList;
        gpWinWatchList = pwatch;
    }

    LeaveCriticalSection(&gcsWinWatchLock);

    return (HWINWATCH) (pwatch);
}

/******************************Public*Routine******************************\
* WinWatchClose
*
* History:
\**************************************************************************/

void
WINAPI
WinWatchClose(
    HWINWATCH hWW
)
{
    PWINWATCH pwatch = (PWINWATCH) hWW;
    PWINWATCH ptmp;

    EnterCriticalSection(&gcsWinWatchLock);

    if (gpWinWatchList == pwatch)
    {
        //
        // The specified winwatch is at the head of the list.
        //

        gpWinWatchList = pwatch->pWinWatchNext;
        LocalFree(pwatch->lprgndata);
        LocalFree(pwatch);
    }
    else
    {
        for (ptmp = gpWinWatchList;
             ptmp != NULL;
             ptmp = ptmp->pWinWatchNext)
        {
            if (ptmp->pWinWatchNext == pwatch)
            {
                //
                // We've found the specified winwatch in the list.
                //

                ptmp->pWinWatchNext = pwatch->pWinWatchNext;
                LocalFree(pwatch->lprgndata);
                LocalFree(pwatch);

                break;
            }
        }
    }

    LeaveCriticalSection(&gcsWinWatchLock);
}


/******************************Public*Routine******************************\
* WinWatchGetClipList
*
* History:
\**************************************************************************/

UINT
WINAPI
WinWatchGetClipList(
    HWINWATCH hWW,
    LPRECT prc,             // May be NULL
    UINT size,
    LPRGNDATA prd
)
{
    PWINWATCH pwatch = (PWINWATCH) hWW;
    DWORD dwSize;
    DWORD dwNewSize;
    UINT dwRet;

    //
    // The first time after the VisRgn has changed, we download and
    // cache a copy of the clipping region.  We do this because the VisRgn
    // can change under our implementation even between doing a BeginAccess/
    // EndAccess, and we should at least maintain a consistent copy of what
    // we think is the current VisRgn.
    //
    // Mostly, we do this so that the following scenario doesn't happen:
    //
    // 1.  The app calls WinWatchGetClipList to ascertain the clip size;
    // 2.  The VisRgn gets more complex;
    // 3.  The app then calls WinWatchGetClipList with a buffer size
    //     allocated from the return code of step 1., and the call fails
    //     because now the buffer isn't long enough.  The problem is that
    //     most applications probably wouldn't expect this second call to
    //     fail, and so would keep on using what is now a completely invalid
    //     region buffer.
    //

    if (pwatch->changed)
    {
        pwatch->changed = FALSE;

        //
        // Assume failure.
        //

        pwatch->lprgndataSize = 0;

        dwSize = GetWindowRegionData(pwatch->hwnd,
                                     0,
                                     NULL);

        if (dwSize != 0)
        {

        Try_Again:

            if (pwatch->lprgndata != NULL)
            {
                LocalFree(pwatch->lprgndata);
            }

            pwatch->lprgndata = LocalAlloc(0, dwSize);

            if (pwatch->lprgndata != NULL)
            {
                dwNewSize = GetWindowRegionData(pwatch->hwnd,
                                                dwSize,
                                                pwatch->lprgndata);

                if (dwNewSize == dwSize)
                {
                    //
                    // Success!  (Note that the docs are wrong and NT does
                    // not return '1' for success -- it returns the size
                    // of the buffer.)
                    //

                    pwatch->lprgndataSize = dwSize;
                }
                else if (dwSize != 0)
                {
                    //
                    // Since dwSize is not zero, which would indicate failure
                    // or success, then we know that the clipping region grew
                    // in size between the time we queried the size and the
                    // time we tried to download it.  This is a pretty rare
                    // event, and the chances of it happening again are slight
                    // (it's more likely that it will shrink the second time,
                    // anyway), so we just try it again.
                    //

                    dwSize = dwNewSize;

                    goto Try_Again;
                }
            }
        }
    }

    //
    // Now use the cached copy to handle any queries.
    //

    dwRet = 0;

    if (size < pwatch->lprgndataSize)
    {
        dwRet = pwatch->lprgndataSize;
    }
    else
    {
        if (pwatch->lprgndataSize != 0)
        {
            RtlCopyMemory(prd, pwatch->lprgndata, pwatch->lprgndataSize);
            dwRet = 1;
        }
    }

    return dwRet;
}


/******************************Public*Routine******************************\
* WinWatchDidStatusChange
*
* History:
\**************************************************************************/


BOOL
WINAPI
WinWatchDidStatusChange(
    HWINWATCH hWW
)
{
    PWINWATCH pwatch = (PWINWATCH) hWW;

    return pwatch->changed;
}


/******************************Public*Routine******************************\
* GetWindowRegionData
*
* History:
\**************************************************************************/

DWORD
WINAPI
GetWindowRegionData(
    HWND hwnd,
    DWORD size,
    LPRGNDATA prd
)
{
    HDC hdc;
    DWORD dwRet = 0;

    hdc = GetDC(hwnd);
    if (hdc)
    {
        dwRet = GetDCRegionData(hdc, size, prd);
        ReleaseDC(hwnd, hdc);
    }

    return dwRet;
}

/******************************Public*Routine******************************\
* GetDCRegionData
*
* History:
\**************************************************************************/

DWORD
WINAPI GetDCRegionData(
    HDC hdc,
    DWORD size,
    LPRGNDATA prd
)
{
    HRGN hrgn;
    DWORD num;
    LPRGNDATA lpdata;

    hrgn = CreateRectRgn(0, 0, 0, 0);
    
    if (hrgn == NULL) {
	WARNING("GetDCRegionData - CreateRectRgn failed.\n");
	return 0;
    }

    GetRandomRgn(hdc, hrgn, 4);

    num = GetRegionData(hrgn, size, prd);

    DeleteObject(hrgn);
    
    return num;
}


/******************************Public*Routine******************************\
* WinWatchNotify
*
* History:
\**************************************************************************/


BOOL
WINAPI
WinWatchNotify(
    HWINWATCH hWW,
    WINWATCHNOTIFYPROC NotifyCallback,
    LPARAM NotifyParam
)
{
    return FALSE;
}

/******************************Private*Routine*****************************\
* bDisplayModeChanged
*
* History:  9-Feb-1999 John Stephens [johnstep] wrote it.
\**************************************************************************/

static BOOL bDisplayModeChanged(PDCIMAN_SURF pPrivate)
{
    LPDCISURFACEINFO lpSurface;
    DDHALINFO HalInfo;
    
    lpSurface = (LPDCISURFACEINFO) (pPrivate + 1);
    if (DdQueryDirectDrawObject(&pPrivate->DirectDrawGlobal,
                                &HalInfo,
                                NULL,
                                NULL,
                                NULL,
                                NULL, NULL, NULL, NULL,
                                NULL,
                                NULL))
    {

        return
            (lpSurface->dwWidth    != HalInfo.vmiData.dwDisplayWidth) ||
            (lpSurface->dwHeight   != HalInfo.vmiData.dwDisplayHeight) ||
            (lpSurface->lStride    != HalInfo.vmiData.lDisplayPitch) ||
            (lpSurface->dwBitCount != HalInfo.vmiData.ddpfDisplay.dwRGBBitCount);
    }

    //
    // If we cannot even query the DirectDraw object, then we cannot make any
    // assumptions about the current display mode, so it may have changed.
    //
    
    return TRUE;
}

/******************************Public*Routine******************************\
* DciBeginAccess
*
* History:
\**************************************************************************/

DCIRVAL
WINAPI
DCIBeginAccess(
    LPDCISURFACEINFO lpSurface,
    int x,
    int y,
    int dx,
    int dy
)
{
    DCIRVAL iRet;
    PDCIMAN_SURF pPrivate;
    DDHAL_LOCKDATA LockData;
    BOOL NewMode;
    PWINWATCH pwatch;

    iRet = DCI_FAIL_GENERIC;

    pPrivate = ((PDCIMAN_SURF) lpSurface) - 1;

    __try
    {
	//
	// Fail if the mode changed.
	//

	if (pPrivate->SurfaceLost)
	{
	    return DCI_FAIL_INVALIDSURFACE;
	}

	LockData.lpDD         = &pPrivate->DirectDrawGlobal;
	LockData.lpDDSurface  = &pPrivate->SurfaceLocal;
	LockData.bHasRect     = TRUE;
	LockData.rArea.left   = x;
	LockData.rArea.top    = y;
	LockData.rArea.right  = x + dx;
	LockData.rArea.bottom = y + dy;
	LockData.dwFlags      = DDLOCK_SURFACEMEMORYPTR;

	//
	// The DCI specification says we could return DCI_STATUS_WASSTILLDRAWING
	// if the accelerator was still busy, but the previous release of DCI on
	// Windows NT 3.51 did not support that feature, so we will endeavor to
	// remain backwards compatible and do the wait explicitly on behalf of
	// the application.
	//

    Try_Again:

	do {

	    //
	    // Hold the DCI critical section while calling the kernel to do the
	    // lock because the kernel surface lock API does not have waiting
	    // semantics; it will fail if another thread is currently in the
	    // kernel locking the same surface.  This is the expected behaviour
	    // for DirectDraw, but some clients of DCI -- OpenGL in particular --
	    // do not expect this.  So we will protect them against themselves
	    // by acquiring the WinWatch lock before calling the kernel.
	    //
	    // This lock is also needed for traversing the WinWatchList.
	    //

	    EnterCriticalSection(&gcsWinWatchLock);

	    do {
		pPrivate->DDSurfaceCallbacks.Lock(&LockData);

	    } while (LockData.ddRVal == DDERR_WASSTILLDRAWING);

	    if (LockData.ddRVal == DDERR_VISRGNCHANGED)
	    {
		if (!DdResetVisrgn(&pPrivate->SurfaceLocal, (HWND) -1))
		{
		    WARNING("DCIBeginAccess - ResetVisRgn failed\n");
		}

		//
		// The VisRgn has changed, and we can't be sure what window it
		// was for.  So we'll mark all WinWatches as having dirty VisRgns.
		// This effect of this is that some of the WinWatches will have to
		// re-download their clipping information when they don't really
		// have to because their specific window has not changed.
		//
		// Note that the WinWatchLock must be held here.
		//

		for (pwatch = gpWinWatchList;
		     pwatch != NULL;
		     pwatch = pwatch->pWinWatchNext)
		{
		    pwatch->changed = TRUE;
		}
	    }

	    LeaveCriticalSection(&gcsWinWatchLock);

	} while (LockData.ddRVal == DDERR_VISRGNCHANGED);

	//
	// 'Surface Lost' means that some sort of mode change occured, and
	// we have to re-enable DirectDraw.
	//

	if (LockData.ddRVal == DDERR_SURFACELOST)
	{
	    if (!DdReenableDirectDrawObject(&pPrivate->DirectDrawGlobal,
					    &NewMode))
	    {
		//
		// We're still in full-screen mode:
		//

		iRet = DCI_ERR_SURFACEISOBSCURED;
	    }
	    else
	    {
                if (!bDisplayModeChanged(pPrivate))
                {
		    //
		    // We switched back to the same mode.  Now that we've re-enabled
		    // DirectDraw, we can try again:
		    //

		    bDestroySurface(pPrivate);
		    if (bCreateSurface(pPrivate) &&
			DdResetVisrgn(&pPrivate->SurfaceLocal, (HWND) -1))
		    {
			goto Try_Again;
		    }
		    else
		    {
			WARNING("DCIBeginAccess - couldn't recreate surface.\n");
		    }
		}

		//
		// We can't reenable the surface, perhaps because a resolution
		// switch or colour depth change occured.  Mark this surface as
		// unusable -- the application will have to reinitialize:
		//

		pPrivate->SurfaceLost = TRUE;
		iRet = DCI_FAIL_INVALIDSURFACE;

		//
		// Unmap the frame buffer now:
		//

                if (!bDestroySurface(pPrivate) ||
		    !DdDeleteDirectDrawObject(&pPrivate->DirectDrawGlobal))
		{
		    WARNING("DCIBeginAccess - failed to delete surface.\n");
		}
	    }
	}

	if (LockData.ddRVal == DD_OK)
	{
	    //
	    // Return the pointer to the frame buffer in the DCI structure.
	    // We always return DCI_STATUS_POINTERCHANGED because it's possible
	    // that the Lock() call mapped the frame buffer to a different
	    // virtual address than it was previously.
	    //

	    lpSurface->wSelSurface = 0;

	    //
	    // DirectDraw has a goofy convention where it returns a pointer to
	    // the upper-left corner of the specified rectangle.  We have to
	    // undo that for DCI:
	    //

	    lpSurface->dwOffSurface = (ULONG_PTR) LockData.lpSurfData
		- (y * lpSurface->lStride)
		- (x * (lpSurface->dwBitCount >> 3));

	    iRet = DCI_STATUS_POINTERCHANGED;
	}
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DCIBeginAccess - exception caused by invalid surface pointer.\n");
	return DCI_FAIL_GENERIC;
    }

    return iRet;
}

/******************************Public*Routine******************************\
* DciEndAccess
*
* History:
\**************************************************************************/

void
WINAPI
DCIEndAccess(
    LPDCISURFACEINFO pdci
)
{
    DDHAL_UNLOCKDATA UnlockData;
    PDCIMAN_SURF pPrivate = ((PDCIMAN_SURF) pdci) - 1;

    __try
    {
	if (!(pPrivate->SurfaceLost))
	{
	    UnlockData.lpDD        = &pPrivate->DirectDrawGlobal;
	    UnlockData.lpDDSurface = &pPrivate->SurfaceLocal;

	    //
	    // For the same reasons as stated in DCIBeginAccess, protect against
	    // two threads trying to unlock the same surface at the same time
	    // in kernel -- kernel would simply fail the call instead of waiting,
	    // and DCI apps won't expect that.
	    //

	    EnterCriticalSection(&gcsWinWatchLock);

	    pPrivate->DDSurfaceCallbacks.Unlock(&UnlockData);

	    LeaveCriticalSection(&gcsWinWatchLock);

	    if (UnlockData.ddRVal != DD_OK)
	    {
		WARNING("DCIEndAccess - failed Unlock\n");
	    }
	}

	//
	// The application shouldn't try to access the frame buffer after
	// after having called EndAccess.
	//

	pdci->wSelSurface = 0;
	pdci->dwOffSurface = 0;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DCIEndAccess - exception caused by invalid surface pointer.\n");
    }
}

/******************************Public*Routine******************************\
* DciDestroy
*
* History:
\**************************************************************************/

void
WINAPI
DCIDestroy(
    LPDCISURFACEINFO pdci
)
{
    PDCIMAN_SURF pPrivate;

    if (pdci != NULL)
    {
        pPrivate = ((PDCIMAN_SURF) pdci) - 1;

        if (!(pPrivate->SurfaceLost))
        {
	    DDHAL_DESTROYSURFACEDATA dsd;

	    dsd.lpDD = pPrivate->SurfaceGlobal.lpDD;
	    dsd.lpDDSurface = &pPrivate->SurfaceLocal;
	    dsd.ddRVal = DDERR_GENERIC;
	    dsd.DestroySurface = pPrivate->DDSurfaceCallbacks.DestroySurface;

	    if (!(pPrivate->DDSurfaceCallbacks.dwFlags & DDHAL_SURFCB32_DESTROYSURFACE) ||
		(dsd.DestroySurface == NULL) ||
		((*dsd.DestroySurface)(&dsd) != DDHAL_DRIVER_HANDLED) ||
                !DdDeleteDirectDrawObject(&pPrivate->DirectDrawGlobal))
            {
                WARNING("DCIDestroy - failed to delete surface.\n");
            }
        }

        LocalFree(pPrivate);
    }
}

DCIRVAL
WINAPI
DCIDraw(
    LPDCIOFFSCREEN pdci
)
{
    return DCI_FAIL_UNSUPPORTED;
}

DCIRVAL
WINAPI
DCISetClipList(
    LPDCIOFFSCREEN pdci,
    LPRGNDATA prd
)
{
    return DCI_FAIL_UNSUPPORTED;
}

DCIRVAL
WINAPI
DCISetDestination(
    LPDCIOFFSCREEN pdci,
    LPRECT dst,
    LPRECT src
)
{
    return DCI_FAIL_UNSUPPORTED;
}


DCIRVAL
WINAPI
DCISetSrcDestClip(
    LPDCIOFFSCREEN pdci,
    LPRECT srcrc,
    LPRECT destrc,
    LPRGNDATA prd
)
{
    return DCI_FAIL_UNSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\debug\gdiview\debug.h ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   debug.h
*
* Abstract:
*
*   Macros used for debugging purposes
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// _debugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and 
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//
//  These macros require extra parantheses for the msg argument
//  for example:
//      WARNING(("App passed NULL pointer, ignoring...\n"));
//      ASSERTMSG(x > 0, ("x is less than 0\n"));
//

#if DBG

// Global debug level

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_RIP     4

extern INT _debugLevel;

//--------------------------------------------------------------------------
// Debug build for native DLL
//--------------------------------------------------------------------------

// Emit debug messages

ULONG DbgPrint(const CHAR*, ...);

// Strip the directory prefix from a filename

const CHAR*
StripDirPrefix(
    const CHAR* filename
    );

#define DBGMSG(level, prefix, msg) \
        do { \
            if (_debugLevel <= (level)) \
            { \
                DbgPrint("%s %s (%d): ", prefix, StripDirPrefix(__FILE__), __LINE__); \
                DbgPrint msg; \
            } \
        } while (0)

#define DBGPRINT(level, msg) \
        do { \
            if (_debugLevel <= (level)) \
            { \
                DbgPrint msg; \
            } \
        } while (0)
    
#define VERBOSE(msg) DBGPRINT(DBG_VERBOSE, msg)
#define TERSE(msg) DBGPRINT(DBG_TERSE, msg)
#define WARNING(msg) DBGMSG(DBG_WARNING, "WRN", msg)

#define ASSERT(cond) \
        do { \
            if (! (cond)) \
            { \
                RIP(("\n")); \
            } \
        } while (0)

#define ASSERTMSG(cond, msg) \
        do { \
            if (! (cond)) \
            { \
                RIP(msg); \
            } \
        } while (0)

#define RIP(msg) \
        do { \
            DBGMSG(DBG_RIP, "RIP", msg); \
            DebugBreak(); \
        } while (0)

#define ENTERFUNC(func) VERBOSE(("%x:%x: Enter "##func##"\n", GetCurrentProcessId(), GetCurrentThreadId()))
#define LEAVEFUNC(func) VERBOSE(("%x:%x: Leave "##func##"\n", GetCurrentProcessId(), GetCurrentThreadId()))

#else // !DBG

//--------------------------------------------------------------------------
// Retail build
//--------------------------------------------------------------------------

#define DbgPrint

#define VERBOSE(msg)
#define TERSE(msg)
#define WARNING(msg)

#define ASSERT(cond)
#define ASSERTMSG(cond, msg)
#define RIP(msg)
#define DBGMSG(level, prefix, msg) 
#define DBGPRINT(level, msg)

#define ENTERFUNC(func)
#define LEAVEFUNC(func)

#endif // !DBG

#ifdef __cplusplus
}
#endif

#endif // !_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\debug\gdiview\output.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    output.h

Abstract:

    This header file declares output routines
    and classes.

Author:

    Jason Hartman (JasonHa) 2000-10-16

--*/


#ifndef _OUTPUT_H_
#define _OUTPUT_H_


class OutputMonitor
{
public:
    OutputMonitor() {
        Client = NULL;
    }

    HRESULT Monitor(PDEBUG_CLIENT Client, ULONG OutputMask);

    HRESULT GetOutputMask(PULONG OutputMask);
    HRESULT SetOutputMask(ULONG OutputMask);

    ~OutputMonitor();

private:
    PDEBUG_CLIENT Client;
    PDEBUG_CLIENT MonitorClient;
};


//----------------------------------------------------------------------------
//
// Default output callbacks implementation, provides IUnknown for
// static classes and prints all text sent through Output.
//
//----------------------------------------------------------------------------

class PrintOutputCallbacks :
    public IDebugOutputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};

#endif  _OUTPUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\debug\gdiview\output.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    output.cpp

Abstract:

    This file contains routines and classes
    to handle output.

Author:

    Jason Hartman (JasonHa) 2000-10-16

Environment:

    User Mode

--*/

#include <stdio.h>

#include <dbgeng.h>

#include "debug.h"
#include "output.h"

#define HISTORY_LENGTH  2048

typedef struct {
    PDEBUG_CLIENT   MonitorClient;  // To be set by created thread
    PDEBUG_CLIENT   Client;
    ULONG           OutputMask;
} MonitorThreadParams;

DWORD WINAPI OutputMonitorThread(MonitorThreadParams *);


HRESULT
OutputMonitor::Monitor(
    PDEBUG_CLIENT ClientToMonitor,
    ULONG OutputMask
    )
{
    Client = ClientToMonitor;

    if (Client == NULL) return S_FALSE;

    Client->AddRef();

    MonitorThreadParams  NewThreadParams = { NULL, Client, OutputMask };
    HANDLE  hThread;
    DWORD   ThreadID = 0;

    hThread = CreateThread(NULL,
                           0,
                           (LPTHREAD_START_ROUTINE)OutputMonitorThread,
                           &NewThreadParams,
                           0,
                           &ThreadID);

    if (hThread)
    {
        while (NewThreadParams.MonitorClient == NULL)
        {
            DWORD ExitCode = 0;
            if (!GetExitCodeThread(hThread, &ExitCode))
                DbgPrint("GetExitCodeThread returned error %lx.\n", GetLastError());
            if (ExitCode != STILL_ACTIVE)
            {
                ThreadID = 0;
                break;
            }

            SleepEx(10, TRUE);
        }

        CloseHandle(hThread);
    }

    MonitorClient = NewThreadParams.MonitorClient;

    return (MonitorClient != NULL) ? S_OK : S_FALSE;
}


HRESULT
OutputMonitor::GetOutputMask(
    PULONG OutputMask
    )
{
    HRESULT hr = S_FALSE;

    if (Client != NULL &&
        MonitorClient != NULL)
    {
        hr = Client->GetOtherOutputMask(MonitorClient, OutputMask);
    }

    return hr;
}


HRESULT
OutputMonitor::SetOutputMask(
    ULONG OutputMask
    )
{
    HRESULT hr = S_FALSE;

    if (Client != NULL &&
        MonitorClient != NULL)
    {
        hr = Client->SetOtherOutputMask(MonitorClient, OutputMask);
    }

    return hr;
}


OutputMonitor::~OutputMonitor()
{
    if (Client)
    {
        if (MonitorClient)
        {
            Client->ExitDispatch(MonitorClient);
        }

        Client->Release();
    }
}


DWORD
WINAPI
OutputMonitorThread(
    MonitorThreadParams *Params
    )
{
    HRESULT                 hr = S_FALSE;
    PDEBUG_CLIENT           MonitorClient;
    PrintOutputCallbacks    PrintCallbacks;

    if (Params != NULL &&
        Params->Client != NULL &&
        (hr = Params->Client->CreateClient(&MonitorClient)) == S_OK)
    {
        if ((hr = MonitorClient->SetOutputMask(Params->OutputMask |
                                               DEBUG_OUTPUT_PROMPT |
                                               DEBUG_OUTPUT_PROMPT_REGISTERS |
                                               DEBUG_OUTPUT_DEBUGGEE |
                                               DEBUG_OUTPUT_DEBUGGEE_PROMPT
                                               )) == S_OK &&
            (hr = MonitorClient->SetOutputCallbacks(&PrintCallbacks)) == S_OK)
        {
            if ((hr = MonitorClient->ConnectSession(DEBUG_CONNECT_SESSION_NO_ANNOUNCE, HISTORY_LENGTH)) != S_OK)
            {
                printf("Couldn't get debugger version/history: HRESULT 0x%lx\n", hr);
            }

            MonitorClient->SetOutputMask(Params->OutputMask);

            Params->MonitorClient = MonitorClient;
            hr = MonitorClient->DispatchCallbacks(INFINITE);
        }
        else
        {
            printf("Output callbacks setup failed, HRESULT: 0x%lx\n", hr);
        }

        MonitorClient->Release();
    }

    DbgPrint("OutputMonitorThread calling ExitThread().\n");

    ExitThread((DWORD)hr);
}



//----------------------------------------------------------------------------
//
// Default output callbacks implementation, provides IUnknown for
// static classes.
//
//----------------------------------------------------------------------------

STDMETHODIMP
PrintOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (//(InterfaceId == IID_IUnknown) ||
        (InterfaceId == __uuidof(IDebugOutputCallbacks)))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
PrintOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
PrintOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
PrintOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    printf("%s", Text);
    return S_OK;
}






#if 0
// Stuff we probably don't need

OutputMonitor::OutputMonitor(
    PDEBUG_CLIENT DbgClient
    )
{
    Client = DbgClient;

    if (Client != NULL)
    {
        Client->AddRef();
    }

    Saved = FALSE;
}


HRESULT
OutputMonitor::Setup(
    ULONG OutMask,
    PDEBUG_OUTPUT_CALLBACKS OutCallbacks
    )
{
    HRESULT Hr = S_FALSE;
    ULONG   LastOutMask;
    PDEBUG_CLIENT f;

    if (Client == NULL)
    {
        return Hr;
    }

    if (!Saved)
    {
        if ((Hr = Client->GetOutputMask(&OrgOutMask)) != S_OK ||
            (Hr = Client->GetOutputCallbacks(&OrgOutCallbacks)) != S_OK)
        {
            return Hr;
        }

        Saved = TRUE;
    }

    if ((Hr = Client->GetOutputMask(&LastOutMask)) == S_OK &&
        (Hr = Client->SetOutputMask(OutMask)) == S_OK)
    {
        if ((Hr = Client->SetOutputCallbacks(OutCallbacks)) != S_OK)
        {
            Client->SetOutputMask(LastOutMask);
        }
    }

    return Hr;
}


HRESULT
OutputMonitor::Execute(
    PCSTR pszCommand
    )
{
    HRESULT         hr = S_FALSE;
    PDEBUG_CONTROL  DbgControl;

    if (Client != NULL &&
        (hr = Client->QueryInterface(__uuidof(IDebugControl),
                                     (void **)&DbgControl)) == S_OK)
    {
        hr = DbgControl->Execute(DEBUG_OUTCTL_THIS_CLIENT |
                                 DEBUG_OUTCTL_OVERRIDE_MASK,
                                 pszCommand,
                                 DEBUG_EXECUTE_NO_REPEAT);

        DbgControl->Release();
    }

    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\debug\gdiview\gdiview.cpp ===
#include <windows.h>
#include <tchar.h>

#include <stdio.h>

#include <dbgeng.h>

#include "debug.h"
#include "output.h"

typedef HRESULT (CALLBACK* PDEBUG_EXTENSION_SET_CLIENT)(LPCSTR RemoteArgs);

#if DBG
CHAR    szDefaultExtPath[] = "\\\\JasonHa\\DbgExts\\gdikdxd";
#else
CHAR    szDefaultExtPath[] = "\\\\JasonHa\\DbgExts\\gdikdxr";
#endif

HMODULE         ghGDIExt = NULL;
PDEBUG_CONTROL  Control = NULL;
BOOL            Continue = TRUE;
PCSTR           gRemoteSpec = NULL;
PCSTR           gMainExtPath = szDefaultExtPath;


HMODULE LoadExtension(PDEBUG_CLIENT Client, PCSTR ExtPath);
BOOL FreeExtension(PDEBUG_CLIENT, HMODULE hExt);
VOID ProcessCommands(PDEBUG_CLIENT Client, OutputMonitor *Monitor);
VOID SetOutputCmd(OutputMonitor *Monitor, const char *Args);
BOOL CtrlHandler(DWORD fdwCtrlType);


int __cdecl main(int argc, char** argv)
{
    HRESULT hr;
    BOOL    CtrlHandlerSet;

    PDEBUG_CLIENT   Client = NULL;

    OutputMonitor   Monitor;

    if (argc < 2)
    {
        printf("Missing remote specification.\n");
        return 1;
    }

    if (argc > 3)
    {
        printf("Too many arguments.\n");
        return 1;
    }

    gRemoteSpec = argv[1];

    if ((hr = DebugConnect(gRemoteSpec,  __uuidof(IDebugClient), (void **)&Client)) != S_OK ||
        Client == NULL)
    {
        printf("Couldn't connect to client: %s, HRESULT: 0x%lx\n", argv[1], hr);
        return 2;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugControl), (void **)&Control)) != S_OK ||
        Control == NULL)
    {
        printf("Couldn't connect to IDebugControl, HRESULT: 0x%lx\n", hr);
        Client->Release();
        return 3;
    }

    if ((hr = Monitor.Monitor(Client,
                              DEBUG_OUTPUT_NORMAL |
                              DEBUG_OUTPUT_ERROR |
                              DEBUG_OUTPUT_WARNING// | DEBUG_OUTPUT_VERBOSE
                              )) != S_OK)
    {
        printf("Output monitor setup failed, HRESULT: 0x%lx\n", hr);
        Control->Release();
        Client->Release();
        return 4;
    }

    CtrlHandlerSet = SetConsoleCtrlHandler(
                        (PHANDLER_ROUTINE) CtrlHandler, // handler function
                        TRUE);                          // add to list

    if ((hr = Client->ConnectSession(DEBUG_CONNECT_SESSION_NO_VERSION, 0)) != S_OK)
    {
        printf("Couldn't finalize connection.  HRESULT 0x%lx\n", hr);
    }
    else
    {
        if (argc > 2)
        {
            gMainExtPath = argv[2];
        }

        ghGDIExt = LoadExtension(Client, gMainExtPath);

        if (ghGDIExt != NULL)
        {
            ProcessCommands(Client, &Monitor);

            FreeExtension(Client, ghGDIExt);
        }

        Control->Output(DEBUG_OUTPUT_NORMAL, "GDIView disconnecting.\n");
    }

    if (CtrlHandlerSet)
    {
        SetConsoleCtrlHandler(
            (PHANDLER_ROUTINE) CtrlHandler, // handler function
            FALSE);                         // remove from list
    }

    Control->Release();
    Client->Release();

    return 0;
}


HMODULE
LoadExtension(
    PDEBUG_CLIENT Client,
    PCSTR ExtPath
    )
{
    HMODULE hExt = NULL;
    BOOL    bInitComplete = FALSE;

    PDEBUG_CONTROL2 Control2;
    ULONG           Status = DEBUG_STATUS_BREAK;

    if (Client->QueryInterface(__uuidof(IDebugControl2),
                               (void **)&Control2) == S_OK)
    {
        Control2->GetExecutionStatus(&Status);
        Control2->Release();
    }

    if (Status != DEBUG_STATUS_NO_DEBUGGEE)
    {
        if ((hExt = LoadLibraryA(ExtPath)) != NULL)
        {
            PDEBUG_EXTENSION_SET_CLIENT     pfnDbgExtSetClient;
            PDEBUG_EXTENSION_INITIALIZE     pfnDbgExtInit;
            PDEBUG_EXTENSION_NOTIFY         pfnDbgExtNotify;
            PDEBUG_EXTENSION_UNINITIALIZE   pfnDbgExtUninit;

            pfnDbgExtSetClient = (PDEBUG_EXTENSION_SET_CLIENT)
                GetProcAddress(hExt, "DebugExtensionSetClient");
            pfnDbgExtInit = (PDEBUG_EXTENSION_INITIALIZE)
                GetProcAddress(hExt, "DebugExtensionInitialize");
            pfnDbgExtNotify = (PDEBUG_EXTENSION_NOTIFY)
                GetProcAddress(hExt, "DebugExtensionNotify");
            pfnDbgExtUninit = (PDEBUG_EXTENSION_UNINITIALIZE)
                GetProcAddress(hExt, "DebugExtensionUninitialize");

            if ((pfnDbgExtSetClient != NULL) &&
                (pfnDbgExtInit != NULL) &&
                (pfnDbgExtNotify != NULL) &&
                (pfnDbgExtUninit != NULL))
            {
                HRESULT hr;
                ULONG   Version, Flags;

                if ((hr = pfnDbgExtSetClient(gRemoteSpec) == S_OK) &&
                    (hr = pfnDbgExtInit(&Version, &Flags)) == S_OK)
                {
                    pfnDbgExtNotify(DEBUG_NOTIFY_SESSION_ACTIVE, 0);

                    if (Status == DEBUG_STATUS_BREAK)
                    {
                        pfnDbgExtNotify(DEBUG_NOTIFY_SESSION_ACCESSIBLE, 0);
                    }

                    bInitComplete = TRUE;
                }
                else
                {
                    printf("Extension init failed: 0x%lx\n", hr);
                }
            }
            else
            {
                printf("Couldn't get all required proc addresses.\n");
            }

            if (!bInitComplete)
            {
                FreeExtension(Client, hExt);
                hExt = NULL;
            }
        }
        else
        {
            printf("LoadLibrary for %s failed with 0x%lx.\n",
                   ExtPath, GetLastError());
        }
    }
    else
    {
        printf("Extension was not loaded since there is no debuggee.\n");
    }

    return hExt;
}


BOOL
FreeExtension(
    PDEBUG_CLIENT Client,
    HMODULE hExt
    )
{
    PDEBUG_EXTENSION_UNINITIALIZE   pfnDbgExtUninit;

    if (hExt == NULL) return FALSE;

    pfnDbgExtUninit = (PDEBUG_EXTENSION_UNINITIALIZE)
        GetProcAddress(ghGDIExt, "DebugExtensionUninitialize");

    if (pfnDbgExtUninit != NULL)
    {
        pfnDbgExtUninit();
    }

    return FreeLibrary(hExt);
}


VOID
ProcessCommands(
    PDEBUG_CLIENT Client,
    OutputMonitor *Monitor)
{
    PDEBUG_CONTROL  DbgControl;
    CHAR    CmdLine[MAX_PATH];
    CHAR   *pCmd;
    CHAR   *pArgs;
    PDEBUG_EXTENSION_CALL pfnDbgExt;

    if (Client == NULL ||
        Client->QueryInterface(__uuidof(IDebugControl), (void **)&DbgControl) != S_OK)
    {
        return;
    }

    while (Continue)
    {
        printf("GDIView> ");

        if (gets(CmdLine))
        {
            pCmd = CmdLine;
            while (*pCmd && isspace(*pCmd)) pCmd++;

            if (! *pCmd) continue;

            if (*pCmd == '.')
            {
                BOOL    FoundCmd = FALSE;

                pCmd++;

                switch (tolower(*pCmd))
                {
                    case 'h':
                        if (_strnicmp(pCmd, "help", strlen(pCmd)) == 0)
                        {
                            printf("GDIView Help:\n"
                                   " .help      This help\n"
                                   " .output    Display/toggle output filtering\n"
                                   " .quit      Exit GDIView\n"
                                   "\n"
                                   " <GDIKDX Extension>     Execute GDIKDX Extension\n"
                                   " help                   GDIKDX help information\n");
                            FoundCmd = TRUE;
                        }
                        break;
                    case 'q':
                        if (_strnicmp(pCmd, "quit", strlen(pCmd)) == 0)
                        {
                            Continue = FALSE;
                            FoundCmd = TRUE;
                        }
                        break;
                    case 'o':
                    {
                        ULONG CmdLen;

                        pArgs = pCmd;
                        do
                        {
                            pArgs++;
                        } while (*pArgs != '\0' && !isspace(*pArgs));

                        if (_strnicmp(pCmd, "output", pArgs - pCmd) == 0)
                        {
                            SetOutputCmd(Monitor, pArgs);
                            FoundCmd = TRUE;
                        }
                        break;
                    }
                    default:
                        break;
                }

                if (!FoundCmd)
                {
                    printf("Unknown internal command: .%s\n", pCmd);
                }
            }
            else
            {
                pArgs = pCmd;
                while (*pArgs && !isspace(*pArgs)) pArgs++;
                if (*pArgs)
                {
                    *pArgs++ = '\0';
                    while (*pArgs && isspace(*pArgs)) pArgs++;
                }

                pfnDbgExt = (PDEBUG_EXTENSION_CALL)GetProcAddress(ghGDIExt, pCmd);
                if (pfnDbgExt != NULL)
                {
                    DbgControl->ControlledOutput(DEBUG_OUTCTL_ALL_OTHER_CLIENTS,
                                                 DEBUG_OUTPUT_NORMAL,
                                                 "GDIView> !%s.%s %s\n",
                                                 gMainExtPath,
                                                 pCmd,
                                                 pArgs);

                    pfnDbgExt(Client, pArgs);
                }
                else
                {
                    printf("Couldn't find extension: %s\n", pCmd);
                }
            }
        }
    }

    DbgControl->Release();
}


VOID
SetOutputCmd(
    OutputMonitor *Monitor,
    const char *Args
    )
{
    HRESULT hr;
    ULONG   OutputMask;
    ULONG   NewMask;
    ULONG   ToggleMask;
    BOOL    Clear = FALSE;

    if (Monitor == NULL) return;

    hr = Monitor->GetOutputMask(&OutputMask);
    if (hr != S_OK)
    {
        printf("Failed to retrieve Monitor's output mask.\n");
        return;
    }
    NewMask = OutputMask;

    while (isspace(*Args)) Args++;

    while (hr == S_OK && *Args != '\0')
    {
        switch (tolower(*Args))
        {
            case '+': Clear = FALSE; ToggleMask = 0; break;
            case '-': Clear = TRUE; ToggleMask = 0; break;
            case 'n': ToggleMask |= DEBUG_OUTPUT_NORMAL; break;
            case 'e': ToggleMask |= DEBUG_OUTPUT_ERROR; break;
            case 'w': ToggleMask |= DEBUG_OUTPUT_WARNING; break;
            case 'v': ToggleMask |= DEBUG_OUTPUT_VERBOSE; break;
            case '?':
                printf("Usage: .output [+-][newv]\n");
                return;
            default: hr = E_INVALIDARG; break;
        }
        Args++;

        if (*Args == '\0' || isspace(*Args))
        {
            if (Clear)
            {
                NewMask &= ~ToggleMask;
            }
            else
            {
                NewMask |= ToggleMask;
            }

            while (isspace(*Args)) Args++;
        }
    }

    if (hr != S_OK)
    {
        printf("Invalid arguments to .output.\n");
    }
    else if (NewMask != OutputMask)
    {
        hr = Monitor->SetOutputMask(NewMask);
        if (hr == S_OK)
        {
            OutputMask = NewMask;
        }
        else
        {
            printf("Error while trying to set new monitor mask.\n");
        }
    }

    printf("Monitoring:");
    if (OutputMask & DEBUG_OUTPUT_NORMAL) printf(" Normal");
    if (OutputMask & DEBUG_OUTPUT_ERROR) printf(" Error");
    if (OutputMask & DEBUG_OUTPUT_WARNING) printf(" Warning");
    if (OutputMask & DEBUG_OUTPUT_VERBOSE) printf(" Verbose");

    OutputMask &= ~(DEBUG_OUTPUT_NORMAL | DEBUG_OUTPUT_ERROR |
                    DEBUG_OUTPUT_WARNING | DEBUG_OUTPUT_VERBOSE);
    if (OutputMask) printf(" Other: 0x%lx", OutputMask);

    printf("\n");
}


// CtrlHandler - process Console Control signals
//
// Note: Global Control must be available whenever
//       CtrlHandler is registered.

BOOL CtrlHandler(DWORD fdwCtrlType)
{
    switch (fdwCtrlType)
    {
        // Handle the CTRL+C and CTRL+Break signals.

        case CTRL_C_EVENT:

        case CTRL_BREAK_EVENT:

            Control->SetInterrupt(DEBUG_INTERRUPT_PASSIVE);
            return TRUE;


        // User wants to exit.

        case CTRL_CLOSE_EVENT:

        case CTRL_LOGOFF_EVENT:

        case CTRL_SHUTDOWN_EVENT:

            Continue = FALSE;
            Control->SetInterrupt(DEBUG_INTERRUPT_EXIT);
            return TRUE;


        // Pass other signals to the next handler.

        default:

            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\fondrv.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    fondrv.h

Abstract:

    stuff common to ntgdi\fondrv\...

Author:

    Jay Krell (JayKrell) January 2002

Environment:

    statically linked into win32k.sys
    kernel mode

Revision History:

--*/

#if !defined(WINDOWS_NTGDI_FONDRV_FONDRV_H_INCLUDED)
#define WINDOWS_NTGDI_FONDRV_FONDRV_H_INCLUDED

#if (_MSC_VER > 1020)
#pragma once
#endif

BOOL
bMappedViewStrlen(
    PVOID  pvViewBase,
    SIZE_T cjViewSize,
    PVOID  pvString,
    OUT PSIZE_T pcjOutLength OPTIONAL
    );

BOOL
bMappedViewRangeCheck(
    PVOID  ViewBase,
    SIZE_T ViewSize,
    PVOID  DataAddress,
    SIZE_T DataSize
    );

#if DBG
VOID
__cdecl
NotifyBadFont(
    PCSTR Format,
    ...
    );
#endif

#endif /* WINDOWS_NTGDI_FONDRV_FONDRV_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\bmfd\fd.h ===
/******************************Module*Header*******************************\
* Module Name: fd.h
*
* file which is going to be included by the most *.c files in this directory.
* Supplies basic types, debugging stuff, error logging and checking stuff,
* error codes, usefull macros etc.
*
* Created: 22-Oct-1990 15:23:44
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/
#define  IFI_PRIVATE

// macros for allocating and freeing memory

//#include <stddef.h>
//#include <stdarg.h>
//#include <windef.h>
//#include <wingdi.h>
//#include <winddi.h>

//#include "mapfile.h"

#include "engine.h"
#include "winres.h"
#include "fondrv.h"

#define abs(x) max((x),-(x))

#if defined(_AMD64_) || defined(_IA64_)

#define  vLToE(pe,l)           (*(pe) = (FLOAT)(l))

#else   // i386

ULONG  ulLToE (LONG l);
VOID   vLToE(FLOATL * pe, LONG l);

#endif

//#define DEBUGSIM

BOOL BmfdEnableDriver(
ULONG iEngineVersion,
ULONG cj,
PDRVENABLEDATA pded);

BOOL
bBmfdLoadFont(
    HFF        iFile,
    PVOID      pvView,
    ULONG      cjView,
    ULONG      iType,
    HFF        *phff
    );

BOOL
BmfdUnloadFontFile (
    HFF hff
    );

LONG
BmfdQueryFontCaps (
    ULONG culCaps,
    PULONG pulCaps
    );

LONG
BmfdQueryFontFile (
    HFF     hff,
    ULONG   ulMode,
    ULONG   cjBuf,
    PULONG  pulBuf
    );

PIFIMETRICS
BmfdQueryFont (
    DHPDEV dhpdev,
    HFF    hff,
    ULONG  iFace,
    ULONG_PTR  *pid
    );

PVOID
BmfdQueryFontTree (
    DHPDEV  dhpdev,
    HFF     hff,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR   *pid
    );

LONG
BmfdQueryFontData (
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH  hg,
    GLYPHDATA *pgd,
    PVOID   pv,
    ULONG   cjSize
    );

VOID
BmfdDestroyFont (
    FONTOBJ *pfo
    );

HFC
BmfdOpenFontContext (
    FONTOBJ *pfo
    );

BOOL
    BmfdCloseFontContext(
    HFC hfc
    );

LONG
BmfdQueryFaceAttr(
    HFC hfc,
    ULONG ulType,
    ULONG culBuffer,
    PULONG pulBuffer
    );

BOOL BmfdQueryAdvanceWidths
(
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
);

BOOL bDbgPrintAndFail(PSZ);


#include "fontfile.h"
#include "winfont.h"
#include "cvt.h"
#include "simulate.h"
#include "fon32.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\bmfd\cvt.h ===
/******************************Module*Header*******************************\
* Module Name: cvt.h
*
* function declarations that are private to cvt.c
*
* Created: 26-Nov-1990 17:39:35
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/

FSHORT
fsSelectionFlags(
    PBYTE
    );

VOID
vAlignHdrData(
    PCVTFILEHDR,
    PRES_ELEM
    );

BOOL
bVerifyResource(
    PCVTFILEHDR,
    PRES_ELEM
    );

BOOL
bVerifyFNTQuick(
    PRES_ELEM
    );

BOOL
bVerifyFNT(
    PCVTFILEHDR,
    PRES_ELEM
    );

BOOL
bGrep(
    PSZ,
    PSZ
    );

VOID
vFigureVendorId(
    CHAR*,
    PSZ
    );

BYTE
jFamilyType(
    FSHORT
    );

ULONG
cjGLYPHDATA(
    ULONG
    );

USHORT
usConvertWeightClass(
    USHORT
    );

VOID
vComputeSpecialChars(
    PCVTFILEHDR,
    PWCHAR,
    PWCHAR
    );

PBYTE
pjRawBitmap(
    HGLYPH,
    PCVTFILEHDR,
    PRES_ELEM,
    PULONG
    );

BOOL
bDescStr(
    PVOID,
    SIZE_T,
    PSZ
    );

VOID
vCvtToBmp(
    GLYPHBITS *,
    GLYPHDATA *,
    PBYTE,
    ULONG,
    ULONG,
    ULONG
    );

VOID
vCvtToBoldBmp(
    GLYPHBITS *,
    GLYPHDATA *,
    PBYTE,
    ULONG,
    ULONG,
    ULONG
    );

VOID
vCvtToItalicBmp(
    GLYPHBITS *,
    GLYPHDATA *,
    PBYTE,
    ULONG,
    ULONG,
    ULONG
    );

VOID
vCvtToBoldItalicBmp(
    GLYPHBITS *,
    GLYPHDATA *,
    PBYTE,
    ULONG,
    ULONG,
    ULONG
    );

VOID
vComputeSimulatedGLYPHDATA(
    GLYPHDATA*,
    PBYTE,
    ULONG,
    ULONG,
    ULONG,
    ULONG,
    ULONG,
    FONTOBJ*
    );

VOID
vFindTAndB(
    PBYTE,
    ULONG,
    ULONG,
    ULONG*,
    ULONG*
    );

BOOL
bConvertFontRes
(
    PVOID        pvView,
    SIZE_T       cjView,
    PRES_ELEM,
    FACEINFO*
    );

VOID
vCheckOffsetTable(
    PCVTFILEHDR,
    PRES_ELEM
    );

BOOL
bBMFDIFIMETRICS(
    PVOID        pvView,
    SIZE_T       cjView,
    PCVTFILEHDR pcvtfh OPTIONAL,
    PRES_ELEM   pre,
    OUT PULONG  pcjIFIOut OPTIONAL
    );

VOID
vDefFace(
    FACEINFO *pfai,
    RES_ELEM *pre
    );

VOID
vBmfdFill_IFIMETRICS(
    FACEINFO   *pfai,
    PRES_ELEM   pre
    );


typedef VOID (* PFN_IFI)(PIFIMETRICS);

//
// This is a useful macro. It returns the offset from the address y
// to the next higher address aligned to an object of type x
//

#define OFFSET_OF_NEXT(x,y) sizeof(x)*((y+sizeof(x)-1)/sizeof(x))

//
// ISIMULATE -- converts from FO_SIM_FOO to FC_SIM_FOO
//
#define ISIMULATE(x)                                 \
                                                     \
        (x) == 0 ?                                   \
            FC_SIM_NONE :                            \
            (                                        \
                (x) == FO_SIM_BOLD ?            \
                    FC_SIM_BOLD :                    \
                    (                                \
                        (x) == FO_SIM_ITALIC ?  \
                            FC_SIMULATE_ITALIC :     \
                            FC_SIMULATE_BOLDITALIC   \
                    )                                \
            )


// The missing range in SYMBOL character set (inclusive-inclusive)

#define CHARSET_SYMBOL_GAP_MIN  127
#define CHARSET_SYMBOL_GAP_MAX  160

// save some typing here, rename what used to be functions into
// these macros

#define   ulMakeULONG(pj)    ((ULONG)READ_DWORD(pj))
#define   lMakeLONG(pj)      ((LONG)READ_DWORD(pj))
#define   usMakeUSHORT(pj)   ((USHORT)READ_WORD(pj))
#define   sMakeSHORT(pj)     ((SHORT)READ_WORD(pj))

//!!! the next one is specific to win31 us char set (1252 cp) and this
//!!! has to be generalized to an arbitrary code page

#define    C_RUNS       15


// these are the indicies into the array of strings below

#define I_DONTCARE     0         // don't care or don't know
#define I_ROMAN        1
#define I_SWISS        2
#define I_MODERN       3
#define I_SCRIPT       4
#define I_DECORATIVE   5

// #define DUMPCALL

#if defined(_X86_)

typedef struct  _FLOATINTERN
{
    LONG    lMant;
    LONG    lExp;
} FLOATINTERN;

typedef FLOATINTERN  EFLOAT;
typedef EFLOAT *PEFLOAT;

VOID    ftoef_c(FLOATL, PEFLOAT);
BOOL    eftol_c(EFLOAT *, PLONG, LONG);

#define vEToEF(e, pef)      ftoef_c((e), (pef))
#define bEFtoL(pe, pl )     eftol_c((pe), (pl), 1 )

#define bIsZero(ef)     ( ((ef).lMant == 0) && ((ef).lExp == 0) )
#define bPositive(ef)       ( (ef).lMant >= 0 )
FIX  fxLTimesEf(EFLOAT *pef, LONG l);

#else // not X86

typedef FLOAT EFLOAT;
typedef EFLOAT *PEFLOAT;

//
//  these could come from the real header files in math
//

#if defined(_AMD64_) || defined(_IA64_)
#define bFToLRound(e, pl) (bFToL(e, pl, 4+2))
extern BOOL bFToL(FLOAT e, PLONG pl, LONG lType);
#else
extern BOOL bFToLRound(FLOAT e, PLONG pl);
#endif

#define vEToEF(e, pef)      ( *(pef) = (e) )
#define bEFtoL( pe, pl )    ( bFToLRound(*(pe), (pl) ))
#define bIsZero(ef)     ( (ef) == 0 )
#define bPositive(ef)       ( (ef) >= 0 )

#endif


BOOL bLoadNtFon(
HFF iFile,
PVOID pvView,
HFF *phff
);


VOID vBmfdMarkFontGone(FONTFILE *pff, DWORD iExceptionCode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\bmfd\fdfc.c ===
/******************************Module*Header*******************************\
* Module Name: fdfc.c
*
* functions that deal with font contexts
*
* Created: 08-Nov-1990 12:42:34
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "fd.h"

#define MAX_HORZ_SCALE      5
#define MAX_VERT_SCALE      255

#ifdef FE_SB // ROTATION: ulGetRotate() function body

/******************************Private*Routine*****************************\
*
* VOID vComputeRotatedXform()
*
* History :
*
*  14-Feb-1993 -By- Hideyuki Nagase [HideyukN]
* Wrote it.
\**************************************************************************/

VOID
vComputeRotatedXform
(
POINTL      *pptlScale,
LONG         lXscale ,
LONG         lYscale
)
{

// If the caling factor is 0 , We have to set it to 1 for avoiding overflow

    if( lXscale == 0L )
    {
        pptlScale->x = 1L;
    }
    else
    {
        pptlScale->x = lXscale;

        if( pptlScale->x < 0 )
            pptlScale->x = -(pptlScale->x);

        if( pptlScale->x > MAX_HORZ_SCALE )
            pptlScale->x = MAX_HORZ_SCALE;
    }

    if( lYscale == 0L )
    {
        pptlScale->y = 1L;
    }
    else
    {
        pptlScale->y = lYscale;

        if( pptlScale->y < 0 )
            pptlScale->y = -(pptlScale->y);

        if( pptlScale->y > MAX_VERT_SCALE )
            pptlScale->y = MAX_VERT_SCALE;
    }
}

/******************************Public*Routine******************************\
* ULONG  ulGetRotate()
*
* Effects:
*
* Warnings:
*
* History:
*
*  8-Feb-1993 -by- Hideyuki Nagase [HideyukN]
* Wrote it.
\**************************************************************************/

ULONG ulGetRotate( POINTL *pptlScale , XFORMOBJ *pxo )
{
    EFLOAT efXX , efXY , efYX , efYY;
    LONG    lXX ,  lXY ,  lYX ,  lYY;
    XFORML  xform;

// Get the transform elements.

    XFORMOBJ_iGetXform(pxo,&xform);

// Convert elements of the matrix from IEEE float to our EFLOAT.

    vEToEF(xform.eM11 , &efXX );
    vEToEF(xform.eM12 , &efXY );
    vEToEF(xform.eM21 , &efYX );
    vEToEF(xform.eM22 , &efYY );

// Convert these from EFLOAT to LONG

    if( !bEFtoL( &efXX , &lXX ) ||
        !bEFtoL( &efXY , &lXY ) ||
        !bEFtoL( &efYX , &lYX ) ||
        !bEFtoL( &efYY , &lYY )
      )
    {
        WARNING("BMFD!bEToEF() fail\n");
        vComputeRotatedXform( pptlScale , MAX_HORZ_SCALE , MAX_VERT_SCALE );
        return( 0L );
    }

// Check transform.

//
// 0 '                  180 '
//
// (  1  0 )(X) = ( X)   ( -1  0 )(X) = (-X)     ( XX XY )(X)
// (  0  1 )(Y)   ( Y)   (  0 -1 )(Y)   (-Y)     ( YX YY )(Y)
//
// 90 '                 270 '
//
// (  0 -1 )(X) = (-Y)   (  0  1 )(X) = ( Y)
// (  1  0 )(Y)   ( X)   ( -1  0 )(Y)   (-X)
//

#ifdef FIREWALLS_MORE
    DbgPrint(" XX = %ld , XY = %ld\n" , lXX , lXY );
    DbgPrint(" YX = %ld , YY = %ld\n" , lYX , lYY );
#endif // FIREWALLS_MORE

    if ( ( lXX >  0 && lXY == 0 ) &&
         ( lYX == 0 && lYY >  0 ) )
    {

    // We have to Rotate bitmap image to 0 degree

    // Compute X Y scaling factor

         vComputeRotatedXform( pptlScale , lXX , lYY );
         return( 0L );
    }
    else if ( ( lXX == 0 && lXY <  0 ) &&
              ( lYX >  0 && lYY == 0 ) )
    {
         vComputeRotatedXform( pptlScale , lXY , lYX );
         return( 900L );
    }
    else if ( ( lXX <  0 && lXY == 0 ) &&
              ( lYX == 0 && lYY <  0 ) )
    {
         vComputeRotatedXform( pptlScale , lXX , lYY );
         return( 1800L );
    }
    else if ( ( lXX == 0 && lXY >  0 ) &&
              ( lYX <  0 && lYY == 0 ) )
    {
         vComputeRotatedXform( pptlScale , lXY , lYX );
         return( 2700L );
    }

    //
    // we are here because:
    // 1) we are asked to handle arbitrary rotation. ( this should not happen )
    // 2) lXX == lXY == lYX == lYY == 0
    //
    // we choose default transformation
    //

    vComputeRotatedXform( pptlScale , 1L , 1L );

#ifdef FIREWALLS_MORE
    WARNING("Bmfd:ulGetRatate():Use default transform ( ulRotate = 0 )\n");
#endif // FIREWALLS_MORE

    return( 0L );
}

#endif // FE_SB


#ifndef FE_SB // We use vComputeRotatedXform() instead of vInitXform()

/******************************Private*Routine*****************************\
* VOID vInitXform
*
* Initialize the coefficients of the transforms for the given font context.
* It also transforms and saves various measurements of the font in the
* context.
*
*  Mon 01-Feb-1993 -by- Bodin Dresevic [BodinD]
* update: changed it to return data into pptlScale
*
\**************************************************************************/



VOID vInitXform(POINTL * pptlScale , XFORMOBJ *pxo)
{
    EFLOAT    efloat;
    XFORM     xfm;

// Get the transform elements.

    XFORMOBJ_iGetXform(pxo, &xfm);

// Convert elements of the matrix from IEEE float to our EFLOAT.

    vEToEF(xfm.eM11, &efloat);

//  If we overflow set to the maximum scaling factor

    if( !bEFtoL( &efloat, &pptlScale->x ) )
        pptlScale->x = MAX_HORZ_SCALE;
    else
    {
    // Ignore the sign of the scale

        if( pptlScale->x == 0 )
        {
            pptlScale->x = 1;
        }
        else
        {
            if( pptlScale->x < 0 )
                pptlScale->x = -pptlScale->x;


            if( pptlScale->x > MAX_HORZ_SCALE )
                pptlScale->x = MAX_HORZ_SCALE;
        }
    }

    vEToEF(xfm.eM22, &efloat);

    if( !bEFtoL( &efloat, &pptlScale->y ) )
        pptlScale->y = MAX_VERT_SCALE;
    else
    {
    // Ignore the sign of the scale

        if( pptlScale->y == 0 )
        {
            pptlScale->y = 1;
        }
        else
        {
            if( pptlScale->y < 0 )
                pptlScale->y = -pptlScale->y;

            if( pptlScale->y > MAX_VERT_SCALE )
                pptlScale->y = MAX_VERT_SCALE;
        }

    }

}


#endif

/******************************Public*Routine******************************\
* BmfdOpenFontContext
*
* History:
*  19-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

HFC
BmfdOpenFontContext (
    FONTOBJ *pfo
    )
{
    PFONTFILE    pff;
    FACEINFO     *pfai;
    FONTCONTEXT  *pfc = (FONTCONTEXT *)NULL;
    PCVTFILEHDR  pcvtfh;
    ULONG        cxMax;
    ULONG        cjGlyphMax;
    POINTL       ptlScale;
    PVOID        pvView;
    COUNT        cjView;
    ULONG        cjfc = offsetof(FONTCONTEXT,ajStretchBuffer);
    FLONG        flStretch;
#ifdef FE_SB
    ULONG        cxMaxNoRotate;
    ULONG        cjGlyphMaxNoRotate;
    ULONG        cyMax;
    ULONG        ulRotate;
#endif // FE_SB

#ifdef DUMPCALL
    DbgPrint("\nBmfdOpenFontContext(");
    DbgPrint("\n    FONTOBJ *pfo = %-#8lx", pfo);
    DbgPrint("\n    )\n");
#endif

    if ( ((HFF) pfo->iFile) == HFF_INVALID)
        return(HFC_INVALID);

    pff = PFF((HFF) pfo->iFile);

    if ((pfo->iFace < 1L) || (pfo->iFace > pff->cFntRes)) // pfo->iFace values are 1 based
        return(HFC_INVALID);

    pfai = &pff->afai[pfo->iFace - 1];
    pcvtfh = &(pfai->cvtfh);

    if ((pfo->flFontType & FO_SIM_BOLD) && (pfai->pifi->fsSelection & FM_SEL_BOLD))
        return HFC_INVALID;
    if ((pfo->flFontType & FO_SIM_ITALIC) && (pfai->pifi->fsSelection & FM_SEL_ITALIC))
        return HFC_INVALID;

#ifdef FE_SB // BmfdOpenFontContext():Get Rotate and compute XY scaling

// get rotation ( 0 , 900 , 1800 or 2700 )
// And we compute horizontal and vertical scaling factors

    ulRotate = ulGetRotate( &ptlScale , FONTOBJ_pxoGetXform(pfo));

#else  // We compute horizontal and vertical scaling facter in above function.

// compute the horizontal and vertical scaling factors

    vInitXform(&ptlScale, FONTOBJ_pxoGetXform(pfo));

#endif


#ifdef FE_SB // BmfdOpenFontConText(): Compute cjGlyphMax

// Compute cjGlyphMax of Rotated font

    cjGlyphMaxNoRotate =
        cjGlyphDataSimulated(
            pfo,
            (ULONG)pcvtfh->usMaxWidth * ptlScale.x,
            (ULONG)pcvtfh->cy * ptlScale.y,
            &cxMaxNoRotate,
            0L);

// In Y axis, We do not have to consider font simulation.

    cyMax = (ULONG)pcvtfh->cy * ptlScale.y;

    if( ( ulRotate == 0L ) || ( ulRotate == 1800L ) )
    {

    // In the case of 0 or 180 degree.

        cjGlyphMax = cjGlyphMaxNoRotate;
        cxMax = cxMaxNoRotate;
    }
     else
    {

    // In the case of 90 or 270 degree.
    // Compute simulated and rotated cjGlyphMax.

        cjGlyphMax =
            cjGlyphDataSimulated(
                pfo,
                (ULONG)pcvtfh->usMaxWidth * ptlScale.x,
                (ULONG)pcvtfh->cy * ptlScale.y,
                NULL,
                ulRotate);

        cxMax = cyMax;
    }

#ifdef DBG_MORE
    DbgPrint("clGlyphMax - 0x%x\n",cjGlyphMax);
#endif

#else
    cjGlyphMax =
        cjGlyphDataSimulated(
            pfo,
            (ULONG)pcvtfh->usMaxWidth * ptlScale.x,
            (ULONG)pcvtfh->cy * ptlScale.y,
            &cxMax);
#endif

// init stretch flags

    flStretch = 0;
    if ((ptlScale.x != 1) || (ptlScale.y != 1))
    {
#ifdef FE_SB // BmfdOpenFontContext() Adjust stretch buffer
        ULONG cjScan = CJ_SCAN(cxMaxNoRotate);
#else
        ULONG cjScan = CJ_SCAN(cxMax); // cj of the stretch buffer
#endif

        flStretch |= FC_DO_STRETCH;

        if (cjScan > CJ_STRETCH) // will use the one at the bottom of FC
        {
            cjfc += cjScan;
            flStretch |= FC_STRETCH_WIDE;
        }
    }

// allocate memory for the font context and get the pointer to font context
// NOTE THAT WE ARE NOT TOUCHING THE MEMORY MAPPED FILE AFTER WE ALLOCATE MEMORY
// IN THIS ROUTINE. GOOD CONSEQUENCE OF THIS IS THAT NO SPECIAL CLEAN UP
// CODE IS NECESSARY TO FREE THAT MEMORY, IT WILL GET CLEANED WHEN
// CloseFontContext is called [bodind]

    if (!(pfc = PFC(hfcAlloc(cjfc))))
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(HFC_INVALID);
    }

    pfc->ident  = ID_FONTCONTEXT;

// state that the hff passed to this function is the FF selected in
// this font context

    pfc->hff        = (HFF) pfo->iFile;
    pfc->pfai       = pfai;
    pfc->flFontType = pfo->flFontType;
    pfc->ptlScale   = ptlScale;
    pfc->flStretch  = flStretch;
    pfc->cxMax      = cxMax;
    pfc->cjGlyphMax = cjGlyphMax;
#ifdef FE_SB // BmfdOpenFontContext() keep rotation degree in FONTCONTEXT
    pfc->ulRotate   = ulRotate;
#endif // FE_SB

// increase the reference count of the font file
// ONLY AFTER WE ARE SURE THAT WE CAN NOT FAIL ANY MORE
// make sure that another thread is not doing it at the same time
// opening another context off of the same fontfile pff

    EngAcquireSemaphore(ghsemBMFD);

    // if this is the first font context corresponding to this font file
    // and then we have to remap file to memory and make sure the pointers
    // to FNT resources are updated accordingly

    if (pff->cRef == 0)
    {
        INT  i;

        if (!EngMapFontFileFD(pff->iFile, (PULONG *) &pvView, &cjView))
        {
            WARNING("BMFD!somebody removed that bm font file!!!\n");

            EngReleaseSemaphore(ghsemBMFD);
            VFREEMEM(pfc);
            return HFC_INVALID;
        }

        for (i = 0; i < (INT)pff->cFntRes; i++)
        {
            pff->afai[i].re.pvResData = (PVOID) (
                (BYTE*)pvView + pff->afai[i].re.dpResData
                );
        }
    }

// now can not fail, update cRef

    (pff->cRef)++;
    EngReleaseSemaphore(ghsemBMFD);

    return((HFC)pfc);
}


/******************************Public*Routine******************************\
* BmfdDestroyFont
*
* Driver can release all resources associated with this font realization
* (embodied in the FONTOBJ).
*
* History:
*  30-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
BmfdDestroyFont (
    FONTOBJ *pfo
    )
{
//
// For the bitmap font driver, this is simply closing the font context.
// We cleverly store the font context handle in the FONTOBJ pvProducer
// field.
//

// This pvProducer could be null if exception occured while
// trying to create fc

    if (pfo->pvProducer)
    {
        BmfdCloseFontContext((HFC) pfo->pvProducer);
        pfo->pvProducer = NULL;
    }
}


/******************************Public*Routine******************************\
* BmfdCloseFontContext
*
* History:
*  19-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
BmfdCloseFontContext (
    HFC hfc
    )
{
    PFONTFILE    pff;
    BOOL bRet;

    if (hfc != HFC_INVALID)
    {
        //
        // get the handle of the font file that is selected into this FONTCONTEXT
        // get the pointer to the FONTFILE
        //

        pff = PFF(PFC(hfc)->hff);

        // decrement the reference count for the corresponding FONTFILE
        // make sure that another thread is not doing it at the same time
        // closing  another context off of the same fontfile pff

        EngAcquireSemaphore(ghsemBMFD);

        if (pff->cRef > 0L)
        {
            (pff->cRef)--;

            //
            // if this file is temporarily going out of use, unmap it
            //

            if (pff->cRef == 0)
            {
                if (!(pff->fl & FF_EXCEPTION_IN_PAGE_ERROR))
                {
                // if FF_EXCEPTION_IN_PAGE_ERROR is set
                // the file should have been unmapped
                // in vBmfdMarkFontGone function

                    EngUnmapFontFileFD(pff->iFile);
                }
                pff->fl &= ~FF_EXCEPTION_IN_PAGE_ERROR;
            }


            // free the memory associated with hfc

            VFREEMEM(hfc);

            bRet = TRUE;
        }
        else
        {
            WARNING("BmfdCloseFontContext: cRef <= 0\n");
            bRet = FALSE;
        }

        EngReleaseSemaphore(ghsemBMFD);
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\bmfd\fdquery.c ===
/******************************Module*Header*******************************\
* Module Name: fdquery.c
*
* (Brief description)
*
* Created: 08-Nov-1990 11:57:35
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/
#include "fd.h"

ULONG
cjBmfdDeviceMetrics (
    PFONTCONTEXT     pfc,
    FD_DEVICEMETRICS *pdevm
    );

VOID
vStretchCvtToBitmap
(
    GLYPHBITS *pgb,
    PBYTE pjBitmap,     // bitmap in *.fnt form
    ULONG cx,           // unscaled width
    ULONG cy,           // unscaled height
    ULONG yBaseline,
    PBYTE pjLineBuffer, // preallocated buffer for use by stretch routines
    ULONG cxScale,      // horizontal scaling factor
    ULONG cyScale,      // vertical scaling factor
    ULONG flSim         // simulation flags
);

#ifdef FE_SB // Rotation
VOID
vFill_RotateGLYPHDATA (
    GLYPHDATA *pDistinationGlyphData,
    PVOID      SourceGLYPHBITS,
    PVOID      DistinationGLYPHBITS,
    UINT       RotateDegree
    );
#endif

/******************************Public*Routine******************************\
* BmfdQueryFont
*
* Returns:
*   Pointer to IFIMETRICS.  Returns NULL if an error occurs.
*
* History:
*  30-Aug-1992 -by- Gilman Wong [gilmanw]
* IFI/DDI merge.
*
*  19-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

PIFIMETRICS
BmfdQueryFont (
    DHPDEV dhpdev,
    HFF    hff,
    ULONG  iFace,
    ULONG_PTR  *pid
    )
{
    FACEINFO   *pfai;

    DONTUSE(dhpdev);
    DONTUSE(pid);

//
// Validate handle.
//
    if (hff == HFF_INVALID)
        return (PIFIMETRICS) NULL;

//
// We assume the iFace is within range.
//
    ASSERTGDI(
        (iFace >= 1L) && (iFace <= PFF(hff)->cFntRes),
        "gdisrv!BmfdQueryFont: iFace out of range\n"
        );

//
// Get ptr to the appropriate FACEDATA struct, take into account that
// iFace values are 1 based.
//
    pfai = &PFF(hff)->afai[iFace - 1];

//
// Return the pointer to IFIMETRICS.
//
    return pfai->pifi;
}


/******************************Public*Routine******************************\
* BmfdQueryFontTree
*
* This function returns pointers to per-face information.
*
* Parameters:
*
*   dhpdev      Not used.
*
*   hff         Handle to a font file.
*
*   iFace       Index of a face in the font file.
*
*   iMode       This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFT_LIGATURES -- returns a pointer to the ligature map.
*
*       QFT_KERNPAIRS -- return a pointer to the kerning pair table.
*
*       QFT_GLYPHSET  -- return a pointer to the WC->HGLYPH mapping table.
*
*   pid         Not used.
*
* Returns:
a   Returns a pointer to the requested data.  This data will not change
*   until BmfdFree is called on the pointer.  Caller must not attempt to
*   modify the data.  NULL is returned if an error occurs.
*
* History:
*  30-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PVOID
BmfdQueryFontTree (
    DHPDEV  dhpdev,
    HFF     hff,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR   *pid
    )
{
    FACEINFO   *pfai;

    DONTUSE(dhpdev);
    DONTUSE(pid);

//
// Validate parameters.
//
    if (hff == HFF_INVALID)
        return ((PVOID) NULL);

    // Note: iFace values are index-1 based.

    if ((iFace < 1L) || (iFace > PFF(hff)->cFntRes))
    {
    RETURN("gdisrv!BmfdQueryFontTree()\n", (PVOID) NULL);
    }

//
// Which mode?
//
    switch (iMode)
    {
    case QFT_LIGATURES:
    case QFT_KERNPAIRS:

    //
    // There are no ligatures or kerning pairs for the bitmap fonts,
    // therefore we return NULL
    //
        return ((PVOID) NULL);

    case QFT_GLYPHSET:

    //
    // Find glyphset structure corresponding to this iFace:
    //
        pfai = &PFF(hff)->afai[iFace - 1];

        return ((PVOID) &pfai->pcp->gset);

    default:

    //
    // Should never get here.
    //
    RIP("gdisrv!BmfdQueryFontTree(): unknown iMode\n");
        return ((PVOID) NULL);
    }
}

/******************************Public*Routine******************************\
*
* BOOL bReconnectBmfdFont(FONTFILE *pff)
*
*
* Effects: If the file is marked gone, we try to reconnect and see if we can
*          use it again. We clear the exception bit so that the system will
*          be able to use this font again.
*
* History:
*  17-Aug-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL bReconnectBmfdFont(FONTFILE *pff)
{
    INT i;
    PVOID pvView;
    COUNT cjView;

    EngAcquireSemaphore(ghsemBMFD);
    if (pff->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
        if (!EngMapFontFileFD(pff->iFile, (PULONG*) &pvView, &cjView))
        {
            WARNING("BMFD! can not reconnect this bm font file!!!\n");
            EngReleaseSemaphore(ghsemBMFD);
            return FALSE;
        }

        for (i = 0; i < (INT)pff->cFntRes; i++)
        {
            pff->afai[i].re.pvResData = (PVOID) (
                (BYTE*)pvView + pff->afai[i].re.dpResData
                );
        }

    // everything is fine again, clear the bit

        pff->fl &= ~FF_EXCEPTION_IN_PAGE_ERROR;
    }
    EngReleaseSemaphore(ghsemBMFD);

    return TRUE;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vBmfdScrubGLYPHBITS
*
* Routine Description:
*
*   This procedure will mask off the last byte of each row so that there
*   are no pixels set outside the boundary of the glyph. This problem
*   has been detected in a Bitstream font named ncd0018.fon.
*   This particular font is in the form of a 32-bit resource.
*   The problem came to light because the ATI driver relies
*   on the fact that the glyphs are "scrubbed" and contain no
*   extraneous bits, even outside the glyph boundary.
*
* Arguments:
*
*   pGb - a pointer to a GLYPHBITS structure
*
* Called by:
*
*   BmfdQueryFontData
*
* Return Value:
*
*   None.
*
\**************************************************************************/

void vBmfdScrubGLYPHBITS(GLYPHBITS *pGb)
{
    int dp;         // number of bytes in each scan
    int cx;         // number of pixels per row
    BYTE jMask;     // mask for last byte of each row;
    BYTE *pj;       // pointer to last byte of row;
    BYTE *pjLast;   // sentinel pointer
    static BYTE ajMonoMask[8] = {0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe};

    cx = pGb->sizlBitmap.cx;
    if ( jMask = ajMonoMask[cx & 7] )
    {
        dp = (cx + 7) / 8;
        pj = pGb->aj + dp - 1;
        pjLast = pj + dp * pGb->sizlBitmap.cy;
        for ( ; pj < pjLast; pj += dp )
        {
            *pj &= jMask;
        }
    }
}

/******************************Public*Routine******************************\
* BmfdQueryFontData
*
*   pfo         Pointer to a FONTOBJ.
*
*   iMode       This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFD_GLYPH           -- return glyph metrics only
*
*       QFD_GLYPHANDBITMAP  -- return glyph metrics and bitmap
*
*       QFD_GLYPHANDOUTLINE -- return glyph metrics and outline
*
*       QFD_MAXEXTENTS      -- return FD_DEVICEMETRICS structure
*
*       QFD_MAXGLYPHBITMAP  -- return size of largest glyph AND its metrics
*
*   cData       Count of data items in the pvIn buffer.
*
*   pvIn        An array of glyph handles.
*
*   pvOut       Output buffer.
*
* Returns:
*   If mode is QFD_MAXGLYPHBITMAP, then size of glyph metrics plus
*   largest bitmap is returned.
*
*   Otherwise, if pvOut is NULL, function will return size of the buffer
*   needed to copy the data requested; else, the function will return the
*   number of bytes written.
*
*   FD_ERROR is returned if an error occurs.
*
* History:
*  30-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.  Contructed from pieces of BodinD's original
* BmfdQueryGlyphBitmap() and BmfdQueryOutline() functions.
\**************************************************************************/

LONG
BmfdQueryFontData (
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH  hg,
    GLYPHDATA *pgd,
    PVOID   pv,
    ULONG   cjSize
    )
{
    PFONTCONTEXT pfc;
    LONG         cjGlyphData = 0;
    LONG         cjAllData = 0;
    PCVTFILEHDR  pcvtfh;
    PBYTE        pjBitmap;  // raw bitmap in the resource file
    ULONG        cxNoSim;   // bm width in pels before simulations
    FWORD        sAscent;
#ifdef FE_SB // BmfdQueryFontData()
    PVOID        pvDst = NULL;
    LONG         cjGlyphDataNoRotate;
#endif // FE_SB

// The net connection died on us, but maybe it is alive again:

    if (!bReconnectBmfdFont(PFF(pfo->iFile)))
    {
        WARNING("bmfd!bmfdQueryFontData: this file is gone\n");
        return FD_ERROR;
    }

// If pfo->pvProducer is NULL, then we need to open a font context.
//
    if ( pfo->pvProducer == (PVOID) NULL )
        pfo->pvProducer = (PVOID) BmfdOpenFontContext(pfo);

    pfc = PFC(pfo->pvProducer);

    if ( pfc == (PFONTCONTEXT) NULL )
    {
        WARNING("gdisrv!bmfdQueryFontData(): cannot create font context\n");
        return FD_ERROR;
    }

// What mode?

    switch (iMode)
    {

    case QFD_GLYPHANDBITMAP:

    //
    // This code is left all inline for better performance.
    //
        pcvtfh = &(pfc->pfai->cvtfh);
        sAscent = pfc->pfai->pifi->fwdWinAscender;

        pjBitmap = pjRawBitmap(hg, pcvtfh, &pfc->pfai->re, &cxNoSim);

#ifdef FE_SB // BmfdQueryFontDate(): Compute size of RASTERGLYPH for ROTATION

    //
    // Compute the size of the RASTERGLYPH. ( GLYPHBITS structure size )
    //

    // Compute No Rotated GLYPHBITS size.

        cjGlyphDataNoRotate = cjGlyphDataSimulated (
                                pfo,
                                cxNoSim * pfc->ptlScale.x,
                                pcvtfh->cy * pfc->ptlScale.y,
                                (PULONG) NULL,
                                0L
                                );

    // Compute Rotated GLYPHBITS size.

        switch( pfc->ulRotate )
        {
            case 0L    :
            case 1800L :

                cjGlyphData = cjGlyphDataNoRotate;

                break;

            case 900L  :
            case 2700L :

                cjGlyphData = cjGlyphDataSimulated (
                                pfo,
                                cxNoSim * pfc->ptlScale.x,
                                pcvtfh->cy * pfc->ptlScale.y,
                                (PULONG) NULL,
                                pfc->ulRotate
                                );


                break;
        }

    //
    // Allocate Buffer for Rotation
    //

        if( pfc->ulRotate != 0L && pv != NULL )
        {

        //  We have to rotate this bitmap. below here , we keep data in temp Buffer
        // And will write this data into pv ,when rotate bitmap.
        //  We can't use original pv directly. Because original pv size is computed
        // for Rotated bitmap. If we use this. it may causes access violation.
        //              hideyukn 08-Feb-1993

        // Keep Master pv
            pvDst = pv;

        // Allocate New pv
            pv    = (PVOID)EngAllocMem(0, cjGlyphDataNoRotate, 'dfmB');

            if( pv == NULL )
            {
                 WARNING("BMFD:LocalAlloc for No Rotated bitmap is fail\n");
                 return( FD_ERROR );
            }

        }
        else
        {

        // This Routine is for at ulRotate != 0 && pv == NULL
        //
        // If User want to only GLYPHDATA , We do not do anything for glyphbits
        // at vFill_RotateGLYPHDATA
        //
        // pvDst is only used in case of ulRotate is Non-Zero
                 ;
        }
#else
    //
    // Compute the size of the RASTERGLYPH.
    //
        cjGlyphData = cjGlyphDataSimulated (
                            pfo,
                            cxNoSim * pfc->ptlScale.x,
                            pcvtfh->cy * pfc->ptlScale.y,
                            (PULONG) NULL
                            );
#endif

#ifdef FE_SB
    // !!!
    // !!! Following vComputeSimulatedGLYPHDATA function will set up GLYPHDATA
    // !!! structure with NO Rotation. If We want to Rotate bitmap , We have to
    // !!! re-setup this GLYPHDATA structure. Pls look into end of this function.
    // !!! But No need to ratate bitmap , We don't need to re-set up it.
    // !!!                          hideyukn 08-Feb-1993
    // !!!
#endif // FE_SB

    //
    // Fill in the GLYPHDATA portion (metrics) of the RASTERGLYPH.
    //
        if ( pgd != (GLYPHDATA *)NULL )
        {
            vComputeSimulatedGLYPHDATA (
                pgd,
                pjBitmap,
                cxNoSim,
                pcvtfh->cy,
                (ULONG)sAscent,
                pfc->ptlScale.x,
                pfc->ptlScale.y,
                pfo
                );
            pgd->hg = hg;
        }

    //
    // Fill in the bitmap portion of the RASTERGLYPH.
    //
        if ( pv != NULL )
        {
            if (cxNoSim == 0)
            {
            // stolen from ttfd:

                GLYPHBITS *pgb = (GLYPHBITS *)pv;

                pgb->ptlOrigin.x = 0;
                pgb->ptlOrigin.y = -sAscent;

                pgb->sizlBitmap.cx = 1;    // cheating
                pgb->sizlBitmap.cy = 1;    // cheating


                *((ULONG *)pgb->aj) = 0;  // fill in a blank 1x1 dib
            }
            else
            {

                if (pfc->flStretch & FC_DO_STRETCH)
                {
                    BYTE ajStretchBuffer[CJ_STRETCH];
                    if (pfc->flStretch & FC_STRETCH_WIDE)
                    {
                        EngAcquireSemaphore(ghsemBMFD);

                    // need to put try/except here so as to release the semaphore
                    // in case the file disappeares [bodind]

#ifndef BMFD_NO_TRY_EXCEPT
                        try
                        {
#endif
                            vStretchCvtToBitmap(
                                pv,
                                pjBitmap,
                                cxNoSim                 ,
                                pcvtfh->cy              ,
                                (ULONG)sAscent ,
                                pfc->ajStretchBuffer,
                                pfc->ptlScale.x,
                                pfc->ptlScale.y,
                                pfo->flFontType & (FO_SIM_BOLD | FO_SIM_ITALIC));
#ifndef BMFD_NO_TRY_EXCEPT
                        }
                        except (EXCEPTION_EXECUTE_HANDLER)
                        {
                            WARNING("bmfd! exception while stretching a glyph\n");
                            vBmfdMarkFontGone(
                                (FONTFILE *)pfc->hff,
                                GetExceptionCode()
                                );
                        }
#endif

                        EngReleaseSemaphore(ghsemBMFD);
                    }
                    else
                    {
                    // we are protected by higher level try/excepts

                        vStretchCvtToBitmap(
                            pv,
                            pjBitmap,
                            cxNoSim                 ,
                            pcvtfh->cy              ,
                            (ULONG)sAscent ,
                            ajStretchBuffer,
                            pfc->ptlScale.x,
                            pfc->ptlScale.y,
                            pfo->flFontType & (FO_SIM_BOLD | FO_SIM_ITALIC));
                    }
                }
                else
                {
                    switch (pfo->flFontType & (FO_SIM_BOLD | FO_SIM_ITALIC))
                    {
                    case 0:

                        vCvtToBmp(
                            pv                      ,
                            pgd                     ,
                            pjBitmap                ,
                            cxNoSim                 ,
                            pcvtfh->cy              ,
                            (ULONG)sAscent
                            );

                        break;

                    case FO_SIM_BOLD:

                        vCvtToBoldBmp(
                            pv                      ,
                            pgd                     ,
                            pjBitmap                ,
                            cxNoSim                 ,
                            pcvtfh->cy              ,
                            (ULONG)sAscent
                            );

                        break;

                    case FO_SIM_ITALIC:

                        vCvtToItalicBmp(
                            pv                      ,
                            pgd                     ,
                            pjBitmap                ,
                            cxNoSim                 ,
                            pcvtfh->cy              ,
                            (ULONG)sAscent
                            );

                        break;

                    case (FO_SIM_BOLD | FO_SIM_ITALIC):

                        vCvtToBoldItalicBmp(
                            pv                      ,
                            pgd                     ,
                            pjBitmap                ,
                            cxNoSim                 ,
                            pcvtfh->cy              ,
                            (ULONG)sAscent
                            );

                        break;

                    default:
                        RIP("BMFD!WRONG SIMULATION REQUEST\n");

                    }
                }
            }
            // Record the pointer to the RASTERGLYPH in the pointer table.

            if ( pgd != NULL )
            {
                pgd->gdf.pgb = (GLYPHBITS *)pv;
            }

            vBmfdScrubGLYPHBITS((GLYPHBITS*)pv);
        }

#ifdef FE_SB // BmfdQueryFontData(): Set up GLYPHDATA and GLYPHBITS for Rotation

        // Check rotation

        if( pfc->ulRotate != 0L )
        {

        // Rotate GLYPHDATA and GLYPHBITS

        // if pv and pvDst is NULL , We only set up GLYPHDATA only
        // and if pgd is NULL , we only set up pvDst

            if (pvDst)
                memset(pvDst, 0, cjSize);

            vFill_RotateGLYPHDATA(
                    pgd,                     // GLYPHDATA *pDistinationGlyphData
                    pv,                      // PVOID      SourceGLYPHBITS
                    pvDst,                   // PVOID      DistinationGLYPHBITS
                    pfc->ulRotate            // UINT       Rotate degree
                    );

        // Free GLYPHBITS tenmorary buffer

        // !!! Now pvDst is Original buffer from GRE.

           if( pv != NULL ) VFREEMEM( pv );
        }

#endif // FE_SB
        return cjGlyphData;

    case QFD_MAXEXTENTS:
    //
    // If buffer NULL, return size.
    //
        if ( pv == (PVOID) NULL )
            return (sizeof(FD_DEVICEMETRICS));

    //
    // Otherwise, copy the data structure.
    //
        else
            return cjBmfdDeviceMetrics(pfc, (FD_DEVICEMETRICS *) pv);

    case QFD_GLYPHANDOUTLINE:
    default:

        WARNING("gdisrv!BmfdQueryFontData(): unsupported mode\n");
        return FD_ERROR;
    }
}

/******************************Public*Routine******************************\
* BmfdQueryAdvanceWidths                                                   *
*                                                                          *
* Queries the advance widths for a range of glyphs.                        *
*                                                                          *
*  Sat 16-Jan-1993 22:28:41 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.  The code is repeated to avoid multiplies wherever possible.   *
* The crazy loop unrolling cuts the time of this routine by 25%.           *
\**************************************************************************/

typedef struct _TYPE2TABLE
{
    USHORT  cx;
    USHORT  offData;
} TYPE2TABLE;

typedef struct _TYPE3TABLE
{
    USHORT  cx;
    USHORT  offDataLo;
    USHORT  offDataHi;
} TYPE3TABLE;

BOOL BmfdQueryAdvanceWidths
(
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
)
{
    USHORT      *psWidths = (USHORT *) plWidths;   // True for the cases we handle.

    FONTCONTEXT *pfc       ;
    FACEINFO    *pfai      ;
    CVTFILEHDR  *pcvtfh    ;
    BYTE        *pjTable   ;
    USHORT       xScale    ;
    USHORT       cxExtra   ;
    USHORT       cx;

    if (!bReconnectBmfdFont(PFF(pfo->iFile)))
    {
        WARNING("bmfd!bmfdQueryAdvanceWidths: this file is gone\n");
        return FD_ERROR;
    }

// If pfo->pvProducer is NULL, then we need to open a font context.
//
    if ( pfo->pvProducer == (PVOID) NULL )
        pfo->pvProducer = (PVOID) BmfdOpenFontContext(pfo);

    pfc = PFC(pfo->pvProducer);

    if ( pfc == (PFONTCONTEXT) NULL )
    {
        WARNING("bmfd!bmfdQueryAdvanceWidths: cannot create font context\n");
        return FD_ERROR;
    }

    pfai    = pfc->pfai;
    pcvtfh  = &(pfai->cvtfh);
    pjTable = (BYTE *) pfai->re.pvResData + pcvtfh->dpOffsetTable;
    xScale  = (USHORT) (pfc->ptlScale.x << 4);
    cxExtra = (pfc->flFontType & FO_SIM_BOLD) ? 16 : 0;

    if (iMode > QAW_GETEASYWIDTHS)
        return(GDI_ERROR);

// Retrieve widths from type 2 tables.

    if (pcvtfh->iVersion == 0x00000200)
    {
        TYPE2TABLE *p2t = (TYPE2TABLE *) pjTable;

        if (xScale == 16)
        {
            while (cGlyphs > 3)
            {
                cx = p2t[phg[0]].cx;
                psWidths[0] = (cx << 4) + cxExtra;
                cx = p2t[phg[1]].cx;
                psWidths[1] = (cx << 4) + cxExtra;
                cx = p2t[phg[2]].cx;
                psWidths[2] = (cx << 4) + cxExtra;
                cx = p2t[phg[3]].cx;
                psWidths[3] = (cx << 4) + cxExtra;

                phg += 4; psWidths += 4; cGlyphs -= 4;
            }

            while (cGlyphs)
            {
                cx = p2t[*phg].cx;
                *psWidths = (cx << 4) + cxExtra;
                phg++,psWidths++,cGlyphs--;
            }
        }
        else
        {
            while (cGlyphs)
            {
                cx = p2t[*phg].cx;
                *psWidths = (cx * xScale) + cxExtra;
                phg++,psWidths++,cGlyphs--;
            }
        }
    }

// Retrieve widths from type 3 tables.

    else
    {
        TYPE3TABLE *p3t = (TYPE3TABLE *) pjTable;

        if (xScale == 16)
        {
            while (cGlyphs > 3)
            {
                cx = p3t[phg[0]].cx;
                psWidths[0] = (cx << 4) + cxExtra;
                cx = p3t[phg[1]].cx;
                psWidths[1] = (cx << 4) + cxExtra;
                cx = p3t[phg[2]].cx;
                psWidths[2] = (cx << 4) + cxExtra;
                cx = p3t[phg[3]].cx;
                psWidths[3] = (cx << 4) + cxExtra;
                phg += 4; psWidths += 4; cGlyphs -= 4;
            }

            while (cGlyphs)
            {
                cx = p3t[*phg].cx;
                *psWidths = (cx << 4) + cxExtra;
                phg++,psWidths++,cGlyphs--;
            }
        }
        else
        {
            while (cGlyphs)
            {
                cx = p3t[*phg].cx;
                *psWidths = (cx * xScale) + cxExtra;
                phg++,psWidths++,cGlyphs--;
            }
        }
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* BmfdQueryFontFile
*
* A function to query per font file information.
*
* Parameters:
*
*   hff         Handle to a font file.
*
*   ulMode      This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFF_DESCRIPTION -- copies a UNICODE string in the buffer
*                          that describes the contents of the font file.
*
*       QFF_NUMFACES   -- returns number of faces in the font file.
*
*   cjBuf       Maximum number of BYTEs to copy into the buffer.  The
*               driver will not copy more than this many BYTEs.
*
*               This should be zero if pulBuf is NULL.
*
*               This parameter is not used in QFF_NUMFACES mode.
*
*   pulBuf      Pointer to the buffer to receive the data
*               If this is NULL, then the required buffer size
*               is returned as a count of BYTEs.  Notice that this
*               is a PULONG, to enforce 32-bit data alignment.
*
*               This parameter is not used in QFF_NUMFACES mode.
*
* Returns:
*
*   If mode is QFF_DESCRIPTION, then the number of BYTEs copied into
*   the buffer is returned by the function.  If pulBuf is NULL,
*   then the required buffer size (as a count of BYTEs) is returned.
*
*   If mode is QFF_NUMFACES, then number of faces in font file is returned.
*
*   FD_ERROR is returned if an error occurs.
*
* History:
*  30-Aug-1992 -by- Gilman Wong [gilmanw]
* Added QFF_NUMFACES mode (IFI/DDI merge).
*
*  Fri 20-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG
BmfdQueryFontFile (
    HFF     hff,        // handle to font file
    ULONG   ulMode,     // type of query
    ULONG   cjBuf,      // size of buffer (in BYTEs)
    PULONG  pulBuf      // return buffer (NULL if requesting size of data)
    )
{
// Verify the HFF.

    if (hff == HFF_INVALID)
    {
    WARNING("bmfd!BmfdQueryFontFile(): invalid HFF\n");
        return(FD_ERROR);
    }

//
// Which mode?.
//
    switch(ulMode)
    {
    case QFF_DESCRIPTION:
    //
    // If present, return the description string.
    //
        if ( PFF(hff)->cjDescription != 0 )
        {
        //
        // If there is a buffer, copy the data.
        //
            if ( pulBuf != (PULONG) NULL )
            {
            //
            // Is buffer big enough?
            //
                if ( cjBuf < PFF(hff)->cjDescription )
                {
                    WARNING("bmfd!BmfdQueryFontFile(): buffer too small for string\n");
                    return (FD_ERROR);
                }
                else
                {
                    RtlCopyMemory((PVOID) pulBuf,
                                  ((PBYTE) PFF(hff)) + PFF(hff)->dpwszDescription,
                                  PFF(hff)->cjDescription);
                }
            }

            return (LONG) PFF(hff)->cjDescription;
        }

    //
    // Otherwise, substitute the facename.
    //
        else
        {
        //
        // There is no description string associated with the font therefore we
        // substitue the facename of the first font in the font file.
        //
            IFIMETRICS *pifi         = PFF(hff)->afai[0].pifi;
            PWSZ        pwszFacename = (PWSZ)((PBYTE) pifi + pifi->dpwszFaceName);
            ULONG       cjFacename   = (wcslen(pwszFacename) + 1) * sizeof(WCHAR);

        //
        // If there is a buffer, copy to it.
        //
            if ( pulBuf != (PULONG) NULL )
            {
            //
            // Is buffer big enough?
            //
                if ( cjBuf < cjFacename )
                {
                    WARNING("bmfd!BmfdQueryFontFile(): buffer too small for face\n");
                    return (FD_ERROR);
                }
                else
                {
                    RtlCopyMemory((PVOID) pulBuf,
                                  (PVOID) pwszFacename,
                                  cjFacename);
                }
            }
            return ((LONG) cjFacename);
        }

    case QFF_NUMFACES:
        return PFF(hff)->cFntRes;

    default:
        WARNING("gdisrv!BmfdQueryFontFile(): unknown mode\n");
        return FD_ERROR;
    }

}


/******************************Public*Routine******************************\
* cjBmfdDeviceMetrics
*
*
* Effects:
*
* Warnings:
*
* History:
*  30-Aug-1992 -by- Gilman Wong [gilmanw]
* Stole it from BodinD's FdQueryFaceAttr() implementation.
\**************************************************************************/

ULONG
cjBmfdDeviceMetrics (
    PFONTCONTEXT     pfc,
    FD_DEVICEMETRICS *pdevm
    )
{
    PIFIMETRICS pifi;
    UINT xScale = pfc->ptlScale.x;
    UINT yScale = pfc->ptlScale.y;

// compute the accelerator flags for this font
// If this is a bitmap font where some of the glyphs have zero widths,
// we need to turn off all the accelerator flags

    if (pfc->pfai->cvtfh.fsFlags & FS_ZERO_WIDTH_GLYPHS)
    {
        pdevm->flRealizedType = 0;
    }
    else
    {
        pdevm->flRealizedType =
            (
            FDM_TYPE_BM_SIDE_CONST  |  // all char bitmaps have the same cy
            FDM_TYPE_CONST_BEARINGS |  // ac spaces for all chars the same,  not 0 necessarilly
            FDM_TYPE_MAXEXT_EQUAL_BM_SIDE
            );

    // the above flags are set regardless of the possible simulation performed on the face
    // the remaining two are only set if italicizing has not been done

        if ( !(pfc->flFontType & FO_SIM_ITALIC) )
        {
            pdevm->flRealizedType |=
                (FDM_TYPE_ZERO_BEARINGS | FDM_TYPE_CHAR_INC_EQUAL_BM_BASE);
        }
    }

    pifi = pfc->pfai->pifi;

#ifdef FE_SB // ROTATION:cjBmfdDeviceMetric(): set direction unit vectors

/**********************************************************************
  Coordinate    (0 degree)   (90 degree)   (180 degree)  (270 degree)
   System

     |(-)          A                 A
     |        Side |                 | Base
     |             |                 |         Base         Side
-----+----->X      +------>   <------+      <------+      +------>
(-)  |  (+)          Base       Side               |      |
     |                                         Side|      | Base
     |(+)                                          V      V
     Y
***********************************************************************/

    switch( pfc->ulRotate )
    {
    case 0L:

    // the direction unit vectors for all ANSI bitmap fonts are the
    // same. We do not even have to look to the font context:

        vLToE(&pdevm->pteBase.x, 1L);
        vLToE(&pdevm->pteBase.y, 0L);
        vLToE(&pdevm->pteSide.x, 0L);
        vLToE(&pdevm->pteSide.y, -1L);    // y axis points down

        pdevm->fxMaxAscender  = LTOFX((LONG)pifi->fwdWinAscender * yScale);
        pdevm->fxMaxDescender = LTOFX((LONG)pifi->fwdWinDescender * yScale );

        pdevm->ptlUnderline1.x = 0L;
        pdevm->ptlUnderline1.y = -(LONG)pifi->fwdUnderscorePosition * yScale;

        pdevm->ptlStrikeOut.x  =
            (pfc->flFontType & FO_SIM_ITALIC) ? (LONG)pifi->fwdStrikeoutPosition / 2 : 0;
        pdevm->ptlStrikeOut.y  = -(LONG)pifi->fwdStrikeoutPosition * yScale;

        pdevm->ptlULThickness.x = 0;
        pdevm->ptlULThickness.y = (LONG)pifi->fwdUnderscoreSize * yScale;

        pdevm->ptlSOThickness.x = 0;
        pdevm->ptlSOThickness.y = (LONG)pifi->fwdStrikeoutSize * yScale;

        break;

    case 900L:

    // the direction unit vectors for all ANSI bitmap fonts are the
    // same. We do not even have to look to the font context:

        vLToE(&pdevm->pteBase.x, 0L);
        vLToE(&pdevm->pteBase.y, -1L);
        vLToE(&pdevm->pteSide.x, -1L);
        vLToE(&pdevm->pteSide.y, 0L);


        pdevm->fxMaxAscender  = LTOFX((LONG)pifi->fwdWinAscender * yScale);
        pdevm->fxMaxDescender = LTOFX((LONG)pifi->fwdWinDescender * yScale );

        pdevm->ptlUnderline1.x = -(LONG)pifi->fwdUnderscorePosition * yScale;
        pdevm->ptlUnderline1.y = 0;

        pdevm->ptlStrikeOut.x  = -(LONG)pifi->fwdStrikeoutPosition * yScale;
        pdevm->ptlStrikeOut.y  =
            (pfc->flFontType & FO_SIM_ITALIC) ? -(LONG)pifi->fwdStrikeoutPosition / 2 : 0;

        pdevm->ptlULThickness.x = (LONG)pifi->fwdUnderscoreSize * yScale;
        pdevm->ptlULThickness.y = 0;

        pdevm->ptlSOThickness.x = (LONG)pifi->fwdStrikeoutSize * yScale;
        pdevm->ptlSOThickness.y = 0;

        break;

    case 1800L:

    // the direction unit vectors for all ANSI bitmap fonts are the
    // same. We do not even have to look to the font context:

        vLToE(&pdevm->pteBase.x, -1L);
        vLToE(&pdevm->pteBase.y, 0L);
        vLToE(&pdevm->pteSide.x, 0L);
        vLToE(&pdevm->pteSide.y, 1L);


        pdevm->fxMaxAscender  = LTOFX((LONG)pifi->fwdWinAscender * yScale);
        pdevm->fxMaxDescender = LTOFX((LONG)pifi->fwdWinDescender * yScale );

        pdevm->ptlUnderline1.x = 0L;
        pdevm->ptlUnderline1.y = (LONG)pifi->fwdUnderscorePosition * yScale;

        pdevm->ptlStrikeOut.x  =
            (pfc->flFontType & FO_SIM_ITALIC) ? -(LONG)pifi->fwdStrikeoutPosition / 2 : 0;
        pdevm->ptlStrikeOut.y  = pifi->fwdStrikeoutPosition * yScale;

        pdevm->ptlULThickness.x = 0;
        pdevm->ptlULThickness.y = (LONG)pifi->fwdUnderscoreSize * yScale;

        pdevm->ptlSOThickness.x = 0;
        pdevm->ptlSOThickness.y = (LONG)pifi->fwdStrikeoutSize * yScale;

        break;

    case 2700L:

    // the direction unit vectors for all ANSI bitmap fonts are the
    // same. We do not even have to look to the font context:

        vLToE(&pdevm->pteBase.x, 0L);
        vLToE(&pdevm->pteBase.y, 1L);
        vLToE(&pdevm->pteSide.x, 1L);
        vLToE(&pdevm->pteSide.y, 0L);

        pdevm->fxMaxAscender  = LTOFX((LONG)pifi->fwdWinAscender * yScale);
        pdevm->fxMaxDescender = LTOFX((LONG)pifi->fwdWinDescender * yScale );

        pdevm->ptlUnderline1.x = (LONG)pifi->fwdUnderscorePosition * yScale;
        pdevm->ptlUnderline1.y = 0L;

        pdevm->ptlStrikeOut.x  = (LONG)pifi->fwdStrikeoutPosition * yScale;
        pdevm->ptlStrikeOut.y  =
            (pfc->flFontType & FO_SIM_ITALIC) ? (LONG)pifi->fwdStrikeoutPosition / 2 : 0;

        pdevm->ptlULThickness.x = (LONG)pifi->fwdUnderscoreSize * yScale;
        pdevm->ptlULThickness.y = 0;

        pdevm->ptlSOThickness.x = (LONG)pifi->fwdStrikeoutSize * yScale;
        pdevm->ptlSOThickness.y = 0;

        break;

    default:

        break;
    }

#else

// the direction unit vectors for all ANSI bitmap fonts are the
// same. We do not even have to look to the font context:

    vLToE(&pdevm->pteBase.x, 1L);
    vLToE(&pdevm->pteBase.y, 0L);
    vLToE(&pdevm->pteSide.x, 0L);
    vLToE(&pdevm->pteSide.y, -1L);    // y axis points down

#endif // FE_SB

// Set the constant increment for a fixed pitch font.  Don't forget to
// take into account a bold simulation!

    pdevm->lD = 0;

    if ((pifi->flInfo & FM_INFO_CONSTANT_WIDTH) &&
        !(pfc->pfai->cvtfh.fsFlags & FS_ZERO_WIDTH_GLYPHS))
    {
        pdevm->lD = (LONG) pifi->fwdMaxCharInc * xScale;

        if (pfc->flFontType & FO_SIM_BOLD)
            pdevm->lD++;
    }

#ifndef FE_SB // cjBmfdDeviceMetric():

// for a bitmap font there is no difference between notional and device
// coords, so that the Ascender and Descender can be copied directly
// from PIFIMETRICS where these two numbers are in notional coords

    pdevm->fxMaxAscender  = LTOFX((LONG)pifi->fwdWinAscender * yScale);
    pdevm->fxMaxDescender = LTOFX((LONG)pifi->fwdWinDescender * yScale );

    pdevm->ptlUnderline1.x = 0L;
    pdevm->ptlUnderline1.y = - pifi->fwdUnderscorePosition * yScale;

    pdevm->ptlStrikeOut.y  = - pifi->fwdStrikeoutPosition * yScale;

    pdevm->ptlStrikeOut.x  =
        (pfc->flFontType & FO_SIM_ITALIC) ? (LONG)pifi->fwdStrikeoutPosition / 2 : 0;

    pdevm->ptlULThickness.x = 0;
    pdevm->ptlULThickness.y = (LONG)pifi->fwdUnderscoreSize * yScale;

    pdevm->ptlSOThickness.x = 0;
    pdevm->ptlSOThickness.y = (LONG)pifi->fwdStrikeoutSize * yScale;


// for a bitmap font there is no difference between notional and device
// coords, so that the Ascender and Descender can be copied directly
// from PIFIMETRICS where these two numbers are in notional coords

    pdevm->fxMaxAscender  = LTOFX((LONG)pifi->fwdWinAscender * yScale);
    pdevm->fxMaxDescender = LTOFX((LONG)pifi->fwdWinDescender * yScale );

    pdevm->ptlUnderline1.x = 0L;
    pdevm->ptlUnderline1.y = - pifi->fwdUnderscorePosition * yScale;

    pdevm->ptlStrikeOut.y  = - pifi->fwdStrikeoutPosition * yScale;

    pdevm->ptlStrikeOut.x  =
        (pfc->flFontType & FO_SIM_ITALIC) ? (LONG)pifi->fwdStrikeoutPosition / 2 : 0;

    pdevm->ptlULThickness.x = 0;
    pdevm->ptlULThickness.y = (LONG)pifi->fwdUnderscoreSize * yScale;

    pdevm->ptlSOThickness.x = 0;
    pdevm->ptlSOThickness.y = (LONG)pifi->fwdStrikeoutSize * yScale;

#endif // FE_SB

// max glyph bitmap width in pixels in x direction
// does not need to be multiplied by xScale, this has already been taken into
// account, see the code in fdfc.c:
//    cjGlyphMax =
//        cjGlyphDataSimulated(
//            pfo,
//            (ULONG)pcvtfh->usMaxWidth * ptlScale.x,
//            (ULONG)pcvtfh->cy * ptlScale.y,
//            &cxMax);
// [bodind]

    pdevm->cxMax = pfc->cxMax;

// new fields

    pdevm->cyMax      = pfc->cjGlyphMax / ((pfc->cxMax + 7) / 8);
    pdevm->cjGlyphMax = pfc->cjGlyphMax;


    return (sizeof(FD_DEVICEMETRICS));
}


#ifdef FE_SB // vFill_RotateGLYPHDATA()

#define CJ_DIB8_SCAN(cx) ((((cx) + 7) & ~7) >> 3)


/*
   BIT macro returns non zero ( if bitmap[x,y] is on) or zero (bitmap[x,y] is off).
   pb : bitmap
   w  : byte count per scan line
   x  : Xth bit in x direction
   y  : scan line

        x
       -------------------->
   y | *******************************
     | *******************************
     | *******************************
     V
*/

BYTE BitON[8] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
BYTE BitOFF[8] = { 0x7f, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xfd, 0xfe };
#define BIT(pb, w, x, y)  (*((PBYTE)(pb) + (w) * (y) + ((x)/8)) & (BitON[(x) & 7]))

/******************************************************************************\
*
* VOID vFill_RotateGLYPHDATA()
*
*
* History :
*
*  11-Feb-1992 (Thu) -by- Hideyuki Nagase [hideyukn]
* Wrote it.
*
\******************************************************************************/

VOID
vFill_RotateGLYPHDATA (
    GLYPHDATA *pDistGlyphData,
    PVOID      SrcGLYPHBITS,
    PVOID      DistGLYPHBITS,
    UINT       RotateDegree
    )
{
    GLYPHDATA  SrcGlyphData;
    ULONG      ulSrcBitmapSizeX , ulDistBitmapSizeX;
    ULONG      ulSrcBitmapSizeY , ulDistBitmapSizeY;
    GLYPHBITS *pSrcGlyphBits , *pDistGlyphBits;
    PBYTE      pbSrcBitmap , pbDistBitmap;
    UINT       x , y , k;
    UINT       cjScanSrc , cjScanDist;
    PBYTE      pb;

//  Now , in this point *pDistGlyphData contain No rotated GLYPHDATA
// Copy No rotate GLYPHDATA to Source Area . later we write back changed data to
// distination area.

//
// these field are defined as:
//
//   unit vector along the baseline -  fxD, fxA, fxAB
// or
//   unit vector in the ascent direction - fxInkTop, fxInkBottom
//
// Because baseline direction and ascent direction are rotated
// as ulRotate specifies, these fileds should be considered as
// rotation independent.
//

// Init Local value
// Set pointer to GLYPHBITS structure

    pSrcGlyphBits = (GLYPHBITS *)SrcGLYPHBITS;
    pDistGlyphBits = (GLYPHBITS *)DistGLYPHBITS;

    if( pDistGlyphData != NULL )
    {

    // Init Source GlyphData

        SrcGlyphData = *pDistGlyphData;

    // Record the pointer to GLYPHBITS in GLYPHDATA structure

        pDistGlyphData->gdf.pgb = pDistGlyphBits;
    }

// Check Rotation

    switch( RotateDegree )
    {
        case 0L :

            WARNING("BMFD:vFill_RotateGLYPHDATA():Why come here?\n");
            break;

        case 900L :

        if( pDistGlyphData != NULL )
        {

        // Setup GLYPHDATA structure

        //  x =  y;
        //  y = -x; !!!! HighPart include plus or minus flag

            pDistGlyphData->ptqD.x = SrcGlyphData.ptqD.y;
            pDistGlyphData->ptqD.y.HighPart = -(SrcGlyphData.ptqD.x.HighPart);
            pDistGlyphData->ptqD.y.LowPart = SrcGlyphData.ptqD.x.LowPart;

        // top = -rihgt ; bottom = -left ; right = bottom ; left = top

            pDistGlyphData->rclInk.top = -(SrcGlyphData.rclInk.right);
            pDistGlyphData->rclInk.bottom = -(SrcGlyphData.rclInk.left);
            pDistGlyphData->rclInk.right = SrcGlyphData.rclInk.bottom;
            pDistGlyphData->rclInk.left = SrcGlyphData.rclInk.top;

        }

        if( pSrcGlyphBits != NULL && pDistGlyphBits != NULL )
        {

        // Get Bitmap size

            ulSrcBitmapSizeX = pSrcGlyphBits->sizlBitmap.cx;
            ulSrcBitmapSizeY = pSrcGlyphBits->sizlBitmap.cy;

        // Get the pointer to Bitmap images

            pbSrcBitmap = (PBYTE)pSrcGlyphBits->aj;
            pbDistBitmap = (PBYTE)pDistGlyphBits->aj;

        // Set Distination Bitmap Size

            ulDistBitmapSizeX = ulSrcBitmapSizeY;
            ulDistBitmapSizeY = ulSrcBitmapSizeX;

        // Setup GLYPHBITS stuff

            pDistGlyphBits->ptlOrigin.x = pSrcGlyphBits->ptlOrigin.y;
            pDistGlyphBits->ptlOrigin.y = -(LONG)(ulSrcBitmapSizeX);

            pDistGlyphBits->sizlBitmap.cx = pSrcGlyphBits->sizlBitmap.cy;
            pDistGlyphBits->sizlBitmap.cy = pSrcGlyphBits->sizlBitmap.cx;

        // Rotate bitmap inage

            cjScanSrc = CJ_DIB8_SCAN( ulSrcBitmapSizeX );
            cjScanDist = CJ_DIB8_SCAN( ulDistBitmapSizeX );

        // we need to clear the dst buffer because the S3 driver expects
        // extra stuff on the edges to be zeroed out

            for ( y = 0; y < ulDistBitmapSizeY ; y++ )
            {
                for ( x= 0 , pb = pbDistBitmap + cjScanDist * y ;
                      x < ulDistBitmapSizeX ;
                      x++ )
                {
                    k = x & 7; // k is from 0 to 7;

                    if ( BIT( pbSrcBitmap , cjScanSrc,
                              ulDistBitmapSizeY - y - 1 ,
                              x
                            )
                       )
                         *pb |= (BitON[ k ] );
                     else
                         *pb &= (BitOFF[ k ] );
                    if ( k == 7 )
                         pb++;
                }
            }
        }

        break;

        case 1800L :

        if( pDistGlyphData != NULL )
        {

        // Setup GLYPHDATA structure

        //  x = -x; !!!! HighPart include plus or minus flag
        //  y = -y; !!!! HighPart include plus or minus flag

            pDistGlyphData->ptqD.x.HighPart = -(SrcGlyphData.ptqD.x.HighPart);
            pDistGlyphData->ptqD.x.LowPart = SrcGlyphData.ptqD.x.LowPart;
            pDistGlyphData->ptqD.y.HighPart = -(SrcGlyphData.ptqD.y.HighPart);
            pDistGlyphData->ptqD.y.LowPart = SrcGlyphData.ptqD.y.LowPart;

        // top = -bottom ; bottom = -top ; right = -left ; left = -right

            pDistGlyphData->rclInk.top = -(SrcGlyphData.rclInk.bottom);
            pDistGlyphData->rclInk.bottom = -(SrcGlyphData.rclInk.top);
            pDistGlyphData->rclInk.right = -(SrcGlyphData.rclInk.left);
            pDistGlyphData->rclInk.left = -(SrcGlyphData.rclInk.right);
        }

        if( pSrcGlyphBits != NULL && pDistGlyphBits != NULL )
        {

        // Get Bitmap size

            ulSrcBitmapSizeX = pSrcGlyphBits->sizlBitmap.cx;
            ulSrcBitmapSizeY = pSrcGlyphBits->sizlBitmap.cy;

        // Get the pointer to Bitmap images

            pbSrcBitmap = (PBYTE)pSrcGlyphBits->aj;
            pbDistBitmap = (PBYTE)pDistGlyphBits->aj;

        // Set Distination Bitmap Size

            ulDistBitmapSizeX = ulSrcBitmapSizeX;
            ulDistBitmapSizeY = ulSrcBitmapSizeY;

        // Setup GLYPHBITS stuff

            pDistGlyphBits->ptlOrigin.x = -(LONG)(ulSrcBitmapSizeX);
            pDistGlyphBits->ptlOrigin.y = -(LONG)(ulSrcBitmapSizeY + pSrcGlyphBits->ptlOrigin.y);

            pDistGlyphBits->sizlBitmap.cx = pSrcGlyphBits->sizlBitmap.cx;
            pDistGlyphBits->sizlBitmap.cy = pSrcGlyphBits->sizlBitmap.cy;


        // Rotate bitmap inage

            cjScanSrc = CJ_DIB8_SCAN( ulSrcBitmapSizeX );
            cjScanDist = CJ_DIB8_SCAN( ulDistBitmapSizeX );

            for ( y = 0; y < ulDistBitmapSizeY ; y++ )
            {
                for ( x = 0 , pb = pbDistBitmap + cjScanDist * y ;
                      x < ulDistBitmapSizeX ;
                      x++ )
                {
                    k = x & 7;

                    if ( BIT( pbSrcBitmap, cjScanSrc,
                              ulDistBitmapSizeX - x - 1,
                              ulDistBitmapSizeY - y - 1
                            )
                       )
                        *pb |= (BitON[ k ] );
                    else
                        *pb &= (BitOFF[ k ] );
                    if ( k == 7 )
                        pb++;
                }
            }
        }

        break;

        case 2700L :

        if( pDistGlyphData != NULL )
        {

        // Setup GLYPHDATA structure

        //  x = -y; !!!! HighPart include plus or minus flag
        //  y =  x;

            pDistGlyphData->ptqD.x.HighPart = -(SrcGlyphData.ptqD.y.HighPart);
            pDistGlyphData->ptqD.x.LowPart = SrcGlyphData.ptqD.y.LowPart;
            pDistGlyphData->ptqD.y = SrcGlyphData.ptqD.x;

        // top = left ; bottom = right ; right = -bottom ; left = -top

            pDistGlyphData->rclInk.top = SrcGlyphData.rclInk.left;
            pDistGlyphData->rclInk.bottom = SrcGlyphData.rclInk.right;
            pDistGlyphData->rclInk.right = -(SrcGlyphData.rclInk.bottom);
            pDistGlyphData->rclInk.left = -(SrcGlyphData.rclInk.top);

        }

        if( pSrcGlyphBits != NULL && pDistGlyphBits != NULL )
        {

        // Get Bitmap size

            ulSrcBitmapSizeX = pSrcGlyphBits->sizlBitmap.cx;
            ulSrcBitmapSizeY = pSrcGlyphBits->sizlBitmap.cy;

        // Get the pointer to Bitmap images

            pbSrcBitmap = (PBYTE)pSrcGlyphBits->aj;
            pbDistBitmap = (PBYTE)pDistGlyphBits->aj;

        // Set Distination Bitmap Size

            ulDistBitmapSizeX = ulSrcBitmapSizeY;
            ulDistBitmapSizeY = ulSrcBitmapSizeX;

        // Setup GLYPHBITS stuff

            pDistGlyphBits->ptlOrigin.x = -(LONG)(ulSrcBitmapSizeY + pSrcGlyphBits->ptlOrigin.y);
            pDistGlyphBits->ptlOrigin.y = pSrcGlyphBits->ptlOrigin.x;

            pDistGlyphBits->sizlBitmap.cx = pSrcGlyphBits->sizlBitmap.cy;
            pDistGlyphBits->sizlBitmap.cy = pSrcGlyphBits->sizlBitmap.cx;

        // Rotate bitmap inage

            cjScanSrc = CJ_DIB8_SCAN( ulSrcBitmapSizeX );
            cjScanDist = CJ_DIB8_SCAN( ulDistBitmapSizeX );

            for ( y = 0; y < ulDistBitmapSizeY ; y++ )
            {
                for ( x = 0 , pb = pbDistBitmap + cjScanDist * y ;
                      x < ulDistBitmapSizeX ;
                      x++ )
                {
                    k = x & 7;

                    if ( BIT( pbSrcBitmap, cjScanSrc,
                              y ,
                              ulDistBitmapSizeX - x - 1
                            )
                       )
                        *pb |= (BitON[ k ] );
                    else
                        *pb &= (BitOFF[ k ] );
                    if ( k == 7 )
                        pb++;
                }
            }
        }

        break;

        default :

            WARNING("BMFD:vFill_RotateGLYPHDATA():ulRotate is invalid\n");
            break;

    } // end switch
}

#endif // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\bmfd\fon16.c ===
/******************************Module*Header*******************************\
* Module Name: fon16.c
*
* routines for accessing font resources within *.fon files
* (win 3.0 16 bit dlls)
*
* Created: 08-May-1991 12:55:14
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/

/*
local Hungarian

j byte
cj count of bytes
pj pointer to byte
off offset
rt resource type
rn resource name
dp offset (ptrdiff_t)
ne new exe, Win16 format, see windows\core\ntgdi\inc\exehdr.h
*/

#include "fd.h"
#include "exehdr.h"

// GETS ushort at (PBYTE)pv + off. both pv and off must be even

#define  US_GET(pv,off) ( *(UNALIGNED PUSHORT)((PBYTE)(pv) + (off)) )

#if DBG
DWORD g_BreakAboutBadFonts;
DWORD g_PrintAboutBadFonts = TRUE;
#endif

VOID
__cdecl
NotifyBadFont(
    PCSTR Format,
    ...
    )
{
#if DBG
    if (g_PrintAboutBadFonts
        || g_BreakAboutBadFonts
        )
    {
        va_list Args;

        va_start(Args, Format);
        vDbgPrintEx(DPFLTR_SYSTEM_ID, DPFLTR_ERROR_LEVEL, (PSTR)Format, Args);
        va_end(Args);
    }
    if (g_BreakAboutBadFonts)
    {
        DbgBreakPoint();
    }
#endif
}

BOOL
bMappedViewStrlen(
    PVOID  pvViewBase,
    SIZE_T cjViewSize,
    PVOID  pvString,
    OUT PSIZE_T pcjOutLength OPTIONAL
    )
/*++

Routine Description:

    Given a mapped view and size and starting address, verify that the 8bit string
        starting at the address is nul terminated within the mapped view, optionally
        returning the length of the string.

Arguments:

    pvViewBase -
    cjViewSize -
    pvString -
    pcjOutLength -

Return Value:

    TRUE: the string is nul terminated within the view
    FALSE: the string is not nul terminated within the view
--*/
{
    BOOL  bSuccess;
    PBYTE pjViewBase;
    PBYTE pjViewEnd;
    PBYTE pjString;
    PBYTE pjStringEnd;

    bSuccess = FALSE;
    if (pcjOutLength != NULL)
    {
        *pcjOutLength = 0;
    }
    pjViewBase = (PBYTE)pvViewBase;
    pjViewEnd = cjViewSize + pjViewBase;
    pjString = (PBYTE)pvString;

    if (!(pjString >= pjViewBase && pjString < pjViewEnd))
    {
        goto Exit;
    }
    for (pjStringEnd = pjString ; pjStringEnd != pjViewEnd && *pjStringEnd != 0 ; ++pjStringEnd)
    {
        // nothing
    }
    if (pjStringEnd == pjViewEnd)
    {
        goto Exit;
    }
    if (pcjOutLength != NULL)
    {
        *pcjOutLength = (SIZE_T)(pjStringEnd - pjString);
    }
    bSuccess = TRUE;
Exit:
#if DBG
    if (!bSuccess)
    {
        NotifyBadFont(
                "WIN32K: bMappedViewStrlen(%p,0x%Ix,%p) returning false\n",
                pvViewBase,
                cjViewSize,
                pvString
                );
    }
#endif
    return bSuccess;
}

BOOL
bMappedViewRangeCheck(
    PVOID  ViewBase,
    SIZE_T ViewSize,
    PVOID  DataAddress,
    SIZE_T DataSize
    )
/*++

Routine Description:

    Given a mapped view and size, range check a data address and size.

Arguments:

    ViewBase -
    ViewSize -
    DataAddress -
    DataSize -

Return Value:

    TRUE: all of the data is within the view
    FALSE: some of the data is outside the view
--*/
{
    ULONG_PTR iViewBegin;
    ULONG_PTR iViewEnd;
    ULONG_PTR iDataBegin;
    ULONG_PTR iDataEnd;
    BOOL      fResult;

    //
    // iDataBegin is        a valid address.
    // iDataEnd is one past a valid address.
    // We must not allow iDataBegin == iViewEnd.
    // We must     allow iDataEnd   == iViewEnd.
    // Therefore, we must not allow iDataBegin == iDataEnd.
    // This can be achieved by not allowing DataSize == 0.
    //
    if (DataSize == 0)
    {
        DataSize = 1;
    }

    iViewBegin = (ULONG_PTR)ViewBase;
    iViewEnd = iViewBegin + ViewSize;
    iDataBegin = (ULONG_PTR)DataAddress;
    iDataEnd = iDataBegin + DataSize;

    fResult = 
        (  iDataBegin >= iViewBegin
        && iDataBegin < iDataEnd
        && iDataEnd <= iViewEnd
        && DataSize <= ViewSize
        );

#if DBG
    if (!fResult)
    {
        NotifyBadFont(
                "WIN32K: bMappedViewRangeCheck(%p,0x%Ix,%p,0x%Ix) returning false\n",
                ViewBase,
                ViewSize,
                DataAddress,
                DataSize
                );
    }
#endif

    return fResult;
}

/******************************Public*Routine******************************\
* bInitWinResData
*
* Initializes the fields of the WINRESDATA structure so as to make it
* possible for the user to access *.fnt resources within the
* corresponding *.fon file
*
*   The function returns True if *.fnt resources found in the *.fon
* file, otherwise false (if not an *.fon file or if it contains no
* *.fnt resources
*
*
* History:
*  January 2002 -by- Jay Krell [JayKrell]
*    range check memory mapped i/o
*  09-May-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bInitWinResData(
    PVOID  pvView,
    COUNT  cjView,
    PWINRESDATA pwrd
    )
{
    PBYTE pjNewExe;     // ptr to the beginning of the new exe hdr
    PBYTE pjResType;    // ptr to the beginning of TYPEINFO struct
    PBYTE pjResName;    // ptr to the beginning of NAMEINFO struct
    ULONG iResID;       // resource type id
    COUNT cFdirEntries;
    BOOL  bZeroUponFailure;
    BOOL  bSuccess;
    ULONG crn;
    PBYTE pjView;
    PBYTE pjResType_FNT;
    PBYTE pjResType_FDIR;
    BOOL  bBreakWhile;

#ifdef DUMPCALL
    DbgPrint("\nbInitWinResData(");
    DbgPrint("\n    PFILEVIEW   pfvw = %-#8lx", pfvw);
    DbgPrint("\n    PWINRESDATA pwrd = %-#8lx", pwrd);
    DbgPrint("\n    )\n");
#endif

    bSuccess = FALSE;
    bZeroUponFailure = FALSE;

    pwrd->pvView = pvView;
    pwrd->cjView = cjView;
    pjView = (PBYTE)pvView;

// check the magic # at the beginning of the old header
    { C_ASSERT(OFF_e_lfanew > OFF_e_magic); }

    if (!bMappedViewRangeCheck(pjView, cjView, pjView + OFF_e_lfanew, sizeof(DWORD)))
    {
        goto Exit;
    }

    if (US_GET(pjView, OFF_e_magic) != EMAGIC)
    {
        goto Exit;
    }

    pwrd->dpNewExe = (PTRDIFF)READ_DWORD(pjView + OFF_e_lfanew);

    pjNewExe = pjView + pwrd->dpNewExe;

// make sure that offset is consistent
    { C_ASSERT(OFF_ne_magic < CJ_NEW_EXE);
      C_ASSERT(OFF_ne_restab < CJ_NEW_EXE);
      C_ASSERT(OFF_ne_rsrctab < CJ_NEW_EXE);
    }
    if (!bMappedViewRangeCheck(pjView, cjView, pjNewExe, CJ_NEW_EXE))
    {
        goto Exit;
    }

    if (US_GET(pjNewExe, OFF_ne_magic) != NEMAGIC)
    {
        goto Exit;
    }

    pwrd->cjResTab = (ULONG)(US_GET(pjNewExe, OFF_ne_restab) -
                             US_GET(pjNewExe, OFF_ne_rsrctab));

    if (pwrd->cjResTab == 0L)
    {
    //
    //  The following test is applied by DOS,  so I presume that it is
    // legitimate.  The assumption is that the resident name table
    // FOLLOWS the resource table directly,  and that if it points to
    // the same location as the resource table,  then there are no
    // resources.

        WARNING("No resources in *.fon file\n");
        goto Exit;
    }

// want offset from pvView, not from pjNewExe => must add dpNewExe

    pwrd->dpResTab = (PTRDIFF)US_GET(pjNewExe, OFF_ne_rsrctab) + pwrd->dpNewExe;

// make sure that offset is consistent

    if (!bMappedViewRangeCheck(pjView, cjView, pjView + pwrd->dpResTab, sizeof(USHORT) + CJ_TYPEINFO))
    {
        goto Exit;
    }

// what really lies at the offset OFF_ne_rsrctab is a NEW_RSRC.rs_align field
// that is used in computing resource data offsets and sizes as a  shift factor.
// This field occupies two bytes on the disk and the first TYPEINFO structure
// follows right after. We want pwrd->dpResTab to point to the first
// TYPEINFO structure, so we must add 2 to get there and subtract 2 from
// the length

    pwrd->ulShift = (ULONG) US_GET(pjView, pwrd->dpResTab);
    pwrd->dpResTab += 2;
    pwrd->cjResTab -= 2;

// Now we want to determine where the resource data is located.
// The data consists of a RSRC_TYPEINFO structure, followed by
// an array of RSRC_NAMEINFO structures,  which are then followed
// by a RSRC_TYPEINFO structure,  again followed by an array of
// RSRC_NAMEINFO structures.  This continues until an RSRC_TYPEINFO
// structure which has a 0 in the rt_id field.

    pjResType = pjView + pwrd->dpResTab;
    pjResType_FNT = NULL;
    pjResType_FDIR = NULL;
    bBreakWhile = FALSE;
    while (TRUE)
    {
        iResID = (ULONG) US_GET(pjResType,OFF_rt_id);
        switch (iResID)
        {
        default:
            break;
        case 0:
            bBreakWhile = TRUE;
            break;
        case RT_FNT:
            pjResType_FNT = pjResType;
            if (pjResType_FDIR != NULL)
                bBreakWhile = TRUE;
            break;
        case RT_FDIR:
            pjResType_FDIR = pjResType;
            if (pjResType_FNT != NULL)
                bBreakWhile = TRUE;
            break;
        }
        if (bBreakWhile)
            break;

    // # of NAMEINFO structures that follow = resources of this type
        crn = (ULONG)US_GET(pjResType, OFF_rt_nres);

    // get ptr to the new TYPEINFO struc and the new resource id
        pjResType = pjResType + CJ_TYPEINFO + crn * CJ_NAMEINFO;

        if (!bMappedViewRangeCheck(pjView, cjView, pjResType, CJ_TYPEINFO))
        {
            goto Exit;
        }
    }

    bZeroUponFailure = TRUE;

    ASSERT((iResID == 0) == (pjResType_FNT == NULL || pjResType_FDIR == NULL));
    if (iResID == 0)
    { // we did not find one or both of them
        goto Exit;
    }

    pjResType = pjResType_FNT;

    // # of NAMEINFO structures that follow == # of font resources
    pwrd->cFntRes = (ULONG)US_GET(pjResType, OFF_rt_nres);

    // this is ptr to the first NAMEINFO struct that follows
    // an RT_FNT TYPEINFO structure

    pjResName = pjResType + CJ_TYPEINFO;
    pwrd->dpFntTab = (PTRDIFF)(pjResName - pjView);

// make sure that offset is consistent

    if ((ULONG)pwrd->dpFntTab > pwrd->cjView)
    {
        goto Exit;
    }

// Now we search for the FONDIR resource.  Windows actually grabs facenames
// from the FONDIR entries and not the FNT entries.  For some wierd fonts this
// makes a difference. [gerritv]

    pjResType = pjResType_FDIR;

    // this is ptr to the first NAMEINFO struct that follows
    // an RT_FDIR TYPEINFO structure

    pjResName = pjResType + CJ_TYPEINFO;
    if (!bMappedViewRangeCheck(pjView, cjView, pjResName, CJ_NAMEINFO))
    {
        goto Exit;
    }

    // Get the offset to res data computed from the top of the new header

    pwrd->dpFdirRes = (PTRDIFF)((ULONG)US_GET(pjResName,OFF_rn_offset) <<
                       pwrd->ulShift);

    // Now pwrd->dpFdirRes is an offset to the FONTDIR resource, the first
    // byte [ushort?] will be the number of entries in the font dir.  Lets make sure it
    // matches the number of FNT resources in the file.

    if (!bMappedViewRangeCheck(pjView, cjView, pjView + pwrd->dpFdirRes, sizeof(USHORT)))
    {
        goto Exit;
    }
    cFdirEntries = (ULONG)US_GET(pjView,pwrd->dpFdirRes);

    if( cFdirEntries != pwrd->cFntRes )
    {
        WARNING( "bInitWinResData: # of FONTDIR entries != # of FNT entries.\n");
        goto Exit;
    }

// now increment dpFdirRes so it points passed the count of entries and
// to the first entry.

    pwrd->dpFdirRes += 2;

    bSuccess = TRUE;
Exit:
    if (!bSuccess)
    {
#if DBG
        NotifyBadFont("WIN32K: %s failing\n", __FUNCTION__);
#endif
        if (bZeroUponFailure && pwrd != NULL)
        {
            pwrd->cFntRes = (ULONG)0;
            pwrd->dpFntTab = (PTRDIFF)0;
        }
    }
    return bSuccess;
}

/******************************Public*Routine******************************\
* bGetFntResource
*
* Writes the pointer to and the size of the iFntRes-th *.fnt resource
* of the *.fon file identified by pwrd. The info is written into RES_ELEM
* structure if successful. The function returns FALSE if it is not possible
* to locate iFntRes-th *.fnt resource in the file.
*
*
* History:
*  January 2002 -by- Jay Krell [JayKrell]
*    range check memory mapped i/o
*  09-May-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bGetFntResource(
    PWINRESDATA pwrd   ,
    ULONG       iFntRes,
    PRES_ELEM   pre
    )
{
    //
    // This function is called in a loop for iFntRes in [0..pwrd->cFntRes),
    // and therefore has quadratic perf.
    //
    PBYTE pjResName;
    PBYTE pjFaceName;
    PTRDIFF dpResData;
    BOOL bSuccess;
    PBYTE pjView;
    PBYTE pjViewEnd;
    SIZE_T cjView;
    SIZE_T cjFaceNameLength;

#ifdef DUMPCALL
    DbgPrint("\nbGetFntResource(");
    DbgPrint("\n    PWINRESDATA pwrd    = %-#8lx", pwrd);
    DbgPrint("\n    ULONG       iFntRes = %-#8lx", iFntRes);
    DbgPrint("\n    PRES_ELEM   pre     = %-#8lx", pre);
    DbgPrint("\n    )\n");
#endif

    ASSERTGDI((pwrd->cFntRes != 0L) && (iFntRes < pwrd->cFntRes),
               "bGetFntResource\n");

    bSuccess = FALSE;
    pjView = (PBYTE)pwrd->pvView;
    cjView = pwrd->cjView;

// get to the Beginning of the NAMEINFO struct that correspoonds to
// the iFntRes-th *.fnt resource. (Note: iFntRes is zero based)

    pjResName = pjView + pwrd->dpFntTab + iFntRes * CJ_NAMEINFO;

// Get the offset to res data computed from the top of the new header

    if (!bMappedViewRangeCheck(pjView, cjView, pjResName, CJ_NAMEINFO))
    {
        goto Exit;
    }
    dpResData = (PTRDIFF)((ULONG)US_GET(pjResName,OFF_rn_offset) <<
                           pwrd->ulShift);

    pre->pvResData = (PVOID)(pjView + dpResData);
    pre->dpResData = dpResData;

    pre->cjResData = (ULONG)US_GET(pjResName,OFF_rn_length) << pwrd->ulShift;

    if (!bMappedViewRangeCheck(pjView, cjView, pre->pvResData, pre->cjResData))
    {
        goto Exit;
    }

    // Get the face name from the FONTDIR

    pjFaceName = pjView + pwrd->dpFdirRes;
    pjViewEnd = pjView + cjView;
    do
    {
        // The first two bytes of the entry are the resource index so we will skip
        // past that.  After that add in the size of the font header.  This will
        // point us to the string for the device_name

        pjFaceName += 2 + OFF_BitsOffset;

        if (!bMappedViewStrlen(pjView, cjView, pjFaceName, &cjFaceNameLength))
        {
            goto Exit;
        }
        pjFaceName += cjFaceNameLength + 1;

        // pjFaceName now really points to the facename
        if( iFntRes )
        {
            if (!bMappedViewStrlen(pjView, cjView, pjFaceName, &cjFaceNameLength))
            {
                goto Exit;
            }
            pjFaceName += cjFaceNameLength + 1;
        }
    }
    while( iFntRes-- );

    //
    // Later on strlen is going to be called on pjFaceName.
    // Let's do a range checked version first.
    //
    if (!bMappedViewStrlen(pjView, cjView, pjFaceName, NULL))
    {
        goto Exit;
    }
    pre->pjFaceName = pjFaceName;

#ifdef FOOGOO
    KdPrint(("%s: offset= 0x%lx, charset = %ld\n", pjFaceName, dpResData + OFF_CharSet, *((BYTE *)pjView + dpResData + OFF_CharSet)));
#endif

    bSuccess = TRUE;
Exit:
    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\bmfd\fon32.h ===
/******************************Module*Header*******************************\
* Module Name: fon32.h
*
*
* Created: 24-Mar-1992 10:07:14
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/


BOOL
bFindLoadAndLockResourceA(
    HANDLE    ,
    LPCSTR    ,
    LPSTR     ,
    HANDLE*   ,
    RES_ELEM*
    );


BOOL bRelockResourcesInDll32(FONTFILE * pff);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\bmfd\fdcvt.c ===
/******************************Module*Header*******************************\
* Module Name: fdcvt.c
*
* ifi interface calls, file loading and file conversions.
*
* Created: 22-Oct-1990 13:33:55
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "fd.h"
#include "ctype.h"
#include "exehdr.h"
#include <string.h>

#if DBG
unsigned gflBmfdDebug = 0;
#define BMFD_DEBUG_DUMP_HEADER 1
typedef VOID (*VPRINT) (char*,...);
VOID vDumpFontHeader(PRES_ELEM, VPRINT);
#endif

// This points to the base of our list of FD_GLYPHSETS

CP_GLYPHSET *gpcpGlyphsets = NULL;

/******************************Public*Routine******************************\
* BmfdQueryFontCaps
*
* Effects: returns the capabilities of this driver.
*          Only mono bitmaps are supported.
*
* History:
*  27-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG BmfdQueryFontCaps(ULONG culCaps, PULONG pulCaps)
{
    ASSERTGDI(culCaps == 2, "ERROR why would the engine call us like this");

    if (culCaps < 2)
        return(0L);

    pulCaps[0] = 2L;

    //
    // 1 bit per pel bitmaps only are supported
    //

    pulCaps[1] = QC_1BIT;

    return(2L);
}

/******************************Public*Routine******************************\
* BmfdUnloadFontFile(HFF hff)
*
* Frees the resources that have been loced allocated by BmfdLoadFontFile
* BmfdLoadFontResData
*
* History:
*  15-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
BmfdUnloadFontFile(
    HFF hff
    )
{
    FACEINFO    *pfai, *pfaiTooFar;

    ASSERTGDI(hff, "BmfdUnloadFontFile, hff\n");

// check the reference count, if not 0 (font file is still
// selected into a font context) we have a problem

    ASSERTGDI(PFF(hff)->cRef == 0L, "cRef: did not update links properly\n");

// free the memory associated with all converted files

    pfai = PFF(hff)->afai;
    pfaiTooFar = pfai + PFF(hff)->cFntRes;

    EngAcquireSemaphore(ghsemBMFD);

    while (pfai < pfaiTooFar)
    {
        vUnloadGlyphset(&gpcpGlyphsets, pfai->pcp);
        pfai += 1;
    }

    EngReleaseSemaphore(ghsemBMFD);

// free memory associated with this FONTFILE object,

    VFREEMEM(hff);
    return(TRUE);
}


/******************************Public*Routine******************************\
*
* FSHORT fsSelectionFlags(PBYTE ajHdr)
*
* Effects: compute fsSelection field of the ifimetrics
*
* History:
*  13-May-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

FSHORT
fsSelectionFlags(
    PBYTE ajHdr
    )
{
    FSHORT fsSelection = 0;

    if (ajHdr[OFF_Italic])
        fsSelection |= FM_SEL_ITALIC;

    if (ajHdr[OFF_Underline])
        fsSelection |= FM_SEL_UNDERSCORE;

    if (ajHdr[OFF_StrikeOut])
        fsSelection |= FM_SEL_STRIKEOUT;

#ifdef DEBUG_ITALIC
    DbgPrint("It = %ld, Str = %ld, Und = %ld, Asc = %ld\n",
       (ULONG)ajHdr[OFF_Italic],
       (ULONG)ajHdr[OFF_StrikeOut],
       (ULONG)ajHdr[OFF_Underline],
       (ULONG)sMakeSHORT((PBYTE)&ajHdr[OFF_Ascent])
       );
#endif // DEBUG_ITALIC

// the following line is somewhat arbitrary, we set the FM_SEL_BOLD
// flag iff weight is > FW_NORMAL (400). we will not allow emboldening
// simulation on the font that has this flag set

    if (usMakeUSHORT((PBYTE)&ajHdr[OFF_Weight]) > FW_NORMAL)
        fsSelection |= FM_SEL_BOLD;

    return(fsSelection);
}


/******************************Public*Routine******************************\
*
*    vAlignHdrData
*
* Effects: packs header data into dword alligned structure
*
* History:
*  29-Oct-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID
vAlignHdrData(
    PCVTFILEHDR  pcvtfh,
    PRES_ELEM    pre
    )
{
    PBYTE ajHdr  = (PBYTE)pre->pvResData;

#ifdef DUMPCALL
    DbgPrint("\nvAlignHdrData("                             );
    DbgPrint("\n    PCVTFILEHDR  pcvtfh = %-#8lx", pcvtfh   );
    DbgPrint("\n    PRES_ELEM    pre    = %-#8lx", pre      );
    DbgPrint("\n    )\n"                                    );
#endif


    /******************************************************/
    /**/  #if DBG                                       /**/
    /**/    if (gflBmfdDebug & BMFD_DEBUG_DUMP_HEADER)  /**/
    /**/      vDumpFontHeader(pre, (VPRINT) DbgPrint);  /**/
    /**/  #endif                                        /**/
    /******************************************************/
// zero out the whole structure before doing anything

    RtlZeroMemory(pcvtfh, sizeof(CVTFILEHDR));

// The iVersion only had length of 2 bytes in the original struct

    pcvtfh->iVersion = usMakeUSHORT((PBYTE)&ajHdr[OFF_Version]);

    pcvtfh->chFirstChar   = ajHdr[OFF_FirstChar  ];
    pcvtfh->chLastChar    = ajHdr[OFF_LastChar   ];
    pcvtfh->chDefaultChar = ajHdr[OFF_DefaultChar];
    pcvtfh->chBreakChar   = ajHdr[OFF_BreakChar  ];

    pcvtfh->cy = usMakeUSHORT((PBYTE)&ajHdr[OFF_PixHeight]);

#ifdef FE_SB // vAlignHdrData():Get DBCS character's width
    pcvtfh->usCharSet     = (USHORT) ajHdr[OFF_CharSet];

    if( !IS_ANY_DBCS_CHARSET( pcvtfh->usCharSet ) )
#endif // FE_SB
    {
        // Fri 29-Apr-1994 07:11:06 by Kirk Olynyk [kirko]
        //
        // There are some buggy font files that are fixed pitch but
        // have a MaxWidth greater than the fixed pitch width
        // e.g. "Crosstalk IBMPC Fonts v2.0". We check for the
        // disparity here. If the font is fixed pitch, as indicated
        // by a non zero value of PixWidth, and the average width
        // is equal to the fixed pitch width, then the maximum
        // pixel width (MaxWidth) is set equal to the PixWidth.
        // If the MaxWidth value was correct, then this piece
        // of code puts in a bad value for the maxiumum width.
        // But this will be fixed! The calling sequences of
        // interest are:
        //
        // bConverFontRes() calls bVerifyFNT() calls vAlignHdrData()
        //
        // then later in bConvertFontRes()
        //
        // bConverFontRes() calls vCheckOffsetTable()
        //
        // It is vCheckOffsetTabl() that would correct
        // the maximum pixel if it was incorrectly set here

        USHORT usPixWidth  = usMakeUSHORT(ajHdr + OFF_PixWidth);
        USHORT usAvgWidth  = usMakeUSHORT(ajHdr + OFF_AvgWidth);
        USHORT usMaxWidth  = usMakeUSHORT(ajHdr + OFF_MaxWidth);

        if (usPixWidth && usPixWidth == usAvgWidth)
            usMaxWidth = usPixWidth;
        pcvtfh->usMaxWidth = usMaxWidth;
#ifdef FE_SB // vAlignHdrData():Init DBCS width 0 for non DBCS font.
        pcvtfh->usDBCSWidth = 0;
#endif // FE_SB
    }
#ifdef FE_SB // vAlignHdrData():Get DBCS character's width
     else
    {
    // usMaxWidth specifies DBCS width in 3.0J and 3.1J font width of double byte
    // character let keep this value, because pcvtfh->usMaxWidth might be change in
    // vCheckOffsetTable()

        pcvtfh->usDBCSWidth = usMakeUSHORT(ajHdr + OFF_MaxWidth);
        pcvtfh->usMaxWidth  = usMakeUSHORT(ajHdr + OFF_MaxWidth);
    }
#endif // FE_SB


    if (pcvtfh->iVersion == 0x00000200)
        pcvtfh->dpOffsetTable = OFF_OffTable20;
    else if (pcvtfh->iVersion == 0x00000300)
        pcvtfh->dpOffsetTable = OFF_OffTable30;
    else
        pcvtfh->dpOffsetTable = -1; // will generate error

}

/******************************Public*Routine******************************\
* BOOL bDbgPrintAndFail(PSZ psz)
*
* History:
*  06-Dec-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#if DBG
BOOL
bDbgPrintAndFail(
    PSZ psz
    )
{
    DONTUSE(psz);
//#ifdef DEBUGFF
    DbgPrint(psz);
//#endif
    return(FALSE);
}

#else

#define bDbgPrintAndFail(psz) FALSE

#endif


BOOL
bVerifyFNTQuick(
    PRES_ELEM   pre
    )
{
#ifdef DUMPCALL
    DbgPrint("\nbVerifyResource("                       );
    DbgPrint("\n    PCVTFILEHDR pcvtfh = %-#8lx", pcvtfh);
    DbgPrint("\n    PRES_ELEM   pre    = %-#8lx", pre   );
    DbgPrint("\n    )\n"                                );
#endif

    PBYTE ajHdr  = (PBYTE)pre->pvResData;
    USHORT usVersion;

    if (pre->cjResData < OFF_OffTable20)
        return(bDbgPrintAndFail("BMFD! resource size too small for OFF_OffTable20\n"));         // supported.

    if ((READ_WORD(&ajHdr[OFF_Type]) & TYPE_VECTOR))   // Vector bit has to
        return(FALSE);          // we expect to hit this line on vector fonts

    usVersion = READ_WORD(&ajHdr[OFF_Version]);

    if ((usVersion != 0x0200) &&     // The only version
        (usVersion != 0x0300) )      // The only version
        return(FALSE);         // we hit that one too on vector fonts

    if ((usVersion == 0x0300) && (pre->cjResData < OFF_OffTable30))
        return(bDbgPrintAndFail("BMFD! resource size too small for OFF_OffTable30\n"));         // supported.

    return TRUE;
}

/******************************Public*Routine******************************\
* bVerifyResource
*
* Effects: CHECK whether header contains file info which corresponds to
*          the raster font requirements, go into the file and check
*          the consistency of the header data
*
* History:
*  30-Oct-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bVerifyResource(
    PCVTFILEHDR pcvtfh,
    PRES_ELEM   pre
    )
{
#ifdef DUMPCALL
    DbgPrint("\nbVerifyResource("                       );
    DbgPrint("\n    PCVTFILEHDR pcvtfh = %-#8lx", pcvtfh);
    DbgPrint("\n    PRES_ELEM   pre    = %-#8lx", pre   );
    DbgPrint("\n    )\n"                                );
#endif

    PBYTE ajHdr  = (PBYTE)pre->pvResData;
    ULONG cjSize;
    LONG  dpBits = lMakeLONG((PBYTE)&ajHdr[OFF_BitsOffset]);
    SHORT sAscent;


    ASSERTGDI(
        ((READ_WORD(&ajHdr[OFF_Version]) == 0x0200) || (READ_WORD(&ajHdr[OFF_Version]) == 0x0300)),
        "BMFD!wrong iVersion for bitmap  font\n"
        );

    if (pcvtfh->iVersion == 0x00000200)
        if (dpBits > SEGMENT_SIZE)
            return(bDbgPrintAndFail("BMFD!dpBits \n")); // Bits Offset Not Ok

// file size must be <= than the size of the view

    cjSize = ulMakeULONG(ajHdr + OFF_Size);
    if (cjSize > pre->cjResData)
    {
        cjSize = pre->cjResData; // no offset can be bigger than this
    }

    sAscent     = sMakeSHORT((PBYTE)&ajHdr[OFF_Ascent]);
    if (abs(sAscent) > (SHORT)pcvtfh->cy)
        return(bDbgPrintAndFail("BMFD!sAscent \n")); // Ascent Too Big

    if (sMakeSHORT((PBYTE)&ajHdr[OFF_ExtLeading]) < 0)
        return(bDbgPrintAndFail("BMFD!ExtLeading \n")); // Ext Lead Not Ok;

#if DBG

// CHECK fsType field, if vector type, this would have been caught by
// bVerifyFNTQuick

    ASSERTGDI(
        (READ_WORD(&ajHdr[OFF_Type]) & TYPE_VECTOR) == 0,
        "bmfd!this mustn't have been a vector font\n"
        );

    if (sMakeSHORT((PBYTE)&ajHdr[OFF_IntLeading]) < 0)
        DbgPrint(
            "bmfd warning: possibly bad font file - sIntLeading = %ld\n\n",
            (LONG)sMakeSHORT((PBYTE)&ajHdr[OFF_IntLeading])
            );

#endif

    if (sMakeSHORT((PBYTE)&ajHdr[OFF_IntLeading]) > sAscent)
        return(bDbgPrintAndFail("BMFD!IntLeading too big\n")); // Int Lead Too Big;

// check consistency of character ranges

    if (pcvtfh->chFirstChar > pcvtfh->chLastChar)
        return(bDbgPrintAndFail("BMFD!FirstChar\n")); // this can't be

// default and break character are given relative to the FirstChar,
// so that the actual default (break) character is given as
// chFirst + chDefault(Break)

    if ((UCHAR)(pcvtfh->chDefaultChar + pcvtfh->chFirstChar) > pcvtfh->chLastChar)
    {
    // here we will do something which never should have been done if
    // win 3.0 did any parameter validation on loading fonts .
    // This is done in order not to reject fonts that have only Def and Break
    // chars messed up, but everything else is ok. Example of such shipped
    // fonts are some samna corp. fonts that come with AmiPro application.
    // Their Def char is the absolute value rather than value relative to
    // the first char in the font. This is of course the bug in the font
    // files, but since win30 does not reject these files, we must not do that
    // either.

    #if DBG
        DbgPrint("bmfd!_bVerifyResource: warning -- bogus Default char = %ld\n", (ULONG)pcvtfh->chDefaultChar);
    #endif

        if ((pcvtfh->chDefaultChar >= pcvtfh->chFirstChar) && (pcvtfh->chDefaultChar <= pcvtfh->chLastChar))
        {
        // attempt to fix the problem stemming from the bug in the font file

            pcvtfh->chDefaultChar -= pcvtfh->chFirstChar;
        }
        else
        {
        // this definitely is not a sensible font file, but samna provided us
        // withone such font as well

            pcvtfh->chDefaultChar = 0;
        }
    }

    if ((UCHAR)(pcvtfh->chBreakChar + pcvtfh->chFirstChar) > pcvtfh->chLastChar)
    {
    // here we will do something which never should have been done if
    // win 3.0 did any parameter validation on loading fonts .
    // This is done in order not to reject fonts that have only Def and Break
    // chars messed up, but everything else is ok. Example of such shipped
    // fonts are some samna corp. fonts that come with AmiPro application.
    // Their Break char is the absolute value rather than value relative to
    // the first char in the font. This is of course the bug in the font
    // files, but since win30 does not reject these files, we must not do that
    // either.

    #if DBG
        DbgPrint("bmfd!_bVerifyResource: warning bogus Break char = %ld\n", (ULONG)pcvtfh->chBreakChar);
    #endif

        if ((pcvtfh->chBreakChar >= pcvtfh->chFirstChar) && (pcvtfh->chBreakChar <= pcvtfh->chLastChar))
        {
        // attempt to fix the problem stemming from the bug in the font file

            pcvtfh->chBreakChar -= pcvtfh->chFirstChar;
        }
        else
        {
        // this definitely is not a sensible font file, but samna provided us
        // with one such font as well

            pcvtfh->chBreakChar = 0;
        }
    }

// offset to the offset table

    ASSERTGDI((pcvtfh->dpOffsetTable & 1) == 0, "dpOffsetTable is not even\n");

    if ((pcvtfh->dpOffsetTable != OFF_OffTable20) &&
        (pcvtfh->dpOffsetTable != OFF_OffTable30))
        return(bDbgPrintAndFail("BMFD!dpOffsetTable \n"));

// make sure that the first offset in the offset table is equal to dpBits,
// this is an internal consistency check of the font, also verify that
// all offsets are smaller than cjSize

    {
        PBYTE pjFirstOffset = (PBYTE)pre->pvResData + pcvtfh->dpOffsetTable + 2;
        UINT  cGlyphs = pcvtfh->chLastChar - pcvtfh->chFirstChar + 1;
        PBYTE pjOffsetEnd;

        if (pcvtfh->iVersion == 0x00000200)
        {
        // in 2.0 offsets are 16 bit

            if (dpBits != (PTRDIFF)(*((PUSHORT)pjFirstOffset)))
                return(bDbgPrintAndFail("BMFD!2.0 pjFirstOffset \n"));

            if (pcvtfh->dpOffsetTable + 2 + (cGlyphs * 4) > pre->cjResData)
                return(bDbgPrintAndFail("BMFD!2.0 OffsetTable out of file \n"));
            // 4 is sizeof(TYPE2TABLE) as defined and used in fdquery.c

            pjOffsetEnd = pjFirstOffset + cGlyphs * 4;
            for ( ; pjFirstOffset < pjOffsetEnd; pjFirstOffset += 4)
            {
                if ((ULONG)READ_WORD(pjFirstOffset) > cjSize)
                    return bDbgPrintAndFail("BMFD!invalid offset in 2.0 bm font\n");
            }
        }
        else // 3.0 guarantedd by the very first check
        {
        // in 3.0 offsets are 32 bit

            if (dpBits != (PTRDIFF)ulMakeULONG(pjFirstOffset))
                return(bDbgPrintAndFail("BMFD!3.0 pjFirstOffset \n"));

            if (pcvtfh->dpOffsetTable + 2 + (cGlyphs * 6) > pre->cjResData)
                return(bDbgPrintAndFail("BMFD!3.0 OffsetTable out of file \n"));
            // 6 is sizeof(TYPE3TABLE) as defined and used in fdquery.c

            pjOffsetEnd = pjFirstOffset + cGlyphs * 6;
            for ( ; pjFirstOffset < pjOffsetEnd; pjFirstOffset += 6)
            {
                if (READ_DWORD(pjFirstOffset) > cjSize)
                    return bDbgPrintAndFail("BMFD!invalid offset in 3.0 bm font\n");
            }
        }
    }

// check 3.0 fields if necessary

    if (pcvtfh->iVersion == 0x00000300)
    {
        FSHORT fsFlags = usMakeUSHORT ((PBYTE)&ajHdr[OFF_Flags]);

        if (fsFlags & (DFF_16COLOR | DFF_256COLOR | DFF_RGBCOLOR))
            return(bDbgPrintAndFail("BMFD!Flags: Do not support color fonts\n"));

        if (lMakeLONG((PBYTE)pre->pvResData + OFF_ColorPointer))
            return(bDbgPrintAndFail("BMFD!dpColor: Do not support color fonts\n"));
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bVerifyFNT
*
* Combine the two routines into a single one
*
* History:
*  27-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bVerifyFNT(
    PCVTFILEHDR pcvtfh,
    PRES_ELEM   pre
    )
{
#ifdef DUMPCALL
    DbgPrint("\nbVerifyFNT("                                );
    DbgPrint("\n    PCVTFILEHDR pcvtfh = %-#8lx", pcvtfh    );
    DbgPrint("\n    PRES_ELEM   pre    = %-#8lx", pre       );
    DbgPrint("\n    )\n"                                    );
#endif


// read nonalligned header data at the top of the view into an alligned structure

    vAlignHdrData(pcvtfh,pre);

// make sure that the data matches requirements of a windows bitmap font

    return(bVerifyResource(pcvtfh,pre));
}

/******************************Public*Routine******************************\
*
* BOOL bBmfdLoadFont    // forward declaration
*
* Loads an *.fon or an *.fnt file,
* returns handle to a fonfile object if successfull
*
* History:
*  27-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bBmfdLoadFont    // forward declaration
(
HFF        iFile,
PBYTE      pvView,
ULONG      cjView,
ULONG      iType,
HFF        *phff
)
{
    PFONTFILE   pff;
    ULONG       cjff;
    WINRESDATA  wrd;
    RES_ELEM    re;
    ULONG       ifnt;
    ULONG       cjDescription;      // size of the desctiption string (in bytes)
    PTRDIFF     dpwszDescription;   // offset to the description string
    CHAR        achDescription[256];    // this is the max length of string
                                        // in the 16-bit EXE format.
    ULONG       cjBMFDIFIMETRICS;

#ifdef FE_SB // hffLoadFont()
    ULONG       cFontResIncludeVert;
#endif // FE_SB

    ULONG       dpIFI;
    IFIMETRICS *pifi;

    *phff = (HFF)NULL;

#ifdef DUMPCALL
    DbgPrint("\nbBmfdLoadFont("                 );
    DbgPrint("\n    ULONG      iType = %-#8lx"  );
    DbgPrint("\n    )\n"                        );
#endif

    ASSERTGDI((iType == TYPE_DLL16) || (iType == TYPE_FNT) || ((iType == TYPE_EXE)),
               "bmfd!bBmfdLoadFont(): unknown iType\n");

// If .FON format, there are possibly multiple font resources.  Handle it.

    if (iType == TYPE_DLL16)
    {
        if (!bInitWinResData(pvView,cjView,&wrd))
        {
            return FALSE;
        }
    }

// Otherwise, if .FNT format, the current file view may be used.

    else // fnt
    {
        re.pvResData = pvView;
        re.dpResData = 0;
        re.cjResData = cjView;
        re.pjFaceName = NULL;           // get the face name from the FNT resource
        wrd.cFntRes = 1;
    }

// If .FON format, retrieve the description string (because we won't have
// the mapped file view later and therefore cannot search for it later).


#ifdef FE_SB // hffLoadFont()
// We assume font all font resource is SHIFT_JIS font. We prepare room for Vertical font
    cjff = offsetof(FONTFILE,afai) + ( wrd.cFntRes * 2 ) * sizeof(FACEINFO);
#else
    cjff = offsetof(FONTFILE,afai) + wrd.cFntRes * sizeof(FACEINFO);
#endif

    dpwszDescription = 0;   // no description string, use Facename later
    cjDescription = 0;

    if ((iType == TYPE_DLL16) && bDescStr(pvView, cjView, achDescription))
    {
        dpwszDescription = cjff;
        cjDescription = (strlen(achDescription) + 1) * sizeof(WCHAR);
        cjff += cjDescription;
    }

// remember where the first ifimetrics goes

    dpIFI = cjff = ALIGN_UP( cjff, PVOID );

// compute the total amount of memory needed for the ifimetrics and everything
// else:

    for (ifnt = 0L; ifnt < wrd.cFntRes; ifnt++)
    {
        if (iType == TYPE_DLL16)
        {
            if (!bGetFntResource(&wrd,ifnt,&re))
                return FALSE;
        }

    // do a preliminary check on the resource, before doing a thorough one

        if (!bVerifyFNTQuick(&re))
            return FALSE;

        if (!bBMFDIFIMETRICS(pvView, cjView, NULL, &re, &cjBMFDIFIMETRICS))
            return FALSE;

#ifdef FE_SB
        cjff += ( cjBMFDIFIMETRICS * 2 );
#else
        cjff += cjBMFDIFIMETRICS;
#endif
    }


// Allocate a FONTFILE of the appropriate size from the handle manager.

    if ((*phff = hffAlloc(cjff)) == HFF_INVALID)
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        RETURN("bmfd!bBmfdLoadFont(): memory allocation error\n", FALSE);
    }

    pff = PFF(*phff);


// Init fields of pff structure

    pff->ident      = ID_FONTFILE;
    pff->fl         = 0;
    pff->iType      = iType;
    pff->iFile    = iFile;        // will be needed at unload time
    pff->cFntRes    = wrd.cFntRes;
    pff->cjDescription    = cjDescription;
    pff->dpwszDescription = dpwszDescription;

// Convert each of the font resources (RES_ELEM) to a CVTRESDATA and a
// (set of) FACEDATA.

    pifi = (IFIMETRICS *)((PBYTE)pff + dpIFI);

#ifdef FE_SB // bBmfdLoadFont()

// We have to compute strict font face count include simulated @face

// ifnt                = Physical font counter
// cFontResIncludeVert = FACEINFO structure counter

    cFontResIncludeVert = 0;

    for (ifnt = 0L; ifnt < wrd.cFntRes; ifnt++)
    {
        // At first We process for nomal face font

        if (iType == TYPE_DLL16)
        {
            if (!bGetFntResource(&wrd,ifnt,&re))
            {
                VFREEMEM(*phff);
                *phff = (HFF)NULL;
                return FALSE;
            }
        }

        pff->afai[cFontResIncludeVert].re = re;    // remember this for easier access later
        pff->afai[cFontResIncludeVert].bVertical = FALSE;
        pff->afai[cFontResIncludeVert].pifi = pifi;

        if (!bConvertFontRes(pvView, cjView, &re, &pff->afai[cFontResIncludeVert]))
        {
        #ifdef DBG_NTRES
            WARNING("bmfd!hffLoadFont(): file format conversion failed\n");
        #endif // DBG_NTRES
            VFREEMEM(*phff);
            *phff = (HFF)NULL;
            return FALSE;
        }

        // Count Nomal face font

        cFontResIncludeVert ++;

        // Point it to next room

        pifi = (IFIMETRICS *)((PBYTE)pifi + pifi->cjThis);

        //
        // Check this font resource's Charset is some DBCS charset. If it is so , Set up
        // Vertical font stuff. Or not so. Increment counter.
        //
        // if the font is for DBCS font, usDBCSWidth is not be zero, the value is setted
        // above bConvertFontRes().
        //

        if( (pff->afai[cFontResIncludeVert - 1].cvtfh.usDBCSWidth) != 0 )
        {
            // Vertical Writting use the same font at SBCS CodeArea

            pff->afai[cFontResIncludeVert].re = re;

            // Vertical Writting use the different font at DBCS CoreArea

            pff->afai[cFontResIncludeVert].bVertical = TRUE;

            pff->afai[cFontResIncludeVert].pifi = pifi;

            // Convert font resource and setup CVTFILEHDR and IFIMETRICS

            if ( !bConvertFontRes(pvView, cjView, &re, &pff->afai[cFontResIncludeVert]))
            {
            #ifdef DBG_NTRES
                WARNING("bmfd!hffLoadFont(): file format conversion failed at Vertical font\n");
            #endif // DBG_NTRES
                VFREEMEM(*phff);
                *phff = (HFF)NULL;
                return FALSE;
            }

            // Count Vertical face font

            cFontResIncludeVert ++;

            // Point it to next room

            pifi = (IFIMETRICS *)((PBYTE)pifi + pifi->cjThis);
        }
    }

// We have strictly font resource count include simulated Vertical font now
// Reset font resource count in FONTFILE structure

    pff->cFntRes    = cFontResIncludeVert;

#else
    for (ifnt = 0L; ifnt < wrd.cFntRes; ifnt++)
    {
        if (iType == TYPE_DLL16)
        {
            if (!bGetFntResource(&wrd,ifnt,&re))
            {
                VFREEMEM(*phff);
                *phff = (HFF)NULL;
                return FALSE;
            }
        }

        pff->afai[ifnt].re   = re;    // remember this for easier access later
        pff->afai[ifnt].pifi = pifi;    // remember this for easier access later

        if (!bConvertFontRes(pvView, cjView, &re, &pff->afai[ifnt]))
        {
        #ifdef DBG_NTRES
            WARNING("bmfd!bBmfdLoadFont(): file format conversion failed\n");
        #endif // DBG_NTRES
            VFREEMEM(*phff);
            *phff = (HFF)NULL;
            return FALSE;
        }

        pifi = (IFIMETRICS *)((PBYTE)pifi + pifi->cjThis);
    }
#endif


// If we found a description string, store it in the FONTFILE.

    if (cjDescription != 0)
        vToUNICODEN((PWSZ) ((PBYTE) pff + dpwszDescription), cjDescription/sizeof(WCHAR), achDescription, cjDescription/sizeof(WCHAR));

// Initialize the rest.

    pff->cRef = 0;

    return TRUE;
}



/******************************Public*Routine******************************\
* jFamilyType(FSHORT fsPitchAndFamily)
*
* computes jFamilyType field of the panose structure
*
* History:
*  19-Dec-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BYTE
jFamilyType(
    FSHORT fsPitchAndFamily
    )
{
    BYTE j;

    if (fsPitchAndFamily & FF_DONTCARE)
        j = PAN_ANY;
    else if (fsPitchAndFamily & FF_SCRIPT)
        j = PAN_FAMILY_SCRIPT;
    else if (fsPitchAndFamily & FF_DECORATIVE)
        j = PAN_FAMILY_DECORATIVE;
    else
    {
        j = PAN_FAMILY_TEXT_DISPLAY;
    }
    return(j);
}

/******************************Public*Routine******************************\
* bConvertFontRes
*
* format of the converted file:
*
* converted header on the top, followed by array of IFIMETRICS structures,
* followed by the table of offsets to GLYPHDATA structures for individual
* glyphs, followed by an array of GLYPHDATA structures themselves
*
* Warnings:
*
* History:
*  January 2002 -by- Jay Krell [JayKrell]
*    range check memory mapped i/o
*  13-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bConvertFontRes(
    PVOID        pvView,
    SIZE_T       cjView,
    PRES_ELEM    pre,            // IN
    FACEINFO    *pfai            // OUT
    )
{
    BOOL bResult;

    bResult = FALSE;

#ifdef DUMPCALL
    DbgPrint("\nbConverFontRes(\n"                  );
    DbgPrint("    PRES_ELEM    pre  = %-#8lx\n",pre );
    DbgPrint("    FACEINFO    *pfai = %-#8lx\n",pfai);
    DbgPrint("    );\n\n"                           );
#endif

// make sure that the data matches requirements of a windows bitmap font
// Note: bVerifyFNT() does more than just look at the font -- it does
//       part of the conversion by copying the data to the CVFILEHDR
//       "converted file header"
//
    if(!bVerifyFNT(&pfai->cvtfh,pre))
    {
        goto Exit;
    }

    ASSERTGDI(pfai->cvtfh.dpOffsetTable != -1L, "BMFD!bConvertFontRes(): could not align header\n");

// compute the size of the IFIMETRICS structure that is followed by
// FamilyName, FaceName and UniqueName UNICODE strings and simulations

    if (!bBMFDIFIMETRICS(pvView, cjView, &pfai->cvtfh, pre, NULL))
    {
        goto Exit;
    }

// compute the size of the converted file to be created, fix bugs in file header

    vCheckOffsetTable(&pfai->cvtfh, pre);

// calucate pfai->iDefFace

    vDefFace(pfai,pre);

// compute glyph set that corresponds to this resource:

    EngAcquireSemaphore(ghsemBMFD);

    pfai->pcp = pcpComputeGlyphset(&gpcpGlyphsets,
                                   (UINT) pfai->cvtfh.chFirstChar,
                                   (UINT) pfai->cvtfh.chLastChar,
                                   ((PBYTE)pre->pvResData)[OFF_CharSet]);

    EngReleaseSemaphore(ghsemBMFD);

    if (pfai->pcp == NULL)
    {
        // If we fail it should be because of we are out of memory.

       SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
       WARNING("BMFD!bConvertFontRes(): memory allocation error\n");
       goto Exit;
    }

    // fill the ifimetrics

    vBmfdFill_IFIMETRICS(pfai,pre);

    bResult = TRUE;
Exit:
#if DBG
    if (!bResult)
    {
        NotifyBadFont("WIN32K: %s failing\n", __FUNCTION__);
    }
#endif
    return bResult;
}

/******************************Public*Routine******************************\
* bBMFDIFIMETRICS
*
* Effects:  returns the size cjIFI of IFIMETRICS struct, with appended strings
*           caches the lengths of these strings,pszFamilyName, and cjIFI
*           for later use by vBmfdFill_IFIMETRICS
* Warnings:
*
* History:
*  January 2002 -by- Jay Krell [JayKrell]
*    range check memory mapped i/o
*  20-Oct-1992 -by- Kirk Olynyk [kirko]
* The IFIMETRICS structure has changed. The effect of the change upon
* this procedure is to allocate room for the new simulation structure
* FONTDIFF which informs GDI of the available simulations.
*  20-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bBMFDIFIMETRICS(
    PVOID        pvView,
    SIZE_T       cjView,
    PCVTFILEHDR pcvtfh OPTIONAL,
    PRES_ELEM   pre,
    OUT PULONG  pcjIFIOut OPTIONAL
    )
{
// face name lives in the original file

    ULONG cSims;
    ULONG cjIFI;
    ULONG cjFaceName;
    PSZ pszFaceName;
    BOOL bResult;
    SIZE_T pszFaceNameLength;

    bResult = FALSE;

    if (pcjIFIOut != NULL)
    {
        *pcjIFIOut = 0;
    }

    if( pre->pjFaceName == NULL )
    {
    // get facename from FNT resource for non 16bit resource files

        pszFaceName = (PSZ)((PBYTE)pre->pvResData +
            lMakeLONG((PBYTE)pre->pvResData + OFF_Face));
    }
    else
    {
    // otherwise get facename from the FONTDIR resource for win 3.1
    // compatibility reasons

        pszFaceName = pre->pjFaceName;
    }

    if (!bMappedViewStrlen(pvView, cjView, pszFaceName, &pszFaceNameLength))
    {
        goto Exit;
    }

// 1 is added to the length of a string in WCHAR's
// so as to allow for the terminating zero character, the number of
// WCHAR's is then multiplied by 2 to get the corresponding number of bytes,
// which is then rounded up to a DWORD boundary for faster access

#ifdef FE_SB // VERTICAL:cjIFIMETRICS(): make room for '@'
    cjFaceName   = ALIGN4(sizeof(WCHAR) * (pszFaceNameLength + 1 + 1));
#else
    cjFaceName   = ALIGN4(sizeof(WCHAR) * (pszFaceNameLength + 1));
#endif

// the full size of IFIMETRICS is the size of the structure itself followed by
// the appended strings AND the 3 FONTDIFF structures corresponding to the
// BOLD, ITALIC, and BOLD_ITALIC simulations.

    cjIFI = sizeof(IFIMETRICS) + cjFaceName;

    if (cSims = (cFacesRes(pre) - 1))
    {
        cjIFI += sizeof(FONTSIM) + cSims * sizeof(FONTDIFF);
    }

    cjIFI = ALIGN_UP( cjIFI, PVOID );

    if (pcvtfh)
    {
    // cache the lengths of these strings for later use

        pcvtfh->cjFaceName   = cjFaceName;
        pcvtfh->cjIFI        = cjIFI;
    }

// make sure that the result is a multiple of ULONG size, otherwise we may
// have a problem when making arrays of IFIMETRICS structures

    ASSERTGDI((cjIFI & 3L) == 0L, "ifi is not DWORD alligned\n");

    if (pcjIFIOut != NULL)
    {
        *pcjIFIOut = cjIFI;
    }
    bResult = TRUE;
Exit:
#if DBG
    if (!bResult)
    {
        NotifyBadFont("WIN32K: %s failing\n", __FUNCTION__);
    }
#endif
    return bResult;
}

/******************************Public*Routine******************************\
* bNonZeroRow
*
* History:
*  21-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bNonZeroRow(
    PBYTE pjRow,
    ULONG cy,
    ULONG cjWidth
    )
{
    ULONG ij;  // index into a byte

    for (ij = 0; ij < cjWidth; ij++, pjRow += cy)
    {
        if (*pjRow)
        {
            return(TRUE);
        }
    }
    return(FALSE);  // zero scan
}

/******************************Public*Routine******************************\
* vFindTAndB
*
* computes top and bottom of the ink using the bits in the raw fnt format
*
* History:
*  21-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vFindTAndB(
    PBYTE pjBitmap, // pointer to the bitmap in *.fnt column format
    ULONG cx,
    ULONG cy,
    ULONG *pyTopIncMin,
    ULONG *pyBottomExcMax
    )
{
    ULONG cjWidth = CJ_SCAN(cx); // # of bytes in row of the bitmap in the *.fnt format

    PBYTE pjRow;
    PBYTE pjRowEnd;

#ifdef DUMPCALL
    DbgPrint("\nvFindTAndB(\n"                                          );
    DbgPrint("    PBYTE  pjBitmap          = %-#8lx\n",pjBitmap         );
    DbgPrint("    ULONG  cx                = %d\n",cx                   );
    DbgPrint("    ULONG  cy                = %d\n",cy                   );
    DbgPrint("    ULONG *pyTopIncMin       = %-#8lx\n",pyTopIncMin      );
    DbgPrint("    ULONG *pyBottomExcMax    = %-#8lx\n",pyBottomExcMax   );
    DbgPrint("    );\n\n"                                               );
#endif

    /* default them to null in every case to prevent accessing unitialized data
       in the case the bitmap is null, or all it's row are filled with zero */
    *pyTopIncMin = *pyBottomExcMax = 0;

// case of zero width glyphs

    if (!pjBitmap)
    {
    // no ink at all, out of here

        ASSERTGDI(cx == 0, "bmfd, vFindTAndB, cx != 0\n");

        return;
    }

// real glyphs

    for
    (
        pjRow = pjBitmap, pjRowEnd = pjRow + cy;
        pjRow < pjRowEnd;
        pjRow++
    )
    {
        if (bNonZeroRow(pjRow, cy, cjWidth))
        {
            *pyTopIncMin = (ULONG)(pjRow - pjBitmap);
            break;
        }
    }

    if (pjRow == pjRowEnd)
    {
    // no ink at all, out of here
        return;
    }

// start searhing backwards for the bottom

    for
    (
        pjRow = pjBitmap + (cy - 1);
        pjRow >= pjBitmap;
        pjRow--
    )
    {
        if (bNonZeroRow(pjRow, cy, cjWidth))
        {
            *pyBottomExcMax = (ULONG)((pjRow - pjBitmap) + 1); // + 1 for exclusiveness
            break;
        }
    }

    ASSERTGDI(*pyTopIncMin <= *pyBottomExcMax, "BMFD!top>bottom\n");
}


/******************************Public*Routine******************************\
* vComputeSpecialChars
*
* Effects:
*    compute special characters taking into account character set
*    Not quite sure what to do when char set is not ansi. It is really
*    to figure out what to do for a "font" where glyph bitmaps
*    are pushbuttons etc.
*    This routine will clearly blow up when a char set is catacana
*    This is char set == 37 (amisym)
*
* History:
*  28-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vComputeSpecialChars(
    PCVTFILEHDR pcvtfh,
    PWCHAR pwcDefaultChar,
    PWCHAR pwcBreakChar
    )
{
    UCHAR chDefault = pcvtfh->chDefaultChar + pcvtfh->chFirstChar;
    UCHAR chBreak   = pcvtfh->chBreakChar + pcvtfh->chFirstChar;

// Default and Break chars are given relative to the first chaR

    RtlMultiByteToUnicodeN(pwcDefaultChar, sizeof(WCHAR), NULL, &chDefault, 1);
    RtlMultiByteToUnicodeN(pwcBreakChar, sizeof(WCHAR), NULL, &chBreak, 1);
}

/******************************Public*Routine******************************\
* vBmfdFill_IFIMETRICS
*
* Effects:
*   fills the fields of the IFIMETRICS structure using the info from
*   the converted and the original font file and converted file header
*
*
* History:
*  Fri 24-Jun-1994 20:30:41 by Kirk Olynyk [kirko]
* Changed the test for pitch to look at PixWidth.
*  20-Oct-92 by Kirk Olynyk [kirko]
* Made changes to be compatible with the new and improved IFIMETRICS
* structure.
*  Fri 24-Jan-1992 07:56:16 by Kirk Olynyk [kirko]
* Changed the way EmHeight is calculated.
*  Fri 18-Oct-1991 10:36:43 by Kirk Olynyk [kirko]
* Changed the InlineDir, CharRot, CharSlope, and WidthClass
* to be expressed as POINTL's.
*  23-Jul-1991  Gilman Wong [gilmanw]
* Fixed PANOSE numbers for jFamily and jSerifStyle.
*  12-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vBmfdFill_IFIMETRICS(
    FACEINFO   *pfai,
    PRES_ELEM   pre
    )
{
    FWORD     fwdHeight;
    FONTSIM  *pFontSim;
    FONTDIFF *pfdiffBold = 0, *pfdiffItalic = 0, *pfdiffBoldItalic = 0;
    PANOSE   *ppanose;
    ULONG     cchFaceName;
    PBYTE     ajHdr  = (PBYTE)pre->pvResData;
    FWORD     sAscent,sIntLeading;
#ifdef FE_SB // vBmfdFill_IFIMETRICS()
    BOOL      bDBCSFont = (pfai->cvtfh.usDBCSWidth != 0 ? TRUE : FALSE);
#endif // FE_SB

// compute pointers to the various sections of the converted file

    PCVTFILEHDR  pcvtfh = &pfai->cvtfh;
    PIFIMETRICS  pifi   = pfai->pifi;

// face name lives in the original file, this is the only place pvView is used

    PSZ   pszFaceName;

// Either grab the facename from the FONTDIR or the FNT resources depending
// on wether or not this is a 16bit font resource.

    if( pre->pjFaceName == NULL )
    {
        pszFaceName = (PSZ)(ajHdr + lMakeLONG((PBYTE)&ajHdr[OFF_Face]));
    }
    else
    {
        pszFaceName = pre->pjFaceName;
    }

#ifdef DUMPCALL
    DbgPrint("\nvBmfdFill_IFIMETRICS(\n"                );
    DbgPrint("    FACEINFO   *pfai = %-#8lx\n",  pfai   );
    DbgPrint("    PRES_ELEM   pre  = %-#8lx\n", pre     );
    DbgPrint("    );\n\n"                               );
#endif

    pifi->cjIfiExtra = 0;

//
// the string begins on a DWORD aligned address.
//
    pifi->dpwszFaceName = OFFSET_OF_NEXT(DWORD,sizeof(IFIMETRICS));

// face name == family name for bitmap fonts [Win3.0 compatibility]

    pifi->dpwszFamilyName    = pifi->dpwszFaceName;

//
// these names don't exist, so point to the NULL char  [Win3.1 compatibility]
// Note: lstrlen() does not count the terminating NULL.
//
    cchFaceName = strlen(pszFaceName);
    pifi->dpwszStyleName =
       pifi->dpwszFaceName + sizeof(WCHAR) * cchFaceName;
    pifi->dpwszUniqueName = pifi->dpwszStyleName;

// copy the strings to their new location. Here we assume that the sufficient
// memory has been allocated

#ifdef FE_SB // vBmfdFill_IFIMETRICS():Add @ to face name

    if( pfai->bVertical )
    {
        vToUNICODEN((PWSZ)((PBYTE)pifi + pifi->dpwszFaceName + sizeof(WCHAR)),
                                cchFaceName+1, pszFaceName, cchFaceName+1);

    // Insert @

        *(PWCHAR)((PBYTE)pifi + pifi->dpwszFaceName) = L'@';
    }
     else
    {
#endif // FE_SB
        vToUNICODEN((PWSZ)((PBYTE)pifi + pifi->dpwszFaceName), cchFaceName+1, pszFaceName, cchFaceName+1);

#ifdef FE_SB
    }
#endif // DBCS_VERT


    pifi->cjThis = pcvtfh->cjIFI;

//
// Check to see if simulations are necessary and if they are, fill
// in the offsets to the various simulation fields and update cjThis
// field of the IFIMETRICS structure
//
    switch (pfai->iDefFace)
    {
    case FF_FACE_NORMAL:
    case FF_FACE_BOLD:
    case FF_FACE_ITALIC:

        pifi->dpFontSim =
           OFFSET_OF_NEXT(
               DWORD,
               sizeof(IFIMETRICS) + pcvtfh->cjFaceName
               );

        pFontSim = (FONTSIM*) ((BYTE*)pifi + pifi->dpFontSim);

        switch (pfai->iDefFace)
        {
        case FF_FACE_NORMAL:
        //
        // simulations are needed for bold, italic, and bold-italic
        //
            pFontSim->dpBold       =
                OFFSET_OF_NEXT(DWORD,sizeof(FONTSIM));

            pFontSim->dpItalic     =
                OFFSET_OF_NEXT(DWORD,pFontSim->dpBold + sizeof(FONTDIFF));

            pFontSim->dpBoldItalic =
                OFFSET_OF_NEXT(DWORD,pFontSim->dpItalic + sizeof(FONTDIFF));


            pfdiffBold      =
                (FONTDIFF*) ((BYTE*) pFontSim + pFontSim->dpBold);

            pfdiffItalic    =
                (FONTDIFF*) ((BYTE*) pFontSim + pFontSim->dpItalic);

            pfdiffBoldItalic =
                (FONTDIFF*) ((BYTE*) pFontSim + pFontSim->dpBoldItalic);

            break;

        case FF_FACE_BOLD:
        case FF_FACE_ITALIC:
        //
        // a simulation is needed for bold-italic only
        //
            pFontSim->dpBold       = 0;
            pFontSim->dpItalic     = 0;

            pFontSim->dpBoldItalic = OFFSET_OF_NEXT(DWORD,sizeof(FONTSIM));
            pfdiffBoldItalic       =
                (FONTDIFF*) ((BYTE*) pFontSim + pFontSim->dpBoldItalic);
            break;

        default:

            RIP("BMFD -- bad iDefFace\n");
        }

        break;

    case FF_FACE_BOLDITALIC:

        pifi->dpFontSim = 0;
        break;

    default:

        RIP("vBmfdFill_IFIMETRICS -- bad iDefFace");

    }

    pifi->jWinCharSet        = ajHdr[OFF_CharSet];

    // There are two way to determine the pitch of a font.
    //
    // a) If the low nibble of ajHdr[OFF_Family] is not zero then
    //    the font is variable pitch otherwise it is fixed
    // b) if ajHdr[OFF_PixWidth] is non zero then the font is
    //    fixed pitch and this is the character width otherwise
    //    the font is varialble pitch
    //
    // Under Windows, method b) is used to determine the pitch of
    // a font. There exist buggy fonts in which methods a) and
    // b) give different answers. An example is found in Issac
    // Asimov's "The Ultimate Robot". For the font face "URPalatI"
    // method a) indicates that the font is fixed pitch while
    // method b) indicates that it is variable. The truth is that
    // this font is varialbe pitch. So, we choose method b).
    // Of course, if another font gives the correct answer for method
    // a) and the incorrect answer for method b) then we will
    // look bad.
    // Mon 27-Jun-1994 06:58:46 by Kirk Olynyk [kirko]

    pifi->jWinPitchAndFamily = ajHdr[OFF_Family] & 0xf0;
    pifi->jWinPitchAndFamily |= ajHdr[OFF_PixWidth] ? FIXED_PITCH : VARIABLE_PITCH;

#ifdef MAYBE_NEEDED_FOR_MET

    if (ajHdr[OFF_Family] & MONO_FONT)
    {
    // Have no idea what MONO_FONT is, some new win95 invetion

        pifi->jWinPitchAndFamily |= MONO_FONT;
    }

#endif

// weight, we have seen files where the weight has been 0 or some other junk
// we replace 400, our mapper would have done it anyway [bodind]

    pifi->usWinWeight = usMakeUSHORT((PBYTE)&ajHdr[OFF_Weight]);
    if ((pifi->usWinWeight > MAX_WEIGHT)  || (pifi->usWinWeight < MIN_WEIGHT))
        pifi->usWinWeight = 400;

    pifi->flInfo = (  FM_INFO_TECH_BITMAP
                    | FM_INFO_RETURNS_BITMAPS
                    | FM_INFO_1BPP
                    | FM_INFO_INTEGER_WIDTH
                    | FM_INFO_RIGHT_HANDED
                    | FM_INFO_INTEGRAL_SCALING
                    | FM_INFO_NONNEGATIVE_AC
#ifdef FE_SB // vBmfdFill_IFIMETRICS():set FM_INFO_90DEGREE_ROTATIONS flag
                    | FM_INFO_90DEGREE_ROTATIONS
#endif
                   );

// we have set it correctly above, we want to make sure that somebody
// is not going to alter that code so as to break the code here

    ASSERTGDI(
        ((pifi->jWinPitchAndFamily & 0xf) == FIXED_PITCH) || ((pifi->jWinPitchAndFamily & 0xf) == VARIABLE_PITCH),
        "BMFD!WRONG PITCH \n"
        );
#ifdef FE_SB // vBmfdFill_IFIMETRICS():remove FM_INFO_CONSTANT_WIDTH flag
    if ((pifi->jWinPitchAndFamily & 0xf) == FIXED_PITCH)
    {
        if( !bDBCSFont )
            pifi->flInfo |= FM_INFO_CONSTANT_WIDTH;

        pifi->flInfo |= FM_INFO_OPTICALLY_FIXED_PITCH;
    }

// Bmfd treat only FIXED pitch font in full width character, We report this infomation to GRE
// for optimaization

    if( bDBCSFont )
    {
        pifi->flInfo |= FM_INFO_DBCS_FIXED_PITCH;
    }
#else
    if ((pifi->jWinPitchAndFamily & 0xf) == FIXED_PITCH)
    {
        pifi->flInfo |= FM_INFO_CONSTANT_WIDTH;
        pifi->flInfo |= FM_INFO_OPTICALLY_FIXED_PITCH;
    }
#endif

    pifi->lEmbedId = 0;
    pifi->fsSelection = fsSelectionFlags(ajHdr);

//
// The choices for fsType are FM_TYPE_LICENSED and FM_READONLY_EMBED
// These are TrueType things and do not apply to old fashioned bitmap
// fonts.
//
    pifi->fsType = 0;

    sIntLeading = sMakeSHORT((PBYTE)&ajHdr[OFF_IntLeading]);
    pifi->fwdUnitsPerEm = (sIntLeading > 0) ?
        (FWORD)pcvtfh->cy - sIntLeading : (FWORD)pcvtfh->cy;

    pifi->fwdLowestPPEm    = 0;

    sAscent                = (FWORD)sMakeSHORT((PBYTE)&ajHdr[OFF_Ascent]);
    pifi->fwdWinAscender   = sAscent;
    pifi->fwdWinDescender  = (FWORD)pcvtfh->cy - sAscent;

    pifi->fwdMacAscender   =  sAscent;
    pifi->fwdMacDescender  = -pifi->fwdWinDescender;
    pifi->fwdMacLineGap    =  (FWORD)sMakeSHORT((PBYTE)&ajHdr[OFF_ExtLeading]);

    pifi->fwdTypoAscender  = pifi->fwdMacAscender;
    pifi->fwdTypoDescender = pifi->fwdMacDescender;
    pifi->fwdTypoLineGap   = pifi->fwdMacLineGap;

    pifi->fwdMaxCharInc    = (FWORD)pcvtfh->usMaxWidth;

    pifi->fwdAveCharWidth  = (FWORD)usMakeUSHORT((PBYTE)&ajHdr[OFF_AvgWidth]);
    if (pifi->fwdAveCharWidth > pcvtfh->usMaxWidth)
    {
    // fix the bug in the header if there is one

        pifi->fwdAveCharWidth = pcvtfh->usMaxWidth;
    }

// don't know much about SuperScripts

    pifi->fwdSubscriptXSize     = 0;
    pifi->fwdSubscriptYSize     = 0;
    pifi->fwdSubscriptXOffset   = 0;
    pifi->fwdSubscriptYOffset   = 0;

//
// don't know much about SubScripts
//
    pifi->fwdSuperscriptXSize   = 0;
    pifi->fwdSuperscriptYSize   = 0;
    pifi->fwdSuperscriptXOffset = 0;
    pifi->fwdSuperscriptYOffset = 0;

//
// win 30 magic. see the code in textsims.c in the Win 3.1 sources
//
    fwdHeight = pifi->fwdWinAscender + pifi->fwdWinDescender;
    pifi->fwdUnderscoreSize     = (fwdHeight > 12) ? (fwdHeight / 12) : 1;
    pifi->fwdUnderscorePosition = -(FWORD)(pifi->fwdUnderscoreSize / 2 + 1);

    pifi->fwdStrikeoutSize = pifi->fwdUnderscoreSize;

    {
    // We are further adjusting underscore position if underline
    // hangs below char stems.
    // The only font where this effect is noticed to
    // be important is an ex pm font sys08cga.fnt, presently used in console

        FWORD yUnderlineBottom = -pifi->fwdUnderscorePosition
                               + ((pifi->fwdUnderscoreSize + (FWORD)1) >> 1);

        FWORD dy = yUnderlineBottom - pifi->fwdWinDescender;

        if (dy > 0)
        {
        #ifdef CHECK_CRAZY_DESC
            DbgPrint("bmfd: Crazy descender: old = %ld, adjusted = %ld\n\n",
            (ULONG)pifi->fwdMaxDescender,
            (ULONG)yUnderlineBottom);
        #endif // CHECK_CRAZY_DESC

            pifi->fwdUnderscorePosition += dy;
        }
    }



//
// Win 3.1 method
//
//    LineOffset = ((((Ascent-IntLeading)*2)/3) + IntLeading)
//
// [remember that they measure the offset from the top of the cell,
//  where as NT measures offsets from the baseline]
//
    pifi->fwdStrikeoutPosition =
        (FWORD) ((sAscent - sIntLeading + 2)/3);

    pifi->chFirstChar   = pcvtfh->chFirstChar;
    pifi->chLastChar    = pcvtfh->chLastChar;
    pifi->chBreakChar   = pcvtfh->chBreakChar   + pcvtfh->chFirstChar;

// chDefault: here we are just putting the junk from the header, which we
// know may be wrong but this is what win31 is reporting.
// E.g. for SmallFonts (shipped with win31) they report
// 128 as default even though it is not even supported in a font.
// In NT however, we must report an existent char as default char to
// the engine. So for buggy fonts we break the relationship
//             wcDefault == AnsiToUnicode(chDefault);

    pifi->chDefaultChar = ((PBYTE)pre->pvResData)[OFF_DefaultChar] +
                          ((PBYTE)pre->pvResData)[OFF_FirstChar]   ;

// wcDefaultChar
// wcBreakChar

    vComputeSpecialChars(
        pcvtfh,
        &(pifi->wcDefaultChar),
        &(pifi->wcBreakChar)
        );

// These should be taken from the glyph set

    {
        FD_GLYPHSET * pgset = &pfai->pcp->gset;
        WCRUN *pwcrunLast =  &(pgset->awcrun[pgset->cRuns - 1]);

        pifi->wcFirstChar =  pgset->awcrun[0].wcLow;
        pifi->wcLastChar  =  pwcrunLast->wcLow + pwcrunLast->cGlyphs - 1;
    }

// This is what Win 3.1 returns for CapHeight and XHeight
// for TrueType fonts ... we will do the same here.
//
    pifi->fwdCapHeight = pifi->fwdUnitsPerEm/2;
    pifi->fwdXHeight   = pifi->fwdUnitsPerEm/4;

    pifi->dpCharSets = 0; // no multiple charsets in bm fonts

// All the fonts that this font driver will see are to be rendered left
// to right

    pifi->ptlBaseline.x = 1;
    pifi->ptlBaseline.y = 0;

    pifi->ptlAspect.y = (LONG) usMakeUSHORT((PBYTE)&ajHdr[OFF_VertRes ]);
    pifi->ptlAspect.x = (LONG) usMakeUSHORT((PBYTE)&ajHdr[OFF_HorizRes]);

    if (pifi->ptlAspect.y == 0)
    {
        pifi->ptlAspect.y = 1;
        WARNING("bmfd!vBmfdFill_IFIMETRICS():ptlAspect.y == 0\n");
    }
    if (pifi->ptlAspect.x == 0)
    {
        pifi->ptlAspect.x = 1;
        WARNING("bmfd!vBmfdFill_IFIMETRICS():ptlAspect.x == 0\n");
    }

    if (!(pifi->fsSelection & FM_SEL_ITALIC))
    {
    // The base class of font is not italicized,

        pifi->ptlCaret.x = 0;
        pifi->ptlCaret.y = 1;
    }
    else
    {
    // somewhat arbitrary

        pifi->ptlCaret.x = 1;
        pifi->ptlCaret.y = 2;
    }



//
// The font box reflects the  fact that a-spacing and c-spacing are zero
//
    pifi->rclFontBox.left   = 0;
    pifi->rclFontBox.top    = (LONG) pifi->fwdTypoAscender;
    pifi->rclFontBox.right  = (LONG) pifi->fwdMaxCharInc;
    pifi->rclFontBox.bottom = (LONG) pifi->fwdTypoDescender;

//
// achVendorId, unknown, don't bother figure it out from copyright msg
//
    pifi->achVendId[0] = 'U';
    pifi->achVendId[1] = 'n';
    pifi->achVendId[2] = 'k';
    pifi->achVendId[3] = 'n';

    pifi->cKerningPairs   = 0;

//
// Panose
//
    pifi->ulPanoseCulture = FM_PANOSE_CULTURE_LATIN;
    ppanose = &(pifi->panose);
    ppanose->bFamilyType = jFamilyType((USHORT)pifi->jWinPitchAndFamily);
    ppanose->bSerifStyle =
        ((pifi->jWinPitchAndFamily & 0xf0) == FF_SWISS) ?
            PAN_SERIF_NORMAL_SANS : PAN_ANY;

    ppanose->bWeight = (BYTE) WINWT_TO_PANWT(pifi->usWinWeight);
    ppanose->bProportion = (usMakeUSHORT((PBYTE)&ajHdr[OFF_PixWidth]) == 0) ? PAN_ANY : PAN_PROP_MONOSPACED;
    ppanose->bContrast        = PAN_ANY;
    ppanose->bStrokeVariation = PAN_ANY;
    ppanose->bArmStyle        = PAN_ANY;
    ppanose->bLetterform      = PAN_ANY;
    ppanose->bMidline         = PAN_ANY;
    ppanose->bXHeight         = PAN_ANY;

//
// Now fill in the fields for the simulated fonts
//

    if (pifi->dpFontSim)
    {
    //
    // Create a FONTDIFF template reflecting the base font
    //
        FONTDIFF FontDiff;

        FontDiff.jReserved1      = 0;
        FontDiff.jReserved2      = 0;
        FontDiff.jReserved3      = 0;
        FontDiff.bWeight         = pifi->panose.bWeight;
        FontDiff.usWinWeight     = pifi->usWinWeight;
        FontDiff.fsSelection     = pifi->fsSelection;
        FontDiff.fwdAveCharWidth = pifi->fwdAveCharWidth;
        FontDiff.fwdMaxCharInc   = pifi->fwdMaxCharInc;
        FontDiff.ptlCaret        = pifi->ptlCaret;

        if (pfdiffBold)
        {
            *pfdiffBold = FontDiff;
            pfdiffBoldItalic->bWeight    = PAN_WEIGHT_BOLD;
            pfdiffBold->fsSelection     |= FM_SEL_BOLD;
            pfdiffBold->usWinWeight      = FW_BOLD;
            pfdiffBold->fwdAveCharWidth += 1;
            pfdiffBold->fwdMaxCharInc   += 1;
        }

        if (pfdiffItalic)
        {
            *pfdiffItalic = FontDiff;
            pfdiffItalic->fsSelection     |= FM_SEL_ITALIC;
            pfdiffItalic->ptlCaret.x = 1;
            pfdiffItalic->ptlCaret.y = 2;
        }

        if (pfdiffBoldItalic)
        {
            *pfdiffBoldItalic = FontDiff;
            pfdiffBoldItalic->bWeight          = PAN_WEIGHT_BOLD;
            pfdiffBoldItalic->fsSelection     |= (FM_SEL_BOLD | FM_SEL_ITALIC);
            pfdiffBoldItalic->usWinWeight      = FW_BOLD;
            pfdiffBoldItalic->fwdAveCharWidth += 1;
            pfdiffBoldItalic->fwdMaxCharInc   += 1;
            pfdiffBoldItalic->ptlCaret.x       = 1;
            pfdiffBoldItalic->ptlCaret.y       = 2;
        }
    }

}



#if defined(_X86_)

extern VOID vLToE(FLOATL *pe, LONG l);
/*
VOID vLToE(FLOATL *pe, LONG l)
{
    PULONG pul = (PULONG)pe;

    ASSERTGDI(sizeof(FLOAT) == sizeof(LONG),
              "vLtoE : sizeof(FLOAT) != sizeof(LONG)\n");

    *pul = ulLToE(l);
}
*/

/*
//!!! an assembly routine should be provided here instead
//!!! Now we comment out all lines where this function should be
//!!! used. Fortunately, this info is not used by the Engine yet
//!!! This is done per request of mikehar (BodinD)

VOID vDivE(FLOAT *pe, LONG l1, LONG l2)   // *pe = l1/l2
{
//!!! this is a hack, it must be fixed to avoid
// 387 instructions in assembled code. This does not work
// on a machine without 387 or a system without math emulator

    *pe = ((FLOAT)l1) / ((FLOAT)l2);
}

*/

#endif


/******************************Public*Routine******************************\
* bDescStr
*
* Grunge around in the EXE header to retrieve the description string.  Copy
* the string (if found) to the return string buffer.  This buffer should
* be at least 256 characters.  The EXE format limits the string to 255
* characters (not including a terminating NULL).
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  09-Mar-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

// !!! [GilmanW] 09-Mar-1992
// !!! This only supports the 16-bit .FON file format (which corresponds to
// !!! the 16-bit NEWEXE format defined in exehdr.h).
// !!!
// !!! We need to add support for the 32-bit .FON format, whatever that is.
// !!!
// !!! Effect this has on 32-bit files: facename will be used as descr string.

BOOL
bDescStr(
    PVOID pvView,
    SIZE_T cjView,
    PSZ pszString
    )
{
    PTRDIFF dpNewExe;       // offset to NEWEXE header
    PTRDIFF dpNRSTOffset;   // offset to non-resident names table
    ULONG cch;              // count of characters in string resource
    PSZ psz;                // pointer to characters in string resource
    PSZ pszTmp;
    PBYTE pj = (PBYTE) pvView;    // PBYTE pointer into file view

#ifdef DUMPCALL
    DbgPrint("\nbDescStr(\n"                            );
    DbgPrint("    PSZ pszString  = %-#8lx\n", pszString );
    DbgPrint("    );\n\n"                               );
#endif

// Validation.  Check EXE_HDR magic number.

    if (OFF_e_magic + sizeof(WORD) > cjView)
    {
        WARNING("bmfd!bDescStr(): header too short\n");
        return (FALSE);
    }

    if (READ_WORD(pj + OFF_e_magic) != EMAGIC)
    {
        WARNING("bmfd!bDescStr(): not a 16-bit .FON file (bad EMAGIC number)!\n");
        return(FALSE);
    }

// More validation.  Check NEWEXE magic number.

    dpNewExe = READ_DWORD(pj + OFF_e_lfanew);

    if ((dpNewExe < 0) || (dpNewExe + sizeof(USHORT) >  cjView))
    {
        WARNING("bmfd!bDescStr(): bad dpNewExe\n");
        return (FALSE);
    }

    if (READ_WORD(pj + dpNewExe) != NEMAGIC )
    {
        WARNING("bmfd!bDescStr(): not a 16-bit .FON file (bad NEMAGIC number)!\n");
        return(FALSE);
    }

// Get description string out of the non-resident strings table of the
// NEWEXE header.  Resource strings are counted strings: the first byte
// is the count of characters, and the string follows.  A NULL is not
// guaranteed.  However, we know the string is < 256 characters.

    dpNRSTOffset = READ_DWORD(pj + dpNewExe + OFF_ne_nrestab);

    if ( (DWORD)(dpNRSTOffset) >  cjView - 1) // one byte the Pascal style string length
    {
        WARNING("bmfd!bDescStr(): bad dpNRSTOffset\n");
        return (FALSE);
    }

    // If zero length string, then there is none.

    if ( (cch = (ULONG)(*(pj + dpNRSTOffset))) == 0 )
    {
        WARNING("bmfd!bDescStr(): bad description string\n");
        return (FALSE);
    }

    if ((dpNRSTOffset + 2 + cch >  cjView) || (*(pj + dpNRSTOffset + cch + 1) != 0))
        // length of the string + one character for the pascal size + one character for the null terminator
    {
        WARNING("bmfd!bDescStr(): bad string\n");
        return (FALSE);
    }

    // Pointer to the actual string.

    psz = pj + dpNRSTOffset + 1;

// Parse out the "FONTRES xxx, yyy, zzz : " header if it exists.

    if ( (pszTmp = strchr(psz, ':')) != (PSZ) NULL )
    {
    // Skip over the ':'.

        pszTmp++;
        cch -= (ULONG)(pszTmp - psz);

    // Skip spaces.

        while ( *pszTmp == ' ' && cch > 0) 
        {
            pszTmp++;
            cch--;
        }

    // If not at end of string, then we're at the string.

        if ( *pszTmp != '\0' && cch > 0)
        {
            psz = pszTmp;
        }

    // Otherwise, this is a bad string (contains only a header).

        else
        {
            WARNING("bmfd!bDescStr(): bad description string (only string header)\n");
            return (FALSE);
        }
    }

// Copy the string.

    strncpy(pszString, psz, cch);
    pszString[cch] = '\0';          // add terminating NULL

// Success.

    return(TRUE);
}

/******************************Public*Routine******************************\
*
* PBYTE pjRawBitmap
*
* gets the pointer to the raw bitmap data in the resource file
*
* History:
*  23-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

PBYTE
pjRawBitmap(
    HGLYPH      hg,      // IN
    PCVTFILEHDR pcvtfh,  // IN
    PRES_ELEM   pre,     // IN
    PULONG      pcx      // OUT place cx here
    )
{
// size of table entry in USHORT's

    ULONG cusTableEntry = ((pcvtfh->iVersion == 0x00000200) ? 2 : 3);

// get the pointer to the beginning of the offset table in
// the original *.fnt file

    PUSHORT pusOffTable = (PUSHORT)((PBYTE)pre->pvResData + pcvtfh->dpOffsetTable);
    PUSHORT pus_cx;
    DWORD   dwOffset;

#ifdef DUMPCALL
    DbgPrint("\npjRawBitmap(\n");
    DbgPrint("    HGLYPH      hg     = %-#8lx\n", hg    );
    DbgPrint("    PCVTFILEHDR pcvtfh = %-#8lx\n", pcvtfh);
    DbgPrint("    PRES_ELEM   pre    = %-#8lx\n", pre   );
    DbgPrint("    PULONG      pcx    = %-#8lx\n", pcx   );
    DbgPrint("    );\n\n"                               );
#endif

// hg is equal to the ansi value of the glyph - chFirstChar:

    if (hg > (HGLYPH)(pcvtfh->chLastChar - pcvtfh->chFirstChar))
    {
        // DbgPrint ( "hg 0x %lx, chFirst 0x %x, chLastChar 0x %x \n",
        //         hg, (WCHAR)pcvtfh->chFirstChar, (WCHAR)pcvtfh->chLastChar);

        hg = pcvtfh->chDefaultChar;
    }

// points to the table entry for this character

    pus_cx = pusOffTable + hg * cusTableEntry;

// If cx is non-zero, then the character exists, else use default char

    *pcx = *pus_cx;

    if (*pus_cx == 0)
    {
    // no bits, will have to return fake bitmap

        return NULL;
    }

// increment pus_cx to point to the offset to the bitmap in the resource file

    pus_cx++;

    if (pcvtfh->iVersion == 0x00000200)
    {
        dwOffset = READ_WORD(pus_cx);
    }
    else // long offset, win 3.0 format
    {
        dwOffset = READ_DWORD(pus_cx);
    }

    if (dwOffset > (CJ_SCAN(*pcx) * pcvtfh->cy) + dwOffset ||
          (CJ_SCAN(*pcx) * pcvtfh->cy) + dwOffset >  pre->cjResData)
    {
    // bitmap is out of font file, will have to return fake bitmap

        WARNING("bmfd!pjRawBitmap(): bitmap is out of font file\n");
        *pcx = 0;
        return NULL;
    }
   return ((PBYTE)pre->pvResData + dwOffset);

}

/******************************Public*Routine******************************\
*
* vCheckOffsetTable: fixes the possible problems in the file header
*
* History:
*  23-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vCheckOffsetTable(
    PCVTFILEHDR pcvtfh,
    PRES_ELEM   pre
    )
{
    ULONG    cusTableEntry;  // size of table entry in USHORT's
    ULONG    i;              // loop index
    USHORT   cxMax;          // has to be computed since there are bugs in files
    ULONG    cCodePoints = pcvtfh->chLastChar + 1 - pcvtfh->chFirstChar;
    PUSHORT  pus_cx;         // pointer to the beginning of the offset table

#ifdef DUMPCALL
    DbgPrint("\nvCheckOffsetTable(\n"                   );
    DbgPrint("    PCVTFILEHDR pcvtfh = %-#8lx\n", pcvtfh);
    DbgPrint("    PRES_ELEM   pre    = %-#8lx\n", pre   );
    DbgPrint("    );\n\n"                               );
#endif

    pus_cx = (PUSHORT)((PBYTE)pre->pvResData + pcvtfh->dpOffsetTable);

    ASSERTGDI (
        ((ULONG_PTR)pus_cx & 1L) == 0,
        "offset table begins at odd address\n"
        );

// initialize the max so far

    cxMax = 0;

    if (pcvtfh->iVersion == 0x00000200)        // 2.0 font file
        cusTableEntry = 2; // 2 bytes for cx + 2 bytes for offset
    else    // 3.0 font file
    {
        ASSERTGDI(pcvtfh->iVersion == 0x00000300, "must be 0x00000300 font\n");
        cusTableEntry = 3; // 2 bytes for cx + 4 bytes for offset
    }

// check offset table for all codepoints. It is important to find the
// real cxMax and not to trust the value in the header since as we have
// seen it may be wrong, which could cause a crash. This in fact is the
// case with one of the faces in aldfonte.fon, where they report avg. width
// to be 0x14 and max width to be 0x13, i.e. smaller than the avg!!!!.
// However, cxMax for that font, found in the loop below, turns out to be
// 0x14, i.e. >= avg width, as it should be. [bodind]

    pcvtfh->fsFlags = 0;

    for (i = 0; i < cCodePoints; i++, pus_cx += cusTableEntry)
    {
        if ((*pus_cx) > cxMax)
            cxMax = (*pus_cx);

    // See if this font file contains zero width glyphs,
    // if so we have to turn off usual DEVICEMETRICS accelerator
    // flags for this font. We shall have to be providing
    // the fake 1x1 bitmap for this font.

        if ((*pus_cx) == 0)
        {
            pcvtfh->fsFlags |= FS_ZERO_WIDTH_GLYPHS;
        }
    }

#ifdef FOOGOO
    if (pcvtfh->fsFlags & FS_ZERO_WIDTH_GLYPHS)
    {
        KdPrint(("\n %s: .fnt font resource with zero width glyphs\n", pre->pjFaceName));
    }
#endif

// cache the values

    pcvtfh->cjGlyphMax = CJ_GLYPHDATA(cxMax,pcvtfh->cy);

    pcvtfh->usMaxWidth = max(pcvtfh->usMaxWidth, cxMax);

}

#if DBG
/******************************Public*Routine******************************\
* vDumpFontHeader                                                          *
*                                                                          *
* History:                                                                 *
*  Mon 27-Jun-1994 07:00:29 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

#define GETBYTE(XXX)  ajHdr[OFF_##XXX]
#define GETWORD(XXX)  READ_WORD(&ajHdr[OFF_##XXX])
#define GETDWORD(XXX) READ_DWORD(&ajHdr[OFF_##XXX])

VOID vDumpFontHeader(
    PRES_ELEM   pre
  , VPRINT      vPrint
)
{
    PBYTE ajHdr  = (PBYTE)pre->pvResData;

    vPrint("\n\nvDumpFontHeader\n\n");
    vPrint("Version     = %-#x\n", GETWORD(Version));
    vPrint("Size        = %-#x\n", GETDWORD(Size));
    vPrint("Copyright   = \"%s\"\n",ajHdr + OFF_Copyright);
    vPrint("Type        = %-#x\n", GETWORD(Type));
    vPrint("Points      = %-#x\n", GETWORD(Points));
    vPrint("VertRes     = %-#x\n", GETWORD(VertRes));
    vPrint("HorizRes    = %-#x\n", GETWORD(HorizRes));
    vPrint("Ascent      = %-#x\n", GETWORD(Ascent));
    vPrint("IntLeading  = %-#x\n", GETWORD(IntLeading));
    vPrint("ExtLeading  = %-#x\n", GETWORD(ExtLeading));
    vPrint("Italic      = %-#x\n", GETBYTE(Italic));
    vPrint("Underline   = %-#x\n", GETBYTE(Underline));
    vPrint("StrikeOut   = %-#x\n", GETBYTE(StrikeOut));
    vPrint("Weight      = %-#x\n", GETWORD(Weight));
    vPrint("CharSet     = %-#x\n", GETBYTE(CharSet));
    vPrint("PixWidth    = %-#x\n", GETWORD(PixWidth));
    vPrint("PixHeight   = %-#x\n", GETWORD(PixHeight));
    vPrint("Family      = %-#x\n", GETBYTE(Family));
    vPrint("AvgWidth    = %-#x\n", GETWORD(AvgWidth));
    vPrint("MaxWidth    = %-#x\n", GETWORD(MaxWidth));
    vPrint("FirstChar   = %-#x\n", GETBYTE(FirstChar));
    vPrint("LastChar    = %-#x\n", GETBYTE(LastChar));
    vPrint("DefaultChar = %-#x\n", GETBYTE(DefaultChar));
    vPrint("BreakChar   = %-#x\n", GETBYTE(BreakChar));
    vPrint("WidthBytes  = %-#x\n", GETWORD(WidthBytes));
    vPrint("Device      = %-#x\n", GETDWORD(Device));
    vPrint("Face        = %-#x\n", GETDWORD(Face));
    vPrint("            = \"%s\"\n",
        (PSZ)(pre->pjFaceName == 0 ? ajHdr + GETWORD(Face) : pre->pjFaceName));
    vPrint("BitsPointer = %-#x\n", GETDWORD(BitsPointer));
    vPrint("BitsOffset  = %-#x\n", GETDWORD(BitsOffset));
    vPrint("jUnused20   = %-#x\n", GETBYTE(jUnused20));
    vPrint("OffTable20  = %-#x\n", GETWORD(OffTable20));
    vPrint("\n\n");
    {
    // consistency checks go here

    char *pszBad = "Inconsistency detected:";
    if ((GETWORD(PixWidth)) && (GETWORD(PixWidth) != GETWORD(MaxWidth)))
        DbgPrint("%s PixWidth != MaxWidth\n",pszBad);
    if ((ajHdr[OFF_Family] & 0xf) && ajHdr[OFF_PixWidth])
        DbgPrint("%s Family indicates variable pitch and PixWidth indicates fixed\n",pszBad);
    else if (!(ajHdr[OFF_Family] & 0xf) && !ajHdr[OFF_PixWidth])
        DbgPrint("%s Family indicates fixed pitch and PixWidth indicates variable\n",pszBad);
    vPrint("\n\n");
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\bmfd\fon32.c ===
/******************************Module*Header*******************************\
* Module Name: fon32.c
*
* support for 32 bit fon files
*
* Created: 03-Mar-1992 15:48:53
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/

#include "fd.h"

/******************************Public*Routine******************************\
* bLoadntFon()
*
* History:
*  07-Jul-1995 -by- Gerrit van Wingerden [gerritv]
* Rewrote for kernel mode.
*  02-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bLoadNtFon(
    HFF    iFile,
    PVOID  pvView,
    HFF    *phff
    )
{
    PFONTFILE      pff;
    IFIMETRICS*    pifi;
    INT            cFonts,i;
    BOOL           bRet = FALSE;
    PVOID          *ppvBases = NULL;
    ULONG          cjIFI,cVerified;
    ULONG          dpIFI;
    ULONG          dpszFileName;
    ULONG          cjff;
#ifdef FE_SB
    ULONG          cVerticalFaces = 0;
    USHORT         CharSet;
#endif
    PBYTE          pjViewBase;
    SIZE_T         cjViewSize;

    // first find the number of font resource in the executeable

    cFonts = cParseFontResources( (HANDLE) iFile, &ppvBases );

    if (cFonts == 0)
    {
        return bRet;
    }
    cVerified = cjIFI = 0;

    // next loop through all the FNT resources to get the size of each fonts
    // IFIMETRICS

    pjViewBase = (PBYTE)((PFONTFILEVIEW)iFile)->fv.pvViewFD;
    cjViewSize = ((PFONTFILEVIEW)iFile)->fv.cjView;

    for( i = 0; i < cFonts; i++ )
    {
        RES_ELEM re;
        ULONG cjBMFDIFIMETRICS;

        re.pvResData = ppvBases[i];
        re.cjResData = ulMakeULONG((PBYTE) ppvBases[i] + OFF_Size );
        re.pjFaceName = NULL;

        if( !bVerifyFNTQuick( &re ) )
        {
            goto exit_freemem;
        }

        if (!bBMFDIFIMETRICS(pjViewBase, cjViewSize, NULL, &re, &cjBMFDIFIMETRICS))
        {
            goto exit_freemem;
        }

        cVerified += 1;
        cjIFI += cjBMFDIFIMETRICS;
    }

    *phff = (HFF)NULL;

#ifdef FE_SB
// extra space for possible vertical face
    cjIFI *= 2;
    dpIFI = offsetof(FONTFILE,afai[0]) + cVerified * 2 * sizeof(FACEINFO);
#else
    dpIFI = offsetof(FONTFILE,afai[0]) + cVerified * sizeof(FACEINFO);
#endif
    dpszFileName = dpIFI + cjIFI;
    cjff = dpszFileName;

    if ((*phff = hffAlloc(cjff)) == (HFF)NULL)
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        RETURN("BMFD! bLoadDll32: memory allocation error\n", FALSE);
    }
    pff = PFF(*phff);

    // init fields of pff structure

    pff->ident      = ID_FONTFILE;
    pff->fl         = 0;
    pff->iType      = TYPE_DLL32;
    pff->cFntRes    = cVerified;
    pff->iFile      = iFile;

    //!!! we could do better here, we could try to get a description string from
    //!!! the version stamp of the file, if there is one, if not we can still use
    //!!! this default mechanism [bodind]

    pff->dpwszDescription = 0;   // no description string, use Facename later
    pff->cjDescription    = 0;

    // finally convert all the resources

    pifi = (IFIMETRICS*)((PBYTE) pff + dpIFI);



    for( i = 0; i < cFonts; i++ )
    {
        RES_ELEM re;
        re.pvResData = ppvBases[i];
        re.cjResData = ulMakeULONG((PBYTE) ppvBases[i] + OFF_Size );
        re.dpResData = (PTRDIFF)((PBYTE) re.pvResData - (PBYTE) pvView );
        re.pjFaceName = NULL;

        pff->afai[i].re = re;
        pff->afai[i].pifi = pifi;
#if FE_SB
        pff->afai[i].bVertical = FALSE;
#endif
        if( !bConvertFontRes( pjViewBase, cjViewSize, &re, &pff->afai[i] ) )
        {
            goto exit_freemem;
        }

        pifi = (IFIMETRICS*)((PBYTE)pifi + pff->afai[i].pifi->cjThis);

#ifdef FE_SB
        CharSet = pff->afai[i].pifi->jWinCharSet;

        if( IS_ANY_DBCS_CHARSET(CharSet) )
        {
            re.pvResData = ppvBases[i];
            re.cjResData = ulMakeULONG((PBYTE) ppvBases[i] + OFF_Size );
            re.dpResData = (PTRDIFF)((PBYTE) re.pvResData - (PBYTE) pvView );
            re.pjFaceName = NULL;

            pff->afai[cFonts+cVerticalFaces].re = re;
            pff->afai[cFonts+cVerticalFaces].pifi = pifi;
            pff->afai[cFonts+cVerticalFaces].bVertical = TRUE;

            if( !bConvertFontRes( pjViewBase, cjViewSize, &re, &pff->afai[cFonts+cVerticalFaces] ) )
            {
                goto exit_freemem;
            }

            pifi = (IFIMETRICS*)((PBYTE)pifi + pff->afai[i].pifi->cjThis);
            cVerticalFaces += 1;
        }
#endif
    }

#ifdef FE_SB
    pff->cFntRes += cVerticalFaces;
#endif

    bRet = TRUE;
    pff->cRef = 0L;

exit_freemem:

    EngFreeMem( (PVOID*) ppvBases );

    if( !bRet && *phff )
    {
        EngFreeMem( (PVOID) *phff );
        *phff = (HFF)NULL;
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\bmfd\fontfile.h ===
/******************************Module*Header*******************************\
* Module Name: fontfile.h
*
* (Brief description)
*
* Created: 25-Oct-1990 09:20:11
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
* Dependencies:
*
*   (#defines)
*   (#includes)
*
\**************************************************************************/

// The CVTRESDATA  struct contains the info about particular resource
// The info is in the converted form (RES_ELEM points to the "raw"
// data in the font file, while  CVTRESDATA points to the data obtained
// from bConvertFontRes

// header of the converted font file, it is used both for 2.0 and 3.0 files,
// the fields that are 3.0 specofic are all zero filled for 2.0 font file.
// this structure has proper DWORD allignment, so that its fields can be
// accessed in the usual fashion, pcvtfh->field_name

#define FS_ZERO_WIDTH_GLYPHS     1

typedef struct _CVTFILEHDR        //  cvtfh,
{
    USHORT  iVersion;             // 2 OR 3
    USHORT  fsFlags;              // zero width glyphs present
    UCHAR   chFirstChar;          // First character defined in font
    UCHAR   chLastChar;           // Last character defined in font
    UCHAR   chDefaultChar;        // Sub. for out of range chars.
    UCHAR   chBreakChar;          // Word Break Character

    USHORT  cy;                   // height in Fixed Height
    USHORT      usMaxWidth;           // Maximum width; one of the corrected values
#ifdef FE_SB // _CVTFILEHDR - add fields for DBCS
    USHORT      usDBCSWidth;          // Width of double byte character
    USHORT      usCharSet;            // Charset of this font resource
#endif // FE_SB

    PTRDIFF     dpOffsetTable;      // offset to the offset table, I added this field

// fields that have no analog in original headers, to be filled with the data
// that corresponds to the converted "file" only. This info is cashed for
// later use by vFill_IFIMETRICS

    ULONG  cjFaceName;
    ULONG  cjIFI;
    ULONG  cjGlyphMax;    // size of the largest GLYPHDATA structure in ULONG's

} CVTFILEHDR, *PCVTFILEHDR;


// flags for the fsSelection field are the same as for the corresponding
// field of the IFIMETRICS structure of the ntifi.h interface, i.e.:

// FM_SEL_ITALIC
// FM_SEL_STRIKEOUT
// FM_SEL_UNDERSCORE
// FM_SEL_BOLD



typedef struct _FACEINFO  // fai
{
    RES_ELEM     re;
    HANDLE       hResData;   // only used for 32 bit dlls
#ifdef FE_SB
    BOOL         bVertical;  // if this face is @face , this field is TRUE
#endif // FE_SB
    CVTFILEHDR   cvtfh;      // aligned and CORRECTED data from the ogiginal header
    ULONG        iDefFace;
    CP_GLYPHSET *pcp;        // pointer to struc describing supported glyph set
    IFIMETRICS  *pifi;       // pointer to ifimetrics for this face
} FACEINFO, *PFACEINFO;


// The FACEDATA  struct contains the info about particular face
// (simulated faces included)

// allowed values for the FACEDATA.iSimulate field, !!! these must not change

#define  FC_SIM_NONE               0L
#define  FC_SIM_EMBOLDEN           1L
#define  FC_SIM_ITALICIZE          2L
#define  FC_SIM_BOLDITALICIZE      3L



typedef struct _BM_FONTFILE       *PFONTFILE;    // pff
typedef struct _BM_FONTCONTEXT    *PFONTCONTEXT; // pfc


#define FF_EXCEPTION_IN_PAGE_ERROR 1

typedef struct _BM_FONTFILE    // ff
{
// fields required by handle manager

    ULONG   ident;          // identifier,conveniently chosen as 0X000000FF

// remaining fields

    FLONG fl;
    ULONG iType;            // original file is *.fnt, 16 bit dll or 32 bit dll

    HFF   iFile;    

    ULONG cRef;    // # no of times this font file is selected into fnt context

    ULONG   cFntRes; // # of *.fnt files associated with this fontfile struct
                     // == # of default faces

    ULONG   cjDescription;      // size of the desctiption string (in bytes)
                                // if size is zero, then there is no string
                                // and the facename should be used instead.

    PTRDIFF dpwszDescription;   // offset to the description string

// array of FACEDATA strucs, which is followed by a UNICODE description
// string.
// Full size of the FONTFILE structure is equal to

    FACEINFO afai[1];
} FONTFILE;

// allowed values for FONTFILE.iType field:

// ORIGINAL FILE IS AN *.FNT FILE which contains a single
// size of the single font

#define TYPE_FNT          1L

// ORIGINAL FILE IS A win 3.0 16 bit *.DLL (*.fon FILE),
// This file is compiled out of many *.fnt files
// that correspond to different sizes of the same face, (e.g. tmsr or helv)
// This is provided to ensure binary compatibility with win 3.0 *.fon files

#define TYPE_DLL16        2L

// ORIGINAL FILE IS A win 3.0 32 bit *.DLL
// This file is compiled out of many *.fnt files using NT tools
// (coff linker and nt resource compiler)

#define TYPE_DLL32        3L

// an fnt file that is embeded in an exe and loaded using FdLoadResData

#define TYPE_EXE          4L


//
// Allowed values for the    FONTFILE.iDefaultFace field
//

#define FF_FACE_NORMAL          0L
#define FF_FACE_BOLD            1L
#define FF_FACE_ITALIC          2L
#define FF_FACE_BOLDITALIC      3L


typedef struct _BM_FONTCONTEXT     // fc
{
// fields required by handle manager

    ULONG ident;            // identifier,conveniently chosen as 0X000000FC

// remaining fields

    HFF    hff;      // handle of the font file selected into this context

#ifdef FE_SB // FONTCONTEXT
    ULONG ulRotate;         // Rotation degree 0 , 900 , 1800 , 2700
#endif // FE_SB

// which resource (face) this context corresponds

    FACEINFO *pfai;

// what to do

    FLONG flFontType;

//  For Win 3.1 compatibility raster fonts can be scaled from 1 to 5
//  vertically and 1-256 horizontally.  ptlScale contains the x and y
//  scaling factors.

    POINTL ptlScale;

// the size of the GLYPHDATA structure necessary to store the largest
// glyph bitmap with the header info. This is value is cashed at the
// time the font context is opened and used later in FdQueryGlyphBitmap

    ULONG cxMax;        // the width in pels of the largest bitmap
    ULONG cjGlyphMax;   // size of the RASTERGLYPH for the largest glyph

// true if ptlScale != (1,1)

    FLONG flStretch;

// buffer of the width of the maximum bm scan, to be used by sretch routine
// We shall only use ajStrecthBuffer if the buffer of length CJ_STRETCH
// that is allocated on the stack is not big enough, which should almost
// never happen

    BYTE ajStretchBuffer[1];

}FONTCONTEXT;

// set if ptlScale != (1,1)

#define FC_DO_STRETCH       1

// set if streching WIDE glyph which can not fit in CJ_STRETCH buffer

#define FC_STRETCH_WIDE   2


// exaple: if CJ_STRETCH == 256, that suffices for bitmap of width cx = 2048
// ==  8 bits * 256 bytes

#define CJ_STRETCH (sizeof(DWORD)  * 64)


//
//  The face  provided in the *.fnt file may or may not be emboldened
//  or italicized, but most often (I'd say in 99.99% of the cases)
//  it will be neither emboldened nor italicized.
//
//  If the font provided in the *.fnt file is "normal" (neither bold nor italic)
//  there will be 4 faces associated with this *.fnt:
//
//       default,                   // neither bold nor italic
//       emboldened,                // simulated
//       italicized                 // simulated
//       emboldened and italicized. // simulated
//
//  If the font provided in the *.fnt file is already emboldened
//  there will be 2 faces associated with this *.fnt:
//
//       default,       // already emboldened
//       italicized     // will appear as emboldened and italicized font
//                      // where italicization will be simulated
//
//  If the font provided in the *.fnt file is already italicized
//  there will be 2 faces associated with this *.fnt:
//
//       default,       // already italicized
//       emboldened     // will appear as emboldened and italicized font
//                      // where emboldening will be simulated
//
//  If the font provided in the *.fnt file is already italicized and emboldened
//  only a single default face will be associated with this *.fnt. No simulated faces
//  will be provided
//

// identifiers for FONTFILE and FONTCONTEXT objects

#define ID_FONTFILE     0x000000FF
#define ID_FONTCONTEXT  0x000000FC

// object types for these objects

#define TYPE_FONTCONTEXT    (OBJTYPE)0x0040
#define TYPE_FONTFILE       (OBJTYPE)0x0041



// basic "methods" that act on the FONTFILE object  (in fontfile.c)

#define hffAlloc(cj)         ((HFF)EngAllocMem(0, cj, 'dfmB'))
#define PFF(hff)             ((PFONTFILE)(hff))

// basic "methods" that act on the FONTCONTEXT object  (in fontfile.c)

#define hfcAlloc(cj)         ((HFC)EngAllocMem(0, cj, 'dfmB'))
#define PFC(hfc)             ((PFONTCONTEXT)(hfc))

#undef  VFREEMEM
#define VFREEMEM(pv)         EngFreeMem((PVOID)pv)

extern HSEMAPHORE   ghsemBMFD;
extern CP_GLYPHSET *gpcpGlyphsets;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\bmfd\fontfile.c ===
/******************************Module*Header*******************************\
* Module Name: fontfile.c
*
* "methods" for operating on FONTCONTEXT and FONTFILE objects
*
* Created: 18-Nov-1990 15:23:10
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "fd.h"

HSEMAPHORE ghsemBMFD;

/******************************Public*Routine******************************\
*
* VOID vBmfdMarkFontGone(FONTFILE *pff, DWORD iExceptionCode)
*
*
* Effects:
*
* Warnings:
*
* History:
*  07-Apr-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vBmfdMarkFontGone(FONTFILE *pff, DWORD iExceptionCode)
{

    ASSERTGDI(pff, "bmfd!vBmfdMarkFontGone, pff\n");
    
    EngAcquireSemaphore(ghsemBMFD);    

// this font has disappeared, probably net failure or somebody pulled the
// floppy with vt file out of the floppy drive

    if (iExceptionCode == STATUS_IN_PAGE_ERROR) // file disappeared
    {
    // prevent any further queries about this font:

        pff->fl |= FF_EXCEPTION_IN_PAGE_ERROR;
        EngUnmapFontFileFD(pff->iFile);
    }
    
    EngReleaseSemaphore(ghsemBMFD);

    if (iExceptionCode == STATUS_ACCESS_VIOLATION)
    {
        RIP("BMFD!this is probably a buggy BITMAP font file\n");
    }
}

BOOL bBmfdMapFontFileFD(FONTFILE *pff)
{
    PVOID       pvView;
    COUNT       cjView;

    return (pff ? (EngMapFontFileFD(pff->iFile, (PULONG *)&pvView, &cjView))
                : FALSE);
}

/******************************Public*Routine******************************\
*
* try/except wrappers:
*
*    BmfdQueryFontData,
*    BmfdLoadFontFile,
*    BmfdUnloadFontFile,
*    BmfdQueryAdvanceWidths
*
* History:
*  29-Mar-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG
BmfdQueryFontDataTE (
    DHPDEV  dhpdev,
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH  hg,
    GLYPHDATA *pgd,
    PVOID   pv,
    ULONG   cjSize
    )
{
    LONG lRet = FD_ERROR;

    DONTUSE(dhpdev);
    
    if (bBmfdMapFontFileFD((FONTFILE *)pfo->iFile))
    {
#ifndef BMFD_NO_TRY_EXCEPT
        try
        {
#endif
            lRet = BmfdQueryFontData (pfo, iMode, hg, pgd, pv, cjSize);
#ifndef BMFD_NO_TRY_EXCEPT
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("bmfd, exception in BmfdQueryFontData\n");
            vBmfdMarkFontGone((FONTFILE *)pfo->iFile, GetExceptionCode());
        }
#endif

        EngUnmapFontFileFD(PFF(pfo->iFile)->iFile);
    }
    return lRet;
}

/******************************Public*Routine******************************\
*
* BmfdLoadFontFileTE
*
*
* History:
*  07-Apr-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

ULONG ExceptionFilter_BmfdLoadFontFile(PEXCEPTION_POINTERS ExceptionPointers)
{
#if DBG
    const static char Function[] = __FUNCTION__;
    ULONG ExceptionCode;

    ExceptionCode = ExceptionPointers->ExceptionRecord->ExceptionCode;

    if (ExceptionCode != STATUS_IN_PAGE_ERROR)
    {
        DbgPrint(
            "%s: .exr %p\n%s: .cxr %p\n",
            Function,
            ExceptionPointers->ExceptionRecord,
            Function,
            ExceptionPointers->ContextRecord
            );

        ASSERTGDI(ExceptionCode == STATUS_IN_PAGE_ERROR,
                      "bmfd!bBmfdLoadFontFile, strange exception code\n");
    }
#endif
    return EXCEPTION_EXECUTE_HANDLER;
}

HFF
BmfdLoadFontFileTE (
    ULONG  cFiles,
    HFF   *piFile,
    PVOID *ppvView,
    ULONG *pcjView,
    DESIGNVECTOR *pdv,
    ULONG  ulLangId,
    ULONG  ulFastCheckSum
    )
{
    HFF hff = (HFF) NULL;
    HFF   iFile;
    PVOID pvView;
    ULONG cjView;
    BOOL     bRet;

    DONTUSE(ulLangId);       // avoid W4 level compiler warning
    DONTUSE(ulFastCheckSum); // avoid W4 level compiler warning

    if ((cFiles != 1) || pdv)
        return hff;

    iFile  = *piFile;
    pvView = *ppvView;
    cjView = *pcjView;

#ifndef BMFD_NO_TRY_EXCEPT
    try
    {
#endif

    // try loading it as an fon file, if it does not work, try as
    // fnt file

        if (!(bRet = bBmfdLoadFont(iFile, pvView, cjView,TYPE_DLL16, &hff)))
        {
        // try as an *.fnt file

            bRet = bBmfdLoadFont(iFile, pvView, cjView,TYPE_FNT,&hff);
        }

        //
        // if this did not work try to load it as a 32 bit dll
        //

        if (!bRet)
        {
            bRet = bLoadNtFon(iFile,pvView,&hff);
        }

        if (!bRet)
        {
            ASSERTGDI(hff == (HFF)NULL, "BMFD!bBmfdLoadFontFile, hff\n");
        }
#ifndef BMFD_NO_TRY_EXCEPT
    }
    except (ExceptionFilter_BmfdLoadFontFile(GetExceptionInformation()))
    {
        WARNING("bmfd, exception in BmfdLoadFontFile\n");

        // if the file disappeared after mem was allocated, free the mem

        if (hff)
        {
            VFREEMEM(hff);
        }

        hff = (HFF)NULL;
    }
#endif

    return hff;
}

/******************************Public*Routine******************************\
*
* BmfdUnloadFontFileTE (
*
* History:
*  07-Apr-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




BOOL
BmfdUnloadFontFileTE (
    HFF  hff
    )
{
    BOOL bRet;

#ifndef BMFD_NO_TRY_EXCEPT
    try
    {
#endif
        bRet = BmfdUnloadFontFile(hff);
#ifndef BMFD_NO_TRY_EXCEPT
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("bmfd, exception in BmfdUnloadFontFile\n");
        bRet = FALSE;
    }
#endif
    return bRet;
}

/******************************Public*Routine******************************\
*
* BOOL BmfdQueryAdvanceWidthsTE
*
* Effects:
*
* Warnings:
*
* History:
*  07-Apr-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL BmfdQueryAdvanceWidthsTE
(
    DHPDEV   dhpdev,
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
)
{
    BOOL bRet = FD_ERROR;    // tri bool according to chuckwh
    DONTUSE(dhpdev);
    
    if (bBmfdMapFontFileFD((FONTFILE *)pfo->iFile))
    {
#ifndef BMFD_NO_TRY_EXCEPT
        try
        {
#endif
            bRet = BmfdQueryAdvanceWidths(pfo,iMode,phg,plWidths,cGlyphs);
#ifndef BMFD_NO_TRY_EXCEPT
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("bmfd, exception in BmfdQueryAdvanceWidths\n");
            vBmfdMarkFontGone((FONTFILE *)pfo->iFile, GetExceptionCode());
        }
#endif

        EngUnmapFontFileFD(PFF(pfo->iFile)->iFile);
    }
    return bRet;
}


/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI
*
\**************************************************************************/

DHPDEV
BmfdEnablePDEV(
    DEVMODEW*   pdm,
    PWSTR       pwszLogAddr,
    ULONG       cPat,
    HSURF*      phsurfPatterns,
    ULONG       cjCaps,
    ULONG*      pdevcaps,
    ULONG       cjDevInfo,
    DEVINFO*    pdi,
    HDEV        hdev,
    PWSTR       pwszDeviceName,
    HANDLE      hDriver)
{

    PVOID*   ppdev;

    //
    // Allocate a four byte PDEV for now
    // We can grow it if we ever need to put information in it.
    //

    ppdev = (PVOID*) EngAllocMem(0, sizeof(PVOID), 'dfmB');

    return ((DHPDEV) ppdev);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
\**************************************************************************/

VOID
BmfdDisablePDEV(
    DHPDEV  dhpdev)
{
    EngFreeMem(dhpdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID
BmfdCompletePDEV(
    DHPDEV dhpdev,
    HDEV   hdev)
{
    return;
}




// The driver function table with all function index/address pairs

DRVFN gadrvfnBMFD[] =
{
    {   INDEX_DrvEnablePDEV,            (PFN) BmfdEnablePDEV,          },
    {   INDEX_DrvDisablePDEV,           (PFN) BmfdDisablePDEV,         },
    {   INDEX_DrvCompletePDEV,          (PFN) BmfdCompletePDEV,        },
    {   INDEX_DrvQueryFont,             (PFN) BmfdQueryFont,           },
    {   INDEX_DrvQueryFontTree,         (PFN) BmfdQueryFontTree,       },
    {   INDEX_DrvQueryFontData,         (PFN) BmfdQueryFontDataTE,     },
    {   INDEX_DrvDestroyFont,           (PFN) BmfdDestroyFont,         },
    {   INDEX_DrvQueryFontCaps,         (PFN) BmfdQueryFontCaps,       },
    {   INDEX_DrvLoadFontFile,          (PFN) BmfdLoadFontFileTE,      },
    {   INDEX_DrvUnloadFontFile,        (PFN) BmfdUnloadFontFileTE,    },
    {   INDEX_DrvQueryFontFile,         (PFN) BmfdQueryFontFile,       },
    {   INDEX_DrvQueryAdvanceWidths,    (PFN) BmfdQueryAdvanceWidthsTE }
};

/******************************Public*Routine******************************\
* BmfdEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
*  Sun 25-Apr-1993 -by- Patrick Haluptzok [patrickh]
* Change to be same as DDI Enable.
*
* History:
*  12-Dec-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL BmfdEnableDriver(
ULONG iEngineVersion,
ULONG cj,
PDRVENABLEDATA pded)
{
// Engine Version is passed down so future drivers can support previous
// engine versions.  A next generation driver can support both the old
// and new engine conventions if told what version of engine it is
// working with.  For the first version the driver does nothing with it.

    iEngineVersion;

    if ((ghsemBMFD = EngCreateSemaphore()) == (HSEMAPHORE) 0)
    {
        return(FALSE);
    }

    pded->pdrvfn = gadrvfnBMFD;
    pded->c = sizeof(gadrvfnBMFD) / sizeof(DRVFN);
    pded->iDriverVersion = DDI_DRIVER_VERSION_NT5;
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\bmfd\simulate.h ===
/******************************Module*Header*******************************\
* Module Name: simulate.h
*
* Created: 17-Apr-1991 08:30:37
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/

ULONG
cFacesRes
(
    RES_ELEM*
    );

ULONG
cFacesFON
(
    WINRESDATA*
    );

VOID
vDontTouchIFIMETRICS(
    IFIMETRICS*
    );



#ifdef FE_SB
LONG
cjGlyphDataSimulated
(
    FONTOBJ*,
    ULONG,
    ULONG,
    ULONG*,
    ULONG
    );
#else
LONG
cjGlyphDataSimulated
(
    FONTOBJ*,
    ULONG,
    ULONG,
    ULONG*
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\bmfd\simulate.c ===
/******************************Module*Header*******************************\
* Module Name: simulate.c
*
*  routines associated with simulated faces i.e. emboldened
*  and/or italicized  faces
*
* Created: 17-Apr-1991 08:31:18
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/

#include "fd.h"

#ifdef SAVE_FOR_HISTORICAL_REASONS

/******************************Public*Routine******************************\
*
* VOID vEmboldenBitmap(RASTERGLYPH * pgldtSrc,RASTERGLYPH * pgldtDst,LONG culDst)
*
* modifies an original glyph bitmap for the default face
* to produce the bitmap that corresponds to an emboldened char.
* Emboldened bitmap is simply an original bitmap offsetted to the right
* by one pel and OR-ed with the original bitmap itself.
*
* History:
*  22-Apr-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vEmboldenBitmap(
    RASTERGLYPH * prgSrc,
    RASTERGLYPH * prgDst
    )
{
    ULONG cxSrc = prgSrc->gb.sizlBitmap.cx;
    ULONG cy    = prgSrc->gb.sizlBitmap.cy;      // same for src and dst
    ULONG cxDst = cxSrc + 1;                // + 1 for emboldening

    PBYTE pjSrc = prgSrc->gb.aj;
    PBYTE pjDst = prgDst->gb.aj;

    ULONG iScan,iByte;        // loop indices
    PBYTE pjS,pjD;

// number of bytes in one scan of the Dst or Src bitmaps. (dword aligned)

    ULONG cjScanDst = CJ_SCAN(cxDst);
    ULONG cjScanSrc = CJ_SCAN(cxSrc);
    ULONG cjBmp        = cjScanDst * cy;

    ULONG cjScanDst = CJ_SCAN(cxDst);
    ULONG cjScanSrc = CJ_SCAN(cxSrc);
    BYTE  jCarry;   // carry bit from shifting Src byte by 1;

    GLYPHDATA *pgldtSrc = &prgSrc->gd;
    GLYPHDATA *pgldtDst = &prgDst->gd;

#ifdef DUMPCALL
    DbgPrint("\nvEmboldenBitmap(");
    DbgPrint("\n    RASTERGLYPH *prgSrc = %-#8lx",prgSrc);
    DbgPrint("\n    RASTERGLYPH *prgDst = %-#8lx",prgDst);
    DbgPrint("\n    )\n");
#endif

    RtlCopyMemory(prgDst,
                  prgSrc,
                  offsetof(RASTERGLYPH,gb) + offsetof(GLYPHBITS,sizlBitmap));

// if engine requested memory that is zero-ed out we would not have to do it
// ourselves

    RtlZeroMemory(pjDst, cjBmp);

// make necessary changes to the fields of GLYPHDATA which
// are affected by emboldening

    pgldtDst->gdf.pgb = &prgDst->gb;

    pgldtDst->rclInk.right += (LONG)1;

// pre and post bearings have not changed nor bmp origin, only inked box

    pgldtDst->fxD = LTOFX(cxDst);
    pgldtDst->ptqD.x.HighPart = (LONG)pgldtDst->fxD;
    pgldtDst->fxAB = pgldtDst->fxD;     // right edge of the black box

// this needs to be changed a bit since aulBMData will not live
// in the GLYPHDATA structure any more

    prgDst->gb.sizlBitmap.cx = cxDst;
    prgDst->gb.sizlBitmap.cy = cy;

// embolden bitmap scan by scan

    for (iScan = 0L; iScan < cy; iScan++)
    {
        pjS = pjSrc;
        pjD = pjDst;

    // embolden individual scans

        jCarry = (BYTE)0;   // no carry to the first byte in the row

        for(iByte = 0L; iByte < cjScanSrc; iByte++, pjS++, pjD++)
        {
            *pjD = (BYTE)(*pjS | ((*pjS >> 1) | jCarry));

        // remember the rightmost bit and shift it to the leftmost position

            jCarry = (BYTE)(*pjS << 7);
        }

        if ((cxSrc & 7L) == 0L)
            *pjD = jCarry;

    // advance to the next scan of the src and dst

        pjSrc += cjScanSrc;
        pjDst += cjScanDst;
    }
}
#endif // SAVE_FOR_HISTORICAL_REASONS

/******************************Public*Routine******************************\
* cjGlyphDataSimulated
*
* Computes the size of the glyphdata for the simulated face given cx and cy
* for the corresponding char in the default face
*
* History:
*  22-Apr-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#ifdef FE_SB // cjGlyphDataSimulated():
LONG
cjGlyphDataSimulated(
    FONTOBJ *pfo,
    ULONG    cxNoSim,    // cx for the same char of the default face
    ULONG    cyNoSim,    // cy for the same char of the default face
    ULONG   *pcxSim,
    ULONG    ulRotate    // Rotation degree
    )
#else
LONG
cjGlyphDataSimulated(
    FONTOBJ *pfo,
    ULONG    cxNoSim,    // cx for the same char of the default face
    ULONG    cyNoSim,    // cy for the same char of the default face
    ULONG   *pcxSim
    )
#endif
{
    ULONG cxSim;

#ifdef DUMPCALL
    DbgPrint("\ncjGlyphDataSimulated(");
    DbgPrint("\n    ULONG        cxNoSim = %-#8lx",cxNoSim);
    DbgPrint("\n    ULONG        cyNoSim = %-#8lx",cyNoSim);
    DbgPrint("\n    ULONG       *pcxSim  = %-#8lx",pcxSim );
    DbgPrint("\n    )\n");
#endif

    if (cxNoSim == 0)
    {
    // blank 1x1 bitmap

        cxSim    = 1;
        cyNoSim  = 1;
    }
    else
    {
        switch( pfo->flFontType & (FO_SIM_BOLD | FO_SIM_ITALIC) )
        {
        case 0:
            cxSim = cxNoSim;
            break;

        case FO_SIM_BOLD:

            cxSim = cxNoSim + 1;
            break;

        case FO_SIM_ITALIC:

            cxSim = cxNoSim + (cyNoSim - 1) / 2;
            break;

        default:

        // here we have used that
        // (k - 1) / 2 + 1 == (k + 1) / 2 for every integer k, (k == cy)

            cxSim = cxNoSim + (cyNoSim + 1) / 2;
            break;
        }
    }

    if (pcxSim != (ULONG *)NULL)
    {
        *pcxSim = cxSim;
    }

#ifdef FE_SB // cjGlyphDataSimulated():

#ifdef DBG_MORE
    DbgPrint("cxSim - 0x%x\n : cyNoSim - 0x%x\n",cxSim , cyNoSim);
#endif // DBG_MORE

    switch( ulRotate )
    {
    case 0L :
    case 1800L :

        return(CJ_GLYPHDATA(cxSim, cyNoSim));

    case 900L :
    case 2700L :

        return(CJ_GLYPHDATA(cyNoSim, cxSim));
    default :
        /* we should never be here */
        return(CJ_GLYPHDATA(cxSim, cyNoSim));
    }
#else
    return(CJ_GLYPHDATA(cxSim, cyNoSim));
#endif

}

/******************************Public*Routine******************************\
*
* cFacesRes
*
* History:
*  13-May-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

ULONG
cFacesRes(
    PRES_ELEM pre
    )
{
    FSHORT fs = fsSelectionFlags((PBYTE)pre->pvResData);

#ifdef DUMPCALL
    DbgPrint("\ncFacesRes(");
    DbgPrint("\n    PRES_ELEM pre = %-#8lx", pre);
    DbgPrint("\n    )\n");
#endif

// kill all the bits but BOLD and ITALIC

    fs = fs & (FSHORT)(FM_SEL_BOLD | FM_SEL_ITALIC);

    //!!! DbgPrint("fsSelection = 0x%lx\n", (ULONG)fs);

    if (fs == 0)    // default face is NORMAL
        return(4L);

    if ((fs == FM_SEL_BOLD) || (fs == FM_SEL_ITALIC))
        return(2L);

    if (fs == (FM_SEL_BOLD | FM_SEL_ITALIC))
        return(1L);

    /* we should never be here */
    return (4L);
}

/******************************Public*Routine******************************\
* VOID vDefFace
*
* History:
*  13-May-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vDefFace(
    FACEINFO   *pfai,
    RES_ELEM   *pre
    )
{
// kill all bits but BOLD and ITALIC bits that should remain unchanged

    FSHORT fs = (FSHORT)(
        fsSelectionFlags((PBYTE) pre->pvResData) &
        (FM_SEL_BOLD  | FM_SEL_ITALIC)
        );

    switch (fs)
    {
    case 0:
        pfai->iDefFace = FF_FACE_NORMAL;
        return;

    case FM_SEL_BOLD:
        pfai->iDefFace = FF_FACE_BOLD;
        return;

    case FM_SEL_ITALIC:
        pfai->iDefFace = FF_FACE_ITALIC;
        return;

    case (FM_SEL_ITALIC | FM_SEL_BOLD):
        pfai->iDefFace = FF_FACE_BOLDITALIC;
        return;

    default:
        RIP("bmfd!_which ape has messed up the code ?\n");
        return;
    }
}

#if 0 /* This function is never used, and ignores memory accesses outside the mapped file. */

/******************************Public*Routine******************************\
*
* ULONG cFacesFON     // no. of faces associated with this FON file
*
* History:
*  January 2002 -by- Jay Krell [JayKrell]
*    #if 0'ed out.
*  13-May-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

ULONG
cFacesFON(
    PWINRESDATA pwrd
    )
{
    ULONG cFace;
    ULONG iRes;
    RES_ELEM re;

#ifdef DUMPCALL
    DbgPrint("\ncFacesFON(");
    DbgPrint("\n    PWINRESDATA pwrd = %-#8lx", pwrd);
    DbgPrint("\n    )\n");
#endif

// this function should have not been called if there are no
// font resources associated with this pwrd

    ASSERTGDI(pwrd->cFntRes != 0L, "No font resources\n");

    cFace = 0L;     // init the sum

    for (iRes = 0L; iRes < pwrd->cFntRes; iRes++)
    {
        if (bGetFntResource(pwrd,iRes,&re))
            cFace += cFacesRes(&re);
    }
    return(cFace);
}
#endif

/******************************Public*Routine******************************\
*
* vComputeSimulatedGLYPHDATA
*
* History:
*  06-Oct-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vComputeSimulatedGLYPHDATA(
    GLYPHDATA *pgldt    ,
    PBYTE      pjBitmap ,
    ULONG      cxNoSim  ,
    ULONG      cy       ,
    ULONG      yBaseLine,
    ULONG      cxScale,
    ULONG      cyScale,
    FONTOBJ   *pfo
    )
{
    ULONG cxSim;            // cx for the bitmap
    LONG  xCharInc;         // x component of the char inc vector

// the following coords refer to bitmap coord system, i.e. the one in which
// the BM origin has coors (0,0)

    ULONG yTopIncMin;    // min over non zero raws
    ULONG yBottomExcMax; // max+1 over non zero raws

#ifdef DUMPCALL
    DbgPrint("\nvComputeSimulatedGLYPHDATA(");
    DbgPrint("\n    GLYPHDATA         *pgldt     = %-#8lx",pgldt     );
    DbgPrint("\n    PBYTE              pjBitmap  = %-#8lx",pjBitmap  );
    DbgPrint("\n    ULONG              cxNoSim   = %-#8lx",cxNoSim   );
    DbgPrint("\n    ULONG              cy        = %-#8lx",cy        );
    DbgPrint("\n    ULONG              yBaseLine = %-#8lx",yBaseLine );
    DbgPrint("\n    FONTOBJ           *pfo       = %-#8lx",pfo       );
    DbgPrint("\n    )\n");
#endif

// compute top and bottom by looking into the bitmap in the row format:

    vFindTAndB (
        pjBitmap, // pointer to the bitmap in *.fnt column format
        cxNoSim,
        cy,
        &yTopIncMin,
        &yBottomExcMax
        );

    if( cyScale != 1 )
    {
        yTopIncMin *= cyScale;
        yBottomExcMax *= cyScale;
        cy *= cyScale;
        yBaseLine *= cyScale;
    }

    cxNoSim *= cxScale;

    pgldt->gdf.pgb = NULL;

    if (yTopIncMin == yBottomExcMax) // no ink at all
    {
    // this is a tricky point. We are dealing with a blank bitmap.
    // The first thought would be to report the zero inked box. It
    // then ambiguous what an A and C spaces should be. The right way to
    // think of this bitmap (this is in fact the break char) is that the
    // inked box is the whole bitmap, just the "color" of the ink happens
    // to be invisible. This is important when dealing with strings
    // which have break character as the first or the last char in the string.
    // If the inked box was reported as zero, text extent for such a string
    // would be computed incorrectly when the corrections for the first A
    // and last C are taken into account

        yTopIncMin = 0L;    // coincides with the top
        yBottomExcMax = cy * cyScale; // coincides with the bottom
    }

// these have to be correct, important for computing char inc for esc != 0

    pgldt->rclInk.top = (LONG)(yTopIncMin - yBaseLine);
    pgldt->rclInk.bottom = (LONG)(yBottomExcMax - yBaseLine);

// minus sign is because the scalar product is supposed to be taken with
// a unit ascender vector

    pgldt->fxInkTop    = -LTOFX(pgldt->rclInk.top);
    pgldt->fxInkBottom = -LTOFX(pgldt->rclInk.bottom);

    switch(pfo->flFontType & (FO_SIM_BOLD | FO_SIM_ITALIC))
    {
    case 0:
        cxSim = cxNoSim;
        xCharInc = (LONG)cxNoSim;
        break;

    case FO_SIM_BOLD:

        cxSim = cxNoSim + 1;
        xCharInc = (LONG)(cxNoSim + 1);
        break;

    case FO_SIM_ITALIC:

        cxSim = cxNoSim + (cy - 1) / 2;
        xCharInc = (LONG)cxNoSim;
        break;

    case (FO_SIM_BOLD | FO_SIM_ITALIC):

    // here we have used that
    // (k - 1) / 2 + 1 == (k + 1) / 2 for every integer k, (k == cy)

        cxSim = cxNoSim + (cy + 1) / 2;
        xCharInc = (LONG)(cxNoSim + 1);
        break;

    default:
        // to silence prefix
        cxSim = 1;
        RIP("BMFD!BAD SIM FLAG\n");
    }

    if (cxNoSim == 0)
    {
        cxSim = 1; // 1X1 blank box
        xCharInc = 0;
    }

    pgldt->fxD = LTOFX(xCharInc);
    pgldt->ptqD.x.HighPart = (LONG)pgldt->fxD;
    pgldt->ptqD.x.LowPart  = 0;
    pgldt->ptqD.y.HighPart = 0;
    pgldt->ptqD.y.LowPart  = 0;

// in this crude picture we are luying about x extents of the black box
// and report the whole bitmap width as an extent

    pgldt->rclInk.left  = 0;           // rclInk.left == lhs of the bitmap, => A < 0
    pgldt->rclInk.right = (LONG)cxSim; // the rhs of the bitmap => c < 0

// compute bearings, remember the rule A + B + C == char inc
// where B is the size of the inked box. For the horizontal case:
//          A == ePreBearing , C == ePostBearing
// In view of these sum rules and the definitions of A,B,C we have
//          B = rclInk.right - rclInk.left;
//          A = rclInk.left;
//          C = xCharInc - rclInk.right;
//      The sum rule is trivially obeyed.

    pgldt->fxA =  LTOFX(pgldt->rclInk.left); // fxA
    pgldt->fxAB = LTOFX(pgldt->rclInk.right); // right edge of the black box
}

/******************************Public*Routine******************************\
*
* VOID vCvtToBmp
*
* Effects: takes the bitmap in the original *.fnt column format and converts
*          it to the Bmp format.
*
* History:
*  25-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vCvtToBmp
(
GLYPHBITS *pgb,
GLYPHDATA *pgd,
PBYTE pjBitmap,     // pointer to the bitmap in *.fnt column format
ULONG cx,
ULONG cy,
ULONG yBaseLine
)
{
    ULONG cjScan = CJ_SCAN(cx);  // # of bytes per scan of the Bmp

// pjColumn points to one of the bytes in the first ROW of the Bmp

    PBYTE pjColumn, pjColumnEnd;
    PBYTE pjDst, pjDstEnd;           // current destination byte

#ifdef DUMPCALL
    DbgPrint("\nvCvtToDIB(");
    DbgPrint("\n    GLYPHBITS    pgb       = %-#8lx",pgb      );
    DbgPrint("\n    GLYPHDATA    pgd       = %-#8lx",pgd      );
    DbgPrint("\n    PBYTE        pjBitmap  = %-#8lx",pjBitmap );
    DbgPrint("\n    ULONG        cx        = %-#8lx",cx       );
    DbgPrint("\n    ULONG        cy        = %-#8lx",cy       );
    DbgPrint("\n    ULONG        yBaseLine = %-#8lx",yBaseLine);
    DbgPrint("\n    )\n");
#endif

// store cx and cy at the top, before Bits

    pgb->sizlBitmap.cx = cx;
    pgb->sizlBitmap.cy = cy;

// this is character independent for BM fonts

    pgb->ptlOrigin.x = 0L;
    pgb->ptlOrigin.y = -(LONG)yBaseLine;

    RtlZeroMemory(pgb->aj, cjScan * cy);

// we shall fill the Bmp column by column, thus traversing the src a byte at
// the time:

    for
    (
        pjColumn = pgb->aj, pjColumnEnd = pjColumn + cjScan;
        pjColumn < pjColumnEnd;
        pjColumn++
    )
    {
        for
        (
            pjDst = pjColumn, pjDstEnd = pjColumn + cy * cjScan;
            pjDst < pjDstEnd;
            pjDst += cjScan, pjBitmap++
        )
        {
            *pjDst = *pjBitmap;
        }
    }
}

/******************************Public*Routine******************************\
*
* vCvtToBoldBmp
*
* History:
*  06-Oct-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vCvtToBoldBmp
(
GLYPHBITS *pgb,
GLYPHDATA *pgd,
PBYTE pjBitmap,     // pointer to the bitmap in *.fnt column format
ULONG cxSrc,
ULONG cy,
ULONG yBaseLine
)
{
    PBYTE pjSrc;
    PBYTE pjDst;

    ULONG cxDst = cxSrc + 1;                // + 1 for emboldening
    ULONG iScan,iByte;        // loop indices
    PBYTE pjS,pjD;

// number of bytes in one scan of the Dst or Src bitmaps. (dword aligned)

    ULONG cjScanDst = CJ_SCAN(cxDst);
    ULONG cjScanSrc = CJ_SCAN(cxSrc);
    BYTE  jCarry;   // carry bit from shifting Src byte by 1;

#ifdef DUMPCALL
    DbgPrint("\nVOID");
    DbgPrint("\nvCvtToBoldDIB(");
    DbgPrint("\n    GLYPHBITS    pgb       = %-#8lx",pgb      );
    DbgPrint("\n    GLYPHDATA    pgd       = %-#8lx",pgd      );
    DbgPrint("\n    PBYTE        pjBitmap  = %-#8lx",pjBitmap );
    DbgPrint("\n    ULONG        cxSrc     = %-#8lx",cxSrc    );
    DbgPrint("\n    ULONG        cy        = %-#8lx",cy       );
    DbgPrint("\n    ULONG        yBaseLine = %-#8lx",yBaseLine);
    DbgPrint("\n    )\n");
#endif

// this is character independent for BM fonts

    pgb->ptlOrigin.x = 0L;
    pgb->ptlOrigin.y = -(LONG)yBaseLine;

    pgb->sizlBitmap.cx = cxDst;
    pgb->sizlBitmap.cy = cy;

// init the loop over scans

    pjSrc = pjBitmap;
    pjDst = pgb->aj;

// embolden bitmap scan by scan

// if engine requested memory that is zero-ed out we would not have to do it
// ourselves

    RtlZeroMemory(pjDst, cjScanDst * cy);

    for (iScan = 0L; iScan < cy; iScan++)
    {
        pjS = pjSrc;
        pjD = pjDst;

    // embolden individual scans

        jCarry = (BYTE)0;   // no carry to the first byte in the row

        for
        (
            iByte = 0L;
            iByte < cjScanSrc;
            iByte++, pjS += cy, pjD++
        )
        {
            *pjD = (BYTE)(*pjS | ((*pjS >> 1) | jCarry));

        // remember the rightmost bit and shift it to the leftmost position

            jCarry = (BYTE)(*pjS << 7);
        }

        if ((cxSrc & 7L) == 0L)
            *pjD = jCarry;

    // advance to the next scan of the src and dst

        pjSrc++;
        pjDst += cjScanDst;
    }
}

/******************************Public*Routine******************************\
*
* vCvtToItalicBmp
*
* History:
*  06-Oct-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vCvtToItalicBmp
(
GLYPHBITS *pgb,
GLYPHDATA *pgd,
PBYTE pjBitmap,     // pointer to the bitmap in *.fnt column format
ULONG cxSrc,
ULONG cy,
ULONG yBaseLine
)
{
    ULONG cxDst = cxSrc + (ULONG)(cy - 1) / 2; // add correction for the

    PBYTE pjSrcScan, pjS;
    PBYTE pjDstScan, pjD;

    LONG  iScan,iByte;        // loop indices

// number of bytes in one scan of the Dst or Src bitmaps. (dword aligned)

    ULONG cjScanDst = CJ_SCAN(cxDst);

    LONG  cjScanSrc = (LONG)CJ_SCAN(cxSrc);
    LONG  lShift;
    BYTE  jCarry;   // carry from shifting Src byte by lShift;
    LONG  cjEmpty;  // number of untouched bytes at the begining of the dest scans

#ifdef DUMPCALL
    DbgPrint("\nVOID");
    DbgPrint("\nvCvtToItalicDIB(");
    DbgPrint("\n    GLYPHBITS    pgb       = %-#8lx",pgb      );
    DbgPrint("\n    GLYPHDATA    pgd       = %-#8lx",pgd      );
    DbgPrint("\n    PBYTE        pjBitmap  = %-#8lx",pjBitmap );
    DbgPrint("\n    ULONG        cxSrc     = %-#8lx",cxSrc    );
    DbgPrint("\n    ULONG        cy        = %-#8lx",cy       );
    DbgPrint("\n    ULONG        yBaseLine = %-#8lx",yBaseLine);
    DbgPrint("\n    )\n");
#endif


// this is character independent for BM fonts

    pgb->ptlOrigin.x = 0;
    pgb->ptlOrigin.y = -(LONG)yBaseLine;

    pgb->sizlBitmap.cx = cxDst;
    pgb->sizlBitmap.cy = cy;

// init the loop over scans

    pjSrcScan = pjBitmap;
    pjDstScan = pgb->aj;

// italicize bitmap row by row

    lShift = ((cy - 1) / 2) & (LONG)7;
    cjEmpty = ((cy - 1) / 2) >> 3;

#ifdef DEBUGITAL
    DbgPrint("cy = %ld,  yBaseLine = %ld, lShift = %ld, cjEmpty = %ld\n",
              cy,  -pgldtSrc->ptlBmpOrigin.y, lShift, cjEmpty);
    DbgPrint("cxSrc = %ld, cxDst = %ld, cjScanSrc = %ld, cjScanDst = %ld\n",
              cxSrc, cxDst, cjScanSrc, cjScanDst);
    DbgPrint("cy = %ld,  cjScanSrc = %ld, \n",
              cy, cjScanSrc);

#endif //  DEBUGITAL

// if engine requested memory that is zero-ed out we would not have to do it
// ourselves

    RtlZeroMemory(pjDstScan , cjScanDst * cy);

    for (iScan = 0L; iScan < (LONG)cy; iScan++)
    {
        if (lShift < 0L)
        {
            lShift = 7L;
            cjEmpty--;
        }

        ASSERTGDI(cjEmpty >= 0L, "cjEmpty\n");

    #ifdef DEBUGITALIC
        DbgPrint("iScan = %ld, lShift = %ld\n", iScan, lShift);
    #endif  // DEBUGITALIC

        pjS = pjSrcScan;
        pjD = pjDstScan + cjEmpty;

    // italicize individual scans

        jCarry = (BYTE)0;   // no carry to the first byte in the row

        for
        (
            iByte = 0L;
            iByte < cjScanSrc;
            iByte++, pjS += cy, pjD++
        )
        {
            *pjD = (BYTE)((*pjS >> lShift) | jCarry);

        // remember the lShift rightmost bits and move them over to the left

            jCarry = (BYTE)(*pjS << (8 - lShift));
        }

    // see if an extra bit in the destination has to be used to store info

        if ((LONG)((8 - (cxSrc & 7L)) & 7L) < lShift)
            *pjD = jCarry;

    // advance to the next scan

        pjSrcScan++;
        pjDstScan += cjScanDst;

    // decrease shift if switching to the next row (row = 2 scans)

        lShift -= (iScan & 1);
    }

    ASSERTGDI(lShift <= 0L, "vItalicizeBitmap: lShift > 0\n");
}

/******************************Public*Routine******************************\
*
* vCvtToBoldItalicBmp
*
* History:
*  06-Oct-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vCvtToBoldItalicBmp
(
GLYPHBITS *pgb,
GLYPHDATA *pgd,
PBYTE pjBitmap,     // pointer to the bitmap in *.fnt column format
ULONG cxSrc,
ULONG cy,
ULONG yBaseLine
)
{
// This is the length in pels for the destination for italicizing
// which serves as a source for subsequent emboldening
// This length is a length in pels of the "virtual"
// italicized source that is to be emboldened.

    ULONG cxSrcItalic = cxSrc + (cy - 1) / 2;  // + slope of italic chars

// length in pels of the true emboldened and italicized destination

    ULONG cxDst = cxSrcItalic + 1;  // + 1 for emboldening

    PBYTE pjSrcScan, pjS;
    PBYTE pjDstScan, pjD;

    LONG iScan,iByte;        // loop indices

// number of bytes in one scan of the Dst or Src bitmaps. (dword aligned)

    ULONG cjScanDst = CJ_SCAN(cxDst);
    ULONG cjScanSrc = CJ_SCAN(cxSrc);

    LONG  lShift;   // shift used to italicize;
    BYTE  jCarry;   // carry from shifting Src byte by lShift;
    LONG  cjEmpty;  // number of untouched bytes at the begining of the dest scans
    BYTE  jSrcItalic;
    BYTE  jCarryBold;

#ifdef DUMPCALL
    DbgPrint("\nVOID");
    DbgPrint("\nvCvtToBoldItalicDIB(");
    DbgPrint("\n    GLYPHBITS    pgb       = %-#8lx",pgb      );
    DbgPrint("\n    GLYPHDATA    pgd       = %-#8lx",pgd      );
    DbgPrint("\n    PBYTE        pjBitmap  = %-#8lx",pjBitmap );
    DbgPrint("\n    ULONG        cxSrc     = %-#8lx",cxSrc    );
    DbgPrint("\n    ULONG        cy        = %-#8lx",cy       );
    DbgPrint("\n    ULONG        yBaseLine = %-#8lx",yBaseLine);
    DbgPrint("\n    )\n");
#endif


// this is character independent for BM fonts

    pgb->ptlOrigin.x = 0;
    pgb->ptlOrigin.y = -(LONG)yBaseLine;

    pgb->sizlBitmap.cx = cxDst;
    pgb->sizlBitmap.cy = cy;

// init the loop over scans

    pjSrcScan = pjBitmap;
    pjDstScan = pgb->aj;

// embold and italicize bitmap row by row   (row = 2 scans)

    lShift = ((cy - 1) / 2) & (LONG)7;
    cjEmpty = ((cy - 1) / 2) >> 3;

#ifdef DEBUGBOLDITAL
    DbgPrint("cy = %ld,  yBaseLine = %ld, lShift = %ld, cjEmpty = %ld\n",
              cy, -pgldtSrc->ptlBmpOrigin.y, lShift, cjEmpty);
    DbgPrint("cxSrc = %ld, cxDst = %ld, cjScanSrc = %ld, cjScanDst = %ld\n",
              cxSrc, cxDst, cjScanSrc, cjScanDst);
    DbgPrint("cy = %ld,  cjScanSrc = %ld\n",
              cy, cjScanSrc);

#endif //  DEBUGBOLDITAL

// if engine requested memory that is zero-ed out we would not have to do it
// ourselves

    RtlZeroMemory(pjDstScan , cjScanDst * cy);

    for (iScan = 0L; iScan < (LONG)cy; iScan++)
    {
        if (lShift < 0L)
        {
            lShift = 7L;
            cjEmpty--;
        }

    #ifdef DEBUGBOLDITAL
        DbgPrint("iScan = %ld, lShift = %ld\n", iScan, lShift);
    #endif  // DEBUGBOLDITAL

        ASSERTGDI(cjEmpty >= 0L, "cjEmpty\n");

        pjS = pjSrcScan;
        pjD = pjDstScan + cjEmpty;

    // embolden individual scans

        jCarry = (BYTE)0;   // no carry to the first byte in the row
        jCarryBold = (BYTE)0;

        for
        (
            iByte = 0L;
            iByte < (LONG)cjScanSrc;
            iByte++, pjS += cy, pjD++
        )
        {
            jSrcItalic = (BYTE)((*pjS >> lShift) | jCarry);
            *pjD = (BYTE)(jSrcItalic | (jSrcItalic >> 1) | jCarryBold);

        // remember the lShift rightmost bits and move them over to the left

            jCarry = (BYTE)(*pjS << (8 - lShift));
            jCarryBold = (BYTE)(jSrcItalic << 7);
        }

    // see if an extra bit in the destination has to be used to store info

        if ((LONG)((8 - (cxSrc & 7L)) & 7L) < lShift)
        {
            jSrcItalic = jCarry;
            *pjD = (BYTE)(jSrcItalic | (jSrcItalic >> 1) | jCarryBold);
            jCarryBold = (BYTE)(jSrcItalic << 7);

            if ((cxSrcItalic & 7L) == 0L)
            {
                pjD++;
                *pjD = jCarryBold;
            }

        }

    // advance to the next scan

        pjSrcScan++;
        pjDstScan += cjScanDst;

    // change the value of the shift if doing the next row

        lShift -= (iScan & 1);
    }


    ASSERTGDI(lShift <= 0L, "vBoldItalicizeBitmap: lShift > 0\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\kdexts\kdexts.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "precomp.hxx"

#include <ntverp.h>

//
// globals
//
EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;



DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\kdexts\ttexts.cxx ===
/******************************Module*Header*******************************\
* Module Name: ttexts.cxx
*
* Created: 29-Aug-1994 08:42:10
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"

#define N2(a,b) dprintf("[%x] %s", &pRemote->##a, (b))
#define N3(a,b,c) N2(a,b); dprintf((c), pLocal->##a)

DWORD adw[1024];

DECLARE_API( help )
{
    char **ppsz;
    static char *apszHelp[] = {
        "",
        "fc     -- FONTCONTEXT",
        "ff     -- FONTFILE",
        "gout   -- fsGlyphInfo",
        "gin    -- fsGlyphInputType",
        "gmc    -- GMC",
        "poly   -- TTPOLYGONHEADER and curves",
        "ttc    -- TTC_FONTFILE"
        "\n",
        0
    };
    for( ppsz=apszHelp; *ppsz; ppsz++ )
        dprintf("\t%s\n", *ppsz);
}

DECLARE_API( gmc )
{
    GMC gmc;
    ULONG_PTR arg;
    int i;

    if ( *args == '\0' )
    {
        dprintf( "Enter address of GMC\n" );
        return;
    }

    sscanf( args, "%p", &arg );
    ReadMemory(arg, &gmc, sizeof(gmc), NULL);

    dprintf("\n\n");
    dprintf("[%p] dyTop    %d\n",  arg+offsetof(GMC,dyTop   ), gmc.dyTop   );
    dprintf("[%p] dyBottom %d\n",  arg+offsetof(GMC,dyBottom), gmc.dyBottom);
    dprintf("[%p] cxCor    %u\n",  arg+offsetof(GMC,cxCor   ), gmc.cxCor   );
    dprintf("[%p] cyCor    %u\n",  arg+offsetof(GMC,cyCor   ), gmc.cyCor   );

    dprintf("\n\n");
}

void dump28_4(LONG l)
{
    if (l < 0)
    {
        l = -l;
        dprintf("%3d.%1x-", l >> 4, l & 15);
    }
    else
        dprintf("%3d.%1x+", l >> 4, l & 15);
}

DECLARE_API( poly )
{
    ULONG_PTR arg;
    TTPOLYGONHEADER Header;
    char *pHeader, *pCurve, *pCopy, *pStart, *pStop;
    POINTFX *pfx, *pfxStop;
    INT_PTR dp;

    if ( *args == '\0')
    {
        dprintf("Enter an argument\n");
        return;
    }
    sscanf( args, "%p", &arg );
    pHeader = (char*) arg;
    ReadMemory( arg, &Header, sizeof(Header), 0);

    dprintf("\n"
            "\n"
            "[%8x] cb         %-#x\n"
            "[%8x] dwType     %-#x %s\n"
            , pHeader + offsetof(TTPOLYGONHEADER, cb ), Header.cb
            , pHeader + offsetof(TTPOLYGONHEADER, dwType), Header.dwType
            , Header.dwType == TT_POLYGON_TYPE ? "TT_POLYGON_TYPE" : "?");

    dprintf(
            "[%8x] pfxStart.x %-#10x "
            , pHeader + offsetof(TTPOLYGONHEADER, pfxStart.x), Header.pfxStart.x);
    dump28_4(*(LONG*)&Header.pfxStart.x);
    dprintf("\n");

    dprintf(
            "[%8x] pfxStart.y %-#10x "
            , pHeader + offsetof(TTPOLYGONHEADER, pfxStart.y), Header.pfxStart.y);
    dump28_4(*(LONG*)&Header.pfxStart.y);
    dprintf("\n");


    if (pCopy = (char*) LocalAlloc(LMEM_FIXED,Header.cb))
    {
        ReadMemory((ULONG_PTR)pHeader, pCopy, Header.cb, 0);
        dp = pHeader - pCopy;
        pStart = pCopy + sizeof(Header);
        pStop  = pCopy + Header.cb;
        for (pCurve = pStart; pCurve < pStop; pCurve = (char*) pfxStop)
        {
            char *pszType;
            WORD i;
            TTPOLYCURVE *p = (TTPOLYCURVE*) pCurve;

            pfx = &p->apfx[0];
            pfxStop = pfx + p->cpfx;

            switch (p->wType)
            {
            case TT_PRIM_LINE:      pszType = "TT_PRIM_LINE"; break;
            case TT_PRIM_QSPLINE:   pszType = "TT_PRIM_QSPLINE";break;
            default: pszType = "?";
            }

            dprintf(    "[%8x] wType %-#x %s\n"
                        "[%8x] cpfx  %-#x\n"
                    , (char*) (&p->wType) + dp, p->wType, pszType
                    , (char*) (&p->cpfx) + dp, p->cpfx);

            for ( i = 0; i < p->cpfx; i++,pfx++)
            {
                dprintf("[%8x] [%3u] %-#10x ", (char*)(&pfx->x) + dp, i, pfx->x);  dump28_4(*(LONG*)&pfx->x); dprintf("\n");
                dprintf("[%8x]       %-#10x ", (char*)(&pfx->y) + dp,    pfx->y);  dump28_4(*(LONG*)&pfx->y); dprintf("\n");
            }
        }
        LocalFree(pCopy);
    }
}

DECLARE_API( gout )
{
    fs_GlyphInfoType gi, *pGi;
    ULONG_PTR arg;
    int i;

    if ( *args == '\0' )
    {
        dprintf( "Enter address of argument\n" );
        return;
    }

    sscanf( args, "%p", &arg );
    ReadMemory(arg, &gi, sizeof(gi), NULL);
    pGi = (fs_GlyphInfoType*) arg;

    dprintf("\n\n");
        dprintf("[%x] memorySizes        \n", &pGi->memorySizes);
    for (i = 0; i < MEMORYFRAGMENTS; i++)
        dprintf("                        %u\n", gi.memorySizes[i]);
    dprintf("[%x] glyphIndex         %06x\n" , &pGi->glyphIndex , gi.glyphIndex        );
    dprintf("[%x] numberOfBytesTaken %06x\n" , &pGi->numberOfBytesTaken, gi.numberOfBytesTaken);

    dprintf("     metricInfo\n");
    dprintf("\t  advanceWidth\n");
    dprintf("[%x]       x                   %-#x\n",  &pGi->metricInfo.advanceWidth.x         , gi.metricInfo.advanceWidth.x        );
    dprintf("[%x]       y                   %-#x\n",  &pGi->metricInfo.advanceWidth.y         , gi.metricInfo.advanceWidth.y        );

    dprintf("\t  leftSideBearing\n");
    dprintf("[%x]       x                   %-#x\n",  &pGi->metricInfo.leftSideBearing.x      , gi.metricInfo.leftSideBearing.x     );
    dprintf("[%x]       y                   %-#x\n",  &pGi->metricInfo.leftSideBearing.y      , gi.metricInfo.leftSideBearing.y     );

    dprintf("\t  leftSideBearingLine\n");
    dprintf("[%x]       x                   %-#x\n",  &pGi->metricInfo.leftSideBearingLine.x  , gi.metricInfo.leftSideBearingLine.x );
    dprintf("[%x]       y                   %-#x\n",  &pGi->metricInfo.leftSideBearingLine.y  , gi.metricInfo.leftSideBearingLine.y );


    dprintf("\t  devLeftSideBearingLine\n");
    dprintf("[%x]       x                   %-#x\n",  &pGi->metricInfo.devLeftSideBearingLine.x , gi.metricInfo.devLeftSideBearingLine.x );
    dprintf("[%x]       y                   %-#x\n",  &pGi->metricInfo.devLeftSideBearingLine.y , gi.metricInfo.devLeftSideBearingLine.y );

    dprintf("\t  devAdvanceWidth\n");
    dprintf("[%x]       x                   %-#x\n",  &pGi->metricInfo.devAdvanceWidth.x      , gi.metricInfo.devAdvanceWidth.x          );
    dprintf("[%x]       y                   %-#x\n",  &pGi->metricInfo.devAdvanceWidth.y      , gi.metricInfo.devAdvanceWidth.y          );

    dprintf("\t  devLeftSideBearing\n");
    dprintf("[%x]       x                   %-#x\n",  &pGi->metricInfo.devLeftSideBearing.x  , gi.metricInfo.devLeftSideBearing.x        );
    dprintf("[%x]       y                   %-#x\n",  &pGi->metricInfo.devLeftSideBearing.y  , gi.metricInfo.devLeftSideBearing.y        );


    dprintf("     bitMapInfo\n");
    dprintf("[%x]    baseAddr %-#x\n"    , &pGi->bitMapInfo.baseAddr, gi.bitMapInfo.baseAddr            );
    dprintf("[%x]    rowBytes %d\n"      , &pGi->bitMapInfo.rowBytes, gi.bitMapInfo.rowBytes            );
    dprintf("[%x]    bounds\n"           , &pGi->bitMapInfo.bounds                                      );
    dprintf("[%x]      top    %d\n"      , &pGi->bitMapInfo.bounds.top   , gi.bitMapInfo.bounds.top     );
    dprintf("[%x]      left   %d\n"      , &pGi->bitMapInfo.bounds.left  , gi.bitMapInfo.bounds.left    );
    dprintf("[%x]      bottom %d\n"      , &pGi->bitMapInfo.bounds.bottom, gi.bitMapInfo.bounds.bottom  );
    dprintf("[%x]      right  %d\n"      , &pGi->bitMapInfo.bounds.right , gi.bitMapInfo.bounds.right   );

    dprintf("[%x] outlineCacheSize   %d\n"   , &pGi->outlineCacheSize   , gi.outlineCacheSize  );
    dprintf("[%x] outlinesExist      %u\n"   , &pGi->outlinesExist      , gi.outlinesExist     );
    dprintf("[%x] numberOfContours   %u\n"   , &pGi->numberOfContours   , gi.numberOfContours  );
    dprintf("[%x] xPtr               %-#x\n" , &pGi->xPtr               , gi.xPtr              );
    dprintf("[%x] yPtr               %-#x\n" , &pGi->yPtr               , gi.yPtr              );
    dprintf("[%x] startPtr           %-#x\n" , &pGi->startPtr           , gi.startPtr          );
    dprintf("[%x] endPtr             %-#x\n" , &pGi->endPtr             , gi.endPtr            );
    dprintf("[%x] onCurve;           %-#x\n" , &pGi->onCurve            , gi.onCurve           );
    dprintf("[%x] scaledCVT          %-#x\n" , &pGi->scaledCVT          , gi.scaledCVT         );
    dprintf("[%x] usBitmapFound      %u\n"   , &pGi->usBitmapFound      , gi.usBitmapFound     );
    dprintf("[%x] usGrayLevels       %u\n"   , &pGi->usGrayLevels       , gi.usGrayLevels       );
}

DECLARE_API( gin )
{
    fs_GlyphInputType gi, *pInput;
    ULONG_PTR arg;
    int i;

    if ( *args == '\0' )
    {
        dprintf( "Enter address of argument\n" );
        return;
    }

    sscanf( args, "%p", &arg );
    pInput = (fs_GlyphInputType*) arg;
    ReadMemory(arg, &gi, sizeof(gi), NULL);

    dprintf("\n\n");
    dprintf("[%x] version                  = %-#x\n"  , &pInput->version, gi.version);
    dprintf("[%x] memoryBases\n"                      , &pInput->memoryBases[0], gi.memoryBases[0]);

    for (i = 0; i < MEMORYFRAGMENTS; i++)
        dprintf("[%x]                           %-#x:%d\n", &pInput->memoryBases[i], gi.memoryBases[i],i);

    dprintf("[%x] sfntDirectroy            %-#x\n", &pInput->sfntDirectory                   , gi.sfntDirectory                  );
    dprintf("[%x] GetSfntFragmentPtr       %-#x\n", &pInput->GetSfntFragmentPtr              , gi.GetSfntFragmentPtr             );
    dprintf("[%x] ReleaseSfntFrag          %-#x\n", &pInput->ReleaseSfntFrag                 , gi.ReleaseSfntFrag                );
    dprintf("[%x] clientID                 %-#x\n", &pInput->clientID                        , gi.clientID                       );
    dprintf("[%x] newsfnt.PlatformID       %04x\n", &pInput->param.newsfnt.platformID        , gi.param.newsfnt.platformID       );
    dprintf("[%x]        .specificID       %04x\n", &pInput->param.newsfnt.specificID        , gi.param.newsfnt.specificID       );
    dprintf("[%x] newtrans.pointSize       %-#x\n", &pInput->param.newtrans.pointSize        , gi.param.newtrans.pointSize       );
    dprintf("[%x]         .xResolution     %d\n",   &pInput->param.newtrans.xResolution      , gi.param.newtrans.xResolution     );
    dprintf("[%x]         .yResolution     %d\n",   &pInput->param.newtrans.yResolution      , gi.param.newtrans.yResolution     );
    dprintf("[%x]         .pixelDiameter   %-#x\n", &pInput->param.newtrans.pixelDiameter    , gi.param.newtrans.pixelDiameter   );
    dprintf("[%x]         .transformMatrix %-#x\n", &pInput->param.newtrans.transformMatrix  , gi.param.newtrans.transformMatrix );
    dprintf("[%x]         .FntTraceFunc    %-#x\n", &pInput->param.newtrans.traceFunc        , gi.param.newtrans.traceFunc       );
    dprintf("[%x]         .usOverScale     %u\n"  , &pInput->param.newtrans.usOverScale      , gi.param.newtrans.usOverScale     );
    dprintf("[%x]         .usEmboldWeightx %u\n"  , &pInput->param.newtrans.usEmboldWeightx  , gi.param.newtrans.usEmboldWeightx );
    dprintf("[%x]         .usEmboldWeighty %u\n"  , &pInput->param.newtrans.usEmboldWeighty  , gi.param.newtrans.usEmboldWeighty );
    dprintf("[%x]         .lDescDev        %d\n"  , &pInput->param.newtrans.lDescDev         , gi.param.newtrans.lDescDev        );
    dprintf("[%x]         .bBitmapEmboldening %d\n", &pInput->param.newtrans.bBitmapEmboldening, gi.param.newtrans.bBitmapEmboldening);
    dprintf("[%x] newglyph.characterCode   %04x\n", &pInput->param.newglyph.characterCode    , gi.param.newglyph.characterCode   );
    dprintf("[%x]         .glyphIndex      %04x\n", &pInput->param.newglyph.glyphIndex       , gi.param.newglyph.glyphIndex      );
    dprintf("[%x]         .bMatchBBox      %d\n"  , &pInput->param.newglyph.bMatchBBox       , gi.param.newglyph.bMatchBBox      );
    dprintf("[%x]         .bNoEmbedded     %d\n"  , &pInput->param.newglyph.bNoEmbeddedBitmap, gi.param.newglyph.bNoEmbeddedBitmap);
    dprintf("[%x] gridfit.styleFunc        %-#x\n", &pInput->param.gridfit.styleFunc         , gi.param.gridfit.styleFunc        );
    dprintf("[%x]        .traceFunc        %-#x\n", &pInput->param.gridfit.traceFunc         , gi.param.gridfit.traceFunc        );
    dprintf("[%x]        .bSkipIfBitmap    %d\n"  , &pInput->param.gridfit.bSkipIfBitmap     , gi.param.gridfit.bSkipIfBitmap    );
    dprintf("[%x] outlineCache             %-#x\n", &pInput->param.outlineCache              , gi.param.outlineCache             );
    dprintf("[%x] band.usBandType          %u\n"  , &pInput->param.band.usBandType           , gi.param.band.usBandType          );
    dprintf("[%x]     .usBandWidth         %u\n"  , &pInput->param.band.usBandWidth          , gi.param.band.usBandWidth         );
    dprintf("[%x]     .outlineCache        %-#x\n", &pInput->param.band.outlineCache         , gi.param.band.outlineCache        );
    dprintf("[%x] scan.bottomClip          %d\n"  , &pInput->param.scan.bottomClip           , gi.param.scan.bottomClip          );
    dprintf("[%x]     .topClip             %d\n"  , &pInput->param.scan.topClip              , gi.param.scan.topClip             );
    dprintf("[%x]     .outlineCache        %-#x\n", &pInput->param.scan.outlineCache         , gi.param.scan.outlineCache        );
    dprintf("\n\n");
}

DECLARE_API( fc )
{
    ULONG_PTR arg;
    LONG l;
    FONTCONTEXT fc,*pfc;
    char ach[200];

    if ( *args == '\0' )
    {
        dprintf( "Enter address of GMC\n" );
        return;
    }

    sscanf( args, "%p", &arg );
    ReadMemory(arg, &fc, sizeof(fc), NULL);

    pfc = (FONTCONTEXT*) arg;

    dprintf("\n\n");
    dprintf("[%x] pfo               %-#10x \n" , &pfc->pfo              , fc.pfo                                      );
    dprintf("[%x] pff               %-#10x \n" , &pfc->pff              , fc.pff                                      );
    dprintf("[%x] gstat                    \n" , &pfc->gstat                                                          );
    dprintf("[%x] flFontType        %-#10x \n" , &pfc->flFontType       , fc.flFontType                               );
    dprintf("[%x] sizLogResPpi      %d %d  \n" , &pfc->sizLogResPpi     , fc.sizLogResPpi.cx, fc.sizLogResPpi.cy      );
    dprintf("[%x] ulStyleSize       %u     \n" , &pfc->ulStyleSize      , fc.ulStyleSize                              );
    dprintf("[%x] xfm                      \n" , &pfc->xfm                                                            );
    dprintf("[%x] mx                       \n" , &pfc->mx                                                             );
    dprintf("           %-#x %-#x %-#x\n"        , fc.mx.transform[0][0], fc.mx.transform[0][1], fc.mx.transform[0][2]);
    dprintf("           %-#x %-#x %-#x\n"        , fc.mx.transform[1][0], fc.mx.transform[1][1], fc.mx.transform[1][2]);
    dprintf("           %-#x %-#x %-#x\n"        , fc.mx.transform[2][0], fc.mx.transform[2][1], fc.mx.transform[2][2]);
    dprintf("[%x] flXform           %-#10x \n" , &pfc->flXform          , fc.flXform                                  );
    dprintf("[%x] lEmHtDev          %d     \n" , &pfc->lEmHtDev         , fc.lEmHtDev                                 );
    dprintf("[%x] fxPtSize          %-#10x \n" , &pfc->fxPtSize         , fc.fxPtSize                                 );
    dprintf("[%x] phdmx             %-#10x \n" , &pfc->phdmx            , fc.phdmx                                    );
    dprintf("[%x] lAscDev           %d     \n" , &pfc->lAscDev          , fc.lAscDev                                  );
    dprintf("[%x] lDescDev          %d     \n" , &pfc->lDescDev         , fc.lDescDev                                 );
    dprintf("[%x] xMin              %d     \n" , &pfc->xMin             , fc.xMin                                     );
    dprintf("[%x] xMax              %d     \n" , &pfc->xMax             , fc.xMax                                     );
    dprintf("[%x] yMin              %d     \n" , &pfc->yMin             , fc.yMin                                     );
    dprintf("[%x] yMax              %d     \n" , &pfc->yMax             , fc.yMax                                     );
    dprintf("[%x] cxMax             %u     \n" , &pfc->cxMax            , fc.cxMax                                    );
    dprintf("[%x] cjGlyphMax        %u     \n" , &pfc->cjGlyphMax       , fc.cjGlyphMax                               );
    dprintf("[%x] pgin              %-#10x \n" , &pfc->pgin             , fc.pgin                                     );
    dprintf("[%x] pgout             %-#10x \n" , &pfc->pgout            , fc.pgout                                    );
    dprintf("[%x] ptp               %-#10x \n" , &pfc->ptp              , fc.ptp                                      );
    dprintf("[%x] ptlSingularOrigin %d %d\n"   , &pfc->ptlSingularOrigin, fc.ptlSingularOrigin.x, fc.ptlSingularOrigin.y);

    dprintf("[%x] pteUnitBase       %-#x %-#x\n" , &pfc->pteUnitBase, fc.pteUnitBase.x, fc.pteUnitBase.y );

    dprintf("[%x] efBase (use !gdikdx.ef %x)\n" , &pfc->efBase , &pfc->efBase);
    dprintf("[%x] ptqUnitBase\n"                 , &pfc->ptqUnitBase);
    dprintf("[%x] vtflSide (use !gdikdx.ef)  \n", &pfc->vtflSide);
    dprintf("[%x] pteUnitSide\n"                 , &pfc->pteUnitSide);
    dprintf("[%x] efSide (use !gdikdx.ef %x)\n" , &pfc->efSide , &pfc->efSide);
    dprintf("[%x] ptqUnitSide\n"                 , &pfc->ptqUnitSide);
    dprintf("[%x] ptfxTop           %-#x %-#x\n" , &pfc->ptfxTop   , fc.ptfxTop.x, fc.ptfxTop.y);
    dprintf("[%x] ptfxBottom        %-#x %-#x\n" , &pfc->ptfxBottom, fc.ptfxBottom.x , fc.ptfxBottom.y);
    dprintf("[%x] ulControl         %-#x\n", &pfc->ulControl, fc.ulControl);
    dprintf("[%x] bVertical         %-#x\n", &pfc->bVertical, fc.bVertical);
    dprintf("[%x] hgSave            %-#x\n", &pfc->hgSave, fc.hgSave);
    dprintf("[%x] pointSize         %-#x\n", &pfc->pointSize, fc.pointSize);
    dprintf("[%x] mxv\n", &pfc->mxv);
    dprintf("[%x] mxn\n", &pfc->mxn);
    dprintf("[%x] fxdevShiftX       %-#x\n", &pfc->fxdevShiftX, fc.fxdevShiftX);
    dprintf("[%x] fxdevShiftY       %-#x\n", &pfc->fxdevShiftY, fc.fxdevShiftY);
    dprintf("[%x] dBase             %d     \n" , &pfc->dBase            , fc.dBase                                    );
    dprintf("[%x] overScale         %d     \n" , &pfc->overScale, fc.overScale);    

    dprintf("\n\n");
}

DECLARE_API( ff )
{
    ULONG_PTR arg;
    LONG l;
    FONTFILE ff, *pLocal, *pRemote;
    char **ppsz;
    TABLE_ENTRY *pte;

    static char *apszReq[] =
    {
        "IT_REQ_CMAP ", "IT_REQ_GLYPH", "IT_REQ_HEAD ", "IT_REQ_HHEAD",
        "IT_REQ_HMTX ", "IT_REQ_LOCA ", "IT_REQ_MAXP ", "IT_REQ_NAME ",
        0
    };
    static char *apszOpt[] =
    {
        "IT_OPT_OS2 ", "IT_OPT_HDMX", "IT_OPT_VDMX", "IT_OPT_KERN",
        "IT_OPT_LSTH", "IT_OPT_POST", "IT_OPT_GASP", 0
    };

    dprintf("\n\n");

    if ( *args == '\0' )
    {
        dprintf( "Enter address of GMC\n" );
        return;
    }

    sscanf( args, "%p", &arg );
    ReadMemory(arg, &ff, sizeof(ff), NULL);

    pLocal  = &ff;
    pRemote = (FONTFILE*) arg;

    dprintf("\n\n");
    N3(pttc,                  "pttc                  ", "%-#x\n");
    N3(hgSearchVerticalGlyph, "hgSearchVerticalGlyph ", "%-#x\n");
    N3(pifi_vertical,         "pifi_vertical         ", "%-#x\n");
    N3(pj034,                 "pj034                 ", "%-#x\n");
    N3(pfcLast,               "pfcLast               ", "%-#x\n");
    N3(pfcToBeFreed,          "pfcToBeFreed          ", "%-#x\n");
    N3(cRef,                  "cRef                  ", "%u\n"  );
    N3(iFile,                 "iFile                 ", "%-#x\n");
    N3(pvView,                "pvView                ", "%-#x\n");
    N3(cjView,                "cjView                ", "%u\n"  );
    N3(pkp,                   "pkp                   ", "%-#x\n");
    N3(pgset,                 "pgset                 ", "%-#x\n");
    N3(pgsetv,                "pgsetv                ", "%-#x\n");
    N3(cRefGSet,              "cRefGSet              ", "%u\n"  );
    N3(cRefGSetV,             "cRefGSetV             ", "%u\n"  );

    dprintf("[%p] tp     [dp]     [cj]\n", arg+offsetof(FONTFILE,ffca)+offsetof(FFCACHE,tp));
    for (ppsz = apszReq, pte = ff.ffca.tp.ateReq; *ppsz; ppsz++, pte++)
        dprintf(
            "[%p]       %-#x %-#x %s\n",
            arg+(ULONG_PTR)pte-(ULONG_PTR)ff.ffca.tp.ateReq,
            pte->dp,
            pte->cj,
            *ppsz
            );
    for (ppsz = apszOpt, pte = ff.ffca.tp.ateOpt; *ppsz; ppsz++, pte++)
        dprintf(
            "[%p]       %-#x %-#x %s\n",
            arg+(ULONG_PTR)pte-(ULONG_PTR)ff.ffca.tp.ateReq,
            pte->dp,
            pte->cj,
            *ppsz
            );

    N3(ffca.ulTableOffset,         "ffca.ulTableOffset         ", "%-#x\n");
    N3(ffca.ulVerticalTableOffset, "ffca.ulVerticalTableOffset ", "%-#x\n");
    N3(ffca.uLongVerticalMetrics,  "ffca.uLongVerticalMetrics  ", "%-#x\n");
    N3(ffca.ulNumFaces,            "ffca.ulNumFaces            ", "%-#x\n");
    N3(ffca.uiFontCodePage,        "ffca.uiFontCodePage        ", "%u\n"  );
    N3(ffca.cj3,                   "ffca.cj3                   ", "%u\n"  );
    N3(ffca.cj4,                   "ffca.cj4                   ", "%u\n"  );
    N3(ffca.fl,                    "ffca.fl                    ", "%-#x\n");
    N3(ffca.dpMappingTable,        "ffca.dpMappingTable        ", "%-#x\n");
    N3(ffca.ui16EmHt,              "ffca.ui16EmHt              ", "%u\n"  );
    N3(ffca.ui16PlatformID,        "ffca.ui16PlatformID        ", "%-#x\n");
    N3(ffca.ui16SpecificID,        "ffca.ui16SpecificID        ", "%-#x\n");
    N3(ffca.ui16LanguageID,        "ffca.ui16LanguageID        ", "%-#x\n");
    N3(ffca.iGlyphSet,             "ffca.iGlyphSet             ", "%u\n"  );
    N3(ffca.wcBiasFirst,           "ffca.wcBiasFirst           ", "%u\n"  );
    N3(ffca.usMinD,                "ffca.usMinD                ", "%u\n"  );
    N3(ffca.igMinD,                "ffca.igMinD                ", "%u\n"  );
    N3(ffca.sMinA,                 "ffca.sMinA                 ", "%d\n"  );
    N3(ffca.sMinC,                 "ffca.sMinC                 ", "%d\n"  );
    N2(ifi,                   "ifi\n");
    dprintf("\n\n");
}

DECLARE_API( ttc )
{
    ULONG_PTR arg;
    unsigned int size;
    TTC_FONTFILE ttc, *pLocal, *pRemote;
    TTC_HFF_ENTRY *pEntry, *pEntryLast, *pRemoteEntry;

    if ( *args == '\0' )
    {
        dprintf( "Enter address of TTC_FONTFILE\n" );
        return;
    }

    sscanf( args, "%p", &arg );
    ReadMemory(arg, &ttc, sizeof(ttc), NULL);

    size = (unsigned int)((char*)&ttc.ahffEntry[ttc.ulNumEntry] - (char*)&ttc);
    ReadMemory(arg, adw, size, 0);

    pLocal  = (TTC_FONTFILE*) adw;
    pRemote = (TTC_FONTFILE*) arg;

    dprintf("\n\n");
    dprintf("[%x] cRef               %-#x\n", &pRemote->cRef, pLocal->cRef);
    dprintf("[%x] fl                 %-#x\n", &pRemote->fl, pLocal->fl);
    dprintf("[%x] ulTrueTypeResource %-#x\n", &pRemote->ulTrueTypeResource, pLocal->ulTrueTypeResource);
    dprintf("[%x] ulNumEntry         %-#x\n", &pRemote->ulNumEntry, pLocal->ulNumEntry);
    dprintf("[%x] pvView             %-#x\n", &pRemote->pvView, pLocal->pvView);
    dprintf("[%x] cjView             %-#x\n", &pRemote->pvView, pLocal->cjView);

    pEntry = pLocal->ahffEntry;
    pEntryLast = pEntry + pLocal->ulNumEntry;
    pRemoteEntry = pRemote->ahffEntry;

    for (; pEntry < pEntryLast; pEntry++, pRemoteEntry++)
    {
        TTC_HFF_ENTRY *pL = pEntry, *pR = pRemoteEntry;

        dprintf("[%x] ulOffsetTable      %-#x\n", &pR->ulOffsetTable, pL->ulOffsetTable);
        dprintf("[%x] iFace              %-#x\n", &pR->iFace, pL->iFace);
        dprintf("[%x] hff                %-#x\n", &pR->hff, pL->iFace);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\bmfd\stretch.c ===
/******************************Module*Header*******************************\
* Module Name: stretch.c
*
* Routines to stretch a glyph bitmap up to five times in the x direction
* and an arbitrary number of times in the y direction.  These limits are
* the ones imposed by windows.
*
* Created: 7-Dec-1992 16:00:00
* Author: Gerrit van Wingerden
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "fd.h"

// Since there are only four ways we can stretch in the x direction we use
// tables to do our stretching.  The tables index 2 to 3 bit quantities to
// bytes or words that correspond to the stretched values of those quantities.
// This is much faster than doing all the shifting neccesary to stretch those
// quantities.

BYTE ajStretch2[16] = { 0x00, 0x03, 0x0C, 0x0F, 0x30, 0x33, 0x3C, 0x3F, 0xC0,
                        0xC3, 0xCC, 0xCF, 0xF0, 0xF3, 0xFC, 0xFF };
BYTE ajStretch3B1[8] = { 0x00, 0x03, 0x1C, 0x1F, 0xE0, 0xE3, 0xFC, 0xFF };
BYTE ajStretch3B2[16] = { 0x00, 0x01, 0x0E, 0x0F, 0x70, 0x71, 0x7E, 0x7F, 0x80,
                          0x81, 0x8E, 0x8F, 0xF0, 0xF1, 0xFE, 0xFF };
BYTE ajStretch3B3[8] = { 0x00, 0x07, 0x38, 0x3F, 0xC0, 0xC7, 0xF8, 0xFF };
WORD awStretch4[16] = { 0x0000, 0x0F00, 0xF000, 0xFF00, 0x000F, 0x0F0F, 0xF00F,
                        0xFF0F, 0x00F0, 0x0FF0, 0xF0F0, 0xFFF0, 0x00FF, 0x0FFF,
                        0xF0FF, 0xFFFF };
WORD awStretch5W1[16] = { 0x0000, 0x0100, 0x3E00, 0x3F00, 0xC007, 0xC107,
                          0xFE07, 0xFF07, 0x00F8, 0x01F8, 0x3EF8, 0x3FF8,
                          0xC0FF, 0xC1FF, 0xFEFF, 0xFFFF };
WORD awStretch5W2[16] = { 0x0000, 0x0300, 0x7C00, 0x7F00, 0x800F, 0x830F,
                          0xFC0F, 0xFF0F, 0x00F0, 0x03F0, 0x7CF0, 0x7FF0,
                          0x80FF, 0x83FF, 0xFCFF, 0xFFFF };
BYTE ajStretch5B1[4] = { 0x00, 0x1F, 0xE0, 0xFF };

/**************************************************************************\
* void vEmboldenItalicizeLine
*
* Emboldens and italicizes a scan line.
*
* Created: 7-Dec-1992 16:00:00
* Author: Gerrit van Wingerden
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/



void vEmboldenItalicizeLine( BYTE *pjDst,       // Destitnation scan line
                             BYTE *pjSrc,       // Source scan line
                             BYTE *pjEnd,       // End of source scan line
                             LONG lShift,       // Amount by which to shift
                             UINT uiPixelWidth  // Width of scan line in pixels
                            )
{
    BYTE jSrcItalic;
    BYTE jCarry = (BYTE) 0;
    BYTE jCarryBold = (BYTE) 0;

    for( ; pjSrc < pjEnd; pjDst++, pjSrc++  )
    {
        jSrcItalic = (BYTE) ( (*pjSrc >> lShift) | jCarry );
        *pjDst = (BYTE) ( jSrcItalic | ( jSrcItalic >> 1 ) | jCarryBold );

        // remember the lShift rightmost and mve them over to the left

        jCarry = (BYTE) ( *pjSrc << ( 8 - lShift ));
        jCarryBold = (BYTE) ( jSrcItalic << 7 );
    }

    if( ( (long) ( 8 - ( uiPixelWidth & 7l )) & 7l ) < lShift )
    {
        jSrcItalic = jCarry;
        *pjDst = (BYTE) ( jSrcItalic | ( jSrcItalic >> 1 ) | jCarryBold );
        jCarryBold = (BYTE) (jSrcItalic << 7 );

        if( ( uiPixelWidth & 0x7l ) == 0l )
        {
            *(++pjDst) = jCarryBold;
        }
    }
}


/**************************************************************************\
* void vEmboldenLine
*
* Emboldens a scan line.
*
* Created: 7-Dec-1992 16:00:00
* Author: Gerrit van Wingerden
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/




void vEmboldenLine( BYTE *pjDst,        // Destination scan line
                    BYTE *pjSrc,        // Source scan line
                    BYTE *pjEnd,        // End of dest scan line
                    UINT uiPixelWidth   // Width of scan line in pixels
                    )
{
    BYTE jCarry = (BYTE) 0;

    for( ; pjDst < pjEnd; pjDst++, pjSrc++  )
    {
        *pjDst = ( *pjSrc | (( *pjSrc >> 1 ) | jCarry ));
        jCarry = ( *pjSrc << 7);
    }

    if( (( uiPixelWidth << 1 ) & 7l ) == 0l )
        *pjDst = jCarry;
}



/**************************************************************************\
* void vItalicizeLine
*
* Italicizes a scan line.
*
* Created: 7-Dec-1992 16:00:00
* Author: Gerrit van Wingerden
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/



void vItalicizeLine( BYTE *pjDst,       // Destitnation scan line
                     BYTE *pjSrc,       // Source scan line
                     BYTE *pjEnd,       // End of source scan line
                     LONG lShift,       // Amount by which to shift
                     UINT uiPixelWidth  // Width of scan line in pixels
                     )
{
    BYTE jCarry = (BYTE) 0;

    for( ; pjSrc < pjEnd; pjDst++, pjSrc++  )
    {
        *pjDst = (( *pjSrc >> lShift ) | jCarry );
        jCarry = ( *pjSrc << ( 8 - lShift) );
    }

    if( ( (long) ( 8 - ( uiPixelWidth & 7l )) & 7l ) < lShift )
        *pjDst = jCarry;
}



/*************************************************************************\
* VOID vStretchGlyphBitmap
*
* Stretches a bitmap in fontfile format ( collumns ) to a row format and
* performs bold and italic simulations.  This routine could be faster
* by spliting it up into several special case routines to handle simulations
* and or different widths or by inlining the italicizing or emboldening
* routines.  However, we hardly ever need to stretch bitmap fonts so it
* was deemed better to have one, nice neat routine that takes up less
* code than several routines that are overall faster.
*
*
* Created: 7-Dec-1992 16:00:00
* Author: Gerrit van Wingerden [gerritv]
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/



VOID vStretchGlyphBitmap( BYTE *pjTarget,       // Target bitmap
                         BYTE *pjSourceBitmap,  // Source bitmap
                         BYTE *pjLineBuffer,    // Scan line buffer
                         UINT uiPixelWidth,     // Width of bitmap in pixels
                         UINT uiHeight,         // Height of bitmap in bits
                         UINT uiVertScale,      // Vertical scaling factor
                         UINT uiHorzScale,      // Horizontal scaling factor
                         UINT flSim )           // Simulation flags
{
    BYTE *pjSource, *pjBufferBase, *pjScanEnd, *pjSimEnd;
    UINT uiScanDelta, uiNewWidth, uiNewWidthSim, cjEmpty, uiCurScan;
    LONG lShift;
    BYTE *pjDone = pjSourceBitmap + uiHeight;

    uiNewWidth = ( ( uiPixelWidth * uiHorzScale ) + 7 ) >> 3;
    pjSimEnd = pjLineBuffer + uiNewWidth;
    cjEmpty = 0;

    switch( flSim )
    {
    case (FO_SIM_ITALIC | FO_SIM_BOLD):
        // fall through to the italic case with one added to cxOffset
    case FO_SIM_ITALIC:
    {
        UINT cxOffset = ( uiHeight * uiVertScale - 1 ) / 2;

        if( flSim & FO_SIM_BOLD )
            cxOffset += 1;

        uiNewWidthSim = ( ( uiPixelWidth * uiHorzScale ) + cxOffset + 7 ) >> 3;
        uiCurScan = 0;
        lShift = cxOffset & (UINT) 7;
        cjEmpty = cxOffset >> 3;
        break;
    }
    case FO_SIM_BOLD:
        uiNewWidthSim = ( ( uiPixelWidth *uiHorzScale ) + 8 ) >> 3; 
        break;
    default:
        uiNewWidthSim = uiNewWidth;
        break;
    }

// output bytes generated per new scan line

    uiScanDelta = uiNewWidthSim * uiVertScale;


    for( ; pjSourceBitmap < pjDone; pjSourceBitmap += 1 )
    {

    // first stretch one scan line

        for( pjSource = pjSourceBitmap, pjBufferBase = pjLineBuffer;
           pjBufferBase < pjLineBuffer + uiNewWidth;
           pjSource += uiHeight )
        {

      switch( uiHorzScale )
      {
      case 1:
        // don't stretch just copy
          *pjBufferBase++ = *pjSource;
          break;
      case 2:
        // stretch first nibble
            *pjBufferBase++ = ajStretch2[ *pjSource >> 4];

        //stretch second nibble
            *pjBufferBase++ = ajStretch2[ *pjSource & 0xf];
         break;
      case 3:
        // first byte
            *pjBufferBase++ = ajStretch3B1[ *pjSource >> 5];
        // second byte
            *pjBufferBase++ = ajStretch3B2[ (*pjSource >> 2) & 0xf];
        // third byte
            *pjBufferBase++ = ajStretch3B3[ *pjSource &0x7];
         break;
      case 4:
                // I know this is strange but I didn't think about alignment
                // errors when I used word sized tables. So i had to hack it.
                // !!! later these tables should be writen to be byte tables.
                // [gerritv]

        // first nibble
                        *pjBufferBase++ = ((BYTE*)(&awStretch4[ *pjSource >> 4]))[0];
                        *pjBufferBase++ = ((BYTE*)(&awStretch4[ *pjSource >> 4]))[1];

                // second nibble
                        *pjBufferBase++ = ((BYTE*)(&awStretch4[ *pjSource & 0xf]))[0];
                        *pjBufferBase++ = ((BYTE*)(&awStretch4[ *pjSource & 0xf]))[1];
         break;
      case 5:
                // first word
                        *pjBufferBase++ = ((BYTE*)(&awStretch5W1[ *pjSource >> 4]))[0];
                        *pjBufferBase++ = ((BYTE*)(&awStretch5W1[ *pjSource >> 4]))[1];

                // second byte
                        *pjBufferBase++ = ((BYTE*)(&awStretch5W2[ (*pjSource >> 1) & 0xf]))[0];
                        *pjBufferBase++ = ((BYTE*)(&awStretch5W2[ (*pjSource >> 1) & 0xf]))[1];

        // third byte
            *pjBufferBase++ = ajStretch5B1[ *pjSource &0x3];
         break;
        }
   }

    // now copy stretched scan line uiVertScale times while making the bitmap byte aligned

      pjScanEnd = pjTarget + uiScanDelta;

        switch( flSim )
        {
        case FO_SIM_ITALIC:

        for( ; pjTarget < pjScanEnd; pjTarget += uiNewWidthSim )
        {

            vItalicizeLine( pjTarget + cjEmpty,
                            pjLineBuffer,
                            pjLineBuffer + uiNewWidth,
                            lShift,
                            uiPixelWidth * uiHorzScale );

            lShift -= ( uiCurScan++ & 0x1 );

            if( lShift < 0 )
            {
                lShift = 7;
                cjEmpty--;
            }
        }
        break;

        case ( FO_SIM_ITALIC | FO_SIM_BOLD ):

            for( ; pjTarget < pjScanEnd; pjTarget += uiNewWidthSim )
            {

                vEmboldenItalicizeLine( pjTarget + cjEmpty,
                                pjLineBuffer,
                                pjLineBuffer + uiNewWidth,
                                lShift,
                                uiPixelWidth * uiHorzScale );

                lShift -= ( uiCurScan++ & 0x1 );

                if( lShift < 0 )
                {
                    lShift = 7;
                    cjEmpty--;
                }
            }

        break;
        case FO_SIM_BOLD:

          // first embolden this scan line

            vEmboldenLine( pjTarget, pjLineBuffer, pjTarget + uiNewWidth, uiPixelWidth * uiHorzScale );
            pjBufferBase = pjTarget;
            pjTarget += uiNewWidthSim;

            for( ; pjTarget < pjScanEnd; pjTarget += uiNewWidthSim )
                memcpy( (PVOID) pjTarget, (PVOID) pjBufferBase, (size_t) uiNewWidthSim );

            break;

        case 0:

        // just copy the scan line uiVertScale times

        for( ; pjTarget < pjScanEnd; pjTarget += uiNewWidthSim )
            memcpy( (PVOID) pjTarget, (PVOID) pjLineBuffer, (size_t) uiNewWidthSim );

        break;
        }

    }
}


/***************************************************************************\
* VOID vStretchCvtToBitmap
*
* Stretches a bitmap and performs bold and italic simulations.
*
* Created: 7-Dec-1992 16:00:00
* Author: Gerrit van Wingerden
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/




VOID
vStretchCvtToBitmap
(
    GLYPHBITS *pgb,
    PBYTE pjBitmap,     // bitmap in *.fnt form
    ULONG cx,           // unscaled width
    ULONG cy,           // unscaled height
    ULONG yBaseline,    // baseline from font file
    PBYTE pjLineBuffer, // preallocated buffer for use by stretch routines
    ULONG cxScale,      // horizontal scaling factor
    ULONG cyScale,      // vertical scaling factor
    ULONG flSim         // simulation flags
)
{
    ULONG cxNew, cyNew, yBaselineNew;

// compute new height, width, and baseline

    cxNew = cx * cxScale;
    cyNew = cy * cyScale;
    yBaselineNew = yBaseline * cyScale;

    switch( flSim )
    {
    case ( FO_SIM_ITALIC | FO_SIM_BOLD ):
        cxNew = cxNew + ( cyNew + 1 ) / 2;
        break;

    case FO_SIM_ITALIC:
        cxNew = cxNew + ( cyNew - 1 ) / 2;
        break;
    case FO_SIM_BOLD:
        cxNew += 1;
        break;
    case 0:
        break;
    }

// glyphbits data


    pgb->sizlBitmap.cx = cxNew;
    pgb->sizlBitmap.cy = cyNew;

    pgb->ptlOrigin.x = 0l;
    pgb->ptlOrigin.y = -(LONG) yBaselineNew;

    RtlZeroMemory( pgb->aj, ( CJ_SCAN( cxNew )) * cyNew );

    vStretchGlyphBitmap(  pgb->aj,
                    pjBitmap,
                    pjLineBuffer,
                    cx,
                    cy,
                    cyScale,
                    cxScale,
                    flSim );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\fnterr.h ===
#ifndef _FNTERR_H
#define _FNTERR_H
/**********************************************************************
	
	fnterr.h -- Error Support Routines prototypes.

	(c) Copyright 1992  Microsoft Corp.
	All rights reserved.

	This header file provides prototypes for the fnterr.c 
	 source module.  This module keys on the #define FSCFG_FNTERR
	which is defined in fsconfig.h

	 7/28/92 dj         First cut.

 **********************************************************************/


#ifdef FSCFG_FNTERR

#define ERR_RANGE                 1
#define ERR_ASSERTION             2
#define ERR_CVT                   3
#define ERR_FDEF                  4
#define ERR_ELEMENT               5
#define ERR_INDEX                 6
#define ERR_STORAGE               7
#define ERR_STACK                 8
#define ERR_POINT                 9
#define ERR_POINT_TLP             10
#define ERR_POINT_PP              11
#define ERR_CONTOUR               12
#define ERR_VECTOR                13
#define ERR_LARGER                14
#define ERR_INT8                  15
#define ERR_INT16                 16
#define ERR_SCANMODE              17
#define ERR_SELECTOR              18
#define ERR_STATE                 19
#define ERR_GETSINGLEWIDTHNIL     20
#define ERR_GETCVTENTRYNIL        21
#define ERR_INVOPC                22
#define ERR_UNBALANCEDIF          23

#define ERR_CONTEXT_FILE          0
#define ERR_CONTEXT_SIZE          1
#define ERR_CONTEXT_CODE          2

#define ERR_CONTEXT(a,b,c,d)      fnterr_Context((a),(b),(c),(d))
#define ERR_START()               fnterr_Start()
#define ERR_RECORD(a)             fnterr_Record((int)(a))
#define ERR_REPORT(a,b,c,d,e)     fnterr_Report((int)(a),(long)(b),(long)(c),(long)(d),(long)(e))
#define ERR_BREAK()               { if ( fnterr_Break() ) break; }
#define ERR_OPC(a)                fnterr_Opc(a)
#define ERR_END()                 fnterr_End()
#define ERR_IF(a)                 fnterr_If(a)

void fnterr_Context (int, char *, unsigned short, unsigned short);
void fnterr_Start (void);
void fnterr_Record (int);
void fnterr_Report (int, long, long, long, long);
int  fnterr_Break (void);
void fnterr_Opc (char*);
void fnterr_End (void);
void fnterr_If (int);

#else

#define ERR_CONTEXT(a,b,c,d)
#define ERR_START()
#define ERR_RECORD(a)
#define ERR_REPORT(a,b,c,d,e)     DEBUGGER ()
#define ERR_BREAK()
#define ERR_OPC(a)
#define ERR_END()
#define ERR_IF(a)

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\fnt.h ===
/*
	File:       fnt.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		  <>     4/30/97    CB      ClaudeBe, catching infinite loops/recursions
	      <>     2/21/97    CB      ClaudeBe, scaled component in composite glyphs
	      <>     2/05/96    CB      ClaudeBe, add bHintForGray in globalGS
	   <11+>     9/15/90    MR,rb   Change pvx and pvy to proj.[xy].  Same for freedom vector.
									Conditionalize vectors for Fracts or ShortFracts.
		<10>     7/26/90    MR      rearrange local graphic state, remove unused parBlockPtr
		 <9>     7/18/90    MR      change loop variable from long to short, and other Ansi-changes
		 <8>     7/13/90    MR      Prototypes for function pointers
		 <5>      6/4/90    MR      Remove MVT
		 <4>      5/3/90    RB      replaced dropoutcontrol with scancontrolin and scancontrol out
									in global graphics state
		 <3>     3/20/90    CL      fields for multiple preprograms fields for ppemDot6 and
									pointSizeDot6 changed SROUND to take D/2 as argument
		 <2>     2/27/90    CL      Added DSPVTL[] instruction.  Dropoutcontrol scanconverter and
									SCANCTRL[] instruction
	   <3.1>    11/14/89    CEL     Fixed two small bugs/feature in RTHG, and RUTG. Added SROUND &
									S45ROUND.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.7>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.6>     6/13/89    SJK     Comment
	   <1.5>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.4>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.3>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts

	To Do:
*/
/*  rwb 4/24/90 Replaced dropoutControl with scanControlIn and scanControlOut in
		global graphics state. 
		<3+>     3/20/90    mrr     Added support for IDEFs.  Made funcDefs long aligned
									by storing int16 length instead of int32 end.
*/

#ifndef FNT_DEFINED
#define FNT_DEFINED

#define STUBCONTROL 0x10000
#define NODOCONTROL 0x20000

#define FNT_PIXELSIZE  ((F26Dot6)0x40)
#define FNT_PIXELSHIFT 6

// public phantom points (cf. scale.c for private phantom points), relative to number of points in glyph
#define LEFTSIDEBEARING		0
#define RIGHTSIDEBEARING	1

#define TOPSIDEBEARING		2
#define BOTTOMSIDEBEARING	3

#define VECTORTYPE	ShortFract

#define NON90DEGTRANS_ROTATED	0x01
#define NON90DEGTRANS_STRETCH	0x02

#ifdef FSCFG_SUBPIXEL
/* For the SubPixel hinting flag field, internal flags */
#define FNT_SP_SUB_PIXEL			0x0001      /* set when calling fs_NewTransformation() */
#define FNT_SP_COMPATIBLE_WIDTH		0x0002      /* set when calling fs_NewTransformation() */
#define FNT_SP_VERTICAL_DIRECTION	0x0004		// set when calling fs_NewTransformation()
#define FNT_SP_BGR_ORDER			0x0008		// set when calling fs_NewTransformation()

#define SPCF_iupxCalled				0x0001		// individual bits of GlobalGS.subPixelCompatibilityFlags
#define SPCF_iupyCalled				0x0002
#define SPCF_inDiagEndCtrl			0x0004
#define SPCF_inVacuformRound		0x0008
#define SPCF_inSkippableDeltaFn		0x0010
#define SPCF_detectedDandIStroke	0x0100
#define SPCF_detectedJellesSpacing	0x0200
#define SPCF_detectedVacuformRound	0x0400
#define SPCF_detectedTomsDiagonal	0x0800


#endif // FSCFG_SUBPIXEL

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA

	#define BADREL	0x01
	#define DONE	0x02
	#define DOING	0x04

	// Data structure for information leap. This information leap is necessary because of the following reason:
	// Technically, what we're doing is to automatically add on-the-fly in-line deltas to the stream of instructions. Such deltas appear
	// after an incoming "link" (MIRP, MDRP), but before one or more outgoing "links". If one of these outgoing links controls a stroke,
	// then this stroke's phase may need to be adjusted (by a delta). However, we don't know whether any of the outgoing links controls a
	// stroke, nor which one, until we've interpreted them all, at which point it is too late to apply a delta, because the delta has to be
	// applied before any outgoing links (dependency). Conversely, the incoming link does not bear any information that would suggest that
	// it links to a stroke (don't know the future). To make matters worse, it is possible that in the stream of instructions the link that
	// controls a stroke comes at the very end of the TT code, even though there may have been many other, unrelated instructions inbetween.
	// Therefore, we have to interpert the entire TT code (upto the IUP instruction in the SP direction) before we know all we need to 
	// calculate and apply the phase control.
	
	typedef struct {
		int16 parent0,parent1; // -1 for none
		int16 child; // for black links (we can satisfy 1 phase shift only, hence no need for several children), else -1
		uint16 flags; // BADREL, DONE, DOING
		F26Dot6 phaseShift;
	} PhaseControlRelation; // 12 bytes (?)
	
#endif

typedef struct VECTOR {
	VECTORTYPE x;
	VECTORTYPE y;
} VECTOR;

typedef struct {
	F26Dot6 *x;         /* The Points the Interpreter modifies */
	F26Dot6 *y;         /* The Points the Interpreter modifies */
	F26Dot6 *ox;        /* Old Points */
	F26Dot6 *oy;        /* Old Points */
	F26Dot6 *oox;       /* Old Unscaled Points, really ints */
	F26Dot6 *ooy;       /* Old Unscaled Points, really ints */
	uint8   *onCurve;   /* indicates if a point is on or off the curve */
	int16   *sp;        /* Start points */
	int16   *ep;        /* End points */
	uint8   *f;         /* Internal flags, one byte for every point */
	int16   nc;         /* Number of contours */
	uint8   *fc;         /* contour flags, one byte for every contour */
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	boolean phaseControlExecuted;
	PhaseControlRelation *pcr;
#endif
} fnt_ElementType;

/* flags for contour flags : */
#define OUTLINE_MISORIENTED 1

typedef struct {
	int32 start;        /* offset to first instruction */
	uint16 length;      /* number of bytes to execute <4> */
	uint16 pgmIndex;    /* index to appropriate preprogram for this func (0..1) */
} fnt_funcDef;

/* <4> pretty much the same as fnt_funcDef, with the addition of opCode */
typedef struct {
	int32 start;
	uint16 length;
	uint8  pgmIndex;
	uint8  opCode;
} fnt_instrDef;

typedef struct {
	uint8 *    Instruction;
	uint32     Length;
} fnt_pgmList;

struct fnt_LocalGraphicStateType;
typedef void (FS_CALLBACK_PROTO *FntTraceFunc)(struct fnt_LocalGraphicStateType*, uint8*);

#ifdef FSCFG_REENTRANT
typedef uint8* (*FntFunc)(struct fnt_LocalGraphicStateType*, uint8*, int32);
typedef void (*FntMoveFunc)(struct fnt_LocalGraphicStateType*, fnt_ElementType*, int32, F26Dot6);
typedef F26Dot6 (*FntProject)(struct fnt_LocalGraphicStateType*, F26Dot6, F26Dot6);
typedef void (*InterpreterFunc)(struct fnt_LocalGraphicStateType*, uint8*, uint8*);
typedef F26Dot6 (*FntRoundFunc)(struct fnt_LocalGraphicStateType*, F26Dot6, F26Dot6);
#else 
typedef uint8* (*FntFunc)(uint8*, int32);
typedef void (*FntMoveFunc)(fnt_ElementType*, int32, F26Dot6);
typedef F26Dot6 (*FntProject)(F26Dot6 x, F26Dot6 y);
typedef void (*InterpreterFunc)(uint8*, uint8*);
typedef F26Dot6 (*FntRoundFunc)(F26Dot6 xin, F26Dot6 engine);
#endif 

typedef struct {

/* PARAMETERS CHANGEABLE BY TT INSTRUCTIONS */
	F26Dot6 wTCI;                   /* width table cut in */
	F26Dot6 sWCI;                   /* single width cut in */
	F26Dot6 scaledSW;               /* scaled single width */
	int32 scanControl;              /* controls kind and when of dropout control */
	int32 instructControl;          /* controls gridfitting and default setting */
	
	F26Dot6 minimumDistance;        /* moved from local gs  7/1/90  */
	FntRoundFunc RoundValue;        /*                              */
#ifdef FSCFG_SUBPIXEL
	uint16		roundState;			// see comments in interp.c
#endif
	F26Dot6 periodMask;             /* ~(gs->period-1)              */
	VECTORTYPE period45;            /*                              */
	int16   period;                 /* for power of 2 periods       */
	int16   phase;                  /*                              */
	int16   threshold;              /* moved from local gs  7/1/90  */

	int16 deltaBase;
	int16 deltaShift;
	int16 angleWeight;
	int16 sW;                       /* single width, expressed in the same units as the character */
	int8 autoFlip;                  /* The auto flip Boolean */
	int8 pad;   
#ifndef FSCFG_NOPAD_PARAMETER_BLOCK_4
	int16 pad2;   
#endif 
} fnt_ParameterBlock;               /* this is exported to client */

#define PREPROGRAM     0
#define FONTPROGRAM    1
#define GLYPHPROGRAM   2

#define MAXPREPROGRAMS 2

#ifdef FSCFG_SUBPIXEL
	#define maxDeltaFunctions	4
#endif

typedef struct fnt_ScaleRecord {
	Fixed fixedScale;       /* Slow Scale */
	int32 denom;            /* Fast and Medium Scale */
	int32 numer;            /* Fast and Medium Scale */
	int32 shift;            /* Fast Scale */
} fnt_ScaleRecord;

typedef F26Dot6 (*GlobalGSScaleFunc)(fnt_ScaleRecord*, F26Dot6);

typedef struct fnt_GlobalGraphicStateType {
	F26Dot6* stackBase;             /* the stack area */
	F26Dot6* store;                 /* the storage area */
	F26Dot6* controlValueTable;     /* the control value table */
	
	uint16  pixelsPerEm;            /* number of pixels per em as an integer */
	uint16  pointSize;              /* the requested point size as an integer */
	Fixed   fpem;                   /* fractional pixels per em    <3> */
	F26Dot6 engine[4];              /* Engine Characteristics */
	
	fnt_ParameterBlock defaultParBlock; /* variables settable by TT instructions */
	fnt_ParameterBlock localParBlock;

	/* Only the above is exported to Client throught FontScaler.h */

/* VARIABLES NOT DIRECTLY MANIPULABLE BY TT INSTRUCTIONS  */
	
	fnt_funcDef*    funcDef;           /* function Definitions identifiers */
	fnt_instrDef*   instrDef;         /* instruction Definitions identifiers */
	GlobalGSScaleFunc ScaleFuncXChild; /* child scaling when !bSameTransformAsMaster */
	GlobalGSScaleFunc ScaleFuncYChild; /* child scaling when !bSameTransformAsMaster */
	GlobalGSScaleFunc ScaleFuncX;
	GlobalGSScaleFunc ScaleFuncY;
	GlobalGSScaleFunc ScaleFuncCVT;
	fnt_pgmList     pgmList[MAXPREPROGRAMS];  /* each program ptr is in here */
	
/* These are parameters used by the call back function */
	fnt_ScaleRecord   scaleXChild; /* child scaling when !bSameTransformAsMaster */
	fnt_ScaleRecord   scaleYChild; /* child scaling when !bSameTransformAsMaster */
	fnt_ScaleRecord   scaleX;
	fnt_ScaleRecord   scaleY;
	fnt_ScaleRecord   scaleCVT;

	Fixed           cvtStretchX;
	Fixed           cvtStretchY;

	int8            identityTransformation;  /* true/false  (does not mean identity from a global sense) */
	int8            non90DegreeTransformation; /* bit 0 is 1 if non-90 degree, bit 1 is 1 if x scale doesn't equal y scale */
	Fixed           xStretch;           /* Tweaking for glyphs under transformational stress <4> */
	Fixed           yStretch;           /* Tweaking for glyphs under transformational stress <4> */
	
	int8            init;               /* executing preprogram ?? */
	/* !!! Should not be uint8, instead fnt_ProgramIndex */
	uint8           pgmIndex;           /* which preprogram is current */
	int32           instrDefCount;      /* number of currently defined IDefs */
	uint8			bSameStretch;
	uint8			bCompositeGlyph;	/* Flag that indicates composite glyph */
	LocalMaxProfile *	 maxp;
	uint16          cvtCount;
	Fixed           interpScalarX;      /* scalar for instructable things */
	Fixed           interpScalarY;      /* scalar for instructable things */
	Fixed           fxMetricScalarX;    /* scalar for metric things */
	Fixed           fxMetricScalarY;    /* scalar for metric things */
	/* int16  pad2; */

	boolean	bHintForGray;
	uint8			bSameTransformAsMaster;	/* for composite glyph, indicate the the sub-componenent has the same scaling than the master glyph */
	uint8			bOriginalPointIsInvalid;/* original point are invalid, we need to use ox/oy instead of scaling oox/ooy */

	uint32		ulMaxJumpCounter;			/* jump counter used to catch infinite loops */
	uint32		ulMaxRecursiveCall;		/* recursive calls counter used to check the level of recursion */
	uint32		ulMaxInstPerProgram;	/* max instruction per program counter to catch denial of service attacks */
    ClientIDType            clientID;  /* client private id/stamp, it's saved here to allow a trace function to access it */
#ifdef FSCFG_SECURE
	F26Dot6* stackMax;             /* maximum stack area */
	int32      maxPointsIncludePhantom;  /* in an individual glyph, including maxCompositePoints  */
#endif // FSCFG_SECURE
	uint16	uBoldSimulVertShift; /* vertical and horizontal (along baseline) shift for embolding simulation */
	uint16	uBoldSimulHorShift;
	F26Dot6	fxScaledDescender; /* scaled descender, used to clip emboldening if necessary */
#ifdef FSCFG_SUBPIXEL
	uint16	flHintForSubPixel;
	uint16	subPixelCompatibilityFlags;
	uint16	numDeltaFunctionsDetected;		  // fns to implement delta instr for range of ppem sizes or odd delta size use SHPIX,
	uint16	deltaFunction[maxDeltaFunctions]; // keep track of these cases to intelligently skip SHPIX
	Fixed	compatibleWidthStemConcertina;
#endif // FSCFG_SUBPIXEL
	boolean bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
									   or text animation where we want to turn off gridfitting hinting
									   but for fonts where glyphs are build by hinting, we still want the
									   glyph shape to be correct */
} fnt_GlobalGraphicStateType;

/* 
 * This is the local graphics state  
 */
typedef struct fnt_LocalGraphicStateType {
	fnt_ElementType *CE0, *CE1, *CE2;   /* The character element pointers */
	VECTOR proj;                        /* Projection Vector */
	VECTOR free;                        /* Freedom Vector */
	VECTOR oldProj;                     /* Old Projection Vector */
	F26Dot6 *stackPointer;

	uint8 *insPtr;                      /* Pointer to the instruction we are about to execute */
	fnt_ElementType *elements;
	fnt_GlobalGraphicStateType *globalGS;
		FntTraceFunc TraceFunc;

	int32 Pt0, Pt1, Pt2;           /* The internal reference points */
	int16 roundToGrid;
	int32 loop;                         /* The loop variable */
	uint8 opCode;                       /* The instruction we are executing */
	uint8 padByte;
	int16 padWord;

	/* Above is exported to client in FontScaler.h */

	VECTORTYPE pfProj; /* = pvx * fvx + pvy * fvy */

	FntMoveFunc MovePoint;
	FntProject Project;
	FntProject OldProject;
	InterpreterFunc Interpreter;
#ifdef FSCFG_REENTRANT
		F26Dot6 (*GetCVTEntry) (struct fnt_LocalGraphicStateType*,int32);
		F26Dot6 (*GetSingleWidth) (struct fnt_LocalGraphicStateType*);
#else 
		F26Dot6 (*GetCVTEntry) (int32 n);
		F26Dot6 (*GetSingleWidth) (void);
#endif 
	FntMoveFunc ChangeCvt;
	Fixed       cvtDiagonalStretch;

	int16       MIRPCode;               /* for fast or slow MIRP's */

	ErrorCode   ercReturn;              /* NO_ERR unless illegal instruction */
	uint8       *pbyEndInst;            /* one past last instruction */
	uint8       *pbyStartInst;          /* used to detect a jump before the begining of the program */

	uint32		ulJumpCounter;			/* jump counter used to catch infinite loops */
	uint32		ulRecursiveCall;		/* recursive calls counter used to check the level of recursion */
	uint32		ulInstPerProgram;		/* */
#ifdef FSCFG_SUBPIXEL
	uint16		inSubPixelDirection;
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	int16		pt0,pt1;
#endif
#endif
} fnt_LocalGraphicStateType;

#endif  /* FNT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\fnterr.c ===
/**********************************************************************
	
	fnterr.c -- Error Support Routines.

	(c) Copyright 1992  Microsoft Corp.
	All rights reserved.

	This source file provides support for debugging routines in fnt.c
	(and macjob.c to a much lesser extent).  This module keys on the
	 #define FSCFG_FNTERR which is defined in fsconfig.h

	 7/28/92 dj         First cut.
	 8/12/94 deanb      included fnterr.h for mac
	12/07/94 deanb		changed %x to %hx or %lx; %d to %hd

 **********************************************************************/

#define FSCFG_INTERNAL

#include "fsconfig.h"
#include "fnterr.h"

#ifdef FSCFG_FNTERR
#include <stdio.h>
#include <string.h>
#include <ctype.h>

/* FILE * fopen(); */
int    abs (int);
/*
int    strlen (char*);
int    strcmp (char*, char*);
int    strcpy (char*, char*);
int    strncpy( char*, char *, int);
*/

#define ERR_MAX_IFS      8
#define ERR_MAX_CODE     16
#define ERR_MAX_FNAME    80
#define ERR_MAX_MSG  512

static int               errOpc;
static int               errBreak;
static int               errIfOk  = 1;
static unsigned short    errSize  = 0;
static unsigned short    errCode  = 0;
static int               errIfNdx = 0;
static long              errInstCount;
static int               errIfs[ERR_MAX_IFS];
static char              errOpName[ERR_MAX_CODE];
static char              errFname[ERR_MAX_FNAME];
static char            * errOpcs[] =
{
  "SVTCA_0",
  "SVTCA_1",
  "SPVTCA",
  "SPVTCA",
  "SFVTCA",
  "SFVTCA",
  "SPVTL",
  "SPVTL",
  "SFVTL",
  "SFVTL",
  "WPV",
  "WFV",
  "RPV",
  "RFV",
  "SFVTPV",
  "ISECT",
  "SetLocalGraphicState",
  "SetLocalGraphicState",
  "SetLocalGraphicState",
  "SetElementPtr",
  "SetElementPtr",
  "SetElementPtr",
  "SetElementPtr",
  "SetLocalGraphicState",
  "SetRoundState",
  "SetRoundState",
  "LMD",
  "ELSE",
  "JMPR",
  "LWTCI",
  "LSWCI",
  "LSW",
  "DUP",
  "SetLocalGraphicState",
  "CLEAR",
  "SWAP",
  "DEPTH",
  "CINDEX",
  "MINDEX",
  "ALIGNPTS",
  "RAW",
  "UTP",
  "LOOPCALL",
  "CALL",
  "FDEF",
  "IllegalInstruction",
  "MDAP",
  "MDAP",
  "IUP",
  "IUP",
  "SHP",
  "SHP",
  "SHC",
  "SHC",
  "SHE",
  "SHE",
  "SHPIX",
  "IP",
  "MSIRP",
  "MSIRP",
  "ALIGNRP",
  "SetRoundState",
  "MIAP",
  "MIAP",
  "NPUSHB",
  "NPUSHW",
  "WS",
  "RS",
  "WCVT",
  "RCVT",
  "RC",
  "RC",
  "WC",
  "MD",
  "MD",
  "MPPEM",
  "MPS",
  "FLIPON",
  "FLIPOFF",
  "DEBUG",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "IF",
  "EIF",
  "BinaryOperand",
  "BinaryOperand",
  "UnaryOperand",
  "DELTAP1",
  "SDB",
  "SDS",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "ROUND",
  "ROUND",
  "ROUND",
  "ROUND",
  "NROUND",
  "NROUND",
  "NROUND",
  "NROUND",
  "WCVTFOD",
  "DELTAP2",
  "DELTAP3",
  "DELTAC1",
  "DELTAC2",
  "DELTAC3",
  "SROUND",
  "S45ROUND",
  "JROT",
  "JROF",
  "SetRoundState",
  "IllegalInstruction",
  "SetRoundState",
  "SetRoundState",
  "SANGW",
  "AA",
  "FLIPPT",
  "FLIPRGON",
  "FLIPRGOFF",
  "IDefPatch",
  "IDefPatch",
  "SCANCTRL",
  "SDPVTL",
  "SDPVTL",
  "GETINFO",
  "IDEF",
  "ROTATE",
  "BinaryOperand",
  "BinaryOperand",
  "SCANTYPE",
  "INSTCTRL",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP"
};

/*
  errOutput() - writes an error to standard out and to a log file.  the
  log file is always opened and closes in order to avoid file corruption
  by an application gone wild.
*/
static void errOutput( char * );
static void errOutput( char * msg )
{
  static  int firsttime = 1;
  FILE  * fp;

  printf("%s", msg);
  fp = fopen ("compfont.err", (firsttime ? "w" : "a"));
  if (fp)
  {
	fprintf (fp, "%s", msg);
	fclose (fp);
  }
  firsttime = 0;
  return;
}

/*
  errPrint() - used to generate a useful (?) error message based on the 
  error 'flag' and the parameters ('v1..v4').
*/
static void errPrint (int, long, long, long, long);
static void errPrint (int flag, long v1, long v2, long v3, long v4)
{
  char   msg[ERR_MAX_MSG];
  char * opcodeName;
  char   c;
  int    i;

/*
  build the context line.  it indicates the file being processed, the point
  size, the character code (or glyph index), as well as the releative inst 
  number of this instruction for this code.
*/
  i  = sprintf (msg,   "\n*** ERROR*** ");
  i += sprintf (msg+i, "\"%s\", ", errFname);
  i += sprintf (msg+i, "%hd Point, ", errSize);
  i += sprintf (msg+i, "Code %hd (0x%hX), ", errCode, errCode);
  i += sprintf (msg+i, "Inst: #%ld\n", errInstCount);

/*
  build the error line.  it indicates the name of the instruction followed
  by the actual error information.  note: finding the actual opcode name
  for some the instructions is sorta kludgy.  names like "SetLocalGraphicState",
  and "BinaryOperand" are not actual instructions.  In these cases, look to
  the second character of the name - if it is lower case, then we need to 
  work a little harder, so look to 'errOpName' (which should be set by this
  point) it should contain the correct instruction name.
*/
  c = *(errOpcs[errOpc]+1);
  opcodeName =(islower(c) && strlen(errOpName)) ? errOpName : errOpcs[errOpc];
  i += sprintf (msg+i, "(%s) ", opcodeName);
  errOpName[0] = '\0';

/*
  output what you have so far and then process the error
*/
  errOutput (msg);
  switch (flag)
  {
	case ERR_RANGE:
	  sprintf (msg, "Value out of range: value = %ld, range = %ld .. %ld\n",
				v1, v2, v3); 
	  break;
	case ERR_ASSERTION:
	  sprintf (msg, "Assertion check failed\n"); 
	  break;
	case ERR_CVT:
	  sprintf (msg, "CVT out of range: CVT = %ld, range = %ld .. %ld\n",
				v1, v2, v3); 
	  break;
	case ERR_FDEF:
	  sprintf (msg, "FDEF out of range: FDEF = %ld, range = %ld .. %ld\n",
				v1, v2, v3); 
	  break;
	case ERR_ELEMENT:
	  sprintf (msg, "Element %ld exceeds max elements (%ld)\n", v1, v2, v3); 
	  break;
	case ERR_CONTOUR:
	  i = sprintf (msg, "CONTOUR out of range: ");
	sprintf (msg+i, "CONTOUR = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_POINT:
	  i = sprintf (msg, "POINT out of range: ");
	sprintf (msg+i, "POINT = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_INDEX:
	  i = sprintf (msg, "POINT 0x%lX is neither element[0] ", v1);
	  sprintf( msg+i, "(0x%lX) nor element[1] (0x%lX)\n", v2, v3); 
	  break;
	case ERR_STORAGE:
	  i = sprintf (msg, "Storage index out of range: ");
	sprintf (msg+i, "Index = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_STACK:
	  i = sprintf (msg, "Stack pointer out of range: ");
	sprintf (msg+i, "Pointer = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_VECTOR:
	  sprintf (msg, "Illegal (x.y) vector: (%ld.%ld)\n", v1, v2); 
	  break;
	case ERR_LARGER:
	  sprintf (msg, "Value too small: %ld is not larger than %ld\n", v2, v1); 
	  break;
	case ERR_INT8:
	  sprintf (msg, "Value too large: 0x%lX exceeds 1 byte capacity\n", v1);
	  break;
	case ERR_INT16:
	  sprintf (msg, "Value too large: 0x%lX exceeds 2 byte capacity\n", v1);
	  break;
	case ERR_SCANMODE:
	  sprintf (msg, "Invalid scan mode: %ld\n", v1);
	  break;
	case ERR_SELECTOR:
	  sprintf (msg, "Invalid scan value: %ld\n", v1);
	  break;
	case ERR_STATE:
	  i = sprintf (msg, "Boundry limit error: xmin = ");
	  sprintf (msg+1, "%ld, xmax = %ld, ymin = %ld, ymax = %ld\n",
				v1, v2, v3, v4); 
	  break;
	case ERR_GETSINGLEWIDTHNIL:
	  sprintf (msg, "Sanity: Single width is nil\n");
	  break;
	case ERR_GETCVTENTRYNIL:
	  sprintf (msg, "Sanity: CVT Entry is nil\n");
	  break;
	case ERR_INVOPC:
	  sprintf (msg, "Invalid opcode: %ld\n", v1);
	  break;
	case ERR_UNBALANCEDIF:
	  sprintf (msg, "Unbalanced: missing %s instruction\n",
				( v1 > 0 ) ? "EIF" : "IF" );
	  break;
	default:
	  sprintf (msg, "Unknown Error:\n");
	  break;
  }

/*
  output the rest and return
*/
  errOutput (msg);
  return;
}

/*
  fnterr_Context() - called before any other fnterr routine.  it records
  the job name, character size and character code / glyph index.
*/
void fnterr_Context (int sw, char * str, unsigned short sz, unsigned short cd)
{
/*
  record a piece of the context
*/
  switch (sw)
  {
	case ERR_CONTEXT_FILE:
	  strncpy ( errFname, str, ERR_MAX_FNAME);
	  errFname[ERR_MAX_FNAME-1] = '\0';
	  break;
	case ERR_CONTEXT_SIZE:
	  errSize = sz;
	  break;
	case ERR_CONTEXT_CODE:
	  errCode = cd;
	  break;
  }

/*
  reset errOpName to be NULL before we start any real processing
*/
  errOpName[0] = '\0';
  return;
}

/*
  fnterr_Start() - called before the main execute loop of fnt_Execute() and
  fnt_TraceExecute().  it resets the instruction count to zero, and errBreak
  to 0 (ie: don't break out of execution loop).  set up IF/EIF counter for
  this level.
*/
void fnterr_Start (void)
{
  errInstCount = 0L;
  errBreak = 0;

  if (errIfOk && (++errIfNdx < ERR_MAX_IFS ))
	errIfs[errIfNdx] = 0;
  else
	errIfOk = 0;

  return;
}

/*
  fnterr_Record() - called inside the main execute loop of fnt_Execute()
  and fnt_TraceExecute().  it increments the instruction count, and resets
  the opcode number.  IFs or EIFs are accounted for. (note: other IFs and
  EIFs will be accounted for by calls to ERR_IF() in fnt.c)
*/
void fnterr_Record (int opc)
{
  errInstCount++;
  errOpc = opc;

  if (!strcmp ("IF", errOpcs[errOpc]))
	fnterr_If (1);
  else if (!strcmp ("EIF", errOpcs[errOpc]))
	fnterr_If (-1);

  return;
}

/*
  fnterr_Report() - called inside the main execute loop of fnt_Execute()
  and fnt_TraceExecute().  it calls errPrint() (with the passed parameters)
  to note the error, and sets errBreak so that the execution loop will end.
*/
void fnterr_Report (int flag, long v1, long v2, long v3, long v4)
{
  errPrint (flag, v1, v2, v3, v4);
  errBreak = 1;
  return;
}

/*
  fnterr_Break() - returns the value of errBreak.  if a non-zero valid is
  returned (re: fnterr_Report()), the main execute loop of fnt_Execute()
  or fnt_TraceExecute() will terminate.
*/
int fnterr_Break (void)
{
  return (errBreak);
}

/*
  fnterr_Opc() - called by combinate fnt calls to indicate the actual
  opcode errGet() can use.  this is a kludgy way to get around the non
  real opcode name in the errOpcs[] table.
*/
void fnterr_Opc (char *opc)
{
  strcpy (errOpName, opc);
  return;
}

/*
  fnterr_End() - called after the main execute loop of fnt_Execute() and
  fnt_TraceExecute().  it checks for balanced IF/EIF pairs.
*/
void fnterr_End (void)
{
  if (errIfOk)
  {
	if (errIfs[errIfNdx])
	  errPrint (ERR_UNBALANCEDIF, (long)errIfs[errIfNdx], 0L, 0L, 0L);
	if (--errIfNdx < 0)
	  errIfOk = 0;
  }
  return;
}

/*
  fnterr_If() - records IF/EIF activity inside of fnt_IF(), fnt_ELSE() and
  fnt_EIF() (re: fnt.c).
*/
void fnterr_If (int val)
{
  if (errIfOk)
	errIfs[errIfNdx] += val;
  return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\fontmath.h ===
/*
		File:           fontmath.h

		Contains:       xxx put contents here xxx

		Written by:     xxx put writers here xxx

		Copyright:      c 1990 by Apple Computer, Inc., all rights reserved.
						(c) 1989-1997. Microsoft Corporation, all rights reserved.

		Change History (most recent first):

				  <>     2/21/97		CB				ClaudeBe, add mth_UnitarySquare for scaled component in composite glyphs
				 <4>    11/27/90        MR              make pascal declaration a macro, conditionalize traps -vs-
																		externs for Fix/Frac math routines. [ph]
				 <3>     11/5/90        MR              Move [U]SHORTMUL into fscdefs.h Rename FixMulDiv to LongMulDiv.
																		[rb]
				 <2>    10/20/90        MR              Add some new math routines (stolen from skia). [rj]
				 <1>     4/11/90        dba             first checked in

		To Do:
*/

#define HIWORDMASK              0xffff0000
#define LOWORDMASK              0x0000ffff
#define DOT6ONEHALF             0x00000020
#define ONESHORTFRAC            (1 << 14)

#define ROUNDFIXTOINT( x )      (int16)((((Fixed) x) + ONEHALFFIX) >> 16)
#define ROUNDFIXED( x )         (((x) + (Fixed)ONEHALFFIX) & (Fixed)HIWORDMASK)
#define DOT6TOFIX(n)            ((Fixed) (n) << 10)
#define FIXEDTODOT6(n)          (F26Dot6) (((n) + ((1) << (9))) >> 10)
#define INTTOFIX(n)             ((Fixed) (n) << 16)
#define INTTODOT6(n)            ((F26Dot6) (n) << 6)
#define FS_HIWORD(n)            ((uint16)((uint32)(n) >> 16))
#define FS_LOWORD(n)            ((uint16)(n))
#define LOWSIXBITS              0x3F


#ifndef __TOOLUTILS__
FS_MAC_PASCAL Fixed FS_PC_PASCAL FS_ENTRY_PROTO FixMul(Fixed,Fixed)   FS_MAC_TRAP(0xA868);
FS_MAC_PASCAL Fixed FS_PC_PASCAL FixRatio (int16 sA, int16 sB);
#endif

#ifndef __FIXMATH__
FS_MAC_PASCAL Fixed FS_PC_PASCAL FS_ENTRY_PROTO FixDiv(Fixed,Fixed)  FS_MAC_TRAP(0xA84D);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracMul(Fract,Fract) FS_MAC_TRAP(0xA84A);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracDiv(Fract,Fract) FS_MAC_TRAP(0xA84B);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracSqrt(Fract)      FS_MAC_TRAP(0xA849);
#endif



ShortFract      FS_ENTRY_PROTO  ShortFracDot (ShortFract x, ShortFract y);
F26Dot6         TMP_CONV NEAR ShortFracMul (F26Dot6 x, ShortFract y);
ShortFract      TMP_CONV NEAR ShortFracDiv (ShortFract x, ShortFract y);
F26Dot6         TMP_CONV NEAR Mul26Dot6 (F26Dot6 a, F26Dot6 b);
F26Dot6         TMP_CONV NEAR Div26Dot6 (F26Dot6 num, F26Dot6 den);
int16           TMP_CONV NEAR MulDivShorts (int16 x, int16 y, int16 z);


#define MulDiv26Dot6(a,b,c) LongMulDiv(a,b,c)

int32 FS_ENTRY_PROTO LongMulDiv(int32 a, int32 b, int32 c);     /* (a*b)/c */

int32 ShortMulDiv(int32 a, int16 b, int16 c);     /* (a*b)/c */

ShortFract ShortFracMulDiv(ShortFract,ShortFract,ShortFract);

void mth_FixXYMul (Fixed* x, Fixed* y, transMatrix* matrix);
void mth_FixVectorMul (vectorType* v, transMatrix* matrix);

/*
 *   B = A * B;     <4>
 *
 *         | a  b  0  |
 *    B =  | c  d  0  | * B;
 *         | 0  0  1  |
 */
void mth_MxConcat2x2 (transMatrix* matrixA, transMatrix* matrixB);

/*
 * scales a matrix by sx and sy.
 *
 *              | sx 0  0  |
 *    matrix =  | 0  sy 0  | * matrix;
 *              | 0  0  1  |
 */
void mth_MxScaleAB (Fixed sx, Fixed sy, transMatrix *matrixB);

boolean mth_IsMatrixStretched (transMatrix*trans);

boolean mth_Identity (transMatrix *matrix);
boolean mth_PositiveSquare (transMatrix *matrix);
boolean mth_PositiveRectangle (transMatrix *matrix);

/*
 * unitary Square
 *
 *              | +-1    0  0  |
 *    matrix =  |   0  +-1  0  |
 *              |   0    0  1  |
 */

boolean mth_UnitarySquare (transMatrix *matrix);

boolean mth_SameStretch (Fixed fxScaleX, Fixed fxScaleY);

boolean mth_GeneralRotation (transMatrix *matrix);
uint16 mth_90degRotationFactor (transMatrix *matrix);
uint16 mth_90degRotationFactorForEmboldening (transMatrix *matrix);
uint16 mth_90degClosestRotationFactor (transMatrix *matrix);
void mth_Non90DegreeTransformation(transMatrix *matrix, boolean *non90degreeRotation, boolean *nonUniformStretching);

int32 mth_CountLowZeros (uint32 n );
Fixed mth_max_abs (Fixed a, Fixed b);

int32 mth_GetShift (uint32 n);

void mth_ReduceMatrix(transMatrix *trans);

void mth_IntelMul (
	int32           lNumPts,
	F26Dot6 *       fxX,
	F26Dot6 *       fxY,
	transMatrix *   trans,
	Fixed           fxXStretch,
	Fixed           fxYStretch);

void    mth_FoldPointSizeResolution(
	Fixed           fxPointSize,
	int16           sXResolution,
	int16           sYResolution,
	transMatrix *   trans);

/*********************************************************************/

/*  Scan Converter Math Functions Appended for now         <5> DeanB */

/*********************************************************************/

int32 PowerOf2(
		int32                   /* + or - 32 bit value */
);

FS_PUBLIC int16 mth_DivShiftShort(int16 sValue, int16 sFactor);
FS_PUBLIC int32 mth_DivShiftLong(int32 sValue, int16 sFactor);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\fontmath.c ===
/*
	File:       FontMath.c

	Contains:   xxx put contents here xxx

	Written by: xxx put writers here xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1997. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

		  <>     2/21/97	CB		ClaudeBe, add mth_UnitarySquare for scaled component in composite glyphs
		 <3>     11/9/90    MR      Fix CompDiv when numer and denom have zero hi longs. [rb]
		 <2>     11/5/90    MR      Remove Types.h from include list, rename FixMulDiv to LongMulDiv
									[rb]
		 <1>    10/20/90    MR      Math routines for font scaler. [rj]

	To Do:
*/

#define FSCFG_INTERNAL

#include "fscdefs.h"
#include "fserror.h"
#include "fontmath.h"


#define HIBITSET                      0x80000000UL
#define POSINFINITY               0x7FFFFFFFUL
#define NEGINFINITY               0x80000000UL
#define POINTSPERINCH               72
#define ALMOSTZERO 33
#define ISNOTPOWEROF2(n)        ((n) & ((n)-1))
#define CLOSETOONE(x)   ((x) >= ONEFIX-ALMOSTZERO && (x) <= ONEFIX+ALMOSTZERO)
#define MAKEABS(x)  if (x < 0) x = -x
#define FXABS(x)  ((x) >= 0L ? (x) : -(x))
#define FRACT2FIX(n)    (((n) + (1 << (sizeof (Fract) - 3))) >> 14)

#define FASTMUL26LIMIT      46340
#define FASTDIV26LIMIT  (1L << 25)

#define USHORTMUL(a, b) ((uint32)((uint32)(uint16)(a)*(uint32)(uint16)(b)))

boolean mth_Max45Trick (Fixed x, Fixed y);

/*******************************************************************/

/* local prototypes */


/*******************************************************************/


#define CompMul(src1, src2, Result)  {                           \
    *((__int64*) (Result)) = (__int64) (src1) *  (__int64) (src2);            \
    }

/*******************************************************************/


int32
CompDiv (
    int32          Denominator,
    LARGE_INTEGER  Dividend
    )
{

    uint32 Divisor;
    int32  Negate;
    uint32 Quotient;
    uint32 Remainder;
    int32  Result;

    //
    // Compute the sign of the result value. If the denominator is zero,
    // then return plus of minus infinity depending of the sign of the
    // result. Otherwise, negate the dividend and divisor as appropriate.
    //

    Negate = Denominator ^ Dividend.HighPart;
    if (Denominator == 0) {
        if (Negate < 0) {
            return NEGINFINITY;

        } else {
            return POSINFINITY;
        }
    }

    if (Denominator < 0) {
        Denominator = - Denominator;
    }

    if (Dividend.HighPart < 0) {
        Dividend.LowPart = - (LONG)Dividend.LowPart;
        if (Dividend.LowPart != 0) {
            Dividend.HighPart = ~Dividend.HighPart;

        } else {
            Dividend.HighPart = - Dividend.HighPart;
        }
    }

    //
    // If there are any high order product bits, then the quotient will
    // overflow.
    //

    Divisor = (uint32)Denominator;
    Remainder = (uint32)Dividend.HighPart;
    if (Divisor <= Remainder) {
        if (Negate < 0) {
            return NEGINFINITY;

        } else {
            return POSINFINITY;
        }
    }

    //
    // Divide the 64-bit product by the 32-bit divisor forming a 32-bit
    // quotient and a 32-bit remainder.
    //

#ifdef i386

    Quotient = (uint32)Dividend.LowPart;
        _asm {
                  mov edx,Remainder
                  mov eax,Quotient
                  div Divisor
                  mov Remainder,edx
                  mov Quotient,eax
             }
#else



    Quotient = RtlEnlargedUnsignedDivide(*(PULARGE_INTEGER)&Dividend,
                                         Divisor,
                                         &Remainder);

#endif


    //
    // Round the result if the remainder is greater than or equal to one
    // half the divisor. If the rounded quotient is zero, then overflow
    // has occured.
    //

    if (Remainder >= (Divisor >> 1)) {
        Quotient += 1;
        if (Quotient == 0) {
            if (Negate < 0) {
                return NEGINFINITY;

            } else {
                return POSINFINITY;
            }
        }
    }

    //
    // Compute the final signed result.
    //

    Result = (int32)Quotient;
    if (Negate >= 0) {
        if (Result >= 0) {
            return Result;

        } else {
            return POSINFINITY;
        }

    } else {
        if ((Result >= 0) || ((Result < 0) && (Quotient == 0x80000000))) {
            return - Result;

        } else {
            return NEGINFINITY;
        }
    }
}


/*******************************************************************/

/*
 *  a*b/c
 */
int32 FS_ENTRY_PROTO LongMulDiv(int32 a, int32 b, int32 c)
{
        LARGE_INTEGER temp;

        CompMul(a, b, &temp);
        return CompDiv(c, temp);
}

/*******************************************************************/

F26Dot6 ShortFracMul (F26Dot6 aDot6, ShortFract b)
{
        LARGE_INTEGER Temp;
	uint32      ulLow;
	F26Dot6     fxProduct;

        CompMul(aDot6, b, &Temp);

        ulLow = (((uint32)Temp.LowPart) >> 13) + 1;           /* rounds up */
        fxProduct = (F26Dot6)(Temp.HighPart << 18) + (F26Dot6)(ulLow >> 1);

	return (fxProduct);
}

/*******************************************************************/

ShortFract FS_ENTRY_PROTO ShortFracDot (ShortFract a, ShortFract b)
{
	return (ShortFract)((((int32)a * (int32)b) + (1L << 13)) >> 14);
}


int32 ShortMulDiv(int32 a, int16 b, int16 c)
{
	return LongMulDiv(a, (int32)b, (int32)c);
}

int16 MulDivShorts (int16 a, int16 b, int16 c)
{
	return (int16)LongMulDiv((int32)a, (int32)b, (int32)c);
}

/*
 *  Total precision routine to multiply two 26.6 numbers        <3>
 */
F26Dot6 Mul26Dot6(F26Dot6 a, F26Dot6 b)
{
	 int32 negative = false;
	uint16 al, bl, ah, bh;
	uint32 lowlong, midlong, hilong;

	if ((a <= FASTMUL26LIMIT) && (b <= FASTMUL26LIMIT) && (a >= -FASTMUL26LIMIT) && (b >= -FASTMUL26LIMIT))
		  return (F26Dot6)(((int32)a * b + (1 << 5)) >> 6);                            /* fast case */

	if (a < 0) { a = -a; negative = true; }
	if (b < 0) { b = -b; negative ^= true; }

	 al = FS_LOWORD(a); ah = FS_HIWORD(a);
	 bl = FS_LOWORD(b); bh = FS_HIWORD(b);

	midlong = USHORTMUL(al, bh) + USHORTMUL(ah, bl);
	 hilong = USHORTMUL(ah, bh) + (uint32)FS_HIWORD(midlong);
	midlong <<= 16;
	midlong += 1 << 5;
	lowlong = USHORTMUL(al, bl) + midlong;
	hilong += (uint32)(lowlong < midlong);

	midlong = (lowlong >> 6) | (hilong << 26);
	if( negative)
	{
		return  (F26Dot6)-((int32)midlong);
	}
	else
	{
		return (F26Dot6)midlong;
	}
}

/*
 *  Total precision routine to divide two 26.6 numbers          <3>
 */
F26Dot6 Div26Dot6(F26Dot6 num, F26Dot6 den)
{
	 int32 negative = false;
	uint32 hinum, lownum, hiden, lowden, result, place;

	if (den == 0L)
	{
		if (num < 0L )
		{
				return (F26Dot6)NEGINFINITY;
		}
		else
		{
			return (F26Dot6)POSINFINITY;
		}
	}

	if ( (num <= FASTDIV26LIMIT) && (num >= -FASTDIV26LIMIT) )          /* fast case */
		  return (F26Dot6)(((int32)num << 6) / den);

	if (num < 0)
	{
		num = -num;
		negative = true;
	}
	if (den < 0)
	{
		den = -den;
		negative ^= true;
	}

	hinum = ((uint32)num >> 26);
	lownum = ((uint32)num << 6);
	hiden = (uint32)den;
	lowden = 0;
	result = 0;
	place = HIBITSET;

	if (hinum >= hiden)
	{
		if( negative )
		{
				return (F26Dot6)(uint32)NEGINFINITY;
		}
		else
		{
			return (F26Dot6)POSINFINITY;
		}
	}

	while (place)
	{
		lowden >>= 1;
		if (hiden & 1)
		{
			lowden += HIBITSET;
		}
		hiden >>= 1;
		if (hiden < hinum)
		{
			hinum -= hiden;
			hinum -= (uint32)(lowden > lownum);
			lownum -= lowden;
			result += place;
		}
		else if (hiden == hinum && lowden <= lownum)
		{
			hinum = 0;
			lownum -= lowden;
			result += place;
		}
		place >>= 1;
	}

	if (negative)
	{
		return (F26Dot6)-((int32)result);
	}
	else
	{
		return (F26Dot6)result;
	}
}

ShortFract ShortFracDiv(ShortFract num,ShortFract denum)
{
	return (ShortFract)(((int32)(num) << 14) / (int32)denum);
}

ShortFract ShortFracMulDiv(ShortFract numA,ShortFract numB,ShortFract denum)
{
	return (ShortFract) LongMulDiv ((int32) numA,(int32) numB, (int32)denum);
}

/* ------------------------------------------------------------ */

#ifndef FSCFG_USE_EXTERNAL_FIXMATH
/*  Here we define Fixed [16.16] and Fract [2.30] precision 
 *  multiplication and division functions and a Fract square root 
 *  function which are compatible with those in the Macintosh toolbox.
 *
 *  The division functions load the 32-bit numerator into the "middle"
 *  bits of a 64-bit numerator, then call the 64-bit by 32-bit CompDiv()
 *  function defined above, which can return a NEGINFINITY or POSINFINITY
 *  overflow return code.
 *
 *  The multiply functions call the 32-bit by 32-bit CompMul() function
 *  defined above which produces a 64-bit result, then they extract the
 *  "interesting" 32-bits from the middle of the 64-bit result and test 
 *  for overflow.
 *
 *  The GET32(a,i) macro defined below extracts a 32-bit value with "i" 
 *  bits of fractional precision from the 64-bit value in "a", a 2-element
 *  array of longs.
 *
 *  The CHKOVF(a,i,v) macro tests the most significant bits of the 
 *  64-bit value in "a", a 2-element array of longs, and tests the 
 *  32-bit result "v" for overflow.  "v" is defined as having "i" bits
 *  of fractional precision.
 *
 *  BIT() and OVFMASK() are "helper" macros used by GET32() and CHKOVF().
 *
 *  BIT(i) returns a mask with the "i"-th bit set.
 *  OVFMASK(i) returns a mask with the most-significant "32-i" bits set.
 */

#define BIT(i)          (1L<<(i))
#define OVFMASK(i)   ( ~0L ^ ( ((uint32)BIT(i)) - 1 ) )
#define CHKOVF(a,i,v)   (\
                ( ((uint32)(a).HighPart & OVFMASK(i))==0)          ? ( (v)>=0 ?(v) :POSINFINITY) : \
                ( ((uint32)(a).HighPart & OVFMASK(i))==OVFMASK(i)) ? ( (v)<=0 ?(v) :NEGINFINITY) : \
                ( ((uint32)(a).HighPart & BIT(31))                 ? POSINFINITY   :NEGINFINITY)   \
	)

#define GET32(b,a,i) \
((((a).HighPart<<(32-(i))) | (int32)((uint32)((a).LowPart)>>(i))) + \
(int32)!!( ((a).LowPart & BIT((i)-1))  && ( b ? ( ( ((a).LowPart & ~OVFMASK(i-1) )) & ~OVFMASK(i-1) ) : TRUE ) ) )

FS_MAC_PASCAL Fixed FS_PC_PASCAL FS_ENTRY_PROTO FixMul (Fixed fxA, Fixed fxB)
{
        LARGE_INTEGER alCompProd;
	Fixed fxProd;
	int  bNegative=FALSE;

	if  (fxA == 0 || fxB == 0)
		return 0;

	if( ((fxA > 0) && (fxB < 0)) || ((fxA < 0) && (fxB > 0)) )
		bNegative = TRUE;

        CompMul ((int32)fxA, (int32)fxB, &alCompProd);

	fxProd = (Fixed)GET32 (bNegative,alCompProd,16);

	return (Fixed)CHKOVF(alCompProd,16,fxProd);
}

FS_MAC_PASCAL Fixed FS_PC_PASCAL FS_ENTRY_PROTO FixDiv (Fixed fxA, Fixed fxB)
{
        LARGE_INTEGER alCompProd;
	
        alCompProd.HighPart = fxA >> 16;
        alCompProd.LowPart = fxA << 16;

        return CompDiv ((int32)fxB, alCompProd);
}

FS_MAC_PASCAL Fixed FS_PC_PASCAL FixRatio (int16 sA, int16 sB)
{
        LARGE_INTEGER alCompProd;
	
        alCompProd.HighPart = ((int32)(sA)) >> 16;
        alCompProd.LowPart = ((int32)(sA)) << 16;

        return CompDiv ((int32)(sB), alCompProd);
}

FS_MAC_PASCAL Fract FS_PC_PASCAL FracMul (Fract frA, Fract frB)
{
        LARGE_INTEGER alCompProd;
	Fract frProd;
	int  bNegative=FALSE;

	if  (frA == 0 || frB == 0)
		return 0;

	if( ((frA > 0) && (frB < 0)) || ((frA < 0) && (frB > 0)) )
		bNegative = TRUE;

        CompMul (frA,frB,&alCompProd);
	frProd = (Fract)GET32 (bNegative,alCompProd,30);

	return (Fract)CHKOVF(alCompProd,30,frProd);
}

FS_MAC_PASCAL Fract FS_PC_PASCAL FracDiv (Fract frA, Fract frB)
{
        LARGE_INTEGER alCompProd;

        alCompProd.HighPart = frA >> 2;
        alCompProd.LowPart  = frA << 30;
        return CompDiv ((int32)frB, alCompProd);
}

/*******************************************************************/

#if !defined(i386) && (!defined(MIPS) || !defined(R4000))
/* 
   Fract FracSqrt (Fract xf)
   Input:  xf           2.30 fixed point value
   Return: sqrt(xf)     2.30 fixed point value
*/

FS_MAC_PASCAL Fract FS_PC_PASCAL FracSqrt (Fract xf)
{
	Fract b = 0L;
	uint32 c, d, x = xf;
	
	if (xf < 0) return (NEGINFINITY);

	/*
	The algorithm extracts one bit at a time, starting from the
	left, and accumulates the square root in b.  The algorithm 
	takes advantage of the fact that non-negative input values
	range from zero to just under two, and corresponding output
	ranges from zero to just under sqrt(2).  Input is assigned
	to temporary value x (unsigned) so we can use the sign bit
	for more precision.
	*/
	
	if (x >= 0x40000000)
	{
		x -= 0x40000000; 
		b  = 0x40000000; 
	}

	/*
	This is the main loop.  If we had more precision, we could 
	do everything here, but the lines above perform the first
	iteration (to align the 2.30 radix properly in b, and to 
	preserve full precision in x without overflow), and afterward 
	we do two more iterations.
	*/
	
	for (c = 0x10000000; c; c >>= 1)
	{
		d = b + c;
		if (x >= d)
		{
			x -= d; 
			b += (c<<1); 
		}
		x <<= 1;
	}

	/*
	Iteration to get last significant bit.
	
	This code has been reduced beyond recognition, but basically,
	at this point c == 1L>>1 (phantom bit on right).  We would
	like to shift x and d left 1 bit when we enter this iteration,
	instead of at the end.  That way we could get phantom bit in
	d back into the word.  Unfortunately, that may cause overflow
	in x.  The solution is to break d into b+c, subtract b from x,
	then shift x left, then subtract c<<1 (1L).
	*/
	
	if (x > (uint32)b) /* if (x == b) then (x < d).  We want to test (x >= d). */
	{
		x -= b;
		x <<= 1;
		x -= 1L;
		b += 1L; /* b += (c<<1) */
	}
	else
	{
		x <<= 1;
	}

	/* 
	Final iteration is simple, since we don't have to maintain x.
	We just need to calculate the bit to the right of the least
	significant bit in b, and use the result to round our final answer.
	*/
	
	return ( b + (Fract)(x>(uint32)b) );
}

#endif  /* FracSqrt */

/*******************************************************************/

#endif


/* TRANSFORMATION ROUTINES */

/*
 *  Good for transforming fixed point values.  Assumes NO translate  <4>
 */
void mth_FixXYMul (Fixed*x, Fixed*y, transMatrix*matrix)
{
  Fixed xTemp, yTemp;
  Fixed *m0, *m1;

  m0 = (Fixed *) & matrix->transform[0][0];
  m1 = (Fixed *) & matrix->transform[1][0];

  xTemp = *x;
  yTemp = *y;
  *x = FixMul (*m0++, xTemp) + FixMul (*m1++, yTemp);
  *y = FixMul (*m0++, xTemp) + FixMul (*m1++, yTemp);

#ifndef PC_OS   /* Never a perspecitive with Windows */ /* !!!DISCUSS   */

  if (*m0 || *m1)     /* these two are Fracts */
  {
	Fixed tmp = FracMul (*m0, xTemp) + FracMul (*m1, yTemp);
	tmp += matrix->transform[2][2];
	if (tmp && tmp != ONEFIX)
	{
	  *x = FixDiv (*x, tmp);
	  *y = FixDiv (*y, tmp);
	}
  }
#endif
}


/*
 *  This could be faster        <4>
 */
void mth_FixVectorMul (vectorType*v, transMatrix*matrix)
{
  mth_FixXYMul (&v->x, &v->y, matrix);
}


/*
 *   B = A * B;     <4>
 *
 *         | a  b  0  |
 *    B =  | c  d  0  | * B;
 *         | 0  0  1  |
 */
void mth_MxConcat2x2 (transMatrix*A, transMatrix*B)
{
  Fixed storage[6];
  Fixed * s = storage;
  int32 i, j;

  for (j = 0; j < 2; j++)
	for (i = 0; i < 3; i++)
	  *s++ = FixMul (A->transform[j][0], B->transform[0][i]) + FixMul (A->transform[j][1], B->transform[1][i]);

  {
	Fixed*dst = &B->transform[2][0];
	Fixed*src = s;
	int16 k;
	for (k = 5; k >= 0; --k)
	  *--dst = *--src;
  }
}


/*
 * scales a matrix by sx and sy.
 *
 *
 *              | sx 0  0  |
 *    matrix =  | 0  sy 0  | * matrix;
 *              | 0  0  1  |
 *
 */
void mth_MxScaleAB (Fixed sx, Fixed sy, transMatrix *matrixB)
{
  int32       i;
  Fixed  *m = (Fixed *) & matrixB->transform[0][0];

  for (i = 0; i < 3; i++, m++)
	*m = FixMul (sx, *m);

  for (i = 0; i < 3; i++, m++)
	*m = FixMul (sy, *m);
}


/*
 *  Return 45 degreeness
 */
#ifndef PC_OS   /* !!!DISCUSS   */
boolean mth_Max45Trick (Fixed x, Fixed y)
{
  MAKEABS (x);
  MAKEABS (y);

  if (x < y)      /* make sure x > y */
  {
	Fixed z = x;
	x = y;
	y = z;
  }

  return  (x - y <= ALMOSTZERO);
}
#else
  #define mth_Max45Trick(x,y)     (x == y || x == -y)
#endif


/*
 *  Sets bPhaseShift to true if X or Y are at 45 degrees, flaging the outline
 *  to be moved in the low bit just before scan-conversion.
 *  Sets [xy]Stretch factors to be applied before hinting.
 *  Returns true if the contours need to be reversed.
 */
boolean mth_IsMatrixStretched (transMatrix*trans)
{
  Fixed*matrix = &trans->transform[0][0];
  Fixed x, y;
  int32 i;
  boolean   bPhaseShift;

  bPhaseShift = FALSE;

  for (i = 0; i < 2; i++, matrix++)
  {
	x = *matrix++;
	y = *matrix++;
	bPhaseShift |= mth_Max45Trick (x, y);
  }
  return( bPhaseShift );
}


/*
 * Returns true if we have the identity matrix.
 */

boolean mth_PositiveSquare (transMatrix *matrix)
{
	return (matrix->transform[0][0] == matrix->transform[1][1] && matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] >= 0);
}

boolean mth_Identity (transMatrix *matrix)
{
	return (matrix->transform[0][0] == matrix->transform[1][1] && matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[0][0] == ONEFIX);
}


boolean mth_PositiveRectangle (transMatrix *matrix)
{
	 return (matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[0][0] >= 0 && matrix->transform[1][1] >= 0);
}

/*
 * unitary Square
 *
 *              | +-1    0  0  |
 *    matrix =  |   0  +-1  0  |
 *              |   0    0  1  |
 */

boolean mth_UnitarySquare (transMatrix *matrix)
{
	return (matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && FXABS(matrix->transform[0][0]) == FXABS(matrix->transform[1][1]) && FXABS(matrix->transform[0][0]) == ONEFIX);
}

boolean mth_SameStretch (Fixed fxScaleX, Fixed fxScaleY)
{
	return(fxScaleX == fxScaleY);
}

boolean mth_GeneralRotation (transMatrix *matrix)
{
  return ((matrix->transform[0][0] || matrix->transform[1][1]) && (matrix->transform[1][0] || matrix->transform[0][1]));
}

/* for a rotation that is a multiple of 90 degrees, return the multiplier factor */
/* for non 90 degree rotations, return 4  (this is used for sbit rotations) */

uint16 mth_90degRotationFactor (transMatrix *matrix)
{
	if (matrix->transform[1][0] == 0 && matrix->transform[0][1] == 0)
    {
    	if (matrix->transform[0][0] > 0 && matrix->transform[1][1] > 0)
            return (0);
    	else if (matrix->transform[0][0] < 0 && matrix->transform[1][1] < 0)
            return (2);
    }
	else if (matrix->transform[0][0] == 0 && matrix->transform[1][1] == 0)
    {
        if (matrix->transform[1][0] < 0 && matrix->transform[0][1] > 0)
            return (1);
       	else if (matrix->transform[1][0] > 0 && matrix->transform[0][1] < 0)
            return (3);
	}
    return (4);                 /* non 90 degree rotation */
}

uint16 mth_90degRotationFactorForEmboldening (transMatrix *matrix)
{
	if (matrix->transform[1][0] == 0 && matrix->transform[0][1] == 0)
    {
		if (matrix->transform[0][0] > 0){
			if(matrix->transform[1][1] > 0)
				return (0);	// 0 degree with sx>0 & sy>0 or 180 degree with sx<0 & sy<0
			else
				return (4); // 0 degree with sx>0 & sy<0 or 180 degree with sx<0 & sy>0
		}
		else if (matrix->transform[0][0] < 0){
			if(matrix->transform[1][1] < 0)
				return (2); // 180 degree with sx>0 & sy>0 or 0 degree with sx<0 & sy<0
			else
				return (6); // 180 degree with sx>0 & sy<0 or 0 degree with sx<0 & sy>0
		}
    }
	else if (matrix->transform[0][0] == 0 && matrix->transform[1][1] == 0)
    {
        if (matrix->transform[1][0] < 0){
			if(matrix->transform[0][1] > 0)
				return (1); // 90 degree with sx>0 & sy>0 or 270 degree with sx<0 & sy<0
			else
				return (7); // 270 degree with sx>0 & sy<0 or 90 degree with sx<0 & sy>0
		}
       	else if (matrix->transform[1][0] > 0){
			if(matrix->transform[0][1] < 0)
				return (3); // 270 degree with sx>0 & sy>0 or 90 degree with sx<0 & sy<0
			else
				return (5); // 90 degree with sx>0 & sy<0 or 270 degree with sx<0 & sy>0
		}
	}
    return (8);                 /* non 90 degree rotation */
}

/* This is for Italic simulation.

/* return values with non-vertical
			Sx>0 & Sy>0		Sx>0 & Sy<0		Sx<0 & Sy>0		Sx<0 & Sy<0
0   degree	0				4				6				2
90  degree	1				5				7				3
180 degree	2				6				4				0
270 degree	3				7				5				1

/* return values with vertical
			Sx>0 & Sy>0		Sx>0 & Sy<0		Sx<0 & Sy>0		Sx<0 & Sy<0
0   degree	1				7				5				3
90  degree	2				4				6				0
180 degree	3				5				7				1
270 degree	0				6				4				2
*/

uint16 mth_90degClosestRotationFactor (transMatrix *matrix)
{
	if (matrix->transform[0][0] > 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] > 0 ||
        matrix->transform[0][0] > 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] > 0 ) 
        return (0); 
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] > 0 ||
             matrix->transform[0][0] > 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] == 0 ) 
        return (1); 
	else if (matrix->transform[0][0] < 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] < 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] < 0 ) 
        return (2); 
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] < 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] ==  0 ) 
        return (3); 
	else if (matrix->transform[0][0] > 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] < 0 ||
			 matrix->transform[0][0] > 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] < 0 ) 
        return (4); 
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] > 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] == 0 ) 
        return (5); 
	else if (matrix->transform[0][0] < 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] > 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] > 0 ) 
        return (6); 
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] < 0 ||
             matrix->transform[0][0] > 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] ==  0 ) 
        return (7); 
    // anything else
    else
        return (8); 
}

void mth_Non90DegreeTransformation(transMatrix *matrix, boolean *non90degreeRotation, boolean *nonUniformStretching) {
	Fixed Xx,Xy,Yx,Yy;

	// first, we apply the matrix to the base vectors X = (1, 0) and Y = (0, 1)
	// this seemingly trivial step tends to be a hidden trap because there are two ways to apply a matrix to a vector, prefix and postfix.
	// in the rasterizer we seem to apply matrices as postfix operators, i.e.
	//
	//          (a00 a01)
	// (x, y) * (       ) = (a00*x + a10*y, a01*x + a11*y)
	//          (a10 a11)
	//
	//   apply to X = (1, 0)           apply to Y = (0, 1)
	Xx = matrix->transform[0][0]; Yx = matrix->transform[1][0];
	Xy = matrix->transform[0][1]; Yy = matrix->transform[1][1];

	// then we test whether the transformation shears the coordinates
	// if so, the transformed base vectors are no longer perpendicular, so we test their dot product against 0
	// notice that due to the limited precision of the fixed point representation , we may introduce a numerical error in general. 	
	// however, we're interested in identifying special cases like multiples of 90 rotations, for which one of the components
	// of the transformed vectors will be 0, hence the dot product should be accurate in these cases.
	if (FixMul(Xx,Yx) + FixMul(Xy,Yy) == 0) { // we're perpendicular

		// next we analyze whether the transformation rotates by a multiple of 90 or not
		// rotations which are multiples of 90 have 0s in either both non-diagonal matrix elements or both diagonal matrix elements
		// notice that this analysis includes mirrorings in x or y, which are handled in much the same way
		*non90degreeRotation = !(Xx == 0 && Yy == 0 || Xy == 0 && Yx == 0);

		// finally we analyze whether the transformation stretches the coordinates uniformly or not
		// for uniform stretchings the transformed base vectors have the same lengths
		// notice again that due to limited precision we may introduce a numerical error which we can ignore for the same reasons
		*nonUniformStretching = FixMul(Xx,Xx) + FixMul(Xy,Xy) != FixMul(Yx,Yx) + FixMul(Yy,Yy);
	
	} else { // we're sheared
		
		// here, we analyze whether the transformation rotates the x-axis by a multiple of 90 or not
		// we do not consider the y-axis because we don't want to exclude italicized fonts
		// for a multiple of 90 rotation, the transformed base vector X is either [anti-]parallel or perpendicular to its original
		// to be perpendicular, its x-component must be 0, hence a00 = 0; to be [anti-]parallel, its y-component must be 0, hence a01 = 0
		*non90degreeRotation = !(Xx == 0 || Xy == 0);

		// finally, we need to know whether the transformation stretches the coordinates at all
		// we know already that the stretching is not uniform, except in the unlikely case that the transformation rotates the y-axis
		// relative to the x-axis, which is a combination of stretching in y (actually, squeezing) by a particular amount, followed by
		// shearing, which stretches the y-axis again. For the correct combination of squeezing and shearing, this yields a uniform
		// stretching. For italicizing characters, this is an unlikely scenario, as italics tend to have the same [x-]height as their
		// roman ancestors. Italicizing is achieved by a shearing without separate stretching, which is a much more likely scenario.
		// For the reasons of their likelyhood, we consider shearing a uniform stretching, but not the rotation of the y-axis. Further-
		// more, for the purpose of identifying special cases, we do so only for rotations by multiples of 90, and only if the area
		// of the parallelogram defined by the two transformed base vectors remains 1, which is what happens under shearing. The area
		// of the parallelogram equals the determinant of the matrix. All other cases are considered proper non-uniform stretchings.
		
		*nonUniformStretching = *non90degreeRotation || FixMul(Xx,Xx) + FixMul(Xy,Xy) != ONEFIX || FixMul(Xx,Yy) - FixMul(Xy,Yx) != ONEFIX;
	}

} // mth_Non90DegreeTransformation

/*
 * mth_GetShift
 * return 2log of n if n is a power of 2 otherwise -1;
 */
int32 mth_GetShift( uint32 n )
{
		if (ISNOTPOWEROF2(n) || !n)
				return -1;
		else
				return mth_CountLowZeros( n );
}

int32 mth_CountLowZeros( uint32 n )
{
		  int32 shift = 0;
		  uint32    one = 1;
		for (shift = 0; !( n & one ); shift++)
				n >>= 1;
		return shift;
}

Fixed mth_max_abs (Fixed a, Fixed b)
{
  if (a < 0)
	a = -a;
  if (b < 0)
	b = -b;
  return (a > b ? a : b);
}

/*
 *  Call this guy before you use the matrix.  He does two things:
 *      He folds any perspective-translation back into perspective,
 *       and then changes the [2][2] element from a Fract to a fixed.
 */
void mth_ReduceMatrix(transMatrix *trans)
{
	Fixed a, *matrix = &trans->transform[0][0];
	Fract bottom = matrix[8];

/*
 *  First, fold translation into perspective, if any.
 */
	a = matrix[2];

	if (a != 0)
	{
		matrix[0] -= LongMulDiv(a, matrix[6], bottom);
		matrix[1] -= LongMulDiv(a, matrix[7], bottom);
	}

	a = matrix[5];

	if (a != 0)
	{
		matrix[3] -= LongMulDiv(a, matrix[6], bottom);
		matrix[4] -= LongMulDiv(a, matrix[7], bottom);
	}
	matrix[6] = matrix[7] = 0;
	matrix[8] = FRACT2FIX(bottom);      /* make this guy a fixed for XYMul routines */
}

void mth_IntelMul (
	int32           lNumPts,
	F26Dot6 *       fxX,
	F26Dot6 *       fxY,
	transMatrix *   trans,
	Fixed           fxXStretch,
	Fixed           fxYStretch)

{
	Fixed   fxM00;
	Fixed   fxM01;
	Fixed   fxM10;
	Fixed   fxM11;
	Fixed   fxOrigX;
	Fixed   fxOrigY;

	if (fxXStretch == 0L || fxYStretch == 0L)
	{
		for (--lNumPts; lNumPts >= 0; --lNumPts)
		{
			*fxY++ = 0;
			*fxX++ = 0;
		}
	}
	else
	{
		if(fxXStretch != ONEFIX)
		{
			fxM00 = FixDiv (trans->transform[0][0], fxXStretch);
			fxM01 = FixDiv (trans->transform[0][1], fxXStretch);
		}
		else
		{
			fxM00 = trans->transform[0][0];
			fxM01 = trans->transform[0][1];
		}

		if(fxYStretch != ONEFIX)
		{
			fxM10 = FixDiv (trans->transform[1][0], fxYStretch);
			fxM11 = FixDiv (trans->transform[1][1], fxYStretch);
		}
		else
		{
			fxM10 = trans->transform[1][0];
			fxM11 = trans->transform[1][1];
		}

		for (--lNumPts; lNumPts >= 0; --lNumPts)
		{
			fxOrigX = *fxX;
			fxOrigY = *fxY;

			*fxX++ = (F26Dot6) (FixMul (fxM00, fxOrigX) + FixMul (fxM10, fxOrigY));
			*fxY++ = (F26Dot6) (FixMul (fxM01, fxOrigX) + FixMul (fxM11, fxOrigY));
		}
	}
}


/*
 *  Fold the point size and resolution into the matrix
 */

void    mth_FoldPointSizeResolution(
	Fixed           fxPointSize,
	int16           sXResolution,
	int16           sYResolution,
	transMatrix *   trans)
{
	Fixed fxScale;

	fxScale = ShortMulDiv(fxPointSize, sYResolution, POINTSPERINCH);
	trans->transform[0][1] = FixMul( trans->transform[0][1], fxScale );
	trans->transform[1][1] = FixMul( trans->transform[1][1], fxScale );
	trans->transform[2][1] = FixMul( trans->transform[2][1], fxScale );

	fxScale = ShortMulDiv(fxPointSize, sXResolution, POINTSPERINCH);
	trans->transform[0][0] = FixMul( trans->transform[0][0], fxScale );
	trans->transform[1][0] = FixMul( trans->transform[1][0], fxScale );
	trans->transform[2][0] = FixMul( trans->transform[2][0], fxScale );
}


/*********************************************************************/

/*  Find the power of 2 greater than the absolute value of passed parameter  */

int32 PowerOf2(
		int32 lValue )
{
	static const int32 iTable[] = { 0, 1, 2, 2, 3, 3, 3, 3,
								  4, 4, 4, 4, 4, 4, 4, 4  };

	if (lValue < 0L)
	{
		lValue = -lValue;
	}

	if (lValue < (1L << 16))
	{
		if (lValue < (1L << 8))
		{
			if (lValue < (1L << 4))
			{
				return (iTable[lValue]);
			}
			else
			{
				return (iTable[lValue >> 4] + 4);
			}
		}
		else
		{
			if (lValue < (1L << 12))
			{
				return (iTable[lValue >> 8] + 8);
			}
			else
			{
				return (iTable[lValue >> 12] + 12);
			}
		}
	}
	else
	{
		if (lValue < (1L << 24))
		{
			if (lValue < (1L << 20))
			{
				return (iTable[lValue >> 16] + 16);
			}
			else
			{
				return (iTable[lValue >> 20] + 20);
			}
		}
		else
		{
			if (lValue < (1L << 28))
			{
				return (iTable[lValue >> 24] + 24);
			}
			else
			{
				return (iTable[lValue >> 28] + 28);
			}
		}
	}
}

/********************************************************************/



/* divide by shifting for translation invariant negatives */

FS_PUBLIC int16 mth_DivShiftShort(int16 sValue, int16 sFactor)
{
	return (int16)mth_DivShiftLong((int32)sValue, sFactor);
}

FS_PUBLIC int32 mth_DivShiftLong(int32 lValue, int16 sFactor)
{
	switch (sFactor)
	{
	case 0:
	case 1:
		break;
	case 2:
		lValue >>= 1;
		break;
	case 4:
		lValue >>= 2;
		break;
	case 8:
		lValue >>= 3;
		break;
	default:
		if (lValue >= 0)
		{
			lValue /= (int32)sFactor;
		}
		else
		{
			lValue = ((lValue - (int32)sFactor + 1) / (int32)sFactor);
		}
		break;
	}
	return lValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\fscaler.c ===
/*
    File:       FontScaler.c

    Contains:   xxx put contents here (or delete the whole line) xxx

    Written by: xxx put name of writer here (or delete the whole line) xxx

   Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
               (c) 1989-1999. Microsoft Corporation, all rights reserved.

    Change History (most recent first):

                 7/10/99  BeatS     Add support for native SP fonts, vertical RGB
                 4/01/99  BeatS     Implement alternative interpretation of TT instructions for SP
        <>      10/14/97    CB      move usOverScale to fs_NewTransformation
        <>       2/21/97    CB      no need to call pre-program if no hints (was causing div by zero)
        <>       1/10/97    CB      empty bitmap with bMatchBbox == TRUE causes crash
        <>      12/14/95    CB      add usNonScaledAH to the private key
        <11>    11/27/90    MR      Need two scalars: one for (possibly rounded) outlines and cvt,
                                    and one (always fractional) metrics. [rb]
        <10>    11/21/90    RB      Allow client to disable DropOutControl by returning a NIL
                                    pointer to memoryarea[7]. Also make it clear that we inhibit
                                    DOControl whenever we band. [This is a reversion to 8, so mr's
                                    initials are added by proxy]
         <9>    11/13/90    MR      (dnf) Revert back to revision 7 to fix a memmory-trashing bug
                                    (we hope). Also fix signed/unsigned comparison bug in outline
                                    caching.
         <8>    11/13/90    RB      Fix banding so that we can band down to one row, using only
                                    enough bitmap memory and auxillary memory for one row.[mr]
         <7>     11/9/90    MR      Add Default return to fs_dropoutval. Continue to fiddle with
                                    banding. [rb]
         <6>     11/5/90    MR      Remove FixMath.h from include list. Clean up Stamp macros. [rb]
         <5>    10/31/90    MR      Conditionalize call to ComputeMapping (to avoid linking
                                    MapString) [ha]
         <4>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
         <3>    10/30/90    RB      [MR] Inhibit DropOutControl when Banding
         <2>    10/20/90    MR      Restore changes since project died. Converting to smart math
                                    routines, integer ppem scaling. [rb]
        <16>     7/26/90    MR      don't include ToolUtils.h
        <15>     7/18/90    MR      Fix return bug in GetAdvanceWidth, internal errors are now ints.
        <14>     7/14/90    MR      remove unused fields from FSInfo
        <13>     7/13/90    MR      Ansi-C fixes, rev. for union in FSInput
        <11>     6/29/90    RB      Thus endeth the too long life of encryption
        <10>     6/21/90    MR      Add calls to ReleaseSfntFrag
         <9>     6/21/90    RB      add scanKind info to fs_dropoutVal
         <8>      6/5/90    MR      remove fs_MapCharCodes
         <7>      6/1/90    MR      
         <6>      6/1/90    RB      fixed bandingbug under dropout control
         <4>      5/3/90    RB      added dropoutval function.  simplified restore outlines.
                                    support for new scanconverter in contourscan, findbitmapsize,
                                    saveoutlines, restoreoutlines.
         <3>     3/20/90    CL      Changed to use fpem (16.16) instead of pixelsPerEm (int) Removed
                                    call to AdjustTransformation (not needed with fpem) Added call
                                    to RunXFormPgm Removed WECANNOTDOTHIS #ifdef Added
                                    fs_MapCharCodes
         <2>     2/27/90    CL      New error code for missing but needed table. (0x1409).  New
                                    CharToIndexMap Table format.
                                    Fixed transformed component bug.
       <3.6>    11/15/89    CEL     Put an else for the ifdef WeCanNotDoThis so Printer compile
                                    could use more effecient code.
       <3.5>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
                                    phantom points are in, even for components in a composite glyph.
                                    They should also work for transformations. Device metric are
                                    passed out in the output data structure. This should also work
                                    with transformations. Another leftsidebearing along the advance
                                    width vector is also passed out. whatever the metrics are for
                                    the component at it's level. Instructions are legal in
                                    components. Instructions are legal in components. The
                                    transformation is internally automatically normalized. This
                                    should also solve the overflow problem we had. Now it is legal
                                    to pass in zero as the address of memory when a piece of the
                                    sfnt is requested by the scaler. If this happens the scaler will
                                    simply exit with an error code ! Five unnecessary element in the
                                    output data structure have been deleted. (All the information is
                                    passed out in the bitmap data structure) fs_FindBMSize now also
                                    returns the bounding box.
       <3.4>     9/28/89    CEL     fs_newglyph did not initialize the output error. Caused routine
                                    to return error from previous routines.
       <3.3>     9/27/89    CEL     Took out devAdvanceWidth & devLeftSideBearing.
       <3.2>     9/25/89    CEL     Changed the NEED_PROTOTYPE ifdef to use the NOT_ON_THE_MAC flag
                                    that existed previously.
       <3.1>     9/15/89    CEL     Changed dispatch scheme. Calling conventions through a trap
                                    needed to match Macintosh pascal. Pascal can not call C unless
                                    there is extra mucky glue. Bug that caused text not to appear.
                                    The font scaler state was set up correctly but the sfnt was
                                    purged. It was reloaded and the clientid changed but was still
                                    the same font. Under the rules of the FontScaler fs_newsfnt
                                    should not have to be called again to reset the state. The extra
                                    checks sent back a BAD_CLIENTID_ERROR so QuickDraw would think
                                    it was a bad font and not continue to draw.
       <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
       <2.4>     8/17/89    sjk     Coded around MPW C3.0 bug
       <2.3>     8/14/89    sjk     1 point contours now OK
       <2.2>      8/8/89    sjk     Improved encryption handling
       <2.1>      8/2/89    sjk     Fixed outline caching bug
       <2.0>      8/2/89    sjk     Just fixed EASE comment
       <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
       <1.4>     6/13/89    SJK     Comment
       <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
                                    bug, correct transformed integralized ppem behavior, pretty much
                                    so
       <1.2>     5/26/89    CEL     EASE messed up on "c" comments
      <y1.1>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
       <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

    To Do:
*/
/*      <3+>     3/20/90    mrr     Conditionalized error checking in fs_SetUpKey.
                                    Compiler option for stamping memmory areas for debugging
                                    Removed error field from FSInfo structure.
                                    Added call to RunFontProgram
                                    Added private function prototypes.
                                    Optimizations from diet clinic

*/

/** FontScaler's Includes **/

#define FSCFG_INTERNAL

#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"        /* For numeric conversion macros    */
#include "fnt.h"
#include "scentry.h"
#include "sfntaccs.h"
#include "fsglue.h"
#include "sbit.h"
#include "fscaler.h"         // moved this to be the last include file (key moved in dot h)


#include "stat.h"                   /* STAT timing card prototypes */
boolean gbTimer = FALSE;            /* set true when timer running */

#ifndef FSCFG_MOVE_KEY_IN_DOT_H
/* the definition of the key in fscaler.h and fscaler.c must be identical */

/** Private Structures  **/

/*** The Internal Key ***/
typedef struct fs_SplineKey {
    sfac_ClientRec      ClientInfo;         /* Client Information */
    char* const *       memoryBases;        /* array of memory Areas */
    char *              apbPrevMemoryBases[MEMORYFRAGMENTS];

    uint16              usScanType;         /* flags for dropout control etc.*/

    fsg_TransformRec    TransformInfo;

    uint16              usNonScaledAW;
    uint16              usNonScaledAH;

    LocalMaxProfile     maxProfile;         /* copy of profile */

    uint32              ulState;            /* for error checking purposes */
    
    boolean             bExecutePrePgm;
    boolean             bExecuteFontPgm;    /* <4> */

    fsg_WorkSpaceAddr   pWorkSpaceAddr;     /* Hard addresses in Work Space */
    fsg_WorkSpaceOffsets WorkSpaceOffsets;  /* Address offsets in Work Space     */
    fsg_PrivateSpaceOffsets PrivateSpaceOffsets; /* Address offsets in Private Space */

    uint16              usBandType;         /* old, small or fast */
    uint16              usBandWidth;        /* from FindBandingSize */

    GlyphBitMap         GBMap;              /* newscan bitmap type */
    WorkScan            WScan;              /* newscan workspace type */

    GlyphBitMap         OverGBMap;          /* for gray scale */
    uint16              usOverScale;        /* 0 => mono; mag factor => gray */
    boolean             bGrayScale;         /* FALSE if mono (usOverScale == 0) */
    boolean             bMatchBBox;         /* force bounding box match */
    boolean             bEmbeddedBitmap;    /* embedded bitmap found */         

    metricsType         metricInfo;         /* Glyph metrics info */
    verticalMetricsType     verticalMetricInfo;

    int32               lExtraWorkSpace;    /* Amount of extra space in workspace */

    boolean             bOutlineIsCached;   /* Outline is cached */
    boolean             bGlyphHasOutline;   /* Outline is empty */
    boolean             bGridFitSkipped;    /* sbit anticipated, no outline loaded */

    uint32              ulGlyphOutlineSize; /* Size of outline cache */
    
    sbit_State          SbitMono;           /* for monochrome bitmaps */
    boolean             bHintingEnabled;    /* hinting is enabled, set to FALSE when 
                                               fs_NewTransformNoGridFit is called */
    boolean             bBitmapEmboldening; /* bitmap emboldening simulation */
    int16               sBoldSimulHorShift; /* shift for emboldening simulation, horizonatlly */
    int16               sBoldSimulVertShift; /* shift for emboldening simulation, vertically */
#ifdef FSCFG_SUBPIXEL
    uint16              flSubPixel;
    fsg_TransformRec    TransformInfoSubPixel;
#endif // FSCFG_SUBPIXEL
} fs_SplineKey;

#endif // FSCFG_MOVE_KEY_IN_DOT_H

/*  CONSTANTS   */

/* Change this if the format for cached outlines change. */
/* Someone might be caching old stuff for years on a disk */

#define OUTLINESTAMP 0x2D0CBBAD
#define OUTLINESTAMP2 0xA5

#define BITMAP_MEMORY_COUNT 4       /* now for gray scale we need 4 */

/* for the key->ulState field */
#define INITIALIZED 0x0000L
#define NEWSFNT     0x0002L
#define NEWTRANS    0x0004L
#define GOTINDEX    0x0008L
#define GOTGLYPH    0x0010L
#define SIZEKNOWN   0x0020L

#define STAMPEXTRA      4

/* 'sfnt' in ASCII  */
#define STAMP           0x73666E74

/*** Memory shared between all fonts and sizes and transformations ***/
#define KEY_PTR_BASE                0 /* Constant Size ! */
#define VOID_FUNC_PTR_BASE          1 /* Constant Size ! */
#define SCAN_PTR_BASE               2 /* Constant Size ! */
#define WORK_SPACE_BASE             3 /* size is sfnt dependent, can't be shared between grid-fitting and scan-conversion */
/*** Memory that can not be shared between fonts and different sizes, can not dissappear after InitPreProgram () ***/
#define PRIVATE_FONT_SPACE_BASE     4 /* size is sfnt dependent */
/* Only needs to exist when ContourScan is called, and it can be shared */
#define BITMAP_PTR_1                5 /* the bitmap - size is glyph size dependent */
#define BITMAP_PTR_2                6 /* size is proportional to number of rows */
#define BITMAP_PTR_3                7 /* used for dropout control - glyph size dependent */
#define BITMAP_PTR_4                8 /* used in gray scale for overscaled bitmap */

static  const   transMatrix   IdentTransform =
    {{{ONEFIX,      0,      0},
      {     0, ONEFIX,      0},
      {     0,      0, ONEFIX}}};


/* PRIVATE DEFINITIONS    */

FS_PRIVATE fs_SplineKey *  fs_SetUpKey (fs_GlyphInputType* inptr, uint32 ulStateBits, ErrorCode * error);
FS_PRIVATE void            fs_InitializeKey(fs_SplineKey * key);
FS_PRIVATE int32           fs__Contour (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints);
FS_PRIVATE int32           fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints);
FS_PRIVATE void            fs_SetState(fs_SplineKey * key, uint32 ulState);
FS_PRIVATE void            FS_CALLBACK_PROTO dummyReleaseSfntFrag (voidPtr p);
FS_PRIVATE void            CHECKSTAMP (char * p);
FS_PRIVATE void            SETSTAMP (char * p);

FS_PRIVATE FS_ENTRY LookForSbitAdvanceWidth(fs_SplineKey *key, uint16 usGlyphIndex, boolean *pbBitmapFound, point *pf26DevAdvanceWidth );
FS_PRIVATE FS_ENTRY LookForSbitAdvanceHeight(fs_SplineKey *key, uint16 usGlyphIndex, boolean *pbBitmapFound,
    point *pf26DevAdvanceHeight);

/* FUNCTIONS    */

FS_PRIVATE void SETSTAMP (char * p)
{
    * ((uint32 *) ((p) - STAMPEXTRA)) = STAMP;
}


FS_PRIVATE void CHECKSTAMP (char * p)
{
    if (* ((uint32 *) ((p) - STAMPEXTRA)) != STAMP)
    {
#ifdef  NOT_ON_THE_MAC
        Assert(FALSE);
#else
        DEBUGGER ();
#endif
    }
}


FS_PRIVATE void FS_CALLBACK_PROTO dummyReleaseSfntFrag (voidPtr p)
{
    FS_UNUSED_PARAMETER(p);
}

FS_PRIVATE void   fs_SetState(fs_SplineKey * key, uint32 ulState)
{
    key->ulState = ulState;
}

/*
 *  Set up the key in case memmory has moved or been purged.
 */
FS_PRIVATE fs_SplineKey * fs_SetUpKey (
    fs_GlyphInputType * inptr,
    uint32              ulStateBits,
    ErrorCode *         error)
{
    fs_SplineKey *  key;

    key = (fs_SplineKey *)inptr->memoryBases[KEY_PTR_BASE];
    if (key == NULL)
    {
        *error = NULL_KEY_ERR;
        return 0;
    }

    key->memoryBases =                           inptr->memoryBases;
    if(key->memoryBases == NULL)
    {
        *error = NULL_MEMORY_BASES_ERR;
        return 0;
    }
    key->ClientInfo.GetSfntFragmentPtr =    inptr->GetSfntFragmentPtr;
    if(key->ClientInfo.GetSfntFragmentPtr == NULL)
    {
        *error = NULL_SFNT_FRAG_PTR_ERR;
        return 0;
    }

    key->ClientInfo.ReleaseSfntFrag = inptr->ReleaseSfntFrag;
    if (!(key->ClientInfo.ReleaseSfntFrag))
    {
        key->ClientInfo.ReleaseSfntFrag = dummyReleaseSfntFrag;
    }

    if ((key->ulState & ulStateBits) != ulStateBits)
    {
        *error = OUT_OFF_SEQUENCE_CALL_ERR;
        return 0;
    }

    key->ClientInfo.lClientID = inptr->clientID;
    *error = NO_ERR;

    return key;
}

FS_PRIVATE void fs_InitializeKey(fs_SplineKey * key)
{
    MEMSET(key, 0, sizeof(fs_SplineKey));
    key->TransformInfo.currentTMatrix = IdentTransform;
#ifdef FSCFG_SUBPIXEL
    key->TransformInfoSubPixel.currentTMatrix = IdentTransform;
#endif // FSCFG_SUBPIXEL
}

/*** FONT SCALER INTERFACE ***/

/*
 *
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    Assert(FS_SBIT_BITDEPTH_MASK == SBIT_BITDEPTH_MASK);
    /* sanity check that the embedded bitmap mask is the same in fscaler.h than in sfntaccs.h */

    if ( outputPtr )
    {
        outputPtr->memorySizes[KEY_PTR_BASE]        = (int32)sizeof (fs_SplineKey) + STAMPEXTRA;
        outputPtr->memorySizes[VOID_FUNC_PTR_BASE]  = 0;
        outputPtr->memorySizes[SCAN_PTR_BASE]       = 0;
        outputPtr->memorySizes[WORK_SPACE_BASE]      = 0; /* we need the sfnt for this */
        outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE] = 0; /* we need the sfnt for this */
        outputPtr->memorySizes[BITMAP_PTR_1]         = 0; /* we need the grid fitted outline for this */
        outputPtr->memorySizes[BITMAP_PTR_2]         = 0; /* we need the grid fitted outline for this */
        outputPtr->memorySizes[BITMAP_PTR_3]         = 0; /* we need the grid fitted outline for this */
        outputPtr->memorySizes[BITMAP_PTR_4]         = 0; /* gray scale memory */
    }
    else
    {
        return NULL_OUTPUT_PTR_ERR;
    }
    if ( inputPtr )
    {
        inputPtr->memoryBases[KEY_PTR_BASE]             = NULL;
        inputPtr->memoryBases[VOID_FUNC_PTR_BASE]       = NULL;
        inputPtr->memoryBases[SCAN_PTR_BASE]            = NULL;
        inputPtr->memoryBases[WORK_SPACE_BASE]          = NULL;
        inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE]  = NULL;
        inputPtr->memoryBases[BITMAP_PTR_1]             = NULL;
        inputPtr->memoryBases[BITMAP_PTR_2]             = NULL;
        inputPtr->memoryBases[BITMAP_PTR_3]             = NULL;
        inputPtr->memoryBases[BITMAP_PTR_4]             = NULL;
    }
    else
    {
        return NULL_INPUT_PTR_ERR;
    }
    return NO_ERR;
}

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    fs_SplineKey *  key;

    FS_UNUSED_PARAMETER(outputPtr);

    key = (fs_SplineKey *)inputPtr->memoryBases[KEY_PTR_BASE];
    SETSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

    fs_InitializeKey(key);

    key->memoryBases = inputPtr->memoryBases;

    fs_SetState(key, INITIALIZED);

    fsc_Initialize();                            /* initialize scan converter */

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

    return NO_ERR;
}


/*
 *  This guy asks for memmory for points, instructions, fdefs and idefs
 */
FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    ErrorCode       error;
    fs_SplineKey *  key;

	if(inputPtr->memoryBases[KEY_PTR_BASE] == NULL) 
	{
		return NULL_MEMORY_BASES_ERR;
	}

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

    STAT_ON_NEWSFNT;                 /* start STAT timer */

    key = fs_SetUpKey(inputPtr, INITIALIZED, &error);

    if(!key)
    {
        return (FS_ENTRY)error;
    }

    error = sfac_DoOffsetTableMap (&key->ClientInfo);  /* Map offset and length table */

    if(error != NO_ERR)
    {
        return (FS_ENTRY)error;
    }

    error = sfac_LoadCriticalSfntMetrics(
        &key->ClientInfo,
        &key->TransformInfo.usEmResolution,
        &key->TransformInfo.bIntegerScaling,
        &key->maxProfile);

    if(error != NO_ERR)
    {
        return (FS_ENTRY)error;
    }

    outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE] = (int32)fsg_PrivateFontSpaceSize (&key->ClientInfo, &key->maxProfile, &key->PrivateSpaceOffsets) + STAMPEXTRA;
    outputPtr->memorySizes[WORK_SPACE_BASE]         = (int32)fsg_WorkSpaceSetOffsets (&key->maxProfile, &key->WorkSpaceOffsets, &key->lExtraWorkSpace) + STAMPEXTRA;


    error = sfac_ComputeMapping (
        &key->ClientInfo,
        inputPtr->param.newsfnt.platformID,
        inputPtr->param.newsfnt.specificID);

    if(error != NO_ERR)
    {
        return (FS_ENTRY)error;
    }

    fs_SetState(key, (INITIALIZED | NEWSFNT));

    /*
     *  Can't run font program yet, we don't have any memory for the
     *  graphic state. Mark it to be run in NewTransformation.
     */

    key->bExecuteFontPgm = TRUE;

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

    STAT_OFF_NEWSFNT;                /* stop STAT timer */

    return NO_ERR;
}

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    return fs__NewTransformation (inputPtr, outputPtr, FALSE);
}


FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    return fs__NewTransformation (inputPtr, outputPtr, TRUE);
}


FS_PRIVATE int32 fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints)
{
    void *          pvGlobalGS;
    void *          pvStack;
    void *          pvTwilightZone;
    void *          pvFontProgram;
    void *          pvPreProgram;
    ErrorCode       error;
    fs_SplineKey *  key;
    int16           xOverResolution;
#ifdef FSCFG_SUBPIXEL
    void *          pvGlobalGSSubPixel;
    uint16          flSubPixelHintFlag;
    void *          pvTwilightZoneSubPixel;
#endif // FSCFG_SUBPIXEL
    uint16            usPPEMX;                  /* for sbits */
    uint16            usPPEMY; 
    uint16            usRotation;

	if((inputPtr->memoryBases[KEY_PTR_BASE] == NULL) ||
	   (inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
    {
        return NULL_MEMORY_BASES_ERR;
    }
    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

    SETSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    SETSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

    STAT_ON_NEWTRAN;                 /* start STAT timer */

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT), &error);

    if(!key)
    {
        return (FS_ENTRY)error;
    }


    key->bHintingEnabled = useHints;

    fsg_UpdateWorkSpaceAddresses(
        key->memoryBases[WORK_SPACE_BASE],
        &(key->WorkSpaceOffsets),
        &(key->pWorkSpaceAddr));

    fsg_UpdateWorkSpaceElement(
        &(key->WorkSpaceOffsets),
        &(key->pWorkSpaceAddr));

    pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

    fsg_UpdatePrivateSpaceAddresses(
        &key->ClientInfo,
        &key->maxProfile,
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets),
        pvStack,
        &pvFontProgram,
        &pvPreProgram);

    pvGlobalGS = fsg_QueryGlobalGS(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

    pvTwilightZone = fsg_QueryTwilightElement(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

    MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);

    key->bExecutePrePgm = (boolean) !inputPtr->param.newtrans.traceFunc;

    if (!key->bHintingEnabled)
    {
        /* if fs_NewTransformNoGridFit was called, we disabled hinting : */
        key->bExecutePrePgm = TRUE;
        key->bExecuteFontPgm = FALSE;
    }

    /* Load the font program and pre program if necessary */

    if (key->bExecuteFontPgm)
    {
        error = sfac_CopyFontAndPrePrograms(
            &key->ClientInfo,
            (char *)pvFontProgram,
            (char *)pvPreProgram);

        if(error)
        {
            return (FS_ENTRY)error;
        }
    }

    key->TransformInfo.currentTMatrix = *inputPtr->param.newtrans.transformMatrix;
    key->TransformInfo.fxPixelDiameter  = inputPtr->param.newtrans.pixelDiameter;
    key->usOverScale = inputPtr->param.newtrans.usOverScale; /* read input param */

    xOverResolution = inputPtr->param.newtrans.xResolution;

#ifdef FSCFG_SUBPIXEL
    /* convert from external client flags to internal flags */
    key->flSubPixel = 0;
    if (inputPtr->param.newtrans.flSubPixel & SP_SUB_PIXEL)
    {
        key->flSubPixel |= FNT_SP_SUB_PIXEL;
    }
    if (inputPtr->param.newtrans.flSubPixel & SP_COMPATIBLE_WIDTH)
    {
        /* compatible width is disabled under rotation but kept under italization */
        if (key->TransformInfo.currentTMatrix.transform[0][1] == 0)
        {
            key->flSubPixel |= FNT_SP_COMPATIBLE_WIDTH;
        }
    }
    if (inputPtr->param.newtrans.flSubPixel & SP_VERTICAL_DIRECTION)
    {
        key->flSubPixel |= FNT_SP_VERTICAL_DIRECTION;
    }
    if (inputPtr->param.newtrans.flSubPixel & SP_SUB_PIXEL && key->TransformInfo.currentTMatrix.transform[0][0] == 0) {
    // we have a combination of rotation and/or mirroring which swaps the roles of the x- and y-axis
        key->flSubPixel ^= FNT_SP_VERTICAL_DIRECTION;
    }
    
    if (inputPtr->param.newtrans.flSubPixel & SP_BGR_ORDER)
    {
        key->flSubPixel |= FNT_SP_BGR_ORDER;
    }
    
    flSubPixelHintFlag = 0;

    if (((key->flSubPixel & FNT_SP_SUB_PIXEL) && (key->usOverScale != 0) ) || 
        (((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) || (key->flSubPixel & FNT_SP_VERTICAL_DIRECTION) || (key->flSubPixel & FNT_SP_BGR_ORDER)) && !(key->flSubPixel & FNT_SP_SUB_PIXEL)))
    {
        /*****
        We do not yet allow a combination of SubPixel and Gray antialiazing
        The following table lists legal combinations of flags in flSubPixel:

        SubPixel    CompWidth   VertDirect  BGROrder    Comment
            No          No          No          No      b/w
            No          No          No          Yes     Illegal to ask for BGR order without asking for SubPixel
            No          No          Yes         No      Illegal to ask for vertical direction without asking for SubPixel
            No          No          Yes         Yes     Illegal by disjunctive combination
            No          Yes         No          No      Illegal to ask for compatible width without asking for SubPixel 
            No          Yes         No          Yes     Illegal by disjunctive combination 
            No          Yes         Yes         No      Illegal by disjunctive combination
            No          Yes         Yes         Yes     Illegal by disjunctive combination
            Yes         No          No          No      Plain SubPixel horizontal direction RGB
            Yes         No          No          Yes     Plain SubPixel horizontal direction BGR
            Yes         No          Yes         No      Plain SubPixel vertical direction RGB
            Yes         No          Yes         Yes     Plain SubPixel vertical direction BGR
            Yes         Yes         No          No      b/w compatible advance width SubPixel horizontal direction RGB
            Yes         Yes         No          Yes     b/w compatible advance width SubPixel horizontal direction BGR
            Yes         Yes         Yes         No      b/w compatible advance width SubPixel vertical direction RGB
            Yes         Yes         Yes         Yes     b/w compatible advance width SubPixel vertical direction BGR
        
        Note that it could be argued that in vertical direction RGB|BGR, advance widths should be b/w compatible
        by nature, because we are not rounding any x-direction positions and distances any differently than
        in b/w. However, with vertical direction RGB, a glyph may assume a height that is closer to its natural
        height than what it would in b/w, and as a result may seem too narrow or too wide, which in turn would
        call for a correction in x, specific to SubPixel with vertical direction RGB and potentially making the
        advance width incompatible. Therefore, we allow the last two combinations of flags.
        *****/

        return BAD_GRAY_LEVEL_ERR;
    }
    
    if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
    {
        if (key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH)
        {
            pvGlobalGSSubPixel = fsg_QueryGlobalGSSubPixel(
                key->memoryBases[PRIVATE_FONT_SPACE_BASE],
                &(key->PrivateSpaceOffsets));
            pvTwilightZoneSubPixel = fsg_QueryTwilightElementSubPixel(
                key->memoryBases[PRIVATE_FONT_SPACE_BASE],
                &(key->PrivateSpaceOffsets));
            key->TransformInfoSubPixel = key->TransformInfo;
        } else
        {
            xOverResolution = xOverResolution * HINTING_HOR_OVERSCALE;
            flSubPixelHintFlag = key->flSubPixel;
        }

    }
#endif // FSCFG_SUBPIXEL

    if (key->usOverScale != 0 && 
            (((1 << (key->usOverScale - 1)) & FS_GRAY_VALUE_MASK) == 0) || key->usOverScale > 31)
    {
        return BAD_GRAY_LEVEL_ERR;
    }


    key->bGrayScale = (key->usOverScale == 0) ? FALSE : TRUE;
    fsg_SetHintFlags(pvGlobalGS, key->bGrayScale
#ifdef FSCFG_SUBPIXEL
        ,flSubPixelHintFlag
#endif // FSCFG_SUBPIXEL
        );

    error = fsg_InitInterpreterTrans (
        &key->TransformInfo,
        pvGlobalGS,
        inputPtr->param.newtrans.pointSize,
#ifdef FSCFG_SUBPIXEL
        xOverResolution,
#else
        inputPtr->param.newtrans.xResolution,
#endif // FSCFG_SUBPIXEL
        inputPtr->param.newtrans.yResolution,
        inputPtr->param.newtrans.bHintAtEmSquare,
        inputPtr->param.newtrans.usEmboldWeightx ,
        inputPtr->param.newtrans.usEmboldWeighty,
        key->ClientInfo.sWinDescender,
        inputPtr->param.newtrans.lDescDev,
        &key->sBoldSimulHorShift,
        &key->sBoldSimulVertShift );

#ifdef FSCFG_SUBPIXEL
    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
        fsg_SetHintFlags(pvGlobalGSSubPixel, key->bGrayScale, key->flSubPixel);

        error = fsg_InitInterpreterTrans (
            &key->TransformInfoSubPixel,
            pvGlobalGSSubPixel,
            inputPtr->param.newtrans.pointSize,
            (int16)(xOverResolution * HINTING_HOR_OVERSCALE),
            inputPtr->param.newtrans.yResolution,
            inputPtr->param.newtrans.bHintAtEmSquare,
            inputPtr->param.newtrans.usEmboldWeightx ,
            inputPtr->param.newtrans.usEmboldWeighty,
            key->ClientInfo.sWinDescender,
            inputPtr->param.newtrans.lDescDev,
            &key->sBoldSimulHorShift,
            &key->sBoldSimulVertShift  );
    }
#endif // FSCFG_SUBPIXEL

    key->bBitmapEmboldening = inputPtr->param.newtrans.bBitmapEmboldening;

    if(error)
    {
        return (FS_ENTRY)error;
    }

    if (key->bExecuteFontPgm)
    {
        error = fsg_RunFontProgram (pvGlobalGS, &key->pWorkSpaceAddr, pvTwilightZone,
                                    inputPtr->param.newtrans.traceFunc);

        if(error)
        {
            return (FS_ENTRY)error;
        }

        key->bExecuteFontPgm = FALSE;
    }

#ifdef FSCFG_SUBPIXEL
    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
        fsg_CopyFontProgramResults (pvGlobalGS, pvGlobalGSSubPixel);
    }
#endif // FSCFG_SUBPIXEL

    if (!key->bExecutePrePgm)
    {

        /* Do this now so we do not confuse font editors    */
        /* Run the pre program and scale the control value table */
        /* Sets key->bExecutePrePgm to false          */

        error = fsg_RunPreProgram (
            &key->ClientInfo,
            &key->maxProfile,
            &key->TransformInfo,
            pvGlobalGS,
            &key->pWorkSpaceAddr,
            pvTwilightZone,
            inputPtr->param.newtrans.traceFunc);

        if(error)
        {
            /* If the pre-program fails, switch off hinting for further glyphs */
            key->bHintingEnabled = FALSE;
            return (FS_ENTRY)error;
        }
#ifdef FSCFG_SUBPIXEL
        if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
        {
            error = fsg_RunPreProgram (
                &key->ClientInfo,
                &key->maxProfile,
                &key->TransformInfoSubPixel,
                pvGlobalGSSubPixel,
                &key->pWorkSpaceAddr,
                pvTwilightZoneSubPixel,
                inputPtr->param.newtrans.traceFunc);

            if(error)
            {
                /* If the pre-program fails, switch off hinting for further glyphs */
                key->bHintingEnabled = FALSE;
                return (FS_ENTRY)error;
            }
        }
#endif // FSCFG_SUBPIXEL
    }

    fsg_GetScaledCVT(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &key->PrivateSpaceOffsets,
        &outputPtr->scaledCVT);

    fsg_QueryPPEMXY(pvGlobalGS, &key->TransformInfo, 
                &usPPEMX, &usPPEMY, &usRotation);

    error = sbit_NewTransform(&key->SbitMono,key->TransformInfo.usEmResolution,
        key->sBoldSimulHorShift, key->sBoldSimulVertShift, usPPEMX, usPPEMY, usRotation );      /* setup for sbits */
    
    if(error)
    {
        return (FS_ENTRY)error;
    }

    fs_SetState(key, (INITIALIZED | NEWSFNT | NEWTRANS));

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

    STAT_OFF_NEWTRAN;             /* stop STAT timer */

    return NO_ERR;
}


/*
 * Compute the glyph index from the character code.
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    ErrorCode         error;
    fs_SplineKey *    key;
    void *            pvGlobalGS;
    uint16            usBitDepth;           /* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */

	if((inputPtr->memoryBases[KEY_PTR_BASE] == NULL) ||
	   (inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
	{
		return NULL_MEMORY_BASES_ERR;
	}
    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

    STAT_ON_NEWGLYPH;                /* start STAT timer */

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS), &error);

    if(!key)
    {
        return (FS_ENTRY)error;
    }

    if (inputPtr->param.newglyph.characterCode != NONVALID)
    {
        error = sfac_GetGlyphIndex(
            &key->ClientInfo,
            inputPtr->param.newglyph.characterCode);

        if(error)
        {
            return (FS_ENTRY)error;
        }

        outputPtr->numberOfBytesTaken = 2;  /*  !!!DISCUSS  */
        outputPtr->glyphIndex = key->ClientInfo.usGlyphIndex;
    }
    else
    {
        key->ClientInfo.usGlyphIndex = inputPtr->param.newglyph.glyphIndex;
        outputPtr->glyphIndex =        inputPtr->param.newglyph.glyphIndex;
        outputPtr->numberOfBytesTaken = 0;
    }

    if( key->ClientInfo.usGlyphIndex > key->maxProfile.numGlyphs - 1)
    {
        return INVALID_GLYPH_INDEX;
    }

    pvGlobalGS = fsg_QueryGlobalGS(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

    key->bEmbeddedBitmap = !inputPtr->param.newglyph.bNoEmbeddedBitmap; /* read input param */

    key->bMatchBBox = inputPtr->param.newglyph.bMatchBBox;

    if (inputPtr->param.newglyph.bNoEmbeddedBitmap)
    {
        outputPtr->usBitmapFound = FALSE;
    } else {
        error = sbit_SearchForBitmap(
            &key->SbitMono,
            &key->ClientInfo,
            key->ClientInfo.usGlyphIndex,
            key->usOverScale,
            &usBitDepth,
            &outputPtr->usBitmapFound );
    
        if(error)
        {
            return (FS_ENTRY)error;
        }

    }

    if (key->usOverScale == 0)
    {
        outputPtr->usGrayLevels = 0; 
        /* usGrayLevels == 0 means 1 bit per pixel */
    } else {
#ifndef FSCFG_CONVERT_GRAY_LEVELS
        if(outputPtr->usBitmapFound)
        {
            outputPtr->usGrayLevels = 0x01 << usBitDepth;
        } else {
#endif // FSCFG_CONVERT_GRAY_LEVELS
            outputPtr->usGrayLevels = key->usOverScale * key->usOverScale + 1;
#ifndef FSCFG_CONVERT_GRAY_LEVELS
        }
#endif // FSCFG_CONVERT_GRAY_LEVELS
    }

    key->bEmbeddedBitmap = outputPtr->usBitmapFound;

#ifdef FSCFG_SUBPIXEL
    if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
    {
        outputPtr->usBitmapFound = FALSE;
    }
#endif // FSCFG_SUBPIXEL

    /* clear all other bits */

    fs_SetState(key, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX));

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

    STAT_OFF_NEWGLYPH;                   /* stop STAT timer */

    return NO_ERR;
}


/*
 * this call is optional.
 *
 * can be called right after fs_NewGlyph ()
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    ErrorCode       error;
    int16           sNonScaledLSB;
    fs_SplineKey *  key;
    void *          pvGlobalGS;

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX), &error);

    if(!key)
    {
        return (FS_ENTRY)error;
    }

    pvGlobalGS = fsg_QueryGlobalGS(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

    error = sfac_ReadGlyphHorMetrics (
        &key->ClientInfo,
        key->ClientInfo.usGlyphIndex,
        &key->usNonScaledAW,
        &sNonScaledLSB);

    if(error)
    {
        return (FS_ENTRY)error;
    }

    fsg_UpdateAdvanceWidth (&key->TransformInfo, pvGlobalGS, key->usNonScaledAW,
        &outputPtr->metricInfo.advanceWidth);

#ifdef FSCFG_SUBPIXEL
    if ((key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) )
    {
        /* in the SubPixel mode, key->TransformInfo is overscaled when we don't ask for compatible width */
        ROUND_FROM_HINT_OVERSCALE(outputPtr->metricInfo.advanceWidth.x);
    }
#endif // FSCFG_SUBPIXEL
    return NO_ERR;
}

/*
 * this call is optional.
 *
 * can be called right after fs_NewGlyph ()
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceHeight (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    ErrorCode       error;
    int16           sNonScaledTSB;
    fs_SplineKey *  key;
    void *          pvGlobalGS;

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX), &error);

    if(!key)
    {
        return (FS_ENTRY)error;
    }

    pvGlobalGS = fsg_QueryGlobalGS(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));


    error = sfac_ReadGlyphVertMetrics (
        &key->ClientInfo,
        key->ClientInfo.usGlyphIndex,
        &key->usNonScaledAH,
        &sNonScaledTSB);

    if(error)
    {
        return (FS_ENTRY)error;
    }

    fsg_UpdateAdvanceHeight (&key->TransformInfo, pvGlobalGS, key->usNonScaledAH,
        &outputPtr->verticalMetricInfo.advanceHeight);

#ifdef FSCFG_SUBPIXEL   
    if ((key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) )
    {
        /* in the SubPixel mode, key->TransformInfo is overscaled when we don't ask for compatible width */
        ROUND_FROM_HINT_OVERSCALE(outputPtr->verticalMetricInfo.advanceHeight.x);
    }
#endif
    return NO_ERR;
}

FS_PRIVATE int32 fs__Contour (fs_GlyphInputType*inputPtr, fs_GlyphInfoType*outputPtr, boolean useHints)
{
    ErrorCode       error;
    void *          pvGlobalGS;
    fs_SplineKey *  key;
    point           f26DevAdvanceWidth;
    point           f26DevAdvanceHeight;
    void *          pvTwilightZone;
    void *          pvStack;
    void *          pvFontProgram;
    void *          pvPreProgram;
#ifdef FSCFG_SUBPIXEL   
    void *          pvGlobalGSSubPixel;
    void *          pvTwilightZoneSubPixel;
    boolean         bSubPixelWidth = FALSE;
#endif // FSCFG_SUBPIXEL

	if((inputPtr->memoryBases[KEY_PTR_BASE] == NULL) ||
	   (inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
    {
        return NULL_MEMORY_BASES_ERR;
    }

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

    STAT_ON_GRIDFIT;                 /* start STAT timer */

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX), &error);

    if(!key)
    {
        return (FS_ENTRY)error;
    }

    if((key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE]) ||
       (key->apbPrevMemoryBases[PRIVATE_FONT_SPACE_BASE] != key->memoryBases[PRIVATE_FONT_SPACE_BASE]))
    {
        fsg_UpdateWorkSpaceAddresses(
            key->memoryBases[WORK_SPACE_BASE],
            &(key->WorkSpaceOffsets),
            &(key->pWorkSpaceAddr));

        pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

        fsg_UpdatePrivateSpaceAddresses(
            &key->ClientInfo,
            &key->maxProfile,
            key->memoryBases[PRIVATE_FONT_SPACE_BASE],
            &(key->PrivateSpaceOffsets),
            pvStack,
            &pvFontProgram,
            &pvPreProgram);

        MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
    }

    /* The element data structures need to be updated here because if the    */
    /* WorkSpace memory is shared, the pointers will not be correct. Since  */
    /* fs_Contour[No]GridFit - fs_ContourScan must have the same shared      */
    /* base, these address do not have to be updated explicitly between      */
    /* each call, only if the memory base has physically moved.              */

    fsg_UpdateWorkSpaceElement(
        &(key->WorkSpaceOffsets),
        &(key->pWorkSpaceAddr));

    pvGlobalGS = fsg_QueryGlobalGS(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

#ifdef FSCFG_SUBPIXEL   
    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
        pvGlobalGSSubPixel = fsg_QueryGlobalGSSubPixel(
            key->memoryBases[PRIVATE_FONT_SPACE_BASE],
            &(key->PrivateSpaceOffsets));
        pvTwilightZoneSubPixel = fsg_QueryTwilightElementSubPixel(
            key->memoryBases[PRIVATE_FONT_SPACE_BASE],
            &(key->PrivateSpaceOffsets));
    }

    if ( (key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) ) 
    {
        bSubPixelWidth = TRUE;
    }
#endif // FSCFG_SUBPIXEL

    pvTwilightZone = fsg_QueryTwilightElement(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

    if (!key->bHintingEnabled)
    {
        /* if fs_NewTransformNoGridFit was called, we disabled hinting : */
        key->bExecutePrePgm = FALSE;
        useHints = FALSE;
    }

    /*  potentially do delayed pre program execution */

    if (key->bExecutePrePgm)
    {
        /* Run the pre program and scale the control value table */

        key->bExecutePrePgm = FALSE;

        error = fsg_RunPreProgram (
            &key->ClientInfo,
            &key->maxProfile,
            &key->TransformInfo,
            pvGlobalGS,
            &key->pWorkSpaceAddr,
            pvTwilightZone,
            NULL);

        if(error)
        {
            /* If the pre-program fails, switch off hinting for further glyphs */
            key->bHintingEnabled = FALSE;
            return (FS_ENTRY)error;
        }
#ifdef FSCFG_SUBPIXEL   
        if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
        {
            error = fsg_RunPreProgram (
                &key->ClientInfo,
                &key->maxProfile,
                &key->TransformInfoSubPixel,
                pvGlobalGSSubPixel,
                &key->pWorkSpaceAddr,
                pvTwilightZoneSubPixel,
                NULL);

            if(error)
            {
                /* If the pre-program fails, switch off hinting for further glyphs */
                key->bHintingEnabled = FALSE;
                return (FS_ENTRY)error;
            }
        }
#endif // FSCFG_SUBPIXEL    
    }

#ifdef FSCFG_SUBPIXEL
    if (inputPtr->param.gridfit.bSkipIfBitmap && key->bEmbeddedBitmap && !(key->flSubPixel & FNT_SP_SUB_PIXEL))
#else
    if (inputPtr->param.gridfit.bSkipIfBitmap && key->bEmbeddedBitmap)
#endif // FSCFG_SUBPIXEL    
    {
        key->bGridFitSkipped = TRUE;    /* disallow grayscale, outline caching, banding */
        
        error = sbit_GetDevAdvanceWidth (
            &key->SbitMono,
            &key->ClientInfo,
            &f26DevAdvanceWidth );
        
        if(error)
        {
            return (FS_ENTRY)error;
        }

        error = sbit_GetDevAdvanceHeight (
            &key->SbitMono,
            &key->ClientInfo,
            &f26DevAdvanceHeight );

        if(error)
        {
            return (FS_ENTRY)error;
        }

    }
    else                                /* if we're using the outline */
    {
        key->bGridFitSkipped = FALSE;   /* allow grayscale, outline caching, banding */

        /* THE CALL */

        error = fsg_GridFit (
            &key->ClientInfo,
            &key->maxProfile,
            &key->TransformInfo,
            pvGlobalGS,
            &key->pWorkSpaceAddr,
            pvTwilightZone,
            inputPtr->param.gridfit.traceFunc,
            useHints,
            &key->usScanType,
            &key->bGlyphHasOutline,
            &key->usNonScaledAW,
            key->bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
            ,bSubPixelWidth
#endif // FSCFG_SUBPIXEL
            );

        if(error)
        {
            return (FS_ENTRY)error;
        }

#ifdef FSCFG_SUBPIXEL

        if (key->flSubPixel & FNT_SP_SUB_PIXEL) {
            Fixed   fxCompatibleWidthScale;
            F26Dot6 devAdvanceWidthX, devLeftSideBearingX, devRightSideBearingX;
            F26Dot6 horTranslation;
            
            /* default scale back factor if we don't need to adjust for compatible width
               (FNT_SP_COMPATIBLE_WIDTH is set off under rotation at fs_NewTransformation) */
            
            fxCompatibleWidthScale = SUBPIXEL_SCALEBACK_FACTOR; 

            if (key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) {
                Fixed concertFactor;

                // compute the B/W glyph metrics
                if (key->bEmbeddedBitmap) {
                    error = sbit_CalcDevHorMetrics (&key->SbitMono,&key->ClientInfo,&devAdvanceWidthX,&devLeftSideBearingX,&devRightSideBearingX);
                    if(error)
                        return (FS_ENTRY)error;
                } else {
                    fsg_CalcDevHorMetrics(&key->pWorkSpaceAddr,&devAdvanceWidthX,&devLeftSideBearingX,&devRightSideBearingX);
                }

                if (key->usNonScaledAW && devAdvanceWidthX) {
                    concertFactor = FixDiv(devAdvanceWidthX,((fnt_GlobalGraphicStateType *)pvGlobalGS)->ScaleFuncX(
                                           &((fnt_GlobalGraphicStateType *)pvGlobalGS)->scaleX,(F26Dot6)key->usNonScaledAW));
                    if (concertFactor < 0) concertFactor = -concertFactor;
                } else {
                    concertFactor = 0x10000; // Fixed 1.0 for 0 AW glyphs
                }
                ((fnt_GlobalGraphicStateType *)pvGlobalGSSubPixel)->compatibleWidthStemConcertina = concertFactor;
                
                /* grid fit for the SubPixel overscale resolution */
                error = fsg_GridFit (
                    &key->ClientInfo,
                    &key->maxProfile,
                    &key->TransformInfoSubPixel,
                    pvGlobalGSSubPixel,
                    &key->pWorkSpaceAddr,
                    pvTwilightZoneSubPixel,
                    inputPtr->param.gridfit.traceFunc,
                    useHints,
                    &key->usScanType,
                    &key->bGlyphHasOutline,
                    &key->usNonScaledAW,
                    key->bBitmapEmboldening,
                    (key->flSubPixel & FNT_SP_SUB_PIXEL)
                    );

                if(error) {
                    return (FS_ENTRY)error;
                }
            } // key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH
            
            fsg_ScaleToCompatibleWidth(&key->pWorkSpaceAddr,fxCompatibleWidthScale);

            if (useHints && (key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH)) {
                horTranslation = 0;
                fsg_AdjustCompatibleMetrics (
                    &key->pWorkSpaceAddr,
                    horTranslation,
                    devAdvanceWidthX*RGB_OVERSCALE);
            }
        }
#endif // FSCFG_SUBPIXEL

        fsg_GetContourData(
            &key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
            (boolean)(key->flSubPixel & FNT_SP_SUB_PIXEL),            
#endif // FSCFG_SUBPIXEL
            &outputPtr->xPtr,
            &outputPtr->yPtr,
            &outputPtr->startPtr,
            &outputPtr->endPtr,
            &outputPtr->onCurve,
            &outputPtr->fc,
            &outputPtr->numberOfContours);

        fsg_GetDevAdvanceWidth(
            &key->pWorkSpaceAddr,
            &f26DevAdvanceWidth);

        fsg_GetDevAdvanceHeight(
            &key->pWorkSpaceAddr,
            &f26DevAdvanceHeight);
    }
    
    outputPtr->metricInfo.devAdvanceWidth.x = DOT6TOFIX(f26DevAdvanceWidth.x);
    outputPtr->metricInfo.devAdvanceWidth.y = DOT6TOFIX(f26DevAdvanceWidth.y);

    outputPtr->verticalMetricInfo.devAdvanceHeight.x = DOT6TOFIX(f26DevAdvanceHeight.x);
    outputPtr->verticalMetricInfo.devAdvanceHeight.y = DOT6TOFIX(f26DevAdvanceHeight.y);

#ifdef FSCFG_SUBPIXEL
    if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
    {
        ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devAdvanceWidth.x);
        ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devAdvanceHeight.x);
    }
#endif // FSCFG_SUBPIXEL

    outputPtr->outlinesExist = (uint16)key->bGlyphHasOutline;

    fsg_GetScaledCVT(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &key->PrivateSpaceOffsets,
        &outputPtr->scaledCVT);

    fs_SetState(key, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH));

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

    STAT_OFF_GRIDFIT;             /* stop STAT timer */

    return NO_ERR;
}

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    return fs__Contour (inputPtr, outputPtr, FALSE);
}


FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    return fs__Contour (inputPtr, outputPtr, TRUE);
}

/*********************************************************************/

/* Calculate scan conversion memory requirements                     */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{

    ErrorCode       error;
    BitMap *        pBMI;

    ContourList     CList;        /* newscan contour list type */
    void *          pvGlobalGS;
    fs_SplineKey *  key;

    point           f26DevAdvanceWidth;
    point           f26DevLeftSideBearing;
    point           f26LeftSideBearing;
    point           f26DevLeftSideBearingLine;
    point           f26LeftSideBearingLine;

    point           f26DevAdvanceHeight;
    point           f26DevTopSideBearing;
    point           f26TopSideBearing;
    point           f26DevTopSideBearingLine;
    point           f26TopSideBearingLine;

    int16           sOverScale;
    uint16          usRoundXMin;
    Rect *          pOrigB;             /* original outline bounding box */
    Rect *          pOverB;             /* over scaled outline bounding box */
    GlyphBitMap *   pOverG;             /* over scaled glyph bitmap struct */
    GlyphBitMap *   pGBMap;             /* orig or over pointer */
    
    uint16          usRowBytes;
    uint32          ulSbitOutSize;      /* sbit output memory */
    uint32          ulSbitWorkSize;     /* sbit workspace memory */
    int16           sNonScaledLSB;      /* for non-dev metrics calc */
    int16           sNonScaledTSB;      /* for non-dev metrics calc */
    int16           sBitmapEmboldeningHorExtra;      
    int16           sBitmapEmboldeningVertExtra;      

	if((inputPtr->memoryBases[KEY_PTR_BASE] == NULL) ||
	   (inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
    {
        return NULL_MEMORY_BASES_ERR;
    }

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

    STAT_ON_FINDBMS;                 /* start STAT timer */
    
    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH), &error);
    if(!key)
    {
        return (FS_ENTRY)error;
    }

    if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
    {
          fsg_UpdateWorkSpaceAddresses(
                key->memoryBases[WORK_SPACE_BASE],
                &(key->WorkSpaceOffsets),
                &(key->pWorkSpaceAddr));
        
          fsg_UpdateWorkSpaceElement(
                &(key->WorkSpaceOffsets),
                &(key->pWorkSpaceAddr));
        
          MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
    }

    pvGlobalGS = fsg_QueryGlobalGS(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

    pOrigB = &key->GBMap.rectBounds;    /* local copy of bounds pointer */

#ifdef FSCFG_SUBPIXEL
    if (key->bEmbeddedBitmap && !(key->flSubPixel & FNT_SP_SUB_PIXEL))                  /* if bitmap are not disabled */
#else
    if (key->bEmbeddedBitmap)               /* if bitmap are not disabled */
#endif // FSCFG_SUBPIXEL    
    {
        error = sbit_GetMetrics (                   /* get device metrics */
            &key->SbitMono,
            &key->ClientInfo,
            &f26DevAdvanceWidth,
            &f26DevLeftSideBearing,
            &f26LeftSideBearing,
            &f26DevAdvanceHeight,
            &f26DevTopSideBearing,
            &f26TopSideBearing,
            pOrigB,
            &usRowBytes,
            &ulSbitOutSize,
            &ulSbitWorkSize );
        
        if (error != NO_ERR)
        {
            return(error);
        }
        
        outputPtr->metricInfo.devAdvanceWidth.x = DOT6TOFIX(f26DevAdvanceWidth.x);
        outputPtr->metricInfo.devAdvanceWidth.y = DOT6TOFIX(f26DevAdvanceWidth.y);
        outputPtr->metricInfo.devLeftSideBearing.x = DOT6TOFIX(f26DevLeftSideBearing.x);
        outputPtr->metricInfo.devLeftSideBearing.y = DOT6TOFIX(f26DevLeftSideBearing.y);
        outputPtr->metricInfo.leftSideBearing.x = DOT6TOFIX(f26LeftSideBearing.x);
        outputPtr->metricInfo.leftSideBearing.y = DOT6TOFIX(f26LeftSideBearing.y);
        
        outputPtr->verticalMetricInfo.devAdvanceHeight.x = DOT6TOFIX(f26DevAdvanceHeight.x);
        outputPtr->verticalMetricInfo.devAdvanceHeight.y = DOT6TOFIX(f26DevAdvanceHeight.y);
        outputPtr->verticalMetricInfo.devTopSideBearing.x = DOT6TOFIX(f26DevTopSideBearing.x);
        outputPtr->verticalMetricInfo.devTopSideBearing.y = DOT6TOFIX(f26DevTopSideBearing.y);
        outputPtr->verticalMetricInfo.topSideBearing.x = DOT6TOFIX(f26TopSideBearing.x);
        outputPtr->verticalMetricInfo.topSideBearing.y = DOT6TOFIX(f26TopSideBearing.y);
        
        /* just copy to 'Line' metrics */

        outputPtr->metricInfo.devLeftSideBearingLine.x = outputPtr->metricInfo.devLeftSideBearing.x;
        outputPtr->metricInfo.devLeftSideBearingLine.y = outputPtr->metricInfo.devLeftSideBearing.y;
        outputPtr->metricInfo.leftSideBearingLine.x = outputPtr->metricInfo.leftSideBearing.x;
        outputPtr->metricInfo.leftSideBearingLine.y = outputPtr->metricInfo.leftSideBearing.y;

        outputPtr->verticalMetricInfo.devTopSideBearingLine.x = outputPtr->verticalMetricInfo.devTopSideBearing.x;
        outputPtr->verticalMetricInfo.devTopSideBearingLine.y = outputPtr->verticalMetricInfo.devTopSideBearing.y;
        outputPtr->verticalMetricInfo.topSideBearingLine.x = outputPtr->verticalMetricInfo.topSideBearing.x;
        outputPtr->verticalMetricInfo.topSideBearingLine.y = outputPtr->verticalMetricInfo.topSideBearing.y;


    error = sfac_ReadGlyphMetrics (             /* get non-dev adv width */
            &key->ClientInfo,
            key->ClientInfo.usGlyphIndex,
            &key->usNonScaledAW,
            &key->usNonScaledAH,
            &sNonScaledLSB,
            &sNonScaledTSB);

        if(error != NO_ERR)
        {
            return error;
        }

        fsg_UpdateAdvanceWidth (
            &key->TransformInfo,                    /* scale the design adv width */
            pvGlobalGS, 
            key->usNonScaledAW,
            &outputPtr->metricInfo.advanceWidth );

        fsg_UpdateAdvanceHeight (
            &key->TransformInfo,                    /* scale the design adv height */
            pvGlobalGS, 
            key->usNonScaledAH,
            &outputPtr->verticalMetricInfo.advanceHeight );

        pBMI = &outputPtr->bitMapInfo;
        pBMI->bounds.left = pOrigB->left;               /* return bbox to client */
        pBMI->bounds.right = pOrigB->right;
        pBMI->bounds.top = pOrigB->bottom;              /* reversed! */
        pBMI->bounds.bottom = pOrigB->top;
        pBMI->rowBytes = (int16)usRowBytes;
        pBMI->baseAddr = 0L;

        outputPtr->memorySizes[BITMAP_PTR_1] = ulSbitOutSize;
        outputPtr->memorySizes[BITMAP_PTR_2] = ulSbitWorkSize;
        outputPtr->memorySizes[BITMAP_PTR_3] = 0L;
        outputPtr->memorySizes[BITMAP_PTR_4] = 0L;
    }
    else                                /* if rasterizing from a contour */
    {
        if (key->TransformInfo.bPhaseShift)
        {
            fsg_45DegreePhaseShift (&key->pWorkSpaceAddr);
        }

        fsg_GetContourData(
            &key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
            FALSE,            
#endif // FSCFG_SUBPIXEL
            &CList.afxXCoord,
            &CList.afxYCoord,
            &CList.asStartPoint,
            &CList.asEndPoint,
            &CList.abyOnCurve,
            &CList.abyFc,
            &CList.usContourCount);

        error = fsc_RemoveDups(&CList);                 /* collapse dup'd points */
        if (error != NO_ERR)
        {
            return(error);
        }

        pGBMap = &key->GBMap;                           /* default to usual structure */
        usRoundXMin = 1;

        if (key->bGrayScale)                                 /* if doing gray scale */
        {
            error = fsc_OverScaleOutline(&CList, key->usOverScale);
            if (error != NO_ERR)
            {
                return(error);
            }
            pGBMap = &key->OverGBMap;                   /* measure overscaled structure */
            usRoundXMin = key->usOverScale;
        }
        
        fsg_GetWorkSpaceExtra(
            key->memoryBases[WORK_SPACE_BASE],
            &(key->WorkSpaceOffsets),
            &(key->WScan.pchRBuffer));
        key->WScan.lRMemSize = key->lExtraWorkSpace;    /* use extra for MeasureGlyph workspace */
        
        if (key->bBitmapEmboldening) 
        {
            if (key->bGrayScale)                                 /* if doing gray scale */
            {
                sBitmapEmboldeningHorExtra = key->usOverScale * key->sBoldSimulHorShift;
                sBitmapEmboldeningVertExtra = key->usOverScale * key->sBoldSimulVertShift;
            } 
#ifdef FSCFG_SUBPIXEL
            else if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
            {
                sBitmapEmboldeningHorExtra = RGB_OVERSCALE * key->sBoldSimulHorShift; 
                sBitmapEmboldeningVertExtra = key->sBoldSimulVertShift; 
            }
#endif // FSCFG_SUBPIXEL
            else
            {
                sBitmapEmboldeningHorExtra = key->sBoldSimulHorShift; 
                sBitmapEmboldeningVertExtra = key->sBoldSimulVertShift; 
            }
        }
        else
        {
            sBitmapEmboldeningHorExtra = 0;
            sBitmapEmboldeningVertExtra = 0;
        }

        error = fsc_MeasureGlyph(
            &CList, 
            pGBMap, 
            &key->WScan, 
            key->usScanType, 
            usRoundXMin,
            sBitmapEmboldeningHorExtra,
            sBitmapEmboldeningVertExtra );

        if (error == SMART_DROP_OVERFLOW_ERR)
        {
            /* glyph is too complex for the smart dropout control */
            key->usScanType &= ~SK_SMART;
            error = fsc_MeasureGlyph(
                &CList, 
                pGBMap, 
                &key->WScan, 
                key->usScanType, 
                usRoundXMin,
                sBitmapEmboldeningHorExtra,
                sBitmapEmboldeningVertExtra );
        }
        if (error != NO_ERR)
        {
            return(error);
        }
        Assert(key->WScan.lRMemSize < key->lExtraWorkSpace);
        
        if (key->bGrayScale)                                 /* if doing gray scale */
        {
            sOverScale = (int16)key->usOverScale;
            
            if (key->bMatchBBox)        /* if bounding box is fixed */
            {                                           /* the calc as if orig monochrome */
                pOverG = &key->OverGBMap;        
                pOrigB->left = (int16)((mth_DivShiftLong(pOverG->fxMinX, sOverScale) + 31L) >> 6);
                pOrigB->right = (int16)((mth_DivShiftLong(pOverG->fxMaxX, sOverScale) + 32L) >> 6);
                pOrigB->bottom = (int16)((mth_DivShiftLong(pOverG->fxMinY, sOverScale) + 31L) >> 6);
                pOrigB->top = (int16)((mth_DivShiftLong(pOverG->fxMaxY, sOverScale) + 32L) >> 6);

                /* force the bitmap to have at least one pixel wide and one pixel high */
                if (pOrigB->left == pOrigB->right)
                {
                    pOrigB->right++;                                /* force 1 pixel wide */
                }
                if (pOrigB->bottom == pOrigB->top)
                {
                    pOrigB->top++;                                /* force 1 pixel high */
                }

            }
            else                                        /* if bounding box can grow */
            {                                           /* then size to gray box */
                pOverB = &key->OverGBMap.rectBounds;        
                pOrigB->left = mth_DivShiftShort(pOverB->left, sOverScale);
                pOrigB->right = mth_DivShiftShort((int16)(pOverB->right + sOverScale - 1), sOverScale);
                pOrigB->bottom = mth_DivShiftShort(pOverB->bottom, sOverScale);
                pOrigB->top = mth_DivShiftShort((int16)(pOverB->top + sOverScale - 1), sOverScale);
            }
        }
        
        fsg_CalcLSBsAndAdvanceWidths(                   /* use original size for all metrics */
            &key->pWorkSpaceAddr,
            INTTODOT6(pOrigB->left),
            INTTODOT6(pOrigB->top),
            &f26DevAdvanceWidth,
            &f26DevLeftSideBearing,
            &f26LeftSideBearing,
            &f26DevLeftSideBearingLine,
            &f26LeftSideBearingLine);

        outputPtr->metricInfo.devAdvanceWidth.x        = DOT6TOFIX(f26DevAdvanceWidth.x);
        outputPtr->metricInfo.devAdvanceWidth.y        = DOT6TOFIX(f26DevAdvanceWidth.y);
        outputPtr->metricInfo.devLeftSideBearing.x     = DOT6TOFIX(f26DevLeftSideBearing.x);
        outputPtr->metricInfo.devLeftSideBearing.y     = DOT6TOFIX(f26DevLeftSideBearing.y);
        outputPtr->metricInfo.leftSideBearing.x        = DOT6TOFIX(f26LeftSideBearing.x);
        outputPtr->metricInfo.leftSideBearing.y        = DOT6TOFIX(f26LeftSideBearing.y);
        outputPtr->metricInfo.devLeftSideBearingLine.x = DOT6TOFIX(f26DevLeftSideBearingLine.x);
        outputPtr->metricInfo.devLeftSideBearingLine.y = DOT6TOFIX(f26DevLeftSideBearingLine.y);
        outputPtr->metricInfo.leftSideBearingLine.x    = DOT6TOFIX(f26LeftSideBearingLine.x);
        outputPtr->metricInfo.leftSideBearingLine.y    = DOT6TOFIX(f26LeftSideBearingLine.y);

        fsg_CalcTSBsAndAdvanceHeights(                   /* use original size for all metrics */
            &key->pWorkSpaceAddr,
            INTTODOT6(pOrigB->left),
            INTTODOT6(pOrigB->top),
            &f26DevAdvanceHeight,
            &f26DevTopSideBearing,
            &f26TopSideBearing,
            &f26DevTopSideBearingLine,
            &f26TopSideBearingLine);

        outputPtr->verticalMetricInfo.devAdvanceHeight.x      = DOT6TOFIX(f26DevAdvanceHeight.x);
        outputPtr->verticalMetricInfo.devAdvanceHeight.y      = DOT6TOFIX(f26DevAdvanceHeight.y);
        outputPtr->verticalMetricInfo.devTopSideBearing.x     = DOT6TOFIX(f26DevTopSideBearing.x);
        outputPtr->verticalMetricInfo.devTopSideBearing.y     = DOT6TOFIX(f26DevTopSideBearing.y);
        outputPtr->verticalMetricInfo.topSideBearing.x        = DOT6TOFIX(f26TopSideBearing.x);
        outputPtr->verticalMetricInfo.topSideBearing.y        = DOT6TOFIX(f26TopSideBearing.y);
        outputPtr->verticalMetricInfo.devTopSideBearingLine.x = DOT6TOFIX(f26DevTopSideBearingLine.x);
        outputPtr->verticalMetricInfo.devTopSideBearingLine.y = DOT6TOFIX(f26DevTopSideBearingLine.y);
        outputPtr->verticalMetricInfo.topSideBearingLine.x    = DOT6TOFIX(f26TopSideBearingLine.x);
        outputPtr->verticalMetricInfo.topSideBearingLine.y    = DOT6TOFIX(f26TopSideBearingLine.y);

        fsg_UpdateAdvanceWidth (&key->TransformInfo, pvGlobalGS, key->usNonScaledAW,
            &outputPtr->metricInfo.advanceWidth);

        fsg_UpdateAdvanceHeight (&key->TransformInfo, pvGlobalGS, key->usNonScaledAH,
            &outputPtr->verticalMetricInfo.advanceHeight);

        MEMCPY(&key->metricInfo, &outputPtr->metricInfo, sizeof( metricsType ));
        MEMCPY(&key->verticalMetricInfo, &outputPtr->verticalMetricInfo, sizeof( verticalMetricsType ));

        pBMI = &outputPtr->bitMapInfo;
        pBMI->bounds.top = pOrigB->bottom;              /* reversed! */
        pBMI->bounds.bottom = pOrigB->top;
        pBMI->baseAddr = 0;
        
#ifdef FSCFG_SUBPIXEL
        if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
        {
            if (!(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) )
            {
                /* in the SubPixel mode, key->TransformInfo is overscaled when we don't ask for compatible width */
                ROUND_FROM_HINT_OVERSCALE(outputPtr->metricInfo.advanceWidth.x);
                ROUND_FROM_HINT_OVERSCALE(outputPtr->verticalMetricInfo.advanceHeight.x);
            }
            ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devAdvanceWidth.x);
            ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devLeftSideBearing.x);
            ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.leftSideBearing.x);
            ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devLeftSideBearingLine.x);
            ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.leftSideBearingLine.x);
            ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devAdvanceHeight.x);
            ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devTopSideBearing.x);
            ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.topSideBearing.x);
            ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devTopSideBearingLine.x);
            ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.topSideBearingLine.x);

            pBMI->bounds.left = FLOOR_RGB_OVERSCALE(pOrigB->left);               /* return bbox to client */
            pBMI->bounds.right = CEIL_RGB_OVERSCALE(pOrigB->right);

            pBMI->rowBytes = ((pBMI->bounds.right - pBMI->bounds.left) + 3) & (-4);

            key->OverGBMap = key->GBMap;
            key->GBMap.sRowBytes = pBMI->rowBytes;
            key->GBMap.rectBounds.left = pBMI->bounds.left;
            key->GBMap.rectBounds.right = pBMI->bounds.right;
            key->GBMap.lMMemSize = (int32)pBMI->rowBytes * (int32)(key->GBMap.rectBounds.top - key->GBMap.rectBounds.bottom);
            outputPtr->memorySizes[BITMAP_PTR_4] = (FS_MEMORY_SIZE) key->OverGBMap.lMMemSize; 
        }
        else
        {
#endif // FSCFG_SUBPIXEL
            pBMI->bounds.left = pOrigB->left;               /* return bbox to client */
            pBMI->bounds.right = pOrigB->right;
            pBMI->rowBytes = key->GBMap.sRowBytes;
#ifdef FSCFG_SUBPIXEL
        }
#endif // FSCFG_SUBPIXEL

        if (key->bGrayScale)                                 /* if doing gray scale */
        {
            pBMI->rowBytes = ((pOrigB->right - pOrigB->left) + 3) & (-4);
            key->GBMap.lMMemSize = (int32)pBMI->rowBytes * (int32)(pOrigB->top - pOrigB->bottom);
            outputPtr->memorySizes[BITMAP_PTR_4] = (FS_MEMORY_SIZE) key->OverGBMap.lMMemSize; 
        }
        
        key->GBMap.sRowBytes = pBMI->rowBytes;
        outputPtr->memorySizes[BITMAP_PTR_1] = (FS_MEMORY_SIZE) key->GBMap.lMMemSize;
        outputPtr->memorySizes[BITMAP_PTR_2] = (FS_MEMORY_SIZE) key->WScan.lHMemSize;
        outputPtr->memorySizes[BITMAP_PTR_3] = (FS_MEMORY_SIZE) key->WScan.lVMemSize;

    }
    fsg_CheckWorkSpaceForFit(
        &(key->WorkSpaceOffsets),
        key->lExtraWorkSpace,
        key->WScan.lRMemSize,
        &(outputPtr->memorySizes[BITMAP_PTR_2]),
        &(outputPtr->memorySizes[BITMAP_PTR_3]));

    key->usBandType = FS_BANDINGOLD;                /* assume old banding */
    key->usBandWidth = 0;
    key->bOutlineIsCached = FALSE;                  /* assume no caching */

    fs_SetState(key,(INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN));

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

    STAT_OFF_FINDBMS;             /* stop STAT timer */
    
    return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    fs_SplineKey *     key;
    int32              ulSize;
    ErrorCode          error;

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTGLYPH | SIZEKNOWN), &error);
    if(!key)
    {
        return (FS_ENTRY)error;
    }

    if (key->bEmbeddedBitmap)
    {
        return SBIT_OUTLINE_CACHE_ERR;      /* can't cache sbits */
    }

    if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
    {
        fsg_UpdateWorkSpaceAddresses(
            key->memoryBases[WORK_SPACE_BASE],
            &(key->WorkSpaceOffsets),
            &(key->pWorkSpaceAddr));

        fsg_UpdateWorkSpaceElement(
            &(key->WorkSpaceOffsets),
            &(key->pWorkSpaceAddr));

        key->WScan.pchRBuffer = (char *)fsg_QueryReusableMemory(
        key->memoryBases[WORK_SPACE_BASE],
        &(key->WorkSpaceOffsets));

        MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
    }

    ulSize = (uint32)sizeof( uint32 );                         /* OUTLINESTAMP              */
    ulSize += (uint32)( sizeof( FS_MEMORY_SIZE ) * BITMAP_MEMORY_COUNT );   /* Memory Bases */
    ulSize += (uint32)( sizeof( uint32 ));                     /* Outlines Exist (padded)   */
    ulSize += (uint32)( sizeof( uint32 ));                     /* Scan Type (padded)        */
    ulSize += (uint32)( sizeof( uint32 ));                     /* Glyph Index (padded)      */
    ulSize += (uint32)( sizeof( uint32 ));                     /* Outline Cache Size        */
    ulSize += (uint32)( sizeof( uint32 ));                     /* Gray Scale Over Factor    */
    ulSize += (uint32)( sizeof( uint32 ));                     /* Grid Fit Skipped Boolean  */
    ulSize += (uint32)( sizeof( uint32 ));                     /* no embedded bitmap Boolean*/
    ulSize += (uint32)sizeof( metricsType );                   /* Metrics information       */
    ulSize += (uint32)sizeof( verticalMetricsType );           /* Vert metrics information  */
    ulSize += (uint32)sizeof( GlyphBitMap );                   /* Glyph Bitmap              */
    ulSize += (uint32)sizeof( GlyphBitMap );                   /* Gray Overscaled Bitmap    */
    ulSize += (uint32)sizeof( WorkScan );                      /* Scanconverter Workspace   */
    ulSize += (uint32)key->WScan.lRMemSize;                    /* Reversal list             */
    ulSize += fsg_GetContourDataSize(&key->pWorkSpaceAddr);    /* Contour Data              */
    ulSize += (uint32)sizeof( uint32 );                        /* OUTLINESTAMP2             */
    ALIGN(uint32, ulSize);

    outputPtr->outlineCacheSize = ulSize;
    key->ulGlyphOutlineSize = ulSize;

    return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    uint8 *            pbyDest;

    fs_SplineKey *     key;
    ErrorCode          error;

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTGLYPH | SIZEKNOWN), &error);

    if(!key)
    {
        return (FS_ENTRY)error;
    }

    if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
    {
        fsg_UpdateWorkSpaceAddresses(
            key->memoryBases[WORK_SPACE_BASE],
            &(key->WorkSpaceOffsets),
            &(key->pWorkSpaceAddr));

        fsg_UpdateWorkSpaceElement(
            &(key->WorkSpaceOffsets),
            &(key->pWorkSpaceAddr));

        MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
    }

    if( (outputPtr->memorySizes[BITMAP_PTR_2] == 0L) || (outputPtr->memorySizes[BITMAP_PTR_3] == 0L))
    {
        fsg_GetRealBitmapSizes(
            &(key->WorkSpaceOffsets),
            &outputPtr->memorySizes[BITMAP_PTR_2],
            &outputPtr->memorySizes[BITMAP_PTR_3]);
    }

    pbyDest = (uint8 *)inputPtr->param.outlineCache;

    *((uint32 *)pbyDest) = OUTLINESTAMP;
    pbyDest += sizeof( uint32 );

    *((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_1];
    pbyDest += sizeof( FS_MEMORY_SIZE  );

    *((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_2];
    pbyDest += sizeof( FS_MEMORY_SIZE  );

    *((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_3];
    pbyDest += sizeof( FS_MEMORY_SIZE  );

    *((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_4];
    pbyDest += sizeof( FS_MEMORY_SIZE   );
     
    /* Outlines exist state */

    *((uint32 *)pbyDest) = (uint32)key->bGlyphHasOutline;
    pbyDest += sizeof( uint32 );

    /* Dropout control state */

    *((uint32 *)pbyDest) = (uint32)key->usScanType;
    pbyDest += sizeof( uint32 );

    /* Glyph Index */

    *((uint32 *)pbyDest) = (uint32)key->ClientInfo.usGlyphIndex;
    pbyDest += sizeof( uint32 );

    /* Outline Cache Size */

    *((uint32 *)pbyDest) = (uint32)key->ulGlyphOutlineSize;
    pbyDest += sizeof( uint32 );

    /* Gray Over Scale Factor */

    *((uint32 *)pbyDest) = (uint32)key->usOverScale;
    pbyDest += sizeof( uint32 );

    /* Grid Fit Skipped Boolean  */

    *((uint32 *)pbyDest) = (uint32)key->bGridFitSkipped;
    pbyDest += sizeof( uint32 );

    /* No embedded bitmap Boolean  */

    *((uint32 *)pbyDest) = (uint32)key->bEmbeddedBitmap;
    pbyDest += sizeof( uint32 );

    /* Glyph metrics */

    MEMCPY(pbyDest, &key->metricInfo, sizeof(metricsType));
    pbyDest += sizeof(metricsType);

    MEMCPY(pbyDest, &key->verticalMetricInfo, sizeof(verticalMetricsType));
    pbyDest += sizeof(verticalMetricsType);

    /* Scan Converter Data Structures */

    MEMCPY(pbyDest, &key->GBMap, sizeof(GlyphBitMap));
    pbyDest += sizeof(GlyphBitMap);

    MEMCPY(pbyDest, &key->OverGBMap, sizeof(GlyphBitMap));
    pbyDest += sizeof(GlyphBitMap);

    MEMCPY(pbyDest, &key->WScan, sizeof(WorkScan));
    pbyDest += sizeof(WorkScan);

    MEMCPY(pbyDest, key->WScan.pchRBuffer, (size_t)key->WScan.lRMemSize);
    pbyDest += key->WScan.lRMemSize;

    /*** save charData ***/

    fsg_DumpContourData(&key->pWorkSpaceAddr, &pbyDest);

    *((uint32 *)pbyDest) = OUTLINESTAMP2;

    fs_SetState(key,(INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN));

    return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    fs_SplineKey *  key;
    uint8 *         pbySrc;
    ErrorCode       error;

    key = fs_SetUpKey(inputPtr, INITIALIZED, &error);
    if(!key)
    {
        return (FS_ENTRY)error;
    }

    pbySrc = (uint8 *)inputPtr->param.outlineCache;

    if ( *((uint32 *)pbySrc) != OUTLINESTAMP )
    {
        return TRASHED_OUTLINE_CACHE;
    }
    pbySrc += sizeof(uint32);

    outputPtr->memorySizes[BITMAP_PTR_1] = *((FS_MEMORY_SIZE *)pbySrc);
    pbySrc += sizeof( FS_MEMORY_SIZE   );

    outputPtr->memorySizes[BITMAP_PTR_2] = *((FS_MEMORY_SIZE *)pbySrc);
    pbySrc += sizeof( FS_MEMORY_SIZE   );

    outputPtr->memorySizes[BITMAP_PTR_3] = *((FS_MEMORY_SIZE *)pbySrc);
    pbySrc += sizeof( FS_MEMORY_SIZE   );

    outputPtr->memorySizes[BITMAP_PTR_4] = *((FS_MEMORY_SIZE *)pbySrc);
    pbySrc += sizeof( FS_MEMORY_SIZE    );

    /* Read in GlyphHasOutline */

    outputPtr->outlinesExist = (uint16)(*((uint32 *)pbySrc));
    pbySrc += sizeof( uint32 );

    /* Read ScanType state */

    key->usScanType = (uint16)(*((uint32 *)pbySrc));
    pbySrc += sizeof( uint32 );

    /* Read Glyph Index */

    outputPtr->glyphIndex = (uint16)(*((uint32 *)pbySrc));
    pbySrc += sizeof( uint32 );

    /* Read Size of Outline Cache  */

    outputPtr->outlineCacheSize = (uint16)(*((uint32 *)pbySrc));
    pbySrc += sizeof( uint32 );

    /* Read Gray Over Scale Factor  */

    key->usOverScale = (uint16)(*((uint32 *)pbySrc));
    outputPtr->usGrayLevels = key->usOverScale * key->usOverScale + 1;
    key->bGrayScale = (key->usOverScale == 0) ? FALSE : TRUE;
    pbySrc += sizeof( uint32 );

    /* Grid Fit Skipped Boolean  */

    key->bGridFitSkipped = (boolean)(*((uint32 *)pbySrc));
    pbySrc += sizeof( uint32 );

    /* No embedded bitmap Boolean  */

    key->bEmbeddedBitmap = (boolean)(*((uint32 *)pbySrc));
    pbySrc += sizeof( uint32 );

    /* Load fs_FindBitmapSize metrics */

    MEMCPY(&outputPtr->metricInfo, pbySrc, sizeof(metricsType));
    pbySrc += sizeof(metricsType);

    MEMCPY(&outputPtr->verticalMetricInfo, pbySrc, sizeof(verticalMetricsType));
    pbySrc += sizeof(verticalMetricsType);

    /* Load ScanConverter data structures */

    MEMCPY(&key->GBMap, pbySrc, sizeof(GlyphBitMap));
    pbySrc += sizeof(GlyphBitMap);

    MEMCPY(&key->OverGBMap, pbySrc, sizeof(GlyphBitMap));
    pbySrc += sizeof(GlyphBitMap);

    MEMCPY(&key->WScan, pbySrc, sizeof(WorkScan));
    pbySrc += sizeof(WorkScan);

    key->WScan.pchRBuffer = (char *)pbySrc;
    pbySrc += key->WScan.lRMemSize;

    fsg_RestoreContourData(
        &pbySrc,
        &outputPtr->xPtr,
        &outputPtr->yPtr,
        &outputPtr->startPtr,
        &outputPtr->endPtr,
        &outputPtr->onCurve,
        &outputPtr->fc,
        &outputPtr->numberOfContours);

    outputPtr->bitMapInfo.baseAddr = NULL;
    outputPtr->bitMapInfo.rowBytes = key->GBMap.sRowBytes;
    outputPtr->bitMapInfo.bounds.left = key->GBMap.rectBounds.left;
    outputPtr->bitMapInfo.bounds.right = key->GBMap.rectBounds.right;
    outputPtr->bitMapInfo.bounds.top = key->GBMap.rectBounds.bottom;   /* reversed! */
    outputPtr->bitMapInfo.bounds.bottom = key->GBMap.rectBounds.top;

    outputPtr->scaledCVT = NULL;
    outputPtr->numberOfBytesTaken = 0;

    key->usBandType = FS_BANDINGOLD;                    /* assume old banding */
    key->usBandWidth = 0;
    key->apbPrevMemoryBases[BITMAP_PTR_2] = NULL;       /* for fast/faster check */
    key->apbPrevMemoryBases[BITMAP_PTR_3] = NULL;

    key->bOutlineIsCached = TRUE;

    fs_SetState(key,(INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN));
    return NO_ERR;
}

/*********************************************************************/

/* Calculate memory requirements for banding                         */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBandingSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    ErrorCode       error;
    fs_SplineKey *  key;
    uint8 *         pbyOutline;
    int16           sMaxOvershoot;
    int16           sHiOvershoot;
    int16           sLoOvershoot;
    GlyphBitMap *   pGBMap;             /* orig or over pointer */


    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN), &error);
    if(!key)
    {
        return (FS_ENTRY)error;
    }

    if (key->bGridFitSkipped || key->bEmbeddedBitmap)
    {
        return SBIT_BANDING_ERR;                /* can't band sbits */
    }
    
    if( !key->bOutlineIsCached )
    {
        CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
        key->WScan.pchRBuffer = (char *)fsg_QueryReusableMemory(
            key->memoryBases[WORK_SPACE_BASE],
            &(key->WorkSpaceOffsets));
    }
    else
    {
        /* Unload the outline cache */

        pbyOutline = (uint8 *)inputPtr->param.band.outlineCache;

        if( *((uint32 *)pbyOutline) != OUTLINESTAMP )
        {
              return TRASHED_OUTLINE_CACHE;
        }

        pbyOutline += sizeof( uint32 ) +
              (BITMAP_MEMORY_COUNT * sizeof (FS_MEMORY_SIZE))  /* !!! Skip over stamp & 3 bitmap sizes */
              + sizeof( uint32 )                      /* Outlines Exist (padded)  */
              + sizeof( uint32 )                      /* Scan Type (padded)        */
              + sizeof( uint32 )                      /* Glyph Index (padded)      */
              + sizeof( uint32 )                      /* Outline Cache Size        */
              + sizeof( uint32 )                      /* Gray Over Scale Factor    */
              + sizeof( uint32 )                      /* Grid Fit Skipped Boolean  */
              + sizeof( uint32 )                      /* no embedded bitmap Boolean*/
              + sizeof( metricsType )                 /* Metrics information       */
              + sizeof( verticalMetricsType )         /* Vert metrics information  */
              + sizeof( GlyphBitMap )
              + sizeof( GlyphBitMap )                 /* Over Scale structure      */
              + sizeof( WorkScan );

        key->WScan.pchRBuffer = (char *)pbyOutline;

        /* No need to further unload outline cache */
    }

    pGBMap = &key->GBMap;                           /* default usual structure */
    key->usBandWidth = inputPtr->param.band.usBandWidth;
    key->usBandType = inputPtr->param.band.usBandType;

    if (key->bGrayScale)                                 /* if doing gray scale */
    {
        pGBMap = &key->OverGBMap;                   /* measure overscaled structure */
        key->usBandWidth *= key->usOverScale;
/*  
 *  Band width for the over scaled bitmap is basically just the requested band 
 *  width times the overscale factor.  However! if the gray scaled bounding 
 *  box has been trimmed to match the monochrome box (i.e. bMatchBBox = TRUE),
 *  then top and bottom bands must be made bigger to include the entire over
 *  scaled bitmap.  If this were not done it would break dropout control, and
 *  bitmaps would change with banding.  So that's why we do this messing around
 *  with overshoot in the key->usBandWidth calculation.
 */
        sMaxOvershoot = 0;
        sHiOvershoot = (int16)(key->OverGBMap.rectBounds.top -
                       key->GBMap.rectBounds.top * (int16)key->usOverScale);
        if (sHiOvershoot > sMaxOvershoot)
        {
            sMaxOvershoot = sHiOvershoot;
        }
        sLoOvershoot = (int16)(key->GBMap.rectBounds.bottom * (int16)key->usOverScale -
                       key->OverGBMap.rectBounds.bottom);
        if (sLoOvershoot > sMaxOvershoot)
        {
            sMaxOvershoot = sLoOvershoot;
        }
        key->usBandWidth += (uint16)sMaxOvershoot;
    }

    error = fsc_MeasureBand(
        pGBMap,                     /* orig or over scaled bounding box, etc. */
        &key->WScan,
        key->usBandType,
        key->usBandWidth,           /* worst case band width */
        key->usScanType );
    if (error != NO_ERR)
    {
        return(error);
    }

    if (key->bGrayScale)                                 /* if doing gray scale */
    {
        key->GBMap.lMMemSize = (int32)key->GBMap.sRowBytes * (int32)inputPtr->param.band.usBandWidth;
        outputPtr->memorySizes[BITMAP_PTR_4] = (FS_MEMORY_SIZE) key->OverGBMap.lMMemSize;
    }
    
    outputPtr->memorySizes[BITMAP_PTR_1] = (FS_MEMORY_SIZE) key->GBMap.lMMemSize;
    outputPtr->memorySizes[BITMAP_PTR_2] = (FS_MEMORY_SIZE) key->WScan.lHMemSize;
    outputPtr->memorySizes[BITMAP_PTR_3] = (FS_MEMORY_SIZE) key->WScan.lVMemSize;
    
    if( !key->bOutlineIsCached )
    {
        fsg_CheckWorkSpaceForFit(
            &(key->WorkSpaceOffsets),
            key->lExtraWorkSpace,
            key->WScan.lRMemSize,                             /* MeasureGlyph workspace */
            &(outputPtr->memorySizes[BITMAP_PTR_2]),
            &(outputPtr->memorySizes[BITMAP_PTR_3]));
    }

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
    if( !key->bOutlineIsCached )
    {
        CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    }

    return NO_ERR;
}

/*********************************************************************/

#ifdef FSCFG_CONVERT_GRAY_LEVELS

// Tables to speed up bitmap translation from different GrayLevels.
uint8 Gray4To5Table[4]= {0,1,3,4};
uint8 Gray16To5Table[16]={0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4};

uint8 Gray4To17Table[4]= {0,5,11,16};
uint8 Gray16To17Table[16]={0,1,2,3,4,5,6,7,9,10,11,12,13,14,15,16};

uint8 Gray4To65Table[4]= {0,21,43,64};
uint8 Gray16To65Table[16]={0,4,9,13,17,21,26,30,34,38,43,47,51,55,60,64};

FS_PRIVATE FS_ENTRY  fs_ConvertGrayLevels (fs_GlyphInfoType *outputPtr, uint16 usOverScale, uint16 usBitDepth);

FS_PRIVATE FS_ENTRY  fs_ConvertGrayLevels (fs_GlyphInfoType *outputPtr, uint16 usOverScale, uint16 usBitDepth)
    {
      uint16    index; // Gray level xlate table index
      switch (usOverScale) {
       case 2:
           {
             uint32 i;
             uint32 bitmapSize=0;
             bitmapSize = (outputPtr->bitMapInfo.bounds.bottom - outputPtr->bitMapInfo.bounds.top)
                         *(outputPtr->bitMapInfo.rowBytes);

             switch (usBitDepth) {
             case 2:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x03);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray4To5Table[index];
                } /* endfor */
                break;
             case 4:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x0f);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To5Table[index];
                } /* endfor */            
                break;
             case 8:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])>>4);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To5Table[index];
                } /* endfor */
                break;

             default:
                  return BAD_GRAY_LEVEL_ERR;
          
             } /* endswitch */
           }
          break;
       case 4:
           {
             uint32 i;
             uint32 bitmapSize=0;
             bitmapSize = (outputPtr->bitMapInfo.bounds.bottom - outputPtr->bitMapInfo.bounds.top)
                         *(outputPtr->bitMapInfo.rowBytes);

             switch (usBitDepth) {
             case 2:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x03);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray4To17Table[index];
                } /* endfor */
                break;
             case 4:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x0f);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To17Table[index];
                } /* endfor */            
                break;
             case 8:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])>>4);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To17Table[index];
                } /* endfor */
                break;

             default:
                  return BAD_GRAY_LEVEL_ERR;
          
             } /* endswitch */
           }
          break;
       case 8:
           {
             uint32 i;
             uint32 bitmapSize=0;
             bitmapSize = (outputPtr->bitMapInfo.bounds.bottom - outputPtr->bitMapInfo.bounds.top)
                         *(outputPtr->bitMapInfo.rowBytes);

             switch (usBitDepth) {
             case 2:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x03);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray4To65Table[index];
                } /* endfor */
                break;
             case 4:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x0f);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To65Table[index];
                } /* endfor */            
                break;
             case 8:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])>>4);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To65Table[index];
                } /* endfor */
                break;

             default:
                  return BAD_GRAY_LEVEL_ERR;
          
             } /* endswitch */
           }
          break;

       default:
               return BAD_GRAY_LEVEL_ERR;
       } /* endswitch */
       return NO_ERR;

    } /* end if bGrayScale */

#endif // FSCFG_CONVERT_GRAY_LEVELS

/* Generate a bitmap                                                 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{    
    ContourList     CList;        /* newscan contour list type */
    fs_SplineKey *  key;
    char *          pBitmapPtr2;
    char *          pBitmapPtr3;
    uint8 *         pbyOutline;
    ErrorCode       error;
    GlyphBitMap *   pGBMap;             /* orig or over pointer */


    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

    STAT_ON_SCAN;                    /* start STAT timer */

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN), &error);
    if(!key)
    {
        return (FS_ENTRY)error;
    }

    if( !key->bOutlineIsCached )                /* if outline or embedded bitmap */
    {
        CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);

        if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
        {
            fsg_UpdateWorkSpaceAddresses(
                 key->memoryBases[WORK_SPACE_BASE],
                 &(key->WorkSpaceOffsets),
                 &(key->pWorkSpaceAddr));

            fsg_UpdateWorkSpaceElement(
                 &(key->WorkSpaceOffsets),
                 &(key->pWorkSpaceAddr));

            key->apbPrevMemoryBases[WORK_SPACE_BASE] = key->memoryBases[WORK_SPACE_BASE];
        }

        fsg_SetUpWorkSpaceBitmapMemory(
            key->memoryBases[WORK_SPACE_BASE],
            &(key->WorkSpaceOffsets),
            key->memoryBases[BITMAP_PTR_2],
            key->memoryBases[BITMAP_PTR_3],
            &pBitmapPtr2,                       /* sbits may need Ptr2 */
            &pBitmapPtr3);

        /* check for embedded bitmap, quick return if found */

#ifdef FSCFG_SUBPIXEL
        if (key->bEmbeddedBitmap && !(key->flSubPixel & FNT_SP_SUB_PIXEL))                  /* if bitmap are not disabled */
#else
        if (key->bEmbeddedBitmap)               /* if bitmap are not disabled */
#endif // FSCFG_SUBPIXEL    
        {
            if ((inputPtr->param.scan.topClip > inputPtr->param.scan.bottomClip) &&  /* if legal band */
               ((inputPtr->param.scan.topClip < key->GBMap.rectBounds.top) ||
                (inputPtr->param.scan.bottomClip > key->GBMap.rectBounds.bottom)))
            {
                return SBIT_BANDING_ERR;            /* can't band sbits */
            }

            error = sbit_GetBitmap (
                &key->SbitMono,
                &key->ClientInfo,
                (uint8 *) inputPtr->memoryBases[BITMAP_PTR_1],
                (uint8 *) pBitmapPtr2 );
        
            if (error != NO_ERR)
            {
                return((FS_ENTRY)error);
            }
            outputPtr->bitMapInfo.baseAddr = key->memoryBases[BITMAP_PTR_1];  /* return bitmap addr */

            CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
            CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);

            STAT_OFF_SCAN;                  /* stop STAT timer */

#ifdef FSCFG_CONVERT_GRAY_LEVELS
            if (key->bGrayScale)
            {
                error = fs_ConvertGrayLevels (outputPtr, key->usOverScale, key->SbitMono.usBitDepth);
            
                if(error)
                {
                    return (FS_ENTRY)error;
                }
            } /* end if bGrayScale */
#endif // FSCFG_CONVERT_GRAY_LEVELS

            return NO_ERR;                  /* return now with an sbit */
        }
        else        /* if scan converting an outline */
        {
            fsg_GetWorkSpaceExtra(
                key->memoryBases[WORK_SPACE_BASE],
                &(key->WorkSpaceOffsets),
                &(key->WScan.pchRBuffer));

            fsg_GetContourData(
                &key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
                FALSE,            
#endif // FSCFG_SUBPIXEL
                &CList.afxXCoord,
                &CList.afxYCoord,
                &CList.asStartPoint,
                &CList.asEndPoint,
                &CList.abyOnCurve,
                &CList.abyFc,
                &CList.usContourCount);
        }
    }
    else            /* Unload the outline cache */
    {
        pbyOutline = (uint8 *)inputPtr->param.scan.outlineCache;

        if( *((uint32 *)pbyOutline) != OUTLINESTAMP )
        {
             return TRASHED_OUTLINE_CACHE;
        }

        pbyOutline += sizeof( uint32 ) +
            (BITMAP_MEMORY_COUNT * sizeof (FS_MEMORY_SIZE))  /* !!! Skip over stamp & 3 bitmap sizes */
            + sizeof( uint32 )                      /* Outlines Exist (padded)  */
            + sizeof( uint32 )                      /* Scan Type (padded)        */
            + sizeof( uint32 )                      /* Glyph Index (padded)      */
            + sizeof( uint32 )                      /* Outline Cache Size        */
            + sizeof( uint32 )                      /* Gray Over Scale Factor    */
            + sizeof( uint32 )                      /* Grid Fit Skipped Boolean  */
            + sizeof( uint32 )                      /* no embedded bitmap Boolean*/
            + sizeof( metricsType )                 /* Metrics information       */
            + sizeof( verticalMetricsType )         /* Vert metrics information  */
            + sizeof( GlyphBitMap )
            + sizeof( GlyphBitMap )                 /* Over Scale structure      */
            + sizeof( WorkScan );

        key->WScan.pchRBuffer = (char *)pbyOutline;
        pbyOutline += key->WScan.lRMemSize;

        fsg_RestoreContourData(
            &pbyOutline,
            &CList.afxXCoord,
            &CList.afxYCoord,
            &CList.asStartPoint,
            &CList.asEndPoint,
            &CList.abyOnCurve,
            &CList.abyFc,
            &CList.usContourCount);

        if( *((uint32 *)pbyOutline) != OUTLINESTAMP2 )
        {
            return TRASHED_OUTLINE_CACHE;
        }

        pBitmapPtr2 = key->memoryBases[BITMAP_PTR_2];
        pBitmapPtr3 = key->memoryBases[BITMAP_PTR_3];
    }

    if (pBitmapPtr3 == NULL)  /* Allow client to turn off DOControl */
    {
        key->usScanType = SK_NODROPOUT;
    }

    key->GBMap.pchBitMap = inputPtr->memoryBases[BITMAP_PTR_1];
    key->GBMap.sHiBand = inputPtr->param.scan.topClip;
    key->GBMap.sLoBand = inputPtr->param.scan.bottomClip;

    if (key->GBMap.sHiBand <= key->GBMap.sLoBand)            /* if negative or no band */
    {
        key->GBMap.sHiBand = key->GBMap.rectBounds.top;     /* then for Apple compatiblity */
        key->GBMap.sLoBand = key->GBMap.rectBounds.bottom;  /* do the entire bitmap */
    }
    if (key->GBMap.sHiBand > key->GBMap.rectBounds.top)
    {
        key->GBMap.sHiBand = key->GBMap.rectBounds.top;     /* clip to bounding box */
    }
    if (key->GBMap.sLoBand < key->GBMap.rectBounds.bottom)
    {
        key->GBMap.sLoBand = key->GBMap.rectBounds.bottom;  /* clip to bounding box */
    }
         
    if ((key->usBandType == FS_BANDINGFASTER) &&
        ((key->apbPrevMemoryBases[BITMAP_PTR_2] != pBitmapPtr2) ||
         (key->apbPrevMemoryBases[BITMAP_PTR_3] != pBitmapPtr3)))
    {
         key->usBandType = FS_BANDINGFAST;  /* to recalculate memory */
    }

    if (key->usBandType == FS_BANDINGOLD)   /* if FindGrayBandingSize wasn't called */
    {
        if ((key->GBMap.sHiBand != key->GBMap.rectBounds.top) ||
            (key->GBMap.sLoBand != key->GBMap.rectBounds.bottom))   /* if banding */
        {
            if (key->bGrayScale)
            {
                return GRAY_OLD_BANDING_ERR;        /* gray scale fails with old banding */
            }
            key->usScanType = SK_NODROPOUT;         /* else force dropout off */
        }
    }
    else if (key->usBandType == FS_BANDINGSMALL)  /* if small mem type */
    {
        if (key->bGrayScale)
        {
            if (key->usOverScale *(key->GBMap.sHiBand - key->GBMap.sLoBand) > (int16)key->usBandWidth)
            {
                return BAND_TOO_BIG_ERR;          /* don't let band exceed calc'd size */
            }
        } else {
            if (key->GBMap.sHiBand - key->GBMap.sLoBand > (int16)key->usBandWidth)
            {
                return BAND_TOO_BIG_ERR;          /* don't let band exceed calc'd size */
            }
        }
        key->usScanType = SK_NODROPOUT;       /* turn off dropout control */
    }
    pGBMap = &key->GBMap;                     /* default to usual structure */
    
    if (key->bGrayScale)
    {
        pGBMap = &key->OverGBMap;             /* measure overscaled structure */
        
        if (key->GBMap.sHiBand == key->GBMap.rectBounds.top)            /* if gray band at top */
        {
            key->OverGBMap.sHiBand = key->OverGBMap.rectBounds.top;     /* use over top */
        }
        else
        {
            key->OverGBMap.sHiBand = (int16)(key->GBMap.sHiBand * (int16)key->usOverScale);
            if (key->OverGBMap.sHiBand > key->OverGBMap.rectBounds.top)
            {
                key->OverGBMap.sHiBand = key->OverGBMap.rectBounds.top; /* clip */
            }
        }
        if (key->GBMap.sLoBand == key->GBMap.rectBounds.bottom)         /* if gray band at bottom */
        {
            key->OverGBMap.sLoBand = key->OverGBMap.rectBounds.bottom;  /* use over bottom */
        }
        else
        {
            key->OverGBMap.sLoBand = (int16)(key->GBMap.sLoBand * (int16)key->usOverScale);
            if (key->OverGBMap.sLoBand < key->OverGBMap.rectBounds.bottom)
            {
                key->OverGBMap.sLoBand = key->OverGBMap.rectBounds.bottom;  /* clip */
            }
        }
        key->OverGBMap.pchBitMap = inputPtr->memoryBases[BITMAP_PTR_4];
    }
#ifdef FSCFG_SUBPIXEL
    if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
    {
        pGBMap = &key->OverGBMap;             /* draw into the overscaled structure */

        key->OverGBMap.pchBitMap = inputPtr->memoryBases[BITMAP_PTR_4];

        /* no banding yet !!! */
        key->OverGBMap.sHiBand = key->OverGBMap.rectBounds.top;
        key->OverGBMap.sLoBand = key->OverGBMap.rectBounds.bottom;
    }
#endif // FSCFG_SUBPIXEL

    key->WScan.pchHBuffer = pBitmapPtr2;
    key->WScan.pchVBuffer = pBitmapPtr3;

    error = fsc_FillGlyph(
        &CList,
        pGBMap,
        &key->WScan,
        key->usBandType,
        key->usScanType
        );
    if (error != NO_ERR)
    {
        return(error);
    }
     
    if (key->bGrayScale)
    {
        error = fsc_CalcGrayMap(
            &key->OverGBMap, 
            &key->GBMap, 
            key->usOverScale
            );
        if (error != NO_ERR)
        {
            return((FS_ENTRY)error);
        }
    }

#ifdef FSCFG_SUBPIXEL
    if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
    {
#ifdef FSCFG_SUBPIXEL_STANDALONE // B.St.
        outputPtr->overscaledBitmapInfo.baseAddr = key->OverGBMap.pchBitMap;
        outputPtr->overscaledBitmapInfo.rowBytes = key->OverGBMap.sRowBytes;
        outputPtr->overscaledBitmapInfo.bounds = key->OverGBMap.rectBounds; // save for more detailed processing
#endif
        fsc_OverscaleToSubPixel (&key->OverGBMap, (key->flSubPixel & FNT_SP_BGR_ORDER) > 0, &key->GBMap);
    }
#endif // FSCFG_SUBPIXEL

    if (key->bBitmapEmboldening)
    {
        if (key->bGrayScale)
        {
            uint16 usGrayLevels = key->usOverScale * key->usOverScale + 1;
            sbit_EmboldenGray((uint8 *)key->GBMap.pchBitMap, (uint16)(key->GBMap.rectBounds.right - key->GBMap.rectBounds.left), 
                          (uint16)(key->GBMap.sHiBand - key->GBMap.sLoBand), key->GBMap.sRowBytes,usGrayLevels, key->sBoldSimulHorShift, key->sBoldSimulVertShift);
        } 
#ifdef FSCFG_SUBPIXEL
        else if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
        {
            sbit_EmboldenSubPixel((uint8 *)key->GBMap.pchBitMap, (uint16)(key->GBMap.rectBounds.right - key->GBMap.rectBounds.left), 
                          (uint16)(key->GBMap.sHiBand - key->GBMap.sLoBand), key->GBMap.sRowBytes, key->sBoldSimulHorShift, key->sBoldSimulVertShift);
        } 
#endif // FSCFG_SUBPIXEL
        else 
        {
            sbit_Embolden((uint8 *)pGBMap->pchBitMap, (uint16)(pGBMap->rectBounds.right - pGBMap->rectBounds.left), 
                          (uint16)(pGBMap->sHiBand - pGBMap->sLoBand), pGBMap->sRowBytes, key->sBoldSimulHorShift, key->sBoldSimulVertShift);
        }
    }

/*  Setting the Band Type to FS_BANDINGFASTER will allow the next call      */
/*  to fsc_FillGlyph to skip the rendering phase of scan conversion and     */
/*  get right to the bitmap fill.  If the client moves either memoryBase[6] */ 
/*  or memoryBase[7] between fs_ContourScan calls, then we must reset the   */
/*  band type to FS_BANDINGFAST to regenerate the data structures.          */

    if (key->usBandType == FS_BANDINGFAST)
    {
        key->usBandType = FS_BANDINGFASTER;    /* to save re-rendering */
        key->apbPrevMemoryBases[BITMAP_PTR_2] = pBitmapPtr2;
        key->apbPrevMemoryBases[BITMAP_PTR_3] = pBitmapPtr3;
    }

    outputPtr->bitMapInfo.baseAddr = key->memoryBases[BITMAP_PTR_1];  /* return bitmap addr */

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
    if( !key->bOutlineIsCached )
    {
        CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    }

    STAT_OFF_SCAN;                /* stop STAT timer */

    return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    FS_UNUSED_PARAMETER(inputPtr);
    FS_UNUSED_PARAMETER(outputPtr);
    return NO_ERR;
}

#ifdef  FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC  void FS_ENTRY_PROTO fs_InitializeData (void)
    {
        fsg_InitializeData ();
    }
#endif



/*********************************************************************/

/* fs_GetScaledAdvanceWidths returns only horizontal advance widths and is not meant to be used under rotation */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceWidths (
    fs_GlyphInputType * inputPtr,
    uint16              usFirstGlyph,
    uint16              usLastGlyph,
    int16 *             psGlyphWidths)
{
    fs_SplineKey *      key;
    void *              pvGlobalGS;
    void *              pvStack;
    void *              pvFontProgram;
    void *              pvPreProgram;
    void *              pvTwilightZone;
    uint16              usCurrentGlyphIndex;
    uint16              usGlyphIndex;
    uint16              usPPEm;
    int16               sNonScaledLSB;
    vectorType          fxGlyphWidth;
    point               f26DevAdvanceWidth;
    boolean             bHdmxEntryExist;
    boolean             bBitmapFound;
    ErrorCode           error;
#ifdef FSCFG_SUBPIXEL   
    boolean             bSubPixelWidth = FALSE;
    fsg_TransformRec *  TransformInfoForGridFit;
    void *              pvGlobalGSSubPixel;
    void *              pvTwilightZoneSubPixel;
#endif // FSCFG_SUBPIXEL

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS ), &error);

    if(!key)
    {
        return (FS_ENTRY)error;
    }

    if((key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE]) ||
       (key->apbPrevMemoryBases[PRIVATE_FONT_SPACE_BASE] != key->memoryBases[PRIVATE_FONT_SPACE_BASE]))
    {
        fsg_UpdateWorkSpaceAddresses(
            key->memoryBases[WORK_SPACE_BASE],
            &(key->WorkSpaceOffsets),
            &(key->pWorkSpaceAddr));

        pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

        fsg_UpdatePrivateSpaceAddresses(
            &key->ClientInfo,
            &key->maxProfile,
            key->memoryBases[PRIVATE_FONT_SPACE_BASE],
            &(key->PrivateSpaceOffsets),
            pvStack,
            &pvFontProgram,
            &pvPreProgram);

        MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
    }

    pvGlobalGS = fsg_QueryGlobalGS(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

    /*  Initialization  */

    bHdmxEntryExist = FALSE;

#ifdef FSCFG_SUBPIXEL   
    if ( (key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) ) 
    {
        bSubPixelWidth = TRUE;
    }
#endif // FSCFG_SUBPIXEL    

    /*  Save current glyph index    */

    usCurrentGlyphIndex = key->ClientInfo.usGlyphIndex;

    /*  Check input parameters  */

    if( (usLastGlyph > key->maxProfile.numGlyphs ) ||
        (usLastGlyph < usFirstGlyph))
    {
        return INVALID_GLYPH_INDEX;
    }

    if( psGlyphWidths == NULL )
    {
        return NULL_INPUT_PTR_ERR;
    }

    /*  Find our current PPEm   */

    fsg_QueryPPEM(pvGlobalGS, &usPPEm);
    /* Only Grab 'hdmx' if not stretched or rotated */

#ifdef FSCFG_SUBPIXEL   
    /* for SubPixel, use Hdmx width only if we are in compatible width mode */
    if( !bSubPixelWidth &&
        (!fsg_IsTransformStretched( &key->TransformInfo )) &&
        (!fsg_IsTransformRotated( &key->TransformInfo )) )
#else
    if( (!fsg_IsTransformStretched( &key->TransformInfo )) &&
        (!fsg_IsTransformRotated( &key->TransformInfo )) )
#endif // FSCFG_SUBPIXEL    
    {

        /*  Check if we can quickly grab the widths from the 'hdmx' table   */

        error = sfac_CopyHdmxEntry(
            &key->ClientInfo,
            usPPEm,
            &bHdmxEntryExist,
            usFirstGlyph,
            usLastGlyph,
            psGlyphWidths);

        if (error != NO_ERR)
        {
            return(error);
        }

        /* If we got a hit on the 'hdmx' we are done    */

        if( bHdmxEntryExist )
        {
            return NO_ERR;
        }
    }

    /* No hit on 'hmdx', now it is time for the dirty work  */

    /* We need to prepare ourselves here for a potential grid fit */

    fsg_UpdateWorkSpaceElement(
        &(key->WorkSpaceOffsets),
        &(key->pWorkSpaceAddr));

    pvTwilightZone = fsg_QueryTwilightElement(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

#ifdef FSCFG_SUBPIXEL
    TransformInfoForGridFit = &key->TransformInfo;
    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
        pvGlobalGSSubPixel = fsg_QueryGlobalGSSubPixel(
            key->memoryBases[PRIVATE_FONT_SPACE_BASE],
            &(key->PrivateSpaceOffsets));
        pvTwilightZoneSubPixel = fsg_QueryTwilightElementSubPixel(
            key->memoryBases[PRIVATE_FONT_SPACE_BASE],
            &(key->PrivateSpaceOffsets));
    }
#endif // FSCFG_SUBPIXEL

    /*  potentially do delayed pre program execution */

    if (key->bExecutePrePgm)
    {
        /* Run the pre program and scale the control value table */

        key->bExecutePrePgm = FALSE;

        error = fsg_RunPreProgram (
            &key->ClientInfo,
            &key->maxProfile,
            &key->TransformInfo,
            pvGlobalGS,
            &key->pWorkSpaceAddr,
            pvTwilightZone,
            NULL);

        if(error)
        {
            /* If the pre-program fails, prevent further glyphs from being called */
            fs_SetState(key, (INITIALIZED | NEWSFNT));

            /* If the pre-program fails, switch off hinting for further glyphs */
            key->bHintingEnabled = FALSE;
            return (FS_ENTRY)error;
        }
#ifdef FSCFG_SUBPIXEL   
        if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
        {
            error = fsg_RunPreProgram (
                &key->ClientInfo,
                &key->maxProfile,
                &key->TransformInfoSubPixel,
                pvGlobalGSSubPixel,
                &key->pWorkSpaceAddr,
                pvTwilightZoneSubPixel,
                NULL);

            if(error)
            {
                /* If the pre-program fails, prevent further glyphs from being called */
                fs_SetState(key, (INITIALIZED | NEWSFNT));

                /* If the pre-program fails, switch off hinting for further glyphs */
                key->bHintingEnabled = FALSE;
                return (FS_ENTRY)error;
            }
        }
#endif // FSCFG_SUBPIXEL    
    }

    /*  Now check 'LTSH' table for linear cutoff information    */

    error = sfac_GetLTSHEntries(
        &key->ClientInfo,
        usPPEm,
        usFirstGlyph,
        usLastGlyph,
        psGlyphWidths);

    /* The pfxGlyphWidths array contains a boolean for each glyph (from     */
    /* first glyph to last glyph) that indicates if the glyph scales        */
    /* linearly.                                                            */

    /* Handle each glyph    */

    for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++)
    {
#ifdef FSCFG_SUBPIXEL
        /* for SubPixel, use linear width only if we are in compatible width mode */
        if( !bSubPixelWidth &&
            (psGlyphWidths[usGlyphIndex - usFirstGlyph]) &&
            (!fsg_IsTransformStretched( &key->TransformInfo )) &&
            (!fsg_IsTransformRotated( &key->TransformInfo )) )
#else
        if( (psGlyphWidths[usGlyphIndex - usFirstGlyph]) &&
            (!fsg_IsTransformStretched( &key->TransformInfo )) &&
            (!fsg_IsTransformRotated( &key->TransformInfo )) )
#endif // FSCFG_SUBPIXEL    
        {
            /* Glyph Scales Linearly    */


        error = sfac_ReadGlyphHorMetrics (
                &key->ClientInfo,
                usGlyphIndex,
                &key->usNonScaledAW,
                &sNonScaledLSB);

            if(error)
            {
                return (FS_ENTRY)error;
            }

            fsg_UpdateAdvanceWidth (
                &key->TransformInfo,
                pvGlobalGS,
                key->usNonScaledAW,
                &fxGlyphWidth);

            psGlyphWidths[usGlyphIndex - usFirstGlyph] = (int16)((fxGlyphWidth.x + ONEHALFFIX) >> 16);
        }
        else    /* Glyph does not scale linearly */
        {
            error = LookForSbitAdvanceWidth (
                key, 
                usGlyphIndex, 
                &bBitmapFound, 
                &f26DevAdvanceWidth );          /* value returned if found */
            
            if(error)
            {
                return (FS_ENTRY)error;
            }

            if (bBitmapFound == FALSE)
            {
                /* Glyph needs to be grid fitted */

                key->ClientInfo.usGlyphIndex = usGlyphIndex;

                error = fsg_GridFit (
                    &key->ClientInfo,
                    &key->maxProfile,
                    &key->TransformInfo,
                    pvGlobalGS,
                    &key->pWorkSpaceAddr,
                    pvTwilightZone,
                    (FntTraceFunc)NULL,
                    TRUE,
                    &key->usScanType,
                    &key->bGlyphHasOutline,
                    &key->usNonScaledAW,
                    key->bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
                    ,bSubPixelWidth
#endif // FSCFG_SUBPIXEL
                    );

                if(error)
                {
                    return (FS_ENTRY)error;
                }

                fsg_GetDevAdvanceWidth (
                    &key->pWorkSpaceAddr,
                    &f26DevAdvanceWidth );
#ifdef FSCFG_SUBPIXEL
                if (bSubPixelWidth)
                /* we need to scale the value downs from hinting overscale */
                {
                    ROUND_FROM_HINT_OVERSCALE(f26DevAdvanceWidth.x);
                }
#endif // FSCFG_SUBPIXEL
            }
            psGlyphWidths[(size_t)(usGlyphIndex - usFirstGlyph)] = (int16)((f26DevAdvanceWidth.x + DOT6ONEHALF) >> 6);
        }
    }

    /* Restore current glyph    */

    key->ClientInfo.usGlyphIndex = usCurrentGlyphIndex;
    
    return NO_ERR;
}

/*********************************************************************/

/*                  Vertical Metrics Helper Function                 */

/*            returns AdvanceHeight vectors for glyph range          */

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceHeights (
    fs_GlyphInputType * inputPtr,
    uint16              usFirstGlyph,
    uint16              usLastGlyph,
    shortVector *       psvAdvanceHeights)
{
    fs_SplineKey *      key;
    void *              pvGlobalGS;
    void *              pvFontProgram;
    void *              pvPreProgram;
    void *              pvStack;
    uint16              usGlyphIndex;
    uint16              usPPEm;
    uint16              usNonScaledAH;              /* advance height from vmtx */
    int16               sNonScaledTSB;              /* top side bearing from vmtx, not used */
    shortVector         svDevAdvanceHeight;         /* advance height from sbits */
    vectorType          vecAdvanceHeight;
    vectorType          vecTopSideBearing;          /* not used */
    point               f26DevAdvanceHeight;
    boolean             bBitmapFound;
    ErrorCode           error;

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS ), &error);

    if(!key)
    {
        return (FS_ENTRY)error;
    }

    if((key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE]) ||
       (key->apbPrevMemoryBases[PRIVATE_FONT_SPACE_BASE] != key->memoryBases[PRIVATE_FONT_SPACE_BASE]))
    {
        fsg_UpdateWorkSpaceAddresses(
            key->memoryBases[WORK_SPACE_BASE],
            &(key->WorkSpaceOffsets),
            &(key->pWorkSpaceAddr));

        pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

        fsg_UpdatePrivateSpaceAddresses(
            &key->ClientInfo,
            &key->maxProfile,
            key->memoryBases[PRIVATE_FONT_SPACE_BASE],
            &(key->PrivateSpaceOffsets),
            pvStack,
            &pvFontProgram,
            &pvPreProgram);

        MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
    }

    pvGlobalGS = fsg_QueryGlobalGS(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

    /*  Check input parameters  */

    if( (usLastGlyph > key->maxProfile.numGlyphs ) ||
        (usLastGlyph < usFirstGlyph))
    {
        return INVALID_GLYPH_INDEX;
    }

    if( psvAdvanceHeights == NULL )
    {
        return NULL_INPUT_PTR_ERR;
    }

    /*  Find our current PPEm   */

    fsg_QueryPPEM(pvGlobalGS, &usPPEm);

    /* Handle each glyph    */

    for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++)
    {
        error = LookForSbitAdvanceHeight (
                key, 
                usGlyphIndex, 
                &bBitmapFound, 
                &f26DevAdvanceHeight);           /* values returned if found */

        if(error)
        {
            return (FS_ENTRY)error;
        }

        if (bBitmapFound)                      /*   if bitmap metrics found */
        {
            svDevAdvanceHeight.x = (int16)((f26DevAdvanceHeight.x + DOT6ONEHALF) >> 6);
            svDevAdvanceHeight.y = (int16)((f26DevAdvanceHeight.y + DOT6ONEHALF) >> 6);
        }
        else        /* if (bBitmapFound == FALSE)   if no bitmap, read vmtx */
        {
            error = sfac_ReadGlyphVertMetrics (
                &key->ClientInfo,
                usGlyphIndex,
                &usNonScaledAH,
                &sNonScaledTSB);

            if(error)
            {
                return (FS_ENTRY)error;
            }

            fsg_ScaleVerticalMetrics (
                &key->TransformInfo,
                pvGlobalGS,
                usNonScaledAH,
                sNonScaledTSB,
                &vecAdvanceHeight,
                &vecTopSideBearing);

            svDevAdvanceHeight.x = (int16)((vecAdvanceHeight.x + ONEHALFFIX) >> 16);
            svDevAdvanceHeight.y = (int16)((vecAdvanceHeight.y + ONEHALFFIX) >> 16);
        }
        
        *psvAdvanceHeights++ = svDevAdvanceHeight;
    }

    return NO_ERR;
}

/*********************************************************************/

/*  Look for an embedded bitmap, if found return the advance width */

FS_PRIVATE FS_ENTRY LookForSbitAdvanceWidth(
    fs_SplineKey *key,
    uint16 usGlyphIndex, 
    boolean *pbBitmapFound, 
    point *pf26DevAdvanceWidth )
{
    uint16      usFoundCode;
    ErrorCode   error;
    uint16      usBitDepth;         /* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    
    *pbBitmapFound = FALSE;                 /* default value */

    error = sbit_SearchForBitmap(
        &key->SbitMono,
        &key->ClientInfo,
        usGlyphIndex, 
        key->usOverScale,
        &usBitDepth,
        &usFoundCode );

    if (error)
    {
        return (FS_ENTRY)error;
    }

    if (usFoundCode != 0)
    {
        error = sbit_GetDevAdvanceWidth (
            &key->SbitMono,
            &key->ClientInfo,
            pf26DevAdvanceWidth );
        
        if (error)
        {
            return (FS_ENTRY)error;
        }
        *pbBitmapFound = TRUE;
    }
    return NO_ERR;
}

/*********************************************************************/

/*  Look for an embedded bitmap, if found return the advance height */

FS_PRIVATE FS_ENTRY LookForSbitAdvanceHeight(
    fs_SplineKey *key,
    uint16 usGlyphIndex, 
    boolean *pbBitmapFound, 
    point *pf26DevAdvanceHeight )
{
    uint16      usFoundCode;
    ErrorCode   error;
    uint16      usBitDepth;         /* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    
    *pbBitmapFound = FALSE;                 /* default value */

    error = sbit_SearchForBitmap(
        &key->SbitMono,
        &key->ClientInfo,
        usGlyphIndex, 
        key->usOverScale,
        &usBitDepth,
        &usFoundCode );

    if (error)
    {
        return (FS_ENTRY)error;
    }

    if (usFoundCode != 0)
    {
        error = sbit_GetDevAdvanceHeight (
            &key->SbitMono,
            &key->ClientInfo,
            pf26DevAdvanceHeight);
        
        if (error)
        {
            return (FS_ENTRY)error;
        }
        *pbBitmapFound = TRUE;
    }
    return NO_ERR;
}


/*********************************************************************/

/*              Char Code to Glyph ID Helper Function                */

/*      returns glyph IDs for array or range of character codes      */

/*********************************************************************/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetGlyphIDs (
    fs_GlyphInputType * inputPtr,
    uint16              usCharCount,
    uint16              usFirstChar,
    uint16 *            pusCharCode,
    uint16 *            pusGlyphID)
{
    ErrorCode           error;
    fs_SplineKey *      key;

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT), &error);
    if(!key)
    {
        return (FS_ENTRY)error;
    }

    error = sfac_GetMultiGlyphIDs(
        &key->ClientInfo, 
        usCharCount, 
        usFirstChar, 
        pusCharCode, 
        pusGlyphID);

    if(error)
    {
        return (FS_ENTRY)error;
    }
    return NO_ERR;
}

/*********************************************************************/

/*              Char Code to Glyph ID Helper Function                */

/*   specific to Win95 - needs no font context, just a cmap pointer  */

/*********************************************************************/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Win95GetGlyphIDs (
    uint8 *             pbyCmapSubTable,
    uint16              usCharCount,
    uint16              usFirstChar,
    uint16 *            pusCharCode,
    uint16 *            pusGlyphID)
{
    ErrorCode           error;

    error = sfac_GetWin95GlyphIDs(
        pbyCmapSubTable, 
        usCharCount, 
        usFirstChar, 
        pusCharCode, 
        pusGlyphID);

    if(error)
    {
        return (FS_ENTRY)error;
    }
    return NO_ERR;
}

/*********************************************************************/

/*              Char Code to Glyph ID Helper Function                */

/*   specific to WinNT                                               */

/*********************************************************************/

/* special helper function fs_WinNTGetGlyphIDs
   - an offset ulCharCodeOffset is added to the character codes from pulCharCode 
     before converting the value to glyph index
   - pulCharCode and pulGlyphID are both uint32 *
   - pulCharCode and pulGlyphID can point to the same address        
*/
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_WinNTGetGlyphIDs (
    fs_GlyphInputType * inputPtr,
    uint16              usCharCount,
    uint16              usFirstChar,
    uint32              ulCharCodeOffset,
    uint32 *            pulCharCode,
    uint32 *            pulGlyphID)
{
    ErrorCode           error;
    fs_SplineKey *      key;

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT), &error);
    if(!key)
    {
        return (FS_ENTRY)error;
    }

    error = sfac_GetWinNTGlyphIDs(
        &key->ClientInfo, 
        key->maxProfile.numGlyphs,  
        usCharCount, 
        usFirstChar, 
        ulCharCodeOffset,
        pulCharCode, 
        pulGlyphID);

    if(error)
    {
        return (FS_ENTRY)error;
    }
    return NO_ERR;
}


/*********************************************************************/

/*                Outline Coordinates Helper Function                */

/* returns (x,y) coordinates of array of points on the glyph outline */

/*********************************************************************/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetOutlineCoordinates (
    fs_GlyphInputType * inputPtr,
    uint16              usPointCount,
    uint16 *            pusPointIndex,
    shortVector *       psvCoordinates)
{
    ErrorCode       error;
    ContourList     CList;        /* newscan contour list type */
    fs_SplineKey *  key;

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH), &error);
    if(!key)
    {
        return (FS_ENTRY)error;
    }
    if (key->ulState & SIZEKNOWN)               /* fail a call after FindBimapSize */
    {
        return OUT_OFF_SEQUENCE_CALL_ERR;
    }
    
    if (key->bGlyphHasOutline == FALSE)
    {
        return BAD_POINT_INDEX_ERR;             /* no meaning if no outlines */
    }

    if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
    {
          fsg_UpdateWorkSpaceAddresses(
                key->memoryBases[WORK_SPACE_BASE],
                &(key->WorkSpaceOffsets),
                &(key->pWorkSpaceAddr));
        
          fsg_UpdateWorkSpaceElement(
                &(key->WorkSpaceOffsets),
                &(key->pWorkSpaceAddr));
        
          MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
    }

    fsg_GetContourData(
        &key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
        (boolean)(key->flSubPixel & FNT_SP_SUB_PIXEL),            
#endif // FSCFG_SUBPIXEL
        &CList.afxXCoord,
        &CList.afxYCoord,
        &CList.asStartPoint,
        &CList.asEndPoint,
        &CList.abyOnCurve,
        &CList.abyFc,
        &CList.usContourCount);

    error = fsc_GetCoords(&CList, usPointCount, pusPointIndex, (PixCoord *)psvCoordinates);
    if (error != NO_ERR)
    {
        return(error);
    }

    return NO_ERR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\fscaler.h ===
#ifdef __cplusplus
extern "C" {
#endif

/*
	File:       fscaler.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		  <>    10/14/97    CB      move usOverScale to fs_NewTransformation
		<9+>     7/17/90    MR      Conditionalize names in FSInput
		 <9>     7/14/90    MR      rename SQRT2 to FIXEDSQRT2, removed specificID and lowestRecPPEM
									from FSInfo
		 <8>     7/13/90    MR      FSInput now has a union to save space, points to matrix instead
									of storing it
		 <6>     6/21/90    MR      Change fillFunc to ReleaseSfntFrag
		 <5>      6/5/90    MR      remove readmvt and mapcharcodes
		 <4>      5/3/90    RB      Added memory area for new scan converter. MIKE REED - Removed
									.error from fsinfo structure. Added MapCharCodes and ReadMVT
									calls.
		 <3>     3/20/90    CL      New comment style for BBS. 
		 <2>     2/27/90    CL      New CharToIndexMap Table format.
	   <3.5>    11/15/89    CEL     Placed an ifdef around inline MPW calls to the trap. This makes
									it easier to compile for skia and the likes who do not use the
									MPW compiler.
	   <3.4>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Instructions are legal in components. Five
									unnecessary element in the output data structure have been
									deleted. (All the information is passed out in the bitmap data
									structure) fs_FindBMSize now also returns the bounding box.
	   <3.3>     9/27/89    CEL     Took out devAdvanceWidth & devLeftSideBearing.
	   <3.2>     9/25/89    CEL     Took out Mac specific functions.
	   <3.1>     9/15/89    CEL     Re-working dispatcher.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/

#include    "fscdefs.h"
#include    "fnt.h"

/* QuickDraw Types */

#ifndef _Quickdraw_
#ifndef __QUICKDRAW__   
	typedef struct BitMap {
		char* baseAddr;
		int16 rowBytes;
		Rect bounds;
	} BitMap;
#endif
#endif

#define MEMORYFRAGMENTS 9           /* extra memory base for overscaled bitmap */

#define NONVALID        0xffff

/* For the flags field in the flags field */

/* set on 68020, do not set on 68000 */
#define READ_NONALIGNED_SHORT_IS_OK 0x0001          /* set when calling fs_OpenFonts() */
/* set on 68020, do not set on 68000 */
#define READ_NONALIGNED_LONG_IS_OK  0x0002          /* set when calling fs_OpenFonts() */

#ifdef FSCFG_SUBPIXEL
/* For the SubPixel flag field */
#define SP_SUB_PIXEL			0x0001          /* set when calling fs_NewTransformation() */
#define SP_COMPATIBLE_WIDTH		0x0002          /* set when calling fs_NewTransformation() */
#define SP_VERTICAL_DIRECTION	0x0004          /* set when calling fs_NewTransformation() */
#define SP_BGR_ORDER			0x0008          /* set when calling fs_NewTransformation() */
#endif // FSCFG_SUBPIXEL

typedef struct {
	vectorType      advanceWidth, leftSideBearing;
	vectorType      leftSideBearingLine, devLeftSideBearingLine;/* along AW line */
	vectorType      devAdvanceWidth, devLeftSideBearing;
} metricsType;

typedef struct {
	vectorType      advanceHeight, topSideBearing;
	vectorType      topSideBearingLine, devTopSideBearingLine;/* along AH line */
	vectorType      devAdvanceHeight, devTopSideBearing;
} verticalMetricsType;

#define FS_MEMORY_SIZE  int32

/*
 * Output data structure to the Font Scaler.
 */
typedef struct {
	FS_MEMORY_SIZE  memorySizes[MEMORYFRAGMENTS];

	uint16          glyphIndex;
	uint16          numberOfBytesTaken; /* from the character code */

	metricsType     metricInfo;
	BitMap          bitMapInfo;

	/* Spline Data */
	int32           outlineCacheSize;
	uint16          outlinesExist;
	uint16          numberOfContours;
	F26Dot6         *xPtr, *yPtr;
	int16           *startPtr;
	int16           *endPtr;
	uint8           *onCurve;
	/* End of spline data */

	/* Only of interest to editors */
	F26Dot6         *scaledCVT;

	/* embedded bitmap return values */
	uint16          usBitmapFound;

	/* vertical metrics */
	verticalMetricsType     verticalMetricInfo;

	/* resulting number of gray levels, 0 means black/white, 1 bit per pixel,
	   (grayscale bitmap are 1 byte per pixel)
	   the number of level you receive is not necessarily what you ask for.
	   If there is no embedded gray bitmap :
			usOverscale 2 -> usGrayLevels 5,
			usOverscale 4 -> usGrayLevels 17,
			usOverscale 8 -> usGrayLevels 65,
	   If an embedded gray bitmap is present in the font, the embedded bitmap
	   will be selected before a gray bitmap generated with an higher overscale.
	   If you are unhappy with the number of gray levels (usGrayLevels) you can force
	   the embedded bitmap off by setting bNoEmbeddedBitmap to TRUE  */
	uint16          usGrayLevels;            
#ifdef FSCFG_SUBPIXEL_STANDALONE // B.St.
	BitMap			overscaledBitmapInfo;
#endif
	uint8			*fc;         /* contour flags, one byte for every contour */
} fs_GlyphInfoType;

/*
 * Input data structure to the Font Scaler.
 *
 * styleFunc is not supported in this version of the Font Scalar. Should be set to NULL.
 *
 */

#ifndef UNNAMED_UNION

typedef struct {
	Fixed                   version;
	char*                   memoryBases[MEMORYFRAGMENTS];
	int32                   *sfntDirectory; 
	GetSFNTFunc             GetSfntFragmentPtr; /* (clientID, offset, length) */
	ReleaseSFNTFunc         ReleaseSfntFrag;
	ClientIDType            clientID; /* client private id/stamp (eg. handle for the sfnt) */

	union {
		struct {
			uint16          platformID;
			uint16          specificID;
		} newsfnt;
		struct {
			Fixed           pointSize;
			int16           xResolution;
			int16           yResolution;
			Fixed           pixelDiameter;      /* compute engine char from this */
			transMatrix*    transformMatrix;
			FntTraceFunc    traceFunc;
			uint16          usOverScale;            /* outline magnification */
            /* embolding simulation */
			uint16          usEmboldWeightx;        /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
			uint16          usEmboldWeighty;        /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
			int32           lDescDev;               /* descender in device metric, used for clipping */
			boolean         bBitmapEmboldening;
#ifdef FSCFG_SUBPIXEL
			uint16          flSubPixel;
#endif // FSCFG_SUBPIXEL
			boolean         bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
													   or text animation where we want to turn off gridfitting hinting
													   but for fonts where glyphs are build by hinting, we still want the
													   glyph shape to be correct */
		} newtrans;
		struct {
			uint16          characterCode;
			uint16          glyphIndex;
			boolean         bMatchBBox;             /* force bounding box match */
			boolean         bNoEmbeddedBitmap;      /* disable the embedded bitmap */			
		} newglyph;
		struct {
			void            (*styleFunc) (fs_GlyphInfoType*);
			FntTraceFunc    traceFunc;
			boolean         bSkipIfBitmap;
		} gridfit;
		int32*  outlineCache;
		struct {                                    /* for fs_FindBandingSize */
			uint16          usBandType;             /* old, small or fast */
			uint16          usBandWidth;            /* number of scanlines */
			int32*          outlineCache;           /* cacheing works with banding */
		} band;
		struct {
			int16           bottomClip;
			int16           topClip;
			int32*          outlineCache;
		} scan;
	} param;
} fs_GlyphInputType;

#else

typedef struct {
	Fixed                   version;
	char*                   memoryBases[MEMORYFRAGMENTS];
	int32                   *sfntDirectory; 
	GetSFNTFunc             GetSfntFragmentPtr; /* (clientID, offset, length) */
	ReleaseSFNTFunc         ReleaseSfntFrag;
	ClientIDType            clientID; /* client private id/stamp (eg. handle for the sfnt) */

	union {
		struct {
			uint16          platformID;
			uint16          specificID;
		};
		struct {
			Fixed           pointSize;
			int16           xResolution;
			int16           yResolution;
			Fixed           pixelDiameter;      /* compute engine char from this */
			transMatrix*    transformMatrix;
			FntTraceFunc    tracePreProgramFunc;
			uint16          usOverScale;            /* outline magnification */
            /* embolding simulation */
			uint16          usEmboldWeightx;        /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
			uint16          usEmboldWeighty;        /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
			int32           lDescDev;               /* descender in device metric, used for clipping */
			boolean         bBitmapEmboldening;
#ifdef FSCFG_SUBPIXEL
			uint16          flSubPixel;
#endif // FSCFG_SUBPIXEL
			boolean         bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
													   or text animation where we want to turn off gridfitting hinting
													   but for fonts where glyphs are build by hinting, we still want the
													   glyph shape to be correct */
		};
		struct {
			uint16          characterCode;
			uint16          glyphIndex;
			boolean         bMatchBBox;             /* force bounding box match */
			boolean         bNoEmbeddedBitmap;      /* disable the embedded bitmap */			
		};
		struct {
			void            (*styleFunc) (fs_GlyphInfoType*);
			FntTraceFunc    traceGridFitFunc;
			boolean         bSkipIfBitmap;
		};
		int32*              outlineCache1;
		struct {                                    /* for fs_FindBandingSize */
			uint16          usBandType;             /* old, small or fast */
			uint16          usBandWidth;            /* number of scanlines */
			int32*          outlineCache3;          /* cacheing works with banding */
		};
		struct {
			int16           bottomClip;
			int16           topClip;
			int32*          outlineCache2;
		};
	};
} fs_GlyphInputType;

#endif      /* unnamed union */

#ifndef FIXEDSQRT2
#define FIXEDSQRT2 0x00016A0A
#endif

/* Font scaler trap selctors */
#define OUTLINEFONTTRAP     0xA854
#define FS_OPENFONTS        0x8000
#define FS_INITIALIZE       0x8001
#define FS_NEWSFNT          0x8002
#define FS_NEWTRANS         0x8003
#define FS_NEWGLYPH         0x8004
#define FS_GETAW            0x8005
#define FS_GRIDFITT         0x8006
#define FS_NOGRIDFITT       0x8007
#define FS_FINDBMSIZE       0x8008
#define FS_SIZEOFOUTLINES   0x8009
#define FS_SAVEOUTLINES     0x800a
#define FS_RESTOREOUTLINES  0x800b
#define FS_CONTOURSCAN      0x800c
#define FS_CLOSE            0x800d
#define FS_READMVT          0x800e
#define FS_MAPCHAR_CODES    0x800f

#ifndef FS_ENTRY
#define FS_ENTRY int32
#endif

#ifdef MACINIT
extern FS_ENTRY fs__OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_OPENFONTS,0xA854};
extern FS_ENTRY fs__Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_INITIALIZE,0xA854};
extern FS_ENTRY fs__NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NEWSFNT,0xA854};
extern FS_ENTRY fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NEWTRANS,0xA854};
extern FS_ENTRY fs__NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NEWGLYPH,0xA854};
extern FS_ENTRY fs__GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_GETAW,0xA854};
extern FS_ENTRY fs__ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_GRIDFITT,0xA854};
extern FS_ENTRY fs__ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NOGRIDFITT,0xA854};
extern FS_ENTRY fs__FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_FINDBMSIZE,0xA854};
extern FS_ENTRY fs__FindBandingSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_FINDBMSIZE,0xA854};

/* these three optional calls are for caching the outlines */
extern FS_ENTRY fs__SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_SIZEOFOUTLINES,0xA854};
extern FS_ENTRY fs__SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_SAVEOUTLINES,0xA854};
extern FS_ENTRY fs__RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_RESTOREOUTLINES,0xA854};

extern FS_ENTRY fs__ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_CONTOURSCAN,0xA854};
extern FS_ENTRY fs__CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_CLOSE,0xA854};

#else

/*** Direct Calls to Font Scaler Client Interface, for Clients not using the trap mechanism ***/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBandingSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

/* these three optional calls are for caching the outlines */
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

#endif

#ifdef FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC void FS_ENTRY_PROTO fs_InitializeData (void);
#endif

/*** Rasterizer Helper Functions ***/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceWidths (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	int16 *             psGlyphWidths);

typedef struct {
	int16 x;
	int16 y;
} shortVector;

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceHeights (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	shortVector *       psvAdvanceHeights);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Win95GetGlyphIDs (
	uint8 *             pbyCmapSubTable,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID);


/* special helper function fs_WinNTGetGlyphIDs
   - an offset ulCharCodeOffset is added to the character codes from pulCharCode 
     before converting the value to glyph index
   - pulCharCode and pulGlyphID are both uint32 *
   - pulCharCode and pulGlyphID can point to the same address        
*/
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_WinNTGetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint32	            ulCharCodeOffset,
	uint32 *	        pulCharCode,
	uint32 *	        pulGlyphID);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetOutlineCoordinates (
	fs_GlyphInputType * inputPtr,
	uint16              usPointCount,
	uint16 *            pusPointIndex,
	shortVector *       psvCoordinates);

/*** Gray scale definitions ***/

#ifndef FSCFG_DISABLE_GRAYSCALE

#define FS_GRAY_VALUE_MASK  0x008B      /* support usOverScale of 1, 2, 4, & 8 */
#define FS_SBIT_BITDEPTH_MASK	0x0116	 /* support sbit with bitDepth of 1, 2, 4 and 8 */
/* FS_SBIT_BITDEPTH_MASK must have the same value as SBIT_BITDEPTH_MASK in sfntaccs.h */ 

#else

#define FS_GRAY_VALUE_MASK  0x0000      /* no grayscale support */
#define FS_SBIT_BITDEPTH_MASK	0x0002	 /* support only sbit with bitDepth of 1 */
/* FS_SBIT_BITDEPTH_MASK must have the same value as SBIT_BITDEPTH_MASK in sfntaccs.h */ 

#endif
/* the value of FS_GRAY_VALUE_MASK and FS_SBIT_BITDEPTH_MASK can be used to determine
   the usGrayLevels the client need to support.

   Fonts without embedded bitmap :
		usGrayLevels = usOverScale * usOverScale + 1;

   Fonts with embedded bitmap (sbit) :
		usGrayLevels = 0x01 << usBitDepth;

  The usGrayLevels the client may receive with the current version are :

  0 for black/white
  5, 17, 65 fonts without embedded bitmap
  4, 16, 256 fonts with embedded bitmap

*/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceHeight (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

#ifdef FSCFG_MOVE_KEY_IN_DOT_H
/* the definition of the key in fscaler.h and fscaler.c must be identical */

/*** The Internal Key ***/
typedef struct fs_SplineKey {
	sfac_ClientRec      ClientInfo;         /* Client Information */
	char* const *       memoryBases;        /* array of memory Areas */
	char *              apbPrevMemoryBases[MEMORYFRAGMENTS];

	uint16              usScanType;         /* flags for dropout control etc.*/

	fsg_TransformRec    TransformInfo;

	uint16              usNonScaledAW;
	uint16              usNonScaledAH;

	LocalMaxProfile     maxProfile;         /* copy of profile */

	uint32              ulState;            /* for error checking purposes */
	
	boolean             bExecutePrePgm;
	boolean             bExecuteFontPgm;    /* <4> */

	fsg_WorkSpaceAddr   pWorkSpaceAddr;     /* Hard addresses in Work Space */
	fsg_WorkSpaceOffsets WorkSpaceOffsets;  /* Address offsets in Work Space     */
	fsg_PrivateSpaceOffsets PrivateSpaceOffsets; /* Address offsets in Private Space */

	uint16              usBandType;         /* old, small or fast */
	uint16              usBandWidth;        /* from FindBandingSize */

	GlyphBitMap         GBMap;              /* newscan bitmap type */
	WorkScan            WScan;              /* newscan workspace type */

	GlyphBitMap         OverGBMap;          /* for gray scale */
	uint16              usOverScale;        /* 0 => mono; mag factor => gray */
	boolean             bGrayScale;			/* FALSE if mono (usOverScale == 0)	*/
	boolean             bMatchBBox;         /* force bounding box match */
	boolean             bEmbeddedBitmap;    /* embedded bitmap found */			

	metricsType         metricInfo;         /* Glyph metrics info */
	verticalMetricsType     verticalMetricInfo;

	int32               lExtraWorkSpace;    /* Amount of extra space in workspace */

	boolean             bOutlineIsCached;   /* Outline is cached */
	boolean             bGlyphHasOutline;   /* Outline is empty */
	boolean             bGridFitSkipped;    /* sbit anticipated, no outline loaded */

	uint32              ulGlyphOutlineSize; /* Size of outline cache */
	
	sbit_State          SbitMono;           /* for monochrome bitmaps */
	boolean             bHintingEnabled;    /* hinting is enabled, set to FALSE when 
                                               fs_NewTransformNoGridFit is called */
	boolean             bBitmapEmboldening; /* bitmap emboldening simulation */
	int16               sBoldSimulHorShift; /* shift for emboldening simulation, horizonatlly */
	int16               sBoldSimulVertShift; /* shift for emboldening simulation, vertically */
#ifdef FSCFG_SUBPIXEL
	uint16				flSubPixel;
	fsg_TransformRec    TransformInfoSubPixel;
#endif // FSCFG_SUBPIXEL
} fs_SplineKey;

#endif // FSCFG_MOVE_KEY_IN_DOT_H

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\fscdefs.h ===
/*
	File:       fscdefs.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  c 1988-1990 by Apple Computer, Inc., all rights reserved.
	Copyright:  c 1991-1999 by Microsoft Corp., all rights reserved.

	Change History (most recent first):
		
				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		         4/01/99  BeatS		Implement alternative interpretation of TT instructions for SP
		 <>     10/14/97    CB      rename ASSERT into FS_ASSERT
		 <3>    11/27/90    MR      Add #define for PASCAL. [ph]
		 <2>     11/5/90    MR      Move USHORTMUL from fontmath.h, add Debug definition [rb]
		 <7>     7/18/90    MR      Add byte swapping macros for INTEL, moved rounding macros from
									fnt.h to here
		 <6>     7/14/90    MR      changed defines to typedefs for int[8,16,32] and others
		 <5>     7/13/90    MR      Declared ReleaseSFNTFunc and GetSFNTFunc
		 <4>      5/3/90    RB      cant remember any changes
		 <3>     3/20/90    CL      type changes for Microsoft
		 <2>     2/27/90    CL      getting bbs headers
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.1>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/

#ifndef FSCDEFS_DEFINED
#define FSCDEFS_DEFINED

#include "fsconfig.h"
#include <stddef.h>
#include <limits.h>

#if !defined(__cplusplus)       // true/false are reserved words for C++
#define true 1
#define false 0
#endif

#ifndef TRUE
	#define TRUE    1
#endif

#ifndef FALSE
#define FALSE   0
#endif

#ifndef FS_PRIVATE
#define FS_PRIVATE static
#endif

#ifndef FS_PUBLIC
#define FS_PUBLIC
#endif

#define ONEFIX      ( 1L << 16 )
#define ONEFRAC     ( 1L << 30 )
#define ONEHALFFIX  0x8000L
#define ONEVECSHIFT 16
#define HALFVECDIV  (1L << (ONEVECSHIFT-1))

#define NULL_GLYPH  0

/* banding type constants */

#define FS_BANDINGOLD       0
#define FS_BANDINGSMALL     1
#define FS_BANDINGFAST      2
#define FS_BANDINGFASTER    3

/* Dropout control values are now defined as bit masks to retain compatability */
/* with the old definition, and to allow for current and future expansion */

#define SK_STUBS          0x0001       /* leave stubs white */
#define SK_NODROPOUT      0x0002       /* disable all dropout control */
#define SK_SMART              0x0004        /* symmetrical dropout, closest pixel */

/* Values used to decode curves */

#define ONCURVE             0x01

#define PHANTOMCOUNT 8

typedef signed char int8;
typedef unsigned char uint8;
typedef short int16;
typedef unsigned short uint16;
typedef long int32;
typedef unsigned long uint32;

typedef __int64 int64;
typedef unsigned __int64 uint64;

typedef short FUnit;
typedef unsigned short uFUnit;

typedef short ShortFract;                       /* 2.14 */

#ifndef F26Dot6
#define F26Dot6 long
#endif

#ifndef boolean
#define boolean int
#endif

#ifndef ClientIDType
#define ClientIDType int32
#endif

#ifndef CONST
#define CONST const
#endif

#ifndef FAR
#define FAR
#endif

#ifndef NEAR
#define NEAR
#endif

#ifndef TMP_CONV
#define TMP_CONV
#endif

#ifndef FS_MAC_PASCAL
#define FS_MAC_PASCAL
#endif

#ifndef FS_PC_PASCAL
#define FS_PC_PASCAL
#endif

#ifndef FS_MAC_TRAP
#define FS_MAC_TRAP(a)
#endif

/* QuickDraw Types */

#ifndef _MacTypes_
#ifndef __TYPES__
	typedef struct Rect {
		int16 top;
		int16 left;
		int16 bottom;
		int16 right;
	} Rect;

typedef long Fixed;         /* also defined in Mac's types.h */
typedef long Fract;

#endif
#endif

typedef struct {
	Fixed       transform[3][3];
} transMatrix;

typedef struct {
	Fixed       x, y;
} vectorType;

/* Private Data Types */
typedef struct {
	int16 xMin;
	int16 yMin;
	int16 xMax;
	int16 yMax;
} BBOX;

typedef struct {
	F26Dot6 x;
	F26Dot6 y;
} point;

typedef int32 ErrorCode;

#define ALIGN(object, p) p =    (p + ((uint32)sizeof(object) - 1)) & ~((uint32)sizeof(object) - 1);

#define ROWBYTESLONG(x)     (((x + 31) >> 5) << 2)

#ifndef SHORTMUL
#define SHORTMUL(a,b)   (int32)((int32)(a) * (b))
#endif

#ifndef SHORTDIV
#define SHORTDIV(a,b)   (int32)((int32)(a) / (b))
#endif

#ifdef FSCFG_BIG_ENDIAN /* target byte order matches Motorola 68000 */
	#define SWAPL(a)        (a)
	#define CSWAPL(a)       (a)
	#define SWAPW(a)        (a)
	#define CSWAPW(a)       (a)
	#define SWAPWINC(a)     (*(a)++)
#else
	/* Portable code to extract a short or a long from a 2- or 4-byte buffer */
	/* which was encoded using Motorola 68000 (TrueType "native") byte order. */
	#define FS_2BYTE(p) ( ((unsigned short)((p)[0]) << 8) |  (p)[1])
	#define FS_4BYTE(p) ( FS_2BYTE((p)+2) | ( (FS_2BYTE(p)+0L) << 16) )
	#define SWAPW(a)	((int16) FS_2BYTE( (unsigned char *)(&a) ))
	#define CSWAPW(num)	(((((num) & 0xff) << 8) & 0xff00) + (((num) >> 8) & 0xff)) // use this variant or else cannot apply to constants due to FS_2BYTE and FS_4BYTE
	#define SWAPL(a)	((int32) FS_4BYTE( (unsigned char *)(&a) ))
	#define CSWAPL(num)	((CSWAPW((num) & 0xffff) << 16) + CSWAPW((num) >> 16)) // use this variant or else cannot apply to constants due to FS_2BYTE and FS_4BYTE
	#define SWAPWINC(a) SWAPW(*(a)); a++    /* Do NOT parenthesize! */
#endif

#ifndef SWAPW // provoke compiler error if still not defined
	#define SWAPW	a
	#define SWAPW	b
#endif

#ifndef LoopCount
#define LoopCount int16      /* short gives us a Motorola DBF */
#endif

#ifndef ArrayIndex
#define ArrayIndex int32     /* avoids EXT.L on Motorola */
#endif

typedef void (*voidFunc) ();
typedef void * voidPtr;
typedef void (FS_CALLBACK_PROTO *ReleaseSFNTFunc) (voidPtr);
typedef void * (FS_CALLBACK_PROTO *GetSFNTFunc) (ClientIDType, int32, int32);

#ifndef	FS_ASSERT
#define FS_ASSERT(expression, message)
#endif

#ifndef	FS_WARNING
#define FS_WARNING(message)
#endif

#ifndef Assert
#define Assert(a)
#endif

#ifndef MEMSET
#define MEMSET(dst, value, size) (void)memset(dst,value,(size_t)(size))
#define FS_NEED_STRING_DOT_H
#endif

#ifndef MEMCPY
#define MEMCPY(dst, src, size) (void)memcpy(dst,src,(size_t)(size))
#ifndef FS_NEED_STRING_DOT_H
#define FS_NEED_STRING_DOT_H
#endif
#endif

#ifdef FS_NEED_STRING_DOT_H
#undef FS_NEED_STRING_DOT_H
#include <string.h>
#endif

#ifndef FS_UNUSED_PARAMETER
#define FS_UNUSED_PARAMETER(a) (a=a)     /* Silence some warnings */
#endif

typedef struct {
	Fixed       version;                /* for this table, set to 1.0 */
	uint16      numGlyphs;
	uint16      maxPoints;              /* in an individual glyph */
	uint16      maxContours;            /* in an individual glyph */
	uint16      maxCompositePoints;     /* in an composite glyph */
	uint16      maxCompositeContours;   /* in an composite glyph */
	uint16      maxElements;            /* set to 2, or 1 if no twilightzone points */
	uint16      maxTwilightPoints;      /* max points in element zero */
	uint16      maxStorage;             /* max number of storage locations */
	uint16      maxFunctionDefs;        /* max number of FDEFs in any preprogram */
	uint16      maxInstructionDefs;     /* max number of IDEFs in any preprogram */
	uint16      maxStackElements;       /* max number of stack elements for any individual glyph */
	uint16      maxSizeOfInstructions;  /* max size in bytes for any individual glyph */
	uint16      maxComponentElements;   /* number of glyphs referenced at top level */
	uint16      maxComponentDepth;      /* levels of recursion, 1 for simple components */
} LocalMaxProfile;

#ifdef FSCFG_SUBPIXEL

	// master switch for turning on Backwards Compatible SubPixel
	// if we turn this off, we basically get the same as in b/w, but with coloured fringes
	// to get the complete original 16x overscaling behaviour back, set HINTING_HOR_OVERSCALE below to 16
	#define	SUBPIXEL_BC
	
	#define ProjVectInX(localGS)	((localGS).proj.x == ONEVECTOR && (localGS).proj.y == 0)
	#define	ProjVectInY(localGS)	((localGS).proj.y == ONEVECTOR && (localGS).proj.x == 0)
	
	#ifdef SUBPIXEL_BC
		
		// master switch for turning on Enhanced Backwards Compatible Advance Width SubPixel Algorithm
		#define SUBPIXEL_BC_AW_STEM_CONCERTINA
		
		#define RunningSubPixel(globalGS)		((uint16)((globalGS)->flHintForSubPixel & FNT_SP_SUB_PIXEL))
		#define CompatibleWidthSP(globalGS)		((uint16)((globalGS)->flHintForSubPixel & FNT_SP_COMPATIBLE_WIDTH))
		#define VerticalSPDirection(globalGS)	((uint16)((globalGS)->flHintForSubPixel & FNT_SP_VERTICAL_DIRECTION))
		#define BGROrderSP(globalGS)			((uint16)((globalGS)->flHintForSubPixel & FNT_SP_BGR_ORDER))
	//	assume that horizontal direction RGB is more frequent than vertical direction, hence put the latter into the else-path
	//	Notice that in order to decide whether we're currently in SubPixel direction, we look at the projection vector, because that's the direction
	//	along which distances are measured. If this projection vector has a non-zero component in the physical direction of our device, we will decide
	//	that rounding should be done in the SubPixel way. For example, if our device has its SubPixel direction in x, and if the projection vector
	//	points in any direction other than the y direction, the pv has a non-zero component in x, hence we round in the SubPixel way. This behaviour
	//	corresponds to the original implementation of the 16x overscaling rasterizer, where the non-zero component in x would be overscaled by 16.
		#define InSubPixelDirection(localGS)	((uint16)(!VerticalSPDirection((localGS).globalGS) ? !ProjVectInY(localGS) : !ProjVectInX(localGS)))
	//	primary values; in interp.c there are further values which are derived from these values, but which are specific to the interpreter
		#define VIRTUAL_OVERSCALE				16 // for itrp_RoundToGrid & al to work properly, this should be a power of two, else have to tabulate rounding
		#define VISUAL_OVERSCALE				2  // between 1.7 and 3, corresponding to the visually experienced resolution relative to the physical resolution.
												   // for our purposes, the exact value is not particularly crucial (cf. ENGINE_COMP_OVERSCALE, MIN_DIST_OVERSCALE,
												   // in interp.c) hence we set it to 2 for efficiency
	#else
		#define RunningSubPixel(globalGS)		false
		#define CompatibleWidthSP(globalGS)		false
		#define VerticalSPDirection(globalGS)	false
		#define InSubPixelDirection(localGS)	false
	//	primary values; in interp.c there are further values which are derived from these values, but which are specific to the interpreter
		#define VIRTUAL_OVERSCALE				1
		#define VISUAL_OVERSCALE				1
	#endif
//	#define VIRTUAL_PIXELSIZE		(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
//	these values are used in various rounding functions, which includes rounding the advance width
//	they are specific to the rounding operation, if this should become necessary in the future
	#define VIRTUAL_PIXELSIZE_RTDG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RDTG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RUTG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RTG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RTHG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_ROFF	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	

	#define HINTING_HOR_OVERSCALE 1 // see SUBPIXEL_BC above for further comments

#ifdef FSCFG_SUBPIXEL_STANDALONE
	
	#define R_Subpixels		5
	#define G_Subpixels		9
	#define B_Subpixels		2

	/* IMPORTANT :
 
	   If you change any of the above
	   make sure you update abColorIndexTable[] in scentry.c
	   and that (R_Subpixels + 1) * (G_Subpixels + 1) * (B_Subpixels + 1) <= 256

	  */

	#define RGB_OVERSCALE (R_Subpixels + G_Subpixels + B_Subpixels)

#else

	#define SUBPIXEL_OVERSCALE 2

	/* IMPORTANT :
 
	   If you change SUBPIXEL_OVERSCALE
	   make sure you update abColorIndexTable[] in scentry.c
	   and that (SUBPIXEL_OVERSCALE + 1) * (SUBPIXEL_OVERSCALE + 1) * (SUBPIXEL_OVERSCALE + 1) <= 256

	  */

	#define RGB_OVERSCALE (SUBPIXEL_OVERSCALE * 3)
#endif

	#define ROUND_FROM_RGB_OVERSCALE(x) x = ((x) + (RGB_OVERSCALE >> 1) ) / RGB_OVERSCALE
	#define ROUND_FROM_HINT_OVERSCALE(x) x = ((x) + (HINTING_HOR_OVERSCALE >> 1) ) / HINTING_HOR_OVERSCALE
	#define ROUND_RGB_OVERSCALE(x) ((x) + (RGB_OVERSCALE >> 1) ) / RGB_OVERSCALE

	#define FLOOR_RGB_OVERSCALE(x) ((x) < 0) ? -((-(x)+ RGB_OVERSCALE -1) / RGB_OVERSCALE) : ((x) / RGB_OVERSCALE) // by the way, this is NOT a floor operation
	#define CEIL_RGB_OVERSCALE(x) FLOOR_RGB_OVERSCALE((x) + RGB_OVERSCALE -1)

	/* we are storing into 2 bits per pixels, weight for each color can be 0,1 or 2 */
	#define MAX_RGB_INDEX (2 * 16 + 2 * 4 + 2 )

	#define SUBPIXEL_SCALEBACK_FACTOR ((RGB_OVERSCALE << 16) / HINTING_HOR_OVERSCALE)

	#define SUBPIXEL_SCALEBACK_UPPER_LIMIT (SUBPIXEL_SCALEBACK_FACTOR *120 /100)
	#define SUBPIXEL_SCALEBACK_LOWER_LIMIT (SUBPIXEL_SCALEBACK_FACTOR *100 /120)
#endif // FSCFG_SUBPIXEL

#endif  /* FSCDEFS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\fsconfig.h ===
/*
	File:       fsconfig.h : (Portable "Standard C" version)

	Written by: Lenox Brassell

	Contains:   #define directives for FontScaler build options

   Copyright:  c 1989-1993 by Microsoft Corp., all rights reserved.

	Change History (most recent first):
		<3>      4/21/93 GregH Documented file
		<2>      7/16/92    DJ      Added fnt_Report_Error() declaration.
		<1>      8/27/91    LB      Created file.

	Usage:  This file is "#include"-ed as the first statement in
			"fscdefs.h".  This file contains platform-specific
			override definitions for the following #define-ed data
		types and macros, which have default definitions in
		"fscdefs.h":

	Purpose:

		This file gives the integrator a place to override the
		default definitions of these items, as well as a place
		to define other configuration-specific macros.

	Definitions:

		The following type definitations can be changed. The defaults have been
		set up for a 32-bit system. Caveat emptor: any change to the defaults may
		severly effect performace or place severe limitations on the capabilities
		of the TrueType rasterizer.

				F26Dot6
					 This is currently defined as a fixed point 26.6 number.
					 If changed to short, it is a 10.6 number.

		The following definition changes the return type for all Font Scalar
		Client Interface calls.

				FS_ENTRY

		The following definition changes the calling convention for all Font
		Scalar Client Interface calls.  By default, the rasterizer uses register
		calling conventions because of the performance gains.

				FS_ENTRY_PROTO

		The following definitions are used for all private and public entry points
		in the TrueType Rasterizer. By default FS_PRIVATE is set to static, but
		for some uses, like profiling and debugging this is undesirable, and
		FS_PRIVATE can be set to null. FS_PUBLIC defaults to null.

				FS_PRIVATE
				FS_PUBLIC

		The following definitions are used for calling conventions to external
		math routines. The Macintosh has external math routines that use pascal
		calling conventions. To enable these, the FS_MAC_PASCAL must be set to
		"pascal". Similary the FS_PC_PASCAL variable needs to be set to "pascal"
		when calling external routines using pascal calling conventions.

				FS_MAC_PASCAL
				FS_PC_PASCAL

		This definition is used for calling Macintosh ToolBox routines. If the
		rasterizer is implemented on a non-Macintosh platform, this Macro should
		be null.

				FS_MAC_TRAP

		These macros are used to override the C memcpy and memset routines

				MEMCPY
				MEMSET

		These math routines can be hooked out by system routines.

				SHORTDIV
				SHORTMUL

		These macros are used to convert big-endian to little-endian. When
		running on a big-endian platform these macros are not necessary.

				SWAPL
				SWAPW
				SWAPWINC

		These macros are used to replace some math routines by faster assembly
		language routines. The notation used for the assembly language routines
		should indicate the processor targeted. For example:

				#define CompMul   CompMul386
				#define CompDiv   CompDiv386
				#define FracSqrt      FracSqrt386

	The following definitions change the way the TrueType rasterizer works on
	specific implementations. These definitions are usually switches that are
	defined or not defined.

		FSCFG_DEBUG

		This is used to create a debugging version of the rasterizer. This
		version does additional error checking and creates a debugger trap
		when the TrueType DEBUG instruction is called.

		FSCFG_FNTERR

		This is used to create a error checking version of the rasterizer. With
		this set, parameters passed to TrueType instructions are range checked.
		If any instructions fails a test, a error message is returned.

		FSCFG_MOVEABLE_MEMBASE

		This is used to implement moveable memory bases. If it is possible that
		the address of a memory base could change between a Font Scaler Client
		Interface call, then this flag should be set in the rasterizer.

		FSCFG_MICROSOFT_KK

		This flag is used to implement the Microsoft KK version of the TrueType
		rasterizer. The effect of this flag is to use a slightly different
		algorithm for parsing the Format 2 cmap table.

		FSCFG_BIG_ENDIAN

		This flag indicates the target platform of the rasterizer uses big-endian
		representation of multiple-byte integers. If this flag is not set, SWAP
		macros are used to convert all multiple-byte integers read from TrueType
		Font Files.

		FSCFG_REENTRANT

		This flag indicates that the TrueType rasterizer should be reentrant.
		This allows multiple treads of execution through the executable and gives
		better system through put on multi-threaded/process environments. Slight
		performance gains are possible when not setting this flag in single tasking
		environments.

		FSCFG_NO_INITIALIZED_DATA

		This flag should be set for platforms that do not support static
		initialization of data. With this flag, a new Font Scalar Client Interface
		call fs_InitializeData needs to be made.

		FSCFG_USESTATCARD

		This flag is set to turn on stat card timing services in the rasterizer.
		This can be used to collect timing information for profiling.
		
		FSCFG_USE_MASK_SHIFT

		This flag is set to enable bitmask generated by shifting rather than by
		table lookup.  Shifted bitmasks use less memory and MAY be faster than
		table bitmasks.  On Big-Endian platforms shifted bitmasks will produce
		bitmaps that are identical to Apple's definition (same byte order).
		Table bitmaps will be identical for all platforms.

		FSCFG_DISABLE_GRAYSCALE

		This flag is set to disable all grayscale functions and save a little
		code space along the way. If defined, all grayscale functions return
		a BAD_GRAY_LEVEL_ERR error code.

		FSCFG_FONTOGRAPHER_BUG

		Fontographer 3.5 has a bug. This is causing numerous symbol fonts to
		have the critical error : Inst: RCVT CVT Out of range. CVT = 255
		This flag is meant to be set under Windows. If will cause additional
		memory to be allocated for the CVT if necessary in order to be sure
		that this illegal read will access memory within the legal range.
		Under a secure rasterizer, this flag will cause RCVT with CVT <= 255
		and CVT > NumCvt to be classified as error instead of critical error

		FSCFG_EUDC_EDITOR_BUG

		The EUDC editor under NT 4.0 has a bug and create bogous fonts.
        	The EUDC editor set maxp->maxStackElements to 0 and use 1 stack element
        	in the pre/font program. If this flag is defined, we will ensure that
        	at least one StackElement is reserved to avoid memory corruption.

       		FSCFG_CONVERT_GRAY_LEVELS

        	with grayscale embedded bitmap, the number of gray levels can be different than expected
        	4, 16, 256 instead of 5, 17, 65. If FSCFG_CONVERT_GRAY_LEVELS is defined, a conversion will be done
        	in the rasterizer to the expected number of gray levels

       FSCFG_SUBPIXEL

        will activate the SubPixel code

		FSCFG_SUBPIXEL_STANDALONE

		will activate a special variant of the SubPixel code for the stand-alone rasterizer
		
        	FSCFG_SECURE

        	Enable critical error checking in the TrueType rasterizer.

		MAC_INIT

		This flag indicates that the TrueType rasterizer will be implemented as
		a Macintosh Init.

		UNNAMED_UNION

		This flag is set for compilers that implement unnamed unions

                ClientIDType

                This definition allow the change the type definition for ClientID. If you are using ClientID to pass a pointer
                and compiling the TrueType rasterizer for a platform where pointer are bigger than 32 bits, 
                you need to change this definition.
*/

/* #define FSCFG_MICROSOFT_KK   */
/* #define FSCFG_USESTATCARD      */
/* #define FSCFG_NO_INITIALIZED_DATA */
/* #define FSCFG_FNTERR           */
/* #define FSCFG_DEBUG            */
/* #define FSCFG_MOVABLE_MEM_BASE */
/* #define FSCFG_BIG_ENDIAN   */
/* #define FSCFG_REENTRANT    */
/* #define FSCFG_NO_INITIALIZED_DATA */
/* #define FSCFG_USE_MASK_SHIFT */
/* #define FSCFG_DISABLE_GRAYSCALE */

#define FSCFG_FONTOGRAPHER_BUG

#define FSCFG_EUDC_EDITOR_BUG

#define FSCFG_SECURE

#define FSCFG_CONVERT_GRAY_LEVELS

#define FSCFG_SUBPIXEL


/* Windows NT, is moving the definition of the internal rasterizer key in fscaler.h for optimization purpose */
#define FSCFG_MOVE_KEY_IN_DOT_H

/* !!! This should be removed */
#define NOT_ON_THE_MAC

/* Assembly Optimization Switches */

/* #define CompMul      CompMul386  */
/* #define CompDiv      CompDiv386  */
/* #define FracSqrt     FracSqrt386 */

// use RtlRoutines for memory operations

// in all uses in the rasterizer MEMSET  is used to zero out the mem

// to get the prototype for RtlZeroMemory and RtlCopyMemory :

#ifdef FSCFG_INTERNAL
#include "nt.h"
#include "ntrtl.h"

#if DBG
/* to activate rasterizer assertions : */
VOID __cdecl TtfdDbgPrint(PCHAR DebugMessage,...);

#define FS_ASSERT(expression, message) { if (!(expression)) { TtfdDbgPrint(message); DbgBreakPoint();} }
#define FS_WARNING(message) { TtfdDbgPrint(message);}
#define Assert(expression) { if (!(expression)) { TtfdDbgPrint("FONT: TrueType rasterizer internal assert"); DbgBreakPoint();} }
#endif // DBG

#endif

#define MEMSET(dst, value, size) RtlZeroMemory(dst, size)
#define MEMCPY(dst, src, size)   RtlCopyMemory(dst, src, size)


// easier to debug with no static functions [BODIND]

#define FS_PRIVATE

// interface to the outside world [bodind]

#define FS_ENTRY_PROTO           __cdecl
#define FS_CALLBACK_PROTO	 __cdecl

// client ID is commonly used to pass a pointer to a structure, for backwards compatibility it
// need to be at least a 32 bits value, to get ready for the 64 bits platform, we define it as ULONG_PTR

#define ClientIDType ULONG_PTR

// only do stamp checking in the debug version

// #if DBG
// #define DEBUGSTAMP
// #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\fserror.h ===
/*
    File:       fserror.h

    Contains:   xxx put contents here (or delete the whole line) xxx

    Written by: xxx put name of writer here (or delete the whole line) xxx

    Copyright:  c 1989-1990 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1997. Microsoft Corporation, all rights reserved.

    Change History (most recent first):

		<>      10/14/97    CB      error if FDEF/IDEF in GlyphProgram
 		 <>     04/30/97    CB      ClaudeBe, missing ENDF, infinite loop/recursion
		 <>     03/1/97    CB      ClaudeBe, div by 0 in hinting error
        <4>     7/13/90    MR      made endif at bottom use a comment
         <3>      5/3/90    RB      Changed char to int8 for variable type.   Now it is legal to
                                    pass in zero as the address of memory when a piece of
         <2>     2/27/90    CL      New error code for missing but needed table. (0x1409)
       <3.1>    11/14/89    CEL     Now it is legal to pass in zero as the address of memory when a
                                    piece of the sfnt is requested by the scaler. If this happens
                                    the scaler will simply exit with an error code !
       <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
       <2.2>     8/14/89    sjk     1 point contours now OK
       <2.1>      8/8/89    sjk     Improved encryption handling
       <2.0>      8/2/89    sjk     Just fixed EASE comment
       <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
       <1.4>     6/13/89    SJK     Comment
       <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
                                    bug, correct transformed integralized ppem behavior, pretty much
                                    so
       <1.2>     5/26/89    CEL     EASE messed up on "c" comments
      <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
       <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

    To Do:
*/
/************/
/** ERRORS **/
/************/
#define NO_ERR                      0x0000
#define NULL_KEY                    0x0000


/** EXTERNAL INTERFACE PACKAGE **/
#define NULL_KEY_ERR                0x1001
#define NULL_INPUT_PTR_ERR          0x1002
#define NULL_MEMORY_BASES_ERR       0x1003
#define VOID_FUNC_PTR_BASE_ERR      0x1004  /* No longer used */
#define OUT_OFF_SEQUENCE_CALL_ERR   0x1005
#define BAD_CLIENT_ID_ERR           0x1006
#define NULL_SFNT_DIR_ERR           0x1007
#define NULL_SFNT_FRAG_PTR_ERR      0x1008
#define NULL_OUTPUT_PTR_ERR         0x1009
#define INVALID_GLYPH_INDEX         0x100A
#define BAND_TOO_BIG_ERR            0x100B  /* possible with FindBandingSize */
#define INVALID_CHARCODE_ERR        0x100C

/* fnt_execute */
#define UNDEFINED_INSTRUCTION_ERR   0x1101
#define TRASHED_MEM_ERR             0x1102
#define DIV_BY_0_IN_HINTING_ERR     0x1103
#define MISSING_ENDF_ERR			0x1104
#define MISSING_EIF_ERR				0x1105
#define INFINITE_RECURSION_ERR		0x1106 
#define INFINITE_LOOP_ERR			0x1107 
#define FDEF_IN_GLYPHPGM_ERR		0x1108 
#define IDEF_IN_GLYPHPGM_ERR		0x1109 

#define TRACE_FAILURE_ERR			0x110A  /* can be used by a trace function to notify of an 
                                               internal error (memory allocation failed,...) */
#define JUMP_BEFORE_START_ERR	    0x110B
#define INSTRUCTION_ERR             0x110C  /* can be used by a trace function to notify the discovery of an error */

#define RAW_NOT_IN_GLYPHPGM_ERR		0x110D 

#define MAX_INSTRUCTIONS_PER_PGM_ERR	0x110E 

#define SECURE_STACK_UNDERFLOW      0x1110
#define SECURE_STACK_OVERFLOW       0x1111
#define SECURE_POINT_OUT_OF_RANGE   0x1112
#define SECURE_INVALID_STACK_ACCESS 0x1113
#define SECURE_FDEF_OUT_OF_RANGE    0x1114
#define SECURE_ERR_FUNCTION_NOT_DEFINED    0x1115
#define SECURE_INVALID_ZONE         0x1116
#define SECURE_INST_OPCODE_TO_LARGE 0x1117
#define SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP  0x1118
#define SECURE_STORAGE_OUT_OF_RANGE 0x1119
#define SECURE_CONTOUR_OUT_OF_RANGE 0x111A
#define SECURE_CVT_OUT_OF_RANGE     0x111B
#define SECURE_UNITIALIZED_ZONE     0x111C


/* fsg_CalculateBBox */
#define POINT_MIGRATION_ERR         0x1201

/* sc_ScanChar */
#define BAD_START_POINT_ERR         0x1301
#define SCAN_ERR                    0x1302
#define BAD_SCAN_KIND_ERR           0x1303
#define BAD_POINT_INDEX_ERR         0x1304

#define SMART_DROP_OVERFLOW_ERR     0x1305

#define  SPLINE_SUBDIVISION_ERR		0x1306


/** SFNT DATA ERROR and errors in sfnt.c **/
#define SFNT_DATA_ERR               0x1400
#define POINTS_DATA_ERR             0x1401
#define INSTRUCTION_SIZE_ERR        0x1402
#define CONTOUR_DATA_ERR            0x1403
#define GLYPH_INDEX_ERR             0x1404
#define BAD_MAGIC_ERR               0x1405
#define OUT_OF_RANGE_SUBTABLE       0x1406
#define UNKNOWN_COMPOSITE_VERSION   0x1407
#define CLIENT_RETURNED_NULL        0x1408
#define MISSING_SFNT_TABLE          0x1409
#define UNKNOWN_CMAP_FORMAT         0x140A
#define BAD_MAXP_DATA               0x140B
#define SFNT_RECURSIVE_COMPOSITE_ERR 0x140C
#define GLYF_TABLE_CORRUPTION_ERR   0x140D
#define BAD_UNITSPEREM_ERR          0x140E
#define BAD_NUMLONGHORMETRICS_ERR   0x140F
#define COMPOSITE_INVALID_GLYPH_INDEX  0x1410
#define LOCA_NOT_ASCENDING          0x1411

/* spline call errors */
#define BAD_CALL_ERR                0x1500

#define TRASHED_OUTLINE_CACHE       0x1600

/* gray scale errors */
#define BAD_GRAY_LEVEL_ERR          0x1701
#define GRAY_OLD_BANDING_ERR        0x1703
#define GRAY_NO_OUTLINE_ERR         0x1704

/* embedded bitmap (sbit) errors */
#define SBIT_COMPONENT_MISSING_ERR  0x1801
#define SBIT_ROTATION_ERR           0x1802
#define SBIT_BANDING_ERR            0x1803
#define SBIT_OUTLINE_CACHE_ERR      0x1804

/* new transformation errors : */
#define TRAN_NULL_TRANSFORM_ERR     0x1901

/* memory error */
#define MEM_OVERRUN_ERR             0x1A00
#define MEM_SUBALLOC_ERR			0x1A01

/************ For Debugging *************/

#ifdef XXX
#define DEBUG_ON
pascal  Debug ()                     /* User break drop into Macsbug */
#ifdef  DEBUG_ON
extern  0xA9FF;
#else
{
    ;
}
#endif

#ifndef DEBUGGER
pascal void DEBUGGER(void) = 0xA9FF; 
#endif

#ifdef  LEAVEOUT
#ifndef DEBUGSTR
pascal  void DEBUGSTR (aString) int8 *aString; extern 0xABFF;
int8    *c2pstr ();
#define BugInfo( aString) DEBUGSTR( c2pstr(aString))
#endif
#endif

#endif  /* XXX */
/****************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\fsglue.h ===
/*
	File:       fsglue.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1996. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

	      <>    12/15/95    CB      add fsg_UpdateAdvanceHeight
	   <11+>     7/17/90    MR      Change error return type to int
		<11>     7/13/90    MR      Declared function pointer prototypes, Debug fields for runtime
									range checking
		 <8>     6/21/90    MR      Add field for ReleaseSfntFrag
		 <7>      6/5/90    MR      remove vectorMappingF
		 <6>      6/4/90    MR      Remove MVT
		 <5>      6/1/90    MR      Thus endeth the too-brief life of the MVT...
		 <4>      5/3/90    RB      adding support for new scan converter and decryption.
		 <3>     3/20/90    CL      Added function pointer for vector mapping
									Removed devRes field
									Added fpem field
		 <2>     2/27/90    CL      Change: The scaler handles both the old and new format
									simultaneously! It reconfigures itself during runtime !  Changed
									transformed width calculation.  Fixed transformed component bug.
	   <3.1>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Now it is legal to pass in zero as the address of
									memory when a piece of the sfnt is requested by the scaler. If
									this happens the scaler will simply exit with an error code !
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/
/*      <3+>     3/20/90    mrr     Added flag executeFontPgm, set in fs_NewSFNT
*/


/*** Offset table ***/

typedef struct {
	uint32 x;
	uint32 y;
	uint32 ox;
	uint32 oy;
	uint32 oox;
	uint32 ooy;
	uint32 onCurve;
	uint32 sp;
	uint32 ep;
	uint32 f;
	uint32 fc;        
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	uint32 pcr;
#endif
} fsg_OutlineFieldInfo;

typedef struct fsg_WorkSpaceAddr{
	 F26Dot6 *              pStack;                     /* Address of stack                  */
	 void *                 pGlyphOutlineBase;      /* Address of Glyph Outline Base     */
	 fnt_ElementType *  pGlyphElement;          /* Address of Glyph Element array    */
	 boolean *              pGlyphDataByteSet;      /* Address of ByteSet array          */
	 void *                 pvGlyphData;                /* Address of GlyphData array        */
	 void *                 pReusableMemoryMarker;  /* Address of reusable memory        */
} fsg_WorkSpaceAddr;

typedef struct fsg_WorkSpaceOffsets {
	uint32                  ulStackOffset;
	uint32                  ulGlyphOutlineOffset;
	uint32                  ulGlyphElementOffset;
	uint32                  ulGlyphDataByteSetOffset;
	uint32                  ulGlyphDataOffset;
	fsg_OutlineFieldInfo    GlyphOutlineFieldOffsets;
	 uint32                      ulReusableMemoryOffset;
	uint32                  ulMemoryBase6Offset;
	uint32                  ulMemoryBase7Offset;
	 uint32                      ulMemoryBase6Size;
	 uint32                      ulMemoryBase7Size;
} fsg_WorkSpaceOffsets;

typedef struct fsg_PrivateSpaceOffsets {
	 uint32                      offset_storage;
	 uint32                      offset_functions;
	 uint32                      offset_instrDefs;       /* <4> */
	 uint32                      offset_controlValues;
	 uint32                      offset_globalGS;
	 uint32                      offset_FontProgram;
	 uint32                      offset_PreProgram;
	 uint32                      offset_TwilightZone;
	 uint32                      offset_TwilightOutline;
	fsg_OutlineFieldInfo    TwilightOutlineFieldOffsets;
#ifdef FSCFG_SUBPIXEL
	 uint32                      offset_storageSubPixel;
	 uint32                      offset_functionsSubPixel;
	 uint32                      offset_instrDefsSubPixel;       /* <4> */
	 uint32                      offset_controlValuesSubPixel;
	 uint32                      offset_globalGSSubPixel;
	 uint32                      offset_TwilightZoneSubPixel;
	 uint32                      offset_TwilightOutlineSubPixel;
#endif // FSCFG_SUBPIXEL
} fsg_PrivateSpaceOffsets;

typedef struct fsg_TransformRec {
	uint16              usEmResolution;     /* used to be int32 <4> */
	transMatrix         currentTMatrix;     /* Current Transform Matrix */
	boolean             bPhaseShift;        /* 45 degrees flag <4> */
	boolean             bPositiveSquare;    /* Transform is a positive square */
	boolean             bIntegerScaling;    /* Font uses integer scaling */
	Fixed               fxPixelDiameter;
	uint32              ulImageState;       /* is glyph rotated, stretched, etc. */
	boolean				bEmboldSimulation; 
	uint16	uBoldSimulHorShift;
} fsg_TransformRec;

/**********************/
/** MODULE INTERFACE **/
/**********************/

/*      Memory Management Routines  */

FS_PUBLIC uint32  fsg_PrivateFontSpaceSize (
	sfac_ClientRec *            ClientInfo,
	 LocalMaxProfile *            pMaxProfile,    /* Max Profile Table    */
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets);

FS_PUBLIC uint32    fsg_WorkSpaceSetOffsets (
	 LocalMaxProfile *       pMaxProfile,    /* Max Profile Table    */
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plExtraWorkSpace);

FS_PUBLIC void  fsg_UpdatePrivateSpaceAddresses(
	sfac_ClientRec *        ClientInfo,      /* Cached sfnt information */
	 LocalMaxProfile *       pMaxProfile,    /* Max Profile Table         */
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets,
	void *                  pvStack,        /* pointer to stack         */
	void **                 pvFontProgram,  /* pointer to font program  */
	void **                 pvPreProgram);  /* pointer to pre program   */

FS_PUBLIC void  fsg_UpdateWorkSpaceAddresses(
	char *                  pWorkSpace,
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	 fsg_WorkSpaceAddr *     pWorkSpaceAddr);

FS_PUBLIC void  fsg_UpdateWorkSpaceElement(
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	 fsg_WorkSpaceAddr *     pWorkSpaceAddr);

FS_PUBLIC void *    fsg_QueryGlobalGS(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *    fsg_QueryGlobalGSSubPixel(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryTwilightElement(
	char *                  pPrivateFontSpace,
	 fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *      fsg_QueryTwilightElementSubPixel(
	char *                  pPrivateFontSpace,
	 fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryStack(fsg_WorkSpaceAddr * pWorkSpaceAddr);

FS_PUBLIC void *      fsg_QueryReusableMemory(
	char *                  pWorkSpace,
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets);

FS_PUBLIC void fsg_CheckWorkSpaceForFit(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32                   lExtraWorkSpace,
	int32                   lMGWorkSpace,
	int32 *                 plSizeBitmap1,
	int32 *                 plSizeBitmap2);

FS_PUBLIC void  fsg_GetRealBitmapSizes(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plSizeBitmap1,
	 int32 *                     plSizeBitmap2);

FS_PUBLIC void  fsg_SetUpWorkSpaceBitmapMemory(
	 char *                      pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char *                  pClientBitmapPtr2,
	char *                  pClientBitmapPtr3,
	char **                 ppMemoryBase6,
	char **                 ppMemoryBase7);

FS_PUBLIC void  fsg_GetWorkSpaceExtra(
	 char *                      pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char **                 ppWorkSpaceExtra);

FS_PUBLIC void  fsg_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM);

FS_PUBLIC void  fsg_QueryPPEMXY(
	void *              pvGlobalGS,
	fsg_TransformRec *  TransformInfo,
	uint16 *            pusPPEMX,
	uint16 *            pusPPEMY,
	uint16 *            pusRotation);


/*      FSGlue Access Routines  */

FS_PUBLIC void  fsg_GetContourData(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
	boolean				bSubPixel,            
#endif // FSCFG_SUBPIXEL
	F26Dot6 **          pX,
	F26Dot6 **          pY,
	int16 **            pSp,
	int16 **            pEp,
	uint8 **            pOnCurve,
	uint8 **			pFc,
	uint16 *            pNc);

FS_PUBLIC uint32      fsg_GetContourDataSize(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr);

FS_PUBLIC void  fsg_DumpContourData(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 uint8 **               pbyOutline);

FS_PUBLIC void  fsg_RestoreContourData(
	 uint8 **               ppbyOutline,
	 F26Dot6 **             ppX,
	 F26Dot6 **             ppY,
	 int16 **               ppSp,
	 int16 **               ppEp,
	 uint8 **               ppOnCurve,
	 uint8 **               ppFc,
	 uint16 *               pNc);

FS_PUBLIC void  fsg_GetDevAdvanceWidth(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 point *                pDevAdvanceWidth);

FS_PUBLIC void  fsg_GetDevAdvanceHeight(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 point *                pDevAdvanceHeight);

FS_PUBLIC void  fsg_GetScaledCVT(
	char *                      pPrivateFontSpace,
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets,
	F26Dot6 **                  ppScaledCVT);

FS_PUBLIC void  fsg_45DegreePhaseShift(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr);

FS_PUBLIC void  fsg_UpdateAdvanceWidth (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAW,
	vectorType *        AdvanceWidth);

FS_PUBLIC void  fsg_UpdateAdvanceHeight (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAH,
	vectorType *        AdvanceHeight);

FS_PUBLIC void  fsg_ScaleVerticalMetrics (
    fsg_TransformRec *  TransformInfo,
    void *              pvGlobalGS,
	uint16              usNonScaledAH,
    int16               sNonScaledTSB,
	vectorType *        pvecAdvanceHeight,
	vectorType *        pvecTopSideBearing);

FS_PUBLIC void  fsg_CalcLSBsAndAdvanceWidths(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 F26Dot6                fxXMin,
	 F26Dot6                fxYMax,
	 point *                devAdvanceWidth,
	 point *                devLeftSideBearing,
	 point *                LeftSideBearing,
	 point *                devLeftSideBearingLine,
	 point *                LeftSideBearingLine);

FS_PUBLIC void  fsg_CalcTSBsAndAdvanceHeights(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 F26Dot6                fxXMin,
	 F26Dot6                fxYMax,
	 point *                devAdvanceHeight,
	 point *                devTopSideBearing,
	 point *                TopSideBearing,
	 point *                devTopSideBearingLine,
	 point *                TopSideBearingLine);

FS_PUBLIC boolean   fsg_IsTransformStretched(
	fsg_TransformRec *  TransformInfo);

FS_PUBLIC boolean   fsg_IsTransformRotated(
	fsg_TransformRec *  TransformInfo);

/*  Control Routines    */

FS_PUBLIC ErrorCode fsg_InitInterpreterTrans (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,     /* GlobalGS */
	Fixed               fxPointSize,
	int16               sXResolution,
	int16               sYResolution,
	boolean           bHintAtEmSquare,
	uint16             usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16             usEmboldWeighty,     /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16               sWinDescender,
	int32               lDescDev,               /* descender in device metric, used for clipping */
	int16 *            psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *            psBoldSimulVertShift   /* shift for emboldening simulation, vertically */
	);

FS_PUBLIC void  fsg_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16				flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    );

FS_PUBLIC ErrorCode fsg_RunFontProgram(
	 void *                 globalGS,           /* GlobalGS */
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 void *                 pvTwilightElement,
	 FntTraceFunc           traceFunc);

FS_PUBLIC ErrorCode fsg_RunPreProgram (
	 sfac_ClientRec *   ClientInfo,
	 LocalMaxProfile *  pMaxProfile,     /* Max Profile Table    */
	 fsg_TransformRec * TransformInfo,
	 void *                 pvGlobalGS,
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 void *                 pvTwilightElement,
	 FntTraceFunc           traceFunc);

FS_PUBLIC ErrorCode fsg_GridFit (
	 sfac_ClientRec *   ClientInfo,      /* sfnt Client information     */
	 LocalMaxProfile *  pMaxProfile,     /* Max Profile Table               */
	 fsg_TransformRec * TransformInfo,  /* Transformation information    */
	 void *                 pvGlobalGS,      /* GlobalGS                            */
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 void *                 pvTwilightElement,
	 FntTraceFunc           traceFunc,
	 boolean                bUseHints,
	 uint16 *               pusScanType,
	 boolean *              pbGlyphHasOutline,
	 uint16 *               pusNonScaledAW,
	boolean                bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean			    bSubPixel
#endif // FSCFG_SUBPIXEL
	 );

#ifdef  FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC  void fsg_InitializeData (void);
#endif

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void  fsg_CopyFontProgramResults(
	void *              pvGlobalGS,
	void *              pvGlobalGSSubPixel);


FS_PUBLIC void  fsg_ScaleToCompatibleWidth (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    Fixed   fxCompatibleWidthScale);  

FS_PUBLIC void  fsg_AdjustCompatibleMetrics (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX);  

FS_PUBLIC void  fsg_CalcDevHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX);

FS_PUBLIC void  fsg_CalcDevNatHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX);

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\sbit.h ===
/*********************************************************************

      sbit.h -- Embedded Bitmap Module Export Definitions

      (c) Copyright 1993-1996  Microsoft Corp.  All rights reserved.

      01/12/96  claudebe    Vertical metrics support
      02/07/95  deanb       Workspace pointers for GetMetrics & GetBitmap
      01/27/95  deanb       usShaveLeft & usShaveRight added to sbit state
      01/05/94  deanb       Bitmap scaling state
      11/29/93  deanb       First cut 
 
**********************************************************************/

/*      SBIT Module State Definition    */

typedef struct
{
    uint32  ulStrikeOffset;         /* into bloc or bsca */
    uint32  ulMetricsOffset;        /* may be either table */
    uint32  ulBitmapOffset;         /* into bdat table */
    uint32  ulBitmapLength;         /* bytes of bdat data */
    uint32  ulOutMemSize;           /* bytes of bitmap output data */
    uint32  ulWorkMemSize;          /* bytes of pre-scaled,rotated bitmap data */
    uint32  ulReadMemSize;          /* bytes of extra memory, to read gray sbit under scaling or rotation */
    uint16  usTableState;           /* unsearched, bloc, bsca, or not found */
    uint16  usPpemX;                /* x pixels per Em */
    uint16  usPpemY;                /* y pixels per Em */
    uint16  usSubPpemX;             /* substitute x ppem for bitmap scaling */
    uint16  usSubPpemY;             /* substitute y ppem for bitmap scaling */
	uint16	usRotation;				/* 0=none; 1=90; 2=180; 3=270; 4=other */
    uint16  usMetricsType;          /* horiz, vert, or big */
    uint16  usMetricsTable;         /* bloc or bdat */
    uint16  usBitmapFormat;         /* bdat definitions */
    uint16  usHeight;               /* bitmap rows */
    uint16  usWidth;                /* bitmap columns */
    uint16  usAdvanceWidth;         /* advance width */
    uint16  usAdvanceHeight;        /* advance height */     /* NEW */
    uint16  usOriginalRowBytes;     /* bytes per row (padded long) */
    uint16  usExpandedRowBytes;     /* bytes per row after grayscale expansion (padded long) */
    uint16  usScaledHeight;         /* scaled bitmap rows */
    uint16  usScaledWidth;          /* scaled bitmap columns */
    uint16  usScaledRowBytes;       /* scaled bytes per row (padded long) */
    uint16  usOutRowBytes;          /* reported bytes per row (for rotation) */
    uint16  usShaveLeft;            /* white pixels on left of bbox in format 5 */
    uint16  usShaveRight;           /* white pixels on right of bbox in format 5 */
    uint16  usShaveTop;             /* white pixels on top of bbox in format 5 */   /* NEW */
    uint16  usShaveBottom;          /* white pixels on bottom of bbox in format 5 */  /* NEW */
	int16   sLSBearingX;            /* left side bearing */
	int16   sLSBearingY;            /* y coord of top left corner */ 
	int16   sTopSBearingX;          /* top side bearing X */ /* NEW */
	int16   sTopSBearingY;          /* top side bearing Y */ /* NEW */
    boolean bGlyphFound;            /* TRUE if glyph found in strike */
    boolean bMetricsValid;          /* TRUE when metrics have been read */
	uint16  usEmResolution;			/* needed when substituting missing metrics */ /* NEW */
	uint16	usBitDepth;				/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint16	uBoldSimulHorShift;
	uint16	uBoldSimulVertShift;
} 
sbit_State;

/**********************************************************************/

/*      SBIT Export Prototypes      */

FS_PUBLIC ErrorCode sbit_NewTransform(
    sbit_State  *pSbit,
    uint16		usEmResolution,
    int16 	sBoldSimulHorShift,
    int16 	sBoldSimulVertShift,
    uint16          usPpemX,
    uint16          usPpemY,
    uint16          usRotation             /* 0 - 3 => 90 deg rotation, else not 90 */
);

FS_PUBLIC ErrorCode sbit_SearchForBitmap(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
	uint16			usGlyphCode,
	uint16          usOverScale,            /* outline magnification requested */
	uint16			*pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    uint16          *pusFoundCode           /* 0 = not found, 1 = bloc, 2 = bsca */
);

FS_PUBLIC ErrorCode sbit_GetDevAdvanceWidth (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvW 
);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC ErrorCode  sbit_CalcDevHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
	F26Dot6 *       pDevAdvanceWidthX,
	F26Dot6 *       pDevLeftSideBearingX,
	F26Dot6 *       pDevRightSideBearingX);
#endif // FSCFG_SUBPIXEL

FS_PUBLIC ErrorCode sbit_GetDevAdvanceHeight (	/* NEW */
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvH 
);

FS_PUBLIC ErrorCode sbit_GetMetrics (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvanceWidth,
    point           *pf26DevLeftSideBearing,
    point           *pf26LSB,
    point           *pf26DevAdvanceHeight, 	/* NEW */
    point           *pf26DevTopSideBearing,	/* NEW */
    point           *pf26TopSB,	/* NEW */
    Rect            *pRect,
    uint16          *pusRowBytes,
    uint32          *pulOutSize,
    uint32          *pulWorkSize
);

FS_PUBLIC ErrorCode sbit_GetBitmap (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    uint8           *pbyOut,
    uint8           *pbyWork
);


/**********************************************************************/

FS_PUBLIC void sbit_Embolden(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift);

FS_PUBLIC void sbit_EmboldenGray(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 usGrayLevels, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void sbit_EmboldenSubPixel(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 suBoldSimulHorShift, int16 sBoldSimulVertShift);
#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\fsglue.c ===
/*++
    File:       FSglue.c

    Contains:   xxx put contents here (or delete the whole line) xxx

    Written by: xxx put name of writer here (or delete the whole line) xxx

    Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
                (c) 1989-1999. Microsoft Corporation, all rights reserved.

    Change History (most recent first):


                 7/10/99  BeatS     Add support for native SP fonts, vertical RGB
         <>     10/14/97    CB      rename ASSERT into FS_ASSERT
         <>     02/21/97    CB      ClaudeBe, scaled component in composite glyphs
         <>     12/14/95    CB      add usNonScaledAH and sNonScaledTSB to  GlyphData
         <7>    11/27/90    MR      Need two scalars: one for (possibly rounded) outlines and cvt,
                                                    and one (always fractional) metrics. [rb]
         <6>    11/16/90    MR      Add SnapShotOutline to make instructions after components work
                                                    [rb]
         <5>     11/9/90    MR      Unrename fsg_ReleaseProgramPtrs to RELEASESFNTFRAG. [rb]
         <4>     11/5/90    MR      Change globalGS.ppemDot6 to globalGS.fpem, change all instrPtr
                                                    and curve flags to uint8. [rb]
         <3>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
         <2>    10/20/90    MR      Change matrix[2][2] back to a fract (in response to change in
                                                    skia). However, ReduceMatrix converts it to a fixed after it has
                                                    been used to "regularize" the matrix. Changed scaling routines
                                                    for outline and CVT to use integer pixelsPerEm. Removed
                                                    scaleFunc from the splineKey. Change some routines that were
                                                    calling FracDiv and FixDiv to use LongMulDiv and ShortMulDiv for
                                                    greater speed and precision. Removed fsg_InitScaling. [rb]
        <20>     8/22/90    MR      Only call fixmul when needed in finalComponentPass loop
        <19>      8/1/90    MR      Add line to set non90DegreeTransformation
        <18>     7/26/90    MR      remove references to metricInfo junk, don't include ToolUtils.h
        <17>     7/18/90    MR      Change error return type to int, split WorkSpace routine into
                                                    two calls, added SWAPW macros
        <16>     7/14/90    MR      Fixed reference to const SQRT2 to FIXEDSQRT2
        <15>     7/13/90    MR      Ansi-C stuff, tried to use correct sizes for variables to avoid
                                    coercion (sp?)
        <12>     6/21/90    MR      Add calls to ReleaseSfntFrag
        <11>      6/4/90    MR      Remove MVT, change matrix to have bottom right element be a
                                    fixed.
        <10>      6/1/90    MR      Thou shalt not pay no more attention to the MVT!
        <8+>     5/29/90    MR      look for problem in Max45Trick
         <8>     5/21/90    RB      bugfix in fsg_InitInterpreterTrans setting key->imageState
         <7>      5/9/90    MR      Fix bug in MoreThanXYStretch
         <6>      5/4/90    RB      support for new scan converter and decryption          mrr - add
                                    fsg_ReverseContours and key->reverseContour         to account
                                    for glyphs that are flipped.         This keeps the
                                    winding-number correct for         the scan converter.  Mike
                                    fixed fsg_Identity
         <5>      5/3/90    RB      support for new scan converter and decryption  mrr - add
                                    fsg_ReverseContours and key->reverseContour to account for
                                    glyphs that are flipped. This keeps the winding-number correct
                                    for the scan converter.
         <4>     4/10/90    CL      Fixed infinite loop counter - changed uint16 to int16 (Mikey).
         <3>     3/20/90    CL      Added HasPerspective for finding fast case
                                    Removed #ifdef SLOW, OLD
                                    Changed NormalizeTransformation to use fpem (16.16) and to use max instead of length
                                    and to loop instead of recurse.
                                    Removed compensation for int ppem in fsg_InitInterpreterTrans (not needed with fpem)
                                    Greased loops in PreTransformGlyph, PostTransformGlyph, LocalPostTransformGlyph,
                                                     ShiftChar, ZeroOutTwilightZone, InitLocalT
                                    Changed GetPreMultipliers to special case unit vector * 2x2 matrix
                                    Added support for ppemDot6 and pointSizeDot6
                                    Changed fsg_MxMul to treat the perspective elements as Fracts
                                    arrays to pointers in ScaleChar
                                    Fixed bugs in loops in posttransformglyph, convert loops to --numPts >= 0
         <2>     2/27/90    CL      It reconfigures itself during runtime !  New lsb and rsb
                                    calculation.  Shift bug in instructed components:  New error
                                    code for missing but needed table. (0x1409)  Optimization which
                                    has to do with shifting and copying ox/x and oy/y.  Fixed new
                                    format bug.  Changed transformed width calculation.  Fixed
                                    device metrics for transformed uninstructed sidebearing
                                    characters.  Dropoutcontrol scanconverter and SCANCTRL[]
                                    instruction.  Fixed transformed component bug.
                                    
       <3.3>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
                                    phantom points are in, even for components in a composite glyph.
                                    They should also work for transformations. Device metric are
                                    passed out in the output data structure. This should also work
                                    with transformations. Another leftsidebearing along the advance
                                    width vector is also passed out. whatever the metrics are for
                                    the component at it's level. Instructions are legal in
                                    components. The old perspective bug has been fixed. The
                                    transformation is internally automatically normalized. This
                                    should also solve the overflow problem we had. Changed
                                    sidebearing point calculations to use 16.16 precision. For zero
                                    or negative numbers in my tricky/fast square root computation it
                                    would go instable and loop forever. It was not able to handle
                                    large transformations correctly. This has been fixed and the
                                    normalization may call it self recursively to gain extra
                                    precision! It used to normalize an identity transformation
                                    unecessarily.
       <3.2>     10/6/89    CEL     Phantom points were removed causing a rounding of last 2 points
                                    bug. Characters would become distorted.
       <3.1>     9/27/89    CEL     Fixed transformation anchor point bug.
       <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
       <2.2>     8/14/89    sjk     1 point contours now OK
       <2.1>      8/8/89    sjk     Improved encryption handling
       <2.0>      8/2/89    sjk     Just fixed EASE comment
       <1.5>      8/1/89    sjk     Added composites and encryption. Plus some
                                    enhanclocalpostements.
       <1.4>     6/13/89    SJK     Comment
       <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
                                    bug, correct transformed integralized ppem behavior, pretty much
                                    so
       <1.2>     5/26/89    CEL     EASE messed up on "c" comments
      <y1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
       <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

    To Do:
*/
/* rwb r/24/90 - Add support for scanControlIn and scanControlOut variables in global graphiscs
 * state
 */
/** System Includes **/

#define FSCFG_INTERNAL

/** FontScaler's Includes **/
#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"
#include "fnt.h"
#include "interp.h"
#include "sfntaccs.h"
#include "fsglue.h"
#include "scale.h"

/*  CONSTANTS   */

/*  These constants are used for interpreting the scan control and scan type
    fields returned by the interpreter. They are documented in the TrueType
    specification under the SCANCTRL and SCANTYPE instructions.
 */

#define SCANINFO_SIZE_MASK   0x000000FF
#define SCANINFO_FLAGS_MASK  0x00003F00
#define SCANINFO_TYPE_MASK   0xFFFF0000
#define SCANINFO_SIZE_CLEAR  ~SCANINFO_SIZE_MASK
#define SCANINFO_FLAGS_CLEAR ~SCANINFO_FLAGS_MASK
#define SCANINFO_TYPE_CLEAR  ~SCANINFO_TYPE_MASK
#define SCANINFO_FLAGS_DONT  0x00003800
#define SCANINFO_FLAGS_DO    0x00000700
#define SCANCTRL_SIZE_MASK                   0x000000FF
#define SCANCTRL_DROPOUT_ALL_SIZES           0xFF
#define SCANCTRL_DROPOUT_IF_LESS             0x0100
#define SCANCTRL_DROPOUT_IF_ROTATED          0x0200
#define SCANCTRL_DROPOUT_IF_STRETCHED        0x0400
#define SCANCTRL_NODROP_UNLESS_LESS          0x0800
#define SCANCTRL_NODROP_UNLESS_ROTATED       0x1000
#define SCANCTRL_NODROP_UNLESS_STRETCH       0x2000
#define SCANTYPE_UNINITIALIZED               0xFFFF

/* fo the key->imageState field */
#define IMAGESTATE_ROTATED      0x0400
#define IMAGESTATE_STRETCHED    0x1000
#define IMAGESTATE_NON_POS_RECT 0x2000
#define IMAGESTATE_SIZE_MASK    0x00FF
#define IMAGESTATE_MAX_PPEM_SIZE 0x000000FF

#define COMPOSITE_ROOT                  0
#define MAX_TWILIGHT_CONTOURS       1
#define DEFAULT_COMPONENT_ELEMENTS  3UL
#define DEFAULT_COMPONENT_DEPTH     1UL
static  const   transMatrix   IdentTransform =
    {{{ONEFIX,      0,      0},
      {     0, ONEFIX,      0},
      {     0,      0, ONEFIX}}};

/*********** macros ************/

#define MAX(a, b)   (((a) > (b)) ? (a) : (b))

#define CHECK_GLYPHDATA(pglyphdata) FS_ASSERT((( (pglyphdata)->acIdent[0] == 'G') &&                            \
                                            ( (pglyphdata)->acIdent[1] == 'D')),"Illegal GlyphData pointer");
#define MAX_COMPONENT_DEPTH(pMaxProfile) (uint32)MAX (pMaxProfile->maxComponentDepth, DEFAULT_COMPONENT_DEPTH)
#define MAX_COMPONENT_ELEMENTS(pMaxProfile) (uint32)MAX (pMaxProfile->maxComponentElements, DEFAULT_COMPONENT_ELEMENTS)

#define MAX_NESTED_GLYPHS(pMaxProfile) (uint32)((MAX_COMPONENT_DEPTH(pMaxProfile) + 1) + MAX_COMPONENT_ELEMENTS(pMaxProfile));

/**********************************************************************************/
/*  TYPEDEFS    */

typedef enum {
    glyphSimple,
    glyphIncompleteComposite,
    glyphComposite,
    glyphUndefined
} GlyphTypes;


/* Glyph Data   */

typedef struct GlyphData GlyphData;

struct GlyphData{
    char        acIdent[2];             /* Identifier for GlyphData                         */
    GlyphData * pSibling;               /* Pointer to siblings                              */
    GlyphData * pChild;                 /* Pointer to children                              */
    GlyphData * pParent;                /* Pointer to parent                                */
    sfac_GHandle hGlyph;                /* Handle for font access                           */
    GlyphTypes  GlyphType;              /* Type of glyph                                    */
    uint16      usGlyphIndex;           /* Glyph Index                                      */
    BBOX        bbox;                   /* Bounding box for glyph                           */
    uint16      usNonScaledAW;          /* Nonscaled Advance Width                          */
    uint16      usNonScaledAH;          /* Nonscaled Advance Height                         */
    int16       sNonScaledLSB;          /* Nonscaled Left Side Bearing                      */
    int16       sNonScaledTSB;          /* Nonscaled Top Side Bearing                       */
    uint16      usDepth;                /* Depth of Glyph in composite tree                 */
    sfac_ComponentTypes MultiplexingIndicator;/* Flag for arguments of composites                */
    boolean     bRoundXYToGrid;         /* Round composite offsets to grid                  */
    int16       sXOffset;               /* X offset for composite (if supplied)             */
    int16       sYOffset;               /* Y offset for composite (if supplied)             */
    uint16      usAnchorPoint1;         /* Anchor Point 1 for composites (if not offsets)   */
    uint16      usAnchorPoint2;         /* Anchor Point 2 for composites (if not offsets)   */
    transMatrix mulT;                   /* Transformation matrix for composite              */
    boolean     bUseChildMetrics;       /* Should use child metrics?                        */
    boolean     bUseMyMetrics;          /* Is glyph USE_MY_METRICS?                         */
    boolean     bScaleCompositeOffset;  /* false by default, Apple scale the composite offset, MS doesn't */ 
    point       ptDevLSB;               /* Left Side Bearing Point                          */
    point       ptDevRSB;               /* Right Side Bearing Point                         */
    uint16      usScanType;             /* ScanType value for this glyph                    */
    uint16      usSizeOfInstructions;   /* Size (in bytes) of glyph instructions            */
    uint8 *     pbyInstructions;        /* Pointer to glyph instructions                    */
    fnt_ElementType * pGlyphElement;    /* Current glyph element pointer                    */

    /* the following variables were added to allow correct handling of scaled/rotated coposite glyphs */
    transMatrix currentTMatrix;         /* current Transf matrix, composite + user transform */
    boolean     bSameTransformAsMaster; /* same transformation as the master glyph, no composite scaling or rotation  */
};

/**********************************************************************************/

/* PRIVATE PROTOTYPES <4> */

FS_PRIVATE void fsg_GetOutlineSizeAndOffsets(
    uint16      usMaxPoints,
    uint16      usMaxContours,
    fsg_OutlineFieldInfo * offsetPtr,
    uint32 *    pulOutlineSize,
    uint32 *    pulReusableMarker);

FS_PRIVATE ErrorCode    fsg_CreateGlyphData(
    sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
    LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
    fsg_TransformRec *  TransformInfo,      /* Transformation information        */
    void *              pvGlobalGS,         /* GlobalGS                              */
    fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                     */
    fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
    FntTraceFunc        traceFunc,          /* Trace function for interpreter   */
    boolean             bUseHints,          /* True if glyph is gridfitted       */
    uint16 *            pusScanType,        /* ScanType value                        */
    boolean *           pbGlyphHasOutline,  /* Outline for glyph                 */
    uint16 *            pusNonScaledAW      /* Return NonScaled Advance Width    */
#ifdef FSCFG_SUBPIXEL
    ,boolean            bSubPixel
#endif // FSCFG_SUBPIXEL
    );
    
FS_PRIVATE ErrorCode   fsg_ExecuteGlyph(
    sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
    LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
    fsg_TransformRec *  TransformInfo,      /* Transformation information         */
    uint32              ulGlyphDataCount,   /* Max nested components */
    void *              pvGlobalGS,         /* GlobalGS                              */
    GlyphData *         pGlyphData,         /* GlyphData pointer                     */
    fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                     */
    fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
    FntTraceFunc        traceFunc,          /* Trace function for interpreter    */
    boolean             bUseHints,          /* True if glyph is gridfitted       */
    boolean *           pbHasOutline,      /* True if glyph has outline         */
    uint32*             pCompositePoints,   /* total number of point for composites, to check for overflow */
    uint32*             pCompositeContours  /* total number of contours for composites, to check for overflow */
#ifdef FSCFG_SUBPIXEL
    ,boolean            bSubPixel
#endif // FSCFG_SUBPIXEL
    );
    
FS_PRIVATE void fsg_ChooseNextGlyph(
    fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address        */
    GlyphData *         pGlyphData,         /* GlyphData pointer        */
    GlyphData **        ppNextGlyphData);   /* Next GlyphData pointer   */

FS_PRIVATE ErrorCode    fsg_SimpleInnerGridFit (
    void *              pvGlobalGS,
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    boolean             bUseHints,
    FntTraceFunc        traceFunc,
    uint16              usEmResolution,
    uint16              usNonScaledAW,
    uint16              usNonScaledAH,
    int16               sNonScaledLSB,
    int16               sNonScaledTSB,
    boolean             bSameTransformAsMaster, /* local transf. same as master transf.   */
    transMatrix         CurrentTMatrix,               /* Current Transformation   */
    BBOX *              bbox,
    uint16              usSizeOfInstructions,
    uint8 *             instructionPtr,
    uint16 *            pusScanType,
    uint16 *            pusScanControl,
    boolean *           pbChangeScanControl);

FS_PRIVATE ErrorCode    fsg_CompositeInnerGridFit (
    void *              pvGlobalGS,
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    boolean             bUseHints,
    FntTraceFunc        traceFunc,
    uint16              usEmResolution,
    uint16              usNonScaledAW,
    uint16              usNonScaledAH,
    int16               sNonScaledLSB,
    int16               sNonScaledTSB,
    boolean             bSameTransformAsMaster, /* local transf. same as master transf.   */
    transMatrix         CurrentTMatrix,               /* Current Transformation   */
    BBOX *              bbox,
    uint16              usSizeOfInstructions,
    uint8 *             instructionPtr,
    uint16 *            pusScanType,
    uint16 *            pusScanControl,
    boolean *           pbChangeScanControl);

FS_PRIVATE void fsg_LinkChild(
    GlyphData *     pGlyphData,             /* GlyphData pointer        */
    GlyphData *     pChildGlyphData);       /* Child GlyphData pointer  */

FS_PRIVATE ErrorCode fsg_MergeGlyphData(
    void *          pvGlobalGS,             /* GlobalGS            */
    GlyphData *     pChildGlyphData,       /* GlyphData pointer     */
    uint16          usEmResolution);

FS_PRIVATE void fsg_TransformChild(
    GlyphData *     pGlyphData);            /* GlyphData pointer    */

FS_PRIVATE void fsg_MergeScanType(
    GlyphData *     pGlyphData,             /* GlyphData pointer    */
    GlyphData *     pParentGlyphData);      /* GlyphData pointer    */

FS_PRIVATE boolean fsg_DoScanControl(
    uint16 usScanControl,
    uint32 ulImageState);

FS_PRIVATE void fsg_InitializeGlyphDataMemory(
    uint32                  ulGlyphDataCount,
    fsg_WorkSpaceAddr *     pWorkSpaceAddr);/* WorkSpace Address    */

FS_PRIVATE  ErrorCode fsg_AllocateGlyphDataMemory(
    uint32                  ulGlyphDataCount,
    fsg_WorkSpaceAddr *     pWorkSpaceAddr, /* WorkSpace Address    */
    GlyphData **            ppGlyphData);   /* GlyphData pointer    */

FS_PRIVATE void fsg_DeallocateGlyphDataMemory(
    fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address    */
    GlyphData *         pGlyphData);        /* GlyphData pointer    */

FS_PRIVATE void fsg_InitializeGlyphData(
    GlyphData *             pGlyphData,     /* GlyphData pointer    */
    fsg_WorkSpaceAddr *     pWorkSpaceAddr, /* WorkSpace Address    */
    uint16                  usGlyphIndex,   /* Glyph Index          */
    uint16                  usDepth);       /* Glyph depth          */

FS_PRIVATE void fsg_CheckFit(
    int32       lSize1,
    int32       lSize2,
    int32       lSize3,
    int32       lTotalSize,
    uint32 *    pfResult);

FS_PRIVATE void  fsg_Embold(
    fsg_WorkSpaceAddr * pWorkSpaceAddr,
    void *              pvGlobalGS,
    boolean             bUseHints, /* True if glyph is gridfitted       */
    boolean             bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
    ,boolean            bSubPixel
#endif // FSCFG_SUBPIXEL
    );     

void fsg_CheckOutlineOrientation (fnt_ElementType *pElement);

/* FSGlue Code  */

/* ..............MEMORY MANAGEMENT ROUTINES................ */


/*                                                              
 * fsg_PrivateFontSpaceSize : This data should remain intact for the life of the sfnt
 *              because function and instruction defs may be defined in the font program
 *              and/or the preprogram.
 */
/*

     PRIVATE SPACE Memory Layout

typedef struct fsg_PrivateSpaceOffsets {
     0  +===========+   ---------------------  <- PrivateSpaceOffsets.offset_storage;
        |           |
        |           |   TrueType Storage
        |           |
        +===========+   ---------------------  <- PrivateSpaceOffsets.offset_functions;
        |           |
        |           |   TrueType Function Defs
        |           |
        +===========+   ---------------------  <- PrivateSpaceOffsets.offset_instrDefs;
        |           |
        |           |   TrueType Instruction Defs
        |           |
        +===========+   ---------------------  <- PrivateSpaceOffsets.offset_controlValues;
        |           |
        |           |   TrueType Scaled CVT
        |           |
        +===========+   ---------------------  <- PrivateSpaceOffsets.offset_globalGS;
        | pStack    |
        | pStorage  |
        | pCVT      |
        | pFDEF     |   TrueType Global GS
        | pIDEF     |
        | pFPGM     |
        | pPPGM     |
        | pGlyphPgm |
        +===========+   ---------------------  <- PrivateSpaceOffsets.offset_FontProgram;
        |           |
        |           |   TrueType Font Program
        |           |
        +===========+   ---------------------  <- PrivateSpaceOffsets.offset_PreProgram;
        |           |
        |           |   TrueType Pre Program
        |           |
        +===========+   ---------------------  <- PrivateSpaceOffsets.offset_TwilightZone;
        |   poox    |
        +-----------+
        |    pox    |
        +-----------+
        |    px     |   Twilight Element
        +-----------+
        :   ...     :
        +-----------+
        |    pep    |
        +-----------+
        |    nc     |
        +===========+   ---------------------  <- PrivateSpaceOffsets.offset_TwilightOutline;
        |x[maxtzpts]|   Twilight Outline
        +-----------+
        |y[maxtzpts]|
        +-----------+
        :   ...     :
        +-----------+
        |ep[maxtzct]|
        +-----------+
        |ox[maxtzpt]|
        +-----------+
        |oox[mxtzpt]|
        +-----------+
        :   ...     :
        +-----------+
        |f[maxtzpts]|
        +===========+   ---------------------

*/
FS_PUBLIC uint32  fsg_PrivateFontSpaceSize (
    sfac_ClientRec *            ClientInfo,
    LocalMaxProfile *           pMaxProfile,      /* Max Profile Table    */
    fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets)
{
    uint32  ulOutlineSize;
    uint32  ulReusableMarker;   /* Unused dummy variable */
    uint32  ulLastOffset;

    PrivateSpaceOffsets->offset_storage         = 0L;
    PrivateSpaceOffsets->offset_functions       = PrivateSpaceOffsets->offset_storage         + (uint32)sizeof (F26Dot6) * (uint32)pMaxProfile->maxStorage;
    PrivateSpaceOffsets->offset_instrDefs       = PrivateSpaceOffsets->offset_functions   + (uint32)sizeof (fnt_funcDef) * (uint32)pMaxProfile->maxFunctionDefs;
    PrivateSpaceOffsets->offset_controlValues   = PrivateSpaceOffsets->offset_instrDefs   + (uint32)sizeof (fnt_instrDef) * (uint32)pMaxProfile->maxInstructionDefs;     /* <4> */
    PrivateSpaceOffsets->offset_globalGS        = PrivateSpaceOffsets->offset_controlValues + (uint32)sizeof (F26Dot6) *
        ((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue));

    ALIGN(voidPtr, PrivateSpaceOffsets->offset_globalGS);
#ifdef FSCFG_SUBPIXEL
    PrivateSpaceOffsets->offset_storageSubPixel         = PrivateSpaceOffsets->offset_globalGS    + (uint32)sizeof (fnt_GlobalGraphicStateType);
    PrivateSpaceOffsets->offset_functionsSubPixel       = PrivateSpaceOffsets->offset_storageSubPixel         + (uint32)sizeof (F26Dot6) * (uint32)pMaxProfile->maxStorage;
    PrivateSpaceOffsets->offset_instrDefsSubPixel       = PrivateSpaceOffsets->offset_functionsSubPixel   + (uint32)sizeof (fnt_funcDef) * (uint32)pMaxProfile->maxFunctionDefs;
    PrivateSpaceOffsets->offset_controlValuesSubPixel   = PrivateSpaceOffsets->offset_instrDefsSubPixel   + (uint32)sizeof (fnt_instrDef) * (uint32)pMaxProfile->maxInstructionDefs;     /* <4> */
    PrivateSpaceOffsets->offset_globalGSSubPixel        = PrivateSpaceOffsets->offset_controlValuesSubPixel + (uint32)sizeof (F26Dot6) *
        ((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue));

    ALIGN(voidPtr, PrivateSpaceOffsets->offset_globalGSSubPixel);
    PrivateSpaceOffsets->offset_FontProgram     = PrivateSpaceOffsets->offset_globalGSSubPixel + (uint32)sizeof (fnt_GlobalGraphicStateType);
#else
    PrivateSpaceOffsets->offset_FontProgram     = PrivateSpaceOffsets->offset_globalGS    + (uint32)sizeof (fnt_GlobalGraphicStateType);
#endif // FSCFG_SUBPIXEL
    PrivateSpaceOffsets->offset_PreProgram      = PrivateSpaceOffsets->offset_FontProgram + (uint32)SFAC_LENGTH (ClientInfo, sfnt_fontProgram);

    PrivateSpaceOffsets->offset_TwilightZone    = PrivateSpaceOffsets->offset_PreProgram      + (uint32)SFAC_LENGTH (ClientInfo, sfnt_preProgram);
    ALIGN(voidPtr, PrivateSpaceOffsets->offset_TwilightZone);

#ifdef FSCFG_SUBPIXEL
    PrivateSpaceOffsets->offset_TwilightZoneSubPixel    = PrivateSpaceOffsets->offset_TwilightZone + (uint32)sizeof (fnt_ElementType);
    ALIGN(voidPtr, PrivateSpaceOffsets->offset_TwilightZoneSubPixel);
/*
    Setup the twilight zone element data structure. This data structure will
    contain all of the address into the twilight zone outline space.
*/
    PrivateSpaceOffsets->offset_TwilightOutline = PrivateSpaceOffsets->offset_TwilightZoneSubPixel + (uint32)sizeof (fnt_ElementType);
    ALIGN(int32, PrivateSpaceOffsets->offset_TwilightOutline);
#else
/*
    Setup the twilight zone element data structure. This data structure will
    contain all of the address into the twilight zone outline space.
*/
    PrivateSpaceOffsets->offset_TwilightOutline = PrivateSpaceOffsets->offset_TwilightZone + (uint32)sizeof (fnt_ElementType);
    ALIGN(int32, PrivateSpaceOffsets->offset_TwilightOutline);
    ulLastOffset = PrivateSpaceOffsets->offset_TwilightOutline;
#endif // FSCFG_SUBPIXEL

/*
    Setup Twilight Zone outline space. This space contains all of the components
    to describe a Twilight Zone outline. Set the offset to our current position,
    and as we calculate the size of this outline space, update the field
    offsets e.g. x, ox, oox, &c.
*/
    /*** Outline -- TWILIGHT ZONE ***/

    fsg_GetOutlineSizeAndOffsets(
        pMaxProfile->maxTwilightPoints,
        MAX_TWILIGHT_CONTOURS,
        &(PrivateSpaceOffsets->TwilightOutlineFieldOffsets),
        &ulOutlineSize,
        &ulReusableMarker);

#ifdef FSCFG_SUBPIXEL
    PrivateSpaceOffsets->offset_TwilightOutlineSubPixel = PrivateSpaceOffsets->offset_TwilightOutline + ulOutlineSize;
    ALIGN(int32, PrivateSpaceOffsets->offset_TwilightOutlineSubPixel);
    ulLastOffset = PrivateSpaceOffsets->offset_TwilightOutlineSubPixel;
#endif // FSCFG_SUBPIXEL

#ifdef FSCFG_FONTOGRAPHER_BUG
/*
        Fontographer 3.5 has a bug. This is causing numerous symbol fonts to
        have the critical error : Inst: RCVT CVT Out of range. CVT = 255
        This flag is meant to be set under Windows. If will cause additional
        memory to be allocated for the CVT if necessary in order to be sure
        that this illegal read will access memory within the legal range.
        Under a secure rasterizer, this flag will cause RCVT with CVT <= 255
        and CVT > NumCvt to be classified as error instead of critical error */

    if ((ulLastOffset + ulOutlineSize) - PrivateSpaceOffsets->offset_controlValues < 256 * (uint32)sizeof (F26Dot6))
    {
        ulOutlineSize = (256 * (uint32)sizeof (F26Dot6)) + PrivateSpaceOffsets->offset_controlValues - ulLastOffset;
    }
#endif // FSCFG_FONTOGRAPHER_BUG

    return ((ulLastOffset + ulOutlineSize) - PrivateSpaceOffsets->offset_storage);
}


/*                          
 * fsg_WorkSpaceSetOffsets : This stuff changes with each glyph
 *
 * Computes the workspace size and sets the offsets into it.
 *
 */

/*

    WORKSPACE Memory Layout

      0 +===========+    ---------------------  <- WorkSpaceOffsets.ulGlyphElementOffset
        |   poox    |
        +-----------+
        |    pox    |
        +-----------+
        |    px     |   Glyph Element 1
        +-----------+
        :   ...     :
        +-----------+
        |    pep    |
        +-----------+
        |    nc     |
        +===========+   ---------------------
        |   poox    |
        +-----------+
        |    pox    |
        +-----------+
        |    px     |   Glyph Element 2
        +-----------+
        :   ...     :
        +-----------+
        |    pep    |
        +-----------+
        |    nc     |
        +===========+   ---------------------
        |           |
        :           :          :
        |           |
        +===========+   ---------------------
        |   poox    |
        +-----------+
        |    pox    |
        +-----------+
        |    px     |   Glyph Element [MaxComponentDepth + 1]
        +-----------+
        :   ...     :
        +-----------+
        |    pep    |
        +-----------+
        |    nc     |
        +===========+   ---------------------  <- WorkSpaceOffsets.ulGlyphOutlineOffset
        |x[maxpts]  |   Glyph Outline
        +-----------+
        |y[maxpts]  |
        +-----------+
        :   ...     :
        +-----------+
        |ep[maxctrs]|
        +-----------+
        |ox[maxpts] |   <- WorkSpaceOffsets.ulReusableMemoryOffset


        !!! with SubPixel, we need to put the ulReusableMemoryOffset after ox because of the conversion done in GetContourData !!!
        +-----------+
        |oox[maxpts]|
        +-----------+
        :   ...     :
        +-----------+
        |f[maxpts]  |
        +===========+   ---------------------  <- WorkSpaceOffsets.ulGlyphDataByteSetBaseOffset
        | T| F| T| F|
        +-----------+
        | F| F| F| F|
        +-----------+
        | F| F| F| F|   Glyph Data Allocation ByteSet
        +-----------+   (number of bytes = ulGlyphDataCount)
        | F| F| F| F|
        +-----------+
        | F| F| F| F|
        +===========+   ---------------------  <- WorkSpaceOffsets.ulGlyphDataBaseOffset
        |  acIdent  |
        +-----------+
        | pSibling  |
        +-----------+
        |  pChild   |
        +-----------+
        |  pParent  |
        +-----------+   GlyphData 1
        |  hGlyph   |
        +-----------+
        | GlyphType |
        +-----------+
        :           :
        +-----------+
        |GlyphElemnt|
        +===========+   ---------------------
        |  acIdent  |
        +-----------+
        | pSibling  |
        +-----------+
        |  pChild   |
        +-----------+
        |  pParent  |
        +-----------+   GlyphData 2
        |  hGlyph   |
        +-----------+
        | GlyphType |
        +-----------+
        :           :
        +-----------+
        |GlyphElemnt|
        +===========+   ---------------------
        |           |
        :           :           :
        |           |
        +===========+   ---------------------
        |  acIdent  |
        +-----------+
        | pSibling  |
        +-----------+
        |  pChild   |
        +-----------+
        |  pParent  |
        +-----------+   GlyphData [ulGlyphDataCount]
        |  hGlyph   |
        +-----------+
        | GlyphType |
        +-----------+
        :           :
        +-----------+
        |GlyphElemnt|
        +===========+   ---------------------  <- WorkSpaceOffsets.ulStackOffset
        |           |
        |           |
        |           |   Stack
        |           |
        |           |
        |           |
        +===========+   ---------------------

*/

FS_PUBLIC uint32    fsg_WorkSpaceSetOffsets (
    LocalMaxProfile *        pMaxProfile,    /* Max Profile Table    */
    fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
    int32 *                 plExtraWorkSpace)
{
    uint32                       ulOutlineDataSize;
    uint32                       ulWorkSpacePos;
    uint32                       ulGlyphDataCount;
    uint16                       maxStackElements;

    ulWorkSpacePos = 0UL;

/*
    Setup the glyph element data array. This data structure contains all of the
    addresses into the glyph outline space. There are the same number of glyph
    element arrays as there are outline spaces; this allows us to handle the
    worstcase composite in the font.
*/
    WorkSpaceOffsets->ulGlyphElementOffset = ulWorkSpacePos;
    ulWorkSpacePos += (uint32)sizeof (fnt_ElementType) *
          (uint32)(MAX_COMPONENT_DEPTH(pMaxProfile) + 1);

/*** Outline -- GLYPH *****/
/*
    Setup Glyph outline space. This space contains all of the components
    to describe a Glyph outline. Set the offset to our current position,
    and as we calculate the size of this outline space, update the elemental
    offsets e.g. x, ox, oox, &c.

    Once we have calculated the size of one outline space, we will duly note
    its size, and then add enough space to handle the outlines for the worst
    case composite depth in the font.
*/
    ALIGN(int16, ulWorkSpacePos);
    WorkSpaceOffsets->ulGlyphOutlineOffset = ulWorkSpacePos; /* Remember start of Glyph Element */

    fsg_GetOutlineSizeAndOffsets(
        (uint16)(PHANTOMCOUNT + MAX (pMaxProfile->maxPoints, pMaxProfile->maxCompositePoints)),
        (uint16)MAX (pMaxProfile->maxContours, pMaxProfile->maxCompositeContours),
        &(WorkSpaceOffsets->GlyphOutlineFieldOffsets),
        &ulOutlineDataSize,
        (uint32 *)&(WorkSpaceOffsets->ulReusableMemoryOffset));

    /* Adjust Reusable memory marker to be based from zero, rather than GlyphOutline */

    WorkSpaceOffsets->ulReusableMemoryOffset += WorkSpaceOffsets->ulGlyphOutlineOffset;

    ulWorkSpacePos += ulOutlineDataSize;
/*
    Set the GlyphData ByteSet array. This array is used to track the memory used
    in GlyphData. Each entry in this array is a boolean.  One needs to also
    calculate the number of GlyphData's that will be needed to handle the
    worstcase composite in the font.
*/
    ALIGN(boolean, ulWorkSpacePos);
    WorkSpaceOffsets->ulGlyphDataByteSetOffset = ulWorkSpacePos;
    ulGlyphDataCount = MAX_NESTED_GLYPHS(pMaxProfile);

    ulWorkSpacePos += ulGlyphDataCount * (uint32)sizeof (boolean);
/*
    Set up the GlyphData array. This array contains the information needed
    to describe composites and components for a glyph.
*/
    ALIGN(voidPtr, ulWorkSpacePos);
    WorkSpaceOffsets->ulGlyphDataOffset = ulWorkSpacePos;
    ulWorkSpacePos += (uint32)sizeof(GlyphData) * ulGlyphDataCount;


    ALIGN(F26Dot6, ulWorkSpacePos);
    WorkSpaceOffsets->ulStackOffset = ulWorkSpacePos;

    maxStackElements = pMaxProfile->maxStackElements;

#ifdef FSCFG_EUDC_EDITOR_BUG
    if (maxStackElements == 0)
    {
        maxStackElements = 1;
    }
#endif // FSCFG_EUDC_EDITOR_BUG

    ulWorkSpacePos += (uint32)maxStackElements * (uint32)sizeof (F26Dot6);

/* Calculate amount of extra memory */

    *plExtraWorkSpace = (int32)ulWorkSpacePos - (int32)WorkSpaceOffsets->ulReusableMemoryOffset;
    WorkSpaceOffsets->ulMemoryBase6Offset = 0L;
    WorkSpaceOffsets->ulMemoryBase7Offset = 0L;

/* Return the total size of the WorkSpace memory.   */

    return(ulWorkSpacePos);

}

FS_PRIVATE void fsg_GetOutlineSizeAndOffsets(
    uint16                  usMaxPoints,
    uint16                  usMaxContours,
    fsg_OutlineFieldInfo *  offsetPtr,
    uint32 *                pulOutlineSize,
    uint32 *                pulReusableMarker)

{
    uint32      ulArraySize;

    offsetPtr->onCurve = 0;

    *pulOutlineSize    = (uint32)usMaxPoints * (uint32)sizeof (uint8);
    ALIGN(int16, *pulOutlineSize);

    offsetPtr->sp   = *pulOutlineSize;
    ulArraySize = (uint32)usMaxContours * (uint32)sizeof (int16);
    *pulOutlineSize += ulArraySize;
    offsetPtr->ep   = *pulOutlineSize;
    *pulOutlineSize += ulArraySize;

    /* need to be before the reusable marker, now that this flag is exported */
    offsetPtr->fc       = *pulOutlineSize;
    *pulOutlineSize    += (uint32)usMaxContours * (uint32)sizeof (uint8);

    ALIGN(F26Dot6, *pulOutlineSize);
    offsetPtr->x       = *pulOutlineSize;
    ulArraySize = (uint32)usMaxPoints * (uint32)sizeof (F26Dot6);
    *pulOutlineSize    += ulArraySize;
    offsetPtr->y       = *pulOutlineSize;
    *pulOutlineSize    += ulArraySize;

#ifndef FSCFG_SUBPIXEL
    *pulReusableMarker = *pulOutlineSize;
    ALIGN(voidPtr, *pulReusableMarker);
#endif // FSCFG_SUBPIXEL
    /* Everything below this point can be reused during contour scanning */

    offsetPtr->ox      = *pulOutlineSize;
    *pulOutlineSize    += ulArraySize;

#ifdef FSCFG_SUBPIXEL
    *pulReusableMarker = *pulOutlineSize;
    ALIGN(voidPtr, *pulReusableMarker);
#endif // FSCFG_SUBPIXEL

    offsetPtr->oy      = *pulOutlineSize;
    *pulOutlineSize    += ulArraySize;

    offsetPtr->oox     = *pulOutlineSize;
    *pulOutlineSize    += ulArraySize;
    offsetPtr->ooy     = *pulOutlineSize;
    *pulOutlineSize    += ulArraySize;

    offsetPtr->f       = *pulOutlineSize;
    *pulOutlineSize    += (uint32)usMaxPoints * (uint32)sizeof (uint8);

    ALIGN(int32, *pulOutlineSize);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
    offsetPtr->pcr      = *pulOutlineSize;
    *pulOutlineSize    += (uint32)usMaxPoints * (uint32)sizeof (PhaseControlRelation);
#endif

}


FS_PUBLIC void  fsg_UpdatePrivateSpaceAddresses(
    sfac_ClientRec *        ClientInfo,     /* Cached sfnt information  */
    LocalMaxProfile *       pMaxProfile,     /* Max Profile Table         */
    char *                  pPrivateFontSpace,
    fsg_PrivateSpaceOffsets * PrivateSpaceOffsets,
    void *                  pvStack,        /* pointer to stack         */
    void **                 pvFontProgram,  /* pointer to font program  */
    void **                 pvPreProgram)   /* pointer to pre program   */
{
    void *                       pvGlobalGS;
    void *                       pvCVT;          /* pointer to CVT  */
    void *                       pvStore;
    void *                       pvFuncDef;
    void *                       pvInstrDef;
    uint32                       ulLengthFontProgram, ulLengthPreProgram;

    pvCVT =         pPrivateFontSpace + PrivateSpaceOffsets->offset_controlValues;
    pvStore =       pPrivateFontSpace + PrivateSpaceOffsets->offset_storage;
    pvFuncDef =     pPrivateFontSpace + PrivateSpaceOffsets->offset_functions;
    pvInstrDef =    pPrivateFontSpace + PrivateSpaceOffsets->offset_instrDefs;
    pvGlobalGS =    pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGS;

    *pvFontProgram =  pPrivateFontSpace + PrivateSpaceOffsets->offset_FontProgram;
    ulLengthFontProgram = SFAC_LENGTH(ClientInfo, sfnt_fontProgram);
    *pvPreProgram =   pPrivateFontSpace + PrivateSpaceOffsets->offset_PreProgram;
    ulLengthPreProgram = SFAC_LENGTH(ClientInfo, sfnt_preProgram);

    itrp_UpdateGlobalGS(pvGlobalGS, pvCVT, pvStore, pvFuncDef, pvInstrDef, pvStack,
        pMaxProfile, (uint16)((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue)),
        ulLengthFontProgram, *pvFontProgram, ulLengthPreProgram, *pvPreProgram, ClientInfo->lClientID);

#ifdef FSCFG_SUBPIXEL
    /* prepare the second pvGlobalGS for SubPixel compatible width */
    pvCVT =         pPrivateFontSpace + PrivateSpaceOffsets->offset_controlValuesSubPixel;
    pvStore =       pPrivateFontSpace + PrivateSpaceOffsets->offset_storageSubPixel;
    pvFuncDef =     pPrivateFontSpace + PrivateSpaceOffsets->offset_functionsSubPixel;
    pvInstrDef =    pPrivateFontSpace + PrivateSpaceOffsets->offset_instrDefsSubPixel;
    pvGlobalGS =    pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGSSubPixel;

    itrp_UpdateGlobalGS(pvGlobalGS, pvCVT, pvStore, pvFuncDef, pvInstrDef, pvStack,
        pMaxProfile, (uint16)((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue)),
        ulLengthFontProgram, *pvFontProgram, ulLengthPreProgram, *pvPreProgram, ClientInfo->lClientID);
#endif // FSCFG_SUBPIXEL

}

FS_PUBLIC void  fsg_UpdateWorkSpaceAddresses(
    char *                  pWorkSpace,
    fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
    fsg_WorkSpaceAddr *     pWorkSpaceAddr)
{
    pWorkSpaceAddr->pStack = (F26Dot6 *)(WorkSpaceOffsets->ulStackOffset + pWorkSpace);
    pWorkSpaceAddr->pGlyphOutlineBase = WorkSpaceOffsets->ulGlyphOutlineOffset + pWorkSpace;
    pWorkSpaceAddr->pGlyphElement = (fnt_ElementType *)(WorkSpaceOffsets->ulGlyphElementOffset + pWorkSpace);
    pWorkSpaceAddr->pGlyphDataByteSet = (boolean *)(WorkSpaceOffsets->ulGlyphDataByteSetOffset + pWorkSpace);
    pWorkSpaceAddr->pvGlyphData = (void *)(WorkSpaceOffsets->ulGlyphDataOffset + pWorkSpace);
    pWorkSpaceAddr->pReusableMemoryMarker = WorkSpaceOffsets->ulReusableMemoryOffset + pWorkSpace;
}

FS_PUBLIC void  fsg_UpdateWorkSpaceElement(
    fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
    fsg_WorkSpaceAddr *     pWorkSpaceAddr)
{
    char *                  pOutlineBase;
    fnt_ElementType *       pGlyphElement;        /* Address of Glyph Element array   */
    fsg_OutlineFieldInfo *  pOffset;

    pOutlineBase =  (char *)pWorkSpaceAddr->pGlyphOutlineBase;
    pGlyphElement = pWorkSpaceAddr->pGlyphElement;

    /* Note: only the first level glyph element has address updated. Second */
    /* levels are updated when referenced.                                           */

    pOffset             = & (WorkSpaceOffsets->GlyphOutlineFieldOffsets);

    pGlyphElement->x        = (F26Dot6 *) (pOutlineBase + pOffset->x);
    pGlyphElement->y        = (F26Dot6 *) (pOutlineBase + pOffset->y);
    pGlyphElement->ox       = (F26Dot6 *) (pOutlineBase + pOffset->ox);
    pGlyphElement->oy       = (F26Dot6 *) (pOutlineBase + pOffset->oy);
    pGlyphElement->oox      = (F26Dot6 *) (pOutlineBase + pOffset->oox);
    pGlyphElement->ooy      = (F26Dot6 *) (pOutlineBase + pOffset->ooy);
    pGlyphElement->sp       = (int16 *) (pOutlineBase + pOffset->sp);
    pGlyphElement->ep       = (int16 *) (pOutlineBase + pOffset->ep);
    pGlyphElement->onCurve  = (uint8 *) (pOutlineBase + pOffset->onCurve);
    pGlyphElement->f        = (uint8 *) (pOutlineBase + pOffset->f);

    pGlyphElement->fc       = (uint8 *) (pOutlineBase + pOffset->fc);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
    pGlyphElement->pcr      = (PhaseControlRelation *) (pOutlineBase + pOffset->pcr);
#endif
}

FS_PUBLIC void *    fsg_QueryGlobalGS(
    char *                  pPrivateFontSpace,
    fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
    return ((void *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGS));
}

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *    fsg_QueryGlobalGSSubPixel(
    char *                  pPrivateFontSpace,
    fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
    return ((void *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGSSubPixel));
}
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryTwilightElement(
    char *                  pPrivateFontSpace,
    fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
    fnt_ElementType *        pTwilightElement; /* Address of Twilight Zone Element */
    fsg_OutlineFieldInfo *  pOffset;
    char *                       pTemp;

    pOffset                 = &(PrivateSpaceOffsets->TwilightOutlineFieldOffsets);
    pTemp                   = pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightOutline;
    pTwilightElement        = (fnt_ElementType *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightZone);

    pTwilightElement->x         = (F26Dot6 *) (pTemp + pOffset->x);
    pTwilightElement->y         = (F26Dot6 *) (pTemp + pOffset->y);
    pTwilightElement->ox        = (F26Dot6 *) (pTemp + pOffset->ox);
    pTwilightElement->oy        = (F26Dot6 *) (pTemp + pOffset->oy);
    pTwilightElement->oox       = (F26Dot6 *) (pTemp + pOffset->oox);
    pTwilightElement->ooy       = (F26Dot6 *) (pTemp + pOffset->ooy);
    pTwilightElement->sp        = (int16 *) (pTemp + pOffset->sp);
    pTwilightElement->ep        = (int16 *) (pTemp + pOffset->ep);
    pTwilightElement->onCurve   = (uint8 *) (pTemp + pOffset->onCurve);
    pTwilightElement->f         = (uint8 *) (pTemp + pOffset->f);

    pTwilightElement->fc        = (uint8 *) (pTemp + pOffset->fc);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
    pTwilightElement->pcr       = (PhaseControlRelation *) (pTemp + pOffset->pcr);
#endif

    return (void *)pTwilightElement;
}

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *      fsg_QueryTwilightElementSubPixel(
    char *                  pPrivateFontSpace,
    fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
    fnt_ElementType *        pTwilightElement; /* Address of Twilight Zone Element */
    fsg_OutlineFieldInfo *  pOffset;
    char *                       pTemp;

    pOffset                 = &(PrivateSpaceOffsets->TwilightOutlineFieldOffsets);
    pTemp                   = pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightOutlineSubPixel;
    pTwilightElement        = (fnt_ElementType *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightZoneSubPixel);

    pTwilightElement->x         = (F26Dot6 *) (pTemp + pOffset->x);
    pTwilightElement->y         = (F26Dot6 *) (pTemp + pOffset->y);
    pTwilightElement->ox        = (F26Dot6 *) (pTemp + pOffset->ox);
    pTwilightElement->oy        = (F26Dot6 *) (pTemp + pOffset->oy);
    pTwilightElement->oox       = (F26Dot6 *) (pTemp + pOffset->oox);
    pTwilightElement->ooy       = (F26Dot6 *) (pTemp + pOffset->ooy);
    pTwilightElement->sp        = (int16 *) (pTemp + pOffset->sp);
    pTwilightElement->ep        = (int16 *) (pTemp + pOffset->ep);
    pTwilightElement->onCurve   = (uint8 *) (pTemp + pOffset->onCurve);
    pTwilightElement->f         = (uint8 *) (pTemp + pOffset->f);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
    pTwilightElement->pcr       = (PhaseControlRelation *) (pTemp + pOffset->pcr);
#endif
    return (void *)pTwilightElement;
}
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryStack(fsg_WorkSpaceAddr * pWorkSpaceAddr)
{
    /* we don't allow the stack to be used to pass informations between pre-program and glyph program
       or between two glyph programs */
    return ((void *)pWorkSpaceAddr->pStack);
}

FS_PUBLIC void *      fsg_QueryReusableMemory(
    char *                  pWorkSpace,
    fsg_WorkSpaceOffsets *  WorkSpaceOffsets)
{
    return pWorkSpace + WorkSpaceOffsets->ulReusableMemoryOffset;
}

FS_PUBLIC void  fsg_CheckWorkSpaceForFit(
    fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
    int32                   lExtraWorkSpace,
    int32                   lMGWorkSpace,
    int32 *                 plSizeBitmap1,
    int32 *                 plSizeBitmap2)
{
    uint32              ulMemoryOffset;

    ulMemoryOffset = WorkSpaceOffsets->ulReusableMemoryOffset;

    ulMemoryOffset += (uint32)lMGWorkSpace;  /* correct for MeasureGlyph Workspace */
    lExtraWorkSpace -= lMGWorkSpace;

    WorkSpaceOffsets->ulMemoryBase6Offset = 0L;
    WorkSpaceOffsets->ulMemoryBase7Offset = 0L;

    /* Save original sizes */

    WorkSpaceOffsets->ulMemoryBase6Size = *plSizeBitmap1;
    WorkSpaceOffsets->ulMemoryBase7Size = *plSizeBitmap2;

    if( *plSizeBitmap1 > *plSizeBitmap2)
    {
        if( *plSizeBitmap1 <= lExtraWorkSpace )
        {
            WorkSpaceOffsets->ulMemoryBase6Offset = ulMemoryOffset;
            ulMemoryOffset += (uint32)*plSizeBitmap1;

            if (( *plSizeBitmap2 <= lExtraWorkSpace - *plSizeBitmap1 ) &&
                ( *plSizeBitmap2 > 0L ))
            {
                WorkSpaceOffsets->ulMemoryBase7Offset = ulMemoryOffset;
                *plSizeBitmap2 = 0L;
            }
            *plSizeBitmap1 = 0L;
        }
        else if (( *plSizeBitmap2 <= lExtraWorkSpace ) &&
                 ( *plSizeBitmap2 > 0L))
        {
            WorkSpaceOffsets->ulMemoryBase7Offset = ulMemoryOffset;
            *plSizeBitmap2 = 0L;
        }

    }
    else  /* (plSizeBitmap1 <= *plSizeBitmap2) */
    {
        if(( *plSizeBitmap2 <= lExtraWorkSpace ) &&
           ( *plSizeBitmap2 > 0L ))
        {
            WorkSpaceOffsets->ulMemoryBase7Offset = ulMemoryOffset;
            ulMemoryOffset += (uint32)*plSizeBitmap2;

            if (( *plSizeBitmap1 <= lExtraWorkSpace - *plSizeBitmap2 ) &&
                 ( *plSizeBitmap1 > 0L ))
            {
                WorkSpaceOffsets->ulMemoryBase6Offset = ulMemoryOffset;
                *plSizeBitmap1 = 0L;
            }
            *plSizeBitmap2 = 0L;
        }
        else if (( *plSizeBitmap1 <= lExtraWorkSpace ) &&
                 ( *plSizeBitmap1 > 0L ))
        {
            WorkSpaceOffsets->ulMemoryBase6Offset = ulMemoryOffset;
            *plSizeBitmap1 = 0L;
        }
    }
}

FS_PUBLIC void  fsg_GetRealBitmapSizes(
    fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
    int32 *                 plSizeBitmap1,
    int32 *                 plSizeBitmap2)
{
     *plSizeBitmap1 = WorkSpaceOffsets->ulMemoryBase6Size;
     *plSizeBitmap2 = WorkSpaceOffsets->ulMemoryBase7Size;
}

FS_PUBLIC void  fsg_SetUpWorkSpaceBitmapMemory(
    char *                  pWorkSpace,
    fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
    char *                  pClientBitmapPtr2,
    char *                  pClientBitmapPtr3,
    char **                 ppMemoryBase6,
    char **                 ppMemoryBase7)
{
    if(WorkSpaceOffsets->ulMemoryBase6Offset != 0L)
    {
        *ppMemoryBase6 = WorkSpaceOffsets->ulMemoryBase6Offset + (char *)pWorkSpace;
    }
    else
    {
        *ppMemoryBase6 = pClientBitmapPtr2;
    }

    if(WorkSpaceOffsets->ulMemoryBase7Offset != 0L)
    {
          *ppMemoryBase7 = WorkSpaceOffsets->ulMemoryBase7Offset + (char *)pWorkSpace;
    }
    else
    {
        *ppMemoryBase7 = pClientBitmapPtr3;
    }
}

FS_PUBLIC void  fsg_GetWorkSpaceExtra(
    char *                  pWorkSpace,
    fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
    char **                 ppWorkSpaceExtra)
{
     *ppWorkSpaceExtra = (char *)(pWorkSpace + WorkSpaceOffsets->ulReusableMemoryOffset);
}

FS_PUBLIC void  fsg_QueryPPEM(
    void *      pvGlobalGS,
    uint16 *    pusPPEM)
{
    scl_QueryPPEM(pvGlobalGS, pusPPEM);
}

/*  Return PPEM in both X and Y and 90 degree rotation factor for sbit matching */

FS_PUBLIC void  fsg_QueryPPEMXY(
    void *              pvGlobalGS,
    fsg_TransformRec *  TransformInfo,
    uint16 *            pusPPEMX,
    uint16 *            pusPPEMY,
    uint16 *            pusRotation)
{
    *pusRotation = mth_90degRotationFactor( &TransformInfo->currentTMatrix );
    scl_QueryPPEMXY(pvGlobalGS, pusPPEMX, pusPPEMY);
}


/*  FSGlue Access Routines  */

FS_PUBLIC void  fsg_GetContourData(
    fsg_WorkSpaceAddr * pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
    boolean             bSubPixel,            
#endif // FSCFG_SUBPIXEL
    F26Dot6 **          pX,
    F26Dot6 **          pY,
    int16 **            pSp,
    int16 **            pEp,
    uint8 **            pOnCurve,
    uint8 **            pFc,
    uint16 *            pNc)
{
    fnt_ElementType *   pElement;

    pElement = pWorkSpaceAddr->pGlyphElement;

    *pX =       pElement->x;
    *pY =       pElement->y;
    *pSp =      pElement->sp;
    *pEp =      pElement->ep;
    *pOnCurve = pElement->onCurve;
    *pFc =     pElement->fc;
    *pNc      = (uint16)pElement->nc;
#ifdef FSCFG_SUBPIXEL
    if (bSubPixel)
    {
        /* we scale down the coordinate from x,y into ox, oy and return those */
        scl_ScaleDownFromSubPixelOverscale(pElement);
        *pX =       pElement->ox;
    }
#endif // FSCFG_SUBPIXEL
}

FS_PUBLIC uint32      fsg_GetContourDataSize(
    fsg_WorkSpaceAddr * pWorkSpaceAddr)
{
    fnt_ElementType *   pElement;

    pElement = pWorkSpaceAddr->pGlyphElement;

    return( scl_GetContourDataSize( pElement ) );
}

FS_PUBLIC void  fsg_DumpContourData(
    fsg_WorkSpaceAddr * pWorkSpaceAddr,
    uint8 **            ppbyOutline)
{
    fnt_ElementType *   pElement;

    pElement = pWorkSpaceAddr->pGlyphElement;

    scl_DumpContourData(pElement, ppbyOutline);
}

FS_PUBLIC void  fsg_RestoreContourData(
    uint8 **        ppbyOutline,
    F26Dot6 **      ppX,
    F26Dot6 **      ppY,
    int16 **        ppSp,
    int16 **        ppEp,
    uint8 **        ppOnCurve,
    uint8 **        ppFc,
    uint16 *        pNc)
{
    fnt_ElementType     pElement;

    scl_RestoreContourData(&pElement, ppbyOutline);

    *ppX =          pElement.x;
    *ppY =          pElement.y;
    *ppSp =         pElement.sp;
    *ppEp =         pElement.ep;
    *ppOnCurve =    pElement.onCurve;
    *ppFc =         pElement.fc;
    *pNc =          (uint16)pElement.nc;
}

FS_PUBLIC void  fsg_GetDevAdvanceWidth(
    fsg_WorkSpaceAddr * pWorkSpaceAddr,
    point *             pDevAdvanceWidth)
{
    fnt_ElementType *   pElement;

    pElement = pWorkSpaceAddr->pGlyphElement;

    scl_CalcDevAdvanceWidth(pElement, pDevAdvanceWidth);
}

FS_PUBLIC void  fsg_GetDevAdvanceHeight(
    fsg_WorkSpaceAddr * pWorkSpaceAddr,
    point *             pDevAdvanceHeight)
{
    fnt_ElementType *   pElement;

    pElement = pWorkSpaceAddr->pGlyphElement;

    scl_CalcDevAdvanceHeight(pElement, pDevAdvanceHeight);
}

FS_PUBLIC void  fsg_GetScaledCVT(
    char *                      pPrivateFontSpace,
    fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets,
    F26Dot6 **                  ppScaledCVT)
{
    *ppScaledCVT = (F26Dot6 *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_controlValues);
}

FS_PUBLIC void  fsg_45DegreePhaseShift(
    fsg_WorkSpaceAddr * pWorkSpaceAddr)
{
    fnt_ElementType *   pElement;

    pElement = pWorkSpaceAddr->pGlyphElement;

    scl_45DegreePhaseShift(pElement);
}

FS_PUBLIC void  fsg_UpdateAdvanceWidth (
    fsg_TransformRec *  TransformInfo,
    void *              pvGlobalGS,
    uint16              usNonScaledAW,
    vectorType *        AdvanceWidth)
{
    AdvanceWidth->y = 0;
    scl_ScaleAdvanceWidth(
        pvGlobalGS,
        AdvanceWidth,
        usNonScaledAW,
        TransformInfo->bPositiveSquare,
        TransformInfo->usEmResolution,
        &TransformInfo->currentTMatrix);
}

FS_PUBLIC void  fsg_UpdateAdvanceHeight (
    fsg_TransformRec *  TransformInfo,
    void *              pvGlobalGS,
    uint16              usNonScaledAH,
    vectorType *        AdvanceHeight)
{
    AdvanceHeight->x = 0;
    scl_ScaleAdvanceHeight(
        pvGlobalGS,
        AdvanceHeight,
        usNonScaledAH,
        TransformInfo->bPositiveSquare,
        TransformInfo->usEmResolution,
        &TransformInfo->currentTMatrix);
}


FS_PUBLIC void  fsg_ScaleVerticalMetrics (
    fsg_TransformRec *  TransformInfo,
    void *              pvGlobalGS,
    uint16              usNonScaledAH,
    int16               sNonScaledTSB,
    vectorType *        pvecAdvanceHeight,
    vectorType *        pvecTopSideBearing )
{
    pvecAdvanceHeight->x = 0;           /* start with x values at zero */
    pvecTopSideBearing->x = 0;          /* since 'vmtx' refers to y values */

    scl_ScaleVerticalMetrics (
        pvGlobalGS,
        usNonScaledAH,
        sNonScaledTSB,
        TransformInfo->bPositiveSquare,
        TransformInfo->usEmResolution,
        &TransformInfo->currentTMatrix,
        pvecAdvanceHeight,
        pvecTopSideBearing);
}


FS_PUBLIC void  fsg_CalcLSBsAndAdvanceWidths(
    fsg_WorkSpaceAddr *     pWorkSpaceAddr,
    F26Dot6                 fxXMin,
    F26Dot6                 fxYMax,
    point *                 devAdvanceWidth,
    point *                 devLeftSideBearing,
    point *                 LeftSideBearing,
    point *                 devLeftSideBearingLine,
    point *                 LeftSideBearingLine)
{
    fnt_ElementType *   pElement;

    pElement = pWorkSpaceAddr->pGlyphElement;

    scl_CalcLSBsAndAdvanceWidths(
        pElement,
        fxXMin,
        fxYMax,
        devAdvanceWidth,
        devLeftSideBearing,
        LeftSideBearing,
        devLeftSideBearingLine,
        LeftSideBearingLine);
}

FS_PUBLIC void  fsg_CalcTSBsAndAdvanceHeights(
    fsg_WorkSpaceAddr *     pWorkSpaceAddr,
    F26Dot6                 fxXMin,
    F26Dot6                 fxYMax,
    point *                 devAdvanceHeight,
    point *                 devTopSideBearing,
    point *                 TopSideBearing,
    point *                 devTopSideBearingLine,
    point *                 TopSideBearingLine)
{
    fnt_ElementType *   pElement;

    pElement = pWorkSpaceAddr->pGlyphElement;

    scl_CalcTSBsAndAdvanceHeights(
        pElement,
        fxXMin,
        fxYMax,
        devAdvanceHeight,
        devTopSideBearing,
        TopSideBearing,
        devTopSideBearingLine,
        TopSideBearingLine);
}

FS_PUBLIC boolean   fsg_IsTransformStretched(
    fsg_TransformRec *  TransformInfo)
{
    return (boolean)(( TransformInfo->ulImageState & IMAGESTATE_STRETCHED ) == IMAGESTATE_STRETCHED);
}

FS_PUBLIC boolean   fsg_IsTransformRotated(
    fsg_TransformRec *  TransformInfo)
{
    return (boolean)(( TransformInfo->ulImageState & IMAGESTATE_ROTATED ) == IMAGESTATE_ROTATED);
}

/*  Control Routines    */

FS_PUBLIC ErrorCode fsg_InitInterpreterTrans (
    fsg_TransformRec *  TransformInfo,
    void *              pvGlobalGS,
    Fixed               fxPointSize,
    int16               sXResolution,
    int16               sYResolution,
    boolean           bHintAtEmSquare,
    uint16            usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
    uint16              usEmboldWeighty,     /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
    int16               sWinDescender,
    int32               lDescDev,               /* descender in device metric, used for clipping */
    int16 *             psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
    int16 *             psBoldSimulVertShift   /* shift for emboldening simulation, vertically */
    )
{
    ErrorCode       error;
    uint32          ulPixelsPerEm;
    transMatrix *   trans;

    trans = &TransformInfo->currentTMatrix;

    error = scl_InitializeScaling(
        pvGlobalGS,
        TransformInfo->bIntegerScaling,
        &TransformInfo->currentTMatrix,
        TransformInfo->usEmResolution,
        fxPointSize,
        sXResolution,
        sYResolution,
        usEmboldWeightx,       /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
        usEmboldWeighty,      /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
        sWinDescender,
        lDescDev,
        psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
        psBoldSimulVertShift,   /* shift for emboldening simulation, vertically */
        bHintAtEmSquare,
        &ulPixelsPerEm);

    if(error)
    {
        return error;
    }

    TransformInfo->bPhaseShift = false;

    if ( ulPixelsPerEm > IMAGESTATE_MAX_PPEM_SIZE )
    {
        TransformInfo->ulImageState = (uint32)IMAGESTATE_MAX_PPEM_SIZE;
    }
    else
    {
        TransformInfo->ulImageState = ulPixelsPerEm;
    }

    TransformInfo->bPositiveSquare = mth_PositiveSquare( trans );

    if ( !(mth_PositiveRectangle( trans )))
    {
        TransformInfo->ulImageState |= IMAGESTATE_NON_POS_RECT;
    }

    if ( !(TransformInfo->bPositiveSquare) )
    {
        if( mth_GeneralRotation (trans))
        {
            TransformInfo->ulImageState |=  IMAGESTATE_ROTATED;
        }

        TransformInfo->ulImageState |= IMAGESTATE_STRETCHED;

        TransformInfo->bPhaseShift = mth_IsMatrixStretched(trans); /*<8>*/
    }

    TransformInfo->bEmboldSimulation = ((usEmboldWeightx != 0) || (usEmboldWeighty != 0)); 

    return NO_ERR;
}

FS_PUBLIC void  fsg_SetHintFlags(
    void *              pvGlobalGS,
    boolean             bHintForGray
#ifdef FSCFG_SUBPIXEL
    ,uint16             flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    )
{
    scl_SetHintFlags(
        pvGlobalGS,
        bHintForGray
#ifdef FSCFG_SUBPIXEL
        ,flHintForSubPixel
#endif // FSCFG_SUBPIXEL
        );
}
/*
 *  All this guy does is record FDEFs and IDEFs, anything else is ILLEGAL
 */
FS_PUBLIC ErrorCode fsg_RunFontProgram(
    void *                  pvGlobalGS,               /* GlobalGS     */
    fsg_WorkSpaceAddr *     pWorkSpaceAddr,
    void *                  pvTwilightElement,
    FntTraceFunc           traceFunc)
{
	itrp_ResetMaxInstructionCounter(pvGlobalGS);

    return itrp_ExecuteFontPgm (
        (fnt_ElementType *)pvTwilightElement,
        pWorkSpaceAddr->pGlyphElement,
        pvGlobalGS,
        traceFunc);
}

/*
 * fsg_RunPreProgram
 *
 * Runs the pre-program and scales the control value table
 *
 */
FS_PUBLIC ErrorCode fsg_RunPreProgram (
    sfac_ClientRec *    ClientInfo,
    LocalMaxProfile *   pMaxProfile,     /* Max Profile Table    */
    fsg_TransformRec *  TransformInfo,
    void *              pvGlobalGS,
    fsg_WorkSpaceAddr * pWorkSpaceAddr,
    void *              pvTwilightElement,
    FntTraceFunc        traceFunc)
{
    ErrorCode           result;
    F26Dot6 *           pfxCVT;
    fnt_ElementType *   pTwilightElement;

    pTwilightElement = (fnt_ElementType *)pvTwilightElement;

	itrp_ResetMaxInstructionCounter(pvGlobalGS);

    result = itrp_SetDefaults (pvGlobalGS, TransformInfo->fxPixelDiameter);

    if (result != NO_ERR)
    {
        return result;
    }

    scl_GetCVTPtr(pvGlobalGS, &pfxCVT);

    result = sfac_CopyCVT(ClientInfo, pfxCVT);

    if (result != NO_ERR)
    {
        return result;
    }

    scl_ScaleCVT (pvGlobalGS, pfxCVT);

    scl_InitializeTwilightContours(
        pTwilightElement,
        (int16)pMaxProfile->maxTwilightPoints,
        MAX_TWILIGHT_CONTOURS);

    scl_ZeroOutlineData(
        pTwilightElement,
        pMaxProfile->maxTwilightPoints,
        MAX_TWILIGHT_CONTOURS);

    result = itrp_ExecutePrePgm (
        pTwilightElement,
        pWorkSpaceAddr->pGlyphElement,
        pvGlobalGS,
        traceFunc);

    return result;
}

/*
 *      fsg_GridFit
 */
FS_PUBLIC ErrorCode fsg_GridFit (
    sfac_ClientRec *    ClientInfo,     /* sfnt Client information      */
    LocalMaxProfile *   pMaxProfile,    /* Max Profile Table            */
    fsg_TransformRec *  TransformInfo,  /* Transformation information   */
    void *              pvGlobalGS,     /* GlobalGS                     */
    fsg_WorkSpaceAddr * pWorkSpaceAddr,
    void *              pvTwilightElement,
    FntTraceFunc        traceFunc,
    boolean             bUseHints,
    uint16 *            pusScanType,
    boolean *           pbGlyphHasOutline,
    uint16 *            pusNonScaledAW,
    boolean            bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
    ,boolean            bSubPixel
#endif // FSCFG_SUBPIXEL
    )
{
    ErrorCode           result;
    fnt_ElementType *   pTwilightElement;
    fnt_GlobalGraphicStateType *globalGS;

    globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

    pTwilightElement = (fnt_ElementType *)pvTwilightElement;

    scl_InitializeTwilightContours(
        pTwilightElement,
        (int16)pMaxProfile->maxTwilightPoints,
        MAX_TWILIGHT_CONTOURS);

    result = fsg_CreateGlyphData (
        ClientInfo,
        pMaxProfile,
        TransformInfo,
        pvGlobalGS,
        pWorkSpaceAddr,
        pTwilightElement,
        traceFunc,
        bUseHints,
        pusScanType,
        pbGlyphHasOutline,
        pusNonScaledAW
#ifdef FSCFG_SUBPIXEL
        ,bSubPixel
#endif // FSCFG_SUBPIXEL
        );

    if(result == NO_ERR)
    {
        if (TransformInfo->bEmboldSimulation)
        {
            fsg_Embold( pWorkSpaceAddr, pvGlobalGS, bUseHints, bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
                    ,bSubPixel
#endif // FSCFG_SUBPIXEL
            );
            if(*pusNonScaledAW)
                *pusNonScaledAW +=  (TransformInfo->usEmResolution * 2 - 1) / 100; /* adjust pusNonScaledAW by 2% of Em height */
        }

        if ((TransformInfo->ulImageState & (IMAGESTATE_NON_POS_RECT)) || globalGS->bHintAtEmSquare)
        {
            scl_PostTransformGlyph (
                pvGlobalGS,
                pWorkSpaceAddr->pGlyphElement,
                &TransformInfo->currentTMatrix);
        }

        /* apply the translation part of the transformation matrix */
        scl_ApplyTranslation (
            pWorkSpaceAddr->pGlyphElement,
            &TransformInfo->currentTMatrix,
            bUseHints,
            globalGS->bHintAtEmSquare
#ifdef FSCFG_SUBPIXEL
            ,bSubPixel
#endif // FSCFG_SUBPIXEL
            );
    }
    return result;
}

FS_PRIVATE ErrorCode    fsg_CreateGlyphData(
    sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
    LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
    fsg_TransformRec *  TransformInfo,      /* Transformation information        */
    void *              pvGlobalGS,         /* GlobalGS                              */
    fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                     */
    fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
    FntTraceFunc        traceFunc,          /* Trace function for interpreter    */
    boolean             bUseHints,          /* True if glyph is gridfitted       */
    uint16 *            pusScanType,        /* ScanType value                        */
    boolean *           pbGlyphHasOutline,  /* Outline for glyph                 */
    uint16 *            pusNonScaledAW      /* Return NonScaled Advance Width    */
#ifdef FSCFG_SUBPIXEL
    ,boolean            bSubPixel
#endif // FSCFG_SUBPIXEL
    )
{
    GlyphData * pGlyphData;
    GlyphData * pNextGlyphData;
    boolean      bHasOutline;
    uint32       ulGlyphDataCount;
    ErrorCode   ReturnCode;
    uint32      CompositePoints = 0;
    uint32      CompositeContours = 0;

    *pbGlyphHasOutline = FALSE;
    bHasOutline = FALSE;

    ulGlyphDataCount = MAX_NESTED_GLYPHS(pMaxProfile);

    fsg_InitializeGlyphDataMemory(ulGlyphDataCount, pWorkSpaceAddr);
    ReturnCode = fsg_AllocateGlyphDataMemory(ulGlyphDataCount, pWorkSpaceAddr, &pGlyphData); /* Allocates GlyphData for topmost   */
    if(ReturnCode != NO_ERR)
    {
        return ReturnCode;
    }
                                                 /* parent  */
    fsg_InitializeGlyphData(pGlyphData, pWorkSpaceAddr,
        ClientInfo->usGlyphIndex, COMPOSITE_ROOT);

    itrp_ResetMaxInstructionCounter(pvGlobalGS);
    while(pGlyphData != NULL)
    {
        CHECK_GLYPHDATA( pGlyphData );

        ReturnCode = fsg_ExecuteGlyph(
            ClientInfo,
            pMaxProfile,
            TransformInfo,
            ulGlyphDataCount,
            pvGlobalGS,
            pGlyphData,
            pWorkSpaceAddr,
            pTwilightElement,
            traceFunc,
            bUseHints,
            &bHasOutline,
            &CompositePoints,
            &CompositeContours
#ifdef FSCFG_SUBPIXEL
            ,bSubPixel
#endif // FSCFG_SUBPIXEL
            );
        if(ReturnCode)
        {
            return ReturnCode;
        }
        *pbGlyphHasOutline |= bHasOutline;
        *pusScanType = pGlyphData->usScanType;
        fsg_ChooseNextGlyph(pWorkSpaceAddr, pGlyphData, &pNextGlyphData);
        *pusNonScaledAW = pGlyphData->usNonScaledAW;
        pGlyphData = pNextGlyphData;
    }

    return NO_ERR;
}

FS_PRIVATE ErrorCode    fsg_ExecuteGlyph(
    sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
    LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
    fsg_TransformRec *  TransformInfo,      /* Transformation information         */
    uint32              ulGlyphDataCount,   /* Max Number of nested glyphs */
    void *              pvGlobalGS,         /* GlobalGS                              */
    GlyphData *         pGlyphData,         /* GlyphData pointer                     */
    fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                      */
    fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
    FntTraceFunc        traceFunc,          /* Trace function for interpreter    */
    boolean             bUseHints,          /* True if glyph is gridfitted       */
    boolean *           pbHasOutline,       /* True if glyph has outline         */
    uint32*                pCompositePoints,/* total number of point for composites, to check for overflow */
    uint32*                pCompositeContours  /* total number of contours for composites, to check for overflow */
#ifdef FSCFG_SUBPIXEL
    ,boolean            bSubPixel
#endif // FSCFG_SUBPIXEL
    )
{
    ErrorCode       ReturnCode;
    boolean         bCompositeGlyph;
    boolean         bLastComponent;
    boolean         bWeHaveInstructions;
    boolean         bWeHaveCompositeInstructions;
    boolean         bScanInfoChanged;
    boolean         bWeHaveAScale;
    uint16          usScanType;
    uint16          usScanControl;
    GlyphData *     pChildGlyphData;
    uint16          usComponentElementCount;
    uint16          contour;

    *pbHasOutline = FALSE;

    if (pGlyphData->GlyphType == glyphUndefined)
    {
        if(pGlyphData->pParent != NULL)
        {
            scl_IncrementChildElement(pGlyphData->pGlyphElement, pGlyphData->pParent->pGlyphElement);
        } else {
            pGlyphData->currentTMatrix = TransformInfo->currentTMatrix;
        }

        ReturnCode = sfac_ReadGlyphHeader(ClientInfo, pGlyphData->usGlyphIndex,
            &pGlyphData->hGlyph, &bCompositeGlyph, pbHasOutline,
            &pGlyphData->pGlyphElement->nc, &pGlyphData->bbox);

        if(ReturnCode != NO_ERR)
        {
            return ReturnCode;
        }

        /* Get advance width, advance height, left side bearing and top side bearing information  */

        ReturnCode = sfac_ReadGlyphMetrics(
            ClientInfo, pGlyphData->usGlyphIndex,
            &pGlyphData->usNonScaledAW, &pGlyphData->usNonScaledAH, 
            &pGlyphData->sNonScaledLSB, &pGlyphData->sNonScaledTSB);

        if(ReturnCode != NO_ERR)
        {
            return ReturnCode;
        }

        if (bCompositeGlyph)
        {
            pGlyphData->GlyphType = glyphIncompleteComposite;
        }
        else
        {
            pGlyphData->GlyphType = glyphSimple;
        }
    }

    if (pGlyphData->GlyphType == glyphSimple)
    {
        ReturnCode = sfac_ReadOutlineData(
            pGlyphData->pGlyphElement->onCurve,
            pGlyphData->pGlyphElement->ooy, pGlyphData->pGlyphElement->oox,
            &pGlyphData->hGlyph, pMaxProfile, *pbHasOutline, pGlyphData->pGlyphElement->nc,
            pGlyphData->pGlyphElement->sp, pGlyphData->pGlyphElement->ep,
            &pGlyphData->usSizeOfInstructions, &pGlyphData->pbyInstructions,
            pCompositePoints, pCompositeContours);

        if(ReturnCode != NO_ERR)
        {
            return ReturnCode;
        }

        if (TransformInfo->bEmboldSimulation 
#ifdef FSCFG_SUBPIXEL
            || bSubPixel
#endif // FSCFG_SUBPIXEL
            )
        {
            // in gdi we use the outline orientation test only for outline emboldening and subpixel rendering
            // doing that all the time affect performance
            fsg_CheckOutlineOrientation (pGlyphData->pGlyphElement);
        }
        else
        {
            int32 Contour;

            for (Contour = 0; Contour < pGlyphData->pGlyphElement->nc; Contour++)
            {
                pGlyphData->pGlyphElement->fc[Contour] = 0;
            }
        }

        ReturnCode = fsg_SimpleInnerGridFit(
            pvGlobalGS,
            pTwilightElement,
            pGlyphData->pGlyphElement,
            bUseHints,
            traceFunc,
            TransformInfo->usEmResolution,
            pGlyphData->usNonScaledAW,
            pGlyphData->usNonScaledAH,
            pGlyphData->sNonScaledLSB,
            pGlyphData->sNonScaledTSB,
            pGlyphData->bSameTransformAsMaster, /* current transf. same as master transf.   */
            pGlyphData->currentTMatrix, /* current transf. : user + composite transf. */
            &pGlyphData->bbox,
            pGlyphData->usSizeOfInstructions,
            pGlyphData->pbyInstructions,
            &usScanType,
            &usScanControl,
            &bScanInfoChanged);

        if(ReturnCode != NO_ERR)
        {
            return ReturnCode;
        }

        if( ! fsg_DoScanControl(usScanControl, TransformInfo->ulImageState))
        {
            pGlyphData->usScanType = SK_NODROPOUT;
        }
        else
        {
            pGlyphData->usScanType = usScanType;
        }

        // here we update the contour orientation bit if necessary, to reflect the final orientation of the contours in the composite
        if (FixMul(pGlyphData->mulT.transform[0][0],pGlyphData->mulT.transform[1][1]) - FixMul(pGlyphData->mulT.transform[0][1],pGlyphData->mulT.transform[1][0]) < 0) {
            for (contour = 0; contour < pGlyphData->pGlyphElement->nc; contour++) {
                pGlyphData->pGlyphElement->fc[contour] ^= OUTLINE_MISORIENTED;
            }
        }

        if (pGlyphData->pParent != NULL)
        {
            ReturnCode = fsg_MergeGlyphData(pvGlobalGS, pGlyphData, TransformInfo->usEmResolution);

            if(ReturnCode != NO_ERR)
            {
                return ReturnCode;
            }
        }

        ReturnCode = sfac_ReleaseGlyph(ClientInfo, &pGlyphData->hGlyph);

        if(ReturnCode != NO_ERR)
        {
            return ReturnCode;
        }

        pGlyphData->pbyInstructions = 0;
        pGlyphData->usSizeOfInstructions = 0;
    }
    else if (pGlyphData->GlyphType == glyphComposite)
    {
        ReturnCode = fsg_CompositeInnerGridFit(
            pvGlobalGS,
            pTwilightElement,
            pGlyphData->pGlyphElement,
            bUseHints,
            traceFunc,
            TransformInfo->usEmResolution,
            pGlyphData->usNonScaledAW,
            pGlyphData->usNonScaledAH,
            pGlyphData->sNonScaledLSB,
            pGlyphData->sNonScaledTSB,
            pGlyphData->bSameTransformAsMaster, /* current transf. same as master transf.   */
            pGlyphData->currentTMatrix, /* current transf. : user + composite transf. */
            &pGlyphData->bbox,
            pGlyphData->usSizeOfInstructions,
            pGlyphData->pbyInstructions,
            &usScanType,
            &usScanControl,
            &bScanInfoChanged);

        if(ReturnCode != NO_ERR)
        {
            return ReturnCode;
        }

        if (pGlyphData->bUseChildMetrics)
        {
            scl_SetSideBearingPoints(
                pGlyphData->pGlyphElement,
                &pGlyphData->ptDevLSB,
                &pGlyphData->ptDevRSB);
        }

        /* If composite has set SCANCTRL, use that value, otherwise merged children */

        if(bScanInfoChanged)
        {
            if( ! fsg_DoScanControl(usScanControl, TransformInfo->ulImageState))
            {
                pGlyphData->usScanType = SK_NODROPOUT;
            }
            else
            {
                pGlyphData->usScanType = usScanType;
            }
        }

        if (pGlyphData->pParent != NULL)
        {
            ReturnCode = fsg_MergeGlyphData(pvGlobalGS, pGlyphData, TransformInfo->usEmResolution);

            if(ReturnCode != NO_ERR)
            {
                return ReturnCode;
            }
        }

        ReturnCode = sfac_ReleaseGlyph(ClientInfo, &pGlyphData->hGlyph);

        if(ReturnCode != NO_ERR)
        {
            return ReturnCode;
        }

        pGlyphData->pbyInstructions = 0;
        pGlyphData->usSizeOfInstructions = 0;
    }
    else if (pGlyphData->GlyphType == glyphIncompleteComposite)
    {
        bLastComponent = FALSE;
        bWeHaveInstructions = FALSE;
        bWeHaveCompositeInstructions = FALSE;

        pGlyphData->GlyphType = glyphComposite;

        usComponentElementCount = 0;

        do
        {
            if(pGlyphData->usDepth + 1UL > MAX_COMPONENT_DEPTH(pMaxProfile))
            {
                return BAD_MAXP_DATA;
            }

            usComponentElementCount++;

            if(usComponentElementCount > MAX_COMPONENT_ELEMENTS(pMaxProfile))
            {
                return BAD_MAXP_DATA;
            }

            ReturnCode = fsg_AllocateGlyphDataMemory(ulGlyphDataCount, pWorkSpaceAddr, &pChildGlyphData);
            if(ReturnCode != NO_ERR)
            {
                return ReturnCode;
            }

            fsg_InitializeGlyphData(
                pChildGlyphData,
                pWorkSpaceAddr,
                NULL_GLYPH,
                (uint16)(pGlyphData->usDepth + 1U) );

            fsg_LinkChild(pGlyphData, pChildGlyphData);

            ReturnCode = sfac_ReadComponentData(
                &pGlyphData->hGlyph,
                &pChildGlyphData->MultiplexingIndicator,
                &pChildGlyphData->bRoundXYToGrid,
                &pChildGlyphData->bUseMyMetrics,
                &pChildGlyphData->bScaleCompositeOffset,
                &bWeHaveInstructions,
                &pChildGlyphData->usGlyphIndex,
                &pChildGlyphData->sXOffset,
                &pChildGlyphData->sYOffset,
                &pChildGlyphData->usAnchorPoint1,
                &pChildGlyphData->usAnchorPoint2,
                &pChildGlyphData->mulT,
                &bWeHaveAScale,
                &bLastComponent);

            if (pChildGlyphData->usGlyphIndex >= pMaxProfile->numGlyphs)
            {
                return COMPOSITE_INVALID_GLYPH_INDEX;
            }

            if (bWeHaveAScale)
            {
                mth_MxConcat2x2( &pChildGlyphData->mulT, &pChildGlyphData->currentTMatrix );
                if (!mth_UnitarySquare(&pChildGlyphData->mulT))
                {
                    pChildGlyphData->bSameTransformAsMaster = FALSE; /* the component is scaled/rotated */
                }

            }

            if(ReturnCode != NO_ERR)
            {
                return ReturnCode;
            }

            bWeHaveCompositeInstructions |= bWeHaveInstructions;
        }
        while (!bLastComponent);

        if(bWeHaveCompositeInstructions)
        {
            ReturnCode = sfac_ReadCompositeInstructions(
                &pGlyphData->hGlyph,
                &pGlyphData->pbyInstructions,
                &pGlyphData->usSizeOfInstructions);

            if(ReturnCode != NO_ERR)
            {
                return ReturnCode;
            }
        }

    }
    return NO_ERR;
}


/*
 *      fsg_SimpleInnerGridFit
 */
FS_PRIVATE ErrorCode    fsg_SimpleInnerGridFit (
    void *              pvGlobalGS,
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    boolean             bUseHints,
    FntTraceFunc        traceFunc,
    uint16              usEmResolution,
    uint16              usNonScaledAW,
    uint16              usNonScaledAH,
    int16               sNonScaledLSB,
    int16               sNonScaledTSB,
    boolean             bSameTransformAsMaster, /* local transf. same as master transf.   */
    transMatrix         CurrentTMatrix,                  /* Current Transformation   */
    BBOX *              bbox,
    uint16              usSizeOfInstructions,
    uint8 *             instructionPtr,
    uint16 *            pusScanType,
    uint16 *            pusScanControl,
    boolean *           pbChangeScanControl)
{
    ErrorCode           result;
/*
    On entry to fsg_SimpleInnerGrid fit the element structure should
    contain only valid original points (oox, ooy). The original points
    will be scaled into the old points (ox, oy) and those will be
    copied into the current points (x, y).
*/
    itrp_SetCompositeFlag(pvGlobalGS, FALSE);

    itrp_QueryScanInfo(pvGlobalGS, pusScanType, pusScanControl);
    *pbChangeScanControl = FALSE;

    scl_CalcOrigPhantomPoints(pGlyphElement, bbox, sNonScaledLSB, sNonScaledTSB, usNonScaledAW, usNonScaledAH);

    if (itrp_bApplyHints(pvGlobalGS) && bUseHints)
    {
        itrp_SetSameTransformFlag(pvGlobalGS, bSameTransformAsMaster);

        if (!bSameTransformAsMaster)
        {
            scl_InitializeChildScaling(
                pvGlobalGS,
                CurrentTMatrix,
                usEmResolution);
        }

        /* hint and same transformation as master glyph */
        scl_ScaleOldCharPoints (pGlyphElement, pvGlobalGS);
        scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

        scl_AdjustOldCharSideBearing(pGlyphElement
#ifdef FSCFG_SUBPIXEL
            , pvGlobalGS
#endif
            );
        scl_AdjustOldPhantomSideBearing(pGlyphElement
#ifdef FSCFG_SUBPIXEL
            , pvGlobalGS
#endif
            );

        scl_CopyCurrentCharPoints(pGlyphElement);
        scl_CopyCurrentPhantomPoints(pGlyphElement);

        scl_RoundCurrentSideBearingPnt(pGlyphElement, pvGlobalGS, usEmResolution);

        if (usSizeOfInstructions > 0)
        {
            scl_ZeroOutlineFlags(pGlyphElement);

            result = itrp_ExecuteGlyphPgm (
                pTwilightElement,
                pGlyphElement,
                instructionPtr,
                instructionPtr + usSizeOfInstructions,
                pvGlobalGS,
                traceFunc,
                pusScanType,
                pusScanControl,
                pbChangeScanControl);

            if(result != NO_ERR)
            {
                return result;
            }

        }

        if (!bSameTransformAsMaster)
        {
            /* scale back to fixed FUnits */
            scl_ScaleBackCurrentCharPoints (pGlyphElement, pvGlobalGS);
            scl_ScaleBackCurrentPhantomPoints (pGlyphElement, pvGlobalGS);
        }
    }
    else 
        /* no hints */
    {
        if (bSameTransformAsMaster)
        {
            /* no hint and same transformation as master glyph */
            /* as ox/oy are not used in this case, we shouldn't need to first
               scale the original coordinate oox/ooy into ox/oy before copying
               them into the current coordinate x/y, the code is left as it
               for historic reason */
            scl_ScaleOldCharPoints (pGlyphElement, pvGlobalGS);
            scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

            scl_CopyCurrentCharPoints(pGlyphElement);
            scl_CopyCurrentPhantomPoints(pGlyphElement);
        }
        else
        {
            /* no hint and different transformation as master glyph */
            /* we shift directly the original coordinates oox/ooy into the
               current coordinates x/y in FixedFUnits,
               as ox/oy are not used in this case, we don't need to do
               a temporary copy into ox/oy */
            scl_OriginalCharPointsToCurrentFixedFUnits (pGlyphElement);
            scl_OriginalPhantomPointsToCurrentFixedFUnits (pGlyphElement);
        }
    }

    return NO_ERR;
}


/*
 *      fsg_CompositeInnerGridFit
 */
FS_PRIVATE ErrorCode    fsg_CompositeInnerGridFit (
    void *              pvGlobalGS,
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    boolean             bUseHints,
    FntTraceFunc        traceFunc,
    uint16              usEmResolution,
    uint16              usNonScaledAW,
    uint16              usNonScaledAH,
    int16               sNonScaledLSB,
    int16               sNonScaledTSB,
    boolean             bSameTransformAsMaster, /* local transf. same as master transf.   */
    transMatrix         CurrentTMatrix,               /* Current Transformation   */
    BBOX *              bbox,
    uint16              usSizeOfInstructions,
    uint8 *             instructionPtr,
    uint16 *            pusScanType,
    uint16 *            pusScanControl,
    boolean *           pbChangeScanControl)
{
    ErrorCode             result;
/*
    On entry to fsg_CompositeInnerGridFit, the current points (x, y)
    are the only valid points in the element. We copy the current points
    onto the old points (ox, oy)
*/
    itrp_SetCompositeFlag(pvGlobalGS, TRUE);

    itrp_QueryScanInfo(pvGlobalGS, pusScanType, pusScanControl);
    *pbChangeScanControl = FALSE;

    /* Note: The original composite character points are invalid at this point. */
    /*       The interpreter handles this case correctly for composites.        */

    scl_CalcOrigPhantomPoints(pGlyphElement, bbox, sNonScaledLSB, sNonScaledTSB, usNonScaledAW, usNonScaledAH);
                                                                  
    scl_CopyOldCharPoints(pGlyphElement);


    if (itrp_bApplyHints(pvGlobalGS) && bUseHints)
    {
        itrp_SetSameTransformFlag(pvGlobalGS, bSameTransformAsMaster);

        if (!bSameTransformAsMaster)
        {
            scl_InitializeChildScaling(
                pvGlobalGS,
                CurrentTMatrix,
                usEmResolution);
            scl_ScaleFixedCurrentCharPoints (pGlyphElement, pvGlobalGS);
        }

        scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

        scl_AdjustOldSideBearingPoints(pGlyphElement
#ifdef FSCFG_SUBPIXEL
            , pvGlobalGS
#endif
            );

        scl_CopyCurrentPhantomPoints(pGlyphElement);

        scl_RoundCurrentSideBearingPnt(pGlyphElement, pvGlobalGS, usEmResolution);

        if (usSizeOfInstructions > 0)
        {
            scl_ZeroOutlineFlags(pGlyphElement);

            result = itrp_ExecuteGlyphPgm (
                pTwilightElement,
                pGlyphElement,
                instructionPtr,
                instructionPtr + usSizeOfInstructions,
                pvGlobalGS,
                traceFunc,
                pusScanType,
                pusScanControl,
                pbChangeScanControl);

            if(result != NO_ERR)
            {
                return result;
            }
        }

        if (!bSameTransformAsMaster)
        {
            /* scale back to fixed FUnits */
            scl_ScaleBackCurrentCharPoints (pGlyphElement, pvGlobalGS);
            scl_ScaleBackCurrentPhantomPoints (pGlyphElement, pvGlobalGS);
        }

    }
    else 
    {
        if (bSameTransformAsMaster)
        {
            /* no hint and same transformation as master glyph */
            /* as ox/oy are not used in this case, we shouldn't need to first
               scale the original coordinate oox/ooy into ox/oy before copying
               them into the current coordinate x/y, the code is left as it
               for historic reason */
            scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

            scl_CopyCurrentPhantomPoints(pGlyphElement);

        }
        else
        {
            /* no hint and different transformation as master glyph */
            /* we shift directly the original coordinates oox/ooy into the
               current coordinates x/y in FixedFUnits,
               as ox/oy are not used in this case, we don't need to do
               a temporary copy into ox/oy */
            scl_OriginalPhantomPointsToCurrentFixedFUnits (pGlyphElement);

        }
    }

    return NO_ERR;
}

FS_PRIVATE void fsg_ChooseNextGlyph(
    fsg_WorkSpaceAddr * pWorkSpaceAddr, /* WorkSpace Address        */
    GlyphData *         pGlyphData,     /* GlyphData pointer        */
    GlyphData **        ppNextGlyphData)/* Next GlyphData pointer   */
{
    if (pGlyphData->pChild != NULL)
    {
        *ppNextGlyphData = pGlyphData->pChild;
        CHECK_GLYPHDATA( *ppNextGlyphData );
        pGlyphData->pChild = NULL;
    }
    else
    {
        *ppNextGlyphData = pGlyphData->pSibling;
        fsg_DeallocateGlyphDataMemory(pWorkSpaceAddr, pGlyphData);
    }
}

#ifdef FSCFG_SUBPIXEL
long fsg_AnalyzeCurrentTransformationMatrix(transMatrix *CTM);
long fsg_AnalyzeCurrentTransformationMatrix(transMatrix *CTM) {
    if (CTM->transform[0][1] == 0 && CTM->transform[1][0] == 0) return 0; // Identity, 180 rotation, mirroring in x or y
    if (CTM->transform[0][0] == 0 && CTM->transform[1][1] == 0) return 1; // 90 rotation, 270 rotation, or any combination of these rotation with a mirroring in x or y
    return 2; // assume arbitrary rotation
} // fsg_AnalyzeCurrentTransformationMatrix
#endif

FS_PRIVATE ErrorCode fsg_MergeGlyphData(
    void *          pvGlobalGS,             /* GlobalGS            */
    GlyphData *     pChildGlyphData,       /* GlyphData pointer     */
    uint16          usEmResolution)
{
    fnt_ElementType * pChildElement;
    fnt_ElementType * pParentElement;
    F26Dot6         fxXOffset, fxYOffset;
    GlyphData *     pParentGlyphData; /* Parent GlyphData pointer   */
#ifdef FSCFG_SUBPIXEL
    RotationParity  rotationParity;
#endif

    CHECK_GLYPHDATA(pChildGlyphData);
    pParentGlyphData = pChildGlyphData->pParent;
    CHECK_GLYPHDATA(pParentGlyphData);

    pChildElement = pChildGlyphData->pGlyphElement;
    pParentElement = pParentGlyphData->pGlyphElement;

    fsg_TransformChild(pChildGlyphData);

    if (!pChildGlyphData->bSameTransformAsMaster && pChildGlyphData->pParent->bSameTransformAsMaster)
    {
        /* coordinates need to be converted from fixed FUnits to user space */
        /* scaling the cordinate of the child glyph from fixed FUnits to user space,
           scaling from original coordinate x/y to original coordinate x/y 
           this is done to have the child and parent glyph at the same coordinate space */

        /* use the master transform */
        itrp_SetSameTransformFlag(pvGlobalGS, TRUE);

        scl_ScaleFixedCurrentCharPoints(pChildElement, pvGlobalGS);
        scl_ScaleFixedCurrentPhantomPoints(pChildElement, pvGlobalGS);

        pChildGlyphData->bSameTransformAsMaster = TRUE;
    }
    
#ifdef FSCFG_SUBPIXEL
    rotationParity = fsg_AnalyzeCurrentTransformationMatrix(&pParentGlyphData->currentTMatrix);
#endif

    if (pChildGlyphData->MultiplexingIndicator == OffsetPoints)
    {
        if (!pChildGlyphData->pParent->bSameTransformAsMaster)
        {
            /* we have both the parent and the child that are not at the same transformation as the master glyph
               we need to use the scaling of the parent as a child scaling to scale the offset */
            scl_InitializeChildScaling(
                pvGlobalGS,
                pChildGlyphData->pParent->currentTMatrix,
                usEmResolution);
        }

        scl_CalcComponentOffset(
            pvGlobalGS,
            pChildGlyphData->sXOffset,
            pChildGlyphData->sYOffset,
            pChildGlyphData->bRoundXYToGrid,
            pChildGlyphData->bSameTransformAsMaster,
            pChildGlyphData->bScaleCompositeOffset,
            pChildGlyphData->mulT,
#ifdef FSCFG_SUBPIXEL
            rotationParity,
#endif
            &fxXOffset,
            &fxYOffset);
    }
    else        /* Values are anchor points */
    {
        FS_ASSERT(pChildGlyphData->MultiplexingIndicator == AnchorPoints,
               "Bad Multiplexing Indicator");

        if ( (pParentElement->nc == 0) || (pChildGlyphData->usAnchorPoint1 > pParentElement->ep[pParentElement->nc-1] + PHANTOMCOUNT) ||
            (pChildGlyphData->usAnchorPoint2 > pParentElement->ep[pParentElement->nc-1] + PHANTOMCOUNT) )
        {
            return POINTS_DATA_ERR;
        }

        scl_CalcComponentAnchorOffset(
            pParentElement,
            pChildGlyphData->usAnchorPoint1,
            pChildElement,
            pChildGlyphData->usAnchorPoint2,
            &fxXOffset,
            &fxYOffset);
    }
    scl_ShiftCurrentCharPoints(pChildElement, fxXOffset, fxYOffset);


    /* If USE_MY_METRICS, copy side bearings to parent  */

    if (pChildGlyphData->bUseMyMetrics)
    {
        pParentGlyphData->bUseChildMetrics = TRUE;

        scl_SaveSideBearingPoints(
            pChildElement,
            &pParentGlyphData->ptDevLSB,
            &pParentGlyphData->ptDevRSB);
    }

    fsg_MergeScanType(pChildGlyphData, pParentGlyphData);

    /* Start the copy   */

    /* scl_AppendOutlineData(pChildElement, pParentElement); */

    scl_UpdateParentElement(pChildElement, pParentElement);

    pChildElement->nc = 0;

    return NO_ERR;
}



FS_PRIVATE void fsg_LinkChild(
    GlyphData *     pGlyphData,     /* GlyphData pointer        */
    GlyphData *     pChildGlyphData)/* Child GlyphData pointer  */
{
    GlyphData * pTempGlyphData;

    if (pGlyphData->pChild == NULL)
    {
        pGlyphData->pChild = pChildGlyphData;
    }
    else
    {

        pTempGlyphData = pGlyphData->pChild;

        CHECK_GLYPHDATA(pTempGlyphData);

        while (pTempGlyphData->pSibling != pGlyphData)
        {
            pTempGlyphData = pTempGlyphData->pSibling;
            CHECK_GLYPHDATA(pTempGlyphData);
        }

        pTempGlyphData->pSibling = pChildGlyphData;
    }
    pChildGlyphData->pSibling = pGlyphData;
    pChildGlyphData->pParent =  pGlyphData;

    /* copy the transformation info from the parent */
    pChildGlyphData->currentTMatrix = pGlyphData->currentTMatrix;
    pChildGlyphData->bSameTransformAsMaster = pGlyphData->bSameTransformAsMaster;
}

FS_PRIVATE void fsg_TransformChild(
    GlyphData *     pGlyphData)     /* GlyphData pointer    */
{

    /* Apply local transform to glyph   */

    if (!mth_Identity(&pGlyphData->mulT))
    {
        scl_LocalPostTransformGlyph (pGlyphData->pGlyphElement, &pGlyphData->mulT);
    }
}

FS_PRIVATE void fsg_MergeScanType(
    GlyphData *     pGlyphData,       /* GlyphData pointer  */
    GlyphData *     pParentGlyphData) /* GlyphData pointer  */
{
    CHECK_GLYPHDATA(pGlyphData);
    CHECK_GLYPHDATA(pParentGlyphData);

    /* Merge Scan Type of parent and child  */

    if(pParentGlyphData->usScanType != SCANTYPE_UNINITIALIZED)
    {

        pParentGlyphData->usScanType =
            (uint16)(((pParentGlyphData->usScanType & (SK_NODROPOUT | SK_STUBS)) &
            (pGlyphData->usScanType & (SK_NODROPOUT | SK_STUBS))) |
            (pParentGlyphData->usScanType & SK_SMART));
    }
    else
    {
        pParentGlyphData->usScanType = pGlyphData->usScanType;
    }
}

/* Use various spline key values to determine if dropout control is to be activated
 * for this glyph, and if so what kind of dropout control.
 * The use of dropout control mode in the scan converter is controlled by 3 conditions.
 * The conditions are: Is the glyph rotated?, is the glyph stretched?,
 * is the current pixels per Em less than a specified threshold?
 * These conditions can be OR'd or ANDed together to determine whether the dropout control
 * mode ought to be used.

Six bits are used to specify the joint condition.  Their meanings are:

BIT     Meaning if set
8       Do dropout mode if other conditions don't block it AND
            pixels per em is less than or equal to bits 0-7
9       Do dropout mode if other conditions don't block it AND
            glyph is rotated
10      Do dropout mode if other conditions don't block it AND
            glyph is stretched
11      Do not do dropout mode unless ppem is less than or equal to bits 0-7
            A value of FF in 0-7  means all sizes
            A value of 0 in 0-7 means no sizes
12      Do not do dropout mode unless glyph is rotated
13      Do not do dropout mode unless glyph is stretched

In other words, we do not do dropout control if:
No bits are set,
Bit 8 is set, but ppem is greater than threshold
Bit 9 is set, but glyph is not rotated
Bit 10 is set, but glyph is not stretched
None of the conditions specified by bits 11-13 are true.

For example, 0xA10 specifies turn dropout control on if the glyph is rotated providing
that it is also less than 0x10 pixels per em.  A glyph is considered stretched if
the X and Y resolutions are different either because of the device characteristics
or because of the transformation matrix.  If both X and Y are changed by the same factor
the glyph is not considered stretched.

 */

FS_PRIVATE boolean fsg_DoScanControl(
    uint16 usScanControl,
    uint32 ulImageState)
{
    if ((usScanControl & SCANCTRL_DROPOUT_IF_LESS) &&
        ((uint8)(ulImageState & IMAGESTATE_SIZE_MASK) <= (uint8)(usScanControl & SCANCTRL_SIZE_MASK)))
    {
        return TRUE;
    }

    if ((usScanControl & SCANCTRL_DROPOUT_IF_LESS) &&
        ((usScanControl & SCANCTRL_SIZE_MASK) == SCANCTRL_DROPOUT_ALL_SIZES))
    {
        return TRUE;
    }

    if ((usScanControl & SCANCTRL_DROPOUT_IF_ROTATED) &&
        (ulImageState & IMAGESTATE_ROTATED))
    {
        return TRUE;
    }

    if ((usScanControl & SCANCTRL_DROPOUT_IF_STRETCHED) &&
        (ulImageState & IMAGESTATE_STRETCHED))
    {
        return TRUE;
    }

    if ((usScanControl & SCANCTRL_NODROP_UNLESS_LESS) &&
        ((uint8)(ulImageState & IMAGESTATE_SIZE_MASK) > (uint8)(usScanControl & SCANCTRL_SIZE_MASK)))
    {
        return FALSE;
    }

    if ((usScanControl & SCANCTRL_NODROP_UNLESS_ROTATED) &&
        ! (ulImageState & IMAGESTATE_ROTATED))
    {
        return FALSE;
    }

    if ((usScanControl & SCANCTRL_NODROP_UNLESS_STRETCH) &&
        ! (ulImageState & IMAGESTATE_STRETCHED))
    {
        return FALSE;
    }

    return FALSE;
}

FS_PRIVATE void fsg_InitializeGlyphDataMemory(
    uint32              ulGlyphDataCount,
    fsg_WorkSpaceAddr * pWorkSpaceAddr) /* WorkSpace Address      */
{
    uint32      ulIndex;
    boolean *   abyGlyphDataFreeBlocks;

    abyGlyphDataFreeBlocks = pWorkSpaceAddr->pGlyphDataByteSet;

    for(ulIndex = 0; ulIndex < ulGlyphDataCount; ulIndex++)
    {
        abyGlyphDataFreeBlocks[ulIndex] = TRUE;
    }
}

FS_PRIVATE  ErrorCode fsg_AllocateGlyphDataMemory(
    uint32              ulGlyphDataCount,
    fsg_WorkSpaceAddr * pWorkSpaceAddr, /* WorkSpace Address      */
    GlyphData **        ppGlyphData)      /* GlyphData pointer    */
{
    uint32      ulIndex;
    boolean *   abyGlyphDataFreeBlocks;

    abyGlyphDataFreeBlocks = pWorkSpaceAddr->pGlyphDataByteSet;

    ulIndex = 0;
    while((!abyGlyphDataFreeBlocks[ulIndex]) && ulIndex < ulGlyphDataCount)
    {
        ulIndex++;
    }

    if (ulIndex == ulGlyphDataCount)
    {
        return SFNT_RECURSIVE_COMPOSITE_ERR;
    }

    abyGlyphDataFreeBlocks[ulIndex] = FALSE;

    *ppGlyphData = (GlyphData *)&((GlyphData *)pWorkSpaceAddr->pvGlyphData)[ulIndex];
    return NO_ERR;
}

FS_PRIVATE void fsg_DeallocateGlyphDataMemory(
    fsg_WorkSpaceAddr * pWorkSpaceAddr, /* WorkSpace Address    */
    GlyphData *         pGlyphData)     /* GlyphData pointer    */
{
    ptrdiff_t   ptIndex;
    boolean *   abyGlyphDataFreeBlocks;

    pGlyphData->acIdent[0] = '\0';
    pGlyphData->acIdent[1] = '\0';

    abyGlyphDataFreeBlocks = pWorkSpaceAddr->pGlyphDataByteSet;

    ptIndex = (ptrdiff_t)(pGlyphData - (GlyphData *)pWorkSpaceAddr->pvGlyphData);

    abyGlyphDataFreeBlocks[ptIndex] = TRUE;
}

FS_PRIVATE void fsg_InitializeGlyphData(
    GlyphData *             pGlyphData,     /* GlyphData pointer    */
    fsg_WorkSpaceAddr *     pWorkSpaceAddr, /* WorkSpace Address    */
    uint16                  usGlyphIndex,   /* Glyph Index          */
    uint16                  usDepth)        /* Glyph depth          */
{
    pGlyphData->acIdent[0] = 'G';
    pGlyphData->acIdent[1] = 'D';
    pGlyphData->pSibling = NULL;
    pGlyphData->pChild = NULL;
    pGlyphData->pParent = NULL;
    pGlyphData->GlyphType = glyphUndefined;
    pGlyphData->hGlyph.pvGlyphBaseAddress = NULL;
    pGlyphData->hGlyph.pvGlyphNextAddress = NULL;
    pGlyphData->usDepth = usDepth;
    pGlyphData->bUseMyMetrics = FALSE;
    pGlyphData->bScaleCompositeOffset = FALSE;
    pGlyphData->bUseChildMetrics = FALSE;
    pGlyphData->bbox.xMin = SHRT_MAX;
    pGlyphData->bbox.yMin = SHRT_MAX;
    pGlyphData->bbox.xMax = SHRT_MIN;
    pGlyphData->bbox.yMax = SHRT_MIN;
    pGlyphData->usSizeOfInstructions = 0;
    pGlyphData->pbyInstructions = NULL;
    pGlyphData->usNonScaledAW = 0;
    pGlyphData->sNonScaledLSB = 0;
    pGlyphData->MultiplexingIndicator = Undefined;
    pGlyphData->bRoundXYToGrid = FALSE;
    pGlyphData->usGlyphIndex = usGlyphIndex;
    pGlyphData->sXOffset = 0;
    pGlyphData->sYOffset = 0;
    pGlyphData->usAnchorPoint1 = 0;
    pGlyphData->usAnchorPoint2 = 0;
    pGlyphData->mulT = IdentTransform;
    pGlyphData->usScanType = SCANTYPE_UNINITIALIZED;
    pGlyphData->ptDevLSB.x = 0L;
    pGlyphData->ptDevLSB.y = 0L;
    pGlyphData->ptDevRSB.x = 0L;
    pGlyphData->ptDevRSB.y = 0L;
    pGlyphData->pGlyphElement = &pWorkSpaceAddr->pGlyphElement[usDepth];
    pGlyphData->pGlyphElement->nc = 0;
    pGlyphData->currentTMatrix = IdentTransform;
    pGlyphData->bSameTransformAsMaster = TRUE;
}

#ifdef  FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC  void fsg_InitializeData (void)
{
    itrp_InitializeData ();
}
#endif

/* definitions and prototype for functions used in emboldening */

#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )

#define LEFTSIDEBEARING 0
#define RIGHTSIDEBEARING 1

#define TOPSIDEBEARING 2
#define BOTTOMSIDEBEARING 3

#define LSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + LEFTSIDEBEARING)
#define RSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + RIGHTSIDEBEARING)

#define TOPSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPSIDEBEARING)
#define BOTTOMSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + BOTTOMSIDEBEARING)

#define POSINFINITY               0x7FFFFFFFUL

#define NotSameKnot(a,b) ((a).x != (b).x || (a).y != (b).y)

/* used by QDiv2 and FQuadraticEqn */
#define places16 16
#define half16 (1 << (places16-1))

#define F32Dot32 int64

#ifndef Sgn
    #define Sgn(a)      ((a) < 0 ? -1 : ((a) > 0 ? 1 : 0))
#endif

typedef struct F26Dot6VECTOR {
    F26Dot6 x;
    F26Dot6 y;
} F26Dot6VECTOR;

typedef struct { long x,y; } Vector;

typedef enum { linkBlack, linkGrey, linkWhite } LinkColor;

short ComputeSign(int32 DeltaPrevX, int32 DeltaPrevY, int32 DeltaNextX, int32 DeltaNextY);

int64 QDiv2(int64 a, int64 b);

void FQuadraticEqn(int64 a, int64 b, int64 c, long* solutions, int64* t1, int64* t2);

F32Dot32 FSqrt(uint64 radicand);

long CurveTransitions(Vector V0, Vector V1, Vector W0, Vector W1, Vector W2);

long CurveTransitionsSegment(Vector V0, Vector V1, Vector W0, Vector W1);

void CalculateXExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY);

void CalculateYExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY);

void SetLineToInfinity (int16 extremumNumber, Vector extremum, Vector* C0, Vector* C1);

void MinMax2Vectors (Vector A,Vector B,Vector *Min, Vector *Max);

void MinMax3Vectors (Vector A,Vector B,Vector C, Vector *Min, Vector *Max);

boolean CheckBoundingBoxCurve(Vector C0,Vector W0,Vector W1,Vector W2,int16 extremumNumber);

boolean CheckBoundingBoxSegment(Vector C0,Vector W0,Vector W1,int16 extremumNumber);

void NormalizeVector26Dot6 (F26Dot6VECTOR *pVect);

void Intersect26Dot6(F26Dot6VECTOR Pt1, F26Dot6VECTOR Pt2, F26Dot6VECTOR Pt3, F26Dot6VECTOR Pt4, F26Dot6VECTOR *ResultPt);

void  EmboldPoint(int32 iPt, int32 iPt1, 
                  boolean bUnderTheThreshold, boolean bMisoriented, 
                  F26Dot6VECTOR PrevPt, 
                  F26Dot6VECTOR CurrPt, 
                  F26Dot6VECTOR NextPt, 
                  F26Dot6 fxRightShift, F26Dot6 fxLeftShift, 
                  F26Dot6 fxTopShift, F26Dot6 fxBottomShift, 
                  F26Dot6   fxScaledDescender,
                  fnt_ElementType * pElement); 
 
boolean Misoriented(int32 contour, uint16 extremumNumber, short extremumKnot, Vector extremum, fnt_ElementType *pElement);

/* emboldening related code */

void NormalizeVector26Dot6 (F26Dot6VECTOR *pVect)
{
    VECTOR Vec;

    itrp_Normalize (pVect->x, pVect->y, &Vec);

    /* transform from ShortFract to 26.6 */
    pVect->x = Vec.x >> 8;
    pVect->y = Vec.y >> 8;  
}

void Intersect26Dot6(F26Dot6VECTOR Pt1, F26Dot6VECTOR Pt2, F26Dot6VECTOR Pt3, F26Dot6VECTOR Pt4, F26Dot6VECTOR *ResultPt)
{
    /* this procedure was inspired by itrp_ISECT */
    F26Dot6 N, D;
    F26Dot6VECTOR B, A;
    F26Dot6VECTOR dB, dA;

      dA.x = Pt2.x - (A.x = Pt1.x);
      dA.y = Pt2.y - (A.y = Pt1.y);

      dB.x = Pt4.x - (B.x = Pt3.x);
      dB.y = Pt4.y - (B.y = Pt3.y);

      if (dA.y == 0) 
      {
        if (dB.x == 0) 
        {
          ResultPt->x = B.x;
          ResultPt->y = A.y;
          return;
        }
        N = B.y - A.y;
        D = -dB.y;
      } 
      else if (dA.x == 0) 
      {
        if (dB.y == 0) 
        {
          ResultPt->x = A.x;
          ResultPt->y = B.y;
          return;
        }
        N = B.x - A.x;
        D = -dB.x;
      } 
      else if (MABS (dA.x) >= MABS (dA.y))
      {
/* To prevent out of range problems divide both N and D with the max */
        N = (B.y - A.y) - MulDiv26Dot6 (B.x - A.x, dA.y, dA.x);
        D = MulDiv26Dot6 (dB.x, dA.y, dA.x) - dB.y;
      } 
      else 
      {
        N = MulDiv26Dot6 (B.y - A.y, dA.x, dA.y) - (B.x - A.x);
        D = dB.x - MulDiv26Dot6 (dB.y, dA.x, dA.y);
      }

      if (MABS(D) > 16) /* this test used to be D != 0 but for very small D we get degenerescence */
      {
        ResultPt->x = B.x + (F26Dot6) MulDiv26Dot6 (dB.x, N, D);
        ResultPt->y = B.y + (F26Dot6) MulDiv26Dot6 (dB.y, N, D);
      } 
      else 
      {
/* degenerate case: parallell lines, what make sence in this special case is to take the
          middle point between Pt2 and Pt3 */
        ResultPt->x = (Pt2.x + Pt3.x) >> 1;
        ResultPt->y = (Pt2.y + Pt3.y) >> 1;
      }

    
}

void  EmboldPoint(int32 iPt, int32 iPt1, 
                  boolean bUnderTheThreshold, boolean bMisoriented,
                  F26Dot6VECTOR PrevPt, 
                  F26Dot6VECTOR CurrPt, 
                  F26Dot6VECTOR NextPt, 
                  F26Dot6 fxRightShift, F26Dot6 fxLeftShift, 
                  F26Dot6 fxTopShift, F26Dot6 fxBottomShift, 
                  F26Dot6   fxScaledDescender,
                  fnt_ElementType * pElement) 


{
    F26Dot6VECTOR dPrev, dNext, Shift, CurrPt1,  NewPt, Delta ;
    F26Dot6 fxTemp;
    int32 i;

    dPrev.x = CurrPt.x - PrevPt.x;
    dPrev.y = CurrPt.y - PrevPt.y;

    dNext.x = NextPt.x - CurrPt.x;
    dNext.y = NextPt.y - CurrPt.y;

    /* compute the orthogonal vectors */

    fxTemp = dPrev.x;
    dPrev.x = -dPrev.y;
    dPrev.y = fxTemp;

    fxTemp = dNext.x;
    dNext.x = -dNext.y;
    dNext.y = fxTemp;

    if (bMisoriented)
    {
        dPrev.x = -dPrev.x;
        dPrev.y = -dPrev.y;
        dNext.x = -dNext.x;
        dNext.y = -dNext.y;
    }

    /* copy of the current point */

    CurrPt1 = CurrPt;

    if (bUnderTheThreshold)
    {
        /* most common case, we are just moving control points one pixel horizontally */

        if (dPrev.x > 0)
        {
            CurrPt1.x += fxRightShift;
        }
        if (dNext.x > 0)
        {
            CurrPt.x += fxRightShift;
        }
    } else 
    {
        /* generalization, move along the vector normal to the curve */

        /* normalize the vectors */
        NormalizeVector26Dot6 (&dPrev);
        NormalizeVector26Dot6 (&dNext);


        /* apply the shift on the previous segment */

        /* Multiply the normalized vector by the shift factor */
        if (dPrev.x > 0)
        {
            Shift.x = Mul26Dot6(dPrev.x, fxRightShift);
        } else {
            Shift.x = Mul26Dot6(dPrev.x, fxLeftShift);
        }

        if (dPrev.y < 0)
        {
            Shift.y = Mul26Dot6(dPrev.y, fxBottomShift);
        } else {
            Shift.y = Mul26Dot6(dPrev.y, fxTopShift);
        }

        PrevPt.x += Shift.x;
        PrevPt.y += Shift.y;

        CurrPt1.x += Shift.x;
        CurrPt1.y += Shift.y;

        /* second segment */

        /* Multiply the normalized vector by the shift factor */
        if (dNext.x > 0)
        {
            Shift.x = Mul26Dot6(dNext.x, fxRightShift);
        } else {
            Shift.x = Mul26Dot6(dNext.x, fxLeftShift);
        }

        if (dNext.y < 0)
        {
            Shift.y = Mul26Dot6(dNext.y, fxBottomShift);
        } else {
            Shift.y = Mul26Dot6(dNext.y, fxTopShift);
        }

        NextPt.x += Shift.x;
        NextPt.y += Shift.y;

        CurrPt.x += Shift.x;
        CurrPt.y += Shift.y;
    }

    if (CurrPt1.x == CurrPt.x && CurrPt1.y == CurrPt.y)
    {
        /* both points were moved by the same value, no need to intersect */
        pElement->x[iPt] = CurrPt.x;
        pElement->y[iPt] = CurrPt.y;
    } else
    {
    /* we need to reintersect */
        Intersect26Dot6(PrevPt, CurrPt1, CurrPt, NextPt, &NewPt);

        /* sanity check that we are not moving the point too far from it's original position,
            this happen at low ppem size when segment lenght get small compared to the shift 
            or when hinting caused outline overlapp */
        Delta.x = NewPt.x - pElement->x[iPt];
        Delta.y = NewPt.y - pElement->y[iPt];

        if (Delta.x > fxRightShift)
        {
            NewPt.x = pElement->x[iPt] + fxRightShift;
        }
        if (Delta.x < -fxLeftShift)
        {
            NewPt.x = pElement->x[iPt] - fxLeftShift;
        }
        if (Delta.y < -fxBottomShift)
        {
            NewPt.y = pElement->y[iPt] - fxBottomShift;
        } 
        if (Delta.y > fxTopShift)
        {
            NewPt.y = pElement->y[iPt] + fxBottomShift;
        } 

        pElement->x[iPt] = NewPt.x;
        pElement->y[iPt] = NewPt.y;

    }
    /* shift all points by fxLeftShift, fxTopShift */
    pElement->x[iPt] += fxLeftShift;
    pElement->y[iPt] += fxBottomShift;

    if (pElement->y[iPt] < fxScaledDescender)
    {
        /* clipping to prevent going below the descender and causing out of bounds problems */
        pElement->y[iPt] = fxScaledDescender;
    }

    if (iPt != iPt1)
    {
        /* duplicate points at the same coordinate, we need to move them all */
        for(i= iPt + 1; i <= iPt1; i++)
        {
            pElement->x[i] = pElement->x[iPt];
            pElement->y[i] = pElement->y[iPt];
        }
    }

}

FS_PRIVATE void  fsg_Embold(
    fsg_WorkSpaceAddr * pWorkSpaceAddr,
    void *              pvGlobalGS,
    boolean             bUseHints, /* True if glyph is gridfitted       */
    boolean             bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
    ,boolean            bSubPixel
#endif // FSCFG_SUBPIXEL
    )
{
    fnt_ElementType *pElement;
    fnt_GlobalGraphicStateType *globalGS;
    int32 iContour, iPt, iPt1, iStartPt, iEndPt;
    F26Dot6VECTOR FirstPt, PrevPt, NextPt, CurrPt;
    F26Dot6 fxRightShift, fxLeftShift; 
    F26Dot6 fxTopShift, fxBottomShift; 
    boolean bUnderTheThreshold;
    boolean bMisoriented;

    globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

    pElement = pWorkSpaceAddr->pGlyphElement;

    bUnderTheThreshold = (globalGS->uBoldSimulHorShift == 1);

#ifdef FSCFG_SUBPIXEL
    if (bSubPixel)
    {
        bUnderTheThreshold = (globalGS->uBoldSimulHorShift <= HINTING_HOR_OVERSCALE);
    }
#endif // FSCFG_SUBPIXEL

    /* adjust the right sidebearing */
    if (pElement->x[RSBPOINTNUM(pElement)] != pElement->x[LSBPOINTNUM(pElement)]) 
        /* we don't increase the width of a zero width glyph, problem with indic script */
    {
#ifdef FSCFG_SUBPIXEL
        if (bSubPixel)
        {
            pElement->x[RSBPOINTNUM(pElement)] += ( ( 1 / HINTING_HOR_OVERSCALE) << 6); /* we increase the widht by one pixel regardless of size for backwards compatibility */
        } else {
#endif // FSCFG_SUBPIXEL
            pElement->x[RSBPOINTNUM(pElement)] += (1 << 6); /* we increase the widht by one pixel regardless of size for backwards compatibility */
#ifdef FSCFG_SUBPIXEL
        }
#endif // FSCFG_SUBPIXEL
    }

    /* adjust the bottom sidebearing, this is done by the value of the HorShift and not the VertShift for backwards compatibility
       in vertical writing */
    if (pElement->y[BOTTOMSBPOINTNUM(pElement)] != pElement->y[TOPSBPOINTNUM(pElement)])
        /* we don't increase the width of a zero width glyph, problem with indic script */
    {
        pElement->y[BOTTOMSBPOINTNUM(pElement)] -= (1 << 6); /* we increase the widht by one pixel regardless of size for backwards compatibility */
    }

    if (!bBitmapEmboldening)
    {    

        if (bUseHints)
        {
            /* to preserve the hinting, we should move by an integer amount of pixel */
            /* divide by 2, round to pixel, convert to 26.6 */
#ifdef FSCFG_SUBPIXEL
            if (bSubPixel)
            {
                fxLeftShift = ((globalGS->uBoldSimulHorShift /HINTING_HOR_OVERSCALE) >> 1) * HINTING_HOR_OVERSCALE; 
                fxRightShift = (globalGS->uBoldSimulHorShift - fxLeftShift) << 6;
                fxLeftShift = fxLeftShift << 6; 
            } else {
#endif // FSCFG_SUBPIXEL
                fxLeftShift = globalGS->uBoldSimulHorShift >> 1; 
                fxRightShift = (globalGS->uBoldSimulHorShift - fxLeftShift) << 6;
                fxLeftShift = fxLeftShift << 6; 
#ifdef FSCFG_SUBPIXEL
            }
#endif // FSCFG_SUBPIXEL
            fxTopShift = globalGS->uBoldSimulVertShift >> 1;
            fxBottomShift = (globalGS->uBoldSimulVertShift - fxTopShift) << 6;
            fxTopShift = fxTopShift << 6;
        } else {
            /* divide by 2, convert to 26.6 */
            fxRightShift = globalGS->uBoldSimulHorShift << 5;
            fxLeftShift = globalGS->uBoldSimulHorShift << 5; 
            fxTopShift = globalGS->uBoldSimulVertShift << 5;
            fxBottomShift = globalGS->uBoldSimulVertShift << 5;
        }

        for (iContour = 0; iContour < pElement->nc; iContour++)
        {
            iStartPt = pElement->sp[iContour];
            iEndPt = pElement->ep[iContour];

            if (iEndPt - iStartPt >= 2)
            /* contour with less than 3 points cannot be emboldened */
            {
                bMisoriented = FALSE;
                if (pElement->fc[iContour] & OUTLINE_MISORIENTED)
                {
                    bMisoriented = TRUE;
                }
                /* we need to save the original coordinate of the first point for the computation of the last point */
                /* to compute the new coordinate for a point, we need the original coordinate of the point, the previous point
                  and the next point */

                FirstPt.x = pElement->x[iStartPt];
                FirstPt.y = pElement->y[iStartPt];

                CurrPt = FirstPt;

                PrevPt.x = pElement->x[iEndPt];
                PrevPt.y = pElement->y[iEndPt];

                NextPt.x = pElement->x[iStartPt+1];
                NextPt.y = pElement->y[iStartPt+1];

                iPt = iStartPt;

                while (iPt <= iEndPt)
                {
                    iPt1 = iPt;

                    /* deal with the special case of two points at the same coordinate, current and next */
                    while ((NextPt.x == CurrPt.x) && (NextPt.y == CurrPt.y) && (iPt1 < iEndPt))
                    {
                        iPt1++;

                         if (iPt1 >= iEndPt)
                             /* the >= is to avoid goind out of bounds when preparing Prev, Next, Curr at the last step */
                        {
                            NextPt.x = FirstPt.x;
                            NextPt.y = FirstPt.y;
                        } else {
                            NextPt.x = pElement->x[iPt1 +1];
                            NextPt.y = pElement->y[iPt1 +1];
                        }
                    }

                    /* we do the computation for the current point */

                    EmboldPoint(iPt, iPt1, bUnderTheThreshold, bMisoriented, PrevPt, CurrPt, NextPt, 
                            fxRightShift, fxLeftShift, fxTopShift, fxBottomShift, globalGS->fxScaledDescender, pElement); 
                
                    iPt = iPt1;

                    iPt++;
                    /* we compute Prev, Next, Curr coordinate for the next point */

                    PrevPt = CurrPt;

                    CurrPt = NextPt;

                     if (iPt >= iEndPt)
                         /* the >= is to avoid goind out of bounds when preparing Prev, Next, Curr at the last step */
                    {
                        NextPt.x = FirstPt.x;
                        NextPt.y = FirstPt.y;
                    } else {
                        NextPt.x = pElement->x[iPt +1];
                        NextPt.y = pElement->y[iPt +1];
                    }
                }
            }
        }
    }
}

short ComputeSign(int32 DeltaPrevX, int32 DeltaPrevY, int32 DeltaNextX, int32 DeltaNextY)
{
    int32 sgn;

    /* as our coordinates are in desing unit, they fit in 16 bits and we are not overflowing here */

    sgn = DeltaPrevX*DeltaNextY - DeltaPrevY*DeltaNextX;
    return (short)Sgn(sgn); // +1 => left turn, -1 => right turn, 0 => straight
}

Vector AddV(const Vector a, const Vector b) {
    Vector c;
    
    c.x = a.x + b.x;
    c.y = a.y + b.y;
    return c;
} // AddV

Vector SubV(const Vector a, const Vector b) {
    Vector c;
    
    c.x = a.x - b.x;
    c.y = a.y - b.y;
    return c;
} // SubV

Vector ShlV(const Vector a, long by) {
    Vector b;
    
    b.x = a.x << by;
    b.y = a.y << by;
    return b;
} // ShlV

Vector ShrV(const Vector a, long by) {
    Vector b;
    
    b.x = a.x >> by;
    b.y = a.y >> by;
    return b;
} // ShrV

int64 QDiv2(int64 a, int64 b) { // special version that replaces epsilons by 1, which is actually 1/65536 since we're actually returning F48Dot16
    int64 q;

    if (a < 0 != b < 0) {
        if (a < 0) a = -a; else b = -b;
        if (a < b) q = -1; else if (a > b << places16) q = -65536-1; else q = -((a + (b >> 1))/b);
    } else {
        if (a < 0) a = -a, b = -b;
        if (a < b) q = 1; else if (a > b << places16) q = 65536+1; else q = (a + (b >> 1))/b;
    }
    return q;
} // QDiv2

F32Dot32 FSqrt(uint64 radicand) {
    uint64 bit,root,s;

    root = 0;
    for (bit = (uint64)1 << 62; bit >= 0x8000 /* we don't need the last 16 bits */; bit >>= 1) {
        s = bit + root;
        if (s <= radicand) {
            radicand -= s;
            root |= (bit << 1);
        };
        radicand <<= 1;
    }
    return root;
} // FSqrt

void FQuadraticEqn(int64 a, int64 b, int64 c, long* solutions, int64* t1, int64* t2) {
    // the usual method for solving quadratic equations
    // input is actually in 32bit, output is F48Dot16
    int64 radicand,root,b1,b2,c1;
    
    *solutions = 0;
    if (a == 0) {
        if (b != 0) {
            *solutions = 1;
            c1 = -(c << places16);
            *t1 = QDiv2(c1,b);
        } // else b == 0, no solutions
    } else {
        a *= 2;
        radicand = b*b - 2*a*c;
        if (radicand > 0) {
            *solutions = 2;

            root = (FSqrt(radicand) + half16) >> places16;
            b <<= places16;

            b1 = -(b - root);
            b2 = -(b + root);
            *t1 = QDiv2(b1,a);
            *t2 = QDiv2(b2,a);
        } else if (radicand == 0) {
            *solutions = 1;
            b1 = -(b << places16);
            *t1 = QDiv2(b1,a);
        } // else radicand < 0, no solutions
    }
} // FQuadraticEqn

long CurveTransitionsSegment(Vector V0, Vector V1, Vector W0, Vector W1) {

//  here we're intersecting a straight line (W0, W1) with a straight line (V0, V1).
//  for the two to intersect, and writing both intersectees in standard polynomial form, there must be parameters u and v such that
//
//      A.x*u + B.x = C.x*v + D.x
//      A.y*u + B.y = C.y*v + D.y
//
//  a system of two "halfway" linear eqns. in two unknowns u and v
//  solving the first eqn. for v (which is linear in v, hence the "halfway") yields
//
//      v = (A.x*u + B.x - D.x)/C.x
//
//  substituting v into the second eqn. yields
//
//      A.y*u + B.y - D.y = C.y*(A.x*u + B.x - D.x)/C.x
//
//  rearranging terms by powers of u and multiplying by D.x yields
//
//      (A.y*C.x - C.y*A.x)*u + B.y*C.x - D.y*C.x + C.y*D.x - C.y*B.x = 0
//
//  which is a single linear eqn. in u with 0 thru 1 solutions obtained "the usual way".
//  solutions must be in the interval ]0,1] to make sure we only accept intersections of the actual segment
//  and we don't count start/end points twice by including them in adjacent segments as well (cf. also ColorTransitions above)

    Vector A,B,C,D;
    int64 a, b;
    long transitions;
    int64 u,vd;

//  re-write Line in polynomial form
//  (W1 - W0)*u + W0, which follows immediately from the "first degree" Bzier "curve" W0*(1-u) + W1*u
    A = SubV(W1,W0);
    B = W0;


//  re-write Line in polynomial form
//  (V1 - V0)*v + V0, which follows immediately from the "first degree" Bzier "curve" V0*(1-u) + V1*u
    C = SubV(V1,V0);
    D = V0;

    a = (A.y*C.x - C.y*A.x);

    transitions = 0;

    if (a != 0)
    {
        b = B.y*C.x - D.y*C.x + C.y*D.x - C.y*B.x;

    //  a*u + b = 0 => u = -b / a

        b = -b << places16;
        u = QDiv2(b,a); /* u stored in 48.16 */
        
        if (0 < u && u <= 0x10000) {
                /* to avoid loss of precision, select in which equation to replace the value of u[] */
            if (MABS(C.x) > MABS(C.y))
            {
                vd = ((int64)A.x)*u  + ((int64)(B.x - D.x))*0x10000; // avoid division by 0 => multiply by C.x
            //  transitions += 0 < vd && vd <= Abs(C.x);
                if (C.x >= 0) {
                    if (0 < vd && vd <= ((int64)C.x)*0x10000) transitions++;
                } else {
                    if (((int64)C.x)*0x10000 <= vd && vd < 0) transitions++;
                }
            } else {
                vd = ((int64)A.y)*u  + ((int64)(B.y - D.y))*0x10000; // avoid division by 0 => multiply by C.y
            //  transitions += 0 < vd && vd <= Abs(C.y);
                if (C.y >= 0) {
                    if (0 < vd && vd <= ((int64)C.y)*0x10000) transitions++;
                } else {
                    if (((int64)C.y)*0x10000 <= vd && vd < 0) transitions++;
                }
            }
        }
    }

    return transitions;
} // CurveTransitionsSegment

long CurveTransitions(Vector V0, Vector V1, Vector W0, Vector W1, Vector W2) {

//  here we're intersecting a quadratic Bzier curve (W0, W1, W2) with a straight line (V0, V1).
//  for the two to intersect, and writing both intersectees in standard polynomial form, there must be parameters u and v such that
//
//      A.x*u^2 + B.x*u + C.x = D.x*v + E.x
//      A.y*u^2 + B.y*u + C.y = D.y*v + E.y
//
//  a system of two "halfway" quadratic eqns. in two unknowns u and v
//  solving the first eqn. for v (which is linear in v, hence the "halfway") yields
//
//      v = (A.x*u^2 + B.x*u + C.x - E.x)/D.x
//
//  substituting v into the second eqn. yields
//
//      A.y*u^2 + B.y*u + C.y - E.y = D.y*(A.x*u^2 + B.x*u + C.x - E.x)/D.x
//
//  rearranging terms by powers of u and multiplying by D.x yields
//
//      (A.y*D.x - D.y*A.x)*u^2 + (B.y*D.x - D.y*B.x)*u + C.y*D.x - D.y*C.x - E.y*D.x + D.y*E.x = 0
//
//  which is a single quadratic eqn. in u with 0 thru 2 solutions obtained "the usual way".
//  solutions must be in the interval ]0,1] to make sure we only accept intersections of the actual Bzier segment
//  and we don't count start/end points twice by including them in adjacent Bzier segments as well (cf. also ColorTransitions above)

    Vector A,B,C,D,E;
    long i,solutions,transitions;
    int64 u[2],vd;

//  re-write Bzier curve in polynomial form
//  W0*(1-u)^2 + 2*W1*(1-u)*u + W2*u^2 = W0*(1 - 2*u + u^2) + 2*W1*(u - u^2) + W2*u^2 = 
//  (W0 - 2*W1 + W2)*u^2 + 2*(W1 - W0)*u + W0
    A = AddV(SubV(W0,ShlV(W1,1)),W2);
    B = ShlV(SubV(W1,W0),1);
    C = W0;

//  re-write Line in polynomial form
//  (V1 - V0)*v + V0, which follows immediately from the "first degree" Bzier "curve" V0*(1-u) + V1*u
    D = SubV(V1,V0);
    E = V0;

    FQuadraticEqn(A.y*D.x - D.y*A.x,B.y*D.x - D.y*B.x,C.y*D.x - D.y*C.x - E.y*D.x + D.y*E.x,&solutions,&u[0],&u[1]);
    
    transitions = 0;
    for (i = 0; i < solutions; i++) {
        if (0 < u[i] && u[i] <= 0x10000) {
            /* to avoid loss of precision, select in which equation to replace the value of u[] */
            if (MABS(D.x) > MABS(D.y))
            {
                vd = ((int64)A.x)*u[i]*u[i] + ((int64)B.x)*u[i]*0x10000 + ((int64)(C.x - E.x))*0x100000000; // avoid division by 0 => multiply by D.x
            //  transitions += 0 < vd && vd <= Abs(D.x);
                if (D.x >= 0) {
                    if (0 < vd && vd <= ((int64)D.x)*0x100000000) transitions++;
                } else {
                    if (((int64)D.x)*0x100000000 <= vd && vd < 0) transitions++;
                }
            } else {
                vd = ((int64)A.y)*u[i]*u[i] + ((int64)B.y)*u[i]*0x10000 + ((int64)(C.y - E.y))*0x100000000; // avoid division by 0 => multiply by D.y
            //  transitions += 0 < vd && vd <= Abs(D.y);
                if (D.y >= 0) {
                    if (0 < vd && vd <= ((int64)D.y)*0x100000000) transitions++;
                } else {
                    if (((int64)D.y)*0x100000000 <= vd && vd < 0) transitions++;
                }
            }
        }
    }


    return transitions;
} // CurveTransitions

boolean CheckBoundingBoxCurve(Vector C0,Vector W0,Vector W1,Vector W2,int16 extremumNumber)
{
    Vector Min, Max;

    /* the curve is completely conatined in the triangle W0,W1,W2 */
    MinMax3Vectors (W0, W1, W2, &Min, &Max);

    switch (extremumNumber)
    {
    case 0:
        /* look for Min X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Min.x <= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
    case 1:
        /* look for Max X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Max.x >= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
    case 2:
        /* look for Min Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Min.y <= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
    case 3:
        /* look for Max Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Max.y >= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
    default:  
        /* we should never get in that case */
        FS_ASSERT(FALSE,"fsglue.c, CheckBoundingBoxCurve, illegal case");
        return TRUE;
    }

}

boolean CheckBoundingBoxSegment(Vector C0,Vector W0,Vector W1, int16 extremumNumber)
{
    Vector Min, Max;

    MinMax2Vectors (W0, W1, &Min, &Max);

    switch (extremumNumber)
    {
    case 0:
        /* look for Min X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Min.x <= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
    case 1:
        /* look for Max X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Max.x >= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
    case 2:
        /* look for Min Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Min.y <= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
    case 3:
        /* look for Max Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Max.y >= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
    default:  
        /* we should never get in that case */
        FS_ASSERT(FALSE,"fsglue.c, CheckBoundingBoxSegment, illegal case");
        return TRUE;
    }

}

void CalculateXExtremum(boolean min, long V0X, long V0Y, boole